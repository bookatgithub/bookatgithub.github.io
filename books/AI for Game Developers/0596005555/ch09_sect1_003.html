<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>9.3 Ant Example</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch09_sect1_002.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch09_sect1_004.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch09_sect1_003"></A>
<H3 class="docSection1Title">9.3 Ant Example</H3>
<P class="docText">The objective in this example of our finite state machine is to create a finite state machine simulation consisting of two teams of AI ants. The purpose of the simulation is for the ants to collect food and return it to their home position. The ants will have to follow certain obstacles and rules in the simulation. First, the ants will move randomly in their environment in an attempt to locate a piece of food. Once an ant finds a piece of food, it will return to its home position. When it arrives home, it will drop its food and then start a new search for water rather than food. The thirsty ants will roam randomly in search of water. Once an ant finds water, it will resume its search for more food.</P>
<P class="docText">Returning food to the home position also will result in a new ant emerging from the home position. The ant population will continue to grow so long as more food is returned to the home position. Of course, the ants will encounter obstacles along the way. In addition to the randomly placed food will be randomly placed poison. Naturally, the poison has a fatal effect on the ants.</P>
<P class="docText"><A class="docLink" HREF="#ch09_fig03">Figure 9-3</A> presents a finite state diagram that illustrates the behavior of each ant in the simulation.</P>
<A NAME="ch09_fig03"></A><p><CENTER>
<H5 class="docFigureTitle">Figure 9-3. Ant finite state machine diagram</H5>
<IMG BORDER="0" SRC="images/0596005555/figs/ch09_fig03.jpg" ALT="figs/ch09_fig03.jpg">
</CENTER></p><br>
<P class="docText">As <A class="docLink" HREF="#ch09_fig03">Figure 9-3</A> shows, each ant begins in the initial forage state. From that point, the state can change in only two ways. The state can change to go home with the found food transition function, or it can encounter the found poison transition, which kills the ant. Once food is found, the state changes to go home. Once again, there are only two ways out of this state. One is to meet the objective and find the home position. This is illustrated by the found home transition arrow. The other possible transition is to find poison. Once the home position is found, the state changes to thirsty. Like the previous states, there are two ways to change states. One is to meet the goal by finding water, and the other is to find poison. If the goal is met, the ant returns to the initial forage state.</P>
<P class="docText">As you can see, the ants will be in one of several different states as they attempt to perform their tasks. Each state represents a different desired behavior. So, we will now use the previously described rules for our simulation to define the possible states for the AI ants. This is demonstrated in <A class="docLink" HREF="#ch09exm06">Example 9-6</A>.</P>
<A NAME="ch09exm06"></A>
<H5 class="docExampleTitle">Example 9-6. Ant states</H5>
<PRE>
   #define   kForage               1
   #define   kGoHome               2
   #define   kThirsty              3
   #define   kDead                 4
</PRE><BR>


<P class="docText">The first rule for the simulation is that the ants forage randomly for food. This is defined by the <span class="docEmphasis">kForage</span> state. Any ant in the <span class="docEmphasis">kForage</span> state moves randomly about its environment in search of food. Once an ant finds a piece of food, it changes to the <span class="docEmphasis">kGoHome</span> state. In this state, the ant returns to its home position. It no longer forages when in the <span class="docEmphasis">kGoHome</span> state. It ignores any food it finds while returning home. If the ant successfully returns to its home position without encountering any poison, it changes to the <span class="docEmphasis">kThirsty</span> state. This state is similar to the forage state, but instead of searching for food the ant searches for water. Once it finds water, the ant changes from the <span class="docEmphasis">kThirsty</span> state back to the <span class="docEmphasis">kForage</span> state. At that point the behavior repeats.</P>
<A NAME="ch09_sect2_003"></A>
<H4 class="docSection2Title">9.2.3 Finite State Machine Classes and Structures</H4>
<P class="docText">Now that we have described and illustrated the basic goal of the finite state machine in our ant simulation, let's move on to the data structure that we will use. As shown in <A class="docLink" HREF="#ch09exm07">Example 9-7</A>, we'll use a C++ class to store all the data related to each finite state machine ant.</P>
<A NAME="ch09exm07"></A>
<H5 class="docExampleTitle">Example 9-7. ai_Entity class</H5>
<PRE>
#define   kMaxEntities        200
class	    ai_Entity
{
   public:
   int                type;
   int                state;
   int                row;
   int                col;
	
   ai_Entity();
   ~ai_Entity();
	
};
ai_Entity     entityList[kMaxEntities];
</PRE><BR>


<P class="docText">As <A class="docLink" HREF="#ch09exm07">Example 9-7</A> shows, we start with a C++ class containing four variables. The first variable is <span class="docEmphasis">type</span>, which is the type of AI entity the structure represents.</P>
<P class="docText">If you remember from the previous description, the ant simulation consists of two teams of ants. We will differentiate between them by using the constants in <A class="docLink" HREF="#ch09exm08">Example 9-8</A>.</P>
<A NAME="ch09exm08"></A>
<H5 class="docExampleTitle">Example 9-8. Team constants</H5>
<PRE>
#define   kRedAnt        1
#define   kBlackAnt      2
</PRE><BR>


<P class="docText">The second variable in <span class="docEmphasis">ai_Entity</span> is <span class="docEmphasis">state</span>. This variable stores the current state of the ant. This can be any of the values defined in <A class="docLink" HREF="#ch09exm06">Example 9-6</A>; namely, <span class="docEmphasis">kForage</span>, <span class="docEmphasis">kGoHome</span>, <span class="docEmphasis">kThirsty</span>, and <span class="docEmphasis">kDead</span>.</P>
<P class="docText">The final two variables are <span class="docEmphasis">row</span> and <span class="docEmphasis">col</span>. The ant simulation takes place in a tiled environment. The <span class="docEmphasis">row</span> and <span class="docEmphasis">col</span> variables contain the positions of the ants within the tiled world.</P>
<P class="docText">As <A class="docLink" HREF="#ch09exm07">Example 9-7</A> goes on to show, we create an array to store each ant's data. Each element in the array represents a different ant. The maximum number of ants in the simulation is limited by the constant, which also is defined in <A class="docLink" HREF="#ch09exm07">Example 9-7</A>.</P>

<A NAME="ch09_sect2_004"></A>
<H4 class="docSection2Title">9.2.4 Defining the Simulation World</H4>
<P class="docText">As we stated previously, the simulation takes place in a tiled environment. The world is represented by a two-dimensional array of integers. <A class="docLink" HREF="#ch09exm09">Example 9-9</A> shows the constant and array declarations.</P>
<A NAME="ch09exm09"></A>
<H5 class="docExampleTitle">Example 9-9. Terrain array</H5>
<PRE>
   #define   kMaxRows      32
   #define   kMaxCols      42
   int   terrain[kMaxRows][kMaxCols];
</PRE><BR>


<P class="docText">Each element in the terrain array stores the value of a tile in the environment. The size of the world is defined by the <span class="docEmphasis">kMaxRows</span> and <span class="docEmphasis">kMaxCols</span> constants. A real tile-based game most likely would contain a large number of possible values for each tile. In this simulation, however, we are using only six possible values. <A class="docLink" HREF="#ch09exm010">Example 9-10</A> shows the constants.</P>
<A NAME="ch09exm010"></A>
<H5 class="docExampleTitle">Example 9-10. Terrain values</H5>
<PRE>
   #define   kGround          1
   #define   kWater           2
   #define   kBlackHome       3
   #define   kRedHome         4
   #define   kPoison          5
   #define   kFood            6
</PRE><BR>


<P class="docText">The default value in the tile environment is <span class="docEmphasis">kGround</span>. You can think of this as nothing more than an empty location. The next constant, <span class="docEmphasis">kWater</span>, is the element the ants search for when in the <span class="docEmphasis">kThirsty</span> state. The next two constants are <span class="docEmphasis">kBlackhome</span> and <span class="docEmphasis">kRedHome</span>. These are the home locations the ants seek out when in the <span class="docEmphasis">kGoHome</span> state. Stepping on a tile containing the <span class="docEmphasis">kPoison</span> element kills the ants, changing their states to <span class="docEmphasis">kDead</span>. The final constant is <span class="docEmphasis">kFood</span>. When an ant in the <span class="docEmphasis">kForage</span> state steps on a terrain element containing the <span class="docEmphasis">kFood</span> element, it changes states from <span class="docEmphasis">kForage</span> to <span class="docEmphasis">kGoHome</span>.</P>
<P class="docText">Once the variables and constants are declared, we can proceed to initialize the world using the code shown in <A class="docLink" HREF="#ch09exm11">Example 9-11</A>.</P>
<A NAME="ch09exm11"></A>
<H5 class="docExampleTitle">Example 9-11. Initializing the world</H5>
<PRE>
   #define   kRedHomeRow         5
   #define   kRedHomeCol         5
	
   #define   kBlackHomeRow       5
   #define   kBlackHomeCol      36
   for (i=0;i&lt;kMaxRows;i++)
      for (j=0;j&lt;kMaxCols;j++)
         {
            terrain[i][j]=kGround;
         }
   terrain[kRedHomeRow][kRedHomeCol]=kRedHome;
   terrain[kBlackHomeRow][kBlackHomeCol]=kBlackHome;
	
   for (i=0;i&lt;kMaxWater;i++)
      terrain[Rnd(2,kMaxRows)-3][Rnd(1,kMaxCols)-1]=kWater;
   for (i=0;i&lt;kMaxPoison;i++)
      terrain[Rnd(2,kMaxRows)-3][Rnd(1,kMaxCols)-1]=kPoison;
   for (i=0;i&lt;kMaxFood;i++)
      terrain[Rnd(2,kMaxRows)-3][Rnd(1,kMaxCols)-1]=kFood;
</PRE><BR>


<P class="docText"><A class="docLink" HREF="#ch09exm11">Example 9-11</A> starts by initializing the entire two-dimensional world array to the value in <span class="docEmphasis">kGround</span>. Remember, this is the default value. We then initialize the two home locations. The actual positions are defined in the constants <span class="docEmphasis">kRedHomeRow</span>, <span class="docEmphasis">kRedHomeCol</span>, <span class="docEmphasis">kBlackHomeRow</span>, and <span class="docEmphasis">kBlackHomeCol</span>. These are the positions the ants move toward when in the <span class="docEmphasis">kGoHome</span> state. Each ant moves to its respective color.</P>
<P class="docText">The final section of <A class="docLink" HREF="#ch09exm11">Example 9-11</A> shows three <span class="docEmphasis">for</span> loops that randomly place the <span class="docEmphasis">kWater</span>, <span class="docEmphasis">kPoison</span>, and <span class="docEmphasis">kFood</span> tiles. The number of each type of tile is defined by its respective constant. Of course, altering these values changes the behavior of the simulation.</P>
<P class="docText"><A class="docLink" HREF="#ch09_fig04">Figure 9-4</A> shows the result of initializing the tiled world. We haven't populated the world yet with any finite state machine ants, but we do have the randomly placed food, water, and poison.</P>
<A NAME="ch09_fig04"></A><p><CENTER>
<H5 class="docFigureTitle">Figure 9-4. Ant world</H5>
<IMG BORDER="0" SRC="images/0596005555/figs/ch09_fig04.jpg" ALT="figs/ch09_fig04.jpg">
</CENTER></p><br>
<P class="docText">Now that we've initialized the variables associated with the tile, the next step is to begin populating the world with AI ants.</P>

<A NAME="ch09_sect2_005"></A>
<H4 class="docSection2Title">9.2.5 Populating the World</H4>
<P class="docText">The first thing we need is some means of creating a new AI entity. To accomplish this, we are going to add a new function to the <span class="docEmphasis">ai_Entity</span> class. <A class="docLink" HREF="#ch09exm12">Example 9-12</A> shows the addition to the <span class="docEmphasis">ai_Entity</span> class.</P>
<A NAME="ch09exm12"></A>
<H5 class="docExampleTitle">Example 9-12. ai_Entity class</H5>
<PRE>
class	     ai_Entity
{
   public:
   int                type;
   int                state;
   int                row;
   int                col;
	
   ai_Entity();
   ~ai_Entity();
	
   void  New (int theType, int theState, int theRow, int theCol);
};
</PRE><BR>


<P class="docText">The <span class="docEmphasis">New</span> function is called whenever it is necessary to add a new ant to the world. At the beginning of the simulation we add only two of each color ant to the world. However, we call this function again whenever an ant successfully returns food to the home position. <A class="docLink" HREF="#ch09exm13">Example 9-13</A> shows how the actual function is defined.</P>
<A NAME="ch09exm13"></A>
<H5 class="docExampleTitle">Example 9-13. New ai_Entity</H5>
<PRE>
void ai_Entity::New(int  theType, int theState, int theRow, int theCol)
{
   int   i;
	
   type=theType;
   row=theRow;
   col=theCol;
   state=theState;
}
</PRE><BR>


<P class="docText">The <span class="docEmphasis">New</span> function is rather simple. It initializes the four values in <span class="docEmphasis">ai_Entity</span>. These include the entity type, state, row, and column. Now let's look at <A class="docLink" HREF="#ch09exm14">Example 9-14</A> to see how the <span class="docEmphasis">New</span> function adds ants to the finite state machine simulation.</P>
<A NAME="ch09exm14"></A>
<H5 class="docExampleTitle">Example 9-14. Adding ants</H5>
<PRE>
   entityList[0].New(kRedAnt,kForage,5,5);
   entityList[1].New(kRedAnt,kForage,8,5);
	
   entityList[2].New(kBlackAnt,kForage,5,36);
   entityList[3].New(kBlackAnt,kForage,8,36);	
</PRE><BR>


<P class="docText">As <A class="docLink" HREF="#ch09exm14">Example 9-14</A> shows, the simulation begins by adding four ants to the world. The first parameter passed to the <span class="docEmphasis">New</span> function specifies the entity type. In this simulation, we start with two red ants and two black ants. The second parameter is the initial state of the finite state machine ants. The final two parameters are the row and column positions of the starting point of each ant.</P>
<P class="docText">As <A class="docLink" HREF="#ch09_fig05">Figure 9-5</A> shows, we added four ants to the simulation using the <span class="docEmphasis">New</span> function.</P>
<A NAME="ch09_fig05"></A><p><CENTER>
<H5 class="docFigureTitle">Figure 9-5. Populating the world</H5>
<IMG BORDER="0" SRC="images/0596005555/figs/ch09_fig05.jpg" ALT="figs/ch09_fig05.jpg">
</CENTER></p><br>
<P class="docText">Each ant shown in <A class="docLink" HREF="#ch09_fig05">Figure 9-5</A> begins with its initial state set to <span class="docEmphasis">kForage</span>. From their initial starting positions they will begin randomly moving about the tiled environment in search of food. In this case, the food is shown as apples. However, if they step on poison, shown as a skull and crossbones, they switch to the <span class="docEmphasis">kDead</span> state. The squares containing the water pattern are the elements they search for when they are in the <span class="docEmphasis">kThirsty</span> state.</P>

<A NAME="ch09_sect2_006"></A>
<H4 class="docSection2Title">9.2.6 Updating the World</H4>
<P class="docText">In the previous section we successfully populated the world with four finite state machine ants. Now we will show you how to run the simulation. This is a critical part of the finite state machine implementation. If you recall, the basic premise of the finite state machine is to link individual and unique states to different types of behavior. This is the part of the code where we actually make each ant behave a certain way depending on its state. This part of the code lends itself to the use of a <span class="docEmphasis">switch</span> statement, which checks for each possible state. In a real game, this <span class="docEmphasis">switch</span> statement typically would be called once each time through the main loop. <A class="docLink" HREF="#ch09exm15">Example 9-15</A> shows how to use the <span class="docEmphasis">switch</span> statement.</P>
<A NAME="ch09exm15"></A>
<H5 class="docExampleTitle">Example 9-15. Running the simulation</H5>
<PRE>
   for (i=0;i&lt;kMaxEntities;i++)
      {
         switch (entityList[i].state)
            {
               case kForage:
                  entityList[i].Forage();
                  break;
               case kGoHome:
                  entityList[i].GoHome();
                  break;
               case kThirsty:
                  entityList[i].Thirsty();
                  break;
               case kDead:
                  entityList[i].Dead();
                  break;
            }
      }
</PRE><BR>


<P class="docText">As <A class="docLink" HREF="#ch09exm15">Example 9-15</A> shows, we create a loop that iterates through each element in the <span class="docEmphasis">entityList</span> array. Each <span class="docEmphasis">entityList</span> element contains a different finite state machine ant. We use a <span class="docEmphasis">switch</span> statement to check the state of each ant in <span class="docEmphasis">entityList</span>. Notice that we have a <span class="docEmphasis">case</span> statement for each possible state. We then link each state to the desired behavior by calling the appropriate function for each behavior. As you can see in <A class="docLink" HREF="#ch09exm16">Example 9-16</A>, we need to add four new functions to the <span class="docEmphasis">ai_Entity</span> class.</P>
<A NAME="ch09exm16"></A>
<H5 class="docExampleTitle">Example 9-16. ai_Entity class functions</H5>
<PRE>
class	   ai_Entity
{
   public:
   int                type;
   int                state;
   int                row;
   int                col;
	
   ai_Entity();
   ~ai_Entity();
	
   void  New (int theType, int theState, int theRow, int theCol);
   void Forage(void);
   void GoHome(void);
   void Thirsty(void);
   void Dead(void);
};
</PRE><BR>


<P class="docText"><A class="docLink" HREF="#ch09exm16">Example 9-16</A> shows the updated <span class="docEmphasis">ai_Entity</span> class with the four new behavior functions. Each function is associated with one of the state behaviors.</P>
<A NAME="ch09_sect3_001"></A>
<H5 class="docSection3Title">9.2.1 Forage</H5>
<P class="docText">The first new function, <span class="docEmphasis">Forage</span>, is associated with the <span class="docEmphasis">kForage</span> state. If you recall, in this state the ants randomly move about the world in search of food. Once in the forage state, the ants can switch to a different state in only two ways. The first way is to meet the objective by randomly finding a piece of food. In this case, the state switches to <span class="docEmphasis">kGoHome</span>. The other way for the ants to switch states is by stepping on poison. In this case, the state switches to <span class="docEmphasis">kDead</span>. This behavior is implemented in the <span class="docEmphasis">Forage</span> function, as shown in <A class="docLink" HREF="#ch09exm17">Example 9-17</A>.</P>
<A NAME="ch09exm17"></A>
<H5 class="docExampleTitle">Example 9-17. Forage function</H5>
<PRE>
void ai_Entity::Forage(void)
{
   int rowMove;
   int colMove;
   int newRow;
   int newCol;
   int foodRow;
   int foodCol;
   int poisonRow;
   int poisonCol;
   rowMove=Rnd(0,2)-1;
   colMove=Rnd(0,2)-1;
   newRow=row+rowMove;
   newCol=col+colMove;
   if (newRow&lt;1) return;
   if (newCol&lt;1) return;
   if (newRow&gt;=kMaxRows-1) return;
   if (newCol&gt;=kMaxCols-1) return;
   if ((terrain[newRow][newCol]==kGround) ||
       (terrain[newRow][newCol]==kWater))
      {
         row=newRow;
         col=newCol;
      }
   if (terrain[newRow][newCol]==kFood)
      {
         row=newRow;
         col=newCol;
         terrain[row][col]=kGround;
         state=kGoHome;
         do {
            foodRow=Rnd(2,kMaxRows)-3;
            foodCol=Rnd(2,kMaxCols)-3;
         } while (terrain[foodRow][foodCol]!=kGround);
         terrain[foodRow][foodCol]=kFood;
      }
   if (terrain[newRow][newCol]==kPoison)
      {
         row=newRow;
         col=newCol;
         terrain[row][col]=kGround;
         state=kDead;
         do {
            poisonRow=Rnd(2,kMaxRows)-3;
            poisonCol=Rnd(2,kMaxCols)-3;
         } while (terrain[poisonRow][poisonCol]!=kGround);
         terrain[poisonRow][poisonCol]=kPoison;
      }
}
</PRE><BR>


<P class="docText">contain the distances to move in both the row and column directions. The next two variables are <span class="docEmphasis">newRow</span> and <span class="docEmphasis">newCol</span>. These two variables contain the new row and column positions of the ant. The final four variables, <span class="docEmphasis">foodRow</span>, <span class="docEmphasis">foodCol</span>, <span class="docEmphasis">poisonRow</span>, and <span class="docEmphasis">poisonCol</span>, are the new positions used to replace any food or poison that might get consumed.</P>
<P class="docText">We then proceed to calculate the new position. We begin by assigning a random number between <span class="docEmphasis">-1</span> and <span class="docEmphasis">+1</span> to the <span class="docEmphasis">rowMove</span> and <span class="docEmphasis">colMove</span> variables. This ensures that the ant can move in any of the eight possible directions in the tiled environment. It's also possible that both values will be <span class="docEmphasis">0</span>, in which case the ant will remain in its current position.</P>
<P class="docText">Once we have assigned <span class="docEmphasis">rowMove</span> and <span class="docEmphasis">colMove</span>, we proceed to add their values to the current row and column positions and store the result in <span class="docEmphasis">newRow</span> and <span class="docEmphasis">newCol</span>. This will be the new ant position, assuming, of course, it's a legal position in the tiled environment. In fact, the next block of <span class="docEmphasis">if</span> statements checks to see if the new position is within the legal bounds of the tiled environment. If it's not a legal position, we exit the function.</P>
<P class="docText">Now that we know the position is legal, we go on to determine what the ant will be standing on in its new position. The first <span class="docEmphasis">if</span> statement simply checks for <span class="docEmphasis">kGround</span> or <span class="docEmphasis">kWater</span> at the new position. Neither of these two elements will cause a change in state, so we simply update the ant <span class="docEmphasis">row</span> and <span class="docEmphasis">col</span> with the values in <span class="docEmphasis">newRow</span> and <span class="docEmphasis">newCol</span>. The ant is shown in its new position after the next screen update.</P>
<P class="docText">The next section shows a critical part of the finite state machine design. This <span class="docEmphasis">if</span> statement checks to see if the new position contains food. This section is critical because it contains a possible state transition. If the new position does contain food, we update the ant's position, erase the food, and change the state of the ant. In this case, we are changing from <span class="docEmphasis">kForage</span> to <span class="docEmphasis">kGoHome</span>. The final <span class="docEmphasis">do-while</span> loop in this <span class="docEmphasis">if</span> statement replaces the consumed food with another randomly placed piece of food. If we don't continuously replace the consumed food, the ant population won't be able to grow.</P>
<P class="docText">The final part of the <span class="docEmphasis">Forage</span> function shows another possible state transition. The last <span class="docEmphasis">if</span> statement checks to see if the new position contains poison. If it does contain poison, the ant's position is updated, the poison is deleted, and the ant's state is changed from <span class="docEmphasis">kForage</span> to <span class="docEmphasis">kDead</span>. We then use the <span class="docEmphasis">do-while</span> loop to replenish the consumed poison.</P>

<A NAME="ch09_sect3_002"></A>
<H5 class="docSection3Title">9.2.2 GoHome</H5>
<P class="docText">We are now going to move on to the second new behavior function that we added to the <span class="docEmphasis">ai_Entity</span> class in <A class="docLink" HREF="#ch09exm16">Example 9-16</A>. This one is called <span class="docEmphasis">GoHome</span> and it's associated with the <span class="docEmphasis">kGoHome</span> state. As we stated previously, the ants switch to the <span class="docEmphasis">kGoHome</span> state once they randomly find a piece of food. They remain in this state until they either successfully return to their home position or step on poison. <A class="docLink" HREF="#ch09exm18">Example 9-18</A> shows the <span class="docEmphasis">GoHome</span> function.</P>
<A NAME="ch09exm18"></A>
<H5 class="docExampleTitle">Example 9-18. GoHome function</H5>
<PRE>
void ai_Entity::GoHome(void)
{
   int   rowMove;
   int   colMove;
   int   newRow;
   int   newCol;
   int   homeRow;
   int   homeCol;
   int   index;
   int   poisonRow;
   int   poisonCol;
   if (type==kRedAnt)
      {
         homeRow=kRedHomeRow;
         homeCol=kRedHomeCol;
      }
   else
      {
         homeRow=kBlackHomeRow;
         homeCol=kBlackHomeCol;
      }
   if (row&lt;homeRow)
      rowMove=1;
   else if (row&gt;homeRow)
      rowMove=-1;
   else
      rowMove=0;
   if (col&lt;homeCol)
      colMove=1;
   else if (col&gt;homeCol)
      colMove=-1;
   else
      colMove=0;
   newRow=row+rowMove;
   newCol=col+colMove;
   if (newRow&lt;1) return;
   if (newCol&lt;1) return;
   if (newRow&gt;=kMaxRows-1) return;
   if (newCol&gt;=kMaxCols-1) return;
   if (terrain[newRow][newCol]!=kPoison)
      {
         row=newRow;
         col=newCol;
      }
   else
      {
         row=newRow;
         col=newCol;
         terrain[row][col]=kGround;
         state=kDead;
         do {
            poisonRow=Rnd(2,kMaxRows)-3;
            poisonCol=Rnd(2,kMaxCols)-3;
         } while (terrain[poisonRow][poisonCol]!=kGround);
         terrain[poisonRow][poisonCol]=kPoison;
      }
   if ((newRow==homeRow) &amp;&amp; (newCol==homeCol))
      {
         row=newRow;
         col=newCol;
         state=kThirsty;
         for (index=0; index &lt;kMaxEntities; index ++)
            if (entityList[index].type==0)
               {
                  entityList[index].New(type,
                                        kForage,
                                        homeRow,
                                        homeCol);
                  break;
               }
      }
}
</PRE><BR>


<P class="docText">The variable declarations in the <span class="docEmphasis">GoHome</span> function are very similar to those in the <span class="docEmphasis">Forage</span> function. In this function, however, we added two new variables, <span class="docEmphasis">homeRow</span> and <span class="docEmphasis">homeCol</span>. We will use these two variables to determine if the ant has successfully reached its home position. The variable <span class="docEmphasis">index</span> is used when adding a new ant to the world. The remaining two variables, <span class="docEmphasis">poisonRow</span> and <span class="docEmphasis">poisonCol</span>, are used to replace any poison that might be consumed.</P>
<P class="docText">We start by determining where the home position is located. If you recall, there are two types of ants, red ants and black ants. Each color has a different home position. The positions of each home are set in the globally defined constants <span class="docEmphasis">kRedHomeRow</span>, <span class="docEmphasis">kRedHomeCol</span>, <span class="docEmphasis">kBlackHomeRow</span>, and <span class="docEmphasis">kBlackHomeCol</span>. We check the entity type to determine if it's a red ant or a black ant. We then use the global home position constants to set the local <span class="docEmphasis">homeRow</span> and <span class="docEmphasis">homeCol</span> variables. Now that we know where the home is located, we can move the ant toward that position.</P>
<P class="docText">As you might recall, this is a variation of the simple chasing algorithm from <A class="docLink" HREF="ch02.html#ch02">Chapter 2</A>. If the ant's current row is less than the home row, the row offset, <span class="docEmphasis">rowMove</span>, is set to <span class="docEmphasis">1</span>. If the ant's row is greater than the home row, <span class="docEmphasis">rowMove</span> is set to <span class="docEmphasis">-1</span>. If they are equal, there is no need to change the ant's row, so <span class="docEmphasis">rowMove</span> is set to <span class="docEmphasis">0</span>. The column positions are handled the same way. If the ant's column is less than the home column, <span class="docEmphasis">colMove</span> is set to <span class="docEmphasis">1</span>. If it's greater, it's set to <span class="docEmphasis">-1</span>. If <span class="docEmphasis">col</span> is equal to <span class="docEmphasis">homeCol</span>, <span class="docEmphasis">colMove</span> is set to <span class="docEmphasis">0</span>.</P>
<P class="docText">Once we have the row and column offsets, we can proceed to calculate the new row and column positions. We determine the new row position by adding <span class="docEmphasis">rowMove</span> to the current row position. We determine the new column position by adding <span class="docEmphasis">colMove</span> to the current column position.</P>
<P class="docText">Once we assign the values to <span class="docEmphasis">newRow</span> and <span class="docEmphasis">newCol</span>, we check to see if the new position is within the bounds of the tiled environment. It's good practice to always do this, but in this case, it's really not necessary. This function always moves the ants toward their home position, which always should be within the confines of the tiled world. So, the ants always will be confined to the limits of the world unless the global home position constants are changed to something outside the limits of the world.</P>
<P class="docText">The first part of the <span class="docEmphasis">if</span> statement checks to see if the ant did not step on poison. If the new position does not contain poison, the ant's position is updated. If the <span class="docEmphasis">else</span> portion of the <span class="docEmphasis">if</span> statement gets executed, we know the ant has, in fact, stepped on poison. In this case, a state change is required—the ant's position is updated, the poison is deleted, and the ant's state is changed from <span class="docEmphasis">kGoHome</span> to <span class="docEmphasis">kDead</span>. We then use the <span class="docEmphasis">do-while</span> loop to replace the consumed poison.</P>
<P class="docText">The final <span class="docEmphasis">if</span> statement in the <span class="docEmphasis">GoHome</span> function checks to see if the goal was achieved. It uses the values we assigned to <span class="docEmphasis">homeRow</span> and <span class="docEmphasis">homeCol</span> to determine if the new position is equal to the home position. If so, the ant's position is updated and the state is switched from <span class="docEmphasis">kGoHome</span> to <span class="docEmphasis">kThirsty</span>. This will make the ant assume a new behavior the next time the <span class="docEmphasis">UpdateWorld</span> function is executed. The final part of the <span class="docEmphasis">if</span> statement is used to generate a new ant. If you recall, whenever food is successfully returned to the home position, a new ant is spawned. We use a <span class="docEmphasis">for</span> loop to traverse the <span class="docEmphasis">entityList</span> and check for the first unused element in the array. If an unused array element is found, we create a new ant at the home position and initialize it to the <span class="docEmphasis">kForage</span> state.</P>

<A NAME="ch09_sect3_003"></A>
<H5 class="docSection3Title">9.2.3 Thirsty</H5>
<P class="docText">The next behavior function we added to the <span class="docEmphasis">ai_Entity</span> class in <A class="docLink" HREF="#ch09exm16">Example 9-16</A> is associated with the <span class="docEmphasis">kThirsty</span> state. As you recall, the ants are switched to the <span class="docEmphasis">kThirsty</span> state after successfully returning food to their home positions. In this state, the ants randomly move about the world in search of water. Unlike the <span class="docEmphasis">kForage</span> state, however, the ants don't return to the home position after meeting their goal. Instead, when the ants find water, the state switches from <span class="docEmphasis">kThirsty</span> back to <span class="docEmphasis">kForage</span>. As with the previous states, stepping on poison automatically changes the state to <span class="docEmphasis">kDead</span>.</P>
<P class="docText">The third new behavior function we added to the <span class="docEmphasis">ai_Entity</span> class is called <span class="docEmphasis">Thirsty</span>, and as the name implies, it's executed when the ants are in the <span class="docEmphasis">kThirsty</span> state. As we stated previously, the ants switch to the <span class="docEmphasis">kThirsty</span> state after successfully returning food to their home positions. They remain in the <span class="docEmphasis">kThirsty</span> state until they find water or until they step on poison. If they find water, they revert to their initial <span class="docEmphasis">kForage</span> state. If they step on poison, they switch to the <span class="docEmphasis">kDead</span> state. <A class="docLink" HREF="#ch09exm19">Example 9-19</A> shows the <span class="docEmphasis">Thirsty</span> function.</P>
<A NAME="ch09exm19"></A>
<H5 class="docExampleTitle">Example 9-19. Thirsty function</H5>
<PRE>
void ai_Entity::Thirsty(void)
{
   int   rowMove;
   int   colMove;
   int   newRow;
   int   newCol;
   int   foodRow;
   int   foodCol;
   int   poisonRow;
   int   poisonCol;
   rowMove=Rnd(0,2)-1;
   colMove=Rnd(0,2)-1;
   newRow=row+rowMove;
   newCol=col+colMove;
   if (newRow&lt;1) return;
   if (newCol&lt;1) return;
   if (newRow&gt;=kMaxRows-1) return;
   if (newCol&gt;=kMaxCols-1) return;
   if ((terrain[newRow][newCol]==kGround) ||
       (terrain[newRow][newCol]==kFood))
      {
         row=newRow;
         col=newCol;
      }
   if (terrain[newRow][newCol]==kWater)
      {
         row=newRow;
         col=newCol;
         terrain[row][col]=kGround;
         state=kForage;
         do {
            foodRow=Rnd(2,kMaxRows)-3;
            foodCol=Rnd(2,kMaxCols)-3;
         } while (terrain[foodRow][foodCol]!=kGround);
         terrain[foodRow][foodCol]=kWater;
      }
   if (terrain[newRow][newCol]==kPoison)
      {
         row=newRow;
         col=newCol;
         terrain[row][col]=kGround;
         state=kDead;
         do {
            poisonRow=Rnd(2,kMaxRows)-3;
            poisonCol=Rnd(2,kMaxCols)-3;
         } while (terrain[poisonRow][poisonCol]!=kGround);
         terrain[poisonRow][poisonCol]=kPoison;
      }
}
</PRE><BR>


<P class="docText">As you can see in <A class="docLink" HREF="#ch09exm19">Example 9-19</A>, the <span class="docEmphasis">Thirsty</span> function begins much like the <span class="docEmphasis">Forage</span> function. We declare two position offset variables, <span class="docEmphasis">rowMove</span> and <span class="docEmphasis">colMove</span>, and two variables for the new ant position, <span class="docEmphasis">newRow</span> and <span class="docEmphasis">newCol</span>. The remaining variables, <span class="docEmphasis">foodRow</span>, <span class="docEmphasis">foodCol</span>, <span class="docEmphasis">poisonRow</span>, and <span class="docEmphasis">poisonCol</span>, are used when replacing consumed food and poison.</P>
<P class="docText">We then calculate a random offset for both the row and column positions. Both the <span class="docEmphasis">rowMove</span> and <span class="docEmphasis">colMove</span> variables contain a random value between <span class="docEmphasis">-1</span> and <span class="docEmphasis">+1</span>. We add these random values to the current positions to get the new position. The new position is stored in <span class="docEmphasis">newRow</span> and <span class="docEmphasis">newCol</span>. The block of <span class="docEmphasis">if</span> statements determines if the new position is within the bounds of the world. If it's not, we immediately exit the function.</P>
<P class="docText">This <span class="docEmphasis">if</span> statement checks to see if the new position is an empty tile or a tile containing food. In other words, it doesn't contain either of the two elements that would cause a change in state.</P>
<P class="docText">The next <span class="docEmphasis">if</span> statement checks to see if the new position contains water. If it does contain water, the ant's position is updated, the water is deleted, and the ant's state is changed back to the initial <span class="docEmphasis">kForage</span> state. The <span class="docEmphasis">do-while</span> loop then randomly places more water.</P>
<P class="docText">As in the previous behavior function, the final <span class="docEmphasis">if</span> statement in the <span class="docEmphasis">Thirsty</span> function checks to see if the ant stepped on poison. If so, the ant's position is updated, the poison is deleted, and the ant's state is changed to <span class="docEmphasis">kDead</span>. Once again, the <span class="docEmphasis">do-while</span> loop is used to replace the consumed poison.</P>

<A NAME="ch09_sect3_004"></A>
<H5 class="docSection3Title">9.2.4 The Results</H5>
<P class="docText">This completes all four functions associated with the <span class="docEmphasis">kForage</span>, <span class="docEmphasis">kThirsty</span>, <span class="docEmphasis">kGoHome</span>, and <span class="docEmphasis">kDead</span> states. You can observe the different behaviors and how the finite state machine ants transition from one state to another by running the simulation.</P>
<P class="docText">As you can see in <A class="docLink" HREF="#ch09_fig06">Figure 9-6</A>, even though we started with only four ants in the simulation, it doesn't take long for them to overrun the world. In fact, it's interesting to watch how quickly they begin multiplying with the given amount of food, water, and poison.</P>
<A NAME="ch09_fig06"></A><p><CENTER>
<H5 class="docFigureTitle">Figure 9-6. Population explosion</H5>
<IMG BORDER="0" SRC="images/0596005555/figs/ch09_fig06.jpg" ALT="figs/ch09_fig06.jpg">
</CENTER></p><br>
<P class="docText">It's also interesting to watch how you can affect the population growth, or decline, by simply altering the values shown in <A class="docLink" HREF="#ch09exm20">Example 9-20</A>.</P>
<A NAME="ch09exm20"></A>
<H5 class="docExampleTitle">Example 9-20. Food, water, and poison regulation</H5>
<PRE>
   #define  kMaxWater      15
   #define  kMaxPoison      8
   #define  kMaxFood       20
</PRE><BR>


<P class="docText">As <A class="docLink" HREF="#ch09exm20">Example 9-20</A> shows, altering the simulation is as simple as modifying a few global constants. For example, decreasing the poison level too much causes a rapid population explosion, while lowering the food supply slows the population growth, but doesn't necessarily cause it to decrease. By adjusting these values, along with the possibility of adding more states and, therefore, more types of behavior, you can make the simulation even more complex and interesting to watch.</P>



<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch09_sect1_002.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch09_sect1_004.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
