<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>A.3 Expressions</title>
<link rel="stylesheet" type="text/css" href="./acc.css" />
</head>

<body>
<div class="prevnext">
<a href="103.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="105.htm"><img src="images/Next1.gif" /></a>
</div>
<h3>A.3 Expressions</h3>
<p>C++ inherits a rich expression syntax from C, to which it adds operator overloading 
(&sect;A.3.1/308). Operator overloading allows program authors to define the argument and 
return types and meaning of operators, but not their precedence, valence (number of 
operands), or associativity, nor the meaning of built-in operators on operands of built-in 
types. In this section we will describe—with a few additions—the operators as they apply 
to built-in types.</p>
<p>Every operator yields a value, the type of which depends on the types of its operands. 
In general, if the operands have the same type, that is the type of the result. Otherwise, 
standard conversions are performed to bring the types to a common type (&sect;A.2.4/303).</p>
<p>An <i>lvalue </i>is a value that denotes a nontemporary object, hence it has an address. Certain 
operations are valid only for lvalues, and some operations yield lvalues. Every 
expression yields a value; some expressions also yield lvalues.</p>
<p>Only three operators guarantee the order of evaluation for their operands:</p>
<div class="details">
<code>&amp;&amp;</code> &nbsp;&nbsp;&nbsp;The right operand is evaluated only if the left operand is <code>true</code>.<br />
<code>||</code> &nbsp;&nbsp;&nbsp;The right operand is evaluated only if the left operand is <code>false</code>.<br />
<code>? :</code> &nbsp;&nbsp;&nbsp;Only one expression after the condition will be evaluated. The expression after 
the <code>?</code> is evaluated if the condition is <code>true</code>; otherwise, the expression after the <code>:</code> 
is evaluated. The result is the expression that was evaluated; it is an lvalue if 
both expressions were lvalues of the same type.
</div>
<p>For the other operators, aside from precedence rules, order of evaluation is not guaranteed. 
That is, the compiler is permitted to evaluate operands in any order. Parentheses 
can be used to override the default precedence, but explicit temporaries are required to 
control the order of evaluation completely.</p>
<p>Each operator has a specified precedence and associativity. In the following table, we 
summarize all the operators in order by precedence. When several operators are grouped 
together, they share the same precedence and associativity. Each grouping introduces a 
new level of precedence. This table expands the one first presented in Chapter 2 and 
includes all the operators:</p>

<table width="650px">
<tr>
<th><i>terminal</i></th>
<th>Identifier or literal constant; identifiers are lvalues, literals are not</th></tr>
<tr>
<td class="tdcell">C::m</td>
<td>The member <code>m</code> from class <code>C</code></td>
</tr>
<tr>
<td class="tdcell">N::m</td>
<td>The member <code>m</code> from namespace <code>N</code>.</td>
</tr>
<tr>
<td class="tdcell">::m</td>
<td>The name <code>m</code> at global scope.</td>
</tr>
</table>
<table width="650px">
<tr>
<td class="tdcell">x[y]</td>
<td>The element in object <code>x</code> indexed by <code>y</code>. Yields an lvalue.</td>
</tr>
<tr>
<td class="tdcell">x-&gt;y</td>
<td>The member <code>y</code> of the object pointed to by <code>x</code>. Yields an lvalue.</td></tr>
<tr>
<td class="tdcell">x.y</td>
<td>The member <code>y</code> of object <code>x</code>. Yields an lvalue if <code>x</code> is an lvalue.</td>
</tr>
<tr>
<td class="tdcell">f(<i>args</i>)</td>
<td>Call function <code>f</code> passing <i>args </i>as argument(s).</td></tr>
<tr>
<td class="tdcell">x++</td>
<td>Increments the lvalue <code>x</code>. Yields the original value of <code>x</code>.</td></tr>
<tr>
<td class="tdcell">x--</td>
<td>Decrements the lvalue <code>x</code>. Yields the original value of <code>x</code>.</td></tr>
</table>
<table width="650px">
<tr>
<td class="tdcell">*x</td>
<td>Dereferences the pointer <code>x</code>. Yields the object pointed to as an lvalue.</td></tr>
<tr>
<td class="tdcell">&amp;x</td>
<td>The address of the object <code>x</code>. Yields a pointer.</td></tr>
<tr>
<td class="tdcell">-x</td>
<td>Unary minus. May be applied only to expressions of numeric type.</td></tr>
<tr>
<td class="tdcell">!x</td>
<td>Logical negation. If <code>x</code> is zero, then <code>!x</code> is <code>true</code>, otherwise <code>false</code>.</td></tr>
<tr>
<td class="tdcell">~x</td>
<td>Ones complement of <code>x</code>. <code>x</code> must be an integral type.</td></tr>
<tr>
<td class="tdcell">++x</td>
<td>Increments the lvalue <code>x</code>. Yields the incremented value as an lvalue.</td>
</tr>
<tr>
<td class="tdcell">--x</td>
<td>Decrements the lvalue <code>x</code>. Yields the decremented value as an lvalue.</td>
</tr>
<tr>
<td class="tdcell">sizeof(e)</td>
<td>The number of bytes, as a <code>size_t</code>, consumed by expression <code>e</code>.</td>
</tr>
<tr>
<td class="tdcell">sizeof(T)</td>
<td>The number of bytes, as a <code>size_t</code>, consumed by objects of type <code>T</code>.</td>
</tr>
<tr>
<td class="tdcell">T(<i>args</i>)</td>
<td>Constructs a <code>T</code> object from <i>args.</i></td>
</tr>
<tr>
<td class="tdcell">new T</td>
<td>Allocates a new, default-initialized object of type <code>T</code>.</td>
</tr>
<tr>
<td class="tdcell">new T(<i>args</i>)</td>
<td>Allocates a new object of type <code>T</code> initialized by <i>args.</i></td>
</tr>
<tr>
<td class="tdcell">new T[n]</td>
<td> Allocates an array of <code>n</code> default-initialized objects of type <code>T</code>.</td>
</tr>
<tr>
<td class="tdcell">delete p</td>
<td>Frees object pointed to by <code>p</code>.</td>
</tr>
<tr>
<td class="tdcell">delete [] p</td>
<td>Frees the array of objects pointed to by <code>p</code>.</td>
</tr>
</table>

<table width="650px">
<tr>
<td class="tdcell">x * y</td>
<td>Product of <code>x</code> and <code>y</code>.</td>
</tr>
<tr>
<td class="tdcell">x / y</td>
<td>Quotient of <code>x</code> and <code>y</code>. If both operands are integers,<br />
the implementation chooses whether to round toward 0 or -&infin;.</td>
</tr>
<tr>
<td class="tdcell">x % y</td>
<td><code>x - ((x / y) * y)</code>.</td>
</tr>
</table>

<table width="650px">
<tr>
<td class="tdcell">x + y</td>
<td>Sum of <code>x</code> and <code>y</code>, if both operands are numeric.<br />
If one operand is a pointer and the other is integral,<br />
yields a pointer to a position <code>y</code> elements after <code>x</code>.</td>
</tr>
<tr>
<td class="tdcell">x - y</td>
<td>Result of subtracting <code>y</code> from <code>x</code> if operands are numeric.<br />
If <code>x</code> and <code>y</code> are pointers, yields the distance, in elements, between them.</td></tr>
</table>

<table width="650px">
<tr>
<td class="tdcell">x &gt;&gt; y</td>
<td>For integral <code>x</code> and <code>y, x</code> shifted right by <code>y</code> bits; <code>y</code> must be non-negative.<br />
If <code>x</code> is an <code>istream</code>, reads from <code>x</code> into <code>y</code> and returns lvalue <code>x</code>.</td>
</tr>
<tr>
<td class="tdcell">x &lt;&lt; y</td>
<td>For integral <code>x</code> and <code>y, x</code> shifted left by <code>y</code> bits; <code>y</code> must be non-negative.<br />
If <code>x</code> is an <code>ostream</code>, writes <code>y</code> into <code>x</code> and returns lvalue <code>x</code>.</td>
</tr>
</table>

<table width="650px">
<tr>
<td class="tdcell">x <i>relop </i>y</td>
<td>Relational operators yield a <code>bool</code> indicating the truth of the relation.<br />
The operators (<code>&lt;, &gt;, &lt;=</code>, and <code>&gt;=</code>) have their obvious meanings.<br />
If <code>x</code> and <code>y</code> are pointers, they must point to the same object or array.</td>
</tr>
</table>

<table width="650px">
<tr>
<td class="tdcell">x == y</td>
<td>Yields a <code>bool</code> indicating whether <code>x</code> equals <code>y</code>.</td>
</tr>
<tr>
<td class="tdcell">x != y</td>
<td>Yields a <code>bool</code> indicating whether <code>x</code> is not equal to <code>y</code>.</td>
</tr>
</table>

<table width="650px">
<tr>
<td class="tdcell">x &amp; y</td>
<td>Bitwise and. <code>x</code> and <code>y</code> must be integral.</td>
</tr></table>

<table width="650px">
<tr>
<td class="tdcell">x ^ y</td>
<td>Bitwise exclusive or. <code>x</code> and <code>y</code> must be integral.</td>
</tr></table>

<table width="650px">
<tr>
<td class="tdcell">x | y</td>
<td>Bitwise or. <code>x</code> and <code>y</code> must be integral.</td>
</tr></table>

<table width="650px">
<tr>
<td class="tdcell">x &amp;&amp; y</td>
<td>Yields a <code>bool</code> indicating whether both <code>x</code> and <code>y</code> are <code>true</code>.<br />
Evaluates <code>y</code> only if <code>x</code> is <code>true</code>.</td>
</tr></table>

<table width="650px">
<tr>
<td class="tdcell">x || y </td>
<td>Yields a <code>bool</code> indicating whether either <code>x</code> or <code>y</code> is <code>true</code>.<br />
Evaluates <code>y</code> only if <code>x</code> is <code>false</code>.</td>
</tr></table>

<table width="650px">
<tr>
<td class="tdcell">x = y</td>
<td>Assigns the value of <code>y</code> to <code>x</code>. Yields <code>x</code> as its (lvalue) result.</td>
</tr>
<tr>
<td class="tdcell">x <i>op= </i>y</td>
<td>Compound assignment operators. Equivalent to <code>x = x <i>op </i>y</code>,<br />
where <i>op </i>is an arithmetic, bitwise, or shift operator.</td>
</tr>
</table>

<table width="650px">
<tr>
<td class="tdcell">x ? y1 : y2 </td>
<td>Yields <code>y1</code> if <code>x</code> is <code>true</code>; <code>y2</code> otherwise.<br />
Only one of <code>y1</code> or <code>y2</code> is evaluated.<br />
<code>y1</code> and <code>y2</code> must be of the same type.<br />
If <code>y1</code> and <code>y2</code> are lvalues, the result is an lvalue.<br />
The operator is right-associative.</td>
</tr></table>

<table width="650px">
<tr>
<td class="tdcell">throw x</td>
<td>Signal an error by throwing value <code>x</code>.<br />
The type of <code>x</code> determines which handler will catch the error.</td>
</tr>
</table>

<table width="650px">
<tr>
<td class="tdcell">x , y</td>
<td>Evaluates <code>x</code>, discards the result, then evaluates <code>y</code>. Yields <code>y</code>.</td>
</tr>
</table>
<h4>A.3.1 Operators</h4>
<p>Most of the built-in operators may be overloaded. The throw, scope, dot, and conditional 
operator (the <code>? :</code> operator) may not be overloaded. All of the other operators may be. 
&sect;11.2.4/192 describes how to define an overloaded operator.</p>
<p>The postfix increment/decrement operator is distinguished from the prefix version by 
being defined as taking a dummy, unused parameter. That is, to overload the postfix 
operators, we write</p>
<div class="prebox"><pre>
class Number {
public:
    Number operator++(int)  { /* <i>function-body */ </i>}
    Number operator--(int)  { /* <i>function-body */ </i>}
};
</pre></div>
<p>The most commonly overloaded operators include the assignment and index operator, the 
shift operators used to do input-output with <code>ostream</code>s and <code>istream</code>s, and the operators 
used to implement iterators summarized in &sect;B.2.5/317.</p>
<div class="prevnext">
<a href="103.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="105.htm"><img src="images/Next1.gif" /></a>
</div>
</body>
</html>