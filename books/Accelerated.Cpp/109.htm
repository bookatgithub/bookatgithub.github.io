<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>B.3 Algorithms</title>
<link rel="stylesheet" type="text/css" href="./acc.css" />
</head>

<body>
<div class="prevnext">
<a href="108.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="errata.html"><img src="images/Next1.gif" /></a>
</div>
<h3>B.3 Algorithms</h3>
<p>The standard library includes many generic algorithms, which are written to operate on 
iterators, thereby gaining independence from the particular data structures on which they 
operate and the types stored therein. Note that associative containers have iterators that 
refer to compound types such as <code>pair&lt;const K, V&gt;</code>. Therefore, using these algorithms 
with associative containers requires careful thought.</p>
<p>Most algorithms operate on sequences delimited by pairs of iterators in which the first 
iterator denotes the first element in the sequence and the second denotes one past the last 
element. Except as noted, all algorithms are defined in the <code>&lt;algorithm&gt;</code> header.</p>
<p><code>#include &lt;algorithm&gt;</code></p>
<div class="details">
Includes declarations for generic algorithms.
</div>
<p><code>accumulate(b, e, t)</code><br />
<code>accumulate(b, e, t, f)</code></p>
<div class="details">
Defined in the <code>&lt;numeric&gt;</code> header. Creates a temporary object <i>obj </i>with the 
same type and value as <code>t</code>. For each input iterator <code>it</code> in the range <code>[b, e)</code>, 
evaluates <code><i>ob = obj</i> + *it</code> or <code><i>obj </i>= f(<i>obj, </i>*it)</code>, depending on which form of 
<code>accumulate</code> was called. The result is a copy of <i><code>obj</code>. </i>Note that because <code>+</code> 
may be overloaded, even the first form of <code>accumulate</code> may operate on 
types other than the built-in arithmetic types. For example, we can use 
<code>accumulate</code> to concatenate all the <code>string</code>s in a container.
</div>
<p><code>binary_search(b, e, t)</code></p>
<div class="details">
Returns a <code>bool</code> indicating whether the value <code>t</code> is in the (sorted) sequence 
delimited by the forward iterators <code>b</code> and <code>e</code>.
</div>
<p><code>copy(b, e, d)</code></p>
<div class="details">
Copies the values in the sequence denoted by the input iterators <code>b</code> and <code>e</code> 
into the destination indicated by output iterator <code>d</code>. The function assumes 
that enough space exists in the destination to hold the values being copied. 
Returns a value that denotes a position one past the last destination element.
</div>
<p><code>equal(b, e, b2)</code><br />
<code>equal(b, e, b2, p)</code></p>
<div class="details">
Returns a <code>bool</code> indicating whether the elements in the sequence denoted by 
the input iterators <code>b</code> and <code>e</code> are equal to the elements in a sequence of the 
same size beginning at the input iterator <code>b2</code>. Uses the predicate <code>p</code> for the 
test, or the <code>==</code> operator if <code>p</code> is not supplied.
</div>
<p><code>fill(b, e, t)</code></p>
<div class="details">
Sets the elements in the sequence denoted by the input iterators <code>b</code> and <code>e</code> to 
the value <code>t</code>. Returns <code>void</code>.
</div>
<p><code>find(b, e, t)</code><br />
<code>find_if(b, e, p)</code></p>
<div class="details">
Returns an iterator denoting the first occurrence of the value <code>t</code>, or for which 
the predicate <code>p</code> is <code>true</code> (if <code>p</code> is supplied), in the sequence denoted by 
the input iterators <code>b</code> and <code>e</code>. Returns <code>e</code> if no such element exists.
</div>
<p><code>lexicographical_compare(b, e, b2, e2)</code><br />
<code>lexicographical_compare(b, e, b2, e2, p)</code></p>
<div class="details">
Returns a <code>bool</code> indicating whether the sequence of elements in the range 
<code>[b, e)</code> is less than the sequence of elements in the range <code>[b2, e2)</code>, using 
the predicate <code>p</code> for element comparisons, or the <code>&lt;</code> operator if <code>p</code> is not supplied. 
If one of the sequences is a prefix of the other, then the shorter 
sequence is considered to be less than the other. Otherwise, the result is 
determined by comparing the first pair of respective elements at which the 
sequences differ. Iterators <code>b, e, b2,</code> and <code>e2</code> need only be input iterators.
</div>
<p><code>max(t1, t2)</code><br />
<code>min(t1, t2)</code></p>
<div class="details">
Returns the larger (for <code>max</code>) or smaller (for <code>min</code>) of <code>t1</code> and <code>t2</code>, both of 
which must be of the same type.
</div>
<p><code>max_element(b, e)</code><br />
<code>min_element(b, e)</code></p>
<div class="details">
Returns an iterator denoting the largest (smallest) element in the sequence 
denoted by the forward iterators <code>b</code> and <code>e</code>.
</div>
<p><code>partition(b, e, p)</code><br />
<code>stable_partition(b, e, p)</code></p>
<div class="details">
Partitions the sequence denoted by the bidirectional iterators <code>b</code> and <code>e</code> so that 
elements for which the predicate <code>p</code> is <code>true</code> are at the front of the container. 
Returns an iterator to the first element for which the predicate is <code>false</code>, or 
<code>e</code> if the predicate is <code>true</code> for all elements. The <code>stable_partition</code> function 
maintains the input order among the elements in each partition.
</div>
<p><code>remove(b, e, t)</code><br />
<code>remove_if(b, e, p)</code></p>
<div class="details">
Rearranges the elements in the sequence denoted by the forward iterators <code>b</code> 
and <code>e</code> so that elements whose values do not match <code>t</code>, or for which the predicate 
<code>p</code> returns <code>false</code> (if <code>p</code> is supplied), are coalesced at the beginning of the 
associated sequence. Returns an iterator one past the unremoved elements.
</div>
<p><code>remove_copy(b, e, d, t)</code><br />
<code>remove_copy_if(b, e, d, p)</code></p>
<div class="details">
Like <code>remove</code>, but it puts a copy of the elements that do not match <code>t</code>, or for 
which the predicate <code>p</code> is <code>false</code>, (if <code>p</code> is supplied), into the destination 
denoted by the output iterator <code>d</code>. Returns a value one past the last destination 
element. The destination is assumed to be large enough to hold the values 
copied. The elements in the sequence denoted by the iterators <code>b</code> and <code>e</code> 
are not moved. Thus, <code>b</code> and <code>e</code> need only be input iterators.
</div>
<p><code>replace(b, e, t1, t2)</code><br />
<code>replace_copy(b, e, d, t1, t2)</code></p>
<div class="details">
Replaces each element with value <code>t1</code> by the value <code>t2</code> in the sequence 
denoted by the forward iterators <code>b</code> and <code>e</code>. Returns <code>void</code>. The second form 
copies the elements, replacing <code>t1</code> with <code>t2</code>, into the sequence denoted by the 
output iterator <code>d</code> and returns a value one past the last destination element. 
For the copy version <code>b</code> and <code>e</code> need only be input iterators.
</div>
<p><code>reverse(b, e)</code><br />
<code>reverse_copy(b, e, d)</code></p>
<div class="details">
The first form reverses the elements in the sequence denoted by the bidirectional 
iterators <code>b</code> and <code>e</code> by swapping pairs of elements, and returns <code>void</code>. 
The second form stores the reversed sequence in the destination starting at 
the output iterator <code>d</code>, and returns a value one past the last destination element. 
As usual, the destination must have enough room to hold the values 
in the sequence.
</div>
<p><code>search(b, e, b2, e2)</code><br />
<code>search(b, e, b2, e2, p)</code></p>
<div class="details">
Returns a forward iterator positioned on the first occurrence, in the 
sequence denoted by the forward iterators <code>b</code> and <code>e</code>, of the subsequence 
denoted by the forward iterators <code>b2</code> and <code>e2</code>. Uses the predicate <code>p</code> for the 
test, or the <code>==</code> operator if <code>p</code> is not supplied.
</div>
<p><code>transform(b, e, d, f)</code><br />
<code>transform(b, e, b2, d, f)</code></p>
<div class="details">
If <code>b2</code> is not supplied, <code>f</code> must take one argument; <code>transform</code> calls the function 
<code>f</code> on the elements in the sequence denoted by the input iterators <code>b</code> and 
<code>e</code>. If <code>b2</code> is supplied, <code>f</code> must take two arguments, which are taken pairwise 
from the sequence denoted by <code>b</code> and <code>e</code> and the sequence of the same length 
beginning at the input iterator <code>b2</code>. In either case, <code>transform</code> puts the 
sequence of results from the function into the destination denoted by the 
output iterator <code>d</code>, and returns a value one past the last destination element. 
As usual, the destination is assumed to be large enough to hold the generated 
elements. Note that <code>d</code> is permitted to be equal to <code>b</code> or <code>b2</code> (if supplied), 
in which case the result replaces the given input sequence.
</div>
<p><code>sort(b, e)</code><br />
<code>sort(b, e, p)</code><br />
<code>stable_sort(b, e)</code><br />
<code>stable_sort(b, e, p)</code></p>
<div class="details">
Sorts, in place, the sequence defined by the random-access iterators <code>b</code> and <code>e</code>. 
Uses the predicate <code>p</code> for the test, or the <code>&lt;</code> operator if <code>p</code> is not supplied. The 
<code>stable_sort</code> functions maintain the input order among equal elements.
</div>
<p><code>unique(b, e)</code><br />
<code>unique(b, e, p)</code></p>
<div class="details">
Rearranges the sequence delimited by the forward iterators <code>b</code> and <code>e</code> so that 
the first instance of each subsequence of consecutive equal elements is 
moved to the beginning of the container. Returns an iterator positioned on 
the first element that should not be considered as part of the result (or <code>e</code> if all 
consecutive pairs of input elements are unequal). Uses the predicate <code>p</code> for 
the test, or <code>==</code> if <code>p</code> is not supplied.
</div>
<p><code>unique_copy(b, e, d, p)</code></p>
<div class="details">
Copies the sequence delimited by input iterators <code>b</code> and <code>e</code> into the sequence 
beginning at the position denoted by the output iterator <code>d</code>, eliminating any 
adjacent duplicates in the process. Returns <code>d</code> after incrementing it by the 
number of elements copied. As usual, assumes <code>d</code> is large enough to hold the 
elements. Uses the predicate <code>p</code> for the test, or <code>==</code> if <code>p</code> is not supplied.
</div>
<div class="prevnext">
<a href="108.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="errata.html"><img src="images/Next1.gif" /></a>
</div>
</body>
</html>