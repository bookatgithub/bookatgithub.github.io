<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>2.7 Details</title>
<link rel="stylesheet" type="text/css" href="./acc.css" />
</head>

<body>
<div class="prevnext">
<a href="13.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="15.htm"><img src="images/Next1.gif" /></a>
</div>
<h3>2.7 Details</h3>
<p>Expressions: C++ inherits a rich set of operators from C, several of which we have already 
used. In addition, as we've already seen with the input and output operators, C++ programs 
can extend the core language by defining what it means to apply built-in operators 
to objects of class type. Correctly understanding complicated expressions is a fundamental 
prerequisite to effective programming in C++. Understanding such expressions requires understanding</p>
<ul><li>
How the operands group, which is controlled by the precedence and associativity of the operators used in the expression</li>
<li>How the operands will be converted to other types, if at all</li>
<li>The order in which the operands are evaluated</li></ul>
<p>Different operators have different precedence. Most of the operators are left-associative, 
although the assignment operators and the operators taking a single argument are right-associative. 
We list the most common operators here-regardless of whether we've used 
them in this chapter. We've ordered them by precedence from highest to lowest, with a 
double line separating groupings with the same precedence.</p>
<table width="650px">
<tr>
<td class="tdcell">x.y</td>
<td>The member <code>y</code> of object <code>x</code></td>
</tr>
<tr>
<td class="tdcell">x[y]</td>
<td>The element in object <code>x</code> indexed by <code>y</code></td>
</tr>
<tr>
<td class="tdcell">x++</td>
<td>Increments <code>x</code>, returning the original value of <code>x</code></td>
</tr>
<tr>
<td class="tdcell">x--</td>
<td>Decrements <code>x</code>, returning the original value of <code>x</code></td>
</tr>
</table>

<table width="650px">
<tr>
<td class="tdcell">++x</td>
<td>Increments <code>x</code>, returning the incremented value</td>
</tr>
<tr>
<td class="tdcell">--x</td>
<td>Decrements <code>x</code>, returning the decremented value</td>
</tr>
<tr>
<td class="tdcell">!x</td>
<td>Logical negation. If <code>x</code> is <code>true</code> then <code>!x</code> is <code>false</code>.</td>
</tr>
</table>

<table width="650px">
<tr>
<td class="tdcell">x * y</td>
<td>Product of <code>x</code> and <code>y</code></td>
</tr>
<tr>
<td class="tdcell">x / y</td>
<td>Quotient of <code>x</code> and <code>y</code>. If both operands are integers, <br />
the implementation chooses whether to round toward zero or - &infin;</td>
</tr>
<tr>
<td class="tdcell">x % y</td>
<td>Remainder of <code>x</code> divided by <code>y</code>, equivalent to <code>x - ((x / y) * y)</code></td>
</tr>
</table>

<table width="650px">
<tr>
<td class="tdcell">x + y</td>
<td>Sum of <code>x</code> and <code>y</code></td>
</tr>
<tr>
<td class="tdcell">x - y</td>
<td>Result of subtracting <code>y</code> from <code>x</code></td>
</tr>
</table>

<table width="650px">
<tr>
<td class="tdcell">x &gt;&gt; y</td>
<td>For integral <code>x</code> and <code>y, x</code> shifted right by <code>y</code> bits; <code>y</code> must be non-negative.<br />
If <code>x</code> is an <code>istream</code>, reads from <code>x</code> into <code>y</code></td>
</tr>
<tr>
<td class="tdcell">x &lt;&lt; y</td>
<td>For integral <code>x</code> and <code>y, x</code> shifted left by <code>y</code> bits; <code>y</code> must be non-negative.<br />
If <code>x</code> is an <code>ostream</code>, writes <code>y</code> onto <code>x</code>.</td>
</tr>
</table>

<table width="650px">
<tr>
<td class="tdcell">x relop y</td>
<td>Relational operators yield a <code>bool</code> indicating the truth of the relation.<br />
The operators (<code>&lt;, &gt;, &lt;=</code>, and <code>&gt;=</code>) have their obvious meanings.</td>
</tr>
</table>

<table width="650px">
<tr>
<td class="tdcell">x == y</td>
<td>Yields a <code>bool</code> indicating whether <code>x</code> equals <code>y</code></td>
</tr>
<tr>
<td class="tdcell">x != y</td>
<td>Yields a <code>bool</code> indicating whether <code>x</code> is not equal to <code>y</code></td>
</tr>
</table>

<table width="650px">
<tr>
<td class="tdcell">x &amp;&amp; y</td>
<td>Yields a <code>bool</code> indicating whether both <code>x</code> and <code>y</code> are <code>true</code>.<br />
Evaluates <code>y</code> only if <code>x</code> is <code>true</code>.</td>
</tr>
</table>

<table width="650px">
<tr>
<td class="tdcell">x || y</td>
<td>Yields a <code>bool</code> indicating whether either <code>x</code> or <code>y</code> is <code>true</code>.<br />
Evaluates <code>y</code> only if <code>x</code> is <code>false</code>.</td>
</tr>
</table>

<table width="650px">
<tr>
<td class="tdcell">x = y</td>
<td>Assign the value of <code>y</code> to <code>x</code>, yielding <code>x</code> as its result.</td>
</tr>
<tr>
<td class="tdcell">x op= y</td>
<td>Compound assignment operators; equivalent to <code>x = x <i>op</i> y</code>,<br />
where <i>op</i> is an arithmetic or shift operator.</td>
</tr>
</table>

<table width="650px">
<tr>
<td class="tdcell">x ? y1 : y2</td>
<td>Yields <code>y1</code> if <code>x</code> is <code>true</code>; <code>y2</code> otherwise.<br />
Evaluates only one of <code>y1</code> and <code>y2</code>.</td>
</tr>
</table>

<p>There is usually no guarantee as to the order in which an expression's operands are evaluated. 
Because the order of evaluation is not fixed, it is important to avoid writing a single 
expression in which one operand depends on the value of another operand. We'll see an 
example in &sect;4.1.5/60.</p>
<p>Operands will be converted to the appropriate type when possible. Numeric operands 
in expressions or relational expressions are converted by the <b><i>usual arithmetic conversions</i></b> 
described in detail in &sect;A.2.4.4/304. Basically, the usual arithmetic conversions attempt to 
preserve precision. Smaller types are converted to larger types, and signed types are converted 
to unsigned. Arithmetic values may be converted to <code>bool</code>: A value of <code>0</code> is considered 
<code>false</code>; any other value is <code>true</code>. Operands of class type are converted as specified 
by the type. We'll see in Chapter 12 how to control such conversions.</p>
<p><b>Types:</b></p>
<p><code>bool</code></p>
<div class="details">Built-in type representing truth values; may be either <code>true</code> or <code>false</code>
</div>
<p><code>unsigned</code></p>
<div class="details">
Integral type that contains only non-negative values
</div>
<p><code>short</code></p>
<div class="details">
Integral type that must hold at least 16 bits
</div>
<p><code>long</code></p>
<div class="details">
Integral type that must hold at least 32 bits
</div>
<p><code>size_t</code></p>
<div class="details">
Unsigned integral type (from <code>&lt;cstddef&gt;</code>) that can hold any object's size
</div>
<p><code>string::size_type</code></p>
<div class="details">
Unsigned integral type that can hold the size of any <code>string</code>
</div>
<p><b>Half-open ranges</b> include one but not both of their endpoints.  For example,  <code>[1, 3)</code> 
includes <code>1</code> and <code>2</code>, but not <code>3</code>.</p>
<p><b>Condition:</b> An expression that yields a truth value. Arithmetic values used in conditions 
are converted to <code>bool</code>: Nonzero values convert to <code>true</code>; zero values convert to <code>false</code>.</p>
<p><b>Statements:</b></p>
<p><code>using <i>namespace-name::name</i>;</code></p>
<div class="details">
Defines name as a synonym for <code><i>namespace-name::name</i></code>.
</div>
<p><code><i>type-name name;</i></code></p>
<div class="details">
Defines name with type <code><i>type-name</i></code>.
</div>
<p><code><i>type-name name = value;</i></code></p>
<div class="details">
Defines name with type <code><i>type-name</i></code> initialized as a copy of value.
</div>
<p><code><i>type-name name(args)</i>;</code></p>
<div class="details">
Defines name with type <code><i>type-name</i></code> constructed as appropriate for the given arguments in <code><i>args</i></code>.
</div>
<p><code><i>expression</i>;</code></p>
<div class="details">
Executes <code><i>expression</i></code> for its side effects.
</div>
<p><code>{ <i>statement(s) </i> }</code></p>
<div class="details">
Called a block. Executes the sequence of zero or more <code><i>statement(s)</i></code> in order. May<br />
be used wherever a <code><i>statement</i></code> is expected. Variables defined inside the braces have<br />
scope limited to the block.
</div>
<p><code>while <i>(condition) statement</i></code></p>
<div class="details">
If condition is <code>false</code>, do nothing; otherwise, execute <code><i>statement</i></code> and then repeat the<br />
entire <code>while</code>.
</div>
<p><code>for<i>(init-statement condition; expression) statement</i></code></p>
<div class="details">
Equivalent to <code>{ <i>init-statement</i> while (<i>condition</i>) {<i>statement expression</i>; } }</code>.
</div>
<p><code>if <i>(condition) statement</i></code></p>
<div class="details">
Executes <code><i>statement</i></code> if <code><i>condition</i></code> is <code>true</code>.
</div>
<p><code>if <i>(condition) statement</i> else <i>statement2</i></code></p>
<div class="details">
Executes <code><i>statement</i></code> if <code><i>condition</i></code> is <code>true</code>, otherwise executes <code><i>statement2</i></code>.<br />
Each <code>else</code> is associated with the nearest matching <code>if</code>.
</div>
<p><code>return <i>val</i>;</code></p>
<div class="details">
Exits the function and returns <code>val</code> to its caller.
</div>
<h4>Exercises</h4>
<p><b>2-0.</b> Compile and run the program presented in this chapter.</p>
<p><b>2-1</b>. Change the framing program so that it writes its greeting with no separation from the frame.</p>
<p><b>2-2</b>. Change the framing program so that it uses a different amount of space to separate the sides 
from the greeting than it uses to separate the top and bottom borders from the greeting.</p>
<p><b>2-3.</b> Rewrite the framing program to ask the user to supply the amount of spacing to leave 
between the frame and the greeting.</p>
<p><b>2-4.</b> The framing program writes the mostly blank lines that separate the borders from the greeting 
one character at a time. Change the program so that it writes all the spaces needed in a single output expression.</p>
<p><b>2-5.</b> Write a set of <code>&quot;*&quot;</code> characters so that they form a square, a rectangle, and a triangle.</p>
<p><b>2-6.</b> What does the following code do?</p>
<div class="prebox"><pre>
int i = 0;
while (i &lt; 10) {
    i += 1;
    std::cout &lt;&lt; i &lt;&lt; std::endl;
}
</pre></div>
<p><b>2-7.</b> Write a program to count down from <code>10</code> to <code>-5</code> .</p>
<p><b>2-8.</b> Write a program to generate the product of the numbers in the range <code>[1, 10)</code>.</p>
<p><b>2-9.</b> Write a program that asks the user to enter two numbers and tells the user which number is larger than the other.</p>
<p><b>2-10.</b> Explain each of the uses of <code>std::</code> in the following program:</p>
<div class="prebox"><pre>
int main() {
int k =  0;
    while (k != n) {             // invariant: we have written k asterisks so far
        using std::cout;
        cout &lt;&lt; &quot;*&quot;;
        ++k;
    }
    std::cout &lt;&lt; std::endl;      // std:: is required here
    return 0;
}
</pre></div>
<div class="prevnext">
<a href="13.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="15.htm"><img src="images/Next1.gif" /></a>
</div>
</body>
</html>