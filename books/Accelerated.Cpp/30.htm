<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>5.7 Testing our split function</title>
<link rel="stylesheet" type="text/css" href="./acc.css" />
</head>

<body>
<div class="prevnext">
<a href="29.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="31.htm"><img src="images/Next1.gif" /></a>
</div>
<h3>5.7 Testing our split function</h3>
<p>Having written our function, we'd like to test it. The easiest way to do so is to write a 
program that reads a line of input and passes that line to the <code>split</code> function. We can 
then write the contents of the <code>vector</code> that <code>split</code> returns. Such a test program will make 
it easy to inspect the output, and to verify that the <code>split</code> function generates the words that we expect.</p>
<p>More usefully, this test function should produce the same results as a program that 
just reads words from the standard input and writes the words one per output line. We 
can write this latter program, run it and our test program on the same input files, and verify 
that our programs generate identical output. If so, we can be fairly confident in our 
<code>split</code> function.</p>
<p>Let's start by writing the test program for split:</p>
<div class="prebox"><pre>
int main() {
    string s;
    // <i>read and split each line of input </i>
    while (getline(cin, s)) {
        vector&lt;string&gt; v = split(s);

        // <i>write each word in </i>v
        for (vector&lt;string&gt;::size_type i = 0; i != v.size(); ++i)
             cout &lt;&lt; v[i] &lt;&lt; endl;
    }
    return 0;
}
</pre></div>
<p>This program needs to read the input an entire line at a time. Fortunately, the <code>string</code> 
library provides what we need in the <code>getline</code> function, which reads input until it 
reaches the end of the line. The <code>getline</code> function takes two arguments. The first is the 
<code>istream</code> from which to read; the second is a reference to the <code>string</code> into which to store 
what is read. As usual, the <code>getline</code> function returns a reference to the <code>istream</code> from 
which we read, so that we can test that <code>istream</code> in a condition. If we hit end-of-file or 
encounter invalid input, then the return from <code>getline</code> will indicate failure and we'll 
break out of the <code>while</code>.</p>
<p>As long as we can read a line of input, we store that line in <code>s</code> and pass it to <code>split</code>, 
storing the return value from <code>split</code> in <code>v</code>. Next, we loop through <code>v</code>, writing each <code>string</code> 
in that <code>vector</code> on a separate line.</p>
<p>Assuming that we added the proper <code>#include</code>s, including one for our own header 
that contained a declaration for <code>split</code>, we could run this function and visually verify that 
it and <code>split</code> work as expected. We can do even better, though, by comparing the output 
of this program with a program that lets the library do all the work:</p>
<div class="prebox"><pre>
int main()
{
    string s;
    while (cin &gt;&gt; s)
        cout &lt;&lt; s &lt;&lt; endl;
    return  0;
}
</pre></div>
<p>This program and the previous one should generate identical output. Here, we let 
the <code>string</code> input operator separate the input stream into a series of words, which we write 
one to a line. By running both programs on the same, complex input, we can have a good 
idea that our split function works.</p>
<div class="prevnext">
<a href="29.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="31.htm"><img src="images/Next1.gif" /></a>
</div>
</body>
</html>