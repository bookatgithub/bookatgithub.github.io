<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>5.9 Details</title>
<link rel="stylesheet" type="text/css" href="./acc.css" />
</head>

<body>
<div class="prevnext">
<a href="31.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="33.htm"><img src="images/Next1.gif" /></a>
</div>
<h3>5.9 Details</h3>
<p><b>Containers and iterators: </b>The standard library is designed so that similar operations on 
different containers have the same interface and the same semantics. The containers we 
have used so far are all <i><b>sequential</b> </i>containers. We'll see in Chapter 7 that the library also 
provides associative containers. All the sequential containers and the <code>string</code> type provide 
the following operations:</p>
<p><code><i>container</i>&lt;T&gt;::iterator</code><br />
<code><i>container</i>&lt;T&gt;::const_iterator</code></p>
<div class="details">
The name of the type of the iterator on this container.
</div>
<p><code>container&lt;T&gt;::size_type</code></p>
<div class="details">
The name of the appropriate type to hold the size of the largest possible 
instance of this container.
</div>
<p><code>c.begin()</code><br />
<code>c.end()</code></p>
<div class="details">
Iterators referring to the first and (one past) the last element in the container.
</div>
<p><code>c.rbegin()</code><br />
<code>c.rend()</code></p>
<div class="details">
Iterators referring to the last and (one beyond) the first element in the container 
that grant access to the container's elements in reverse order.
</div>
<p><code>container&lt;T&gt; c;</code><br />
<code>container&lt;T&gt; c(c2)</code>;</p>
<div class="details">
Defines <code>c</code> as a container that is empty or a copy of <code>c2</code> if given.
</div>
<p><code>container&lt;T&gt; c(n)</code>;</p>
<div class="details">
Defines <code>c</code> as a container with <code>n</code> elements that are value-initialized (&sect;7.2/125) 
according to the type of <code>T</code>. If <code>T</code> is a class type, that type will control how to 
initialize the elements. If <code>T</code> is a built-in arithmetic type, then the elements will be 
initialized to 0.
</div>
<p><code>container&lt;T&gt; c(n, t)</code>;</p>
<div class="details">
Defines <code>c</code> as a container with <code>n</code> elements that are copies of <code>t</code>.
</div>
<p><code>container&lt;T&gt; c(b, e)</code>;</p>
<div class="details">
Creates a container that holds a copy of the elements denoted by iterators in 
the range <code>[b, e)</code>.
</div>
<p><code>c = c2</code></p>
<div class="details">
Replaces the contents of container <code>c</code> with a copy of the container <code>c2</code>.
</div>
<p><code>c.size()</code></p>
<div class="details">
Returns the number of elements in <code>c</code> as a <code>size_type</code>.
</div>
<p><code>c.empty()</code></p>
<div class="details">
Predicate that indicates whether <code>c</code> has no elements.
</div>
<p><code>c.insert(d, b, e)</code></p>
<div class="details">
Copies elements denoted by iterators in the range <code>[b, e)</code> and inserts them 
into <code>c</code> immediately before <code>d</code>.
</div>
<p><code>c.erase(it)</code><br />
<code>c.erase(b, e)</code></p>
<div class="details">
Removes the element denoted by <code>it</code> or the range of elements denoted by 
<code>[b, e)</code> from the container <code>c</code>. This operation is fast for <code>list</code> but can be slow 
for <code>vector</code> and <code>string</code>, because for these types it involves copying all the 
elements after the one that is removed. For <code>list</code>, iterators to the element(s) 
that are erased are invalidated. For <code>vector</code> and <code>string</code>, all iterators to elements 
after the one erased are invalidated.
</div>
<p><code>c.push_back(t)</code></p>
<div class="details">
Adds an element to the end of <code>c</code> with the value <code>t</code>.
</div>
<p>Containers that support random access, and the <code>string</code> type, also provide the following:</p>
<p><code>c[n]</code></p>
<div class="details">
Fetches the character at position <code>n</code> from the container <code>c</code>.
</div>
<p><b>Iterator operations:</b></p>
<p><code>*it</code></p>
<div class="details">
Dereferences the iterator <code>it</code> to obtain the value stored in the container at the 
position that <code>it</code> denotes. This operation is often combined with . to obtain a 
member of a class object, as in <code>(*it).x</code>, which yields the member <code>x</code> of the 
object denoted by the iterator <code>it. * </code>has lower precedence than . and the 
same precedence as <code>++</code> and <code>—</code>.
</div>
<p><code>it-&gt;x</code></p>
<div class="details">
Equivalent to <code>(*it).x</code>, which returns the member <code>x</code> denoted by the object 
obtained by dereferencing the iterator <code>it</code>. Same precedence as the <code>.</code> operator.
</div>
<p><code>++i</code><br />
<code>it++</code></p>
<div class="details">
Increments the iterator so that it denotes the next element in the container.
</div>
<p><code>b == e</code><br />
<code>b != e</code></p>
<div class="details">
Compares two iterators for equality or inequality.
</div>
<p><b>The <code>string</code> type </b>offers iterators that support the same operations as do iterators on 
<code>vector</code>s. In particular, <code>string</code> supports full random access, about which we'll learn 
more in Chapter 8. In addition to the operations on containers, <code>string</code> also provides:</p>
<p><code>s.substr(i, j)</code></p>
<div class="details">
Creates a new <code>string</code> that holds a copy of the characters in <code>s</code> with 
indices in the range <code>[i, i + j)</code>.
</div>
<p><code>getline(is, s)</code></p>
<div class="details">
Reads a line of input from <code>is</code> and stores it in <code>s</code>.
</div>
<p><code>s += s2</code></p>
<div class="details">
Replaces the value of <code>s</code> by <code>s + s2</code>.
</div>
<p><b>The <code>vector</code> type </b>offers the most powerful iterators, called random-access iterators, of 
any of the library containers. We'll learn more about these in Chapter 8.</p>
<p>Although all the functions we've written have relied on dynamically allocating our 
<code>vector</code> elements, there are also mechanisms for preallocating elements, and an operation 
to direct the <code>vector</code> to allocate, but not to use, additional memory in order to avoid the 
overhead of repeated memory allocations.</p>
<p><code>v.reserve(n)</code></p>
<div class="details">
Reserves space to hold <code>n</code> elements, but does not initialize them. This 
operation does not change the size of the container. It affects only the 
frequency with which vector may have to allocate memory in response 
to repeated calls to <code>insert</code> or <code>push_back</code>.
</div>
<p><code>v.resize(n)</code></p>
<div class="details">
Gives <code>v</code> a new size equal to <code>n</code>. If <code>n</code> is smaller than the current size of <code>v</code>, 
elements beyond <code>n</code> are removed from the <code>vector</code>. If <code>n</code> is greater than 
the current size, then new elements are added to <code>v</code> and initialized as 
appropriate to the type in <code>v</code>.
</div>
<p><b>The <code>list</code> type </b>is optimized for efficiently inserting and deleting elements at any point in 
the container. The operations on <code>list</code>s and <code>list</code> iterators include those described in 
&sect;5.9/96. In addition,</p>
<p><code>l.sort()</code><br />
<code>l.sort(cmp)</code></p>
<div class="details">
Sorts the elements in <code>l</code> using the <code>&lt;</code> operator for the type in the <code>list</code>, or 
the predicate <code>cmp</code>.
</div>
<p><b>The <code>&lt;cctype&gt;</code> header </b>provides useful functions for manipulating character data:</p>
<div class="prebox">
<pre>
isspace(c)     true if c is a whitespace character.
isalpha(c)     true if c is an alphabetic character.
isdigit(c)     true if c is a digit character.
isalnum(c)     true if c is a letter or a digit.
ispunct(c)     true if c is a punctuation character.
isupper(c)     true if c is an uppercase letter.
islower(c)     true if c is a lowercase letter.
toupper(c)     Yields the uppercase equivalent to c
tolower(c)     Yields the lowercase equivalent to c
</pre>
</div>
<h4>Exercises</h4>
<p><b>5-0.</b> Compile, execute, and test the programs in this chapter.</p>
<p><b>5-1.</b> Design and implement a program to produce a permuted index. A permuted index is one in 
which each phrase is indexed by every word in the phrase. So, given the following input,</p>
<div class="prebox"><pre>
The quick brown fox 
jumped over the fence
</pre></div>
<p>the output would be</p>
<div class="prebox"><pre>
      The quick     brown fox 
jumped over the     fence
The quick brown     fox 
                    jumped over the fence
         jumped     over the fence
            The     quick brown fox 
    jumped over     the fence
                    The quick brown fox
</pre></div>
<p>A good algorithm is suggested in <i>The AWK Programming Language </i>by Aho, Kernighan, 
and Weinberger (Addison-Wesley, 1988). That solution divides the problem into three steps:</p>
<ol>
<li>Read each line of the input and generate a set of rotations of that line. Each rotation puts 
the next word of the input in the first position and rotates the previous first word to the 
end of the phrase. So the output of this phase for the first line of our input would be
<div class="prebox"><pre>
The quick brown fox
quick brown fox The
brown fox The quick
fox The quick brown
</pre></div>
</li>
Of course, it will be important to know where the original phrase ends and where the 
rotated beginning begins.
<li>Sort the rotations.</li>
<li>Unrotate and write the permuted index, which involves finding the separator, putting 
the phrase back together, and writing it properly formatted.</li></ol>
<p><b>5-2.</b> Write the complete new version of the student-grading program, which extracts records for 
failing students, using <code>vector</code>s. Write another that uses <code>list</code>s. Measure the performance 
difference on input files of ten lines, 1,000 lines, and 10,000 lines.</p>
<p><b>5-3.</b> By using a <code>typedef</code>, we can write one version of the program that implements either a 
<code>vector</code>-based solution or a <code>list</code>-based one. Write and test this version of the program.</p>
<p><b>5-4.</b> Look again at the driver functions you wrote in the previous exercise. Note that it is possible 
to write a driver that differs only in the declaration of the type for the data structure that 
holds the input file. If your <code>vector</code> and <code>list</code> test drivers differ in any other way, rewrite 
them so that they differ only in this declaration.</p>
<p><b>5-5.</b> Write a function named <code>center(const vector&lt;string&gt;&amp;)</code> that returns a picture in 
which all the lines of the original picture are padded out to their full width, and the padding 
is as evenly divided as possible between the left and right sides of the picture. What are the 
properties of pictures for which such a function is useful? How can you tell whether a given 
picture has those properties?</p>
<p><b>5-6.</b> Rewrite the <code>extract_fails</code> function from &sect;5.1.1/77 so that instead of erasing each failing 
student from the input vector <code>v</code>, it copies the records for the passing students to the beginning 
of <code>v</code>, and then uses the <code>resize</code> function to remove the extra elements from the end of 
<code>v</code>. How does the performance of this version compare with the one in &sect;5.1.1/77?</p>
<p><b>5-7.</b> Given the implementation of frame in &sect;5.8.1/93, and the following code fragment</p>
<div class="prebox"><pre>
vector&lt;string&gt; v;
frame(v);
</pre></div>
<p>describe what happens in this call. In particular, trace through how both the <code>width</code> function 
and the frame function operate. Now, run this code. If the results differ from your expectations, 
first understand why your expectations and the program differ, and then change one 
to match the other.</p>
<p><b>5-8.</b> In the <code>hcat</code> function from &sect;5.8.3/95, what would happen if we defined <code>s</code> outside the scope 
of the <code>while</code>? Rewrite and execute the program to confirm your hypothesis.</p>
<p><b>5-9.</b> Write a program to write the lowercase words in the input followed by the uppercase 
words.</p>
<p><b>5-10.</b> Palindromes are words that are spelled the same right to left as left to right. Write a program 
to find all the palindromes in a dictionary. Next, find the longest palindrome.</p>
<p><b>5-11.</b> In text processing it is sometimes useful to know whether a word has any ascenders or 
descenders. Ascenders are the parts of lowercase letters that extend above the text line; in 
the English alphabet, the letters b, d, f, h, k, l, and t have ascenders. Similarly, the descenders 
are the parts of lowercase letters that descend below the line; In English, the letters g, j, 
p, q, and y have descenders. Write a program to determine whether a word has any ascenders 
or descenders. Extend that program to find the longest word in the dictionary that has 
neither ascenders nor descenders.</p>
<div class="prevnext">
<a href="31.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="33.htm"><img src="images/Next1.gif" /></a>
</div>
</body>
</html>