<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>6.5 Details</title>
<link rel="stylesheet" type="text/css" href="./acc.css" />
</head>

<body>
<div class="prevnext">
<a href="36.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="38.htm"><img src="images/Next1.gif" /></a>
</div>
<h3>6.5 Details</h3>
<p><b>Type modifiers:</b></p>
<p><code>static <i>type variable</i>;</code></p>
<div class="details">
For local declarations, declares <i>variable </i>with <code>static</code> storage class. The value of <i>variable </i>
persists across executions of this scope and is guaranteed to be initialized before 
the variable is used for the first time. When the program exits from the scope, the variable 
keeps its value until the next time the program enters that scope. We'll see in 
&sect;13.4/244 that the meaning of <code>static</code> varies with context.
</div>
<p><b>Types: </b>The built-in type <code>void</code> can be used in a restricted number of ways, one of which is 
to indicate that a function yields no return value. Such functions can be exited through a 
<code>return</code>; that has no value or by falling off the end of the function.</p>
<p><b>Iterator adaptors </b>are functions that yield iterators. The most common are the adaptors 
that generate <code>insert_iterators</code>, which are iterators that grow the associated container 
dynamically. Such iterators can be used safely as the destination of a copying algorithm. 
They are defined in header <code>&lt;iterator&gt;</code>:</p>
<p><code>back_inserter(c)</code></p>
<div class="details">
Yields an iterator on the container <code>c</code> that appends elements to <code>c</code>. The container must 
support <code>push_back</code>, which the <code>list, vector</code>, and the <code>string</code> types all do.
</div>
<p><code>front_inserter(c)</code></p>
<div class="details">
Like <code>back_inserter</code>, but inserts at the front of the container. The container must 
support <code>push_front</code>, which <code>list</code> does, but <code>string</code> and <code>vector</code> do not.
</div>
<p><code>inserter(c, it)</code></p>
<div class="details">
Like <code>back_inserter</code>, but inserts elements before the iterator <code>it</code>.
</div>
<p><b>Algorithms: </b>Unless otherwise indicated, <code>&lt;algorithm&gt;</code> defines these algorithms:</p>
<p><code>accumulate(b, e, t)</code></p>
<div class="details">
Creates a local variable and initializes it to a copy of <code>t</code> (with the same type as <code>t</code>, which 
means that the type of <code>t</code> is crucially important to the behavior of <code>accumulate</code>), adds 
each element in the range <code>[b, e)</code> to the variable, and returns a copy of the variable as 
its result. Defined in <code>&lt;numeric&gt;</code>.
</div>
<p><code>find(b, e, t)</code><br />
<code>find_if(b, e, p)</code><br />
<code>search(b, e, b2, e2)</code></p>
<div class="details">
Algorithms to look for a given value in the sequence <code>[b, e)</code>. The <code>find</code> algorithm 
looks for the value <code>t</code>; the <code>find_if</code> algorithm tests each element against the predicate 
<code>p</code>; the search algorithm looks for the sequence denoted by <code>[b2, e2)</code>.
</div>
<p><code>copy(b, e, d)</code><br />
<code>remove_copy(b, e, d, t)</code><br />
<code>remove_copy_if(b, e, d, p)</code></p>
<div class="details">
Algorithms to copy the sequence from <code>[b, e)</code> to the destination denoted by <code>d</code>. The 
<code>copy</code> algorithm copies the entire sequence; <code>remove_copy</code> copies all elements not 
equal to <code>t</code>; and <code>remove_copy_if</code> copies all elements for which the predicate <code>p</code> fails.
</div>
<p><code>remove_if(b, e, p)</code></p>
<div class="details">
Arranges the container so that the elements in the range <code>[b, e)</code> for which the predicate 
<code>p</code> is false are at the front of the range. Returns an iterator denoting one past the 
range of these &quot;unremoved&quot; elements.
</div>
<p><code>remove(b, e, t)</code></p>
<div class="details">
Like <code>remove_if</code>, but tests which elements to keep against the value <code>t</code>.
</div>
<p><code>transform(b, e, d, f)</code></p>
<div class="details">
Runs the function <code>f</code> on the elements in the range <code>[b, e)</code>, storing the result of <code>f</code> in <code>d</code>.
</div>
<p><code>partition(b, e, p)</code>
<code>stable_partition(b, e, p)</code></p>
<div class="details">
Partitions the elements in the range <code>[b, e)</code>, based on the predicate <code>p</code>, so that elements 
for which the predicate is <code>true</code> are at the front of the container. Returns an iterator to 
the first element for which the predicate is <code>false</code>, or <code>e</code> if the predicate is <code>true</code> for all 
elements. The <code>stable_partition</code> function maintains the input order among the elements in each partition.
</div>
<h4>Exercises</h4>
<p><b>6-0.</b>&nbsp; &nbsp; Compile, execute, and test the programs in this chapter.</p>
<p><b>6-1.</b>&nbsp; &nbsp; Reimplement the <code>frame</code> and <code>hcat</code> operations from &sect;5.8.1/93 and &sect;5.8.3/94 to use iterators.</p>
<p><b>6-2.</b>&nbsp; &nbsp; Write a program to test the <code>find_urls</code> function.</p>
<p><b>6-3.</b>&nbsp; &nbsp; What does this program fragment do?</p>
<div class="prebox"><pre>
vector&lt;int&gt; u(10, 100);
vector&lt;int&gt; v;
copy(u.begin(), u.end(), v.begin());
</pre></div>
<p>Write a program that contains this fragment, and compile and execute it.</p>
<p><b>6-4.</b> &nbsp;&nbsp;Correct the program you wrote in the previous exercise to copy from <code>u</code> into <code>v</code>. There are at 
least two possible ways to correct the program. Implement both, and describe the relative 
advantages and disadvantages of each approach.</p>
<p><b>6-5.</b> &nbsp;&nbsp;Write an analysis function to call <code>optimistic_median</code>.</p>
<p><b>6-6.</b> &nbsp;&nbsp;Note that the function from the previous exercise and the functions from &sect;6.2.2/113 and 
&sect;6.2.3/115 do the same task. Merge these three analysis functions into a single function.</p>
<p><b>6-7.</b> &nbsp;&nbsp;The portion of the grading analysis program from &sect;6.2.1/110 that read and classified student 
records depending on whether they did (or did not) do all the homework is similar to the 
problem we solved in <code>extract_fails</code>. Write a function to handle this subproblem.</p>
<p><b>6-8.</b> &nbsp;&nbsp;Write a single function that can be used to classify students based on criteria of your choice. 
Test this function by using it in place of the <code>extract_fails</code> program, and use it in the program 
to analyze student grades.</p>
<p><b>6-9.</b> &nbsp;&nbsp;Use a library algorithm to concatenate all the elements of a <code>vector&lt;string&gt;</code>.</p>
<div class="prevnext">
<a href="36.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="38.htm"><img src="images/Next1.gif" /></a>
</div>
</body>
</html>