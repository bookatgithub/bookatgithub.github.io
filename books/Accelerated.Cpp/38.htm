<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>Using associative containers</title>
<link rel="stylesheet" type="text/css" href="./acc.css" />
</head>

<body>
<div class="prevnext">
<a href="37.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="39.htm"><img src="images/Next1.gif" /></a>
</div>
<div class="chapname">
<h1>7</h1>
</div>
<div id="chapter">
<h2>Using associative containers</h2>
</div>
<p>All the containers that we have used until now have been sequential containers, whose 
elements remain in the sequence that we choose for them. When we use <code>push_back</code> or 
<code>insert</code> to add elements to a sequential container, each element will stay where we put it 
until we do something to the container that reorders the elements.</p>
<p>Some kinds of programs are hard to write efficiently if we restrict ourselves to sequential 
containers. For example, if we have a container of integers, and we wish to write a 
program that determines whether any element of the container has the value 42, we have 
two plausible strategies—neither of which is ideal. One alternative is to inspect every element 
of the container until we find 42 or run out of elements. This approach is straightforward, 
but potentially slow—especially if the container has many elements. The other 
alternative is for us to keep the container in an appropriate order and devise an efficient 
algorithm to find the element we seek. This approach can yield fast searches, but such 
algorithms are not easy to devise. In other words, we must live with a slow program, or 
come up with our own sophisticated algorithm. Fortunately, as we'll see in this chapter, 
the library offers a third alternative.</p>
<a name="container">
<h3>7.1 Containers that support efficient look-up</h3>
</a>
<p>Instead of storing data in a sequential container, we can use an <i><b>associative container</b>. </i>Such 
containers automatically arrange their elements into a sequence that depends on the values 
of the elements themselves, rather than the sequence in which we inserted them. 
Moreover, associative containers exploit this ordering to let us locate particular elements 
much more quickly than do the sequential containers, without our having to keep the container 
ordered by ourselves.</p>
<p>Associative containers offer efficient ways to find an element that contains a particular 
value, and might contain additional information as well. The part of each container element 
that we can use for these efficient searches is called a <i><b>key</b>. </i>For example, if we were 
keeping track of information about students, we might use the student's name as the key, 
so that we could find students efficiently by name.</p>
<p>In the sequential containers, the closest that we have seen to a key is the integer index 
that accompanies every element of a <code>vector</code>. However, even these indices are not really 
keys, because every time we insert or delete a <code>vector</code> element, we implicitly change the 
index of every element <i>after </i>the one that we touched.</p>
<p>The most common kind of associative data structure is one that stores key-value pairs, 
associating a value with each key, and that lets us insert and retrieve elements quickly 
based on their keys. When we put a particular key-value pair into the data structure, that 
key will continue to be associated with the same value until we delete the pair. Such a data 
structure is called an <i><b>associative array</b>. </i>Many languages, such as AWK, Perl, and Sno-bol, 
have associative arrays built in. In C++, associative arrays are part of the library. The 
most common kind of associative array in C++ is called a <b>map, </b>and, analogous with other 
containers, it is defined in the <code>&lt;map&gt;</code> header.</p>
<p>In many ways, <code>map</code>s behave like <code>vector</code>s. One fundamental difference is that the 
index of a <code>map</code> need not be an integer; it can be a <code>string</code>, or any other type with values 
that we can compare so as to keep them ordered.</p>
<p>Another important difference between associative and sequential containers is that, 
because associative containers are self-ordering, our own programs must not do anything 
that changes the order of the elements. For that reason, algorithms that change the contents 
of containers often don't work for associative containers. In exchange for that 
restriction, associative containers offer a variety of useful operations that are impossible to 
implement efficiently for sequential containers.</p>
<p>This chapter presents several programming examples that use maps to write compact 
and efficient look-up-intensive programs.</p>
<div class="prevnext">
<a href="37.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="39.htm"><img src="images/Next1.gif" /></a>
</div>
</body>
</html>