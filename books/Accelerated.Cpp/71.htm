<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>11.6 Details</title>
<link rel="stylesheet" type="text/css" href="./acc.css" />
</head>

<body>
<div class="prevnext">
<a href="70.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="72.htm"><img src="images/Next1.gif" /></a>
</div>
<h3>11.6 Details</h3>
<p><b>Template classes </b>can be formed using the template facility described in &sect;8.1.1/140:</p>
<div class="prebox"><pre>
template &lt;class <i>type-parameter [, </i>class <i>type-parameter]... &gt;
</i>class <i>class-name </i>{ ... } ;
</pre></div>
<p></p>
<p>creates a template class named <i><code>class-name</code> </i>that depends on the given type parameters. 
These type-parameter names may be used inside the template wherever a type is 
required. In the scope of the class, the template class may be referred to without qualification; 
outside the class scope, <i><code>class-name</code> </i>must be qualified with the type parameters:</p>
<div class="prebox"><pre>
template &lt;class T&gt;
Vec&lt;T&gt;&amp; Vec&lt;T&gt;::operator=(const Vec&amp;) { ... }
</pre></div>
<p>Users specify the actual types when creating objects of template types: <code>Vec&lt;int&gt;</code> causes 
the implementation to instantiate a version of <code>Vec</code> binding the type parameter to <code>int</code>.</p>
<p><b>Copy control: </b>In general, classes control what happens when objects are created, copied, 
assigned, or destroyed. Constructors are invoked as a side effect of creating or copying 
objects; the assignment operator is invoked in expressions involving assignment; and the 
destructor is run automatically when objects are destroyed or go out of scope.</p>
<p>Classes that allocate resources in a constructor almost invariably must define the copy 
constructor, the assignment operator, and the destructor. When we write an assignment 
operator, it is essential for us to check for self-assignment. For consistency with the built-in 
assignment operators, it is good practice to return a reference to the left-hand operand.</p>
<p><b>Synthesized operations: </b>If a class defines no constructors, the compiler will synthesize 
the default constructor. If the class does not explicitly define them, the compiler will synthesize 
the copy constructor, assignment operator, and/or destructor. The synthesized 
operations are defined recursively: Each synthesized operator recursively applies the 
appropriate operation for the data members of the class.</p>
<p><b>Overloaded operators </b>are defined by defining a function named <code>operator</code> <i>op</i>, where <i>op </i>
is the operator being defined. At least one parameter must be of class type. When an 
operator function is a member of a class, its left-hand operand (if it is a binary operator) or 
its only operand (if it is a unary operator) is bound to the object on which it is invoked. 
The index operator and the assignment operator must be class members.</p>
<h4>Exercises</h4>
<p><b>11-0.</b> Compile, execute, and test the programs in this chapter.</p>
<p><b>11-1.</b> The <code>Student_info</code> structure that we defined in Chapter 9 did not define a copy constructor, 
assignment operator, or destructor. Why not?</p>
<p><b>11-2.</b> That structure did define a default constructor. Why?</p>
<p><b>11-3.</b> What does the synthesized assignment operator for <code>Student_info</code> objects do?</p>
<p><b>11-4.</b> How many members does the synthesized <code>Student_info</code> destructor destroy?</p>
<p><b>11-5.</b> Instrument the <code>Student_info</code> class to count how often objects are created, copied, 
assigned, and destroyed. Use this instrumented class to execute the student record 
programs from Chapter 6. Using the instrumented <code>Student_info</code> class will let you see how 
many copies the library algorithms are doing. Comparing the number of copies will let 
you estimate what proportion of the cost differences we saw are accounted for by the use 
of each library class. Do this instrumentation and analysis.</p>
<p><b>11-6.</b> Add an operation to remove an element from a <code>Vec</code> and another to empty the entire <code>Vec</code>. 
These should behave analogously to the <code>erase</code> and <code>clear</code> operations on <code>vector</code>s.</p>
<p><b>11-7.</b> Once you've added <code>erase</code> and <code>clear</code> to <code>Vec</code>, you can use that class instead of <code>vector</code> 
in most of the earlier programs in this book. Rewrite the <code>Student_info</code> programs from 
Chapter 9 and the programs that work with character pictures from Chapter 5 to use <code>Vec</code>s 
instead of <code>vector</code>s.</p>
<p><b>11-8.</b> Write a simplified version of the standard <code>list</code> class and its associated iterator.</p>
<p><b>11-9.</b> The <code>grow</code> function in &sect;11.5.1/208 doubles the amount of memory each time it needs more. 
Estimate the efficiency gains of this strategy. Once you've predicted how much of a difference 
it makes, change the <code>grow</code> function appropriately and measure the difference.</p>
<div class="prevnext">
<a href="70.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="72.htm"><img src="images/Next1.gif" /></a>
</div>
</body>
</html>