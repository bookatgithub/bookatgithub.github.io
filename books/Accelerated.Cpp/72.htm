<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>Making class objects act like values</title>
<link rel="stylesheet" type="text/css" href="./acc.css" />
</head>

<body>
<div class="prevnext">
<a href="71.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="73.htm"><img src="images/Next1.gif" /></a>
</div>
<div class="chapname">
<h1>12</h1>
</div>
<div id="chapter">
<h2>Making class objects act like values</h2>
</div>
<p>Objects of built-in types generally behave like values: Whenever we copy an object of such 
a type, the original and the copy have the same value but are otherwise independent. 
Subsequent changes to one object do not affect the other. We can create objects of these 
types, pass them to and from functions, copy them, or assign them to other objects.</p>
<p>For most of the built-in types, the language also defines a rich set of operators and provides 
automatic conversions between logically similar types. For example, if we add an 
<code>int</code> and a <code>double</code>, the compiler automatically converts the <code>int</code> into a <code>double</code>.</p>
<p>When we define our own classes, we control the extent to which the resulting objects 
behave like values. We saw in Chapters 9 and 11 that the class author controls what happens 
when objects are created, copied, assigned, and destroyed. By defining copying and 
assignment appropriately, the class author can arrange for objects of that class to act like 
values. That is, the class author can arrange for each object to have state that is independent 
of any other object. Our Vec and <code>Student_info</code> classes are examples of types that 
act like values.</p>
<p>In this chapter, we shall see that the class author can also control conversions and 
related operations on class objects, thereby providing classes whose objects behave even 
more similarly to objects of built-in types. The standard-library <code>string</code> class is a good 
example of such a type because of its rich set of operators and support for automatic conversions. 
Accordingly, in this chapter, we will define a simplified version of <code>string</code>, 
called <code>Str</code>, much as we defined a simplified version of <code>vector</code> in Chapter 11. We will 
focus on the operators and conversions that let us write expressions involving <code>string</code>s. 
In this chapter, we will not concern ourselves with efficiency. Instead, in Chapter 14, we 
will revisit <code>Str</code> to understand techniques for managing more efficiently the storage associated 
with each <code>Str</code> object.</p>
<p>We do not need to worry much about the implementation details of our <code>Str</code> class, 
because we did most of the work already when we implemented the <code>Vec</code> class. Accordingly, 
most of the discussion in this chapter will revolve around how to design an appropriate 
interface to our class.</p>
<div class="prevnext">
<a href="71.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="73.htm"><img src="images/Next1.gif" /></a>
</div>
</body>
</html>