<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>Managing memory (almost) automatically</title>
<link rel="stylesheet" type="text/css" href="./acc.css" />
</head>

<body>
<div class="prevnext">
<a href="87.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="89.htm"><img src="images/Next1.gif" /></a>
</div>
<div class="chapname">
<h1>14</h1>
</div>
<div id="chapter">
<h2>Managing memory (almost) automatically</h2>
</div>
<p>When we built our Student_info <code>handle</code> class in Chapter 13, we combined two separable 
abstractions. Not only was that class an interface to the operations on student records, 
but it also managed a pointer to an implementation object. Combining two independent 
abstractions into a single class is often a sign of weak design.</p>
<p>What we'd like is to be able to define a class that is similar to <code>Student_info</code>, but that 
is strictly an interface class. Such interface classes are common in C++, especially when 
they interface to an inheritance hierarchy. We will arrange for our interface class to delegate 
the implementation details to another class, which behaves like a pointer but also 
manages the underlying memory. Once we have separated the interface class from the 
pointerlike class, we should be able to use a single pointerlike class with multiple interface 
classes.</p>
<p>As we'll see, we can also use classes such as these to improve the performance of programs 
that manage memory often. By arranging for several pointerlike objects to refer to 
a single underlying object where appropriate, we can avoid copying objects unnecessarily.</p>
<p>Much of this chapter revolves around the answer to a single question: What does it 
mean to copy an object? At first glance, this question seems to have an obvious answer: A 
copy is a distinct object that has all the properties of the original object. However, the 
moment it becomes possible for one object to refer to another, the question becomes more 
complicated: If an object <code>x</code> refers to an object <code>y</code>, does copying <code>x</code> cause <code>y</code> to be copied too?</p>
<p>Sometimes the answer to this latter question is obvious: If <code>y</code> is a member of <code>x</code>, the 
answer must be yes, and if <code>x</code> is nothing more than a pointer that happens to point to <code>y</code>, 
the answer is no. In this chapter we'll define three different versions of our pointerlike 
class, each of which differs from the others in how it defines copying.</p>
<p>These questions about copying, and the very idea of a pointerlike class, are fairly 
abstract notions. Because we will implement these abstractions, it is not surprising that 
this chapter is by far the most abstract in the book. As a result, it is likely to require—and 
repay—careful study.</p>
<div class="prevnext">
<a href="87.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="89.htm"><img src="images/Next1.gif" /></a>
</div>
</body>
</html>
