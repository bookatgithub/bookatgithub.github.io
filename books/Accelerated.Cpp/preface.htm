<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>Preface</title>
<link rel="stylesheet" type="text/css" href="./acc.css" />
</head>

<body>
<div class="prevnext">
<a href="series.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="Dedication.htm"><img src="images/Next1.gif" /></a>
</div>
<div id="chapter">
<h1>Preface</h1>
</div>
<h3>A new approach to C++ programming</h3>
<p>We assume that you want to learn quickly how to write useful C++ programs. Therefore, 
we start by explaining the most useful parts of C++. This strategy may seem obvious 
when we put it that way, but it has the radical implication that we do not begin by teaching 
C, even though C++ builds on C. Instead, we use high-level data structures from the 
start, explaining only later the foundations on which those data structures rest. This 
approach lets you to begin writing idiomatic C++ programs immediately.</p>
<p>Our approach is unusual in another way: We concentrate on solving problems, rather 
than on exploring language and library features. We explain the features, of course, but 
we do so in order to support the programs, rather than using the programs as an excuse 
to demonstrate the features.</p>
<p>Because this book teaches C++ programming, not just features/it is particularly useful 
for readers who already know some C++, and who want to use the language in a more 
natural, effective style. Too often, people new to C++ learn the language mechanics without 
learning how to apply the language to everyday problems.</p>
<h3>Our approach works—for beginners and experienced programmers</h3>
<p>We used to teach a week-long intensive C++ course every summer at Stanford University. 
We originally adopted a traditional approach to that course: Assuming that the students 
already knew C, we started by showing them how to define classes, and then moved systematically 
through the rest of the language. We found that our students would be confused 
and frustrated for about two days—until they had learned enough that they could 
start writing useful programs. Once they got to that point, they learned quickly.</p>
<p>When we got our hands on a C++ implementation that supported enough of what was 
then the brand-new standard library, we overhauled the course. The new course used the 
library right from the beginning, concentrated on writing useful programs, and went into 
details only after the students had learned enough to use those details productively.</p>
<p>The results were dramatic: After one day in the classroom, our students were able to 
write programs that had taken them most of the week in the old course. Moreover, their 
frustration vanished.</p>
<h3>Abstraction</h3>
<p>Our approach is possible only because C++, and our understanding of it, has had time to 
mature. That maturity has let us ignore many of the low-level ideas that were the mainstay 
of earlier C++ programs and programmers.</p>
<p>The ability to ignore details is characteristic of maturing technologies. For example, 
early automobiles broke down so often that every driver had to be an amateur mechanic. 
It would have been foolhardy to go for a drive without knowing how to get back home 
even if something went wrong. Today's drivers don't need detailed engineering knowledge 
in order to use a car for transportation. They may wish to learn the engineering 
details for other reasons, but that's another story entirely.</p>
<p>We define abstraction as selective ignorance—concentrating on the ideas that are relevant 
to the task at hand, and ignoring everything else—and we think that it is the most 
important idea in modern programming. The key to writing a successful program is 
knowing which parts of the problem to take into account, and which parts to ignore. 
Every programming language offers tools for creating useful abstractions, and every successful 
programmer knows how to use those tools.</p>
<p>We think, abstractions are so useful that we've filled this book with them. Of course, 
we don't usually call them abstractions directly, because they come in so many forms. 
Instead, we refer to functions, data structures, classes, and inheritance—all of which are 
abstractions. Not only do we refer to them, but we use them throughout the book.</p>
<p>If abstractions are well designed and well chosen, we believe that we can use them 
even if we don't understand all the details of how they work. We do not need to be automotive 
engineers to drive a car, nor do we need to understand everything about how C++ 
works before we can use it.</p>
<h3>Coverage</h3>
<p>If you are serious about C++ programming, you need to know everything in this book— 
even though this book doesn't tell you everything you need to know.</p>
<p>This statement is not as paradoxical as it sounds. No book this size can contain everything 
you'll ever need to know about C++, because different programmers and applications 
require different knowledge. Therefore, any book that covers all of C++—such as 
Stroustrup's <i>The C++ Programming Language </i>(Addison-Wesley, 2000)—will inevitably tell 
you a lot that you don't need to know. Someone else will need it, even if you don't.</p>
<p>On the other hand, many parts of C++ are so universally important that it is hard to be 
productive without understanding them. We have concentrated on those parts. It is possible 
to write a wide variety of useful programs using only the information in this book. 
Indeed, one of our reviewers, who is the lead programmer for a substantial commercial 
system written in C++, told us that this book covers essentially all of the facilities that he 
uses in his work.</p>
<p>Using these facilities, you can write true C++ programs—not C++ programs in the style 
of C, or any other language. Once you have mastered the material in this book, you will 
know enough to figure out what else you want to learn, and how to go about it. Amateur 
telescope makers have a saying that it is easier to make a 3-inch mirror and then to make a 
6-inch mirror than to make a 6-inch mirror from scratch.</p>
<p>We cover only standard C++, and ignore proprietary extensions. This approach has 
the advantage that the programs that we teach you to write will work just about anywhere. 
However, it also implies that we do not talk about how to write programs that 
run in windowing environments, because such programs are invariably tied to a specific 
environment, and often to a specific vendor. If you want to write programs that will work 
only in a particular environment, you will have to turn elsewhere to learn how to do so— 
but don't put this book down quite yet! Because our approach is universal, you will be 
able to use everything that you learn here in whatever environments you use in the 
future. By all means, go ahead and read that book about GUI applications that you were 
considering—but please read this one first.</p>
<h3>A note to experienced C and C++ programmers</h3>
<p>When you learn a new programming language, you may be tempted to write programs in 
a style that is familiar from the languages that you already know. Our approach seeks to 
avoid that temptation by using high-level abstractions from the C++ standard library right 
from the start. If you are already an experienced C or C++ programmer, this approach 
contains some good news and some bad news—and it's the same news.</p>
<p>The news is that you are likely to be surprised at how little of your knowledge will 
help you understand C++ as we present it. You will have more to learn at first than you 
might expect (which is bad), but you will learn more quickly than you might expect 
(which is good). In particular, if you already know C++, you probably learned first how 
to program in C, which means that your C++ programming style is built on a C foundation. 
There is nothing wrong with that approach, but our approach is so different that we 
think you'll see a side of C++ that you haven't seen before.</p>
<p>Of course, many of the syntactic details will be familiar, but they're just details. We 
treat the important ideas in a completely different order from what you've probably 
encountered. For example, we don't mention pointers or arrays until Chapter 10, and 
we're not even going to discuss your old favorites, printf and malloc, at all. On the 
other hand, we start talking about the standard-library string class in Chapter 1. When 
we say we're adopting a new approach, we mean it!</p>
<h3>Structure of this book</h3>
<p>You may find it convenient to think of this book as being in two parts. The first part, 
through Chapter 7, concentrates on programs that use standard-library abstractions. The 
second part, starting with Chapter 8, talks about defining your own abstractions.</p>
<p>Presenting the library first is an unusual idea, but we think it's right. Much of the C++ 
language—especially the harder parts—exists mostly for the benefit of library authors. 
Library users don't need to know those parts of the language at all. By ignoring those 
parts of the language until the second part of the book, we make it possible to write useful 
C++ programs much more quickly than if we had adopted a more conventional approach.</p>
<p>Once you have understood how to use the library, you will be ready to learn about the 
low-level facilities on which the library is built, and how to use those facilities to write 
your own libraries. Moreover, you will have a feeling for how to make a library useful, 
and when to avoid writing new library code altogether.</p>
<p>Although this book is smaller than many C++ books, we have tried to use every important 
idea at least twice, and key ideas more than that. As a result, many parts of the book 
refer to other parts. These references look like &sect;39.4.3/857, which refers to text on page 
857 that is part of section 39.4.3—or at least it would do so if this book had that many sections 
or pages. The first time we explain each idea, we mention it in <i><b>bold italic </b></i>type to 
make it easy to find and to call your attention to it as an important point.</p>
<p>Every chapter (except the last) concludes with a section called <i>Details. </i>These sections 
serve two purposes: They make it easy to remember the ideas that the chapter introduced, 
and they cover additional, related material that we think you will need to know eventually. 
We suggest that you skim these sections on first reading, and refer back to them later 
as needed.</p>
<p>The two appendices summarize and elucidate the important parts of the language and 
library at a level of detail that we hope will be useful when you are writing programs.</p>
<h3>Getting the most out of this book</h3>
<p>Every book about programming includes example programs, and this one is no different. 
In order to understand how these programs work, there is no substitute for running them 
on a computer. Such computers abound, and new ones appear constantly—which means 
that anything we might say about them would be inaccurate by the time you read these 
words. Therefore, if you do not yet know how to compile and execute a C++ program, 
please visit <a href="http://www.acceleratedcpp.com">http://www.acceleratedcpp.com</a> and see what we have to say there. 
We will update that website from time to time with information and advice about the 
mechanics of running C++ programs. The site also offers machine-readable versions of 
some of the example programs, and other information that you might find interesting.</p>
<h3>Acknowledgments</h3>
<p>We would like to thank the people without whom this book would have been impossible. 
It owes much of its form to our reviewers: Robert Berger, Dag Br&uuml;ck, Adam Buchsbaum, 
Stephen Clamage, John Kalb, Jeffrey Oldham, David Slayton, Bjarne Stroustrup, Albert 
Tenbusch, Bruce Tetelman, and Clovis Tondo. Many people from Addison-Wesley participated 
in its publication; the ones we know about are Tyrrell Albaugh, Bunny Ames, Mike 
Hendrickson, Deborah Lafferty, Cathy Ohala, and Simone Payment. Alexander Tsiris 
checked the Greek etymology in &sect;13.2.2/236. Finally, the idea of starting with high-level 
programs grew over many years, stimulated by the hundreds of students who have sat 
through our courses and the thousands of people who have attended our talks.</p>
<p><i>Andrew Koenig</i>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Gillette, New Jersey</font></p>
<p><i>Barbara E. Moo</i>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;June 2000</font></p>
<div class="prevnext">
<a href="series.htm"><img src="images/Prev1.gif" /></a>&nbsp;&nbsp;<a href="Dedication.htm"><img src="images/Next1.gif" /></a>
</div>
</body>
</html>