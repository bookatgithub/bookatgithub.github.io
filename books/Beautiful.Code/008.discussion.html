<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 1.3. Discussion</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>A Regular Expression Matcher</SPAN><SPAN> &gt; Discussion</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=discussion></A>
<H3 class=docSection1Title id=-100000>1.3. Discussion</H3>
<P class=docText><A name="The function"></A>The function <TT>match(regexp, text</TT><A name="is an"></A>) tests whether there is an occurrence of the <A name=idx-CHP-1-0021></A><A name="within the"></A>regular expression anywhere within the text; it returns 1 if a match is found and 0 if not. If there is more than one match, it finds the leftmost and shortest.</P>
<P class=docText><A name="operation of"></A>The basic operation of <TT>match</TT><A name="first character"></A> is straightforward. If the first character of the regular expression is ^ (an anchored match), any possible match must occur at the beginning of the string. That is, if the regular expression is <TT>^xyz</TT>, it matches <TT>xyz</TT> only if <TT>xyz</TT><A name="This is"></A> occurs at the beginning of the text, not somewhere in the middle. This is tested by <A name=idx-CHP-1-0022></A><A name="rest of"></A>matching the rest of the regular expression against the text starting at the beginning and nowhere else. Otherwise, the regular expression might match anywhere within the string. This is tested by matching the pattern against each character position of the text in turn. If there are multiple matches, only the first (leftmost) one will be identified. That is, if the regular expression is <TT>xyz</TT><A name="first occurrence"></A>, it will match the first occurrence of <TT>xyz</TT> regardless of where it occurs.</P>
<P class=docText><A name="input string"></A>Notice that advancing over the input string is done with a <TT>do-while</TT><A name="a comparatively"></A> loop, a comparatively unusual construct in C programs. The occurrence of a <TT>do-while</TT> instead of a <TT>while</TT><A name="a question"></A> should always raise a question: why isn't the loop termination condition being tested at the beginning of the loop, before it's too late, rather than at the end after something has been done? But the test is correct here: since the * operator permits zero-length matches, we first have to check whether a <A name=idx-CHP-1-0023></A>null match is possible.<A name=idx-CHP-1-0024></A></P>
<P class=docText><A name="the work"></A>The bulk of the work is done in the function <TT>matchhere(regexp, text</TT><A name="whether the"></A>), which tests whether the regular expression matches the text that begins right here. The function <TT>matchhere</TT><A name="to match"></A> operates by attempting to match the first character of the regular expression with the first character of the text. If the match fails, there can be no match at this text position and <TT>matchhere</TT><A name="character of"></A> returns 0. If the match succeeds, however, it's possible to advance to the next character of the regular expression and the next character of the text. This is done by calling <TT>matchhere</TT> recursively.</P>
<P class=docText><A name="is a"></A>The situation is a bit more complicated because of some special cases, and of course the need to stop the recursion. The easiest case is that if the <A name=idx-CHP-1-0025></A><A name="its end"></A>regular expression is at its end (<TT>regexp[0]=='\0'</TT><A name="thus the"></A>), all previous tests have succeeded, and thus the regular expression matches the text.</P>
<P class=docText><A name="If the"></A>If the regular expression is a character followed by a <TT>*, matchstar</TT><A name="see whether"></A> is called to see whether the closure matches. The function <TT>matchstar(c, regexp, text</TT><A name="repetitions of"></A>) tries to match repetitions of the text character <TT>c</TT><A name="zero repetitions"></A>, beginning with zero repetitions and counting up, until it either finds a match of the rest of the text, or it fails and thus concludes that there is no match. This algorithm identifies a "<A name=idx-CHP-1-0026></A><A name="fine for"></A>shortest match," which is fine for simple pattern matching as in <SPAN class=docEmphasis>grep</SPAN><A name="as possible"></A>, where all that matters is finding a match as quickly as possible. A "<A name=idx-CHP-1-0027></A><A name="more intuitive"></A>longest match" is more intuitive and almost certain to be better for a text editor where the matched text will be replaced. Most modern regular expression libraries provide both alternatives, and <SPAN class=docEmphasis>The Practice of Programming</SPAN><A name=of></A> presents a simple variant of <TT>matchstar</TT> for this case, shown below.<A name=idx-CHP-1-0028></A></P>
<P class=docText><A name="of a"></A>If the regular expression consists of a $ at the <A name=idx-CHP-1-0029></A><A name="end of"></A>end of the expression, the text matches only if it too is at its end:</P><PRE>	if (regexp[0] == '$' &amp;&amp; regexp[1] == '\0')
	    return *text == '\0';
</PRE><BR>
<P class=docText><A name="not at"></A>Otherwise, if we are not at the end of the text string (that is, <TT>*text!='\0'</TT><A name="first character"></A>), and if the first character of the text string matches the first character of the regular expression, so far so good; we go on to test whether the next character of the regular expression matches the next character of the text by making a recursive call to <TT>matchhere</TT><A name="call is"></A>. This recursive call is the heart of the algorithm and the reason why the code is so compact and clean.</P>
<P class=docText><A name="these attempts"></A>If all of these attempts to match fail, there can be no match at this point between the regular expression and the text, so <TT>matchhere</TT> returns 0.</P>
<P class=docText>This code uses C <A name=idx-CHP-1-0030></A><A name="call that"></A>pointers intensively. At each stage of the recursion, if something matches, the recursive call that follows uses pointer arithmetic (e.g., <TT>regexp+1</TT> and <TT>text+1</TT><A name="the subsequent"></A>) so that the subsequent function is called with the next character of the regular expression and of the text. The depth of recursion is no more than the length of the pattern, which in normal use is quite short, so there is no danger of running out of space.</P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
