<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 3.5. Conclusion</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>The Most Beautiful Code I Never Wrote</SPAN><SPAN> &gt; Conclusion</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=conclusion-id001></A>
<H3 class=docSection1Title id=-100000>3.5. Conclusion</H3>
<P class=docText><A name="Beauty has"></A>Beauty has many sources. This chapter has concentrated on the beauty conferred by simplicity, elegance, and concision. The following <A name=idx-CHP-3-0145></A><A name="this overarching"></A>aphorisms all express this overarching theme:</P>
<UL>
<LI>
<P class=docList><A name="function by"></A>Strive to add function by deleting code.</P></LI>
<LI>
<P class=docList><A name="knows he"></A>A designer knows he has achieved perfection not when there is nothing left to add, but when there is nothing left to take away. (Saint-Exupéry)</P></LI>
<LI>
<P class=docList><A name="beautiful code"></A>In software, the most beautiful code, the most beautiful functions, and the most beautiful programs are sometimes not there at all.</P></LI>
<LI>
<P class=docList>Vigorous writing is concise. Omit needless words. (Strunk and White)</P></LI>
<LI>
<P class=docList><A name="those that"></A>The cheapest, fastest, and most reliable components of a computer system are those that aren't there. (Bell)</P></LI>
<LI>
<P class=docList><A name="do more"></A>Endeavor to do more and more with less and less.</P></LI>
<LI>
<P class=docList><A name="I would"></A>If I had more time, I would have written you a shorter letter. (Pascal)</P></LI>
<LI>
<P class=docList><A name="may have"></A>The Inventor's Paradox: The more ambitious plan may have more chance of success. (Pólya)</P></LI>
<LI>
<P class=docList><A name="Simplicity does"></A>Simplicity does not precede complexity, but follows it. (Perlis)</P></LI>
<LI>
<P class=docList>Less is more. (Browning)</P></LI>
<LI>
<P class=docList><A name="simple as"></A>Make everything as simple as possible, but no simpler. (Einstein)</P></LI>
<LI>
<P class=docList><A name="be seen"></A>Software should sometimes be seen as a soap bubble. (Perlis)</P></LI>
<LI>
<P class=docList><A name="through simplicity"></A>Seek beauty through simplicity.</P></LI></UL>
<P class=docText><A name="Go thou"></A>Here endeth the lesson. Go thou and do likewise.</P>
<P class=docText>For those who desire more concrete hints, here are some <A name=idx-CHP-3-0146></A>ideas grouped into three main categories.</P>
<DL class=docList>
<DT><BR>
<P><SPAN class=docPubcolor><SPAN class=docEmphasis>Analysis of programs</SPAN> </SPAN></P></DT>
<DD>
<P class=docList><A name="program is"></A>One way to gain insight into the behavior of a program is to instrument it and then run it on representative data, as in <A class=docLink href="021.more_and_more_with_less_and_less.html#quicksort_inner_loop_instrumented_to_count_comparisons">Example 3-2</A><A name="less concerned"></A>. Often, though, we are less concerned with the program as a whole than with individual aspects. In this case, for instance, we considered only the number of comparisons that Quicksort uses on the average and ignored many other aspects. Sedgewick ("The analysis of Quicksort programs," <SPAN class=docEmphasis>Acta Informatica</SPAN><A name="the space"></A>, Vol. 7) studies issues such as the space it requires and many other components of runtime for a variety of Quicksort variants. By concentrating on the key issues, we can ignore (for a while) other aspects of the program. One of my articles, "A Case Study in Applied Algorithm Design" (<SPAN class=docEmphasis>IEEE Computer</SPAN><A name="the problem"></A>, Vol. 17, No. 2) describes how I once faced the problem of evaluating the performance of a <SPAN class=docEmphasis><A name="strip heuristic"></A>strip heuristic</SPAN><A name="approximate travelling"></A> for finding an approximate travelling salesman tour through <TT>N</TT><A name="unit square"></A> points in the unit square. I estimated that a complete program for the task might take 100 lines of code. After a series of steps similar in spirit to what we have seen in this chapter, I used a dozen-line simulation to give much more accuracy (and after completing my little simulation, I found that Beardwood et al. ["The Shortest Path Through Many Points," <SPAN class=docEmphasis>Proc. Cambridge Philosophical Soc.</SPAN><A name="simulation as"></A>, Vol. 55] had re-expressed my simulation as a double integral, and thereby had solved the problem mathematically some two decades earlier).</P></DD>
<DT><BR>
<P><SPAN class=docPubcolor><SPAN class=docEmphasis>Small pieces of code</SPAN> </SPAN></P></DT>
<DD>
<P class=docList><A name="computer programming"></A>I believe that computer programming is a practical skill, and I agree with Pólya that we "acquire any practical skill by imitation and practice." Programmers who long to write beautiful code should therefore read beautiful programs and imitate the techniques they learn as they write their own programs. I find that one of the most useful places to practice is on small code fragments, say of just one or two dozen lines. It was hard work but great fun preparing the second edition of <SPAN class=docEmphasis>Programming Pearls</SPAN><A name="down to"></A>. I implemented every piece of code, and labored to pare each down to its essence. I hope that others enjoy reading the code as much as I enjoyed writing it.</P></DD>
<DT><BR>
<P><SPAN class=docPubcolor><SPAN class=docEmphasis>Software systems</SPAN> </SPAN></P></DT>
<DD>
<P class=docList><A name="have described"></A>For specificity, I have described one tiny task in excruciating detail. I believe that the glory of these principles lies not in tiny code fragments, but rather in large programs and huge computer systems. Parnas ("Designing software for ease of extension and contraction," <SPAN class=docEmphasis>IEEE T. Software Engineering</SPAN><A name="a system"></A>, Vol. 5, No. 2) offers techniques to whittle a system down to its essentials. For immediate applicability, don't forget the deep insight of Tom Duff: "Whenever possible, steal code."</P></DD></DL></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
