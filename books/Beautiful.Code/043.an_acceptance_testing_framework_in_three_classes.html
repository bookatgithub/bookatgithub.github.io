<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 6.1. An Acceptance Testing Framework in Three Classes</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>Framework for Integrated Test: Beauty Through Fragility</SPAN><SPAN> &gt; An Acceptance Testing Framework in Three Classes</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=framework_for_integrated_test_beauty_through_fragility></A>
<H2 class=docChapterTitle id=title-ID0ERYCK>6. Framework for Integrated Test: Beauty Through Fragility</H2>
<P class=docText><SPAN class=docEmphasis><A name="Michael Feathers"></A>Michael Feathers</SPAN> <A name=idx-CHP-6-0279></A></P>
<P class=docText><SPAN class=docEmphSmaller><A name="ideas about"></A>I have some ideas about what good design is</SPAN><A name="all develop"></A>. Every programmer does. We all develop these ideas through practice, and we draw on them as we work. If we're tempted to use a public variable in a class, we remember that public variables are usually a symptom of bad design, and if we see implementation inheritance, we remember that we should prefer delegation to inheritance.<SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-6-FNOTE-1');">[*]</A></SUP></P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-6-FNOTE-1>[*]</A></SUP> <SPAN class=docEmphasis><A name="of Reusable"></A>Design Patterns: Elements of Reusable Object-Oriented Software</SPAN><A name="and John"></A>, Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, Addison-Wesley, 1995.</P></BLOCKQUOTE>
<P class=docText><A name="through the"></A>Rules like these are useful. They help us move our way through the design space as we work, but we do ourselves a disservice if we forget that they are just rules of thumb. If we forget, we can end up with design where we are "doing everything" right, but we still miss the mark.</P>
<P class=docText><A name="were driven"></A>These thoughts were driven home to me back in 2002 when Ward <A name=idx-CHP-6-0280></A><A name="Integrated Test"></A>Cunningham released Framework for Integrated Test (<A name=idx-CHP-6-0281></A><A name="of a"></A>FIT), his automated testing framework. FIT consists of a small set of elegant Java classes. They maneuver in a path around nearly every rule of thumb about design in the Java community, and each little turn that they make is compelling. They stand in stark contrast to design that just follows the rules.</P>
<P class=docText><A name="To me"></A>To me, <A name=idx-CHP-6-0282></A><A name="an invitation"></A>FIT is beautiful code. It's an invitation to think about the contextual nature of design.</P>
<P class=docText><A name="through one"></A>In this chapter, I'll walk through one of the earliest released versions of FIT. I'll show how FIT deviates from much of the current accepted wisdom of Java and OO framework development, and describe how FIT challenged me to reconsider some of my deeply held preconceptions about design. I don't know whether you'll reconsider yours after reading this chapter, but I invite you to look just the same. With luck, I'll be able to express what makes FIT's design special.</P><A name=an_acceptance_testing_framework_in_three_classes></A>
<H3 class=docSection1Title id=-100000>6.1. An Acceptance Testing Framework in Three Classes</H3>
<P class=docText><A name="relatively simple"></A>FIT is relatively simple to explain. It's a little framework that lets you write executable application tests in HTML tables. Each type of table is processed by a programmer-defined class called a fixture. When the framework processes a page of HTML, it creates a fixture object for each table in the page. The fixture uses the table as input to validation code of your choice: it reads cell values, communicates with your application, checks expected values, and marks cells green or red to indicate success or failure of a check.<A name=idx-CHP-6-0283></A></P>
<P class=docText><A name="in the"></A>The first cell in the table specifies the name of the fixture class that will be used to process the table. For instance, <A class=docLink href="javascript:moveTo('html_table_displayed_before_fit_processing');">Figure 6-1</A> shows a table that will be processed by the <TT>MarketEvaluation</TT> fixture. <A class=docLink href="javascript:moveTo('html_table_displayed_after_fit_processing');">Figure 6-2</A><A name="cells would"></A> shows the same table after FIT has processed it; onscreen, the shaded cells would be red to show a validation failure.</P><A name=html_table_displayed_before_fit_processing></A>
<P>
<CENTER>
<H5 class=docFigureTitle><A name="table displayed"></A>Figure 6-1. HTML table displayed before FIT processing</H5><IMG id="" height=138 alt="" src="images/framework_for_integrated_test_beauty_through_fragility.0.png" width=371 border=0> </CENTER>
<P></P><BR><A name=html_table_displayed_after_fit_processing></A>
<P>
<CENTER>
<H5 class=docFigureTitle><A name="after FIT"></A>Figure 6-2. HTML table displayed after FIT processing</H5><IMG id="" height=171 alt="" src="images/framework_for_integrated_test_beauty_through_fragility.1.png" width=399 border=0> </CENTER>
<P></P><BR>
<P class=docText><A name="is that"></A>The key idea behind FIT is that <A name=idx-CHP-6-0284></A><A name="documents can"></A>documents can serve as tests. You could, for instance, embed tables in a requirements document and run the document through FIT to see whether the behavior specified in those tables exists in your software. These documents with tables can be written directly in HTML, or they can be written in Microsoft Word or any other application that can save documents as HTML. Because a FIT fixture is just a piece of software, it can call any portion of an application you care to test, and make those calls at any level. It's all under your control as a programmer.</P>
<P class=docText><A name="more time"></A>I won't spend any more time explaining <A name=idx-CHP-6-0285></A><A name="problem domain"></A>FIT and its problem domain; there's more information on the FIT web site (<A class=docLink href="http://fit.c2.com/" target=_blank>http://fit.c2.com</A><A name="do want"></A>). But I do want to describe the design of FIT and some of the interesting choices it embodies.</P>
<P class=docText><A name="FIT is"></A>The core of FIT is only three classes: <TT>Parse, Fixture</TT>, and <TT>TypeAdapter</TT>. Their fields and methods, and the <A name=idx-CHP-6-0286></A>relationships between them, are shown in <A class=docLink href="javascript:moveTo('relations_among_fit_classes');">Figure 6-3</A>.<A name=idx-CHP-6-0287></A><A name=idx-CHP-6-0288></A></P><A name=relations_among_fit_classes></A>
<P>
<CENTER>
<H5 class=docFigureTitle>Figure 6-3. Relations among FIT classes</H5><IMG id="" height=328 alt="" src="images/framework_for_integrated_test_beauty_through_fragility.2.png" width=500 border=0> </CENTER>
<P></P><BR>
<P class=docText>Let's walk through it.</P>
<P class=docText>In a nutshell, the <TT>Parse</TT> class represents the HTML of a document. The constructor of <TT>Parse</TT> accepts a string and recursively constructs a tree of <TT>Parse</TT> objects, knit together using the fields <TT>parts</TT> and <TT>more</TT>. Each <TT>Parse</TT> object represents some portion of the document: there's an individual <TT>Parse</TT> for each table, row, and cell.</P>
<P class=docText>The <TT>Fixture</TT> class traverses the tree of parses, and <TT>TypeAdapter</TT><A name="the application"></A> converts testing values (numerics, dates, etc.) to text and back again. Fixtures talk to the application you are testing and mark individual cells red or green if a check passes or fails.</P>
<P class=docText><A name="the work"></A>Most of the work in FIT happens in subclasses of the <TT>Fixture</TT><A name="of the"></A> class. Fixtures define the format of the HTML tables they interpret. If you want to create a table that consists of, say, a series of commands to execute against your application, you use the predefined <TT>ActionFixture</TT><A name="your application"></A> class. If you want to query your application for multiple results and compare them against a set of expected values, you use the <TT>RowFixture</TT><A name="FIT provides"></A> class. FIT provides these simple subclasses, but it also allows you to subclass <TT>Fixture</TT> yourself.<A name=idx-CHP-6-0289></A><A name=idx-CHP-6-0290></A></P>
<P class=docText><A name="useful framework"></A>FIT is a useful framework. I use it often, and I'm continually amazed at what you can do with that core of three classes. Many frameworks would take three or four times as many classes to do the same amount of work.</P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
