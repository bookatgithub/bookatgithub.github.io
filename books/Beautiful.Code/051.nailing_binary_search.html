<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 7.3. Nailing Binary Search</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>Beautiful Tests</SPAN><SPAN> &gt; Nailing Binary Search</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=nailing_binary_search></A>
<H3 class=docSection1Title id=-100000>7.3. Nailing Binary Search</H3>
<P class=docText><A name="Given its"></A>Given its history, I am not going to be fooled by the apparent simplicity of binary search, or by the obviousness of the fix, especially because I've never used the unsigned bit shift operator (i.e., &gt;&gt;&gt;) in any other code. I am going to test this <SPAN class=docEmphasis>fixed</SPAN><A name="search as"></A> version of binary search as if I had never heard of it before, nor implemented it before. I am not going to trust anyone's word, or tests, or proofs, that this time it will really work. I want to be confident that it works as it should through my own <A name=idx-CHP-7-0334></A>testing. I want to <SPAN class=docEmphasis>nail</SPAN> it.<A name=idx-CHP-7-0335></A></P>
<P class=docText>Here's my initial <A name=idx-CHP-7-0336></A><A name="of tests"></A>testing strategy (or team of tests):</P>
<UL>
<LI>
<P class=docList>Start with <SPAN class=docEmphasis>smoke tests</SPAN>.<A name=idx-CHP-7-0337></A></P></LI>
<LI>
<P class=docList>Add some <SPAN class=docEmphasis>boundary value</SPAN> tests.<A name=idx-CHP-7-0338></A></P></LI>
<LI>
<P class=docList><A name="various thorough"></A>Continue with various thorough and exhaustive types of tests.</P></LI>
<LI>
<P class=docList>Finally, add some <SPAN class=docEmphasis>performance</SPAN> tests.</P></LI></UL>
<P class=docText><A name=idx-CHP-7-0339></A><A name="a linear"></A>Testing is rarely a linear process. Instead of showing you the finished set of tests, I am going to walk you through my thought processes while I am working on the tests.</P><A name=smoking_allowed_and_encouraged></A>
<H4 class=docSection2Title id=title-ID0E34CK>7.3.1. Smoking Allowed (and Encouraged)</H4>
<P class=docText>Let's get started with the <A name=idx-CHP-7-0340></A><A name="does the"></A>smoke tests. These are designed to make sure that the code does the right thing when used in the most basic manner. They are the first line of defense and the first tests that should be written, because if an implementation does not pass the <A name=idx-CHP-7-0341></A><A name="testing is"></A>smoke tests, further testing is a waste of time. I often write the smoke tests before I write the code; this is called <SPAN class=docEmphasis>test-driven development</SPAN> (or <SPAN class=docEmphasis>TDD</SPAN>).</P>
<P class=docText>Here's my smoke test for <A name=idx-CHP-7-0342></A>binary search:</P><PRE>	import static org.junit.Assert.*;
	import org.junit.Test;

	public class BinarySearchSmokeTest {

	@Test
	public void smokeTestsForBinarySearch() {

	    int[] arrayWith42 = new int[] { 1, 4, 42, 55, 67, 87, 100, 245 };
	    assertEquals(2, Util.binarySearch(arrayWith42, 42));
	    assertEquals(-1, Util.binarySearch(arrayWith42, 43));

	    }

	}
</PRE><BR>
<P class=docText><A name="test is"></A>As you can tell, this test is really, <SPAN class=docEmphasis>really</SPAN><A name="by itself"></A>, basic. Not a huge confidence builder by itself, but still beautiful because it's a very fast and efficient first step toward more thorough tests.</P>
<P class=docText><A name="Because this"></A>Because this smoke test executes extremely fast (in less than 1/100<SUP>th</SUP><A name="on my"></A> of a second on my system), you might ask why I didn't include a few more tests. The answer is that part of the beauty of smoke tests is that they can continue to pay dividends after the bulk of the development is done. To reconfirm my confidence in the code—call it "confidence maintenance"—I like to combine all smoke tests into a suite that I run every time I do a new build (which might be dozens of times a day), and I want this smoke test suite to run fast—ideally in a minute or two. If you have thousands of classes, and thousands of smoke tests, it's essential to keep each one to a bare minimum.</P><A name=pushing_the_boundaries></A>
<H4 class=docSection2Title id=title-ID0ES6CK>7.3.2. Pushing the Boundaries</H4>
<P class=docText><A name=boundary></A>As the name implies, boundary <A name=idx-CHP-7-0343></A><A name="designed to"></A>testing is designed to explore and validate what happens when the code has to deal with extremes and corner cases. In the case of <A name=idx-CHP-7-0344></A><A name="parameters are"></A>binary search, the two parameters are the <A name=idx-CHP-7-0345></A><A name="each of"></A>array and the target value. Let's think of some boundary cases for each of these parameters.<SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-7-FNOTE-6');">[#]</A></SUP></P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-7-FNOTE-6>[#]</A></SUP><A name=for></A> The specification for <A name=idx-CHP-7-0346></A><A name="the array"></A>binary search says that the array <SPAN class=docEmphasis>must</SPAN><A name="this call"></A> be sorted prior to making this call, and that if it is not sorted, the results are undefined. We are also assuming that a null array parameter should throw a <TT>NullPointerException</TT><A name="Because most"></A>. Because most readers should already be familiar with basic boundary <A name=idx-CHP-7-0347></A><A name="going to"></A>testing techniques, I am going to skip some of those obvious tests.</P></BLOCKQUOTE>
<P class=docText><A name="of interesting"></A>The first set of interesting corner cases that come to mind has to do with the size of the array being searched. I begin with the following basic boundary tests:</P><PRE>	int[] testArray;

	@Test
	public void searchEmptyArray() {
	    testArray = new int[] {};
	    assertEquals(-1, Util.binarySearch(testArray, 42));
	}

	@Test
	public void searchArrayOfSizeOne() {
	    testArray = new int[] { 42 };
	    assertEquals(0, Util.binarySearch(testArray, 42));
	    assertEquals(-1, Util.binarySearch(testArray, 43));
	}
</PRE><BR>
<P class=docText><A name="that an"></A>It's pretty clear that an empty array is a good boundary case, and so is an array of size 1 because it's the smallest nonempty array. Both of these tests are beautiful because they increase my confidence that the right thing happens at the lower boundary of array size.</P>
<P class=docText><A name="want to"></A>But I also want to test the search with a very large array, and this is where it gets interesting (especially with the hindsight knowledge that the bug manifests itself only on arrays with over one billion elements).</P>
<P class=docText><A name="to ensure"></A>My first thought is to create an array large enough to ensure that the integer-overflow bug has been fixed, but I immediately recognize a testability issue: my laptop does not have enough resources to create an array that large in memory. But I know that there are systems that <SPAN class=docEmphasis>do</SPAN><A name="gigabytes of"></A> have many gigabytes of memory and keep large arrays in memory. I want to make sure, one way or another, that the <TT>mid</TT><A name="in those"></A> integer does not overflow in those cases.</P>
<P class=docText>What can I do?</P>
<P class=docText><A name="time I"></A>I know that by the time I am done with some of the other tests I have in mind, I will have enough tests to give me confidence that the basic algorithm and implementation works <SPAN class=docEmphasis><A name="provided that"></A>provided that the midpoint is calculated correctly and does not overflow into a negative number</SPAN><A name="my reasoning"></A>. So, here's a summary of my reasoning, leading to a possible testing strategy for enormous arrays:<A name=idx-CHP-7-0348></A></P>
<DIV style="FONT-WEIGHT: bold">
<OL class=docList type=1>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList>I cannot test <TT>binarySearch</TT> directly with <A name=idx-CHP-7-0349></A><A name="to verify"></A>arrays large enough to verify that the overflow bug in the calculation of <TT>mid</TT><A name="occur anymore"></A> does not occur anymore.</P></DIV></LI>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList>However, I <SPAN class=docEmphasis>can</SPAN><A name="to give"></A> write enough tests to give me confidence that my <TT>binarySearch</TT> implementation works correctly on smaller arrays.</P></DIV></LI>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList>I can also test the way <SPAN class=docEmphasis>mid</SPAN> is calculated when very large values are used, without getting arrays involved.</P></DIV></LI>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList>So, if I can gain enough confidence through <A name=idx-CHP-7-0350></A>testing that:</P>
<UL>
<LI>
<P class=docList>My implementation of the basic <TT>binarySearch</TT> algorithm is sound as long as <TT>mid</TT> is calculated correctly, and</P></LI>
<LI>
<P class=docList>The way the midpoint is calculated is correct</P></LI></UL>
<P class=docList>then I can have confidence that <TT>binarySearch</TT> will do the right thing on very large arrays.</P></DIV></LI></OL></DIV>
<P class=docText>So the not-so-obvious, but beautiful, <A name=idx-CHP-7-0351></A>testing strategy is to isolate and test the pesky, overflow-prone calculation independently.</P>
<P class=docText>One possibility is to create a new method:</P><PRE>	static int calculateMidpoint(int low, int high) {
	    return (low + high) &gt;&gt;&gt; 1;
	}
</PRE><BR>
<P class=docText>then change the following line in the code from:</P><PRE>	int mid = (low + high) &gt;&gt;&gt; 1;
</PRE><BR>
<P class=docText>to:</P><PRE>	int mid = calculateMidpoint(low, high);
</PRE><BR>
<P class=docText>and then test the heck out of the <TT>calculateMidpoint</TT> method to make sure it always does the right thing.</P>
<P class=docText><A name="adding the"></A>I can already hear a few of you screaming about adding the overhead of a method call in an algorithm designed for maximum speed. But there's no need to cry foul. Here's why I believe this change to the code is not only acceptable, but the right thing to do:</P>
<DIV style="FONT-WEIGHT: bold">
<OL class=docList type=1>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList><A name="can trust"></A>These days, I can trust compiler optimization to do the right thing and inline the method for me, so there is no performance penalty.</P></DIV></LI>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList><A name="code more"></A>The change makes the code more readable. I checked with several other Java programmers, and most of them were not familiar with the unsigned bit shift operator, or were not 100 percent sure how it worked. For them, seeing <TT>calculateMidpoint(low, high</TT>) is more obvious than seeing (<TT>low + high) &gt;&gt;&gt; 1</TT>.</P></DIV></LI>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList><A name="more testable"></A>The change makes the code more testable.</P></DIV></LI></OL></DIV>
<P class=docText><A name="This is"></A>This is actually a good example of how the very act of creating a test for your code will improve its design or legibility. In other words, testing can help you make your code more beautiful.</P>
<P class=docText><A name="sample boundary"></A>Here is a sample boundary test for the new <TT>calculateMidpoint</TT> method:</P><PRE>	@Test
	public void calculateMidpointWithBoundaryValues(<A name=idx-CHP-7-0352></A>) {
	    assertEquals(0, calculateMidpoint (0, 1));
	    assertEquals(1, calculateMidpoint (0, 2));
	    assertEquals(1200000000, calculateMidpoint (1100000000, 1300000000));
	    assertEquals(Integer.MAX_VALUE - 2,
	        calculateMidpoint (Integer.MAX_VALUE-2, Integer.MAX_VALUE-1));
	    assertEquals(Integer.MAX_VALUE - 1,
	        calculateMidpoint (Integer.MAX_VALUE-1, Integer.MAX_VALUE));
	}
</PRE><BR>
<P class=docText><A name="and they"></A>I run the tests, and they pass. Good. I am now confident that calculating <TT>mid</TT><A name="unfamiliar operator"></A> using the unfamiliar operator does what it's supposed to do within the range of <A name=idx-CHP-7-0353></A><A name="want to"></A>array sizes I want to handle with this implementation of <A name=idx-CHP-7-0354></A>binary search.</P>
<P class=docText><A name="the position"></A>The other set of boundary cases has to do with the position of the target number. I can think of three obvious boundary cases for the <A name=idx-CHP-7-0355></A><A name="first item"></A>target item location: first item in the list, last item in the list, and right smack in the middle of the list. So, I write a simple test to check these cases:</P>
<DIV class=codeSegmentsExpansionLinks>Code View: <SPAN>Scroll</SPAN> / <A href="javascript:expandCodeSegments()">Show All</A></DIV><PRE class=preFixedWidth>	@Test
	public void testBoundaryCasesForItemLocation() {
	    testArray = new int[] { -324, -3, -1, 0, 42, 99, 101 };
	    assertEquals(0, Util.binarySearch(testArray, -324));  // first position
	    assertEquals(3, Util.binarySearch(testArray, 0));      // middle position
	    assertEquals(6, Util.binarySearch(testArray, 101));   // last position
	}


					    </PRE><BR>
<P class=docText><A name="test I"></A>Note that in this test I used some negative numbers and 0, both in the array and for the target number. It had occurred to me, while reading the tests I had already written, that I had used only positive numbers. Since that's not part of the specification, I should introduce negative numbers and 0 in my tests. Which leads me to the following piece of <A name=idx-CHP-7-0356></A>testing wisdom:</P>
<BLOCKQUOTE>
<P class=docText><A name="of more"></A>The best way to think of more test cases is to start writing <SPAN class=docEmphasis>some</SPAN><A name="test cases"></A> test cases.</P></BLOCKQUOTE>
<P class=docText><A name="started to"></A>Now that I started to think about positive/negative numbers and 0, I realize that it would be good to have a couple of tests that use the minimum and maximum integer values.<A name=I_indexterm7_tt79></A></P><PRE>	public void testForMinAndMaxInteger() {
	    testArray = new int[] {
	      Integer.MIN_VALUE, -324, -3, -1, 0, 42, 99, 101, Integer.MAX_VALUE
	    };
	    assertEquals(0, Util.binarySearch(testArray, Integer.MIN_VALUE));
	    assertEquals(8, Util.binarySearch(testArray, Integer.MAX_VALUE));
	}
</PRE><BR>
<P class=docText><A name="boundary cases"></A>So far, all the boundary cases I thought of passed, and I am starting to feel pretty confident. But then I think of the 90 percent of professional programmers in Jon Bentley's class who implemented <A name=idx-CHP-7-0357></A><A name="and thought"></A>binary search and thought they had it right but didn't, and my confidence begins to wane a little bit. Did I make any unwarranted assumptions about the inputs? I did not think about negative numbers and 0 until this last test case. What other unwarranted assumptions have I made? Because I handcrafted the tests, perhaps I subconsciously created cases that would work and missed ones that would fail.</P>
<P class=docText><A name="known problem"></A>This is a known problem with programmers <A name=idx-CHP-7-0358></A><A name=implementing></A>testing their own code. If they can't think of some scenarios when implementing <A name=idx-CHP-7-0359></A><A name="that they"></A>the code, it's likely that they will not be able to think of them when they switch context and try to <SPAN class=docEmphasis>break</SPAN> the code. Truly beautiful <A name=idx-CHP-7-0360></A><A name="to make"></A>testing requires a developer to make an extra effort, think outside the box, explore weird scenarios, look for weaknesses, and try to break things.</P>
<P class=docText><A name="test and"></A>So, what haven't I thought of? My smoke test and <A name=idx-CHP-7-0361></A><A name="boundary tests"></A>boundary tests do not feel sufficient. Is my test set representative enough that I can, through some form of induction,<SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-7-FNOTE-7');">[**]</A></SUP><A name="will work"></A> claim the code will work in all instances? The words of Joshua Bloch echo in my mind: <SPAN class=docEmphasis><A name="write even"></A>"…It is hard to write even the smallest piece of code correctly."</SPAN></P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-7-FNOTE-7>[**]</A></SUP> By <SPAN class=docEmphasis>induction</SPAN><A name="deriving general"></A>, I mean deriving general <A name=idx-CHP-7-0362></A><A name="facts or"></A>principles from particular facts or instances.</P></BLOCKQUOTE>
<P class=docText><A name="that my"></A>What kind of tests would make me feel confident enough that my implementation will do the right thing with all sorts of inputs—not just the ones I handcrafted?</P><A name=random_acts_of_testing></A>
<H4 class=docSection2Title id=title-ID0EXKDK>7.3.3. Random Acts of Testing</H4>
<P class=docText><A name="written traditional"></A>So far I've written traditional, tried-and-true types of tests. I used a few concrete examples to test the search code against my expectations of what the correct behavior should be in those cases. Those tests all pass, so I have <SPAN class=docEmphasis>some</SPAN><A name="my code"></A> level of confidence in my code. But I also realize that my tests are very specific and cover only a very small subset of all the possible inputs. What I would like, and what would help me sleep at night knowing my code has been thoroughly covered, is a way of testing over a much broader set of inputs. For this to happen I need two things:<A name=idx-CHP-7-0363></A></P>
<DIV style="FONT-WEIGHT: bold">
<OL class=docList type=1>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList><A name="large and"></A>A way to generate a large and diverse set of inputs</P></DIV></LI>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList><A name="A set"></A>A set of generalized assertions that will work on any input</P></DIV></LI></OL></DIV>
<P class=docText>Let's tackle the first requirement.</P>
<P class=docText><A name="here is"></A>What I need here is a way to generate arrays of integers of all shapes and sizes. The only requirement I am going to make is that the resulting arrays are sorted, because that's a precondition. Other than that, anything goes. Here's my initial implementation of the generator:<SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-7-FNOTE-8');">[<IMG alt=dagger src="images/U2020.GIF"><IMG alt=dagger src="images/U2020.GIF">]</A></SUP><A name=I_indexterm7_tt81></A></P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-7-FNOTE-8>[<IMG alt=dagger src="images/U2020.GIF"><IMG alt=dagger src="images/U2020.GIF">]</A></SUP> I say <SPAN class=docEmphasis>initial</SPAN><A name="quickly realized"></A> implementation because I quickly realized that I needed to populate the array with negative as well as positive numbers, and changed the generator accordingly.</P></BLOCKQUOTE><PRE>	public int[] generateRandomSortedArray(int maxArraySize, int maxValue) {
	    int arraySize = 1 + rand.nextInt(maxArraySize);
	    int[] randomArray = new int[arraySize];
	    for (int i = 0; i &lt; arraySize; i++) {
	        randomArray[i] = rand.nextInt(maxValue);
	    }
	    Arrays.sort(randomArray);
	    return randomArray;
	}
</PRE><BR>
<P class=docText><A name="I take"></A>For my generator, I take advantage of <TT>java.util</TT>'s <A name=idx-CHP-7-0364></A>random-number generator and <TT>Arrays</TT><A name="contained the"></A> utilities. The latter once contained the very same binary-search bug Joshua Bloch mentioned in his blog, but it's fixed in the version of Java I am using. Because I already covered the handling of empty arrays to my satisfaction in my other tests, I use a minimum array size here of 1. The generator is parameterized because I might want to create different sets of tests as I go along: some with small arrays containing big numbers, some with big arrays and small numbers, and so on.</P>
<P class=docText><A name="about the"></A>Now I have to come up with some general statements about the desired behavior of the <A name=idx-CHP-7-0365></A><A name="that can"></A>binary search that can be expressed as assertions. By "general," I mean statements that must hold true for any input array and target value. My colleagues Marat Boshernitsan and David Saff call these <SPAN class=docEmphasis>theories</SPAN><A name="we have"></A>. The idea is that we have a theory of how the code should behave, and the more we test the theory, the more confident we can be that what we theorize is actually true. In the following example, I am going to apply a much simplified version of Saff and Boshernitsan's theories.</P>
<P class=docText><A name="some theories"></A>Let's try to come up with some theories for <TT>binarySearch</TT><A name="Here we"></A>. Here we go:</P>
<BLOCKQUOTE>
<P class=docText><A name=of></A>For all instances of <TT><I>testArray</I></TT> and <TT><I>target</I></TT>, where <TT><I>testArray</I></TT><A name="array of"></A> is a sorted array of integers and is not null, and <TT><I>target</I></TT><A name="the following"></A> is an integer, the following must always be true of <TT>binarySearch</TT>:</P>
<P class=docText>Theory 1:<SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-7-FNOTE-9');">[<IMG alt="double dagger" src="images/U2021.GIF"><IMG alt="double dagger" src="images/U2021.GIF">]</A></SUP> If <TT>binarySearch</TT>(<TT><I>testArray, target</I></TT>) returns -1, then <TT><I>testArray</I></TT> does not contain <TT><I>target</I></TT>.</P>
<P class=docText>Theory 2: If <TT>binarySearch</TT>(<TT><I>testArray, target</I></TT>) returns <TT><I>n</I></TT>, and <TT><I>n</I></TT><A name="or equal"></A> is greater than or equal to 0, then <TT><I>testArray</I></TT> contains <TT><I>target</I></TT> at position <TT><I>n</I></TT>.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-7-FNOTE-9>[<IMG alt="double dagger" src="images/U2021.GIF"><IMG alt="double dagger" src="images/U2021.GIF">]</A></SUP><A name="such as"></A> In practice I would use, and recommend using, descriptive names for the theories, such as: <SPAN class=docEmphasis>binary-SearchReturnsMinusOneImpliesArrayDoesNotContainElement</SPAN><A name="found that"></A>, but I found that for this chapter, the reasoning is easier to follow if I use Theory1, Theory2, etc.</P></BLOCKQUOTE></BLOCKQUOTE>
<P class=docText>Here's my code for <A name=idx-CHP-7-0366></A>testing these two theories:</P>
<DIV class=codeSegmentsExpansionLinks>Code View: <SPAN>Scroll</SPAN> / <A href="javascript:expandCodeSegments()">Show All</A></DIV><PRE class=preFixedHeight>	public class BinarySearchTestTheories {

	<A name=idx-CHP-7-0367></A>Random rand;

	@Before
	public void initialize() {
	    rand = new Random();
	}

	@Test
	public void testTheories() {

	    int maxArraySize = 1000;
	    int maxValue = 1000;
	    int experiments = 1000;
	    int[] testArray;
	    int target;
	    int returnValue;

	    while (experiments-- &gt; 0) {
	        testArray = generateRandomSortedArray(maxArraySize, maxValue);<A name=idx-CHP-7-0368></A>
	        if (rand.nextBoolean()) {
	            target = testArray[rand.nextInt(testArray.length)];
	        } else {
	            target = rand.nextInt();
	        }
	        returnValue = Util.<A name=idx-CHP-7-0369></A>binarySearch(testArray, target);
	        assertTheory1(testArray, target, returnValue);
	        assertTheory2(testArray, target, returnValue);
	    }
	}

	public void assertTheory1(int[] testArray, int target, int returnValue) {
	    if (returnValue == -1)
	        assertFalse(arrayContainsTarget(testArray, target));
	}

	public void assertTheory2(int[] testArray, int target, int returnValue) {
	    if (returnValue &gt;= 0)
	        assertEquals(target, testArray[returnValue]);
	}

	public boolean arrayContainsTarget(int[] testArray, int target) {
	    for (int i = 0; i &lt; testArray.length; i++)
	        if (testArray[i] == target)
	            return true;
	    return false;
	}


					    </PRE><BR>
<P class=docText>In the main test method, <TT>testTheories</TT><A name="experiments I"></A>, I decide how many experiments I want to run in order to confirm the theories, and use that as my loop counter. Inside the loop, the random-array generator I just wrote gives me a sorted array. I want to test both successful and unsuccessful searches, so I use Java's random number generator again to "toss a coin" (through the <TT>rand.nextBoolean()</TT><A name="I decide"></A> code). Based on the virtual coin toss, I decide whether I am going to pick a target number that I <SPAN class=docEmphasis>know</SPAN><A name="is in"></A> is in the array or one that's unlikely to be in the array. Finally, I call <TT>binarySearch</TT><A name="and invoke"></A>, store the return value, and invoke the methods for the theories I have so far.</P>
<P class=docText><A name="to implement"></A>Notice that, in order to implement the tests for my theories, I had to write a test helper method, <TT>arrayContainsTarget</TT><A name="me an"></A>, that gives me an alternative way of checking whether <TT>testArray</TT><A name="This is"></A> contains the target element. This is a common practice for this type of <A name=idx-CHP-7-0370></A><A name="similar to"></A>testing. Even though the implementation of this helper method provides functionality similar to <TT>binarySearch</TT><A name="simpler "></A>, it's a much simpler (albeit much slower) search implementation. I have confidence that the helper does the right thing, so I can use it to test an implementation I am much less sure about.</P>
<P class=docText><A name="experiments on"></A>I start by running 1,000 experiments on arrays of size up to 1,000. The tests take a fraction of a second, and everything passes. Good. Time to explore a little more (remember that <A name=idx-CHP-7-0371></A>testing is an exploratory activity).</P>
<P class=docText>I change the experiment and <TT>maxArraySize</TT><A name="now take"></A> values to 10,000, then 100,000. The tests now take closer to a minute, and my CPU maxes out. I feel like I am giving the code a really good workout.</P>
<P class=docText><A name="My confidence"></A>My confidence is building, but one of my beliefs is: <SPAN class=docEmphasis><A name="tests pass"></A>If all your tests pass, chances are that your tests are not good enough</SPAN><A name="should I"></A>. What other properties should I test now that I have this framework?</P>
<P class=docText><A name="for a"></A>I think for a bit and notice that my two theories are both of the form:</P>
<BLOCKQUOTE>
<P class=docText><A name="true about"></A>If something is true about the return value of <TT>binarySearch</TT>, then something else must be true about the <TT>testArray</TT> and the <TT>target</TT>.</P></BLOCKQUOTE>
<P class=docText>In other words, I have logic of the form <SPAN class=docEmphasis>p</SPAN> implies <SPAN class=docEmphasis>q</SPAN> (or, <SPAN class=docEmphasis>p</SPAN> <IMG alt="rightwards double arrow" src="images/U2192.GIF"> <SPAN class=docEmphasis>q</SPAN>, using logic notation), which means I am only <A name=idx-CHP-7-0372></A>testing half of what I should be <A name=idx-CHP-7-0373></A>testing. I should also have tests of the form <SPAN class=docEmphasis>q</SPAN> <IMG alt="rightwards double arrow" src="images/U2192.GIF"> <SPAN class=docEmphasis>p</SPAN>:<SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-7-FNOTE-10');">[§§]</A></SUP></P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-7-FNOTE-10>[§§]</A></SUP> Of course, either <SPAN class=docEmphasis>p, q</SPAN>, or both, could be negated (e.g., <SPAN class=docEmphasis>~p <IMG alt="rightwards double arrow" src="images/U2192.GIF">~q</SPAN>, or <SPAN class=docEmphasis>p <IMG alt="rightwards double arrow" src="images/U2192.GIF">~q</SPAN>). I am arbitrarily using <SPAN class=docEmphasis>p</SPAN> and <SPAN class=docEmphasis>q</SPAN><A name="array parameter"></A> as stand-ins for any predicate about the return value and the array parameter, respectively. What's important here is to recognize that when you are programming, you typically think in terms of <SPAN class=docEmphasis>p <IMG alt="rightwards double arrow" src="images/U2192.GIF"> q</SPAN> (if <SPAN class=docEmphasis>p</SPAN> is true, then <SPAN class=docEmphasis>q</SPAN> must happen—the so-called <SPAN class=docEmphasis>happy path</SPAN><A name="common usage"></A>: the normal, most common usage of the code). When you are testing, however, you must force yourself to think both backward (<SPAN class=docEmphasis>q <IMG alt="rightwards double arrow" src="images/U2192.GIF"> ?</SPAN>, or if <SPAN class=docEmphasis>q</SPAN><A name="be true"></A> is true what must be true about <SPAN class=docEmphasis>p</SPAN><A name="is not"></A>?), and in negative terms (if p is not true [i.e., <SPAN class=docEmphasis>~p</SPAN><A name="what must"></A>], what must be true about <SPAN class=docEmphasis>q</SPAN>?).</P></BLOCKQUOTE>
<BLOCKQUOTE>
<P class=docText><A name="true about"></A>If something is true about the <TT>testArray</TT> and the <TT>target</TT><A name="must be"></A>, then something else must be true about the return value.</P></BLOCKQUOTE>
<P class=docText><A name="a bit"></A>This is a bit tricky, but important, so let me clarify with some specifics. The tests for Theory 1 verify that when the return value is -1, the target element is not in the array. But they don't verify that when the target element is not in the array, the return value is -1. In other words: <SPAN class=docEmphasis><A name="had this"></A>if I only had this one theory with which to test</SPAN>, an implementation that returned -1 sometimes, but not <SPAN class=docEmphasis>every</SPAN><A name="exists with"></A> time it should, would still pass all my tests. A similar problem exists with Theory 2.</P>
<P class=docText><A name="demonstrate this"></A>I can demonstrate this with <SPAN class=docEmphasis>mutation testing</SPAN>, a technique for <SPAN class=docEmphasis>testing the tests</SPAN><A name="basic idea"></A> invented by Jeff Offut. The basic idea is to mutate the code under tests with some known bugs. If the tests you have still pass despite the bug in the code, then the tests are probably not as thorough as they need to be.</P>
<P class=docText>Let me mutate <TT>binarySearch</TT><A name="try do"></A> in some drastic and arbitrary way. I'll try do this: if <TT>target</TT><A name="is greater"></A> is greater than 424242 and <TT>target</TT><A name="in the"></A> is not contained in the array, instead of returning -1, I am going to return <SPAN class=docEmphasis>-42</SPAN><A name="See the"></A>. How's that for software vandalism? See the tail end of the following code:</P><PRE>	public static int <A name=idx-CHP-7-0374></A>binarySearch(int[] a, int target) {
	    int low = 0;
	    int high = a.length - 1;

	    while (low &lt;= high) {
	        int mid = (low + high) / 2;
	        int midVal = a[mid];

	        if (midVal &lt; target)
	            low = mid + 1;
	        else if (midVal &gt; target)
	            high = mid - 1;
	        else
	            return mid;
	    }
	    if (target &lt;= 424242)
	        return -1;
	    else
	        return -42;
	}
</PRE><BR>
<P class=docText><A name="this is"></A>Hopefully, you'll agree that this is a pretty big mutation: the code returns an unexpected and unspecified value if the target is a number greater than 424242 and is not contained in the array. And yet, all the tests we have written so far pass with flying colors.</P>
<P class=docText><A name="to add"></A>We definitely need to add at least a couple more theories to make the tests tighter and catch this category of mutations:</P>
<BLOCKQUOTE>
<P class=docText>Theory 3: If <TT><I>testArray</I></TT> does not contain <TT><I>target</I></TT>, then it must return <TT>-1</TT>.</P>
<P class=docText>Theory 4: If <TT><I>testArray</I></TT> contains <TT><I>target</I></TT> at position <TT><I>n</I></TT>, then <TT>binarySearch</TT> <TT><I>(testArray, target</I></TT>) must return <TT><I>n</I></TT>.</P></BLOCKQUOTE>
<P class=docText>These theories are tested as follows:</P><PRE>	public void assertTheory3(int[] testArray, int target, int returnValue) {
	    if (!arrayContainsTarget(testArray, target))
	        assertEquals(-1, returnValue);
	}

	public void assertTheory4(int[] testArray, int target, int returnValue) {
	        assertEquals(getTargetPosition(testArray, target), returnValue);
	}

	public int getTargetPosition(int[] testArray, int target) {
	    for (int i = 0; i &lt; testArray.length; i++)
	        if (testArray[i] == target)
	            return i;
	    return -1;
	}
</PRE><BR>
<P class=docText>Notice that I had to create another helper method, <TT>getTargetPosition</TT>, which has exactly the same behavior as <TT>binarySearch</TT><A name="that it"></A> (but I am confident that it works properly, with the huge downside that it requires up to <SPAN class=docEmphasis>n</SPAN> instead of log<SUB>2</SUB> <SPAN class=docEmphasis>n</SPAN> comparisons). Because <TT>getTargetPosition</TT><A name="similar to"></A> is very similar to <TT>arrayContainsTarget</TT><A name="I rewrite"></A>, and code duplication is bad, I rewrite the latter as follows:</P><PRE>	public boolean arrayContainsTarget(int[] testArray, int target) {
	    return getTargetPosition(testArray, target) &gt;= 0;
	}
</PRE><BR>
<P class=docText><A name="with my"></A>I run these tests again with my <A name=idx-CHP-7-0375></A><A name="and now"></A>random-array generator, and now the <TT>return-42</TT><A name="that helps"></A> mutation is caught immediately. Good, that helps my confidence. I remove the intentional bug and run the tests again. I expect them to pass, but they don't. Some tests for Theory 4 are not passing. JUnit is failing with messages of the form:</P><PRE>	expected:&lt;n&gt; but was:&lt;n + 1&gt;
</PRE><BR>
<P class=docText>Theory 4 says that:</P>
<BLOCKQUOTE>
<P class=docText>If <TT><I>testArray</I></TT> contains <TT><I>target</I></TT> at position <TT><I>n</I></TT>, then <TT>binarySearch</TT>(<TT><I>testArray, target</I></TT>) must return <TT><I>n</I></TT>.<A name=idx-CHP-7-0376></A></P></BLOCKQUOTE>
<P class=docText><A name="search routine"></A>So, in some cases, the search routine is returning a location that's off by one. How's that possible?</P>
<P class=docText><A name="a bit"></A>I need a bit more data. JUnit's assertions can accept a message of type <TT>String</TT><A name="so I"></A> as the first parameter, so I change Theory 4's <TT>assertEqual</TT><A name="when it"></A> to include some text that will give me more information when it fails:</P>
<DIV class=codeSegmentsExpansionLinks>Code View: <SPAN>Scroll</SPAN> / <A href="javascript:expandCodeSegments()">Show All</A></DIV><PRE class=preFixedWidth>	public void assertTheory4(int[] testArray, int target, int returnValue) {
	  String testDataInfo = "Theory 4 - Array=" +
	        printArray(testArray)
	        + " target="
	        + target;
	  assertEquals(testDataInfo, getTargetPosition(testArray, target), returnValue);
	}


					    </PRE><BR>
<P class=docText><A name="fails to"></A>Now, whenever Theory 4 fails to hold, JUnit will show me the contents of the array as well as the target value. I run the tests again (with small values of <TT>maxArraySize</TT> and <TT>maxValue</TT><A name="easier to"></A> to make the output easier to read) and get the following:</P>
<DIV class=codeSegmentsExpansionLinks>Code View: <SPAN>Scroll</SPAN> / <A href="javascript:expandCodeSegments()">Show All</A></DIV><PRE class=preFixedWidth>	java.lang.AssertionError: Theory 4 - Array=[2, 11, 36, 66, 104, 108, 108, 108, 122,
	155, 159, 161, 191] target=108 expected:&lt;5&gt; but was:&lt;6&gt;


					    </PRE><BR>
<P class=docText><A name="take into"></A>I see what's happening. Theory 4 does not take into account duplicate values, and I hadn't thought of that. There are three instances of the number 108. I guess I need to find out what the specification is for handling duplicate values, and fix either the code or my theory and tests. But I'll leave this as an exercise to the reader (I always wanted to say that!) because I am running out of space, and I want to say a few words about performance tests before we wrap up this chapter.</P><A name=performance_anxiety></A>
<H4 class=docSection2Title id=title-ID0EOZDK>7.3.4. Performance Anxiety</H4>
<P class=docText><A name="The tests"></A>The tests we've already run based on these theories put a pretty tight net around the implementation. It's going to be tough to pass all these tests and still have a buggy implementation. But there is something we overlooked. All the tests we have are good tests for search, but what we are <A name=idx-CHP-7-0377></A><A name=a></A>testing is specifically a <SPAN class=docEmphasis>binary</SPAN><A name="set of"></A> search. We need a set of tests for <SPAN class=docEmphasis>binary-ness</SPAN><A name="to see"></A>. We need to see whether the number of <A name=idx-CHP-7-0378></A><A name="performs matches"></A>comparisons our implementation performs matches the expectations of a maximum of log<SUB>2</SUB> <SPAN class=docEmphasis>n</SPAN> comparisons. How can we go about this?<A name=idx-CHP-7-0379></A><A name=idx-CHP-7-0380></A></P>
<P class=docText><A name="quickly dismiss"></A>My first thought is to use the system clock, but I quickly dismiss the idea because the clock I have available does not have enough resolution for this particular challenge (<A name=idx-CHP-7-0381></A><A name="is blazingly"></A>binary search is blazingly fast), and I can't really control the execution environment. So, I use another developer <A name=idx-CHP-7-0382></A><A name="alternate implementation"></A>testing trick: I create an alternate implementation of <TT>binarySearch</TT> called <TT>binarySearchComparisonsCount</TT><A name="uses the"></A>. This version of the code uses the same logic as the original, but it keeps a count of the comparisons and returns that number instead of -1 or the target location.<SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-7-FNOTE-11');">[||||]</A></SUP><A name="that code"></A> Here's that code:</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-7-FNOTE-11>[||||]</A></SUP> Instead of modifying <TT>binarySearch</TT><A name="comparison count"></A> to return the comparison count, a better, cleaner, and more object-oriented design (suggested by David Saff) would be to create a <TT>CountingComparator</TT><A name="generalized Comparator"></A> class that implements Java's generalized Comparator interface and to modify <TT>binarySearch</TT><A name="an instance"></A> to take an instance of that class as a third parameter. This would generalize <TT>binarySearch</TT><A name="types other"></A> to work with types other than integers, another example of how <A name=idx-CHP-7-0383></A>testing can lead to better design and more beautiful code.</P></BLOCKQUOTE><PRE>	public static int binarySearchComparisonCount(int[] a, int target) {
	    int low = 0;
	    int high = a.length - 1;

	    int comparisonCount = 0;

	    while (low &lt;= high) {

	        comparisonCount++;

	        int mid = (low + high) &gt;&gt;&gt; 1;
	        int midVal = a[mid];

	        if (midVal &lt; target)
	            low = mid + 1;
	        else if (midVal &gt; target)
	            high = mid - 1;
	        else
	            return comparisonCount;
	    }
	    return comparisonCount;
	}
</PRE><BR>
<P class=docText>Then I create another theory based on that code:</P>
<BLOCKQUOTE>
<P class=docText>Theory 5: If the size of <TT><I>testArray</I></TT> is <TT><I>n</I></TT>, then <TT><I>binarySearchComparisonCount(testArray, target</I></TT>) must return a number less than, or equal to, 1 + log2 <TT><I>n</I></TT>.</P></BLOCKQUOTE>
<P class=docText>Here's the code for the theory:</P><PRE>	public void assertTheory5(int[] testArray, int target) {
	    int numberOfComparisons =
	        Util.binarySearchComparisonCount(testArray, target);
	    assertTrue(numberOfComparisons &lt;= 1 + log2(testArray.length));
	}
</PRE><BR>
<P class=docText><A name="the method"></A>I add this latest theory to my existing list inside the method <TT>testTheories</TT><A name="looks like"></A>, which now looks like this:</P><PRE>	...
	    while (experiments-- &gt; 0) {
	        testArray = generateRandomSortedArray( );
	        if (rand.nextInt( ) % 2 == 0) {
	            target = testArray[rand.nextInt(testArray.length)];
	        } else {
	            target = rand.nextInt( );
	        }
	        returnValue = Util.binarySearch(testArray, target);
	        assertTheory1(testArray, target, returnValue);
	        assertTheory2(testArray, target, returnValue);
	        assertTheory3(testArray, target, returnValue);
	        assertTheory4(testArray, target, returnValue);
	        assertTheory5(testArray, target);
	    }
	...
</PRE><BR>
<P class=docText><A name="tests with"></A>I run a few tests with a <TT>maxArraySize</TT><A name="and I"></A> set of a few different values, and I find that Theory 5 seems to be holding strong.</P>
<P class=docText><A name="Because it"></A>Because it's almost noon, I set the number of <TT>experiments</TT><A name="to lunch"></A> to 1,000,000 and go to lunch while my computer crunches away and tests each theory a million times.</P>
<P class=docText><A name="I see"></A>When I get back, I see that all my tests pass. There are probably a couple more things that I would want to test, but I have made great progress in boosting <SPAN class=docEmphasis>my</SPAN><A name="this implementation"></A> confidence in this implementation of <TT>binarySearch</TT><A name="have different"></A>. Because different developers have different backgrounds, styles, and levels of experience, you might have focused on different areas of the code. A developer already familiar with the unsigned shift operator, for example, would not feel the same need I had to test it.</P>
<P class=docText><A name=performance></A>In this section, I wanted to give you a flavor of performance <A name=idx-CHP-7-0384></A><A name="show you"></A>testing and show you how you could gain insight into and confidence in your code's performance by combining code instrumentation with test theories. I highly recommend you study <A class=docLink href="019.the_most_beautiful_code_i_never_wrote.html#the_most_beautiful_code_i_never_wrote">Chapter 3</A><A name="this important"></A>, where Jon Bentley gives this important topic the attention and beautiful treatment it deserves.</P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
