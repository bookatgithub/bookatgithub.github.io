<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Chapter 9. Top Down Operator Precedence</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>Top Down Operator Precedence</SPAN><SPAN> &gt; JavaScript</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=top_down_operator_precedence></A>
<H2 class=docChapterTitle id=title-ID0ED3CK>9. Top Down Operator Precedence</H2>
<P class=docText><SPAN class=docEmphasis><A name="Douglas Crockford"></A>Douglas Crockford</SPAN> <A name=idx-CHP-9-0504></A><A name=idx-CHP-9-0505></A><A name=idx-CHP-9-0506></A></P>
<P class=docText><SPAN class=docEmphSmaller><A name="presented "></A>In 1973, vaughan pratt presented "top down operator precedence"</SPAN><SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-9-FNOTE-1');">[*]</A></SUP><A name=annual></A> at the first annual <A name=idx-CHP-9-0507></A><A name="Programming Languages"></A>Principles of Programming Languages Symposium in Boston. In the paper, Pratt described a parsing technique that combines the best properties of <A name=idx-CHP-9-0508></A><A name=the></A>Recursive Descent and the <A name=idx-CHP-9-0509></A>Operator Precedence syntax technique of Robert W Floyd.<SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-9-FNOTE-2');">[<IMG alt=dagger src="images/U2020.GIF">]</A></SUP><A name="easy to"></A>. He claimed that the technique is simple to understand, trivial to implement, easy to use, extremely efficient, and very flexible. I will add that it is also beautiful.<A name=idx-CHP-9-0510></A><A name=idx-CHP-9-0511></A></P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-9-FNOTE-1>[*]</A></SUP><A name="available at"></A> Pratt's paper is available at <A class=docLink href="http://portal.acm.org/citation.cfm?id=512931" target=_blank>http://portal.acm.org/citation.cfm?id=512931</A><A name="himself can"></A>; more information about Pratt himself can be found at <A class=docLink href="http://boole.stanford.edu/pratt.html" target=_blank>http://boole.stanford.edu/pratt.html</A>.</P></BLOCKQUOTE>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-9-FNOTE-2>[<IMG alt=dagger src="images/U2020.GIF">]</A></SUP><A name="W Floyd"></A> For a description of Floyd, see "Robert W Floyd, In Memoriam," Donald E. Knuth, <A class=docLink href="http://sigact.acm.org/floyd" target=_blank>http://sigact.acm.org/floyd</A></P></BLOCKQUOTE>
<P class=docText><A name="It might"></A>It might seem odd that such an obviously utopian approach to compiler construction is completely neglected today. Why is this the case? Pratt suggested in the paper that preoccupation with BNF grammars and their various offspring, along with their related automata and theorems, have precluded development in directions that are not visibly in the domain of automata theory.</P>
<P class=docText><A name="that his"></A>Another explanation is that his technique is most effective when used in a dynamic, functional programming language. Its use in a static, procedural language would be considerably more difficult. In his paper, Pratt used LISP and almost effortlessly built parse trees from streams of tokens.</P>
<P class=docText>But <A name=idx-CHP-9-0512></A><A name="not greatly"></A>parsing techniques are not greatly valued in the LISP community, which celebrates the Spartan denial of syntax. There have been many attempts since LISP's creation to give the language a rich, <A name=idx-CHP-9-0513></A>ALGOL-like syntax, including:</P>
<DL class=docList>
<DT><BR>
<P><I><SPAN class=docPubcolor>Pratt's CGOL</SPAN></I></P></DT>
<DD>
<P class=docList><A class=docLink href="http://zane.brouhaha.com/~healyzh/doc/cgol.doc.txt" target=_blank>http://zane.brouhaha.com/~healyzh/doc/cgol.doc.txt</A> </P></DD>
<DT><BR>
<P><I><SPAN class=docPubcolor>LISP 2</SPAN></I></P></DT>
<DD>
<P class=docList><A class=docLink href="http://community.computerhistory.org/scc/projects/LISP/index.html#LISP_2_" target=_blank>http://community.computerhistory.org/scc/projects/LISP/index.html#LISP_2_</A> </P></DD>
<DT><BR>
<P><I><SPAN class=docPubcolor>MLISP</SPAN></I></P></DT>
<DD>
<P class=docList><A class=docLink href="ftp://reports.stanford.edu/pub/cstr/reports/cs/tr/68/92/CS-TR-68-92.pdf" target=_blank>ftp://reports.stanford.edu/pub/cstr/reports/cs/tr/68/92/CS-TR-68-92.pdf</A> </P></DD>
<DT><BR>
<P><I><SPAN class=docPubcolor>Dylan</SPAN></I></P></DT>
<DD>
<P class=docList><A class=docLink href="http://www.opendylan.org/" target=_blank>http://www.opendylan.org</A> </P></DD>
<DT><BR>
<P><I><SPAN class=docPubcolor>Interlisp's Clisp</SPAN></I></P></DT>
<DD>
<P class=docList><A class=docLink href="http://community.computerhistory.org/scc/projects/LISP/interlisp/Teitelman-3IJCAI.pdf" target=_blank>http://community.computerhistory.org/scc/projects/LISP/interlisp/Teitelman-3IJCAI.pdf</A> </P></DD>
<DT><BR>
<P><I><SPAN class=docPubcolor>McCarthy's original M-expressions</SPAN></I></P></DT>
<DD>
<P class=docList><A class=docLink href="http://www-formal.stanford.edu/jmc/history/lisp/lisp.html" target=_blank>http://www-formal.stanford.edu/jmc/history/lisp/lisp.html</A> </P></DD></DL>
<P class=docText><A name="to find"></A>All failed to find acceptance. The functional programming community found the correspondence between programs and data to be much more valuable than expressive syntax. But the mainstream programming community likes its syntax, so LISP has never been accepted by the mainstream. Pratt's technique befits a dynamic language, but dynamic language communities historically have had no use for the syntax that Pratt's technique realizes.</P><A name=javascript></A>
<H3 class=docSection1Title id=-100000>9.1. JavaScript</H3>
<P class=docText><A name="with the"></A>The situation changed with the advent of <A name=idx-CHP-9-0514></A><A name="obviously a"></A>JavaScript. JavaScript is a dynamic, functional language, but in a syntactic sense, it is obviously a member of the C family. JavaScript is a dynamic language with a community that likes syntax. In addition, JavaScript is object oriented. Pratt's 1973 paper <A name=idx-CHP-9-0515></A><A name="orientation but"></A>anticipated object orientation but lacked an expressive notation for it. JavaScript has an expressive object notation. Thus, JavaScript is an ideal language for exploiting Pratt's technique. I will show that we can quickly and inexpensively produce parsers in JavaScript.<A name=idx-CHP-9-0516></A><A name=idx-CHP-9-0517></A></P>
<P class=docText><A name="this short"></A>We don't have time in this short chapter to deal with the whole JavaScript language, and perhaps we wouldn't want to because the language is a mess. But it has some brilliant stuff in it, which is worthy of your consideration. We will build a parser that can process <A name=idx-CHP-9-0518></A><A name="that parser"></A>Simplified JavaScript, and we will write that parser in <A name=idx-CHP-9-0519></A><A name="Simplified JavaScript"></A>Simplified JavaScript. Simplified JavaScript is just the good stuff, including:</P><A name=idx-CHP-9-0520></A><A name=idx-CHP-9-0521></A><A name=idx-CHP-9-0522></A><A name=idx-CHP-9-0523></A><A name=idx-CHP-9-0524></A><A name=idx-CHP-9-0525></A>
<DL class=docList>
<DT><BR>
<P><SPAN class=docPubcolor><SPAN class=docEmphasis>Functions as first-class objects</SPAN> </SPAN></P></DT>
<DD>
<P class=docList><A name="with lexical"></A>Functions are lambdas with lexical scoping.</P></DD>
<DT><BR>
<P><SPAN class=docPubcolor><SPAN class=docEmphasis><A name="prototypal inheritance"></A>Dynamic objects with prototypal inheritance</SPAN> </SPAN></P></DT>
<DD>
<P class=docList><A name="We can"></A>Objects are class-free. We can add a new member to any object by ordinary assignment. An object can inherit members from another object.<A name=idx-CHP-9-0520></A><A name=idx-CHP-9-0521></A></P></DD>
<DT><BR>
<P><SPAN class=docPubcolor><SPAN class=docEmphasis><A name="array literals"></A>Object literals and array literals</SPAN>.</SPAN></P></DT>
<DD>
<P class=docList><A name="and arrays"></A>This is a very convenient notation for creating new objects and arrays. <A name=idx-CHP-9-0522></A>JavaScript <A name=idx-CHP-9-0523></A><A name="the inspiration"></A>literals were the inspiration for the JSON data interchange (<A class=docLink href="http://www.json.org/" target=_blank>http://www.JSON.org</A>) format.<A name=idx-CHP-9-0524></A><A name=idx-CHP-9-0525></A></P></DD></DL>
<P class=docText><A name=of></A>We will take advantage of <A name=idx-CHP-9-0526></A>JavaScript's <A name=idx-CHP-9-0527></A><A name="objects that"></A>prototypal nature to make token objects that inherit from symbols, and symbols that inherit from an original symbol. We will depend on the <TT>object</TT><A name="which makes"></A> function, which makes a new object that inherits members from an existing object. Our implementation will also depend on a tokenizer that produces an array of simple token objects from a string. We will advance through the array of tokens as we weave our parse tree.</P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
