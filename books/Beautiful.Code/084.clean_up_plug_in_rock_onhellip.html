<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 11.7. Clean Up, Plug In, Rock On…</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>Secure Communication: The Technology Of Freedom</SPAN><SPAN> &gt; Clean Up, Plug In, Rock On…</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=clean_up_plug_in_rock_onhellip></A>
<H3 class=docSection1Title id=-100000>11.7. Clean Up, Plug In, Rock On…</H3>
<P class=docText><A name="After developing"></A>After developing the initial prototype of Cryptonite in Costa Rica, I continued working on it independently. After a much needed cleanup of the code (prototype development had been hectic and had left not much time to refactor or test the code), I worked on a number of Perl modules and components that would be needed next, to make the jump from a simple prototype to a scalable product. These included <A name=idx-CHP-11-0770></A><A name="identical to"></A>Crypt::GPG (with an interface almost identical to that of Crypt::PGP5, so that switching to GnuPG for the crypto operations in Cryptonite involved little more than a single-line change to the code), and <A name=idx-CHP-11-0771></A>Persistence::Database::SQL and <A name=idx-CHP-11-0772></A><A name="in a"></A>Persistence::Object::Postgres (which provide object persistence in a <A name=idx-CHP-11-0773></A><A name="a similar"></A>Postgres database, with a similar interface to <A name=idx-CHP-11-0774></A><A name="database switch"></A>Persistence::Object::Simple, making the backend database switch quite seamless as well).</P>
<P class=docText>Persistence::Object::Postgres, like Persistence::Object::Simple, uses a <A name=idx-CHP-11-0775></A>blessed reference<SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-11-FNOTE-6');">[#]</A></SUP><A name="to the"></A> to a hash container to store key-value pairs, which can be committed to the database with a <TT>commit</TT><A name="also uses"></A> method call. It also uses Perl's <A name=idx-CHP-11-0776></A><A name="large objects"></A>Tie mechanism to tie Postgres' large objects (BLOBs) to filehandles, enabling natural filehandle-based access to large binary objects in the data-base. One of the major benefits of Persistence::Database::SQL over Persistence::Object:: Simple, of course, is that it enables proper queries into a real database. For example, with Persistence::Object::Simple, there's no clean way to quickly search for a particular user's record, whereas with Persistence::Database::SQL, getting a specific user record from the database is straightforward:</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-11-FNOTE-6>[#]</A></SUP><A name="object when"></A> In Perl, a reference becomes an object when associated to a class by bless, so "blessed reference" is just a Perlish term for an object.</P></BLOCKQUOTE><PRE>	sub _getuser { # Get a user object from the database.
	  my $self = shift; my $username = shift;
	  $self-&gt;db-&gt;table('users'); $self-&gt;db-&gt;template($usertmpl);
	  my ($user) = $self-&gt;db-&gt;select("WHERE USERNAME = '$username'");
	  return $user;
	}
</PRE><BR>
<P class=docText><A name="With Persistence"></A>With Persistence::Object::Simple one would have to either iterate over all the persistent objects in the data directory or resort to a hack such as directly grepping the plaintext persistence files in the data directory.</P>
<P class=docText><A name="interface of"></A>In most respects, the interface of Persistence::Object::Postgres is very similar to that of Persistence::Object::Simple. To modify an object with either module, the code is identical:</P><PRE>	my $user = $self-&gt;_getuser($username);
	return $self-&gt;cluebat (EBADLOGIN) unless $user and $user-&gt;timestamp;
	$user-&gt;set_level($level);
	$user-&gt;commit;
</PRE><BR>
<P class=docText><A name="a plaintext"></A>The switch from a plaintext database to a real DBMS was made after most of the prototype code was basically working well, and marked the second stage of <A name=idx-CHP-11-0777></A><A name="the system"></A>Cryptonite development: getting the system ready for real-world deployment. For prototype development, Persistence::Object::Simple was great, as it didn't require a database server to be available for development, and objects were stored in plaintext files so they could be easily examined for debugging.</P>
<P class=docText><A name="homomorphic interfaces"></A>The use of homomorphic interfaces for Crypt::GPG and Persistence::Object::Postgres allowed these major changes (of the encryption and the database backends) to be made with very minor edits to the code in <A name=idx-CHP-11-0778></A>Cryptonite::Mail::Service.</P><A name=revamping_the_mail_store></A>
<H4 class=docSection2Title id=title-ID0ENHDK>11.7.1. Revamping the Mail Store</H4>
<P class=docText>Storing user mail in plain <SPAN class=docEmphasis>mbox</SPAN><A name="to be"></A> files worked for the first prototype, but a production system needed to be able to access and update individual messages more efficiently than a single flat file mailbox allowed. I also wanted to move toward the very important objective of providing mail store replication for fault-tolerance.<A name=idx-CHP-11-0779></A><A name=idx-CHP-11-0780></A></P>
<P class=docText><A name="consideration also"></A>A usability consideration also imposed some requirements on the mail store. In <A name=idx-CHP-11-0781></A><A name="about MIME"></A>Cryptonite, unlike most email clients, information about MIME structures of messages would be made visible to users in the message list. This would make it possible for a user to visually identify which messages were encrypted and/or signed, directly in the message list. Availability of information about message parts in the message list would also enable the user to open a message subpart directly. The message parts are visible as icons in the rightmost column of the message list view, as shown in <A class=docLink href="javascript:moveTo('message_list_with_parts');">Figure 11-4</A>.</P><A name=message_list_with_parts></A>
<P>
<CENTER>
<H5 class=docFigureTitle>Figure 11-4. Message list with parts</H5><IMG id="" height=106 alt="" src="images/clean_up_plug_in_rock_onhellip.0.png" width=500 border=0> </CENTER>
<P></P><BR>
<P class=docText><A name="mail store"></A>To enable such visual feedback, the mail store would need to efficiently provide accurate information about the <A name=idx-CHP-11-0782></A><A name="MIME structure"></A>MIME structure of a list of messages. A further complication was the fact that the OpenPGP/MIME spec allows for MIME parts to be nested within signed and/or encrypted parts, so only an OpenPGP/<A name=idx-CHP-11-0783></A><A name="return accurate"></A>MIME-aware mail store could return accurate information about MIME structures of <A name=idx-CHP-11-0784></A>encrypted or signed messages.</P>
<P class=docText><A name="to implement"></A>So I decided to implement, based on the <A name=idx-CHP-11-0785></A>Mail::Folder module, an SQL-based <A name=idx-CHP-11-0786></A><A name="backend with"></A>mail storage backend with most of the abilities of an IMAP4rev1 server. The core of this system is the Mail::Folder::SQL class, based on Mail::Folder and using Persistence::Object::Postgres. This was back when IMAP had not yet gained much traction. I opted not to use an existing <A name=idx-CHP-11-0787></A><A name="a mail"></A>IMAP server as a mail store because I <A name=idx-CHP-11-0788></A><A name="as mail"></A>anticipated needing some features that most IMAP servers didn't support well, such as mail store <A name=idx-CHP-11-0789></A><A name="the ability"></A>replication and the ability to retrieve detailed information about the structure of a MIME message without having to retrieve and parse the entire message.</P>
<P class=docText><A name="servers might"></A>Even though some IMAP servers might have suited my needs, I also didn't want Cryptonite to be dependent on and tied down to the capabilities of any specific IMAP server implementation. All in all, this turned out to be a good decision, even though it did lead to a lot of effort being expended on code that was later demoted to a less central role in the system.</P>
<P class=docText>Mail store <A name=idx-CHP-11-0790></A><A name="two Perl"></A>replication was hacked up using two Perl modules I wrote: <A name=idx-CHP-11-0791></A><A name=and></A>Replication::Recall and <A name=idx-CHP-11-0792></A>DBD::Recall, which used Eric Newton's <A name=idx-CHP-11-0793></A>Recall replication framework (<A class=docLink href="http://www.fault-tolerant.org/recall" target=_blank>http://www.fault-tolerant.org/recall</A><A name="across multiple"></A>) to replicate databases across multiple servers. The idea was to use this as a prototype and to custom-build a new database replication system in the future.</P>
<P class=docText><A name="mail store"></A>With the encryption, database, and mail store backends revamped, and with a new, cleaner theme, the first internal beta of Cryptonite went online in October 2001. It was tested by many users of varying skill levels, some of whom even used it as their primary mail client. Usability testing during the internal beta indicated that novice users were able to successfully generate and import keys, and to send and read encrypted and signed messages without much trouble.</P><A name=persistence_of_decryption></A>
<H4 class=docSection2Title id=title-ID0E2LDK>11.7.2. Persistence of Decryption</H4>
<P class=docText><A name="feature for"></A>An essential feature for an <A name=idx-CHP-11-0794></A><A name="is the"></A>encrypted mail client is the ability to keep <A name=idx-CHP-11-0795></A><A name="the user"></A>decrypted messages available in decrypted form for the duration of the user's session. A <A name=idx-CHP-11-0796></A><A name="client that"></A>secure mail client that lacks this facility can get very irritating and inefficient to use, as it would require typing in long passphrases and waiting for decryption every time you want to read an encrypted message or search within encrypted messages.</P>
<P class=docText>Persistence for previously <A name=idx-CHP-11-0797></A>decrypted messages in <A name=idx-CHP-11-0798></A><A name="creating a"></A>Cryptonite was accomplished by creating a new Mail::Folder class, based on Mail::Folder::SQL. Mail::Folder::Shadow would delegate mailbox accesses to a <SPAN class=docEmphasis>shadow folder</SPAN><A name="counterpart in"></A> if the message had a counterpart in the shadow folder; otherwise, it would access the underlying (or <SPAN class=docEmphasis>shadowed</SPAN>) folder.</P>
<P class=docText><A name="By this"></A>By this means, decrypted messages could be kept in the shadow folder while a session was alive, and little modification of the code was necessary to add persistent decrypts, other than to plug in the <A name=idx-CHP-11-0799></A><A name="implements its"></A>Mail::Folder::Shadow module everywhere Mail::Folder::SQL was used. Mail::Folder::Shadow implements its magic with a simple, tweakable delegation table:</P><PRE>	my %method =
	qw (get_message 1 get_mime_message 1 get_message_file 1 get_header 1
	    get_mime_message 1 mime_type 1 get_mime_header 1 get_fields 1
	    get_header_fields 1 refile 1 add_label 2 delete_label 2
	    label_exists 2 list_labels 2 message_exists 1 delete_message 5
	    sync 2 delete 2 open 2 set_header_fields 2 close 2 DESTROY 2
	    get_mime_skeleton 1 get_body_part 1);
</PRE><BR>
<P class=docText><A name="as appropriate"></A>Mail::Folder::Shadow delegates method calls as appropriate to the shadow folder, the original shadowed folder, or to both. Perl's powerful <TT>AUTOLOAD</TT><A name="a mechanism"></A> feature, which provides a mechanism to handle methods that are not explicitly defined in a class, is a simple way to accomplish this delegation, while also providing a simple mechanism to tweak at runtime how different methods are handled.<A name=idx-CHP-11-0800></A></P>
<P class=docText><A name="to check"></A>Methods that have to check the shadow store, such as <TT>get_message</TT> and <TT>get_header</TT><A name="in the"></A>, are delegated to the shadow if the message concerned exists in the shadow folder; otherwise, they are delegated to the original shadowed folder. Other methods, such as <TT>add_label</TT> and <TT>delete</TT><A name="need to"></A> (which deletes a folder), need to be dispatched to both the shadow and the shadowed folder, as these messages must change the state of the original folder, as well as that of the shadow folder.</P>
<P class=docText>Yet other methods, such as <TT>delete_message</TT><A name="list through"></A>, can accept a message list through an array reference. Some of the messages in the message list may be shadowed, and others may not. Mail::Folder::Shadow's <TT>AUTOLOAD</TT><A name="two lists"></A> handles such methods by building two lists from the message list passed to it, one of shadowed messages and one of nonshadowed messages. It then calls the method on both the shadowed and <A name=idx-CHP-11-0801></A><A name="shadow folder"></A>shadow folder for messages that are shadowed, and only on the <A name=idx-CHP-11-0802></A><A name="messages that"></A>shadowed folder for messages that aren't.</P>
<P class=docText><A name="of all"></A>The practical upshot of all of this is that <SPAN class=docEmphasis>cmaild</SPAN><A name="to use"></A> can continue to use folders just as it did before, and stash decrypted messages in the shadow folder for the duration of a session. There are a few extra methods in Mail::Folder::Shadow to enable this, including <TT>update_shadow</TT><A name="to save"></A>, which is used to save the decrypted message in the shadow folder; <TT>delete_shadow</TT>, used to delete individual shadowed messages at user request; and <TT>unshadow</TT>, used to delete all messages in shadow folders before session termination.</P>
<P class=docText><A name="a session"></A>Mail::Folder::Shadow makes it possible to offer persistence of decrypted messages for a session and to implement search within encrypted messages—both essential features from a user's perspective, but rarely implemented in current-generation OpenPGP-compliant <A name=idx-CHP-11-0803></A>email systems.</P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
