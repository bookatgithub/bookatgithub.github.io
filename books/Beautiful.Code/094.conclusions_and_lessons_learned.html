<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 12.4. Conclusions and Lessons Learned</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>Growing Beautiful Code in BioPerl</SPAN><SPAN> &gt; Conclusions and Lessons Learned</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=conclusions_and_lessons_learned></A>
<H3 class=docSection1Title id=-100000>12.4. Conclusions and Lessons Learned</H3>
<P class=docText><A name="Designing software"></A>Designing software to be used by other developers is a challenge. It has to be easy and straightforward to use because developers are just as impatient as everyone else, but it can't be so dumbed-down that it loses functionality. Ideally, a code library must be immediately usable by naïve developers, easily customized by more sophisticated developers, and readily extensible by experts.</P>
<P class=docText><A name="this sweet"></A>I think Bio::Graphics hits this sweet spot. Developers new to BioPerl can get started right away by writing simple scripts that use familiar BioPerl objects such as Bio::SeqFeature:: Generic. Intermediate developers can customize the library's output by writing callbacks, while the most sophisticated developers can extend the library with custom glyphs.</P>
<P class=docText><A name="power of"></A>Bio::Graphics also illustrates the power of standard interfaces. Because it was designed to render any object that follows BioPerl's <A name=idx-CHP-12-1011></A><A name="work hand"></A>Bio::SeqFeatureI interface, it will work hand-in-hand with any of BioPerl's sequence data access modules. Bio::Graphics can generate diagrams of handcoded sequence features as easily as it can display features read from a flat file, retrieved from a database query, or generated by a web service and transmitted across the network.</P>
<P class=docText><A name="has a"></A>The module also has a few warts, and if I had to reimplement it now, I would have done several things differently. A major issue is the way that <A name=idx-CHP-12-1012></A><A name="to a"></A>subglyphs are generated. In the current implementation, if you assign a glyph to a feature and the feature has subfeatures, the subglyphs will all be of the same type as the top-level glyph.</P>
<P class=docText><A name="two drawbacks"></A>This has two drawbacks. First, one must use subclassing to create composite glyphs in which the subglyphs reuse code from a previously defined class and the parent glyph is something new. Second, glyph methods always have to be aware of which level of features they are currently rendering. For example, to create a glyph in which the top level is represented as a dotted octagon and the subfeatures are represented as rectangles, the <TT>draw_component()</TT><A name="to call"></A> routine must be sure to call the glyph's <TT>level()</TT><A name="current nesting"></A> method to find out the current nesting level and then draw the appropriate shape. If I were to do it again, I would provide an API to select the right glyph to use at each level of nesting.<A name=I_indexterm12_tt302></A></P>
<P class=docText><A name="Another annoyance"></A>Another annoyance is the box model. Glyphs are allowed to allocate additional space around themselves in order to draw decorations such as arrows, highlights, or labels. They do this by overriding methods called <TT>pad_left(), pad_right()</TT>, and so on.</P>
<P class=docText><A name="until you"></A>This works fine until you define a new glyph class that inherits from the old one, and you need to adjust the padding for additional decoration. The derived class must be careful to find out how much padding its parent requests (by calling the inherited pad method) and then add its own padding needs to this value. This can get tricky. If I were to do it over, I would simply keep track of where the glyph draws in its <TT>draw_component()</TT><A name="bounding rectangle"></A> routine, and increase its bounding rectangle as needed.</P>
<P class=docText><A name="of these"></A>Unfortunately, implementing either of these fixes will change the glyph API in pretty fundamental ways and would require someone, most likely myself, to rewrite all 60+ existing glyph classes in order not to break them. So for the time being, I will accept that the module will always be Pretty Good but will never achieve Perfection. And this is the last, and maybe the best, lesson learned.</P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
