<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 13.4. Filtering Down to Just the Relevant Genes</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>The Design of the Gene Sorte</SPAN><SPAN> &gt; Filtering Down to Just the Relevant Genes</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=filtering_down_to_just_the_relevant_genes></A>
<H3 class=docSection1Title id=-100000>13.4. Filtering Down to Just the Relevant Genes</H3>
<P class=docText><A name=idx-CHP-13-1061></A><A name="Filters are"></A>Filters are one of the most powerful features of the gene sorter. Filters can be applied to each of the columns in order to view just the genes relevant to a particular purpose. For instance, a filter on the gene expression column can be used to find genes that are expressed in the brain but not in other tissues. A filter on the genome position can find genes on the X chromosome. A combination of these filters could find brain-specific genes found on the X chromosome. These genes would be particularly interesting to researchers on autism, since that condition appears to be to a fairly strong degree sex-linked.<A name=idx-CHP-13-1062></A><A name=idx-CHP-13-1063></A></P>
<P class=docText><A name="two filter"></A>Each column has two filter methods: <TT>filterControls</TT><A name="HTML for"></A> to write the HTML for the filter user interface and <TT>advFilter</TT><A name="run the"></A> to actually run the filter. These two methods communicate with each other through cart variables that use a naming convention that includes the program name, the letters <TT>as</TT><A name="name as"></A>, and the column name as prefixes to the specific variable name. In this way, different columns of the same type have different cart variables, and filter variables can be distinguished from other variables. A helpful routine named <TT>cartFindPrefix</TT><A name="is heavily"></A>, which returns a list of all variables with a given prefix, is heavily used by the filter system.<A name=idx-CHP-13-1064></A><A name=idx-CHP-13-1065></A></P>
<P class=docText><A name="are arranged"></A>The filters are arranged as a chain. Initially, the program constructs a list of all genes. Next it checks the cart to see whether any filters are set. If so, it calls the filters for each column. The first filter gets the entire gene list as input. Subsequent filters start with the output of the previous filter. The order in which the filters are applied doesn't matter.<A name=I_indexterm13_tt304></A><A name=I_indexterm13_tt305></A></P>
<P class=docText><A name="most speed"></A>The filters are the most speed-critical <A name=idx-CHP-13-1066></A>code in the <A name=idx-CHP-13-1067></A><A name="is executed"></A>Gene Sorter. Most of the code is executed on just 50 or 100 <A name=idx-CHP-13-1068></A><A name="but the"></A>genes, but the filters work on tens of thousands. To keep good interactive response time, the filter should spend less than 0.0001 of a second per gene. A modern CPU operates so fast that generally 0.0001s is not much of a limitation. However, a disk seek still takes about 0.005s, so the filter must avoid causing seeks.</P>
<P class=docText><A name="by checking"></A>Most filters start by checking the cart to see whether any of their variables are set, and if not, just quickly return the input list unchanged. Next, the filters read the tables associated with a column. Reading the entire table avoids potentially causing a disk seek for each item, and while it is slower if just processing a few genes, it is much faster when processing a large set of genes.</P>
<P class=docText><A name="the filter"></A>Genes that pass the filter are put into a hash, keyed by gene ID. Finally, the filter calls a routine named <TT>weedUnlessInHash</TT><A name="through each"></A> that loops through each gene in the input to see whether it is in the hash and, if so, copies the gene to the output. The net result is a fast and flexible system in a relatively small amount of code.</P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
