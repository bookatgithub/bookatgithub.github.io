<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 17.5. Multiplexing and Demultiplexing</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>Another Level of Indirection</SPAN><SPAN> &gt; Multiplexing and Demultiplexing</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=multiplexing_and_demultiplexing></A>
<H3 class=docSection1Title id=-100000>17.5. Multiplexing and Demultiplexing</H3>
<P class=docText><A name="As you"></A>As you can see back in <A class=docLink href="126.from_code_to_pointers.html#layers_of_indirection_in_the_freebsd_implementation_of_the_r">Figure 17-1</A><A name=the></A>, the processing of the <A name=idx-CHP-17-1433></A><A name="start from"></A>read system call doesn't start from <TT>VOP_READ. VOP_READ</TT><A name="called from"></A> is actually called from <TT>vn_read</TT><A name="called through"></A>, which itself is called through a function pointer.<A name=idx-CHP-17-1434></A></P>
<P class=docText><A name="operating system"></A>This level of indirection is used for another purpose. The Unix operating system and its derivatives treat all <A name=idx-CHP-17-1435></A><A name="output sources"></A>input and output sources uniformly. Thus, instead of having separate system calls for reading from, say, a file, a socket, or a pipe, the <TT>read</TT><A name="from any"></A> system call can read from any of those I/O abstractions. I find this design both elegant and useful; I've often relied on it, using tools in ways their makers couldn't have <A name=idx-CHP-17-1436></A><A name="age of"></A>anticipated. (This statement says more about the age of the tools I use than my creativity.)</P>
<P class=docText><A name="The indirection"></A>The indirection appearing in the middle of <A class=docLink href="126.from_code_to_pointers.html#layers_of_indirection_in_the_freebsd_implementation_of_the_r">Figure 17-1</A><A name="FreeBSD uses"></A> is the mechanism FreeBSD uses for providing this <A name=idx-CHP-17-1437></A>high-level <A name=idx-CHP-17-1438></A><A name="each file"></A>I/O abstraction independence. Associated with each file descriptor is a function pointer leading to the code that will service the particular request: <TT>pipe_read</TT> for pipes, <TT>soo_read</TT> for sockets, <TT>mqf_read</TT><A name="message queues"></A> for POSIX message queues, <TT>kqueue_read</TT> for kernel event queues, and, finally, <TT>vn_read</TT> for actual files.</P>
<P class=docText><A name="we have"></A>So far, in our example, we have encountered two instances where <A name=idx-CHP-17-1439></A><A name="in such"></A>function pointers are used to dispatch a request to different functions. Typically, in such cases, a function pointer is used to demultiplex a single request to multiple potential providers. This use of indirection is so common that it forms an important element of object-oriented languages, in the form of <A name=idx-CHP-17-1440></A><A name="to various"></A>dynamic dispatch to various subclass methods. To me, the manual implementation of <A name=idx-CHP-17-1441></A><A name="procedural language"></A>dynamic dispatch in a procedural language like C is a distinguishing mark of an expert programmer. (Another is the ability to write a structured program in assembly language or Fortran.)</P>
<P class=docText><A name="as a"></A>Indirection is also often introduced as a way to factor common functionality. Have a look at the top of <A class=docLink href="126.from_code_to_pointers.html#layers_of_indirection_in_the_freebsd_implementation_of_the_r">Figure 17-1</A><A name="Modern Unix"></A>. Modern Unix systems have four variants of the vanilla <TT>read</TT><A name="call variants"></A> system call. The system call variants starting with <TT>p (pread, preadv)</TT><A name="of a"></A> allow the specification of a file position together with the call. The variants ending with a <TT>v (readv, preadv)</TT><A name="specification of"></A> allow the specification of a <A name=idx-CHP-17-1442></A><A name="instead of"></A>vector of I/O requests instead of a single one. Although I consider this proliferation of system calls inelegant and against the spirit of Unix, applications programmers seem to depend on them for squeezing every bit of performance out of the Web or database servers they implement.</P>
<P class=docText><A name="indirection through"></A>All these calls share some common code. The FreeBSD implementation introduces indirection through <A name=idx-CHP-17-1443></A><A name="in order"></A>additional functions in order to avoid code duplication. The function <TT>kern_preadv</TT><A name="of the"></A> handles the common parts of the positional system call variants, while <TT>kern_readv</TT><A name="The functionality"></A> handles the remaining two system calls. The functionality common in all four is handled by another function, <TT>dofileread</TT><A name="In my"></A>. In my mind, I can picture the joy developers got from factoring out the code common to those functions by introducing more levels of indirection. I always feel elated if, after committing a refactoring change, the lines I add are less than the lines I remove.<A name=idx-CHP-17-1444></A></P>
<P class=docText><A name="our call"></A>The journey from our call to a read function in our user-level program to the movement of a disk head to fetch our data from a platter is a long and tortuous one. In our description, we haven't considered what happens above the kernel layer (<A name=idx-CHP-17-1445></A>virtual machines, <A name=idx-CHP-17-1446></A>buffering, <A name=idx-CHP-17-1447></A><A name="happens when"></A>data representation), or what happens when a filesystem handles a request (buffering again, device drivers, data representation). Interestingly, there's a pleasant symmetry between the two ends we haven't covered: both involve <A name=idx-CHP-17-1448></A><A name="such as"></A>hardware interfaces (virtual machines, such as the JVM at the top, and real interfaces at the bottom), buffering (to minimize system calls at the top, and to optimize the hardware's performance at the bottom), and data representation (to interact with the user's locale at the top, and to match the physical layer's requirements at the bottom). It seems that indirection is everywhere we care to cast our eyes. In the representative chunk we've looked at, nine levels of function calls, two indirections through function pointers, and a domain-specific language provided us with a representative view of its power.</P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
