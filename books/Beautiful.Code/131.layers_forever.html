<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 17.6. Layers Forever?</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>Another Level of Indirection</SPAN><SPAN> &gt; Layers Forever?</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=layers_forever></A>
<H3 class=docSection1Title id=-100000>17.6. Layers Forever?</H3>
<P class=docText><A name="We could"></A>We could continue looking at more code examples forever, so it is worth bringing our discussion to an end by noting that Lampson attributes the aphorism that started our exploration (all problems in computer science can be solved by another level of indirection) to David <A name=idx-CHP-17-1449></A><A name="the subroutine"></A>Wheeler, the inventor of the subroutine. Significantly, Wheeler completed his quote with another phrase: "But that usually will create another problem." Indeed, indirection and <A name=idx-CHP-17-1450></A><A name="and time"></A>layering add space and time overhead, and can obstruct the code's comprehensibility.</P>
<P class=docText><A name="and space"></A>The time and space overhead is often unimportant, and should rarely concern us. In most cases, the delays introduced by an extra pointer lookup or subroutine call are insignificant in the greater scheme of things. In fact, nowadays the tendency in modern programming languages is for some operations to always happen through a level of <A name=idx-CHP-17-1451></A><A name="to provide"></A>indirection in order to provide an additional measure of flexibility. Thus, for example, in <A name=idx-CHP-17-1452></A><A name="pointer indirection"></A>Java and C#, almost all accesses to objects go through one pointer indirection, to allow for automatic garbage collection. Also, in Java, almost all calls to <A name=idx-CHP-17-1453></A><A name="are dispatched"></A>instance methods are dispatched through a lookup table, in order to allow inheriting classes to override a method at runtime.</P>
<P class=docText><A name="burden all"></A>Despite these overheads that burden all object accesses and method calls, both platforms are doing fine in the marketplace, thank you very much. In other cases, compilers optimize away the indirection we developers put in our code. Thus, most compilers detect cases where calling a function is more expensive than substituting its code inline, and automatically perform this inlining.</P>
<P class=docText><A name="edge of"></A>Then again, when we're operating at the edge of performance, indirection can be a burden. One trick that developers trying to feed gigabit network interfaces use to speed up their code is to combine functionality of different levels of the network stack, collapsing some layers of abstraction. But these are extreme cases.</P>
<P class=docText><A name="On the"></A>On the other hand, the effect that indirection has on the comprehensibility of our code is a very important concern, because over the last 50 years, in contrast to the dizzying increases in CPU speeds, the ability of humans to understand code hasn't improved much. Therefore, the proponents of agile processes advise us to be especially wary when introducing layering to handle some vague, unspecified requirements we imagine might crop up in the future rather than today's concrete needs. As Bart Smaalders quipped when discussing performance anti-patterns: "Layers are for cakes, not for software."</P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
