<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 18.2. Special Accommodations</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>Python's Dictionary Implementation: Being All Things to All People</SPAN><SPAN> &gt; Special Accommodations</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=special_accommodations></A>
<H3 class=docSection1Title id=-100000>18.2. Special Accommodations</H3>
<P class=docText><A name="When trying"></A>When trying to be all things to all people—a time- and memory-efficient data type for Python users, an internal data structure used as part of the interpreter's implementation, and a readable and maintainable code base for Python's developers—it's necessary to complicate a pure, theoretically elegant implementation with special-case code for particular cases… but not too much.</P><A name=a_special-case_optimization_for_small_hashes></A>
<H4 class=docSection2Title id=title-ID0ETTDK>18.2.1. A Special-Case Optimization for Small Hashes</H4>
<P class=docText>The <TT>PyDictObject</TT><A name="for an"></A> also contains space for an eight-slot hash table. Small <A name=idx-CHP-18-1479></A><A name="elements or"></A>dictionaries with five elements or fewer can be stored in this table, saving the time cost of an extra <TT>malloc()</TT><A name="improves cache"></A> call. This also improves cache locality; for example, <TT>PyDictObject</TT> structures <A name=idx-CHP-18-1480></A><A name="space when"></A>occupy 124 bytes of space when using x86 GCC and therefore can fit into two 64-byte cache lines. The <A name=idx-CHP-18-1481></A><A name="three keys"></A>dictionaries used for keyword arguments most commonly have one to three keys, so this optimization helps improve function-call performance.<A name=idx-CHP-18-1482></A></P><A name=when_special-casing_is_worth_the_overhead></A>
<H4 class=docSection2Title id=title-ID0E5UDK>18.2.2. When Special-Casing Is Worth the Overhead</H4>
<P class=docText><A name="a single"></A>As previously explained, a single dictionary can contain keys of several different data types. In most <A name=idx-CHP-18-1483></A><A name="class instances"></A>Python programs, the dictionaries underlying class instances and modules have only strings as keys. It's natural to wonder whether a specialized dictionary object that only accepted strings as keys might provide benefits. Perhaps a special-case data type would be useful and make the interpreter run faster?<A name=idx-CHP-18-1484></A><A name=idx-CHP-18-1485></A></P><A name=the_java_implementation_another_special-case_optimization></A>
<H5 class=docSection3Title id=title-ID0E2VDK>18.2.2.1. The Java implementation: another special-case optimization</H5>
<P class=docText>In fact, there <SPAN class=docEmphasis>is</SPAN> a <A name=idx-CHP-18-1486></A>string-specialized dictionary type in <A name=idx-CHP-18-1487></A>Jython (<A class=docLink href="http://www.jython.org/" target=_blank>http://www.jython.org</A><A name="Jython has"></A>), an implementation of Python in Java. Jython has an <TT>org.python.org.PyStringMap</TT><A name="class used"></A> class used only for dictionaries in which all keys are strings; it is used for the <TT>_ _dict_ _</TT><A name="instances and"></A> dictionary underpinning class instances and modules. Jython code that creates a dictionary for user code employs a different class, <TT>org.python.core.PyDictionary</TT><A name="that uses"></A>, a heavyweight object that uses a <TT>java.util.Hashtable</TT><A name="its contents"></A> to store its contents and does extra indirection to allow <TT>PyDictionary</TT> to be subclassed.<A name=idx-CHP-18-1488></A></P>
<P class=docText><A name="users to"></A>Python's language definition doesn't allow users to replace the internal<TT>_ _dict_ _</TT><A name="subclassing unnecessary"></A> dictionaries by a different data type, making the overhead of supporting subclassing unnecessary. For Jython, having a specialized string-only dictionary type makes sense.</P><A name=the_c_implementation_selecting_the_storage_function_dynamica></A>
<H5 class=docSection3Title id=title-ID0EKXDK>18.2.2.2. The C implementation: selecting the storage function dynamically</H5>
<P class=docText>CPython does <SPAN class=docEmphasis>not</SPAN><A name="specialized dictionary"></A> have a specialized dictionary type, as Jython does. Instead, it employs a different trick: an individual dictionary uses a string-only function until a search for non-string data is requested, and then a more general function is used. The implementation is simple. <TT>PyDictObject</TT> contains one field, <TT>ma_lookup</TT><A name="function used"></A>, that's a pointer to the function used to look up keys:<A name=idx-CHP-18-1489></A><A name=idx-CHP-18-1490></A></P><PRE>	struct PyDictObject {
	    ...
	    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);
	};
</PRE><BR>
<P class=docText><TT>PyObject</TT><A name="represents any"></A> is the C structure that represents any Python data object, containing basic fields such as a reference count and a pointer to a type object. Specific types such as <TT>PyIntObject</TT><A name=and></A> and <TT>PyStringObject</TT><A name="with additional"></A> extend the structure with additional fields as necessary. The dictionary implementation calls <TT>(dict-&gt;ma_lookup)(dict, key, hash)</TT> to find a key; <TT>key</TT><A name="to the"></A> is a pointer to the <TT>PyObject</TT><A name=and></A> representing the key, and <TT>hash</TT><A name="value derived"></A> is the hash value derived for the key.<A name=idx-CHP-18-1491></A><A name=idx-CHP-18-1492></A><A name=idx-CHP-18-1493></A><A name=idx-CHP-18-1494></A></P>
<P class=docText><TT>ma_lookup</TT> is initially set to <TT>lookdict_string</TT>, a function that assumes that both the <A name=idx-CHP-18-1495></A><A name="are strings"></A>keys in the dictionary and the key being searched for are strings represented as Python's standard <TT>PyStringObject</TT> type. <TT>lookdict_string</TT><A name="take a"></A> can therefore take a few shortcuts. One shortcut is that string-to-string <A name=idx-CHP-18-1496></A><A name="some unnecessary"></A>comparisons never raise exceptions, so some unnecessary error checking can be skipped. Another is that there's no need to check for rich comparisons on the object; arbitrary Python data types can provide their own separate versions of &lt;, &gt;, &lt;=, &gt;=, ==, and !=, but the standard string type has no such special cases.</P>
<P class=docText><A name="either because"></A>If a nonstring key is encountered, either because it's used as a dictionary key or the program makes an attempt to search for it, the <TT>ma_lookup</TT><A name="field is"></A> field is changed to point to the more general <TT>lookdict</TT> function. <TT>lookdict_string</TT><A name="of its"></A> checks the type of its input and changes <TT>ma_lookup</TT><A name="the chosen"></A> if necessary, then calls the chosen function to obtain a correct answer. (CPython trivia: this means that a dictionary with only string keys will become slightly slower if you issue <TT>d.get(1)</TT><A name="the search"></A>, even though the search can't possibly succeed. All subsequent code in the program that refers to the dictionary will also go through the more general function and incur a slight slowdown.) Subclasses of <TT>PyStringObject</TT><A name="treated as"></A> have to be treated as nonstrings because the subclass might define a new equality test.</P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
