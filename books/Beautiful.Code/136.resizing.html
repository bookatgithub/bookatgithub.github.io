<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 18.4. Resizing</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>Python's Dictionary Implementation: Being All Things to All People</SPAN><SPAN> &gt; Resizing</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=resizing></A>
<H3 class=docSection1Title id=-100000>18.4. Resizing</H3>
<P class=docText><A name="The size"></A>The size of a dictionary's hash table needs to be adjusted as keys are added. The code aims to keep the table two-thirds full; if a dictionary is holding <SPAN class=docEmphasis>n</SPAN><A name="have at"></A> keys, the table must have at least <SPAN class=docEmphasis>n/</SPAN><A name="a trade"></A> (2/3) slots. This ratio is a trade-off: filling the table more densely results in more collisions when searching for a key, but uses less memory and therefore fits into cache better. Experiments have been tried where the 2/3 ratio is adjusted depending on the size of the dictionary, but they've shown poor results; every insert operation has to check whether the dictionary needed to be resized, and the complexity that the check adds to the insert operation slows things down.<A name=idx-CHP-18-1503></A><A name=idx-CHP-18-1504></A></P><A name=determining_the_new_table_size></A>
<H4 class=docSection2Title id=title-ID0EWUDK>18.4.1. Determining the New Table Size</H4>
<P class=docText><A name="dictionary needs"></A>When a dictionary needs to be resized, how should the new size be determined? For small- or medium-size <A name=idx-CHP-18-1505></A><A name="or fewer"></A>dictionaries with 50,000 keys or fewer, the new size is <TT>ma_used*4</TT>. Most Python programs that work with large <A name=idx-CHP-18-1506></A><A name="and then"></A>dictionaries build up the dictionary in an initial phase of processing, and then look up individual keys or loop over the entire contents. Quadrupling the dictionary size like this keeps the dictionary sparse (the fill ratio starts out at 1/4) and reduces the number of resize operations performed during the build phase. Large dictionaries with more than 50,000 keys use <TT>ma_used*2</TT><A name="consuming too"></A> to avoid consuming too much memory for empty slots.<A name=idx-CHP-18-1507></A></P>
<P class=docText><A name="from a"></A>On deleting a key from a dictionary, the slot occupied by the key is changed to point to a dummy key, and the <TT>ma_used</TT><A name="of full"></A> count is updated, but the number of full slots in the table isn't checked. This means dictionaries are never resized on deletion. If you build a large dictionary and then delete many keys from it, the dictionary's hash table may be larger than if you'd constructed the smaller dictionary directly. This usage pattern is quite infrequent, though. Keys are almost never deleted from the many small <A name=idx-CHP-18-1508></A><A name="dictionaries used"></A>dictionaries used for objects and for passing function arguments. Many <A name=idx-CHP-18-1509></A><A name="build a"></A>Python programs will build a dictionary, work with it for a while, and then discard the whole dictionary. Therefore, very few Python programs will encounter high memory usage because of the no-resize-on-deletion policy.</P><A name=a_memory_trade-off_thats_worth_it_the_free_list></A>
<H4 class=docSection2Title id=title-ID0EJWDK>18.4.2. A Memory Trade-Off That's Worth It: The Free List</H4>
<P class=docText><A name="are used"></A>Many dictionary instances are used by Python itself to hold the <A name=idx-CHP-18-1510></A><A name=in></A>keyword arguments in <A name=idx-CHP-18-1511></A><A name="therefore created"></A>function calls. These are therefore created very frequently and have a very short lifetime, being destroyed when the function returns. An effective optimization when facing a high creation rate and short lifetime is to recycle unused data structures, reducing the number of <TT>malloc()</TT> and <TT>free()</TT> calls.</P>
<P class=docText>Python therefore maintains a <TT>free_dicts</TT> array of <A name=idx-CHP-18-1512></A><A name="elements long"></A>dictionary structures no longer in use. In Python 2.5, this array is 80 elements long. When a new <TT>PyDictObject</TT><A name="pointer is"></A> is required, a pointer is taken from <TT>free_dicts</TT> and the structure is reused. <A name=idx-CHP-18-1513></A><A name="the array"></A>Dictionaries are added to the array when deletion is requested; if <TT>free_dicts</TT> is full, the structure is simply freed.<A name=idx-CHP-18-1514></A></P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
