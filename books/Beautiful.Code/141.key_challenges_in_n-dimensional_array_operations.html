<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 19.1. Key Challenges in N-Dimensional Array Operations</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>Multidimensional Iterators in NumPy</SPAN><SPAN> &gt; Key Challenges in N-Dimensional Array Operations</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=multidimensional_iterators_in_numpy></A>
<H2 class=docChapterTitle id=title-ID0E3UDK>19. Multidimensional Iterators in NumPy</H2>
<P class=docText><SPAN class=docEmphasis><A name="Travis E"></A>Travis E. Oliphant</SPAN> <A name=idx-CHP-19-1519></A><A name=idx-CHP-19-1520></A></P>
<P class=docText><SPAN class=docEmphSmaller><A name="optional package"></A>Numpy is an optional package for the python language</SPAN><A name=powerful></A> that provides a powerful <A name=idx-CHP-19-1521></A>N-dimensional array object. An <SPAN class=docEmphasis>N</SPAN><A name="a data"></A>-dimensional array is a data structure that uses <SPAN class=docEmphasis>N</SPAN><A name="individual elements"></A> integers, or indices, to access individual elements. It is a useful model for a wide variety of data processed by a computer.<A name=idx-CHP-19-1522></A></P>
<P class=docText>For example, a <A name=idx-CHP-19-1523></A>one-dimensional array can store the samples of a sound wave, a <A name=idx-CHP-19-1524></A>two-dimensional array can store a grayscale image, a <A name=idx-CHP-19-1525></A><A name="having a"></A>three-dimensional array can store a color image (with one of the dimensions having a length of 3 or 4), and a four-dimensional array can store the value of pressure in a room during a concert. Even higher-dimensional <A name=idx-CHP-19-1526></A><A name="often useful"></A>arrays are often useful.</P>
<P class=docText><A name="for the"></A>NumPy provides an environment for the mathematical and structural manipulation of arrays of arbitrary dimensions. These manipulations are at the heart of much scientific, engineering, and multimedia code that routinely deals with large amounts of data. Being able to perform these mathematical and structural manipulations in a high-level language can considerably simplify the development and later reuse of these algorithms.</P>
<P class=docText><A name=idx-CHP-19-1527></A><A name="mathematical calculations"></A>NumPy provides an assortment of mathematical calculations that can be done on arrays, as well as providing very simple syntax for structural operations. As a result, Python (with <A name=idx-CHP-19-1528></A><A name="can be"></A>NumPy) can be successfully used for the development of significant and fast-performing engineering and scientific code.</P>
<P class=docText><A name="allows fast"></A>One feature that allows fast structural manipulation is that <A name=idx-CHP-19-1529></A><A name="a NumPy"></A>any subregion of a NumPy array can be selected using the concept of <SPAN class=docEmphasis>slicing</SPAN><A name="slice is"></A>. In Python, a slice is defined by a starting index, a stopping index, and a stride, using the notation <TT>start:stop:stride</TT> (inside square brackets).<A name=idx-CHP-19-1530></A></P>
<P class=docText><A name="want to"></A>For example, suppose we want to crop and shrink a 656x498 image to a 160x120 image by selecting a region in the middle of the image. If the image is <A name=idx-CHP-19-1531></A>held in the NumPy array, <TT>im</TT>, this operation can be performed using:</P><PRE>	im2=im[8:-8:4, 9:-9:4]
</PRE><BR>
<P class=docText><A name="in this"></A>An important feature of NumPy, however, is that the new image selected in this way actually shares data with the underlying image. A copy is not performed. This can be an important optimization when calculating with large data sets where indiscriminate copying can <A name=idx-CHP-19-1532></A><A name="computing resources"></A>overwhelm the computing resources.</P><A name=key_challenges_in_n-dimensional_array_operations></A>
<H3 class=docSection1Title id=-100000>19.1. Key Challenges in N-Dimensional Array Operations</H3>
<P class=docText><A name="fast implementations"></A>In order to provide fast implementations of all mathematical operations, NumPy implements loops (in C) that work quickly over an array or several arrays of any number of dimensions. Writing such generic code that works quickly on arrays of arbitrary dimension can be a mind-stretching task. It may be easy to write a <TT>for</TT><A name="elements of"></A> loop to process all the elements of a one-dimensional array, or two nested <TT>for</TT><A name="loops to"></A> loops to process all the elements of a two-dimensional array. Indeed, if you know ahead of time how many dimensions the array consists of, you can use the right number of <TT>for</TT><A name="loop over"></A> loops to directly loop over all of the elements of the array. But how do you write a general <TT>for</TT><A name="process all"></A>loop that will process all of the elements of an <SPAN class=docEmphasis>N</SPAN>-dimensional array when <SPAN class=docEmphasis>N</SPAN><A name="an arbitrary"></A> can be an arbitrary integer?<A name=idx-CHP-19-1533></A><A name=idx-CHP-19-1534></A><A name=idx-CHP-19-1535></A></P>
<P class=docText><A name="basic solutions"></A>There are two basic solutions to this problem. One solution is to use recursion by thinking about the problem in terms of a recursive case and a base case. Thus, if <TT>copy_ND(a, b, N)</TT> is a function that copies an <TT>N</TT>-dimensional array pointed to by <TT>b</TT> to another N-dimensional array pointed to by <TT>a</TT>, a simple recursive implementation might look like:</P><PRE>	if (N==0)
	    copy memory from b to a
	    return
	set up ptr_to_a and ptr_to_b
	for n=0 to size of first dimension of a and b
	    copy_ND(ptr_to_a, ptr_to_b, N-1)
	    add stride_a[0] to ptr_to_a and stride_b[0] to ptr_b
</PRE><BR>
<P class=docText>Notice the use of the single <TT>for</TT><A name="the recursion"></A> loop and the check for the base case that stops the recursion when <SPAN class=docEmphasis>N</SPAN> reaches 0.</P>
<P class=docText><A name="not always"></A>It is not always easy to think about how to write every algorithm as a recursive algorithm, even though the code just shown can often be used as a starting model. <A name=idx-CHP-19-1536></A>Recursion also requires the <A name=idx-CHP-19-1537></A><A name="call at"></A>use of a function call at each <A name=idx-CHP-19-1538></A><A name="can be"></A>iteration of the loop. So it can be all too easy for recursion to create slow code, unless some <A name=idx-CHP-19-1539></A><A name="optimization is"></A>base-case optimization is performed (such as stopping when <SPAN class=docEmphasis>N</SPAN><A name="memory copy"></A>==1 and doing the memory copy in a <TT>for</TT> loop locally).</P>
<P class=docText><A name="not do"></A>Most languages will not do that kind of optimization automatically, so an elegant-looking recursive solution might end up looking much more contrived by the time optimizations are added.</P>
<P class=docText><A name="algorithms require"></A>In addition, many algorithms require the storage of intermediate information that will be used during later recursions. For example, what if the maximum or minimum value in the array must be tracked? Typically, such values become part of the recursive call structure and are passed along as arguments in the recursive call. In the end, each algorithm that uses recursion must be written in a slightly different way. Thus, it is hard to provide the programmer with additional simplifying tools for recursive solutions.</P>
<P class=docText>Instead of using recursion, <A name=idx-CHP-19-1540></A><A name="to accomplish"></A>NumPy uses iteration to accomplish most of its <SPAN class=docEmphasis>N</SPAN>-dimensional algorithms. Every recursive solution can be written using an iterative solution. <A name=idx-CHP-19-1541></A>Iterators are an abstraction that simplifies thinking about these algorithms. Therefore, using iterators, <SPAN class=docEmphasis>N</SPAN><A name="still be"></A>-dimensional routines can be developed that run quickly, while the code can still be read and understood using a single looping structure.</P>
<P class=docText><A name="is an"></A>An iterator is an abstract concept that encapsulates the idea of walking through all of the elements of an array with just one loop. In <A name=idx-CHP-19-1542></A><A name="that can"></A>Python itself, iterators are objects that can be used as the predicate of any <TT>for</TT> loop. For example:</P><PRE>	for x in iterobj:
	    process(x)
</PRE><BR>
<P class=docText>will run the function <TT>process</TT><A name=of></A> on all of the elements of <TT>iterobj</TT><A name="The most"></A>. The most important requirement of <TT>iterobj</TT><A name="has some"></A> is that it has some way to get its "next" element. Thus, the concept of an iterator refocuses the problem of looping over all the elements of a data structure to one of finding the next element.</P>
<P class=docText><A name="understand how"></A>In order to understand how iterators are implemented and used in <A name=idx-CHP-19-1543></A><A name="crucial to"></A>NumPy, it is crucial to have at least some conception of how NumPy views the memory in an <SPAN class=docEmphasis>N</SPAN><A name="should clarify"></A>-dimensional array. The next section should clarify this point.</P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
