<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 19.2. Memory Models for an N-Dimensional Array</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>Multidimensional Iterators in NumPy</SPAN><SPAN> &gt; Memory Models for an N-Dimensional Array</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=memory_models_for_an_n-dimensional_array></A>
<H3 class=docSection1Title id=-100000>19.2. Memory Models for an N-Dimensional Array</H3>
<P class=docText><A name="The simplest"></A>The simplest model for an <SPAN class=docEmphasis>N</SPAN><A name="memory can"></A>-dimensional array in computer memory can be used whenever all of the elements of the array are sitting next to each other in a contiguous segment. Under such circumstances, getting to the next element of the array is as simple as adding a fixed constant to a pointer to the memory location of the current data pointer. As a result, an iterator for contiguous memory arrays requires just adding a fixed constant to the current data pointer. Therefore, if every <SPAN class=docEmphasis>N</SPAN><A name="were contiguous"></A>-dimensional array in NumPy were contiguous, discussing iterators would be rather uninteresting.<A name=idx-CHP-19-1544></A></P>
<P class=docText><A name="of the"></A>The beauty of the iterator abstraction is that it allows us to think about processing and manipulating <A name=idx-CHP-19-1545></A><A name="the same"></A>noncontiguous arrays with the same ease as contiguous arrays. Noncontiguous arrays arise in <A name=idx-CHP-19-1546></A><A name="of some"></A>NumPy because an array can be created that is a "view" of some other contiguous memory area. This new array may not itself be contiguous.</P>
<P class=docText><A name="a three"></A>For example, consider a three-dimensional array, <TT>a</TT><A name=With></A>, that is contiguous in memory. With <A name=idx-CHP-19-1547></A><A name="consisting of"></A>NumPy, you can create another array consisting of a subset of this larger array using Python's slicing notation. Thus, the statement <TT>b=a[::2, 3:, 1::3]</TT><A name="returns another"></A> returns another NumPy array consisting of every other element in the first dimension, all elements starting at the fourth element (with zero-based indexing) in the second dimension, and every third element starting at the second element in the third dimension. This new array is not a copy of the memory at those locations; it is a view of the original array and shares memory with it. But this new array cannot be represented as a contiguous chunk of memory.</P>
<P class=docText><A name="further drive"></A>A two-dimensional illustration should further drive home the point. <A class=docLink href="javascript:moveTo('a_two-dimensional_array_slice_and_its_linear_representation_');">Figure 19-1</A><A name="array with"></A> shows a contiguous, two-dimensional, 4 x 5 array with memory locations labeled from 1 through 20. Above the representation of the 4 x 5 array is a linear representation of the memory for the array as the computer might see it. If <TT>a</TT><A name="full memory"></A> represents the full memory block, <TT>b=a[1:3, 1:4]</TT><A name="region "></A> represents the shaded region (memory locations 7, 8, 9, 12, 13, and 14). As emphasized in the linear representation, these memory locations are not contiguous.</P><A name=a_two-dimensional_array_slice_and_its_linear_representation_></A>
<P>
<CENTER>
<H5 class=docFigureTitle>Figure 19-1. A two-dimensional array slice and its linear representation in memory</H5><IMG id="" height=197 alt="" src="images/memory_models_for_an_n-dimensional_array.0.png" width=500 border=0> </CENTER>
<P></P><BR>
<P class=docText>NumPy's general memory model for an <SPAN class=docEmphasis>N</SPAN><A name="of arrays"></A>-dimensional array supports the creation of these kinds of noncontiguous views of arrays. It is made possible by attaching to the array a sequence of integers that represent the values for the "striding" through each dimension.</P>
<P class=docText><A name="value for"></A>The stride value for a particular dimension specifies how many bytes must be skipped to get from one element of the array to another along the associated dimension, or axis. This stride value can even be negative, indicating that the next element in the array is obtained by moving backward in memory. The extra complication of the (potentially) arbitrary striding means that constructing an iterator to handle the generic case is more difficult.</P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
