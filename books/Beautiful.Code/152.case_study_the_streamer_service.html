<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 20.4. Case Study: The Streamer Service</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>A Highly Reliable Enterprise System for NASA's Mars Rover Mission</SPAN><SPAN> &gt; Case Study: The Streamer Service</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=case_study_the_streamer_service></A>
<H3 class=docSection1Title id=-100000>20.4. Case Study: The Streamer Service</H3>
<P class=docText><A name="seen some"></A>You've seen some of the beauty of CIP at the architectural level. It's time to focus on one of its middleware services—the <A name=idx-CHP-20-1655></A><A name="and examine"></A>streamer service—as a case study, and examine some of the nails that allowed us to meet the mission's strict functional, reliability, and robustness requirements. You'll see that the nails were not particularly fancy; the beauty was in knowing just where to pound them in.<A name=idx-CHP-20-1656></A></P><A name=functionality></A>
<H4 class=docSection2Title id=title-ID0ECZDK>20.4.1. Functionality</H4>
<P class=docText><A name="MER mission"></A>One of the MER mission's data management needs is to allow users to download data and image files from the mission file servers located at JPL to their personal workstations and laptops. As described earlier, CIP data-tier utilities generate metadata that allow users to find the files they want based on various search criteria. Users also need to upload files that contain their analysis reports to the servers.<A name=idx-CHP-20-1657></A><A name=idx-CHP-20-1658></A></P>
<P class=docText><A name="performs file"></A>CIP's streamer service performs file downloading and uploading. We gave the service that name because it streams the file data securely across the Internet between the mission file servers at JPL and users' local computers. It uses the web services protocol, so client applications can be written in any language that supports the protocol, and these applications are free to devise whatever GUI they deem suitable.<A name=I_indexterm20_tt415></A></P><A name=service_architecture></A>
<H4 class=docSection2Title id=title-ID0ED1DK>20.4.2. Service Architecture</H4>
<P class=docText><A name="the other"></A>Like each of the other middleware services, the <A name=idx-CHP-20-1659></A>streamer service <A name=idx-CHP-20-1660></A><A name="Each request"></A>uses web services to receive client requests and to return responses. Each request is first fielded by the <A name=idx-CHP-20-1661></A><A name="which is"></A>streamer service provider, which is implemented by a stateless session bean. The service provider creates a <A name=idx-CHP-20-1662></A><A name="stateful session"></A>file reader, implemented by a stateful session bean, to do the actual work of downloading the requested file contents to the client. Conversely, the service provider creates a file writer, also implemented by a stateful session bean, to upload file contents (see <A class=docLink href="javascript:moveTo('the_streamer_service_architecture');">Figure 20-3</A>).<A name=idx-CHP-20-1663></A></P><A name=the_streamer_service_architecture></A>
<P>
<CENTER>
<H5 class=docFigureTitle>Figure 20-3. The streamer service architecture</H5><IMG id="" height=739 alt="" src="images/case_study_the_streamer_service.0.png" width=460 border=0> </CENTER>
<P></P><BR>
<P class=docText><A name="can be"></A>At any given moment, multiple users can be downloading or uploading files, and any single user can also have several download or upload operations going at once. So, there can be numerous file reader and file writer beans active in the middleware. A single stateless Streamer Service Provider bean handles all the requests, unless the load becomes heavy, at which time the application server can create more provider beans.<A name=idx-CHP-20-1664></A></P>
<P class=docText><A name="Why does"></A>Why does each file reader and file writer have to be a <SPAN class=docEmphasis>stateful</SPAN><A name="file is"></A> session bean? Unless the file is small, the streamer service transfers the file contents one block at a time in response to "Read Data Block" or "Write Data Block" requests from the client. (The download block size is configurable on the middleware server. The client application chooses the upload block size.) From one request to the next, the stateful bean keeps track of the open source or destination file on the mission file servers and the position within the file of the next block to be read or written.</P>
<P class=docText><A name="very simple"></A>This is a very simple architecture, but it very effectively handles multiple downloads simultaneously from multiple users. <A class=docLink href="javascript:moveTo('how_the_two-layer_service_handles_a_file_read');">Figure 20-4</A><A name="sequence of"></A> shows the sequence of events for downloading a file from the mission file servers to a user's local machine.</P><A name=how_the_two-layer_service_handles_a_file_read></A>
<P>
<CENTER>
<H5 class=docFigureTitle><A name="service handles"></A>Figure 20-4. How the two-layer service handles a file read</H5><IMG id="" height=419 alt="" src="images/case_study_the_streamer_service.1.png" width=500 border=0> </CENTER>
<P></P><BR>
<P class=docText>Note that the <A name=idx-CHP-20-1665></A><A name="service requests"></A>Streamer Service Provider bean does not maintain any state between service requests. It functions as a rapid service dispatcher that parcels work out to the stateful File Reader beans. Because it doesn't need to track requests or maintain state, it can handle requests intermingled from several client applications. Each File Reader bean maintains state information (where to get the next block of data) for a single client application as the application <A name=idx-CHP-20-1666></A><A name="Data Block"></A>makes multiple "Read Data Block" requests to download a complete file. This architecture enables the <A name=idx-CHP-20-1667></A><A name="multiple files"></A>streamer service to download multiple files to multiple clients simultaneously while providing acceptable throughput for all.</P>
<P class=docText><A name="a file"></A>The sequence of events for a file upload from a user's local machine to the mission file servers is just as straightforward. It's shown in <A class=docLink href="javascript:moveTo('how_the_two-layer_service_handles_a_file_write');">Figure 20-5</A>.</P><A name=how_the_two-layer_service_handles_a_file_write></A>
<P>
<CENTER>
<H5 class=docFigureTitle><A name="Figure "></A>Figure 20-5. How the two-layer service handles a file write</H5><IMG id="" height=375 alt="" src="images/case_study_the_streamer_service.2.png" width=500 border=0> </CENTER>
<P></P><BR>
<P class=docText><A name="but besides"></A>These tables don't show it, but besides a file token, each client request also includes a user token. A client application first obtains a user token when it <A name=idx-CHP-20-1668></A><A name="login request"></A>makes a successful login request (with a user name and password) to the middleware's user management service, thus authenticating the user. A user token contains information that identifies a particular user session, including the user's role. It enables the <A name=idx-CHP-20-1669></A><A name="to verify"></A>streamer service to verify that a request is coming from a legitimate user. It checks the user's role to ensure that she has the right to download a particular file. For example, the MER mission disallowed users from foreign (non-U.S.) countries from accessing certain files, and <A name=idx-CHP-20-1670></A><A name="such security"></A>CIP respected all such security restrictions.</P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
