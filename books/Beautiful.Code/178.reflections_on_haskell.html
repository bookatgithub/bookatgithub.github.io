<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 24.4. Reflections on Haskell</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>Beautiful Concurrency</SPAN><SPAN> &gt; Reflections on Haskell</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=reflections_on_haskell></A>
<H3 class=docSection1Title id=-100000>24.4. Reflections on Haskell</H3>
<P class=docText><A name="Haskell is"></A>Haskell is, first and foremost, a <SPAN class=docEmphasis>functional</SPAN><A name="it is"></A> language. Nevertheless, I think that it is also the world's most beautiful <SPAN class=docEmphasis>imperative</SPAN><A name="imperative language"></A> language. Considered as an imperative language, Haskell's unusual features are that:<A name=idx-CHP-24-2075></A></P>
<UL>
<LI>
<P class=docList><A name=idx-CHP-24-2076></A><A name="are rigorously"></A>Actions (which have effects) are rigorously distinguished from pure values by the type system.</P></LI>
<LI>
<P class=docList>Actions are <A name=idx-CHP-24-2077></A><A name="passed to"></A>first-class values. They can be passed to functions, returned as results, formed into lists, and so on, all without causing any side effects.</P></LI></UL>
<P class=docText>Using actions as first-class values, the programmer can define <SPAN class=docEmphasis>application-specific control structures</SPAN><A name="language designer"></A>, rather than make do with the ones provided by the language designer. For example, <TT>nTimes</TT><A name=simple></A> is a simple <TT>for</TT> loop, and <TT>choose</TT><A name="guarded command"></A> implements a sort of guarded command. We also saw other applications of actions as values. In the main program, we used Haskell's rich expression language (in this case, list comprehensions) to generate a list of actions, which we then performed in order, using <TT>sequence_</TT>. Earlier, when defining <TT>helper1</TT><A name="out an"></A>, we improved modularity by abstracting out an action from a chunk of code. To illustrate these points, I have perhaps overused Haskell's abstraction power in the Santa code, which is a very small program. For large programs, though, it is hard to overstate the importance of actions as values.<A name=idx-CHP-24-2078></A></P>
<P class=docText><A name="On the"></A>On the other hand, I have underplayed other aspects of Haskell—higher-order functions, lazy evaluation, data types, polymorphism, type classes, and so on—because of the focus on <A name=idx-CHP-24-2079></A><A name="programs are"></A>concurrency. Not many Haskell programs are as imperative as this one! You can find a great deal of information about Haskell at <A class=docLink href="http://haskell.org/" target=_blank>http://haskell.org</A><A name="and interpreters"></A>, including books, tutorials, Haskell compilers and interpreters, Haskell libraries, mailing lists, and much more besides.</P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
