<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 24.5. Conclusion</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>Beautiful Concurrency</SPAN><SPAN> &gt; Conclusion</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=conclusion-id012></A>
<H3 class=docSection1Title id=-100000>24.5. Conclusion</H3>
<P class=docText><A name="My main"></A>My main goal is to persuade you that you can write programs in a fundamentally more modular way using <A name=idx-CHP-24-2080></A><A name="can with"></A>STM than you can with locks and condition variables. First, though, note that transactional memory allows us to completely avoid many of the standard problems that plague lock-based <A name=idx-CHP-24-2081></A><A name="earlier in"></A>concurrent programs (as explained earlier in the section "Locks Are Bad"). <SPAN class=docEmphasis><A name="these problems"></A>None of these problems arises in STM Haskell</SPAN><A name="prevents you"></A>. The type system prevents you from reading or writing a <TT>TVar</TT> outside an atomic block, and because there <SPAN class=docEmphasis>are</SPAN><A name="simply do"></A> no programmer-visible locks, the questions of which locks to take, and in which order, simply do not arise. Other benefits of STM, which I lack the space to describe here, include freedom from lost wakeups and the treatment of exceptions and error recovery.<A name=idx-CHP-24-2082></A><A name=idx-CHP-24-2083></A></P>
<P class=docText><A name="also discussed"></A>However, as we also discussed in the section "Locks Are Bad," the worst problem with lock-based programming is that <SPAN class=docEmphasis>locks do not compose</SPAN><A name=an></A>. In contrast, any function with an <TT>STM</TT><A name="using sequencing"></A> type in Haskell can be composed, using sequencing or choice, with any other function with an <TT>STM</TT><A name="type to"></A> type to make a new function of <TT>STM</TT><A name="will guarantee"></A> type. Furthermore, the compound function will guarantee all the same atomicity properties that the individual functions did. In particular, blocking (<TT>retry</TT>) and choice (<TT>orElse</TT><A name="when expressed"></A>), which are fundamentally non-modular when expressed using locks, are fully modular in STM. For example, consider this transaction, which uses functions we defined in the section "Blocking and Choice":</P><PRE>	atomically (do { limitedWithdraw a1 10
	               ; limitedWithdraw2 a2 a3 20 })
</PRE><BR>
<P class=docText><A name="blocks until"></A>This transaction blocks until <TT>a1</TT><A name="and either"></A> contains at least 10 units, and either <TT>a2</TT> or <TT>a3</TT><A name="the programmer"></A> has 20 units. However, that complicated blocking condition is not written explicitly by the programmer, and indeed if the <TT>limitedWithdraw</TT><A name="implemented in"></A> functions are implemented in a sophisticated library, the programmer might have no idea what their blocking conditions are. STM is modular: small programs can be glued together to make larger programs <SPAN class=docEmphasis>without exposing their implementations</SPAN>.</P>
<P class=docText><A name=of></A>There are many aspects of <A name=idx-CHP-24-2084></A><A name="not covered"></A>transactional memory that I have not covered in this brief overview, including important topics such as nested transactions, exceptions, progress, starvation, and invariants. You can find many of them discussed in papers about STM Haskell.<SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-24-FNOTE-25');">[*****]</A></SUP></P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-24-FNOTE-25>[*****]</A></SUP><A name="Tim Harris"></A> Tim Harris, Simon Marlow, Simon Peyton <A name=idx-CHP-24-2085></A>Jones, and Maurice Herlihy, "Composable memory transactions," <SPAN class=docEmphasis><A name="Principles and"></A>ACM Symposium on Principles and Practice of Parallel Programming (PPoPP '05</SPAN><A name="and Simon"></A>), June 2005; Tim Harris and Simon Peyton Jones, "Transactional memory with data invariants," <SPAN class=docEmphasis><A name="SIGPLAN Workshop"></A>First ACM SIGPLAN Workshop on Languages, Compilers, and Hardware Support for Transactional Computing (TRANSACT '06</SPAN><A name="Simon Marlow"></A>), Ottawa, June 2006, ACM; Anthony Discolo, Tim Harris, Simon Marlow, Simon Peyton Jones, and Satnam Singh, "Lock-free data structures using STMs in Haskell," <SPAN class=docEmphasis>Eighth International Symposium on Functional and Logic Programming (FLOPS '06</SPAN>), April 2006.</P></BLOCKQUOTE>
<P class=docText><A name="potentially must"></A>Transactional memory is a particularly good "fit" for Haskell. In STM, the implementation potentially must track every memory load and store, but a Haskell STM need only track <TT>TVar</TT><A name="form only"></A> operations, and these form only a tiny fraction of all the memory loads and stores executed by a Haskell program. Furthermore, the treatment of actions as first-class values, and the rich type system, allow us to offer strong static guarantees without extending the language in any way. However, there is nothing to stop the adoption of transactional memory in mainstream imperative languages, although it may be less elegant and require more language support. Indeed doing so is a hot research topic; Larus and Rajwar give a comprehensive summary.<SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-24-FNOTE-26');">[<IMG alt=dagger src="images/U2020.GIF"><IMG alt=dagger src="images/U2020.GIF"><IMG alt=dagger src="images/U2020.GIF"><IMG alt=dagger src="images/U2020.GIF"><IMG alt=dagger src="images/U2020.GIF">]</A></SUP><A name=I_indexterm24_tt528></A><A name=I_indexterm24_tt529></A></P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-24-FNOTE-26>[<IMG alt=dagger src="images/U2020.GIF"><IMG alt=dagger src="images/U2020.GIF"><IMG alt=dagger src="images/U2020.GIF"><IMG alt=dagger src="images/U2020.GIF"><IMG alt=dagger src="images/U2020.GIF">]</A></SUP> James Larus and Ravi Rajwar, <SPAN class=docEmphasis>Transactional Memory</SPAN>, Morgan &amp; Claypool, 2006.</P></BLOCKQUOTE>
<P class=docText><A name="using a"></A>Using STM is like using a high-level language instead of assembly code—you can still write buggy programs, but many tricky bugs simply cannot occur, and it is much easier to focus attention on the higher-level aspects of the program. There is, alas, no silver bullet that will make concurrent programs easy to write. But STM looks like a promising step forward, and one that will help you to write beautiful code.</P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
