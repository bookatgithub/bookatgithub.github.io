<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Chapter 26. Labor-Saving Architecture: An Object-Oriented Framework for Networked Software</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>Labor-Saving Architecture: An Object-Oriented Framework for Networked Software</SPAN><SPAN> &gt; Sample Application: Logging Service</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=labor-saving_architecture_an_object-oriented_framework_for_n></A>
<H2 class=docChapterTitle id=title-ID0EFCEK>26. Labor-Saving Architecture: An Object-Oriented Framework for Networked Software</H2>
<P class=docText><SPAN class=docEmphasis><A name="William R"></A>William R. Otte and Douglas C. Schmidt</SPAN> <A name=idx-CHP-26-2245></A><A name=idx-CHP-26-2246></A><A name=idx-CHP-26-2247></A><A name=idx-CHP-26-2248></A></P>
<P class=docText><SPAN class=docEmphSmaller><A name="networked applications"></A>Developing software for networked applications is hard</SPAN><A name="software for"></A>, and developing reusable software for networked applications is even harder. First, there are the complexities inherent to distributed systems, such as optimally mapping application services onto hardware nodes, synchronizing service initialization, and ensuring availability while masking partial failures. These complexities can stymie even experienced software developers because they arise from fundamental challenges in the domain of network programming.</P>
<P class=docText><A name="also master"></A>Unfortunately, developers must also master <SPAN class=docEmphasis>accidental complexities</SPAN><A name="nonportable programming"></A>, such as low-level and nonportable programming interfaces and the use of function-oriented design techniques that require tedious and error-prone revisions as requirements and/or platforms evolve. These complexities arise largely from limitations with the software tools and techniques applied historically by developers of networked software.<A name=idx-CHP-26-2249></A></P>
<P class=docText><A name="user interfaces"></A>Despite the use of object-oriented technologies in many domains, such as graphical user interfaces and productivity tools, much networked software still uses C-level <A name=idx-CHP-26-2250></A><A name="application programmatic"></A>operating system (OS) application programmatic interfaces (APIs), such as the Unix <A name=idx-CHP-26-2251></A><A name=Windows></A>socket API or the Windows <A name=idx-CHP-26-2252></A><A name="networked programming"></A>threading API. Many accidental complexities of networked programming stem from the use of these C-level OS APIs, which are not type-safe, often not reentrant, and not portable across OS platforms. The C APIs were also designed before the wide-spread adoption of modern design methods and technologies, so they encourage developers to decompose their problems functionally in terms of processing steps in a top-down design, instead of using OO design and programming techniques. Experience over the past several decades has shown that <A name=idx-CHP-26-2253></A><A name="functional decomposition"></A>functional decomposition of nontrivial software complicates maintenance and evolution because functional requirements are rarely stable design centers. <SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-26-FNOTE-1');">[*]</A></SUP><A name=idx-CHP-26-2254></A></P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-26-FNOTE-1>[*]</A></SUP> <SPAN class=docEmphasis>Object-Oriented Software Construction</SPAN>, Second Edition, Bertrand Meyer, Prentice Hall, 1997.</P></BLOCKQUOTE>
<P class=docText><A name="advances in"></A>Fortunately, two decades of advances in design/implementation techniques and programming languages have made it much easier to write and reuse <A name=idx-CHP-26-2255></A><A name="languages "></A>networked software. In particular, object-oriented (OO) programming languages (such as C++, Java, and C#) combined with <SPAN class=docEmphasis>patterns</SPAN> (such as Wrapper Facades, <SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-26-FNOTE-2');">[<IMG alt=dagger src="images/U2020.GIF">]</A></SUP><A name="Template Method"></A>Adapters, and the Template Method <SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-26-FNOTE-3');">[<IMG alt="double dagger" src="images/U2021.GIF">]</A></SUP>), and frameworks (such as <A name=idx-CHP-26-2257></A><A name="like ACE"></A>host infrastructure middleware like ACE<SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-26-FNOTE-4');">[§]</A></SUP> and the Java <A name=idx-CHP-26-2258></A>class libraries for network programming, <SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-26-FNOTE-5');">[||]</A></SUP>and similar <A name=idx-CHP-26-2260></A><A name="syntactic and"></A>host infrastructure middleware) help to encapsulate low-level functional OS APIs and mask syntactic and semantic differences between platforms. As a result, developers can focus on application-specific behavior and properties in their software, rather than repeatedly wrestling with the accidental complexities of programming the low-level networking and OS infrastructure.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-26-FNOTE-2>[<IMG alt=dagger src="images/U2020.GIF">]</A></SUP> <SPAN class=docEmphasis><A name="for Concurrent"></A>Pattern-Oriented Software Architecture, Vol. 2: Patterns for Concurrent and Networked Objects</SPAN>, Douglas <A name=idx-CHP-26-2256></A><A name="John Wiley"></A>Schmidt, Michael Stal, Hans Rohnert, and Frank Buschmann, John Wiley and Sons, 2000.</P></BLOCKQUOTE>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-26-FNOTE-3>[<IMG alt="double dagger" src="images/U2021.GIF">]</A></SUP> <SPAN class=docEmphasis>Design Patterns: Elements of Reusable Object-Oriented Software</SPAN>, Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, Addison-Wesley, 1995.</P></BLOCKQUOTE>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-26-FNOTE-4>[§]</A></SUP><A name="and Frameworks"></A> C++ Network Programming, Vol. 2: Systematic Reuse with ACE and Frameworks, Douglas C. Schmidt and Stephen D. Huston, Addison-Wesley Longman, 2003.</P></BLOCKQUOTE>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-26-FNOTE-5>[||]</A></SUP> <SPAN class=docEmphasis><A name="Java Network"></A>Java Network Programming</SPAN>, Third Edition, <A name=idx-CHP-26-2259></A>Elliotte Rusty Harold, O'Reilly, 2004.</P></BLOCKQUOTE>
<P class=docText><A name="of applying"></A>A key benefit of applying patterns and frameworks <A name=idx-CHP-26-2261></A><A name="is that"></A>to networked software is that they can help developers craft reusable architectures that (1) capture the common structure and behavior in a particular domain, and (2) make it easy to change or replace various algorithms, policies, and mechanisms selectively without affecting other existing parts of the architecture. While most developers of networked software can apply well-designed OO frameworks to their applications, the knowledge of how to create such a framework remains a black art that has historically been learned only by extensive (and expensive) trial and error.</P>
<P class=docText><A name="to the"></A>In addition to the conventional challenges of devising a flexible OO design that can expand and contract to meet new requirements, networked software must often run efficiently and scalably in a range of operating environments. The goal of this chapter is to help demystify the black art of OO <A name=idx-CHP-26-2262></A><A name="software by"></A>frameworks for networked software by using a case study to systematically dissect the design and implementation of a representative networked software application.</P>
<P class=docText><A name="of patterns"></A>In general, the beauty of our solution stems from its use of patterns and OO techniques to balance key domain forces, such as reusability, extensibility, and performance. In particular, our approach enables developers to identify common design/programming artifacts, thereby enhancing reuse. It also provide a means to encapsulate variabilities in a common and parameterizable way, thereby enhancing extensibility and portability.</P><A name=sample_application_logging_service></A>
<H3 class=docSection1Title id=-100000>26.1. Sample Application: Logging Service</H3>
<P class=docText><A name="software that"></A>The OO software that we use as the basis of our case study is a <A name=idx-CHP-26-2263></A><A name=in></A>networked logging service. As shown in <A class=docLink href="javascript:moveTo('architecture_of_a_networked_logging_service');">Figure 26-1</A><A name="applications that"></A>, this service consists of client applications that generate log records and send them to a central logging server that receives and stores the log records for later inspection and processing.<A name=idx-CHP-26-2264></A></P><A name=architecture_of_a_networked_logging_service></A>
<P>
<CENTER>
<H5 class=docFigureTitle><A name="Figure "></A>Figure 26-1. Architecture of a networked logging service</H5><IMG id="" height=389 alt="" src="images/labor-saving_architecture_an_object-oriented_framework_for_n.0.png" width=500 border=0> </CENTER>
<P></P><BR>
<P class=docText><A name="portion "></A>The logging server portion (at the center of <A class=docLink href="javascript:moveTo('architecture_of_a_networked_logging_service');">Figure 26-1</A><A name="logging service"></A>) of our networked logging service provides an ideal context for demonstrating the beauty of OO <A name=idx-CHP-26-2265></A><A name="because it"></A>networked software because it exhibits the following dimensions of design-time variability that developers can choose from when implementing such a server:</P>
<UL>
<LI>
<P class=docList>Different interprocess communication (<A name=idx-CHP-26-2266></A><A name="named pipes"></A>IPC) mechanisms (such as sockets, SSL, shared memory, TLI, named pipes, etc.) that developers can use to send and receive log records.</P></LI>
<LI>
<P class=docList><A name=idx-CHP-26-2267></A><A name="can use"></A>Different concurrency models (such as iterative, reactive, thread-per-connection, process-per-connection, various types of thread pools, etc.) that developers can use to process log records.</P></LI>
<LI>
<P class=docList>Different locking <A name=idx-CHP-26-2268></A><A name="or process"></A>strategies (such as thread-level or process-level recursive mutex, nonrecursive mutex, readers/writer lock, null mutex, etc.) that developers can use to serialize access to resources, such as a count of the number of requests, shared by multiple threads.</P></LI>
<LI>
<P class=docList>Different <A name=idx-CHP-26-2269></A><A name="can be"></A>log record formats that can be transmitted from client to server. Once received by the server, the log records can be handled in different ways—e.g., printed to console, stored to a single file, or even one file per client to maximize parallel writes to disk.</P></LI></UL>
<P class=docText><A name="implement any"></A>It is relatively straightforward to implement any one of these combinations, such as running one thread per connection-logging server using socket-based IPC and a thread-level nonrecursive mutex. A one-size-fits-all solution, however, is inadequate to meet the needs of all logging services because different customer requirements and different operating environments can have significantly different impacts on time/space trade-offs, cost, and schedule. A key challenge is therefore to design a configurable logging server that is <SPAN class=docEmphasis><A name="easily extensible"></A>easily extensible</SPAN><A name="needs with"></A> to meet new needs with a <SPAN class=docEmphasis>minimum of effort</SPAN>.</P>
<P class=docText><A name="of the"></A>At the heart of the solution to this challenge is a thorough understanding of the patterns and associated design techniques needed to develop OO frameworks that efficiently:</P>
<UL>
<LI>
<P class=docList><A name="structure and"></A>Capture common structure and behavior in base classes and generic classes</P></LI>
<LI>
<P class=docList><A name="of behavior"></A>Enable selective customization of behavior via subclasses and by providing concrete parameters to generic classes</P></LI></UL>
<P class=docText><A class=docLink href="javascript:moveTo('object-oriented_design_for_the_logging_server_framework');">Figure 26-2</A> illustrates the design of an OO <A name=idx-CHP-26-2270></A><A name="design is"></A>logging server framework that realizes these goals. The core of this design is the <TT>Logging_Server</TT><A name="the common"></A> class, which defines the common structure and functionality for the logging server via the use of:<A name=idx-CHP-26-2271></A><A name=idx-CHP-26-2272></A></P>
<UL>
<LI>
<P class=docList><A name=idx-CHP-26-2273></A>C++ <A name=idx-CHP-26-2274></A><A name="to defer"></A>parameterized types, which allow developers to defer the selection of data types <A name=idx-CHP-26-2275></A><A name="functions until"></A>used in generic classes or functions until their point of instantiation</P></LI>
<LI>
<P class=docList><A name=The></A>The <A name=idx-CHP-26-2276></A><A name="defines the"></A>Template Method pattern, which defines the skeleton of an algorithm, delegating individual steps to methods that may be overridden by subclasses</P></LI>
<LI>
<P class=docList>The <A name=idx-CHP-26-2277></A><A name="encapsulates non"></A>Wrapper Facade pattern, which encapsulates non-object-oriented APIs and data within type-safe object-oriented classes</P></LI></UL>
<P class=docText><A name="concrete instantiations"></A>Subclasses and concrete instantiations of <TT>Logging_Server</TT><A name="reusable architecture"></A> refine this common reusable architecture to customize variable steps in the logging server behavior by selecting desired IPC mechanisms, concurrency models, and locking strategies. The <TT>Logging_Server</TT> is thus a <SPAN class=docEmphasis>product-line architecture</SPAN> <SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-26-FNOTE-6');">[#]</A></SUP><A name="define a"></A>that defines an integrated set of classes that collaborate to define a reusable design for a family of related logging servers.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-26-FNOTE-6>[#]</A></SUP> <A name=idx-CHP-26-2278></A><A name="Practices and"></A>Software Product Lines: Practices and Patterns, Paul Clements and Linda Northrop, Addison-Wesley, 2001.</P></BLOCKQUOTE><A name=object-oriented_design_for_the_logging_server_framework></A>
<P>
<CENTER>
<H5 class=docFigureTitle><A name="logging server"></A>Figure 26-2. Object-oriented design for the logging server framework</H5><IMG id="" height=494 alt="" src="images/labor-saving_architecture_an_object-oriented_framework_for_n.1.png" width=500 border=0> </CENTER>
<P></P><BR>
<P class=docText><A name="is organized"></A>The remainder of this chapter is organized as follows. The next section describes the OO <A name=idx-CHP-26-2279></A><A name="design of"></A>design of the logging server framework, exploring its architecture and the forces that influence the design of the OO framework to illustrate why we selected certain patterns and language features, as well as summarizing alternative approaches that we rejected for various reasons. Two further sections present several C++ sequential programming instantiations of the logging server framework and of concurrent programming instantiations of this framework. We conclude by summarizing the beauty of the OO software concepts and techniques in this chapter.<A name=idx-CHP-26-2280></A><A name=idx-CHP-26-2281></A></P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
