<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 26.4. Implementing Concurrent Logging Servers</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>Labor-Saving Architecture: An Object-Oriented Framework for Networked Software</SPAN><SPAN> &gt; Implementing Concurrent Logging Servers</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=implementing_concurrent_logging_servers></A>
<H3 class=docSection1Title id=-100000>26.4. Implementing Concurrent Logging Servers</H3>
<P class=docText><A name="To overcome"></A>To overcome the scalability limitations of the iterative and reactive servers shown in the previous sections, the logging servers in this section use OS <A name=idx-CHP-26-2358></A><A name="Using the"></A>concurrency mechanisms: processes and threads. Using the APIs provided by operating systems to spawn threads or processes, however, can be a daunting task due to accidental complexities in their design. These complexities stem from semantic and syntactic differences that exist not only between different operating systems, but also different versions of the same operating system. Our solution to these complexities is again to apply wrapper facades that provide a consistent interface across platforms and integrate these wrapper facades into our OO <TT>Logging_Server</TT> framework.<A name=idx-CHP-26-2359></A><A name=idx-CHP-26-2360></A></P><A name=a_thread-per-connection_logging_server></A>
<H4 class=docSection2Title id=title-ID0EFEEK>26.4.1. A Thread-per-Connection Logging Server</H4>
<P class=docText>Our thread-per-connection logging server (<TT>TPC_Logging_Server</TT><A name="thread that"></A>) runs a main thread that waits for and accepts new connections from clients. After accepting a new connection, a new worker thread is spawned to handle incoming log records from that connection. <A class=docLink href="javascript:moveTo('steps_in_the_thread-per-connection_logging_server');">Figure 26-10</A><A name="steps in"></A> shows the steps in this process.</P><A name=steps_in_the_thread-per-connection_logging_server></A>
<P>
<CENTER>
<H5 class=docFigureTitle><A name="the thread"></A>Figure 26-10. Steps in the thread-per-connection logging server</H5><IMG id="" height=160 alt="" src="images/implementing_concurrent_logging_servers.0.png" width=500 border=0> </CENTER>
<P></P><BR>
<P class=docText><A name="the steps"></A>The main loop for this particular logging server differs from the steps depicted in <A class=docLink href="188.object-oriented_design_of_the_logging_server_framework.html#logging_server_main_loop">Figure 26-3</A><A name="call to"></A> because the call to <TT>handle_data( )</TT><A name="worker threads"></A> is not necessary, as the worker threads are responsible for that call. There are two ways to handle this situation:<A name=I_indexterm26_tt632></A></P>
<UL>
<LI>
<P class=docList><A name=base></A>We could note that the base <TT>run( )</TT><A name="method calls"></A> method calls <TT>handle_data( )</TT><A name="argument of"></A> with the default argument of a <TT>NULL</TT><A name="our implementation"></A> pointer, and simply have our implementation exit immediately for that input.</P></LI>
<LI>
<P class=docList><A name="simply override"></A>We could simply override the <TT>run( )</TT><A name="own implementation"></A> method with our own implementation that omits this call.</P></LI></UL>
<P class=docText><A name="avoids a"></A>The second solution may at first appear advantageous because it avoids a virtual method call to <TT>handle_data( )</TT><A name="solution is"></A>. The first solution is better in this case, however, because the performance hit of that virtual call is not a limiting factor, and overriding the <TT>run( )</TT><A name="this class"></A> template method would prevent this class from benefiting from changes to the base class implementation, potentially causing it to fail in subtle and pernicious ways.</P>
<P class=docText>The main challenge here is <A name=idx-CHP-26-2361></A><A name="with the"></A>implementing the concurrency strategy itself. As with the <TT>Iterative_Server</TT><A name="in the"></A> in the earlier section "An Iterative <A name=idx-CHP-26-2362></A>Logging Server," the <TT>wait_for_ multiple_events( )</TT><A name="because our"></A> method is superfluous because our main loop simply waits for new connections, so it is sufficient for <TT>handle_connections( )</TT> to block on <TT>accept( )</TT><A name="worker threads"></A> and subsequently spawn worker threads to handle connected clients. Our <TT>TPC_Logging_Server</TT><A name="therefore provide"></A> class must therefore provide a method to serve as an entry point for the thread. In C and C++, a class method may serve as an entry point to a thread only if the class is defined as static, so we define the <TT>TPC_Logging_Server::svc( )</TT> static class method.</P>
<P class=docText><A name="have an"></A>At this point, we have an important design decision to make: what exactly does the thread entry point do? It is tempting to simply have the <TT>svc( )</TT><A name="log records"></A> method itself perform all of the work necessary to receive log records from its associated connection. This design is less than ideal, however, because static methods cannot be virtual, as that would cause problems if we later derive a new logging server from this implementation to change the way it handles data events. Application developers would then be forced to provide an implementation of <TT>handle_connections( )</TT><A name="textually identical"></A> that is textually identical to this class to call the proper static method.</P>
<P class=docText><A name="design and"></A>Moreover, to leverage our existing design and code, it is preferable to have the log record processing logic inside the <TT>handle_data( )</TT> method and to define a <TT>Thread_Args</TT><A name="peer returned"></A> helper object that holds the peer returned from <TT>accept( )</TT><A name="and a"></A> and a pointer to the <TT>Logging_Server</TT><A name="interface will"></A> object itself. Our class interface will therefore look like the diagram in <A class=docLink href="javascript:moveTo('thread-per-connection_server_interface');">Figure 26-11</A>.</P><A name=thread-per-connection_server_interface></A>
<P>
<CENTER>
<H5 class=docFigureTitle>Figure 26-11. Thread-per-connection server interface</H5><IMG id="" height=204 alt="" src="images/implementing_concurrent_logging_servers.1.png" width=500 border=0> </CENTER>
<P></P><BR>
<P class=docText>The remainder of <TT>TPC_Logging_Server</TT><A name="requiring only"></A> is straightforward to implement, requiring only that our thread entry point delegate processing to the virtual method <TT>handle_data( )</TT> using the <TT>server_pointer</TT><A name=the></A> contained within the <TT>Thread_Args</TT><A name="to the"></A> helper object passed to the <TT>svc( )</TT> method, as shown in <A class=docLink href="javascript:moveTo('thread-per-connection_thread_behavior');">Figure 26-12</A>.<A name=idx-CHP-26-2363></A></P><A name=thread-per-connection_thread_behavior></A>
<P>
<CENTER>
<H5 class=docFigureTitle>Figure 26-12. Thread-per-connection thread behavior</H5><IMG id="" height=276 alt="" src="images/implementing_concurrent_logging_servers.2.png" width=500 border=0> </CENTER>
<P></P><BR>
<P class=docText>The following code implements a <TT>TPC_Logging_Server</TT> main program that uses the secure socket API and the readers/writer lock:</P><PRE>	int main (int argc, char *argv[]) {
	  TPC_Logging_Server&lt;SSL_Acceptor, RW_Lock&gt; server (argc, argv);
	  server.run ();
	  return 0;
	}
</PRE><BR>
<P class=docText>This <TT>main( )</TT> function instantiates a <TT>TPC_Logging_Server</TT> that communicates using SSL connections, and uses an <TT>RW_Lock</TT> to synchronize the <TT>count_connections( )</TT> function in the <TT>Logging_Server</TT> base class. Except for the name of the class we are instantiating, <TT>this main( )</TT><A name="in this"></A> function is identical to the one that was written earlier in this chapter for the <TT>Reactive_Logging_Server</TT><A name="is another"></A>. This commonality is another beautiful aspect of our design: regardless of the particular combination of concurrency, IPC, and synchronization mechanisms we choose to use, the instantiation and invocation of our server remains the same.</P>
<P class=docText><A name="the scalability"></A>The thread-per-connection logging service addresses the scalability limitations with the sequential implementations described earlier in the section "Evaluating the Sequential Logging Server Solutions." The design of our OO <A name=idx-CHP-26-2364></A><A name="integrate this"></A>framework makes it straightforward to integrate this concurrency model with minimal changes to the existing code. In particular, <TT>TPC_Logging_Server</TT><A name="inherits implementations"></A> inherits implementations of <TT>open( )</TT>, <TT>count_request( )</TT>, and most importantly <TT>run( )</TT><A name="to leverage"></A>, allowing this class to leverage bug fixes and improvements to our main event loop transparently. Moreover, adding the necessary synchronization around the <TT>request_count_ is</TT><A name="of parameterizing"></A> simply a matter of parameterizing the <TT>TPC_Logging_Server</TT> with the <TT>RW_LOCK</TT> class.</P><A name=a_process-per-connection_logging_server></A>
<H4 class=docSection2Title id=title-ID0EDLEK>26.4.2. A Process-per-Connection Logging Server</H4>
<P class=docText><A name="server described"></A>The process-per-connection logging server described next is similar to the thread-per-connection design shown in <A class=docLink href="javascript:moveTo('steps_in_the_thread-per-connection_logging_server');">Figure 26-10</A><A name="of spawning"></A>, except that instead of spawning a thread, we spawn a new process to handle incoming log records from each client. The choice of processes over threads for concurrency forces us to make design choices to accommodate the variations in process-creation semantics between platforms. There are two key semantic differences between the process APIs on Linux and Windows that our server design must encapsulate:<A name=idx-CHP-26-2365></A></P>
<UL>
<LI>
<P class=docList><A name="processes is"></A>In Linux (and other POSIX systems) the primary vehicle for creating new processes is the <TT>fork( )</TT><A name="generates an"></A> system function, which generates an exact duplicate of the calling program image, including open I/O handles. The processes differ only in their return value from <TT>fork( )</TT><A name="can choose"></A>. At this point, child processes can choose to proceed from that point, or load a different program image using the <TT>exec*( )</TT> family of system calls.</P></LI>
<LI>
<P class=docList>Windows, however, uses the <TT>CreateProcess( )</TT><A name="to a"></A> API call, which is functionally equivalent to a POSIX <TT>fork( )</TT><A name="followed immediately"></A>, followed immediately by a call to one of the <TT>exec*( )</TT><A name="of this"></A> system functions. The impact of this difference is that in Windows you have an <SPAN class=docEmphasis>entirely new process</SPAN> that by default <SPAN class=docEmphasis>does not</SPAN><A name="handles open"></A> have access to I/O handles open in the parent. To use a connection accepted by the parent process, therefore, the handle must be explicitly duplicated and passed to the child on the command line.</P></LI></UL>
<P class=docText><A name="define a"></A>We therefore define a set of wrapper facades that not only hide the syntactic differences between platforms, but also provide a way to hide the semantic differences as well. These wrappers consist of the three cooperating classes shown in <A class=docLink href="javascript:moveTo('portable_process_wrapper_facades');">Figure 26-13</A>. The <TT>Process</TT><A name="single process"></A> class represents a single process and is used to create and synchronize processes. The <TT>Process_Options</TT><A name="options and"></A> class provides a way to set both platform-independent process options (such as command-line options and environment variables) and platform-specific process options (such as avoiding zombie processes). Finally, the <TT>Process_Manager</TT><A name="manages the"></A> class portably manages the life cycle of groups of processes. We won't cover all the uses of these wrapper facades in this chapter, though they are based on the wrapper facades in ACE. <SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-26-FNOTE-17');">[||||||]</A></SUP><A name="know that"></A>It is sufficient to know that not only can processes be created portably on Linux and Windows, but also that I/O handles can be duplicated and passed portably and automatically to the new process.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-26-FNOTE-17>[||||||]</A></SUP> <SPAN class=docEmphasis>C</SPAN>++ <SPAN class=docEmphasis><A name="and Patterns"></A>Network Programming, Vol. 1: Mastering Complexity with ACE and Patterns</SPAN><A name="Douglas C"></A>, Douglas C. <A name=idx-CHP-26-2366></A>Schmidt and Stephen D. Huston, Addison-Wesley, 2001.</P></BLOCKQUOTE>
<P class=docText><A name="is therefore"></A>The design challenge is therefore to accommodate the fact that processes spawned after new connections are accepted will start at the beginning of our program. We certainly don't want child processes to attempt to open a new acceptor and listen for connections of their own; instead, they should listen for data events only on their assigned handle. A naïve solution to this problem would rely on applications to detect this condition and call a special entry point defined in the interface to our process-based <TT>Logging_Server</TT> class.</P><A name=portable_process_wrapper_facades></A>
<P>
<CENTER>
<H5 class=docFigureTitle><A name="wrapper facades"></A>Figure 26-13. Portable process wrapper facades</H5><IMG id="" height=378 alt="" src="images/implementing_concurrent_logging_servers.3.png" width=432 border=0> </CENTER>
<P></P><BR>
<P class=docText><A name="is less"></A>This simple solution, however, is less than ideal. It would require us not only to change the public interface of our process-based <TT>Logging_Server</TT><A name="intimate implementation"></A>, but to expose intimate implementation details to applications, violating encapsulation. A better solution is to override the <TT>run( )</TT> template method inherited from the <TT>Logging_Server</TT><A name="to determine"></A> base class, which is passed a copy of the command-line argument by users, to determine whether it has been passed any I/O handles. If not, the process assumes it is a parent and delegates to the base class <TT>run( )</TT><A name="assumes it"></A> method. Otherwise, the process assumes it's a child, so it decodes the handle and <TT>calls handle_data( )</TT>, as shown in <A class=docLink href="javascript:moveTo('process-per-connection_run_template_method');">Figure 26-14</A>.<A name=idx-CHP-26-2367></A></P><A name=process-per-connection_run_template_method></A>
<P>
<CENTER>
<H5 class=docFigureTitle>Figure 26-14. Process-per-connection run( ) template method</H5><IMG id="" height=211 alt="" src="images/implementing_concurrent_logging_servers.4.png" width=500 border=0> </CENTER>
<P></P><BR>
<P class=docText><A name="server implementation"></A>The remainder of this server implementation is straightforward. As shown in <A class=docLink href="javascript:moveTo('connection_handling_for_the_process-per-connection_server');">Figure 26-15</A><A name="the procedure"></A>, the process wrapper facade makes the procedure for spawning our worker processes fairly simple. The implementation for <TT>handle_data( )</TT><A name="should be"></A> should be textually identical to that shown in <A class=docLink href="javascript:moveTo('thread-per-connection_thread_behavior');">Figure 26-12</A>.</P><A name=connection_handling_for_the_process-per-connection_server></A>
<P>
<CENTER>
<H5 class=docFigureTitle><A name="for the"></A>Figure 26-15. Connection handling for the process-per-connection server</H5><IMG id="" height=376 alt="" src="images/implementing_concurrent_logging_servers.5.png" width=500 border=0> </CENTER>
<P></P><BR>
<P class=docText><A name=the></A>Our reimplementation of the <TT>run( )</TT><A name=the></A> method from the <TT>Logging_Server</TT><A name="us to"></A> base class allows us to maintain the beautifully simple, straightforward, and uniform invocation used by our other logging servers:</P><PRE>	int main (int argc, char *argv[]) {
	  PPC_Logging_Server&lt;SSL_Acceptor, Null_Mutex&gt; server (argc, argv);
	  server.run ( );
	  return 0;
	}
</PRE><BR>
<P class=docText>This <TT>main( )</TT><A name="the class"></A> program differs from the thread-per-connection server only in the name of the class that is instantiated and the choice of a <TT>Null_Mutex</TT><A name="dispatch of"></A> for synchronization. The dispatch of either a parent or a child process is handled transparently by the <TT>run( )</TT><A name="passed to"></A> method, driven by the command-line arguments passed to the <TT>PPC_Logging_Server</TT> constructor.</P><A name=evaluating_the_concurrent_logging_server_solutions></A>
<H4 class=docSection2Title id=title-ID0EVQEK>26.4.3. Evaluating the Concurrent Logging Server Solutions</H4>
<P class=docText>Both <A name=idx-CHP-26-2368></A><A name="this section"></A>concurrent logging servers described in this section significantly enhance the <TT>Reactive_Logging_Server</TT><A name=and></A> and <TT>Iterative_Logging_Server</TT><A name="to scale"></A> in their ability to scale as the number of clients increases by taking leveraging hardware and OS support for multiple threads of execution. It is hard, however, to develop thread-per-connection and process-per-connection concurrency strategies in a platform-agnostic manner. We accomplished this task by using wrapper facades to hide platform differences. Our <A name=idx-CHP-26-2369></A><A name="provided a"></A>framework-based server design also provided a common external interface to the <TT>Logging_Server</TT><A name="bulk of"></A> class, shielding the bulk of the logging server from the configured concurrency strategy. Moreover, our design leveraged the <TT>run( )</TT><A name="from the"></A> template method inherited from the <TT>Logging_Server</TT><A name="enhancements to"></A> base class, allowing our implementations to integrate bug fixes or other enhancements to the main server event loop.</P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
