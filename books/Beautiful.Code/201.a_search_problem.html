<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 28.3. A Search Problem</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>Beautiful Debugging</SPAN><SPAN> &gt; A Search Problem</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=a_search_problem></A>
<H3 class=docSection1Title id=-100000>28.3. A Search Problem</H3>
<P class=docText><A name="come back"></A>Let's come back to our initial problem of debugging the debugger. Even after isolating and fixing the bug, I wondered: is there a way to find the failure-inducing change automatically? What one would need is a test that is automatically invoked each time the programmer changes something. As soon as the test broke, we would know what had changed most recently so we could immediately fix it. (A few years later, David Saff and Michael Ernst implemented this idea under the name <SPAN class=docEmphasis>continuous testing</SPAN>.)<A name=idx-CHP-28-2445></A><A name=idx-CHP-28-2446></A></P>
<P class=docText><A name="knew the"></A>In my situation, I knew the change that had caused the test to fail—it was the change from <SPAN class=docEmphasis>gdb</SPAN> 4.16 to <SPAN class=docEmphasis>gdb</SPAN><A name="that the"></A> 4.17. The problem was that the change was so <SPAN class=docEmphasis>huge</SPAN><A name="should be"></A>, affecting 8,721 locations. There should be a way to break down this change into smaller pieces.</P>
<P class=docText><A name="tried to"></A>What if I tried to split it into 8,721 smaller changes, each affecting just one location? This way, I could apply and test one change after the other until the test failed—and the last change applied would be the one that broke the test. In other words, I would simulate the 4.17 version's development history. (Actually, it would not be me who would simulate the history; instead, it would be a tool I built. And while I would be sitting sipping my tea, playing a game with my kids, or catching up my email stream, this nifty little tool would search and find the failure-inducing change. Neat.)</P>
<P class=docText>There was a catch, though. <SPAN class=docEmphasis><A name="changes had"></A>I had no clue about the order in which the changes had to be applied</SPAN><A name="was crucial"></A>. And this was crucial because the individual changes may depend on each other. For instance, change A may introduce a variable that would be used in new code included in other changes B or C. Whenever B or C are applied, A must be applied, too; otherwise, building <SPAN class=docEmphasis>gdb</SPAN><A name="rename some"></A> would fail. Likewise, change X may rename some function definition; other changes (Y, Z) in other locations may reflect this renaming. If X is applied, Y and Z must be applied as well, because again, otherwise, <SPAN class=docEmphasis>gdb</SPAN> would not build.</P>
<P class=docText><A name="one change"></A>How does one determine whether one change depends upon another? This problem looked quite hard—and almost intractable without very fancy (and not yet existing) multiversion program analysis.</P>
<P class=docText><A name="How about"></A>How about just trying out various orderings of changes? 8,721 individual changes can be ordered in 8,721 x 8,720 x 8,719 x … x 1 = 8,721! <A name=idx-CHP-28-2447></A><A name="anyone could"></A>different ways. No way anyone could test all of them. Trying out all subsets is somewhat better: 8,721 changes mean 2<SUP>8,721</SUP> =10<SUP>2,625</SUP><A name="a lot"></A> possible subsets, which means a lot fewer tests than 8,721 orderings. I could try to console myself with the thought that by the time these computations had ended on my machine, quantum computing, time travel, and universally correct programs would long have gone mainstream, eliminating the need for such futile attempts.</P>
<P class=docText><A name="another try"></A>So, I made another try. How about good old <A name=idx-CHP-28-2448></A><A name="could start"></A>divide and conquer? We could start applying the first half of changes to the <SPAN class=docEmphasis>gdb</SPAN> 4.16 source and test it. If <SPAN class=docEmphasis>ddd</SPAN><A name="if it"></A> failed, we would know that the failure-inducing change was in that first half; if it did not fail, we'd keep on searching in the other half. With each test, we'd reduce the search space by one-half, and thus finally end up in the failure-inducing change. That's it, I thought: an automatic application of the scientific method, systematically creating, testing, and refining hypotheses.</P>
<P class=docText><A name="we do"></A>But again—what do we do if applying a set of changes ends in inconsistent code? I had no idea.</P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
