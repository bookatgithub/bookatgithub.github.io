<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 28.6. Minimizing Input</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>Beautiful Debugging</SPAN><SPAN> &gt; Minimizing Input</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=minimizing_input></A>
<H3 class=docSection1Title id=-100000>28.6. Minimizing Input</H3>
<P class=docText><A name="The interesting"></A>The interesting thing about delta <A name=idx-CHP-28-2456></A><A name="automation of"></A>debugging (or any other automation of the scientific method) is that it is very general. Rather than search for causes in a set of changes, you can also search for causes in other search spaces. For instance, you can easily apply <A name=idx-CHP-28-2457></A><A name="search for"></A>delta debugging to search for failure causes in program input, which Ralf Hildebrandt and I did in 2002.<A name=idx-CHP-28-2458></A><A name=idx-CHP-28-2459></A><A name=idx-CHP-28-2460></A></P>
<P class=docText><A name="for causes"></A>When searching for causes in program input, the program code stays the same: no application of changes, no reconstruction, just execution. Instead, it is the input that changes. Think of a program that works on most inputs, but fails on one specific input. One can easily have <A name=idx-CHP-28-2461></A><A name="the failure"></A>delta debugging isolate the failure-inducing difference between the two inputs: "The cause of the web browser crashing is the <TT>&lt;SELECT&gt;</TT> tag in line 40."</P>
<P class=docText><A name="a minimized"></A>One can also modify the algorithm so that it returns a minimized input: "To have the web browser crash, just feed it a web page containing <TT>&lt;SELECT&gt;</TT><A name="every single"></A>." In minimized input, every single remaining character is relevant for the failure to occur. Minimized inputs can be very valuable for debuggers because they make things simple: they lead to shorter executions and smaller states to be examined. As an important (and perhaps beautiful) side effect, they capture the essence of the failure.</P>
<P class=docText><A name="programmers who"></A>I once met some programmers who were dealing with bugs in a third-party database. They had very complex, machine-generated SQL queries that sometimes would cause the database to fail. The vendor did not categorize these bugs as high priority because "you are our only customer dealing with such complex queries." Then the programmers simplified a one-page SQL query to a single line that still triggered the failure. Faced with this single line, the vendor immediately gave the bug the highest priority and fixed it.<A name=I_indexterm28_tt669></A><A name=I_indexterm28_tt670></A></P>
<P class=docText><A name="easiest way"></A>How does one achieve minimization? The easiest way is to feed <TT>dd()</TT><A name="with an"></A> with an empty <TT>c_pass</TT><A name="a passing"></A>, and to have a passing test return "pass" only if the input is empty, and "unresolved" otherwise. <TT>c_pass</TT> remains unchanged while <TT>c_fail</TT><A name="smaller with"></A> becomes smaller and smaller with each failing test.</P>
<P class=docText><A name="is required"></A>Again, all that is required to isolate such <A name=idx-CHP-28-2462></A><A name=an></A>failure causes is an <A name=idx-CHP-28-2463></A><A name="smaller pieces"></A>automated test and a means to split the input into smaller pieces—that is, a splitting function that has some basic knowledge about the syntax of the input.</P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
