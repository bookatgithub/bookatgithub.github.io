<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Chapter 29. Treating Code As an Essay</title>
</head><body>
<DIV></DIV>
<DIV>
<DIV><A name=treating_code_as_an_essay></A>
<H2 class=docChapterTitle id=title-ID0E4IEK>29. Treating Code As an Essay</H2>
<P class=docText><SPAN class=docEmphasis><A name="Yukihiro Matsumoto"></A>Yukihiro Matsumoto</SPAN> <A name=idx-CHP-29-2475></A><A name=idx-CHP-29-2476></A></P>
<P class=docText><SPAN class=docEmphSmaller><A name="attributes with"></A>Programs share some attributes with essays</SPAN><A name="important question"></A>. For essays, the most important question readers ask is, "What is it about?" For programs, the main question is, "What does it do?" In fact, the purpose should be sufficiently clear that neither question ever needs to be uttered. Still, for both essays and computer code, it's always important to look at how each one is written. Even if the idea itself is good, it will be difficult to transmit to the desired audience if it is difficult to understand. The style in which they are written is just as important as their purpose. Both essays and lines <A name=idx-CHP-29-2477></A><A name="are meant"></A>of code are meant—before all else—to be read and understood by human beings.<SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-29-FNOTE-1');">[*]</A></SUP></P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-29-FNOTE-1>[*]</A></SUP><A name="translated from"></A> This chapter was translated from the Japanese by Nevin Thompson.</P></BLOCKQUOTE>
<P class=docText><A name="reading computer"></A>You may ask: "Are human beings actually supposed to be the ones reading computer programs?" The assumption is that people use programs to tell computers what to do, and computers then use compilers or interpreters to compile and understand the code. At the end of the process, the program is translated into machine language that is normally read only by the CPU. That is, of course, the way things work, but this explanation only describes one aspect of computer programs.</P>
<P class=docText><A name="are not"></A>Most programs are not write-once. They are reworked and rewritten again and again in their lives. Bugs must be debugged. Changing requirements and the need for increased functionality mean the program itself may be modified on an ongoing basis. During this process, human beings must be able to read and understand the original code; it is therefore more important by far for humans to be able to understand the program than it is for the computer.</P>
<P class=docText>Computers can, <A name=idx-CHP-29-2478></A>of course, deal with complexity <A name=idx-CHP-29-2479></A><A name="not the"></A>without complaint, but this is not the case for human beings. Unreadable code will reduce most people's productivity significantly. On the other hand, easily understandable code will increase it. And we see beauty in such code.</P>
<P class=docText><A name="In other"></A>What makes a computer program readable? In other words, what is beautiful code? Although different people have different standards about what a beautiful program might be, judging the attributes of computer code is not simply a matter of aesthetics. Instead, computer programs are judged according to how well they execute their intended tasks. In other words, "beautiful code" is not an abstract virtue that exists independent of its programmers' efforts. Rather, beautiful code is really meant to help the programmer be happy and productive. This is the metric I use to evaluate the beauty of a program.</P>
<P class=docText><SPAN class=docEmphasis>Brevity</SPAN><A name="is one"></A> is one element that helps make code beautiful. As Paul Graham says, "Succinctness is power." In the vocabulary of programming, <A name=idx-CHP-29-2480></A><A name="Because there"></A>brevity is a virtue. Because there is a definite cost involved in scanning code with the human eye, programs should ideally contain no unnecessary information.<A name=idx-CHP-29-2481></A></P>
<P class=docText>For example, when type <A name=idx-CHP-29-2482></A><A name="when the"></A>declarations are unnecessary, or when the design does not require class <A name=idx-CHP-29-2483></A><A name="main routine"></A>declarations and main routine definitions, brevity mandates that it should be possible to simply avoid them. To illustrate this principle, <A class=docLink href="javascript:moveTo('hello_world_in_java_versus_ruby');">Example 29-1</A> shows a <A name=idx-CHP-29-2484></A><A name="in Java"></A>Hello World program in Java and Ruby.</P><A name=hello_world_in_java_versus_ruby></A>
<H5 class=docExampleTitle id=title-ID0ELMEK>Example 29-1. "Hello World" in Java versus Ruby</H5>
<P>
<TABLE cellSpacing=0 cellPadding=5 width=* border=1>
<TBODY>
<TR>
<TD><A name=I_book_tt2id101441></A>
<P>
<TABLE cellSpacing=0 width="100%" border=1>
<COLGROUP span=2>
<COL>
<COL></COLGROUP>
<THEAD>
<TR>
<TH class="docTableCell thead" scope=col>Java </TH>
<TH class="docTableCell thead" scope=col>Ruby </TH></TR></THEAD>
<TBODY>
<TR>
<TD class=docTableCell><PRE>class Sample {}
public static void main(String[] argv) {
System.out.println("Hello World");
}
</PRE><BR></TD>
<TD class=docTableCell><PRE>print "Hello World\n"
</PRE><BR></TD></TR></TBODY></TABLE></P><BR></TD></TR></TBODY></TABLE></P>
<P class=docText><A name="and Ruby"></A>Both programs accomplish exactly the same task—simply displaying the words "Hello World"—but Java and Ruby approach it in radically different ways. In Ruby's version of the program, all that's necessary is to describe the essence of the task. Print "Hello World". No declaration. No data type. In Java, though, it is necessary to include a variety of descriptions that are not immediately related to our intent. Of course, there is merit in including all of the things that Java does. However, because it is impossible to omit anything, brevity is lost. (To digress a little, Ruby's "Hello World" is trilingual: it also works in Perl and Python.)</P>
<P class=docText><A name="also mean"></A>Brevity can also mean the <A name=idx-CHP-29-2485></A>elimination of <A name=idx-CHP-29-2486></A><A name=the></A>redundancy. Redundancy is defined as the <A name=idx-CHP-29-2487></A><A name="the cost"></A>duplication of information. When information is duplicated, the cost of maintaining consistency can be quite high. And because a considerable amount of time can be spent maintaining consistency, redundancy will lower programming productivity.</P>
<P class=docText><A name="Although it"></A>Although it could be argued that redundancy lowers costs when interpreting meaning, the truth is actually the opposite because redundant code contains so much surplus information. One consequence of this extra weight is that the redundant approach relies on the use of supporting tools. Although relying on IDEs to input information has become popular recently, these tools are not intended to help interpret meaning. The real shortcut for developing elegant code is to choose an elegant programming language. Ruby and other lightweight languages like it support this approach.</P>
<P class=docText><A name="eliminate redundancy"></A>In order to eliminate redundancy, we follow the <A name=idx-CHP-29-2488></A>DRY principle: <A name=idx-CHP-29-2489></A><A name="same code"></A>Don't Repeat Yourself. If the same code exists in multiple places, whatever you're trying to say becomes obscured.</P>
<P class=docText><A name="of DRY"></A>The concept of DRY is the antithesis of copy-and-paste coding. In the past, some organizations measured productivity by the number of lines <A name=idx-CHP-29-2490></A><A name="programmer produced"></A>of code a programmer produced, so redundancy was actually tacitly encouraged. I've even heard that copying as much code as possible was sometimes considered a virtue. But this is wrong.</P>
<P class=docText><A name=on></A>The real virtue, I believe, lies in brevity. The recent popularity of Ruby on <A name=idx-CHP-29-2491></A><A name="driven by"></A>Rails is driven by its dogged pursuit of <A name=idx-CHP-29-2492></A><A name="language is"></A>brevity and DRY. The Ruby language is serious about "never writing the same thing twice" and "making descriptions concise." Rails inherits this philosophy from the Ruby language.</P>
<P class=docText><A name="beautiful code"></A>A more controversial aspect of beautiful code may be its <SPAN class=docEmphasis>familiarity</SPAN><A name="Human beings"></A>. Human beings are more conservative than you might think; most people find it difficult to embrace new concepts or change their ways of thinking. Instead, many prefer to continue suffering rather than change. Most people are unwilling to replace familiar tools or learn a new language without a good reason. Whenever they can, human beings will compare new processes they are trying to learn with what they have always regarded as common sense, with a resulting negative assessment of the new process that may be undeserved.<A name=idx-CHP-29-2493></A></P>
<P class=docText><A name="changing one"></A>The cost of changing one's ways of thinking is far higher than is commonly thought. In order to easily switch between totally different concepts (for example, from procedural programming to logical or functional programming), it is necessary to become acquainted with a wide variety of concepts. Steep learning curves create pain in humans' brains. Therefore, they reduce programmers' productivity.</P>
<P class=docText><A name="point of"></A>According to this point of view, because Ruby supports the concept of "beautiful code," it is an extremely conservative programming language. While called a pure object-oriented language, Ruby does not use innovative control structures based on object message passing like Smalltalk. Instead, Ruby sticks to traditional control structures programmers are familiar with, such as <TT>if</TT>, <TT>while</TT><A name="inherits the"></A>, etc. It even inherits the <TT>end</TT><A name="code blocks"></A> keyword to terminate code blocks from good old Algol-family languages.</P>
<P class=docText>Compared to other contemporary programming languages, <A name=idx-CHP-29-2494></A><A name="that "></A>Ruby does sometimes look old-fashioned. But it's important to keep in mind that "never be too innovative" is also a key to creating beautiful code.</P>
<P class=docText><SPAN class=docEmphasis>Simplicity</SPAN><A name="next element"></A> is the next element <A name=idx-CHP-29-2495></A><A name="feel beauty"></A>of beautiful code. We often feel beauty in simple code. If a program is hard to understand, it cannot be considered beautiful. And when programs are obscure rather than comprehensible, the results are bugs, mistakes, and confusion.<A name=idx-CHP-29-2496></A></P>
<P class=docText><A name="misunderstood concepts"></A>Simplicity is one of most misunderstood concepts in programming. People who design languages frequently want to keep those languages simple and clean. While the sentiment is noble, doing this can make programs written in that language more complex. Mike Cowlishaw, who designed the Rexx scripting language at IBM, once pointed out that because language users are more common than language implementers, the needs of the latter must give way to those of the former:</P>
<BLOCKQUOTE>
<P class=docText><A name="The general"></A>The general principle is that very few people have to implement interpreters or compilers for a language, whereas millions of people have to use and live with the language. One should therefore optimize for the millions, rather than the few. Compiler writers didn't love me for that, because Rexx got to be a hard language to interpret or compile, but I think it has paid off for people in general, certainly programmers in general. <SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-29-FNOTE-2');">[<IMG alt=dagger src="images/U2020.GIF">]</A></SUP></P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-29-FNOTE-2>[<IMG alt=dagger src="images/U2020.GIF">]</A></SUP> <SPAN class=docEmphasis>Dr. Dobb's Journal</SPAN>, March 1996.</P></BLOCKQUOTE></BLOCKQUOTE>
<P class=docText><A name="the bottom"></A>I agree from the bottom of my heart. Ruby is meant to be the personification of this ideal, and while it is far from simple, it supports simple solutions for programming. Because Ruby is not simple, the programs that use it can be. This is true of other lightweight languages as well; they are not lightweight in the sense of ease of implementation, but they are called lightweight because of their intention to lighten the workload of the programmer.</P>
<P class=docText><A name="this means"></A>To see what this means in practice, consider <A name=idx-CHP-29-2497></A><A name="tool like"></A>Rake, a build tool like <SPAN class=docEmphasis>make</SPAN><A name="used by"></A> that is widely used by Ruby programmers. Unlike <SPAN class=docEmphasis>Makefiles</SPAN>, which are written in a single-purpose file format, <SPAN class=docEmphasis>Rakefiles</SPAN> are written in Ruby, as sort of Domain Specific Language (DSL) with full-featured programmability. <A class=docLink href="javascript:moveTo('sample_rakefile');">Example 29-2</A> shows a <SPAN class=docEmphasis>Rakefile</SPAN> that runs a set of tests.<A name=idx-CHP-29-2498></A></P><A name=sample_rakefile></A>
<H5 class=docExampleTitle id=title-ID0EHTEK>Example 29-2. Sample Rakefile</H5>
<P>
<TABLE cellSpacing=0 cellPadding=5 width=* border=1>
<TBODY>
<TR>
<TD><PRE>task :default =&gt; [:test] 
task :test do
  ruby "test/unittest.rb"
end
</PRE><BR></TD></TR></TBODY></TABLE></P>
<P class=docText>The <SPAN class=docEmphasis>Rakefile</SPAN> takes advantage of the following shortcuts in Ruby syntax:</P>
<UL>
<LI>
<P class=docList>Parentheses for method arguments can be eliminated.</P></LI>
<LI>
<P class=docList>Unbraced hash key/value pairs can appear at the end of methods.</P></LI>
<LI>
<P class=docList>Code blocks can be attached at the tails of method calls.</P></LI></UL>
<P class=docText><A name="they are"></A>You can program in Ruby without these syntax elements, so in theory, they are redundant. They are often criticized for making language more complex. However, <A class=docLink href="javascript:moveTo('rakefile_without_abbreviated_syntax');">Example 29-3</A> shows how <A class=docLink href="javascript:moveTo('sample_rakefile');">Example 29-2</A><A name="written without"></A> would be written without using these features.</P><A name=rakefile_without_abbreviated_syntax></A>
<H5 class=docExampleTitle id=title-ID0ETUEK>Example 29-3. Rakefile without abbreviated syntax</H5>
<P>
<TABLE cellSpacing=0 cellPadding=5 width=* border=1>
<TBODY>
<TR>
<TD><PRE>task({:default =&gt; [:test]})
task(:test, &amp;lambda(){
  ruby "test/unittest.rb"
})
</PRE><BR></TD></TR></TBODY></TABLE></P>
<P class=docText><A name="syntax were"></A>As you can see, if Ruby's syntax were stripped of redundancies, Ruby the language might become more elegant, but programmers would have to do more work, and their programs would be harder to read. So, when simpler tools are used to solve a complex problem, complexity is merely shifted to the programmer, which is really putting the cart before the horse.</P>
<P class=docText><A name="the concept"></A>The next important element in the concept of "beautiful code" is flexibility. I define flexibility here as <SPAN class=docEmphasis><A name="freedom from"></A>freedom from enforcement from tools</SPAN><A name="forced to"></A>. When programmers are forced to do something against their intentions, for the tools' sake, the result is stress. This stress negatively affects the programmer. The end result is far from happiness, and far from beauty as well, according to our definitions of beauty in code. Humans are more valuable than any tools or languages. Computers should serve programmers to maximize their productivity and happiness, but in reality, they often increase the burden instead of lightening it.</P>
<P class=docText><SPAN class=docEmphasis>Balance</SPAN><A name="element of"></A> is the final element of beautiful code. So far I have talked about brevity, conservatism, simplicity, and flexibility. No element by itself will ensure a beautiful program. When balanced together and kept in mind from the very beginning, each element will work harmoniously with the others to create beautiful code. And if you also make sure to have fun writing and reading code, you will experience happiness as a programmer.</P>
<P class=docText>Happy Hacking!<A name=I_indexterm29_tt676></A></P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
