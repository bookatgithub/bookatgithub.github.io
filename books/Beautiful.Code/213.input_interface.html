<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 30.2. Input Interface</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>When a Button Is All That Connects You to the World</SPAN><SPAN> &gt; Input Interface</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=input_interface></A>
<H3 class=docSection1Title id=-100000>30.2. Input Interface</H3>
<P class=docText><A name="As the"></A>As the single binary input, we selected the <A name=idx-CHP-30-2529></A><A name="allowed a"></A>right mouse button. This allowed a variety of buttons to easily be connected to eLocutor. By opening up the mouse and soldering the desired button in parallel with the right mouse button, any electrician or hobbyist should be able to make the connection.<A name=idx-CHP-30-2530></A></P>
<P class=docText><A class=docLink href="javascript:moveTo('connecting_professor_hawkings_switch_in_parallel_to_the_righ');">Figure 30-2</A><A name="made a"></A> shows how we made a temporary connection for Professor Hawking's special switch: the circuit board at the left bottom is taken from the inside of a mouse, and the points at which the external switch was soldered are the ones where the right mouse button is connected.<A name=I_indexterm30_tt678></A></P><A name=connecting_professor_hawkings_switch_in_parallel_to_the_righ></A>
<P>
<CENTER>
<H5 class=docFigureTitle><A name="Professor Hawking"></A>Figure 30-2. Connecting Professor Hawking's switch in parallel to the right mouse button</H5><IMG id="" height=375 alt="" src="images/input_interface.0.png" width=500 border=0> </CENTER>
<P></P><BR><A name=the_tree></A>
<H4 class=docSection2Title id=title-ID0EELEK>30.2.1. The Tree</H4>
<P class=docText><A name="provide the"></A>If you can provide the software only a single binary <A name=idx-CHP-30-2531></A><A name="have to"></A>input, one part of the graphic user interface is obvious: all choices have to be presented turn by turn in the form of a binary tree. At each node, if the user clicks <A name=idx-CHP-30-2532></A><A name="fixed time"></A>within a fixed time, the interface selects it, which might open up further choices in the form of a subtree. If the user does not click, the software automatically takes him to the next sibling of the node and waits again for a click.<A name=idx-CHP-30-2533></A></P>
<P class=docText><A name="used the"></A>To implement this tree, we used the Visual Basic <A name=idx-CHP-30-2534></A>TreeView control.<SUP class=docFootnote><A class=docLink href="javascript:moveTo('CHP-30-FNOTE-4');">[§]</A></SUP><A name="as a"></A> This should be looked upon as a tree that grows from left to right. If, at any node, you click within a user-selected time interval—which is set using a Timer control—you expand the node and climb up the tree (i.e., move to the right), or, if it is a leaf node, carry out some action. If you don't click, <A name=idx-CHP-30-2535></A><A name="eLocutor shifts"></A>eLocutor shifts its focus to the next sibling of the node. If the bottom is reached without a click, <A name=idx-CHP-30-2536></A><A name="with the"></A>eLocutor starts again with the node at the top.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=CHP-30-FNOTE-4>[§]</A></SUP> <A class=docLink href="http://www.virtualsplat.com/tips/visual-basic-treeview-control.asp" target=_blank>http://www.virtualsplat.com/tips/visual-basic-treeview-control.asp</A>.</P></BLOCKQUOTE>
<P class=docText><A name="tree such"></A>We populated the tree such that it provides, at each level in the tree, a node called Up that, if selected, takes the highlight to its parent, one level closer to the root.</P>
<P class=docText><A name="are Type"></A>The top-level nodes are Type, Scroll, Edit (the primary editing functions), and Commands (miscellaneous). Leaf nodes in the Type subtree enter text into the typing buffer. Those in the Edit subtree delete or copy text from this buffer, while those in the Scroll buffer control the movement of text between buffers.</P>
<P class=docText><A name="eLocutor expresses"></A>The intelligence of eLocutor expresses itself by dynamically repopulating the tree, so that you can relatively quickly find the next action you wish to take: it learns in several different ways from your actions, to be better able to predict in the future.</P>
<P class=docText>The biggest problem <A name=idx-CHP-30-2537></A>with binary <A name=idx-CHP-30-2538></A><A name="and need"></A>input is navigation. If you are in the middle of typing and need to delete something at the start of the sentence, it takes a long time to wait for Up many times to get to the root, then down into Scroll to find the correct position to start deleting, then Up several times again to get to the root, then down into Edit for the deletion, then up and down again to scroll to the end, and again to return to typing. We were very relieved to find an answer to this dilemma.</P><A name=the_long_click></A>
<H4 class=docSection2Title id=title-ID0EVNEK>30.2.2. The Long Click</H4>
<P class=docText><A name="Professor Hawking"></A>From observing Professor Hawking use Equalizer, I discovered a new mode of operation: besides simply just clicking the button, he could hold down the button and release it at a strategic moment. The button, in effect, is not merely a binary input device, but actually an analog one, for it can provide a signal of varying duration. We thought long and hard about how best to use this new power we were presented with: we could now get more information out of a click than a simple bit. We could, for instance, allow the user to pick from a list of choices. A short click would now be used for the default action, while a <A name=idx-CHP-30-2539></A><A name="many other"></A>long click opened up many other options.<A name=idx-CHP-30-2540></A></P>
<P class=docText><A name="newfound power"></A>Clearly, we wanted to use this newfound power for some extra choices for rapid navigation. We also were delighted with the ability to perform different operations on the text highlighted in the tree, such as to type it, copy it into the filter, etc. Without the long-click ability, we were limited to one action per leaf node, whereas now we could offer the user other choices regarding what to do with the highlighted tree node, which need not even be a leaf node.</P>
<P class=docText><A name="The list"></A>The list of extra choices could not be too large, for that would require the user to hold down the button for relatively long periods of time. Consequently, we wanted these choices to change depending on where in the tree we were. "Type this" for instance, made no sense when we were in the Scroll subtree but was quite handy in the Speller.</P>
<P class=docText><A name="up with"></A>What we came up with was a simple, easy-to-understand mode of operation. Clicking a node performs its default action. But if you keep the button pressed, a separate menu opens up whose options roll by one by one, from which you pick one by releasing the button when the desired choice shows up. We use this a bit like the right-click button under Microsoft Windows, to present the user <A name=idx-CHP-30-2541></A><A name="include a"></A>context-sensitive menu choices. These typically include a jump to the root node of the tree, reverse traversal, etc.</P>
<P class=docText><A name="of this"></A>The importance of this extra mode of operation can hardly be overstated: not only did it substantially increase the speed of text entry and correction, it provided tremendous flexibility to the developers.</P>
<P class=docText><A name="was needed"></A>An elegant solution was needed to make the long-click menu context-sensitive, for it would have been too cumbersome to create a special long-click menu for each node of the binary tree. Like the tree, long-click menus are stored in the form of text files, which are editable in <A name=idx-CHP-30-2542></A>eLocutor. In selecting the appropriate long-click menu, <A name=idx-CHP-30-2543></A><A name="file exists"></A>eLocutor looks to see which node is highlighted. If a text file exists with the same name as the node in the long-click directory, it is picked up as the menu. If it doesn't, eLocutor looks for the name of the node one level above in the tree, and so on.</P>
<P class=docText><A name="each subtree"></A>In this way, each subtree can have its own long-click menu, entirely under the control of the user. Another way to present this design is to say that unless a child menu item chooses to override the long-click menu defined for its parent, the child automatically inherits the parent's menu.</P>
<P class=docText><A name=the></A>Partial code for implementing the <A name=idx-CHP-30-2544></A>long click is shown in <A class=docLink href="javascript:moveTo('implementing_context-sensitive_menu_selection_for_the_long_c');">Example 30-1</A><A name=file></A>. OpenLongClick-File looks for and opens a file <A name=idx-CHP-30-2545></A><A name="with the"></A>with the same name as the parameter passed to it, and if that is not found, recursively looks for one with the name of its parent. Each time the long-click timer times out, a fresh line from this file is displayed in the text box <SPAN class=docEmphasis>tblongclick</SPAN><A name="is released"></A>. When the button is released, the command in <SPAN class=docEmphasis>tblongclick</SPAN><A name="how long"></A> is selected. Depending on how long the button is held pressed, the long-click timer runs out repeatedly. Each time the timer runs out, it causes the code in <A class=docLink href="javascript:moveTo('implementing_context-sensitive_menu_selection_for_the_long_c');">Example 30-1</A><A name="and set"></A> to check and set the Boolean variable <TT>ThisIsALongClick</TT><A name="execute some"></A>, and then to execute some code that needs to run only once in each <A name=idx-CHP-30-2546></A><A name="file for"></A>long click in order to select and open the appropriate long-click file for reading.</P>
<P class=docText><A name="that repeats"></A>The portion that repeats upon each expiration of the long-click timer reads a line from the file and displays it in the <SPAN class=docEmphasis>tblongclick</SPAN><A name="reaches the"></A> text box. When the file reaches the end, it is closed and reopened, and the first line is read in. When the button is released, <TT>ThisIsALongClick</TT> is reset.</P><A name=implementing_context-sensitive_menu_selection_for_the_long_c></A>
<H5 class=docExampleTitle id=title-ID0E2QEK>Example 30-1. Implementing context-sensitive menu selection for the long click</H5>
<P>
<TABLE cellSpacing=0 cellPadding=5 width=* border=1>
<TBODY>
<TR>
<TD><PRE>Private Sub longclick_Timer()
Dim st As String
Dim filenum As Long
    If Not ThisIsALongClick Then
        ThisIsALongClick = True
        If MenuTree.SelectedItem.Text = stStart Then
        'we are at the root already
            OpenLongClickFile MenuTree.SelectedItem
        Else
            OpenLongClickFile MenuTree.SelectedItem.Parent
'find the list of long-click menu choices suited for this context
        End If
    End If
    If EOF(longclickfilenum) Then
'list of choices finished, cycle to the first one by reopening file
        Close #longclickfilenum
        Open stlongclickfilename For <A name=idx-CHP-30-2547></A>Input As #longclickfilenum
    End If
    Line Input #longclickfilenum, st
    tblongclick = st
End Sub
</PRE><BR></TD></TR></TBODY></TABLE></P>
<P class=docText><A name="long click"></A>Commands made available using the long click include:<A name=idx-CHP-30-2548></A></P><A name=idx-CHP-30-2549></A><A name=idx-CHP-30-2550></A><A name=idx-CHP-30-2551></A>
<DL class=docList>
<DT><BR>
<P><SPAN class=docPubcolor><SPAN class=docPubcolor><SPAN class=docMonofont>&gt;Start</SPAN></SPAN> </SPAN></P></DT>
<DD>
<P class=docList><A name="Takes you"></A>Takes you to the root of the tree (the &gt; indicates a "go to").</P></DD>
<DT><BR>
<P><SPAN class=docPubcolor><SPAN class=docPubcolor><SPAN class=docMonofont>Upwards</SPAN></SPAN> </SPAN></P></DT>
<DD>
<P class=docList><A name="backward and"></A>Moves the cursor backward and upward in the tree until the right mouse button is clicked. Useful when you did not press the button when the desired menu choice was highlighted—i.e., you missed your turn.</P></DD>
<DT><BR>
<P><SPAN class=docPubcolor><SPAN class=docPubcolor><SPAN class=docMonofont>Type This</SPAN></SPAN> </SPAN></P></DT>
<DD>
<P class=docList><A name="highlighted in"></A>Types whatever is highlighted in the tree into the middle box. Available only under the Type subtree.</P></DD>
<DT><BR>
<P><SPAN class=docPubcolor><SPAN class=docPubcolor><SPAN class=docMonofont>Set Filter</SPAN></SPAN> </SPAN></P></DT>
<DD>
<P class=docList><A name="is highlighted"></A>Copies whatever is highlighted in the tree into the filter; useful for searching text. Also available as a long-click option only when the highlighted item is under the Type subtree.</P></DD>
<DT><BR>
<P><SPAN class=docPubcolor><SPAN class=docPubcolor><SPAN class=docMonofont>Words Up, Words Down</SPAN></SPAN> </SPAN></P></DT>
<DD>
<P class=docList><A name="during typing"></A>For rapid scrolling during typing, described later.</P></DD>
<DT><BR>
<P><SPAN class=docPubcolor><SPAN class=docPubcolor><SPAN class=docMonofont>Pause</SPAN></SPAN> </SPAN></P></DT>
<DD>
<P class=docList><A name="user holds"></A>Useful when a command has to be executed repeatedly. When the user holds the button down for a <A name=idx-CHP-30-2549></A><A name="menu tree"></A>long click, the menu tree freezes, with one of its items highlighted. Selecting the long-click <TT>Pause</TT><A name="of suspension"></A> option maintains this state of suspension. Now, each time the user clicks, the command highlighted in the menu tree is executed. To come out of pause, a <A name=idx-CHP-30-2550></A>long click must again be used.</P></DD>
<DT><BR>
<P><SPAN class=docPubcolor><SPAN class=docPubcolor><SPAN class=docMonofont>Help</SPAN></SPAN> </SPAN></P></DT>
<DD>
<P class=docList>Opens up and plays a <A name=idx-CHP-30-2551></A>context-sensitive <SPAN class=docEmphasis>.avi</SPAN><A name="choices the"></A> video file that explains the choices the tree is offering the user. The Help subdirectory contains a bunch of <SPAN class=docEmphasis>.avi</SPAN><A name="It must"></A> files. It must contain at least one file, which is called <SPAN class=docEmphasis>Start.avi</SPAN><A name="item is"></A>. When the Help long-click item is selected, the appropriate <SPAN class=docEmphasis>.avi</SPAN><A name="on where"></A> file is played, based on where the user currently is in the menu tree.</P></DD></DL>
<P class=docText><A name="file to"></A>The correct file to play is found in a fashion similar to the long-click menu. The software first looks for a file <A name=idx-CHP-30-2552></A>with an <SPAN class=docEmphasis>.avi</SPAN> extension in the <SPAN class=docEmphasis>helpvideos</SPAN> subdirectory of <SPAN class=docEmphasis>C:\eLocutor</SPAN><A name="file is"></A>. If such a file is found, it is played; otherwise, <A name=idx-CHP-30-2553></A>eLocutor looks for an <SPAN class=docEmphasis>.avi</SPAN><A name="If an"></A> file with the name of the parent of the highlighted node. If an <SPAN class=docEmphasis>.avi</SPAN><A name="this name"></A> file with this name is not found in the <SPAN class=docEmphasis>helpvideos</SPAN><A name="the menu"></A> directory, eLocutor climbs recursively up the menu tree until it finds a node with a corresponding help video. This feature allowed us to ship only overview videos to start with, and gradually add more and more detailed videos, which the user only needed to copy into the <SPAN class=docEmphasis>helpvideos</SPAN><A name="showing them"></A> subdirectory for eLocutor to start showing them.<A name=idx-CHP-30-2554></A></P>
<P class=docText><A name="Some help"></A>Some help videos are available at <A class=docLink href="http://www.holisticit.com/eLocutor/helpvideos.zip" target=_blank>http://www.holisticit.com/eLocutor/helpvideos.zip</A>. Given the <A name=idx-CHP-30-2555></A><A name="this software"></A>dynamic nature of this software, watching some videos will help the reader understand this chapter faster and more thoroughly.</P><A name=dynamic_tree_repopulation></A>
<H4 class=docSection2Title id=title-ID0EFXEK>30.2.3. Dynamic Tree Repopulation</H4>
<P class=docText><A name="the tree"></A>The contents of the tree are stored on disk in the form of text files. The big advantage of this approach is that these files can be edited dynamically both by eLocutor and by the user. In other words, they gave us an easy way to meet one of our design criteria: to allow the user herself to adapt eLocutor to her own needs, by making data structures transparent and easily user-editable.<A name=idx-CHP-30-2556></A><A name=I_indexterm30_tt680></A><A name=I_indexterm30_tt681></A></P>
<P class=docText><A name="tries to"></A>Because eLocutor tries to predict what you may wish to do next, the binary tree needs to be dynamic; subtrees such as Next Word are frequently repopulated. The name of each file is the same as that of a node (with a <SPAN class=docEmphasis>.txt</SPAN><A name="list of"></A> extension), and contains a list of names of its immediate children. If any of the node names end in <SPAN class=docEmphasis>.txt</SPAN><A name="its children"></A>, they represent the root of a sub-tree, and the names of its children can be found in the corresponding file. For instance, the root file is named <SPAN class=docEmphasis>Start.txt</SPAN><A name="the lines"></A> and contains the lines <SPAN class=docEmphasis>type.txt, edit.txt, scroll.txt</SPAN>, and <SPAN class=docEmphasis>commands.txt</SPAN><A name="a set"></A>, each line corresponding to a set of options displayed to the user for one of the menus described in the earlier section "The Tree."</P>
<P class=docText><A name=in></A>A node name not ending in <SPAN class=docEmphasis>.txt</SPAN><A name="represents a"></A> represents a leaf node. Selecting it results in some action being taken. For instance, if the leaf node is in the Type subtree, its selection results in the corresponding text being typed into the buffer.</P>
<P class=docText><A name="that are"></A>To indicate nodes that are dynamically repopulated, the prefix ^ is used. For instance, the following list shows the contents of <SPAN class=docEmphasis>type.txt</SPAN><A name="child nodes"></A>, which form the child nodes of Type in the tree shown in <A class=docLink href="212.basic_design_model.html#the_elocutor_screen">Figure 30-1</A>:<A name=idx-CHP-30-2557></A></P><PRE>	commonwords.txt
	speller
	^word completion.txt
	^next word.txt
	suffixes.txt
	^justsaid.txt
	^clipboard.txt
	^phrase completion.txt
	^templates.txt
	vocabularytree.txt
</PRE><BR>
<P class=docText><A name="names are"></A>Subtrees whose names are prefixed <A name=idx-CHP-30-2558></A><A name="only when"></A>with ^ are populated only when the user clicks on the corresponding root node.</P>
<P class=docText>The Visual Basic TreeView control has an <A name=idx-CHP-30-2559></A><A name="of creating"></A>indexing feature to speed up retrieval. This feature made us think of creating nodes in the tree with words as names, grouped together such that siblings in a tree might replace one another in a sentence without making it sound absurd. For instance, a sentence including the word "London" could easily appear in another context with the word "Boston" in its place.</P>
<P class=docText><A name="index in"></A>Using the index in this fashion allowed us to implement two critical features of <A name=idx-CHP-30-2560></A><A name="discussed shortly"></A>eLocutor, Replace and Template, which are discussed shortly. The downside, though, was that we had to live with the limitations of the <A name=idx-CHP-30-2561></A><A name="View control"></A>indexing feature of the Tree View control, which does not allow duplicate keys. Nothing prevented us from inserting more than one node with the same name into the tree. Only one of those, however, could be indexed.</P>
<P class=docText><A name="The subnode"></A>The subnode vocabulary tree of Type is the root node of a large subtree, which groups words that might meaningfully replace one other in a sentence. For Replace and Template to work, these need to be indexed. However, the same word might show up at other places in the tree, perhaps as a suggestion for word completion or a next word. Those instances cannot be indexed. To keep it simple, we decided not to index the contents of dynamically repopulated subtrees.</P>
<P class=docText><A name="as a"></A>Speller is treated as a special case. Its contents are not dynamic. However, the large number of leaf nodes it contains, besides the fact that it contains every word in the vocabulary tree, means it could not be indexed either. It is populated only as needed—i.e., the children of a node in the speller subtree are created only when it is selected.</P><A name=simple_typing></A>
<H4 class=docSection2Title id=title-ID0EP1EK>30.2.4. Simple Typing</H4>
<P class=docText><A name="contains three"></A>The Type subtree contains three nodes that help you do plain typing. Under Speller appear all the letters from a through z, which allow you to pick the first letter of the word you desire. You are then presented similar choices for the next letter, but only if that combination occurs at the start of a word in the dictionary. In this way, you pick letter by letter, until you have the full word. At this point, the node at which you find yourself may or may not be a leaf node. If it is a leaf node, you can type it by simply clicking it. But often it is not.<A name=idx-CHP-30-2562></A><A name=idx-CHP-30-2563></A><A name=idx-CHP-30-2564></A></P>
<P class=docText><A name="are other"></A>"Vocabularytree" and "commonwords," described later, are other nodes that make it easy for you to type. However, if the system's prediction feature is working well, which happens if you are trying to make a sentence similar to one in the database, you do not need these facilities often.</P><A name=prediction_word_completion_and_next_word></A>
<H4 class=docSection2Title id=title-ID0EM2EK>30.2.5. Prediction: Word Completion and Next Word</H4>
<P class=docText>In the <A name=idx-CHP-30-2565></A><A name="several tables"></A>predictor database are several tables. One is a simple list of roughly 250,000 words used to populate the <A name=idx-CHP-30-2566></A><A name="starting characters"></A>Word Completion subtree. A user who has typed one or more starting characters of a word can use this list to type the rest of the word, suggestions for which are shown to the right of the screen, in the above half, as shown in <A class=docLink href="212.basic_design_model.html#the_elocutor_screen">Figure 30-1</A><A name=idx-CHP-30-2567></A><A name="is available"></A>. This table is available to the user in its entirety via the Speller subtree.<A name=idx-CHP-30-2568></A><A name=idx-CHP-30-2569></A></P>
<P class=docText><A name="type the"></A>Say you wish to type the word <SPAN class=docEmphasis>instant</SPAN><A name="node because"></A>. This is not a leaf node because words such as <SPAN class=docEmphasis>instantaneous</SPAN><A name="exist that"></A> exist that begin <A name=idx-CHP-30-2570></A>with <SPAN class=docEmphasis>instant</SPAN>. Hence, to type <SPAN class=docEmphasis>instant</SPAN><A name="of the"></A>, you select each of the seven characters in turn, and then when <SPAN class=docEmphasis>instant</SPAN><A name="a long"></A> is highlighted, you use a long click to invoke the Type This option.</P>
<P class=docText><A name="has the"></A>Another table has the fields <SPAN class=docEmphasis>word1, word2</SPAN>, and <SPAN class=docEmphasis>frequency</SPAN><A name="a long"></A>. To populate this table, a long list of sentences are provided to a piece of companion software, <SPAN class=docEmphasis>dbmanager</SPAN><A name="you have"></A>, which tabulates how often each word follows each other word. Once you have typed a word, this table is queried and the Next Word subtree populated, so that it provides the user a list of words that are likely to follow this one.</P>
<P class=docText><A name="entered by"></A>Each sentence entered by the user through <A name=idx-CHP-30-2571></A><A name="the file"></A>eLocutor is copied into the file <SPAN class=docEmphasis>mailtomehtaatvsnldotcom.txt</SPAN><A name="was to"></A>. The reason for this filename was to gently encourage the user to mail me samples of text he had generated using eLocutor, so that I might get some ideas about how to make it more efficient. Users are advised to edit this file and remove whatever is inappropriate before feeding it to <SPAN class=docEmphasis>dbmanager</SPAN><A name="so that"></A>, so that with time, prediction gets better. In case a software writer wishes to implement a better method of predicting the next word, all she has to do is to alter the query in the Access database; there is no need to delve into the eLocutor code for this.<A name=idx-CHP-30-2572></A></P>
<P class=docText><A name="lists combinations"></A>A separate table lists combinations of punctuation characters occurring in the text supplied to the database, which are treated by eLocutor more or less as words.</P>
<P class=docText><A name="for software"></A>It is hard for software to predict what the user might wish to type next, <A name=idx-CHP-30-2573></A><A name="knowledge of"></A>without a knowledge of semantics. We tried talking to linguists to see whether there was a reasonably easy way to make such predictions, but soon gave up. What we did instead was laboriously combine words into semantic groups under the "Vocabulary tree" subtree. For instance, the ancestry of "Boston" in the vocabulary tree is Nouns <IMG alt="rightwards double arrow" src="images/U2192.GIF"> Places <IMG alt="rightwards double arrow" src="images/U2192.GIF"> Cities. Of course, the user can use this subtree to actually type in words, but that isn't very convenient. The semantic subgroups are better for allowing the user to "fill in the blanks" in the Template and <A name=idx-CHP-30-2574></A>Replace features.</P><A name=templates_and_replace></A>
<H4 class=docSection2Title id=title-ID0E25EK>30.2.6. Templates and Replace</H4>
<P class=docText><A name="select any"></A>The user can select any sentence out of the database as a template to create new ones. This is done by first typing its starting word or words, and then looking under the Template subtree. At the bottom of the screen in <A class=docLink href="212.basic_design_model.html#the_elocutor_screen">Figure 30-1</A> <A name=idx-CHP-30-2575></A>are suggestions for completing the phrase or sentence. To populate this list, <A name=idx-CHP-30-2576></A><A name="has already"></A>eLocutor looks in its database for sentences beginning with what has already been typed since the last sentence terminator. The same suggestions are also available under the Template subtree, with which the user can create new sentences by simply filling in the blanks in old ones. Should there be too many suggestions, a word or phrase can be put into the filter. Only phrases or sentences containing what is in the filter show up.<A name=idx-CHP-30-2577></A><A name=idx-CHP-30-2578></A></P>
<P class=docText><A name="templates by"></A>eLocutor processes templates by looking at the phrase selected as a template, word by word. Any word in the template not found in the vocabulary tree is directly typed into the buffer. For each word found in the vocabulary tree, using the TreeView indexing feature, eLocutor takes the user to that part of the tree, allowing him to pick it or one of its siblings. So, if the sentence "How are you?" is in the database, the user needs just a few rapid clicks to type, "How is she?" While such "fill in the blanks" is taking place, the portion of the template not yet used is visible in the Template box under the tree.</P>
<P class=docText><A name="advantage of"></A>The Template feature takes advantage of the logical grouping of words under the vocabulary tree to transform the contents of an entire sentence or phrase. The Replace feature allows the user a similar facility on just a single word, the last one found in the middle box. However, not all words are listed under the vocabulary tree. A text box on the screen is therefore needed to tell the user which category, if any, the word in question is found under. On the screen is a box captioned <TT>Replace</TT><A name="the buffer"></A>. If the last word in the buffer is found in the vocabulary tree, the name of its parent is written into the Replace text box.</P>
<P class=docText><A name="For instance"></A>For instance, if the last word in the buffer is Boston, the Replace text box contains the word <TT>Cities</TT><A name="user that"></A>. This tells the user that the software has recognized the category of the last word. If she then selects the Replace command (under the Word Completion subtree), the last word is deleted from the buffer and the user is taken to the place in the vocabulary tree where it was found, allowing her to easily find another city name to replace it with.</P>
<P class=docText>In <A class=docLink href="212.basic_design_model.html#the_elocutor_screen">Figure 30-1</A><A name="typed is"></A>, the last word typed is <TT>We</TT><A name="box shows"></A>. The Replace box shows <TT>subjectpronoun</TT><A name="the space"></A> (which doesn't entirely fit in the space provided). Selecting <TT>Replace</TT> deletes the <TT>We</TT> and takes the user to the <TT>subjectpronoun</TT> subtree, where she could easily select <TT>You</TT>, for instance.</P><A name=the_cache_implementation></A>
<H4 class=docSection2Title id=title-ID0ECBFK>30.2.7. The Cache Implementation</H4>
<P class=docText><A name=idx-CHP-30-2579></A>Caching in <A name=idx-CHP-30-2580></A>eLocutor relies on the subroutine <A name=idx-CHP-30-2581></A><A name="the text"></A>SaveReverse, which takes two parameters: the name of the file in which the text is to be saved, and the text itself. The subroutine replaces the file <A name=idx-CHP-30-2582></A><A name="fresh one"></A>with a fresh one, in which the text passed to SaveReverse is the first line of the file, followed by the first 19 lines of the original contents that do not match the first line.<A name=idx-CHP-30-2583></A></P>
<P class=docText><A name="first writing"></A>This is achieved by first writing the text represented by the variable <TT>stringtoadd</TT> into the first element of <TT>starray</TT><A name="the array"></A>, then filling the rest of the array with lines from the file as long as they are not the same as <TT><A name="stringtoadd "></A>stringtoadd (HistoryLength</TT><A name="of value"></A> is a constant of value 20). Finally, the file is opened for writing, which causes its previous contents to be deleted, and the entire contents of <TT>starray</TT><A name="the file"></A> are copied to the file.</P>
<P class=docText><A name="city name"></A>Thus, if a city name already listed in <SPAN class=docEmphasis>favouritecities.txt</SPAN><A name="changes position"></A> is used, it simply changes position to become the first name in the file. If a new city name is used, it also becomes the first name, followed by the first 19 lines of the previous contents of the file. In other words, the last line of the file is dropped, and it gets a new first line. As the name of the routine suggests, lines of text are saved in reverse, so the last used word becomes the first.</P>
<P class=docText>The code for SaveReverse is shown in <A class=docLink href="javascript:moveTo('adding_text_to_the_start_of_a_text_file_without_duplication');">Example 30-2</A>.</P><A name=adding_text_to_the_start_of_a_text_file_without_duplication></A>
<H5 class=docExampleTitle id=title-ID0EDDFK>Example 30-2. Adding text to the start of a text file, without duplication</H5>
<P>
<TABLE cellSpacing=0 cellPadding=5 width=* border=1>
<TBODY>
<TR>
<TD>
<DIV class=codeSegmentsExpansionLinks>Code View: <SPAN>Scroll</SPAN> / <A href="javascript:expandCodeSegments()">Show All</A></DIV><PRE class=preFixedHeight>Sub SaveReverse(ByVal filest As String, ByVal stringtoadd As String) 'not
'an append, a prepend...
'with elimination of duplicates
    Dim starray(HistoryLength) As String
    Dim i As Long
    Dim arrlength As Long
    Dim st As String
    Dim filenum As Long
    starray(0) = stringtoadd
    filenum = FreeFile
    i = 1
    On Error GoTo err1
    Open filest For <A name=idx-CHP-30-2584></A>Input As #filenum
    While Not EOF(filenum) And (i &lt; HistoryLength)
        Line Input #filenum, st
        If (st &lt;&gt; stringtoadd) Then 'only save non-duplicates
            starray(i) = st
            i = i + 1
        End If
    Wend
    arrlength = i - 1
    Close #filenum
    Open filest For Output As #filenum       'this deletes the existing file contents
    For i = 0 To arrlength
        Print #filenum, starray(i)
    Next
    Close #filenum
    Exit Sub
err1:
'    MsgBox "error <A name=idx-CHP-30-2585></A>with file " + filest
    Open filest For Output As #filenum
    Close #filenum
    Open filest For <A name=idx-CHP-30-2586></A>Input As #filenum        'this creates an empty file if one does 'not
exist
    Resume Next
End Sub


					    </PRE><BR></TD></TR></TBODY></TABLE></P><A name=common_words_and_favorites></A>
<H4 class=docSection2Title id=title-ID0ECEFK>30.2.8. Common Words and Favorites</H4>
<P class=docText><A name=idx-CHP-30-2587></A>Frequently used words are collected in the "<A name=idx-CHP-30-2588></A><A name="of very"></A>common words" subtree, which has two components. Part of this subtree is static, consisting of very frequently used words such as <SPAN class=docEmphasis>a, and, but</SPAN><A name="part contains"></A>, etc. The dynamic part contains additional words frequently used by the user, which are found under its "favouritechoices" subtree.<A name=idx-CHP-30-2589></A><A name=idx-CHP-30-2590></A><A name=idx-CHP-30-2591></A></P>
<P class=docText><A name="by the"></A>The last 20 words found by the user in Speller can be found under its "favouritespeller" subtree. Likewise, if a node exists in the vocabulary tree called "cities," the user needs only to create a blank file, <SPAN class=docEmphasis>favouritecities.txt</SPAN><A name="the user"></A>. Thereafter, the last 20 selections made by the user of words found under the cities subtree will be available under "favouritecities" in the "favouritechoices" subtree. In this way, the user can decide himself what kind of words, if used frequently, are worth remembering, and how they should be slotted.</P>
<P class=docText><A class=docLink href="javascript:moveTo('how_elocutor_files_words_already_typed_under_favourites');">Example 30-3</A><A name="shows the"></A> shows the subroutine that creates a new "favourites" and inserts it into the tree. Please note that stfavourite is the constant favorite, and MakeFullFileName returns a proper filename including the path, filename, and <SPAN class=docEmphasis>.txt</SPAN> extension.</P><A name=how_elocutor_files_words_already_typed_under_favourites></A>
<H5 class=docExampleTitle id=title-ID0EVFFK>Example 30-3. How eLocutor files words already typed under "favourites"</H5>
<P>
<TABLE cellSpacing=0 cellPadding=5 width=* border=1>
<TBODY>
<TR>
<TD>
<DIV class=codeSegmentsExpansionLinks>Code View: <SPAN>Scroll</SPAN> / <A href="javascript:expandCodeSegments()">Show All</A></DIV><PRE class=preFixedWidth>Public Sub AddToFavourites(parentnode As Node, stAdd As String)
Dim tempfilename As String
    If parentnode.Text = stStart Then
        Exit Sub
    End If
    tempfilename = MakeFullFileName(App.Path, stfavourite + parentnode.Text)
    If FileExists(tempfilename) Then
        SaveReverse tempfilename, stAdd
    Else
        AddToFavourites parentnode.Parent, stAdd
    End If
End Sub


					    </PRE><BR></TD></TR></TBODY></TABLE></P>
<P class=docText><A name="is typed"></A>Whenever a word is typed, eLocutor looks to see whether it also can be found in the vocabulary tree. Suppose the word Boston has just been typed. In that case, Boston is inserted at the top of the file <SPAN class=docEmphasis>favouritecities.txt</SPAN><A name="the subroutine"></A>, if it exists, using the subroutine SaveReverse. If not, eLocutor looks for <SPAN class=docEmphasis>favouriteplaces.txt</SPAN><A name="parent of"></A>, because the parent of Cities is Places. If that file doesn't exist, eLocutor tries a higher ancestor. If <SPAN class=docEmphasis>favouriteplaces.txt</SPAN><A name="added to"></A> does exist, Boston is added to that file using the same subroutine. This provides the user with some control over what the software should consider her "favourites." By creating a file called <SPAN class=docEmphasis>favouritecities.txt</SPAN>, she is telling eLocutor that she uses city names a lot.<A name=idx-CHP-30-2592></A><A name=idx-CHP-30-2593></A></P><A name=retracing_paths></A>
<H4 class=docSection2Title id=title-ID0EWGFK>30.2.9. Retracing Paths</H4>
<P class=docText>To aid in rapid <A name=idx-CHP-30-2594></A>navigation in a rather large tree, <A name=idx-CHP-30-2595></A><A name="made a"></A>eLocutor automatically remembers, for each subtree in which the user has made a selection, what the user did the last 20 times after making a selection here. These destinations are presented conveniently to the user. Each parent node <TT>x</TT><A name=subtree></A> has a subtree <TT>x_</TT><A name="the user"></A>Next. After selecting a leaf node, the user should look under the sibling _Next node and select a destination close to where she wants to go next. Effectively, <A name=idx-CHP-30-2596></A><A name="performed by"></A>eLocutor detects patterns in operations performed by the user and allows her to repeat them easily. The software also remembers the last 20 files that were opened, the last 20 items of text searched for, and the last 20 statements spoken by the user. All of these were easily implemented using SaveReverse.<A name=idx-CHP-30-2597></A></P><A name=the_typing_buffer_editing_and_scrolling></A>
<H4 class=docSection2Title id=title-ID0E4HFK>30.2.10. The Typing Buffer, Editing, and Scrolling</H4>
<P class=docText><A name="There were"></A>There were several different ways we could have handled the scrolling of text, and its selection for cutting and pasting. Most <A name=idx-CHP-30-2598></A><A name="a single"></A>editors work with a single window. In the case of a large document, of course, the entire text does not fit in the window displayed, and scrollbars are used to navigate through the text. When text needs to be copied or cut, it has to be first selected. The selected text is highlighted using different foreground and background colors. We had some problems with this standard approach.<A name=idx-CHP-30-2599></A><A name=idx-CHP-30-2600></A><A name=idx-CHP-30-2601></A></P>
<P class=docText><A name="to also"></A>We wanted eLocutor to also be usable by persons with cerebral palsy, who often have severe <A name=idx-CHP-30-2602></A><A name="resulting in"></A>motor disabilities resulting in speech and vision impairment. For them, we needed to show at least part of the text in a very large font. If we were to use this for all text on the screen, we wouldn't have much on the screen at all. We felt it would be awkward to use a substantially larger font for part of the text in a window. Text highlighted for cutting and pasting by changing background color was found by some to be distracting and difficult to read. Our experience in, and fondness of, audio editing led us to select a different paradigm.</P>
<P class=docText><A name="when audio"></A>In the old days, when audio recording was done using spools of tape, the editor would listen to the tape until he found the start of the portion he wanted to cut, clamp it there, then listen for the end of the portion that was to be deleted, and clamp there again. Now, the portion in between the clamps could easily be cut, or replaced with something else. The tape, therefore, is divided by the two clamps into three sections: that before clamp 1, that after clamp 2, and the portion between clamps.</P>
<P class=docText><A name="text boxes"></A>We adopted the same approach with text, dividing it into three text boxes, with gates between them. Typing is all done at the end of the text in the middle box. This is where the text actually gets inserted and deleted. The Backspace option under Edit deletes text in the middle box from the end. You can decide whether you want to get rid of a character, word, phrase, sentence, paragraph, or the entire middle box.</P>
<P class=docText><A name="select Cut"></A>If you select Cut or Copy under Edit, the entire text in the middle box is copied into the clipboard. Cut, of course, leaves the middle box empty. To compare this with conventional editors, which allow you to set the beginning and the ending of the block of text you wish to cut or copy, imagine that the block begins at the boundary between the upper and the middle box, and ends at the boundary between the middle box and the lower box. Cut or Copy always lifts the entire contents of the middle box.</P>
<P class=docText><A name="multiple boxes"></A>Having the text in multiple boxes in this way allowed us to make more intensive use of screen real estate. We showed the text in the upper box only during <A name=idx-CHP-30-2603></A><A name="it to"></A>scrolling. At other times, we could use it to show the highlighted tree item in large font, as in <A class=docLink href="212.basic_design_model.html#the_elocutor_screen">Figure 30-1</A>, <A name=idx-CHP-30-2604></A><A name="or the"></A>or the contents of lower levels of the tree to provide the user <A name=idx-CHP-30-2605></A><A name="reused the"></A>with a "look ahead." Similarly, we reused the space for the lower box to display the long-click menu at the appropriate time.</P>
<P class=docText><A name="trial and"></A>There was much trial and error in figuring out what worked best, in use of screen real estate. When individual users make special requests with regard to what they wish to view on the screen, we try to accommodate those in the spaces for the upper and lower boxes.</P>
<P class=docText><A name="the clamps"></A>Analogous to the clamps in audio editing, we have gates. If you wish to cut out a large segment of text, you first scroll until the start of the segment is at the beginning of the middle box. We now close the gate between it at the upper box, so that scrolling does not move text past this boundary: the text is "clamped" at this point. You continue scrolling up or down until the end of the segment you wish to cut is at the end of the middle box. You can now select Cut under Edit.</P>
<P class=docText><A name="Scroll allow"></A>Menu choices under Scroll allow one or both gates to be opened. Red and green circles show the status of the gates. In <A class=docLink href="212.basic_design_model.html#the_elocutor_screen">Figure 30-1</A>, <A name=idx-CHP-30-2606></A><A name="and right"></A>both gates are open, indicated by green circles to the left and right of the middle box. Two commands, Text Up and Text Down, are available to move text between the boxes. For text to be able to move between the top and the middle box, or between the middle box and the bottom box, the corresponding gate must be open.</P>
<P class=docText><A name="of text"></A>The amount of text moved by the text up/down commands depends on the marker selected by the user, which can be character, word, punctuation mark, sentence, or paragraph. The scroll marker currently selected is shown on the screen below the tree. Commands are also available to move the entire contents of the text boxes from one to the other.</P>
<P class=docText><A name="able to"></A>In order to be able to scroll a small amount during typing, Words Down and Words Up options are available using the long click. When one of these is selected, words scroll in the selected direction until the right mouse button is clicked again. Note that combinations of punctuation characters are treated as words, too. This allows the user to make quick corrections in the immediate vicinity of the point of insertion or deletion of text, to rapidly scroll a bit while typing.</P><A name=the_clipboard></A>
<H4 class=docSection2Title id=title-ID0E5KFK>30.2.11. The Clipboard</H4>
<P class=docText><A name="or Copy"></A>When the user selects Cut or Copy in the Edit subtree, SaveReverse is invoked to prepend the contents of the middle box to the file <SPAN class=docEmphasis>clipboard.txt</SPAN><A name="keeping a"></A>, keeping a total of 20 paragraphs. The advantage of this approach is that it allows paragraphs to be easily rearranged, and older cuts to be pasted again and again. In most text <A name=idx-CHP-30-2607></A><A name="or Copy"></A>editors, each time Cut or Copy is selected, the previous contents of the clipboard are lost. In <A name=idx-CHP-30-2608></A><A name="hangs around"></A>eLocutor, older clipboard information hangs around for a while.<A name=idx-CHP-30-2609></A><A name=idx-CHP-30-2610></A><A name=idx-CHP-30-2611></A></P><A name=searching></A>
<H4 class=docSection2Title id=title-ID0EIMFK>30.2.12. Searching</H4>
<P class=docText><A name="can lack"></A>No self-respecting editor can lack a <A name=idx-CHP-30-2612></A>search function, but <A name=idx-CHP-30-2613></A><A name="to look"></A>eLocutor allowed us to look at this basic function afresh. We realized that searching is indeed just a special case of scrolling, so we merely extended our scroll implementation. The user can copy text from the middle box into the filter buffer, or select Set Filter with the desired text highlighted in the tree via a long click. When text is present in the filter, and a scroll command is given, scrolling does not stop until the contents of the filter are also found in the middle box, or the end of text reached.<A name=idx-CHP-30-2614></A><A name=idx-CHP-30-2615></A></P><A name=macros></A>
<H4 class=docSection2Title id=title-ID0ENNFK>30.2.13. Macros</H4>
<P class=docText><A name="with Professor"></A>An interesting point came up in one of our discussions with Professor Hawking's office. They told me he sometimes had problems with Equalizer when delivering a speech, if the lighting made it hard for him to read the screen. Without being able to read the screen, he found it hard to alternately scroll the text, then issue a speak command.<A name=idx-CHP-30-2616></A><A name=idx-CHP-30-2617></A></P>
<P class=docText>In <A name=idx-CHP-30-2618></A><A name="was possible"></A>eLocutor, it already was possible to put the entire text of the speech in the middle box and issue a command to the software to say it, but that was insufficient. People might clap or laugh in the middle, so he needed to be able to wait for them to subside before continuing to deliver the lecture.</P>
<P class=docText><A name="been hard"></A>It would not have been hard to build in a function to scroll and speak a sentence each time the user selected a particular menu item, but rather than hardcode this, we thought it would be better to address this problem at a more general level, by providing a macro function that would allow other such combinations to be made in the future.</P>
<P class=docText><A name="a node"></A>In the Commands subtree is a node called Macros, under which all files in the subdirectory <SPAN class=docEmphasis>C:\eLocutor\macros</SPAN><A name="are listed"></A> are listed. If any of these is selected, the file is opened, and the commands listed in it are executed one by one. No complexities are possible in macro design: no jumps, loops, or branching.</P>
<P class=docText>For <A name=idx-CHP-30-2619></A><A name="two short"></A>speech delivery, we created two short macros, <TT>preparespeech</TT> and <TT>scrollspeak</TT>. <TT>preparespeech</TT><A name="if they"></A> opens both gates if they aren't already, and pushes the entire text into the lower box. Having executed this macro, the user then selects Pause via a long click when <TT>scrollspeak</TT><A name="this could"></A> is highlighted. All this could be done in advance.</P>
<P class=docText><A name="user does"></A>Once on stage, the user does not need to look at the screen. Each time he now clicks, he executes <TT>scrollclick</TT><A name="Up command"></A>, so that effectively two commands are executed. First is a Text Up command, which sends as much text as decided by the scroll marker from the lower box into the middle box, and from the middle box to the top box. The second command speaks the contents of the middle box. Typically, for speech delivery, the scroll marker would be set to a sentence, so that the speech is delivered a sentence at a time, but if greater flexibility were desired, it could be set to a paragraph as well.<A name=I_indexterm30_tt683></A></P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
