<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 33.3. Three in a Row</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>Writing Programs for "The Book"</SPAN><SPAN> &gt; Three in a Row</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=three_in_a_row></A>
<H3 class=docSection1Title id=-100000>33.3. Three in a Row</H3>
<P class=docText><A name="If you"></A>If you were working out a <A name=idx-CHP-33-2799></A><A name="pencil and"></A>collinearity problem with pencil and paper, how would you go about it? One natural approach is to plot the positions of the three points on graph paper, and then, if the answer isn't obvious by inspection, draw a line through two of the points and see whether the line passes through the third point (see <A class=docLink href="javascript:moveTo('three_noncollinear_points');">Figure 33-2</A><A name="accuracy in"></A>). If it's a close call, accuracy in placing the points and drawing the line becomes critical.</P><A name=three_noncollinear_points></A>
<P>
<CENTER>
<H5 class=docFigureTitle><A name="noncollinear points"></A>Figure 33-2. Three noncollinear points</H5><IMG id="" height=202 alt="" src="images/three_in_a_row.0.png" width=500 border=0> </CENTER>
<P></P><BR>
<P class=docText><A name="can do"></A>A computer program can do the same thing, although for the computer nothing is ever "obvious by inspection." To draw a line through two points, the program derives the equation of that line. To see whether the third point lies on the line, the program tests whether or not the coordinates of the point satisfy the equation. (Exercise: For any set of three given points, there are three pairs of points you could choose to connect, in each case leaving a different third point to be tested for collinearity. Some choices may make the task easier than others, in the sense that less precision is needed. Is there some simple criterion for making this decision?)</P>
<P class=docText>The equation of a line takes the form <SPAN class=docEmphasis>y=mx+b</SPAN>, where <SPAN class=docEmphasis>m</SPAN> is the slope and <SPAN class=docEmphasis>b</SPAN> is the <SPAN class=docEmphasis>y</SPAN>-intercept, the point (if there is one) where the line crosses the <SPAN class=docEmphasis>y</SPAN>-axis. So, given three points <SPAN class=docEmphasis>p</SPAN>, <SPAN class=docEmphasis>q</SPAN>, and <SPAN class=docEmphasis>r</SPAN>, you want to find the values of <SPAN class=docEmphasis>m</SPAN> and <SPAN class=docEmphasis>b</SPAN><A name="test the"></A> for the line that passes through two of them, and then test the <SPAN class=docEmphasis>x</SPAN>-and <SPAN class=docEmphasis>y</SPAN><A name="third point"></A>-coordinates of the third point to see if the same equation holds.</P>
<P class=docText>Here's the code:</P><PRE>	(defun naive-collinear (px py qx qy rx ry)
	  (let ((m (slope px py qx qy))
	        (b (<A name=idx-CHP-33-2800></A>y-intercept px py qx qy)))
	    (= ry (+ (* m rx) b))))
</PRE><BR>
<P class=docText><A name="it returns"></A>The procedure is a predicate: it returns a Boolean value of true or false (in Lisp argot, <TT>t</TT> or <TT>nil</TT>). The six arguments are the <SPAN class=docEmphasis>x</SPAN>-and <SPAN class=docEmphasis>y</SPAN>-coordinates of the points <SPAN class=docEmphasis>p</SPAN>, <SPAN class=docEmphasis>q</SPAN>, and <SPAN class=docEmphasis>r</SPAN>. The <TT>let</TT> form introduces local variables named <TT>m</TT> and <TT>b</TT><A name="by the"></A>, binding them to values returned by the procedures <TT>slope</TT><A name=and></A> and <TT>y-intercept</TT><A name="the definitions"></A>. I'll return shortly to the definitions of those procedures, but their <A name=idx-CHP-33-2801></A><A name="apparent from"></A>functions should be apparent from their names. Finally, the last line of the procedure does all the work, posing the question: is the <SPAN class=docEmphasis>y</SPAN>-coordinate of point <SPAN class=docEmphasis>r</SPAN> equal to <SPAN class=docEmphasis>m</SPAN> times the <SPAN class=docEmphasis>x</SPAN>-coordinate of <SPAN class=docEmphasis>r</SPAN>, plus <SPAN class=docEmphasis>b</SPAN><A name="is returned"></A>? The answer is returned as the value of the <TT>naive-collinear</TT> function.</P>
<P class=docText><A name="Does it"></A>Could it be simpler? Well, we'll see. Does it work? Often. If you were to set the procedure loose on a large collection of points generated at random, it would probably run without error for a very long time. Nevertheless, it's easy to break it. Just try applying it to points with (<SPAN class=docEmphasis>x y</SPAN>) coordinates (0 0), (0 1), and (0 2). These points are surely collinear—they all lie on the <SPAN class=docEmphasis>y</SPAN>-axis—and yet the <TT>naive-collinear</TT><A name="them as"></A> procedure can't be expected to return a sensible value when given them as arguments.</P>
<P class=docText><A name="cause of"></A>The root cause of this failure is lurking inside the definition of <TT>slope</TT>. Mathematically, the slope <SPAN class=docEmphasis>m</SPAN> is Δ<SPAN class=docEmphasis>y</SPAN>/Δ<SPAN class=docEmphasis>x</SPAN><A name="as follows"></A>, which the program calculates as follows:</P><PRE>	(defun slope (px py qx qy)
	  (/ (- qy py) (- qx px))))
</PRE><BR>
<P class=docText>If <SPAN class=docEmphasis>p</SPAN> and <SPAN class=docEmphasis>q</SPAN> happen to have the same <SPAN class=docEmphasis>x</SPAN>-coordinate, then Δ<SPAN class=docEmphasis>x</SPAN> is zero, and Δ<SPAN class=docEmphasis>y</SPAN>/Δ<SPAN class=docEmphasis>x</SPAN><A name="trying to"></A> is undefined. If you insist on trying to calculate the slope, you'll get no further than a divide-by-zero error. There are lots of ways of coping with this annoyance. The method I chose as I first assembled the pieces of this little program was to have <TT>slope</TT><A name="return a"></A> return a special signal value if <TT>px</TT> is equal to <TT>qx</TT><A name="is to"></A>. The Lisp custom is to use the value <TT>nil</TT> for this purpose:</P><PRE>	(defun slope (px py qx qy)
	  (if (= px qx)
	      nil
	      (/ (- qy py) (- qx px))))
</PRE><BR>
<P class=docText>Like the slope, the <SPAN class=docEmphasis>y</SPAN>-intercept of a <A name=idx-CHP-33-2802></A><A name="also undefined"></A>vertical line is also undefined because the line crosses the <SPAN class=docEmphasis>y</SPAN><A name="or "></A>-axis either nowhere or (if <SPAN class=docEmphasis>x</SPAN>=0) everywhere. The same <TT>nil</TT> trick applies:</P><PRE>	(defun y-intercept (px py qx qy)
	  (let ((m (slope px py qx qy)))
	    (if (not m)
	        nil
	        (- py (* m px)))))
</PRE><BR>
<P class=docText><A name="to re"></A>Now, I also had to re-rig the calling procedure to handle the possibility that the slope <TT>m</TT> is not a number but a bogus value:</P><PRE>	(defun less-naive-collinearp (px py qx qy rx ry)
	  (let ((m (slope px py qx qy))
	        (b (y-intercept px py qx qy)))
	    (if (numberp m)
	        (= ry (+ (* m rx) b))
	        (= px rx))))
</PRE><BR>
<P class=docText>If <SPAN class=docEmphasis>m</SPAN> is numeric—if the predicate (<TT>numberp m</TT>) returns t—then I proceed as before. Otherwise, I know that <SPAN class=docEmphasis>p</SPAN> and <SPAN class=docEmphasis>q</SPAN> share the same <SPAN class=docEmphasis>x</SPAN>-coordinate. It follows that the three points are collinear if <SPAN class=docEmphasis>r</SPAN> also has this same <SPAN class=docEmphasis>x</SPAN> value.</P>
<P class=docText><A name="vertical lines"></A>As the program evolved, the need to make special provisions for vertical lines was a continual irritation. It began to look like every procedure I wrote would have some ugly patch bolted on to deal with the possibility that a line is parallel to the <SPAN class=docEmphasis>y</SPAN><A name="was just"></A>-axis. Admittedly, the patch was just an <TT>if</TT><A name="two of"></A> expression, an extra line or two of code, not a major issue of software engineering. Conceptually, though, it seemed a needless complication, and perhaps a sign that I was doing something wrong or making life harder than it had to be. Vertical lines are not fundamentally any different from horizontal ones, or from lines that wander across the plane at any other angle. It's an arbitrary convention to measure slope with respect to the <SPAN class=docEmphasis>y</SPAN><A name="different if"></A>-axis; the universe would look no different if we all adopted a different reference direction.</P>
<P class=docText><A name="This observation"></A>This observation suggests a way around the problem: rotate the whole coordinate frame. If a set of points are collinear in one frame, they must be collinear in all other frames as well. Tilt the axes by a few degrees one way or the other, and the divide-by-zero impasse disappears. The rotation is not difficult or <A name=idx-CHP-33-2803></A><A name="matrix multiplication"></A>computationally expensive; it's just a matrix multiplication. On the other hand, taking this approach means I still have to write that <TT>if</TT><A name="see whether"></A> expression somewhere, testing to see whether <TT>px</TT><A name=to></A> is equal to <TT>qx</TT><A name="is to"></A>. What I'd really prefer is to streamline the logic and get rid of the branch point altogether. Shouldn't it be possible to test for <A name=idx-CHP-33-2804></A><A name="of the"></A>collinearity by means of some simple calculation on the coordinates of the points, without any kind of case analysis?</P>
<P class=docText><A name="recommended "></A>Here's a solution recommended (in a slightly different context) by one web site, which I shall allow to remain anonymous: when Δ<SPAN class=docEmphasis>x</SPAN> is 0, just set Δ<SPAN class=docEmphasis>y</SPAN>/Δ<SPAN class=docEmphasis>x</SPAN> to 10<SUP>10</SUP><A name="As a"></A>, a value "close enough to infinity." As a practical matter, I suspect that this policy might actually work quite well, most of the time. After all, if the input to the program derives in any way from <A name=idx-CHP-33-2805></A><A name="there will"></A>measurements made in the real world, there will be errors far larger than 1 part in 10<SUP>10</SUP><A name="All the"></A>. All the same, this is a strategy I did not consider seriously. I may not know what the <SPAN class=docEmphasis>Book</SPAN> version of <TT>collinear</TT><A name="refuse to"></A> looks like, but I refuse to believe it has a constant defined as "close enough to infinity."<A name=I_indexterm33_tt736></A></P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
