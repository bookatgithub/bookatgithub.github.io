<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="styles/globalstyle.css" type="text/css" rel="stylesheet"/>
<link title="medium" href="styles/two.css" type="text/css" rel="stylesheet"/>
<script src="scripts/main.js" type="text/javascript" language="javascript"></script>
<title>Section 33.6. Meandering On</title>
</head><body>
<DIV class=h3 style="MARGIN-TOP: 0px; PADDING-BOTTOM: 1em; WIDTH: 100%; PADDING-TOP: 0px"><SPAN>Writing Programs for "The Book"</SPAN><SPAN> &gt; Meandering On</SPAN></DIV>
<DIV></DIV>
<DIV>
<DIV><A name=meandering_on></A>
<H3 class=docSection1Title id=-100000>33.6. Meandering On</H3>
<P class=docText><A name="To tell"></A>To tell the rest of this story, I need to mention the context in which it took place. Some months ago I was playing with a simple model of <A name=idx-CHP-33-2817></A><A name="those giant"></A>river meandering—the formation of those giant horseshoe bends you see in the Lower Mississippi. The model decomposed the smooth curve of the river's course into a chain of short, straight segments. I needed to measure curvature along the river in terms of the bending angles between these segments, and in particular, I wanted to detect regions of zero curvature—hence the collinearity predicate.</P>
<P class=docText><A name="the program"></A>Another part of the program gave me even more trouble. As meanders grow and migrate, one loop sometimes runs into the next one, at which point the river takes a shortcut and leaves behind a stranded "oxbow" lake. (You don't want to be standing in the way when this happens on the Mississippi.) To detect such events in the model, I needed to scan for <A name=idx-CHP-33-2818></A><A name="I was"></A>intersections of segments. Again, I was able to get a routine working, but it seemed needlessly complex, with a decision tree sprouting a dozen branches. As in the case of collinearity, vertical segments and coincident points required special handling, and I also had to worry about parallel segments.</P>
<P class=docText><A name="I eventually"></A>For the intersection problem, I eventually spent some time in the library and checked out what the Net had to offer. I learned a lot. That's where I found the tip that 1010 is close enough to infinity. And Bernard Chazelle and Herbert Edelsbrunner suggested a subtler way of finessing the singularities and degeneracies I had run into. In a 1992 review article on <A name=idx-CHP-33-2819></A>line-segment intersection algorithms (see the "Further Reading" section at the end of this chapter), they wrote:</P>
<BLOCKQUOTE>
<P class=docText><A name="endpoints have"></A>For the ease of exposition, we shall assume that no two endpoints have the same <SPAN class=docEmphasis>x</SPAN>-or <SPAN class=docEmphasis>y</SPAN><A name="to the"></A>-coordinates. This, in particular, applies to the two endpoints of the same segment, and thus rules out the presence of vertical or horizontal segments…Our rationale is that the key ideas of the algorithm are best explained without having to worry about special cases every step of the way. Relaxing the assumptions is very easy (no new ideas are required) but tedious. That's for the theory. Implementing the algorithm so that the program works in all cases, however, is a daunting task. There are also numerical problems that alone would justify writing another paper. Following a venerable tradition, however, we shall try not to worry too much about it.</P></BLOCKQUOTE>
<P class=docText><A name="lesson learned"></A>Perhaps the most important lesson learned from this foray into the literature was that others have also found meaty challenges in this field. It's not just that I'm a code wimp. This was a reassuring discovery; on the other hand, it did nothing to actually solve my problem.</P>
<P class=docText><A name="intersection algorithms"></A>Later, I wrote an item about line-segment intersection algorithms on my weblog at <A class=docLink href="http://bit-player.org/" target=_blank>http://bit-player.org</A><A name="This was"></A>. This was essentially a plea for help, and help soon came pouring in—more than I could absorb at the time. One reader suggested polar coordinates as a remedy for undefined slopes, and another advocated rewriting the linear equations in parametric form, so that <SPAN class=docEmphasis>x</SPAN>-and <SPAN class=docEmphasis>y</SPAN><A name="functions of"></A>-coordinates are given as functions of a new variable <SPAN class=docEmphasis>t</SPAN><A name="a somewhat"></A>. Barry Cipra proposed a somewhat different parametric scheme, and then came up with yet another algorithm, based on the idea of applying an affine transformation to shift one of the segments onto the interval (–1 0),(1 0). David Eppstein advocated removing the problem from Euclidean <A name=idx-CHP-33-2820></A><A name="solving it"></A>geometry and solving it on the projective plane, where the presence of "a point at infinity" helps in dealing with singularities. Finally, Jonathan Richard Shewchuk gave me a pointer to his lecture notes, papers, and working code; I'll return to Shewchuk's ideas below.</P>
<P class=docText><A name="this flood"></A>I was impressed—and slightly abashed—by this flood of thoughtful and creative suggestions. There were several viable candidates for a segment-intersection procedure. Furthermore, I also found an answer to the collinearity problem. Indeed, I believe the solution that was handed to me may well be the <SPAN class=docEmphasis>Book</SPAN> algorithm.</P></DIV></DIV>
<p>&nbsp;</p><p>&nbsp;</p><!-- 仁·义 -->
</body></html>
