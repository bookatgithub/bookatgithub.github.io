<html><head><title>23.4. Dealing with User Issues</title><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css"><link href="includes/searchResults.css" rel="stylesheet" type="text/css"><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css"><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css"></head><body leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"><a name="toppage"></a><table width="100%" border="0" cellspacing="0" cellpadding="0" class="sfbody"><tr valign="top"><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="getting_it_right.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="epilogue-id001.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">Process Project Management Software Engineering Business Andrew Stellman  Jennifer Greene  O'Reilly Media, Inc. Beautiful Teams<a name="dealing_with_user_issues"></a>
<h3 id="title-IDA3WCG" class="docSection1Title">23.4. Dealing with User Issues</h3>
<p class="docText">One of the major tasks that we had to undertake was education
        and support for the users of the tool set. Most were unfamiliar with
        the Ada programming language, few knew any details of the processor
        architecture, and the tool set was new to all of the users.<a name="idx-CHP-23-0750"></a></p>
<p class="docText">Aside from dealing with some of the myths about Ada, the HADS
        team had to struggle with a general lack of Ada knowledge among the
        777 developers. Ada is a powerful language with a lot of features that
        make it ideal for safety-critical embedded systems. These days it
        would not be considered to be a complex language, but at the time, it
        was considered to be a very complicated language to learn. Many of the
        software engineering concepts that Ada was designed to assist were
        foreign to the majority of developers. The HADS team had to take on a
        role as informal instructors in the use of Ada. For example, Ada's
        strong type checking can lead to difficulties <a name="idx-CHP-23-0751"></a>getting programs to compile. This is an intentional
        attempt, in the design of the language, to catch inconsistencies as
        early as possible (during compilation) rather than at runtime. But
        struggling users tend to blame their tools. We were often called to
        help out some user with a compilation problem. Since most of us on the
        HADS team were very familiar with Ada, this was not difficult, but
        time-consuming. It also could lead to some tense encounters.</p>
<p class="docText">I remember being asked to go help Frank who was having some
        difficulties getting his code to compile. I went over to his desk and
        we sat down to go over his code. He definitely was having some
        type-mismatch problems with the subscripts of an array and the
        elements of the array. So we struggled through getting the types
        straightened out. Frank was quite frustrated with the strong type
        checking. I think he came from the school that feels that anything
        should compile and then you debug the result. Finally we got his code
        to a state where it would compile, but it seemed overly complex. I
        said to him, "You know, there is a better way to do this," and told
        him about some Ada features that would make the
        code clearer and probably generate more efficient code. Frank got all
        upset, feeling insulted that I was criticizing his code. I was taken
        aback, since in the HADS project we did this all the time, and the
        team members considered it helpful. Of course, the members of the
        <a name="idx-CHP-23-0752"></a>HADS team knew that they were good and didn't feel
        threatened. Frank had just gone through a lot of frustration just to
        get something to compile, and was then told there was a better
        way.</p>
<p class="docText">Passing all of a test suite does not guarantee that a compiler
        is bug-free. The ACVC tests are a rigorous set of tests for the basic
        features of Ada, but combinations of features may not be tested and
        implementation dependencies are not included in the suite. Naturally,
        the HADS team had to deal with bugs in the releases. One thing that we
        did well was, when possible, to duplicate a bug with a small test
        which was then added to our own regression test suite that was run in
        addition to the ACVC tests. Producing such a test case can be
        difficult.</p>
<p class="docText">One time Paul came to the team with a bug report, and after
        looking at it, we agreed that this did seem to be a code generation
        problem. Unfortunately, Paul said that he could produce the bug only
        in a large, complex system, and that whenever he would try to simplify
        it, the bug would go away. Clearly he had found some obscure corner
        case. Luckily, as part of Honeywell, we had no difficulties getting
        permission to get all of Paul's code. By turning on some output of the
        internal workings of the compiler, we were able to see what the
        compiler was doing, and we were able to reduce the original case
        consisting of several thousand lines of code down to a test program of
        about twenty lines. Sometimes it was not as easy as this, and we might
        spend several days creating a small test case. Still, the effort was
        worthwhile since finding a correction for a bug in a small program is
        much easier than trying to find the correction in a large program. The
        small program also provided the basis for the regression test.</p>
<p class="docText">I've often said that software tools are at the bottom of the
        food chain. By that I mean that when all else fails, <a name="idx-CHP-23-0753"></a>users blame their tools. We had to deal with this issue
        a great deal, since not only was there a tool to blame, but it was a
        "homegrown" tool, and therefore was more mistrusted. One day, I got a
        support call from Frances who was complaining about a compiler bug.
        When she was writing to an array, erroneous code generation was
        causing another nearby variable to be overwritten. This kind of
        behavior is possible, perhaps even likely, when using a language like
        C that doesn't check that an array subscript is in the proper range.
        With Ada's compile and runtime checks, this behavior should be caught.
        If it is statically known at compile time that a subscript will be out
        of bounds, a warning will be emitted at compile time. At runtime,
        checks will raise an exception if an attempt to access an array with
        an out-of-bounds subscript is done. Such runtime checks do generate
        extra code and can create inefficiencies, so Ada compilers allow an
        option to turn off some or all runtime checks. Frances had done her
        build using an inherited build script that turned off runtime checks.
        A small amount of investigation and debugging showed that the source
        code was written so that values were written beyond the end of the
        array. The compiler was generating code to do exactly what it was
        instructed to do. We had to continually educate users on the tools'
        command-line options and their effects.</p>
<p class="docText">We had to deal with many bug reports that
        turned out to be user error. Unofficially we called these UIB (User Is
        Bozo) errors.</p>
<p class="docText">Once the ACVC tests were passing and several releases with some
        implementation-dependent features were made, the team began working on
        creating a source-level debugging environment for the <a name="idx-CHP-23-0754"></a>HADS system. About this time, Cynthia was taken from the
        team to work on the 777 project. The remaining members of the team did
        the initial work on the debugger. Tom, Dave, Peter, Dan, and Waleen
        then returned to compiler issues, while I finished the first release
        of the debugger. Tom concentrated on peephole optimizations, Dave
        concentrated on efficient use of registers, and Dan and Waleen
        concentrated on general choice of optimal machine code generation for
        a construct.</p>
<p class="docText">One of the things that Dave needed to do in providing for
        efficient use of registers was "live/dead" analysis to determine when
        a register is holding a variable and when that variable is no longer
        used. As a side effect of doing this analysis, it was easy to
        determine whether a register was being read before it was written to.
        This would mean that an uninitialized variable was being used. Dave
        generated code that would emit a warning about an uninitialized
        variable being used. Once this was released to users and they began to
        get the warning, they began to call, asking for help to find their
        uninitialized variables. Dave found a clever way to analyze the inputs
        to the register allocation whereby he could output the name of the
        uninitialized variable. He implemented this and wrote several small
        test cases that showed that it worked properly. We included this
        feature in the next release. Almost immediately, we started to get
        complaints that the compiler had slowed down, and as we looked into
        it, we found that it was this uninitialized variable analysis. For one
        system that had compiled in under five minutes with the previous
        release, we aborted its compile after a day and a half. Naturally, the
        compiler was not any slower when there were no uninitialized
        variables, but it was clear that the ability to name any uninitialized
        variable detected was not worth the expense.</p>
<p class="docText">Adding information about the uninitialized variables was just
        one example of a request for a feature that came from our users. Since
        we were in-house and since many of the users had gotten to know us, we
        were often individually approached to add a feature to one of the
        tools. This began to get out of hand and we soon adopted a policy of
        "just say no" to any such request. We referred all of the requestors
        to our project lead, Tom, who would decide, along with the rest of the
        team, whether the request should be added to our work and what
        priority it should have.</p>
<p class="docText">We also instituted a "top 10" list for each person. Each person
        had a list of his top 10 priorities. That way, he knew what he should
        be working on now and what was coming up next. Tom might revise these
        lists daily, but if we disagreed with the priorities, he was open to
        discussion. We also had weekly meetings, on Friday afternoons, where
        we discussed the progress of the previous week and helped set
        priorities for the coming week. A small amount of technical discussion
        might also occur at these meetings.</p>
<p class="docText">When we were making the source-level debugger, much could be
        taken from previous DDC-I work, but many areas of debugging are
        architecture-specific. The <a name="idx-CHP-23-0755"></a>handling of debug information is
        architecture-specific, and each target has specific ways of doing
        things such as setting breakpoints. Because the simulator was so
        useful to the <a name="idx-CHP-23-0756"></a>team, a debugger that supported both the simulator and
        actual targets was made. As with the compiler, the release of the
        debugger was not a "big bang"&mdash;rather, a series of releases, supporting
        more and more features, was planned.</p>
<p class="docText">With the release of the debugger, more <a name="idx-CHP-23-0757"></a>user support was required. One issue that was
        particularly perplexing was variables in registers. The code ported
        from the DDC-I baseline did a good job of indicating the initial
        location of a variable in a register, and where the register was
        stored if a subprogram was called while in the scope of the variable.
        But when we started to add optimizations to reuse registers, we found
        that we did not have information about how a variable might be moved
        from the register into memory and the register given to another
        variable. Users would ask for the value of a variable at a point where
        it was dead and its register reused. They would get an incorrect,
        confusing value when really the correct answer was that the variable
        was no longer available at that point in the code. It was a
        significant task to design a system to track this and to implement it
        in the debugger and in the register assignment portion of the
        compiler.</p>
<p class="docText">Many users are unfamiliar with using source-level debuggers,
        having mostly used print statements to get information about their
        programs. Educating users about how to use the debugger was an ongoing
        task. It seemed that no one reads manuals. As users would get familiar
        with the debugger, they would often ask for the addition of a feature
        that would make debugging easier for them. Usually it was easy to
        "fill" these requests since the feature was already in the debugger
        and the user hadn't read the manual.</p>
<p class="docText">Even with source-level debugging, sometimes it is useful for
        users to be able to debug at a machine code level to examine the
        low-level behavior of the code. Of course, when debugging at this
        machine code level, it is useful to know something about the
        architecture of the machine and its assembly language. Unfortunately,
        many users didn't bother to read that documentation either. One day,
        Sam called me up and said, "Either this debugger is broken, or there
        is something wrong with the simulator." So, I went over to his cubicle
        to see whether I could find the problem so that we could fix it. He
        was debugging at the machine code level where he could step individual
        machine instructions. He said, "Look, here I am ready to execute a
        call statement, but when I step into the machine code, I end up at the
        statement after the call rather than in the called routine." It was
        hard not to laugh. The architecture utilizes a "delay slot" to keep
        the instruction pipeline full when doing a branch or call. So, the
        behavior that Sam was seeing was the correct behavior.</p>
<p class="docText">A similar experience came when Helen called up to tell us that
        the compiler had optimized an important statement of her code. She was
        stepping through the code at the machine code level and got to a call
        statement. The source window was reflecting the source code positions
        that corresponded to the machine instructions executed. She said,
        "See, the assignment that is done just before the call was not done."
        Our optimization had moved the assignment into the delay slot. If she
        had executed one more machine code step, she might have been surprised
        that she didn't immediately get to the called routine, but she would
        have seen her assignment being done.</p>
<a href="19991539.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="getting_it_right.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="epilogue-id001.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td><td align="center">
                        &nbsp;
                      </td></tr><tr><td colspan="3" align="center" valign="bottom"><br /><p class="v2" align="center"></p><br /></td></tr></table></body>