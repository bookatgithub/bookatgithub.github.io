<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section A.2.&nbsp; A Brief Tour of the Algorithms</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app01lev1sec1.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=app01lev1sec3.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="app01lev1sec2"></a>
<h3 class="docSection1Title">A.2. A Brief Tour of the Algorithms</h3>
<p class="docText"><a class="docLink" href="ch11.html#ch11">Chapter 11</a> introduced the generic algorithms and outlined their underlying architecture. The library defines more than 100 algorithms. Learning to use them requires understanding their structure rather than memorizing the details of each algorithm. In this section we describe each of the algorithms. In it, we organize the algorithms by the type of action the algorithm performs.</P>
<a name="app01lev2sec1"></a>
<H4 class="docSection2Title">A.2.1. Algorithms to Find an Object</h4>
<p class="docText">The <tt>find</tt> and <tt>count</tt> algorithms search the input range for a specific value. <tt>find</tt> returns an iterator to an element; <tt>count</tt> returns the number of matching elements.</P>
<a name="app01lev3sec1"></a>
<h5 class="docSection3Title">Simple Find Algorithms</h5>
<p class="docText">These algorithms require input iterators. The <tt>find</tt> and <tt>count</tt> algorithms look for specific elements. The <tt>find</tt> algorithms return an iterator referring to the first matching element. The <tt>count</tt> algorithms return a count of how many times the element occurs in the input sequence.</P>
<pre>
<span class="docEmphStrong">find(beg, end, val)</span>
<span class="docEmphStrong">count(beg, end, val)</span>
</pre><BR>
<p class="docText"><a name="idd1e156047"></a><a name="idd1e156051"></a><a name="idd1e156055"></a><a name="idd1e156059"></a><a name="idd1e156063"></a><a name="idd1e156067"></a><a name="idd1e156071"></a>Looks for element(s) in input range equal to <tt>val</tt>. Uses the equality (<tt>==</tt>) operator of the underlying type. <tt>find</tt> returns an iterator to the first matching element or <tt>end</tt> if no such element exists. <tt>count</tt> returns a count of how many times <tt>val</tt> occurs.</p>
<pre>
<span class="docEmphStrong">find_if(beg, end, unaryPred)</span>
<span class="docEmphStrong">count_if(beg, end, unaryPred)</span>
</pre><br>
<p class="docText">Looks for element(s) in input range for which <tt>unaryPred</tt> is true. The predicate must take a single parameter of the <tt>value_type</tt> of the input range and return a type that can be used as a condition.</p>
<p class="docText"><tt>find</tt> returns an iterator to first element for which <tt>unaryPred</tt> is true, or <tt>end</tt> if no such element exists. <tt>count</tt> applies <tt>unaryPred</tt> to each element and returns the number of elements for which <tt>unaryPred</tt> was true.</p>

<a name="app01lev3sec2"></a>
<h5 class="docSection3Title">Algorithms to Find One of Many Values</H5>
<p class="docText">These algorithms require two pairs of forward iterators. They search for the first (or last) element in the first range that is equal to any element in the second range. The types of <tt>beg1</tt> and <tt>end1</tt> must match exactly, as must the types of <tt>beg2</tt> and <tt>end2</tt>.</p>
<p class="docText">There is no requirement that the types of <tt>beg1</tt> and <tt>beg2</tt> match exactly. However, it must be possible to compare the element types of the two sequences. So, for example, if the first sequence is a <tt>list&lt;string&gt;</tt>, then the second could be a <tt>vector&lt;char*&gt;</tt>.</P>
<p class="docText">Each algorithm is overloaded. By default, elements are tested using the <tt>==</tt> operator for the element type. Alternatively, we can specify a predicate that takes two parameters and returns a <tt>bool</tt> indicating whether the test between these two elements succeeds or fails.</P>
<pre>
<span class="docEmphStrong">find_first_of(beg1, end1, beg2, end2)</span>
</pre><br>
<p class="docText">Returns an iterator to the first occurrence in the first range of any element from the second range. Returns <tt>end1</tt> if no match found.</p>
<pre>
<span class="docEmphStrong">find_first_of(beg1, end1, beg2, end2, binaryPred)</span>
</pre><br>
<p class="docText">Uses <tt>binaryPred</tt> to compare elements from each sequence. Returns an iterator to the first element in the first range for which the <tt>binaryPred</tt> is true when applied to that element and an element from the second sequence. Returns <tt>end1</tt> if no such element exits.</P>
<pre>
<span class="docEmphStrong">find_end(beg1, end1, beg2, end2)</span>
<span class="docEmphStrong">find_end(beg1, end1, beg2, end2, binaryPred)</span>
</pre><BR>
<p class="docText">Operates like <tt>find_first_of</tt>, except that it searches for the last occurrence of any element from the second sequence.</p>
<p class="docText">As an example, if the first sequence is 0,1,1,2,2,4,0,1 and the second sequence is 1,3,5,7,9, then <tt>find_end</tt> would return an iterator denoting the last element in the input range, and <tt>find_first_of</tt> would return an iterator to the second elementin this example, it returns the first 1 in the input sequence.</p>

<a name="app01lev3sec3"></a>
<h5 class="docSection3Title">Algorithms to Find a Subsequence</h5>
<p class="docText"><a name="idd1e156251"></a><a name="idd1e156255"></a><a name="idd1e156259"></a><a name="idd1e156263"></a>These algorithms require forward iterators. They look for a subsequence rather than a single element. If the subsequence is found, an iterator is returned to the first element in the subsequence. If no subsequence is found, the <tt>end</tt> iterator from the input range is returned.</P>
<p class="docText">Each function is overloaded. By default, the equality (<tt>==</tt>) operator is used to compare elements; the second version allows the programmer to supply a predicate to test instead.</p>
<pre>
<span class="docEmphStrong">adjacent_find(beg, end)</span>
<span class="docEmphStrong">adjacent_find(beg, end, binaryPred)</span>
</pre><br>
<p class="docText">Returns an iterator to the first adjacent pair of duplicate elements. Returns <tt>end</tt> if there are no adjacent duplicate elements. In the first case, duplicates are found by using <tt>==</tt>. In the second, duplicates are those for which the <tt>binaryPred</tt> is true.</P>
<pre>
<span class="docEmphStrong">search(beg1, end1, beg2, end2)</span>
<span class="docEmphStrong">search(beg1, end1, beg2, end2, binaryPred)</span>
</pre><br>
<p class="docText">Returns an iterator to the first position in the input range at which the second range occurs as a subsequence. Returns <tt>end1</tt> if the subsequence is not found. The types of <tt>beg1</tt> and <tt>beg2</tt> may differ but must be compatible: It must be possible to compare elements in the two sequences.</p>
<pre>
<span class="docEmphStrong">search_n(beg, end, count, val)</span>
<span class="docEmphStrong">search_n(beg, end, count, val, binaryPred)</span>
</pre><BR>
<p class="docText">Returns an iterator to the beginning of a subsequence of <tt>count</tt> equal elements. Returns <tt>end</tt> if no such subsequence exists. The first version looks for <tt>count</tt> occurrences of the given <tt>value</tt>; the second version <tt>count</tt> occurrences for which the <tt>binaryPred</tt> is true.</p>


<a name="app01lev2sec2"></a>
<H4 class="docSection2Title">A.2.2. Other Read-Only Algorithms</h4>
<p class="docText">These algorithms require input iterators for their first two arguments. The <tt>equal</tt> and <tt>mismatch</tt> algorithms also take an additional input iterator that denotes a second range. There must be at least as many elements in the second sequence as there are in the first. If there are more elements in the second, they are ignored. If there are fewer, it is an error and results in undefined run-time behavior.</p>
<p class="docText">As usual, the types of the iterators denoting the input range must match exactly. The type of <tt>beg2</tt> must be compatible with the type of <tt>beg1</tt>. That is, it must be possible to compare elements in both sequences.</p>
<p class="docText">The <tt>equal</tt> and <tt>mismatch</tt> functions are overloaded: One version uses the element equality operator (<tt>==</tt>) to test pairs of elements; the other uses a predicate.</p>
<pre>
<span class="docEmphStrong">for_each(beg, end, f)</span>
</pre><br>
<p class="docText">Applies the function (or function object (<a class="docLink" href="ch14lev1sec8.html#ch14lev1sec8">Section 14.8</a>, p. <a class="docLink" href="ch14lev1sec8.html#ch14lev1sec8">530</a>)) <tt>f</tt> to each element in its input range. The return value, if any, from <tt>f</tt> is ignored. The iterators are input iterators, so the elements may not be written by <tt>f</tt>. Typically, <tt>for_each</tt> is used with a function that has side effects. For example, <tt>f</tt> might print the values in the range.</p>
<pre>
<span class="docEmphStrong">mismatch(beg1, end1, beg2)</span>
<span class="docEmphStrong">mismatch(beg1, end1, beg2, binaryPred)</span>
</pre><br>
<p class="docText"><a name="idd1e156443"></a><a name="idd1e156447"></a><a name="idd1e156451"></a><a name="idd1e156455"></a><a name="idd1e156459"></a><a name="idd1e156463"></a>Compares the elements in two sequences. Returns a pair of iterators denoting the first elements that do not match. If all the elements match, then the <tt>pair</tt> returned is <tt>end1</tt>, and an iterator into <tt>beg2</tt> offset by the size of the first sequence.</p>
<pre>
<span class="docEmphStrong">equal(beg1, end1, beg2)</span>
<span class="docEmphStrong">equal(beg1, end1, beg2, binaryPred)</span>
</pre><br>
<p class="docText">Determines whether two sequences are equal. Returns <tt>true</tt> if each element in the input range equals the corresponding element in the sequence that begins at <tt>beg2</tt>.</p>
<p class="docText">For example, given the sequences <tt>meet</tt> and <tt>meat</tt>, a call to <tt>mismatch</tt> would return a <tt>pair</tt> containing iterators referring to the second <tt>e</tt> in the first sequence and to the element <tt>a</tt> in the second sequence. If, instead, the second sequence were <tt>meeting</tt>, and we called <tt>equal</tt>, then the <tt>pair</tt> returned would be <tt>end1</tt> and an iterator denoting the element <tt>i</tt> in the second range.</p>

<a name="app01lev2sec3"></a>
<h4 class="docSection2Title">A.2.3. Binary-Search Algorithms</H4>
<p class="docText">Although these algorithms may be used with forward iterators, they offer specialized versions that are much faster when used with random-access iterators.</P>
<p class="docText">These algorithms perform a binary search, which means that the input sequence must be sorted. These algorithms behave similarly to the associative container members of the same name (<a class="docLink" href="ch10lev1sec5.html#ch10lev2sec17">Section 10.5.2</a>, p. <a class="docLink" href="ch10lev1sec5.html#ch10lev2sec17">377</a>). The <tt>equal_range, lower_bound</tt>, and <tt>upper_bound</tt> algorithms return an iterator that refers to the positions in the container at which the given element could be inserted while still preserving the container's ordering. If the element is larger than any other in the container, then the iterator that is returned might be the off-the-end iterator.</p>
<p class="docText">Each algorithm provides two versions: The first uses the element type's less-than operator (<tt>&lt;</tt>) to test elements; the second uses the specified comparison.</P>
<pre>
<span class="docEmphStrong">lower_bound(beg, end, val)</span>
<span class="docEmphStrong">lower_bound(beg, end, val, comp)</span>
</pre><br>
<p class="docText">Returns an iterator to the first position in which val can be inserted while preserving the ordering.</p>
<pre>
<span class="docEmphStrong">upper_bound(beg, end, val)</span>
<span class="docEmphStrong">upper_bound(beg, end, val, comp)</span>
</pre><BR>
<p class="docText">Returns an iterator to the last position in which val can be inserted while preserving the ordering.</P>
<pre>
<span class="docEmphStrong">equal_range(beg, end, val)</span>
<span class="docEmphStrong">equal_range(beg, end, val, comp)</span>
</pre><br>
<p class="docText">Returns an iterator pair indicating the subrange in which val could be inserted while preserving the ordering.</p>
<pre>
<span class="docEmphStrong">binary_search(beg, end, val)</span>
<span class="docEmphStrong">binary_search(beg, end, val, comp)</span>
</pre><br>
<p class="docText">Returns a <tt>bool</tt> indicating whether the sequence contains an element that is equal to <tt>val</tt>. Two values <tt>x</tt> and <tt>y</tt> are considered equal if <tt>x &lt; y</tt> and <tt>y &lt;x</tt> both yield false.</p>

<a name="app01lev2sec4"></a>
<h4 class="docSection2Title">A.2.4. Algorithms that Write Container Elements</H4>
<p class="docText"><a name="idd1e156651"></a><a name="idd1e156655"></a><a name="idd1e156659"></a><a name="idd1e156663"></a><a name="idd1e156668"></a><a name="idd1e156673"></a>Many algorithms write container elements. These algorithms can be distinguished both by the kinds of iterators on which they operate and by whether they write elements in the input range or write to a specified destination.</p>
<p class="docText">The simplest algorithms read elements in sequence, requiring only input iterators. Those that write back to the input sequence require forward iterators. Some read the sequence backward, thus requiring bidirectional iterators. Algorithms that write to a separate destination, as usual, assume the destination is large enough to hold the output.</P>
<a name="app01lev3sec4"></a>
<H5 class="docSection3Title">Algorithms that Write but do Not Read Elements</h5>
<p class="docText">These algorithms require an output iterator that denotes a destination. They take a second argument that specifies a count and write that number of elements to the destination.</p>
<pre>
<span class="docEmphStrong">fill_n(dest, cnt, val)</span>
<span class="docEmphStrong">generate_n(dest, cnt, Gen)</span>
</pre><br>
<p class="docText">Write <tt>cnt</tt> values to <tt>dest</tt>. The <tt>fill_n</tt> function writes <tt>cnt</tt> copies of the value <tt>val</tt>; <tt>generate_n</tt> evaluates the generator <tt>Gen() cnt</tt> times. A generator is a function (or function object (<a class="docLink" href="ch14lev1sec8.html#ch14lev1sec8">Section 14.8</a>, p. <a class="docLink" href="ch14lev1sec8.html#ch14lev1sec8">530</a>)) that is expected to produce a different return value each time it is called.</P>

<a name="app01lev3sec5"></a>
<H5 class="docSection3Title">Algorithms that Write Elements Using Input Iterators</h5>
<p class="docText">Each of these operations reads an input sequence and writes to an output sequence denoted by <tt>dest</tt>. They require <tt>dest</tt> to be an output iterator, and the iterators denoting the input range must be input iterators. The caller is responsible for ensuring that <tt>dest</tt> can hold as many elements as necessary given the input sequence. These algorithms return <tt>dest</tt> incremented to denote one past the last element written.</p>
<pre>
<span class="docEmphStrong">copy(beg, end, dest)</span>
</pre><br>
<p class="docText">Copies the input range to the sequence beginning at iterator <tt>dest</tt>.</p>
<pre>
<span class="docEmphStrong">transform(beg, end, dest, unaryOp)</span>
<span class="docEmphStrong">transform(beg, end, beg2, dest, binaryOp)</span>
</pre><BR>
<p class="docText">Applies the specified operation to each element in the input range, writing the result to <tt>dest</tt>. The first version applies a unary operation to each element in the input range. The second applies a binary operation to pairs of elements. It takes the first argument to the binary operation from the sequence denoted by <tt>beg</tt> and <tt>end</tt> and takes the second argument from the sequence beginning at <tt>beg2</tt>. The programmer must ensure that the sequence beginning at <tt>beg2</tt> has at least as many elements as are in the first sequence.</p>
<pre>
<span class="docEmphStrong">replace_copy(beg, end, dest, old_val, new_val)</span>
<span class="docEmphStrong">replace_copy_if(beg, end, dest, unaryPred, new_val)</span>
</pre><br>
<p class="docText">Copies each element to <tt>dest</tt>, replacing specified elements by the <tt>new_val</tt>. The first version replaces those elements that are <tt>==</tt> to <tt>old_val</tt>. The second version replaces those elements for which <tt>unaryPred</tt> is true.</P>
<pre>
<span class="docEmphStrong">merge(beg1, end1, beg2, end2, dest)</span>
<span class="docEmphStrong">merge(beg1, end1, beg2, end2, dest, comp)</span>
</pre><br>
<p class="docText"><a name="idd1e156842"></a><a name="idd1e156846"></a><a name="idd1e156850"></a><a name="idd1e156854"></a><a name="idd1e156858"></a><a name="idd1e156862"></a><a name="idd1e156866"></a><a name="idd1e156870"></a><a name="idd1e156875"></a><a name="idd1e156879"></a>Both input sequences must be sorted. Writes a merged sequence to <tt>dest</tt>. The first version compares elements using the <tt>&lt;</tt> operator; the second version uses the given comparison.</p>

<a name="app01lev3sec6"></a>
<H5 class="docSection3Title">Algorithms that Write Elements Using Forward Iterators</h5>
<p class="docText">These algorithms require forward iterators because they write elements in their input sequence.</P>
<pre>
<span class="docEmphStrong">swap(elem1, elem2)</span>
<span class="docEmphStrong">iter_swap(iter1, iter2)</span>
</pre><br>
<p class="docText">Parameters to these functions are references, so the arguments must be writable. Swaps the specified element or elements denoted by the given iterators.</p>
<pre>
<span class="docEmphStrong">swap_ranges(beg1, end1, beg2)</span>
</pre><br>
<p class="docText">Swaps the elements in the input range with those in the second sequence beginning at <tt>beg2</tt>. The ranges must not overlap. The programmer must ensure that the sequence starting at <tt>beg2</tt> is at least as large as the input sequence. Returns <tt>beg2</tt> incremented to denote the element just after the last one swapped.</p>
<pre>
<span class="docEmphStrong">fill(beg, end, val)</span>
<span class="docEmphStrong">generate(beg, end, Gen)</span>
</pre><br>
<p class="docText">Assigns a new value to each element in the input sequence. <tt>fill</tt> assigns the value <tt>val</tt>; <tt>generate</tt> executes <tt>Gen()</tt> to create new values.</p>
<pre>
<span class="docEmphStrong">replace(beg, end, old_val, new_val)</span>
<span class="docEmphStrong">replace_if(beg, end, unaryPred, new_val)</span>
</pre><br>
<p class="docText">Replace each matching element by <tt>new_val</tt>. The first version uses <tt>==</tt> to compare elements with <tt>old_val;</tt> the second version executes <tt>unaryPred</tt> on each element, replacing those for which <tt>unaryPred</tt> is true.</p>

<a name="app01lev3sec7"></a>
<h5 class="docSection3Title">Algorithms that Write Elements Using Bidirectional Iterators</h5>
<p class="docText">These algorithms require the ability to go backward in the sequence, and so they require bidirectional iterators.</p>
<pre>
<span class="docEmphStrong">copy_backward(beg, end, dest)</span>
</pre><br>
<p class="docText">Copies elements in reverse order to the output iterator <tt>dest</tt>. Returns <tt>dest</tt> incremented to denote one past the last element copied.</p>
<pre>
<span class="docEmphStrong">inplace_merge(beg, mid, end)</span>
<span class="docEmphStrong">inplace_merge(beg, mid, end, comp)</span>
</pre><BR>
<p class="docText">Merges two adjacent subsequences from the same sequence into a single, ordered sequence: The subsequences from <tt>beg</tt> to <tt>mid</tt> and from <tt>mid</tt> to <tt>end</tt> are merged into <tt>beg</tt> to <tt>end</tt>. First version uses <tt>&lt;</tt> to compare elements; second version uses a specified comparison. Returns <tt>void</tt>.</P>


<a name="app01lev2sec5"></a>
<h4 class="docSection2Title">A.2.5. Partitioning and Sorting Algorithms</H4>
<p class="docText"><a name="idd1e157067"></a><a name="idd1e157071"></a><a name="idd1e157075"></a><a name="idd1e157079"></a>The sorting and partitioning algorithms provide various strategies for ordering the elements of a container.</p>
<p class="docText">A <tt>partition</tt> divides elements in the input range into two groups. The first group consists of those elements that satisfy the specified predicate; the second, those that do not. For example, we can partition elements in a container based on whether the elements are odd, or on whether a word begins with a capital letter, and so forth.</p>
<p class="docText">Each of the sorting and partitioning algorithms provides stable and unstable versions. A stable algorithm maintains the relative order of equal elements. For example, given the sequence</P>
<pre>
      { "pshew", "Honey", "tigger", "Pooh" }
</pre><BR>
<p class="docText">a stable partition based on whether a word begins with a capital letter generates the sequence in which the relative order of the two word categories is maintained:</p>
<pre>
     { "Honey", "Pooh", "pshew", "tigger" }
</pre><br>
<p class="docText">The stable algorithms do more work and so may run more slowly and use more memory than the unstable counterparts.</p>
<a name="app01lev3sec8"></a>
<h5 class="docSection3Title">Partitioning Algorithms</h5>
<p class="docText">These algorithms require bidirectional iterators.</P>
<pre>
<span class="docEmphStrong">stable_partition(beg, end, unaryPred)</span>
<span class="docEmphStrong">partition(beg, end, unaryPred)</span>
</pre><br>
<p class="docText">Uses <tt>unaryPred</tt> to partition the input sequence. Elements for which <tt>unaryPred</tt> is true are put at the beginning of the sequence; those for which the predicate is false are at the end. Returns an iterator just past the last element for which <tt>unaryPred</tt> is true.</P>

<a name="app01lev3sec9"></a>
<H5 class="docSection3Title">Sorting Algorithms</h5>
<p class="docText">These algorithms require random-access iterators. Each of the sorting algorithms provides two overloaded versions. One version uses element operator <tt>&lt;</tt> to compare elements; the other takes an extra parameter that specifies the comparison. These algorithms require random-access iterators. With one exception, these algorithms return <tt>void</tt>; <tt>partial_sort_copy</tt> returns an itertor into the destination.</p>
<p class="docText">The <tt>partial_sort</tt> and <tt>nth_element</tt> algorithms do only part of the job of sorting the sequence. They are often used to solve problems that might otherwise be handled by sorting the entire sequence. Because these operations do less work, they typically are faster than sorting the entire input range.</p>
<pre>
<span class="docEmphStrong">sort(beg, end)</span>
<span class="docEmphStrong">stable_sort(beg, end)</span>
<span class="docEmphStrong">sort(beg, end, comp)</span>
<span class="docEmphStrong">stable_sort(beg, end, comp)</span>
</pre><BR>
<p class="docText">Sorts the entire range.</P>
<pre>
<span class="docEmphStrong">partial_sort(beg, mid, end)</span>
<span class="docEmphStrong">partial_sort(beg, mid, end, comp)</span>
</pre><br>
<p class="docText"><a name="idd1e157205"></a><a name="idd1e157210"></a><a name="idd1e157215"></a>Sorts a number of elements equal to <tt>mid</tt>  <tt>beg</tt>. That is, if <tt>mid</tt>  <tt>beg</tt> is equal to 42, then this function puts the lowest-valued elements in sorted order in the first 42 positions in the sequence. After <tt>partial_sort</tt> completes, the elements in the range from <tt>beg</tt> up to but not including <tt>mid</tt> are sorted. No element in the sorted range is larger than any element in the range after <tt>mid</tt>. The order among the unsorted elements is unspecified.</p>
<p class="docText">As an example, we might have a collection of race scores and want to know what the first-, second- and third-place scores are but don't care about the order of the other times. We might sort such a sequence as follows:</p>
<pre>
     partial_sort(scores.begin(),
                 scores.begin() + 3, scores.end());
</pre><br>
<pre>
<span class="docEmphStrong">partial_sort_copy(beg, end, destBeg, destEnd)</span>
<span class="docEmphStrong">partial_sort_copy(beg, end, destBeg, destEnd, comp)</span>
</pre><BR>
<p class="docText">Sorts elements from the input range and puts as much of the sorted sequence as fits into the sequence denoted by the iterators <tt>destBeg</tt> and <tt>destEnd</tt>. If the destination range is the same size or has more elements than the input range, then the entire input range is sorted and stored starting at <tt>destBeg</tt>. If the destination size is smaller, then only as many sorted elements as will fit are copied.</p>
<p class="docText">Returns an iterator into the destination that refers just after the last element that was sorted. The returned iterator will be <tt>destEnd</tt> if that destination sequence is smaller or equal in size to the input range.</p>
<pre>
<span class="docEmphStrong">nth_element(beg, nth, end)</span>
<span class="docEmphStrong">nth_element(beg, nth, end, comp)</span>
</pre><BR>
<p class="docText">The argument <tt>nth</tt> must be an iterator positioned on an element in the input sequence. After <tt>nth_element</tt>, the element denoted by that iterator has the value that would be there if the entire sequence were sorted. The elements in the container are also partitioned around <tt>nth</tt>: Those before <tt>nth</tt> are all smaller than or equal to the value denoted by <tt>nth</tt>, and the ones after it are greater than or equal to it. We might use <tt>nth_element</tt> to find the value closest to the median:</p>
<pre>
     nth_element(scores.begin(), scores.begin() +
              scores.size()/2, scores.end());
</pre><br>


<a name="app01lev2sec6"></a>
<H4 class="docSection2Title">A.2.6. General Reordering Operations</h4>
<p class="docText">Several algorithms reorder the elements in a specified way. The first two, <tt>remove</tt> and <tt>unique</tt>, reorder the container so that the elements in the first part of the sequence meet some criteria. They return an iterator marking the end of this subsequence. Others, such as <tt>reverse, rotate</tt>, and <tt>random_shuffle</tt> rearrange the entire sequence.</P>
<p class="docText">These algorithms operate &quot;in place;&quot; they rearrange the elements in the input sequence itself. Three of the reordering algorithms offer &quot;copying&quot; versions. These algorithms, <tt>remove_copy, rotate_copy</tt>, and <tt>unique_copy</tt>, write the reordered sequence to a destination rather than rearranging elements directly.</p>
<a name="app01lev3sec10"></a>
<h5 class="docSection3Title">Reordering Algorithms Using Forward Iterators</h5>
<p class="docText"><a name="idd1e157361"></a><a name="idd1e157365"></a><a name="idd1e157370"></a><a name="idd1e157374"></a><a name="idd1e157379"></a><a name="idd1e157383"></a>These algorithms reorder the input sequence. They require that the iterators be at least forward iterators.</p>
<pre>
<span class="docEmphStrong">remove(beg, end, val)</span>
<span class="docEmphStrong">remove_if(beg, end, unaryPred)</span>
</pre><br>
<p class="docText">&quot;Removes&quot; elements from the sequence by overwriting them with elements that are to be kept. The removed elements are those that are <tt>==</tt> to <tt>val</tt> or for which <tt>unaryPred</tt> is true. Returns an iterator just past the last element that was not removed.</p>
<p class="docText">For example, if the input sequence is <tt>hello world</tt> and <tt>val</tt> is <tt>o</tt>, then a call to <tt>remove</tt> will overwrite the two elements that are the letter <tt>'o'</tt> by shifting the sequence to the left twice. The new sequence will be <tt>hell wrldld</tt>. The returned iterator will denote the element after the first <tt>d</tt>.</p>
<pre>
<span class="docEmphStrong">unique(beg, end)</span>
<span class="docEmphStrong">unique(beg, end, binaryPred)</span>
</pre><br>
<p class="docText">&quot;Removes&quot; all but the first of each consecutive group of matching elements. Returns an iterator just past the last unique element. First version uses <tt>==</tt> to determine whether two elements are the same; second version uses the predicate to test adjacent elements.</p>
<p class="docText">For example, if the input sequence is <tt>boohiss</tt>, then after the call to <tt>unique</tt>, the first sequence will contain <tt>bohisss</tt>. The iterator returned will point to the element after the first <tt>s</tt>. The value of the remaining two elements in the sequence is unspecified.</p>
<pre>
<span class="docEmphStrong">rotate(beg, mid, end)</span>
</pre><br>
<p class="docText">Rotates the elements around the element denoted by <tt>mid</tt>. The element at <tt>mid</tt> becomes the first element; those from <tt>mid + 1</tt> through <tt>end</tt> come next, followed by the range from <tt>beg</tt> to <tt>mid</tt>. Returns <tt>void</tt>.</p>
<p class="docText">For example, given the input sequence <tt>hissboo</tt>, if <tt>mid</tt> denotes the character <tt>b</tt>, then rotate would reorder the sequence as <tt>boohiss</tt>.</P>

<a name="app01lev3sec11"></a>
<H5 class="docSection3Title">Reordering Algorithms Using Bidirectional Iterators</h5>
<p class="docText">Because these algorithms process the input sequence backward, they requre bidirectional iterators.</P>
<pre>
<span class="docEmphStrong">reverse(beg, end)</span>
<span class="docEmphStrong">reverse_copy(beg, end, dest)</span>
</pre><br>
<p class="docText">Reverses the elements in the sequence. <tt>reverse</tt> operates in place; it writes the rearranged elements back into the input sequence. <tt>reverse_copy</tt> copies the elements in reverse order to the output iterator <tt>dest</tt>. As usual, the programmer must ensure that <tt>dest</tt> can be used safely. <tt>reverse</tt> returns <tt>void</tt>; <tt>reverse_copy</tt> returns an iterator just past the last element copied into the destination.</p>

<a name="app01lev3sec12"></a>
<H5 class="docSection3Title">Reordering Algorithms Writing to Output Iterators</H5>
<p class="docText">These algorithms require forward iterators for the input sequence and an output iterator for the destination.</p>
<p class="docText"><a name="idd1e157573"></a><a name="idd1e157578"></a><a name="idd1e157583"></a><a name="idd1e157588"></a><a name="idd1e157592"></a>Each of the preceding general reordering algorithms has an <tt>_copy</tt> version. These <tt>_copy</tt> versions perform the same reordering but write the reordered elements to a specified destination sequence rather than changing the input sequence. Except for <tt>rotate_copy</tt>, which requires forward iterators, the input range is specified by input iterators. The <tt>dest</tt> iterator must be an output iterator and, as usual, the programmer must guarantee that the destination can be written safely. The algorithms return the <tt>dest</tt> iterator incremented to denote one past the last element copied.</p>
<pre>
<span class="docEmphStrong">remove_copy(beg, end, dest, val)</span>
<span class="docEmphStrong">remove_copy_if(beg, end, dest, unaryPred)</span>
</pre><br>
<p class="docText">Copies elements except those matching <tt>val</tt> or for which <tt>unaryPred</tt> return true into <tt>dest</tt>.</p>
<pre>
<span class="docEmphStrong">unique_copy(beg, end, dest)</span>
<span class="docEmphStrong">unique_copy(beg, end, dest, binaryPred)</span>
</pre><br>
<p class="docText">Copies unique elements to <tt>dest</tt>.</P>
<pre>
<span class="docEmphStrong">rotate_copy(beg, mid, end, dest)</span>
</pre><br>
<p class="docText">Like rotate except that it leaves its input sequence unchanged and writes the rotated sequence to <tt>dest</tt>. Returns <tt>void</tt>.</P>

<a name="app01lev3sec13"></a>
<H5 class="docSection3Title">Reordering Algorithms Using Random-Access Iterators</h5>
<p class="docText">Because these algorithms rearrange the elements in a random order, they require random-access iterators.</p>
<pre>
<span class="docEmphStrong">random_shuffle(beg, end)</span>
<span class="docEmphStrong">random_shuffle(beg, end, rand)</span>
</pre><br>
<p class="docText">Shuffles the elements in the input sequence. The second version takes a random-number generator. That function must take and return a value of the iterator's <tt>difference_type</tt>. Both versions return <tt>void</tt>.</P>


<a name="app01lev2sec7"></a>
<H4 class="docSection2Title">A.2.7. Permutation Algorithms</h4>
<p class="docText">Consider the following sequence of three characters: <tt>abc</tt>. There are six possible permutations on this sequence: <tt>abc, acb, bac, bca, cab</tt>, and <tt>cba</tt>. These permutations are listed in lexicographical order based on the less-than operator. That is, <tt>abc</tt> is the first permutation because its first element is less than or equal to the first element in every other permutation, and its second element is smaller than any permutation sharing the same first element. Similarly, <tt>acb</tt> is the next permutation because it begins with <tt>a</tt>, which is smaller than the first element in any remaining permutation. Those permutations that begin with <tt>b</tt> come before those that begin with <tt>c</tt>.</p>
<p class="docText">For any given permutation, we can say which permutation comes before it and which after it. Given the permutation <tt>bca</tt>, we can say that its previous permutation is <tt>bac</tt> and that its next permutation is <tt>cab</tt>. There is no previous permutation of the sequence <tt>abc</tt>, nor is there a next permutation of <tt>cba</tt>.</p>
<p class="docText"><a name="idd1e157756"></a><a name="idd1e157761"></a>The library provides two permutation algorithms that generate the permutations of a sequence in lexicographical order. These algorithms reorder the sequence to hold the (lexicographically) next or previous permutation of the given sequence. They return a <tt>bool</tt> that indicates whether there was a next or previous permutation.</p>
<p class="docText">The algorithms each have two versions: One uses the element type <tt>&lt;</tt> operator, and the other takes an extra argument that specifies a comparison to use to compare the elements. These algorithms assume that the elements in the sequence are unique. That is, the algorithms assume that no two elements in the sequence have the same value.</P>
<a name="app01lev3sec14"></a>
<h5 class="docSection3Title">Permutation Algorithms Require Bidirectional Iterators</h5>
<p class="docText">To produce the permutation, the sequence must be processed both forward and backward, thus requiring bidirectional iterators.</P>
<pre>
<span class="docEmphStrong">next_permutation(beg, end)</span>
<span class="docEmphStrong">next_permutation(beg, end, comp)</span>
</pre><br>
<p class="docText">If the sequence is already in the last permutation, then <tt>next_permutation</tt> reorders the sequence to be the lowest permutation and returns <tt>false</tt>. Otherwise, it transforms the input sequence into the next permutation, which is the lexicographically next ordered sequence and returns <tt>true</tt>. The first version uses the element <tt>&lt;</tt> operator to compare elements; the second version uses specified comparison.</P>
<pre>
<span class="docEmphStrong">prev_permutation(beg, end)</span>
<span class="docEmphStrong">prev_permutation(beg, end, comp)</span>
</pre><br>
<p class="docText">Like <tt>next_permutation</tt>, but transforms the sequence to form the previous permutation. If this is the smallest permutation, then it reorders the sequence to be the largest permutation and returns <tt>false</tt>.</P>


<a name="app01lev2sec8"></a>
<h4 class="docSection2Title">A.2.8. Set Algorithms for Sorted Sequences</h4>
<p class="docText">The set algorithms implement general set operations on a sequence that is in sorted order.</p>
<a name="app01note01"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> These algorithms are distinct from the library <tt>set</tt> container and should not be confused with operations on <tt>set</tt>s. Instead, these algorithms provide setlike behavior on an ordinary sequential container (<tt>vector, list</tt>, etc.) or other sequence, such as an input stream.</p></td></tr></table><br>
</p></div><BR>
<p class="docText">With the exception of <tt>includes</tt>, they also take an output iterator. As usual, the programmer must ensure that the destination is large enough to hold the generated sequence. These algorithms return their <tt>dest</tt> iterator incremented to denote the element just after the last one that was written to <tt>dest</tt>.</P>
<p class="docText">Each algorithm provides two forms: The first uses the <tt>&lt;</tt> operator for the element type to compare elements in the two input sequences. The second takes a comparison, which is used to compare the elements.</p>
<a name="app01lev3sec15"></a>
<H5 class="docSection3Title">Set Algorithms Require Input Iterators</h5>
<p class="docText"><a name="idd1e157885"></a><a name="idd1e157889"></a><a name="idd1e157893"></a><a name="idd1e157897"></a><a name="idd1e157901"></a><a name="idd1e157905"></a><a name="idd1e157909"></a><a name="idd1e157913"></a>These algorithms process elements sequentially, requiring input iterators.</p>
<pre>
<span class="docEmphStrong">includes(beg, end, beg2, end2)</span>
<span class="docEmphStrong">includes(beg, end, beg2, end2, comp)</span>
</pre><BR>
<p class="docText">Returns <tt>TRue</tt> if every element in the second sequence is contained in the input sequence. Returns <tt>false</tt> otherwise.</p>
<pre>
<span class="docEmphStrong">set_union(beg, end, beg2, end2, dest)</span>
<span class="docEmphStrong">set_union(beg, end, beg2, end2, dest, comp)</span>
</pre><br>
<p class="docText">Creates a sorted sequence of the elements that are in either sequence. Elements that are in both sequences occur in the output sequence only once. Stores the sequence in <tt>dest</tt>.</p>
<pre>
<span class="docEmphStrong">set_intersection(beg, end, beg2, end2, dest)</span>
<span class="docEmphStrong">set_intersection(beg, end, beg2, end2, dest, comp)</span>
</pre><br>
<p class="docText">Creates a sorted sequence of elements present in both sequences. Stores the sequence in <tt>dest</tt>.</p>
<pre>
<span class="docEmphStrong">set_difference(beg, end, beg2, end2, dest)</span>
<span class="docEmphStrong">set_difference(beg, end, beg2, end2, dest, comp)</span>
</pre><BR>
<p class="docText">Creates a sorted sequence of elements present in the first container but not in the second.</p>
<pre>
<span class="docEmphStrong">set_symmetric_difference(beg, end, beg2, end2, dest)</span>
<span class="docEmphStrong">set_symmetric_difference(beg, end, beg2, end2, dest, comp)</span>
</pre><BR>
<p class="docText">Creates a sorted sequence of elements present in either container but not in both.</P>


<a name="app01lev2sec9"></a>
<h4 class="docSection2Title">A.2.9. Minimum and Maximum Values</h4>
<p class="docText">The first group of these algorithms are unique in the library in that they operate on values rather than sequences. The second set takes a sequence that is denoted by input iterators.</p>
<pre>
<span class="docEmphStrong">min(val1, val2)</span>
<span class="docEmphStrong">min(val1, val2, comp)</span>
<span class="docEmphStrong">max(val1, val2)</span>
<span class="docEmphStrong">max(val1, val2, comp)</span>
</pre><BR>
<p class="docText">Returns the minimum/maximum of <tt>val1</tt> and <tt>val2</tt>. The arguments must have exactly the same type as each other. Uses either <tt>&lt;</tt> operator for the element type or the specified comparison. Arguments and the return type are both <tt>const</tt> references, meaning that objects are not copied.</P>
<pre>
<span class="docEmphStrong">min_element(beg, end)</span>
<span class="docEmphStrong">min_element(beg, end, comp)</span>
<span class="docEmphStrong">max_element(beg, end)</span>
<span class="docEmphStrong">max_element(beg, end, comp)</span>
</pre><br>
<p class="docText">Returns an iterator referring to the smallest/largest element in the input sequence. Uses either <tt>&lt;</tt> operator for the element type or the specified comparison.</p>
<a name="app01lev3sec16"></a>
<h5 class="docSection3Title">Lexicographical Comparison</h5>
<p class="docText"><a name="idd1e158079"></a><a name="idd1e158083"></a><a name="idd1e158087"></a>Lexicographical comparison examines corresponding elements in two sequences and determines the comparison based on the first unequal pair of elements. Because the algorithms process elements sequentially, they require input iterators. If one sequence is shorter than the other and all its elements match the corresponding elements in the longer sequence, then the shorter sequence is lexicographically smaller. If the sequences are the same size and the corresponding elements match, then neither is lexicographically less than the other.</P>
<pre>
<span class="docEmphStrong">lexicographical_compare(beg1, end1, beg2, end2)</span>
<span class="docEmphStrong">lexicographical_compare(beg1, end1, beg2, end2, comp)</span>
</pre><br>
<p class="docText">Does an element by element comparison of the elements in the two sequences. Returns <tt>true</tt> if the first sequence is lexicographically less than the second sequence. Otherwise, returns <tt>false</tt>. Uses either <tt>&lt;</tt> operator for the element type or the specified comparison.</P>


<a name="app01lev2sec10"></a>
<h4 class="docSection2Title">A.2.10. Numeric Algorithms</h4>
<p class="docText">Numeric algorithms require input iterators; if the algorithm writes output, it uses an output iterator for the destination</P>
<p class="docText">These functions perform simple arithmetic manipulations of their input sequence. To use the numeric algorithms, the <tt>numeric</tt> header must be included.</p>
<pre>
<span class="docEmphStrong">accumulate(beg, end, init)</span>
<span class="docEmphStrong">accumulate(beg, end, init, BinaryOp)</span>
</pre><BR>
<p class="docText">Returns the sum of all the values in the input range. The summation starts with the initial value specified by <tt>init</tt>. The return type is the same type as the type of <tt>init</tt>.</p>
<p class="docText">Given the sequence <tt>1,1,2,3,5,8</tt> and an initial value of 0, the result is 20. The first version applies the <tt>+</tt> operator for the element type; second version applies the specified binary operation.</p>
<pre>
<span class="docEmphStrong">inner_product(beg1, end1, beg2, init)</span>
<span class="docEmphStrong">inner_product(beg1, end1, beg2, init, BinOp1, BinOp2)</span>
</pre><br>
<p class="docText">Returns the sum of the elements generated as the product of two sequences. The two sequences are examined in step, and the elements from each sequence are multiplied. The product of that multiplication is summed. The initial value of the sum is specified by <tt>init</tt>. The second sequence beginning at <tt>beg2</tt> is assumed to have at least as many elements as are in the first sequence; any elements in the second sequence beyond the size of the first sequence are ignored. The type of <tt>init</tt> determines the return type.</p>
<p class="docText">The first version uses the element's multiplication (<tt>*</tt>) and addition (<tt>+</tt>) operators: Given the two sequences <tt>2,3,5,8</tt> and <tt>1,2,3,4,5,6,7</tt>, the result is the sum of the initial value plus the following product pairs:</p>
<pre>
     initial_value + (2 * 1) + (3 * 2) + (5 * 3) + (8 * 4)
</pre><br>
<p class="docText">If we provide an initial value of 0, then the result is 55.</p>
<p class="docText"><a name="idd1e158212"></a><a name="idd1e158216"></a>The second version applies the specified binary operations, using the first operation in place of addition and the second in place of multiplication. As an example, we might use <tt>inner_product</tt> to produce a list of parenthesized namevalue pairs of elements, where the name is taken from the first input sequence and the corresponding value is in the second:</p>
<pre>
     // <span class="docEmphItalicAlt">combine elements into a parenthesized, comma-separated pair</span>
     string combine(string x, string y)
     {
         return "(" + x + ", " + y + ")";
     }
     // <span class="docEmphItalicAlt">add two strings, each separated by a comma</span>
     string concatenate(string x, string y)
     {
         if (x.empty())
             return y;
         return x + ", " + y;
     }
         cout &lt;&lt; inner_product(names.begin(), names.end(),
                                     values.begin(), string(),
                                     concatenate, combine);
</pre><br>
<p class="docText">If the first sequence contains <tt>if, string</tt>, and <tt>sort</tt>, and the second contains <tt>keyword, library type</tt>, and <tt>algorithm</tt>, then the output would be</p>
<pre>
   <span class="docEmphStrong">(if, keyword), (string, library type), (sort, algorithm)</span>

   <span class="docEmphStrong">partial_sum(beg, end, dest)</span>
   <span class="docEmphStrong">partial_sum(beg, end, dest, BinaryOp)</span>
</pre><br>
<p class="docText">Writes a new sequence to <tt>dest</tt> in which the value of each new element represents the sum of all the previous elements up to and including its position within the input range. The first version uses the <tt>+</tt> operator for the element type; the second version applies the specified binary operation. The programmer must ensure that <tt>dest</tt> is at least as large as the input sequence. Returns the <tt>dest</tt> iterator incremented to refer just after the last element written.</p>
<p class="docText">Given the input sequence <tt>0,1,1,2,3,5,8</tt>, the destination sequence will be <tt>0,1,2,4,7,12,20</tt>. The fourth element, for example, is the partial sum of the three previous values (<tt>0,1,1</tt>) plus its own( <tt>2</tt>), yielding a value of 4.</p>
<pre>
<span class="docEmphStrong">adjacent_difference(beg, end, dest)</span>
<span class="docEmphStrong">adjacent_difference(beg, end, dest, BinaryOp)</span>
</pre><BR>
<p class="docText">Writes a new sequence to <tt>dest</tt> in which the value of each new element other than the first represents the difference of the current and previous element. The first version uses the element type's <tt>-</tt> operation; the second version applies the specified binary operation. The programmer must ensure that <tt>dest</tt> is at least as large as the input sequence.</P>
<p class="docText">Given the sequence <tt>0,1,1,2,3,5,8</tt>, the first element of the new sequence is a copy of the first element of the original sequence: 0. The second element is the difference between the first two elements: 1. The third element is the difference between the second and third element, which is 0, and so on. The new sequence is <tt>0,1,0,1,1,2,3</tt>.</p>


<a href="21001535.html"><img src="images/pixel.gif" alt="" width="1" height="1" border="0"></a><UL></ul></td></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app01lev1sec1.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=app01lev1sec3.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>