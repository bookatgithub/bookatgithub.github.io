<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section A.3.&nbsp; The IO Library Revisited</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app01lev1sec2.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=index.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="app01lev1sec3"></a>
<h3 class="docSection1Title" id="432172-859">A.3. The IO Library Revisited</h3>
<p class="docText"><a name="idd1e158339"></a><a name="idd1e158342"></a><a name="idd1e158348"></a><a name="idd1e158351"></a><a name="idd1e158356"></a>In <a class="docLink" href="ch08.html#ch08">Chapter 8</a> we introduced the basic architecture and most commonly used parts of the IO library. This Appendix completes our coverage of the IO library.</P>
<a name="app01lev2sec11"></a>
<H4 class="docSection2Title">A.3.1. Format State</h4>
<p class="docText">In addition to a condition state (<a class="docLink" href="ch08lev1sec2.html#ch08lev1sec2">Section 8.2</a>, p. <a class="docLink" href="ch08lev1sec2.html#ch08lev1sec2">287</a>), each <tt>iostream</tt> object also maintains a format state that controls the details of how IO is formatted. The format state controls aspects of formatting such as the notational base for an integral value, the precision of a floating-point value, the width of an output element, and so on. The library also defines a set of manipulators (listed in Tables A.2 (p. 829) and A.3 (p. 833) for modifying the format state of an object. Simply speaking, a manipulator is a function or object that can be used as an operand to an input or output operator. A manipulator returns the stream object to which it is applied, so we can output multiple manipulators and data in a single statement.</P>
<p class="docText">When we read or write a manipulator, no data are read or written. Instead, an action is taken. Our programs have already used one manipulator, <tt>endl</tt>, which we &quot;write&quot; to an output stream as if it were a value. But <tt>endl</tt> isn't a value; instead, it performs an operation: It writes a newline and flushes the buffer.</p>

<a name="app01lev2sec12"></a>
<h4 class="docSection2Title">A.3.2. Many Manipulators Change the Format State</H4>
<p class="docText">Many manipulators change the format state of the stream. They change the format of how floating-pointer numbers are printed or whether a <tt>bool</tt> is displayed as a numeric value or using the <tt>bool</tt> literals, <tt>TRue</tt> or <tt>false</tt>, and so forth.</p>
<a name="app01note02"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><TD valign="top"><p class="docText"> Manipulators that change the format state of the stream usually leave the format state changed for all subsequent IO.</p></TD></TR></table><br>
</p></div><br>
<p class="docText">Most of the manipulators that change the format state provide set/unset pairs; one manipulator sets the format state to a new value and the other unsets it, restoring the normal default formatting.</P>
<p class="docText">The fact that a manipulator makes a persistent change to the format state can be useful when we have a set of IO operations that want to use the same formatting. Indeed, some programs take advantage of this aspect of manipulators to reset the behavior of one or more formatting rules for all its input or output. In such cases, the fact that a manipulator changes the stream is a desirable property.</P>
<p class="docText">However, many programs (and, more importantly, programmers) expect the state of the stream to match the normal library defaults. In these cases, leaving the state of the stream in a nonstandard state can lead to errors.</p>
<a name="app01note03"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></TD><td valign="top"><p class="docText"> It is usually best to undo any state change made by a manipulator. Ordinarily, a stream should be in its ordinary, default state after every IO operation.</p></TD></tr></table><br>
</P></div><br>
<a name="app01lev3sec17"></a>
<H5 class="docSection3Title">Using <tt>flags</tt> Operation to Restore the Format State</h5>
<p class="docText"><a name="idd1e158452"></a><a name="idd1e158457"></a><a name="idd1e158463"></a>An even better approach to managing changes to format state uses the <tt>flags</tt> operations. The <tt>flags</tt> operations are similar to the <tt>rdstate</tt> and <tt>setstate</tt> operations that manage the condition state of the stream. In this case, the library defines a pair of <tt>flags</tt> functions:</p>
<ul><li><p class="docList"><tt>flags()</tt> with no arguments returns the stream's current format state. The value returned is a library defined type named <tt>fmtflags</tt>.</p></li><li><p class="docList"><tt>flags(arg)</tt> takes a <tt>fmtflags</tt> argument and sets the stream's format as indicated by the argument.</p></li></ul>
<p class="docText">We can use these functions to remember and restore the format state of either an input or output stream:</p>
<pre>
     void display(ostream&amp; os)
     {
          // <span class="docEmphItalicAlt">remember the current format state</span>
          ostream::fmtflags curr_fmt = os.flags();
          // <span class="docEmphItalicAlt">do output that uses manipulators that change the format state of</span> <span class="docEmphasis">os</span>
          os.flags(curr_fmt);              // <span class="docEmphItalicAlt">restore the original format state of</span> <span class="docEmphasis">os</span>
     }
</pre><br>


<a name="app01lev2sec13"></a>
<h4 class="docSection2Title">A.3.3. Controlling Output Formats</H4>
<p class="docText">Many of the manipulators allow us to change the appearance of our output. There are two broad categories of output control: controlling the presentation of numeric values and controlling the amount and placment of padding.</P>
<a name="app01lev3sec18"></a>
<h5 class="docSection3Title">Controlling the Format of Boolean Values</H5>
<p class="docText">One example of a manipulator that changes the formatting state of its object is the <tt>boolalpha</tt> manipulator. By default, <tt>bool</tt> values print as 1 or 0. A <tt>true</tt> value is written as the integer 1 and a <tt>false</tt> value as 0. We can override this formatting by applying the <tt>boolalpha</tt> manipulator to the stream:</p>
<pre>
     cout &lt;&lt; "default bool values: "
          &lt;&lt; true &lt;&lt; " " &lt;&lt; false
          &lt;&lt; "\nalpha bool values: "
          &lt;&lt; boolalpha
          &lt;&lt; true &lt;&lt; " " &lt;&lt; false
          &lt;&lt; endl;
</pre><BR>
<p class="docText">When executed, the program generates the following:</P>
<pre>
     <span class="docEmphStrong">default bool values: 1 0</span>
     <span class="docEmphStrong">alpha bool values: true false</span>
</pre><br>
<p class="docText">Once we &quot;write&quot; <tt>boolalpha</tt> on <tt>cout</tt>, we've changed how <tt>cout</tt> will print <tt>bool</tt> values from this point on. Subsequent operations that print <tt>bool</tt>s will print them as either <tt>true</tt> or <tt>false</tt>.</p>
<p class="docText"><a name="idd1e158612"></a><a name="idd1e158617"></a><a name="idd1e158622"></a><a name="idd1e158628"></a><a name="idd1e158634"></a><a name="idd1e158640"></a><a name="idd1e158646"></a><a name="idd1e158652"></a><a name="idd1e158658"></a><a name="idd1e158664"></a><a name="idd1e158670"></a><a name="idd1e158676"></a><a name="idd1e158682"></a><a name="idd1e158687"></a><a name="idd1e158692"></a>To undo the format state change to <tt>cout</tt>, we must apply <tt>noboolalpha</tt>:</p>
<pre>
bool bool_val;
cout &lt;&lt; boolalpha    // <span class="docEmphItalicAlt">sets internal state of</span> <span class="docEmphasis">cout</span>
     &lt;&lt; bool_val
     &lt;&lt; noboolalpha; // <span class="docEmphItalicAlt">resets internal state to default formatting</span>
</pre><br>
<p class="docText">Now we change the formatting of <tt>bool</tt> values only to print of <tt>bool_val</tt> and immediately reset the stream back to its initial state.</P>

<a name="app01lev3sec19"></a>
<h5 class="docSection3Title">Specifying the Base for Integral Values</H5>
<p class="docText">By default, integral values are written and read in decimal notation. The programmer can change the notational base to octal or hexadecimal or back to decimal (the representation of floating-point values is unaffected) by using the manipulators <tt>hex, oct</tt>, and <tt>dec:</tt></P>
<pre>
     const int ival = 15, jval = 1024; // <span class="docEmphasis">const,</span> <span class="docEmphItalicAlt">so values never change</span>
     cout &lt;&lt; "default: ival = " &lt;&lt; ival
          &lt;&lt; " jval = " &lt;&lt; jval &lt;&lt; endl;
     cout &lt;&lt; "printed in octal: ival = " &lt;&lt; oct &lt;&lt; ival
          &lt;&lt; " jval = " &lt;&lt; jval &lt;&lt; endl;
     cout &lt;&lt; "printed in hexadecimal: ival = " &lt;&lt; hex &lt;&lt; ival
          &lt;&lt; " jval = " &lt;&lt; jval &lt;&lt; endl;
     cout &lt;&lt; "printed in decimal: ival = " &lt;&lt; dec &lt;&lt; ival
          &lt;&lt; " jval = " &lt;&lt; jval &lt;&lt; endl;
</pre><br>
<p class="docText">When compiled and executed, the program generates the following output:</p>
<pre>
     <span class="docEmphStrong">default: ival = 15 jval = 1024</span>
     <span class="docEmphStrong">printed in octal: ival = 17 jval = 2000</span>
     <span class="docEmphStrong">printed in hexadecimal: ival = f jval = 400</span>
     <span class="docEmphStrong">printed in decimal: ival = 15 jval = 1024</span>
</pre><br>
<p class="docText">Notice that like <tt>boolalpha</tt>, these manipulators change the format state. They affect the immediately following output, and all subsequent integral output, until the format is reset by invoking another manipulator.</P>

<a name="app01lev3sec20"></a>
<H5 class="docSection3Title">Indicating Base on the Output</h5>
<p class="docText">By default, when we print numbers, there is no visual cue as to what notational base was used. Is 20, for example, really 20, or an octal representation of 16? When printing numbers in decimal mode, the number is printed as we expect. If we need to print octal or hexadecimal values, it is likely that we should also use the <tt>showbase</tt> manipulator. The <tt>showbase</tt> manipulator causes the output stream to use the same conventions as used for specifying the base of an integral constant:</p>
<ul><li><p class="docList">A leading 0x indicates hexadecimal</P></li><li><p class="docList">A leading 0 indicates octal</P></li><li><p class="docList">The absence of either indicates decimal</P></li></UL>
<p class="docText"><a name="idd1e158816"></a><a name="idd1e158822"></a><a name="idd1e158827"></a><a name="idd1e158833"></a><a name="idd1e158839"></a><a name="idd1e158845"></a><a name="idd1e158851"></a><a name="idd1e158857"></a><a name="idd1e158863"></a><a name="idd1e158868"></a><a name="idd1e158873"></a>Here is the program revised to use <tt>showbase</tt>:</p>
<pre>
     const int ival = 15, jval = 1024; // <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">so values never change</span>
     cout &lt;&lt; showbase; // <span class="docEmphItalicAlt">show base when printing integral values</span>
     cout &lt;&lt; "default: ival = " &lt;&lt; ival
          &lt;&lt; " jval = " &lt;&lt; jval &lt;&lt; endl;
     cout &lt;&lt; "printed in octal: ival = " &lt;&lt; oct &lt;&lt; ival
          &lt;&lt; " jval = " &lt;&lt; jval &lt;&lt; endl;
     cout &lt;&lt; "printed in hexadecimal: ival = " &lt;&lt; hex &lt;&lt; ival
          &lt;&lt; " jval = " &lt;&lt; jval &lt;&lt; endl;
     cout &lt;&lt; "printed in decimal: ival = " &lt;&lt; dec &lt;&lt; ival
          &lt;&lt; " jval = " &lt;&lt; jval &lt;&lt; endl;
     cout &lt;&lt; noshowbase; // <span class="docEmphItalicAlt">reset state of the stream</span>
</pre><br>
<p class="docText">The revised output makes it clear what the underlying value really is:</p>
<pre>
     <span class="docEmphStrong">default: ival = 15 jval = 1024</span>
     <span class="docEmphStrong">printed in octal: ival = 017 jval = 02000</span>
     <span class="docEmphStrong">printed in hexadecimal: ival = 0xf jval = 0x400</span>
     <span class="docEmphStrong">printed in decimal: ival = 15 jval = 1024</span>
</pre><br>
<p class="docText">The <tt>noshowbase</tt> manipulator resets <tt>cout</tt> so that it no longer displays the notational base of integral values.</p>
<p class="docText">By default, hexadecimal values are printed in lowercase with a lowercase x. We could display the <tt>X</tt> and the hex digits <tt>a</tt><tt>f</tt> as uppercase by applying the <tt>uppercase</tt> manipulator.</p>
<pre>
     cout &lt;&lt; uppercase &lt;&lt; showbase &lt;&lt; hex
          &lt;&lt; "printed in hexadecimal: ival = " &lt;&lt; ival
          &lt;&lt; " jval = " &lt;&lt; jval &lt;&lt; endl
          &lt;&lt; nouppercase &lt;&lt; endl;
</pre><br>
<p class="docText">The preceding program generates the following output:</p>
<pre>
     <span class="docEmphStrong">printed in hexadecimal: ival = 0XF jval = 0X400</span>
</pre><br>
<p class="docText">To revert back to the lowercase x, we apply the nouppercase manipulator.</p>

<a name="app01lev3sec21"></a>
<h5 class="docSection3Title">Controlling the Format of Floating-Point Values</h5>
<p class="docText">There are three aspects of formatting floating-point values that we can control:</p>
<UL><LI><p class="docList">Precision: how many digits are printed</p></LI><li><p class="docList">Notation: whether to print in decimal or scientific notation</p></LI><LI><p class="docList">Handling of the decimal point for floating-point values that are whole numbers</p></li></ul>
<p class="docText">By default, floating-point values are printed using six digits of precision. If the value has no fractional part, then the decimal point is omitted. Whether the number is printed using decimal or scientific notation depends on the value of the floating-point number being printed. The library chooses a format that enhances readability of the number. Very large and very small values are printed using scientific notation. Other values use fixed decimal.</p>

<a name="app01lev3sec22"></a>
<h5 class="docSection3Title">Specifying How Much Precision to Print</H5>
<p class="docText"><a name="idd1e159004"></a><a name="idd1e159010"></a><a name="idd1e159015"></a><a name="idd1e159021"></a><a name="idd1e159027"></a><a name="idd1e159035"></a>By default, precision controls the total number of digits that are printed. When printed, floating-point values are rounded, not truncated, to the current precision. Thus, if the current precision is four, then <tt>3.14159</tt> becomes <tt>3.142</tt>; if the precision is three, then it is printed as <tt>3.14</tt>.</p>
<p class="docText">We can change the precision through a member function named <tt>precision</tt> or by using the <tt>setprecision</tt> manipulator. The <tt>precision</tt> member is overloaded (<a class="docLink" href="ch07lev1sec8.html#ch07lev1sec8">Section 7.8</a>, p. <a class="docLink" href="ch07lev1sec8.html#ch07lev1sec8">265</a>): One version takes an <tt>int</tt> value and sets the precision to that new value. It returns the <span class="docEmphasis">previous</span> precision value. The other version takes no arguments and returns the current precision value. The <tt>setprecision</tt> manipulator takes an argument, which it uses to set the precision.</P>
<a name="app01table02"></a><P><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table A.2. Manipulators Defined in <tt>iostream</tt></h5></caption><colgroup><col width="20"><col width="150"><col width="300"></colgroup><thead></thead><tr><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>boolalpha</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Display true and false as strings</P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>x</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>noboolalpha</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Display true and false as 0, 1</p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>showbase</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Generate prefix indicating numeric base</p></TD></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>x</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>noshowbase</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Do not generate notational base prefix</p></td></tr><TR><td class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>showpoint</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Always display decimal point</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>x</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>noshowpoint</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Only display decimal point if fraction</p></TD></tr><TR><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>showpos</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Display + in nonnegative numbers</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>x</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>noshowpos</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Do not display + in nonnegative numbers</p></td></TR><TR><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>uppercase</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Print 0X in hexadecimal, E in scientific</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>x</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>nouppercase</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Print 0x in hexadecimal, e in scientific</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>x</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>dec</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Display in decimal numeric base</p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>hex</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Display in hexadecimal numeric base</p></td></TR><TR><td class="docTableCell" align="left" valign="top">&nbsp;</TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>oct</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Display in octal numeric base</p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>left</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Add fill characters to right of value</p></td></TR><TR><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>right</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Add fill characters to left of value</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top">&nbsp;</td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>internal</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Add fill characters between sign and value</p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>fixed</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Display floating-point in decimal notation</P></TD></tr><TR><td class="docTableCell" align="left" valign="top">&nbsp;</td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>scientific</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Display floating-point in scientific notation</p></td></tr><TR><td class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>flush</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Flush ostream buffer</P></TD></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>ends</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Insert null, then flush ostream buffer</p></td></TR><tr><TD class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>endl</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Insert newline, then flush ostream buffer</p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>unitbuf</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Flush buffers after every output operation</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>x</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>nounitbuf</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Restore normal buffer flushing</P></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>x</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>skipws</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Skip whitespace with input operators</p></td></TR><tr><td class="docTableCell" align="left" valign="top">&nbsp;</TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>noskipws</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Do not skip whitespace with input operators</P></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>ws</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">&quot;Eat&quot; whitespace</p></td></tr><tr><TD class="docTableFooter" align="left" valign="top" colspan="2"><p class="docText">x <span class="docEmphasis">indicates default stream state</span></P></td></TR></table></p><br>
<p class="docText"><a name="idd1e159502"></a><a name="idd1e159508"></a><a name="idd1e159513"></a><a name="idd1e159518"></a><a name="idd1e159524"></a><a name="idd1e159530"></a><a name="idd1e159536"></a><a name="idd1e159542"></a>The following program illustrates the different ways we can control the precision use when printing floating point values:</P>
<pre>
     // <span class="docEmphasis">cout.precision</span> <span class="docEmphItalicAlt">reports current precision value</span>
     cout &lt;&lt; "Precision: " &lt;&lt; cout.precision()
          &lt;&lt; ", Value: "   &lt;&lt; sqrt(2.0) &lt;&lt; endl;
     // <span class="docEmphasis">cout.precision(12)</span> <span class="docEmphItalicAlt">asks that 12 digits of precision to be printed</span>
     cout.precision(12);
     cout &lt;&lt; "Precision: " &lt;&lt; cout.precision()
          &lt;&lt; ", Value: "   &lt;&lt; sqrt(2.0) &lt;&lt; endl;
     // <span class="docEmphItalicAlt">alternative way to set precision using</span> <span class="docEmphasis">setprecision</span> <span class="docEmphItalicAlt">manipulator</span>
     cout &lt;&lt; setprecision(3);
     cout &lt;&lt; "Precision: " &lt;&lt; cout.precision()
          &lt;&lt; ", Value: "   &lt;&lt; sqrt(2.0) &lt;&lt; endl;
</pre><BR>
<p class="docText">When compiled and executed, the program generates the following output:</p>
<pre>
     <span class="docEmphStrong">Precision: 6, Value: 1.41421</span>
     <span class="docEmphStrong">Precision: 12, Value: 1.41421356237</span>
     <span class="docEmphStrong">Precision: 3, Value: 1.41</span>
</pre><br>
<p class="docText">This program calls the library <tt>sqrt</tt> function, which is found in the <tt>cmath</tt> header. The <tt>sqrt</tt> function is overloaded and can be called on either a <tt>float, double</tt>, or <tt>long double</tt> argument. It returns the square root of its argument.</p>
<a name="app01note04"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> The <tt>setprecision</tt> manipulators and other manipulators that take arguments are defined in the <tt>iomanip</tt> header.</P></td></tr></table><br>
</P></div><BR>

<a name="app01lev3sec23"></a>
<h5 class="docSection3Title">Controlling the Notation</h5>
<p class="docText">By default, the notation used to print floating-point values depends on the size of the number: If the number is either very large or very small, it will be printed in scientific notation; otherwise, fixed decimal is used. The library chooses the notation that makes the number easiest to read.</p>
<a name="app01note05"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><TD valign="top"><p class="docText"> When printing a floating-point number as a plain number (as opposed to printing money, or a percentage, where we want to control the appearance of the value), it is usually best to let the library choose the notation to use. The one time to force either scientific or fixed decimal is when printing a table in which the decimal points should line up.</p></td></TR></table><br>
</P></div><br>
<p class="docText">If we want to force either scientific or fixed notation, we can do so by using the appropriate manipulator: The <tt>scientific</tt> manipulator changes the stream to use scientific notation. As with printing the <tt>x</tt> on hexadecimal integral values, we can also control the case of the <tt>e</tt> in scientific mode through the <tt>uppercase</tt> manipulator. The <tt>fixed</tt> manipulator changes the stream to use fixed decimal.</p>
<p class="docText">These manipulators change the default meaning of the precision for the stream. After executing either <tt>scientific</tt> or <tt>fixed</tt>, the precision value controls the <a name="idd1e159671"></a><a name="idd1e159677"></a><a name="idd1e159683"></a><a name="idd1e159691"></a><a name="idd1e159699"></a>number of digits after the decimal point. By default, precision specifies the total number of digitsboth before and after the decimal point. Using <tt>fixed</tt> or <tt>scientific</tt> lets us print numbers lined up in columns. This strategy ensures that the decimal point is always in a fixed position relative to the fractional part being printed.</p>

<a name="app01lev3sec24"></a>
<h5 class="docSection3Title">Reverting to Default Notation for Floating-Point Values</h5>
<p class="docText">Unlike the other manipulators, there is no manipulator to return the stream to its default state in which it chooses a notation based on the value being printed. Instead, we must call the <tt>unsetf</tt> member to undo the change made by either <tt>scientific</tt> or <tt>fixed</tt>. To return the stream to default handling of float values we pass <tt>unsetf</tt> function a library-defined value named <tt>floatfield</tt>:</p>
<pre>
     // <span class="docEmphItalicAlt">reset to default handling for notation</span>
     cout.unsetf(ostream::floatfield);
</pre><br>
<p class="docText">Except for undoing their effect, using these manipulators is like using any other manipulator:</p>
<pre>
     cout &lt;&lt; sqrt(2.0) &lt;&lt; '\n' &lt;&lt; endl;
     cout &lt;&lt; "scientific: " &lt;&lt; scientific &lt;&lt; sqrt(2.0) &lt;&lt; '\n'
          &lt;&lt; "fixed decimal: " &lt;&lt; fixed &lt;&lt; sqrt(2.0) &lt;&lt; "\n\n";
     cout &lt;&lt; uppercase
          &lt;&lt; "scientific: " &lt;&lt; scientific &lt;&lt; sqrt(2.0) &lt;&lt; '\n'
          &lt;&lt; "fixed decimal: " &lt;&lt; fixed &lt;&lt; sqrt(2.0) &lt;&lt; endl
          &lt;&lt; nouppercase;
     // <span class="docEmphItalicAlt">reset to default handling for notation</span>
     cout.unsetf(ostream::floatfield);
     cout &lt;&lt; '\n' &lt;&lt; sqrt(2.0) &lt;&lt; endl;
</pre><br>
<p class="docText">produces the following output:</p>
<pre>
     <span class="docEmphStrong">1.41421</span>

     <span class="docEmphStrong">scientific: 1.414214e+00</span>
     <span class="docEmphStrong">fixed decimal: 1.414214</span>

     <span class="docEmphStrong">scientific: 1.414214E+00</span>
     <span class="docEmphStrong">fixed decimal: 1.414214</span>

     <span class="docEmphStrong">1.41421</span>
</pre><br>

<a name="app01lev3sec25"></a>
<h5 class="docSection3Title">Printing the Decimal Point</h5>
<p class="docText">By default, when the fractional part of a floating-point value is 0, the decimal point is not displayed. The <tt>showpoint</tt> manipulator forces the decimal point to be printed:</P>
<pre>
     cout &lt;&lt; 10.0 &lt;&lt; endl;        // <span class="docEmphItalicAlt">prints</span> <span class="docEmphasis">10</span>
     cout &lt;&lt; showpoint &lt;&lt; 10.0    // <span class="docEmphItalicAlt">prints</span> <span class="docEmphasis">10.0000</span>
          &lt;&lt; noshowpoint &lt;&lt; endl; // <span class="docEmphItalicAlt">revert to default handling of decimal point</span>
</pre><BR>
<p class="docText"><a name="idd1e159818"></a><a name="idd1e159823"></a><a name="idd1e159828"></a><a name="idd1e159834"></a><a name="idd1e159840"></a><a name="idd1e159846"></a><a name="idd1e159852"></a><a name="idd1e159858"></a><a name="idd1e159864"></a><a name="idd1e159870"></a><a name="idd1e159876"></a><a name="idd1e159882"></a><a name="idd1e159888"></a><a name="idd1e159894"></a><a name="idd1e159900"></a><a name="idd1e159905"></a><a name="idd1e159910"></a><a name="idd1e159915"></a>The <tt>noshowpoint</tt> manipulator reinstates the default behavior. The next output expression will have the default behavior, which is to suppress the decimal point if the floating-point value has a 0 fractional part.</p>

<a name="app01lev3sec26"></a>
<H5 class="docSection3Title">Padding the Output</h5>
<p class="docText">When printing data in columns, we often want fairly fine control over how the data are formatted. The library provides several manipulators to help us accomplish the control we might need:</p>
<UL><LI><p class="docList"><tt>setw</tt> to specify the minimum space for the <span class="docEmphasis">next</span> numeric or string value.</p></li><li><p class="docList"><tt>left</tt> to left-justify the output.</p><p class="docList"><tt>right</tt> to right-justfiy the output. Output is right-justified by default.</p></LI><li><p class="docList"><tt>internal</tt> controls placement of the sign on negative values. <tt>internal</tt> left-justifies the sign and right-justifies the value, padding any intervening space with blanks.</P></LI><li><p class="docList"><tt>setfill</tt> lets us specify an alternative character to use when padding the output. By default, the value is a space.</p></li></UL>
<a name="app01note06"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> <tt>setw</tt>, like <tt>endl</tt>, does not change the internal state of the output stream. It determines the size of only the <span class="docEmphasis">next</span> output.</P></td></tr></table><BR>
</p></div><br>
<p class="docText">The following program illustrates these manipulators</P>
<pre>
     int i = -16;
     double d = 3.14159;
     // <span class="docEmphItalicAlt">pad first column to use minimum of 12 positions in the output</span>
     cout &lt;&lt; "i: " &lt;&lt; setw(12) &lt;&lt; i &lt;&lt; "next col" &lt;&lt; '\n'
          &lt;&lt; "d: " &lt;&lt; setw(12) &lt;&lt; d &lt;&lt; "next col" &lt;&lt; '\n';
     // <span class="docEmphItalicAlt">pad first column and left-justify all columns</span>
     cout &lt;&lt; left
          &lt;&lt; "i: " &lt;&lt; setw(12) &lt;&lt; i &lt;&lt; "next col" &lt;&lt; '\n'
          &lt;&lt; "d: " &lt;&lt; setw(12) &lt;&lt; d &lt;&lt; "next col" &lt;&lt; '\n'
          &lt;&lt; right; // <span class="docEmphItalicAlt">restore normal justification</span>
     // <span class="docEmphItalicAlt">pad first column and right-justify all columns</span>
     cout &lt;&lt; right
          &lt;&lt; "i: " &lt;&lt; setw(12) &lt;&lt; i &lt;&lt; "next col" &lt;&lt; '\n'
          &lt;&lt; "d: " &lt;&lt; setw(12) &lt;&lt; d &lt;&lt; "next col" &lt;&lt; '\n';
     // <span class="docEmphItalicAlt">pad first column but put the padding internal to the field</span>
     cout &lt;&lt; internal
          &lt;&lt; "i: " &lt;&lt; setw(12) &lt;&lt; i &lt;&lt; "next col" &lt;&lt; '\n'
          &lt;&lt; "d: " &lt;&lt; setw(12) &lt;&lt; d &lt;&lt; "next col" &lt;&lt; '\n';
     // <span class="docEmphItalicAlt">pad first column, using # as the pad character</span>
     cout &lt;&lt; setfill('#')
          &lt;&lt; "i: " &lt;&lt; setw(12) &lt;&lt; i &lt;&lt; "next col" &lt;&lt; '\n'
          &lt;&lt; "d: " &lt;&lt; setw(12) &lt;&lt; d &lt;&lt; "next col" &lt;&lt; '\n'
          &lt;&lt; setfill(' '); // <span class="docEmphItalicAlt">restore normal pad character</span>
</pre><br>
<p class="docText"><a name="idd1e160025"></a><a name="idd1e160031"></a><a name="idd1e160037"></a><a name="idd1e160043"></a><a name="idd1e160049"></a><a name="idd1e160054"></a>When executed, this program generates</P>
<pre>
     <span class="docEmphStrong">i:          -16next col</span>
     <span class="docEmphStrong">d:      3.14159next col</span>
     <span class="docEmphStrong">i: -16         next col</span>
     <span class="docEmphStrong">d: 3.14159     next col</span>
     <span class="docEmphStrong">i:          -16next col</span>
     <span class="docEmphStrong">d:      3.14159next col</span>
     <span class="docEmphStrong">i: -         16next col</span>
     <span class="docEmphStrong">d:      3.14159next col</span>
     <span class="docEmphStrong">i: -#########16next col</span>
     <span class="docEmphStrong">d: #####3.14159next col</span>
</pre><br>
<a name="app01table03"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table A.3. Manipulators Defined in <tt>iomanip</tt></h5></caption><colgroup><col width="200"><col width="300"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>setfill(ch)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Fill whitespace with <tt>ch</tt></p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>setprecision(n)</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Set floating-point precision to <tt>n</tt></p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>setw(w)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Read or write value to <tt>w</tt> characters</p></TD></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>setbase(b)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Output integers in base <tt>b</tt></P></TD></tr></table></p><br>


<a name="app01lev2sec14"></a>
<h4 class="docSection2Title">A.3.4. Controlling Input Formatting</H4>
<p class="docText">By default, the input operators ignore whitespace (blank, tab, newline, formfeed, and carriage return). The following loop</p>
<pre>
     while (cin &gt;&gt; ch)
         cout &lt;&lt; ch;
</pre><br>
<p class="docText">given the input sequence</P>
<pre>
     <span class="docEmphStrong">a b   c</span>
     <span class="docEmphStrong">d</span>
</pre><br>
<p class="docText">executes four times to read the characters <tt>a</tt> through <tt>d</tt>, skipping the intervening blanks, possible tabs, and newline characters. The output from this program is</P>
<pre>
     <span class="docEmphStrong">abcd</span>
</pre><br>
<p class="docText">The <tt>noskipws</tt> manipulator causes the input operator to read, rather than skip, whitespace. To return to the default behavior, we apply <tt>skipws</tt> manipulator:</P>
<pre>
     cin &gt;&gt; noskipws;      // <span class="docEmphItalicAlt">set</span> <span class="docEmphasis">cin</span> <span class="docEmphItalicAlt">so that it reads whitespace</span>
     while (cin &gt;&gt; ch)
             cout &lt;&lt; ch;
     cin &gt;&gt; skipws; // <span class="docEmphItalicAlt">reset</span> <span class="docEmphasis">cin</span> <span class="docEmphItalicAlt">to default state so that it discards whitespace</span>
</pre><br>
<p class="docText">Given the same input as before, this loop makes seven iterations, reading white-space as well as the characters in the input. This loop generates</p>
<pre>
     <span class="docEmphStrong">a b    c</span>
     <span class="docEmphStrong">d</span>
</pre><br>

<a name="app01lev2sec15"></a>
<h4 class="docSection2Title">A.3.5. Unformatted Input/Output Operations</h4>
<p class="docText"><a name="idd1e160276"></a><a name="idd1e160283"></a><a name="idd1e160290"></a><a name="idd1e160297"></a><a name="idd1e160303"></a>So far, our programs have used only formatted IO operations. The input and output operators (<tt>&lt;&lt;</tt> and <tt>&gt;&gt;</tt>) format the data they read or write according to the data type being handled. The input operators ignore whitespace; the output operators apply padding, precision, and so on.</p>
<p class="docText">The library also provides a rich set of low-level operations that support unformatted IO. These operations let us deal with a stream as a sequence of uninterpreted bytes rather than as a sequence of data types, such as <tt>char, int, string</tt>, and so on.</p>

<a name="app01lev2sec16"></a>
<h4 class="docSection2Title">A.3.6. Single-Byte Operations</h4>
<p class="docText">Several of the unformatted operations deal with a stream one byte at a time. They read rather than ignore whitespace. For example, we could use the unformatted IO operations <tt>get</tt> and <tt>put</tt> to read the characters one at a time:</p>
<pre>
     char ch;
     while (cin.get(ch))
             cout.put(ch);
</pre><br>
<p class="docText">This program preserves the whitespace in the input. Its output is identical to the input. Given the same input as read by the previous program that used <tt>noskipws</tt>, this program generates the same output:</p>
<pre>
     <span class="docEmphStrong">a b    c</span>
     <span class="docEmphStrong">d</span>
</pre><br>
<a name="app01table04"></a><P><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table A.4. Single-Byte Low-Level IO Operations</h5></caption><colgroup><col width="150"><col width="350"></colgroup><thead></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>is.get(ch)</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Puts next byte from the <tt>istream is</tt> in character <tt>ch</tt>. Returns <tt>is</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>os.put(ch)</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Puts character <tt>ch</tt> onto the <tt>ostream os</tt>. Returns <tt>os</tt>.</P></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>is.get()</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns next byte from <tt>is</tt> as an <tt>int</tt>.</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>is.putback(ch)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Puts character <tt>ch</tt> back on <tt>is</tt>; returns <tt>is</tt>.</P></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>is.unget()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Moves <tt>is</tt> back one byte; returns <tt>is</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>is.peek()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns the next byte as an <tt>int</tt> but doesn't remove it.</P></TD></tr></table></P><br>
<a name="app01lev3sec27"></a>
<h5 class="docSection3Title">Putting Back onto an Input Stream</H5>
<p class="docText">Sometimes we need to read a character in order to know that we aren't ready for it yet. In such cases, we'd like to put the character back onto the stream. The library gives us three ways to do so, each of which has subtle differences from the others:</P>
<ul><li><p class="docList"><tt>peek</tt> returns a copy of the next character on the input stream but does not change the stream. The value returned by <tt>peek</tt> stays on the stream and will be the next one retrieved.</p></li><li><p class="docList"><a name="idd1e160516"></a><a name="idd1e160519"></a><a name="idd1e160530"></a><a name="idd1e160537"></a><tt>unget</tt> backs up the input stream so that whatever value was last returned is still on the stream. We can call <tt>unget</tt> even if we do not know what value was last taken from the stream.</P></li><LI><p class="docList"><tt>putback</tt> is a more specialized version of <tt>unget</tt>: It returns the last value read from the stream but takes an argument that must be the same as the one that was last read. Few programs use <tt>putback</tt> because the simpler <tt>unget</tt> does the same job with fewer constraints.</P></li></ul>
<p class="docText">In general, we are guaranteed to be able to put back at most one value before the next read. That is, we are not guaranteed to be able to call <tt>putback</tt> or <tt>unget</tt> successively without an intervening read operation.</p>

<a name="app01lev3sec28"></a>
<H5 class="docSection3Title"><tt>int</tt> Return Values from Input Operations</H5>
<p class="docText">The version of <tt>get</tt> that takes no argument and the <tt>peek</tt> function return a character from the input stream as an <tt>int</tt>. This fact can be surprising; it might seem more natural to have these functions return a <tt>char</tt>.</p>
<p class="docText">The reason that these functions return an <tt>int</tt> is to allow them to return an end-of-file marker. A given character set is allowed to use every value in the <tt>char</tt> range to represent an actual character. Thus, there is no extra value in that range to use to represent end-of-file.</p>
<p class="docText">Instead, these functions convert the character to <tt>unsigned char</tt> and then promote that value to <tt>int</tt>. As a result, even if the character set has characters that map to negative values, the <tt>int</tt> returned from these operations will be a positive value (<a class="docLink" href="ch02lev1sec1.html#ch02lev2sec1">Section 2.1.1</a>, p. <a class="docLink" href="ch02lev1sec1.html#ch02lev2sec1">36</a>). By returning end-of-file as a negative value, the library guarantees that end-of-file will be distinct from any legitimate character value. Rather than requiring us to know the actual value returned, the <tt>iostream</tt> header defines a <tt>const</tt> named <tt>EOF</tt> that we can use to test if the value returned from <tt>get</tt> is end-of-file. It is essential that we use an <tt>int</tt> to hold the return from these functions:</p>
<pre>
     int ch;   // <span class="docEmphItalicAlt">NOTE:</span> <span class="docEmphasis">int</span><span class="docEmphItalicAlt">, not</span> <span class="docEmphasis">char</span><span class="docEmphItalicAlt">!!!!</span>
     // <span class="docEmphItalicAlt">loop to read and write all the data in the input</span>
     while ((ch = cin.get()) != EOF)
              cout.put(ch);
</pre><br>
<p class="docText">This program operates identically to one on page <a class="docLink" href="#app01lev2sec15">834</a>, the only difference being the version of <tt>get</tt> that is used to read the input.</P>


<a name="app01lev2sec17"></a>
<h4 class="docSection2Title">A.3.7. Multi-Byte Operations</h4>
<p class="docText">Other unformatted IO operations deal with chunks of data at a time. These operations can be important if speed is an issue, but like other low-level operations they are error-prone. In particular, these operations require us to allocate and manage the character arrays (<a class="docLink" href="ch04lev1sec3.html#ch04lev2sec14">Section 4.3.1</a>, p. <a class="docLink" href="ch04lev1sec3.html#ch04lev2sec14">134</a>) used to store and retrieve data.</P>
<p class="docText">The multi-byte operations are listed in <a class="docLink" href="#app01table05">Table A.5</a> (p. <a class="docLink" href="#app01table05">837</a>). It is worth noting that the <tt>get</tt> member is overloaded; there is a third version that reads a sequence of characters.</p>
<a name="app01sb01"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<H2 class="docSidebarTitle">Caution: Low-Level Routines Are Error-Prone</h2>
<p class="docText"><a name="idd1e160711"></a><a name="idd1e160720"></a><a name="idd1e160731"></a><span class="docEmphStrong">In general, we advocate using the higher-level abstractions provided by the library. The IO operations that return <tt>int</tt> are a good example of why.</span></p>
<p class="docText"><span class="docEmphStrong">It is a common programming error to assign the return from <tt>get</tt> or one of the other <tt>int</tt> returning functions to a <tt>char</tt> rather than an <tt>int</tt>.</span> <span class="docEmphStrong">Doing so is an error but an error the compiler will not detect. Instead, what happens depends on the machine and on the input data. For example, on a machine in which <tt>char</tt>s are implemented as <tt>unsigned char</tt>s, this loop will run forever:</span></p>
<pre><a name="PLID26"></a><div class="v1"><a href="app01lev1sec3.html#PLID26">[View full width]</a></div>
     char ch;    // <span class="docEmphItalicAlt">Using a char here invites disaster!</span>
     // <span class="docEmphItalicAlt">return from cin.get is converted from int to char and
<img border="0" width="14" height="9" alt="" align="left" src="images/ccc.gif"> then compared to an int</span>
     while ((ch = cin.get()) != EOF)
              cout.put(ch);
</pre><br>
<p class="docText"><span class="docEmphStrong">The problem is that when <tt>get</tt> returns <tt>EOF</tt>, that value will be converted to an <tt>unsigned char</tt> value. That converted value is no longer equal to the integral value of <tt>EOF</tt>, and the loop will continue forever.</span></p>
<p class="docText"><span class="docEmphStrong">At least that error is likely to be caught in testing. On machines for which <tt>char</tt>s are implemented as <tt>signed char</tt>s, we can't say with confidence what the behavior of the loop might be. What happens when an out-of-bounds value is assigned to a <tt>signed</tt> value is up to the compiler. On many machines, this loop will appear to work, unless a character in the input matches the EOF value. While such characters are unlikely in ordinary data, presumably low-level IO is necessary only when reading binary values that do not map directly to ordinary characters and numeric values. For example, on our machine, if the input contains a character whose value is <tt>'\377'</tt> then the loop terminates prematurely. <tt>'\377'</tt> is the value on our machine to which -1 converts when used as a <tt>signed char</tt>. If the input has this value, then it will be treated as the (premature) end-of-file indicator.</span></p>
<p class="docText"><span class="docEmphStrong">Such bugs do not happen when reading and writing typed values. If you can use the more type-safe, higher-level operations supported by the library, do so.</span></p>
</td></tr></table></p><br>
<p class="docText">The <tt>get</tt> and <tt>getline</tt> functions take the same parameters, and their actions are similar but not identical. In each case, <tt>sink</tt> is a <tt>char</tt> array into which the data are placed. The functions read until one of the following conditions occurs:</p>
<ul><LI><p class="docList"><tt>size - 1</tt> characters are read</P></li><LI><p class="docList">End-of-file is encountered</p></li><LI><p class="docList">The delimiter character is encountered</P></li></ul>
<p class="docText">Following any of these conditions, a null character is put in the next open position in the array. The difference between these functions is the treatment of the delimiter. <tt>get</tt> leaves the delimiter as the next character of the <tt>istream</tt>. <tt>getline</tt> reads and discards the delimiter. In either case, the delimiter is <span class="docEmphasis">not</span> stored in <tt>sink</tt>.</p>
<a name="app01note07"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><TD valign="top"><p class="docText"> It is a common error to intend to remove the delimiter from the stream but to forget to do so.</P></td></tr></table><br>
</P></div><BR>
<a name="app01table05"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table A.5. Multi-Byte Low-Level IO Operations</h5></caption><colgroup><col width="150"><col width="350"></colgroup><thead></thead><tr><TD class="docTableCell" align="left" valign="top" colspan="2"><p class="docText"><tt>is.get(sink, size, delim)</tt></p></td></TR><tr><td class="docTableCell" align="left" valign="top">&nbsp;</TD><td class="docTableCell" align="left" valign="top"><p class="docText">Reads up to <tt>size</tt> bytes from <tt>is</tt> and stores them in the character array pointed to by <tt>sink</tt>. Reads until encountering the <tt>delim</tt> character or until it has read <tt>size</tt> bytes or encounters end-of-file. If the <tt>delim</tt> is present, it is left on the input stream and not read into <tt>sink</tt>.</P></td></tr><tr><td class="docTableCell" align="left" valign="top" colspan="2"><p class="docText"><tt>is.getline(sink, size, delim)</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText">Same behavior as three-argument version of <tt>get</tt> but reads and discards <tt>delim</tt>.</p></td></TR><TR><td class="docTableCell" align="left" valign="top" colspan="2"><p class="docText"><tt>is.read(sink, size)</tt></P></td></tr><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText">Reads up to <tt>size</tt> bytes into the character array <tt>sink</tt>. Returns <tt>is</tt>.</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>is.gcount()</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Returns number of bytes read from the stream <tt>is</tt> by last call to an unformatted read operation.</p></td></TR><TR><td class="docTableCell" align="left" valign="top" colspan="2"><p class="docText"><tt>os.write(source, size)</tt></p></td></tr><TR><td class="docTableCell" align="left" valign="top">&nbsp;</td><TD class="docTableCell" align="left" valign="top"><p class="docText">Writes <tt>size</tt> bytes from the character array <tt>source</tt> to <tt>os</tt>. Returns <tt>os</tt>.</p></td></TR><tr><TD class="docTableCell" align="left" valign="top" colspan="2"><p class="docText"><tt>is.ignore(size, delim)</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText">Reads and ignores at most <tt>size</tt> characters up to but not including <tt>delim</tt>. By default, <tt>size</tt> is 1 and <tt>delim</tt> is end-of-file.</p></td></tr></table></p><br>
<a name="app01lev3sec29"></a>
<h5 class="docSection3Title">Determining How Many Characters Were Read</H5>
<p class="docText"><a name="idd1e161070"></a><a name="idd1e161077"></a><a name="idd1e161084"></a><a name="idd1e161091"></a><a name="idd1e161099"></a><a name="idd1e161106"></a>Several of the read operations read an unknown number of bytes from the input. We can call <tt>gcount</tt> to determine how many characters the last unformatted input operation read. It is esssential to call <tt>gcount</tt> before any intervening unformatted input operation. In particular, the single-character operations that put characters back on the stream are also unformatted input operations. If <tt>peek, unget</tt>, or <tt>putback</tt> are called before calling <tt>gcount</tt>, then the return value will be 0!</P>


<a name="app01lev2sec18"></a>
<h4 class="docSection2Title">A.3.8. Random Access to a Stream</H4>
<p class="docText">The various stream types generally support random access to the data in their associated stream. We can reposition the stream so that it skips around, reading first the last line, then the first, and so on. The library provides a pair of functions to <span class="docEmphasis">seek</span> to a given location and to <span class="docEmphasis">tell</span> the current location in the associated stream.</p>
<a name="app01note08"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><TD width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> Random IO is an inherently system-dependent. To understand how to use these features, you must consult your system's documentation.</p></td></tr></table><BR>
</p></div><BR>
<a name="app01lev3sec30"></a>
<H5 class="docSection3Title">Seek and Tell Functions</h5>
<p class="docText">To support random access, the IO types maintain a marker that determines where the next read or write will happen. They also provide two functions: One repositions the marker by <span class="docEmphasis">seek</span>ing to a given position; the second <span class="docEmphasis">tell</span>s us the current position <a name="idd1e161166"></a><a name="idd1e161172"></a><a name="idd1e161178"></a><a name="idd1e161189"></a><a name="idd1e161195"></a><a name="idd1e161201"></a><a name="idd1e161212"></a><a name="idd1e161223"></a><a name="idd1e161234"></a><a name="idd1e161240"></a><a name="idd1e161246"></a><a name="idd1e161254"></a><a name="idd1e161265"></a>of the marker. The library actually defines two pairs of <span class="docEmphasis">seek</span> and <span class="docEmphasis">tell</span> functions, which are described in <a class="docLink" href="#app01table06">Table A.6</a>. One pair is used by input streams, the other by output streams. The input and output versions are distinguished by a suffix that is either a <tt>g</tt> or a <tt>p</tt>. The <tt>g</tt> versions indicate that we are &quot;getting&quot; (reading) data, and the <tt>p</tt> functions indicate that we are &quot;putting&quot; (writing) data.</p>
<a name="app01table06"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table A.6. Seek and Tell Functions</H5></caption><colgroup><col width="100"><col width="300"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>seekg</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Reposition the marker in an input stream</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>tellg</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Return the current position of the marker in an input stream</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>seekp</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Reposition the marker for an output stream</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>tellp</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Return the current position of the marker in an output stream</P></td></tr></table></P><BR>
<p class="docText">Logically enough, we can use only the <tt>g</tt> versions on an <tt>istream</tt> or its derived types <tt>ifstream</tt>, or <tt>istringstream</tt>, and we can use only the <tt>p</tt> versions on an <tt>ostream</tt> or its derived types <tt>ofstream</tt>, and <tt>ostringstream</tt>. An <tt>iostream, fstream</tt>, or <tt>stringstream</tt> can both read and write the associated stream; we can use either the <tt>g</tt> or <tt>p</tt> versions on objects of these types.</p>

<a name="app01lev3sec31"></a>
<h5 class="docSection3Title">There Is Only One Marker</h5>
<p class="docText">The fact that the library distinguishes between the &quot;putting&quot; and &quot;getting&quot; versions of the <tt>seek</tt> and <tt>tell</tt> functions can be misleading. Even though the library makes this distinction, it maintains only a single marker in the filethere is <span class="docEmphasis">not</span> a distinct read marker and write marker.</p>
<p class="docText">When we're dealing with an input-only or output-only stream, the distinction isn't even apparent. We can use only the <tt>g</tt> or only the <tt>p</tt> versions on such streams. If we attempt to call <tt>tellp</tt> on an <tt>ifstream</tt>, the compiler will complain. Similarly, it will not let us call <tt>seekg</tt> on an <tt>ostringstream</tt>.</p>
<p class="docText">When using the <tt>fstream</tt> and <tt>stringstream</tt> types that can both read and write, there is a single buffer that holds data to be read and written and a single marker denoting the current position in the buffer. The library maps both the <tt>g</tt> and <tt>p</tt> positions to this single marker.</P>
<a name="app01note09"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><TD width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> Because there is only a single marker, we <span class="docEmphasis">must</span> do a <tt>seek</tt> to reposition the marker whenever we switch between reading and writing.</p></TD></TR></table><br>
</p></div><br>

<a name="app01lev3sec32"></a>
<h5 class="docSection3Title">Plain <tt>iostream</tt>s Usually Do Not Allow Random Access</H5>
<p class="docText">The <tt>seek</tt> and <tt>tell</tt> functions are defined for all the stream types. Whether they do anything useful depends on the kind of object to which the stream is bound. On most systems, the streams bound to <tt>cin, cout, cerr</tt> and <tt>clog</tt> do <span class="docEmphasis">not</span> support random accessafter all, what would it mean to jump ten places back when writing directly to <tt>cout</tt>? We can call the <tt>seek</tt> and <tt>tell</tt> functions, but these functions will fail at run time, leaving the stream in an invalid state.</p>
<a name="app01note10"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><TD valign="top"><p class="docText"><a name="idd1e161503"></a><a name="idd1e161510"></a><a name="idd1e161517"></a><a name="idd1e161524"></a><a name="idd1e161531"></a><a name="idd1e161539"></a> Because the <tt>istream</tt> and <tt>ostream</tt> types usually do not support random access, the remainder of this section should be considered as applicable to only the <tt>fstream</tt> and <tt>sstream</tt> types.</p></TD></tr></table><br>
</p></div><br>

<a name="app01lev3sec33"></a>
<h5 class="docSection3Title">Repositioning the Marker</h5>
<p class="docText">The <tt>seekg</tt> and <tt>seekp</tt> functions are used to change the read and write positions in a file or a <tt>string</tt>. After a call to <tt>seekg</tt>, the read position in the stream is changed; a call to <tt>seekp</tt> sets the position at which the next write will take place.</p>
<p class="docText">There are two versions of the seek functions: One moves to an &quot;absolute&quot; address within the file; the other moves to a byte offset from a given position:</p>
<pre>
     // <span class="docEmphItalicAlt">set the indicated marker a fixed position within a file or string</span>
     seekg(new_position); // <span class="docEmphItalicAlt">set read marker</span>
     seekp(new_position); // <span class="docEmphItalicAlt">set write marker</span>

     // <span class="docEmphItalicAlt">offset some distance from the indicated position</span>
     seekg(offset, dir); // <span class="docEmphItalicAlt">set read marker</span>
     seekp(offset, dir); // <span class="docEmphItalicAlt">set write marker</span>
</pre><br>
<p class="docText">The first version sets the current position to a given location. The second takes an offset and an indicator of where to offset from. The possible values for the offset are listed in <a class="docLink" href="#app01table07">Table A.7</a>.</p>
<a name="app01table07"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table A.7. Offset From Argument to <tt>seek</tt></h5></caption><colgroup><col width="100"><col width="300"></colgroup><thead></thead><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>beg</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">The beginning of the stream</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>cur</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">The current position of the stream</P></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>end</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">The end of the stream</P></td></tr></table></p><br>
<p class="docText">The argument and return types for these functions are machine-dependent types defined in both <tt>istream</tt> or <tt>ostream</tt>. The types, named <tt>pos_type</tt> and <tt>off_type</tt>, represent a file position and an offset from that position, respectively. A value of type <tt>off_type</tt> can be positive or negative; we can <tt>seek</tt> forward or backward in the file.</P>

<a name="app01lev3sec34"></a>
<h5 class="docSection3Title">Accessing the Marker</h5>
<p class="docText">The current position is returned by either <tt>tellg</tt> or <tt>tellp</tt>, depending on whether we're looking for the read or write position. As before, the <tt>p</tt> indicates putting (writing) and the <tt>g</tt> indicates getting (reading). The <tt>tell</tt> functions are usually used to remember a location so that we can subsequently <tt>seek</tt> back to it:</P>
<pre>
     // <span class="docEmphItalicAlt">remember current write position in mark</span>
    ostringstream writeStr; // output stringstream
    ostringstream::pos_type mark = writeStr.tellp();
     // ...
     if (cancelEntry)
          // <span class="docEmphItalicAlt">return to marked position</span>
          writeStr.seekp(mark);
</pre><br>
<p class="docText"><a name="idd1e161738"></a><a name="idd1e161744"></a><a name="idd1e161750"></a><a name="idd1e161756"></a>The <tt>tell</tt> functions return a value that indicates the position in the associated stream. As with the <tt>size_type</tt> of a <tt>string</tt> or <tt>vector</tt>, we do not know the actual type of the object returned from <tt>tellg</tt> or <tt>tellp</tt>. Instead, we use the <tt>pos_type</tt> member of the appropriate stream class.</p>


<a name="app01lev2sec19"></a>
<H4 class="docSection2Title">A.3.9. Reading and Writing to the Same File</h4>
<p class="docText">Let's look at a programming example. Assume we are given a file to read. We are to write a new line at the end of the file that contains the relative position at which each line begins. For example, given the following file,</P>
<pre>
     <span class="docEmphStrong">abcd</span>
     <span class="docEmphStrong">efg</span>
     <span class="docEmphStrong">hi</span>
     <span class="docEmphStrong">j</span>
</pre><br>
<p class="docText">the program should produce the following modified file:</p>
<pre>
        <span class="docEmphStrong">abcd</span>
        <span class="docEmphStrong">efg</span>
        <span class="docEmphStrong">hi</span>
        <span class="docEmphStrong">j</span>
        <span class="docEmphStrong">5 9 12 14</span>
</pre><br>
<p class="docText">Note that our program need not write the offset for the first lineit always occurs at position 0. It should print the offset that corresponds to the end of the data portion of the file. That is, it should record the position after the end of the input so that we'll know where the original data ends and where our output begins.</p>
<p class="docText">We can write this program by writing a loop that reads a line at a time:</p>
<pre>
     int main()
     {
         // <span class="docEmphItalicAlt">open for input and output and pre-position file pointers to end of file</span>
         fstream inOut("copyOut",
                        fstream::ate | fstream::in | fstream::out);
         if (!inOut) {
             cerr &lt;&lt; "Unable to open file!" &lt;&lt; endl;
             return EXIT_FAILURE;
         }
         // <span class="docEmphasis">inOut</span> <span class="docEmphItalicAlt">is opened in</span> <span class="docEmphasis">ate</span> <span class="docEmphItalicAlt">mode, so it starts out positioned at the end,</span>
         // <span class="docEmphItalicAlt">which we must remember as it is the original end-of-file position</span>
         ifstream::pos_type end_mark = inOut.tellg();
         inOut.seekg(0, fstream::beg); // <span class="docEmphItalicAlt">reposition to start of the file</span>
         int cnt = 0;                  // <span class="docEmphItalicAlt">accumulator for byte count</span>
         string line;                  // <span class="docEmphItalicAlt">hold each line of input</span>
         // <span class="docEmphItalicAlt">while we haven't hit an error and are still reading the original data</span>
         // <span class="docEmphItalicAlt">and successfully read another line from the file</span>
         while (inOut &amp;&amp; inOut.tellg() != end_mark
                      &amp;&amp; getline(inOut, line))
         {
             cnt += line.size() + 1; //   <span class="docEmphItalicAlt">add 1 to account for the newline</span>
         // <span class="docEmphItalicAlt">remember current read marker</span>
         ifstream::pos_type mark = inOut.tellg();
             inOut.seekp(0, fstream::end);// <span class="docEmphItalicAlt">set write marker to end</span>
             inOut &lt;&lt; cnt;        // <span class="docEmphItalicAlt">write the accumulated length</span>
             // <span class="docEmphItalicAlt">print separator if this is not the last line</span>
             if (mark != end_mark) inOut &lt;&lt; " ";
             inOut.seekg(mark);         // <span class="docEmphItalicAlt">restore read position</span>
          }
          inOut.clear();                // <span class="docEmphItalicAlt">clear flags in case we hit an error</span>
          inOut.seekp(0, fstream::end); // <span class="docEmphItalicAlt">seek to end</span>
          inOut &lt;&lt; "\n";                // <span class="docEmphItalicAlt">write a newline at end of file</span>
          return 0;
     }
</pre><br>
<p class="docText">This program opens the <tt>fstream</tt> using the <tt>in, out</tt>, and <tt>ate</tt> modes. The first two modes indicate that we intend to both read and write to the same file. By also opening it in <tt>ate</tt> mode, the file starts out positioned at the end. As usual, we check that the open succeeded, and exit if it did not.</p>
<a name="app01lev3sec35"></a>
<h5 class="docSection3Title">Initial Setup</h5>
<p class="docText">The core of our program will loop through the file a line at a time, recording the relative position of each line as it does so. Our loop should read the contents of the file up to but not including the line that we are adding to hold the line offsets. Because we will be writing to the file, we can't just stop the loop when it encounters end-of-file. Instead, the loop should end when it reaches the point at which the original input ended. To do so, we must first remember the original end-of-file position.</p>
<p class="docText">We opened the file in <tt>ate</tt> mode, so it is already positioned at the end. We store the initial end position in <tt>end_mark</tt>. Of course, having remembered the end position, we must reposition the read marker at the beginning of the file before we attempt to read any data.</p>

<a name="app01lev3sec36"></a>
<h5 class="docSection3Title">Main Processing Loop</h5>
<p class="docText">Our <tt>while</tt> loop has a three-part condition.</P>
<p class="docText">We first check that the stream is valid. Assuming the first test on <tt>inOut</tt> succeeds, we then check whether we've exhausted our original input. We do this check by comparing the current read position returned from <tt>tellg</tt> with the position we remembered in <tt>end_mark</tt>. Finally, assuming that both tests succeeded, we call <tt>getline</tt> to read the next line of input. If <tt>getline</tt> succeeds, we perform the body of the loop.</P>
<p class="docText">The job that the <tt>while</tt> does is to increment the counter to determine the offset at which the next line starts and write that marker at the end of the file. Notice that the end of the file advances on each trip through the loop.</p>
<p class="docText">We start by remembering the current position in <tt>mark</tt>. We need to keep that value because we have to reposition the file in order to write the next relative offset. The <tt>seekp</tt> call does this repositioning, resetting the file pointer to the end of the file. We write the counter value and then restore the file position to the value we remembered in <tt>mark</tt>. The effect is that we return the marker to the same place it was after the last read. Having restored the marker, we're ready to repeat the condition in the <tt>while</tt>.</P>

<a name="app01lev3sec37"></a>
<h5 class="docSection3Title">Completing the File</h5>
<p class="docText">Once we exit the loop, we have read each line and calculated all the starting offsets. All that remains is to print the offset of the last line. As with the other writes, we call <tt>seekp</tt> to position the file at the end and write the value of <tt>cnt</tt>. The only tricky part is remembering to <tt>clear</tt> the stream. We might exit the loop due to an end-of-file or other input error. If so, <tt>inOut</tt> would be in an error state, and both the <tt>seekp</tt> and the output expression would fail.</P>



<UL></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app01lev1sec2.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=index.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>