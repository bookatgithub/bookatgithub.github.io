<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 2.2.&nbsp; Literal Constants</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch02lev1sec1.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch02lev1sec3.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch02lev1sec2"></a>
<h3 class="docSection1Title">2.2. Literal Constants</h3>
<p class="docText">A value, such as <tt>42</tt>, in a program is known as a <B><a name="ch02term30"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_30">literal constant</a></b>: literal because we can speak of it only in terms of its value; constant because its value cannot be changed. Every literal has an associated type. For example, <tt>0</tt> is an <tt>int</tt> and <tt>3.14159</tt> is a <tt>double</tt>. Literals exist only for the built-in types. There are no literals of class types. Hence, there are no literals of any of the library types.</P>
<a name="ch02sb02"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<h2 class="docSidebarTitle">Advice: Using the Built-in Arithmetic Types</H2>
<p class="docText"><a name="idd1e7573"></a><a name="idd1e7576"></a><a name="idd1e7588"></a><a name="idd1e7594"></a><a name="idd1e7599"></a><a name="idd1e7613"></a><a name="idd1e7619"></a><a name="idd1e7636"></a><a name="idd1e7646"></a><a name="idd1e7662"></a><a name="idd1e7671"></a><a name="idd1e7676"></a><span class="docEmphStrong">The number of integral types in C++ can be bewildering. C++, like C, is designed to let programs get close to the hardware when necessary, and the integral types are defined to cater to the peculiarities of various kinds of hardware. Most programmers can (and should) ignore these complexities by restricting the types they actually use.</span></P>
<p class="docText"><span class="docEmphStrong">In practice, many uses of integers involve counting. For example, programs often count the number of elements in a data structure such as a <tt>vector</tt> or an array. We'll see in <a class="docLink" href="ch03.html#ch03">Chapters 3</a> and <a class="docLink" href="ch04.html#ch04">4</a> that the library defines a set of types to use when dealing with the size of an object. When counting such elements it is always right to use the library-defined type intended for this purpose. When counting in other circumstances, it is usually right to use an <tt>unsigned</tt> value. Doing so avoids the possibility that a value that is too large to fit results in a (seemingly) negative result.</span></p>
<p class="docText"><span class="docEmphStrong">When performing integer arithmetic, it is rarely right to use <tt>short</tt>s. In most programs, using <tt>short</tt>s leads to mysterious bugs when a value is assigned to a <tt>short</tt> that is bigger than the largest number it can hold. What happens depends on the machine, but typically the value &quot;wraps around&quot; so that a number too large to fit turns into a large negative number. For the same reason, even though <tt>char</tt> is an integral type, the <tt>char</tt> type should be used to hold characters and not for computation. The fact that <tt>char</tt> is <tt>signed</tt> on some implementations and <tt>unsigned</tt> on others makes it problematic to use it as a computational type.</span></p>
<p class="docText"><span class="docEmphStrong">On most machines, integer calculations can safely use <tt>int</tt>. Technically speaking, an <tt>int</tt> can be as small as 16 bitstoo small for most purposes. In practice, almost all general-purpose machines use 32-bits for <tt>int</tt>s, which is often the same size used for <tt>long</tt>. The difficulty in deciding whether to use <tt>int</tt> or <tt>long</tt> occurs on machines that have 32-bit <tt>int</tt>s and 64-bit <tt>long</tt>s. On such machines, the <span class="docEmphasis">run-time</span> cost of doing arithmetic with <tt>long</tt>s can be considerably greater than doing the same calculation using a 32-bit <tt>int</tt>. Deciding whether to use <tt>int</tt> or <tt>long</tt> requires detailed understanding of the program and the actual run-time performance cost of using <tt>long</tt> versus <tt>int</tt></span>.</p>
<p class="docText"><span class="docEmphStrong">Determining which floating-point type to use is easier: It is almost always right to use <tt>double</tt>. The loss of precision implicit in <tt>float</tt> is significant, whereas the cost of double precision calculations versus single precision is negligible. In fact, on some machines, double precision is faster than single. The precision offered by <tt>long double</tt> usually is unnecessary and often entails considerable extra run-time cost.</span></p>
</td></TR></table></p><BR>
<a name="ch02lev2sec3"></a>
<H4 class="docSection2Title">Rules for Integer Literals</h4>
<p class="docText">We can write a literal integer constant using one of three notations: decimal, octal, or hexadecimal. These notations, of course, do not change the bit representation of the value, which is always binary. For example, we can write the value <tt>20</tt> in any of the following three ways:</p>
<pre>
     20     // <span class="docEmphasis">decimal</span>
     024    // <span class="docEmphasis">octal</span>
     0x14   // <span class="docEmphasis">hexadecimal</span>
</pre><br>
<p class="docText">Literal integer constants that begin with a leading <tt>0</tt> (zero) are interpreted as octal; those that begin with either <tt>0x</tt> or <tt>0X</tt> are interpreted as hexadecimal.</P>
<p class="docText">By default, the type of a literal integer constant is either <tt>int</tt> or <tt>long</tt>. The precise type depends on the value of the literalvalues that fit in an <tt>int</tt> are type <a name="idd1e7839"></a><a name="idd1e7853"></a><a name="idd1e7870"></a><a name="idd1e7885"></a><a name="idd1e7900"></a><a name="idd1e7915"></a><a name="idd1e7921"></a><a name="idd1e7941"></a><a name="idd1e7959"></a><a name="idd1e7966"></a><a name="idd1e7972"></a><a name="idd1e7993"></a><a name="idd1e8009"></a><a name="idd1e8026"></a><a name="idd1e8043"></a><a name="idd1e8058"></a><a name="idd1e8075"></a><a name="idd1e8092"></a><a name="idd1e8109"></a><a name="idd1e8126"></a><tt>int</tt> and larger values are type <tt>long</tt>. By adding a suffix, we can force the type of a literal integer constant to be type <tt>long</tt> or <tt>unsigned</tt> or <tt>unsigned long</tt>. We specify that a constant is a <tt>long</tt> by immediately following the value with either <tt>L</tt> or <tt>l</tt> (the letter &quot;ell&quot; in either uppercase or lowercase).</P>
<a name="ch02sb03"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 2.1.2</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch02qa1q1"></a><b>Exercise 2.1:</b></td><TD><p class="docText">What is the difference between an <tt>int</tt>, a <tt>long</tt>, and a <tt>short</tt> value?</p>
</TD></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa1q2"></a><b>Exercise 2.2:</b></td><td><p class="docText">What is the difference between an <tt>unsigned</tt> and a <tt>signed</tt> type?</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa1q3"></a><b>Exercise 2.3:</b></td><TD><p class="docText">If a <tt>short</tt> on a given machine has 16 bits then what is the largest number that can be assigned to a <tt>short</tt>? To an <tt>unsigned short</tt>?</P>
</td></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa1q4"></a><B>Exercise 2.4:</b></TD><td><p class="docText">What value is assigned if we assign 100,000 to a 16-bit <tt>unsigned short</tt>? What value is assigned if we assign 100,000 to a plain 16-bit <tt>short</tt>?</p>
</td></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch02qa1q5"></a><b>Exercise 2.5:</b></TD><TD><p class="docText">What is the difference between a <tt>float</tt> and a <tt>double</tt>?</p>
</td></tr><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch02qa1q6"></a><b>Exercise 2.6:</b></td><td><p class="docText">To calculate a mortgage payment, what types would you use for the rate, principal, and payment? Explain why you selected each type.</p>
</TD></tr></table></p>
</blockquote>
</TD></tr></table></p><BR>
<a name="ch02note04"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="84" height="51" SRC="images/0201721481/graphics/tip.jpg;400478"></td><td valign="top"><p class="docText"> When specifying a long, use the uppercase <tt>L</tt>: the lowercase letter <tt>l</tt> is too easily mistaken for the digit 1.</p></td></tr></table><br>
</p></div><br>
<p class="docText">In a similar manner, we can specify <tt>unsigned</tt> by following the literal with either <tt>U</tt> or <tt>u</tt>. We can obtain an <tt>unsigned long</tt> literal constant by following the value by both <tt>L</tt> and <tt>U</tt>. The suffix must appear with no intervening space:</p>
<pre>
     128u     /* <span class="docEmphasis">unsigned</span>   */          1024UL    /* <span class="docEmphasis">unsigned long</span>   */
     1L       /* <span class="docEmphasis">long</span>    */             8Lu        /* <span class="docEmphasis">unsigned long</span>   */
</pre><br>
<p class="docText">There are no literals of type <tt>short</tt>.</p>

<a name="ch02lev2sec4"></a>
<h4 class="docSection2Title">Rules for Floating-Point Literals</H4>
<p class="docText">We can use either common decimal notation or scientific notation to write floating-point literal constants. Using scientific notation, the exponent is indicated either by <tt>E</tt> or <tt>e</tt>. By default, floating-point literals are type <tt>double</tt>. We indicate single precision by following the value with either <tt>F</tt> or <tt>f</tt>. Similarly, we specify extended precision by following the value with either <tt>L</tt> or <tt>l</tt> (again, use of the lowercase <tt>l</tt> is discouraged). Each pair of literals below denote the same underlying value:</P>
<pre>
     3.14159F            .001f          12.345L            0.
     3.14159E0f          1E-3F          1.2345E1L          0e0
</pre><br>

<a name="ch02lev2sec5"></a>
<H4 class="docSection2Title">Boolean and Character Literals</h4>
<p class="docText">The words <tt>true</tt> and <tt>false</tt> are literals of type <tt>bool</tt>:</P>
<pre>
     bool test = false;
</pre><BR>
<p class="docText"><a name="idd1e8398"></a><a name="idd1e8403"></a><a name="idd1e8410"></a><a name="idd1e8415"></a><a name="idd1e8420"></a><a name="idd1e8433"></a><a name="idd1e8440"></a><a name="idd1e8443"></a><a name="idd1e8449"></a><a name="idd1e8457"></a><a name="idd1e8462"></a><a name="idd1e8470"></a><a name="idd1e8478"></a><a name="idd1e8481"></a><a name="idd1e8491"></a><a name="idd1e8502"></a><a name="idd1e8510"></a><a name="idd1e8516"></a><a name="idd1e8521"></a><a name="idd1e8527"></a><a name="idd1e8532"></a><a name="idd1e8535"></a><a name="idd1e8544"></a><a name="idd1e8552"></a><a name="idd1e8555"></a><a name="idd1e8560"></a><a name="idd1e8566"></a>Printable character literals are written by enclosing the character within single quotation marks:</p>
<pre>
     'a'         '2'         ','         ' ' // <span class="docEmphItalicAlt">blank</span>
</pre><br>
<p class="docText">Such literals are of type <tt>char</tt>. We can obtain a wide-character literal of type <tt>wchar_t</tt> by immediately preceding the character literal with an <tt>L</tt>, as in</p>
<pre>
     L'a'
</pre><br>

<a name="ch02lev2sec6"></a>
<h4 class="docSection2Title">Escape Sequences for Nonprintable Characters</H4>
<p class="docText">Some characters are <b><a name="ch02term35"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_35">nonprintable</a></b>. A nonprintable character is a character for which there is no visible image, such as backspace or a control character. Other characters have special meaning in the language, such as the single and double quotation marks, and the backslash. Nonprintable characters and special characters are written using an <B><a name="ch02term20"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_20">escape sequence</a></b>. An escape sequence begins with a backslash. The language defines the following escape sequences:</P>
<p><table cellspacing="0" FRAME="void" RULES="none" cellpadding="5"><colgroup><col width="125"><col width="125"><col width="125"><col width="125"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText">newline</P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>\n</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">horizontal tab</P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>\t</tt></P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText">vertical tab</P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>\v</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">backspace</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>\b</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">carriage return</P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>\r</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">formfeed</P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>\f</tt></p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText">alert (bell)</p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>\a</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">backslash</P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>\\</tt></p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText">question mark</p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>\?</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">single quote</P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>\'</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">double quote</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>\"</tt></p></td><td class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top">&nbsp;</td></TR></table></p><br>
<p class="docText">We can write any character as a generalized escape sequence of the form</P>
<pre>
     \ooo
</pre><BR>
<p class="docText">where <tt>ooo</tt> represents a sequence of as many as three octal digits. The value of the octal digits represents the numerical value of the character. The following examples are representations of literal constants using the ASCII character set:</p>
<pre>
     \7 (<span class="docEmphasis">bell</span>)      \12 (<span class="docEmphasis">newline</span>)     \40 (<span class="docEmphasis">blank</span>)
     \0 (<span class="docEmphasis">null</span>)      \062 (<span class="docEmphasis">'2'</span>)        \115 (<span class="docEmphasis">'M'</span>)
</pre><br>
<p class="docText">The character represented by '<tt>\0'</tt> is often called a &quot;null character,&quot; and has special significance, as we shall soon see.</p>
<p class="docText">We can also write a character using a hexadecimal escape sequence</p>
<pre>
     \xddd
</pre><br>
<p class="docText">consisting of a backslash, an <tt>x</tt>, and one or more hexadecimal digits.</P>

<a name="ch02lev2sec7"></a>
<h4 class="docSection2Title">Character String Literals</H4>
<p class="docText">All of the literals we've seen so far have primitive built-in types. There is one additional literalstring literalthat is more complicated. String literals are <B><a name="ch02term4"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_04"><span class="docEmphasis">arrays</span></a></b> of constant characters, a type that we'll discuss in more detail in <a class="docLink" href="ch04lev1sec3.html#ch04lev1sec3">Section 4.3</a> (p. <a class="docLink" href="ch04lev1sec3.html#ch04lev1sec3">130</a>).</p>
<p class="docText">String literal constants are written as zero or more characters enclosed in double quotation marks. Nonprintable characters are represented by their underlying escape sequence.</p>
<pre>
     "Hello World!"                 // <span class="docEmphItalicAlt">simple string literal</span>
     ""                             // <span class="docEmphItalicAlt">empty string literal</span>
     "\nCC\toptions\tfile.[cC]\n"   // <span class="docEmphItalicAlt">string literal using newlines and tabs</span>
</pre><br>
<p class="docText"><a name="idd1e8854"></a><a name="idd1e8859"></a><a name="idd1e8864"></a>For compatibility with C, string literals in C++ have one character in addition to those typed in by the programmer. Every string literal ends with a null character added by the compiler. A character literal</P>
<pre>
     'A' // <span class="docEmphItalicAlt">single quote: character literal</span>
</pre><BR>
<p class="docText">represents the single character <tt>A</tt>, whereas</p>
<pre>
     "A" // <span class="docEmphItalicAlt">double quote: character string literal</span>
</pre><br>
<p class="docText">represents an array of two characters: the letter <tt>A</tt> and the null character.</p>
<p class="docText">Just as there is a wide character literal, such as</p>
<pre>
        L'a'
</pre><BR>
<p class="docText">there is a wide string literal, again preceded by <tt>L</tt>, such as</p>
<pre>
      L"a wide string literal"
</pre><br>
<p class="docText">The type of a wide string literal is an array of constant wide characters. It is also terminated by a wide null character.</P>

<a name="ch02lev2sec8"></a>
<h4 class="docSection2Title">Concatenated String Literals</h4>
<p class="docText">Two string literals (or two wide string literals) that appear adjacent to one another and separated only by spaces, tabs, or newlines are concatenated into a single new string literal. This usage makes it easy to write long literals across separate lines:</P>
<pre>
     // <span class="docEmphItalicAlt">concatenated long string literal</span>
     std::cout &lt;&lt; "a multi-line "
                  "string literal "
                  "using concatenation"
               &lt;&lt; std::endl;
</pre><br>
<p class="docText">When executed this statement would print:</P>
<pre>
     <span class="docEmphStrong">a multi-line string literal using concatenation</span>
</pre><br>
<p class="docText">What happens if you attempt to concatenate a string literal and a wide string literal? For example:</p>
<pre>
     // <span class="docEmphItalicAlt">Concatenating plain and wide character strings is undefined</span>
     std::cout &lt;&lt; "multi-line " L"literal " &lt;&lt; std::endl;
</pre><br>
<p class="docText">The result is <b><a name="ch02term57"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_57">undefined</a></b>that is, there is no standard behavior defined for concatenating the two different types. The program might appear to work, but it also might crash or produce garbage values. Moreover, the program might behave differently under one compiler than under another.</p>
<a name="ch02sb04"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Advice: Don't Rely on Undefined Behavior</h2>
<p class="docText"><a name="idd1e8977"></a><a name="idd1e8982"></a><a name="idd1e8985"></a><span class="docEmphStrong">Programs that use undefined behavior are in error. If they work, it is only by coincidence. Undefined behavior results from a program error that the compiler cannot detect or from an error that would be too much trouble to detect.</span></p>
<p class="docText"><span class="docEmphStrong">Unfortunately, programs that contain undefined behavior can appear to execute correctly in some circumstances and/or on one compiler. There is no guarantee that the same program, compiled under a different compiler or even a subsequent release of the current compiler, will continue to run correctly. Nor is there any guarantee that what works with one set of inputs will work with another.</span></p>
<p class="docText"><span class="docEmphStrong">Programs should not (knowingly) rely on undefined behavior. Similarly, programs usually should not rely on machine-dependent behavior, such as assuming that the size of an <tt>int</tt> is a fixed and known value. Such programs are said to be <span class="docEmphasis">nonportable</span>. When the program is moved to another machine, any code that relies on machine-dependent behavior may have to be found and corrected. Tracking down these sorts of problems in previously working programs is, mildly put, a profoundly unpleasant task.</span></p>
</TD></TR></table></p><BR>

<a name="ch02lev2sec9"></a>
<h4 class="docSection2Title">Multi-Line Literals</h4>
<p class="docText">There is a more primitive (and less useful) way to handle long strings that depends on an infrequently used program formatting feature: Putting a backslash as the last character on a line causes that line and the next to be treated as a single line.</P>
<p class="docText">As noted on page <a class="docLink" href="ch01lev1sec4.html#ch01sb06">14</a>, C++ programs are largely free-format. In particular, there are only a few places that we may not insert whitespace. One of these is in the middle of a word. In particular, we may not break a line in the middle of a word. We can circumvent this rule by using a backslash:</P>
<pre>
      // <span class="docEmphItalicAlt">ok: A \ before a newline ignores the line break</span>
      std::cou\
      t &lt;&lt; "Hi" &lt;&lt; st\
      d::endl;
</pre><br>
<p class="docText">is equivalent to</p>
<pre>
      std::cout &lt;&lt; "Hi" &lt;&lt; std::endl;
</pre><br>
<p class="docText">We could use this feature to write a long string literal:</p>
<pre>
           // <span class="docEmphItalicAlt">multiline string literal</span>
           std::cout &lt;&lt; "a multi-line \
      string literal \
      using a backslash"
                    &lt;&lt; std::endl;
          return 0;
      }
</pre><br>
<p class="docText">Note that the backslash must be the last thing on the lineno comments or trailing blanks are allowed. Also, any leading spaces or tabs on the subsequent lines are part of the literal. For this reason, the continuation lines of the long literal do not have the normal indentation.</P>
<a name="ch02sb05"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<h2 class="docSidebarTitle">Exercises Section 2.2</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch02qa2q1"></a><b>Exercise 2.7:</b></td><td><p class="docText"><a name="idd1e9069"></a>Explain the difference between the following sets of literal constants:</p>
<pre>
  (a) 'a',L 'a',"a",L"a"
  (b) 10, 10u, 10L, 10uL, 012, 0xC
  (c) 3.14, 3.14f, 3.14L
</pre><BR>
</td></tr><TR valign="top"><td align="right" class="docText" width="50"><a name="ch02qa2q2"></a><b>Exercise 2.8:</b></TD><td><p class="docText">Determine the type of each of these literal constants:</P>
<pre>
      (a) -10 (b) -10u (c) -10. (d) -10e-2
</pre><br>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa2q3"></a><b>Exercise 2.9:</b></td><td><p class="docText">Which, if any, of the following are illegal?</p>
<pre>
      (a) "Who goes with F\145rgus?\012"
      (b) 3.14e1L          (c) "two" L"some"
      (d) 1024f            (e) 3.14UL
      (f) "multiple line
           comment"
</pre><br>
</td></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch02qa2q4"></a><B>Exercise 2.10:</b></td><TD><p class="docText">Using escape sequences, write a program to print <tt>2M</tt> followed by a newline. Modify the program to print <tt>2</tt>, then a tab, then an <tt>M</tt>, followed by a newline.</p>
</td></TR></table></P>
</blockquote>
</td></tr></table></p><br>


<a href="21001535.html"><img src="images/pixel.gif" alt="" width="1" height="1" border="0"></a><ul></UL></td></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch02lev1sec1.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch02lev1sec3.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>