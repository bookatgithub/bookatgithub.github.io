<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 2.3.&nbsp; Variables</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch02lev1sec2.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch02lev1sec4.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch02lev1sec3"></a>
<h3 class="docSection1Title">2.3. Variables</h3>
<p class="docText">Imagine that we are given the problem of computing 2 to the power of 10. Our first attempt might be something like</P>
<pre>
      #include &lt;iostream&gt;
      int main()
      {
          // <span class="docEmphItalicAlt">a first, not very good, solution</span>
          std::cout &lt;&lt; "2 raised to the power of 10: ";
          std::cout &lt;&lt; 2*2*2*2*2*2*2*2*2*2;
          std::cout &lt;&lt; std::endl;
          return 0;
      }
</pre><BR>
<p class="docText">This program solves the problem, although we might double- or triple-check to make sure that exactly 10 literal instances of 2 are being multiplied. Otherwise, we're satisfied. Our program correctly generates the answer 1,024.</p>
<p class="docText">We're next asked to compute 2 raised to the power of 17 and then to the power of 23. Changing our program each time is a nuisance. Worse, it proves to be remarkably error-prone. Too often, the modified program produces an answer with one too few or too many instances of 2.</P>
<p class="docText">An alternative to the explicit brute force power-of-2 computation is twofold:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">Use named objects to perform and print each computation.</P></div></LI><li><div style="font-weight:normal"><p class="docList">Use flow-of-control constructs to provide for the repeated execution of a sequence of program statements while a condition is true.</p></div></li></ol></div>
<p class="docText"><a name="idd1e9178"></a><a name="idd1e9181"></a><a name="idd1e9184"></a>Here, then, is an alternative way to compute 2 raised to the power of 10:</p>
<pre>
      #include &lt;iostream&gt;
      int main()
      {
          // <span class="docEmphItalicAlt">local objects of type</span> <span class="docEmphasis">int</span>
          int value = 2;
          int pow = 10;
          int result = 1;
          // <span class="docEmphItalicAlt">repeat calculation of</span> <span class="docEmphasis">result</span> <span class="docEmphItalicAlt">until</span> <span class="docEmphasis">cnt</span> <span class="docEmphItalicAlt">is equal to</span> <span class="docEmphasis">pow</span>
          for (int cnt = 0; cnt != pow; ++cnt)
              result *= value;   // <span class="docEmphasis">result = result * value;</span>
          std::cout &lt;&lt; value
                    &lt;&lt; " raised to the power of "
                    &lt;&lt; pow &lt;&lt; ": \t"
                    &lt;&lt; result &lt;&lt; std::endl;
          return 0;
      }
</pre><br>
<p class="docText"><tt>value, pow, result</tt>, and <tt>cnt</tt> are variables that allow for the storage, modification, and retrieval of values. The <tt>for</tt> loop allows for the repeated execution of our calculation until it's been executed <tt>pow</tt> times.</P>
<a name="ch02sb06"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<h2 class="docSidebarTitle">Exercises Section 2.3</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch02qa3q1"></a><b>Exercise 2.11:</b></td><td><p class="docText">Write a program that prompts the user to input two numbers, the base and exponent. Print the result of raising the base to the power of the exponent.</p>
</TD></tr></table></p>
</blockquote>
</TD></tr></table></p><BR>
<a name="ch02sb07"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<h2 class="docSidebarTitle">Key Concept: Strong Static Typing</h2>
<p class="docText"><span class="docEmphStrong">C++ is a statically typed language, which means that types are checked at compile time. The process by which types are checked is referred to as type-checking.</span></p>
<p class="docText"><span class="docEmphStrong">In most languages, the type of an object constrains the operations that the object can perform. If the type does not support a given operation, then an object of that type cannot perform that operation.</span></p>
<p class="docText"><span class="docEmphStrong">In C++, whether an operation is legal or not is checked at compile time. When we write an expression, the compiler checks that the objects used in the expression are used in ways that are defined by the type of the objects. If not, the compiler generates an error message; an executable file is not produced.</span></p>
<p class="docText"><span class="docEmphStrong">As our programs, and the types we use, get more complicated, we'll see that static <b><a name="ch02term54"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_54">type checking</a></b> helps find bugs in our programs earlier. A consequence of static checking is that the type of every entity used in our programs must be known to the compiler. Hence, we must define the type of a variable before we can use that variable in our programs.</span></p>
</td></tr></table></p><br>
<a name="ch02lev2sec10"></a>
<h4 class="docSection2Title">2.3.1. What Is a Variable?</H4>
<p class="docText"><a name="idd1e9291"></a><a name="idd1e9294"></a>A variable provides us with named storage that our programs can manipulate. Each variable in C++ has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable. C++ programmers tend to refer to variables as &quot;variables&quot; or as &quot;objects&quot; interchangeably.</P>
<a name="ch02lev3sec4"></a>
<h5 class="docSection3Title">Lvalues and Rvalues</H5>
<p class="docText">We'll have more to say about expressions in <a class="docLink" href="ch05.html#ch05">Chapter 5</a>, but for now it is useful to know that there are two kinds of expressions in C++:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList"><B><a name="ch02term32"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_32">lvalue</a></b> (pronounced &quot;ell-value&quot;): An expression that is an lvalue may appear as either the left-hand or right-hand side of an assignment.</P></div></li><li><div style="font-weight:normal"><p class="docList"><b><a name="ch02term42"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_42">rvalue</a></b> (pronounced &quot;are-value&quot;): An expression that is an rvalue may appear on the right- but not left-hand side of an assignment.</p><p class="docList">Variables are lvalues and so may appear on the left-hand side of an assignment. Numeric literals are rvalues and so may not be assigned. Given the variables:</p><pre>
      int units_sold = 0;
      double sales_price = 0, total_revenue = 0;
</pre><BR></div></li></ol></div>
<p class="docText">it is a compile-time error to write either of the following:</P>
<pre>
      // <span class="docEmphItalicAlt">error: arithmetic expression is not an lvalue</span>
      units_sold * sales_price = total_revenue;
      // <span class="docEmphItalicAlt">error: literal constant is not an lvalue</span>
      0 = 1;
</pre><BR>
<p class="docText">Some operators, such as assignment, require that one of their operands be an lvalue. As a result, lvalues can be used in more contexts than can rvalues. The context in which an lvalue appears determines how it is used. For example, in the expression</p>
<pre>
      units_sold = units_sold + 1;
</pre><br>
<p class="docText">the variable <tt>units_sold</tt> is used as the operand to two different operators. The <tt>+</tt> operator cares only about the values of its operands. The value of a variable is the value currently stored in the memory associated with that variable. The effect of the addition is to fetch that value and add one to it.</p>
<p class="docText">The variable <tt>units_sold</tt> is also used as the left-hand side of the <tt>=</tt> operator. The <tt>=</tt> operator reads its right-hand side and writes to its left-hand side. In this expression, the result of the addition is stored in the storage associated with <tt>units_sold;</tt> the previous value in <tt>units_sold</tt> is overwritten.</P>
<a name="ch02note05"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> In the course of the text, we'll see a number of situations in which the use of an rvalue or lvalue impacts the behavior and/or the performance of our programsin particular when passing and returning values from a function.</P></td></tr></table><BR>
</p></div><br>
<a name="ch02sb08"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Exercises Section 2.3.1</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa4q1"></a><b>Exercise 2.12:</b></td><td><p class="docText"><a name="idd1e9412"></a><a name="idd1e9415"></a><a name="idd1e9418"></a><a name="idd1e9421"></a><a name="idd1e9424"></a>Distinguish between an lvalue and an rvalue; show examples of each.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa4q2"></a><B>Exercise 2.13:</b></TD><td><p class="docText">Name one case where an lvalue is required.</P>
</td></tr></table></P>
</blockquote>
</TD></tr></table></p><br>
<a name="ch02sb09"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Terminology: What Is an object?</H2>
<p class="docText"><span class="docEmphStrong">C++ programmers tend to be cavalier in their use of the term <span class="docEmphasis">object</span>. Most generally, an object is a region of memory that has a type. More specifically, evaluating an expression that is an lvalue yields an object.</span></P>
<p class="docText"><span class="docEmphStrong">Strictly speaking, some might reserve the term <span class="docEmphasis">object</span> to describe only variables or values of class types. Others might distinguish between named and unnamed objects, always referring to variables when discussing named objects. Still others distinguish between objects and values, using the term <span class="docEmphasis">object</span> for data that can be changed by the program and using the term <span class="docEmphasis">value</span> for those that are read-only.</span></p>
<p class="docText"><span class="docEmphStrong">In this book, we'll follow the more colloquial usage that an object is a region of memory that has a type. We will freely use <span class="docEmphasis">object</span> to refer to most of the data manipulated by our programs regardless of whether those data have built-in or class type, are named or unnamed, or are data that can be read or written.</span></p>
</td></TR></table></P><br>


<a name="ch02lev2sec11"></a>
<h4 class="docSection2Title">2.3.2. The Name of a Variable</h4>
<p class="docText">The name of a variable, its <b><a name="ch02term24"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_24">identifier</a></b>, can be composed of letters, digits, and the underscore character. It must begin with either a letter or an underscore. Upper- and lowercase letters are distinct: Identifiers in C++ are case-sensitive. The following defines four distinct identifiers:</P>
<pre>
      // <span class="docEmphasis">declares four different</span> int <span class="docEmphasis">variables</span>
      int somename, someName, SomeName, SOMENAME;
</pre><br>
<a name="ch02note06"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><TD valign="top"><p class="docText"> There is no language-imposed limit on the permissible length of a name, but out of consideration for others that will read and/or modify our code, it should not be too long.</p></TD></tr></table><br>
</p></div><br>
<p class="docText">For example,</p>
<pre>
      gosh_this_is_an_impossibly_long_name_to_type
</pre><br>
<p class="docText">is a really bad identifier name.</p>
<a name="ch02lev3sec5"></a>
<h5 class="docSection3Title">C++ Keywords</h5>
<p class="docText">C++ reserves a set of words for use within the language as keywords. Keywords may not be used as program identifiers. <a class="docLink" href="#ch02table02">Table 2.2</a> on the next page lists the complete set of C++ keywords.</p>
<a name="ch02table02"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 2.2. C++ Keywords</h5></caption><colgroup><col width="100"><col width="100"><col width="100"><col width="100"><col width="100"></colgroup><thead></thead><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>asm</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>do</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>if</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>return</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>try</tt></P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>auto</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>double</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>inline</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>short</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>typedef</tt></P></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>bool</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>dynamic_cast</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>int</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>signed</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>typeid</tt></P></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>break</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>else</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>long</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sizeof</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>typename</tt></p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>case</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>enum</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mutable</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>static</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>union</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>catch</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>explicit</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>namespace</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>static_cast</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>unsigned</tt></p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>char</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>export</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>new</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>struct</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>using</tt></P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>class</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>extern</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>operator</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>switch</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>virtual</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>const</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>false</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>private</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>template</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>void</tt></P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>const_cast</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>float</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>protected</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>this</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>volatile</tt></p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>continue</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>for</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>public</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>throw</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>wchar_t</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>default</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>friend</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>register</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>true</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>while</tt></p></TD></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>delete</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>goto</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>reinterpret_cast</tt></p></td><td class="docTableCell" align="left" valign="top">&nbsp;</TD><td class="docTableCell" align="left" valign="top">&nbsp;</td></TR></table></p><br>
<p class="docText">C++ also reserves a number of words that can be used as alternative names for various operators. These alternative names are provided to support character sets <a name="idd1e9917"></a><a name="idd1e9922"></a><a name="idd1e9927"></a>that do not support the standard set of C++ operator symbols. These names, listed in <a class="docLink" href="#ch02table03">Table 2.3</a>, also may not be used as identifiers:</P>
<a name="ch02table03"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 2.3. C++ Operator Alternative Names</h5></caption><colgroup><col width="100"><col width="100"><col width="100"><col width="100"><col width="50"><col width="50"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>and</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>bitand</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>compl</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>not_eq</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>or_eq</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>xor_eq</tt></p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>and_eq</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>bitor</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>not</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>or</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>xor</tt></p></td><td class="docTableCell" align="left" valign="top">&nbsp;</td></TR></table></p><br>
<p class="docText">In addition to the keywords, the standard also reserves a set of identifiers for use in the library. Identifiers cannot contain two consecutive underscores, nor can an identifier begin with an underscore followed immediately by an upper-case letter. Certain identifiersthose that are defined outside a functionmay not begin with an underscore.</P>

<a name="ch02lev3sec6"></a>
<h5 class="docSection3Title">Conventions for Variable Names</h5>
<p class="docText">There are a number of generally accepted conventions for naming variables. Following these conventions can improve the readability of a program.</P>
<ul><LI><p class="docList">A variable name is normally written in lowercase letters. For example, one writes <tt>index</tt>, not <tt>Index</tt> or <tt>INDEX</tt>.</p></li><li><p class="docList">An identifier is given a mnemonic namethat is, a name that gives some indication of its use in a program, such as <tt>on_loan</tt> or <tt>salary</tt>.</p></li><li><p class="docList">An identifier containing multiple words is written either with an underscore between each word or by capitalizing the first letter of each embedded word. For example, one generally writes <tt>student_loan</tt> or <tt>studentLoan</tt>, not <tt>studentloan</tt>.</p></li></ul>
<a name="ch02note07"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><TD valign="top"><p class="docText"><a name="idd1e10080"></a><a name="idd1e10083"></a><a name="idd1e10088"></a><a name="idd1e10091"></a><a name="idd1e10096"></a><a name="idd1e10099"></a><a name="idd1e10102"></a><a name="idd1e10105"></a><a name="idd1e10110"></a> The most important aspect of a naming convention is that it be applied consistently.</P></td></TR></table><br>
</p></div><BR>
<a name="ch02sb10"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 2.3.2</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><td align="right" class="docText" width="50"><a name="ch02qa5q1"></a><B>Exercise 2.14:</b></TD><td><p class="docText">Which, if any, of the following names are invalid? Correct each identified invalid name.</p>
<pre>
      (a) int double = 3.14159;        (b) char _;
      (c) bool catch-22;               (d) char 1_or_2 ='1';
      (e) float Float = 3.14f;
</pre><br>
</TD></TR></table></p>
</blockquote>
</td></tr></table></p><BR>


<a name="ch02lev2sec12"></a>
<h4 class="docSection2Title">2.3.3. Defining Objects</h4>
<p class="docText">The following statements define five variables:</P>
<pre>
      int units_sold;
      double sales_price, avg_price;
      std::string title;
      Sales_item curr_book;
</pre><br>
<p class="docText">Each definition starts with a <b><a name="ch02term55"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_55">type specifier</a></b>, followed by a comma-separated list of one or more names. A semicolon terminates the definition. The type specifier names the type associated with the object: <tt>int, double, std::string</tt>, and <tt>Sales_item</tt> are all names of types. The types <tt>int</tt> and <tt>double</tt> are built-in types, <tt>std::string</tt> is a type defined by the library, and <tt>Sales_item</tt> is a type that we used in <a class="docLink" href="ch01lev1sec5.html#ch01lev1sec5">Section 1.5</a> (p. <a class="docLink" href="ch01lev1sec5.html#ch01lev1sec5">20</a>)and will define in subsequent chapters. The type determines the amount of storage that is allocated for the variable and the set of operations that can be performed on it.</P>
<p class="docText">Multiple variables may be defined in a single statement:</p>
<pre>
      double salary, wage;    // <span class="docEmphasis">defines two variables of type</span> double
      int month,
          day, year;          // <span class="docEmphasis">defines three variables of type</span> int
      std::string address;    // <span class="docEmphasis">defines one variable of type</span> std::string
</pre><BR>
<a name="ch02lev3sec7"></a>
<h5 class="docSection3Title">Initialization</h5>
<p class="docText">A definition specifies a variable's type and identifier. A definition may also provide an initial value for the object. An object defined with a specified first value is spoken of as <b><a name="ch02term26"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_26">initialized</a></b>. C++ supports two forms of <span class="docEmphRoman"><a name="ch02term60"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_60">variable initialization</a></span>: <b><a name="ch02term12"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_12">copy-initialization</a></b> and <b><a name="ch02term17"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_17">direct-initialization</a></b>. The copy-initialization syntax uses the equal (<tt>=</tt>) symbol; direct-initialization places the initializer in parentheses:</p>
<pre>
      int ival(1024);     // <span class="docEmphasis">direct-initialization</span>
      int ival = 1024;    // <span class="docEmphasis">copy-initialization</span>
</pre><br>
<p class="docText"><a name="idd1e10248"></a><a name="idd1e10253"></a><a name="idd1e10256"></a>In both cases, <tt>ival</tt> is initialized to <tt>1024</tt>.</p>
<a name="ch02note08"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> Although, at this point in the book, it may seem obscure to the reader, in C++ it is essential to understand that initialization is not assignment. Initialization happens when a variable is created and gives that variable its initial value. Assignment involves obliterating an object's current value and replacing that value with a new one.</P></TD></tr></table><BR>
</p></div><br>
<p class="docText">Many new C++ programmers are confused by the use of the <tt>=</tt> symbol to initialize a variable. It is tempting to think of initialization as a form of assignment. But initialization and assignment are different operations in C++. This concept is particularly confusing because in many other languages the distinction is irrelevant and can be ignored. Moreover, even in C++ the distinction rarely matters until one attempts to write fairly complex classes. Nonetheless, it is a crucial concept and one that we will reiterate throughout the text.</P>
<a name="ch02note09"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> There are subtle differences between copy- and direct-initialization when initializing objects of a class type. We won't completely explain these differences until <a class="docLink" href="ch13.html#ch13">Chapter 13</a>. For now, it's worth knowing that the direct syntax is more flexible and can be slightly more efficient.</p></TD></tr></table><BR>
</P></div><br>

<a name="ch02lev3sec8"></a>
<h5 class="docSection3Title">Using Multiple Initializers</h5>
<p class="docText">When we initialize an <span class="docEmphRoman"><a name="ch02term36"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_36">object</a></span> of a built-in type, there is only one way to do so: We supply a value, and that value is copied into the newly defined object. For built-in types, there is little difference between the direct and the copy forms of initialization.</P>
<p class="docText">For objects of a class type, there are initializations that can be done only using direct-initialization. To understand why, we need to know a bit about how classes control initialization.</P>
<p class="docText">Each class may define one or more special member functions (<a class="docLink" href="ch01lev1sec5.html#ch01lev2sec10">Section 1.5.2</a>, p. <a class="docLink" href="ch01lev1sec5.html#ch01lev2sec10">24</a>) that say how we can initialize variables of the class type. The member functions that define how initialization works are known as <b><a name="ch02term11"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_11">constructors</a></b>. Like any function, a constructor can take multiple arguments. A class may define several constructors, each of which must take a different number or type of arguments.</p>
<p class="docText">As an example, we'll look a bit at the <tt>string</tt> class, which we'll cover in more detail in <a class="docLink" href="ch03.html#ch03">Chapter 3</a>. The <tt>string</tt> type is defined by the library and holds character strings of varying sizes. To use <tt>string</tt>s, we must include the <tt>string</tt> header. Like the IO types, <tt>string</tt> is defined in the <tt>std</tt> namespace.</p>
<p class="docText">The <tt>string</tt> class defines several constructors, giving us various ways to initialize a <tt>string</tt>. One way we can initialize a <tt>string</tt> is as a copy of a character string literal:</p>
<pre>
      #include &lt;string&gt;
      // <span class="docEmphItalicAlt">alternative ways to initialize</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">from a character string literal</span>
      std::string titleA = "C++ Primer, 4th Ed.";
      std::string titleB("C++ Primer, 4th Ed.");
</pre><BR>
<p class="docText"><a name="idd1e10378"></a><a name="idd1e10383"></a>In this case, either initialization form can be used. Both definitions create a <tt>string</tt> object whose initial value is a copy of the specified string literal.</p>
<p class="docText">However, we can also initialize a <tt>string</tt> from a count and a character. Doing so creates a <tt>string</tt> containing the specified character repeated as many times as indicated by the count:</p>
<pre>
      std::string all_nines(10, '9');   // all_nines= <span class="docEmphasis">"9999999999"</span>
</pre><BR>
<p class="docText">In this case, the only way to initialize <tt>all_nines</tt> is by using the direct form of initialization. It is not possible to use copy-initialization with multiple initializers.</p>

<a name="ch02lev3sec9"></a>
<h5 class="docSection3Title">Initializing Multiple Variables</H5>
<p class="docText">When a definition defines two or more variables, each variable may have its own initializer. The name of an object becomes visible immediately, and so it is possible to initialize a subsequent variable to the value of one defined earlier in the same definition. Initialized and uninitialized variables may be defined in the same definition. Both forms of initialization syntax may be intermixed:</p>
<pre>
      #include &lt;string&gt;
      // <span class="docEmphasis">ok:</span> salary <span class="docEmphasis">defined and initialized before it is used to initialize</span> wage
      double salary = 9999.99,
            wage(salary + 0.01);
      // <span class="docEmphasis">ok: mix of initialized and uninitialized</span>
      int interval,
          month = 8, day = 7, year = 1955;
      // <span class="docEmphasis">ok: both forms of initialization syntax used</span>
      std::string title("C++ Primer, 4th Ed."),
                  publisher = "A-W";
</pre><BR>
<p class="docText">An object can be initialized with an arbitrarily complex expression, including the return value of a function:</p>
<pre>
      double price = 109.99, discount = 0.16;
      double sale_price = apply_discount(price, discount);
</pre><br>
<p class="docText">In this example, <tt>apply_discount</tt> is a function that takes two values of type <tt>double</tt> and returns a value of type <tt>double</tt>. We pass the variables <tt>price</tt> and <tt>discount</tt> to that function and use its return value to initialize <tt>sale_price</tt>.</p>


<a name="ch02lev2sec13"></a>
<h4 class="docSection2Title">2.3.4. Variable Initialization Rules</h4>
<p class="docText">When we define a variable without an initializer, the system sometimes initializes the variable for us. What value, if any, is supplied depends on the type of the variable and may depend on where it is defined.</p>
<a name="ch02lev3sec10"></a>
<h5 class="docSection3Title">Initialization of Variables of Built-in Type</h5>
<p class="docText">Whether a variable of built-in type is automatically initialized depends on where it is defined. Variables defined outside any function body are initialized to zero. <a name="idd1e10489"></a><a name="idd1e10494"></a><a name="idd1e10499"></a><a name="idd1e10504"></a>Variables of built-in type defined inside the body of a function are <b><a name="ch02term58"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_58">uninitialized</a></b>. Using an uninitialized variable for anything other than as the left-hand operand of an assignment is undefined. Bugs due to uninitialized variables can be hard to find. As we cautioned on page <a class="docLink" href="ch02lev1sec2.html#ch02sb04">42</a>, you should never rely on undefined behavior.</p>
<a name="ch02sb11"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Exercises Section 2.3.3</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><td align="right" class="docText" width="50"><a name="ch02qa6q1"></a><b>Exercise 2.15:</b></TD><TD><p class="docText">What, if any, are the differences between the following definitions:</p>
<pre>
      int month = 9, day = 7;

      int month = 09, day = 07;
</pre><br>
<p class="docText">If either definition contains an error, how might you correct the problem?</p>
</td></tr><TR valign="top"><td align="right" class="docText" width="50"><a name="ch02qa6q3"></a><B>Exercise 2.16:</b></TD><td><p class="docText">Assuming <tt>calc</tt> is a function that returns a <tt>double</tt>, which, if any, of the following are illegal definitions? Correct any that are identified as illegal.</p>
<pre>
     (a) int car = 1024, auto = 2048;
     (b) int ival = ival;
     (c) std::cin &gt;&gt; int input_value;
     (d) double salary = wage = 9999.99;
     (e) double calc = calc();
</pre><br>
</TD></TR></table></p>
</blockquote>
</td></tr></table></p><BR>
<a name="ch02note10"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><td valign="top"><p class="docText"> We recommend that every object of built-in type be initialized. It is not always necessary to initialize such variables, but it is easier and safer to do so until you can be certain it is safe to omit an initializer.</P></td></TR></table><br>
</p></div><br>
<a name="ch02sb12"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Caution: Uninitialized Variables Cause Run-Time Problems</h2>
<p class="docText"><span class="docEmphStrong">Using an uninitialized object is a common program error, and one that is often difficult to uncover. The compiler is not required to detect a use of an uninitialized variable, although many will warn about at least some uses of uninitialized variables. However, no compiler can detect all uses of uninitialized variables.</span></p>
<p class="docText"><span class="docEmphStrong">Sometimes, we're lucky and using an uninitialized variable results in an immediate crash at run time. Once we track down the location of the crash, it is usually pretty easy to see that the variable was not properly initialized.</span></p>
<p class="docText"><span class="docEmphStrong">Other times, the program completes but produces erroneous results. Even worse, the results can appear correct when we run our program on one machine but fail on another. Adding code to the program in an unrelated location can cause what we thought was a correct program to suddenly start to produce incorrect results.</span></p>
<p class="docText"><span class="docEmphStrong">The problem is that uninitialized variables actually do have a value. The compiler puts the variable somewhere in memory and treats whatever bit pattern was in that memory as the variable's initial state. When interpreted as an integral value, any bit pattern is a legitimate valuealthough the value is unlikely to be one that the programmer intended. Because the value is legal, using it is unlikely to lead to a crash. What it is likely to do is lead to incorrect execution and/or incorrect calculation.</span></p>
</td></TR></table></P><br>

<a name="ch02lev3sec11"></a>
<H5 class="docSection3Title">Initialization of Variables of Class Type</h5>
<p class="docText"><a name="idd1e10606"></a><a name="idd1e10611"></a><a name="idd1e10616"></a><a name="idd1e10619"></a><a name="idd1e10622"></a><a name="idd1e10628"></a><a name="idd1e10631"></a><a name="idd1e10636"></a>Each class defines how objects of its type can be initialized. Classes control object initialization by defining one or more constructors (<a class="docLink" href="#ch02lev2sec12">Section 2.3.3</a>, p. <a class="docLink" href="#ch02lev2sec12">49</a>). As an example, we know that the <tt>string</tt> class provides at least two constructors. One of these constructors lets us initialize a <tt>string</tt> from a character string literal and another lets us initialize a <tt>string</tt> from a character and a count.</p>
<p class="docText">Each class may also define what happens if a variable of the type is defined but an initializer is not provided. A class does so by defining a special constructor, known as the <B><a name="ch02term15"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_15">default constructor</a></b>. This constructor is called the default constructor because it is run &quot;by default;&quot; if there is no initializer, then this constructor is used. The default constructor is used regardless of where a variable is defined.</P>
<p class="docText">Most classes provide a default constructor. If the class has a default constructor, then we can define variables of that class without explicitly initializing them. For example, the <tt>string</tt> type defines its default constructor to initialize the <tt>string</tt> as an empty stringthat is, a string with no characters:</p>
<pre>
      std::string empty;  // <span class="docEmphasis">empty</span> <span class="docEmphItalicAlt">is the empty string;</span> <span class="docEmphasis">empty =""</span>
</pre><br>
<p class="docText">Some class types do not have a default constructor. For these types, every definition must provide explicit initializer(s). It is not possible to define variables of such types without giving an initial value.</p>
<a name="ch02sb13"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Exercises Section 2.3.4</H2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa7q1"></a><b>Exercise 2.17:</b></TD><TD><p class="docText">What are the initial values, if any, of each of the following variables?</p>
<pre>
      std::string global_str;
      int global_int;
      int main()
      {
          int local_int;
          std::string local_str;
          // ...
          return 0;
      }
</pre><br>
</td></tr></table></P>
</blockquote>
</td></tr></table></P><br>


<a name="ch02lev2sec14"></a>
<h4 class="docSection2Title">2.3.5. Declarations and Definitions</H4>
<p class="docText">As we'll see in <a class="docLink" href="ch02lev1sec9.html#ch02lev1sec9">Section 2.9</a> (p. <a class="docLink" href="ch02lev1sec9.html#ch02lev1sec9">67</a>), C++ programs typically are composed of many files. In order for multiple files to access the same variable, C++ distinguishes between declarations and definitions.</p>
<p class="docText">A <B><a name="ch02term16"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_16">definition</a></b> of a variable allocates storage for the variable and may also specify an initial value for the variable. There must be one and only one definition of a variable in a program.</p>
<p class="docText">A <b><a name="ch02term14"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_14">declaration</a></b> makes known the type and name of the variable to the program. A definition is also a declaration: When we define a variable, we declare its name <a name="idd1e10749"></a>and type. We can declare a name without defining it by using the <tt>extern</tt> keyword. A declaration that is not also a definition consists of the object's name and its type preceded by the keyword <tt>extern</tt>:</p>
<pre>
      extern int i;   // <span class="docEmphItalicAlt">declares but does not define</span> <span class="docEmphasis">i</span>
      int i;          //  <span class="docEmphItalicAlt">declares and defines</span> <span class="docEmphasis">i</span>
</pre><br>
<p class="docText">An <tt>extern</tt> declaration is <span class="docEmphasis">not</span> a definition and does not allocate storage. In effect, it claims that a definition of the variable exists elsewhere in the program. A variable can be declared multiple times in a program, but it must be defined only once.</p>
<p class="docText">A declaration may have an initializer only if it is also a definition because only a definition allocates storage. The initializer must have storage to initialize. If an initializer is present, the declaration is treated as a definition even if the declaration is labeled <tt>extern</tt>:</p>
<pre>
      extern double pi = 3.1416; // <span class="docEmphItalicAlt">definition</span>
</pre><br>
<p class="docText">Despite the use of <tt>extern</tt>, this statement defines <tt>pi</tt>. Storage is allocated and initialized. An <tt>extern</tt> declaration may include an initializer only if it appears outside a function.</p>
<p class="docText">Because an <tt>extern</tt> that is initialized is treated as a definition, any subseqent definition of that variable is an error:</p>
<pre>
      extern double pi = 3.1416; // <span class="docEmphItalicAlt">definition</span>
      double pi;                 // <span class="docEmphItalicAlt">error: redefinition of</span> <span class="docEmphasis">pi</span>
</pre><br>
<p class="docText">Similarly, a subsequent <tt>extern</tt> declaration that has an initializer is also an error:</p>
<pre>
      extern double pi = 3.1416; // <span class="docEmphItalicAlt">definition</span>
      extern double pi;          // <span class="docEmphItalicAlt">ok: declaration not definition</span>
      extern double pi = 3.1416; // <span class="docEmphItalicAlt">error: redefinition of</span> <span class="docEmphasis">pi</span>
</pre><br>
<p class="docText">The distinction between a declaration and a definition may seem pedantic but in fact is quite important.</p>
<a name="ch02note11"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><td valign="top"><p class="docText"> In C++ a variable must be defined exactly once and must be defined or declared before it is used.</p></TD></TR></table><br>
</p></div><br>
<p class="docText">Any variable that is used in more than one file requires declarations that are separate from the variable's definition. In such cases, one file will contain the definition for the variable. Other files that use that same variable will contain declarations forbut not a definition ofthat same variable.</p>
<a name="ch02sb14"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<H2 class="docSidebarTitle">Exercises Section 2.3.5</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa8q1"></a><B>Exercise 2.18:</b></TD><td><p class="docText">Explain the meaning of each of these instances of <tt>name</tt>:</p>
<pre>
      extern std::string name;
      std::string name("exercise 3.5a");
      extern std::string name("exercise 3.5a");
</pre><br>
</td></TR></table></p>
</blockquote>
</td></TR></table></p><br>

<a name="ch02lev2sec15"></a>
<H4 class="docSection2Title">2.3.6. Scope of a Name</h4>
<p class="docText"><a name="idd1e10913"></a><a name="idd1e10916"></a><a name="idd1e10919"></a><a name="idd1e10922"></a><a name="idd1e10927"></a>Every name in a C++ program must refer to a unique entity (such as a variable, function, type, etc.). Despite this requirement, names can be used more than once in a program: A name can be reused as long as it is used in different contexts, from which the different meanings of the name can be distinguished. The context used to distinguish the meanings of names is a <B><a name="ch02term43"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_43">scope</a></b>. A scope is a region of the program. A name can refer to different entities in different scopes.</p>
<p class="docText">Most scopes in C++ are delimited by curly braces. Generally, names are visible from their point of declaration until the end the scope in which the declaration appears. As an example, consider this program, which we first encountered in <a class="docLink" href="ch01lev1sec4.html#ch01lev2sec6">Section 1.4.2</a> (p. <a class="docLink" href="ch01lev1sec4.html#ch01lev2sec6">14</a>):</p>
<pre>
      #include &lt;iostream&gt;
      int main()
      {
          int sum = 0;
          //  <span class="docEmphItalicAlt">sum values from 1 up to 10 inclusive</span>
          for (int val = 1; val &lt;= 10; ++val)
              sum += val;   // <span class="docEmphItalicAlt">equivalent to</span> <span class="docEmphasis">sum = sum + val</span>

          std::cout &lt;&lt; "Sum of 1 to 10 inclusive is "
                    &lt;&lt; sum &lt;&lt; std::endl;
          return 0;
      }
</pre><br>
<p class="docText">This program defines three names and uses two names from the standard library. It defines a function named <tt>main</tt> and two variables named <tt>sum</tt> and <tt>val</tt>. The name <tt>main</tt> is defined outside any curly braces and is visible throughout the program. Names defined outside any function have <b><a name="ch02term21"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_21">global scope</a></b>; they are accessible from anywhere in the program. The name <tt>sum</tt> is defined within the scope of the <tt>main</tt> function. It is accessible throughout the <tt>main</tt> function but not outside of it. The variable <tt>sum</tt> has <b><a name="ch02term31"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_31">local scope</a></b>. The name <tt>val</tt> is more interesting. It is defined in the scope of the <tt>for</tt> statement (<a class="docLink" href="ch01lev1sec4.html#ch01lev2sec6">Section 1.4.2</a>, p. <a class="docLink" href="ch01lev1sec4.html#ch01lev2sec6">14</a>). It can be used in that statement but not elsewhere in <tt>main</tt>. It has <span class="docEmphStrong">statement scope</span>.</p>
<a name="ch02lev3sec12"></a>
<h5 class="docSection3Title">Scopes in C++ Nest</h5>
<p class="docText">Names defined in the global scope can be used in a local scope; global names and those defined local to a function can be used inside a statement scope, and so on. Names can also be redefined in an inner scope. Understanding what entity a name refers to requires unwinding the scopes in which the names are defined:</p>
<pre>
      #include &lt;iostream&gt;
      #include &lt;string&gt;
      /*  <span class="docEmphItalicAlt">Program for illustration purposes only:</span>
       *  <span class="docEmphItalicAlt">It is bad style for a function to use a global variable and then</span>
       *  <span class="docEmphItalicAlt">define a local variable with the same name</span>
       */
      std::string s1 = "hello";  // <span class="docEmphasis">s1</span> <span class="docEmphItalicAlt">has global scope</span>
      int main()
      {
          std::string s2 = "world"; // <span class="docEmphasis">s2</span> <span class="docEmphItalicAlt">has local scope</span>
          // <span class="docEmphItalicAlt">uses global</span> <span class="docEmphasis">s1;</span> <span class="docEmphItalicAlt">prints</span> <span class="docEmphasis">"hello world"</span>
          std::cout &lt;&lt; s1 &lt;&lt; " " &lt;&lt; s2 &lt;&lt; std::endl;
          int s1 = 42; // <span class="docEmphasis">s1</span> <span class="docEmphItalicAlt">is local and hides global</span> <span class="docEmphasis">s1</span>
          // <span class="docEmphItalicAlt">uses local</span> <span class="docEmphasis">s1</span>;<span class="docEmphItalicAlt">prints</span> <span class="docEmphasis">"42 world"</span>
          std::cout &lt;&lt; s1 &lt;&lt; " " &lt;&lt; s2 &lt;&lt; std::endl;
          return 0;
      }
</pre><br>
<p class="docText"><a name="idd1e11083"></a>This program defines three variables: a global <tt>string</tt> named <tt>s1</tt>, a local <tt>string</tt> named <tt>s2</tt>, and a local <tt>int</tt> named <tt>s1</tt>. The definition of the local <tt>s1</tt> <span class="docEmphasis">hides</span> the global <tt>s1</tt>.</p>
<p class="docText">Variables are visible from their point of declaration. Thus, the local definition of <tt>s1</tt> is not visible when the first output is performed. The name <tt>s1</tt> in that output expression refers to the global <tt>s1</tt>. The output printed is <tt>hello world</tt>. The second statement that does output follows the local definition of <tt>s1</tt>. The local <tt>s1</tt> is now in scope. The second output uses the local rather than the global <tt>s1</tt>. It writes <tt>42 world</tt>.</p>
<a name="ch02note12"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><TD valign="top"><p class="docText"> Programs such as the preceeding are likely to be confusing. It is almost always a bad idea to define a local variable with the same name as a global variable that the function uses or might use. It is much better to use a distinct name for the local.</p></td></TR></table><BR>
</p></div><br>
<p class="docText">We'll have more to say about local and global scope in <a class="docLink" href="ch07.html#ch07">Chapter 7</a> and about statement scope in <a class="docLink" href="ch06.html#ch06">Chapter 6</a>. C++ has two other levels of scope: <span class="docEmphStrong">class scope</span>, which we'll cover in <a class="docLink" href="ch12.html#ch12">Chapter 12</a> and <span class="docEmphStrong">namespace scope</span>, which we'll see in <a class="docLink" href="ch17lev1sec2.html#ch17lev1sec2">Section 17.2</a>.</p>


<a name="ch02lev2sec16"></a>
<h4 class="docSection2Title">2.3.7. Define Variables Where They Are Used</h4>
<p class="docText">In general, variable definitions or declarations can be placed anywhere within the program that a statement is allowed. A variable must be declared or defined before it is used.</P>
<a name="ch02note13"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><td valign="top"><p class="docText"> It is usually a good idea to define an object near the point at which the object is first used.</p></TD></TR></table><br>
</p></div><br>
<p class="docText">Defining an object where the object is first used improves readability. The reader does not have to go back to the beginning of a section of code to find the definition of a particular variable. Moreover, it is often easier to give the variable a useful initial value when the variable is defined close to where it is first used.</p>
<p class="docText">One constraint on placing declarations is that variables are accessible from the point of their definition until the end of the enclosing block. A variable must be defined in or before the outermost scope in which the variable will be used.</P>
<a name="ch02sb15"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Exercises Section 2.3.6</h2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch02qa9q1"></a><b>Exercise 2.19:</b></td><td><p class="docText"><a name="idd1e11218"></a><a name="idd1e11221"></a>What is the value of <tt>j</tt> in the following program?</p>
<pre>
      int i = 42;
      int main()
      {
          int i = 100;
          int j = i;
          // ...
      }
</pre><br>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa9q2"></a><b>Exercise 2.20:</b></td><td><p class="docText">Given the following program fragment, what values are printed?</p>
<pre>
      int i = 100, sum = 0;
      for (int i = 0; i != 10; ++i)
           sum += i;
      std::cout &lt;&lt; i &lt;&lt; " " &lt;&lt; sum &lt;&lt; std::endl;
</pre><BR>
</TD></tr><TR valign="top"><td align="right" class="docText" width="50"><a name="ch02qa9q3"></a><b>Exercise 2.21:</b></TD><TD><p class="docText">Is the following program legal?</p>
<pre>
      int sum = 0;
      for (int i = 0; i != 10; ++i)
          sum += i;
      std::cout &lt;&lt; "Sum from 0 to " &lt;&lt; i
                &lt;&lt; " is " &lt;&lt; sum &lt;&lt; std::endl;
</pre><br>
</td></tr></table></p>
</blockquote>
</TD></tr></table></P><BR>


<a href="21001535.html"><img src="images/pixel.gif" alt="" width="1" height="1" border="0"></a><ul></ul></td></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch02lev1sec2.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch02lev1sec4.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>