<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 3.2.&nbsp; Library string Type</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch03lev1sec1.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch03lev1sec3.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch03lev1sec2"></a>
<h3 class="docSection1Title">3.2. Library <tt>string</tt> Type</h3>
<p class="docText">The <tt>string</tt> type supports variable-length character strings. The library takes care of managing the memory associated with storing the characters and provides various useful operations. The library <tt>string</tt> type is intended to be efficient enough for general use.</P>
<p class="docText">As with any library type, programs that use <tt>string</tt>s must first include the associated header. Our programs will be shorter if we also provide an appropriate <tt>using</tt> declaration:</P>
<pre>
     #include &lt;string&gt;
     using std::string;
</pre><br>
<a name="ch03lev2sec2"></a>
<H4 class="docSection2Title">3.2.1. Defining and Initializing <tt>string</tt>s</h4>
<p class="docText">The <tt>string</tt> library provides several constructors (<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec12">Section 2.3.3</a>, p. <a class="docLink" href="ch02lev1sec3.html#ch02lev2sec12">49</a>). A constructor is a special member function that defines how objects of that type can be <a name="idd1e15771"></a><a name="idd1e15779"></a><a name="idd1e15787"></a><a name="idd1e15793"></a><a name="idd1e15802"></a><a name="idd1e15811"></a><a name="idd1e15820"></a><a name="idd1e15829"></a><a name="idd1e15835"></a><a name="idd1e15841"></a><a name="idd1e15847"></a><a name="idd1e15855"></a>initialized. <a class="docLink" href="#ch03table01">Table 3.1</a> on the facing page lists the most commonly used <tt>string</tt> constructors. The default constructor (<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec13">Section 2.3.4</a>, p. <a class="docLink" href="ch02lev1sec3.html#ch02lev2sec13">52</a>) is used &quot;by default&quot; when no initializer is specified.</p>
<a name="ch03table01"></a><P><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 3.1. Ways to Initialize a <tt>string</tt></h5></caption><colgroup><col width="200"><col width="300"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>string s1;</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Default constructor; <tt>s1</tt> is the empty string</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>string s2(s1);</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Initialize <tt>s2</tt> as a copy of <tt>s1</tt></p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>string s3("value");</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Initialize <tt>s3</tt> as a copy of the string literal</p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>string s4(n, 'c');</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Initialize <tt>s4</tt> with <tt>n</tt> copies of the character <tt>'c'</tt></p></td></tr></table></p><br>
<a name="ch03sb02"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Caution: Library <tt>string</tt> Type and String Literals</h2>
<p class="docText"><span class="docEmphStrong">For historical reasons, and for compatibility with C, character string literals are <span class="docEmphasis">not</span> the same type as the standard library <tt>string</tt> type. This fact can cause confusion and is important to keep in mind when using a string literal or the <tt>string</tt> data type.</span></P>
</TD></tr></table></P><br>
<a name="ch03sb03"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<h2 class="docSidebarTitle">Exercises Section 3.2.1</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa2q1"></a><B>Exercise 3.2:</b></td><TD><p class="docText">What is a default constructor?</P>
</td></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch03qa2q2"></a><B>Exercise 3.3:</b></td><td><p class="docText">Name the three ways to initialize a <tt>string</tt>.</p>
</td></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa2q3"></a><B>Exercise 3.4:</b></td><td><p class="docText">What are the values of <tt>s</tt> and <tt>s2</tt>?</P>
<pre>
     string s;
     int main() {
      string s2;
     }
</pre><br>
</TD></tr></table></p>
</blockquote>
</td></tr></table></p><br>

<a name="ch03lev2sec3"></a>
<h4 class="docSection2Title">3.2.2. Reading and Writing <tt>string</tt>s</h4>
<p class="docText">As we saw in <a class="docLink" href="ch01.html#ch01">Chapter 1</a>, we use the <tt>iostream</tt> library to read and write values of built-in types such as <tt>int, double</tt>, and so on. Similarly, we can use the <tt>iostream</tt> and <tt>string</tt> libraries to allow us to read and write <tt>string</tt>s using the standard input and output operators:</p>
<pre>
     // <span class="docEmphItalicAlt">Note:</span> <span class="docEmphasis">#include</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">using</span> <span class="docEmphItalicAlt">declarations must be added to compile this code</span>
     int main()
     {
         string s;          // <span class="docEmphItalicAlt">empty string</span>
         cin &gt;&gt; s;          // <span class="docEmphItalicAlt">read whitespace-separated string into</span> <span class="docEmphasis">s</span>
         cout &lt;&lt; s &lt;&lt; endl; // <span class="docEmphItalicAlt">write</span> <span class="docEmphasis">s</span> <span class="docEmphItalicAlt">to the output</span>
         return 0;
     }
</pre><br>
<p class="docText">This program begins by defining a <tt>string</tt> named <tt>s</tt>. The next line,</p>
<pre>
     cin &gt;&gt; s;        // <span class="docEmphItalicAlt">read whitespace-separated string into</span> <span class="docEmphasis">s</span>
</pre><br>
<p class="docText">reads the standard input storing what is read into <tt>s</tt>. The <tt>string</tt> input operator:</p>
<UL><LI><p class="docList">Reads and discards any leading whitespace (e.g., spaces, newlines, tabs)</p></LI><li><p class="docList">It then reads characters until the next whitespace character is encountered</p></LI></UL>
<p class="docText"><a name="idd1e16152"></a><a name="idd1e16159"></a><a name="idd1e16163"></a><a name="idd1e16170"></a><a name="idd1e16177"></a>So, if the input to this program is &quot;<span class="docEmphStrong"><tt>Hello World!</tt></span>&quot;, (note leading and trailing spaces) then the output will be &quot;<span class="docEmphStrong"><tt>Hello</tt></span>&quot; with no extra spaces.</p>
<p class="docText">The input and output operations behave similarly to the operators on the builtin types. In particular, the operators return their left-hand operand as their result. Thus, we can chain together multiple reads or writes:</p>
<pre>
     string s1, s2;
     cin &gt;&gt; s1 &gt;&gt; s2; // <span class="docEmphItalicAlt">read first input into</span> <span class="docEmphasis">s1</span>, <span class="docEmphItalicAlt">second into</span> <span class="docEmphasis">s2</span>
     cout &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; endl; // <span class="docEmphItalicAlt">write both</span> <span class="docEmphasis">string</span><span class="docEmphItalicAlt">s</span>
</pre><br>
<p class="docText">If we give this version of the program the same input as in the previous paragraph, our output would be</p>
<pre>
     <span class="docEmphStrong">HelloWorld!</span>
</pre><br>
<a name="ch03note03"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></TD><td valign="top"><p class="docText"> To compile this program, you must add <tt>#include</tt> directives for both the <tt>iostream</tt> and <tt>string</tt> libraries and must issue <tt>using</tt> declarations for all the names used from the library: <tt>string, cin, cout</tt>, and <tt>endl</tt>.</p></td></TR></table><BR>
<p class="docText">The programs presented from this point on will assume that the needed <tt>#include</tt> and <tt>using</tt> declarations have been made.</p>
</p></div><br>
<a name="ch03lev3sec2"></a>
<h5 class="docSection3Title">Reading an Unknown Number of <tt>string</tt>s</H5>
<p class="docText">Like the input operators that read built-in types, the <tt>string</tt> input operator returns the stream from which it read. Therefore, we can use a <tt>string</tt> input operation as a condition, just as we did when reading <tt>int</tt>s in the program on page 18. The following program reads a set of <tt>string</tt>s from the standard input and writes what it has read, one <tt>string</tt> per line, to the standard output:</p>
<pre>
     int main()
     {
         string word;
         // <span class="docEmphItalicAlt">read until end-of-file, writing each word to a new line</span>
         while (cin &gt;&gt; word)
             cout &lt;&lt; word &lt;&lt; endl;
         return 0;
     }
</pre><br>
<p class="docText">In this case, we read into a <tt>string</tt> using the input operator. That operator returns the <tt>istream</tt> from which it read, and the <tt>while</tt> condition tests the stream after the read completes. If the stream is validit hasn't hit end-of-file or encountered an invalid inputthen the body of the <tt>while</tt> is executed and the value we read is printed to the standard output. Once we hit end-of-file, we fall out of the <tt>while</tt>.</P>

<a name="ch03lev3sec3"></a>
<h5 class="docSection3Title">Using <tt>getline</tt> to Read an Entire Line</h5>
<p class="docText">There is an additional useful <tt>string</tt> IO operation: <B><a name="ch03term8"></a><a class="docLink" href="ch03lev1sec7.html#gloss03_08"><span class="docEmphStrong"><tt>getline</tt></span></a></b>. This is a function that takes both an input stream and a <tt>string</tt>. The <tt>getline</tt> function reads the <a name="idd1e16348"></a><a name="idd1e16355"></a><a name="idd1e16362"></a><a name="idd1e16369"></a>next line of input from the stream and stores what it read, <span class="docEmphasis">not including</span> the newline, in its <tt>string</tt> argument. Unlike the input operator, <tt>getline</tt> does not ignore leading newlines. Whenever <tt>getline</tt> encounters a newline, even if it is the first character in the input, it stops reading the input and returns. The effect of encountering a newline as the first character in the input is that the <tt>string</tt> argument is set to the empty <tt>string</tt>.</p>
<p class="docText">The <tt>getline</tt> function returns its <tt>istream</tt> argument so that, like the input operator, it can be used as a condition. For example, we could rewrite the previous program that wrote one word per line to write a line at a time instead:</P>
<pre>
     int main()
     {
         string line;
         // <span class="docEmphItalicAlt">read line at time until end-of-file</span>
         while (getline(cin, line))
             cout &lt;&lt; line &lt;&lt; endl;
         return 0;
     }
</pre><br>
<p class="docText">Because <tt>line</tt> does not contain a newline, we must write our own if we want the <tt>string</tt>s written one to a line. As usual, we use <tt>endl</tt> to write a newline and flush the output buffer.</p>
<a name="ch03note04"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> The newline that causes <tt>getline</tt> to return is discarded; it does <span class="docEmphasis">not</span> get stored in the <tt>string</tt>.</p></td></tr></table><br>
</p></div><br>
<a name="ch03sb04"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<H2 class="docSidebarTitle">Exercises Section 3.2.2</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch03qa3q1"></a><b>Exercise 3.5:</b></td><td><p class="docText">Write a program to read the standard input a line at a time. Modify your program to read a word at a time.</p>
</td></TR><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch03qa3q2"></a><B>Exercise 3.6:</b></td><td><p class="docText">Explain how whitespace characters are handled in the <tt>string</tt> input operator and in the <tt>getline</tt> function.</p>
</TD></TR></table></p>
</blockquote>
</td></tr></table></p><BR>


<a name="ch03lev2sec4"></a>
<h4 class="docSection2Title">3.2.3. Operations on <tt>string</tt>s</h4>
<p class="docText"><a class="docLink" href="#ch03table02">Table 3.2</a> on the next page lists the most commonly used <tt>string</tt> operations.</P>
<a name="ch03table02"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 3.2. <tt>string</tt> Operations</H5></caption><colgroup><col width="150"><col width="375"></colgroup><thead></thead><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.empty()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns <tt>true</tt> if <tt>s</tt> is empty; otherwise returns <tt>false</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.size()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns number of characters in <tt>s</tt></p></TD></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>s[n]</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Returns the character at position <tt>n</tt> in <tt>s</tt>; positions start at 0.</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s1 + s2</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Returns a <tt>string</tt> equal to the concatenation of <tt>s1</tt> and <tt>s2</tt></P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s1 = s2</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Replaces characters in <tt>s1</tt> by a copy of <tt>s2</tt></p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>v1 == v2</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Returns <tt>true</tt> if <tt>v1</tt> and <tt>v2</tt> are equal; <tt>false</tt> otherwise</P></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>!=, &lt;, &lt;=</tt>, <br><tt>&gt;, and &gt;=</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Have their normal meanings</p></td></tr></table></p><br>
<a name="ch03lev3sec4"></a>
<h5 class="docSection3Title">The <tt>string size</tt> and <tt>empty</tt> Operations</h5>
<p class="docText">The length of a <tt>string</tt> is the number of characters in the <tt>string</tt>. It is returned by the <tt>size</tt> operation:</P>
<pre>
     int main()
     {
         string st("The expense of spirit\n");
         cout &lt;&lt; "The size of " &lt;&lt; st &lt;&lt; "is " &lt;&lt; st.size()
              &lt;&lt; " characters, including the newline" &lt;&lt; endl;
         return 0;
     }
</pre><BR>
<p class="docText"><a name="idd1e16678"></a><a name="idd1e16682"></a><a name="idd1e16689"></a>If we compile and execute this program it yields</p>
<pre>
     <span class="docEmphStrong">The size of The expense of spirit</span>
     <span class="docEmphStrong">is 22 characters, including the newline</span>
</pre><BR>
<p class="docText">Often it is useful to know whether a <tt>string</tt> is empty. One way we could do so would be to compare <tt>size</tt> with 0:</p>
<pre>
     if (st.size() == 0)
          // <span class="docEmphItalicAlt">ok: empty</span>
</pre><br>
<p class="docText">In this case, we don't really need to know how many characters are in the <tt>string</tt>; we are only interested in whether the <tt>size</tt> is zero. We can more directly answer this question by using the <tt>empty</tt> member:</P>
<pre>
     if (st.empty())
          // <span class="docEmphItalicAlt">ok: empty</span>
</pre><BR>
<p class="docText">The <tt>empty</tt> function returns the <tt>bool</tt> (<a class="docLink" href="ch02lev1sec1.html#ch02lev1sec1">Section 2.1</a>, p. <a class="docLink" href="ch02lev1sec1.html#ch02lev1sec1">34</a>) value <tt>true</tt> if the <tt>string</tt> contains no characters; otherwise, it returns <tt>false</tt>.</p>

<a name="ch03lev3sec5"></a>
<h5 class="docSection3Title"><tt>string::size_type</tt></h5>
<p class="docText">It might be logical to expect that <tt>size</tt> returns an <tt>int</tt>, or, thinking back to the note on page <a class="docLink" href="ch02lev1sec2.html#ch02sb02">38</a>, an <tt>unsigned</tt>. Instead, the <tt>size</tt> operation returns a value of type <tt>string::size_type</tt>. This type requires a bit of explanation.</p>
<p class="docText">The <tt>string</tt> classand many other library typesdefines several companion types. These companion types make it possible to use the library types in a machine-independent manner. The type <B><a name="ch03term19"></a><a class="docLink" href="ch03lev1sec7.html#gloss03_19"><span class="docEmphStrong"><tt>size_type</tt></span></a></b> is one of these companion types. It is defined as a synonym for an <tt>unsigned</tt> typeeither <tt>unsigned int</tt> or <tt>unsigned long</tt>that is guaranteed to be big enough to hold the size of any <a name="idd1e16821"></a><a name="idd1e16828"></a><a name="idd1e16836"></a><a name="idd1e16845"></a><a name="idd1e16850"></a><a name="idd1e16859"></a><a name="idd1e16872"></a><a name="idd1e16878"></a><a name="idd1e16886"></a><a name="idd1e16895"></a><tt>string</tt>. To use the <tt>size_type</tt> defined by <tt>string</tt>, we use the scope operator to say that the name <tt>size_type</tt> is defined in the <tt>string</tt> class.</p>
<a name="ch03note05"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><td valign="top"><p class="docText"> Any variable used to store the result from the <tt>string size</tt> operation ought to be of type <tt>string::size_type</tt>. It is particularly important <span class="docEmphasis">not</span> to assign the return from <tt>size</tt> to an <tt>int</tt>.</P></TD></tr></table><br>
</p></div><br>
<p class="docText">Although we don't know the precise type of <tt>string::size_type</tt>, wedo know that it is an <tt>unsigned</tt> type (<a class="docLink" href="ch02lev1sec1.html#ch02lev2sec1">Section 2.1.1</a>, p. <a class="docLink" href="ch02lev1sec1.html#ch02lev2sec1">34</a>). We also know that for a given type, the <tt>unsigned</tt> version can hold a positive value twice as large as the corresponding <tt>signed</tt> type can hold. This fact implies that the largest <tt>string</tt> could be twice as large as the size an <tt>int</tt> can hold.</P>
<p class="docText">Another problem with using an <tt>int</tt> is that on some machines the size of an <tt>int</tt> is too small to hold the size of even plausibly large <tt>string</tt>s. For example, if a machine has 16-bit <tt>int</tt>s, then the largest <tt>string</tt> an <tt>int</tt> could represent would have 32,767 characters. A <tt>string</tt> that held the contents of a file could easily exceed this size. The safest way to hold the <tt>size</tt> of a <tt>string</tt> is to use the type the library defines for this purpose, which is <tt>string::size_type</tt>.</p>

<a name="ch03lev3sec6"></a>
<h5 class="docSection3Title">The <tt>string</tt> Relational Operators</H5>
<p class="docText">The <tt>string</tt> class defines several operators that compare two <tt>string</tt> values. Each of these operators works by comparing the characters from each <tt>string</tt>.</p>
<a name="ch03note06"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><td valign="top"><p class="docText"> <tt>string</tt> comparisons are case-sensitivethe upper- and lowercase versions of a letter are different characters. On most computers, the uppercase letters come first: Every uppercase letter is less than any lowercase letter.</p></td></tr></table><br>
</p></div><br>
<p class="docText">The equality operator compares two <tt>string</tt>s, returning <tt>true</tt> if they are equal. Two <tt>string</tt>s are equal if they are the same length and contain the same characters. The library also defines <tt>!=</tt> to test whether two <tt>string</tt>s are unequal.</p>
<p class="docText">The relational operators <tt>&lt;, &lt;=, &gt;, &gt;=</tt> test whether one <tt>string</tt> is less than, less than or equal, greater than, or greater than or equal to another:</p>
<pre>
     string big = "big", small = "small";
     string s1 = big;    // <span class="docEmphasis">s1</span> <span class="docEmphItalicAlt">is a copy of</span> <span class="docEmphasis">big</span>
     if (big == small)   // <span class="docEmphItalicAlt">false</span>
         // ...
     if (big &lt;= s1)      // <span class="docEmphItalicAlt">true, they're equal, so</span> <span class="docEmphasis">big</span> <span class="docEmphItalicAlt">is less than or equal to</span> <span class="docEmphItalicAlt">s1</span>
         // ...
</pre><br>
<p class="docText">The relational operators compare <tt>string</tt>s using the same strategy as in a (case-sensitive) dictionary:</p>
<ul><LI><p class="docList">If two <tt>string</tt>s have different lengths and if every character in the shorter <tt>string</tt> is equal to the corresponding character of the longer <tt>string</tt>, then the shorter <tt>string</tt> is less than the longer one.</P></li><LI><p class="docList">If the characters in two <tt>string</tt>s differ, then we compare them by comparing the first character at which the <tt>string</tt>s differ.</p></li></UL>
<p class="docText"><a name="idd1e17130"></a><a name="idd1e17138"></a><a name="idd1e17146"></a><a name="idd1e17154"></a><a name="idd1e17163"></a><a name="idd1e17172"></a><a name="idd1e17178"></a><a name="idd1e17184"></a><a name="idd1e17195"></a><a name="idd1e17206"></a><a name="idd1e17217"></a><a name="idd1e17223"></a><a name="idd1e17232"></a><a name="idd1e17238"></a>As an example, given the <tt>string</tt>s</P>
<pre>
     string substr = "Hello";
     string phrase = "Hello World";
     string slang  = "Hiya";
</pre><br>
<p class="docText">then <tt>substr</tt> is less than <tt>phrase</tt>, and <tt>slang</tt> is greater than either <tt>substr</tt> or <tt>phrase</tt>.</p>

<a name="ch03lev3sec7"></a>
<h5 class="docSection3Title">Assignment for <tt>string</tt>s</h5>
<p class="docText">In general the library types strive to make it as easy to use a library type as it is to use a built-in type. To this end, most of the library types support assignment. In the case of <tt>string</tt>s, we can assign one <tt>string</tt> object to another:</p>
<pre>
     // <span class="docEmphasis">st1</span> <span class="docEmphItalicAlt">is an empty string,</span> <span class="docEmphasis">st2</span> <span class="docEmphItalicAlt">is a copy of the literal</span>
     string st1, st2 = "The expense of spirit";
     st1 = st2; // <span class="docEmphItalicAlt">replace</span> <span class="docEmphasis">st1</span> <span class="docEmphItalicAlt">by a copy of</span> <span class="docEmphasis">st2</span>
</pre><BR>
<p class="docText">After the assignment, <tt>st1</tt> contains a copy of the characters in <tt>st2</tt>.</p>
<p class="docText">Most <tt>string</tt> library implementations go to some trouble to provide efficient implementations of operations such as assignment, but it is worth noting that conceptually, assignment requires a fair bit of work. It must delete the storage containing the characters associated with <tt>st1</tt>, allocate the storage needed to contain a copy of the characters associated with <tt>st2</tt>, and then copy those characters from <tt>st2</tt> into this new storage.</P>

<a name="ch03lev3sec8"></a>
<H5 class="docSection3Title">Adding Two <tt>string</tt>s</h5>
<p class="docText">Addition on <tt>string</tt>s is defined as concatenation. That is, it is possible to concatenate two or more <tt>string</tt>s through the use of either the plus operator (<tt>+</tt>) or the compound assignment operator (<tt>+=</tt>) (<a class="docLink" href="ch01lev1sec4.html#ch01lev2sec5">Section 1.4.1</a>, p. <a class="docLink" href="ch01lev1sec4.html#ch01lev2sec5">13</a>). Given the two <tt>string</tt>s</p>
<pre>
     string s1("hello, ");
     string s2("world\n");
</pre><br>
<p class="docText">we can concatenate the two <tt>string</tt>s to create a third <tt>string</tt> as follows:</P>
<pre>
     string s3 = s1 + s2;   // <span class="docEmphasis">s3 is hello, world</span>\n
</pre><BR>
<p class="docText">If we wanted to append <tt>s2</tt> to <tt>s1</tt> directly, then we would use <tt>+=</tt>:</p>
<pre>
     s1 += s2;   // <span class="docEmphItalicAlt">equivalent to</span> <span class="docEmphasis">s1 = s1 + s2</span>
</pre><br>

<a name="ch03lev3sec9"></a>
<h5 class="docSection3Title">Adding Character String Literals and <tt>string</tt>s</h5>
<p class="docText">The <tt>string</tt>s <tt>s1</tt> and <tt>s2</tt> included punctuation directly. We could achieve the same result by mixing <tt>string</tt> objects and string literals as follows:</P>
<pre>
     string s1("hello");
     string s2("world");

     string s3 = s1 + ", " + s2 + "\n";
</pre><br>
<p class="docText"><a name="idd1e17458"></a><a name="idd1e17463"></a><a name="idd1e17471"></a><a name="idd1e17474"></a><a name="idd1e17488"></a><a name="idd1e17494"></a><a name="idd1e17500"></a><a name="idd1e17507"></a><a name="idd1e17513"></a>When mixing <tt>string</tt>s and string literals, at least one operand to each <tt>+</tt> operator must be of <tt>string</tt> type:</p>
<pre>
     string s1 = "hello";   // <span class="docEmphItalicAlt">no punctuation</span>
     string s2 = "world";
     string s3 = s1 + ", ";           // <span class="docEmphItalicAlt">ok: adding a</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">and a literal</span>
     string s4 = "hello" + ", ";      // <span class="docEmphItalicAlt">error: no</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">operand</span>
     string s5 = s1 + ", " + "world"; // <span class="docEmphItalicAlt">ok: each + has</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">operand</span>
     string s6 = "hello" + ", " + s2; // <span class="docEmphItalicAlt">error: can't add</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">literals</span>
</pre><BR>
<p class="docText">The initializations of <tt>s3</tt> and <tt>s4</tt> involve only a single operation. In these cases, it is easy to determine that the initialization of <tt>s3</tt> is legal: We initialize <tt>s3</tt> by adding a <tt>string</tt> and a string literal. The initialization of <tt>s4</tt> attempts to add two string literals and is illegal.</p>
<p class="docText">The initialization of <tt>s5</tt> may appear surprising, but it works in much the same way as when we chain together input or output expressions (<a class="docLink" href="ch01lev1sec2.html#ch01lev1sec2">Section 1.2</a>, p. <a class="docLink" href="ch01lev1sec2.html#ch01lev1sec2">5</a>). In this case, the <tt>string</tt> library defines addition to return a <tt>string</tt>. Thus, when we initialize <tt>s5</tt>, the subexpression <tt>s1 + ", "</tt> returns a <tt>string</tt>, which can be concatenated with the literal <tt>"world\n"</tt>. It is as if we had written</p>
<pre>
     string tmp = s1 + ", "; // <span class="docEmphItalicAlt">ok: + has a</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">operand</span>
     s5 = tmp + "world";     // <span class="docEmphItalicAlt">ok: + has a</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">operand</span>
</pre><BR>
<p class="docText">On the other hand, the initialization of <tt>s6</tt> is illegal. Looking at each subexpression in turn, we see that the first subexpression adds two string literals. There is no way to do so, and so the statement is in error.</p>

<a name="ch03lev3sec10"></a>
<H5 class="docSection3Title">Fetching a Character from a <tt>string</tt></h5>
<p class="docText">The <tt>string</tt> type uses the <span class="docEmphStrong">subscript</span> (<tt>[ ]</tt>) operator to access the individual characters in the <tt>string</tt>. The subscript operator takes a <tt>size_type</tt> value that denotes the character position we wish to fetch. The value in the subscript is often called &quot;the subscript&quot; or &quot;an <b><a name="ch03term10"></a><a class="docLink" href="ch03lev1sec7.html#gloss03_10">index</a></b>.&quot;</p>
<a name="ch03note07"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> Subscripts for <tt>string</tt>s start at zero; if <tt>s</tt> is a <tt>string</tt>, then if <tt>s</tt> isn't empty, <tt>s[0]</tt> is the first character in the <tt>string, s[1]</tt> is the second if there is one, and the last character is in <tt>s[s.size() - 1]</tt>.</p></td></tr></table><br>
<p class="docText"><span class="docEmphasis">It is an error to use an index outside this range.</span></p>
</P></div><BR>
<p class="docText">We could use the subscript operator to print each character in a <tt>string</tt> on a separate line:</p>
<pre>
     string str("some string");
     for (string::size_type ix = 0; ix != str.size(); ++ix)
         cout &lt;&lt; str[ix] &lt;&lt; endl;
</pre><BR>
<p class="docText">On each trip through the loop we fetch the next character from <tt>str</tt>, printing it followed by a newline.</p>

<a name="ch03lev3sec11"></a>
<h5 class="docSection3Title">Subscripting Yields an Lvalue</H5>
<p class="docText"><a name="idd1e17748"></a><a name="idd1e17755"></a><a name="idd1e17762"></a><a name="idd1e17766"></a><a name="idd1e17772"></a><a name="idd1e17777"></a><a name="idd1e17783"></a><a name="idd1e17787"></a><a name="idd1e17791"></a><a name="idd1e17795"></a><a name="idd1e17799"></a><a name="idd1e17803"></a><a name="idd1e17807"></a><a name="idd1e17811"></a><a name="idd1e17815"></a><a name="idd1e17819"></a><a name="idd1e17823"></a><a name="idd1e17827"></a><a name="idd1e17832"></a><a name="idd1e17845"></a><a name="idd1e17858"></a><a name="idd1e17861"></a><a name="idd1e17869"></a><a name="idd1e17877"></a><a name="idd1e17883"></a><a name="idd1e17887"></a>Recall that a variable is an lvalue (<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec10">Section 2.3.1</a>, p. <a class="docLink" href="ch02lev1sec3.html#ch02lev2sec10">45</a>), and that the left-hand side of an assignment must be an lvalue. Like a variable, the value returned by the subscript operator is an lvalue. Hence, a subscript can be used on either side of an assignment. The following loop sets each character in <tt>str</tt> to an asterisk:</P>
<pre>
     for (string::size_type ix = 0; ix != str.size(); ++ix)
         str[ix] = '*';
</pre><br>

<a name="ch03lev3sec12"></a>
<h5 class="docSection3Title">Computing Subscript Values</h5>
<p class="docText">Any expression that results in an integral value can be used as the index to the subscript operator. For example, assuming <tt>someval</tt> and <tt>someotherval</tt> are integral objects, we could write</p>
<pre>
     str[someotherval * someval] = someval;
</pre><br>
<p class="docText">Although any integral type can be used as an index, the actual type of the index is <tt>string::size_type</tt>, which is an <tt>unsigned</tt> type.</P>
<a name="ch03note08"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><td valign="top"><p class="docText"> The same reasons to use <tt>string::size_type</tt> as the type for a variable that holds the return from <tt>size</tt> apply when defining a variable to serve as an index. A variable used to index a <tt>string</tt> should have type <tt>string::size_type</tt>.</p></TD></TR></table><br>
</p></div><br>
<p class="docText">When we subscript a <tt>string</tt>, we are responsible for ensuring that the index is &quot;in range.&quot; By in range, we mean that the index is a number that, when assigned to a <tt>size_type</tt>, is a value in the range from 0 through the size of the <tt>string</tt> minus one. By using a <tt>string::size_type</tt> or another <tt>unsigned</tt> type as the index, we ensure that the subscript cannot be less than zero. As long as our index is an <tt>unsigned</tt> type, we need only check that it is less than the size of the <tt>string</tt>.</p>
<a name="ch03note09"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></TD><td valign="top"><p class="docText"> The library is not required to check the value of the index. Using an index that is out of range is undefined and usually results in a serious run-time error.</p></TD></tr></table><BR>
</p></div><br>


<a name="ch03lev2sec5"></a>
<h4 class="docSection2Title">3.2.4. Dealing with the Characters of a <tt>string</tt></h4>
<p class="docText">Often we want to process the individual characters of a <tt>string</tt>. For example, we might want to know if a particular character is a whitespace character or whether the character is alphabetic or numeric. <a class="docLink" href="#ch03table03">Table 3.3</a> on the facing page lists the functions that can be used on the characters in a <tt>string</tt> (or on any other <tt>char</tt> value). These functions are defined in the <b><a name="ch03term3"></a><a class="docLink" href="ch03lev1sec7.html#gloss03_03"><span class="docEmphStrong"><tt>cctype</tt> header</span></a></b>.</p>
<a name="ch03table03"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 3.3. <tt>cctype</tt> Functions</h5></caption><colgroup><col width="175"><col width="325"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>isalnum(c)</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>TRue</tt> if <tt>c</tt> is a letter or a digit.</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>isalpha(c)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>true</tt> if <tt>c</tt> is a letter.</p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>iscntrl(c)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>true</tt> if <tt>c</tt> is a control character.</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>isdigit(c)</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>true</tt> if <tt>c</tt> is a digit.</P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>isgraph(c)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>true</tt> if <tt>c</tt> is not a space but is printable.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>islower(c)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>true</tt> if <tt>c</tt> is a lowercase letter.</p></TD></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>isprint(c)</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>TRue</tt> if <tt>c</tt> is a printable character.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>ispunct(c)</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>TRue</tt> if <tt>c</tt> is a punctuation character.</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>isspace(c)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>true</tt> if <tt>c</tt> is whitespace.</P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>isupper(c)</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>TRue</tt> if <tt>c</tt> is an uppercase letter.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>isxdigit(c)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>true</tt> if <tt>c</tt> is a hexadecimal digit.</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>tolower(c)</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">If <tt>c</tt> is an uppercase letter, returns its lowercase equivalent; otherwise returns <tt>c</tt> unchanged.</p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>toupper(c)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">If <tt>c</tt> is a lowercase letter, returns its uppercase equivalent; otherwise returns <tt>c</tt> unchanged.</p></TD></tr></table></P><BR>
<p class="docText">These functions mostly test the given character and return an <tt>int</tt>, which acts as a truth value. Each function returns zero if the test fails; otherwise, they return a (meaningless) nonzero value indicating that the character is of the requested kind.</p>
<p class="docText">For these functions, a printable character is a character with a visible representation; whitespace is one of space, tab, vertical tab, return, newline, and formfeed; and punctuation is a printable character that is not a digit, a letter, or (printable) whitespace character such as space.</p>
<p class="docText">As an example, we could use these functions to print the number of punctuation characters in a given <tt>string</tt>:</p>
<pre>
     string s("Hello World!!!");
     string::size_type punct_cnt = 0;
     // <span class="docEmphItalicAlt">count number of punctuation characters in</span> <span class="docEmphasis">s</span>
     for (string::size_type index = 0; index != s.size(); ++index)
         if (ispunct(s[index]))
             ++punct_cnt;
     cout &lt;&lt; punct_cnt
          &lt;&lt; " punctuation characters in " &lt;&lt; s &lt;&lt; endl;
</pre><BR>
<p class="docText">The output of this program is</P>
<pre>
     <span class="docEmphStrong">3 punctuation characters in Hello World!!!</span>
</pre><br>
<p class="docText">Rather than returning a truth value, the <tt>tolower</tt> and <tt>toupper</tt> functions return a charactereither the argument unchanged or the lower- or uppercase version of the character. We could use <tt>tolower</tt> to change <tt>s</tt> to lowercase as follows:</p>
<pre>
     // <span class="docEmphItalicAlt">convert</span> <span class="docEmphasis">s</span> <span class="docEmphItalicAlt">to lowercase</span>
     for (string::size_type index = 0; index != s.size(); ++index)
         s[index] = tolower(s[index]);
     cout &lt;&lt; s &lt;&lt; endl;
</pre><br>
<p class="docText">which generates</p>
<pre>
     <span class="docEmphStrong">hello world!!!</span>
</pre><BR>
<a name="ch03sb05"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Advice: Use the C++ Versions of C Library Headers</h2>
<p class="docText"><a name="idd1e18352"></a><a name="idd1e18355"></a><a name="idd1e18360"></a><a name="idd1e18365"></a><a name="idd1e18371"></a><a name="idd1e18376"></a><a name="idd1e18381"></a><a name="idd1e18386"></a><a name="idd1e18391"></a><a name="idd1e18395"></a><span class="docEmphStrong">In addition to facilities defined specifically for C++, the C++ library incorporates the C library. The <tt>cctype</tt> header makes available the C library functions defined in the C header file named <tt>ctype.h</tt>.</span></P>
<p class="docText"><span class="docEmphStrong">The standard C headers names use the form <span class="docEmphasis">name</span></span><span class="docEmphStrong"><tt>.h</tt>. The C++ versions of these headers are named <tt>c</tt></span><span class="docEmphBoldItalic">name</span><span class="docEmphStrong">the C++ versions remove the <tt>.h</tt> suffix and precede the <span class="docEmphasis">name</span> by the letter <tt>c</tt></span><span class="docEmphStrong">. The</span><span class="docEmphStrong"><tt>c</tt> indicates that the header originally comes from the C library. Hence, <tt>cctype</tt> has the same contents as <tt>ctype.h</tt>, but in a form that is appropriate for C++ programs. In particular, the names defined in the <tt>c</tt></span><span class="docEmphBoldItalic">name</span> <span class="docEmphStrong">headers are defined inside the <tt>std</tt> namespace, whereas those defined in the <tt>.h</tt> versions are not.</span></p>
<p class="docText"><span class="docEmphStrong">Ordinarily, C++ programs should use the <tt>c</tt></span><span class="docEmphBoldItalic">name</span> <span class="docEmphStrong">versions of headers and not the <span class="docEmphasis">name</span></span><span class="docEmphStrong"><tt>.h</tt> versions. That way names from the standard library are consistently found in the <tt>std</tt> namespace. Using the <tt>.h</tt> headers puts the burden on the programmer to remember which library names are inherited from C and which are unique to C++.</span></P>
</td></tr></table></p><br>
<a name="ch03sb06"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 3.2.4</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa4q1"></a><b>Exercise 3.7:</b></TD><TD><p class="docText">Write a program to read two <tt>string</tt>s and report whether the <tt>string</tt>s are equal. If not, report which of the two is the larger. Now, change the program to report whether the <tt>string</tt>s have the same length and if not report which is longer.</p>
</TD></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch03qa4q2"></a><B>Exercise 3.8:</b></td><td><p class="docText">Write a program to read <tt>string</tt>s from the standard input, concatenating what is read into one large <tt>string</tt>. Print the concatenated <tt>string</tt>. Next, change the program to separate adjacent input <tt>string</tt>s by a space.</p>
</td></tr><TR valign="top"><td align="right" class="docText" width="50"><a name="ch03qa4q3"></a><B>Exercise 3.9:</b></TD><td><p class="docText">What does the following program do? Is it valid? If not, why not?</p>
<pre>
     string s;
     cout &lt;&lt; s[0] &lt;&lt; endl;
</pre><br>
</TD></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa4q4"></a><b>Exercise 3.10:</b></td><TD><p class="docText">Write a program to strip the punctuation from a <tt>string</tt>. The input to the program should be a string of characters including punctuation; the output should be a <tt>string</tt> in which the punctuation is removed.</p>
</td></TR></table></p>
</blockquote>
</td></TR></table></p><BR>


<a href="21001535.html"><img src="images/pixel.gif" alt="" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch03lev1sec1.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch03lev1sec3.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>