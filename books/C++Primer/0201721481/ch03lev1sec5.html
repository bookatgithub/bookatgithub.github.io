<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 3.5.&nbsp; Library bitset Type</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch03lev1sec4.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch03lev1sec6.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch03lev1sec5"></a>
<h3 class="docSection1Title">3.5. Library <tt>bitset</tt> Type</h3>
<p class="docText">Some programs deal with ordered collections of bits. Each bit can contain either a 0 (off) or a 1 (on) value. Using bits is a compact way to keep yes/no information (sometimes called flags) about a set of items or conditions. The standard library makes it easy to deal with bits through the <B><a name="ch03term2"></a><a class="docLink" href="ch03lev1sec7.html#gloss03_02"><span class="docEmphStrong"><tt>bitset</tt></span></a></b> class. To use a <tt>bitset</tt> we must include its associated header file. In our examples, we also assume an appropriate <tt>using</tt> declaration for <tt>std::bitset</tt> is made:</P>
<pre>
     #include &lt;bitset&gt;
     using std::bitset;
</pre><br>
<a name="ch03lev2sec15"></a>
<H4 class="docSection2Title">3.5.1. Defining and Initializing <tt>bitset</tt>s</h4>
<p class="docText"><a name="idd1e21292"></a><a name="idd1e21295"></a><a class="docLink" href="#ch03table06">Table 3.6</a> lists the constructors for <tt>bitset</tt>. Like <tt>vector</tt>, the <tt>bitset</tt> class is a class template. Unlike <tt>vector</tt>, objects of type <tt>bitset</tt> differ by size rather than by type. When we define a <tt>bitset</tt>, we say how many bits the <tt>bitset</tt> will contain, which we do by specifying the size between a pair of angle brackets.</p>
<a name="ch03table06"></a><P><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 3.6. Ways to Initialize a <tt>bitset</tt></h5></caption><colgroup><col width="200"><col width="300"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>bitset&lt;n&gt; b;</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>b</tt> has <tt>n</tt> bits, each bit is <tt>0</tt></p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>bitset&lt;n&gt; b(u);</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>b</tt> is a copy of the <tt>unsigned long</tt> value <tt>u</tt></p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>bitset&lt;n&gt; b(s);</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>b</tt> is a copy of the bits contained in <tt>string s</tt></p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>bitset&lt;n&gt; b(s, pos, n);</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>b</tt> is a copy of the bits in <tt>n</tt> characters from <tt>s</tt> starting from position <tt>pos</tt></p></td></tr></table></p><br>
<pre>
     bitset&lt;32&gt; bitvec; // <span class="docEmphItalicAlt">32 bits, all zero</span>
</pre><br>
<p class="docText">The size must be a constant expression (<a class="docLink" href="ch02lev1sec7.html#ch02lev1sec7">Section 2.7</a>, p. <a class="docLink" href="ch02lev1sec7.html#ch02lev1sec7">62</a>). It might be defined, as we did here, using an integral literal constant or using a <tt>const</tt> object of integral type that is initialized from a constant.</p>
<p class="docText">This statement defines <tt>bitvec</tt> as a <tt>bitset</tt> that holds 32 bits. Just as with the elements of a <tt>vector</tt>, the bits in a <tt>bitset</tt> are not named. Instead, we refer to them positionally. The bits are numbered starting at 0. Thus, <tt>bitvec</tt> has bits numbered 0 through 31. The bits starting at 0 are referred to as the <b><a name="ch03term13"></a><a class="docLink" href="ch03lev1sec7.html#gloss03_13">low-order</a></b> bits, and those ending at 31 are referred to as <b><a name="ch03term9"></a><a class="docLink" href="ch03lev1sec7.html#gloss03_09">high-order</a></b> bits.</p>
<a name="ch03lev3sec19"></a>
<H5 class="docSection3Title">Initializing a <tt>bitset</tt> from an <tt>unsigned</tt> Value</H5>
<p class="docText">When we use an <tt>unsigned long</tt> value as an initializer for a <tt>bitset</tt>, that value is treated as a bit pattern. The bits in the <tt>bitset</tt> are a copy of that pattern. If the size of the <tt>bitset</tt> is greater than the number of bits in an <tt>unsigned long</tt>, then the remaining high-order bits are set to zero. If the size of the <tt>bitset</tt> is less than that number of bits, then only the low-order bits from the <tt>unsigned</tt> value are used; the high-order bits beyond the size of the <tt>bitset</tt> object are discarded.</p>
<p class="docText">On a machine with 32-bit <tt>unsigned long</tt>s, the hexadecimal value <tt>0xffff</tt> is represented in bits as a sequence of 16 ones followed by 16 zeroes. (Each <tt>0xf</tt> digit is represented as <tt>1111</tt>.) We can initialize a <tt>bitset</tt> from <tt>0xffff</tt>:</P>
<pre>
     // <span class="docEmphasis">bitvec1</span> <span class="docEmphItalicAlt">is smaller than the initializer</span>
     bitset&lt;16&gt; bitvec1(0xffff);          // <span class="docEmphItalicAlt">bits 0 ... 15 are set to 1</span>
     // <span class="docEmphasis">bitvec2</span> <span class="docEmphItalicAlt">same size as initializer</span>
     bitset&lt;32&gt; bitvec2(0xffff);          // <span class="docEmphItalicAlt">bits 0 ... 15 are set to 1; 16 ... 31 are 0</span>
     // <span class="docEmphItalicAlt">on a 32-bit machine, bits 0 to 31 initialized from</span> <span class="docEmphasis">0xffff</span>
     bitset&lt;128&gt; bitvec3(0xffff);         // <span class="docEmphItalicAlt">bits 32 through 127 initialized to zero</span>
</pre><br>
<p class="docText">In all three cases, the bits 0 to 15 are set to one. For <tt>bitvec1</tt>, the high-order bits in the initializer are discarded; <tt>bitvec1</tt> has fewer bits than an <tt>unsigned</tt> <tt>long</tt>. <tt>bitvec2</tt> is the same size as an <tt>unsigned long</tt>, so all the bits are used to initialize that object. <tt>bitvec3</tt> is larger than an <tt>unsigned long</tt>, so its high-order bits above 31 are initialized to zero.</p>

<a name="ch03lev3sec20"></a>
<H5 class="docSection3Title">Initializing a <tt>bitset</tt> from a <tt>string</tt></H5>
<p class="docText">When we initialize a <tt>bitset</tt> from a <tt>string</tt>, the <tt>string</tt> represents the bit pattern directly. The bits are read from the <tt>string</tt> <span class="docEmphasis">from right to left</span>:</p>
<pre>
     string strval("1100");
     bitset&lt;32&gt; bitvec4(strval);
</pre><br>
<p class="docText">The bit pattern in <tt>bitvec4</tt> has bit positions 2 and 3 set to 1, while the remaining bit positions are 0. If the <tt>string</tt> contains fewer characters than the size of the <tt>bitset</tt>, the high-order bits are set to zero.</p>
<a name="ch03note20"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> The numbering conventions of <tt>string</tt>s and <tt>bitsets</tt> are inversely related: The rightmost character in the <tt>string</tt>the one with the highest subscriptis used to initialize the low-order bit in the <tt>bitset</tt>the bit with subscript 0. When initializing a <tt>bitset</tt> from a <tt>string</tt>, it is essential to remember this difference.</P></td></tr></table><br>
</P></div><BR>
<p class="docText">We need not use the entire <tt>string</tt> as the initial value for the <tt>bitset</tt>. Instead, we can use a substring as the initializer:</p>
<pre>
     string str("1111111000000011001101");
     bitset&lt;32&gt; bitvec5(str, 5, 4); // <span class="docEmphItalicAlt">4 bits starting at</span> <span class="docEmphasis">str[5], 1100</span>
     bitset&lt;32&gt; bitvec6(str, str.size() - 4);     // <span class="docEmphItalicAlt">use last 4 characters</span>
</pre><br>
<p class="docText">Here <tt>bitvec5</tt> is initialized by a substring of <tt>str</tt> starting at <tt>str[5]</tt> and continuing for four positions. As usual, we start at the rightmost end of this substring when initializing the <tt>bitset</tt>, meaning that <tt>bitvec5</tt> is initialized with bit positions 0 through 3 set to <tt>1100</tt> while its remaining bit positions are set to 0. Leaving off the third parameter says to use characters from the starting position to the end of the <tt>string</tt>. In this case, the characters starting four from the end of <tt>str</tt> are used to initialize the lower four bits of <tt>bitvec6</tt>. The remainder of the bits in <tt>bitvec6</tt> are initialized to zero. We can view these initializations as</p>

<p class="docText">
<img border="0" alt="" width="500" height="256" SRC="images/0201721481/graphics/103fig01.gif;400478"></p>



<a name="ch03lev2sec16"></a>
<H4 class="docSection2Title">3.5.2. Operations on <tt>bitset</tt>s</h4>
<p class="docText"><a name="idd1e21732"></a><a name="idd1e21739"></a><a name="idd1e21746"></a><a name="idd1e21753"></a><a name="idd1e21760"></a><a name="idd1e21765"></a><a name="idd1e21771"></a>The <tt>bitset</tt> operations (<a class="docLink" href="#ch03table07">Table 3.7</a>) define various operations to test or set one or more bits in the <tt>bitset</tt>.</p>
<a name="ch03table07"></a><P><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 3.7. <tt>bitset</tt> Operations</h5></caption><colgroup><col width="175"><col width="325"></colgroup><thead></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>b.any()</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Is any bit in <tt>b</tt> on?</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>b.none()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Are no bits in <tt>b</tt> on?</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>b.count()</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Number of bits in <tt>b</tt> that are on</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>b.size()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Number of bits in <tt>b</tt></P></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>b[pos]</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Access bit in <tt>b</tt> at position <tt>pos</tt></P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>b.test(pos)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Is bit in <tt>b</tt> in position <tt>pos</tt> on?</P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>b.set()</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Turn on all bits in <tt>b</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>b.set(pos)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Turn on the bit in <tt>b</tt> at position <tt>pos</tt></p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>b.reset()</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Turn off all bits in <tt>b</tt></p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>b.reset(pos)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Turn off the bit in <tt>b</tt> at position <tt>pos</tt></P></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>b.flip()</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Change the state of each bit in <tt>b</tt></P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>b.flip(pos)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Reverse value of the bit in <tt>b</tt> in position <tt>pos</tt></P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>b.to_ulong()</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns an <tt>unsigned long</tt> with the same bits as in <tt>b</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>os &lt;&lt; b</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Prints the bits in <tt>b</tt> to the stream <tt>os</tt></p></td></tr></table></P><BR>
<a name="ch03lev3sec21"></a>
<h5 class="docSection3Title">Testing the Entire <tt>bitset</tt></H5>
<p class="docText">The <tt>any</tt> operation returns <tt>true</tt> if one or more bits of the <tt>bitset</tt> object are turned onthat is, are equal to 1. Conversely, the operation <tt>none</tt> returns <tt>true</tt> if all the bits of the object are set to zero.</P>
<pre>
     bitset&lt;32&gt; bitvec; // <span class="docEmphItalicAlt">32 bits, all zero</span>
     bool is_set = bitvec.any();            // <span class="docEmphItalicAlt">false, all bits are zero</span>
     bool is_not_set = bitvec.none();       // <span class="docEmphItalicAlt">true, all bits are zero</span>
</pre><BR>
<p class="docText">If we need to know how many bits are set, we can use the <tt>count</tt> operation, which returns the number of bits that are set:</p>
<pre>
     size_t bits_set = bitvec.count(); // <span class="docEmphItalicAlt">returns number of bits that are on</span>
</pre><br>
<p class="docText">The return type of the <tt>count</tt> operation is a library type named <span class="docEmphStrong"><tt>size_t</tt>.</span> The <tt>size_t</tt> type is defined in the <tt>cstddef</tt> header, which is the C++ version of the <tt>stddef.h</tt> header from the C library. It is a machine-specific <span class="docEmphasis">unsigned</span> type that is guaranteed to be large enough to hold the size of an object in memory.</p>
<p class="docText">The <tt>size</tt> operation, like the one in <tt>vector</tt> and <tt>string</tt>, returns the total number of bits in the <tt>bitset</tt>. The value returned has type <tt>size_t:</tt></p>
<pre>
     size_t sz = bitvec.size(); // <span class="docEmphItalicAlt">returns</span> <span class="docEmphasis">32</span>
</pre><br>

<a name="ch03lev3sec22"></a>
<H5 class="docSection3Title">Accessing the Bits in a <tt>bitset</tt></h5>
<p class="docText"><a name="idd1e22142"></a><a name="idd1e22150"></a><a name="idd1e22157"></a><a name="idd1e22164"></a><a name="idd1e22171"></a><a name="idd1e22178"></a><a name="idd1e22185"></a><a name="idd1e22191"></a><a name="idd1e22205"></a>The subscript operator lets us read or write the bit at the indexed position. As such, we can use it to test the value of a given bit or to set that value:</P>
<pre>
     // <span class="docEmphItalicAlt">assign 1 to even numbered bits</span>
     for (int index = 0; index != 32; index += 2)
                 bitvec[index] = 1;
</pre><BR>
<p class="docText">This loop turns on the even-numbered bits of <tt>bitvec</tt>.</p>
<p class="docText">As with the subscript operator, we can use the <tt>set, test</tt>, and <tt>reset</tt> operations to test or set a given bit value:</p>
<pre>
     // <span class="docEmphItalicAlt">equivalent loop using set operation</span>
     for (int index = 0; index != 32; index += 2)
                 bitvec.set(index);
</pre><br>
<p class="docText">To test whether a bit is on, we can use the <tt>test</tt> operation or test the value returned from the subscript operator:</P>
<pre>
     if (bitvec.test(i))
          // <span class="docEmphItalicAlt">bitvec[i] is on</span>
     // <span class="docEmphItalicAlt">equivalent test using subscript</span>
     if (bitvec[i])
          // <span class="docEmphItalicAlt">bitvec[i] is on</span>
</pre><BR>
<p class="docText">The result of testing the value returned from a subscript is <tt>true</tt> if the bit is 1 or <tt>false</tt> if the bit is <tt>0</tt>.</p>

<a name="ch03lev3sec23"></a>
<h5 class="docSection3Title">Setting the Entire <tt>bitset</tt></h5>
<p class="docText">The <tt>set</tt> and <tt>reset</tt> operations can also be used to turn on or turn off the entire <tt>bitset</tt> object, respectively:</P>
<pre>
     bitvec.reset(); // <span class="docEmphItalicAlt">set all the bits to 0.</span>
     bitvec.set();   // <span class="docEmphItalicAlt">set all the bits to 1</span>
</pre><br>
<p class="docText">The <tt>flip</tt> operation reverses the value of an individual bit or the entire <tt>bitset</tt>:</p>
<pre>
     bitvec.flip(0);   // <span class="docEmphItalicAlt">reverses value of first bit</span>
     bitvec[0].flip(); // <span class="docEmphItalicAlt">also reverses the first bit</span>
     bitvec.flip();    // <span class="docEmphItalicAlt">reverses value of all bits</span>
</pre><BR>

<a name="ch03lev3sec24"></a>
<h5 class="docSection3Title">Retrieving the Value of a <tt>bitset</tt></h5>
<p class="docText">The <tt>to_ulong</tt> operation returns an <tt>unsigned long</tt> that holds the same bit pattern as the <tt>bitset</tt> object. We can use this operation only if the size of the <tt>bitset</tt> is less than or equal to the size of an <tt>unsigned long</tt>:</P>
<pre>
     unsigned long ulong = bitvec3.to_ulong();
     cout &lt;&lt; "ulong = " &lt;&lt; ulong &lt;&lt; endl;
</pre><br>
<p class="docText">The <tt>to_ulong</tt> operation is intended to be used when we need to pass a <tt>bitset</tt> to a C or pre-Standard C++ program. If the <tt>bitset</tt> contains more bits than the size of an <tt>unsigned long</tt>, a run-time exception is signaled. We'll introduce exceptions in <a class="docLink" href="ch06lev1sec13.html#ch06lev1sec13">Section 6.13</a> (p. <a class="docLink" href="ch06lev1sec13.html#ch06lev1sec13">215</a>) and look at them in more detail in <a class="docLink" href="ch17lev1sec1.html#ch17lev1sec1">Section 17.1</a> (p. <a class="docLink" href="ch17lev1sec1.html#ch17lev1sec1">688</a>).</P>

<a name="ch03lev3sec25"></a>
<h5 class="docSection3Title">Printing the Bits</h5>
<p class="docText"><a name="idd1e22406"></a><a name="idd1e22414"></a><a name="idd1e22420"></a><a name="idd1e22429"></a>We can use the output operator to print the bit pattern in a <tt>bitset</tt> object:</p>
<pre>
     bitset&lt;32&gt; bitvec2(0xffff); // <span class="docEmphItalicAlt">bits 0 ... 15 are set to 1; 16 ... 31 are 0</span>
     cout &lt;&lt; "bitvec2: " &lt;&lt; bitvec2 &lt;&lt; endl;
</pre><br>
<p class="docText">will print</p>
<pre>
     <span class="docEmphStrong">bitvec2: 00000000000000001111111111111111</span>
</pre><br>

<a name="ch03lev3sec26"></a>
<h5 class="docSection3Title">Using the Bitwise Operators</h5>
<p class="docText">The <tt>bitset</tt> class also supports the built-in bitwise operators. As defined by the language, these operators apply to integral operands. They perform operations similar to the <tt>bitset</tt> operations described in this section. <a class="docLink" href="ch05lev1sec3.html#ch05lev1sec3">Section 5.3</a> (p. <a class="docLink" href="ch05lev1sec3.html#ch05lev1sec3">154</a>) describes these operators.</p>
<a name="ch03sb15"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 3.5.2</H2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch03qa9q1"></a><b>Exercise 3.23:</b></td><TD><p class="docText">Explain the bit pattern each of the following <tt>bitset</tt> objects contains:</P>
<pre>
     (a) bitset&lt;64&gt; bitvec(32);
     (b) bitset&lt;32&gt; bv(1010101);
     (c) string bstr; cin &gt;&gt; bstr; bitset&lt;8&gt;bv(bstr);
</pre><br>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa9q2"></a><B>Exercise 3.24:</b></td><TD><p class="docText">Consider the sequence 1,2,3,5,8,13,21. Initialize a <tt>bitset&lt;32&gt;</tt> object that has a one bit in each position corresponding to a number in this sequence. Alternatively, given an empty <tt>bitset</tt>, write a small program to turn on each of the appropriate bits.</P>
</td></tr></table></p>
</blockquote>
</TD></TR></table></p><br>



<a href="21001535.html"><img src="images/pixel.gif" alt="" width="1" height="1" border="0"></a><ul></ul></TD></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch03lev1sec4.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch03lev1sec6.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>