<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 4.2.&nbsp; Introducing Pointers</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch04lev1sec1.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch04lev1sec3.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch04lev1sec2"></a>
<h3 class="docSection1Title">4.2. Introducing Pointers</h3>
<p class="docText">Just as we can traverse a <tt>vector</tt> either by using a subscript or an iterator, we can also traverse an array by using either a subscript or a <B><a name="ch04term11"></a><a class="docLink" href="ch04lev1sec6.html#gloss04_11">pointer</a></b>. A pointer is a compound type; a pointer points to an object of some other type. Pointers are iterators for arrays: A pointer can point to an element in an array. The dereference and increment operators, when applied to a pointer that points to an array element, have similar behavior as when applied to an iterator. When we dereference a pointer, <a name="idd1e24228"></a><a name="idd1e24233"></a><a name="idd1e24239"></a><a name="idd1e24244"></a><a name="idd1e24252"></a>we obtain the object to which the pointer points. When we increment a pointer, we advance the pointer to denote the next element in the array. Before we write programs using pointers, we need to know a bit more about them.</P>
<a name="ch04sb03"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<h2 class="docSidebarTitle">Exercises Section 4.1.2</H2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa2q1"></a><b>Exercise 4.6:</b></td><td><p class="docText">This code fragment intends to assign the value of its index to each array element. It contains a number of indexing errors. Identify them.</P>
<pre>
          const size_t array_size = 10;
          int ia[array_size];
          for (size_t ix = 1; ix &lt;= array_size; ++ix)
                ia[ix] = ix;
</pre><br>
</TD></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa2q2"></a><b>Exercise 4.7:</b></TD><TD><p class="docText">Write the code necessary to assign one array to another. Now, change the code to use <tt>vector</tt>s. How might you assign one <tt>vector</tt> to another?</p>
</td></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch04qa2q3"></a><b>Exercise 4.8:</b></td><TD><p class="docText">Write a program to compare two arrays for equality. Write a similar program to compare two <tt>vector</tt>s.</p>
</td></TR><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch04qa2q4"></a><b>Exercise 4.9:</b></td><td><p class="docText">Write a program to define an array of 10 <tt>int</tt>s. Give each element the same value as its position in the array.</p>
</td></tr></table></p>
</blockquote>
</td></tr></table></p><br>
<a name="ch04lev2sec3"></a>
<h4 class="docSection2Title">4.2.1. What Is a Pointer?</h4>
<p class="docText">For newcomers, pointers are often hard to understand. Debugging problems due to pointer errors bedevil even experienced programmers. However, pointers are an important part of most C programs and to a much lesser extent remain important in many C++ programs.</P>
<p class="docText">Conceptually, pointers are simple: A pointer points at an object. Like an iterator, a pointer offers indirect access to the object to which it points. However, pointers are a much more general construct. Unlike iterators, pointers can be used to point at single objects. Iterators are used only to access elements in a container.</P>
<p class="docText">Specifically, a pointer holds the address of another object:</p>
<pre>
          string s("hello world");
          string *sp = &amp;s; // <span class="docEmphasis">sp</span> <span class="docEmphItalicAlt">holds the address of</span> <span class="docEmphasis">s</span>
</pre><BR>
<p class="docText">The second statement defines <tt>sp</tt> as a pointer to <tt>string</tt> and initializes <tt>sp</tt> to point to the <tt>string</tt> object named <tt>s</tt>. The <tt>*</tt> in <tt>*sp</tt> indicates that <tt>sp</tt> is a pointer. The <tt>&amp;</tt> operator in <tt>&amp;s</tt> is the <span class="docEmphStrong">address-of</span> operator. It returns a value that when dereferenced yields the original object. The address-of operator may be applied only to an lvalue (<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec10">Section 2.3.1</a>, p. <a class="docLink" href="ch02lev1sec3.html#ch02lev2sec10">45</a>). Because a variable is an lvalue, we may take its address. Similarly, the subscript and dereference operators, when applied to a <tt>vector, string</tt>, or built-in array, yield lvalues. Because these operators yield lvalues, we may apply the address-of to the result of the subscript or dereference operator. Doing so gives us the address of a particular element.</p>
<a name="ch04sb04"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<h2 class="docSidebarTitle">Advice: Avoid Pointers and Arrays</h2>
<p class="docText"><a name="idd1e24410"></a><span class="docEmphStrong">Pointers and arrays are surprisingly error-prone. Part of the problem is conceptual: Pointers are used for low-level manipulations and it is easy to make bookkeeping mistakes. Other problems arise because of the syntax, particularly the declaration syntax used with pointers.</span></p>
<p class="docText"><span class="docEmphStrong">Many useful programs can be written without needing to use arrays or pointers. Instead, modern C++ programs should use <tt>vector</tt>s and iterators to replace general arrays and <tt>string</tt>s to replace C-style array-based character strings.</span></p>
</td></TR></table></p><BR>

<a name="ch04lev2sec4"></a>
<H4 class="docSection2Title">4.2.2. Defining and Initializing Pointers</h4>
<p class="docText">Every pointer has an associated type. The type of a pointer determines the type of the objects to which the pointer may point. A pointer to <tt>int</tt>, for example, may only point to an object of type <tt>int</tt>.</p>
<a name="ch04lev3sec5"></a>
<h5 class="docSection3Title">Defining Pointer Variables</H5>
<p class="docText">We use the <tt>*</tt> symbol in a declaration to indicate that an identifier is a pointer:</P>
<pre>
          vector&lt;int&gt;   *pvec;      // <span class="docEmphasis">pvec</span> <span class="docEmphItalicAlt">can point to a</span> <span class="docEmphasis">vector&lt;int&gt;</span>
          int           *ip1, *ip2; // <span class="docEmphasis">ip1</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">ip2</span> <span class="docEmphItalicAlt">can point to an</span> <span class="docEmphasis">int</span>
          string        *pstring;   // <span class="docEmphasis">pstring</span> <span class="docEmphItalicAlt">can point to a</span> <span class="docEmphasis">string</span>
          double        *dp;        // <span class="docEmphasis">dp</span> <span class="docEmphItalicAlt">can point to a</span> <span class="docEmphasis">double</span>
</pre><br>
<a name="ch04note06"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="84" height="51" SRC="images/0201721481/graphics/tip.jpg;400478"></TD><td valign="top"><p class="docText"> When attempting to understand pointer declarations, read them from right to left.</p></TD></tr></table><br>
</P></div><br>
<p class="docText">Reading the definition of <tt>pstring</tt> from right to left, we see that</P>
<pre>
          string *pstring;
</pre><br>
<p class="docText">defines <tt>pstring</tt> as a pointer that can point to <tt>string</tt> objects. Similarly,</p>
<pre>
          int *ip1, *ip2; // <span class="docEmphasis">ip1</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">ip2</span> <span class="docEmphItalicAlt">can point to an</span> <span class="docEmphasis">int</span>
</pre><br>
<p class="docText">defines <tt>ip2</tt> as a pointer and <tt>ip1</tt> as a pointer. Both pointers point to <tt>int</tt>s.</p>
<p class="docText">The <tt>*</tt> can come anywhere in a list of objects of a given type:</p>
<pre>
          double dp, *dp2; // <span class="docEmphasis">dp2</span> <span class="docEmphItalicAlt">is a ponter,</span> <span class="docEmphasis">dp</span> <span class="docEmphItalicAlt">is an object: both type</span> <span class="docEmphasis">double</span>
</pre><br>
<p class="docText">defines <tt>dp2</tt> as a pointer and <tt>dp</tt> as an object, both of type <tt>double</tt>.</p>

<a name="ch04lev3sec6"></a>
<h5 class="docSection3Title">A Different Pointer Declaration Style</h5>
<p class="docText">The <tt>*</tt> symbol may be separated from its identifier by a space. It is legal to write:</p>
<pre>
          string* ps; // <span class="docEmphItalicAlt">legal but can be misleading</span>
</pre><br>
<p class="docText">which says that <tt>ps</tt> is a pointer to <tt>string</tt>.</p>
<p class="docText">We say that this definition can be misleading because it encourages the belief that <tt>string*</tt> is the type and any variable defined in the same definition is a pointer to <tt>string</tt>. However,</p>
<pre>
          string* ps1, ps2; // <span class="docEmphasis">ps1</span> <span class="docEmphItalicAlt">is a pointer to</span> <span class="docEmphasis">string,  ps2</span> <span class="docEmphItalicAlt">is a</span> <span class="docEmphasis">string</span>
</pre><BR>
<p class="docText"><a name="idd1e24666"></a><a name="idd1e24671"></a><a name="idd1e24676"></a><a name="idd1e24681"></a><a name="idd1e24686"></a>defines <tt>ps1</tt> as a pointer, but <tt>ps2</tt> is a plain <tt>string</tt>. If we want to define two pointers in a single definition, we must repeat the <tt>*</tt> on each identifier:</P>
<pre>
          string* ps1, *ps2; // <span class="docEmphItalicAlt">both</span> <span class="docEmphasis">ps1</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">ps2</span> <span class="docEmphItalicAlt">are pointers to</span> <span class="docEmphasis">string</span>
</pre><br>

<a name="ch04lev3sec7"></a>
<H5 class="docSection3Title">Multiple Pointer Declarations Can Be Confusing</h5>
<p class="docText">There are two common styles for declaring multiple pointers of the same type. One style requires that a declaration introduce only a single name. In this style, the <tt>*</tt> is placed with the type to emphasize that the declaration is declaring a pointer:</p>
<pre>
          string* ps1;
          string* ps2;
</pre><BR>
<p class="docText">The other style permits multiple declarations in a single statement but places the <tt>*</tt> adjacent to the identifier. This style emphasizes that the object is a pointer:</P>
<pre>
          string *ps1, *ps2;
</pre><br>
<a name="ch04note07"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="84" height="51" SRC="images/0201721481/graphics/tip.jpg;400478"></td><TD valign="top"><p class="docText"> As with all questions of style, there is no single right way to declare pointers. The important thing is to choose a style and stick with it.</p></TD></TR></table><br>
</p></div><br>
<p class="docText">In this book we use the second style and place the <tt>*</tt> with the pointer variable name.</P>

<a name="ch04lev3sec8"></a>
<H5 class="docSection3Title">Possible Pointer Values</h5>
<p class="docText">A valid pointer has one of three states: It can hold the address of a specific object, it can point one past the end of an object, or it can be zero. A zero-valued pointer points to no object. An uninitialized pointer is invalid until it is assigned a value. The following definitions and assignments are all legal:</p>
<pre>
          int ival = 1024;
          int *pi = 0;       // <span class="docEmphasis">pi</span> <span class="docEmphItalicAlt">initialized to address no object</span>
          int *pi2 = &amp; ival; // <span class="docEmphasis">pi2</span> <span class="docEmphItalicAlt">initialized to address of</span> <span class="docEmphasis">ival</span>
          int *pi3;          // <span class="docEmphItalicAlt">ok, but dangerous,</span> <span class="docEmphasis">pi3</span> <span class="docEmphItalicAlt">is uninitialized</span>
          pi = pi2;          // <span class="docEmphasis">pi</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">pi2</span> <span class="docEmphItalicAlt">address the same object, e.g.</span> <span class="docEmphasis">ival</span>
          pi2 = 0;           // <span class="docEmphasis">pi2</span> <span class="docEmphItalicAlt">now addresses no object</span>
</pre><br>

<a name="ch04lev3sec9"></a>
<h5 class="docSection3Title">Avoid Uninitialized Pointers</H5>
<a name="ch04note08"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> Uninitialized pointers are a common source of run-time errors.</P></td></TR></table><br>
</p></div><br>
<p class="docText">As with any other uninitialized variable, what happens when we use an uninitialized pointer is undefined. Using an uninitialized pointer almost always results in a run-time crash. However, the fact that the crash results from using an uninitialized pointer can be quite hard to track down.</p>
<p class="docText"><a name="idd1e24851"></a><a name="idd1e24855"></a><a name="idd1e24858"></a>Under most compilers, if we use an uninitialized pointer the effect will be to use whatever bits are in the memory in which the pointer resides as if it were an address. Using an uninitialized pointer uses this supposed address to manipulate the underlying data at that supposed location. Doing so usually leads to a crash as soon as we attempt to dereference the uninitialized pointer.</p>
<p class="docText">It is not possible to detect whether a pointer is uninitialized. There is no way to distinguish a valid address from an address formed from the bits that are in the memory in which the pointer was allocated. Our recommendation to initialize all variables is particularly important for pointers.</p>
<a name="ch04note09"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><td valign="top"><p class="docText"> If possible, do not define a pointer until the object to which it should point has been defined. That way, there is no need to define an uninitialized pointer.</p></td></TR></table><BR>
<p class="docText">If you must define a pointer separately from pointing it at an object, then initialize the pointer to zero. The reason is that a zero-valued pointer can be tested and the program can detect that the pointer does not point to an object.</p>
</P></div><br>

<a name="ch04lev3sec10"></a>
<h5 class="docSection3Title">Constraints on Initialization of and Assignment to Pointers</H5>
<p class="docText">There are only four kinds of values that may be used to initialize or assign to a pointer:</P>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">A constant expression (<a class="docLink" href="ch02lev1sec7.html#ch02lev1sec7">Section 2.7</a>, p. <a class="docLink" href="ch02lev1sec7.html#ch02lev1sec7">62</a>) with value 0 (e.g., a <tt>const</tt> integral object whose value is zero at compile time or a literal constant 0)</p></div></li><li><div style="font-weight:normal"><p class="docList">An address of an object of an appropriate type</p></div></LI><li><div style="font-weight:normal"><p class="docList">The address one past the end of another object</P></div></LI><li><div style="font-weight:normal"><p class="docList">Another valid pointer of the same type</p></div></li></ol></div>
<p class="docText">It is illegal to assign an <tt>int</tt> to a pointer, even if the value of the <tt>int</tt> happens to be 0. It is okay to assign the literal 0 or a <tt>const</tt> whose value is known to be <tt>0</tt> at compile time:</P>
<pre>
          int ival;
          int zero = 0;
          const int c_ival = 0;
          int *pi = ival; // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">pi</span> <span class="docEmphItalicAlt">initialized from int value of</span> <span class="docEmphasis">ival</span>
          pi = zero;      // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">pi</span> <span class="docEmphItalicAlt">assigned int value of zero</span>
          pi = c_ival;    // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">c_ival</span> <span class="docEmphItalicAlt">is a</span> <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">with compile-time value of 0</span>
          pi = 0;         // <span class="docEmphItalicAlt">ok: directly initialize to literal constant 0</span>
</pre><BR>
<p class="docText">In addition to using a literal 0 or a <tt>const</tt> with a compile-time value of 0, we can also use a facility that C++ inherits from C. The <tt>cstdlib</tt> header defines a preprocessor variable (<a class="docLink" href="ch02lev1sec9.html#ch02lev2sec31">Section 2.9.2</a>, p. <a class="docLink" href="ch02lev1sec9.html#ch02lev2sec31">69</a>) named <tt>NULL</tt>, which is defined as 0. When we use a preprocessor variable in our code, it is automatically replaced by its value. Hence, initializing a pointer to <tt>NULL</tt> is equivalent to initializing it to 0:</p>
<pre>
          // <span class="docEmphasis">cstdlib #defines NULL</span> <span class="docEmphItalicAlt">to 0</span>
          int *pi = NULL; // <span class="docEmphItalicAlt">ok: equivalent to</span> <span class="docEmphasis">int *pi = 0;</span>
</pre><br>
<p class="docText"><a name="idd1e25023"></a><a name="idd1e25030"></a><a name="idd1e25038"></a><a name="idd1e25043"></a>As with any preprocessor variable (<a class="docLink" href="ch02lev1sec9.html#ch02lev2sec31">Section 2.9.2</a>, p. <a class="docLink" href="ch02lev1sec9.html#ch02lev2sec31">71</a>) we should not use the name <tt>NULL</tt> for our own variables.</p>
<a name="ch04note10"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> Preprocessor variables are not defined in the <tt>std</tt> namespace and hence the name is <tt>NULL</tt>, not <tt>std::NULL</tt>.</p></td></TR></table><br>
</P></div><br>
<p class="docText">With two exceptions, which we cover in <a class="docLink" href="#ch04lev2sec7">Sections 4.2.5</a> and <a class="docLink" href="ch15lev1sec3.html#ch15lev1sec3">15.3</a>, we may only initialize or assign a pointer from an address or another pointer that has the same type as the target pointer:</p>
<pre>
          double dval;
          double *pd = &amp;dval;   // <span class="docEmphItalicAlt">ok: initializer is address of a</span> <span class="docEmphasis">double</span>
          double *pd2 = pd;     // <span class="docEmphItalicAlt">ok: initializer is a pointer to</span> <span class="docEmphasis">double</span>

          int *pi = pd;   // <span class="docEmphItalicAlt">error: types of</span> <span class="docEmphasis">pi</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">pd</span> <span class="docEmphItalicAlt">differ</span>
          pi = &amp;dval;     // <span class="docEmphItalicAlt">error: attempt to assign address of a</span> <span class="docEmphasis">double</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">int *</span>
</pre><br>
<p class="docText">The reason the types must match is that the type of the pointer is used to determine the type of the object that it addresses. Pointers are used to indirectly access an object. The operations that the pointer can perform are based on the type of the pointer: A pointer to <tt>int</tt> treats the underlying object as if it were an <tt>int</tt>. If that pointer actually addressed an object of some other type, such as <tt>double</tt>, then any operations performed by the pointer would be in error.</p>

<a name="ch04lev3sec11"></a>
<h5 class="docSection3Title"><tt>void*</tt> Pointers</h5>
<p class="docText">The type <b><a name="ch04term20"></a><a class="docLink" href="ch04lev1sec6.html#gloss04_20"><span class="docEmphStrong"><tt>void*</tt></span></a></b> is a special pointer type that can hold an address of any object:</p>
<pre>
          double obj = 3.14;
          double *pd = &amp;obj;
          // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">void*</span> <span class="docEmphItalicAlt">can hold the address value of any data pointer type</span>
          void *pv = &amp;obj;       // <span class="docEmphasis">obj</span> <span class="docEmphItalicAlt">can be an object of any type</span>
          pv = pd;               // <span class="docEmphasis">pd</span> <span class="docEmphItalicAlt">can be a pointer to any type</span>
</pre><br>
<p class="docText">A <tt>void*</tt> indicates that the associated value is an address but that the type of the object at that address is unknown.</p>
<p class="docText">There are only a limited number of actions we can perform on a <tt>void*</tt> pointer: We can compare it to another pointer, we can pass or return it from a function, and we can assign it to another <tt>void*</tt> pointer. We cannot use the pointer to operate on the object it addresses. We'll see in <a class="docLink" href="ch05lev1sec12.html#ch05lev2sec28">Section 5.12.4</a> (p. <a class="docLink" href="ch05lev1sec12.html#ch05lev2sec28">183</a>) how we can retrieve the address stored in a <tt>void*</tt> pointer.</p>


<a name="ch04lev2sec5"></a>
<h4 class="docSection2Title">4.2.3. Operations on Pointers</H4>
<p class="docText">Pointers allow indirect manipulation of the object to which the pointer points. We can access the object by dereferencing the pointer. Dereferencing a pointer is similar to dereferencing an iterator (<a class="docLink" href="ch03lev1sec4.html#ch03lev1sec4">Section 3.4</a>, p. <a class="docLink" href="ch03lev1sec4.html#ch03lev1sec4">98</a>). The <tt>*</tt> operator (the dereference operator) returns the object to which the pointer points:</P>
<pre>
          string s("hello world");
          string *sp = &amp;s; // <span class="docEmphasis">sp</span> <span class="docEmphItalicAlt">holds the address of</span> <span class="docEmphasis">s</span>
          cout  &lt;&lt;*sp;     // <span class="docEmphItalicAlt">prints</span> <span class="docEmphasis">hello world</span>
</pre><br>
<a name="ch04sb05"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Exercises Section 4.2.2</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa3q1"></a><b>Exercise 4.10:</b></td><TD><p class="docText"><a name="idd1e25268"></a><a name="idd1e25275"></a><a name="idd1e25282"></a><a name="idd1e25290"></a><a name="idd1e25298"></a><a name="idd1e25308"></a><a name="idd1e25313"></a>Explain the rationale for preferring the first form of pointer declaration:</p>
<pre>
          int *ip; // <span class="docEmphItalicAlt">good practice</span>
          int* ip; // <span class="docEmphItalicAlt">legal but misleading</span>
</pre><BR>
</TD></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa3q2"></a><B>Exercise 4.11:</b></TD><td><p class="docText">Explain each of the following definitions. Indicate whether any are illegal and if so why.</p>
<pre>
          (a) int* ip;
          (b) string s, *sp = 0;
          (c) int i; double* dp = &amp;i;
          (d) int* ip, ip2;
          (e) const int i = 0, *p = i;
          (f) string *p = NULL;
</pre><br>
</td></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa3q3"></a><B>Exercise 4.12:</b></td><td><p class="docText">Given a pointer, <tt>p</tt>, can you determine whether <tt>p</tt> points to a valid object? If so, how? If not, why not?</P>
</td></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa3q4"></a><b>Exercise 4.13:</b></td><td><p class="docText">Why is the first pointer initialization legal and the second illegal?</p>
<pre>
          int i = 42;
          void *p = &amp;i;
          long *lp = &amp;i;
</pre><br>
</td></tr></table></p>
</blockquote>
</td></tr></table></p><BR>
<p class="docText">When we dereference <tt>sp</tt>, we fetch the value of <tt>s</tt>. We hand that value to the output operator. The last statement, therefore, prints the contents of <tt>s</tt>that is, <tt>hello world</tt>.</P>
<a name="ch04lev3sec12"></a>
<h5 class="docSection3Title">Dereference Yields an Lvalue</H5>
<p class="docText">The dereference operator returns the lvalue of the underlying object, so we can use it to change the value of the object to which the pointer points:</p>
<pre>
          *sp = "goodbye"; // <span class="docEmphItalicAlt">contents of</span> <span class="docEmphasis">s</span> <span class="docEmphItalicAlt">now changed</span>
</pre><br>
<p class="docText">Because we assign to <tt>*sp</tt>, this statement leaves <tt>sp</tt> pointing to <tt>s</tt> and changes the value of <tt>s</tt>.</P>
<p class="docText">We can also assign a new value to <tt>sp</tt> itself. Assigning to <tt>sp</tt> causes <tt>sp</tt> to point to a different object:</P>
<pre>
          string s2 = "some value";
          sp = &amp;s2;  // <span class="docEmphasis">sp</span> <span class="docEmphItalicAlt">now points to</span> <span class="docEmphasis">s2</span>
</pre><br>
<p class="docText">We change the value of a pointer by assigning to it directlywithout dereferencing the pointer.</p>
<a name="ch04sb06"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Key Concept: Assigning <span class="docEmphasis">TO</span> or <span class="docEmphasis">THROUGH</span> a Pointer</h2>
<p class="docText"><a name="idd1e25480"></a><a name="idd1e25485"></a><span class="docEmphStrong">When first using pointers, the difference in whether an assignment is to the pointer or through the pointer to the value pointed to can be confusing. The important thing to keep in mind is that if the left-hand operand is dereferenced, then the value pointed to is changed. If there is no dereference, then the pointer itself is being changed. A picture can sometimes help:</span></P>

<p class="docText">
<img border="0" alt="" width="500" height="269" SRC="images/0201721481/graphics/121fig01.gif;400478"></P>

</td></tr></table></p><BR>

<a name="ch04lev3sec13"></a>
<H5 class="docSection3Title">Comparing Pointers and References</h5>
<p class="docText">While both references and pointers are used to indirectly access another value, there are two important differences between references and pointers. The first is that a reference always refers to an object: It is an error to define a reference without initializing it. The behavior of assignment is the second important difference: Assigning to a reference changes the object to which the reference is bound; it does not rebind the reference to another object. Once initialized, a reference <span class="docEmphasis">always</span> refers to the same underlying object.</p>
<p class="docText">Consider these two program fragments. In the first, we assign one pointer to another:</p>
<pre>
          int ival = 1024, ival2 = 2048;
          int *pi = &amp;ival, *pi2 = &amp;ival2;
          pi = pi2;    // <span class="docEmphasis">pi</span> <span class="docEmphItalicAlt">now points to</span> <span class="docEmphasis">ival2</span>
</pre><br>
<p class="docText">After the assignment, <tt>ival</tt>, the object addressed by <tt>pi</tt> remains unchanged. The assignment changes the value of <tt>pi</tt>, making it point to a different object. Now consider a similar program that assigns two references:</P>
<pre>
          int &amp;ri = ival, &amp;ri2 = ival2;
          ri = ri2;    // <span class="docEmphItalicAlt">assigns</span> <span class="docEmphasis">ival2</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">ival</span>
</pre><br>
<p class="docText">This assignment changes <tt>ival</tt>, the value referenced by <tt>ri</tt>, and not the reference itself. After the assignment, the two references still refer to their original objects, and the value of those objects is now the same as well.</p>

<a name="ch04lev3sec14"></a>
<H5 class="docSection3Title">Pointers to Pointers</h5>
<p class="docText"><a name="idd1e25577"></a><a name="idd1e25582"></a><a name="idd1e25587"></a><a name="idd1e25592"></a><a name="idd1e25597"></a>Pointers are themselves objects in memory. They, therefore, have addresses that we can store in a pointer:</p>
<pre>
          int ival = 1024;
          int *pi = &amp;ival; // <span class="docEmphItalicAlt">pi points to an int</span>
          int **ppi = &amp;pi; // <span class="docEmphItalicAlt">ppi points to a pointer to int</span>
</pre><BR>
<p class="docText">which yields a pointer to a pointer. We designate a pointer to a pointer by using <tt>**</tt>. We might represent these objects as</p>

<p class="docText">
<img border="0" alt="" width="303" height="53" SRC="images/0201721481/graphics/122fig01.gif;400478"></P>

<p class="docText">As usual, dereferencing <tt>ppi</tt> yields the object to which <tt>ppi</tt> points. In this case, that object is a pointer to an <tt>int</tt>:</p>
<pre>
          int *pi2 = *ppi; // <span class="docEmphasis">ppi</span> <span class="docEmphItalicAlt">points to a pointer</span>
</pre><br>
<p class="docText">To actually access <tt>ival</tt>, we need to dereference <tt>ppi</tt> twice:</p>
<pre>
          cout &lt;&lt; "The value of ival\n"
               &lt;&lt; "direct value: " &lt;&lt; ival &lt;&lt; "\n"
               &lt;&lt; "indirect value: " &lt;&lt; *pi &lt;&lt; "\n"
               &lt;&lt; "doubly indirect value: " &lt;&lt; **ppi
               &lt;&lt; endl;
</pre><br>
<p class="docText">This program prints the value of <tt>ival</tt> three different ways. First, by direct reference to the variable. Then, through the pointer to <tt>int</tt> in <tt>pi</tt>, and finally, by dereferencing <tt>ppi</tt> twice to get to the underlying value in <tt>ival</tt>.</p>
<a name="ch04sb07"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 4.2.3</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch04qa4q1"></a><B>Exercise 4.14:</b></td><TD><p class="docText">Write code to change the value of a pointer. Write code to change the value to which the pointer points.</p>
</td></TR><TR valign="top"><td align="right" class="docText" width="50"><a name="ch04qa4q2"></a><b>Exercise 4.15:</b></td><td><p class="docText">Explain the key differences between pointers and references.</p>
</TD></tr><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch04qa4q3"></a><b>Exercise 4.16:</b></td><td><p class="docText">What does the following program do?</P>
<pre>
          int i = 42, j = 1024;
          int *p1 = &amp;i, *p2 = &amp;j;
          *p2 = *p1 * *p2;
          *p1 *= *p1;
</pre><BR>
</td></tr></table></p>
</blockquote>
</td></TR></table></p><br>


<a name="ch04lev2sec6"></a>
<H4 class="docSection2Title">4.2.4. Using Pointers to Access Array Elements</h4>
<p class="docText">Pointers and arrays are closely intertwined in C++. In particular, when we use the name of an array in an expression, that name is automatically converted into a pointer to the first element of the array:</p>
<pre>
          int ia[] = {0,2,4,6,8};
          int *ip = ia; // <span class="docEmphasis">ip</span> <span class="docEmphItalicAlt">points to</span> <span class="docEmphasis">ia[0]</span>
</pre><BR>
<p class="docText"><a name="idd1e25760"></a><a name="idd1e25767"></a><a name="idd1e25774"></a><a name="idd1e25782"></a><a name="idd1e25787"></a><a name="idd1e25792"></a><a name="idd1e25798"></a><a name="idd1e25808"></a><a name="idd1e25821"></a><a name="idd1e25824"></a><a name="idd1e25829"></a>If we want to point to another element in the array, we could do so by using the subscript operator to locate the element and then applying the address-of operator to find its location:</p>
<pre>
          ip = &amp;ia[4];    // <span class="docEmphasis">ip</span> <span class="docEmphItalicAlt">points to last element in</span> <span class="docEmphasis">ia</span>
</pre><BR>
<a name="ch04lev3sec15"></a>
<h5 class="docSection3Title">Pointer Arithmetic</h5>
<p class="docText">Rather than taking the address of the value returned by subscripting, we could use <b><a name="ch04term12"></a><a class="docLink" href="ch04lev1sec6.html#gloss04_12">pointer arithmetic</a></b>. Pointer arithmetic works the same way (and has the same constraints) as iterator arithmetic (<a class="docLink" href="ch03lev1sec4.html#ch03lev2sec14">Section 3.4.1</a>, p. <a class="docLink" href="ch03lev1sec4.html#ch03lev2sec14">100</a>). Using pointer arithmetic, we can compute a pointer to an element by adding (or subtracting) an integral value to (or from) a pointer to another element in the array:</p>
<pre>
          ip = ia;            // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">ip</span> <span class="docEmphItalicAlt">points to</span> <span class="docEmphasis">ia[0]</span>
          int *ip2 = ip + 4;  // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">ip2</span> <span class="docEmphItalicAlt">points to</span> <span class="docEmphasis">ia[4]</span>, <span class="docEmphItalicAlt">the last element in</span> <span class="docEmphasis">ia</span>
</pre><br>
<p class="docText">When we add <tt>4</tt> to the pointer <tt>ip</tt>, we are computing a new pointer. That new pointer points to the element four elements further on in the array from the one to which <tt>ip</tt> currently points.</p>
<p class="docText">More generally, when we add (or subtract) an integral value to a pointer, the effect is to compute a new pointer. The new pointer points to the element as many elements as that integral value ahead of (or behind) the original pointer.</p>
<a name="ch04note11"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> Pointer arithmetic is legal only if the original pointer and the newly calculated pointer address elements of the same array or an element one past the end of that array. If we have a pointer to an object, we can also compute a pointer that points just after that object by adding one to the pointer.</p></TD></TR></table><br>
</P></div><br>
<p class="docText">Given that <tt>ia</tt> has 4 elements, adding 10 to <tt>ia</tt> would be an error:</p>
<pre>
          // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">ia</span> <span class="docEmphItalicAlt">has only 4 elements,</span> <span class="docEmphasis">ia</span> <span class="docEmphItalicAlt">+ 10 is an invalid address</span>
          int *ip3 = ia + 10;
</pre><BR>
<p class="docText">We can also subtract two pointers as long as they point into the same array or to an element one past the end of the array:</P>
<pre>
          ptrdiff_t n = ip2 - ip; // <span class="docEmphItalicAlt">ok: distance between the pointers</span>
</pre><br>
<p class="docText">The result is four, the distance between the two pointers, measured in objects. The result of subtracting two pointers is a library type named <b><a name="ch04term14"></a><a class="docLink" href="ch04lev1sec6.html#gloss04_14"><span class="docEmphStrong"><tt>ptrdiff_t</tt>.</span></a></b> Like <tt>size_t</tt>, the <tt>ptrdiff_t</tt> type is a machine-specific type and is defined in the <tt>cstddef</tt> header. The <tt>size_t</tt> type is an <tt>unsigned</tt> type, whereas <tt>ptrdiff_t</tt> is a <tt>signed</tt> integral type.</p>
<p class="docText">The difference in type reflects how these two types are used: <tt>size_t</tt> is used to hold the size of an array, which must be a positive value. The <tt>ptrdiff_t</tt> type is guaranteed to be large enough to hold the difference between any two pointers into <a name="idd1e26012"></a><a name="idd1e26019"></a><a name="idd1e26032"></a><a name="idd1e26037"></a><a name="idd1e26040"></a>the same array, which might be a negative value. For example, had we subtracted <tt>ip2</tt> from <tt>ip</tt>, the result would be <tt>-4</tt>.</p>
<p class="docText">It is always possible to add or subtract zero to a pointer, which leaves the pointer unchanged. More interestingly, given a pointer that has a value of zero, it is also legal to add zero to that pointer. The result is another zero-valued pointer. We can also subtract two pointers that have a value of zero. The result of subtracting two zero-valued pointers is zero.</p>

<a name="ch04lev3sec16"></a>
<H5 class="docSection3Title">Interaction between Dereference and Pointer Arithmetic</h5>
<p class="docText">The result of adding an integral value to a pointer is itself a pointer. We can dereference the resulting pointer directly without first assigning it to another pointer:</P>
<pre>
          int last = *(ia + 4); // <span class="docEmphItalicAlt">ok: initializes</span> <span class="docEmphasis">last</span> <span class="docEmphItalicAlt">to 8, the value of</span> <span class="docEmphasis">ia[4]</span>
</pre><BR>
<p class="docText">This expression calculates the address four elements past <tt>ia</tt> and dereferences that pointer. It is equivalent to writing <tt>ia[4]</tt>.</p>
<a name="ch04note12"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><td valign="top"><p class="docText"> The parentheses around the addition are essential. Writing</p></td></tr></table><BR>
<pre>
          last = *ia + 4;     // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">last</span> <span class="docEmphItalicAlt">= 4, equivalent to</span> <span class="docEmphasis">ia[0]+4</span>
</pre><br>
<p class="docText">means dereference <tt>ia</tt> and add four to the dereferenced value.</p>
</P></div><br>
<p class="docText">The parentheses are required due to the <b><a name="ch04term13"></a><a class="docLink" href="ch04lev1sec6.html#gloss04_13">precedence</a></b> of the addition and dereference operators. We'll learn more about precedence in <a class="docLink" href="ch05lev1sec10.html#ch05lev2sec14">Section 5.10.1</a> (p. <a class="docLink" href="ch05lev1sec10.html#ch05lev2sec14">168</a>). Simply put, precedence stipulates how operands are grouped in expressions with multiple operators. The dereference operator has a higher precedence than the addition operator.</P>
<p class="docText">The operands to operators with higher precedence are grouped more tightly than those of lower precedence. Without the parentheses, the dereference operator would use <tt>ia</tt> as its operand. The expression would be evaluated by dereferencing <tt>ia</tt> and adding four to the value of the element at the beginning of <tt>ia</tt>.</p>
<p class="docText">By parenthesizing the expression, we override the normal precedence rules and effectively treat <tt>(ia + 4)</tt> as a single operand. That operand is an address of an element four past the one to which <tt>ia</tt> points. That new address is dereferenced.</P>

<a name="ch04lev3sec17"></a>
<h5 class="docSection3Title">Subscripts and Pointers</h5>
<p class="docText">We have already seen that when we use an array name in an expression, we are actually using a pointer to the first element in the array. This fact has a number of implications, which we shall point out as they arise.</p>
<p class="docText">One important implication is that when we subscript an array, we are really subscripting a pointer:</p>
<pre>
          int ia[] = {0,2,4,6,8};
          int i = ia[0]; // <span class="docEmphasis">ia</span> <span class="docEmphItalicAlt">points to the first element in</span> <span class="docEmphasis">ia</span>
</pre><br>
<p class="docText">When we write <tt>ia[0]</tt>, that is an expression that uses the name of an array. When we subscript an array, we are really subscripting a pointer to an element in that array. We can use the subscript operator on any pointer, as long as that pointer points to an element in an array:</p>
<pre>
          int *p = &amp;ia[2];     // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">p</span> <span class="docEmphItalicAlt">points to the element indexed by 2</span>
          int j = p[1];        // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">p[1]</span> <span class="docEmphItalicAlt">equivalent to</span> <span class="docEmphasis">*(p + 1)</span>,
                               //    <span class="docEmphasis">p[1]</span> <span class="docEmphItalicAlt">is the same element as</span> <span class="docEmphasis">ia[3]</span>
          int k = p[-2];       // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">p[-2]</span> <span class="docEmphItalicAlt">is the same element as</span> <span class="docEmphasis">ia[0]</span>
</pre><br>

<a name="ch04lev3sec18"></a>
<h5 class="docSection3Title">Computing an Off-the-End Pointer</h5>
<p class="docText"><a name="idd1e26253"></a><a name="idd1e26256"></a>When we use a <tt>vector</tt>, the <tt>end</tt> operation returns an iterator that refers just past the end of the <tt>vector</tt>. We often use this iterator as a sentinel to control loops that process the elements in the <tt>vector</tt>. Similarly, we can compute an off-the-end pointer value:</p>
<pre>
          const size_t arr_size = 5;
          int arr[arr_size] = {1,2,3,4,5};
          int *p = arr;           // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">p</span> <span class="docEmphItalicAlt">points to</span> <span class="docEmphasis">arr[0]</span>
          int *p2 = p + arr_size; // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">p2</span> <span class="docEmphItalicAlt">points one past the end of</span> <span class="docEmphasis">arr</span>
                                  //    <span class="docEmphItalicAlt">use caution -- do not dereference!</span>
</pre><br>
<p class="docText">In this case, we set <tt>p</tt> to point to the first element in <tt>arr</tt>. We then calculate a pointer one past the end of <tt>arr</tt> by adding the size of <tt>arr</tt> to the pointer value in <tt>p</tt>. When we add <tt>5</tt> to <tt>p</tt>, the effect is to calculate the address of that is five <tt>int</tt>s away from <tt>p</tt>in other words, <tt>p + 5</tt> points just past the end of <tt>arr</tt>.</p>
<a name="ch04note13"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> It is legal to compute an address one past the end of an array or object. It is not legal to dereference a pointer that holds such an address. Nor is it legal to compute an address more than one past the end of an array or an address before the beginning of an array.</p></td></TR></table><BR>
</p></div><br>
<p class="docText">The address we calculated and stored in <tt>p2</tt> acts much like the iterator returned from the <tt>end</tt> operation on <tt>vector</tt>s. The iterator we obtain from <tt>end</tt> denotes &quot;one past the end&quot; of the <tt>vector</tt>. We may not dereference that iterator, but we may compare it to another iterator value to see whether we have processed all the elements in the <tt>vector</tt>. Similarly, the value we calculated for <tt>p2</tt> can be used <span class="docEmphasis">only</span> to compare to another pointer value or as an operand in a pointer arithmetic expression. If we attempt to dereference <tt>p2</tt>, the most likely result is that it would yield some garbage value. Most compilers, would treat the result of dereferencing <tt>p2</tt> as an <tt>int</tt>, using whatever bits happened to be in memory at the location just after the last element in <tt>arr</tt>.</p>

<a name="ch04lev3sec19"></a>
<h5 class="docSection3Title">Printing the Elements of an Array</h5>
<p class="docText">Now we are ready to write a program that uses pointers:</P>
<pre>
          const size_t arr_sz = 5;
          int int_arr[arr_sz] = { 0, 1, 2, 3, 4 };
          // <span class="docEmphasis">pbegin</span> <span class="docEmphItalicAlt">points to first element,</span> <span class="docEmphasis">pend</span> <span class="docEmphItalicAlt">points just after the last</span>
          for (int *pbegin = int_arr, *pend = int_arr + arr_sz;
                    pbegin != pend; ++pbegin)
              cout &lt;&lt; *pbegin &lt;&lt; ' '; // <span class="docEmphItalicAlt">print the current element</span>
</pre><br>
<p class="docText">This program uses a feature of the <tt>for</tt> loop that we have not yet used: We may define multiple variables inside the <span class="docEmphasis">init-statement</span> (<a class="docLink" href="ch01lev1sec4.html#ch01lev2sec6">Section 1.4.2</a>, p. <a class="docLink" href="ch01lev1sec4.html#ch01lev2sec6">14</a>) of a <tt>for</tt> as long as the variables are defined using the same type. In this case, we're defining two <tt>int</tt> pointers named <tt>pbegin</tt> and <tt>pend</tt>.</P>
<p class="docText">We use these pointers to traverse the array. Like other built-in types, arrays have no member functions. Hence, there are no <tt>begin</tt> and <tt>end</tt> operations on arrays. Instead, we must position pointers to denote the first and one past the last elements ourselves. We do so in the initialization of our two pointers. We initialize <tt>pbegin</tt> to address the first element of <tt>int_arr</tt> and <tt>pend</tt> to one past the last element in the array:</P>

<p class="docText">
<img border="0" alt="" width="312" height="112" SRC="images/0201721481/graphics/126fig01.gif;400478"></p>

<p class="docText">The pointer <tt>pend</tt> serves as a sentinel, allowing the <tt>for</tt> loop to know when to stop. Each iteration of the <tt>for</tt> loop increments <tt>pbegin</tt> to address the next element. On the first trip through the loop, <tt>pbegin</tt> denotes the first element, on the second iteration, the second element, and so on. After processing the last element in the array, <tt>pbegin</tt> will be incremented once more and will then equal <tt>pend</tt>. At that point we know that we have iterated across the entire array.</p>

<a name="ch04lev3sec20"></a>
<h5 class="docSection3Title">Pointers Are Iterators for Arrays</H5>
<p class="docText">Astute readers will note that this program is remarkably similar to the program on page <a class="docLink" href="ch03lev1sec4.html#ch03lev2sec13">99</a>, which traversed and printed the contents of a <tt>vector</tt> of <tt>string</tt>s. The loop in that program</P>
<pre>
          // <span class="docEmphItalicAlt">equivalent loop using iterators to reset all the elements in</span> <span class="docEmphasis">ivec</span> <span class="docEmphItalicAlt">to 0</span>
          for (vector&lt;int&gt;::iterator iter = ivec.begin();
                                     iter != ivec.end(); ++iter)
              *iter = 0; // <span class="docEmphItalicAlt">set element to which</span> <span class="docEmphasis">iter</span> <span class="docEmphItalicAlt">refers to 0</span>
</pre><br>
<p class="docText">used iterators in much the same way that pointers are used in the program to print the contents of the array. This similarity is not a coincidence. In fact, the built-in array type has many of the properties of a library container, and pointers, when we use them in conjunction with arrays, are themselves iterators. We'll have much more to say about containers and iterators in <a class="docLink" href="part02.html#part02">Part II</a>.</p>


<a name="ch04lev2sec7"></a>
<h4 class="docSection2Title">4.2.5. Pointers and the <tt>const</tt> Qualifier</h4>
<p class="docText">There are two kinds of interactions between pointers and the <tt>const</tt> qualifier discussed in <a class="docLink" href="ch02lev1sec4.html#ch02lev1sec4">Section 2.4</a> (p. <a class="docLink" href="ch02lev1sec4.html#ch02lev1sec4">56</a>): We can have pointers to <tt>const</tt> objects and pointers that are themselves <tt>const</tt>. This section discusses both kinds of pointers.</P>
<a name="ch04lev3sec21"></a>
<h5 class="docSection3Title">Pointers to <tt>const</tt> Objects</h5>
<p class="docText">The pointers we've seen so far can be used to change the value of the objects to which they point. But if we have a pointer to a <tt>const</tt> object, we do not want to <a name="idd1e26590"></a><a name="idd1e26599"></a><a name="idd1e26603"></a><a name="idd1e26611"></a><a name="idd1e26616"></a><a name="idd1e26626"></a>allow that pointer to change the underlying, <tt>const</tt> value. The language enforces this property by requiring that pointers to <tt>const</tt> objects must take the <tt>const</tt>ness of their target into account:</P>
<pre>
          const double *cptr;  // <span class="docEmphasis">cptr</span> <span class="docEmphItalicAlt">may point to a</span> <span class="docEmphasis">double</span> <span class="docEmphItalicAlt">that is</span> <span class="docEmphasis">const</span>
</pre><br>
<a name="ch04sb08"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<H2 class="docSidebarTitle">Exercises Section 4.2.4</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa5q1"></a><b>Exercise 4.17:</b></td><td><p class="docText">Given that p1 and p2 point to elements in the same array, what does the following statement do?</p>
<pre>
          p1 += p2 - p1;
</pre><br>
<p class="docText">Are there any values of <tt>p1</tt> or <tt>p2</tt> that could make this code illegal?</p>
</td></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch04qa5q2"></a><B>Exercise 4.18:</b></td><TD><p class="docText">Write a program that uses pointers to set the elements in an array of <tt>int</tt>s to zero.</p>
</td></TR></table></P>
</blockquote>
</td></tr></table></p><br>
<p class="docText">Here <tt>cptr</tt> is a pointer to an object of type <tt>const double</tt>. The <tt>const</tt> qualifies the type of the object to which <tt>cptr</tt> points, not <tt>cptr</tt> itself. That is, <tt>cptr</tt> itself is not <tt>const</tt>. We need not initialize it and can assign a new value to it if we so desire. What we cannot do is use <tt>cptr</tt> to change the value to which it points:</p>
<pre>
          *cptr = 42;   // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">*cptr</span> <span class="docEmphItalicAlt">might be</span> <span class="docEmphasis">const</span>
</pre><BR>
<p class="docText">It is also a compile-time error to assign the address of a <tt>const</tt> object to a plain, non<tt>const</tt> pointer:</p>
<pre>
          const double pi = 3.14;
          double *ptr = &amp;pi;        // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">ptr</span> <span class="docEmphItalicAlt">is a plain pointer</span>
          const double *cptr = &amp;pi; // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">cptr</span> <span class="docEmphItalicAlt">is a pointer to</span> <span class="docEmphasis">const</span>
</pre><BR>
<p class="docText">We cannot use a <tt>void*</tt> pointer (<a class="docLink" href="#ch04lev2sec4">Section 4.2.2</a>, p. <a class="docLink" href="#ch04lev2sec4">119</a>) to hold the address of a <tt>const</tt> object. Instead, we must use the type <B><a name="ch04term4"></a><a class="docLink" href="ch04lev1sec6.html#gloss04_04"><span class="docEmphStrong"><tt>const void*</tt></span></a></b> to hold the address of a <tt>const</tt> object:</p>
<pre>
          const int universe = 42;
          const void *cpv = &amp;universe; // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">cpv</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">const</span>
          void *pv = &amp;universe;        // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">universe</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">const</span>
</pre><br>
<p class="docText">A pointer to a <tt>const</tt> object can be assigned the address of a non<tt>const</tt> object, such as</p>
<pre>
          double dval = 3.14; // <span class="docEmphasis">dval</span> <span class="docEmphItalicAlt">is a</span> <span class="docEmphasis">double;</span> <span class="docEmphItalicAlt">its value can be changed</span>
          cptr = &amp;dval;       // <span class="docEmphItalicAlt">ok: but can't change</span> <span class="docEmphasis">dval</span> <span class="docEmphItalicAlt">through</span> <span class="docEmphasis">cptr</span>
</pre><BR>
<p class="docText">Although <tt>dval</tt> is not a <tt>const</tt>, any attempt to modify its value through <tt>cptr</tt> results in a compile-time error. When we declared <tt>cptr</tt>, we said that it would not change the value to which it points. The fact that it happens to point to a non<tt>const</tt> object is irrelevant.</P>
<a name="ch04note14"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"><a name="idd1e26911"></a><a name="idd1e26917"></a> We cannot use a pointer to <tt>const</tt> to change the underlying object. However, if the pointer addresses a non<tt>const</tt> object, it is possible that some other action will change the object to which the pointer points.</p></td></TR></table><br>
</p></div><BR>
<p class="docText">The fact that values to which a <tt>const</tt> pointer points can be changed is subtle and can be confusing. Consider:</p>
<pre>
          dval = 3.14159;       // <span class="docEmphasis">dval</span> <span class="docEmphItalicAlt">is not</span> <span class="docEmphasis">const</span>
          *cptr = 3.14159;      // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">cptr</span> <span class="docEmphItalicAlt">is a pointer to</span> <span class="docEmphasis">const</span>
          double *ptr = &amp;dval;  // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">ptr</span> <span class="docEmphItalicAlt">points at non-</span><span class="docEmphasis">const double</span>
          *ptr = 2.72;          // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">ptr</span> <span class="docEmphItalicAlt">is plain pointer</span>
          cout &lt;&lt; *cptr;        // <span class="docEmphItalicAlt">ok: prints 2.72</span>
</pre><BR>
<p class="docText">In this case, <tt>cptr</tt> is defined as a pointer to <tt>const</tt> but it actually points at a non<tt>const</tt> object. Even though the object to which it points is non<tt>const</tt>, we cannot use <tt>cptr</tt> to change the object's value. Essentially, there is no way for <tt>cptr</tt> to know whether the object it points to is <tt>const</tt>, and so it treats all objects to which it might point as <tt>const</tt>.</p>
<p class="docText">When a pointer to <tt>const</tt> does point to a non<tt>const</tt>, it is possible that the value of the object might change: After all, that value is not <tt>const</tt>. We could either assign to it directly or, as here, indirectly through another, plain non<tt>const</tt> pointer. It is important to remember that there is no guarantee that an object pointed to by a pointer to <tt>const</tt> won't change.</p>
<a name="ch04note15"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="84" height="51" SRC="images/0201721481/graphics/tip.jpg;400478"></td><td valign="top"><p class="docText"> It may be helpful to think of pointers to <tt>const</tt> as &quot;pointers that <span class="docEmphasis">think</span> they point to <tt>const</tt>.&quot;</p></td></tr></table><br>
</p></div><br>
<p class="docText">In real-world programs, pointers to <tt>const</tt> occur most often as formal parameters of functions. Defining a parameter as a pointer to <tt>const</tt> serves as a contract guaranteeing that the actual object being passed into the function will not be modified through that parameter.</P>

<a name="ch04lev3sec22"></a>
<H5 class="docSection3Title"><tt>const</tt> Pointers</h5>
<p class="docText">In addition to pointers to <tt>const</tt>, we can also have <tt>const</tt> pointersthat is, pointers whose own value we may not change:</P>
<pre>
          int errNumb = 0;
          int *const curErr = &amp;errNumb; // <span class="docEmphasis">curErr</span> <span class="docEmphItalicAlt">is a constant pointer</span>
</pre><br>
<p class="docText">Reading this definition from right to left, we see that &quot;<tt>curErr</tt> is a constant pointer to an object of type <tt>int</tt>.&quot; As with any <tt>const</tt>, we may not change the value of the pointerthat is, we may not make it point to any other object. Any attempt to assign to a constant pointereven assigning the same value back to <tt>curErr</tt>is flagged as an error during compilation:</p>
<pre>
          curErr = curErr; // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">curErr</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">const</span>
</pre><BR>
<p class="docText">As with any <tt>const</tt>, we must initialize a <tt>const</tt> pointer when we create it.</P>
<p class="docText"><a name="idd1e27135"></a><a name="idd1e27144"></a><a name="idd1e27149"></a>The fact that a pointer is itself <tt>const</tt> says nothing about whether we can use the pointer to change the value to which it points. Whether we can change the value pointed to depends entirely on the type to which the pointer points. For example, <tt>curErr</tt> addresses a plain, non<tt>const int</tt>. We can use <tt>curErr</tt> to change the value of <tt>errNumb</tt>:</p>
<pre>
          if (*curErr) {
              errorHandler();
              *curErr = 0; // <span class="docEmphItalicAlt">ok: reset value of the object to which</span> <span class="docEmphasis">curErr</span> <span class="docEmphItalicAlt">is bound</span>
          }
</pre><br>

<a name="ch04lev3sec23"></a>
<h5 class="docSection3Title"><tt>const</tt> Pointer to a <tt>const</tt> Object</h5>
<p class="docText">We can also define a constant pointer to a constant object as follows:</p>
<pre>
          const double pi = 3.14159;
          // <span class="docEmphasis">pi_ptr</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">and points to a</span> <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">object</span>
          const double *const pi_ptr = &amp;pi;
</pre><BR>
<p class="docText">In this case, neither the value of the object addressed by <tt>pi_ptr</tt> nor the address itself can be changed. We can read its definition from right to left as &quot;<tt>pi_ptr</tt> is a constant pointer to an object of type <tt>double</tt> defined as <tt>const</tt>.&quot;</p>

<a name="ch04lev3sec24"></a>
<H5 class="docSection3Title">Pointers and Typedefs</H5>
<p class="docText">The use of pointers in typedefs (<a class="docLink" href="ch02lev1sec6.html#ch02lev1sec6">Section 2.6</a>, p. <a class="docLink" href="ch02lev1sec6.html#ch02lev1sec6">61</a>) often leads to surprising results. Here is a question almost everyone answers incorrectly at least once. Given the following,</p>
<pre>
          typedef string *pstring;
          const pstring cstr;
</pre><br>
<p class="docText">what is the type of <tt>cstr</tt>? The simple answer is that it is a pointer to <tt>const pstring</tt>. The deeper question is: what underlying type does a pointer to <tt>const pstring</tt> represent? Many think that the actual type is</p>
<pre>
          const string *cstr; // <span class="docEmphItalicAlt">wrong interpretation of const pstring cstr</span>
</pre><BR>
<p class="docText">That is, that a <tt>const pstring</tt> would be a pointer to a constant <tt>string</tt>. But that is incorrect.</P>
<p class="docText">The mistake is in thinking of a typedef as a textual expansion. When we declare a <tt>const pstring</tt>, the <tt>const</tt> modifies the type of <tt>pstring</tt>, which is a pointer. Therefore, this definition declares <tt>cstr</tt> to be a <tt>const</tt> pointer to <tt>string</tt>. The definition is equivalent to</p>
<pre>
          // <span class="docEmphItalicAlt">cstr is a const pointer to string</span>
          string *const cstr; // <span class="docEmphItalicAlt">equivalent to const pstring cstr</span>
</pre><br>
<a name="ch04sb09"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Advice: Understanding Complicated <tt>const</tt> Type Declarations</h2>
<p class="docText"><a name="idd1e27333"></a><a name="idd1e27336"></a><a name="idd1e27339"></a><a name="idd1e27344"></a><a name="idd1e27349"></a><a name="idd1e27354"></a><span class="docEmphStrong">Part of the problem in reading <tt>const</tt> declarations arises because the <tt>const</tt> can go either before or after the type:</span></P>
<pre>
          string const s1;   // <span class="docEmphasis">s1</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">s2</span> <span class="docEmphItalicAlt">have same type</span>,
          const string s2;   // <span class="docEmphItalicAlt">they're both</span> <span class="docEmphasis">string</span><span class="docEmphItalicAlt">s that are</span> <span class="docEmphasis">const</span>
</pre><br>
<p class="docText"><span class="docEmphStrong">When writing <tt>const</tt> definitions using typedefs, the fact that the <tt>const</tt> can precede the type can lead to confusion as to the actual type being defined:</span></p>
<pre><a name="PLID55"></a><div class="v1"><a href="ch04lev1sec2.html#PLID55">[View full width]</a></div>
          string s;
          typedef string *pstring;
          const pstring cstr1 = &amp;s; // <span class="docEmphItalicAlt">written this way the type
<img border="0" width="14" height="9" alt="" align="left" src="images/ccc.gif"> is obscured</span>
          pstring const cstr2 = &amp;s; // <span class="docEmphItalicAlt">all three decreations are
<img border="0" width="14" height="9" alt="" align="left" src="images/ccc.gif"> the same type</span>
          string *const cstr3 = &amp;s; // <span class="docEmphItalicAlt">they're all</span> <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">pointers
<img border="0" width="14" height="9" alt="" align="left" src="images/ccc.gif"> to</span> <span class="docEmphasis">string</span>
</pre><BR>
<p class="docText"><span class="docEmphStrong">Putting the <tt>const</tt> after <tt>pstring</tt> and reading the declaration from right to left makes it clearer that <tt>cstr2</tt> is a <tt>const pstring</tt>, which in turn is a <tt>const</tt> pointer to <tt>string</tt>.</span></p>
<p class="docText"><span class="docEmphStrong">Unfortunately, most readers of C++ programs expect to see the <tt>const</tt> before the type. As a result, it is probably a good idea to put the <tt>const</tt> first, respecting common practice. But it can be helpful in understanding declarations to rewrite them to put the <tt>const</tt> after the type.</span></P>
</td></tr></table></p><br>



<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch04lev1sec1.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch04lev1sec3.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>