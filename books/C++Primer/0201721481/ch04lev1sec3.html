<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 4.3.&nbsp; C-Style Character Strings</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch04lev1sec2.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch04lev1sec4.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch04lev1sec3"></a>
<h3 class="docSection1Title">4.3. C-Style Character Strings</h3>
<a name="ch04note16"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></TD><td valign="top"><p class="docText"> Although C++ supports C-style strings, they should not be used by C++ programs. C-style strings are a surprisingly rich source of bugs and are the root cause of many, many security problems.</p></TD></TR></table><br>
</p></div><br>
<p class="docText">In <a class="docLink" href="ch02lev1sec2.html#ch02lev1sec2">Section 2.2</a> (p. <a class="docLink" href="ch02lev1sec2.html#ch02lev1sec2">40</a>) we first used string literals and learned that the type of a string literal is array of constant characters. We can now be more explicit and note that the type of a string literal is an array of <tt>const char</tt>. A string literal is an instance of a more general construct that C++ inherits from C: <span class="docEmphStrong">C-style character strings</span>. C-style strings are not actually a type in either C or C++. Instead, C-style strings are null-terminated arrays of characters:</p>
<pre>
          char ca1[] = {'C', '+', '+'};        // <span class="docEmphItalicAlt">no null, not C-style string</span>
          char ca2[] = {'C', '+', '+', '\0'};  // <span class="docEmphItalicAlt">explicit null</span>
          char ca3[] = "C++";     // <span class="docEmphItalicAlt">null terminator added automatically</span>
          const char *cp = "C++"; // <span class="docEmphItalicAlt">null terminator added automatically</span>
          char *cp1 = ca1;   // <span class="docEmphItalicAlt">points to first element of a array, but not C-style string</span>
          char *cp2 = ca2;   // <span class="docEmphItalicAlt">points to first element of a null-terminated</span> <span class="docEmphasis">char</span> <span class="docEmphItalicAlt">array</span>
</pre><br>
<p class="docText">Neither <tt>ca1</tt> nor <tt>cp1</tt> are C-style strings: <tt>ca1</tt> is a character array, but the array is not null-terminated. <tt>cp1</tt>, which points to <tt>ca1</tt>, therefore, does not point to a null-terminated array. The other declarations are all C-style strings, remembering that the name of an array is treated as a pointer to the first element of the array. Thus, <tt>ca2</tt> and <tt>ca3</tt> are pointers to the first elements of their respective arrays.</P>
<a name="ch04sb10"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<h2 class="docSidebarTitle">Exercises Section 4.3</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch04qa6q1"></a><b>Exercise 4.19:</b></td><td><p class="docText"><a name="idd1e27569"></a>Explain the meaning of the following five definitions. Identify any illegal definitions.</p>
<pre>
          (a) int i;
          (b) const int ic;
          (c) const int *pic;
          (d) int *const cpi;
          (e) const int *const cpic;
</pre><BR>
</td></tr><TR valign="top"><td align="right" class="docText" width="50"><a name="ch04qa6q2"></a><b>Exercise 4.20:</b></TD><td><p class="docText">Which of the following initializations are legal? Explain why.</P>
<pre>
          (a) int i = -1;
          (b) const int ic = i;
          (c) const int *pic = &amp;ic;
          (d) int *const cpi = &amp;ic;
          (e) const int *const cpic = &amp;ic;
</pre><br>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa6q3"></a><b>Exercise 4.21:</b></td><td><p class="docText">Based on the definitions in the previous exercise, which of the following assignments are legal? Explain why.</p>
<pre>
          (a) i = ic;
          (b) pic = &amp;ic;
          (c) cpi = pic;
          (d) pic = cpic;
          (e) cpic = &amp;ic;
          (f) ic = *cpic;
</pre><br>
</td></tr></table></p>
</blockquote>
</TD></TR></table></p><BR>
<a name="ch04lev2sec8"></a>
<h4 class="docSection2Title">Using C-style Strings</h4>
<p class="docText">C-style strings are manipulated through (<tt>const</tt>) <tt>char*</tt> pointers. One frequent usage pattern uses pointer arithmetic to traverse the C-style string. The traversal tests and increments the pointer until we reach the terminating null character:</P>
<pre>
          const char *cp = "some value";
          while (*cp) {
              // <span class="docEmphItalicAlt">do something to</span> <span class="docEmphasis">*cp</span>
              ++cp;
          }
</pre><BR>
<p class="docText">The condition in the <tt>while</tt> dereferences the <tt>const char*</tt> pointer <tt>cp</tt> and the resulting character is tested for its <tt>true</tt> or <tt>false</tt> value. A true value is any character other than the null. So, the loop continues until it encounters the null character that terminates the array to which <tt>cp</tt> points. The body of the <tt>while</tt> does whatever processing is needed and concludes by incrementing <tt>cp</tt> to advance the pointer to address the next character in the array.</p>
<a name="ch04note17"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></TD><td valign="top"><p class="docText"> This loop will fail if the array that <tt>cp</tt> addresses is not null-terminated. If this case, the loop is apt to read characters starting at <tt>cp</tt> until it encounters a null character somewhere in memory.</P></TD></tr></table><br>
</p></div><BR>

<a name="ch04lev2sec9"></a>
<H4 class="docSection2Title">C Library String Functions</h4>
<p class="docText"><a name="idd1e27696"></a><a name="idd1e27701"></a><a name="idd1e27706"></a><a name="idd1e27712"></a><a name="idd1e27717"></a>The Standard C library provides a set of functions, listed in <a class="docLink" href="#ch04table01">Table 4.1</a>, that operate on C-style strings. To use these functions, we must include the associated C header file</p>
<a name="ch04table01"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 4.1. C-Style Character String Functions</H5></caption><colgroup><col width="200"><col width="300"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>strlen(s)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns the length of <tt>s</tt>, not counting the null.</P></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>strcmp(s1, s2)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Compares <tt>s1</tt> and <tt>s2</tt> for equality. Returns 0 if <tt>s1 == s2</tt>, positive value if <tt>s1 &gt; s2</tt>, negative value if <tt>s1 &lt; s2</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>strcat(s1, s2)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Appends <tt>s2</tt> to <tt>s1</tt>. Returns <tt>s1</tt>.</P></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>strcpy(s1, s2)</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Copies <tt>s2</tt> into <tt>s1</tt>. Returns <tt>s1</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>strncat(s1, s2,n)</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Appends <tt>n</tt> characters from <tt>s2</tt> onto <tt>s1</tt>. Returns <tt>s1</tt>.</P></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>strncpy(s1, s2, n)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Copies <tt>n</tt> characters from <tt>s2</tt> into <tt>s1</tt>. Returns <tt>s1</tt>.</p></td></TR></table></p><br>
<pre>
          #include &lt;cstring&gt;
</pre><BR>
<p class="docText">which is the C++ version of the <tt>string.h</tt> header from the C library.</p>
<a name="ch04note18"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></TD><td valign="top"><p class="docText"> These functions do no checking on their string parameters.</p></td></tr></table><br>
</p></div><br>
<p class="docText">The pointer(s) passed to these routines must be nonzero and each pointer must point to the initial character in a null-terminated array. Some of these functions write to a string they are passed. These functions assume that the array to which they write is large enough to hold whatever characters the function generates. It is up to the programmer to ensure that the target string is big enough.</p>
<p class="docText">When we compare library <tt>string</tt>s, we do so using the normal relational operators. We can use these operators to compare pointers to C-style strings, but the effect is quite different; what we're actually comparing is the pointer values, not the strings to which they point:</p>
<pre>
          if (cp1 &lt; cp2) // <span class="docEmphItalicAlt">compares addresses, not the values pointed to</span>
</pre><br>
<p class="docText">Assuming <tt>cp1</tt> and <tt>cp2</tt> point to elements in the same array (or one past that array), then the effect of this comparison is to compare the address in <tt>cp1</tt> with the address in <tt>cp2</tt>. If the pointers do not address the same array, then the comparison is undefined.</p>
<p class="docText">To compare the strings, we must use <tt>strcmp</tt> and interpret the result:</p>
<pre>
          const char *cp1 = "A string example";
          const char *cp2 = "A different string";
          int i = strcmp(cp1, cp2);    // <span class="docEmphasis">i</span> <span class="docEmphItalicAlt">is positive</span>
          i = strcmp(cp2, cp1);        // <span class="docEmphasis">i</span> <span class="docEmphItalicAlt">is negative</span>
          i = strcmp(cp1, cp1);        // <span class="docEmphasis">i</span> <span class="docEmphItalicAlt">is zero</span>
</pre><br>
<p class="docText"><a name="idd1e27961"></a><a name="idd1e27965"></a><a name="idd1e27969"></a><a name="idd1e27973"></a><a name="idd1e27977"></a><a name="idd1e27981"></a>The <tt>strcmp</tt> function returns three possible values: 0 if the strings are equal; or a positive or negative value, depending on whether the first string is larger or smaller than the second.</P>

<a name="ch04lev2sec10"></a>
<H4 class="docSection2Title">Never Forget About the Null-Terminator</h4>
<p class="docText">When using the C library string functions it is essential to remember the strings must be null-terminated:</P>
<pre>
          char ca[] = {'C', '+', '+'}; // <span class="docEmphItalicAlt">not null-terminated</span>
          cout &lt;&lt; strlen(ca) &lt;&lt; endl; // <span class="docEmphItalicAlt">disaster:</span> <span class="docEmphasis">ca</span> <span class="docEmphItalicAlt">isn't null-terminated</span>
</pre><br>
<p class="docText">In this case, <tt>ca</tt> is an array of characters but is not null-terminated. What happens is undefined. The <tt>strlen</tt> function assumes that it can rely on finding a null character at the end of its argument. The most likely effect of this call is that <tt>strlen</tt> will keep looking through the memory that follows wherever <tt>ca</tt> happens to reside until it encounters a null character. In any event, the return from <tt>strlen</tt> will not be the correct value.</p>

<a name="ch04lev2sec11"></a>
<H4 class="docSection2Title">Caller Is Responsible for Size of a Destination String</H4>
<p class="docText">The array that we pass as the first argument to <tt>strcat</tt> and <tt>strcpy</tt> <span class="docEmphasis">must</span> be large enough to hold the generated string. The code we show here, although a common usage pattern, is frought with the potential for serious error:</p>
<pre>
          // <span class="docEmphItalicAlt">Dangerous: What happens if we miscalculate the size of</span> <span class="docEmphasis">largeStr?</span>
          char largeStr[16 + 18 + 2];         // <span class="docEmphItalicAlt">will hold</span> <span class="docEmphasis">cp1</span> <span class="docEmphItalicAlt">a space and</span> <span class="docEmphasis">cp2</span>
          strcpy(largeStr, cp1);              // <span class="docEmphItalicAlt">copies</span> <span class="docEmphasis">cp1</span> <span class="docEmphItalicAlt">into</span> <span class="docEmphasis">largeStr</span>
          strcat(largeStr, " ");              // <span class="docEmphItalicAlt">adds a space at end of</span> <span class="docEmphasis">largeStr</span>
          strcat(largeStr, cp2);              // <span class="docEmphItalicAlt">concatenates</span> <span class="docEmphasis">cp2</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">largeStr</span>
          // <span class="docEmphasis">prints A string example A different string</span>
          cout &lt;&lt; largeStr &lt;&lt; endl;
</pre><br>
<p class="docText">The problem is that we could easily miscalculate the size needed in <tt>largeStr</tt>. Similarly, if we later change the sizes of the strings to which either <tt>cp1</tt> or <tt>cp2</tt> point, then the calculated size of <tt>largeStr</tt> will be wrong. Unfortunately, programs similar to this code are widely distributed. Programs with such code are error-prone and often lead to serious security leaks.</p>

<a name="ch04lev2sec12"></a>
<h4 class="docSection2Title">When Using C-Style Strings, Use the <tt>strn</tt> Functions</h4>
<p class="docText">If you must use C-style strings, it is usually safer to use the <tt>strncat</tt> and <tt>strncpy</tt> functions instead of <tt>strcat</tt> and <tt>strcpy</tt>:</P>
<pre>
          char largeStr[16 + 18 + 2]; // <span class="docEmphItalicAlt">to hold</span> <span class="docEmphasis">cp1</span> <span class="docEmphItalicAlt">a space and</span> <span class="docEmphasis">cp2</span>
          strncpy(largeStr, cp1, 17); // <span class="docEmphItalicAlt">size to copy includes the null</span>
          strncat(largeStr, " ", 2);  // <span class="docEmphItalicAlt">pedantic, but a good habit</span>
          strncat(largeStr, cp2, 19); // <span class="docEmphItalicAlt">adds at most 18 characters, plus a null</span>
</pre><br>
<p class="docText">The trick to using these versions is to properly calculate the value to control how many characters get copied. In particular, we must <span class="docEmphasis">always</span> remember to account for the null when copying or concatenating characters. We must allocate space for the <a name="idd1e28181"></a><a name="idd1e28188"></a><a name="idd1e28193"></a><a name="idd1e28198"></a>null because that is the character that terminates <tt>largeStr</tt> after each call. Let's walk through these calls in detail:</P>
<UL><li><p class="docList">On the call to <tt>strncpy</tt>, we ask to copy 17 characters: all the characters in <tt>cp1</tt> plus the null. Leaving room for the null is necessary so that <tt>largeStr</tt> is properly terminated. After the <tt>strncpy</tt> call, <tt>largeStr</tt> has a <tt>strlen</tt> value of 16. Remember, <tt>strlen</tt> counts the characters in a C-style string, not including the null.</p></li><LI><p class="docList">When we call <tt>strncat</tt>, we ask to copy two characters: the space and the null that terminates the string literal. After this call, <tt>largeStr</tt> has a <tt>strlen</tt> of 17. The null that had ended <tt>largeStr</tt> is overwritten by the space that we appended. A new null is written after that space.</P></li><li><p class="docList">When we append <tt>cp2</tt> in the second call, we again ask to copy all the characters from <tt>cp2</tt>, <span class="docEmphasis">including</span> the null. After this call, the <tt>strlen</tt> of <tt>largeStr</tt> would be 35: 16 characters from <tt>cp1</tt>, 18 from <tt>cp2</tt>, and 1 for the space that separates the two strings.</p></li></UL>
<p class="docText">The array size of <tt>largeStr</tt> remains 36 throughout.</p>
<p class="docText">These operations are safer than the simpler versions that do not take a size argument as long as we calculate the size argument correctly. If we ask to copy or concatenate more characters than the size of the target array, we will still overrun that array. If the string we're copying from or concatenating is bigger than the requested size, then we'll inadvertently truncate the new version. Truncating is safer than overrunning the array, but it is still an error.</p>

<a name="ch04lev2sec13"></a>
<H4 class="docSection2Title">Whenever Possible, Use Library <tt>string</tt>s</h4>
<p class="docText">None of these issues matter if we use C++ library <tt>string</tt>s:</p>
<pre>
          string largeStr = cp1; // <span class="docEmphItalicAlt">initialize</span> <span class="docEmphasis">large Str</span> <span class="docEmphItalicAlt">as a copy of</span> <span class="docEmphasis">cp1</span>
          largeStr += " ";       // <span class="docEmphItalicAlt">add space at end of</span> <span class="docEmphasis">largeStr</span>
          largeStr += cp2;       // <span class="docEmphItalicAlt">concatenate</span> <span class="docEmphasis">cp2</span> <span class="docEmphItalicAlt">onto end of</span> <span class="docEmphasis">largeStr</span>
</pre><BR>
<p class="docText">Now the library handles all memory management, and we need no longer worry if the size of either string changes.</p>
<a name="ch04note19"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> For most applications, in addition to being safer, it is also more efficient to use library <tt>string</tt>s rather than C-style strings.</p></td></tr></table><br>
</p></div><br>

<a name="ch04lev2sec14"></a>
<h4 class="docSection2Title">4.3.1. Dynamically Allocating Arrays</h4>
<p class="docText">A variable of array type has three important limitations: Its size is fixed, the size must be known at compile time, and the array exists only until the end of the block in which it was defined. Real-world programs usually cannot live with these restrictionsthey need a way to allocate an array <b><a name="ch04term7"></a><a class="docLink" href="ch04lev1sec6.html#gloss04_07">dynamically</a></b> at run time. Although all arrays have fixed size, the size of a dynamically allocated array need <a name="idd1e28367"></a><a name="idd1e28372"></a><a name="idd1e28376"></a><a name="idd1e28383"></a><a name="idd1e28386"></a><a name="idd1e28389"></a><a name="idd1e28393"></a>not be fixed at compile time. It can be (and usually is) determined at run time. Unlike an array variable, a dynamically allocated array continues to exist until it is explicitly freed by the program.</P>
<a name="ch04sb11"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Exercises Section 4.3</h2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><td align="right" class="docText" width="50"><a name="ch04qa7q1"></a><b>Exercise 4.22:</b></td><td><p class="docText">Explain the difference between the following two <tt>while</tt> loops:</p>
<pre>
          const char *cp = "hello";
          int cnt;
          while (cp) { ++cnt; ++cp; }
          while (*cp) { ++cnt; ++cp; }
</pre><BR>
</td></TR><TR valign="top"><td align="right" class="docText" width="50"><a name="ch04qa7q2"></a><b>Exercise 4.23:</b></td><TD><p class="docText">What does the following program do?</P>
<pre>
          const char ca[] = {'h', 'e', 'l', 'l', 'o'};
          const char *cp = ca;
          while (*cp) {
              cout &lt;&lt; *cp &lt;&lt; endl;
              ++cp;
          }
</pre><br>
</td></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch04qa7q3"></a><b>Exercise 4.24:</b></td><TD><p class="docText">Explain the differences between <tt>strcpy</tt> and <tt>strncpy</tt>. What are the advantages of each? The disadvantages?</p>
</td></TR><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch04qa7q4"></a><b>Exercise 4.25:</b></td><td><p class="docText">Write a program to compare two <tt>string</tt>s. Now write a program to compare the value of two C-style character strings.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa7q5"></a><b>Exercise 4.26:</b></td><td><p class="docText">Write a program to read a <tt>string</tt> from the standard input. How might you write a program to read from the standard input into a C-style character string?</p>
</td></TR></table></P>
</blockquote>
</td></TR></table></p><br>
<p class="docText">Every program has a pool of available memory it can use during program execution to hold dynamically allocated objects. This pool of available memory is referred to as the program's <B><a name="ch04term8"></a><a class="docLink" href="ch04lev1sec6.html#gloss04_08">free store</a></b> or <B><a name="ch04term9"></a><a class="docLink" href="ch04lev1sec6.html#gloss04_09">heap</a></b>. C programs use a pair of functions named <tt>malloc</tt> and <tt>free</tt> to allocate space from the free store. In C++ we use <b><a name="ch04term10"></a><a class="docLink" href="ch04lev1sec6.html#gloss04_10"><span class="docEmphStrong"><tt>new</tt></span></a></b> and <b><a name="ch04term5"></a><a class="docLink" href="ch04lev1sec6.html#gloss04_05"><span class="docEmphStrong"><tt>delete</tt></span></a></b> expressions.</p>
<a name="ch04lev3sec25"></a>
<h5 class="docSection3Title">Defining a Dynamic Array</h5>
<p class="docText">When we define an array variable, we specify a type, a name, and a dimension. When we dynamically allocate an array, we specify the type and size but do not name the object. Instead, the <tt>new</tt> expression returns a pointer to the first element in the newly allocated array:</P>
<pre>
          int *pia = new int[10]; // <span class="docEmphItalicAlt">array of 10 uninitialized</span> <span class="docEmphasis">ints</span>
</pre><br>
<p class="docText">This <tt>new</tt> expression allocates an array of ten <tt>int</tt>s and returns a pointer to the first element in that array, which we use to initialize <tt>pia</tt>.</P>
<p class="docText">A <tt>new</tt> expression takes a type and optionally an array dimension specified inside a bracket-pair. The dimension can be an arbitrarily complex expression. When we allocate an array, <tt>new</tt> returns a pointer to the first element in the array. <a name="idd1e28555"></a><a name="idd1e28561"></a><a name="idd1e28566"></a><a name="idd1e28573"></a><a name="idd1e28578"></a>Objects allocated on the free store are unnamed. We use objects on the heap only indirectly through their address.</P>

<a name="ch04lev3sec26"></a>
<h5 class="docSection3Title">Initializing a Dynamically Allocated Array</h5>
<p class="docText">When we allocate an array of objects of a class type, then that type's default constructor (<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec13">Section 2.3.4</a>, p. <a class="docLink" href="ch02lev1sec3.html#ch02lev2sec13">50</a>) is used to initialize each element. If the array holds elements of built-in type, then the elements are uninitialized:</p>
<pre>
          string *psa = new string[10]; // <span class="docEmphItalicAlt">array of 10 empty</span> <span class="docEmphasis">strings</span>
          int *pia = new int[10];       // <span class="docEmphItalicAlt">array of 10 uninitialized</span> <span class="docEmphasis">ints</span>
</pre><BR>
<p class="docText">Each of these <tt>new</tt> expressions allocates an array of ten objects. In the first case, those objects are <tt>string</tt>s. After allocating memory to hold the objects, the default <tt>string</tt> constructor is run on each element of the array in turn. In the second case, the objects are a built-in type; memory to hold ten <tt>int</tt>s is allocated, but the elements are uninitialized.</P>
<p class="docText">Alternatively, we can value-initialize (<a class="docLink" href="ch03lev1sec3.html#ch03lev2sec6">Section 3.3.1</a>, p. <a class="docLink" href="ch03lev1sec3.html#ch03lev2sec6">92</a>) the elements by following the array size by an empty pair of parentheses:</p>
<pre>
          int *pia2 = new int[10] (); // <span class="docEmphItalicAlt">array of 10 uninitialized</span> <span class="docEmphasis">ints</span>
</pre><br>
<p class="docText">The parentheses are effectively a request to the compiler to value-initialize the array, which in this case sets its elements to 0.</p>
<a name="ch04note20"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> The elements of a dynamically allocated array can be initialized only to the default value of the element type. The elements cannot be initialized to separate values as can be done for elements of an array variable.</p></td></TR></table><br>
</P></div><br>

<a name="ch04lev3sec27"></a>
<h5 class="docSection3Title">Dynamic Arrays of <tt>const</tt> Objects</h5>
<p class="docText">If we create an array of <tt>const</tt> objects of built-in type on the free store, we must initialize that array: The elements are <tt>const</tt>, there is no way to assign values to the elements. The only way to initialize the elements is to value-initialize the array:</p>
<pre>
          // <span class="docEmphItalicAlt">error: uninitialized</span> <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">array</span>
          const int *pci_bad = new const int[100];
          // <span class="docEmphItalicAlt">ok: value-initialized</span> <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">array</span>
          const int *pci_ok = new const int[100]();
</pre><br>
<p class="docText">It is possible to have a <tt>const</tt> array of elements of a class type that provides a default constructor:</p>
<pre>
          // <span class="docEmphItalicAlt">ok: array of 100 empty</span> <span class="docEmphasis">strings</span>
          const string *pcs = new const string[100];
</pre><br>
<p class="docText">In this case, the default constructor is used to initialize the elements of the array.</p>
<p class="docText">Of course, once the elements are created, they may not be changedwhich means that such arrays usually are not very useful.</p>

<a name="ch04lev3sec28"></a>
<h5 class="docSection3Title">It Is Legal to Dynamically Allocate an Empty Array</h5>
<p class="docText"><a name="idd1e28741"></a><a name="idd1e28747"></a>When we dynamically allocate an array, we often do so because we don't know the size of the array at compile time. We might write code such as</p>
<pre>
          size_t n = get_size(); // <span class="docEmphasis">get_size</span> <span class="docEmphItalicAlt">returns number of elements needed</span>
          int* p = new int[n];
          for (int* q = p; q != p + n; ++q)
               /* <span class="docEmphItalicAlt">process the array</span> */ ;
</pre><br>
<p class="docText">to figure out the size of the array and then allocate and process the array.</P>
<p class="docText">An interesting question is: What happens if <tt>get_size</tt> returns 0? The answer is that our code works fine. The language specifies that a call to <tt>new</tt> to create an array of size zero is legal. It is legal even though we could not create an array variable of size 0:</P>
<pre>
          char arr[0];            // <span class="docEmphItalicAlt">error: cannot define zero-length array</span>
          char *cp = new char[0]; // <span class="docEmphItalicAlt">ok: but</span> <span class="docEmphasis">cp</span> <span class="docEmphItalicAlt">can't be dereferenced</span>
</pre><br>
<p class="docText">When we use <tt>new</tt> to allocate an array of zero size, <tt>new</tt> returns a valid, nonzero pointer. This pointer will be distinct from any other pointer returned by <tt>new</tt>. The pointer cannot be dereferencedafter all, it points to no element. The pointer can be compared and so can be used in a loop such as the preceeding one. It is also legal to add (or subtract) zero to such a pointer and to subtract the pointer from itself, yielding zero.</P>
<p class="docText">In our hypothetical loop, if the call to <tt>get_size</tt> returned 0, then the call to <tt>new</tt> would still succeed. However, <tt>p</tt> would not address any element; the array is empty. Because <tt>n</tt> is zero, the <tt>for</tt> loop effectively compares <tt>q</tt> to <tt>p</tt>. These pointers are equal; <tt>q</tt> was initialized to <tt>p</tt>, so the condition in the <tt>for</tt> fails and the loop body is not executed.</p>

<a name="ch04lev3sec29"></a>
<h5 class="docSection3Title">Freeing Dynamic Memory</H5>
<p class="docText">When we allocate memory, we must eventually free it. Otherwise, memory is gradually used up and may be exhausted. When we no longer need the array, we must <span class="docEmphasis">explicitly</span> return its memory to the free store. We do so by applying the <tt>delete []</tt> expression to a pointer that addresses the array we want to release:</P>
<pre>
          delete [] pia;
</pre><br>
<p class="docText">deallocates the array pointed to by <tt>pia</tt>, returning the associated memory to the free store. The empty bracket pair between the <tt>delete</tt> keyword and the pointer is necessary: It indicates to the compiler that the pointer addresses an array of elements on the free store and not simply a single object.</p>
<a name="ch04note21"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></TD><td valign="top"><p class="docText"> If the empty bracket pair is omitted, it is an error, but an error that the compiler is unlikely to catch; the program may fail at run time.</P></TD></tr></table><br>
</p></div><BR>
<p class="docText">The least serious run-time consequence of omitting brackets when freeing an array is that too little memory will be freed, leading to a memory leak. On some systems <a name="idd1e28888"></a><a name="idd1e28895"></a><a name="idd1e28900"></a>and/or for some element types, more serious run-time problems are possible. It is essential to remember the bracket-pair when deleting pointers to arrays.</P>
<a name="ch04sb12"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Contrasting C-Style Strings and C++ Library <tt>string</tt>s</H2>
<p class="docText"><span class="docEmphStrong">The following two programs illustrate the differences in using C-style character strings versus using the C++ library <tt>string</tt> type. The <tt>string</tt> version is shorter, easier to understand, and less error-prone:</span></p>
<pre><a name="PLID22"></a><div class="v1"><a href="ch04lev1sec3.html#PLID22">[View full width]</a></div>
          // <span class="docEmphItalicAlt">C-style character string implementation</span>
             const char *pc = "a very long literal string";
             const size_t len = strlen(pc +1);      // <span class="docEmphItalicAlt">space to
<img border="0" width="14" height="9" alt="" align="left" src="images/ccc.gif"> allocate</span>
             // <span class="docEmphItalicAlt">performance test on string allocation and copy</span>
             for (size_t ix = 0; ix != 1000000; ++ix) {
                 char *pc2 = new char[len + 1]; // <span class="docEmphItalicAlt">allocate the space</span>
                 strcpy(pc2, pc);               // <span class="docEmphItalicAlt">do the copy</span>
                 if (strcmp(pc2, pc))           // <span class="docEmphItalicAlt">use the new string</span>
                     ;   // <span class="docEmphItalicAlt">do nothing</span>
                 delete [] pc2;                 // <span class="docEmphItalicAlt">free the memory</span>
          }
          // <span class="docEmphItalicAlt">string implementation</span>
             string str("a very long literal string");
             // <span class="docEmphItalicAlt">performance test on string allocation and copy</span>
             for (int ix = 0; ix != 1000000; ++ix) {
                 string str2 = str; // <span class="docEmphItalicAlt">do the copy, automatically
<img border="0" width="14" height="9" alt="" align="left" src="images/ccc.gif"> allocated</span>
                 if (str != str2)           // <span class="docEmphItalicAlt">use the new string</span>
                       ;  // <span class="docEmphItalicAlt">do nothing</span>
          }
                                            // <span class="docEmphasis">str2</span> <span class="docEmphItalicAlt">is
<img border="0" width="14" height="9" alt="" align="left" src="images/ccc.gif"> automatically freed</span>
</pre><br>
<p class="docText"><span class="docEmphStrong">These programs are further explored in the exercises to <a class="docLink" href="#ch04lev2sec14">Section 4.3.1</a> (p. <a class="docLink" href="#ch04lev2sec14">139</a>).</span></P>
</td></tr></table></P><br>

<a name="ch04lev3sec30"></a>
<H5 class="docSection3Title">Using Dynamically Allocated Arrays</h5>
<p class="docText">A common reason to allocate an array dynamically is if its dimension cannot be known at compile time. For example, <tt>char*</tt> pointers are often used to refer to multiple C-style strings during the execution of a program. The memory used to hold the various strings typically is allocated dynamically during program execution based on the length of the string to be stored. This technique is considerably safer than allocating a fixed-size array. Assuming we correctly calculate the size needed at run time, we no longer need to worry that a given string will overflow the fixed size of an array variable.</p>
<p class="docText">Suppose we have the following C-style strings:</p>
<pre>
          const char *noerr = "success";
          // ...
          const char *err189 = "Error: a function declaration must "
                               "specify a function return type!";
</pre><br>
<p class="docText">We might want to copy one or the other of these strings at run time to a new character array. We could calculate the dimension at run time, as follows:</p>
<pre>
    const char *errorTxt;
    if (errorFound)
        errorTxt = err189;
    else
        errorTxt = noerr;
    // <span class="docEmphItalicAlt">remember the 1 for the terminating null</span>
    int dimension = strlen(errorTxt) + 1;
    char *errMsg = new char[dimension];
    // <span class="docEmphItalicAlt">copy the text for the error into</span> <span class="docEmphasis">errMsg</span>
    strncpy (errMsg, errorTxt, dimension);
</pre><br>
<p class="docText">Recall that <tt>strlen</tt> returns the length of the string <span class="docEmphasis">not</span> including the null. It is essential to remember to add 1 to the length returned from <tt>strlen</tt> to accommodate the trailing null.</p>
<a name="ch04sb13"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 4.3.1</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch04qa8q1"></a><b>Exercise 4.27:</b></TD><td><p class="docText">Given the following <tt>new</tt> expression, how would you <tt>delete pa</tt>?</p>
<pre>
     int *pa = new int[10];
</pre><BR>
</TD></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa8q2"></a><b>Exercise 4.28:</b></td><TD><p class="docText">Write a program to read the standard input and build a <tt>vector</tt> of <tt>int</tt>s from values that are read. Allocate an array of the same size as the <tt>vector</tt> and copy the elements from the <tt>vector</tt> into the array.</p>
</TD></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa8q3"></a><b>Exercise 4.29:</b></TD><TD><p class="docText">Given the two program fragments in the highlighted box on page <a class="docLink" href="#ch04sb12">138</a>,</p>
<div style="font-weight:bold"><ol class="docList" type="a"><li><div style="font-weight:normal"><p class="docList">Explain what the programs do.</p></div></li><LI><div style="font-weight:normal"><p class="docList">As it happens, on average, the <tt>string</tt> class implementation executes considerably faster than the C-style string functions. The relative average execution times on our more than five-year-old PC are as follows:</p><pre>
          user       0.47    # string class
          user       2.55    # C-style character string
</pre><br></div></LI></ol></div>
<p class="docText">Did you expect that? How would you account for it?</p>
</td></TR><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch04qa8q4"></a><b>Exercise 4.30:</b></td><td><p class="docText">Write a program to concatenate two C-style string literals, putting the result in a C-style string. Write a program to concatenate two library <tt>string</tt>s that have the same value as the literals used in the first program.</p>
</td></tr></table></p>
</blockquote>
</td></tr></table></p><br>


<a name="ch04lev2sec15"></a>
<h4 class="docSection2Title">4.3.2. Interfacing to Older Code</h4>
<p class="docText">Many C++ programs exist that predate the standard library and so do not yet use the <tt>string</tt> and <tt>vector</tt> types. Moreover, many C++ programs interface to existing C programs that cannot use the C++ library. Hence, it is not infrequent to <a name="idd1e29158"></a><a name="idd1e29165"></a><a name="idd1e29170"></a><a name="idd1e29174"></a><a name="idd1e29181"></a><a name="idd1e29187"></a><a name="idd1e29194"></a><a name="idd1e29202"></a><a name="idd1e29207"></a><a name="idd1e29213"></a>encounter situations where a program written in modern C++ must interface to code that uses arrays and/or C-style character strings. The library offers facilities to make the interface easier to manage.</P>
<a name="ch04lev3sec31"></a>
<H5 class="docSection3Title">Mixing Library <tt>string</tt>s and C-Style Strings</h5>
<p class="docText">As we saw on page <a class="docLink" href="ch03lev1sec2.html#ch03lev2sec2">80</a> we can initialize a <tt>string</tt> from a string literal:</P>
<pre>
          string st3("Hello World");  // <span class="docEmphasis">st3</span> <span class="docEmphItalicAlt">holds</span> <span class="docEmphasis">Hello World</span>
</pre><br>
<p class="docText">More generally, because a C-style string has the same type as a string literal and is null-terminated in the same way, we can use a C-style string anywhere that a string literal can be used:</p>
<UL><LI><p class="docList">We can initialize or assign to a <tt>string</tt> from a C-style string.</p></li><li><p class="docList">We can use a C-style string as one of the two operands to the <tt>string</tt> addition or as the right-hand operand to the compound assignment operators.</p></li></UL>
<p class="docText">The reverse functionality is not provided: there is no direct way to use a library <tt>string</tt> when a C-style string is required. For example, there is no way to initialize a character pointer from a <tt>string:</tt></p>
<pre>
          char *str = st2; // <span class="docEmphItalicAlt">compile-time type error</span>
</pre><BR>
<p class="docText">There is, however, a <tt>string</tt> member function named <tt>c_str</tt> that we can often use to accomplish what we want:</P>
<pre>
          char *str = st2.c_str(); // <span class="docEmphItalicAlt">almost ok, but not quite</span>
</pre><br>
<p class="docText">The name <tt>c_str</tt> indicates that the function returns a C-style character string. Literally, it says, &quot;Get me the C-style string representation&quot;that is, a pointer to the beginning of a null-terminated character array that holds the same data as the characters in the <tt>string</tt>.</p>
<p class="docText">This initialization fails because <tt>c_str</tt> returns a pointer to an array of <tt>const char</tt>. It does so to prevent changes to the array. The correct initialization is:</p>
<pre>
          const char *str = st2.c_str(); // <span class="docEmphasis">ok</span>
</pre><BR>
<a name="ch04note22"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> The array returned by <tt>c_str</tt> is not guaranteed to be valid indefinitely. Any subsequent use of <tt>st2</tt> that might change the value of <tt>st2</tt> can invalidate the array. If a program needs continuing access to the data, then the program must copy the array returned by <tt>c_str</tt>.</P></td></tr></table><BR>
</p></div><br>

<a name="ch04lev3sec32"></a>
<H5 class="docSection3Title">Using an Array to Initialize a <tt>vector</tt></h5>
<p class="docText">On page <a class="docLink" href="ch04lev1sec1.html#page_112">112</a> we noted that it is not possible to initialize an array from another array. Instead, we have to create the array and then explicitly copy the elements from one array into the other. It turns out that we can use an array to initialize a <tt>vector</tt>, although the form of the initialization may seem strange at first. To initialize a <tt>vector</tt> from an array, we specify the address of the first element and one past the last element that we wish to use as initializers:</P>
<pre>
          const size_t arr_size = 6;
          int int_arr[arr_size] = {0, 1, 2, 3, 4, 5};
          // <span class="docEmphasis">ivec</span> <span class="docEmphItalicAlt">has 6 elements: each a copy of the corresponding element in</span> <span class="docEmphasis">int_arr</span>
          vector&lt;int&gt; ivec(int_arr, int_arr + arr_size);
</pre><br>
<p class="docText"><a name="idd1e29394"></a><a name="idd1e29399"></a>The two pointers passed to <tt>ivec</tt> mark the range of values with which to initialize the <tt>vector</tt>. The second pointer points one past the last element to be copied. The range of elements marked can also represent a subset of the array:</p>
<pre>
          // <span class="docEmphItalicAlt">copies 3 elements:</span> <span class="docEmphasis">int_arr[1], int_arr[2], int_arr[3]</span>
          vector&lt;int&gt; ivec(int_arr + 1, int_arr + 4);
</pre><br>
<p class="docText">This initialization creates <tt>ivec</tt> with three elements. The values of these elements are copies of the values in <tt>int_arr[1]</tt> through <tt>int_arr[3]</tt>.</p>
<a name="ch04sb14"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 4.3.2</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa9q1"></a><B>Exercise 4.31:</b></TD><td><p class="docText">Write a program that reads a string into a character array from the standard input. Describe how your program handles varying size inputs. Test your program by giving it a string of data that is longer than the array size you've allocated.</P>
</td></tr><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch04qa9q2"></a><b>Exercise 4.32:</b></td><td><p class="docText">Write a program to initialize a <tt>vector</tt> from an array of <tt>int</tt>s.</p>
</td></TR><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch04qa9q3"></a><B>Exercise 4.33:</b></td><td><p class="docText">Write a program to copy a <tt>vector</tt> of <tt>int</tt>s into an array of <tt>int</tt>s.</p>
</TD></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa9q4"></a><b>Exercise 4.34:</b></td><TD><p class="docText">Write a program to read <tt>string</tt>s into a <tt>vector</tt>. Now, copy that <tt>vector</tt> into an array of character pointers. For each element in the <tt>vector</tt>, allocate a new character array and copy the data from the <tt>vector</tt> element into that character array. Then insert a pointer to the character array into the array of character pointers.</p>
</td></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa9q5"></a><B>Exercise 4.35:</b></td><TD><p class="docText">Print the contents of the <tt>vector</tt> and the array created in the previous exercise. After printing the array, remember to delete the character arrays.</p>
</td></tr></table></p>
</blockquote>
</td></tr></table></p><br>



<a href="21001535.html"><img src="images/pixel.gif" alt="" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch04lev1sec2.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch04lev1sec4.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>