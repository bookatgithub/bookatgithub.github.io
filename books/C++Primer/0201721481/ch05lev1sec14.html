<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Keyterm&nbsp;Defined Terms</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec13.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch06.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch05lev1sec14"></a>
<h3 class="docSection1Title">Defined Terms</h3>
<p class="docText"></P>

<a name="gloss05_01"></a><dl class="docList"><dt><B><a class="docLink" href="ch05lev1sec12.html#ch05term1">arithmetic conversion</a></b></dt><dd><p class="docText">A conversion from one arithmetic type to another. In the context of the binary arithmetic operators, arithmetic conversions usually attempt to preserve precision by converting a smaller type to a larger type (e.g., small integral types, such as <tt>char</tt> and <tt>short</tt>, are converted to <tt>int</tt>).</p></dd><BR><br></dl>
<a name="gloss05_02"></a><dl class="docList"><dt><b><a class="docLink" href="ch05.html#ch05term2">associativity</a></b></dt><dd><p class="docText">Determines how operators of the same precedence are grouped. Operators can be either right associative (operators are grouped from right to left) or left associative (operators are grouped from left to right).</P></dd><BR><br></dl>
<a name="gloss05_03"></a><dl class="docList"><dt><b><a class="docLink" href="ch05lev1sec3.html#ch05term3">binary operators</a></b></dt><dd><p class="docText">Operators that take two operands.</p></dd><br><br></dl>
<a name="gloss05_04"></a><dl class="docList"><dt><B><a class="docLink" href="ch05lev1sec12.html#ch05term4">cast</a></b></dt><dd><p class="docText">An explicit conversion.</p></dd><BR><BR></dl>
<a name="gloss05_05"></a><dl class="docList"><dt><b><a class="docLink" href="ch05lev1sec10.html#ch05term5">compound expression</a></b></dt><dd><p class="docText">An expression involving more than one operator.</p></dd><br><BR></dl>
<a name="gloss05_06"></a><dl class="docList"><dt><B><a class="docLink" href="ch05lev1sec12.html#ch05term6">const_cast</a></b></dt><dd><p class="docText">A cast that converts a <tt>const</tt> object to the corresponding non<tt>const</tt> type.</p></dd><br><br></dl>
<a name="gloss05_07"></a><dl class="docList"><dt><b><a class="docLink" href="ch05lev1sec12.html#ch05term7">conversion</a></b></dt><dd><p class="docText">Process whereby a value of one type is transformed into a value of another type. The language defines conversions among the built-in types. Conversions to and from class types are also possible.</P></dd><br><br></dl>
<a name="gloss05_08"></a><dl class="docList"><dt><B><a class="docLink" href="ch05lev1sec11.html#ch05term8">dangling pointer</a></b></dt><dd><p class="docText">A pointer that refers to memory that once had an object but no longer does. Dangling pointers are the source of program errors that are quite difficult to detect.</p></dd><br><BR></dl>
<a name="gloss05_09"></a><dl class="docList"><dt><b><a class="docLink" href="ch05lev1sec11.html#ch05term9">delete expression</a></b></dt><dd><p class="docText">A <tt>delete</tt> expression frees memory that was allocated by <tt>new</tt>. There are two forms of <tt>delete</tt>:</P>
<pre>
     delete <span class="docEmphasis">p;</span>      // <span class="docEmphItalicAlt">delete object</span>
     delete [] <span class="docEmphasis">p;</span>    // <span class="docEmphItalicAlt">delete array</span>
</pre><br>
<p class="docText">In the first case, <tt>p</tt> must be a pointer to a dynamically allocated object; in the second, <tt>p</tt> must point to the first element in a dynamically allocated array. In C++ programs, <tt>delete</tt> replaces the use of the C library <tt>free</tt> function.</p></dd><br><br></dl>
<a name="gloss05_10"></a><dl class="docList"><dt><b><a class="docLink" href="ch05lev1sec12.html#ch05term10">dynamic_cast</a></b></dt><dd><p class="docText"><a name="idd1e40967"></a><a name="idd1e40972"></a><a name="idd1e40977"></a><a name="idd1e40982"></a><a name="idd1e40987"></a><a name="idd1e40993"></a><a name="idd1e40999"></a><a name="idd1e41005"></a><a name="idd1e41011"></a><a name="idd1e41016"></a><a name="idd1e41021"></a><a name="idd1e41024"></a><a name="idd1e41029"></a><a name="idd1e41032"></a><a name="idd1e41036"></a><a name="idd1e41039"></a><a name="idd1e41042"></a><a name="idd1e41045"></a><a name="idd1e41053"></a><a name="idd1e41058"></a><a name="idd1e41061"></a><a name="idd1e41064"></a><a name="idd1e41071"></a><a name="idd1e41074"></a><a name="idd1e41077"></a><a name="idd1e41080"></a>Used in combination with inheritance and run-time type identification. See <a class="docLink" href="ch18lev1sec2.html#ch18lev1sec2">Section 18.2</a> (p. <a class="docLink" href="ch18lev1sec2.html#ch18lev1sec2">772</a>).</p></dd><br><br></dl>
<a name="gloss05_11"></a><dl class="docList"><dt><b><a class="docLink" href="ch05.html#ch05term11">expression</a></b></dt><dd><p class="docText">The lowest level of computation in a C++ program. Expressions generally apply an operator to one or more operands. Each expression yields a result. Expressions can be used as operands, so we can write compound expressions requiring the evaluation of multiple operators.</p></dd><br><br></dl>
<a name="gloss05_12"></a><dl class="docList"><dt><b><a class="docLink" href="ch05lev1sec12.html#ch05term12">implicit conversion</a></b></dt><dd><p class="docText">A conversion that is automatically generated by the compiler. Given an expression that needs a particular type but has an operand of a differing type, the compiler will automatically convert the operand to the desired type if an appropriate conversion exists.</P></dd><BR><br></dl>
<a name="gloss05_13"></a><dl class="docList"><dt><B><a class="docLink" href="ch05lev1sec12.html#ch05term13">integral promotions</a></b></dt><dd><p class="docText">Subset of the standard conversions that take a smaller integral type to its most closely related larger type. Integral types (e.g. <tt>short, char</tt>, etc.) are promoted to <tt>int</tt> or <tt>unsigned int</tt>.</p></dd><br><BR></dl>
<a name="gloss05_14"></a><dl class="docList"><dt><B><a class="docLink" href="ch05lev1sec11.html#ch05term14">new expression</a></b></dt><dd><p class="docText">A <tt>new</tt> expression allocates memory at run time from the free store. This chapter looked at the form that allocates a single object:</p>
<pre>
     new type;
     new type(inits);
</pre><br>
<p class="docText">allocates an object of the indicated <span class="docEmphasis">type</span> and optionally initializes that object using the initializers in <span class="docEmphasis">inits</span>. Returns a pointer to the object. In C++ programs, <tt>new</tt> replaces use of the C library <tt>malloc</tt> function.</p></dd><br><br></dl>
<a name="gloss05_15"></a><dl class="docList"><dt><B><a class="docLink" href="ch05.html#ch05term15">operands</a></b></dt><dd><p class="docText">Values on which an expression</p></dd><BR><BR></dl>
<a name="gloss05_16"></a><dl class="docList"><dt><b><a class="docLink" href="ch05.html#ch05term16">operator</a></b></dt><dd><p class="docText">Symbol that determines what action an expression performs. The language defines a set of operators and what those operators mean when applied to values of built-in type. The language also defines the precedence and associativity of each operator and specifies how many operands each operator takes. Operators may be overloaded and applied to values of class type.</p></dd><br><BR></dl>
<a name="gloss05_17"></a><dl class="docList"><dt><B><a class="docLink" href="ch05.html#ch05term17">operator overloading</a></b></dt><dd><p class="docText">The ability to redefine an operator to apply to class types. We'll see in <a class="docLink" href="ch14.html#ch14">Chapter 14</a> how to define overloaded versions of operators.</p></dd><br><br></dl>
<a name="gloss05_18"></a><dl class="docList"><dt><b><a class="docLink" href="ch05.html#ch05term18">order of evaluation</a></b></dt><dd><p class="docText">Order, if any, in which the operands to an operator are evaluated. In most cases in C++ the compiler is free to evaluate operands in any order.</P></dd><br><br></dl>
<a name="gloss05_19"></a><dl class="docList"><dt><B><a class="docLink" href="ch05.html#ch05term19">precedence</a></b></dt><dd><p class="docText">Defines the order in which different operators in a compound expression are grouped. Operators with higher precedence are grouped more tightly than operators with lower precedence.</p></dd><br><BR></dl>
<a name="gloss05_20"></a><dl class="docList"><dt><b><a class="docLink" href="ch05lev1sec12.html#ch05term20">reinterpret_cast</a></b></dt><dd><p class="docText">Interprets the contents of the operand as a different type. Inherently machine-dependent and dangerous.</P></dd><br><br></dl>
<a name="gloss05_21"></a><dl class="docList"><dt><b><a class="docLink" href="ch05.html#ch05term21">result</a></b></dt><dd><p class="docText">The value or object obtained by evaluating an expression.</p></dd><br><br></dl>
<a name="gloss05_22"></a><dl class="docList"><dt><b><a class="docLink" href="ch05lev1sec12.html#ch05term22">static_cast</a></b></dt><dd><p class="docText">An explicit request for a type conversion that the compiler would do implicitly. Often used to override an implicit conversion that the compiler would otherwise perform.</p></dd><br><br></dl>
<a name="gloss05_23"></a><dl class="docList"><dt><b><a class="docLink" href="ch05.html#ch05term23">unary operators</a></b></dt><dd><p class="docText">Operators that take a single operand.</p></dd><br><BR></dl>
<a name="gloss05_24"></a><dl class="docList"><dt><B><a class="docLink" href="ch05lev1sec3.html#ch05term24"><tt>~</tt> operator</a></b></dt><dd><p class="docText">The bitwise NOT operator. Inverts the bits of its operand.</p></dd><BR><br></dl>
<a name="gloss05_25"></a><dl class="docList"><dt><b><tt>,</tt> operator</b></dt><dd><p class="docText">The comma operator. Expressions separated by a comma are evaluated left to right. Result of a comma expression is the value of the right-most expression.</P></dd><BR><br></dl>
<a name="gloss05_26"></a><dl class="docList"><dt><b><a class="docLink" href="ch05lev1sec10.html#ch05term26"><tt>?:</tt> operator</a></b></dt><dd><p class="docText">The conditional operator. If-then-else expression of the form: operates.</p>
<pre>
     cond ? expr1 : expr2;
</pre><br>
<p class="docText">If the condition <span class="docEmphasis">cond</span> is true then <span class="docEmphasis">expr1</span> is evaluated. Otherwise, <span class="docEmphasis">expr2</span> is evaluated.</p></dd><BR><br></dl>
<a name="gloss05_27"></a><dl class="docList"><dt><B><a class="docLink" href="ch05.html#ch05term27"><tt>&amp;</tt> operator</a></b></dt><dd><p class="docText">Bitwise AND operator. Generates a new integral value in which each bit position is 1 if both operands have a 1 in that position; otherwise the bit is 0.</P></dd><br><br></dl>
<a name="gloss05_28"></a><dl class="docList"><dt><b><a class="docLink" href="ch05lev1sec3.html#ch05term28"><tt>^</tt> operator</a></b></dt><dd><p class="docText"><a name="idd1e41298"></a><a name="idd1e41303"></a><a name="idd1e41308"></a><a name="idd1e41313"></a><a name="idd1e41318"></a><a name="idd1e41323"></a><a name="idd1e41328"></a><a name="idd1e41334"></a><a name="idd1e41340"></a><a name="idd1e41346"></a><a name="idd1e41352"></a><a name="idd1e41358"></a><a name="idd1e41364"></a><a name="idd1e41370"></a><a name="idd1e41378"></a><a name="idd1e41384"></a>The bitwise exclusive or operator. Generates a new integral value in which each bit position is 1 if either but not both operands contain a 1 in that bit position; otherwise, the bit is 0.</P></dd><BR><br></dl>
<a name="gloss05_29"></a><dl class="docList"><dt><b><a class="docLink" href="ch05lev1sec3.html#ch05term29"><tt>|</tt> operator</a></b></dt><dd><p class="docText">The bitwise OR operator. Generates a new integral value in which each bit position is 1 if either operand has a 1 in that position; otherwise the bit is 0.</p></dd><br><BR></dl>
<a name="gloss05_30"></a><dl class="docList"><dt><b><a class="docLink" href="ch05lev1sec5.html#ch05term30"><tt>++</tt> operator</a></b></dt><dd><p class="docText">The increment operator. The increment operator has two forms, prefix and postfix. Prefix increment yields an lvalue. It adds one to the operand and returns the changed value of the operand. Postfix increment yields an rvalue. It adds one to the operand and returns the original, unchanged value of the operand.</p></dd><BR><br></dl>
<a name="gloss05_31"></a><dl class="docList"><dt><b><a class="docLink" href="ch05lev1sec5.html#ch05term31"><tt>--</tt> operator</a></b></dt><dd><p class="docText">The decrement operator. has two forms, prefix and postfix. Prefix decrement yields an lvalue. It subtracts one from the operand and returns the changed value of the operand. Postfix decrement yields an rvalue. It subtracts one from the operand and returns the original, unchanged value of the operand.</P></dd><br><BR></dl>
<a name="gloss05_32"></a><dl class="docList"><dt><b><a class="docLink" href="ch05lev1sec3.html#ch05term32"><tt>&lt;&lt;</tt> operator</a></b></dt><dd><p class="docText">The left-shift operator. Shifts bits in the left-hand operand to the left. Shifts as many bits as indicated by the right-hand operand. The right-hand operand must be zero or positive and strictly less than the number of bits in the left-hand operand.</p></dd><br><br></dl>
<a name="gloss05_33"></a><dl class="docList"><dt><b><a class="docLink" href="ch05lev1sec3.html#ch05term33"><tt>&gt;&gt;</tt> operator</a></b></dt><dd><p class="docText">The right-shift operator. Like the left-shift operator except that bits are shifted to the right. The right-hand operand must be zero or positive and strictly less than the number of bits in the left-hand operand.</p></dd><br><br></dl>


<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec13.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch06.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>