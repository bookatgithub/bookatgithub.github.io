<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 5.3.&nbsp; The Bitwise Operators</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec2.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch05lev1sec4.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch05lev1sec3"></a>
<h3 class="docSection1Title" id="432172-882">5.3. The Bitwise Operators</h3>
<p class="docText">The bitwise operators take operands of integral type. These operators treat their integral operands as a collection of bits, providing operations to test and set individual bits. In addition, these operators may be applied to <tt>bitset</tt> (<a class="docLink" href="ch03lev1sec5.html#ch03lev1sec5">Section 3.5</a>, p. <a class="docLink" href="ch03lev1sec5.html#ch03lev1sec5">101</a>) operands with the behavior as described here for integral operands.</P>
<a name="ch05table03"></a><P><table cellspacing="0" class="allBorders" border="1" RULES="groups" cellpadding="5"><caption><h5 class="docTableTitle">Table 5.3. Bitwise Operators</H5></caption><colgroup><col width="175"><col width="175"><col width="150"></colgroup><thead><tr><th class="bottomBorder thead" scope="col" align="center" valign="top"><p class="docText"><a name="idd1e32574"></a><a name="idd1e32579"></a><a name="idd1e32584"></a><a name="idd1e32589"></a><a name="idd1e32598"></a><a name="idd1e32604"></a><a name="idd1e32609"></a><a name="idd1e32615"></a><a name="idd1e32620"></a><a name="idd1e32628"></a><a name="idd1e32634"></a><a name="idd1e32640"></a><a name="idd1e32648"></a><a name="idd1e32654"></a>Operator</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Function</P></th><th class="bottomBorder thead" scope="col" align="center" valign="top"><p class="docText">Use</P></th></tr></thead><tr><td class="bottomBorder" align="center" valign="top"><p class="docText"><tt>~</tt></p></td><TD class="bottomBorder" align="left" valign="top"><p class="docText">bitwise NOT</p></TD><TD class="bottomBorder" align="center" valign="top"><p class="docText"><tt>~expr</tt></p></td></tr><TR><TD class="docTableCell" align="center" valign="top"><p class="docText"><tt>&lt;&lt;</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">left shift</p></TD><td class="docTableCell" align="center" valign="top"><p class="docText"><tt>expr1 &lt;&lt; expr2</tt></p></TD></tr><tr><TD class="bottomBorder" align="center" valign="top"><p class="docText"><tt>&gt;&gt;</tt></p></TD><td class="bottomBorder" align="left" valign="top"><p class="docText">right shift</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText"><tt>expr1 &gt;&gt; expr2</tt></p></td></tr><tr><td class="bottomBorder" align="center" valign="top"><p class="docText"><tt>&amp;</tt></p></td><td class="bottomBorder" align="left" valign="top"><p class="docText">bitwise AND</p></TD><TD class="bottomBorder" align="center" valign="top"><p class="docText"><tt>expr1 &amp; expr2</tt></p></TD></tr><tr><TD class="bottomBorder" align="center" valign="top"><p class="docText"><tt>^</tt></P></td><td class="bottomBorder" align="left" valign="top"><p class="docText">bitwise XOR</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText"><tt>expr1 ^ expr2</tt></P></td></TR><TR><td class="bottomBorder" align="center" valign="top"><p class="docText"><tt>|</tt></p></td><TD class="bottomBorder" align="left" valign="top"><p class="docText">bitwise OR</P></td><td class="bottomBorder" align="center" valign="top"><p class="docText"><tt>expr1 | expr2</tt></p></td></TR></table></p><br>
<p class="docText">The type of an integer manipulated by the bitwise operators can be either signed or unsigned. If the value is negative, then the way that the &quot;sign bit&quot; is handled in a number of the bitwise operations is machine-dependent. It is, therefore, likely to differ across implementations; programs that work under one implementation may fail under another.</P>
<a name="ch05note04"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><TD valign="top"><p class="docText"> Because there are no guarantees for how the sign bit is handled, we strongly recommend using an <tt>unsigned</tt> type when using an integral value with the bitwise operators.</p></td></tr></table><br>
</p></div><br>
<p class="docText">In the following examples we assume that an <tt>unsigned char</tt> has 8 bits. The bitwise NOT operator (<b><a name="ch05term24"></a><a class="docLink" href="ch05lev1sec14.html#gloss05_24"><span class="docEmphStrong"><tt>~</tt></span></a></b>) is similar in behavior to the <tt>bitset flip</tt> (<a class="docLink" href="ch03lev1sec5.html#ch03lev2sec16">Section 3.5.2</a>, p. <a class="docLink" href="ch03lev1sec5.html#ch03lev2sec16">105</a>) operation: It generates a new value with the bits of its operand inverted. Each 1 bit is set to 0; each 0 bit is set to 1:</p>
<p><table cellspacing="0" FRAME="void" RULES="none" cellpadding="5"><colgroup><col width="375"><col width="125"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>unsigned char bits = 0227;</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><img border="0" alt="" id="195131139046" width="127" height="20" SRC="images/0201721481/graphics/155fig01.gif;400478"></P></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>bits = ~bits;</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><img border="0" alt="" id="195131139046" width="127" height="20" SRC="images/0201721481/graphics/155fig02.gif;400478"></p></td></tr></table></p><BR>
<p class="docText">The <tt>&lt;&lt;, &gt;&gt;</tt> operators are the bitwise shift operators. These operators use their right-hand operand to indicate by how many bits to shift. They yield a value that is a copy of the left-hand operand with the bits shifted as directed by the right-hand operand. The bits are shifted left (<b><a name="ch05term32"></a><a class="docLink" href="ch05lev1sec14.html#gloss05_32"><span class="docEmphStrong"><tt>&lt;&lt;</tt></span></a></b>) or right (<B><a name="ch05term33"></a><a class="docLink" href="ch05lev1sec14.html#gloss05_33"><span class="docEmphStrong"><tt>&gt;&gt;</tt></span></a></b>), discarding the bits that are shifted off the end.</P>
<p><table cellspacing="0" FRAME="void" RULES="none" cellpadding="5"><colgroup><col width="375"><col width="125"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>unsigned char bits = 1;</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><img border="0" alt="" id="195131139046" width="127" height="20" SRC="images/0201721481/graphics/155fig03.gif;400478"></p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>bits &lt;&lt; 1;</tt> // <span class="docEmphasis">left shift</span></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><img border="0" alt="" id="195131139046" width="127" height="20" SRC="images/0201721481/graphics/155fig04.gif;400478"></p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>bits &lt;&lt; 2;</tt> // <span class="docEmphasis">left shift</span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><img border="0" alt="" id="195131139046" width="127" height="20" SRC="images/0201721481/graphics/155fig05.gif;400478"></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>bits &gt;&gt; 3;</tt> // <span class="docEmphasis">right shift</span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><img border="0" alt="" id="195131139046" width="127" height="21" SRC="images/0201721481/graphics/155fig06.gif;400478"></p></TD></TR></table></p><BR>
<p class="docText">The left shift operator (<tt>&lt;&lt;</tt>) inserts 0-valued bits in from the right. The right shift operator (<tt>&gt;&gt;</tt>) inserts 0-valued bits in from the left if the operand is unsigned. <a name="idd1e32955"></a><a name="idd1e32960"></a><a name="idd1e32965"></a><a name="idd1e32970"></a><a name="idd1e32976"></a><a name="idd1e32982"></a><a name="idd1e32988"></a><a name="idd1e32995"></a><a name="idd1e33001"></a><a name="idd1e33009"></a><a name="idd1e33017"></a>If the operand is signed, it can either insert copies of the sign bit or insert 0-valued bits; which one it uses is implementation defined. The right-hand operand must not be negative and must be a value that is strictly less than the number of bits in the left-hand operand. Otherwise, the effect of the operation is undefined.</p>
<p class="docText">The bitwise AND operator (<tt>&amp;</tt>) takes two integral operands. For each bit position, the result is 1 if both operands contain 1; otherwise, the result is 0.</p>
<a name="ch05note05"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> It is a common error to confuse the bitwise AND operator (<tt>&amp;</tt>) with the logical AND operator (<tt>&amp;&amp;</tt>) (<a class="docLink" href="ch05lev1sec2.html#ch05lev1sec2">Section 5.2</a>, p. <a class="docLink" href="ch05lev1sec2.html#ch05lev1sec2">152</a>). Similarly, it is common to confuse the bitwise OR operator (<b><a name="ch05term29"></a><a class="docLink" href="ch05lev1sec14.html#gloss05_29"><span class="docEmphStrong"><tt>|</tt></span></a></b>) and the logical OR operator(<tt>||</tt>).</p></TD></tr></table><BR>
</P></div><br>
<p class="docText">Here we illustrate the result of bitwise AND of two <tt>unsigned char</tt> values, each of which is initialized by an octal literal:</p>
<p><table cellspacing="0" FRAME="void" RULES="none" cellpadding="5"><colgroup><col width="375"><col width="125"></colgroup><thead></thead><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>unsigned char b1 = 0145;</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><img border="0" alt="" id="195131139046" width="127" height="21" SRC="images/0201721481/graphics/156fig01.gif;400478"></p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>unsigned char b2 = 0257;</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><img border="0" alt="" id="195131139046" width="127" height="20" SRC="images/0201721481/graphics/156fig02.gif;400478"></p></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>unsigned char result = b1 &amp; b2;</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><img border="0" alt="" id="195131139046" width="127" height="19" SRC="images/0201721481/graphics/156fig03.gif;400478"></p></td></tr></table></p><br>
<p class="docText">The bitwise XOR (exclusive or) operator (<b><a name="ch05term28"></a><a class="docLink" href="ch05lev1sec14.html#gloss05_28"><span class="docEmphStrong"><tt>^</tt></span></a></b>) also takes two integral operands. For each bit position, the result is 1 if either but not both operands contain 1; otherwise, the result is 0.</p>
<P><table cellspacing="0" FRAME="void" RULES="none" cellpadding="5"><colgroup><col width="375"><col width="125"></colgroup><thead></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>result = b1 ^ b2;</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><img border="0" alt="" id="195131139046" width="126" height="20" SRC="images/0201721481/graphics/156fig04.gif;400478"></P></TD></tr></table></p><br>
<p class="docText">The bitwise OR (inclusive or) operator (<tt>|</tt>) takes two integral operands. For each bit position, the result is 1 if either or both operands contain 1; otherwise, the result is 0.</p>
<p><table cellspacing="0" FRAME="void" RULES="none" cellpadding="5"><colgroup><col width="375"><col width="125"></colgroup><thead></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>result = b1 | b2;</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><img border="0" alt="" id="195131139046" width="126" height="20" SRC="images/0201721481/graphics/156fig05.gif;400478"></p></td></TR></table></P><br>
<a name="ch05lev2sec5"></a>
<h4 class="docSection2Title">5.3.1. Using <tt>bitset</tt> Objects or Integral Values</h4>
<p class="docText">We said that the <tt>bitset</tt> class was easier to use than the lower-level bitwise operations on integral values. Let's look at a simple example and show how we might solve a problem using either a <tt>bitset</tt> or the bitwise operators. Assume that a teacher has 30 students in a class. Each week the class is given a pass/fail quiz. We'll track the results of each quiz using one bit per student to represent the pass or fail grade on a given test. We might represent each quiz in either a <tt>bitset</tt> or as an integral value:</p>
<pre>
     bitset&lt;30&gt; bitset_quiz1;     //  <span class="docEmphasis">bitset</span> <span class="docEmphItalicAlt">solution</span>
     unsigned long int_quiz1 = 0; // <span class="docEmphItalicAlt">simulated collection of bits</span>
</pre><BR>
<p class="docText">In the <tt>bitset</tt> case we can define <tt>bitset_quiz1</tt> to be exactly the size we need. By default each of the bits is set to zero. In the case where we use a built-in type to hold our quiz results, we define <tt>int_quiz1</tt> as an <tt>unsigned long</tt>, meaning <a name="idd1e33241"></a><a name="idd1e33246"></a>that it will have at least 32 bits on any machine. Finally, we explicitly initialize <tt>int_quiz1</tt> to ensure that the bits start out with well-defined values.</p>
<p class="docText">The teacher must be able to set and test individual bits. For example, assuming that the student represented by position 27 passed, we'd like to be able to set that bit appropriately:</p>
<pre>
     bitset_quiz1.set(27);   //  <span class="docEmphItalicAlt">indicate student number 27 passed</span>
     int_quiz1 |= 1UL&lt;&lt;27;   //  <span class="docEmphItalicAlt">indicate student number 27 passed</span>
</pre><BR>
<p class="docText">In the <tt>bitset</tt> case we do so directly by passing the bit we want turned on to <tt>set</tt>. The <tt>unsigned long</tt> case will take a bit more explanation. The way we'll set a specific bit is to OR our quiz data with another integer that has only one bitthe one we wantturned on. That is, we need an <tt>unsigned long</tt> where bit 27 is a one and all the other bits are zero. We can obtain such a value by using the left shift operator and the integer constant 1:</p>
<pre>
     1UL &lt;&lt; 27;  //  <span class="docEmphItalicAlt">generate a value with only bit number 27 set</span>
</pre><br>
<p class="docText">Now when we bitwise OR this value with <tt>int_quiz1</tt>, all the bits except bit 27 will remain unchanged. That bit will be turned on. We use a compound assignment (<a class="docLink" href="ch01lev1sec4.html#ch01lev2sec5">Section 1.4.1</a>, p. <a class="docLink" href="ch01lev1sec4.html#ch01lev2sec5">13</a>) to OR this value into <tt>int_quiz1</tt>. This operator, <tt>|=</tt>, executes in the same way that <tt>+=</tt> does. It is equivalent to the more verbose:</P>
<pre>
     //  <span class="docEmphItalicAlt">following assignment is equivalent to</span> <span class="docEmphasis">int_quiz1</span> |= <span class="docEmphasis">1UL &lt;&lt; 27;</span>
     int_quiz1 = int_quiz1 | 1UL &lt;&lt; 27;
</pre><br>
<p class="docText">Imagine that the teacher reexamined the quiz and discovered that student 27 actually had failed the test. The teacher must now turn off bit 27:</P>
<pre>
     bitset_quiz1.reset(27);   // <span class="docEmphItalicAlt">student number 27 failed</span>
     int_quiz1 &amp;= ~(1UL&lt;&lt;27);  // <span class="docEmphItalicAlt">student number 27 failed</span>
</pre><br>
<p class="docText">Again, the <tt>bitset</tt> version is direct. We <tt>reset</tt> the indicated bit. For the simulated case, we need to do the inverse of what we did to set the bit: This time we'll need an integer that has bit 27 turned off and all the other bits turned on. We'll bitwise AND this value with our quiz data to turn off just that bit. We can obtain a value with all but bit 27 turned on by inverting our previous value. Applying the bitwise NOT to the previous integer will turn on every bit except the 27th. When we bitwise AND this value with <tt>int_quiz1</tt>, all except bit 27 will remain unchanged.</p>
<p class="docText">Finally, we might want to know how the student at position 27 fared. To do so, we could write</p>
<pre>
     bool status;
     status = bitset_quiz1[27];       // <span class="docEmphItalicAlt">how did student number 27 do?</span>
     status = int_quiz1 &amp; (1UL&lt;&lt;27);  // <span class="docEmphItalicAlt">how did student number 27 do?</span>
</pre><br>
<p class="docText">In the <tt>bitset</tt> case we can fetch the value directly to determine how that student did. In the <tt>unsigned long</tt> case, the first step is to set the 27th bit of an integer to 1. The bitwise AND of this value with <tt>int_quiz1</tt> evaluates to nonzero if bit 27 of <tt>int_quiz1</tt> is also on; otherwise, it evaluates to zero.</p>
<a name="ch05note06"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><td valign="top"><p class="docText"><a name="idd1e33392"></a><a name="idd1e33399"></a><a name="idd1e33406"></a><a name="idd1e33414"></a><a name="idd1e33425"></a><a name="idd1e33433"></a><a name="idd1e33441"></a><a name="idd1e33452"></a><a name="idd1e33460"></a> In general, the library <tt>bitset</tt> operations are more direct, easier to read, easier to write, and more likely to be used correctly. Moreover, the size of a <tt>bitset</tt> is not limited by the number of bits in an <tt>unsigned</tt>. Ordinarily <tt>bitset</tt> should be used in preference to lower-level direct bit manipulation of integral values.</p></td></tr></table><BR>
</P></div><br>
<a name="ch05sb04"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Exercises Section 5.3.1</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa3q1"></a><b>Exercise 5.9:</b></td><TD><p class="docText">Assume the following two definitions:</p>
<pre>
     unsigned long ul1 = 3, ul2 = 7;
</pre><BR>
<p class="docText">What is the result of each of the following expressions?</P>
<pre>
     (a) ul1 &amp; ul2     (c)  ul1 | ul2
     (b) ul1 &amp;&amp; ul2    (d)  ul1 || ul2
</pre><br>
</td></tr><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch05qa3q3"></a><b>Exercise 5.10:</b></td><td><p class="docText">Rewrite the <tt>bitset</tt> expressions that set and reset the quiz results using a subscript operator.</p>
</TD></tr></table></p>
</blockquote>
</TD></tr></table></p><BR>

<a name="ch05lev2sec6"></a>
<h4 class="docSection2Title">5.3.2. Using the Shift Operators for IO</H4>
<p class="docText">The IO library redefines the bitwise <tt>&gt;&gt;</tt> and <tt>&lt;&lt;</tt> operators to do input and output. Even though many programmers never need to use the bitwise operators directly, most programs do make extensive use of the overloaded versions of these operators for IO. When we use an overloaded operator, it has the same precedence and associativity as is defined for the built-in version of the operator. Therefore, programmers need to understand the precedence and associativity of these operators even if they never use them with their built-in meaning as the shift operators.</p>
<a name="ch05lev3sec1"></a>
<h5 class="docSection3Title">The IO Operators Are Left Associative</h5>
<p class="docText">Like the other <span class="docEmphRoman"><a name="ch05term3"></a><a class="docLink" href="ch05lev1sec14.html#gloss05_13">binary operators</a></span>, the shift operators are left associative. These operators group from left to right, which accounts for the fact that we can concatenate input and output operations into a single statement:</p>
<pre>
     cout &lt;&lt; "hi" &lt;&lt; " there" &lt;&lt; endl;
</pre><br>
<p class="docText">executes as:</p>
<pre>
     ( (cout &lt;&lt; "hi") &lt;&lt; " there" ) &lt;&lt; endl;
</pre><br>
<p class="docText">In this statement, the operand <tt>"hi"</tt> is grouped with the first <tt>&lt;&lt;</tt> symbol. Its result is grouped with the second, and then that result is grouped to the third.</p>
<p class="docText">The shift operators have midlevel precedence: lower precedence than the arithmetic operators but higher than the relational, assignment, or conditional operators. These relative precedence levels affect how we write IO expressions involving <a name="idd1e33585"></a><a name="idd1e33590"></a><a name="idd1e33596"></a><a name="idd1e33601"></a>operands that use operators with lower precedence. We often need to use parentheses to force the right grouping:</p>
<pre>
     cout &lt;&lt; 42 + 10;   // <span class="docEmphItalicAlt">ok, + has higher precedence, so the sum is printed</span>
     cout &lt;&lt; (10 &lt; 42); // <span class="docEmphItalicAlt">ok: parentheses force intended grouping; prints</span> <span class="docEmphasis">1</span>
     cout &lt;&lt; 10 &lt; 42;   // <span class="docEmphItalicAlt">error: attempt to compare</span> <span class="docEmphasis">cout</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">42</span>!
</pre><br>
<p class="docText">The second <tt>cout</tt> is interpreted as</p>
<pre>
     (cout &lt;&lt; 10) &lt; 42;
</pre><br>
<p class="docText">this expression says to &quot;write 10 onto <tt>cout</tt> and then compare the result of that operation (e.g., <tt>cout</tt>) to 42.&quot;</p>



<UL></UL></td></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec2.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch05lev1sec4.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>