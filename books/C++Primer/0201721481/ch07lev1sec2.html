<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 7.2.&nbsp; Argument Passing</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch07lev1sec1.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch07lev1sec3.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch07lev1sec2"></a>
<h3 class="docSection1Title">7.2. Argument Passing</h3>
<p class="docText">Each parameter is created anew on each call to the function. The value used to initialize a parameter is the corresponding argument passed in the call.</P>
<a name="ch07note03"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> Parameters are initialized the same way that variables are. If the parameter has a nonreference type, then the argument is copied. If the parameter is a reference (<a class="docLink" href="ch02lev1sec5.html#ch02lev1sec5">Section 2.5</a>, p. <a class="docLink" href="ch02lev1sec5.html#ch02lev1sec5">58</a>), then the parameter is just another name for the argument.</P></TD></tr></table><br>
</p></div><br>
<a name="ch07sb01"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<H2 class="docSidebarTitle">Exercises Section 7.1.2</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa1q1"></a><B>Exercise 7.1:</b></TD><td><p class="docText"><a name="idd1e48544"></a><a name="idd1e48549"></a><a name="idd1e48554"></a><a name="idd1e48559"></a>What is the difference between a parameter and an argument?</p>
</td></tr><TR valign="top"><td align="right" class="docText" width="50"><a name="ch07qa1q2"></a><b>Exercise 7.2:</b></TD><td><p class="docText">Indicate which of the following functions are in error and why. Suggest how you might correct the problems.</p>
<pre>
     (a) int f() {
             string s;
             // ...
             return s;
         }
     (b) f2(int i) { /* ... */ }
     (c) int calc(int v1, int v1) /* ... */ }
     (d) double square(double x) return x * x;
</pre><BR>
</td></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa1q3"></a><b>Exercise 7.3:</b></td><td><p class="docText">Write a program to take two <tt>int</tt> parameters and generate the result of raising the first parameter to the power of the second. Write a program to call your function passing it two <tt>int</tt>s. Verify the result.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa1q4"></a><b>Exercise 7.4:</b></td><td><p class="docText">Write a program to return the absolute value of its parameter.</P>
</TD></tr></table></P>
</blockquote>
</td></tr></table></P><BR>
<a name="ch07lev2sec6"></a>
<h4 class="docSection2Title">7.2.1. Nonreference Parameters</h4>
<p class="docText">Parameters that are plain, nonreference types are initialized by copying the corresponding argument. When a parameter is initialized with a copy, the function has no access to the actual arguments of the call. It cannot change the arguments. Let's look again at the definition of <tt>gcd</tt>:</p>
<pre>
     // <span class="docEmphItalicAlt">return the greatest common divisor</span>
     int gcd(int v1, int v2)
     {
         while (v2) {
             int temp = v2;
             v2 = v1 % v2;
             v1 = temp;
         }
         return v1;
     }
</pre><br>
<p class="docText">Inside the body of the <tt>while</tt>, we change the values of both <tt>v1</tt> and <tt>v2</tt>. However, these changes are made to the local parameters and are not reflected in the arguments used to call <tt>gcd</tt>. Thus, when we call</p>
<pre>
     gcd(i, j)
</pre><BR>
<p class="docText">the values <tt>i</tt> and <tt>j</tt> are unaffected by the assignments performed inside <tt>gcd</tt>.</p>
<a name="ch07note04"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> Nonreference parameters represent local <span class="docEmphasis">copies</span> of the corresponding argument. Changes made to the parameter are made to the local copy. Once the function terminates, these local values are gone.</P></TD></tr></table><br>
</p></div><br>
<a name="ch07lev3sec3"></a>
<H5 class="docSection3Title">Pointer Parameters</h5>
<p class="docText"><a name="idd1e48684"></a><a name="idd1e48691"></a><a name="idd1e48698"></a><a name="idd1e48704"></a><a name="idd1e48710"></a><a name="idd1e48719"></a><a name="idd1e48725"></a><a name="idd1e48732"></a><a name="idd1e48740"></a><a name="idd1e48745"></a><a name="idd1e48750"></a><a name="idd1e48757"></a><a name="idd1e48764"></a><a name="idd1e48771"></a>A parameter can be a pointer (<a class="docLink" href="ch04lev1sec2.html#ch04lev1sec2">Section 4.2</a>, p. <a class="docLink" href="ch04lev1sec2.html#ch04lev1sec2">114</a>), in which case the argument pointer is copied. As with any nonreference type parameter, changes made to the parameter are made to the local copy. If the function assigns a new pointer value to the parameter, the calling pointer value is unchanged.</p>
<p class="docText">Recalling the discussion in <a class="docLink" href="ch04lev1sec2.html#ch04lev2sec5">Section 4.2.3</a> (p. <a class="docLink" href="ch04lev1sec2.html#ch04lev2sec5">121</a>), the fact that the pointer is copied affects only assignments to the pointer. If the function takes a pointer to a non<tt>const</tt> type, then the function can assign through the pointer and change the value of the object to which the pointer points:</P>
<pre>
     void reset(int *ip)
     {
         *ip = 0; // <span class="docEmphItalicAlt">changes the value of the object to which</span> <span class="docEmphasis">ip</span> <span class="docEmphItalicAlt">points</span>
         ip = 0;   // <span class="docEmphItalicAlt">changes only the local value of</span> <span class="docEmphasis">ip</span><span class="docEmphItalicAlt">; the argument is unchanged</span>
     }
</pre><br>
<p class="docText">After a call to <tt>reset</tt>, the argument is unchanged but the object to which the argument points will be 0:</p>
<pre>
     int i = 42;
     int *p = &amp;i;
     cout &lt;&lt; "i: " &lt;&lt; *p &lt;&lt; '\n';   // <span class="docEmphItalicAlt">prints</span> <span class="docEmphasis">i: 42</span>
     reset(p);                      // <span class="docEmphItalicAlt">changes</span> <span class="docEmphasis">*p</span> <span class="docEmphItalicAlt">but not</span> <span class="docEmphasis">p</span>
     cout &lt;&lt; "i: " &lt;&lt; *p &lt;&lt; endl;   // <span class="docEmphItalicAlt">ok: prints</span> <span class="docEmphasis">i: 0</span>
</pre><BR>
<p class="docText">If we want to prevent changes to the value to which the pointer points, then the parameter should be defined as a pointer to <tt>const</tt>:</p>
<pre>
     void use_ptr(const int *p)
     {
          // <span class="docEmphasis">use_ptr</span> <span class="docEmphItalicAlt">may read but not write to</span> <span class="docEmphasis">*p</span>
     }
</pre><BR>
<p class="docText">Whether a pointer parameter points to a <tt>const</tt> or non<tt>const</tt> type affects the arguments that we can use to call the function. We can call <tt>use_ptr</tt> on either an <tt>int*</tt> or a <tt>const int*</tt>; we can pass only on an <tt>int*</tt> to <tt>reset</tt>. This distinction follows from the initialization rules for pointers (<a class="docLink" href="ch04lev1sec2.html#ch04lev2sec7">Section 4.2.5</a>, p. <a class="docLink" href="ch04lev1sec2.html#ch04lev2sec7">126</a>). We may initialize a pointer to <tt>const</tt> to point to a non<tt>const</tt> object but may not use a pointer to non<tt>const</tt> to point to a <tt>const</tt> object.</p>

<a name="ch07lev3sec4"></a>
<h5 class="docSection3Title"><tt>const</tt> Parameters</h5>
<p class="docText">We can call a function that takes a nonreference, non<tt>const</tt> parameter passing either a <tt>const</tt> or non<tt>const</tt> argument. For example, we could pass two <tt>const int</tt>s to our <tt>gcd</tt> function:</p>
<pre>
     const int i = 3, j = 6;
     int k = rgcd(3, 6);   // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">k</span> <span class="docEmphItalicAlt">initialized to</span> <span class="docEmphasis">3</span>
</pre><br>
<p class="docText">This behavior follows from the normal initialization rules for <tt>const</tt> objects (<a class="docLink" href="ch02lev1sec4.html#ch02lev1sec4">Section 2.4</a>, p. <a class="docLink" href="ch02lev1sec4.html#ch02lev1sec4">56</a>). Because the initialization copies the value of the initializer, we can initialize a non<tt>const</tt> object from a <tt>const</tt> object, or vice versa.</p>
<p class="docText"><a name="idd1e48987"></a><a name="idd1e48995"></a><a name="idd1e49003"></a>If we make the parameter a <tt>const</tt> nonreference type:</p>
<pre>
     void fcn(const int i) { /* <span class="docEmphasis">fcn</span> <span class="docEmphItalicAlt">can read but not write to</span> <span class="docEmphasis">i</span> */ }
</pre><br>
<p class="docText">then the function cannot change its local copy of the argument. The argument is still passed as a copy so we can pass <tt>fcn</tt> either a <tt>const</tt> or non<tt>const</tt> object.</p>
<p class="docText">What may be surprising, is that although the parameter is a <tt>const</tt> inside the function, the compiler otherwise treats the definition of <tt>fcn</tt> as if we had defined the parameter as a plain <tt>int</tt>:</p>
<pre>
     void fcn(const int i) { /* <span class="docEmphasis">fcn</span> <span class="docEmphItalicAlt">can read but not write to</span> <span class="docEmphasis">i</span> */ }
     void fcn(int i) { /* ... */ }            // <span class="docEmphItalicAlt">error: redefines</span> <span class="docEmphasis">fcn(int)</span>
</pre><br>
<p class="docText">This usage exists to support compatibility with the C language, which makes no distinction between functions taking <tt>const</tt> or non<tt>const</tt> parameters.</p>

<a name="ch07lev3sec5"></a>
<h5 class="docSection3Title">Limitations of Copying Arguments</H5>
<p class="docText">Copying an argument is not suitable for every situation. Cases where copying doesn't work include:</P>
<ul><LI><p class="docList">When we want the function to be able to change the value of an argument.</p></li><LI><p class="docList">When we want to pass a large object as an argument. The time and space costs to copy the object are often too high for real-world applications.</P></li><li><p class="docList">When there is no way to copy the object.</p></li></ul>
<p class="docText">In these cases we can instead define the parameters as references or pointers.</P>
<a name="ch07sb02"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<h2 class="docSidebarTitle">Exercises Section 7.2.1</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch07qa2q1"></a><b>Exercise 7.5:</b></td><td><p class="docText">Write a function that takes an <tt>int</tt> and a pointer to an <tt>int</tt> and returns the larger of the <tt>int</tt> value of the value to which the pointer points. What type should you use for the pointer?</p>
</TD></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch07qa2q2"></a><b>Exercise 7.6:</b></td><TD><p class="docText">Write a function to swap the values pointed to by two pointers to <tt>int</tt>. Test the function by calling it and printing the swapped values.</p>
</TD></tr></table></p>
</blockquote>
</td></tr></table></p><br>


<a name="ch07lev2sec7"></a>
<h4 class="docSection2Title">7.2.2. Reference Parameters</h4>
<p class="docText">As an example of a situation where copying the argument doesn't work, consider a function to swap the values of its two arguments:</p>
<pre>
      // <span class="docEmphItalicAlt">incorrect version of</span> <span class="docEmphasis">swap:</span> <span class="docEmphItalicAlt">The arguments are not changed!</span>
     void swap(int v1, int v2)
     {
         int tmp = v2;
         v2 = v1;    // <span class="docEmphItalicAlt">assigns new value to local copy of the argument</span>
         v1 = tmp;
     }               // <span class="docEmphItalicAlt">local objects</span> <span class="docEmphasis">v1</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">v2</span> <span class="docEmphItalicAlt">no longer exist</span>
</pre><br>
<p class="docText"><a name="idd1e49200"></a><a name="idd1e49205"></a><a name="idd1e49211"></a><a name="page_233"></a>In this case, we want to change the arguments themselves. As defined, though, <tt>swap</tt> cannot affect those arguments. When it executes, <tt>swap</tt> exchanges the <span class="docEmphasis">local copies</span> of its arguments. The arguments passed to <tt>swap</tt> are unchanged:</p>
<pre>
     int main()
     {
         int i = 10;
         int j = 20;
         cout &lt;&lt; "Before swap():\ti: "
              &lt;&lt; i &lt;&lt; "\tj: " &lt;&lt; j &lt;&lt; endl;
         swap(i, j);
         cout &lt;&lt; "After swap():\ti: "
              &lt;&lt; i &lt;&lt; "\tj: " &lt;&lt; j &lt;&lt; endl;
         return 0;
     }
</pre><br>
<p class="docText">Compiling and executing this program results in the following output:</p>
<pre>
     <span class="docEmphStrong">Before swap(): i: 10 j: 20</span>
     <span class="docEmphStrong">After  swap(): i: 10 j: 20</span>
</pre><BR>
<p class="docText">For <tt>swap</tt> to work as intended and swap the values of its arguments, we need to make the parameters references:</P>
<pre>
     // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">swap</span> <span class="docEmphItalicAlt">acts on references to its arguments</span>
     void swap(int &amp;v1, int &amp;v2)
     {
         int tmp = v2;
         v2 = v1;
         v1 = tmp;
     }
</pre><br>
<p class="docText">Like all references, reference parameters refer directly to the objects to which they are bound rather than to copies of those objects. When we define a reference, we must initialize it with the object to which the reference will be bound. Reference parameters work exactly the same way. Each time the function is called, the reference parameter is created and bound to its corresponding argument. Now, when we call <tt>swap</tt></P>
<pre>
     swap(i, j);
</pre><br>
<p class="docText">the parameter <tt>v1</tt> is just another name for the object <tt>i</tt> and <tt>v2</tt> is another name for <tt>j</tt>. Any change to <tt>v1</tt> is actually a change to the argument <tt>i</tt>. Similarly, changes to <tt>v2</tt> are actually made to <tt>j</tt>. If we recompile <tt>main</tt> using this revised version of <tt>swap</tt>, we can see that the output is now correct:</p>
<pre>
     <span class="docEmphStrong">Before swap(): i: 10 j: 20</span>
     <span class="docEmphStrong">After  swap(): i: 20 j: 10</span>
</pre><BR>
<a name="ch07note05"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="84" height="51" SRC="images/0201721481/graphics/tip.jpg;400478"></td><td valign="top"><p class="docText"> Programmers who come to C++ from a C background are used to passing pointers to obtain access to the argument. In C++ it is safer and more natural to use reference parameters.</p></TD></tr></table><BR>
</P></div><br>
<a name="ch07lev3sec6"></a>
<h5 class="docSection3Title">Using Reference Parameters to Return Additional Information</h5>
<p class="docText"><a name="idd1e49344"></a><a name="idd1e49349"></a>We've seen one example, <tt>swap</tt>, in which reference parameters were used to allow the function to change the value of its arguments. Another use of reference parameters is to return an additional result to the calling function.</P>
<p class="docText">Functions can return only a single value, but sometimes a function has more than one thing to return. For example, let's define a function named <tt>find_val</tt> that searches for a particular value in the elements of a <tt>vector</tt> of integers. It returns an iterator that refers to the element, if the element was found, or to the <tt>end</tt> value if the element isn't found. We'd also like the function to return an occurrence count if the value occurs more than once. In this case the iterator returned should be to the first element that has the value for which we're looking.</P>
<p class="docText">How can we define a function that returns both an iterator and an occurrence count? We could define a new type that contains an iterator and a count. An easier solution is to pass an additional reference argument that <tt>find_val</tt> can use to return a count of the number of occurrences:</p>
<pre>
     // <span class="docEmphItalicAlt">returns an iterator that refers to the first occurrence of</span> <span class="docEmphasis">value</span>
     // <span class="docEmphItalicAlt">the reference parameter</span> <span class="docEmphasis">occurs</span> <span class="docEmphItalicAlt">contains a second return value</span>
     vector&lt;int&gt;::const_iterator find_val(
         vector&lt;int&gt;::const_iterator beg,             // <span class="docEmphItalicAlt">first element</span>
         vector&lt;int&gt;::const_iterator end,             // <span class="docEmphItalicAlt">one past last element</span>
         int value,                                    // <span class="docEmphItalicAlt">the value we want</span>
         vector&lt;int&gt;::size_type &amp;occurs)              // <span class="docEmphItalicAlt">number of times it occurs</span>
     {
         // <span class="docEmphasis">res_iter</span> <span class="docEmphItalicAlt">will hold first occurrence, if any</span>
         vector&lt;int&gt;::const_iterator res_iter = end;
         occurs = 0; // <span class="docEmphItalicAlt">set occurrence count parameter</span>
         for ( ; beg != end; ++beg)
             if (*beg == value) {
                 // <span class="docEmphItalicAlt">remember first occurrence of</span> <span class="docEmphasis">value</span>
                 if (res_iter == end)
                    res_iter = beg;
                 ++occurs; // <span class="docEmphItalicAlt">increment occurrence count</span>
             }
         return res_iter;  // <span class="docEmphItalicAlt">count returned implicitly in</span> <span class="docEmphasis">occurs</span>
     }
</pre><br>
<p class="docText">When we call <tt>find_val</tt>, we have to pass four arguments: a pair of iterators that denote the range of elements (<a class="docLink" href="ch09lev1sec2.html#ch09lev2sec4">Section 9.2.1</a>, p. <a class="docLink" href="ch09lev1sec2.html#ch09lev2sec4">314</a>) in the <tt>vector</tt> in which to look, the value to look for, and a <tt>size_type</tt> (<a class="docLink" href="ch03lev1sec2.html#ch03lev2sec4">Section 3.2.3</a>, p. <a class="docLink" href="ch03lev1sec2.html#ch03lev2sec4">84</a>) object to hold the occurrence count. Assuming <tt>ivec</tt> is a <tt>vector&lt;int&gt;, it</tt> is an iterator of the right type, and <tt>ctr</tt> is a <tt>size_type</tt>, we could call <tt>find_val</tt> as follows:</p>
<pre>
     it = find_val(ivec.begin(), ivec.end(), 42, ctr);
</pre><br>
<p class="docText">After the call, the value of <tt>ctr</tt> will be the number of times 42 occurs, and <tt>it</tt> will refer to the first occurrence if there is one. Otherwise, <tt>it</tt> will be equal to <tt>ivec.end()</tt> and <tt>ctr</tt> will be zero.</P>

<a name="ch07lev3sec7"></a>
<h5 class="docSection3Title">Using (<tt>const</tt>) References to Avoid Copies</h5>
<p class="docText"><a name="idd1e49511"></a><a name="idd1e49518"></a><a name="idd1e49526"></a><a name="idd1e49533"></a><a name="idd1e49540"></a><a name="idd1e49545"></a><a name="idd1e49555"></a><a name="idd1e49562"></a>The other circumstance in which reference parameters are useful is when passing a large object to a function. Although copying an argument is okay for objects of built-in data types and for objects of class types that are small in size, it is (often) too inefficient for objects of most class types or large arrays. Moreover, as we'll learn in <a class="docLink" href="ch13.html#ch13">Chapter 13</a>, some class types cannot be copied. By using a reference parameter, the function can access the object directly without copying it.</P>
<p class="docText">As an example, we'll write a function that compares the length of two <tt>string</tt>s. Such a function needs to access the <tt>size</tt> of each <tt>string</tt> but has no need to write to the <tt>string</tt>s. Because <tt>string</tt>s can be long, we'd like to avoid copying them. Using <tt>const</tt> references we can avoid the copy:</p>
<pre>
     // <span class="docEmphItalicAlt">compare the length of two strings</span>
     bool isShorter(const string &amp;s1, const string &amp;s2)
     {
         return s1.size() &lt; s2.size();
     }
</pre><br>
<p class="docText">Each parameter is a reference to <tt>const string</tt>. Because the parameters are references the arguments are not copied. Because the parameters are <tt>const</tt> references, <tt>is Shorter</tt> may not use the references to change the arguments.</P>
<a name="ch07note06"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> When the only reason to make a parameter a reference is to avoid copying the argument, the parameter should be <tt>const</tt> reference.</p></td></tr></table><br>
</p></div><br>

<a name="ch07lev3sec8"></a>
<h5 class="docSection3Title">References to <tt>const</tt> Are More Flexible</h5>
<p class="docText">It should be obvious that a function that takes a plain, non<tt>const</tt> reference may not be called on behalf of a <tt>const</tt> object. After all, the function might change the object it is passed and thus violate the <tt>const</tt>ness of the argument.</p>
<p class="docText">What may be less obvisous is that we also cannot call such a function with an rvalue (<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec10">Section 2.3.1</a>, p. <a class="docLink" href="ch02lev1sec3.html#ch02lev2sec10">45</a>) or with an object of a type that requires a conversion:</p>
<pre>
     // <span class="docEmphItalicAlt">function takes a non-const reference parameter</span>
     int incr(int &amp;val)
     {
         return ++val;
     }
     int main()
     {
         short v1 = 0;
         const int v2 = 42;
         int v3 = incr(v1);   // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">v1</span> <span class="docEmphItalicAlt">is not an</span> <span class="docEmphasis">int</span>
         v3 = incr(v2);       // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">v2</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">const</span>
         v3 = incr(0);        // <span class="docEmphItalicAlt">error: literals are not lvalues</span>
         v3 = incr(v1 + v2);  // <span class="docEmphItalicAlt">error: addition doesn't yield an lvalue</span>
         int v4 = incr(v3);   // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">v3</span> <span class="docEmphItalicAlt">is a non</span> <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">object type</span> <span class="docEmphasis">int</span>
     }
</pre><BR>
<p class="docText"><a name="idd1e49717"></a><a name="idd1e49724"></a><a name="idd1e49729"></a>The problem is that a non<tt>const</tt> reference (<a class="docLink" href="ch02lev1sec5.html#ch02lev1sec5">Section 2.5</a>, p. <a class="docLink" href="ch02lev1sec5.html#ch02lev1sec5">59</a>) may be bound only to non<tt>const</tt> object of exactly the same type.</P>
<p class="docText">Parameters that do not change the value of the corresponding argument should be <tt>const</tt> references. Defining such parameters as non<tt>const</tt> references needlessly restricts the usefulness of a function. As an example, we might write a program to find a given character in a <tt>string</tt>:</p>
<pre>
     // <span class="docEmphItalicAlt">returns index of first occurrence of</span> <span class="docEmphItalicAlt">c</span> <span class="docEmphItalicAlt">in</span> <span class="docEmphasis">s</span> <span class="docEmphItalicAlt">or</span> <span class="docEmphasis">s.size()</span> <span class="docEmphItalicAlt">if</span> <span class="docEmphasis">c</span> <span class="docEmphItalicAlt">isn't in</span> <span class="docEmphasis">s</span>
     // <span class="docEmphItalicAlt">Note:</span> <span class="docEmphasis">s</span> <span class="docEmphItalicAlt">doesn't change, so it should be a reference to</span> <span class="docEmphasis">const</span>
     string::size_type find_char(string &amp;s, char c)
     {
         string::size_type i = 0;
         while (i != s.size() &amp;&amp; s[i] != c)
             ++i;                   // <span class="docEmphItalicAlt">not found, look at next character</span>
         return i;
     }
</pre><BR>
<p class="docText">This function takes its <tt>string</tt> argument as a plain (non<tt>const)</tt> reference, even though it doesn't modify that parameter. One problem with this definition is that we cannot call it on a character string literal:</p>
<pre>
     if (find_char("Hello World", 'o')) // ...
</pre><br>
<p class="docText">This call fails at compile time, even though we can convert the literal to a <tt>string</tt>.</P>
<p class="docText">Such problems can be surprisingly pervasive. Even if our program has no <tt>const</tt> objects and we only call <tt>find_char</tt> on behalf of <tt>string</tt> objects (as opposed to on a string literal or an expression that yields a <tt>string</tt>), we can encounter compile-time problems. For example, we might have another function <tt>is_sentence</tt> that wants to use <tt>find_char</tt> to determine whether a <tt>string</tt> represents a sentence:</P>
<pre>
     bool is_sentence (const string &amp;s)
     {
          // <span class="docEmphItalicAlt">if there's a period and it's the last character in</span> <span class="docEmphasis">s</span>
          // <span class="docEmphItalicAlt">then</span> <span class="docEmphasis">s</span> <span class="docEmphItalicAlt">is a sentence</span>
          return (find_char(s, '.') == s.size() - 1);
     }
</pre><br>
<p class="docText">As written, the call to <tt>find_char</tt> from inside <tt>is_sentence</tt> is a compile-time error. The parameter to <tt>is_sentence</tt> is a reference to <tt>const string</tt> and cannot be passed to <tt>find_char</tt>, which expects a reference to a non<tt>const string</tt>.</p>
<a name="ch07note07"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></TD><td valign="top"><p class="docText"> Reference parameters that are not changed should be references to <tt>const</tt>. Plain, non<tt>const</tt> reference parameters are less flexible. Such parameters may not be initialized by <tt>const</tt> objects, or by arguments that are literals or expressions that yield rvalues.</P></TD></tr></table><br>
</p></div><BR>

<a name="ch07lev3sec9"></a>
<H5 class="docSection3Title">Passing a Reference to a Pointer</h5>
<p class="docText">Suppose we want to write a function that swaps two pointers, similar to the program we wrote earlier that swaps two integers. We know that we use <tt>*</tt> to define <a name="idd1e49928"></a><a name="idd1e49933"></a><a name="idd1e49940"></a><a name="idd1e49947"></a><a name="idd1e49952"></a><a name="idd1e49958"></a>a pointer and <tt>&amp;</tt> to define a reference. The question here is how to combine these operators to obtain a reference to a pointer. Here is an example:</p>
<pre>
     // <span class="docEmphItalicAlt">swap values of two pointers to</span> <span class="docEmphasis">int</span>
     void ptrswap(int *&amp;v1, int *&amp;v2)
     {
         int *tmp = v2;
         v2 = v1;
         v1 = tmp;
     }
</pre><br>
<p class="docText">The parameter</p>
<pre>
     int *&amp;v1
</pre><BR>
<p class="docText">should be read from right to left: <tt>v1</tt> is a reference to a pointer to an object of type <tt>int</tt>. That is, <tt>v1</tt> is just another name for whatever pointer is passed to <tt>ptrswap</tt>.</p>
<p class="docText">We could rewrite the <tt>main</tt> function from page <a class="docLink" href="#page_233">233</a> to use <tt>ptrswap</tt> and swap pointers to the values 10 and 20:</p>
<pre>
     int main()
     {
         int i = 10;
         int j = 20;
         int *pi = &amp;i;  // <span class="docEmphasis">pi points to i</span>
         int *pj = &amp;j; // <span class="docEmphasis">pj points to j</span>
         cout &lt;&lt; "Before ptrswap():\t*pi: "
              &lt;&lt; *pi &lt;&lt; "\t*pj: " &lt;&lt; *pj &lt;&lt; endl;
         ptrswap(pi, pj); // <span class="docEmphItalicAlt">now</span> <span class="docEmphasis">pi</span> <span class="docEmphItalicAlt">points to</span> <span class="docEmphasis">j; pj</span> <span class="docEmphItalicAlt">points to</span> <span class="docEmphasis">i</span>
         cout &lt;&lt; "After ptrswap():\t*pi: "
              &lt;&lt; *pi &lt;&lt; "\t*pj: " &lt;&lt; *pj &lt;&lt; endl;
         return 0;
     }
</pre><BR>
<p class="docText">When compiled and executed, the program generates the following output:</p>
<pre>
     <span class="docEmphStrong">Before ptrswap(): *pi: 10 *pj: 20</span>
     <span class="docEmphStrong">After ptrswap():  *pi: 20 *pj: 10</span>
</pre><br>
<p class="docText">What happens is that the <span class="docEmphasis">pointer</span> values are swapped. When we call <tt>ptrswap, pi</tt> points to <tt>i</tt> and <tt>pj</tt> points to <tt>j</tt>. Inside <tt>ptrswap</tt> the pointers are swapped so that after <tt>ptrswap, pi</tt> points to the object <tt>pj</tt> had addressed. In other words, <tt>pi</tt> now points to <tt>j</tt>. Similarly, <tt>pj</tt> points to <tt>i</tt>.</P>


<a name="ch07lev2sec8"></a>
<h4 class="docSection2Title">7.2.3. <tt>vector</tt> and Other Container Parameters</H4>
<a name="ch07note08"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><td valign="top"><p class="docText"> Ordinarily, functions should not have <tt>vector</tt> or other library container parameters. Calling a function that has a plain, nonreference <tt>vector</tt> parameter will copy every element of the <tt>vector</tt>.</p></td></tr></table><br>
</p></div><br>
<p class="docText">In order to avoid copying the <tt>vector</tt>, we might think that we'd make the parameter a reference. However, for reasons that will be clearer after reading <a class="docLink" href="ch11.html#ch11">Chapter 11</a>, <a name="idd1e50137"></a><a name="idd1e50142"></a><a name="idd1e50147"></a><a name="idd1e50152"></a><a name="idd1e50157"></a><a name="idd1e50162"></a><a name="idd1e50167"></a><a name="idd1e50172"></a><a name="idd1e50177"></a>in practice, C++ programmers tend to pass containers by passing iterators to the elements we want to process:</p>
<a name="ch07sb03"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<h2 class="docSidebarTitle">Exercises Section 7.2.2</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch07qa3q1"></a><B>Exercise 7.7:</b></td><td><p class="docText">Explain the difference in the following two parameter declarations:</p>
<pre>
     void f(T);
     void f(T&amp;);
</pre><br>
</td></TR><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch07qa3q2"></a><B>Exercise 7.8:</b></td><td><p class="docText">Give an example of when a parameter should be a reference type. Give an example of when a parameter should not be a reference.</p>
</TD></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa3q3"></a><b>Exercise 7.9:</b></td><TD><p class="docText">Change the declaration of <tt>occurs</tt> in the parameter list of <tt>find_val</tt> (defined on page <a class="docLink" href="#ch07lev3sec6">234</a>) to be a nonreference argument type and rerun the program. How does the behavior of the program change?</p>
</td></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa3q4"></a><B>Exercise 7.10:</b></td><TD><p class="docText">The following program, although legal, is less useful than it might be. Identify and correct the limitation on this program:</p>
<pre>
     bool test(string&amp; s) { return s.empty(); }
</pre><br>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa3q5"></a><b>Exercise 7.11:</b></td><td><p class="docText">When should reference parameters be <tt>const</tt>? What problems might arise if we make a parameter a plain reference when it could be a <tt>const</tt> reference?</p>
</td></tr></table></p>
</blockquote>
</TD></TR></table></p><BR>
<pre>
     // <span class="docEmphItalicAlt">pass iterators to the first and one past the last element to print</span>
     void print(vector&lt;int&gt;::const_iterator beg,
                vector&lt;int&gt;::const_iterator end)
     {
         while (beg != end) {
             cout &lt;&lt; *beg++;
             if (beg != end) cout &lt;&lt; " "; // <span class="docEmphItalicAlt">no space after last element</span>
         }
         cout &lt;&lt; endl;
     }
</pre><br>
<p class="docText">This function prints the elements starting with one referred to by <tt>beg</tt> up to but not including the one referred to by <tt>end</tt>. We print a space after each element but the last.</p>

<a name="ch07lev2sec9"></a>
<H4 class="docSection2Title">7.2.4. Array Parameters</H4>
<p class="docText">Arrays have two special properties that affect how we define and use functions that operate on arrays: We cannot copy an array (<a class="docLink" href="ch04lev1sec1.html#ch04lev2sec1">Section 4.1.1</a>, p. <a class="docLink" href="ch04lev1sec1.html#ch04lev2sec1">112</a>) and when we use the name of an array it is automatically converted to a pointer to the first element (<a class="docLink" href="ch04lev1sec2.html#ch04lev2sec6">Section 4.2.4</a>, p. <a class="docLink" href="ch04lev1sec2.html#ch04lev2sec6">122</a>). Because we cannot copy an array, we cannot write a function that takes an array type parameter. Because arrays are automatically converted to pointers, functions that deal with arrays usually do so indirectly by manipulating pointers to elements in the array.</p>
<a name="ch07lev3sec10"></a>
<h5 class="docSection3Title">Defining an Array Parameter</h5>
<p class="docText"><a name="idd1e50323"></a><a name="idd1e50330"></a>Let's assume that we want to write a function that will print the contents of an array of <tt>int</tt>s. We could specify the array parameter in one of three ways:</p>
<pre>
     // <span class="docEmphItalicAlt">three equivalent definitions of printValues</span>
     void printValues(int*) { /* ... */ }
     void printValues(int[]) { /* ... */ }
     void printValues(int[10]) { /* ... */ }
</pre><br>
<p class="docText">Even though we cannot pass an array directly, we can write a function parameter that looks like an array. Despite appearances, a parameter that uses array syntax is treated as if we had written a pointer to the array element type. These three definitions are equivalent; each is interpreted as taking a parameter of type <tt>int*</tt>.</P>
<a name="ch07note09"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><td valign="top"><p class="docText"> It is usually a good idea to define array parameters as pointers, rather than using the array syntax. Doing so makes it clear that what is being operated on is a pointer to an array element, not the array itself. Because an array dimension is ignored, including a dimension in a parameter definition is particularly misleading.</p></TD></TR></table><br>
</p></div><br>

<a name="ch07lev3sec11"></a>
<h5 class="docSection3Title">Parameter Dimensions Can Be Misleading</H5>
<p class="docText">The compiler ignores any dimension we might specify for an array parameter. Relying, incorrectly, on the dimension, we might write <tt>printValues</tt> as</p>
<pre>
     // <span class="docEmphItalicAlt">parameter treated as</span> <span class="docEmphasis">const int*</span><span class="docEmphItalicAlt">, size of array is ignored</span>
     void printValues(const int ia[10])
     {
          // <span class="docEmphItalicAlt">this code assumes array has 10 elements;</span>
          // <span class="docEmphItalicAlt">disaster if argument has fewer than 10 elements!</span>
          for (size_t i = 0; i != 10; ++i)
          {
              cout &lt;&lt; ia[i] &lt;&lt; endl;
          }
     }
</pre><br>
<p class="docText">Although this code <span class="docEmphasis">assumes</span> that the array it is passed has at least 10 elements, nothing in the language enforces that assumption. The following calls are all legal:</P>
<pre>
     int main()
     {
         int i = 0, j[2] = {0, 1};
         printValues(&amp;i);      // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">&amp;i</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">int*</span><span class="docEmphItalicAlt">; probable run-time error</span>
         printValues(j);      // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">j</span> <span class="docEmphItalicAlt">is converted to pointer to 0th</span>
                              // <span class="docEmphItalicAlt">element; argument has type</span> <span class="docEmphasis">int*;</span>
                              // <span class="docEmphItalicAlt">probable run-time error</span>
         return 0;
     }
</pre><br>
<p class="docText">Even though the compiler issues no complaints, both calls are in error, and probably will fail at run time. In each case, memory beyond the array will be accessed <a name="idd1e50442"></a><a name="idd1e50449"></a><a name="idd1e50456"></a><a name="idd1e50463"></a><a name="idd1e50470"></a><a name="idd1e50475"></a><a name="idd1e50481"></a><a name="idd1e50486"></a>because <tt>printValues</tt> assumes that the array it is passed has at least 10 elements. Depending on the values that happen to be in that memory, the program will either produce spurious output or crash.</p>
<a name="ch07note10"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> When the compiler checks an argument to an array parameter, it checks only that the argument is a pointer and that the types of the pointer and the array elements match. The size of the array is not checked.</p></td></tr></table><br>
</p></div><br>

<a name="ch07lev3sec12"></a>
<h5 class="docSection3Title">Array Arguments</h5>
<p class="docText">As with any other type, we can define an array parameter as a reference or nonreference type. Most commonly, arrays are passed as plain, nonreference types, which are quietly converted to pointers. As usual, a nonreference type parameter is initialized as a copy of its corresponding argument. When we pass an array, the argument is a pointer to the first element in the array. That pointer value is copied; the array elements themselves are not copied. The function operates on a copy of the pointer, so it cannot change the value of the argument pointer. The function can, however, use that pointer to change the element values to which the pointer points. Any changes through the pointer parameter are made to the array elements themselves.</p>
<a name="ch07note11"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></TD><td valign="top"><p class="docText"> Functions that do not change the elements of their array parameter should make the parameter a pointer to <tt>const</tt>:</P></td></tr></table><BR>
<pre>
     // <span class="docEmphasis">f</span> <span class="docEmphItalicAlt">won't change the elements in the array</span>
     void f(const int*) { /* ... */ }
</pre><BR>
</p></div><br>

<a name="ch07lev3sec13"></a>
<h5 class="docSection3Title">Passing an Array by Reference</h5>
<p class="docText">As with any type, we can define an array parameter as a reference to the array. If the parameter is a reference to the array, then the compiler does not convert an array argument into a pointer. Instead, a reference to the array itself is passed. In this case, the array size is part of the parameter and argument types. The compiler will check that the size of the array argument matches the size of the parameter:</p>
<pre>
     // <span class="docEmphItalicAlt">ok: parameter is a reference to an array; size of array is fixed</span>
     void printValues(int (&amp;arr)[10]) { /* ... */ }
     int main()
     {
         int i = 0, j[2] = {0, 1};
         int k[10] = {0,1,2,3,4,5,6,7,8,9};
         printValues(&amp;i); // <span class="docEmphItalicAlt">error: argument is not an array of 10</span> <span class="docEmphasis">ints</span>
         printValues(j);  // <span class="docEmphItalicAlt">error: argument is not an array of 10</span> <span class="docEmphasis">ints</span>
         printValues(k);  // <span class="docEmphItalicAlt">ok: argument is an array of 10</span> <span class="docEmphasis">ints</span>
         return 0;
     }
</pre><BR>
<p class="docText">This version of <tt>printValues</tt> may be called only for arrays of exactly 10 <tt>int</tt>s, limiting which arrays can be passed. However, because the parameter is a reference, <a name="idd1e50582"></a><a name="idd1e50587"></a><a name="idd1e50594"></a><a name="idd1e50601"></a><a name="idd1e50606"></a><a name="idd1e50611"></a>it is safe to rely on the size in the body of the function:</p>
<pre>
     // <span class="docEmphItalicAlt">ok: parameter is a reference to an array; size of array is fixed</span>
     void printValues(int (&amp;arr)[10])
     {
         for (size_t i = 0; i != 10; ++i) {
             cout &lt;&lt; arr[i] &lt;&lt; endl;
         }
     }
</pre><BR>
<a name="ch07note12"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> The parentheses around <tt>&amp;arr</tt> are necessary because of the higher precedence of the subscript operator:</P></td></tr></table><br>
<pre>
     f(int &amp;arr[10])     // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">arr</span> <span class="docEmphItalicAlt">is an array of references</span>
     f(int (&amp;arr)[10]) // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">arr</span> <span class="docEmphItalicAlt">is a reference to an array of 10</span> <span class="docEmphasis">int</span><span class="docEmphItalicAlt">s</span>
</pre><br>
</P></div><br>
<p class="docText">We'll see in <a class="docLink" href="ch16lev1sec1.html#ch16lev2sec5">Section 16.1.5</a> (p. <a class="docLink" href="ch16lev1sec1.html#ch16lev2sec5">632</a>) how we might write this function in a way that would allow us to pass a reference parameter to an array of any size.</p>

<a name="ch07lev3sec14"></a>
<H5 class="docSection3Title">Passing a Multidimensioned Array</h5>
<p class="docText">Recall that there are no multidimensioned arrays in C++ (<a class="docLink" href="ch04lev1sec4.html#ch04lev1sec4">Section 4.4</a>, p. <a class="docLink" href="ch04lev1sec4.html#ch04lev1sec4">141</a>). Instead, what appears to be a multidimensioned array is an array of arrays.</p>
<p class="docText">As with any array, a multidimensioned array is passed as a pointer to its zeroth element. An element in a multidimenioned array is an array. The size of the second (and any subsequent dimensions) is part of the element type and must be specified:</P>
<pre>
     // <span class="docEmphItalicAlt">first parameter is an array whose elements are arrays of 10</span> <span class="docEmphasis">int</span><span class="docEmphItalicAlt">s</span>
     void printValues(int (matrix*)[10], int rowSize);
</pre><br>
<p class="docText">declares <tt>matrix</tt> as a pointer to an array of ten <tt>int</tt>s.</P>
<a name="ch07note13"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> Again, the parentheses around <tt>*matrix</tt> are necessary:</p></td></tr></table><br>
<pre>
     int *matrix[10];   // <span class="docEmphItalicAlt">array of 10 pointers</span>
     int (*matrix)[10]; // <span class="docEmphItalicAlt">pointer to an array of 10</span> <span class="docEmphasis">int</span><span class="docEmphItalicAlt">s</span>
</pre><br>
</p></div><br>
<p class="docText">We could also declare a multidimensioned array using array syntax. As with a single-dimensioned array, the compiler ignores the first dimension and so it is best not to include it:</p>
<pre>
     // <span class="docEmphItalicAlt">first parameter is an array whose elements are arrays of 10</span> <span class="docEmphasis">int</span><span class="docEmphItalicAlt">s</span>
     void printValues(int matrix[][10], int rowSize);
</pre><BR>
<p class="docText">declares <tt>matrix</tt> to be what looks like a two-dimensioned array. In fact, the parameter is a pointer to an element in an array of arrays. Each element in the array is itself an array of ten <tt>int</tt>s.</P>


<a name="ch07lev2sec10"></a>
<h4 class="docSection2Title">7.2.5. Managing Arrays Passed to Functions</H4>
<p class="docText">As we've just seen, type checking for a nonreference array parameter confirms only that the argument is a pointer of the same type as the elements in the array. <a name="idd1e50784"></a><a name="idd1e50789"></a><a name="idd1e50794"></a><a name="idd1e50801"></a><a name="idd1e50806"></a><a name="idd1e50811"></a><a name="idd1e50816"></a><a name="idd1e50821"></a><a name="idd1e50826"></a><a name="idd1e50831"></a><a name="idd1e50836"></a>Type checking does not verify that the argument actually points to an array of a specified size.</p>
<a name="ch07note14"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> It is up to any program dealing with an array to ensure that the program stays within the bounds of the array.</p></td></tr></table><BR>
</p></div><BR>
<p class="docText">There are three common programming techniques to ensure that a function stays within the bounds of its array argument(s). The first places a marker in the array itself that can be used to detect the end of the array. C-style character strings are an example of this approach. C-style strings are arrays of characters that encode their termination point with a null character. Programs that deal with C-style strings use this marker to stop processing elements in the array.</P>
<a name="ch07lev3sec15"></a>
<h5 class="docSection3Title">Using the Standard Library Conventions</h5>
<p class="docText">A second approach is to pass pointers to the first and one past the last element in the array. This style of programming is inspired by techniques used in the standard library. We'll learn more about this style of programming in <a class="docLink" href="part02.html#part02">Part II</a>.</p>
<p class="docText">Using this approach, we could rewrite <tt>printValues</tt> and call the new version as follows:</P>
<pre>
     void printValues(const int *beg, const int *end)
     {
         while (beg != end) {
             cout &lt;&lt; *beg++ &lt;&lt; endl;
          }
     }
     int main()
     {
         int j[2] = {0, 1};
         // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">j</span> <span class="docEmphItalicAlt">is converted to pointer to 0th element in</span> <span class="docEmphasis">j</span>
         //     <span class="docEmphasis">j + 2</span> <span class="docEmphItalicAlt">refers one past the end of</span> <span class="docEmphasis">j</span>
         printValues(j, j + 2);
         return 0;
     }
</pre><BR>
<p class="docText">The loop inside <tt>printValues</tt> looks like other programs we've written that used <tt>vector</tt> iterators. We march the <tt>beg</tt> pointer one element at a time through the array. We stop the loop when <tt>beg</tt> is equal to the end marker, which was passed as the second parameter to the function.</p>
<p class="docText">When we call this version, we pass two pointers: one to the first element we want to print and one just past the last element. The program is safe, as long as we correctly calculate the pointers so that they denote a range of elements.</p>

<a name="ch07lev3sec16"></a>
<h5 class="docSection3Title">Explicitly Passing a Size Parameter</h5>
<p class="docText">A third approach, which is common in C programs and pre-Standard C++ programs, is to define a second parameter that indicates the size of the array.</P>
<p class="docText"><a name="idd1e50929"></a><a name="idd1e50936"></a><a name="idd1e50942"></a><a name="idd1e50947"></a><a name="idd1e50954"></a><a name="idd1e50959"></a>Using this approach, we could rewrite <tt>printValues</tt> one more time. The new version and a call to it looks like:</p>
<pre>
     // <span class="docEmphasis">const int ia[]</span> <span class="docEmphItalicAlt">is equivalent to</span> <span class="docEmphasis">const int* ia</span>
     // <span class="docEmphasis">size</span> <span class="docEmphItalicAlt">is passed explicitly and used to control access to elements of</span> <span class="docEmphasis">ia</span>
     void printValues(const int ia[], size_t size)
     {
          for (size_t i = 0; i != size; ++i) {
              cout &lt;&lt; ia[i] &lt;&lt; endl;
          }
     }
     int main()
     {
         int j[] = { 0, 1 }; // <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">array of size 2</span>
         printValues(j, sizeof(j)/sizeof(*j));
         return 0;
     }
</pre><br>
<p class="docText">This version uses the <tt>size</tt> parameter to determine how many elements there are to print. When we call <tt>printValues</tt>, we must pass an additional parameter. The program executes safely as long as the size passed is no greater than the actual size of the array.</P>
<a name="ch07sb04"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Exercises Section 7.2.5</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa4q1"></a><b>Exercise 7.12:</b></td><td><p class="docText">When would you use a parameter that is a pointer? When would you use a parameter that is a reference? Explain the advantages and disadvantages of each.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa4q2"></a><b>Exercise 7.13:</b></td><TD><p class="docText">Write a program to calculate the sum of the elements in an array. Write the function three times, each one using a different approach to managing the array bounds.</P>
</td></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa4q3"></a><B>Exercise 7.14:</b></TD><td><p class="docText">Write a program to sum the elements in a <tt>vector&lt;double&gt;</tt>.</p>
</td></tr></table></p>
</blockquote>
</TD></tr></table></P><BR>


<a name="ch07lev2sec11"></a>
<h4 class="docSection2Title">7.2.6. <tt>main</tt>: Handling Command-Line Options</h4>
<p class="docText">It turns out that <tt>main</tt> is a good example of how C programs pass arrays to functions. Up to now, we have defined <tt>main</tt> with an empty parameter list:</p>
<pre>
     int main() { ... }
</pre><BR>
<p class="docText">However, we often need to pass arguments to <tt>main</tt>. TRaditionally, such arguments are options that determine the operation of the program. For example, assuming our <tt>main</tt> program was in an executable file named <tt>prog</tt>, we might pass options to the program as follows:</p>
<pre>
     prog -d -o ofile data0
</pre><br>
<p class="docText"><a name="idd1e51097"></a><a name="idd1e51102"></a><a name="idd1e51106"></a><a name="idd1e51113"></a><a name="idd1e51117"></a><a name="idd1e51122"></a><a name="idd1e51129"></a><a name="idd1e51134"></a>The way this usage is handled is that <tt>main</tt> actually defines two parameters:</p>
<pre>
     int main(int argc, char *argv[]) { ... }
</pre><br>
<p class="docText">The second parameter, <tt>argv</tt>, is an array of C-style character strings. The first parameter, <tt>argc</tt>, passes the number of strings in that array. Because the second parameter is an array, we might alternatively define <tt>main</tt> as</P>
<pre>
     int main(int argc, char **argv) { ... }
</pre><br>
<p class="docText">indicating that <tt>argv</tt> points to a <tt>char*</tt>.</p>
<p class="docText">When arguments are passed to <tt>main</tt>, the first string in <tt>argv</tt>, if any, is always the name of the program. Subsequent elements pass additional optional strings to <tt>main</tt>. Given the previous command line, <tt>argc</tt> would be set to 5, and <tt>argv</tt> would hold the following C-style character strings:</P>
<pre>
     argv[0] = "prog";
     argv[1] = "-d";
     argv[2] = "-o";
     argv[3] = "ofile";
     argv[4] = "data0";
</pre><br>
<a name="ch07sb05"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<H2 class="docSidebarTitle">Exercises Section 7.2.6</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa5q1"></a><b>Exercise 7.15:</b></td><td><p class="docText">Write a <tt>main</tt> function that takes two values as arguments and print their sum.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa5q2"></a><b>Exercise 7.16:</b></TD><TD><p class="docText">Write a program that could accept the options presented in this section. Print the values of the arguments passed to <tt>main</tt>.</p>
</TD></tr></table></p>
</blockquote>
</TD></TR></table></p><br>

<a name="ch07lev2sec12"></a>
<h4 class="docSection2Title">7.2.7. Functions with Varying Parameters</h4>
<a name="ch07note15"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></TD><TD valign="top"><p class="docText"> Ellipsis parameters are in C++ in order to compile C programs that use <tt>varargs</tt>. See your C compiler documentation for how to use <tt>varargs</tt>. Only simple data types from the C++ program should be passed to functions with ellipses parameters. In particular, objects of most class types are not copied properly when passed to ellipses parameters.</p></td></tr></table><BR>
</P></div><br>
<p class="docText">Ellipses parameters are used when it is impossible to list the type and number of all the arguments that might be passed to a function. Ellipses suspend type checking. Their presence tells the compiler that when the function is called, zero or more arguments may follow and that the types of the arguments are unknown. Ellipses may take either of two forms:</p>
<pre>
     void foo(parm_list, ...);
     void foo(...);
</pre><br>
<p class="docText"><a name="idd1e51269"></a><a name="idd1e51275"></a><a name="idd1e51280"></a><a name="idd1e51286"></a><a name="idd1e51291"></a><a name="idd1e51298"></a><a name="idd1e51304"></a><a name="idd1e51310"></a><a name="idd1e51315"></a>The first form provides declarations for a certain number of parameters. In this case, type checking is performed when the function is called for the arguments that correspond to the parameters that are explicitly declared, whereas type checking is suspended for the arguments that correspond to the ellipsis. In this first form, the comma following the parameter declarations is optional.</p>
<p class="docText">Most functions with an ellipsis use some information from a parameter that is explicitly declared to obtain the type and number of optional arguments provided in a function call. The first form of function declaration with ellipsis is therefore most commonly used.</P>


<a href="21001535.html"><img src="images/pixel.gif" alt="" width="1" height="1" border="0"></a><ul></ul></TD></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch07lev1sec1.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch07lev1sec3.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>