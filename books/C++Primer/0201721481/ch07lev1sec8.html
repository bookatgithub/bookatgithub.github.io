<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 7.8.&nbsp; Overloaded Functions</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch07lev1sec7.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch07lev1sec9.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch07lev1sec8"></a>
<h3 class="docSection1Title" id="432172-971">7.8. Overloaded Functions</h3>
<p class="docText">Two functions that appear in the same scope are <B><a name="ch07term29"></a><a class="docLink" href="ch07lev1sec11.html#gloss07_20">overloaded</a></b> if they have the same name but have different parameter lists.</P>
<p class="docText">If you have written an arithmetic expression in a programming language, you have used an overloaded function. The expression</p>
<pre>
     1 + 3
</pre><BR>
<p class="docText">invokes the addition operation for integer operands, whereas the expression</p>
<pre>
     1.0 + 3.0
</pre><br>
<p class="docText">invokes a <span class="docEmphasis">different</span> operation that adds floating-point operands. It is the compiler's responsibility, not the programmer's, to distinguish between the different operations and to apply the appropriate operation depending on the operands' types.</P>
<p class="docText">Similarly, we may define a set of functions that perform the same general action but that apply to different parameter types. These functions may be called without worrying about which function is invoked, much as we can add <tt>int</tt>s or <tt>double</tt>s without worrying whether integer arithmetic or floating-point arithmetic is performed.</P>
<p class="docText">Function overloading can make programs easier to write and to understand by eliminating the need to inventand remembernames that exist only to help the compiler figure out which function to call. For example, a database application might well have several <tt>lookup</tt> functions that could do the lookup based on <a name="idd1e54717"></a><a name="idd1e54724"></a>name, phone number, account number, and so on. Function overloading allows us to define a collection of functions, each named <tt>lookup</tt>, that differ in terms of what values they use to do the search. We can call <tt>lookup</tt> passing a value of any of several types:</p>
<pre>
     Record lookup(const Account&amp;);  // <span class="docEmphItalicAlt">find by</span> <span class="docEmphasis">Account</span>
     Record lookup(const Phone&amp;);    // <span class="docEmphItalicAlt">find by</span> <span class="docEmphasis">Phone</span>
     Record lookup(const Name&amp;);     // <span class="docEmphItalicAlt">find by</span> <span class="docEmphasis">Name</span>
     Record r1, r2;
     r1 = lookup(acct);                  // <span class="docEmphItalicAlt">call version that takes an</span> <span class="docEmphasis">Account</span>
     r2 = lookup(phone);                 // <span class="docEmphItalicAlt">call version that takes a</span> <span class="docEmphasis">Phone</span>
</pre><br>
<p class="docText">Here, all three functions share the same name, yet they are three distinct functions. The compiler uses the argument type(s) passed in the call to figure out which function to call.</p>
<p class="docText">To understand function overloading, we must understand how to define a set of overloaded functions and how the compiler decides which function to use for a given call. We'll review these topics in the remainder of this section.</p>
<a name="ch07note31"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><TD valign="top"><p class="docText"> There may be only one instance of <tt>main</tt> in any program. The <tt>main</tt> function may <span class="docEmphasis">not</span> be overloaded.</p></td></tr></table><BR>
</P></div><br>
<a name="ch07lev2sec26"></a>
<h4 class="docSection2Title">Distinguishing Overloading from Redeclaring a Function</h4>
<p class="docText">If the return type and parameter list of two functions declarations match exactly, then the second declaration is treated as a redeclaration of the first. If the parameter lists of two functions match exactly but the return types differ, then the second declaration is an error:</p>
<pre>
     Record lookup(const Account&amp;);
     bool lookup(const Account&amp;); // <span class="docEmphItalicAlt">error: only return type is different</span>
</pre><BR>
<p class="docText">Functions cannot be overloaded based only on differences in the return type.</p>
<p class="docText">Two parameter lists can be identical, even if they don't look the same:</p>
<pre>
     // <span class="docEmphItalicAlt">each pair declares the same function</span>
     Record lookup(const Account &amp;acct);
     Record lookup(const Account&amp;); // <span class="docEmphItalicAlt">parameter names are ignored</span>
     typedef Phone Telno;
     Record lookup(const Phone&amp;);
     Record lookup(const Telno&amp;); // <span class="docEmphasis">Telno</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">Phone</span> <span class="docEmphItalicAlt">are the same type</span>
     Record lookup(const Phone&amp;, const Name&amp;);
     // <span class="docEmphItalicAlt">default argument doesn't change the number of parameters</span>
     Record lookup(const Phone&amp;, const Name&amp; = "");
     // <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">is irrelevent for nonreference parameters</span>
     Record lookup(Phone);
     Record lookup(const Phone); // <span class="docEmphItalicAlt">redeclaration</span>
</pre><BR>
<p class="docText">In the first pair, the first declaration names its parameter. Parameter names are only a documentation aid. They do not change the parameter list.</p>
<p class="docText"><a name="idd1e54860"></a><a name="idd1e54866"></a><a name="page_267"></a>In the second pair, it looks like the types are different, but <tt>Telno</tt> is not a new type; it is a synonym for <tt>Phone</tt>. A typedef name provides an alternative name for an existing data type; it does not create a new data type. Therefore, two parameters that differ only in that one uses a typedef and the other uses the type to which the typedef corresponds are not different.</p>
<p class="docText">In the third pair, the parameter lists differ only in their default arguments. A default argument doesn't change the number of parameters. The function takes two arguments, whether they are supplied by the user or by the compiler.</P>
<p class="docText">The last pair differs only as to whether the parameter is <tt>const</tt>. This difference has no effect on the objects that can be passed to the function; the second declaration is treated as a redeclaration of the first. The reason follows from how arguments are passed. When the parameter is copied, whether the parameter is <tt>const</tt> is irrelevantthe function executes on a copy. Nothing the function does can change the argument. As a result, we can pass a <tt>const</tt> object to either a <tt>const</tt> or non<tt>const</tt> parameter. The two parameters are indistinguishable.</p>
<p class="docText">It is worth noting that the equivalence between a parameter and a <tt>const</tt> parameter applies only to nonreference parameters. A function that takes a <tt>const</tt> reference is different from on that takes a non<tt>const</tt> reference. Similarly, a function that takes a pointer to a <tt>const</tt> type differs from a function that takes a pointer to the non<tt>const</tt> object of the same type.</P>
<a name="ch07sb13"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Advice: When Not to Overload a Function Name</h2>
<p class="docText"><span class="docEmphStrong">Although overloading can be useful in avoiding the necessity to invent (and remember) names for common operations, it is easy to take this advantage too far. There are some cases where providing different function names adds information that makes the program easier to understand. Consider a set of member functions for a <tt>Screen</tt> class that move <tt>Screen</tt></span><span class="docEmphStrong">'s cursor.</span></p>
<pre>
     Screen&amp; moveHome();
     Screen&amp; moveAbs(int, int);
     Screen&amp; moveRel(int, int, char *direction);
</pre><br>
<p class="docText"><span class="docEmphStrong">It might at first seem better to overload this set of functions under the name <tt>move</tt>:</span></p>
<pre>
     Screen&amp; move();
     Screen&amp; move(int, int);
     Screen&amp; move(int, int, *direction);
</pre><br>
<p class="docText"><span class="docEmphStrong">However, by overloading these functions we've lost information that was inherent in the function names and by doing so may have rendered the program more obscure.</span></p>
<p class="docText"><span class="docEmphStrong">Although cursor movement is a general operation shared by all these functions, the specific nature of that movement is unique to each of these functions. <tt>moveHome</tt>, for example, represents a special instance of cursor movement. Which of the two calls is easier to understand for a reader of the program? Which of the two calls is easier to remember for a programmer using the <tt>Screen</tt> class?</span></p>
<pre>
     // <span class="docEmphItalicAlt">which is easier to understand?</span>
     myScreen.home(); // <span class="docEmphItalicAlt">we think this one!</span>
     myScreen.move();
</pre><br>
</td></TR></table></P><br>

<a name="ch07lev2sec27"></a>
<H4 class="docSection2Title">7.8.1. Overloading and Scope</h4>
<p class="docText"><a name="idd1e54988"></a><a name="idd1e54995"></a>We saw in the program on page <a class="docLink" href="ch02lev1sec3.html#ch02lev2sec15">54</a> that scopes in C++ nest. A name declared local to a function hides the same name declared in the global scope (<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec15">Section 2.3.6</a>, p. <a class="docLink" href="ch02lev1sec3.html#ch02lev2sec15">54</a>). The same is true for function names as for variable names:</p>
<pre>
     /* <span class="docEmphItalicAlt">Program for illustration purposes only:</span>
      * <span class="docEmphItalicAlt">It is bad style for a function to define a local variable</span>
      * <span class="docEmphItalicAlt">with the same name as a global name it wants to use</span>
      */
     string init(); // <span class="docEmphItalicAlt">the name</span> <span class="docEmphasis">init</span> <span class="docEmphItalicAlt">has global scope</span>
     void fcn()
     {
         int init = 0;        // <span class="docEmphasis">init</span> <span class="docEmphItalicAlt">is local and hides global</span> <span class="docEmphasis">init</span>
         string s = init();   // <span class="docEmphItalicAlt">error: global</span> <span class="docEmphasis">init</span> <span class="docEmphItalicAlt">is hidden</span>
     }
</pre><BR>
<p class="docText">Normal scoping rules apply to names of overloaded functions. If we declare a function locally, that function hides rather than overloads the same function declared in an outer scope. As a consequence, declarations for every version of an overloaded function must appear in the same scope.</P>
<a name="ch07note32"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> In general, it is a bad idea to declare a function locally. Function declarations should go in header files.</P></td></TR></table><BR>
<p class="docText">To explain how scope interacts with overloading we will violate this practice and use a local function declaration.</p>
</p></div><br>
<p class="docText">As an example, consider the following program:</P>
<pre>
     void print(const string &amp;);
     void print(double);   // <span class="docEmphItalicAlt">overloads the</span> <span class="docEmphasis">print</span> <span class="docEmphItalicAlt">function</span>
     void fooBar(int ival)
     {
         void print(int);   // <span class="docEmphItalicAlt">new scope: hides previous instances of</span> <span class="docEmphasis">print</span>
         print("Value: ");  // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">print(const string &amp;)</span> <span class="docEmphItalicAlt">is hidden</span>
         print(ival); // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">print(int)</span> <span class="docEmphItalicAlt">is visible</span>
         print(3.14); // <span class="docEmphItalicAlt">ok: calls</span> <span class="docEmphasis">print(int)</span><span class="docEmphItalicAlt">;</span> <span class="docEmphasis">print(double)</span> <span class="docEmphItalicAlt">is hidden</span>
     }
</pre><BR>
<p class="docText">The declaration of <tt>print(int)</tt> in the function <tt>fooBar</tt> hides the other declarations of <tt>print</tt>. It is as if there is only one <tt>print</tt> function available: the one that takes a single <tt>int</tt> parameter. Any use of the name <tt>print</tt> at this scopeor a scope nested in this scopewill resolve to this instance.</p>
<p class="docText">When we call <tt>print</tt>, the compiler first looks for a declaration of that name. It finds the local declaration for <tt>print</tt> that takes an <tt>int</tt>. Once the name is found, the compiler does no further checks to see if the name exists in an outer scope. Instead, the compiler assumes that this declaration is the one for the name we are using. What remains is to see if the use of the name is valid</p>
<p class="docText">The first call passes a string literal but the function parameter is an <tt>int</tt>. A string literal cannot be implicitly converted to an <tt>int</tt>, so the call is an error. The <a name="idd1e55166"></a><a name="idd1e55171"></a><a name="idd1e55176"></a><a name="idd1e55181"></a><a name="idd1e55184"></a><a name="idd1e55189"></a><a name="idd1e55194"></a><a name="idd1e55197"></a><a name="idd1e55202"></a><a name="idd1e55207"></a><tt>print(const string&amp;)</tt> function, which would have matched this call, is hidden and is not considered when resolving this call.</p>
<p class="docText">When we call <tt>print</tt> passing a <tt>double</tt>, the process is repeated. The compiler finds the local definition of <tt>print(int)</tt>. The <tt>double</tt> argument can be converted to an <tt>int</tt>, so the call is legal.</p>
<a name="ch07note33"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><td valign="top"><p class="docText"> In C++ name lookup happens before type checking.</p></TD></tr></table><BR>
</p></div><br>
<p class="docText">Had we declared <tt>print(int)</tt> in the same scope as the other <tt>print</tt> functions, then it would be another overloaded version of <tt>print</tt>. In that case, these calls would be resolved differently:</p>
<pre>
     void print(const string &amp;);
     void print(double); // <span class="docEmphItalicAlt">overloads</span> <span class="docEmphasis">print</span> <span class="docEmphItalicAlt">function</span>
     void print(int);    // <span class="docEmphItalicAlt">another overloaded instance</span>
     void fooBar2(int ival)
     {
         print("Value: "); // <span class="docEmphItalicAlt">ok: calls</span> <span class="docEmphasis">print(const string &amp;)</span>
         print(ival);      // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">print(int)</span>
         print(3.14);      // <span class="docEmphItalicAlt">ok: calls</span> <span class="docEmphasis">print (double)</span>
     }
</pre><br>
<p class="docText">Now when the compiler looks for the name <tt>print</tt> it finds three functions with that name. On each call it selects the version of <tt>print</tt> that matches the argument that is passed.</p>

<a name="ch07lev2sec28"></a>
<h4 class="docSection2Title">7.8.2. Function Matching and Argument Conversions</h4>
<p class="docText">Function <b><a name="ch07term19"></a><a class="docLink" href="ch07lev1sec11.html#gloss07_19">overload resolution</a></b> (also known as <b><a name="ch07term13"></a><a class="docLink" href="ch07lev1sec11.html#gloss07_13">function matching</a></b>) is the process by which a function call is associated with a specific function from a set of overloaded functions. The compiler matches a call to a function automatically by comparing the actual arguments used in the call with the parameters offered by each function in the overload set. There are three possible outcomes:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">The compiler finds one function that is a <b><a name="ch07term4"></a><a class="docLink" href="ch07lev1sec11.html#gloss07_04">best match</a></b> for the actual arguments and generates code to call that function.</p></div></LI><LI><div style="font-weight:normal"><p class="docList">There is no function with parameters that match the arguments in the call, in which case the compiler indicates a compile-time error.</p></div></LI><li><div style="font-weight:normal"><p class="docList">There is more than one function that matches and none of the matches is clearly best. This case is also an error; the call is <b><a name="ch07term28"></a><a class="docLink" href="ch07lev1sec11.html#gloss07_01">ambiguous</a></b>.</P></div></LI></ol></div>
<p class="docText">Most of the time it is straghtforward to determine whether a particular call is legal and if so, which function will be invoked by the compiler. Often the functions in the overload set differ in terms of the number of arguments, or the types of the arguments are unrelated. Function matching gets tricky when multiple functions have parameters that are related by conversions (<a class="docLink" href="ch05lev1sec12.html#ch05lev1sec12">Section 5.12</a>, p. <a class="docLink" href="ch05lev1sec12.html#ch05lev1sec12">178</a>). In these cases, programmers need to have a good grasp of the process of function matching.</p>
<a name="ch07sb14"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 7.8.1</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch07qa13q1"></a><b>Exercise 7.34:</b></td><td><p class="docText"><a name="idd1e55364"></a><a name="idd1e55367"></a><a name="idd1e55372"></a><a name="idd1e55377"></a><a name="idd1e55382"></a>Define a set of overloaded functions named <tt>error</tt> that would match the following calls:</P>
<pre>
     int index, upperBound;
     char selectVal;
     // ...
     error("Subscript out of bounds: ", index, upperBound);
     error("Division by zero");
     error("Invalid selection", selectVal);
</pre><BR>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa13q2"></a><B>Exercise 7.35:</b></td><td><p class="docText">Explain the effect of the second declaration in each one of the following sets of declarations. Indicate which, if any, are illegal.</P>
<pre>
     (a) int calc(int, int);
         int calc(const int, const int);

     (b) int get();
         double get();

     (c) int *reset(int *);
         double *reset(double *);
</pre><br>
</td></TR></table></p>
</blockquote>
</TD></tr></table></p><br>

<a name="ch07lev2sec29"></a>
<h4 class="docSection2Title">7.8.3. The Three Steps in Overload Resolution</h4>
<p class="docText">Consider the following set of functions and function call:</p>
<pre>
     void f();
     void f(int);
     void f(int, int);
     void f(double, double = 3.14);
     f(5.6);  // <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">void f(double, double)</span>
</pre><br>
<a name="ch07lev3sec33"></a>
<h5 class="docSection3Title">Candidate Functions</h5>
<p class="docText">The first step of function overload resolution identifies the set of overloaded functions considered for the call. The functions in this set are the <b><a name="ch07term6"></a><a class="docLink" href="ch07lev1sec11.html#gloss07_06">candidate functions</a></b>. A candidate function is a function with the same name as the function that is called and for which a declaration is visible at the point of the call. In this example, there are four candidate functions named <tt>f</tt>.</p>

<a name="ch07lev3sec34"></a>
<h5 class="docSection3Title">Determining the Viable Functions</h5>
<p class="docText">The second step selects the functions from the set of candidate functions that can be called with the arguments specified in the call. The selected functions are the <B><a name="ch07term27"></a><a class="docLink" href="ch07lev1sec11.html#gloss07_27">viable functions</a></b>. To be viable, a function must meet two tests. First, the function must have the same number of parameters as there are arguments in the call. Second, the type of each argument must matchor be convertible tothe type of its corresponding parameter.</P>
<a name="ch07note34"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><TD valign="top"><p class="docText"> When a function has default arguments (<a class="docLink" href="ch07lev1sec4.html#ch07lev2sec17">Section 7.4.1</a>, p. <a class="docLink" href="ch07lev1sec4.html#ch07lev2sec17">253</a>), a call may appear to have fewer arguments than it actually does. Default arguments are arguments and are treated the same way as any other argument during function matching.</P></td></tr></table><br>
</p></div><br>
<p class="docText">For the call <tt>f(5.6)</tt>, we can eliminate two of our candidate functions because of a mismatch on number of arguments. The function that has no parameters and the one that has two <tt>int</tt> parameters are not viable for this call. Our call has only one argument, and these functions have zero and two parameters, respectively.</P>
<p class="docText">On the other hand, the function that takes two <tt>double</tt>s might be viable. A call to a function declaration that has a default argument (<a class="docLink" href="ch07lev1sec4.html#ch07lev2sec17">Section 7.4.1</a>, p. <a class="docLink" href="ch07lev1sec4.html#ch07lev2sec17">253</a>) may omit that argument. The compiler will automatically supply the default argument value for the omitted argument. Hence, a given call might have more arguments than appear explicitly.</p>
<p class="docText">Having used the number of arguments to winnow the potentially viable functions, we must now look at whether the argument types match those of the parameters. As with any call, an argument might match its parameter either because the types match exactly or because there is a conversion from the argument type to the type of the parameter. In the example, both of our remaining functions are viable.</P>
<UL><li><p class="docList"><tt>f(int)</tt> is a viable function because a conversion exists that can convert the argument of type <tt>double</tt> to the parameter of type <tt>int</tt>.</p></li><LI><p class="docList"><tt>f(double, double)</tt> is a viable function because a default argument is provided for the function's second parameter and its first parameter is of type <tt>double</tt>, which exactly matches the type of the parameter.</P></li></ul>
<a name="ch07note35"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> If there are no viable functions, then the call is in error.</P></td></tr></table><BR>
</p></div><BR>

<a name="ch07lev3sec35"></a>
<h5 class="docSection3Title">Finding the Best Match, If Any</h5>
<p class="docText">The third step of function overload resolution determines which viable function has the best match for the actual arguments in the call. This process looks at each argument in the call and selects the viable function (or functions) for which the corresponding parameter best matches the argument. The details of &quot;best&quot; here will be explained in the next section, but the idea is that the closer the types of the argument and parameter are to each other, the better the match. So, for example, an exact type match is better than a match that requires a conversion from the argument type to the parameter type.</p>
<p class="docText">In our case, we have only one explicit argument to consider. That argument has type <tt>double</tt>. To call <tt>f(int)</tt>, the argument would have to be converted from <tt>double</tt> to <tt>int</tt>. The other viable function, <tt>f(double, double)</tt>, is an exact match for this argument. Because an exact match is better than a match that requires a conversion, the compiler will resolve the call <tt>f(5.6)</tt> as a call to the function that has two <tt>double</tt> parameters.</p>

<a name="ch07lev3sec36"></a>
<h5 class="docSection3Title">Overload Resolution with Multiple Parameters</h5>
<p class="docText"><a name="idd1e55580"></a><a name="idd1e55585"></a><a name="idd1e55590"></a><a name="idd1e55595"></a><a name="idd1e55600"></a>Function matching is more complicated if there are two or more explicit arguments. Given the same functions named <tt>f</tt>, let's analyze the following call:</p>
<pre>
     f(42, 2.56);
</pre><br>
<p class="docText">The set of viable functions is selected in the same way. The compiler selects those functions that have the required number of parameters and for which the argument types match the parameter types. In this case, the set of viable functions are <tt>f(int, int)</tt> and <tt>f(double, double)</tt>. The compiler then determines argument by argument which function is (or functions are) the best match. There is a match if there is one and only one function for which</p>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">The match for each argument is no worse than the match required by any other viable function.</p></div></li><li><div style="font-weight:normal"><p class="docList">There is at least one argument for which the match is better than the match provided by any other viable function.</P></div></LI></ol></div>
<p class="docText">If after looking at each argument there is no single function that is preferable, then the call is in error. The compiler will complain that the call is ambiguous.</p>
<p class="docText">In this call, when we look only at the first argument, we find that the function <tt>f(int, int)</tt> is an exact match. To match the second function, the <tt>int</tt> argument <tt>42</tt> must be converted to a <tt>double</tt>. A match through a built-in conversion is &quot;less good&quot; than one that is exact. So, considering only this parameter, the function that takes two <tt>int</tt>s is a better match than the function that takes two <tt>double</tt>s.</P>
<p class="docText">However, when we look at the second argument, then the function that takes two <tt>double</tt>s is an exact match to the argument <tt>2.56</tt>. Calling the version of <tt>f</tt> that takes two <tt>int</tt>s would require that <tt>2.56</tt> be converted from <tt>double</tt> to <tt>int</tt>. When we consider only the second parameter, then the function <tt>f(double, double)</tt> is the better match.</p>
<p class="docText">This call is therefore ambiguous: Each viable function is a better match on one of the arguments to the call. The compiler will generate an error. We could force a match by explicitly casting one of our arguments:</p>
<pre>
     f(static_cast&lt;double&gt;(42), 2.56);  // <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">f(double, double)</span>
     f(42, static_cast&lt;int&gt;(2.56));     // <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">f(int, int)</span>
</pre><BR>
<a name="ch07note36"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><td valign="top"><p class="docText"> In practice, arguments should not need casts when calling over-loaded functions: The need for a cast means that the parameter sets are designed poorly.</p></TD></tr></table><BR>
</P></div><br>


<a name="ch07lev2sec30"></a>
<h4 class="docSection2Title">7.8.4. Argument-Type Conversions</h4>
<p class="docText">In order to determine the best match, the compiler ranks the conversions that could be used to convert each argument to the type of its corresponding parameter. Conversions are ranked in descending order as follows:</P>
<a name="ch07sb15"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 7.8.3</h2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa14q1"></a><B>Exercise 7.36:</b></td><td><p class="docText"><a name="idd1e55744"></a><a name="idd1e55749"></a>What is a candidate function? What is a viable function?</P>
</td></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa14q2"></a><b>Exercise 7.37:</b></td><td><p class="docText">Given the declarations for <tt>f</tt>, determine whether the following calls are legal. For each call list the viable functions, if any. If the call is illegal, indicate whether there is no match or why the call is ambiguous. If the call is legal, indicate which function is the best match.</p>
<pre>
     (a) f(2.56, 42);
     (b) f(42);
     (c) f(42, 0);
     (d) f(2.56, 3.14);
</pre><br>
</td></tr></table></p>
</blockquote>
</td></tr></table></p><BR>
<div style="font-weight:bold"><ol class="docList" type="1"><LI><div style="font-weight:normal"><p class="docList">An exact match. The argument and parameter types are the same.</p></div></LI><li><div style="font-weight:normal"><p class="docList">Match through a promotion (<a class="docLink" href="ch05lev1sec12.html#ch05lev2sec26">Section 5.12.2</a>, p. <a class="docLink" href="ch05lev1sec12.html#ch05lev2sec26">180</a>).</p></div></LI><LI><div style="font-weight:normal"><p class="docList">Match through a standard conversion (<a class="docLink" href="ch05lev1sec12.html#ch05lev2sec27">Section 5.12.3</a>, p. <a class="docLink" href="ch05lev1sec12.html#ch05lev2sec27">181</a>).</p></div></li><li><div style="font-weight:normal"><p class="docList">Match through a class-type conversion. (<a class="docLink" href="ch14lev1sec9.html#ch14lev1sec9">Section 14.9</a> (p. <a class="docLink" href="ch14lev1sec9.html#ch14lev1sec9">535</a>) covers these conversions.)</p></div></li></ol></div>
<a name="ch07note37"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><td valign="top"><p class="docText"> Promotions and conversions among the built-in types can yield surprising results in the context of function matching. Fortunately, well-designed systems rarely include functions with parameters as closely related as those in the following examples.</p></td></TR></table><BR>
</p></div><br>
<p class="docText">These examples bear study to cement understanding both of function matching in particular and of the relationships among the built-in types in general.</p>
<a name="ch07lev3sec37"></a>
<h5 class="docSection3Title">Matches Requiring Promotion or Conversion</H5>
<p class="docText">Promotions or conversions are applied when the type of the argument can be promoted or converted to the appropriate parameter type using one of the standard conversions.</p>
<p class="docText">One important point to realize is that the small integral types promote to <tt>int</tt>. Given two functions, one of which takes an <tt>int</tt> and the other a <tt>short</tt>, the <tt>int</tt> version will be a better match for a value of any integral type other than <tt>short</tt>, even though <tt>short</tt> might appear on the surface to be a better match:</p>
<pre>
     void ff(int);
     void ff(short);
     ff('a');    // <span class="docEmphasis">char</span> <span class="docEmphItalicAlt">promotes to</span> <span class="docEmphasis">int</span><span class="docEmphItalicAlt">, so matches</span> <span class="docEmphasis">f(int)</span>
</pre><BR>
<p class="docText">A character literal is type <tt>char</tt>, and <tt>chars</tt> are promoted to <tt>int</tt>. That promoted type matches the type of the parameter of function <tt>ff(int)</tt>. A <tt>char</tt> could also be converted to <tt>short</tt>, but a conversion is a &quot;less good&quot; match than a promotion. And so this call will be resolved as a call to <tt>ff (int)</tt>.</p>
<p class="docText"><a name="idd1e55910"></a><a name="idd1e55915"></a><a name="idd1e55920"></a>A conversion that is done through a promotion is preferred to another standard conversion. So, for example, a <tt>char</tt> is a better match for a function taking an <tt>int</tt> than it is for a function taking a <tt>double</tt>. All other standard conversions are treated as equivalent. The conversion from <tt>char</tt> to <tt>unsigned char</tt>, for example, does not take precedence over the conversion from <tt>char</tt> to <tt>double</tt>. As a concrete example, consider:</p>
<pre>
     extern void manip(long);
     extern void manip(float);
     manip(3.14);  // <span class="docEmphItalicAlt">error: ambiguous call</span>
</pre><BR>
<p class="docText">The literal constant 3.14 is a <tt>double</tt>. That type could be converted to either <tt>long</tt> or <tt>float</tt>. Because there are two possible standard conversions, the call is ambiguous. No one standard conversion is given precedence over another.</p>

<a name="ch07lev3sec38"></a>
<H5 class="docSection3Title">Parameter Matching and Enumerations</h5>
<p class="docText">Recall that an object of <tt>enum</tt> type may be initialized only by another object of that <tt>enum</tt> type or one of its enumerators (<a class="docLink" href="ch02lev1sec7.html#ch02lev1sec7">Section 2.7</a>, p. <a class="docLink" href="ch02lev1sec7.html#ch02lev1sec7">63</a>). An integral object that happens to have the same value as an enumerator cannot be used to call a function expecting an <tt>enum</tt> argument:</p>
<pre>
     enum Tokens {INLINE = 128, VIRTUAL = 129};
     void ff(Tokens);
     void ff(int);
     int main() {
         Tokens curTok = INLINE;
         ff(128);    // <span class="docEmphItalicAlt">exactly matches</span> <span class="docEmphasis">ff(int)</span>
         ff(INLINE); // <span class="docEmphItalicAlt">exactly matches</span> <span class="docEmphasis">ff(Tokens)</span>
         ff(curTok); // <span class="docEmphItalicAlt">exactly matches</span> <span class="docEmphasis">ff(Tokens)</span>
         return 0;
     }
</pre><br>
<p class="docText">The call that passes the literal <tt>128</tt> matches the version of <tt>ff</tt> that takes an <tt>int</tt>.</p>
<p class="docText">Although we cannot pass an integral value to a <tt>enum</tt> parameter, we can pass an <tt>enum</tt> to a parameter of integral type. When we do so, the <tt>enum</tt> value promotes to <tt>int</tt> or to a larger integral type. The actual promotion type depends on the values of the enumerators. If the function is overloaded, the type to which the <tt>enum</tt> promotes determines which function is called:</p>
<pre>
     void newf(unsigned char);
     void newf(int);
     unsigned char uc = 129;
     newf(VIRTUAL); // <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">newf(int)</span>
     newf(uc);      // <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">newf(unsigned char)</span>
</pre><br>
<p class="docText">The <tt>enum Tokens</tt> has only two enumerators, the largest of which has a value of 129. That value can be represented by the type <tt>unsigned char</tt>, and many compilers would store the <tt>enum</tt> as an <tt>unsigned char</tt>. However, the type of <tt>VIRTUAL</tt> is not <tt>unsigned char</tt>. Enumerators and values of an <tt>enum</tt> type, are not promoted to <tt>unsigned char</tt>, even if the values of the enumerators would fit.</p>
<a name="ch07note38"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"><a name="idd1e56099"></a><a name="idd1e56105"></a><a name="idd1e56114"></a><a name="idd1e56123"></a><a name="idd1e56132"></a> When using overloaded functions with <tt>enum</tt> parameters, remember: Two enumeration types may behave quite differently during function overload resolution, depending on the value of their enumeration constants. The enumerators determine the type to which they promote. And that type is machine-dependent.</p></TD></TR></table><br>
</P></div><br>

<a name="ch07lev3sec39"></a>
<h5 class="docSection3Title">Overloading and <tt>const</tt> Parameters</H5>
<a name="ch07note39"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> Whether a parameter is <tt>const</tt> only matters when the parameter is a reference or pointer.</p></TD></tr></table><BR>
</P></div><br>
<p class="docText">We can overload a function based on whether a reference parameter refers to a <tt>const</tt> or non<tt>const</tt> type. Overloading on <tt>const</tt> for a reference parameter is valid because the compiler can use whether the argument is <tt>const</tt> to determine which function to call:</p>
<pre>
     Record lookup(Account&amp;);
     Record lookup(const Account&amp;); // <span class="docEmphItalicAlt">new function</span>
     const Account a(0);
     Account b;
     lookup(a);   // <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">lookup(const Account&amp;)</span>
     lookup(b);   // <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">lookup(Account&amp;)</span>
</pre><br>
<p class="docText">If the parameter is a plain reference, then we may not pass a <tt>const</tt> object for that parameter. If we pass a <tt>const</tt> object, then the only function that is viable is the version that takes a <tt>const</tt> reference.</P>
<p class="docText">When we pass a non<tt>const</tt> object, either function is viable. We can use a non<tt>const</tt> object to initializer either a <tt>const</tt> or non<tt>const</tt> reference. However, initializing a <tt>const</tt> reference to a non<tt>const</tt> object requires a conversion, whereas initializing a non<tt>const</tt> parameter is an exact match.</P>
<p class="docText">Pointer parameters work in a similar way. We may pass the address of a <tt>const</tt> object only to a function that takes a pointer to <tt>const</tt>. We may pass a pointer to a non<tt>const</tt> object to a function taking a pointer to a <tt>const</tt> or non<tt>const</tt> type. If two functions differ only as to whether a pointer parameter points to <tt>const</tt> or non<tt>const</tt>, then the parameter that points to the non<tt>const</tt> type is a better match for a pointer to a non<tt>const</tt> object. Again, the compiler can distinguish: If the argument is <tt>const</tt>, it calls the function that takes a <tt>const*</tt>; otherwise, if the argument is a non<tt>const</tt>, the function taking a plain pointer is called.</p>
<p class="docText">It is worth noting that we cannot overload based on whether the pointer itself is <tt>const</tt>:</p>
<pre>
     f(int *);
     f(int *const); // <span class="docEmphItalicAlt">redeclaration</span>
</pre><br>
<p class="docText">Here the <tt>const</tt> applies to the pointer, not the type to which the pointer points. In both cases the pointer is copied; it makes no difference whether the pointer itself is <tt>const</tt>. As we noted on page <a class="docLink" href="#page_267">267</a>, when a parameter is passed as a copy, we cannot overload based on whether that parameter is <tt>const</tt>.</p>
<a name="ch07sb16"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Exercises Section 7.8.4</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><td align="right" class="docText" width="50"><a name="ch07qa15q1"></a><B>Exercise 7.38:</b></td><td><p class="docText"><a name="idd1e56327"></a><a name="idd1e56332"></a><a name="idd1e56335"></a><a name="idd1e56340"></a><a name="idd1e56345"></a><a name="idd1e56348"></a><a name="idd1e56353"></a><a name="idd1e56358"></a>Given the following declarations,</p>
<pre>
     void manip(int, int);
     double dobj;
</pre><br>
<p class="docText">what is the rank (<a class="docLink" href="#ch07lev2sec30">Section 7.8.4</a>, p. <a class="docLink" href="#ch07lev2sec30">272</a>) of each conversion in the following calls?</p>
<pre>
     (a) manip('a', 'z');    (b) manip(55.4, dobj);
</pre><br>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa15q2"></a><b>Exercise 7.39:</b></td><td><p class="docText">Explain the effect of the second declaration in each one of the following sets of declarations. Indicate which, if any, are illegal.</P>
<pre>
     (a) int calc(int, int);
         int calc(const int&amp;, const int&amp;);

     (b) int calc(char*, char*);
         int calc(const char*, const char*);

     (c) int calc(char*, char*);
         int calc(char* const, char* const);
</pre><BR>
</td></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa15q3"></a><B>Exercise 7.40:</b></TD><td><p class="docText">Is the following function call legal? If not, why is the call in error?</p>
<pre>
     enum Stat { Fail, Pass };
     void test(Stat);
     test(0);
</pre><br>
</td></tr></table></P>
</blockquote>
</td></TR></table></P><br>



<ul></ul></TD></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch07lev1sec7.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch07lev1sec9.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>