<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 9.3.&nbsp; Sequence Container Operations</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch09lev1sec2.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch09lev1sec4.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch09lev1sec3"></a>
<h3 class="docSection1Title">9.3. Sequence Container Operations</h3>
<p class="docText">Each sequential container defines a set of useful typedefs and supports operations that let us</P>
<UL><li><p class="docList">Add elements to the container</P></li><li><p class="docList">Delete elements from the container</P></LI><li><p class="docList">Determine the size of the container</p></li><li><p class="docList">Fetch the first and last elements from the container, if any</p></LI></ul>
<a name="ch09lev2sec6"></a>
<H4 class="docSection2Title">9.3.1. Container Typedefs</H4>
<p class="docText">We've used three of the container-defined types: <tt>size_type, iterator</tt>, and <tt>const_iterator</tt>. Each container defines these types, along with several others shown in <a class="docLink" href="#ch09table05">Table 9.5</a>.</p>
<a name="ch09table05"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 9.5. Container-Defined Typedefs</H5></caption><colgroup><col width="200"><col width="300"></colgroup><thead></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>size_type</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Unsigned integral type large enough to hold size of largest possible container of this container type</P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>iterator</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Type of the iterator for this container type</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>const_iterator</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Type of the iterator that can read but not write the elements</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>reverse_iterator</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Iterator that addresses elements in reverse order</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>const_reverse_iterator</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Reverse iterator that can read but not write the elements</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>difference_type</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Signed integral type large enough to hold the difference, which might be negative, between two iterators</p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>value_type</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Element type</P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>reference</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Element's lvalue type; synonym for <tt>value_type&amp;</tt></P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>const_reference</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Element's const lvalue type; same as <tt>const value_type&amp;</tt></p></td></tr></table></p><br>
<p class="docText"><a name="idd1e65413"></a><a name="idd1e65420"></a><a name="idd1e65426"></a><a name="idd1e65430"></a><a name="idd1e65436"></a><a name="idd1e65442"></a><a name="idd1e65448"></a><a name="idd1e65454"></a><a name="idd1e65460"></a><a name="idd1e65466"></a><a name="idd1e65473"></a><a name="idd1e65480"></a><a name="idd1e65487"></a><a name="idd1e65494"></a><a name="idd1e65501"></a><a name="idd1e65508"></a><a name="idd1e65515"></a><a name="idd1e65521"></a><a name="idd1e65528"></a><a name="idd1e65535"></a><a name="idd1e65542"></a><a name="idd1e65549"></a><a name="idd1e65556"></a><a name="idd1e65563"></a><a name="idd1e65570"></a><a name="idd1e65583"></a><a name="idd1e65588"></a><a name="idd1e65592"></a><a name="idd1e65601"></a><a name="idd1e65606"></a><a name="idd1e65614"></a><a name="idd1e65620"></a><a name="idd1e65626"></a><a name="idd1e65633"></a><a name="idd1e65640"></a><a name="idd1e65647"></a><a name="idd1e65654"></a><a name="idd1e65661"></a><a name="idd1e65668"></a>We'll have more to say about reverse iterators in <a class="docLink" href="ch11lev1sec3.html#ch11lev2sec9">Section 11.3.3</a> (p. <a class="docLink" href="ch11lev1sec3.html#ch11lev2sec9">412</a>), but briefly, a reverse iterator is an iterator that goes backward through a container and inverts the iterator operations: For example, saying <tt>++</tt> on a reverse iterator yields the previous element in the container.</p>
<p class="docText">The last three types in <a class="docLink" href="#ch09table05">Table 9.5</a> on the facing page let us use the type of the elements stored in a container without directly knowing what that type is. If we need the element type, we refer to the container's <tt>value_type</tt>. If we need a reference to that type, we use <tt>reference</tt> or <tt>const_reference</tt>. The utility of these element-related typedefs will be more apparent when we define our own generic programs in <a class="docLink" href="ch16.html#ch16">Chapter 16</a>.</P>
<p class="docText">Expressions that use a container-defined type can look intimidating:</P>
<pre>
     // <span class="docEmphasis">iter</span> <span class="docEmphItalicAlt">is the</span> <span class="docEmphasis">iterator</span> <span class="docEmphItalicAlt">type defined by</span> <span class="docEmphasis">list&lt;string&gt;</span>
     list&lt;string&gt;::iterator iter;

     // <span class="docEmphasis">cnt</span> <span class="docEmphItalicAlt">is the</span> <span class="docEmphasis">difference_type</span> <span class="docEmphItalicAlt">type defined by</span> <span class="docEmphasis">vector&lt;int&gt;</span>
     vector&lt;int&gt;::difference_type cnt;
</pre><br>
<p class="docText">The declaration of <tt>iter</tt> uses the scope operator to say that we want the name on the right-hand side of the <tt>::</tt> from the scope of the left-hand side. The effect is to declare that <tt>iter</tt> has whatever type is defined for the <span class="docEmphRoman"><a name="ch09term7"></a><a class="docLink" href="ch09lev1sec9.html#gloss09_07"><span class="docEmphRoman"><tt>iterator</tt></span></a></span> member from the <span class="docEmphRoman"><a name="ch09term10"></a><a class="docLink" href="ch09lev1sec9.html#gloss09_10"><span class="docEmphRoman"><tt>list</tt></span></a></span> class that holds elements of type <tt>string</tt>.</P>
<a name="ch09sb06"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<H2 class="docSidebarTitle">Exercises Section 9.3.1</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa5q1"></a><b>Exercise 9.16:</b></TD><td><p class="docText">What type should be used as the index into a <tt>vector</tt> of <tt>int</tt>s?</P>
</TD></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa5q2"></a><B>Exercise 9.17:</b></TD><td><p class="docText">What type should be used to read the elments in a <tt>list</tt> of <tt>string</tt>s?</p>
</td></tr></table></P>
</blockquote>
</td></tr></table></P><br>

<a name="ch09lev2sec7"></a>
<h4 class="docSection2Title">9.3.2. <tt>begin</tt> and <tt>end</tt> Members</H4>
<p class="docText">The <span class="docEmphRoman"><a name="ch09term2"></a><a class="docLink" href="ch09lev1sec9.html#gloss09_02"><span class="docEmphRoman"><tt>begin</tt></span></a></span> and <tt>end</tt> operations yield iterators that refer to the first and one past the last element in the container. These iterators are most often used to form an iterator range that encompasses all the elements in the container.</p>
<a name="ch09table06"></a><P><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 9.6. Container <tt>begin</tt> and <tt>end</tt> Operations</h5></caption><colgroup><col width="200"><col width="300"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.begin()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Yields an iterator referring to the first element in <tt>c</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.end()</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Yields an iterator referring to the one past the last element in <tt>c</tt></p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.rbegin()</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Yields a reverse iterator referring to the last element in <tt>c</tt></p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.rend()</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Yields a reverse iterator referring one past (i.e., before) the first element in <tt>c</tt></p></td></TR></table></P><br>
<p class="docText">There are two different versions of each of these operations: One is a <tt>const</tt> member (<a class="docLink" href="ch07lev1sec7.html#ch07lev2sec22">Section 7.7.1</a>, p. <a class="docLink" href="ch07lev1sec7.html#ch07lev2sec22">260</a>) and the other is non<tt>const</tt>. The return type of these operations varies on whether the container is <tt>const</tt>. In each case, if the container <a name="idd1e65933"></a><a name="idd1e65938"></a><a name="idd1e65945"></a><a name="idd1e65952"></a><a name="idd1e65959"></a><a name="idd1e65966"></a><a name="idd1e65973"></a><a name="idd1e65979"></a><a name="idd1e65985"></a><a name="idd1e65991"></a>is non<tt>const</tt>, then the result's type is <tt>iterator</tt> or <tt>reverse_iterator</tt>. If the object is <tt>const</tt>, then the type is prefixed by <tt>const_</tt>, that is, <tt>const_iterator</tt> or <tt>const_reverse_iterator</tt>. We cover reverse iterators in <a class="docLink" href="ch11lev1sec3.html#ch11lev2sec9">Section 11.3.3</a> (p. <a class="docLink" href="ch11lev1sec3.html#ch11lev2sec9">412</a>).</p>

<a name="ch09lev2sec8"></a>
<h4 class="docSection2Title">9.3.3. Adding Elements to a Sequential Container</h4>
<p class="docText">In <a class="docLink" href="ch03lev1sec3.html#ch03lev2sec7">Section 3.3.2</a> (p. <a class="docLink" href="ch03lev1sec3.html#ch03lev2sec7">94</a>) we saw one way to add elements: <tt>push_back</tt>. Every sequential container supports <tt>push_back</tt>, which appends an element to the back of the container. The following loop reads one <tt>string</tt> at a time into <tt>text_word:</tt></P>
<pre>
     // <span class="docEmphItalicAlt">read from standard input putting each word onto the end of container</span>
     string text_word;
     while (cin &gt;&gt; text_word)
         container.push_back(text_word);
</pre><br>
<p class="docText">The call to <tt>push_back</tt> creates a new element at the end of <span class="docEmphRoman"><a name="ch09term3"></a><a class="docLink" href="ch09lev1sec9.html#gloss09_03"><span class="docEmphRoman"><tt>container</tt></span></a></span>, increasing the <tt>size</tt> of <tt>container</tt> by one. The value of that element is a copy of <tt>text_word</tt>. The type of <tt>container</tt> can be any of <tt>list, vector</tt>, or <tt>deque</tt>.</p>
<p class="docText">In addition to <tt>push_back</tt>, the <tt>list</tt> and <tt>deque</tt> containers support an analogous operation named <tt>push_front</tt>. This operation inserts a new element at the front of the container. For example,</P>
<pre>
     list&lt;int&gt; ilist;
     // <span class="docEmphItalicAlt">add elements at the end of</span> <span class="docEmphasis">ilist</span>
     for (size_t ix = 0; ix != 4; ++ix)
         ilist.push_back(ix);
</pre><br>
<p class="docText">uses <tt>push_back</tt> to add the sequence <tt>0, 1, 2, 3</tt> to the end of <tt>ilist</tt>.</p>
<p class="docText">Alternatively, we could use <tt>push_front</tt></P>
<pre>
     // <span class="docEmphItalicAlt">add elements to the start of</span> <span class="docEmphasis">ilist</span>
     for (size_t ix = 0; ix != 4; ++ix)
         ilist.push_front(ix);
</pre><br>
<p class="docText">to add the elements <tt>0, 1, 2, 3</tt> to the beginning of <tt>ilist</tt>. Because each element is inserted at the new beginning of the <tt>list</tt>, they wind up in reverse order. After executing both loops, <tt>ilist</tt> holds the sequence <tt>3,2,1,0,0,1,2,3</tt>.</P>
<a name="ch09sb07"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Key Concept: Container Elements Are Copies</h2>
<p class="docText"><span class="docEmphStrong">When we add an element to a container, we do so by copying the element value into the container. Similarly, when we initialize a container by providing a range of elements, the new container contains copies of the original range of elements. There is no relationship between the element in the container and the value from which it was copied. Subsequent changes to the element in the container have no effect on the value that was copied, and vice versa.</span></p>
</td></tr></table></p><br>
<a name="ch09table07"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 9.7. Operations that Add Elements to a Sequential Container</h5></caption><colgroup><col width="150"><col width="350"></colgroup><thead></thead><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.push_back(t)</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Adds element with value <tt>t</tt> to the end of <tt>c</tt>. Returns <tt>void</tt>.</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.push_front(t)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Adds element with value <tt>t</tt> to front of <tt>c</tt>. Returns <tt>void</tt>.</P>
<p class="docText"><span class="docEmphStrong">Valid only for <tt>list</tt> or <tt>deque</tt></span>.</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.insert(p,t)</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Inserts element with value <tt>t</tt> before the element referred to by iterator <tt>p</tt>. Returns an iterator referring to the element that was added.</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.insert(p,n,t)</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Inserts <tt>n</tt> elements with value <tt>t</tt> before the element referred to by iterator <tt>p</tt>. Returns <tt>void</tt>.</p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.insert(p,b,e)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Inserts elements in the range denoted by iterators <tt>b</tt> and <tt>e</tt> before the element referred to by iterator <tt>p</tt>. Returns <tt>void</tt>.</p></td></tr></table></p><br>
<a name="ch09lev3sec7"></a>
<h5 class="docSection3Title">Adding Elements at a Specified Point in the Container</h5>
<p class="docText"><a name="idd1e66317"></a><a name="idd1e66323"></a><a name="idd1e66330"></a><a name="idd1e66336"></a><a name="idd1e66343"></a><a name="idd1e66349"></a>The <tt>push_back</tt> and <tt>push_front</tt> operations provide convenient ways to insert a single element at the end or beginning of a sequential container. More generally, <tt>insert</tt> allows us to insert elements at any particular point in the container. There are three versions of <tt>insert</tt>. The first takes an iterator and an element value. The iterator refers to the position at which to insert the value. We could use this version of <tt>insert</tt> to insert an element at the beginning of a container:</p>
<pre>
     vector&lt;string&gt; svec;
     list&lt;string&gt; slist;
     string spouse("Beth");

     // <span class="docEmphItalicAlt">equivalent to calling</span> <span class="docEmphasis">slist.push_front (spouse);</span>
     slist.insert(slist.begin(), spouse);

     // <span class="docEmphItalicAlt">no</span> <span class="docEmphasis">push_front</span> <span class="docEmphItalicAlt">on</span> <span class="docEmphasis">vector</span> <span class="docEmphItalicAlt">but we can</span> <span class="docEmphasis">insert</span> <span class="docEmphItalicAlt">before</span> <span class="docEmphasis">begin()</span>
     // <span class="docEmphasis">warning: inserting anywhere but at the end of a</span> <span class="docEmphasis">vector</span> <span class="docEmphItalicAlt">is an expensive operation</span>
     svec.insert(svec.begin(), spouse);
</pre><br>
<p class="docText">The value is inserted <span class="docEmphasis">before</span> the position referred to by the iterator. The iterator can refer to any position in the container, including one past the end of the container. Because the iterator might refer to a nonexistent element off the end of the container, <tt>insert</tt> inserts before the position rather than after it. This code</p>
<pre>
     slist.insert(iter, spouse); // <span class="docEmphItalicAlt">insert</span> <span class="docEmphasis">spouse</span> <span class="docEmphItalicAlt">just before</span> <span class="docEmphasis">iter</span>
</pre><BR>
<p class="docText">inserts a copy of <tt>spouse</tt> just before the element referred to by <tt>iter</tt>.</P>
<p class="docText">This version of <tt>insert</tt> returns an iterator referring to the newly inserted element. We could use the return value to repeatedly insert elements at a specified position in the container:</p>
<pre>
     list&lt;string&gt; lst;
     list&lt;string&gt;::iterator iter = lst.begin();
     while (cin &gt;&gt; word)
        iter = lst.insert(iter, word); // <span class="docEmphItalicAlt">same as calling</span> <span class="docEmphasis">push_front</span>
</pre><BR>
<a name="ch09note09"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><td valign="top"><p class="docText"><a name="idd1e66475"></a><a name="idd1e66484"></a><a name="idd1e66490"></a><a name="idd1e66496"></a> It is important to understand thoroughly how this loop operatesin particular to understand why we say that the loop is equivalent to calling <tt>push_front</tt>.</p></td></tr></table><br>
</P></div><br>
<p class="docText">Before the loop, we initialize <tt>iter</tt> to <tt>lst.begin()</tt>. Because the <tt>list</tt> is empty, <tt>lst.begin()</tt> and <tt>lst.end()</tt> are equal, so <tt>iter</tt> refers one past the end of the (empty) <tt>list</tt>. The first call to <tt>insert</tt> puts the element we just read in front of the element referred to by <tt>iter</tt>. The value returned by <tt>insert</tt> is an iterator referring to this new element, which is now the first, and only, element in <tt>lst</tt>. We assign that iterator to <tt>iter</tt> and repeat the <tt>while</tt>, reading another word. As long as there are words to insert, each trip through the <tt>while</tt> inserts a new element ahead of <tt>iter</tt> and reassigns to <tt>iter</tt> the value of the newly inserted element. That element is always the first element, so each iteration inserts an element ahead of the first element in the <tt>list</tt>.</P>

<a name="ch09lev3sec8"></a>
<H5 class="docSection3Title">Inserting a Range of Elements</h5>
<p class="docText">A second form of <tt>insert</tt> adds a specified number of identical elements at an indicated position:</p>
<pre>
     svec.insert(svec.end(), 10, "Anna");
</pre><br>
<p class="docText">This code inserts ten elements at the end of <tt>svec</tt> and initializes each of those elements to the <tt>string "Anna"</tt>.</P>
<p class="docText">The final form of <tt>insert</tt> adds a range of elements denoted by an iterator pair into the container. For example, given the following array of <tt>string</tt>s</P>
<pre>
     string sarray[4] = {"quasi", "simba", "frollo", "scar"};
</pre><br>
<p class="docText">we can insert all or a subset of the array elements into our <tt>list</tt> of <tt>string</tt>s:</p>
<pre>
     // <span class="docEmphItalicAlt">insert all the elements in</span> <span class="docEmphasis">sarray</span> <span class="docEmphItalicAlt">at end of</span> <span class="docEmphasis">slist</span>
     slist.insert(slist.end(), sarray, sarray+4);
     list&lt;string&gt;::iterator slist_iter = slist.begin();
     // <span class="docEmphItalicAlt">insert last two elements of</span> <span class="docEmphasis">sarray</span> <span class="docEmphItalicAlt">before</span> <span class="docEmphasis">slist_iter</span>
     slist.insert(slist_iter, sarray+2, sarray+4);
</pre><br>

<a name="ch09lev3sec9"></a>
<h5 class="docSection3Title">Inserting Elements Can Invalidate Iterators</H5>
<p class="docText">As we'll see in <a class="docLink" href="ch09lev1sec4.html#ch09lev1sec4">Section 9.4</a> (p. <a class="docLink" href="ch09lev1sec4.html#ch09lev1sec4">330</a>), adding elements to a <tt>vector</tt> can cause the entire container to be relocated. If the container is relocated, then all iterators into the container are invalidated. Even if the <tt>vector</tt> does not have to be relocated, any iterator to an element after the one inserted is invalidated.</p>
<a name="ch09note10"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><TD valign="top"><p class="docText"> Iterators may be invalidated after doing any <tt>insert</tt> or <tt>push</tt> operation on a <tt>vector</tt> or <tt>deque</tt>. When writing loops that <tt>insert</tt> elements into a <tt>vector</tt> or a <tt>deque</tt>, the program must ensure that the iterator is refreshed on each trip through the loop.</p></TD></tr></table><br>
</p></div><br>

<a name="ch09lev3sec10"></a>
<h5 class="docSection3Title">Avoid Storing the Iterator Returned from <tt>end</tt></h5>
<p class="docText"><a name="idd1e66710"></a><a name="idd1e66715"></a><a name="idd1e66724"></a><a name="idd1e66733"></a><a name="idd1e66739"></a><a name="idd1e66747"></a><a name="idd1e66755"></a><a name="idd1e66763"></a><a name="idd1e66769"></a><a name="idd1e66774"></a><a name="idd1e66779"></a><a name="idd1e66788"></a>When we add elements to a <tt>vector</tt> or <tt>deque</tt>, some or all of the iterators may be invalidated. It is safest to assume that all iterators are invalid. This advice is particularly true for the iterator returned by <tt>end</tt>. That iterator is <span class="docEmphasis">always</span> invalidated by any insertion anywhere in the container.</p>
<p class="docText">As an example, consider a loop that reads each element, processes it and adds a new element following the original. We want the loop to process each original element. We'll use the form of <tt>insert</tt> that takes a single value and returns an iterator to the element that was just inserted. After each insertion, we'll increment the iterator that is returned so that the loop is positioned to operate on the next original element. If we attempt to &quot;optimize&quot; the loop, by storing an iterator to the <tt>end()</tt>, we'll have a disaster:</p>
<pre>
     vector&lt;int&gt;::iterator first = v.begin(),
                           last = v.end(); // <span class="docEmphItalicAlt">cache end iterator</span>
     // <span class="docEmphItalicAlt">diaster: behavior of this loop is undefined</span>
     while (first != last) {
         // <span class="docEmphItalicAlt">do some processing</span>
         // <span class="docEmphItalicAlt">insert new value and reassign</span> <span class="docEmphasis">first</span>, <span class="docEmphItalicAlt">which otherwise would be invalid</span>
         first = v.insert(first, 42);
         ++first;  // <span class="docEmphItalicAlt">advance</span> <span class="docEmphasis">first</span> <span class="docEmphItalicAlt">just past the element we added</span>
      }
</pre><br>
<p class="docText">The behavior of this code is undefined. On many implementations, we'll get an infinite loop. The problem is that we stored the value returned by the <tt>end</tt> operation in a local variable named <tt>last</tt>. In the body of the loop, we add an element. Adding an element invalidates the iterator stored in <tt>last</tt>. That iterator neither refers to an element in <tt>v</tt> nor any longer refers to one past the last element in <tt>v</tt>.</p>
<a name="ch09note11"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="84" height="51" SRC="images/0201721481/graphics/tip.jpg;400478"></TD><TD valign="top"><p class="docText"> Don't cache the iterator returned from <tt>end</tt>. Inserting or deleting elements in a <tt>deque</tt> or <tt>vector</tt> will invalidate the cached iterator.</p></TD></tr></table><br>
</P></div><BR>
<p class="docText">Rather than storing the <tt>end</tt> iterator, we must recompute it after each insertion:</p>
<pre>
     // <span class="docEmphItalicAlt">safer: recalculate</span> <span class="docEmphasis">end</span> <span class="docEmphItalicAlt">on each trip whenever the loop adds/erases elements</span>
     while (first != v.end()) {
         // <span class="docEmphItalicAlt">do some processing</span>
         first = v.insert(first, 42); // <span class="docEmphItalicAlt">insert new value</span>
         ++first; // <span class="docEmphItalicAlt">advance</span> <span class="docEmphasis">first</span> <span class="docEmphItalicAlt">just past the element we added</span>
     }
</pre><br>


<a name="ch09lev2sec9"></a>
<h4 class="docSection2Title">9.3.4. Relational Operators</h4>
<p class="docText">Each container supports the relational operators (<a class="docLink" href="ch05lev1sec2.html#ch05lev1sec2">Section 5.2</a>, p. <a class="docLink" href="ch05lev1sec2.html#ch05lev1sec2">152</a>) that can be used to compare two containers. The containers must be the same kind of container and must hold elements of the same type. We can compare a <tt>vector&lt;int&gt;</tt> only with another <tt>vector&lt;int&gt;</tt>. We cannot compare a <tt>vector&lt;int&gt;</tt> with a <tt>list&lt;int&gt;</tt> or a <tt>vector&lt;double&gt;</tt>.</p>
<a name="ch09sb08"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<H2 class="docSidebarTitle">Exercises Section 9.3.3</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch09qa6q1"></a><B>Exercise 9.18:</b></td><td><p class="docText"><a name="idd1e66969"></a><a name="idd1e66976"></a><a name="idd1e66983"></a><a name="idd1e66991"></a><a name="idd1e66999"></a><a name="idd1e67007"></a>Write a program to copy elements from a <tt>list</tt> of <tt>int</tt>s into two <tt>deque</tt>s. The <tt>list</tt> elements that are even should go into one <tt>deque</tt> and those that are odd into the second.</p>
</td></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa6q2"></a><B>Exercise 9.19:</b></td><td><p class="docText">Assuming <tt>iv</tt> is a <tt>vector</tt> of <tt>int</tt>s, what is wrong with the following program? How might you correct the problem(s)?</P>
<pre>
     vector&lt;int&gt;::iterator mid = iv.begin() + iv.size()/2;
     while (vector&lt;int&gt;::iterator iter != mid)
         if (iter == some_val)
             iv.insert(iter, 2 * some_val);
</pre><br>
</TD></tr></table></p>
</blockquote>
</td></tr></table></p><br>
<p class="docText">Comparing two containers is based on a pairwise comparison of the elements of the containers. The comparison uses the same relational operator as defined by the element type: Comparing two containers using <tt>!=</tt> uses the <tt>!=</tt> operator for the element type. If the element type doesn't support the operator, then the containers cannot be compared using that operator.</p>
<p class="docText">These operators work similarly to the <tt>string</tt> relationals (<a class="docLink" href="ch03lev1sec2.html#ch03lev2sec4">Section 3.2.3</a>, p. <a class="docLink" href="ch03lev1sec2.html#ch03lev2sec4">85</a>):</p>
<ul><li><p class="docList">If both containers are the same size and all the elements are equal, then the two containers are equal; otherwise, they are unequal.</p></li><li><p class="docList">If the containers have different sizes but every element of the shorter one is equal to the corresponding element of the longer one, then the shorter one is considered to be less than the other.</P></LI><li><p class="docList">If neither container is an initial subsequence of the other, then the comparison depends on comparing the first unequal elements.</P></li></ul>
<p class="docText">The easiest way to understand these operators is by studying examples:</P>
<pre>
     /*
                  ivec1: 1 3 5 7 9 12
                  ivec2: 0 2 4 6 8 10 12
                  ivec3: 1 3 9
                  ivec4: 1 3 5 7
                  ivec5: 1 3 5 7 9 12
     */
     // <span class="docEmphasis">ivec1</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">ivec2</span> <span class="docEmphItalicAlt">differ at</span> <span class="docEmphasis">element[0]: ivec1</span> <span class="docEmphItalicAlt">greater than</span> <span class="docEmphasis">ivec2</span>
     ivec1 &lt; ivec2 // <span class="docEmphasis">false</span>
     ivec2 &lt; ivec1 // <span class="docEmphasis">true</span>

     // <span class="docEmphasis">ivec1</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">ivec3</span> <span class="docEmphItalicAlt">differ at</span> <span class="docEmphasis">element[2]: ivec1</span> <span class="docEmphItalicAlt">less than</span> <span class="docEmphasis">ivec3</span>
     ivec1 &lt; ivec3 // <span class="docEmphasis">true</span>

     // <span class="docEmphItalicAlt">all elements equal, but</span> <span class="docEmphasis">ivec4</span> <span class="docEmphItalicAlt">has fewer elements, so</span> <span class="docEmphasis">ivec1</span> <span class="docEmphItalicAlt">is greater than</span> <span class="docEmphasis">ivec4</span>
     ivec1 &lt; ivec4 // <span class="docEmphasis">false</span>

     ivec1 == ivec5 // <span class="docEmphasis">true;</span> <span class="docEmphItalicAlt">each element equal and same number of elements</span>
     ivec1 == ivec4 // <span class="docEmphasis">false; ivec4</span> <span class="docEmphItalicAlt">has fewer elements than</span> <span class="docEmphasis">ivec1</span>
     ivec1 != ivec4 // <span class="docEmphasis">true; ivec4</span> <span class="docEmphItalicAlt">has fewer elements than</span> <span class="docEmphasis">ivec1</span>
</pre><BR>
<a name="ch09lev3sec11"></a>
<h5 class="docSection3Title">Relational Operators Use Their Element's Relational Operator</h5>
<a name="ch09note12"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><td valign="top"><p class="docText"><a name="idd1e67215"></a><a name="idd1e67220"></a><a name="idd1e67225"></a><a name="idd1e67231"></a><a name="idd1e67237"></a><a name="idd1e67243"></a><a name="idd1e67250"></a><a name="idd1e67257"></a><a name="idd1e67264"></a><a name="idd1e67270"></a><a name="idd1e67276"></a><a name="idd1e67283"></a><a name="idd1e67290"></a><a name="idd1e67297"></a><a name="idd1e67302"></a><a name="idd1e67307"></a><a name="idd1e67313"></a><a name="idd1e67319"></a><a name="idd1e67325"></a><a name="idd1e67331"></a><a name="idd1e67337"></a><a name="idd1e67344"></a><a name="idd1e67351"></a> We can compare two containers only if the same relational operator defined for the element types.</P></TD></tr></table><br>
</p></div><BR>
<p class="docText">Each container relational operator executes by comparing pairs of elements from the two containers:</P>
<pre>
     ivec1 &lt; ivec2
</pre><br>
<p class="docText">Assuming <tt>ivec1</tt> and <tt>ivec2</tt> are <tt>vector&lt;int&gt;</tt>, then this comparison uses the built-in <tt>int</tt> less-than operator. If the <tt>vector</tt>s held <tt>strings</tt>, then the <tt>string</tt> less-than operator would be used.</p>
<p class="docText">If the <tt>vector</tt>s held objects of the <tt>Sales_item</tt> type that we used in <a class="docLink" href="ch01lev1sec5.html#ch01lev1sec5">Section 1.5</a> (p. <a class="docLink" href="ch01lev1sec5.html#ch01lev1sec5">20</a>), then the comparison would be illegal. We did not define the relational operators for <tt>Sales_item</tt>. If we have two containers of <tt>Sales_items</tt>, we could not compare them:</p>
<pre>
     vector&lt;Sales_item&gt; storeA;
     vector&lt;Sales_item&gt; storeB;

     if (storeA &lt; storeB) // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">Sales_item</span> <span class="docEmphItalicAlt">has no less-than operator</span>
</pre><br>
<a name="ch09sb09"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Exercises Section 9.3.4</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><td align="right" class="docText" width="50"><a name="ch09qa7q3"></a><B>Exercise 9.20:</b></td><td><p class="docText">Write a program to compare whether a <tt>vector&lt;int&gt;</tt> contains the same elements as a <tt>list&lt;int&gt;</tt>.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa7q4"></a><b>Exercise 9.21:</b></td><td><p class="docText">Assuming <tt>c1</tt> and <tt>c2</tt> are containers, what constraints does the following usage place on the element types in <tt>c1</tt> and <tt>c2</tt>?</p>
<pre>
     if (c1 &lt; c2)
</pre><br>
<p class="docText">What, if any, constraints are there on <tt>c1</tt> and <tt>c2</tt>?</p>
</TD></TR></table></p>
</blockquote>
</TD></tr></table></p><BR>


<a name="ch09lev2sec10"></a>
<H4 class="docSection2Title">9.3.5. Container Size Operations</h4>
<p class="docText">Each container type supports four size-related operations. We used <tt>size</tt> and <tt>empty</tt> in <a class="docLink" href="ch03lev1sec2.html#ch03lev2sec4">Section 3.2.3</a> (p. <a class="docLink" href="ch03lev1sec2.html#ch03lev2sec4">83</a>): <tt>size</tt> returns the number of elements in the container; <tt>empty</tt> returns a <tt>bool</tt> that is <tt>true</tt> if <tt>size</tt> is zero and <tt>false</tt> otherwise.</p>
<p class="docText">The <tt>resize</tt> operation changes the number of elements in the container. If the current size is greater than the new size, then elements are deleted from the back of the container. If the current size is less than the new size, then elements are added to the back of the container:</p>
<pre>
     list&lt;int&gt; ilist(10, 42);   // <span class="docEmphItalicAlt">10</span> <span class="docEmphasis">ints:</span> <span class="docEmphItalicAlt">each has value</span> <span class="docEmphasis">42</span>

     ilist.resize(15);          // <span class="docEmphItalicAlt">adds 5 elements of value</span> <span class="docEmphasis">0</span> <span class="docEmphItalicAlt">to back of</span> <span class="docEmphasis">ilist</span>

     ilist.resize(25, -1);      // <span class="docEmphItalicAlt">adds 10 elements of value</span> <span class="docEmphasis">-1</span> <span class="docEmphItalicAlt">to back of</span> <span class="docEmphasis">ilist</span>

     ilist.resize(5);           // <span class="docEmphItalicAlt">erases 20 elements from the back of</span> <span class="docEmphasis">ilist</span>
</pre><br>
<p class="docText"><a name="idd1e67595"></a><a name="idd1e67601"></a><a name="idd1e67608"></a><a name="idd1e67615"></a><a name="idd1e67621"></a><a name="idd1e67629"></a><a name="idd1e67636"></a><a name="idd1e67643"></a><a name="idd1e67649"></a><a name="idd1e67655"></a><a name="idd1e67662"></a><a name="idd1e67669"></a>The <tt>resize</tt> operation takes an optional element-value argument. If this argument is present, then any newly added elements receive this value. If this argument is absent, then any new elements are value initialized (<a class="docLink" href="ch03lev1sec3.html#ch03lev2sec6">Section 3.3.1</a>, p. <a class="docLink" href="ch03lev1sec3.html#ch03lev2sec6">92</a>).</P>
<a name="ch09note13"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> <tt>resize</tt> can invalidate iterators. A <tt>resize</tt> operation on a <tt>vector</tt> or <tt>deque</tt> potentially invalidates all iterators.</p></TD></TR></table><br>
<p class="docText">For any container type, if <tt>resize</tt> shrinks the container, then any iterator to an element that is deleted is invalidated.</p>
</p></div><br>
<a name="ch09table08"></a><P><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 9.8. Sequential Container Size Operations</h5></caption><colgroup><col width="150"><col width="350"></colgroup><thead></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.size()</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Returns the number of elements in <tt>c</tt>. Return type is <tt>c::size_type</tt>.</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.max_size()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns maximum number of elements <tt>c</tt> can contain. Return type is <tt>c::size_type</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.empty()</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Returns a <tt>bool</tt> that indicates whether <tt>size</tt> is 0 or not.</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.resize(n)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Resize <tt>c</tt> so that it has <tt>n</tt> elements. If <tt>N &lt; c.size()</tt>, the excess elements are discarded. If new elements must be added, they are value initialized.</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.resize(n,t)</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Resize <tt>c</tt> to have <tt>n</tt> elements. Any elements added have value <tt>t</tt>.</p></td></TR></table></P><br>
<a name="ch09sb10"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Exercises Section 9.3.5</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><td align="right" class="docText" width="50"><a name="ch09qa8q1"></a><b>Exercise 9.22:</b></TD><td><p class="docText">Given that <tt>vec</tt> holds 25 elements, what does <tt>vec.resize(100)</tt> do? What if we next wrote <tt>vec.resize(10)?</tt></P>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa8q2"></a><b>Exercise 9.23:</b></td><td><p class="docText">What, if any, restrictions does using <tt>resize</tt> with a single size argument place on the element types?</p>
</td></tr></table></p>
</blockquote>
</td></tr></table></P><BR>

<a name="ch09lev2sec11"></a>
<h4 class="docSection2Title">9.3.6. Accessing Elements</H4>
<p class="docText">If a container is not empty, then the <tt>front</tt> and <tt>back</tt> members return references bound to the first or last elements in the container:</p>
<pre>
     // <span class="docEmphItalicAlt">check that there are elements before dereferencing an iterator</span>
     // <span class="docEmphItalicAlt">or calling</span> <span class="docEmphasis">front</span> <span class="docEmphItalicAlt">or</span> <span class="docEmphasis">back</span>
     if (!ilist.empty()) {
         // <span class="docEmphasis">val</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">val2</span> <span class="docEmphItalicAlt">refer to the same element</span>
         list&lt;int&gt;::reference val = *ilist.begin();
         list&lt;int&gt;::reference val2 = ilist.front();

         // <span class="docEmphasis">last</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">last2</span> <span class="docEmphItalicAlt">refer to the same element</span>
         list&lt;int&gt;::reference last = *--ilist.end();
         list&lt;int&gt;::reference last2 = ilist.back(); }
</pre><br>
<p class="docText"><a name="idd1e67931"></a><a name="idd1e67939"></a><a name="idd1e67947"></a><a name="idd1e67954"></a><a name="idd1e67961"></a><a name="idd1e67968"></a><a name="idd1e67977"></a><a name="idd1e67991"></a><a name="idd1e68005"></a><a name="idd1e68010"></a><a name="idd1e68019"></a><a name="idd1e68028"></a><a name="idd1e68035"></a>This program uses two different approaches to fetch a reference to the first and last elements in <tt>ilist</tt>. The direct approach is to call <tt>front</tt> or <tt>back</tt>. Indirectly, we can obtain a reference to the same element by dereferencing the iterator returned by <tt>begin</tt> or the element one before the iterator returned by <tt>end</tt>. Two things are noteworthy in this program: The <tt>end</tt> iterator refers &quot;one past the end&quot; of the container so to fetch the last element we must first decrement that iterator. The other important point is that before calling <tt>front</tt> or <tt>back</tt> or dereferencing the iterators from <tt>begin</tt> or <tt>end</tt> we check that <tt>ilist</tt> isn't empty. If the list were empty all of the operations in the <tt>if</tt> would be undefined.</P>
<p class="docText">When we introduced subscripting in <a class="docLink" href="ch03lev1sec3.html#ch03lev2sec7">Section 3.3.2</a> (p. <a class="docLink" href="ch03lev1sec3.html#ch03lev2sec7">94</a>), we noted that the programmer must ensure that an element exists at the indicated subscript location. The subscript operator itself does not check. The same caution applies to using the <tt>front</tt> or <tt>back</tt> operations. If the container is empty, these operations yield an undefined result. If the container has only one element, then <tt>front</tt> and <tt>back</tt> each return a reference to that element.</P>
<a name="ch09note14"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> Using a subscript that is out-of-range or calling <tt>front</tt> or <tt>back</tt> on an empty container are serious programming errors.</P></td></TR></table><BR>
</p></div><br>
<a name="ch09table09"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 9.9. Operations to Access Elements in a Sequential Container</H5></caption><colgroup><col width="150"><col width="350"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.back()</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Returns a reference to the last element in <tt>c</tt>. Undefined if <tt>c</tt> is empty.</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.front()</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Returns a reference to the first element in <tt>c</tt>. Undefined if <tt>c</tt> is empty.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>c[n]</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns a reference to the element indexed by <tt>n</tt>.</p>
<p class="docText">Undefined if <tt>n &lt;0</tt> or <tt>n &gt;= c.size()</tt>.</p>
<p class="docText"><span class="docEmphStrong">Valid only for <tt>vector</tt> and <tt>deque</tt></span>.</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.at(n)</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Returns a reference to the element indexed by <tt>n</tt>. If index is out of range, throws <tt>out_of_range</tt> exception.</p><p class="docText"><span class="docEmphStrong">Valid only for <tt>vector</tt> and <tt>deque</tt></span>.</P></TD></tr></table></p><br>
<p class="docText">An alternative to subscripting is to use the <tt>at</tt> member. This function acts like the subscript operation but if the index is invalid, <tt>at</tt> throws an <tt>out_of_range</tt> exception (<a class="docLink" href="ch06lev1sec13.html#ch06lev1sec13">Section 6.13</a>, p. <a class="docLink" href="ch06lev1sec13.html#ch06lev1sec13">215</a>):</p>
<pre>
     vector&lt;string&gt; svec;     // <span class="docEmphItalicAlt">empty</span> <span class="docEmphasis">vector</span>
     cout &lt;&lt; svec[0];         // <span class="docEmphItalicAlt">run-time error: There are no elements in</span> <span class="docEmphasis">svec!</span>
     cout &lt;&lt; svec.at(0);      // <span class="docEmphItalicAlt">throws</span> <span class="docEmphasis">out_of_range</span> <span class="docEmphItalicAlt">exception</span>
</pre><BR>
<a name="ch09sb11"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<h2 class="docSidebarTitle">Exercises Section 9.3.6</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch09qa9q1"></a><b>Exercise 9.24:</b></td><td><p class="docText">Write a program that fetches the first element in a <tt>vector</tt>. Do so using <tt>at</tt>, the subscript operator, <tt>front</tt>, and <tt>begin</tt>. Test the program on an empty <tt>vector</tt>.</p>
</TD></tr></table></p>
</blockquote>
</TD></tr></table></p><BR>

<a name="ch09lev2sec12"></a>
<h4 class="docSection2Title">9.3.7. Erasing Elements</H4>
<p class="docText"><a name="idd1e68322"></a><a name="idd1e68329"></a><a name="idd1e68338"></a><a name="idd1e68345"></a><a name="idd1e68352"></a><a name="idd1e68358"></a><a name="idd1e68364"></a><a name="idd1e68372"></a><a name="idd1e68379"></a><a name="idd1e68386"></a><a name="idd1e68393"></a><a name="idd1e68398"></a><a name="idd1e68403"></a><a name="idd1e68409"></a><a name="idd1e68415"></a><a name="idd1e68421"></a><a name="idd1e68428"></a><a name="idd1e68437"></a>Recall that there is both a general <tt>insert</tt> operation that inserts anywhere in the container and specific <tt>push_front</tt> and <tt>push_back</tt> operations to add elements only at the front or back. Similarly, there is a general <tt>erase</tt> and specific <tt>pop_front</tt> and <tt>pop_back</tt> operations to remove elements.</p>
<a name="ch09lev3sec12"></a>
<h5 class="docSection3Title">Removing the First or Last Element</h5>
<p class="docText">The <tt>pop_front</tt> and <tt>pop_back</tt> functions remove the first and last elements in the container. There is no <tt>pop_front</tt> operation for <tt>vector</tt>s. These operations remove the indicated element and return <tt>void</tt>.</p>
<p class="docText">One common use of <tt>pop_front</tt> is to use it together with <tt>front</tt> to process a container as a stack:</p>
<pre>
     while (!ilist.empty()) {
         process(ilist.front()); // <span class="docEmphItalicAlt">do something with the current top of</span> <span class="docEmphasis">ilist</span>
         ilist.pop_front();      // <span class="docEmphItalicAlt">done; remove first element</span>
     }
</pre><br>
<p class="docText">This loop is pretty simple: We use <tt>front</tt> to get a value to operate on and then call <tt>pop_front</tt> to remove that element from the <tt>list</tt>.</p>
<a name="ch09note15"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> The <tt>pop_front</tt> and <tt>pop_back</tt> return <tt>void</tt>; they do <span class="docEmphasis">not</span> return the value of the element popped. To examine that value, it is necessary to call <tt>front</tt> or <tt>back</tt> prior to popping the element.</p></TD></TR></table><br>
</P></div><br>
<a name="ch09table10"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 9.10. Operations to Remove Elements from a Sequential Container</H5></caption><colgroup><col width="150"><col width="350"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.erase(p)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Removes element referred to by the iterator <tt>p</tt>.</P>
<p class="docText">Returns an iterator referring to the element after the one deleted, or an off-the-end iterator if <tt>p</tt> referred to the last element. Undefined if <tt>p</tt> is an off-the-end iterator.</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.erase(b,e)</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Removes the range of elements denoted by the iterators <tt>b</tt> and <tt>e</tt>.</p>
<p class="docText">Returns an iterator referring after the last one in the range that was deleted, or an off-the-end iterator if <tt>e</tt> is itself an off-the-end iterator.</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.clear()</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Removes all the elements in <tt>c</tt>. Returns <tt>void</tt>.</p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.pop_back()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Removes the last element in <tt>c</tt>. Returns <tt>void</tt>. Undefined if <tt>c</tt> is empty.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.pop_front()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Removes the first element in <tt>c</tt>. Returns <tt>void</tt>. Undefined if <tt>c</tt> is empty.</p>
<p class="docText"><span class="docEmphStrong">Valid only for <tt>list</tt> or <tt>deque</tt></span>.</P></TD></tr></table></P><br>

<a name="ch09lev3sec13"></a>
<h5 class="docSection3Title">Removing an Element From within the Container</H5>
<p class="docText">The more general way to remove an element, or range of elements, is through <tt>erase</tt>. There are two versions of <tt>erase</tt>: We can delete a single element referred to by an iterator or a range of elements marked by a pair of iterators. Both forms <a name="idd1e68698"></a><a name="idd1e68704"></a><a name="idd1e68710"></a><a name="idd1e68717"></a><a name="idd1e68723"></a><a name="idd1e68730"></a><a name="idd1e68736"></a>of <tt>erase</tt> return an iterator referring to the location after the element or range that was removed. That is, if element <tt>j</tt> is the element immediately after <tt>i</tt> and we <tt>erase</tt> element <tt>i</tt> from the container, then the iterator returned will refer to <tt>j</tt>.</P>
<a name="ch09note16"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> As usual, the <tt>erase</tt> operations don't check their argument(s). It is up to the programmer to ensure that the iterator or iterator range is valid.</P></td></TR></table><BR>
</p></div><br>
<p class="docText">The <tt>erase</tt> operation is often used after finding an element that should be removed from the container. The easiest way to find a given element is to use the library <tt>find</tt> algorithm. We'll see more about <tt>find</tt> in <a class="docLink" href="ch11lev1sec1.html#ch11lev1sec1">Section 11.1</a> (p. <a class="docLink" href="ch11lev1sec1.html#ch11lev1sec1">392</a>). To use <tt>find</tt> or any other generic algorithm, we must include the <tt>algorithm</tt> header. The <tt>find</tt> function takes a pair of iterators that denote a range in which to look, and a value to look for within that range. <tt>find</tt> returns an iterator referring to the first element with that value or the off-the-end iterator:</p>
<pre>
     string searchValue("Quasimodo");
     list&lt;string&gt;::iterator iter =
            find(slist.begin(), slist.end(), searchValue);

     if (iter != slist.end())
          slist.erase(iter);
</pre><BR>
<p class="docText">Note that we check that the iterator is not the <tt>end</tt> iterator before erasing the element. When we ask <tt>erase</tt> to erase a single element, the element must existthe behavior of <tt>erase</tt> is undefined if we ask it to <tt>erase</tt> an off-the-end iterator.</P>

<a name="ch09lev3sec14"></a>
<h5 class="docSection3Title">Removing All the Elements in a Container</h5>
<p class="docText">To delete all the elements in a container, we could either call <tt>clear</tt> or pass the iterators from <tt>begin</tt> and <tt>end</tt> to <tt>erase</tt>:</p>
<pre>
     slist.clear(); // <span class="docEmphItalicAlt">delete all the elements within the container</span>
     slist.erase(slist.begin(), slist.end()); // <span class="docEmphItalicAlt">equivalent</span>
</pre><br>
<p class="docText">The iterator-pair version of <tt>erase</tt> lets us delete a subrange of elements:</P>
<pre>
     // <span class="docEmphItalicAlt">delete range of elements between two values</span>
     list&lt;string&gt;::iterator elem1, elem2;

     // <span class="docEmphasis">elem1</span> <span class="docEmphItalicAlt">refers to</span> <span class="docEmphasis">val1</span>
     elem1 = find(slist.begin(), slist.end(), val1);

     // <span class="docEmphasis">elem2</span> <span class="docEmphItalicAlt">refers to the first occurrence of</span> <span class="docEmphasis">val2</span> <span class="docEmphItalicAlt">after</span> <span class="docEmphasis">val1</span>
     elem2 = find(elem1, slist.end(), val2);

     // <span class="docEmphItalicAlt">erase range from</span> <span class="docEmphasis">val1</span> <span class="docEmphItalicAlt">up to but not including</span> <span class="docEmphasis">val2</span>
     slist.erase(elem1, elem2);
</pre><br>
<p class="docText">This code starts by calling <tt>find</tt> twice to obtain iterators to two elements. The iterator <tt>elem1</tt> refers to the first occurrence of <tt>val1</tt> or to the off-the-end iterator if <tt>val1</tt> is not present in the <tt>list</tt>. The iterator <tt>elem2</tt> refers to the first occurrence of <tt>val2</tt> that appears after <tt>val1</tt> if that element exists, otherwise, <tt>elem2</tt> is an off the-end iterator. The call to <tt>erase</tt> removes the elements starting from the referred to by <tt>elem1</tt> up to but not including <tt>elem2</tt>.</p>
<a name="ch09note17"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></TD><td valign="top"><p class="docText"><a name="idd1e68953"></a><a name="idd1e68960"></a><a name="idd1e68966"></a><a name="idd1e68974"></a><a name="idd1e68982"></a><a name="idd1e68990"></a><a name="idd1e68997"></a><a name="idd1e69006"></a><a name="idd1e69014"></a><a name="idd1e69021"></a><a name="idd1e69030"></a><a name="idd1e69039"></a><a name="idd1e69048"></a><a name="idd1e69057"></a><a name="idd1e69067"></a><a name="idd1e69073"></a><a name="idd1e69081"></a><a name="idd1e69090"></a><a name="idd1e69097"></a> The <tt>erase, pop_front</tt>, and <tt>pop_back</tt> functions invalidate any iterators that refer to the removed elements. For <tt>vector</tt>s, iterators to elements after the erasure point are also invalidated. For <tt>deque</tt>, if the <tt>erase</tt> does not include either the first or last element, all iterators into the <tt>deque</tt> are invalidated.</P></td></tr></table><br>
</p></div><br>
<a name="ch09sb12"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 9.3.7</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa10q1"></a><B>Exercise 9.25:</b></TD><td><p class="docText">What happens in the program that erased a range of elements if <tt>val1</tt> is equal to <tt>val2</tt>. What happens if either <tt>val1</tt> or <tt>val2</tt> or both are not present.</P>
</td></tr><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch09qa10q2"></a><b>Exercise 9.26:</b></td><td><p class="docText">Using the following definition of <tt>ia</tt>, copy <tt>ia</tt> into a <tt>vector</tt> and into a <tt>list</tt>. Use the single iterator form of <tt>erase</tt> to remove the elements with odd values from your <tt>list</tt> and the even values from your <tt>vector</tt>.</p>
<pre>
     int ia[] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 55, 89 };
</pre><br>
</TD></tr><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch09qa10q3"></a><b>Exercise 9.27:</b></td><td><p class="docText">Write a program to process a <tt>list</tt> of <tt>string</tt>s. Look for a particular value and, if found, remove it. Repeat the program using a <tt>deque</tt>.</P>
</TD></tr></table></p>
</blockquote>
</td></tr></table></P><br>


<a name="ch09lev2sec13"></a>
<h4 class="docSection2Title">9.3.8. Assignment and <tt>swap</tt></H4>
<p class="docText">The assignment-related operators act on the entire container. Except for <tt>swap</tt>, they can be expressed in terms of <tt>erase</tt> and <tt>insert</tt> operations. The assignment operator <span class="docEmphasis">erases</span> the entire range of elements in the left-hand container and then <span class="docEmphasis">inserts</span> the elements of the right-hand container object into the left-hand container:</p>
<pre>
     c1 = c2; // <span class="docEmphItalicAlt">replace contents of c1 with a copy of elements in c2</span>
     // <span class="docEmphItalicAlt">equivalent operation using erase and insert</span>
     c1.erase(c1.begin(), c1.end()); // <span class="docEmphItalicAlt">delete all elements in c1</span>
     c1.insert(c1.begin(), c2.begin(), c2.end()); // <span class="docEmphItalicAlt">insert c2</span>
</pre><br>
<p class="docText">After the assignment, the left- and right-hand containers are equal: Even if the containers had been of unequal size, after the assignment both containers have the size of the right-hand operand.</P>
<a name="ch09note18"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> Assignment and the <tt>assign</tt> operations invalidate all iterators into the left-hand container. <tt>swap</tt> does <span class="docEmphasis">not</span> invalidate iterators. After <tt>swap</tt>, iterators continue to refer to the same elements, although those elements are now in a different container.</p></td></tr></table><br>
</p></div><br>
<a name="ch09lev3sec15"></a>
<h5 class="docSection3Title">Using <tt>assign</tt></h5>
<p class="docText">The <tt>assign</tt> operation deletes all the elements in the container and then inserts new elements as specified by the arguments. Like the constructor that copies elements from a container, the assignment operator (<tt>=</tt>) can be used to assign one <a name="idd1e69304"></a><a name="idd1e69310"></a><a name="idd1e69316"></a><a name="idd1e69323"></a><a name="idd1e69330"></a><a name="idd1e69337"></a><a name="idd1e69344"></a><a name="idd1e69351"></a><a name="idd1e69357"></a><a name="idd1e69364"></a><a name="idd1e69368"></a><a name="idd1e69374"></a>container to another only if the container and element type are the same. If we want to assign elements of a different but compatible element type and/or from a different container type, then we must use the <tt>assign</tt> operation. For example, we could use <tt>assign</tt> to assign a range of <tt>char*</tt> values from a <tt>vector</tt> into a <tt>list</tt> of <tt>string</tt>.</p>
<a name="ch09table11"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 9.11. Sequential Container Assignment Operations</H5></caption><colgroup><col width="150"><col width="350"></colgroup><thead></thead><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>c1 = c2</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Deletes elements in <tt>c1</tt> and copies elements from <tt>c2</tt> into <tt>c1</tt>. <tt>c1</tt> and <tt>c2</tt> must be the same type.</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>c1.swap(c2)</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Swaps contents: After the call <tt>c1</tt> has elements that were in <tt>c2</tt>, and <tt>c2</tt> has elements that were in <tt>c1</tt>. <tt>c1</tt> and <tt>c2</tt> must be the same type. Execution time usually <span class="docEmphasis">much</span> faster than copying elements from <tt>c2</tt> to <tt>c1</tt>.</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.assign(b,e)</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Replaces the elements in <tt>c</tt> by those in the range denoted by iterators <tt>b</tt> and <tt>e</tt>. The iterators <tt>b</tt> and <tt>e</tt> must not refer to elements in <tt>c</tt>.</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>c.assign(n,t)</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Replaces the elements in <tt>c</tt> by <tt>n</tt> elements with value <tt>t</tt>.</p></TD></tr></table></P><br>
<a name="ch09note19"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> Because the original elements are deleted, the iterators passed to <tt>assign</tt> must not refer to elements in the container on which <tt>assign</tt> is called.</p></td></tr></table><br>
</p></div><br>
<p class="docText">The arguments to <tt>assign</tt> determine how many elements are inserted and what values the new elements will have. This statement:</p>
<pre>
     // <span class="docEmphItalicAlt">equivalent to slist1 = slist2</span>
     slist1.assign(slist2.begin(), slist2.end());
</pre><BR>
<p class="docText">uses the version of <tt>assign</tt> that takes a pair of iterators. After deleting the elements in <tt>slist1</tt>, the function copies the elements in the range denoted by the iterators into <tt>slist2</tt>. Thus, this code is equivalent to assigning <tt>slist2</tt> to <tt>slist1</tt>.</P>
<a name="ch09note20"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> The <tt>assign</tt> operator that takes an iterator pair lets us assign elements of one container type to another.</P></td></tr></table><br>
</p></div><br>
<p class="docText">A second version of assign takes an integral value and an element value. It replaces the elements in the container by the specified number of elements, each of which has the specified element value</P>
<pre>
     // <span class="docEmphItalicAlt">equivalent to:</span> <span class="docEmphasis">slist1.clear();</span>
     // <span class="docEmphItalicAlt">followed by</span> <span class="docEmphasis">slist1.insert(slist1.begin(), 10, "Hiya!");</span>
     slist1.assign(10, "Hiya!"); // <span class="docEmphItalicAlt">10 elements; each one is</span> <span class="docEmphasis">Hiya!</span>
</pre><br>
<p class="docText">After executing this statement, <tt>slist1</tt> has 10 elements, each of which has the value <tt>Hiya!</tt>.</P>

<a name="ch09lev3sec16"></a>
<H5 class="docSection3Title">Using <tt>swap</tt> to Avoid the Cost of Deleting Elements</h5>
<p class="docText">The <tt>swap</tt> operation swaps the values of its two operands. The types of the containers must match: The operands must be the same kind of container, and they <a name="idd1e69644"></a>must hold values of the same type. After the call to <tt>swap</tt>, the elements that had been in the right-hand operand are in the left, and vice versa:</p>
<pre>
     vector&lt;string&gt; svec1(10); // <span class="docEmphasis">vector</span> <span class="docEmphItalicAlt">with 10 elements</span>
     vector&lt;string&gt; svec2(24); // <span class="docEmphasis">vector</span> <span class="docEmphItalicAlt">with 24 elements</span>
     svec1.swap(svec2);
</pre><br>
<p class="docText">After the <tt>swap, svec1</tt> contains 24 <tt>string</tt> elements and <tt>svec2</tt> contains 10.</P>
<a name="ch09note21"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> The important thing about <tt>swap</tt> is that it does not delete or insert any elements and is guaranteed to run in constant time. No elements are moved, and so iterators are not invalidated.</P></td></tr></table><BR>
</p></div><br>
<p class="docText">The fact that elements are not moved means that iterators are not invalidated. They refer to the same elements as they did before the swap. However, after the <tt>swap</tt>, those elements are in a different container. For example, had <tt>iter</tt> referred to the <tt>string</tt> at position <tt>svec1[3]</tt> before the <tt>swap</tt> it will refer to the element at position <tt>svec2[3]</tt> after the <tt>swap</tt>.</P>
<a name="ch09sb13"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<h2 class="docSidebarTitle">Exercises Section 9.3.8</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa11q1"></a><b>Exercise 9.28:</b></td><td><p class="docText">Write a program to assign the elements from a <tt>list</tt> of <tt>char*</tt> pointers to C-style character strings to a <tt>vector</tt> of <tt>string</tt>s.</p>
</td></tr></table></p>
</blockquote>
</TD></TR></table></p><BR>



<ul></ul></TD></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch09lev1sec2.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch09lev1sec4.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>