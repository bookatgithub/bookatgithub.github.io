<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 9.6.&nbsp; strings Revisited</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch09lev1sec5.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch09lev1sec7.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch09lev1sec6"></a>
<h3 class="docSection1Title">9.6. <tt>string</tt>s Revisited</h3>
<p class="docText">We introduced the <tt>string</tt> type in <a class="docLink" href="ch03lev1sec2.html#ch03lev1sec2">Section 3.2</a> (p. <a class="docLink" href="ch03lev1sec2.html#ch03lev1sec2">80</a>). <a class="docLink" href="#ch09table12">Table 9.12</a> (p. <a class="docLink" href="#ch09table12">337</a>) recaps the <tt>string</tt> operations covered in that section.</P>
<a name="ch09table12"></a><P><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 9.12. <tt>string</tt> Operations Introduced in <a class="docLink" href="ch03lev1sec2.html#ch03lev1sec2">Section 3.2</a></H5></caption><colgroup><col width="150"><col width="350"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>string s;</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Defines a new, empty <tt>string</tt> named <tt>s</tt>.</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>string s(cp);</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Defines a new <tt>string</tt> initialized from the null-terminated C-style string pointed to by <tt>cp</tt>.</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>string s(s2);</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Defines a new <tt>string</tt> initialized as a copy of <tt>s2</tt>.</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>is &gt;&gt; s;</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Reads a whitespace-separated string from the input stream <tt>is</tt> into <tt>s</tt>.</p></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>os &lt;&lt; s;</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Writes <tt>s</tt> to the output stream <tt>os</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>getline(is, s)</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Reads characters up to the first newline from input stream <tt>is</tt> into <tt>s</tt>.</P></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s1 + s2</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Concatenates <tt>s1</tt> and <tt>s2</tt>, yielding a new <tt>string</tt>.</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>s1 += s2</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Appends <tt>s2</tt> to <tt>s1</tt>.</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText">Relational Operators</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">The equality (<tt>==</tt> and <tt>!=</tt>) and relational (<tt>&lt;, &lt;=, &gt;</tt>, and <tt>&gt;=)</tt> can be used to compare <tt>string</tt>s. <tt>string</tt> comparison is equivalent to (case-sensitive) dictionary ordering.</p></TD></tr></table></p><BR>
<p class="docText">In addition to the operations we've already used, <tt>string</tt>s also supports most of the sequential container operations. In some ways, we can think of a <tt>string</tt> as a container of characters. With some exceptions, <tt>string</tt>s support the same operations that <tt>vector</tt>s support: The exceptions are that <tt>string</tt> does not support the operations to use the container like a stack: We cannot use the <tt>front, back</tt>, and <tt>pop_back</tt> operations on <tt>string</tt>s.</p>
<a name="ch09sb15"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<H2 class="docSidebarTitle">Exercises Section 9.5</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa13q1"></a><b>Exercise 9.33:</b></td><td><p class="docText"><a name="idd1e70845"></a><a name="idd1e70852"></a><a name="idd1e70859"></a><a name="idd1e70866"></a>Which is the most appropriatea <tt>vector</tt>, a <tt>deque</tt>, or a <tt>list</tt>for the following program tasks? Explain the rationale for your choice. If there is no reason to prefer one or another container explain why not?</p>
<div style="font-weight:bold"><ol class="docList" type="a"><li><div style="font-weight:normal"><p class="docList">Read an unknown number of words from a file for the purpose of generating English language sentences.</p></div></li><li><div style="font-weight:normal"><p class="docList">Read a fixed number of words, inserting them in the container alphabetically as they are entered. We'll see in the next chapter that associative containers are better suited to this problem.</p></div></LI><LI><div style="font-weight:normal"><p class="docList">Read an unknown number of words. Always insert new words at the back. Remove the next value from the front.</p></div></LI><li><div style="font-weight:normal"><p class="docList">Read an unknown number of integers from a file. Sort the numbers and then print them to standard output.</p></div></LI></ol></div>
</TD></tr></table></p>
</blockquote>
</td></tr></table></p><BR>
<p class="docText">The container operations that <tt>string</tt> supports are:</p>
<UL><LI><p class="docList">The typedefs, including the iterator types, listed in <a class="docLink" href="ch09lev1sec3.html#ch09table05">Table 9.5</a> (p. <a class="docLink" href="ch09lev1sec3.html#ch09table05">316</a>).</p></li><li><p class="docList">The constructors listed in <a class="docLink" href="ch09lev1sec1.html#ch09table02">Table 9.2</a> (p. <a class="docLink" href="ch09lev1sec1.html#ch09table02">307</a>) except for the constructor that takes a single size parameter.</P></LI><li><p class="docList">The operations to add elements listed in <a class="docLink" href="ch09lev1sec3.html#ch09table07">Table 9.7</a> (p. <a class="docLink" href="ch09lev1sec3.html#ch09table07">319</a>) that <tt>vector</tt> supports. Note: Neither <tt>vector</tt> nor <tt>string</tt> supports <tt>push_front</tt>.</p></li><li><p class="docList">The size operations in <a class="docLink" href="ch09lev1sec3.html#ch09table08">Table 9.8</a> (p. <a class="docLink" href="ch09lev1sec3.html#ch09table08">324</a>).</P></li><li><p class="docList">The subscript and <tt>at</tt> operations listed in <a class="docLink" href="ch09lev1sec3.html#ch09table09">Table 9.9</a> (p. <a class="docLink" href="ch09lev1sec3.html#ch09table09">325</a>); <tt>string</tt> does not provide <tt>back</tt> or <tt>front</tt> operations listed in that table.</P></li><li><p class="docList">The <tt>begin</tt> and <tt>end</tt> operations of <a class="docLink" href="ch09lev1sec3.html#ch09table06">Table 9.6</a> (p. <a class="docLink" href="ch09lev1sec3.html#ch09table06">317</a>).</P></li><LI><p class="docList">The <tt>erase</tt> and <tt>clear</tt> operations of <a class="docLink" href="ch09lev1sec3.html#ch09table10">Table 9.10</a> (p. <a class="docLink" href="ch09lev1sec3.html#ch09table10">326</a>); <tt>string</tt> does not support either <tt>pop_back</tt> or <tt>pop_front</tt>.</p></li><li><p class="docList">The assignment operations in <a class="docLink" href="ch09lev1sec3.html#ch09table11">Table 9.11</a> (p. <a class="docLink" href="ch09lev1sec3.html#ch09table11">329</a>).</p></li><li><p class="docList">Like the elements in a <tt>vector</tt>, the characters of a <tt>string</tt> are stored contiguously. Therefore, <tt>string</tt> supports the <tt>capacity</tt> and <tt>reserve</tt> operations described in <a class="docLink" href="ch09lev1sec4.html#ch09lev1sec4">Section 9.4</a> (p. <a class="docLink" href="ch09lev1sec4.html#ch09lev1sec4">330</a>).</p></li></ul>
<p class="docText">When we say that <tt>string</tt> supports the container operations, we mean that we could take a program that manipulates a <tt>vector</tt> and rewrite that same program to operate on <tt>string</tt>s. For example, we could use iterators to print the characters of a <tt>string</tt> a line at a time to the standard output:</p>
<pre>
     string s("Hiya!");
     string::iterator iter = s.begin();
     while (iter != s.end())
         cout &lt;&lt; *iter++ &lt;&lt; endl; // <span class="docEmphItalicAlt">postfix increment: print old value</span>
</pre><br>
<p class="docText">Not surprisingly, this code looks almost identical to the code from page <a class="docLink" href="ch05lev1sec5.html#ch05sb07">163</a> that printed the elements of a <tt>vector&lt;int&gt;</tt>.</p>
<p class="docText">In addition to the operations that <tt>string</tt> shares with the containers, <tt>string</tt> supports other operations that are specific to <tt>string</tt>s. We will review these <tt>string</tt>-specific operations in the remainder of this section. These operations include additional versions of container-related operations as well as other, completely new functions. The additional functions that <tt>string</tt> provides are covered starting on page <a class="docLink" href="#ch09table15">341</a>.</p>
<p class="docText">The additional versions of the container operations that <tt>string</tt> provides are defined to support attributes that are unique to <tt>string</tt>s and not shared by the containers. For example, several operations permit us to specify arguments that are pointers to character arrays. These operations support the close interaction between library <tt>string</tt>s and character arrays, whether null-terminated or not. Other versions let us use indices rather than iterators. These versions operate positionally: We specify a starting position, and in some cases a count, to specify the element or range of elements which we want to manipulate.</P>
<a name="ch09sb16"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Exercises Section 9.6</h2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><td align="right" class="docText" width="50"><a name="ch09qa14q1"></a><b>Exercise 9.34:</b></td><td><p class="docText">Use iterators to change the characters in a <tt>string</tt> to uppercase.</p>
</TD></tr><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch09qa14q2"></a><b>Exercise 9.35:</b></td><td><p class="docText">Use iterators to find and to erase each capital letter from a <tt>string</tt>.</P>
</TD></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa14q3"></a><b>Exercise 9.36:</b></TD><td><p class="docText">Write a program that initializes a <tt>string</tt> from a <tt>vector&lt;char&gt;</tt>.</p>
</TD></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch09qa14q4"></a><b>Exercise 9.37:</b></TD><td><p class="docText">Given that you want to read a character at a time into a <tt>string</tt>, and you know that the data you need to read is at least 100 characters long, how might you improve the performance of your program?</p>
</td></tr></table></p>
</blockquote>
</td></tr></table></p><br>
<a name="ch09note26"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="84" height="51" SRC="images/0201721481/graphics/tip.jpg;400478"></td><TD valign="top"><p class="docText"><a name="idd1e71225"></a> The <tt>string</tt> library defines a great number of functions, which use repeated patterns. Given the number of functions supported, this section can be mind-numbing on first reading.</P></td></TR></table><br>
<p class="docText">Readers might want to skim the remainder of <a class="docLink" href="#ch09lev1sec6">Section 9.6</a>. Once you know what kinds of operations are available, you can return for the details when writing programs that need to use a given operation.</p>
</P></div><BR>
<a name="ch09lev2sec18"></a>
<h4 class="docSection2Title">9.6.1. Other Ways to Construct <tt>string</tt>s</h4>
<p class="docText">The <tt>string</tt> class supports all but one of the constructors in <a class="docLink" href="ch09lev1sec1.html#ch09table02">Table 9.2</a> (p. <a class="docLink" href="ch09lev1sec1.html#ch09table02">307</a>). The constructor that takes a single size parameter is not supported for <tt>string</tt>. We can create a <tt>string</tt>: as the empty <tt>string</tt>, by providing no argument; as a copy of another <tt>string</tt>; from a pair of iterators; or from a count and a character:</p>
<pre>
     string s1;           // <span class="docEmphasis">s1</span> <span class="docEmphItalicAlt">is the empty string</span>
     string s2(5, 'a');   // <span class="docEmphasis">s2 == "aaaaa"</span>
     string s3(s2);       // <span class="docEmphasis">s3</span> <span class="docEmphItalicAlt">is a copy of</span> <span class="docEmphasis">s2</span>
     string s4(s3.begin(),
               s3.begin() + s3.size() / 2); // <span class="docEmphasis">s4 == "aa"</span>
</pre><br>
<p class="docText">In addition to these constructors, the <tt>string</tt> type supports three other ways to create a <tt>string</tt>. We have already used the constructor that takes a pointer to the first character in a null-terminated, character array. There is another constructor that takes a pointer to an element in a character array and a count of how many characters to copy. Because the constructor takes a count, the array does not have to be null-terminated:</p>
<pre>
     char *cp = "Hiya";            // <span class="docEmphItalicAlt">null-terminated array</span>
     char c_array[] = "World!!!!"; // <span class="docEmphItalicAlt">null-terminated</span>
     char no_null[] = {'H', 'i'};  // <span class="docEmphItalicAlt">not null-terminated</span>

     string s1(cp);             // <span class="docEmphasis">s1 == "Hiya"</span>
     string s2(c_array, 5);     // <span class="docEmphasis">s2 == "World"</span>
     string s3(c_array + 5, 4); // <span class="docEmphasis">s3 == "!!!!"</span>
     string s4(no_null);        // <span class="docEmphItalicAlt">runtime error</span>: <span class="docEmphasis">no_null</span> <span class="docEmphItalicAlt">not null-terminated</span>
     string s5(no_null, 2);     // <span class="docEmphItalicAlt">ok</span>: <span class="docEmphasis">s5 == "Hi"</span>
</pre><BR>
<p class="docText">We define <tt>s1</tt> using the constructor that takes a pointer to the first character of a null-terminated array. All the characters in that array, up to but not including the terminating null, are copied into the newly created <tt>string</tt>.</p>
<p class="docText">The initializer for <tt>s2</tt> uses the second constructor, taking a pointer and a count. In this case, we start at the character denoted by the pointer and copy as many characters as indicated in the second argument. <tt>s2</tt>, therefore, is a copy of the first five characters from the array <tt>c_array</tt>. Remember that when we pass an array as an argument, it is automatically converted to a pointer to its first element. Of course, we are not restricted to passing a pointer to the beginning of the array. We initialize <tt>s3</tt> to hold four exclamation points by passing a pointer to the first exclamation point in <tt>c_array</tt>.</P>
<p class="docText">The initializers for <tt>s4</tt> and <tt>s5</tt> are not C-style strings. The definition of <tt>s4</tt> is an error. This form of initialization may be called only with a null-terminated array. Passing an array that does not contain a null is a serious error (<a class="docLink" href="ch04lev1sec3.html#ch04lev1sec3">Section 4.3</a>, p. <a class="docLink" href="ch04lev1sec3.html#ch04lev1sec3">130</a>), although it is an error that the compiler cannot detect. What happens at run time is undefined.</P>
<p class="docText">The initialization of <tt>s5</tt> is fine: That initializer includes a count that says how many characters to copy. As long as the count is within the size of the array, it doesn't matter whether the array is null-terminated.</p>
<a name="ch09table13"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 9.13. Additional Ways to Construct <tt>string</tt>s</H5></caption><colgroup><col width="150"><col width="350"></colgroup><thead></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>string s(cp, n)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Create <tt>s</tt> as a copy of <tt>n</tt> characters from array pointed to by <tt>cp</tt>.</P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>string s(s2, pos2)</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Create <tt>s</tt> as a copy of characters in the <tt>string s2</tt> starting at index <tt>pos2</tt>. Undefined if <tt>pos2 &gt; s2.size()</tt>.</P></td></tr><tr><td class="docTableCell" align="left" valign="top" colspan="2"><p class="docText"><tt>string s(s2, pos2, len2)</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText">Create <tt>s</tt> as a copy of <tt>len2</tt> characters from <tt>s2</tt> starting at index <tt>pos2</tt>. Undefined if <tt>pos2 &gt; s2.size()</tt>. Regardless of the value of <tt>len2</tt>, copies at most <tt>s2.size() - pos2</tt> characters.</p></td></TR><TR><td class="docTableFooter" align="center" valign="top" colspan="2"><p class="docText"><span class="docEmphBoldItalic">Note:</span> <tt>n, len2</tt> <span class="docEmphBoldItalic">and</span> <tt>pos2</tt> <span class="docEmphBoldItalic">are all</span> <tt>unsigned</tt> <span class="docEmphBoldItalic">values.</span></P></td></tr></table></P><BR>
<a name="ch09lev3sec17"></a>
<h5 class="docSection3Title">Using a Substring as the Initializer</h5>
<p class="docText">The other pair of constructors allow us to create a <tt>string</tt> as a copy of a substring of the characters in another <tt>string</tt>:</p>
<pre>
     string s6(s1, 2);    // <span class="docEmphasis">s6 == "ya"</span>
     string s7(s1, 0, 2); // <span class="docEmphasis">s7 == "Hi"</span>
     string s8(s1, 0, 8); // <span class="docEmphasis">s8 == "Hiya"</span>
</pre><br>
<p class="docText">The first two arguments are the <tt>string</tt> from which we want to copy and a starting position. In the two-argument version, the newly created <tt>string</tt> is initialized with the characters from that position to the end of the <tt>string</tt> argument. We can also provide a third argument that specifies how many characters to copy. In this case, we copy as many characters as indicated (up to the size of the <tt>string</tt>), starting at the specified position. For example, when we create <tt>s7</tt>, we copy two characters from <tt>s1</tt>, starting at position zero. When we create <tt>s8</tt>, we copy only four characters, not the requested nine. Regardless of how many characters we ask to copy, the library copies up to the size of the <tt>string</tt>, but not more.</p>


<a name="ch09lev2sec19"></a>
<H4 class="docSection2Title">9.6.2. Other Ways to Change a <tt>string</tt></h4>
<p class="docText">Many of the container operations that <tt>string</tt> supports operate in terms of iterators. For example, <tt>erase</tt> takes an iterator or iterator range to specify which element(s) to remove from the container. Similarly, the first argument to each version of <tt>insert</tt> takes an iterator to indicate the position before which to insert <a name="idd1e71616"></a><a name="idd1e71623"></a><a name="idd1e71630"></a><a name="idd1e71637"></a><a name="idd1e71644"></a><a name="idd1e71651"></a>the values represented by the other arguments. Although <tt>string</tt> supports these iterator-based operations, it also supplies operations that work in terms of an index. The index is used to indicate the starting element to <tt>erase</tt> or the position before which to <tt>insert</tt> the appropriate values. <a class="docLink" href="#ch09table14">Table 9.14</a> lists the operations that are common to both <tt>string</tt> and the containers; <a class="docLink" href="#ch09table15">Table 9.15</a> on the facing page lists the <tt>string</tt>-only operations.</P>
<a name="ch09table14"></a><P><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 9.14. <tt>string</tt> Operations in Common with the Containers</h5></caption><colgroup><col width="150"><col width="375"></colgroup><thead></thead><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.insert(p, t)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Insert copy of value <tt>t</tt> before element referred to by iterator <tt>p</tt>.</p>
<p class="docText">Returns an iterator referring to the inserted element.</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.insert(p, n, t)</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Insert <tt>n</tt> copies of <tt>t</tt> before <tt>p</tt>. Returns <tt>void</tt>.</p></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.insert(p, b, e)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Insert elements in range denoted by iterators <tt>b</tt> and <tt>e</tt> before <tt>p</tt>.</p>
<p class="docText">Returns <tt>void</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.assign(b, e)</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Replace <tt>s</tt> by elements in range denoted by <tt>b</tt> and <tt>e</tt>. For <tt>string</tt>, returns <tt>s</tt>, for the containers, returns <tt>void</tt>.</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.assign(n, t)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Replace <tt>s</tt> by <tt>n</tt> copies of value <tt>t</tt>. For <tt>string</tt>, returns <tt>s</tt>, for the containers, returns <tt>void</tt>.</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.erase(p)</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Erase element referred to by iteartor <tt>p</tt>.</p>
<p class="docText">Returns an iterator to the element after the one deleted.</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.erase(b, e)</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Remove elements in range denoted by <tt>b</tt> and <tt>e</tt>.</p>
<p class="docText">Returns an iterator to the first element after the range deleted.</p></TD></tr></table></p><BR>
<a name="ch09table15"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 9.15. <tt>string</tt>-Specific Versions</h5></caption><colgroup><col width="200"><col width="300"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.insert(pos, n, c)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Insert <tt>n</tt> copies of character <tt>c</tt> before element at index <tt>pos</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.insert(pos, s2)</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Insert copy of <tt>string s2</tt> before <tt>pos</tt>.</P></td></TR><tr><td class="docTableCell" align="left" valign="top" colspan="2"><p class="docText"><tt>s.insert(pos, s2, pos2, len)</tt></P></TD></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText">Insert <tt>len</tt> characters from <tt>s2</tt> starting at <tt>pos2</tt> before <tt>pos</tt>.</P></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.insert(pos, cp, len)</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Insert <tt>len</tt> characters from array pointed to by <tt>cp</tt> before <tt>pos</tt>.</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.insert(pos, cp)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Insert copy of null-terminated string pointed to by <tt>cp</tt> before <tt>pos</tt>.</P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.assign(s2)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Replace <tt>s</tt> by a copy of <tt>s2</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.assign(s2, pos2, len)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Replace <tt>s</tt> by a copy of <tt>len</tt> characters from <tt>s2</tt> starting at index <tt>pos2</tt> in <tt>s2</tt>.</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.assign(cp, len)</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Replace <tt>s</tt> by <tt>len</tt> characters from array pointed to by <tt>cp</tt>.</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.assign(cp)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Replace <tt>s</tt> by null-terminated array pointed to by <tt>cp</tt>.</P></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.erase(pos, len)</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Erase <tt>len</tt> characters starting at <tt>pos</tt>.</P></td></tr><tr><td class="docTableFooter" align="center" valign="top" colspan="2"><p class="docText"><span class="docEmphBoldItalic">Unless noted otherwise, all operations return a reference to <tt>s</tt></span>.</P></td></tr></table></P><br>
<a name="ch09lev3sec18"></a>
<h5 class="docSection3Title">Position-Based Arguments</H5>
<p class="docText">The <tt>string</tt>-specific versions of these operations take arguments similar to those of the additional constructors covered in the previous section. These operations let us deal with <tt>string</tt>s positionally and/or let us use arguments that are pointers to character arrays rather than <tt>string</tt>s.</p>
<p class="docText">For example, all containers let us specify a pair of iterators that denote a range of elements to <tt>erase</tt>. For <tt>strings</tt>, we can also specify the range by passing a starting position and count of the number of elements to <tt>erase</tt>. Assuming <tt>s</tt> is at least five characters long, we could erase the last five characters as follows:</P>
<pre>
     s.erase(s.size() - 5, 5); // <span class="docEmphItalicAlt">erase last five characters from</span> <span class="docEmphasis">s</span>
</pre><br>
<p class="docText">Similarly, we can <tt>insert</tt> a given number of values in a container before the element referred to by an iterator. In the case of <tt>string</tt>s, we can specify the insertion point as an index rather than using an iterator:</p>
<pre>
     s.insert(s.size(), 5, '!'); // <span class="docEmphItalicAlt">insert five exclamation points at end of</span> <span class="docEmphasis">s</span>
</pre><br>

<a name="ch09lev3sec19"></a>
<h5 class="docSection3Title">Specifying the New Contents</h5>
<p class="docText">The characters to <tt>insert</tt> or <tt>assign</tt> into the <tt>string</tt> can be taken from a character array or another <tt>string</tt>. For example, we can use a null-terminated character array as the value to <tt>insert</tt> or <tt>assign</tt> into a <tt>string</tt>:</p>
<pre>
     char *cp = "Stately plump Buck";
     string s;
     s.assign(cp, 7);            // <span class="docEmphasis">s == "Stately"</span>
     s.insert(s.size(), cp + 7); // <span class="docEmphasis">s == "Stately plump Buck"</span>
</pre><br>
<p class="docText">Similarly, we can <tt>insert</tt> a copy of one <tt>string</tt> into another as follows:</p>
<pre>
     s = "some string";
     s2 = "some other string";
     // <span class="docEmphItalicAlt">3 equivalent ways to insert all the characters from</span> <span class="docEmphasis">s2</span> <span class="docEmphItalicAlt">at beginning of s</span>
     // <span class="docEmphItalicAlt">insert iterator range before</span> <span class="docEmphasis">s.begin()</span>
     s.insert(s.begin(), s2.begin(), s2.end());
     // <span class="docEmphItalicAlt">insert copy of</span> <span class="docEmphasis">s2</span> <span class="docEmphItalicAlt">before position 0 in</span> <span class="docEmphasis">s</span>
     s.insert(0, s2);
     // <span class="docEmphItalicAlt">insert</span> <span class="docEmphasis">s2.size()</span> <span class="docEmphItalicAlt">characters from s2 starting at</span> <span class="docEmphasis">s2[0]</span> <span class="docEmphItalicAlt">before</span> <span class="docEmphasis">s[0]</span>
     s.insert(0, s2, 0, s2.size());
</pre><br>


<a name="ch09lev2sec20"></a>
<h4 class="docSection2Title">9.6.3. <tt>string</tt>-Only Operations</h4>
<p class="docText">The <tt>string</tt> type provides several other operations that the containers do not:</p>
<ul><LI><p class="docList">The <tt>substr</tt> function that returns a substring of the current <tt>string</tt></P></li><LI><p class="docList">The <tt>append</tt> and <tt>replace</tt> functions that modify the <tt>string</tt></p></li><LI><p class="docList">A family of <tt>find</tt> functions that search the <tt>string</tt></P></li></ul>
<a name="ch09lev3sec20"></a>
<h5 class="docSection3Title">The <tt>substr</tt> Operation</h5>
<p class="docText"><a name="idd1e72342"></a><a name="idd1e72349"></a><a name="idd1e72356"></a><a name="idd1e72363"></a><a name="idd1e72370"></a><a name="idd1e72377"></a>The <tt>substr</tt> operation lets us retrieve a substring from a given <tt>string</tt>. We can pass <tt>substr</tt> a starting position and a count. It creates a new <tt>string</tt> that has that many characters, (up to the end of the <tt>string</tt>) from the target <tt>string</tt>, starting at the given position:</p>
<pre>
     string s("hello world");
     // <span class="docEmphItalicAlt">return substring of 5 characters starting at position 6</span>
     string s2 = s.substr(6, 5);   // <span class="docEmphItalicAlt">s2 = world</span>
</pre><BR>
<p class="docText">Alternatively, we could obtain the same result by writing:</p>
<pre>
     // <span class="docEmphItalicAlt">return substring from position 6 to the end of</span> <span class="docEmphasis">s</span>
     string s3 = s.substr(6);      // <span class="docEmphItalicAlt">s3 = world</span>
</pre><BR>
<a name="ch09table16"></a><P><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 9.16. Substring Operation</h5></caption><colgroup><col width="150"><col width="350"></colgroup><thead></thead><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.substr(pos, n)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Return a <tt>string</tt> containing <tt>n</tt> characters from <tt>s</tt> starting at <tt>pos</tt>.</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.substr(pos)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Return a <tt>string</tt> containing characters from <tt>pos</tt> to the end of <tt>s</tt>.</P></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.substr()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Return a copy of <tt>s</tt>.</p></td></tr></table></p><br>

<a name="ch09lev3sec21"></a>
<h5 class="docSection3Title">The <tt>append</tt> and <tt>replace</tt> Functions</h5>
<p class="docText">There are six overloaded versions of <tt>append</tt> and ten versions of <tt>replace</tt>. The <tt>append</tt> and <tt>replace</tt> functions are overloaded using the same set of arguments, which are listed in <a class="docLink" href="#ch09table18">Table 9.18</a> on the next page. These arguments specify the characters to add to the <tt>string</tt>. In the case of <tt>append</tt>, the characters are added at the end of the <tt>string</tt>. In the <tt>replace</tt> function, these characters are inserted in place a specified range of existing characters in the <tt>string</tt>.</p>
<p class="docText">The <tt>append</tt> operation is a shorthand way of inserting at the end:</P>
<pre>
     string s("C++ Primer");        // <span class="docEmphItalicAlt">initialize</span> <span class="docEmphasis">s</span> <span class="docEmphItalicAlt">to "C++ Primer"</span>
     s.append(" 3rd Ed.");          // <span class="docEmphasis">s == "C++ Primer 3rd Ed."</span>
     // <span class="docEmphItalicAlt">equivalent to</span> <span class="docEmphasis">s.append(" 3rd Ed.")</span>
     s.insert(s.size(), " 3rd Ed.");
</pre><BR>
<p class="docText">The <tt>replace</tt> operations remove an indicated range of characters and insert a new set of characters in their place. The <tt>replace</tt> operations have the same effect as calling <tt>erase</tt> and <tt>insert</tt>.</p>
<p class="docText">The ten different versions of <tt>replace</tt> differ from each other in how we specify the characters to remove and in how we specify the characters to insert in their place. The first two arguments specify the range of elements to remove. We can specify the range either with an iterator pair or an index and a count. The remaining arguments specify what new characters to insert.</P>
<p class="docText">We can think of <tt>replace</tt> as a shorthand way of erasing some characters and inserting others in their place:</p>
<a name="ch09table17"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 9.17. Operations to Modify <tt>string</tt>s (<span class="docEmphasis">args</span> defined in <a class="docLink" href="#ch09table18">Table 9.18</a>)</H5></caption><colgroup><col width="200"><col width="325"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.append(</tt> <span class="docEmphBoldItalic">args</span><tt>)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Append <span class="docEmphasis">args</span> to <tt>s</tt>. Returns reference to <tt>s</tt>.</P></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.replace(pos, len</tt>, <span class="docEmphBoldItalic">args</span><tt>)</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Remove <tt>len</tt> characters from <tt>s</tt> starting at <tt>pos</tt> and replace them by characters formed by <span class="docEmphasis">args</span>. Returns reference to <tt>s</tt>.</P>
<p class="docText"><span class="docEmphStrong">This version does not take <span class="docEmphasis">args</span> equal to <tt>b2</tt></span><span class="docEmphStrong">, <tt>e2</tt></span>.</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.replace(b, e</tt>, <span class="docEmphBoldItalic">args</span><tt>)</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Remove characters in the range denoted by iterators <tt>b</tt> and <tt>e</tt> and replace them by <span class="docEmphasis">args</span>. Returns reference to <tt>s</tt>.</p>
<p class="docText"><span class="docEmphStrong">This version does not take <span class="docEmphasis">args</span> equal to <tt>s2, pos2, len2</tt>.</span></p></TD></tr></table></P><br>
<pre>
     // <span class="docEmphItalicAlt">starting at position 11, erase 3 characters and then insert</span> <span class="docEmphasis">"4th"</span>
     s.replace(11, 3, "4th");          // <span class="docEmphasis">s == "C++ Primer 4th Ed."</span>
     // <span class="docEmphItalicAlt">equivalent way to replace</span> <span class="docEmphasis">"3rd" by "4th"</span>
     s.erase(11, 3);                   <span class="docEmphasis">// s == "C++ Primer Ed."</span>
     s.insert(11, "4th");              <span class="docEmphasis">// s == "C++ Primer 4th Ed."</span>
</pre><br>
<a name="ch09note27"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> There is no requirement that the size of the text removed and inserted be the same.</p></td></tr></table><br>
</p></div><br>
<p class="docText">In the previous call to <tt>replace</tt>, the text we inserted happens to be the same size as the text we removed. We could insert a larger or smaller <tt>string</tt>:</P>
<pre>
     s.replace(11, 3, "Fourth"); // <span class="docEmphasis">s == "C++ Primer Fourth Ed."</span>
</pre><BR>
<p class="docText">In this call we remove three characters but insert six in their place.</p>
<a name="ch09table18"></a><P><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 9.18. Arguments to <tt>append</tt> and <tt>replace</tt></h5></caption><colgroup><col width="150"><col width="370"></colgroup><thead></thead><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>s2</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">The <tt>string s2</tt>.</p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>s2, pos2, len2</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">up to <tt>len2</tt> characters from <tt>s2</tt> starting at <tt>pos2</tt>.</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>cp</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Null-terminated array pointed to by pointer <tt>cp</tt>.</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>cp, len2</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">up to <tt>len2</tt> characters from character array pointed to by <tt>cp</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>n, c</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>n</tt> copies of character <tt>c</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>b2, e2</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Characters in the range formed by iterators <tt>b2</tt> and <tt>e2</tt>.</P></td></tr></table></P><BR>


<a name="ch09lev2sec21"></a>
<h4 class="docSection2Title">9.6.4. <tt>string</tt> Search Operations</h4>
<p class="docText">The <tt>string</tt> class provides six search functions, each named as a variant of <tt>find</tt>. The operations all return a <tt>string::size_type</tt> value that is the index of where the match occurred, or a special value named <tt>string::npos</tt> if there is no match. The <tt>string</tt> class defines <tt>npos</tt> as a value that is guaranteed to be greater than any valid index.</p>
<p class="docText"><a name="idd1e72963"></a><a name="idd1e72970"></a><a name="idd1e72976"></a>There are four versions of each of the search operations, each of which takes a different set of arguments. The arguments to the search operations are listed in <a class="docLink" href="#ch09table20">Table 9.20</a>. Basically, these operations differ as to whether they are looking for a single character, another <tt>string</tt>, a C-style, null-terminated string, or a given number of characters from a character array.</p>
<a name="ch09table19"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 9.19. <tt>string</tt> Search Operations (Arguments in <a class="docLink" href="#ch09table20">Table 9.20</a>)</h5></caption><colgroup><col width="200"><col width="325"></colgroup><thead></thead><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.find(</tt> <span class="docEmphBoldItalic">args</span><tt>)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Find first occurrence of <span class="docEmphasis">args</span> in <tt>s</tt>.</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.rfind(</tt> <span class="docEmphBoldItalic">args</span><tt>)</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Find last occurrence of <span class="docEmphasis">args</span> in <tt>s</tt>.</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.find_first_of(</tt> <span class="docEmphBoldItalic">args</span><tt>)</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Find first occurrence of any character from <span class="docEmphasis">args</span> in <tt>s</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.find_last_of(</tt> <span class="docEmphBoldItalic">args</span><tt>)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Find last occurrence of any character from <span class="docEmphasis">args</span> in <tt>s</tt>.</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.find_first_not_of(</tt> <span class="docEmphBoldItalic">args</span><tt>)</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Find first character in <tt>s</tt> that is not in <span class="docEmphasis">args</span>.</p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.find_last_not_of(</tt> <span class="docEmphBoldItalic">args</span><tt>)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Find last character in <tt>s</tt> that is not in <span class="docEmphasis">args</span>.</p></TD></tr></table></P><BR>
<a name="ch09table20"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 9.20. Arguments to <tt>string find</tt> Operations</h5></caption><colgroup><col width="100"><col width="400"></colgroup><thead></thead><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>c, pos</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Look for the character <tt>c</tt> starting at position <tt>pos</tt> in <tt>s</tt>. <tt>pos</tt> defaults to 0.</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>s2, pos</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Look for the <tt>string s2</tt> starting at position <tt>pos</tt> in <tt>s</tt>. <tt>pos</tt> defaults to 0.</p></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>cp, pos</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Look for the C-style null-terminated string pointed to by the pointer <tt>cp</tt>.</p>
<p class="docText">Start looking starting at position <tt>pos</tt> in <tt>s</tt>. <tt>pos</tt> defaults to 0.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>cp, pos, n</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Look for the first <tt>n</tt> characters in the array pointed to by the pointer <tt>cp</tt>.</p>
<p class="docText">Start looking starting at position <tt>pos</tt> in <tt>s</tt>. No default for <tt>pos</tt> or <tt>n</tt>.</P></td></tr></table></P><BR>
<a name="ch09lev3sec22"></a>
<h5 class="docSection3Title">Finding an Exact Match</h5>
<p class="docText">The simplest of the search operations is the <tt>find</tt> function. It looks for its argument and returns the index of the first match that is found, or <tt>npos</tt> if there is no match:</p>
<pre>
     string name("AnnaBelle");
     string::size_type pos1 = name.find("Anna"); // <span class="docEmphasis">pos1 == 0</span>
</pre><br>
<p class="docText">Returns 0, the index at which the substring <tt>"Anna"</tt> is found in <tt>"AnnaBelle"</tt>.</p>
<a name="ch09note28"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><td valign="top"><p class="docText"> By default, the find operations (and other <tt>string</tt> operations that deal with characters) use the built-in operators to compare characters in the <tt>string</tt>. As a result, these operations (and other <tt>string</tt> operations) are case sensitive.</p></td></TR></table><BR>
</p></div><br>
<p class="docText">When we look for a value in the <tt>string</tt>, case matters:</p>
<pre>
     string lowercase("annabelle");
     pos1 = lowercase.find("Anna"); // <span class="docEmphasis">pos1 == npos</span>
</pre><br>
<p class="docText">This code will set <tt>pos2</tt> to <tt>npos</tt>the <tt>string Anna</tt> does not match <tt>anna</tt>.</P>
<a name="ch09note29"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><td valign="top"><p class="docText"><a name="idd1e73362"></a><a name="idd1e73369"></a> The <tt>find</tt> operations return a <tt>string::size_type</tt>. Use an object of that type to hold the return from <tt>find</tt>.</P></td></TR></table><br>
</p></div><br>

<a name="ch09lev3sec23"></a>
<h5 class="docSection3Title">Find Any Character</h5>
<p class="docText">A slightly more complicated problem would be if we wanted to match any character in our search string. For example, the following locates the first digit within <tt>name</tt>:</p>
<pre>
     string numerics("0123456789");
     string name("r2d2");
     string::size_type pos = name.find_first_of(numerics);
     cout &lt;&lt; "found number at index: " &lt;&lt; pos
          &lt;&lt; " element is "  &lt;&lt; name[pos] &lt;&lt; endl;
</pre><br>
<p class="docText">In this example, <tt>pos</tt> is set to a value of 1 (the elements of a <tt>string</tt>, remember, are indexed beginning at 0).</p>

<a name="ch09lev3sec24"></a>
<h5 class="docSection3Title">Specifying Where to Start the Search</h5>
<p class="docText">We can pass an optional starting position to the <tt>find</tt> operations. This optional argument indicates the index position from which to start the search. By default, that position is set to zero. One common programming pattern uses this optional argument to loop through a <tt>string</tt> finding all occurrences. We could rewrite our search of <tt>"r2d2"</tt> to find all the numbers in <tt>name</tt>:</p>
<pre>
     string::size_type pos = 0;
     // <span class="docEmphItalicAlt">each trip reset pos to the next instance in name</span>
     while ((pos = name.find_first_of(numerics, pos))
                   != string::npos) {
         cout &lt;&lt; "found number at index: " &lt;&lt; pos
              &lt;&lt; " element is " &lt;&lt; name[pos] &lt;&lt; endl;
         ++pos; // <span class="docEmphItalicAlt">move to the next character</span>
     }
</pre><br>
<p class="docText">In this case, we initialize <tt>pos</tt> to zero so that on the first trip through the <tt>while name</tt> is searched, beginning at position 0. The condition in the <tt>while</tt> resets <tt>pos</tt> to the index of the first number encountered, starting from the current value of <tt>pos</tt>. As long as the return from <tt>find_first_of</tt> is a valid index, we print our result and increment <tt>pos</tt>.</p>
<p class="docText">Had we neglected to increment <tt>pos</tt> at the end of this loop, then it would never terminate. To see why, consider what would happen if we didn't. On the second trip through the loop. we start looking at the character indexed by <tt>pos</tt>. That character would be a number, so <tt>find_first_of</tt> would (repeatedly) returns <tt>pos</tt>!</P>
<a name="ch09note30"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> It is essential that we increment <tt>pos</tt>. Doing so ensures that we start looking for the next number at a point <span class="docEmphasis">after</span> the number we just found.</P></TD></tr></table><br>
</p></div><br>

<a name="ch09lev3sec25"></a>
<h5 class="docSection3Title">Looking for a Nonmatch</H5>
<p class="docText"><a name="idd1e73512"></a><a name="idd1e73516"></a><a name="idd1e73520"></a><a name="idd1e73524"></a><a name="idd1e73531"></a><a name="idd1e73538"></a><a name="idd1e73545"></a><a name="idd1e73552"></a>Instead of looking for a match, we might call <tt>find_first_not_of</tt> to find the first position that is <span class="docEmphasis">not</span> in the search argument. For example, to find the first non-numeric character of a <tt>string</tt>, we can write</p>
<pre>
     string numbers("0123456789");
     string dept("03714p3");

     // <span class="docEmphItalicAlt">returns</span> <span class="docEmphasis">5</span>, <span class="docEmphItalicAlt">which is the index to the character</span> <span class="docEmphasis">'p'</span>
     string::size_type pos = dept.find_first_not_of(numbers);
</pre><BR>

<a name="ch09lev3sec26"></a>
<H5 class="docSection3Title">Searching Backward</h5>
<p class="docText">Each of the <tt>find</tt> operations that we've seen so far executes left to right. The library provides an analogous set of operations that look through the <tt>string</tt> from right to left. The <tt>rfind</tt> member searches for the lastthat is, rightmostoccurrence of the indicated substring:</p>
<pre>
     string river("Mississippi");
     string::size_type first_pos = river.find("is"); // <span class="docEmphItalicAlt">returns 1</span>
     string::size_type last_pos = river.rfind("is"); // <span class="docEmphItalicAlt">returns 4</span>
</pre><br>
<p class="docText"><tt>find</tt> returns an index of 1, indicating the start of the first <tt>"is"</tt>, while <tt>rfind</tt> returns an index of 4, indicating the start of the last occurrence of <tt>"is"</tt>.</P>

<a name="ch09lev3sec27"></a>
<H5 class="docSection3Title">The <tt>find_last</tt> Functions</h5>
<p class="docText">The <tt>find_last</tt> functions operate like the corresponding <tt>find_first</tt> functions, except that they return the <span class="docEmphasis">last</span> match rather than the first:</p>
<ul><li><p class="docList"><tt>find_last_of</tt> searches for the last character that matches any element of the search <tt>string</tt>.</P></li><li><p class="docList"><tt>find_last_not_of</tt> searches for the last character that does not match any element of the search <tt>string</tt>.</P></li></ul>
<p class="docText">Each of these operations takes an optional second argument indicating the position within the <tt>string</tt> to begin searching.</P>


<a name="ch09lev2sec22"></a>
<h4 class="docSection2Title">9.6.5. Comparing <tt>string</tt>s</H4>
<p class="docText">As we saw in <a class="docLink" href="ch03lev1sec2.html#ch03lev2sec4">Section 3.2.3</a> (p. <a class="docLink" href="ch03lev1sec2.html#ch03lev2sec4">85</a>), the <tt>string</tt> type defines all the relational operators so that we can compare two <tt>string</tt>s for equality (<tt>==</tt>), inequality (<tt>!=</tt>), and the less- or greater-than operations (<tt>&lt;, &lt;=, &gt;, &gt;=</tt>). Comparison between <tt>string</tt>s is lexicographicalthat is, <tt>string</tt> comparison is the same as a case-sensitive, dictionary ordering:</p>
<pre>
     string cobol_program_crash("abend");
     string cplus_program_crash("abort");
</pre><br>
<a name="ch09sb17"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 9.6.4</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa15q1"></a><b>Exercise 9.38:</b></td><td><p class="docText"><a name="idd1e73744"></a><a name="idd1e73752"></a><a name="idd1e73760"></a><a name="idd1e73767"></a><a name="idd1e73776"></a><a name="idd1e73785"></a><a name="idd1e73794"></a><a name="idd1e73803"></a><a name="idd1e73810"></a><a name="idd1e73816"></a>Write a program that, given the <tt>string</tt></P>
<pre>
     "ab2c3d7R4E6"
</pre><BR>
<p class="docText">finds each numeric character and then each alphabetic character. Write two versions of the program. The first should use <tt>find_first_of</tt>, and the second <tt>find_first_not_of</tt>.</p>
</TD></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch09qa15q2"></a><B>Exercise 9.39:</b></td><td><p class="docText">Write a program that, given the <tt>string</tt>s</p>
<pre>
     string line1 = "We were her pride of 10 she named us:";
     string line2 = "Benjamin, Phoenix, the Prodigal"
     string line3 = "and perspicacious pacific Suzanne";

     string sentence = line1 + ' ' + line2 + ' ' + line3;
</pre><br>
<p class="docText">counts the number of words in <tt>sentence</tt> and identifies the largest and smallest words. If several words have the largest or smallest length, report all of them.</p>
</TD></tr></table></P>
</blockquote>
</TD></tr></table></p><br>
<p class="docText">Here <tt>cobol_program_crash</tt> is less than the <tt>cplus_program_crash</tt>. The relational operators compare two <tt>string</tt>s character by character until reaching a position where the two <tt>string</tt>s differ. The overall comparison of the <tt>string</tt>s depends on the comparison between these unequal characters. In this case, the first unequal characters are <tt>'e'</tt> and <tt>'o'</tt>. The letter <tt>'e'</tt> occurs before (is less than) <tt>'o'</tt> in the English alphabet and so <tt>"abend"</tt> is less than <tt>"abort"</tt>. If the <tt>string</tt>s are of different length, and one <tt>string</tt> is a substring of the other, then the shorter <tt>string</tt> is less than the longer.</P>
<a name="ch09lev3sec28"></a>
<H5 class="docSection3Title">The <tt>compare</tt> Functions</h5>
<p class="docText">In addition to the relational operators, <tt>string</tt> provides a set of <tt>compare</tt> operations that perform lexicographical comparions. The results of these operations are similar to the C library <tt>strcmp</tt> function (<a class="docLink" href="ch04lev1sec3.html#ch04lev1sec3">Section 4.3</a>, p. <a class="docLink" href="ch04lev1sec3.html#ch04lev1sec3">132</a>). Given</p>
<pre>
     s1.compare <span class="docEmphasis">(args);</span>
</pre><br>
<p class="docText"><tt>compare</tt> returns one of three possible values:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><LI><div style="font-weight:normal"><p class="docList">A positive value if <tt>s1</tt> is greater than the <tt>string</tt> represented by <span class="docEmphasis">args</span></p></div></li><LI><div style="font-weight:normal"><p class="docList">A negative value if <tt>s1</tt> is less than the <tt>string</tt> represented by <span class="docEmphasis">args</span></p></div></li><LI><div style="font-weight:normal"><p class="docList">0 if <tt>s1</tt> is equal to the <tt>string</tt> represented by <span class="docEmphasis">args</span></p></div></LI></ol></div>
<p class="docText">For example</p>
<pre>
     // <span class="docEmphItalicAlt">returns a negative value</span>
     cobol_program_crash.compare(cplus_program_crash);
     // <span class="docEmphItalicAlt">returns a positive value</span>
     cplus_program_crash.compare(cobol_program_crash);
</pre><br>
<a name="ch09table21"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 9.21. <tt>string compare</tt> Operations</h5></caption><colgroup><col width="150"><col width="350"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.compare(s2)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Compare <tt>s</tt> to <tt>s2</tt>.</p></td></tr><TR><TD class="docTableCell" align="left" valign="top" colspan="2"><p class="docText"><tt>s.compare(pos1, n1, s2)</tt></p></TD></tr><tr><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><td class="docTableCell" align="left" valign="top"><p class="docText">Compares <tt>n1</tt> characters starting at <tt>pos1</tt> from <tt>s</tt> to <tt>s2</tt>.</p></td></tr><tr><TD class="docTableCell" align="left" valign="top" colspan="2"><p class="docText"><tt>s.compare(pos1, n1, s2, pos2, n2)</tt></p></TD></TR><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><TD class="docTableCell" align="left" valign="top"><p class="docText">Compares <tt>n1</tt> characters starting at <tt>pos1</tt> from <tt>s</tt> to the <tt>n2</tt> characters starting at <tt>pos2</tt> in <tt>s2</tt>.</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.compare(cp)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Compares <tt>s</tt> to the null-terminated string pointed to by <tt>cp</tt>.</P></td></tr><TR><td class="docTableCell" align="left" valign="top" colspan="2"><p class="docText"><tt>s.compare(pos1, n1, cp)</tt></P></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText">Compares <tt>n1</tt> characters starting at <tt>pos1</tt> from <tt>s</tt> to <tt>cp</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top" colspan="2"><p class="docText"><tt>s.compare(pos1, n1, cp, n2)</tt></p></td></TR><TR><td class="docTableCell" align="left" valign="top">&nbsp;</TD><td class="docTableCell" align="left" valign="top"><p class="docText">Compares <tt>n1</tt> characters starting at <tt>pos1</tt> from <tt>s</tt> to <tt>n2</tt> characters starting from the pointer <tt>cp</tt>.</p></TD></TR></table></p><br>
<p class="docText"><a name="idd1e74196"></a><a name="idd1e74199"></a><a name="idd1e74204"></a><a name="idd1e74209"></a><a name="idd1e74213"></a><a name="idd1e74219"></a><a name="idd1e74225"></a><a name="idd1e74231"></a>The overloaded set of six <tt>compare</tt> operations allows us to compare a substring of either one or both <tt>string</tt>s for comparison. They also let us compare a <tt>string</tt> to a character array or portion thereof:</p>
<pre>
     char second_ed[] = "C++ Primer, 2nd Edition";
     string third_ed("C++ Primer, 3rd Edition");
     string fourth_ed("C++ Primer, 4th Edition");

     // <span class="docEmphItalicAlt">compares C++ library string to C-style string</span>
     fourth_ed.compare(second_ed); // <span class="docEmphItalicAlt">ok,</span> <span class="docEmphasis">second_ed</span> <span class="docEmphItalicAlt">is null-terminated</span>

     // <span class="docEmphItalicAlt">compare substrings of</span> <span class="docEmphasis">fourth_ed</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">third_ed</span>
     fourth_ed.compare(fourth_ed.find("4th"), 3,
                       third_ed, third_ed.find("3rd"), 3);
</pre><br>
<p class="docText">The second call to <tt>compare</tt> is the most interesting. This call uses the version of <tt>compare</tt> that takes five arguments. We use <tt>find</tt> to locate the position of the beginning of the substring <tt>"4th"</tt>. We compare three characters starting at that position to a substring from <tt>third_ed</tt>. That substring begins at the position returned from <tt>find</tt> when looking for <tt>"3rd"</tt> and again we compare three characters. Essentially, this call compares <tt>"4th"</tt> to <tt>"3rd"</tt>.</p>



<a href="21001535.html"><img src="images/pixel.gif" alt="" width="1" height="1" border="0"></a><UL></ul></TD></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch09lev1sec5.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch09lev1sec7.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>