<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 9.7.&nbsp; Container Adaptors</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch09lev1sec6.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch09lev1sec8.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch09lev1sec7"></a>
<h3 class="docSection1Title">9.7. Container Adaptors</h3>
<p class="docText">In addition to the sequential containers, the library provides three sequential container adaptors: <tt>queue</tt>, <span class="docEmphRoman"><a name="ch09term11"></a><a class="docLink" href="ch09lev1sec9.html#gloss09_11"><span class="docEmphRoman"><tt>priority_queue</tt>,</span></a></span> and <tt>stack</tt>. An <B><a name="ch09term1"></a><a class="docLink" href="ch09lev1sec9.html#gloss09_01">adaptor</a></b> is a general concept in the library. There are container, iterator, and function adaptors. Essentially, an adaptor is a mechanism for making one thing act like another. A container adaptor takes an existing container type and makes it act like a different abstract type. For example, the <tt>stack</tt> adaptor takes any of the sequential containers and makes it operate as if it were a <tt>stack</tt>. <a class="docLink" href="#ch09table22">Table 9.22</a> (p. <a class="docLink" href="#ch09table22">350</a>) lists the operations and types that are common to all the container adaptors.</P>
<a name="ch09table22"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 9.22. Common Adaptor Operations and Types</h5></caption><colgroup><col width="150"><col width="350"></colgroup><thead></thead><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>size_type</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Type large enough to hold size of largest object of this type.</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>value_type</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Element type.</p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>container_type</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Type of the underlying container on which the adaptor is implemented.</P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>A a;</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Create a new empty adaptor named <tt>a</tt>.</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>A a(c);</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Create a new adaptor named <tt>a</tt> with a copy of the container <tt>c</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis">Relational Operators</span></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Each adaptor supports all the relational operators: <tt>==, !=, &lt;, &lt;=, &gt;, &gt;=</tt>.</p></TD></tr></table></p><BR>
<a name="ch09sb18"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 9.6.5</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><td align="right" class="docText" width="50"><a name="ch09qa16q1"></a><B>Exercise 9.40:</b></TD><td><p class="docText"><a name="idd1e74460"></a><a name="idd1e74466"></a><a name="idd1e74472"></a><a name="idd1e74479"></a><a name="idd1e74485"></a>Write a program that accepts the following two <tt>string</tt>s:</p>
<pre>
     string q1("When lilacs last in the dooryard bloom'd");
     string q2("The child is father of the man");
</pre><br>
<p class="docText">Using the <tt>assign</tt> and <tt>append</tt> operations, create the <tt>string</tt></P>
<pre>
     string sentence("The child is in the dooryard");
</pre><BR>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa16q2"></a><B>Exercise 9.41:</b></td><td><p class="docText">Write a program that, given the <tt>string</tt>s</P>
<pre>
     string generic1("Dear Ms Daisy:");
     string generic2("MrsMsMissPeople");
</pre><br>
<p class="docText">implements the function</p>
<pre>
     string greet(string form, string lastname, string title,
                  string::size_type pos, int length);
</pre><BR>
<p class="docText">using the <tt>replace</tt> operations, where <tt>lastname</tt> replaces <tt>Daisy</tt> and <tt>pos</tt> indexes into <tt>generic2</tt> of <tt>length</tt> characters replacing <tt>Ms</tt>. For example, the following</p>
<pre>
     string lastName("AnnaP");
     string salute = greet(generic1, lastName, generic2, 5, 4);
</pre><BR>
<p class="docText">returns the <tt>string</tt></p>
<pre>
     Dear Miss AnnaP:
</pre><br>
</td></tr></table></p>
</blockquote>
</td></tr></table></p><br>
<p class="docText">To use an adaptor, we must include its associated header:</p>
<pre>
     #include &lt;stack&gt;    // <span class="docEmphItalicAlt">stack adaptor</span>
     #include &lt;queue&gt;    // <span class="docEmphItalicAlt">both queue and priority_queue adaptors</span>
</pre><br>
<a name="ch09lev2sec23"></a>
<h4 class="docSection2Title">Initializing an Adapator</h4>
<p class="docText">Each adaptor defines two constructors: the default constructor that creates an empty object and a constructor that takes a container and makes a copy of that container as its underlying value. For example, assuming that <tt>deq</tt> is a <tt>deque&lt;int&gt;</tt>, we could use <tt>deq</tt> to initialize a new <tt>stack</tt> as follows:</P>
<pre>
     stack&lt;int&gt; stk(deq);      // <span class="docEmphItalicAlt">copies elements from</span> <span class="docEmphasis">deq</span> into <span class="docEmphasis">stk</span>
</pre><BR>

<a name="ch09lev2sec24"></a>
<h4 class="docSection2Title">Overriding the Underlying Container Type</H4>
<p class="docText">By default both <tt>stack</tt> and <span class="docEmphRoman"><a name="ch09term12"></a><a class="docLink" href="ch09lev1sec9.html#gloss09_12"><span class="docEmphRoman"><tt>queue</tt></span></a></span> are implemented in terms of <tt>deque</tt>, and a <tt>priority_queue</tt> is implemented on a <tt>vector</tt>. We can override the default container type by naming a sequential container as a second type argument when creating the adaptor:</p>
<pre>
     // <span class="docEmphItalicAlt">empty</span> <span class="docEmphasis">stack</span> <span class="docEmphItalicAlt">implemented on top of</span> <span class="docEmphasis">vector</span>
     stack&lt; string, vector&lt;string&gt; &gt; str_stk;

     // <span class="docEmphasis">str_stk2</span> <span class="docEmphItalicAlt">is implemented on top of</span> <span class="docEmphasis">vector</span> <span class="docEmphItalicAlt">and holds a copy of</span> <span class="docEmphasis">svec</span>
     stack&lt;string, vector&lt;string&gt; &gt; str_stk2(svec);
</pre><br>
<p class="docText"><a name="idd1e74703"></a><a name="idd1e74710"></a><a name="idd1e74717"></a><a name="idd1e74725"></a><a name="idd1e74733"></a><a name="idd1e74741"></a><a name="idd1e74749"></a><a name="idd1e74756"></a><a name="idd1e74762"></a><a name="idd1e74767"></a>There are constraints on which containers can be used for a given adapator. We can use any of the sequential containers as the underlying container for a <tt>stack</tt>. Thus, a <tt>stack</tt> can be built on a <tt>vector, list</tt>, or <tt>deque</tt>. The <tt>queue</tt> adapator requires <tt>push_front</tt> in its underlying container, and so could be built on a <tt>list</tt> but not on a <tt>vector</tt>. A <tt>priority_queue</tt> requires random access and so can be built on a <tt>vector</tt> or a <tt>deque</tt> but not on a <tt>list</tt>.</P>

<a name="ch09lev2sec25"></a>
<H4 class="docSection2Title">Relational Operations on Adaptors</h4>
<p class="docText">Two adaptors of the same type can be compared for equality, inequality, less-than, greater-than, less-than-equal, and greater-than-equal relationships, provided that the underlying element type supports the equality and less-than operators. For these operations, the elements are compared in turn. The first pair of unequal elements determines the less-than or greater-than relationship.</p>

<a name="ch09lev2sec26"></a>
<h4 class="docSection2Title">9.7.1. Stack Adaptor</h4>
<p class="docText">The operations provided by a <tt>stack</tt> are listed in <a class="docLink" href="#ch09table23">Table 9.23</a> on the facing page. The following program exercises this set of five <tt>stack</tt> operations:</p>
<a name="ch09table23"></a><P><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 9.23. Operations Supported by the Stack Container Adaptor</H5></caption><colgroup><col width="100"><col width="400"></colgroup><thead></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.empty()</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Returns <tt>TRue</tt> if the <tt>stack</tt> is empty; false otherwise.</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.size()</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Returns a count of the number of elements on the <tt>stack</tt>.</p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.pop()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Removes, but does not return, the top element from the <tt>stack</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.top()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns, but does not remove, the top element on the <tt>stack</tt>.</p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>s.push(item)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Places a new top element on the <tt>stack</tt>.</P></TD></tr></table></p><br>
<pre>
     // <span class="docEmphItalicAlt">number of elements we'll put in our stack</span>
     const stack&lt;int&gt;::size_type stk_size = 10;
     stack&lt;int&gt; intStack; // <span class="docEmphItalicAlt">empty stack</span>
     // <span class="docEmphItalicAlt">fill up the stack</span>
     int ix = 0;
     while (intStack.size() != stk_size)
         // <span class="docEmphItalicAlt">use postfix increment; want to push old value onto</span> <span class="docEmphasis">intStack</span>
         intStack.push(ix++); // <span class="docEmphasis">intStack</span> <span class="docEmphItalicAlt">holds 0...9 inclusive</span>

     int error_cnt = 0;
     // <span class="docEmphItalicAlt">look at each value and pop it off the stack</span>
     while (intStack.empty() == false) {
         int value = intStack.top();
         // <span class="docEmphItalicAlt">read the top element of the stack</span>
         if (value != --ix) {
             cerr &lt;&lt; "oops! expected " &lt;&lt; ix
                  &lt;&lt; " received " &lt;&lt; value &lt;&lt; endl;
             ++error_cnt; }
         intStack.pop(); // <span class="docEmphItalicAlt">pop the top element, and repeat</span>
     }
     cout &lt;&lt; "Our program ran with "
          &lt;&lt; error_cnt &lt;&lt; " errors!" &lt;&lt; endl;
</pre><br>
<p class="docText"><a name="idd1e74970"></a><a name="idd1e74977"></a><a name="idd1e74984"></a><a name="idd1e74991"></a><a name="idd1e74998"></a>The declaration</p>
<pre>
     stack&lt;int&gt; intStack;   // <span class="docEmphItalicAlt">empty stack</span>
</pre><BR>
<p class="docText">defines <tt>intStack</tt> to be an empty <tt>stack</tt> that holds integer elements. The <tt>for</tt> loop adds <tt>stk_size</tt> elements initializing each to the next integer in sequence starting from zero. The <tt>while</tt> loop iterates through the entire <tt>stack</tt>, examining the <tt>top</tt> value and <tt>pop</tt>ping it from the <tt>stack</tt> until the <tt>stack</tt> is empty.</p>
<p class="docText">Each container adaptor defines its own operations in terms of operations provided by the underlying container type. By default, this <tt>stack</tt> is implemented using a <tt>deque</tt> and uses <tt>deque</tt> operations to implement the operations of a <tt>stack</tt>. For example, when we execute</P>
<pre>
     // <span class="docEmphItalicAlt">use postfix increment; want to push old value onto</span> <span class="docEmphasis">intStack</span>
     intStack.push(ix++);    // <span class="docEmphasis">intStack</span> <span class="docEmphItalicAlt">holds 0...9 inclusive</span>
</pre><BR>
<p class="docText">this operation executes by calling the <tt>push_back</tt> operation of the <tt>deque</tt> object on which <tt>intStack</tt> is based. Although <tt>stack</tt> is implemented by using a <tt>deque</tt>, we have no direct access to the <tt>deque</tt> operations. We cannot call <tt>push_back</tt> on a <tt>stack</tt>; instead, we must use the <tt>stack</tt> operation named <tt>push</tt>.</p>

<a name="ch09lev2sec27"></a>
<h4 class="docSection2Title">9.7.2. Queue and Priority Queue</h4>
<p class="docText">The library <tt>queue</tt> uses a first-in, first-out (FIFO) storage and retrieval policy. Objects entering the queue are placed in the back. The next object retrieved is taken from the front of the queue. There are two kinds of queues: the FIFO queue, which we will speak of simply as a <tt>queue</tt>, and a priority queue.</P>
<p class="docText">A <tt>priority_queue</tt> lets us establish a priority among the elements held in the queue. Rather than place a newly entered item at the back of the queue, the item is placed ahead of all those items with a lower priority. By default, the library uses the <tt>&lt;</tt> operator on the element type to determine relative priorities.</P>
<p class="docText"><a name="idd1e75146"></a><a name="idd1e75153"></a><a name="idd1e75160"></a><a name="idd1e75167"></a><a name="idd1e75174"></a><a name="idd1e75182"></a><a name="idd1e75189"></a><a name="idd1e75197"></a><a name="idd1e75204"></a><a name="idd1e75211"></a><a name="idd1e75218"></a>A real-world example of a priority queue is the line to check luggage at an airport. Those whose flight is going to leave within the next 30 minutes are generally moved to the front of the line so that they can finish the check-in process before their plane takes off. A programming example of a priority queue is the scheduler of an operating system determining which, of a number of waiting processes, should execute next.</p>
<p class="docText">To use either <tt>queue</tt> or <tt>priority_queue</tt>, we must include the <tt>queue</tt> header. <a class="docLink" href="#ch09table24">Table 9.24</a> lists the operations supported by <tt>queue</tt> and <tt>priority_queue</tt>.</p>
<a name="ch09table24"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 9.24. Operations Supported by Queues and Priority Queues</H5></caption><colgroup><col width="100"><col width="400"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>q.empty()</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns <tt>TRue</tt> if the <tt>queue</tt> is empty; false otherwise.</p></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>q.size()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns a count of the number of elements on the <tt>queue</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>q.pop()</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Removes, but does not return, the front element from the <tt>queue</tt>.</P></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>q.front()</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Returns, but does not remove, the front element on the <tt>queue</tt>.</p>
<p class="docText"><span class="docEmphStrong">This operation can be applied only to a <tt>queue</tt></span>.</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>q.back()</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Returns, but does not remove, the back element on the <tt>queue</tt>.</p>
<p class="docText"><span class="docEmphStrong">This operation can be applied only to a <tt>queue</tt></span>.</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>q.top()</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Returns, but does not remove, the highest-priority element.</p>
<p class="docText"><span class="docEmphStrong">This operation can be applied only to a <tt>priority_queue</tt>.</span></p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>q.push(item)</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Places a new element at the end of the <tt>queue</tt> or at its appropriate position based on priority in a <tt>priority_queue</tt>.</p></td></tr></table></p><br>
<a name="ch09sb19"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 9.7.2</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch09qa17q1"></a><B>Exercise 9.42:</b></td><TD><p class="docText">Write a program to read a series of words into a <tt>stack</tt>.</p>
</td></TR><TR valign="top"><td align="right" class="docText" width="50"><a name="ch09qa17q2"></a><b>Exercise 9.43:</b></td><td><p class="docText">Use a <tt>stack</tt> to process parenthesized expressions. When you see an open parenthesis, note that it was seen. When you see a close parenthesis after an open parenthesis, <tt>pop</tt> elements down to and including the open parenthesis off the <tt>stack</tt>. <tt>push</tt> a value onto the <tt>stack</tt> to indicate that a parenthesized expression was replaced.</p>
</TD></tr></table></P>
</blockquote>
</TD></tr></table></p><br>


<UL></UL></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch09lev1sec6.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch09lev1sec8.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>