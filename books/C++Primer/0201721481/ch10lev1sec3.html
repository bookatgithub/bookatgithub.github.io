<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 10.3.&nbsp; The map Type</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch10lev1sec2.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch10lev1sec4.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch10lev1sec3"></a>
<h3 class="docSection1Title">10.3. The <tt>map</tt> Type</h3>
<p class="docText"><a name="idd1e77269"></a><a name="idd1e77274"></a><a name="idd1e77279"></a><a name="idd1e77284"></a><a name="idd1e77290"></a><a name="idd1e77296"></a><a name="idd1e77302"></a><a name="idd1e77308"></a><a name="idd1e77314"></a><a name="idd1e77320"></a><a name="idd1e77326"></a><a name="idd1e77332"></a><a name="idd1e77338"></a><a name="idd1e77341"></a><a name="idd1e77347"></a><a name="idd1e77350"></a>A <tt>map</tt> is a collection of keyvalue pairs. The <tt>map</tt> type is often referred to as an <B><a name="ch10term1"></a><a class="docLink" href="ch10lev1sec8.html#gloss10_01">associative array</a></b>: It is like the built-in array type, in that the key can be used as an index to fetch a value. It is associative in that values are associated with a particular key rather than being fetched by position in the array.</P>
<a name="ch10lev2sec5"></a>
<h4 class="docSection2Title">10.3.1. Defining a <tt>map</tt></H4>
<p class="docText">To use a <b><a name="ch10term4"></a><a class="docLink" href="ch10lev1sec8.html#gloss10_04"><span class="docEmphStrong"><tt>map</tt></span></a></b>, we must include the <tt>map</tt> header. When we define a <tt>map</tt> object, we must indicate both the key and <b><a name="ch10term11"></a><a class="docLink" href="ch10lev1sec8.html#gloss10_11">value type</a></b>:</P>
<pre>
     // <span class="docEmphItalicAlt">count number of times each word occurs in the input</span>
     map&lt;string, int&gt; word_count; // <span class="docEmphItalicAlt">empty</span> <span class="docEmphasis">map</span> <span class="docEmphItalicAlt">from string to</span> <span class="docEmphasis">int</span>
</pre><BR>
<p class="docText">defines a <tt>map</tt> object <tt>word_count</tt> that is indexed by a <tt>string</tt> and that holds an associated <tt>int</tt> value.</p>
<a name="ch10table03"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 10.3. Constructors for <tt>map</tt></h5></caption><colgroup><col width="175"><col width="325"></colgroup><thead></thead><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>map&lt;k, v&gt; m;</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Create an empty <tt>map</tt> named <tt>m</tt> with key and value types <tt>k</tt> and <tt>v</tt>.</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>map&lt;k, v&gt; m(m2);</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Create <tt>m</tt> as a copy of <tt>m2</tt>; <tt>m</tt> and <tt>m2</tt> must have the same key and value types.</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>map&lt;k, v&gt; m(b, e);</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Create <tt>m</tt> as a copy of the elements from the range denoted by iterators <tt>b</tt> and <tt>e</tt>. Elements must have a type that can be converted to <tt>pair&lt;const k, v&gt;</tt>.</p></TD></tr></table></p><br>
<a name="ch10lev3sec1"></a>
<h5 class="docSection3Title">Constraints on the Key Type</h5>
<p class="docText">Whenever we use an associative container, its keys have not only a type, but also an associated comparison function. By default, the library uses the <tt>&lt;</tt> operator for the <span class="docEmphRoman"><a name="ch10term3"></a><a class="docLink" href="ch10lev1sec8.html#gloss10_03">key type</a></span> to compare the keys. <a class="docLink" href="ch15lev1sec8.html#ch15lev2sec23">Section 15.8.3</a> (p. <a class="docLink" href="ch15lev1sec8.html#ch15lev2sec23">605</a>) will show how we can override the default and provide our own function.</p>
<p class="docText">Whichever comparison function we use must define a <b><a name="ch10term10"></a><a class="docLink" href="ch10lev1sec8.html#gloss10_10">strict weak ordering</a></b> over the key type. We can think of a strict weak ordering as &quot;less than,&quot; although we might choose to define a more complicated comparison function. However we define it, such a comparison function must always yield false when we compare a key with itself. Moreover, if we compare two keys, they cannot both be &quot;less than&quot; each other, and if <tt>k1</tt> is &quot;less than&quot; <tt>k2</tt>, which in turn is &quot;less than&quot; <tt>k3</tt>, then <tt>k1</tt> must be &quot;less than&quot; <tt>k3</tt>. If we have two keys, neither of which is &quot;less than&quot; the other, the container will treat them as equal. When used as a key to a <tt>map</tt>, either value could be used to access the corresponding element.</p>
<a name="ch10note02"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> In practice, what's important is that the key type must define the <tt>&lt;</tt> operator and that that operator should &quot;do the right thing.&quot;</P></TD></tr></table><BR>
</p></div><br>
<p class="docText"><a name="idd1e77572"></a><a name="idd1e77577"></a><a name="idd1e77584"></a><a name="idd1e77591"></a>As an example, in our bookstore problem, we might add a type named <tt>ISBN</tt> that would encapsulate the rules for ISBNs. In our implementation, ISBNs are <tt>string</tt>s, which we can compare to determine which ISBN is less than another. Therefore, the ISBN type could support a <tt>&lt;</tt> operation. Given that we had such a type, we could define a <tt>map</tt> that would allow us to efficiently search for a particular book held by a bookstore.</P>
<pre>
     map&lt;ISBN, Sales_item&gt; bookstore;
</pre><BR>
<p class="docText">defines a <tt>map</tt> object named <tt>bookstore</tt> that is indexed by an <tt>ISBN</tt>. Each element in the <tt>map</tt> holds an associated instance of our <tt>Sales_item</tt> class.</p>
<a name="ch10note03"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> The key type needs to support only the <tt>&lt;</tt> operator. There is no requirement that it support the other relational or equality operators.</p></TD></TR></table><br>
</p></div><br>
<a name="ch10sb03"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<h2 class="docSidebarTitle">Exercises Section 10.3.1</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><td align="right" class="docText" width="50"><a name="ch10qa3q1"></a><b>Exercise 10.5:</b></TD><td><p class="docText">Define a <tt>map</tt> that associates words with a <tt>list</tt> of line numbers on which the word might occur.</p>
</TD></tr><TR valign="top"><td align="right" class="docText" width="50"><a name="ch10qa3q2"></a><b>Exercise 10.6:</b></td><td><p class="docText">Could we define a <tt>map</tt> from <tt>vector&lt;int&gt;::iterator to int</tt>? What about from <tt>list&lt;int&gt;::iterator</tt> to <tt>int</tt>? What about from <tt>pair&lt;int, string&gt;</tt> to <tt>int</tt>? In each case, if not, explain why not.</p>
</td></tr></table></p>
</blockquote>
</td></tr></table></p><br>


<a name="ch10lev2sec6"></a>
<h4 class="docSection2Title">10.3.2. Types Defined by <tt>map</tt></H4>
<p class="docText">The elements of a <tt>map</tt> are keyvalue pairs That is, each element has two parts: its key and the value associated with that key. The <tt>value_type</tt> for a <tt>map</tt> reflects this fact. This type is more complicated than those we've seen for other containers: <tt>value_type</tt> is a <tt>pair</tt> that holds the key and value of a given element. Moreover, the key is <tt>const</tt>. For example, the <tt>value_type</tt> of the <tt>word_count</tt> array is <tt>pair&lt;const string, int&gt;</tt>.</P>
<a name="ch10table04"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 10.4. Types Defined by the <tt>map</tt> Class</h5></caption><colgroup><col width="200"><col width="325"></colgroup><thead></thead><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>map&lt;K, V&gt;::key_type</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">The type of the keys used to index the <tt>map</tt>.</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>map&lt;K, V&gt;::mapped_type</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">The type of the values associated with the keys in the <tt>map</tt>.</p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>map&lt;K, V&gt;::value_type</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">A pair whose first element has type <tt>const</tt></P></td></tr><TR><td class="docTableCell" align="left" valign="top">&nbsp;</td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>map&lt;K, V&gt;::key_type</tt> and <tt>second</tt> has type</p></TD></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>map&lt;K, V&gt;::mapped_type</tt>.</p></td></tr></table></p><br>
<a name="ch10note04"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><TD valign="top"><p class="docText"> When learning the <tt>map</tt> interface, it is essential to remember that the <tt>value_type</tt> is a <tt>pair</tt> and that we can change the value but not the key member of that <tt>pair</tt>.</p></TD></tr></table><br>
</P></div><BR>
<a name="ch10lev3sec2"></a>
<h5 class="docSection3Title">Dereferencing a <tt>map</tt> Iterator Yields a <tt>pair</tt></h5>
<p class="docText"><a name="idd1e77866"></a><a name="idd1e77878"></a><a name="idd1e77891"></a><a name="idd1e77895"></a><a name="idd1e77901"></a><a name="idd1e77909"></a><a name="idd1e77916"></a><a name="idd1e77923"></a><a name="idd1e77930"></a><a name="idd1e77940"></a><a name="idd1e77948"></a><a name="idd1e77955"></a><a name="idd1e77962"></a><a name="idd1e77969"></a>When we dereference an iterator, we get a reference to a value of the container's <tt>value_type</tt>. In the case of <tt>map</tt>, the <tt>value_type</tt> is a <tt>pair</tt>:</p>
<pre>
     // <span class="docEmphItalicAlt">get an iterator to an element in</span> <span class="docEmphasis">word_count</span>
     map&lt;string, int&gt;::iterator map_it = word_count.begin();

     // <span class="docEmphasis">*map_it is</span> <span class="docEmphItalicAlt">a reference to a</span> <span class="docEmphasis">pair&lt;const string, int&gt;</span> <span class="docEmphItalicAlt">object</span>
     cout &lt;&lt; map_it-&gt;first;                  // <span class="docEmphItalicAlt">prints the key for this element</span>
     cout &lt;&lt; " " &lt;&lt; map_it-&gt;second;          // <span class="docEmphItalicAlt">prints the value of the element</span>
     map_it-&gt;first = "new key";              // <span class="docEmphItalicAlt">error: key is</span> <span class="docEmphasis">const</span>
     ++map_it-&gt;second;     // <span class="docEmphItalicAlt">ok: we can change value through an iterator</span>
</pre><br>
<p class="docText">Dereferencing the iterator yields a <tt>pair</tt> object in which <tt>first</tt> member holds the <tt>const</tt> key and <tt>second</tt> member holds the value.</p>

<a name="ch10lev3sec3"></a>
<H5 class="docSection3Title">Additional <tt>map</tt> Typedefs</h5>
<p class="docText">The <tt>map</tt> class defines two additional types, <tt>key_type</tt> and <B><a name="ch10term5"></a><a class="docLink" href="ch10lev1sec8.html#gloss10_05"><span class="docEmphStrong"><tt>mapped_type</tt></span></a></b>, that let us access the type of either the key or the value. For <tt>word_count</tt>, the <tt>key_type</tt> is <tt>string</tt> and <tt>mapped_type</tt> is <tt>int</tt>. As with the sequential containers (<a class="docLink" href="ch09lev1sec3.html#ch09lev2sec6">Section 9.3.1</a>, p. <a class="docLink" href="ch09lev1sec3.html#ch09lev2sec6">317</a>), we use the scope operator to fetch a type memberfor example, <tt>map&lt;string, int&gt;::key_type</tt>.</P>
<a name="ch10sb04"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Exercises Section 10.3.2</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa4q1"></a><b>Exercise 10.7:</b></TD><td><p class="docText">What are the <tt>mapped_type, key_type</tt>, and <tt>value_type</tt> of a <tt>map</tt> from <tt>int</tt> to <tt>vector&lt;int&gt;?</tt></p>
</TD></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch10qa4q2"></a><b>Exercise 10.8:</b></TD><td><p class="docText">Write an expression using a <tt>map</tt> iterator to assign a value to an element.</p>
</td></tr></table></p>
</blockquote>
</td></tr></table></p><br>


<a name="ch10lev2sec7"></a>
<h4 class="docSection2Title">10.3.3. Adding Elements to a <tt>map</tt></h4>
<p class="docText">Once the <tt>map</tt> is defined, the next step is to populate it with the keyvalue element pairs. We can do so either by using the <tt>insert</tt> member or by fetching an element using the subscript operator and then assigning a value to the element returned. In both cases, the fact that there can be only a single element for a given key affects the behavior of these operations.</p>

<a name="ch10lev2sec8"></a>
<h4 class="docSection2Title">10.3.4. Subscripting a <tt>map</tt></H4>
<p class="docText">When we write</P>
<pre>
     map &lt;string, int&gt; word_count; // <span class="docEmphItalicAlt">empty</span> <span class="docEmphasis">map</span>

     // <span class="docEmphItalicAlt">insert default initialzed element with key</span> <span class="docEmphasis">Anna;</span> <span class="docEmphItalicAlt">then assign 1 to its value</span>
     word_count["Anna"] = 1;
</pre><br>
<p class="docText"><a name="idd1e78200"></a><a name="idd1e78208"></a><a name="idd1e78214"></a><a name="idd1e78228"></a><a name="idd1e78233"></a><a name="idd1e78242"></a><a name="idd1e78249"></a>the following steps take place:</P>
<a name="ch10pro01"></a>




<table border="0" class="docText"><tr><td width="25" valign="top"><div class="docText"><B>1. </b></div></TD><td><div class="docText"><tt>word_count</tt> is searched for the element whose key is <tt>Anna</tt>. The element is not found.<br><br></div></td></tr><TR><td width="25" valign="top"><div class="docText"><B>2. </b></div></TD><td><div class="docText">A new keyvalue pair is inserted into <tt>word_count</tt>. The key is a <tt>const string</tt> holding <tt>Anna</tt>. The value is value initialized, meaning in this case that the value is 0.<br><br>
</div></TD></TR><tr><td width="25" valign="top"><div class="docText"><b>3. </b></div></td><TD><div class="docText">The new keyvalue pair is inserted into <tt>word_count</tt>.<br><br>
</div></TD></tr><tr><TD width="25" valign="top"><div class="docText"><b>4. </b></div></TD><td><div class="docText">The newly inserted element is fetched and is given the value 1.<br><br>
</div></td></tr></table>
<a name="ch10note05"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> Subscripting a <tt>map</tt> behaves quite differently from subscripting an array or <tt>vector</tt>: Using an index that is not already present <span class="docEmphasis">adds</span> an element with that index to the <tt>map</tt>.</p></td></tr></table><BR>
</P></div><br>
<p class="docText">As with other subscript operators, the <tt>map</tt> subscript takes an index (that is, a key) and fetches the value associated with that key. When we look for a key that is already in the <tt>map</tt>, then the behavior is the same for a <tt>map</tt> subscript or a <tt>vector</tt> subscript: The value associated with the key is returned. For <tt>map</tt>s only, if the key is not already present, <span class="docEmphasis">a new element is created and inserted</span> into the <tt>map</tt> for that key. The associated value is value-initialized: An element of class type is initialized using the default constructor for the element type; a built-in type is initialized to 0.</P>
<a name="ch10lev3sec4"></a>
<h5 class="docSection3Title">Using the Value Returned from a Subscript Operation</h5>
<p class="docText">As usual, the subscript operator returns an lvalue. The lvalue it returns is the value associated with the key. We can read or write the element:</P>
<pre>
     cout &lt;&lt; word_count["Anna"]; // <span class="docEmphItalicAlt">fetch element indexed by</span> <span class="docEmphasis">Anna;</span> <span class="docEmphItalicAlt">prints</span> 1
     ++word_count["Anna"];       // <span class="docEmphItalicAlt">fetch the element and add one to it</span>
     cout &lt;&lt; word_count["Anna"]; // <span class="docEmphItalicAlt">fetch the element and print it; prints</span> <span class="docEmphasis">2</span>
</pre><BR>
<a name="ch10note06"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> Unlike <tt>vector</tt> or <tt>string</tt>, the type returned by <tt>map</tt> subscript operator differs from the type obtained by dereferencing a <tt>map</tt> iterator.</P></td></TR></table><BR>
</p></div><br>
<p class="docText">As we've seen, a <tt>map</tt> iterator returns a <tt>value_type</tt>, which is a <tt>pair</tt> that contains a <tt>const key_type</tt> and <tt>mapped_type;</tt> the subscript operator returns a value of type <tt>mapped_type</tt>.</p>

<a name="ch10lev3sec5"></a>
<H5 class="docSection3Title">Programming Implications of the Subscript Behavior</H5>
<p class="docText">The fact that subscript adds an element if it is not already in the <tt>map</tt> allows us to write surprisingly succinct programs:</p>
<pre>
     // <span class="docEmphItalicAlt">count number of times each word occurs in the input</span>
     map&lt;string, int&gt; word_count; // <span class="docEmphItalicAlt">empty</span> <span class="docEmphasis">map</span> <span class="docEmphItalicAlt">from string to</span> <span class="docEmphasis">int</span>
     string word;
     while (cin &gt;&gt; word)
       ++word_count[word];
</pre><br>
<p class="docText"><a name="idd1e78447"></a><a name="idd1e78453"></a><a name="idd1e78460"></a>This program creates a <tt>map</tt> that keeps track of how many times each word occurs. The <tt>while</tt> loop reads the standard input one word at a time. Each time it reads a new word, it uses that word to index <tt>word_count</tt>. If <tt>word</tt> is already in the <tt>map</tt>, then its value is incremented.</p>
<p class="docText">The interesting part is what happens when a word is encountered for the first time: A new element indexed by <tt>word</tt>, with an initial value of zero, is created and inserted into <tt>word_count</tt>. The value of that element is immediately incremented so that each time we insert a new word into the <tt>map</tt> it starts off with an occurrence count of one.</p>
<a name="ch10sb05"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Exercises Section 10.3.4</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><td align="right" class="docText" width="50"><a name="ch10qa5q1"></a><B>Exercise 10.9:</b></td><td><p class="docText">Write a program to count and print the number of times each word occurs in the input.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa5q2"></a><b>Exercise 10.10:</b></td><td><p class="docText">What does the following program do?</p>
<pre>
     map&lt;int, int&gt; m;
     m[0] = 1;
</pre><br>
<p class="docText">Contrast the behavior of the previous program with this one:</p>
<pre>
     vector&lt;int&gt; v;
     v[0] = 1;
</pre><BR>
</TD></tr><TR valign="top"><td align="right" class="docText" width="50"><a name="ch10qa5q3"></a><b>Exercise 10.11:</b></TD><TD><p class="docText">What type can be used to subscript a <tt>map</tt>? What type does the sub-script operator return? Give a concrete examplethat is, define a <tt>map</tt> and then write the types that could be used to subscript the <tt>map</tt> and the type that would be returned from the subscript operator.</p>
</td></tr></table></p>
</blockquote>
</td></TR></table></p><BR>


<a name="ch10lev2sec9"></a>
<H4 class="docSection2Title">10.3.5. Using <tt>map::insert</tt></h4>
<p class="docText">The <tt>insert</tt> members operate similarly to the operations on sequential containers (<a class="docLink" href="ch09lev1sec3.html#ch09lev2sec8">Section 9.3.3</a>, p. <a class="docLink" href="ch09lev1sec3.html#ch09lev2sec8">318</a>), with one important caveat: We must account for the effect of the key. The key impacts the argument types: The versions that insert a single element take a value that is a keyvalue <tt>pair</tt>. Similarly, for the version that takes an iterator pair, the iterators must refer to elements that are keyvalue <tt>pair</tt>s. The other difference is the return type from the version of <tt>insert</tt> that takes a single value, which we will cover in the remainder of this section.</p>
<a name="ch10lev3sec6"></a>
<h5 class="docSection3Title">Using <tt>insert</tt> Instead of Subscripting</H5>
<p class="docText">When we use a subscript to add an element to a <tt>map</tt>, the value part of the element is value-initialized. Often we immediately assign to that value, which means that we've initialized and assigned the same object. Alternatively, we could insert the element directly by using the syntactically more intimidating <tt>insert</tt> member:</P>
<pre>
     // <span class="docEmphItalicAlt">if</span> <span class="docEmphasis">Anna</span> <span class="docEmphItalicAlt">not already in</span> <span class="docEmphasis">word_count</span>, <span class="docEmphItalicAlt">inserts new element with value</span> <span class="docEmphasis">1</span>
     word_count.insert(map&lt;string, int&gt;::value_type("Anna", 1));
</pre><br>
<a name="ch10table05"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 10.5. <tt>insert</tt> Operations on maps</h5></caption><colgroup><col width="150"><col width="350"></colgroup><thead></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><a name="idd1e78653"></a><a name="idd1e78661"></a><a name="idd1e78669"></a><tt>m.insert(e)</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>e</tt> is a value of the <tt>value_type</tt> for <tt>m</tt>. If the key(<tt>e.first)</tt> is not in <tt>m</tt>, inserts a new element with value <tt>e.second</tt>. If the key is in <tt>m</tt>, then <tt>m</tt> is unchanged. Returns a <tt>pair</tt> containing a <tt>map</tt> iterator referring to the element with key <tt>e.first</tt> and a <tt>bool</tt> indicating whether the element was inserted or not.</p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>m.insert(beg, end)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>beg</tt> and <tt>end</tt> are iterators that denote a range of values that are keyvalue <tt>pair</tt>s with the same type as <tt>m</tt>'s <tt>value_type</tt>. For each element in the range, if the given key is not already in <tt>m</tt>, it inserts the key and its associated value into <tt>m</tt>. Returns <tt>void</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>m.insert(iter, e)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>e is</tt> a value of the <tt>value_type</tt> for <tt>m</tt>. If the key(<tt>e.first)</tt> is not in <tt>m</tt>, inserts the new element using the iterator <tt>iter</tt> as a hint for where to begin the search for where the new element should be stored. Returns an iterator that refers to the element in <tt>m</tt> with given key.</p></TD></TR></table></p><BR>
<p class="docText">The argument to this version of <tt>insert</tt></p>
<pre>
     map&lt;string, int&gt;::value_type(anna, 1)
</pre><br>
<p class="docText">is a newly created <tt>pair</tt> that is directly inserted into the <tt>map</tt>. Remember that <tt>value_type</tt> is a synonym for the type <tt>pair&lt;const K, V&gt;</tt>, where <tt>K</tt> is the key type and <tt>V</tt> is the type of the associated value. The argument to <tt>insert</tt> constructs a new object of the appropriate <tt>pair</tt> type to insert into the <tt>map</tt>. By using <tt>insert</tt>, we can avoid the extraneous initialization of the value that happens when we insert a new <tt>map</tt> element as a side-effect of using a subscript.</P>
<p class="docText">The argument to <tt>insert</tt> is fairly unwieldy. There are two ways to simplify it. We might use <tt>make_pair:</tt></P>
<pre>
     word_count.insert(make_pair("Anna", 1));
</pre><br>
<p class="docText">Or use a typedef:</p>
<pre>
     typedef map&lt;string,int&gt;::value_type valType;
     word_count.insert(valType("Anna", 1));
</pre><br>
<p class="docText">Either approach improves readability by making the call less complicated.</p>

<a name="ch10lev3sec7"></a>
<h5 class="docSection3Title">Testing the Return from <tt>insert</tt></H5>
<p class="docText">There can be only one element with a given key in a <tt>map</tt>. If we attempt to <tt>insert</tt> an element with a key that is already in the <tt>map</tt>, then <tt>insert</tt> does nothing. The versions of <tt>insert</tt> that take an iterator or iterator pair do not indicate whether or how many elements were inserted.</p>
<p class="docText">However, the version of <tt>insert</tt> that takes a single keyvalue <tt>pair</tt> does return a value. That value is a <tt>pair</tt> that contains an iterator that refers to the element in the <tt>map</tt> with the corresponding key, and a <tt>bool</tt> that indicates whether the element was inserted. If the key is already in the <tt>map</tt>, then the value is unchanged, and the <tt>bool</tt> portion of the return is <tt>false</tt>. If the key isn't present, then the element is inserted and the <tt>bool</tt> is <tt>TRue</tt>. In either case, the iterator refers to the element with the given key. We could rewrite our word count program to use <tt>insert</tt>:</P>
<pre>
     // <span class="docEmphItalicAlt">count number of times each word occurs in the input</span>
     map&lt;string, int&gt; word_count; // <span class="docEmphItalicAlt">empty</span> <span class="docEmphasis">map</span> <span class="docEmphItalicAlt">from string to</span> <span class="docEmphasis">int</span>
     string word;
     while (cin &gt;&gt; word) {
         // <span class="docEmphItalicAlt">inserts element with key equal to</span> <span class="docEmphasis">word</span> <span class="docEmphItalicAlt">and value</span> 1;
         // <span class="docEmphItalicAlt">if</span> <span class="docEmphasis">word</span> <span class="docEmphItalicAlt">already in</span> <span class="docEmphasis">word_count</span>, <span class="docEmphItalicAlt">insert</span> <span class="docEmphItalicAlt">does nothing</span>
         pair&lt;map&lt;string, int&gt;::iterator, bool&gt; ret =
                   word_count.insert(make_pair(word, 1));
         if (!ret.second)          // <span class="docEmphasis">word</span> <span class="docEmphItalicAlt">already in</span> <span class="docEmphasis">word_count</span>
             ++ret.first-&gt;second;  // <span class="docEmphItalicAlt">increment counter</span>
     }
</pre><br>
<p class="docText">For each <tt>word</tt>, we attempt to <tt>insert</tt> it with a value 1. The <tt>if</tt> test examines the <tt>bool</tt> in the return from the <tt>insert</tt>. If it is <tt>false</tt>, then the insertion didn't happen and an element indexed by <tt>word</tt> was already in <tt>word_count</tt>. In this case we increment the value associated with that element.</p>

<a name="ch10lev3sec8"></a>
<h5 class="docSection3Title">Unwinding the Syntax</H5>
<p class="docText">The definition of <tt>ret</tt> and the increment may be hard to decipher:</P>
<pre>
     pair&lt;map&lt;string, int&gt;::iterator, bool&gt; ret =
             word_count.insert(make_pair(word, 1));
</pre><br>
<p class="docText">It should be easy to see that we're defining a <tt>pair</tt> and that the second type of the <tt>pair</tt> is <tt>bool</tt>. The first type of that <tt>pair</tt> is a bit harder to understand. It is the <tt>iterator</tt> type defined by the <tt>map&lt;string, int&gt;</tt> type.</p>
<p class="docText">We can understand the increment by first parenthesizing it to reflect the precedence (<a class="docLink" href="ch05lev1sec10.html#ch05lev2sec14">Section 5.10.1</a>, p. <a class="docLink" href="ch05lev1sec10.html#ch05lev2sec14">168</a>) of the operators:</p>
<pre>
     ++((ret.first)-&gt;second); // <span class="docEmphItalicAlt">equivalent expression</span>
</pre><br>
<p class="docText">Explaining this expression step by step, we have</P>
<ul><li><p class="docList"><tt>ret</tt> holds return value from <tt>insert</tt>, which is a <tt>pair</tt>. The <tt>first</tt> member of that <tt>pair</tt> is a <tt>map</tt> iterator referring to the key that was inserted.</P></li><li><p class="docList"><tt>ret.first</tt> fetches the <tt>map</tt> iterator from the <tt>pair</tt> returned by <tt>insert</tt>.</P></li><LI><p class="docList"><tt>ret.first-&gt;second</tt> dereferences that iterator obtaining a <tt>value_type</tt> object. That object is also a <tt>pair</tt>, in which the <tt>second</tt> member is the value part of the element we added.</p></li><li><p class="docList"><tt>++ret.first-&gt;second</tt> increments that value.</p></li></ul>
<p class="docText">Putting it back together, the increment statement fetches the iterator for the element indexed by <tt>word</tt> and increments the value part of that element.</p>
<a name="ch10sb06"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 10.3.5</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch10qa6q1"></a><b>Exercise 10.12:</b></TD><td><p class="docText"><a name="idd1e79158"></a><a name="idd1e79165"></a>Rewrite the word-count program that you wrote in the exercises for <a class="docLink" href="#ch10lev2sec8">Section 10.3.4</a> (p. <a class="docLink" href="#ch10lev2sec8">364</a>) to use <tt>insert</tt> instead of subscripting. Explain which program you think is easier to write and read. Explain your reasoning.</p>
</TD></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa6q2"></a><b>Exercise 10.13:</b></td><td><p class="docText">Given a <tt>map&lt;string, vector&lt;int&gt; &gt;</tt>, write the types used as an argument and as the return value for the version of <tt>insert</tt> that inserts one element.</P>
</td></TR></table></P>
</blockquote>
</td></tr></table></p><BR>


<a name="ch10lev2sec10"></a>
<H4 class="docSection2Title">10.3.6. Finding and Retrieving a <tt>map</tt> Element</h4>
<p class="docText">The subscript operator provides the simplest method of retrieving a value:</p>
<pre>
     map&lt;string,int&gt; word_count;
     int occurs = word_count["foobar"];
</pre><br>
<p class="docText">As we've seen, using a subscript has an important side effect: If that key is not already in the <tt>map</tt>, then subscript inserts an element with that key.</p>
<p class="docText">Whether this behavior is correct depends on our expectations. In this example, if &quot;foobar&quot; weren't already present, it would be added to the <tt>map</tt> with an associated value of 0. In this case, <tt>occurs</tt> gets a value of 0.</P>
<p class="docText">Our word-counting programs relied on the fact that subscripting a nonexistent element inserts that element and initializes the value to 0. There are times, though, when we want to know if an element is present but do not want the element inserted if it is not present. In such cases, we cannot use the subscript operator to determine whether the element is present.</p>
<p class="docText">There are two operations, <tt>count</tt> and <tt>find</tt>, that we can use to determine if a key is present without causing it to be inserted.</p>
<a name="ch10table06"></a><P><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 10.6. Interrogating a <tt>map</tt> Without Changing It</h5></caption><colgroup><col width="150"><col width="350"></colgroup><thead></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>m.count(k)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns the number of occurrences of <tt>k</tt> within <tt>m</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>m.find(k)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns an iterator to the element indexed by <tt>k</tt>, if there is one, or returns an off-the-end iterator (<a class="docLink" href="ch03lev1sec4.html#ch03lev1sec4">Section 3.4</a>, p. <a class="docLink" href="ch03lev1sec4.html#ch03lev1sec4">97</a>) if the key is not present.</p></td></tr></table></P><BR>
<a name="ch10lev3sec9"></a>
<h5 class="docSection3Title">Using <tt>count</tt> to Determine Whether a Key is in the <tt>map</tt></H5>
<p class="docText">The <tt>count</tt> member for a <tt>map</tt> always returns either 0 or 1. A <tt>map</tt> may have only one instance of any given key, so <tt>count</tt> effectively indicates whether the key is present. The return from <tt>count</tt> is more useful for <tt>multimaps</tt>, which we cover in <a class="docLink" href="ch10lev1sec5.html#ch10lev1sec5">Section 10.5</a> (p. <a class="docLink" href="ch10lev1sec5.html#ch10lev1sec5">375</a>). If the return value is nonzero, we can use the subscript operator to fetch the value associated with the key without worrying that doing so will insert the element into the <tt>map</tt>:</p>
<pre>
     int occurs = 0;
     if (word_count.count("foobar"))
         occurs = word_count["foobar"];
</pre><br>
<p class="docText"><a name="idd1e79358"></a><a name="idd1e79365"></a><a name="idd1e79372"></a><a name="idd1e79379"></a>Of course, executing <tt>count</tt> followed by the subscript effectively looks for the element twice. If we want to use the element if it is present, we should use <tt>find</tt>.</P>

<a name="ch10lev3sec10"></a>
<H5 class="docSection3Title">Retrieving an Element Without Adding It</h5>
<p class="docText">The <tt>find</tt> operation returns an iterator to the element or the <tt>end</tt> iterator if the element is not present:</p>
<pre>
     int occurs = 0;
     map&lt;string,int&gt;::iterator it = word_count.find("foobar");
     if (it != word_count.end())
         occurs = it-&gt;second;
</pre><br>
<p class="docText">We should use <tt>find</tt> when we want to obtain a reference to the element with the specified key if it exists, and do not want to create the element if it does not exist.</p>
<a name="ch10sb07"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<H2 class="docSidebarTitle">Exercises Section 10.3.6</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa7q1"></a><B>Exercise 10.14:</b></TD><td><p class="docText">What is the difference between the <tt>map</tt> operations <tt>count</tt> and <tt>find</tt>?</p>
</td></tr><TR valign="top"><td align="right" class="docText" width="50"><a name="ch10qa7q2"></a><b>Exercise 10.15:</b></TD><td><p class="docText">What kinds of problems would you use <tt>count</tt> to solve? When might you use <tt>find</tt> instead?</p>
</TD></tr><TR valign="top"><td align="right" class="docText" width="50"><a name="ch10qa7q3"></a><b>Exercise 10.16:</b></td><td><p class="docText">Define and initialize a variable to hold the result of a call to <tt>find</tt> on a <tt>map</tt> from <tt>string</tt> to <tt>vector</tt> of <tt>int</tt>.</p>
</td></tr></table></p>
</blockquote>
</td></tr></table></p><br>


<a name="ch10lev2sec11"></a>
<h4 class="docSection2Title">10.3.7. Erasing Elements from a <tt>map</tt></H4>
<p class="docText">There are three variants of the <tt>erase</tt> operation to remove elements from a <tt>map</tt>. As with the sequential containers, we can <tt>erase</tt> a single element or a range of elements by passing <tt>erase</tt> an iterator or an iterator pair. These versions of <tt>erase</tt> are similar to the corresponding operations on sequential containers with one exception: The <tt>map</tt> operations return <tt>void</tt>, whereas those on the sequential containers return an iterator to the element following the one that was removed.</P>
<p class="docText">The <tt>map</tt> type supplies an additional <tt>erase</tt> operation that takes a value of the <tt>key_type</tt> and removes the element with the given key if the element exists. We could use this version to remove a specific word from <tt>word_count</tt> before printing the results:</p>
<pre>
     // <span class="docEmphItalicAlt">erase of a key returns number of elements removed</span>
     if (word_count.erase(removal_word))
          cout &lt;&lt; "ok: " &lt;&lt; removal_word &lt;&lt; " removed\n";
     else cout &lt;&lt; "oops: " &lt;&lt; removal_word &lt;&lt; " not found!\n";
</pre><BR>
<p class="docText">The <tt>erase</tt> function returns a count of how many elements were removed. In the case of a <tt>map</tt>, that number is either zero or one. If the return value is zero, then the element we wanted to erase was not in the <tt>map</tt>.</p>
<a name="ch10table07"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 10.7. Removing Elements from a <tt>map</tt></H5></caption><colgroup><col width="150"><col width="350"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><a name="idd1e79581"></a><a name="idd1e79587"></a><a name="idd1e79594"></a><a name="idd1e79601"></a><a name="idd1e79608"></a><a name="idd1e79615"></a><tt>m.erase(k)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Removes the element with key <tt>k</tt> from <tt>m</tt>. Returns <tt>size_type</tt> indicating the number of elements removed.</P></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>m.erase(p)</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Removes element referred to by the iterator <tt>p</tt> from <tt>m</tt>. <tt>p</tt> must refer to an actual element in <tt>m</tt>; it must not be equal to <tt>m.end()</tt>. Returns <tt>void</tt>.</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>m.erase(b, e)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Removes the elements in the range denoted by the iterator pair <tt>b, e</tt>. <tt>b</tt> and <tt>e</tt> must be a valid range of elements in <tt>m</tt>: <tt>b</tt> and <tt>e</tt> must refer to elements in <tt>m</tt> or one past the last element in <tt>m</tt>. <tt>b</tt> and <tt>e</tt> must either be equalin which case the range is emptyor the element to which <tt>b</tt> refers must occur before the element referred to by <tt>e</tt>. Returns <tt>void</tt>.</P></td></tr></table></P><br>

<a name="ch10lev2sec12"></a>
<H4 class="docSection2Title">10.3.8. Iterating across a <tt>map</tt></h4>
<p class="docText">Like any other container, <tt>map</tt> provides <tt>begin</tt> and <tt>end</tt> operations that yield iterators that we can use to traverse the <tt>map</tt>. For example, we could print the <tt>map</tt> named <tt>word_count</tt> that we built on page <a class="docLink" href="#ch10note05">363</a> as follows:</p>
<pre>
     // <span class="docEmphItalicAlt">get iterator positioned on the first element</span>
     map&lt;string, int&gt;::const_iterator
                             map_it = word_count.begin();
     // <span class="docEmphItalicAlt">for each element in the</span> <span class="docEmphasis">map</span>
     while (map_it != word_count.end()) {
         // <span class="docEmphItalicAlt">print the element key, value pairs</span>
         cout &lt;&lt; map_it-&gt;first &lt;&lt; " occurs "
              &lt;&lt; map_it-&gt;second &lt;&lt; " times" &lt;&lt; endl;
         ++map_it; // <span class="docEmphItalicAlt">increment iterator to denote the next element</span>
     }
</pre><br>
<p class="docText">The <tt>while</tt> condition and increment for the iterator in this loop look a lot like the programs we wrote that printed the contents of a <tt>vector</tt> or a <tt>string</tt>. We initialize an iterator, <tt>map_it</tt>, to refer to the first element in <tt>word_count</tt>. As long as the iterator is not equal to the <tt>end</tt> value, we print the current element and then increment the iterator. The body of the loop is more complicated than those earlier programs because we must print both the key and value for each element.</p>
<a name="ch10note07"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> The output of our word-count program prints the words in alphabetical order. When we use an iterator to traverse a <tt>map</tt>, the iterators yield elements in ascending key order.</p></td></tr></table><br>
</P></div><BR>

<a name="ch10lev2sec13"></a>
<h4 class="docSection2Title">10.3.9. A Word Transformation Map</H4>
<p class="docText">We'll close this section with a program to illustrate creating, searching, and iterating across a <tt>map</tt>. Our problem is to write a program that, given one <tt>string</tt>, transforms it into another. The input to our program is two files. The first file contains several word pairs. The first word in the pair is one that might be in the input <a name="idd1e79823"></a><a name="idd1e79829"></a><a name="idd1e79834"></a><a name="idd1e79839"></a><a name="idd1e79842"></a><a name="idd1e79849"></a>string. The second is the word to use in the output. Essentially, this file provides a set of word transformationswhen we find the first word, we should replace it by the second. The second file contains the text to transform. If the contents of the word transformation file is</p>
<P><table cellspacing="0" FRAME="void" RULES="none" cellpadding="5"><colgroup><col width="200"><col width="300"></colgroup><thead></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphStrong"><tt>'em</tt></span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphStrong"><tt>them</tt></span></p></TD></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphStrong"><tt>cuz</tt></span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphStrong"><tt>because</tt></span></P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphStrong"><tt>gratz</tt></span></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphStrong"><tt>grateful</tt></span></p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphStrong"><tt>i</tt></span></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphStrong"><tt>I</tt></span></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphStrong"><tt>nah</tt></span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphStrong"><tt>no</tt></span></p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphStrong"><tt>pos</tt></span></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphStrong"><tt>supposed</tt></span></p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphStrong"><tt>sez</tt></span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphStrong"><tt>said</tt></span></p></TD></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphStrong"><tt>tanx</tt></span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphStrong"><tt>thanks</tt></span></P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphStrong"><tt>wuz</tt></span></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphStrong"><tt>was</tt></span></p></TD></tr></table></p><BR>
<p class="docText">and the text we are given to transform is</p>
<pre>
     <span class="docEmphStrong">nah i sez tanx cuz i wuz pos to</span>
     <span class="docEmphStrong">not cuz i wuz gratz</span>
</pre><BR>
<p class="docText">then the program should generate the following output:</p>
<pre>
     <span class="docEmphStrong">no I said thanks because I was supposed to</span>
     <span class="docEmphStrong">not because I was grateful</span>
</pre><br>
<a name="ch10lev3sec11"></a>
<h5 class="docSection3Title">The Word Transformation Program</h5>
<p class="docText">Our solution, which appears on the next page, stores the word transformation file in a <tt>map</tt>, using the word to be replaced as the key and the word to use as the replacement as its corresponding value. We then read the input, looking up each word to see if it has a transformation. If so, we do the transformation and then print the transformed word. If not, we print the original word.</p>
<p class="docText">Our <tt>main</tt> program takes two arguments (<a class="docLink" href="ch07lev1sec2.html#ch07lev2sec11">Section 7.2.6</a>, p. <a class="docLink" href="ch07lev1sec2.html#ch07lev2sec11">243</a>): the name of the word transformation file and the name of the file to transform. We start by checking the number of arguments. The first argument, <tt>argv[0]</tt>, is always the name of the command. The file names will be in <tt>argv[1]</tt> and <tt>argv[2]</tt>.</p>
<p class="docText">Once we know that <tt>argv[1]</tt> is valid, we call <tt>open_file</tt> (<a class="docLink" href="ch08lev1sec4.html#ch08lev2sec12">Section 8.4.3</a>, p. <a class="docLink" href="ch08lev1sec4.html#ch08lev2sec12">299</a>) to <tt>open</tt> the word transformation file. Assuming the <tt>open</tt> succeeded, we read the transformation pairs. We call <tt>insert</tt> using the first word as the key and the second as the value. When the <tt>while</tt> concludes, <tt>trans_map</tt> contains the data we need to transform the input. If there's a problem with the arguments, we <tt>throw</tt> (<a class="docLink" href="ch06lev1sec13.html#ch06lev1sec13">Section 6.13</a>, p. <a class="docLink" href="ch06lev1sec13.html#ch06lev1sec13">215</a>) an exception and exit the program.</p>
<p class="docText">Next, we call <tt>open_file</tt> to open the file we want to transform. The second <tt>while</tt> uses <tt>getline</tt> to read that file a line at a time. We read by line so that our output will have line breaks at the same position as our input file. To get the words from each line we use a nested <tt>while</tt> loop that uses an <tt>istringstream</tt>. This part of the program is similar to the sketch we wrote on page <a class="docLink" href="ch08lev1sec5.html#ch08lev2sec13">300</a>.</p>
<p class="docText">The inner <tt>while</tt> checks each word to see if it is in the transformation map. If it is, then we replace the word by its corresponding value from the <tt>map</tt>. Finally, we print the word, transformed or not. We use the <tt>bool firstword</tt> to determine whether to print a space. If it is the first word in the line, we don't print a space.</p>
<pre>
    /*
     * <span class="docEmphItalicAlt">A program to transform words.</span>
     * <span class="docEmphItalicAlt">Takes two arguments: The first is name of the word transformation file</span>
     *                      <span class="docEmphItalicAlt">The second is name of the input to transform</span>
     */
    int main(int argc, char **argv)
    {
        // <span class="docEmphasis">map</span> <span class="docEmphItalicAlt">to hold the word transformation pairs:</span>
        // <span class="docEmphasis">key</span> <span class="docEmphItalicAlt">is the word to look for in the input;</span> value <span class="docEmphasis">is word to use in the output</span>
        map&lt;string, string&gt; trans_map;
        string key, value;
        if (argc != 3)
            throw runtime_error("wrong number of arguments");
        // <span class="docEmphItalicAlt">open transformation file and check that open succeeded</span>
        ifstream map_file;
        if (!open_file(map_file, argv[1]))
            throw runtime_error("no transformation file");
        // <span class="docEmphItalicAlt">read the transformation map and build the map</span>
         while (map_file &gt;&gt; key &gt;&gt; value)
             trans_map.insert(make_pair(key, value));
        // <span class="docEmphItalicAlt">ok, now we're ready to do the transformations</span>
        // <span class="docEmphItalicAlt">open the input file and check that the open succeeded</span>
        ifstream input;
        if (!open_file(input, argv[2]))
            throw runtime_error("no input file");
        string line;    // <span class="docEmphItalicAlt">hold each line from the input</span>
        // <span class="docEmphItalicAlt">read the text to transform it a line at a time</span>
        while (getline(input, line)) {
            istringstream stream(line);   // <span class="docEmphItalicAlt">read the line a word at a time</span>
            string word;
            bool firstword = true;   // <span class="docEmphItalicAlt">controls whether a space is printed</span>
            while (stream &gt;&gt; word) {
               // <span class="docEmphItalicAlt">ok: the actual mapwork, this part is the heart of the program</span>
               map&lt;string, string&gt;::const_iterator map_it =
                                  trans_map.find(word);
               // <span class="docEmphItalicAlt">if this word is in the transformation map</span>
               if (map_it != trans_map.end())
                   // <span class="docEmphItalicAlt">replace it by the transformation value in the map</span>
                   word = map_it-&gt;second;
               if (firstword)
                   firstword = false;
               else
                   cout &lt;&lt; " ";  // <span class="docEmphItalicAlt">print space between words</span>
               cout &lt;&lt; word;
            }
            cout &lt;&lt; endl;        // <span class="docEmphItalicAlt">done with this line of input</span>
    }
    return 0;
 }
</pre><br>
<a name="ch10sb08"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<h2 class="docSidebarTitle">Exercises Section 10.3.9</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch10qa8q1"></a><B>Exercise 10.17:</b></td><td><p class="docText"><a name="idd1e80223"></a><a name="idd1e80230"></a><a name="idd1e80237"></a><a name="idd1e80244"></a><a name="idd1e80251"></a><a name="idd1e80258"></a><a name="idd1e80265"></a><a name="idd1e80271"></a><a name="idd1e80278"></a><a name="idd1e80286"></a><a name="idd1e80293"></a><a name="idd1e80299"></a><a name="idd1e80306"></a><a name="idd1e80313"></a><a name="idd1e80320"></a><a name="idd1e80327"></a><a name="idd1e80334"></a>Our transformation program uses <tt>find</tt> to look for each word:</p>
<pre>
     map&lt;string, string&gt;::const_iterator map_it =
              trans_map.find(word);
</pre><br>
<p class="docText">Why do you suppose the program uses <tt>find</tt>? What would happen if it used the subscript operator instead?</p>
</TD></tr><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch10qa8q2"></a><b>Exercise 10.18:</b></td><td><p class="docText">Define a <tt>map</tt> for which the key is the family surname and the value is a <tt>vector</tt> of the children's names. Populate the <tt>map</tt> with at least six entries. Test it by supporting user queries based on a surname, which should list the names of children in that family.</P>
</TD></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa8q3"></a><b>Exercise 10.19:</b></TD><td><p class="docText">Extend the <tt>map</tt> from the previous exercise by having the <tt>vector</tt> store a <tt>pair</tt> that holds a child's name and birthday. Revise the program accordingly. Test your modified test program to verify its correctness.</p>
</TD></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch10qa8q4"></a><b>Exercise 10.20:</b></TD><td><p class="docText">List at least three possible applications in which the <tt>map</tt> type might be of use. Write the definition of each <tt>map</tt> and indicate how the elements are likely to be inserted and retrieved.</p>
</td></tr></table></p>
</blockquote>
</td></tr></table></p><br>



<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch10lev1sec2.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch10lev1sec4.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>