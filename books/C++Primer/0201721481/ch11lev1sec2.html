<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 11.2.&nbsp; A First Look at the Algorithms</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch11lev1sec1.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch11lev1sec3.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch11lev1sec2"></a>
<h3 class="docSection1Title">11.2. A First Look at the Algorithms</h3>
<p class="docText">Before covering the structure of the algorithms library, let's look at a couple of examples. We've already seen the use of <tt>find</tt>; in this section we'll use a few additional algorithms. To use a generic algorithm, we must include the <tt>algorithm</tt> header:</P>
<pre>
    #include &lt;algorithm&gt;
</pre><BR>
<p class="docText">The library also defines a set of generalized numeric algorithms, using the same conventions as the generic algorithms. To use these algorithms we include the <tt>numeric</tt> header:</p>
<pre>
    #include &lt;numeric&gt;
</pre><BR>
<p class="docText">With only a handful of exceptions, all the algorithms operate over a range of elements. We'll refer to this range as the &quot;input range.&quot; The algorithms that take an input range always use their first two parameters to denote that range. These parameters are iterators used to denote the first and one past the last element that we want to process.</p>
<p class="docText">Although most algorithms are similar in that they operate over an input range, they differ in how they use the elements in that range. The most basic way to understand the algorithms is to know whether they read elements, write elements, or rearrange the order of the elements. We'll look at samples of each kind of algorithm in the remainder of this section.</p>
<a name="ch11lev2sec4"></a>
<H4 class="docSection2Title">11.2.1. Read-Only Algorithms</H4>
<p class="docText"><a name="idd1e84533"></a><a name="idd1e84537"></a><a name="idd1e84542"></a><a name="idd1e84547"></a>A number of the algorithms read, but never write to, the elements in their input range. <tt>find</tt> is one such algorithm. Another simple, read-only algorithm is <tt>accumulate</tt>, which is defined in the <tt>numeric</tt> header. Assuming <tt>vec</tt> is a <tt>vector</tt> of <tt>int</tt> values, the following code</p>
<pre>
     // <span class="docEmphItalicAlt">sum the elements in vec starting the summation with the value</span> <span class="docEmphasis">42</span>
     int sum = accumulate(vec.begin(), vec.end(), 42);
</pre><br>
<p class="docText">sets <tt>sum</tt> equal to the sum of the elements in <tt>vec</tt> plus 42. <tt>accumulate</tt> takes three parameters. The first two specify a range of elements to sum. The third is an initial value for the sum. The <tt>accumulate</tt> function sets an internal variable to the initial value. It then adds the value of each element in the range to that initial value. The algorithm returns the result of the summation. The return type of <tt>accumulate</tt> is the type of its third argument.</p>
<a name="ch11note01"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> The third argument, which specifies the starting value, is necessary because <tt>accumulate</tt> knows nothing about the element types that it is accumulating. Therefore, it has no way to invent an appropriate starting value or associated type.</P></td></tr></table><br>
</P></div><BR>
<p class="docText">There are two implications of the fact that <tt>accumulate</tt> doesn't know about the types over which it sums. First, we must pass an initial starting value because otherwise <tt>accumulate</tt> cannot know what starting value to use. Second, the type of the elements in the container must match or be convertible to the type of the third argument. Inside <tt>accumulate</tt>, the third argument is used as the starting point for the summation; the elements in the container are successively added into this sum. It must be possible to add the element type to the type of the sum.</p>
<p class="docText">As an example, we could use <tt>accumulate</tt> to concatenate the elements of a <tt>vector</tt> of <tt>string</tt>s:</p>
<pre>
     // <span class="docEmphItalicAlt">concatenate elements from v and store in sum</span>
     string sum = accumulate(v.begin(), v.end(), string(""));
</pre><br>
<p class="docText">The effect of this call is to concatenate each element in <tt>vec</tt> onto a <tt>string</tt> that starts out as the empty string. Note that we explicitly create a <tt>string</tt> as the third parameter. Passing a character-string literal would be a compile-time error. If we passed a string literal, the summation type would be <tt>const char*</tt> but the <tt>string</tt> addition operator (<a class="docLink" href="ch03lev1sec2.html#ch03lev2sec4">Section 3.2.3</a>, p. <a class="docLink" href="ch03lev1sec2.html#ch03lev2sec4">86</a>) for operands of type <tt>string</tt> and <tt>const char*</tt> yields a <tt>string</tt> not a <tt>const char*</tt>.</p>
<a name="ch11lev3sec1"></a>
<H5 class="docSection3Title">Using <tt>find_first_of</tt></h5>
<p class="docText">In addition to <tt>find</tt>, the library defines several other, more complicated searching algorithms. Several of these are similar to the <tt>find</tt> operations of the <tt>string</tt> class (<a class="docLink" href="ch09lev1sec6.html#ch09lev2sec21">Section 9.6.4</a>, p. <a class="docLink" href="ch09lev1sec6.html#ch09lev2sec21">343</a>). One such is <tt>find_first_of</tt>. This algorithm takes two pairs of iterators that denote two ranges of elements. It looks in the first range for a match to any element from the second range and returns an iterator denoting the first element that matches. If no match is found, it returns the end iterator of the <a name="idd1e84711"></a><a name="idd1e84716"></a>first range. Assuming that <tt>roster1</tt> and <tt>roster2</tt> are two <tt>list</tt>s of names, we could use <tt>find_first_of</tt> to count how many names are in both lists:</p>
<pre>
     // <span class="docEmphItalicAlt">program for illustration purposes only:</span>
     // <span class="docEmphItalicAlt">there are much faster ways to solve this problem</span>
     size_t cnt = 0;
     list&lt;string&gt;::iterator it = roster1.begin();
     // <span class="docEmphItalicAlt">look in</span> <span class="docEmphasis">roster1</span> <span class="docEmphItalicAlt">for any name also in</span> <span class="docEmphasis">roster2</span>
     while   ((it = find_first_of(it, roster1.end(),
                  roster2.begin(), roster2.end()))
                     != roster1.end()) {
        ++cnt;
        // <span class="docEmphItalicAlt">we got a match, increment</span> <span class="docEmphasis">it</span> <span class="docEmphItalicAlt">to look in the rest of</span> <span class="docEmphasis">roster1</span>
        ++it;
     }
     cout &lt;&lt; "Found " &lt;&lt; cnt
          &lt;&lt; " names on both rosters" &lt;&lt; endl;
</pre><BR>
<p class="docText">The call to <tt>find_first_of</tt> looks for any element in <tt>roster2</tt> that matches an element from the first rangethat is, it looks for an element in the range from <tt>it</tt> to <tt>roster1.end()</tt>. The function returns the first element in that range that is also in the second range. On the first trip through the <tt>while</tt>, we look in the entire range of <tt>roster1</tt>. On second and subsequent trips, we look in that part of <tt>roster1</tt> that has not already been matched.</p>
<p class="docText">In the condition, we check the return from <tt>find_first_of</tt> to see whether we found a matching name. If we got a match, we increment our counter. We also increment <tt>it</tt> so that it refers to the next element in <tt>roster1</tt>. We know we're done when <tt>find_first_of</tt> returns <tt>roster1.end()</tt>, which it does if there is no match.</p>
<a name="ch11sb03"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Key Concept: Iterator Argument Types</h2>
<p class="docText"><span class="docEmphStrong">In general, the generic algorithms operate on iterator pairs that denote a range of elements in a container (or other sequence). The types of the arguments that denote the range must match exactly, and the iterators themselves must denote a range: They must refer to elements in the same container (or to the element just past the end of that container), and if they are unequal, then it must be possible to reach the second iterator by repeatedly incrementing the first iterator.</span></p>
<p class="docText"><span class="docEmphStrong">Some algorithms, such as <tt>find_first_of</tt>, take two pairs of iterators. The iterator types in each pair must match exactly, but there is no requirement that the type of the two pairs match each other. In particular, the elements can be stored in different kinds of sequences. What is required is that we be able to compare elements from the two sequences.</span></p>
<p class="docText"><span class="docEmphStrong">In our program, the types of <tt>roster1</tt> and <tt>roster2</tt> need not match exactly: <tt>roster1</tt> could be a <tt>list</tt> while <tt>roster2</tt> was a <tt>vector</tt></span>, <span class="docEmphStrong"><tt>deque</tt></span>, <span class="docEmphStrong">or other sequence that we'll learn about later in this chapter. What is required is that we be able to compare the elements from these two sequences using the <tt>==</tt> operator. If <tt>roster1</tt> is a <tt>list&lt;string&gt;</tt>, then</span> <span class="docEmphStrong"><tt>roster2</tt> could be a <tt>vector&lt;char*&gt;</tt> because the <tt>string</tt> library defines <tt>==</tt> on a <tt>string</tt> and a <tt>char*</tt></span>.</p>
</td></tr></table></p><br>
<a name="ch11sb04"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 11.2.1</H2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch11qa2q1"></a><b>Exercise 11.3:</b></td><TD><p class="docText"><a name="idd1e84902"></a>Use <tt>accumulate</tt> to sum the elements in a <tt>vector&lt;int&gt;</tt>.</P>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q2"></a><b>Exercise 11.4:</b></TD><td><p class="docText">Assuming <tt>v</tt> is a <tt>vector&lt;double&gt;</tt> what, if anything, is wrong with calling <tt>accumulate&lt;v.begin(), v.end(), 0)</tt>?</P>
</TD></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q3"></a><B>Exercise 11.5:</b></TD><td><p class="docText">What would happen if the program that called <tt>find_first_of</tt> did not increment <tt>it</tt>?</p>
</td></tr></table></P>
</blockquote>
</td></tr></table></P><br>


<a name="ch11lev2sec5"></a>
<h4 class="docSection2Title">11.2.2. Algorithms that Write Container Elements</H4>
<p class="docText">Some algorithms write element values. When using algorithms that write elements, we must take care to ensure that the sequence into which the algorithm writes is at least as large as the number of elements being written.</p>
<p class="docText">Some algorithms write directly into the input sequence. Others take an additional iterator that denotes a destination. Such algorithms use the destination iterator as a place in which to write output. Still a third kind writes a specified number of elements to some sequence.</P>
<a name="ch11lev3sec2"></a>
<h5 class="docSection3Title">Writing to the Elements of the Input Sequence</h5>
<p class="docText">The algorithms that write to their input sequence are inherently safethey write only as many elements as are in the specified input range.</p>
<p class="docText">A simple example of an algorithm that writes to its input sequence is <tt>fill</tt>:</p>
<pre>
     fill(vec.begin(), vec.end(), 0); // <span class="docEmphItalicAlt">reset each element to 0</span>
     // <span class="docEmphItalicAlt">set subsequence of the range to 10</span>
     fill(vec.begin(), vec.begin() + vec.size()/2, 10);
</pre><br>
<p class="docText"><tt>fill</tt> takes a pair of iterators that denote a range in which to write copies of its third parameter. It executes by setting each element in the range to the given value. Assuming that the input range is valid, then the writes are safe. The algorithm writes only to elements known to exist in the input range itself.</p>

<a name="ch11lev3sec3"></a>
<h5 class="docSection3Title">Algorithms Do Not Check Write Operations</h5>
<p class="docText">The <tt>fill_n</tt> function takes an iterator, a count, and a value. It writes the specified number of elements with the given value starting at the element referred to by the iterator. The <tt>fill_n</tt> function assumes that it is safe to write the specified number of elements. It is a fairly common beginner mistake to call <tt>fill_n</tt> (or similar algorithms that write to elements) on a container that has no elements:</p>
<pre>
     vector&lt;int&gt; vec; // <span class="docEmphItalicAlt">empty</span> <span class="docEmphasis">vector</span>
     // <span class="docEmphItalicAlt">disaster: attempts to write to 10 (nonexistent) elements in</span> <span class="docEmphasis">vec</span>
     fill_n(vec.begin(), 10, 0);
</pre><br>
<p class="docText">This call to <tt>fill_n</tt> is a disaster. We specified that ten elements should be written, but there are no such elements <tt>vec</tt> is empty. The result is undefined and will probably result in a serious run-time failure.</p>
<a name="ch11note02"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></TD><td valign="top"><p class="docText"><a name="idd1e85047"></a><a name="idd1e85052"></a><a name="idd1e85056"></a><a name="idd1e85062"></a><a name="idd1e85065"></a><a name="idd1e85070"></a><a name="idd1e85075"></a><a name="idd1e85080"></a> Algorithms that write a specified number of elements or that write to a destination iterator do not check whether the destination is large enough to hold the number of elements being written.</P></td></tr></table><BR>
</P></div><br>

<a name="ch11lev3sec4"></a>
<h5 class="docSection3Title">Introducing <tt>back_inserter</tt></h5>
<p class="docText">One way to ensure that an algorithm has enough elements to hold the output is to use an <b><a name="ch11term7"></a><a class="docLink" href="ch11lev1sec7.html#gloss11_07">insert iterator</a></b>. An insert iterator is an iterator that <span class="docEmphasis">adds</span> elements to the underlying container. Ordinarily, when we assign to a container element through an iterator, we assign to the element to which the iterator refers. When we assign through an insert iterator, a new element equal to the right-hand value is added to the container.</p>
<p class="docText">We'll have more to say about insert iterators in <a class="docLink" href="ch11lev1sec3.html#ch11lev2sec7">Section 11.3.1</a> (p. <a class="docLink" href="ch11lev1sec3.html#ch11lev2sec7">406</a>). However, in order to illustrate how to safely use algorithms that write to a container, we will use <B><a name="ch11term1"></a><a class="docLink" href="ch11lev1sec7.html#gloss11_01"><span class="docEmphStrong"><tt>back_inserter</tt>.</span></a></b> Programs that use <tt>back_inserter</tt> must include the <tt>iterator</tt> header.</p>
<p class="docText">The <tt>back_inserter</tt> function is an iterator adaptor. Like the container adaptors (<a class="docLink" href="ch09lev1sec7.html#ch09lev1sec7">Section 9.7</a>, p. <a class="docLink" href="ch09lev1sec7.html#ch09lev1sec7">348</a>), an iterator adaptor takes an object and generates a new object that adapts the behavior of its argument. In this case, the argument to <tt>back_inserter</tt> is a reference to a container. <tt>back_inserter</tt> generates an insert iterator bound to that container. When we attempt to assign to an element through that iterator, the assignment calls <tt>push_back</tt> to add an element with the given value to the container. We can use <tt>back_inserter</tt> to generate an iterator to use as the destination in <tt>fill_n:</tt></P>
<pre>
     vector&lt;int&gt; vec; // <span class="docEmphItalicAlt">empty</span> <span class="docEmphasis">vector</span>
     // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">back_inserter</span> <span class="docEmphItalicAlt">creates an</span> <span class="docEmphasis">insert</span> <span class="docEmphItalicAlt">iterator that adds elements to</span> <span class="docEmphasis">vec</span>
     fill_n (back_inserter(vec), 10, 0); // <span class="docEmphItalicAlt">appends 10 elements to</span> <span class="docEmphasis">vec</span>
</pre><BR>
<p class="docText">Now, each time <tt>fill_n</tt> writes a value, it will do so through the insert iterator generated by <tt>back_inserter</tt>. The effect will be to call <tt>push_back</tt> on <tt>vec</tt>, adding ten elements to the end of <tt>vec</tt>, each of which has the value 0.</p>

<a name="ch11lev3sec5"></a>
<h5 class="docSection3Title">Algorithms that Write to a Destination Iterator</h5>
<p class="docText">A third kind of algorithm writes an unknown number of elements to a destination iterator. As with <tt>fill_n</tt>, the destination iterator refers to the first element of a sequence that will hold the output. The simplest such algorithm is <tt>copy</tt>. This algorithm takes three iterators: The first two denote an input range and the third refers to an element in the destination sequence. It is essential that the destination passed to <tt>copy</tt> be at least as large as the input range. Assuming <tt>ilst</tt> is a <tt>list</tt> holding <tt>int</tt>s, we might <tt>copy</tt> it into a <tt>vector</tt>:</P>
<pre>
     vector&lt;int&gt; ivec; // <span class="docEmphItalicAlt">empty</span> <span class="docEmphasis">vector</span>
     // <span class="docEmphItalicAlt">copy elements from</span> <span class="docEmphasis">ilst</span> <span class="docEmphItalicAlt">into</span> <span class="docEmphasis">ivec</span>
     copy (ilst.begin(), ilst.end(), back_inserter(ivec));
</pre><BR>
<p class="docText"><tt>copy</tt> reads elements from the input range, copying them to the destination.</p>
<p class="docText"><a name="idd1e85278"></a><a name="idd1e85285"></a><a name="idd1e85288"></a><a name="idd1e85291"></a><a name="idd1e85296"></a><a name="idd1e85300"></a>Of course, this example is a bit inefficient: Ordinarily if we want to create a new container as a copy of an existing container, it is better to use an input range directly as the initializer for a newly constructed container:</p>
<pre>
     // <span class="docEmphItalicAlt">better way to copy elements from</span> <span class="docEmphasis">ilst</span>
     vector&lt;int&gt; ivec(ilst.begin(), ilst.end());
</pre><br>

<a name="ch11lev3sec6"></a>
<h5 class="docSection3Title">Algorithm <tt>_copy</tt> Versions</H5>
<p class="docText">Several algorithms provide so-called &quot;copying&quot; versions. These algorithms do some processing on the elements of their input sequence but do not change the original elements. Instead, a new sequence is written that contains the result of processing the elements of the original.</p>
<p class="docText">The <tt>replace</tt> algorithm is a good example. This algorithm reads and writes to an input sequence, replacing a given value by a new value. The algorithm takes four parameters: a pair of iterators denoting the input range and a pair of values. It substitutes the second value for each element that is equal the first:</p>
<pre>
     // <span class="docEmphItalicAlt">replace any element with value of</span> <span class="docEmphasis">0</span> <span class="docEmphItalicAlt">by</span> <span class="docEmphasis">42</span>
     replace(ilst.begin(), ilst.end(), 0, 42);
</pre><BR>
<p class="docText">This call replaces all instances of 0 by the 42. If we wanted to leave the original sequence unchanged, we would call <tt>replace_copy</tt>. That algorithm takes a third iterator argument denoting a destination in which to write the adjusted sequence:</p>
<pre>
     // <span class="docEmphItalicAlt">create empty</span> <span class="docEmphasis">vector</span> <span class="docEmphItalicAlt">to hold the replacement</span>
     vector&lt;int&gt; ivec;

     // <span class="docEmphItalicAlt">use</span> <span class="docEmphasis">back_inserter</span> <span class="docEmphItalicAlt">to grow destination as needed</span>
     replace_copy (ilst.begin(), ilst.end(),
                  back_inserter(ivec), 0, 42);
</pre><br>
<p class="docText">After this call, <tt>ilst</tt> is unchanged, and <tt>ivec</tt> contains a copy of <tt>ilst</tt> with the exception that every element in <tt>ilst</tt> with the value 0 has the value 42 in <tt>ivec</tt>.</P>


<a name="ch11lev2sec6"></a>
<h4 class="docSection2Title">11.2.3. Algorithms that Reorder Container Elements</H4>
<p class="docText">Suppose we want to analyze the words used in a set of children's stories. For example, we might want know how many words contain six or more characters. We want to count each word only once, regardless of how many times it appears or whether it appears in multiple stories. We'd like to be able to print the words in size order, and we want the words to be in alphabetic order within a given size.</p>
<p class="docText">We'll assume that we have read our input and stored the text of each book in a <tt>vector</tt> of <tt>string</tt>s named <tt>words</tt>. How might we solve the part of the problem that involves counting word occurrences? To solve this problem, we'd need to:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">Eliminate duplicate copies of each word</p></div></li><li><div style="font-weight:normal"><p class="docList">Order the words based on size</p></div></li><li><div style="font-weight:normal"><p class="docList">Count the words whose size is 6 or greater</p></div></li></ol></div>
<a name="ch11sb05"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<H2 class="docSidebarTitle">Exercises Section 11.2.2</h2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa3q1"></a><B>Exercise 11.6:</b></TD><td><p class="docText"><a name="idd1e85458"></a>Using <tt>fill_n</tt>, write a program to set a sequence of <tt>int</tt> values to 0.</p>
</td></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch11qa3q2"></a><b>Exercise 11.7:</b></TD><TD><p class="docText">Determine if there are any errors in the following programs and, if so, correct the error(s):</p>
<pre>
     (a) vector&lt;int&gt; vec; list&lt;int&gt; lst; int i;
         while (cin &gt;&gt; i)
             lst.push_back(i);
         copy(lst.begin(), lst.end(), vec.begin());

     (b) vector&lt;int&gt; vec;
         vec.reserve(10);
         fill_n(vec.begin(), 10, 0);
</pre><br>
</td></TR><TR valign="top"><td align="right" class="docText" width="50"><a name="ch11qa3q3"></a><b>Exercise 11.8:</b></td><td><p class="docText">We said that algorithms do not change the size of the containers over which they operate. Why doesn't the use of <tt>back_inserter</tt> invalidate this claim?</P>
</td></tr></table></P>
</blockquote>
</td></tr></table></P><br>
<p class="docText">We can use generic algorithms in each of these steps.</P>
<p class="docText">For purposes of illustration, we'll use the following simple story as our input:</p>
<pre>
     <span class="docEmphStrong">the quick red fox jumps over the slow red turtle</span>
</pre><br>
<p class="docText">Given this input, our program should produce the following output:</p>
<pre>
     <span class="docEmphStrong">1 word 6 characters or longer</span>
</pre><br>
<a name="ch11lev3sec7"></a>
<h5 class="docSection3Title">Eliminating Duplicates</h5>
<p class="docText">Assuming our input is in a <tt>vector</tt> named <tt>words</tt>, our first subproblem is to eliminate duplicates from the <tt>words</tt>:</p>
<pre>
     // <span class="docEmphItalicAlt">sort</span> <span class="docEmphasis">words</span> <span class="docEmphItalicAlt">alphabetically so we can find the duplicates</span>
     sort(words.begin(), words.end());
     /* <span class="docEmphItalicAlt">eliminate duplicate words:</span>
      * <span class="docEmphasis">unique</span> <span class="docEmphItalicAlt">reorders</span> <span class="docEmphasis">words</span> <span class="docEmphItalicAlt">so that each word appears once in the</span>
      *    <span class="docEmphItalicAlt">front portion of</span> <span class="docEmphasis">words</span> <span class="docEmphItalicAlt">and returns an iterator one past the unique range;</span>
      * <span class="docEmphasis">erase</span> <span class="docEmphItalicAlt">uses a</span> <span class="docEmphasis">vector</span> <span class="docEmphItalicAlt">operation to remove the nonunique elements</span>
      */
     vector&lt;string&gt;::iterator end_unique =
                    unique(words.begin(), words.end());
     words.erase(end_unique, words.end());
</pre><br>
<p class="docText">Our input <tt>vector</tt> contains a copy of every word used in each story. We start by sorting this <tt>vector</tt>. The <tt>sort</tt> algorithm takes two iterators that denote the range of elements to sort. It uses the <tt>&lt;</tt> operator to compare the elements. In this call we ask that the entire <tt>vector</tt> be sorted.</p>
<p class="docText">After the call to <tt>sort</tt>, our <tt>vector</tt> elements are ordered:</p>
<pre>
     <span class="docEmphStrong">fox jumps over quick red red slow the the turtle</span>
</pre><br>
<p class="docText">Note that the words <tt>red</tt> and <tt>the</tt> are duplicated.</p>

<a name="ch11lev3sec8"></a>
<h5 class="docSection3Title">Using <tt>unique</tt></H5>
<p class="docText"><a name="idd1e85653"></a><a name="idd1e85659"></a><a name="idd1e85665"></a><a name="idd1e85668"></a><a name="idd1e85672"></a>Once <tt>words</tt> is sorted, our problem is to keep only one copy of each word that is used in our stories. The <tt>unique</tt> algorithm is well suited to this problem. It takes two iterators that denote a range of elements. It rearranges the elements in the input range so that adjacent duplicated entries are eliminated and returns an iterator that denotes the end of the range of the unique values.</P>
<p class="docText">After the call to <tt>unique</tt>, the <tt>vector</tt> holds</p>
<p class="docText"><tt>words</tt></P>

<p class="docText">
<img border="0" alt="" width="500" height="100" SRC="images/0201721481/graphics/402fig01.gif;400478"></p>

<p class="docText">Note that the size of <tt>words</tt> is unchanged. It still has ten elements; only the order of these elements has changed. The call to <tt>unique</tt> &quot;removes&quot; adjacent duplicates. We put remove in quotes because <tt>unique</tt> doesn't remove any elements. Instead, it overwrites adjacent duplicates so that the unique elements are copied into the front of the sequence. The iterator returned by <tt>unique</tt> denotes one past the end of the range of unique elements.</p>

<a name="ch11lev3sec9"></a>
<H5 class="docSection3Title">Using Container Operations to Remove Elements</H5>
<p class="docText">If we want to eliminate the duplicate items, we must use a container operation, which we do in the call to <tt>erase</tt>. This call erases the elements starting with the one to which <tt>end_unique</tt> refers through the end of <tt>words</tt>. After this call, <tt>words</tt> contains the eight unique words from the input.</p>
<a name="ch11note03"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> Algorithms never directly change the size of a container. If we want to add or remove elements, we must use a container operation.</p></TD></TR></table><br>
</p></div><br>
<p class="docText">It is worth noting that this call to <tt>erase</tt> would be safe even if there were no duplicated words in our <tt>vector</tt>. If there were no duplicates, then <tt>unique</tt> would return <tt>words.end()</tt>. Both arguments in the call to <tt>erase</tt> would have the same value, <tt>words.end()</tt>. The fact that the iterators are equal would mean that the range to <tt>erase</tt> would be empty. Erasing an empty range has no effect, so our program is correct even if the input has no duplicates.</P>

<a name="ch11lev3sec10"></a>
<H5 class="docSection3Title">Defining Needed Utility Functions</h5>
<p class="docText">Our next subproblem is to count how many words are of length six or greater. To solve this problem, we'll use two additional generic algorithms: <tt>stable_sort</tt> and <tt>count_if</tt>. To use each of these algorithms we'll need a companion utility function, known as a <b><a name="ch11term14"></a><a class="docLink" href="ch11lev1sec7.html#gloss11_14">predicates</a></b>. A predicate is a function that performs some test and returns a type that can be used in a condition to indicate success or failure.</p>
<p class="docText">The first predicate we need will be used to sort the elements based on size. To do this sort, we need to define a predicate function that compares two <tt>string</tt>s and returns a <tt>bool</tt> indicating whether the first is shorter in length than the second:</p>
<pre>
     // <span class="docEmphItalicAlt">comparison function to be used to sort by word length</span>
     bool isShorter(const string &amp;s1, const string &amp;s2)
     {
         return s1.size() &lt; s2.size();
     }
</pre><BR>
<p class="docText"><a name="idd1e85813"></a><a name="idd1e85818"></a><a name="idd1e85823"></a><a name="idd1e85828"></a><a name="idd1e85834"></a><a name="idd1e85840"></a>The other function we need will determine whether a given <tt>string</tt> is of length six or greater:</p>
<pre>
     // <span class="docEmphItalicAlt">determine whether a length of a given word is 6 or more</span>
     bool GT6(const string &amp;s)
     {
          return s.size() &gt;= 6;
     }
</pre><br>
<p class="docText">Although this function solves our problem, it is unnecessarily limitedthe function hardwires the size into the function itself. If we wanted to find out how many words were of another length, we'd have to write another function. We could easily write a more general comparison function that took two parameters, the <tt>string</tt> and the size. However, the function we pass to <tt>count_if</tt> takes a single argument, so we cannot use the more general approach in this program. We'll see a better way to write this part of our solution in <a class="docLink" href="ch14lev1sec8.html#ch14lev2sec27">Section 14.8.1</a> (p. <a class="docLink" href="ch14lev1sec8.html#ch14lev2sec27">531</a>).</P>

<a name="ch11lev3sec11"></a>
<h5 class="docSection3Title">Sorting Algorithms</h5>
<p class="docText">The library defines four different sort algorithms, of which we've used the simplest, <tt>sort</tt>, tosort <tt>words</tt> into alphabetical order. In addition to <tt>sort</tt>, the library also defines a <tt>stable_sort</tt> algorithm. A <tt>stable_sort</tt> maintains the original order among equal elements. Ordinarily, we don't care about the relative order of equal elements in a sorted sequence. After all, they're equal. However, in this case, we have defined &quot;equal&quot; to mean &quot;the same length.&quot; Elements that have the same length can still be distinct when viewed alphabetically. By calling <tt>stable_sort</tt>, we maintain alphabetic order among those elements that have the same length.</P>
<p class="docText">Both <tt>sort</tt> and <tt>stable_sort</tt> are overloaded functions. One version uses the <tt>&lt;</tt> operator for the element type to do the comparison. We used this version of <tt>sort</tt> to sort <tt>words</tt> before looking for duplicate elements. The second version takes a third parameter: the name of a predicate to use when comparing elements. That function must take two arguments of the same type as the element type and return a value that can be tested in a condition. We will use this second version, passing our <tt>isShorter</tt> function to compare elements:</p>
<pre>
     // <span class="docEmphItalicAlt">sort</span> <span class="docEmphasis">words</span> <span class="docEmphItalicAlt">by size, but maintain alphabetic order for words of the same size</span>
     stable_sort(words.begin(), words.end(), isShorter);
</pre><BR>
<p class="docText">After this call, <tt>words</tt> is sorted by element size, but the words of each length are also still in alphabetical order:</p>

<p class="docText">
<img border="0" alt="" width="375" height="38" SRC="images/0201721481/graphics/403fig01.gif;400478"></p>


<a name="ch11lev3sec12"></a>
<h5 class="docSection3Title">Counting Words of Length Six or More</h5>
<p class="docText"><a name="idd1e85957"></a>Now that we've reordered our <tt>vector</tt> by word size, our remaining problem is to count how many words are of length six or greater. The <tt>count_if</tt> algorithm handles this problem:</p>
<pre>
     vector&lt;string&gt;::size_type wc =
                  count_if(words.begin(), words.end(), GT6);
</pre><br>
<p class="docText"><tt>count_if</tt> executes by reading the range denoted by its first two parameters. It passes each value that it reads to the predicate function represented by its third argument. That function must take a single argument of the element type and must return a value that can be tested as a condition. The algorithm returns a count of the number of elements for which the function succeeded. In this case, <tt>count_if</tt> passes each word to <tt>GT6</tt>, which returns the <tt>bool</tt> value <tt>true</tt> if the word's length is six or more.</p>

<a name="ch11lev3sec13"></a>
<h5 class="docSection3Title">Putting It All Together</h5>
<p class="docText">Having looked at the program in detail, here is the program as a whole:</p>
<pre>
     // <span class="docEmphItalicAlt">comparison function to be used to sort by word length</span>
     bool isShorter(const string &amp;s1, const string &amp;s2)
     {
         return s1.size() &lt; s2.size();
     }
     // <span class="docEmphItalicAlt">determine whether a length of a given word is 6 or more</span>
     bool GT6(const string &amp;s)
     {
         return s.size() &gt;= 6;
     }
     int main()
     {
         vector&lt;string&gt; words;
         // <span class="docEmphItalicAlt">copy contents of each book into a single</span> <span class="docEmphasis">vector</span>
         string next_word;
         while (cin &gt;&gt; next_word) {
             // <span class="docEmphItalicAlt">insert next book's contents at end of</span> <span class="docEmphasis">words</span>
             words.push_back(next_word);
         }
         // <span class="docEmphItalicAlt">sort</span> <span class="docEmphasis">words</span> <span class="docEmphItalicAlt">alphabetically so we can find the duplicates</span>
         sort (words.begin(), words.end());
         /* <span class="docEmphItalicAlt">eliminate duplicate words:</span>
          * <span class="docEmphasis">unique</span> <span class="docEmphItalicAlt">reorders</span> <span class="docEmphasis">words</span> <span class="docEmphItalicAlt">so that each word appears once in the</span>
          *       <span class="docEmphItalicAlt">front portion of</span> <span class="docEmphasis">words</span> <span class="docEmphItalicAlt">and returns an iterator one past the unique range;</span>
          * <span class="docEmphasis">erase</span> <span class="docEmphItalicAlt">uses a</span> <span class="docEmphasis">vector</span> <span class="docEmphItalicAlt">operation to remove the nonunique elements</span>
          */
         vector&lt;string&gt;::iterator end_unique =
                     unique(words.begin(), words.end());
         words.erase(end_unique, words.end());
          // <span class="docEmphItalicAlt">sort</span> <span class="docEmphasis">words</span> <span class="docEmphItalicAlt">by size, but maintain alphabetic order for words of the same size</span>
          stable_sort(words.begin(), words.end(), isShorter);
          vector&lt;string&gt;::size_type wc =
                          count_if (words.begin(), words.end(), GT6);
          cout &lt;&lt; wc &lt;&lt; " " &lt;&lt; make_plural(wc, "word", "s")
               &lt;&lt; " 6 characters or longer" &lt;&lt; endl;
          return 0;
     }
</pre><br>
<p class="docText"><a name="idd1e86080"></a><a name="idd1e86083"></a><a name="idd1e86088"></a><a name="idd1e86093"></a><a name="idd1e86096"></a>We leave as an exercise the problem of printing the words in size order.</p>
<a name="ch11sb06"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<H2 class="docSidebarTitle">Exercises Section 11.2.3</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch11qa4q1"></a><b>Exercise 11.9:</b></td><td><p class="docText">Implement the program to count words of size 4 or greater, including printing the list of unique words in the input. Test your program by running it on the program's source file.</p>
</td></TR><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch11qa4q2"></a><B>Exercise 11.10:</b></td><td><p class="docText">The library defines a <tt>find_if</tt> function. Like <tt>find</tt>, the <tt>find_if</tt> function takes a pair of iterators that indicates a range over which to operate. Like <tt>count_if</tt>, it also takes a third parameter that names a predicate that can be used to test each element in the range. <tt>find_if</tt> returns an iterator that refers to the first element for which the function returns a nonzero value. It returns its second iterator argument if there is no such element. Use the <tt>find_if</tt> function to rewrite the portion of our program that counted how many words are greater than length six.</p>
</TD></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa4q3"></a><b>Exercise 11.11:</b></td><TD><p class="docText">Why do you think the algorithms don't change the size of containers?</p>
</td></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa4q4"></a><B>Exercise 11.12:</b></td><TD><p class="docText">Why was it be necessary to use <tt>erase</tt> rather than define a generic algorithm that could remove elements from the container?</p>
</td></tr></table></p>
</blockquote>
</td></tr></table></p><br>



<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch11lev1sec1.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch11lev1sec3.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>