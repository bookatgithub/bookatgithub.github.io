<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 11.3.&nbsp; Revisiting Iterators</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch11lev1sec2.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch11lev1sec4.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch11lev1sec3"></a>
<h3 class="docSection1Title" id="432172-806">11.3. Revisiting Iterators</h3>
<p class="docText">In <a class="docLink" href="ch11lev1sec2.html#ch11lev2sec5">Section 11.2.2</a> (p. <a class="docLink" href="ch11lev1sec2.html#ch11lev2sec5">398</a>) we saw that the library defines iterators that are independent of a particular container. In fact, there are three additional kinds of iterators:</P>
<UL><li><p class="docText"><a name="idd1e86198"></a><span class="docEmphStrong">insert iterators:</span> These iterators are bound to a container and can be used to insert elements to the container.</P></li><li><p class="docText"><a name="idd1e86207"></a><span class="docEmphStrong"><tt>iostream</tt> iterators:</span> These iterators can be bound to input or output streams and used to iterate through the associated IO stream.</P></LI><li><p class="docText"><a name="idd1e86218"></a><b><a name="ch11term16"></a><a class="docLink" href="ch11lev1sec7.html#gloss11_16">reverse iterators:</a></b> These iterators move backward, rather than forward. Each container type defines its own <tt>reverse_iterator</tt> types, which are retuned by the <tt>rbegin</tt> and <tt>rend</tt> functions.</p></li></ul>
<p class="docText">These iterator types are defined in the <tt>iterator</tt> header.</P>
<p class="docText">This section will look at each of these kinds of iterators and show how they can be used with the generic algorithms. We'll also take a look at how and when to use the container <tt>const_iterators</tt>.</p>
<a name="ch11lev2sec7"></a>
<H4 class="docSection2Title">11.3.1. Insert Iterators</H4>
<p class="docText"><a name="idd1e86253"></a><a name="idd1e86257"></a><a name="idd1e86261"></a><a name="idd1e86269"></a><a name="idd1e86276"></a><a name="idd1e86279"></a><a name="idd1e86287"></a>In <a class="docLink" href="ch11lev1sec2.html#ch11lev2sec5">Section 11.2.2</a> (p. <a class="docLink" href="ch11lev1sec2.html#ch11lev2sec5">398</a>) we saw that we can use <tt>back_inserter</tt> to create an iterator that adds elements to a container. The <tt>back_inserter</tt> function is an example of an <b><a name="ch11term8"></a><a class="docLink" href="ch11lev1sec7.html#gloss11_08">inserter</a></b>. An inserter is an iterator adaptor (<a class="docLink" href="ch09lev1sec7.html#ch09lev1sec7">Section 9.7</a>, p. <a class="docLink" href="ch09lev1sec7.html#ch09lev1sec7">348</a>) that takes a container and yields an iterator that inserts elements into the specified container. When we assign through an insert iterator, the iterator inserts a new element. There are three kinds of inserters, which differ as to where elements are inserted:</p>
<ul><LI><p class="docList"><tt>back_inserter</tt>, which creates an iterator that uses <tt>push_back</tt>.</P></li><li><p class="docList"><tt>front_inserter</tt>, which uses <tt>push_front</tt>.</p></li><LI><p class="docList"><tt>inserter</tt>, which uses <tt>insert</tt>. In addition to a container, <tt>inserter</tt> takes a second argument: an iterator indicating the position ahead of which insertion should begin.</p></li></UL>
<a name="ch11lev3sec14"></a>
<h5 class="docSection3Title"><tt>front_inserter</tt> Requires <tt>push_front</tt></h5>
<p class="docText"><B><a name="ch11term4"></a><a class="docLink" href="ch11lev1sec7.html#gloss11_04"><span class="docEmphStrong"><tt>front_inserter</tt></span></a></b> operates similarly to <tt>back_inserter:</tt> It creates an iterator that treats assignment as a call to <tt>push_front</tt> on its underlying container.</p>
<a name="ch11note04"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> We can use <tt>front_inserter</tt> <span class="docEmphasis">only</span> if the container has a <tt>push_front</tt> operation. Using <tt>front_inserter</tt> on a <tt>vector</tt>, or other container that does not have <tt>push_front</tt>, is an error.</p></td></tr></table><br>
</p></div><br>

<a name="ch11lev3sec15"></a>
<h5 class="docSection3Title"><tt>inserter</tt> Yields an Iterator that Inserts at a Given Place</h5>
<p class="docText">The <tt>inserter</tt> adaptor provides a more general form. This adaptor takes both a container and an iterator denoting a position at which to do the insertion:</p>
<pre>
     // <span class="docEmphItalicAlt">position an iterator into ilst</span>
     list&lt;int&gt;::iterator it =
                      find (ilst.begin(), ilst.end(), 42);
     // <span class="docEmphItalicAlt">insert replaced copies of ivec at that point in ilst</span>
     replace_copy (ivec.begin(), ivec.end(),
                   inserter (ilst, it), 100, 0);
</pre><BR>
<p class="docText">We start by using <tt>find</tt> to locate an element in <tt>ilst</tt>. The call to <tt>replace_copy</tt> uses an <tt>inserter</tt> that will insert elements into <tt>ilst</tt> just before of the element denoted by the iterator returned from <tt>find</tt>. The effect of the call to <tt>replace_copy</tt> is to copy the elements from <tt>ivec</tt>, replacing each value of <tt>100</tt> by <tt>0</tt>. The elements are inserted just ahead of the element denoted by <tt>it</tt>.</P>
<p class="docText">When we create an <tt>inserter</tt>, we say where to insert new elements. Elements are always inserted in <span class="docEmphasis">front</span> of the position denoted by the iterator argument to <tt>inserter</tt>.</p>
<p class="docText">We might think that we could simulate the effect of <tt>front_inserter</tt> by using <tt>inserter</tt> and the <tt>begin</tt> iterator for the container. However, an <tt>inserter</tt> behaves quite differently from <tt>front_inserter</tt>. When we use <tt>front_inserter</tt>, <a name="idd1e86499"></a><a name="idd1e86504"></a><a name="idd1e86508"></a><a name="idd1e86513"></a><a name="idd1e86519"></a><a name="idd1e86525"></a>the elements are always inserted ahead of the then first element in the container. When we use <tt>inserter</tt>, elements are inserted ahead of a specific position. Even if that position initially is the first element, as soon as we insert an element in front of that element, it is no longer the one at the beginning of the container:</P>
<pre>
     list&lt;int&gt; ilst, ilst2, ilst3;     // <span class="docEmphItalicAlt">empty lists</span>
     // <span class="docEmphItalicAlt">after this loop</span> <span class="docEmphasis">ilst</span> <span class="docEmphItalicAlt">contains:</span> <span class="docEmphasis">1 2 3 4</span>
     for (list&lt;int&gt;::size_type i = 0; i != 4; ++i)
          ilst.push_front(i);
     // <span class="docEmphItalicAlt">after copy ilst2 contains:</span> <span class="docEmphItalicAlt">4 3 2 1</span>
     copy (ilst.begin(), ilst.end(), front_inserter(ilst2));
     // <span class="docEmphItalicAlt">after copy, ilst3 contains:</span> <span class="docEmphasis">1 2 3 4</span>
     copy (ilst.begin(), ilst.end(),
                  inserter (ilst3, ilst3.begin()));
</pre><br>
<p class="docText">When we copy into <tt>ilst2</tt>, elements are always inserted ahead of any other element in the <tt>list</tt>. When we copy into <tt>ilst3</tt>, elements are inserted at a fixed point. That point started out as the head of the <tt>list</tt>, but as soon as even one element is added, it is no longer the first element.</p>
<a name="ch11note05"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> Recalling the discussion in <a class="docLink" href="ch09lev1sec3.html#ch09lev2sec8">Section 9.3.3</a> (p. <a class="docLink" href="ch09lev1sec3.html#ch09lev2sec8">318</a>), it is important to understand that using <tt>front_inserter</tt> results in the elements appearing in the destination in reverse order.</p></td></TR></table><br>
</P></div><BR>
<a name="ch11sb07"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Exercises Section 11.3.1</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa5q1"></a><b>Exercise 11.13:</b></TD><td><p class="docText">Explain the differences among the three insert iterators.</p>
</TD></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch11qa5q2"></a><b>Exercise 11.14:</b></TD><td><p class="docText">Write a program that uses <tt>replace_copy</tt> to copy a sequence from one container to another, replacing elements with a given value in the first sequence by the specified new value. Write the program to use an <tt>inserter</tt>, a <tt>back_inserter</tt> and a <tt>front_inserter</tt>. Discuss how the output sequence varies in each case.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa5q3"></a><b>Exercise 11.15:</b></td><td><p class="docText">The algorithms library defines a function named <tt>unique_copy</tt> that operates like <tt>unique</tt>, except that it takes a third iterator denoting a sequence into which to copy the unique elements. Write a program that uses <tt>unique_copy</tt> to copy the unique elements from a <tt>list</tt> into an initially empty <tt>vector</tt>.</p>
</td></tr></table></p>
</blockquote>
</TD></TR></table></p><BR>


<a name="ch11lev2sec8"></a>
<h4 class="docSection2Title">11.3.2. <tt>iostream</tt> Iterators</h4>
<p class="docText">Even though the <tt>iostream</tt> types are not containers, there are iterators that can be used with <tt>iostream</tt> objects: An <B><a name="ch11term9"></a><a class="docLink" href="ch11lev1sec7.html#gloss11_09"><span class="docEmphStrong"><tt>istream_iterator</tt></span></a></b> reads an input stream, and an <B><a name="ch11term12"></a><a class="docLink" href="ch11lev1sec7.html#gloss11_12"><span class="docEmphStrong"><tt>ostream_iterator</tt></span></a></b> writes an output stream. These iterators treat their corresponding stream as a sequence of elements of a specified type. Using a <span class="docEmphRoman"><a name="ch11term17"></a><a class="docLink" href="ch11lev1sec7.html#gloss11_17">stream iterator</a></span>, we can use the generic algorithms to read (or write) data to (or from) stream objects.</p>
<p class="docText"><a name="idd1e86703"></a><a name="idd1e86711"></a><a name="idd1e86719"></a><a name="idd1e86728"></a><a name="idd1e86734"></a><a name="idd1e86743"></a><a name="idd1e86750"></a><a name="idd1e86760"></a><a name="idd1e86770"></a><a name="idd1e86777"></a><a name="idd1e86787"></a>The stream iterators define only the most basic of the iterator operations: increment, dereference, and assignment. In addition, we can compare two <tt>istream</tt> iterators for equality (or inequality). There is no comparison for <tt>ostream</tt> iterators.</p>
<a name="ch11lev3sec16"></a>
<h5 class="docSection3Title">Defining Stream Iterators</h5>
<p class="docText">The stream iterators are class templates: An <tt>istream_iterator</tt> can be defined for any type for which the input operator (the <tt>&gt;&gt;</tt> operator) is defined. Similarly, an <tt>ostream_iterator</tt> can be defined for any type that has an output operator (the <tt>&lt;&lt;</tt> operator).</p>
<a name="ch11table01"></a><P><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 11.1. <tt>iostream</tt> Iterator Constructors</H5></caption><colgroup><col width="225"><col width="300"></colgroup><thead></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>istream_iterator&lt;T&gt; in(strm);</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Create <tt>istream_iterator</tt> that reads objects of type <tt>T</tt> from input stream <tt>strm</tt>.</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>istream_iterator&lt;T&gt; in;</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Off-the-end iterator for <tt>istream_iterator</tt>.</P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>ostream_iterator&lt;T&gt; in(strm);</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Create <tt>ostream_iterator</tt> that writes objects of type <tt>T</tt> to the output stream <tt>strm</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top" colspan="2"><p class="docText"><tt>ostream_iterator&lt;T&gt; in(strm, delim);</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><TD class="docTableCell" align="left" valign="top"><p class="docText">Create <tt>ostream_iterator</tt> that writes objects of type <tt>T</tt> to the output stream <tt>strm</tt> using <tt>delim</tt> as a separator between elements. <tt>delim</tt> is a null-terminated character array.</P></td></TR></table></p><br>
<p class="docText">When we create a stream iterator, we must specify the type of objects that the iterator will read or write:</P>
<pre>
     istream_iterator&lt;int&gt; cin_it(cin);    // <span class="docEmphItalicAlt">reads</span> <span class="docEmphasis">ints1</span> <span class="docEmphItalicAlt">from</span> <span class="docEmphasis">cin</span>
     istream_iterator&lt;int&gt; end_of_stream;  // <span class="docEmphItalicAlt">end iterator value</span>
     // <span class="docEmphItalicAlt">writes</span> <span class="docEmphasis">Sales_items</span> <span class="docEmphItalicAlt">from the</span> <span class="docEmphasis">ofstream</span> <span class="docEmphItalicAlt">named</span> <span class="docEmphasis">outfile</span>
     // <span class="docEmphItalicAlt">each element is followed by a space</span>
     of stream outfile;
     ostream_iterator&lt;Sales_item&gt; output(outfile, " ");
</pre><BR>
<p class="docText">We must bind an <tt>ostream_iterator</tt> to a specific stream. When we create an <tt>istream_iterator</tt>, we can bind it to a stream. Alternatively, we can supply no argument, which creates an iterator that we can use as the off-the-end value. There is no off-the-end iterator for <tt>ostream_iterator</tt>.</p>
<p class="docText">When we create an <tt>ostream_iterator</tt>, we may (optionally) provide a second argument that specifies a delimiter to use when writing elements to the output stream. The delimiter must be a C-style character string. Because it is a C-style string, it must be null-terminated; otherwise, the behavior is undefined.</p>

<a name="ch11lev3sec17"></a>
<h5 class="docSection3Title">Operations on <tt>istream_iterators</tt></h5>
<p class="docText">Constructing an <tt>istream_iterator</tt> bound to a stream positions the iterator so that the first dereference reads the first value from the stream.</p>
<a name="ch11table02"></a><P><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 11.2. <tt>istream_iterator</tt> Operations</H5></caption><colgroup><col width="125"><col width="375"></colgroup><thead></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><a name="idd1e87030"></a><tt>it1 == it2</tt> <br><tt>it1 != it2</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Equality (inequality) between two <tt>istream_iterators</tt>. The iterators must read the same type. Two iterators are equal if they are both the end value. Two non-end-of-stream iterators are equal if they are constructed using the same input stream.</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>*it</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Returns the value read from the stream.</p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>it-&gt;mem</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Synonym for <tt>(*it).mem</tt>. Returns member, <tt>mem</tt>, of the object read from the stream.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>++it it++</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Advances the iterator by reading the next value from the input stream using the <tt>&#187;</tt> operator for the element type. As usual, the prefix version advances the stream and returns a reference to the incremented iterator. The postfix version advances the stream but returns the old value.</p></td></TR></table></P><br>
<p class="docText">As an example, we could use an <tt>istream_iterator</tt> to read the standard input into a <tt>vector</tt>:</P>
<pre>
     istream_iterator&lt;int&gt; in_iter(cin); // <span class="docEmphItalicAlt">read ints from cin</span>
     istream_iterator&lt;int&gt; eof; // <span class="docEmphItalicAlt">istream "end" iterator</span>
     // <span class="docEmphItalicAlt">read until end of file, storing what was read in vec</span>
     while (in_iter != eof)
             // <span class="docEmphItalicAlt">increment advances the stream to the next value</span>
             // <span class="docEmphItalicAlt">dereference reads next value from the</span> <span class="docEmphasis">istream</span>
             vec.push_back(*in_iter++);
</pre><br>
<p class="docText">This loop reads <tt>int</tt>s from <tt>cin</tt>, and stores what was read in <tt>vec</tt>. On each trip the loop checks whether <tt>in_iter</tt> is the same as <tt>eof</tt>. That iterator was defined as the empty <tt>istream_iterator</tt>, which is used as the end iterator. An iterator bound to a stream is equal to the end iterator once its associated stream hits end-of-file or encounters another error.</p>
<p class="docText">The hardest part of this program is the argument to <tt>push_back</tt>, which uses the dereference and postfix increment operators. Precedence rules (<a class="docLink" href="ch05lev1sec5.html#ch05lev1sec5">Section 5.5</a>, p. <a class="docLink" href="ch05lev1sec5.html#ch05lev1sec5">163</a>) say that the result of the increment is the operand to the dereference. Incrementing an <tt>istream_iterator</tt> advances the stream. However, the expression uses the postfix increment, which yields the <span class="docEmphasis">old</span> value of the iterator. The effect of the increment is to read the next value from the stream but return an iterator that refers to the previous value read. We dereference that iterator to obtain that value.</P>
<p class="docText">What is more interesting is that we could rewrite this program as:</P>
<pre>
     istream_iterator&lt;int&gt; in_iter(cin); // <span class="docEmphItalicAlt">read</span> <span class="docEmphasis">ints</span> <span class="docEmphItalicAlt">from</span> <span class="docEmphasis">cin</span>
     istream_iterator&lt;int&gt; eof;      // <span class="docEmphasis">istream</span> <span class="docEmphItalicAlt">"end" iterator</span>
     vector&lt;int&gt; vec(in_iter, eof);  // <span class="docEmphItalicAlt">construct</span> <span class="docEmphasis">vec</span> <span class="docEmphItalicAlt">from an iterator range</span>
</pre><br>
<p class="docText">Here we construct <tt>vec</tt> from a pair of iterators that denote a range of elements. Those iterators are <tt>istream_iterators</tt>, which means that the range is obtained by reading the associated stream. The effect of this constructor is to read <tt>cin</tt> until it hits end-of-file or encounters an input that is not an <tt>int</tt>. The elements that are read are used to construct <tt>vec</tt>.</p>

<a name="ch11lev3sec18"></a>
<h5 class="docSection3Title">Using <tt>ostream_iterators</tt> and <tt>ostream_iterators</tt></h5>
<p class="docText"><a name="idd1e87238"></a><a name="idd1e87244"></a><a name="idd1e87251"></a><a name="idd1e87258"></a>We can use an <tt>ostream_iterator</tt> to write a sequence of values to a stream in much the same way that we might use an iterator to assign a sequence of values to the elements of a container:</p>
<pre>
     // <span class="docEmphItalicAlt">write one string per line to the standard output</span>
     ostream_iterator&lt;string&gt; out_iter(cout, "\n");
     // <span class="docEmphItalicAlt">read strings from standard input and the end iterator</span>
     istream_iterator&lt;string&gt; in_iter(cin), eof;
     // <span class="docEmphItalicAlt">read until eof and write what was read to the standard output</span>
     while (in_iter != eof)
         // <span class="docEmphItalicAlt">write value of</span> <span class="docEmphasis">in_iter to</span> <span class="docEmphItalicAlt">standard output</span>
         // <span class="docEmphItalicAlt">and then increment the iterator to get the next value from</span> <span class="docEmphasis">cin</span>
        *out_iter++ = *in_iter++;
</pre><BR>
<p class="docText">This program reads <tt>cin</tt>, writing each word it reads on separate line on <tt>cout</tt>.</p>
<p class="docText">We start by defining an <tt>ostream_iterator</tt> to write <tt>string</tt>s to <tt>cout</tt>, following each <tt>string</tt> by a newline. We define two <tt>istream_iterators</tt> that we'll use to read <tt>string</tt>s from <tt>cin</tt>. The <tt>while</tt> loop works similarly to our previous example. This time, instead of storing the values we read into a <tt>vector</tt>, we print them to <tt>cout</tt> by assigning the values we read to <tt>out_iter</tt>.</P>
<p class="docText">The assignment works similarly to the one in the program on page <a class="docLink" href="ch06lev1sec7.html#ch06sb03">205</a> that copied one array into another. We dereference both iterators, assigning the right-hand value into the left, incrementing each iterator. The effect is to write what was read to <tt>cout</tt> and then increment each iterator, reading the next value from <tt>cin</tt>.</P>

<a name="ch11lev3sec19"></a>
<h5 class="docSection3Title">Using <tt>istream_iterators</tt> with Class Types</h5>
<p class="docText">We can create an <tt>istream_iterator</tt> for any type for which an input operator (<tt>&gt;&gt;</tt>) exists. For example, we might use an <tt>istream_iterator</tt> to read a sequence of <tt>Sales_item</tt> objects to sum:</p>
<pre>
     istream_iterator&lt;Sales_item&gt; item_iter(cin), eof;
     Sales_item sum; // <span class="docEmphItalicAlt">initially empty</span> <span class="docEmphasis">Sales_item</span>
     sum = *item_iter++; // <span class="docEmphItalicAlt">read first transaction into sum and get next record</span>
     while (item_iter != eof) {
        if (item_iter-&gt;same_isbn(sum))
            sum = sum + *item_iter;
        else {
            cout &lt;&lt; sum &lt;&lt; endl;
            sum = *item_iter;
        }
        ++item_iter; // <span class="docEmphItalicAlt">read next transaction</span>
     }
     cout &lt;&lt; sum &lt;&lt; endl; // <span class="docEmphItalicAlt">remember to print last set of records</span>
</pre><BR>
<p class="docText">This program binds <tt>item_iter</tt> to <tt>cin</tt> and says that the iterator will read objects of type <tt>Sales_item</tt>. The program next reads the first record into <tt>sum</tt>:</P>
<pre>
     sum = *item_iter++; // <span class="docEmphItalicAlt">read first transaction into sum and get next record</span>
</pre><br>
<p class="docText"><a name="idd1e87427"></a><a name="idd1e87433"></a><a name="idd1e87439"></a><a name="idd1e87446"></a><a name="idd1e87453"></a><a name="idd1e87460"></a>This statement uses the dereference operator to fetch the first record from the standard input and assigns that value to <tt>sum</tt>. It increments the iterator, causing the stream to read the next record from the standard input.</p>
<p class="docText">The <tt>while</tt> loop executes until we hit end-of-file on <tt>cin</tt>. Inside the <tt>while</tt>, we compare the <tt>isbn</tt> of the record we just read with <tt>sum</tt>'s <tt>isbn</tt>. The first statement in the <tt>while</tt> uses the arrow operator to dereference the <tt>istream</tt> iterator and obtain the most recently read object. We then run the <tt>same_isbn</tt> member on that object and the object in <tt>sum</tt>.</p>
<p class="docText">If the <tt>isbn</tt>s are the same, we increment the totals in <tt>sum</tt>. Otherwise, we print the current value of <tt>sum</tt> and reset it as a copy of the most recently read transaction. The last step in the loop is to increment the iterator, which in this case causes the next transaction to be read from the standard input. The loop continues until an error or end-of-file is encountered. Before exiting we remember to print the values associated with the last ISBN in the input.</p>

<a name="ch11lev3sec20"></a>
<H5 class="docSection3Title">Limitations on Stream Iterators</h5>
<p class="docText">The stream iterators have several important limitations:</p>
<UL><li><p class="docList">It is not possible to read from an <tt>ostream_iterator</tt>, and it is not possible to write to an <tt>istream_iterator</tt>.</p></LI><li><p class="docList">Once we assign a value to an <tt>ostream_iterator</tt>, the write is committed. There is no way to subsequently change a value once it is assigned. Moreover, each distinct value of an <tt>ostream_iterator</tt> is expected to be used for output exactly once.</P></li><li><p class="docList">There is no <tt>-&gt;</tt> operator for <tt>ostream_iterator</tt>.</p></li></ul>

<a name="ch11lev3sec21"></a>
<h5 class="docSection3Title">Using Stream Iterators with the Algorithms</h5>
<p class="docText">As we know, the algorithms operate in terms of iterator operations. And as we've seen, stream iterators define at least some of the iterator operations. Because the stream iterators support iterator operations, we can use them with at least some of the generic algorithms. As an example, we could read numbers from the standard input and write the unique numbers we read on the standard output:</p>
<pre>
     istream_iterator&lt;int&gt; cin_it(cin);    // <span class="docEmphItalicAlt">reads</span> <span class="docEmphasis">ints</span> <span class="docEmphItalicAlt">from</span> <span class="docEmphasis">cin</span>
     istream_iterator&lt;int&gt; end_of_stream;  // <span class="docEmphItalicAlt">end iterator value</span>
     // <span class="docEmphItalicAlt">initialize</span> <span class="docEmphasis">vec</span> <span class="docEmphItalicAlt">from the standard input:</span>
     vector&lt;int&gt; vec(cin_it, end_of_stream);
     sort(vec.begin(), vec.end());

     // <span class="docEmphItalicAlt">writes</span> <span class="docEmphasis">ints to cout</span> <span class="docEmphItalicAlt">using " " as the delimiter</span>
     ostream_iterator&lt;int&gt; output(cout, " ");

     // <span class="docEmphItalicAlt">write only the unique elements in</span> <span class="docEmphasis">vec</span> <span class="docEmphItalicAlt">to the standard output</span>
     unique_copy(vec.begin(), vec.end(), output);
</pre><br>
<p class="docText">If the input to this program is</p>
<pre>
     <span class="docEmphStrong">23 109 45 89 6 34 12 90 34 23 56 23 8 89 23</span>
</pre><br>
<p class="docText"><a name="idd1e87632"></a><a name="idd1e87639"></a><a name="idd1e87646"></a><a name="idd1e87652"></a><a name="idd1e87658"></a><a name="idd1e87664"></a><a name="idd1e87668"></a><a name="idd1e87674"></a><a name="idd1e87680"></a><a name="idd1e87686"></a><a name="idd1e87694"></a><a name="idd1e87701"></a><a name="idd1e87708"></a><a name="idd1e87715"></a><a name="idd1e87723"></a><a name="idd1e87728"></a><a name="idd1e87735"></a><a name="idd1e87742"></a><a name="idd1e87749"></a><a name="idd1e87756"></a><a name="idd1e87763"></a><a name="idd1e87770"></a><a name="idd1e87777"></a><a name="idd1e87784"></a><a name="idd1e87791"></a><a name="idd1e87798"></a><a name="idd1e87805"></a><a name="idd1e87813"></a><a name="idd1e87823"></a><a name="idd1e87831"></a><a name="idd1e87836"></a><a name="idd1e87841"></a><a name="idd1e87844"></a><a name="idd1e87851"></a><a name="idd1e87858"></a><a name="idd1e87863"></a><a name="idd1e87869"></a><a name="idd1e87875"></a><a name="idd1e87881"></a><a name="idd1e87888"></a><a name="idd1e87895"></a><a name="idd1e87902"></a><a name="idd1e87906"></a><a name="idd1e87913"></a><a name="idd1e87920"></a>then the output would be</p>
<pre>
     <span class="docEmphStrong">6 8 12 23 34 45 56 89 90 109</span>
</pre><br>
<p class="docText">The program creates <tt>vec</tt> from the iterator pair, <tt>input</tt> and <tt>end_of_stream</tt>. The effect of this initializer is to read <tt>cin</tt> until end-of-file or an error occurs. The values read are stored in <tt>vec</tt>.</P>
<p class="docText">Once the input is read and <tt>vec</tt> initialized, we call <tt>sort</tt> to sort the input. Duplicated items from the input will be adjacent after the call to <tt>sort</tt>.</P>
<p class="docText">The program uses <tt>unique_copy</tt>, which is a copying version of <tt>unique</tt>. It copies the unique values in its input range to the destination iterator. This call uses our output iterator as the destination. The effect is to copy the unique values from <tt>vec</tt> to <tt>cout</tt>, following each value by a space.</p>
<a name="ch11sb08"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Exercises Section 11.3.2</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa6q1"></a><b>Exercise 11.16:</b></td><TD><p class="docText">Rewrite the program on 410 to use the <tt>copy</tt> algorithm to write the contents of a file to the standard output.</p>
</TD></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa6q2"></a><b>Exercise 11.17:</b></TD><TD><p class="docText">Use a pair of <tt>istream_iterators</tt> to initialize a <tt>vector</tt> of <tt>int</tt>s.</p>
</td></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch11qa6q3"></a><b>Exercise 11.18:</b></td><TD><p class="docText">Write a program to read a sequence of integer numbers from the standard input using an <tt>istream_iterator</tt>. Write the odd numbers into one file, using an <tt>ostream_iterator</tt>. Each value should be followed by a space. Write the even numbers into a second file, also using an <tt>ostream_iterator</tt>. Each of these values should be placed on a separate line.</p>
</td></TR></table></p>
</blockquote>
</TD></tr></table></p><br>


<a name="ch11lev2sec9"></a>
<h4 class="docSection2Title">11.3.3. Reverse Iterators</h4>
<p class="docText">A reverse iterator is an iterator that traverses a container backward. That is, it traverses from the last element toward the first. A reverse iterator inverts the meaning of increment (and decrement): <tt>++</tt> on a reverse iterator accesses the previous element; <tt>--</tt> accesses the next element.</p>
<p class="docText">Recall that each container defines <tt>begin</tt> and <tt>end</tt> members. These members return respectively an iterator to the first element of the container and an iterator one past the last element of the container. The containers also define <tt>rbegin</tt> and <tt>rend</tt>, which return reverse iterators to the last element in the container and one &quot;past&quot; (that is, one before) the beginning of the container. As with ordinary iterators, there are both <tt>const</tt> and non<tt>const</tt> reverse iterators. <a class="docLink" href="#ch11fig01">Figure 11.1</a> on the facing page illustrates the relationship between these four iterators on a hypothetical <tt>vector</tt> named <tt>vec</tt>.</p>
<a name="ch11fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 11.1. Comparing <tt>begin</tt>/<tt>end</tt> and <tt>rbegin</tt>/<tt>rend</tt> Iterators</h5>

<p class="docText">
<img border="0" alt="" id="195131139046" width="450" height="126" SRC="images/0201721481/graphics/11fig01.gif;400478"></p>

</center></p><br>
<p class="docText">Given a <tt>vector</tt> that contains the numbers from 0 to 9 in ascending order</P>
<pre>
     vector&lt;int&gt; vec;
     for (vector&lt;int&gt;::size_type i = 0; i != 10; ++i)
         vec.push_back(i); // <span class="docEmphasis">elements are 0,1,2,...9</span>
</pre><BR>
<p class="docText">the following <tt>for</tt> loop prints the elements in reverse order:</p>
<pre>
     // <span class="docEmphItalicAlt">reverse iterator of vector from back to front</span>
     vector&lt;int&gt;::reverse_iterator r_iter;
     for (r_iter = vec.rbegin(); // <span class="docEmphItalicAlt">binds</span> <span class="docEmphasis">r_iter to</span> <span class="docEmphItalicAlt">last element</span>
          r_iter != vec.rend();  // <span class="docEmphasis">rend</span> <span class="docEmphItalicAlt">refers 1 before 1st element</span>
          ++r_iter)              // <span class="docEmphItalicAlt">decrements iterator one element</span>
         cout &lt;&lt; *r_iter &lt;&lt; endl;    // <span class="docEmphItalicAlt">prints 9,8,7,...0</span>
</pre><BR>
<p class="docText"><a name="idd1e88170"></a><a name="idd1e88175"></a><a name="idd1e88180"></a>Although it may seem confusing to have the meaning of the increment and decrement operators reversed, doing so lets us use the algorithms transparently to process a container forward or backward. For example, we could sort our <tt>vector</tt> in descending order by passing <tt>sort</tt> a pair of reverse iterators:</p>
<pre>
     // <span class="docEmphItalicAlt">sorts vec in "normal" order</span>
     sort(vec.begin(), vec.end());
     // <span class="docEmphItalicAlt">sorts in reverse: puts smallest element at the end of vec</span>
     sort(vec.rbegin(), vec.rend());
</pre><br>
<a name="ch11lev3sec22"></a>
<H5 class="docSection3Title">Reverse Iterators Require Decrement Operators</H5>
<p class="docText">Not surprisingly, we can define a reverse iterator only from an iterator that supports <tt>--</tt> as well as <tt>++</tt>. After all, the purpose of a reverse iterator is to move the iterator backward through the sequence. The iterators on the standard containers all support decrement as well as increment. However, the stream iterators do not, because it is not possible to move backward through a stream. Therefore, it is not possible to create a reverse iterator from a stream iterator.</p>

<a name="ch11lev3sec23"></a>
<h5 class="docSection3Title">Relationship between Reverse Iterators and Other Iterators</h5>
<p class="docText">Suppose we have a <tt>string</tt> named <tt>line</tt> that contains a comma-separated list of words, and we want to print the first word in <tt>line</tt>. Using <tt>find</tt>, this task is easy:</p>
<pre>
     // <span class="docEmphItalicAlt">find first element in a comma-separated list</span>
     string::iterator comma = find(line.begin(), line.end(), ',');
     cout &lt;&lt; string(line.begin(), comma) &lt;&lt; endl;
</pre><br>
<p class="docText">If there is a comma in <tt>line</tt>, then <tt>comma</tt> refers to that comma; otherwise it is <tt>line.end()</tt>. When we print the <tt>string</tt> from <tt>line.begin()</tt> to <tt>comma</tt> we print characters up to the comma, or the entire <tt>string</tt> if there is no comma.</P>
<p class="docText"><a name="idd1e88277"></a><a name="idd1e88281"></a><a name="idd1e88284"></a><a name="idd1e88289"></a><a name="idd1e88294"></a><a name="idd1e88300"></a><a name="idd1e88305"></a>If we wanted the last word in the list, we could use reverse iterators instead:</p>
<pre>
     // <span class="docEmphItalicAlt">find last element in a comma-separated list</span>
     string::reverse_iterator rcomma =
                            find(line.rbegin(), line.rend(), ',');
</pre><BR>
<p class="docText">Because we pass <tt>rbegin()</tt> and <tt>rend()</tt>, this call starts with the last character in <tt>line</tt> and searches backward. When <tt>find</tt> completes, if there is a comma, then <tt>rcomma</tt> refers to the last comma in the linethat is it refers to the first comma found in the backward search. If there is no comma, then <tt>rcomma</tt> is <tt>line.rend()</tt>.</P>
<p class="docText">The interesting part comes when we try to print the word we found. The direct attempt</p>
<pre>
     // <span class="docEmphItalicAlt">wrong: will generate the word in reverse order</span>
     cout &lt;&lt; string(line.rbegin(), rcomma) &lt;&lt; endl;
</pre><br>
<p class="docText">generates bogus output. For example, had our input been</p>
<pre>
     <span class="docEmphStrong">FIRST,MIDDLE,LAST</span>
</pre><BR>
<p class="docText">then this statement would print <tt>TSAL</tt>!</P>
<p class="docText"><a class="docLink" href="#ch11fig02">Figure 11.2</a> illustrates the problem: We are using reverse iterators, and such iterators process the <tt>string</tt> backward. To get the right output, we need to transform the reverse iterators <tt>line.rbegin()</tt> and <tt>rcomma</tt> into normal iterators that go forward. There is no need to transform <tt>line.rbegin()</tt> as we already know that the result of that transformation would be <tt>line.end()</tt>. We can transform <tt>rcomma</tt> by calling <tt>base</tt>, which is a member of each reverse iterator type:</p>
<a name="ch11fig02"></a><p><center>
<h5 class="docFigureTitle">Figure 11.2. Relationship between Reverse and Ordinary Iterators</h5>

<p class="docText">
<img border="0" alt="" id="195131139046" width="415" height="123" SRC="images/0201721481/graphics/11fig02.gif;400478"></P>

</center></p><br>
<pre>
     // <span class="docEmphItalicAlt">ok: get a forward iterator and read to end of</span> <span class="docEmphasis">line</span>
     cout &lt;&lt; string(rcomma.base(), line.end()) &lt;&lt; endl;
</pre><BR>
<p class="docText">Given the same preceeding input, this statement prints <tt>LAST</tt> as expected.</p>
<p class="docText">The objects shown in <a class="docLink" href="#ch11fig02">Figure 11.2</a> visually illustrate the relationship between ordinary and reverse iterators. For example, <tt>rcomma</tt> and <tt>rcomma.base()</tt> refer to different elements, as do <tt>line.rbegin()</tt> and <tt>line.end()</tt>. These differences are needed to ensure that the range of elements whether processed forward or backward is the same. Technically speaking, the relationship between <a name="idd1e88451"></a><a name="idd1e88456"></a><a name="idd1e88460"></a>normal and reverse iterators is designed to accommodate the properties of a left-inclusive range (<a class="docLink" href="ch09lev1sec2.html#ch09lev2sec4">Section 9.2.1</a>, p. <a class="docLink" href="ch09lev1sec2.html#ch09lev2sec4">314</a>), so that <tt>[line.rbegin(), rcomma)</tt> and <tt>[rcomma.base(), line.end())</tt> refer to the same elements in <tt>line</tt>.</p>
<a name="ch11note06"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> The fact that reverse iterators are intended to represent ranges and that these ranges are asymmetric has an important consequence. When we initialize or assign a reverse iterator from a plain iterator, the resulting iterator does not refer to the same element as the original.</p></td></tr></table><br>
</p></div><br>
<a name="ch11sb09"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 11.3.3</h2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><td align="right" class="docText" width="50"><a name="ch11qa7q1"></a><B>Exercise 11.19:</b></td><td><p class="docText">Write a program that uses <tt>reverse_iterators</tt> to print the contents of a <tt>vector</tt> in reverse order.</P>
</TD></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa7q2"></a><b>Exercise 11.20:</b></td><TD><p class="docText">Now print the elements in reverse order using ordinary iterators.</p>
</TD></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa7q3"></a><b>Exercise 11.21:</b></TD><TD><p class="docText">Use <tt>find</tt> to find the last element in a <tt>list</tt> of <tt>int</tt>s with value 0.</p>
</td></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch11qa7q4"></a><b>Exercise 11.22:</b></td><TD><p class="docText">Given a <tt>vector</tt> that has 10 elements, copy the elements from position 3 through 7 in reverse order to a <tt>list</tt>.</p>
</td></TR></table></p>
</blockquote>
</TD></tr></table></p><br>


<a name="ch11lev2sec10"></a>
<h4 class="docSection2Title">11.3.4. <tt>const</tt> Iterators</h4>
<p class="docText">Careful readers will have noted that in the program on page <a class="docLink" href="ch11lev1sec1.html#ch11lev1sec1">392</a> that used <tt>find</tt>, we defined <tt>result</tt> as a <tt>const_iterator</tt>. We did so because we did not intend to use the iterator to change a container element.</p>
<p class="docText">On the other hand, we used a plain, non<tt>const</tt> iterator to hold the return from <tt>find_first_of</tt> on page <a class="docLink" href="ch11lev1sec2.html#ch11sb03">397</a>, even though we did not intend to change any container elements in that program either. The difference in treatment is subtle and deserves an explanation.</p>
<p class="docText">The reason is that in the second case, we use the iterator as an argument to <tt>find_first_of:</tt></p>
<pre>
     find_first_of(it, roster1.end(),
                   roster2.begin(), roster2.end())
</pre><br>
<p class="docText">The input range for this call is specified by <tt>it</tt> and the iterator returned from a call to <tt>roster1.end()</tt>. Algorithms require the iterators that denote a range to have <span class="docEmphasis">exactly</span> the same type. The iterator returned by <tt>roster1.end()</tt> depends on the type of <tt>roster1</tt>. If that container is a <tt>const</tt> object, then the iterator is <tt>const_iterator;</tt> otherwise, it is the plain <tt>iterator</tt> type. In this program, <tt>roster1</tt> was not <tt>const</tt>, and so <tt>end</tt> returns an <tt>iterator</tt>.</p>
<p class="docText">If we defined <tt>it</tt> as a <tt>const_iterator</tt>, the call to <tt>find_first_of</tt> would not compile. The types of the iterators used to denote the range would not have been identical. <tt>it</tt> would have been a <tt>const_iterator</tt>, and the iterator returned by <tt>roster1.end()</tt> would be <tt>iterator</tt>.</p>

<a name="ch11lev2sec11"></a>
<h4 class="docSection2Title">11.3.5. The Five Iterator Categories</h4>
<p class="docText"><a name="idd1e88682"></a><a name="idd1e88687"></a><a name="idd1e88690"></a><a name="idd1e88695"></a><a name="idd1e88700"></a><a name="idd1e88703"></a><a name="idd1e88708"></a><a name="idd1e88713"></a><a name="idd1e88718"></a>Iterators define a common set of operations, but some iterators are more powerful than other iterators. For example, <tt>ostream_iterators</tt> support only increment, dereference, and assignment. Iterators on <tt>vector</tt>s support these operations and the decrement, relational, and arithmetic operators as well. As a result, we can classify iterators based on the set of operations they provide.</P>
<p class="docText">Similarly, we can categorize algorithms by the kinds of operations they require from their iterators. Some, such as <tt>find</tt>, require only the ability to read through the iterator and to increment it. Others, such as <tt>sort</tt>, require the ability to read, write, and randomly access elements. The iterator operations required by the algorithms are grouped into five categories. These five categories correspond to five categories of iterators, which are summarized in <a class="docLink" href="#ch11table03">Table 11.3</a>.</P>
<a name="ch11table03"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 11.3. Iterator Categories</h5></caption><colgroup><col width="200"><col width="300"></colgroup><thead></thead><tr><TD class="docTableCell" align="left" valign="top"><p class="docText">Input iterator</P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Read, but not write; increment only</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText">Output iterator</P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Write, but not read; increment only</p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText">Forward iterator</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Read and write; increment only</P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText">Bidirectional iterator</p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Read and write; increment and decrement</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">Random access iterator</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Read and write; full iterator arithmetic</p></td></tr></table></p><br>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList"><B><a name="ch11term6"></a><a class="docLink" href="ch11lev1sec7.html#gloss11_06">Input iterators</a></b> can read the elements of a container but are not guaranteed to be able to write into a container. An input iterator must provide the following minimum support:</P><ul><LI><p class="docList">Equality and inequality operators (<tt>==, !=</tt>) to compare two iterators.</p></li><LI><p class="docList">Prefix and postfix increment (<tt>++</tt>) to advance the iterator.</P></li><li><p class="docList">Dereference operator (<tt>*</tt>) to read an element; dereference may appear only on the right-hand side of an assignment.</p></li><li><p class="docList">The arrow operator (<tt>-&gt;</tt>) as a synonym for <tt>(*it).member</tt> that is, dereference the iterator and fetch a member from the underlying object.</P></li></UL><p class="docList">Input iterators may be used only sequentially; there is no way to examine an element once the input iterator has been incremented. Generic algorithms requiring only this level of support include <tt>find</tt> and <tt>accumulate</tt>. The library <tt>istream_iterator</tt> type is an input iterator.</P></div></li><li><div style="font-weight:normal"><p class="docList"><b><a name="ch11term13"></a><a class="docLink" href="ch11lev1sec7.html#gloss11_13">Output iterators</a></b> can be thought of as having complementary functionality to input iterators; An output iterator can be used to write an element but it is not guaranteed to support reading. Output iterators require:</P><UL><li><p class="docList">Prefix and postfix increment (<tt>++</tt>) to advance the iterator.</p></li><li><p class="docList">Dereference (<tt>*</tt>), which may appear only as the left-hand side of an assignment. Assigning to a dereferenced output iterator writes to the underlying element.</P></li></ul><p class="docList"><a name="idd1e88898"></a><a name="idd1e88901"></a><a name="idd1e88909"></a><a name="idd1e88917"></a><a name="idd1e88925"></a><a name="idd1e88930"></a><a name="idd1e88936"></a><a name="idd1e88939"></a><a name="idd1e88945"></a><a name="idd1e88950"></a><a name="idd1e88955"></a><a name="idd1e88960"></a><a name="idd1e88965"></a><a name="idd1e88970"></a><a name="idd1e88975"></a><a name="idd1e88980"></a><a name="idd1e88986"></a><a name="idd1e88992"></a><a name="idd1e88999"></a><a name="idd1e89002"></a><a name="idd1e89008"></a><a name="idd1e89014"></a><a name="idd1e89020"></a><a name="idd1e89026"></a><a name="idd1e89032"></a>Output iterators may require that each iterator value must be written exactly once. When using an output iterator, we should use <tt>*</tt> once and only once on a given iterator value. Output iterators are generally used as a third argument to an algorithm and mark the position where writing should begin. For example, the <tt>copy</tt> algorithm takes an output iterator as its third parameter and copies elements from its input range to the destination indicated by the output iterator. The <tt>ostream_iterator</tt> type is an output iterator.</P></div></li><li><div style="font-weight:normal"><p class="docList"><B><a name="ch11term3"></a><a class="docLink" href="ch11lev1sec7.html#gloss11_03">Forward iterators</a></b> read from and write to a given container. They move in only one direction through the sequence. Forward iterators support all the operations of both input iterators and output iterators. In addition, they can read or write the same element multiple times. We can copy a forward iterator to remember a place in the sequence so as to return to that place later. Generic algorithms that require a forward iterator include <tt>replace</tt>.</p></div></LI><li><div style="font-weight:normal"><p class="docList"><b><a name="ch11term2"></a><a class="docLink" href="ch11lev1sec7.html#gloss11_02">Bidirectional iterators</a></b> read from and write to a container in both directions. In addition to supporting all the operations of a forward iterator, a bidirectional iterator also supports the prefix and postfix decrement (<tt>--</tt>) operators. Generic algorithms requiring a bidirectional iterator include <tt>reverse</tt>. All the library containers supply iterators that at a minimum meet the requirements for a bidirectional iterator.</p></div></li><li><div style="font-weight:normal"><p class="docList"><b><a name="ch11term15"></a><a class="docLink" href="ch11lev1sec7.html#gloss11_15">Random-access iterators</a></b> provide access to any position within the container in constant time. These iterators support all the functionality of bidirectional iterators. In addition, random-access iterators support:</p><ul><li><p class="docList">The relational operators <tt>&lt;, &lt;=, &gt;</tt>, and <tt>&gt;=</tt> to compare the relative positions of two iterators.</p></li><li><p class="docList">Addition and subtraction operators <tt>+, +=, -</tt>, and <tt>-=</tt> between an iterator and an integral value. The result is the iterator advanced (or retreated) the integral number of elements within the container.</p></LI><LI><p class="docList">The subtraction operator <tt>-</tt> when applied to two iterators, which yields the distance between two iterators.</p></LI><li><p class="docList">The subscript operator <tt>iter[n]</tt> as a synonym for <tt>*(iter + n)</tt>.</p></LI></UL><p class="docList">Generic algorithms requiring a random-access iterator include the <tt>sort</tt> algorithms. The <tt>vector, deque</tt>, and <tt>string</tt> iterators are random-access iterators, as are pointers when used to access elements of a built-in array.</p></div></li></ol></div>
<p class="docText">With the exception of output iterators, the <span class="docEmphRoman"><a name="ch11term10"></a><a class="docLink" href="ch11lev1sec7.html#gloss11_10">iterator categories</a></span> form a sort of hierarchy: Any iterator of a higher category can be used where an iterator of lesser power is required. We can call an algorithm requiring an input iterator with an input iterator or a forward, bidirectional, or random-access iterator. Only a random-access iterator may be passed to an algorithm requiring a random-access iterator.</p>
<p class="docText">The <tt>map, set</tt>, and <tt>list</tt> types provide bidirectional iterators. Iterators on <tt>string, vector</tt>, and <tt>deque</tt> are random-access iterators, as are pointers bound to arrays. An <tt>istream_iterator</tt> is an input iterator, and an <tt>ostream_iterator</tt> is an output iterator.</p>
<a name="ch11sb10"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<H2 class="docSidebarTitle">Key Concept: Associative Containers and the Algorithms</H2>
<p class="docText"><a name="idd1e89170"></a><a name="idd1e89175"></a><span class="docEmphStrong">Although the <tt>map</tt> and <tt>set</tt> types provide bidirectional iterators, we can use only a subset of the algorithms on associative containers. The problem is that the key in an associative container is <tt>const</tt></span><span class="docEmphStrong">. Hence, any algorithm that writes to elements in the sequence cannot be used on an associative container. We may use iterators bound to associative containers only to supply arguments that will be read.</span></p>
<a name="ch11note07"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="84" height="51" SRC="images/0201721481/graphics/tip.jpg;400478"></TD><td valign="top"><p class="docText"> <span class="docEmphStrong">When dealing with the algorithms, it is best to think of the iterators on associative containers as if they were input iterators that also support decrement, not as full bidirectional iterators.</span></p></td></tr></table><BR>
</p></div><br>
</TD></tr></table></p><BR>
<p class="docText">The C++ standard specifies the minimum iterator category for each iterator parameter of the generic and numeric algorithms. For example, <tt>find</tt>which implements a one-pass, read-only traversal over a containerminimally requires an input iterator. The <tt>replace</tt> function requires a pair of iterators that are at least forward iterators. The first two iterators to <tt>replace_copy</tt> must be at least forward. The third, which represents a destination, must be at least an output iterator.</p>
<p class="docText">For each parameter, the iterator must be at least as powerful as the stipulated minimum. Passing an iterator of a lesser power results in an error; passing an stronger iterator type is okay.</P>
<a name="ch11note08"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> Errors in passing an invalid category of iterator to an algorithm are not guaranteed to be caught at compile-time.</p></td></tr></table><br>
</p></div><br>
<a name="ch11sb11"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<H2 class="docSidebarTitle">Exercises Section 11.3.5</h2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa8q1"></a><B>Exercise 11.23:</b></TD><td><p class="docText">List the five iterator categories and the operations that each supports.</p>
</td></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch11qa8q2"></a><b>Exercise 11.24:</b></TD><TD><p class="docText">What kind of iterator does a <tt>list</tt> have? What about a <tt>vector</tt>?</p>
</td></tr><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch11qa8q3"></a><b>Exercise 11.25:</b></td><td><p class="docText">What kinds of iterators do you think <tt>copy</tt> requires? What about <tt>reverse</tt> or <tt>unique</tt>?</p>
</TD></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch11qa8q4"></a><b>Exercise 11.26:</b></td><TD><p class="docText">Explain why each of the following is incorrect. Identify which errors should be caught during compilation.</p>
<pre>
     (a) string sa[10];
         const vector&lt;string&gt; file_names(sa, sa+6);
         vector&lt;string&gt;::iterator it = file_names.begin()+2;

     (b) const vector&lt;int&gt; ivec;
         fill(ivec.begin(), ivec.end(), ival);

     (c) sort(ivec.begin(), ivec.rend());

     (d) sort(ivec1.begin(), ivec2.end());
</pre><BR>
</td></tr></table></p>
</blockquote>
</td></tr></table></p><br>


<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch11lev1sec2.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch11lev1sec4.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>