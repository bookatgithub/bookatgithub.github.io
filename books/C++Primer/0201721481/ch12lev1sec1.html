<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 12.1.&nbsp; Class Definitions and Declarations</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch12.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch12lev1sec2.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch12lev1sec1"></a>
<h3 class="docSection1Title">12.1. Class Definitions and Declarations</h3>
<p class="docText">Starting from <a class="docLink" href="ch01.html#ch01">Chapter 1</a>, our programs have used classes. The library types we've used<tt>vector, istream, string</tt>are all class types. We've also defined some simple classes of our own, such as the <tt>Sales_item</tt> and <tt>TextQuery</tt> classes. To recap, let's look again at the <tt>Sales_item</tt> class:</P>
<pre>
class Sales_item {
public:
    // <span class="docEmphItalicAlt">operations on</span> <span class="docEmphasis">Sales_item</span> <span class="docEmphItalicAlt">objects</span>
    double avg_price() const;
    bool same_isbn(const Sales_item &amp;rhs) const
        { return isbn == rhs.isbn; }
    // <span class="docEmphItalicAlt">default constructor needed to initialize members of built-in type</span>
    Sales_item(): units_sold(0), revenue(0.0) { }
private:
    std::string isbn;
    unsigned units_sold;
    double revenue;
};

double Sales_item::avg_price() const
{
    if (units_sold)
        return revenue/units_sold;
    else
        return 0;
}
</pre><BR>
<a name="ch12lev2sec1"></a>
<h4 class="docSection2Title">12.1.1. Class Definitions: A Recap</H4>
<p class="docText">In writing this class in <a class="docLink" href="ch02lev1sec8.html#ch02lev1sec8">Section 2.8</a> (p. <a class="docLink" href="ch02lev1sec8.html#ch02lev1sec8">63</a>) and <a class="docLink" href="ch07lev1sec7.html#ch07lev1sec7">Section 7.7</a> (p. <a class="docLink" href="ch07lev1sec7.html#ch07lev1sec7">258</a>), we already learned a fair bit about classes.</p>
<a name="ch12note01"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> Most fundamentally, a class defines a new type and a new scope.</p></td></tr></table><BR>
</p></div><BR>
<a name="ch12lev3sec1"></a>
<H5 class="docSection3Title">Class Members</h5>
<p class="docText">Each class defines zero or more members. Members can be either data, functions, or type definitions.</p>
<p class="docText"><a name="idd1e91140"></a><a name="idd1e91147"></a><a name="idd1e91154"></a><a name="idd1e91159"></a><a name="idd1e91162"></a><a name="idd1e91165"></a><a name="idd1e91171"></a><a name="idd1e91174"></a><a name="idd1e91177"></a><a name="idd1e91182"></a>A class may contain multiple <tt>public, private</tt>, and <tt>protected</tt> sections. We've already used the <tt>public</tt> and <tt>private</tt> access labels: Members defined in the <tt>public</tt> section are accessible to all code that uses the type; those defined in the <tt>private</tt> section are accessible to other class members. We'll have more to say about <tt>protected</tt> when we discuss inheritance in <a class="docLink" href="ch15.html#ch15">Chapter 15</a>.</p>
<p class="docText">All members must be declared inside the class; there is no way to add members once the class definition is complete.</P>

<a name="ch12lev3sec2"></a>
<H5 class="docSection3Title">Constructors</h5>
<p class="docText">When we create an object of a class type, the compiler automatically uses a constructor (<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec12">Section 2.3.3</a>, p. <a class="docLink" href="ch02lev1sec3.html#ch02lev2sec12">49</a>) to initialize the object. A constructor is a special member function that has the same name as the class. Its purpose is to ensure that each data member is set to sensible initial values.</p>
<p class="docText">A constructor generally should use a <span class="docEmphRoman"><a name="ch12term9"></a><a class="docLink" href="ch12lev1sec8.html#gloss12_09">constructor initializer list</a></span> (<a class="docLink" href="ch07lev1sec7.html#ch07lev2sec24">Section 7.7.3</a>, p. <a class="docLink" href="ch07lev1sec7.html#ch07lev2sec24">263</a>), to initialize the data members of the object:</p>
<pre>
// <span class="docEmphItalicAlt">default constructor needed to initialize members of built-in type</span>
Sales_item(): units_sold(0), revenue(0.0) { }
</pre><br>
<p class="docText">The constructor initializer list is a list of member names and parenthesized initial values. It follows the constructor's parameter list and begins with a colon.</P>

<a name="ch12lev3sec3"></a>
<h5 class="docSection3Title">Member Functions</h5>
<p class="docText">Member functions must be declared, and optionally may be defined, inside the class; functions defined inside the class are <tt>inline</tt> (<a class="docLink" href="ch07lev1sec6.html#ch07lev1sec6">Section 7.6</a>, p. <a class="docLink" href="ch07lev1sec6.html#ch07lev1sec6">256</a>) by default.</P>
<p class="docText">Member functions defined outside the class must indicate that they are in the scope of the class. The definition of <tt>Sales_item::avg_price</tt> uses the scope operator (<a class="docLink" href="ch01lev1sec2.html#ch01lev2sec3">Section 1.2.2</a>, p. <a class="docLink" href="ch01lev1sec2.html#ch01lev2sec3">8</a>) to indicate that the definition is for the <tt>avg_price</tt> function of the <tt>Sales_item</tt> class.</p>
<p class="docText">Member functions take an extra implicit argument that binds the function to the object on behalf of which the function is calledwhen we write</p>
<pre>
trans.avg_price()
</pre><BR>
<p class="docText">we are calling the <tt>avg_price</tt> function on the object named <tt>trans</tt>. If <tt>TRans</tt> is a <tt>Sales_item</tt> object, then references to a member of the <tt>Sales_item</tt> class inside the <tt>avg_price</tt> function are to the members in <tt>trans</tt>.</p>
<p class="docText">Member functions may be declared <tt>const</tt> by putting the <tt>const</tt> keyword following the parameter list:</p>
<pre>
double avg_price() const;
</pre><br>
<p class="docText">A <tt>const</tt> member may not change the data members of the object on which it operates. The <tt>const</tt> must appear in both the declaration and definition. It is a compile-time error for the <tt>const</tt> to be indicated on one but not the other.</p>
<a name="ch12sb01"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 12.1.1</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa1q1"></a><B>Exercise 12.1:</b></TD><td><p class="docText"><a name="idd1e91373"></a><a name="idd1e91376"></a><a name="idd1e91379"></a><a name="idd1e91385"></a><a name="idd1e91391"></a><a name="idd1e91396"></a><a name="idd1e91399"></a><a name="idd1e91402"></a><a name="idd1e91405"></a><a name="idd1e91408"></a><a name="idd1e91413"></a><a name="idd1e91418"></a>Write a class named <tt>Person</tt> that represents the name and address of a person. Use a <tt>string</tt> to hold each of these elements.</P>
</td></tr><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch12qa1q2"></a><b>Exercise 12.2:</b></td><td><p class="docText">Provide a constructor for <tt>Person</tt> that takes two <tt>string</tt>s.</p>
</td></TR><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch12qa1q3"></a><B>Exercise 12.3:</b></td><td><p class="docText">Provide operations to return the name and address. Should these functions be <tt>const</tt>? Explain your choice.</p>
</TD></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa1q4"></a><b>Exercise 12.4:</b></td><TD><p class="docText">Indicate which members of <tt>Person</tt> you would declare as <tt>public</tt> and which you would declare as <tt>private</tt>. Explain your choice.</p>
</td></TR></table></p>
</blockquote>
</td></TR></table></p><BR>


<a name="ch12lev2sec2"></a>
<h4 class="docSection2Title">12.1.2. Data Abstraction and Encapsulation</h4>
<p class="docText">The fundamental ideas behind classes are <b><a name="ch12term11"></a><a class="docLink" href="ch12lev1sec8.html#gloss12_11">data abstraction</a></b> and <b><a name="ch12term13"></a><a class="docLink" href="ch12lev1sec8.html#gloss12_13">encapsulation</a></b>.</p>
<p class="docText">Data abstraction is a programming (and design) technique that relies on the separation of interface and implementation. The class designer must worry about how a class is implemented, but programmers that use the class need not know about these details. Instead, programmers who use a type need to know only the type's interface; they can think <span class="docEmphasis">abstractly</span> about what the type does rather than concretely about how the type works.</p>
<p class="docText">Encapsulation is a term that describes the technique of combining lower-level elements to form a new, higher-level entity. A function is one form of encapsulation: The detailed actions performed by the function are <span class="docEmphasis">encapsulated</span> in the larger entity that is the function itself. Encapsulated elements hide the details of their implementationwe may call a function but have no access to the statements that it executes. In the same way, a class is an encapsulated entity: It represents an aggregation of several members, and most (well-designed) class types hide the members that implement the type.</p>
<p class="docText">If we think about the library <tt>vector</tt> type, it is an example of both data abstraction and encapsulation. It is abstract in that to use it, we think about its interfaceabout the operations that it can perform. It is encapsulated because we have no access to the details of how the type is representated nor to any of its implementation artifacts. An array, on the other hand, is similar in concept to a <tt>vector</tt> but is neither abstract nor encapsulated. We manipulate an array directly by accessing the memory in which the array is stored.</p>
<a name="ch12lev3sec4"></a>
<h5 class="docSection3Title">Access Labels Enforce Abstraction and Encapsulation</h5>
<p class="docText">In C++ we use <span class="docEmphRoman"><a name="ch12term2"></a><a class="docLink" href="ch12lev1sec8.html#gloss12_02">access labels</a></span> (<a class="docLink" href="ch02lev1sec8.html#ch02lev1sec8">Section 2.8</a>, p. <a class="docLink" href="ch02lev1sec8.html#ch02lev1sec8">65</a>) to define the abstract interface to the class and to enforce encapsulation. A class may contain zero or more access labels:</p>
<ul><li><p class="docList">Members defined after a <tt>public</tt> label are accessible to all parts of the program. The data-abstraction view of a type is defined by its <span class="docEmphRoman"><a name="ch12term22"></a><a class="docLink" href="ch12lev1sec8.html#gloss12_22"><span class="docEmphRoman"><tt>public</tt> members</span></a></span>.</P></LI><li><p class="docList">Members defined after a <tt>private</tt> label are not accessible to code that uses the class. The <tt>private</tt> sections encapsulate (e.g., hide) the implementation from code that uses the type.</P></li></ul>
<p class="docText"><a name="idd1e91568"></a><a name="idd1e91573"></a><a name="idd1e91578"></a><a name="idd1e91583"></a><a name="idd1e91586"></a><a name="idd1e91591"></a>There are no restrictions on how often an access label may appear. Each access label specifies the access level of the succeeding member definitions. The specified access level remains in effect until the next access label is encountered or the closing right brace of the class body is seen.</P>
<p class="docText">A class may define members before any access label is seen. The access level of members defined after the open curly of the class and before the first access label depend on how the class is defined. If the class is defined with the <span class="docEmphRoman"><a name="ch12term24"></a><a class="docLink" href="ch12lev1sec8.html#gloss12_24"><span class="docEmphRoman"><tt>struct</tt> keyword</span></a></span>, then members defined before the first access label are <tt>public</tt>; if the class is defined using the <span class="docEmphRoman"><a name="ch12term5"></a><a class="docLink" href="ch12lev1sec8.html#gloss12_05"><span class="docEmphRoman"><tt>class</tt> keyword</span></a></span>, then the members are <tt>private</tt>.</P>
<a name="ch12sb02"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Advice: Concrete and Abstract Types</h2>
<p class="docText"><span class="docEmphStrong">Not all types need to be abstract. The library <tt>pair</tt> class is a good example of a useful, well-designed class that is concrete rather than abstract. A <span class="docEmphRoman"><a name="ch12term7"></a><a class="docLink" href="ch12lev1sec8.html#gloss12_07">concrete class</a></span> is a class that exposes, rather than hides, its implementation.</span></P>
<p class="docText"><span class="docEmphStrong">Some classes, such as <tt>pair</tt>, really have no abstract interface. The <tt>pair</tt> type exists to bundle two data members into a single object. There is no need or advantage to hiding the data members. Hiding the members in a class like <tt>pair</tt> would only complicate the use of the type.</span></p>
<p class="docText"><span class="docEmphStrong">Even so, such types often have member functions. In particular, it is a good idea for any class that has data members of built-in or compound type to define constructor(s) to initialize those members. The user of the class could initialize or assign to the data members but it is less error-prone for the class to do so.</span></P>
</TD></tr></table></p><br>

<a name="ch12lev3sec5"></a>
<H5 class="docSection3Title">Different Kinds of Programming Roles</H5>
<p class="docText">Programmers tend to think about the people who will run their applications as &quot;users.&quot; Applications are designed for and evolve in response to feedback from those who ultimately &quot;use&quot; the applications. Classes are thought of in a similar way: A class designer designs and implements a class for &quot;users&quot; of that class. In this case, the &quot;user&quot; is a programmer, not the ultimate user of the application.</p>
<p class="docText">Authors of successful applications do a good job of understanding and implementing the needs of the application's users. Similarly, well-designed, useful classes are designed with a close attention to the needs of the users of the class.</p>
<p class="docText">In another way, the division between class designer and class user reflects the division between users of an application and the designers and implementors of the application. Users care only if the application meets their needs in a cost-effective way. Similarly, users of a class care only about its interface. Good class designers define a class interface that is intuitive and easy to use. Users care about the implementation only in so far as the implementation affects their use of the class. If the implementation is too slow or puts burdens on users of the class, then the users must care. In well-designed classes, only the class designer worries about the implementation.</p>
<p class="docText">In simple applications, the user of a class and the designer of the class might be one and the same person. Even in such cases, it is useful to keep the roles distinct. When designing the interface to a class, the class designer should think about how <a name="idd1e91667"></a><a name="idd1e91672"></a><a name="idd1e91677"></a><a name="idd1e91680"></a>easy it will be to use the class. When using the class, the designer shouldn't think about how the class works.</p>
<a name="ch12note02"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></TD><td valign="top"><p class="docText"> C++ programmers tend to speak of &quot;users&quot; interchangably as users of the application or users of a class.</p></TD></tr></table><BR>
</p></div><br>
<p class="docText">When referring to a &quot;user,&quot; the context makes it clear which kind of user is meant. If we speak of &quot;user code&quot; or the &quot;user&quot; of the <tt>Sales_item</tt> class, we mean a programmer who is using a class in writing an application. If we speak of the &quot;user&quot; of the bookstore application, we mean the manager of the store who is running the application.</p>
<a name="ch12sb03"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Key Concept: Benefits of Data Abstraction and Encapsulation</h2>
<p class="docText"><span class="docEmphStrong">Data abstraction and encapsulation provide two important advantages:</span></p>
<ul><li><p class="docList"><span class="docEmphStrong">Class internals are protected from inadvertent user-level errors, which might corrupt the state of the object.</span></p></li><LI><p class="docList"><span class="docEmphStrong">The class implementation may evolve over time in response to changing requirements or bug reports without requiring change in user-level code.</span></P></li></UL>
<p class="docText"><span class="docEmphStrong">By defining data members only in the <tt>private</tt> section of the class, the class author is free to make changes in the data. If the implementation changes, only the class code needs to be examined to see what affect the change may have. If data are <tt>public</tt>, then any function that directly accesses the data members of the old representation might be broken. It would be necessary to locate and rewrite all those portions of code that relied on the old representation before the program could be used again.</span></p>
<p class="docText"><span class="docEmphStrong">Similarly, if the internal state of the class is <tt>private</tt>, then changes to the member data can happen in only a limited number of places. The data is protected from mistakes that users might introduce. If there is a bug that corrupts the object's state, the places to look for the bug are localized: When data are <tt>private</tt>, only a member function could be responsible for the error. The search for the mistake is limited, greatly easing the problems of maintenance and program correctness.</span></p>
<p class="docText"><span class="docEmphStrong">If the data are <tt>private</tt> and if the interface to the member functions does not change, then user functions that manipulate class objects require no change.</span></P>
<a name="ch12note03"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> <span class="docEmphStrong">Because changing a class definition in a header file effectively changes the text of every source file that includes that header, code that uses a class must be recompiled when the class changes.</span></p></TD></tr></table><BR>
</P></div><br>
</td></tr></table></P><BR>


<a name="ch12lev2sec3"></a>
<h4 class="docSection2Title">12.1.3. More on Class Definitions</h4>
<p class="docText">The classes we've defined so far have been simple; yet they have allowed us to explore quite a bit of the language support for classes. There remain a few more details about the basics of writing a class that we shall cover in the remainder of this section.</p>
<a name="ch12sb04"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<h2 class="docSidebarTitle">Exercises Section 12.1.2</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch12qa2q1"></a><b>Exercise 12.5:</b></TD><td><p class="docText"><a name="idd1e91790"></a><a name="idd1e91797"></a><a name="idd1e91802"></a><a name="idd1e91807"></a><a name="idd1e91811"></a>What are the access labels supported by C++ classes? What kinds of members should be defined after each access label? What, if any, are the constraints on where and how often an access label may appear inside a class definition?</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa2q2"></a><b>Exercise 12.6:</b></td><td><p class="docText">How do classes defined with the <tt>class</tt> keyword differ from those defined as <tt>struct</tt>?</p>
</td></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch12qa2q3"></a><B>Exercise 12.7:</b></td><TD><p class="docText">What is encapsulation? Why it is useful?</p>
</td></TR></table></P>
</blockquote>
</td></tr></table></p><br>
<a name="ch12lev3sec6"></a>
<h5 class="docSection3Title">Multiple Data Members of the Same Type</H5>
<p class="docText">As we've seen, class data members are declared similarly to how ordinary variables are declared. One way in which member declarations and ordinary declarations are the same is that if a class has multiple data members with the same type, these members can be named in a single member declaration.</p>
<p class="docText">For example, we might define a type named <tt>Screen</tt> to represent a window on a computer. Each <tt>Screen</tt> would have a <tt>string</tt> member that holds the contents of the window, and three <tt>string::size_type</tt> members: one that specifies the character on which the cursor currently rests, and two others that specify the height and width of the window. We might define the members of this class as:</P>
<pre>
     class Screen {
     public:
         // <span class="docEmphItalicAlt">interface member functions</span>
     private:
         std::string contents;
         std::string::size_type cursor;
         std::string::size_type height, width;
     };
</pre><BR>

<a name="ch12lev3sec7"></a>
<h5 class="docSection3Title">Using Typedefs to Streamline Classes</h5>
<p class="docText">In addition to defining data and function members, a class can also define its own local names for types. Our <tt>Screen</tt> will be a better abstraction if we provide a typedef for <tt>std::string::size_type:</tt></p>
<pre>
     class Screen {
     public:
         // <span class="docEmphItalicAlt">interface member functions</span>
         typedef std::string::size_type index;
     private:
         std::string contents;
         index cursor;
         index height, width;
     };
</pre><BR>
<p class="docText">Type names defined by a class obey the standard access controls of any other member. We put the definition of <tt>index</tt> in the <tt>public</tt> part of the class because <a name="idd1e91914"></a><a name="idd1e91919"></a><a name="idd1e91924"></a><a name="idd1e91927"></a>we want users to use that name. Users of class <tt>Screen</tt> need not know that we use a <tt>string</tt> as the underlying implementation. By defining <tt>index</tt>, we hide this detail of how <tt>Screen</tt> is implemented. By making the type <tt>public</tt>, we let our users use this name.</P>

<a name="ch12lev3sec8"></a>
<h5 class="docSection3Title">Member Functions May Be Overloaded</h5>
<p class="docText">Another way our classes have been simple is that they have defined only a few member functions. In particular, none of our classes have needed to define over-loaded versions of any of their member functions. However, as with nonmember functions, a member function may be overloaded (<a class="docLink" href="ch07lev1sec8.html#ch07lev1sec8">Section 7.8</a>, p. <a class="docLink" href="ch07lev1sec8.html#ch07lev1sec8">265</a>).</p>
<p class="docText">With the exception of overloaded operators (<a class="docLink" href="ch14lev1sec9.html#ch14lev2sec34">Section 14.9.5</a>, p. <a class="docLink" href="ch14lev1sec9.html#ch14lev2sec34">547</a>)which have special rulesa member function overloads only other member functions of its own class. A class member function is unrelated to, and cannot overload, ordinary nonmember functions or functions declared in other classes. The same rules apply to overloaded member functions as apply to plain functions: Two overloaded members cannot have the same number and types of parameters. The function-matching (<a class="docLink" href="ch07lev1sec8.html#ch07lev2sec28">Section 7.8.2</a>, p. <a class="docLink" href="ch07lev1sec8.html#ch07lev2sec28">269</a>) process used for calls of nonmember overloaded functions also applies to calls of overloaded member functions.</p>

<a name="ch12lev3sec9"></a>
<H5 class="docSection3Title">Defining Overloaded Member Functions</h5>
<p class="docText">To illustrate overloading, we might give our <tt>Screen</tt> class two overloaded members to return a given character from the window. One version will return the character currently denoted by the cursor and the other returns the character at a given row and column:</p>
<pre>
class Screen {
public:
    typedef std::string::size_type index;
    // <span class="docEmphItalicAlt">return character at the cursor or at a given position</span>
    char get() const { return contents[cursor]; }
    char get(index ht, index wd) const;
    // <span class="docEmphItalicAlt">remaining members</span>
private:
    std::string contents;
    index cursor;
    index height, width;
};
</pre><BR>
<p class="docText">As with any overloaded function, we select which version to run by supplying the appropriate number and/or types of arguments to a given call:</p>
<pre>
     Screen myscreen;
     char ch = myscreen.get();// <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">Screen::get()</span>
     ch = myscreen.get(0,0);  // <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">Screen::get(index, index)</span>
</pre><br>

<a name="ch12lev3sec10"></a>
<H5 class="docSection3Title">Explicitly Specifying <tt>inline</tt> Member Functions</h5>
<p class="docText">Member functions that are defined inside the class, such as the <tt>get</tt> member that takes no arguments, are automatically treated as <tt>inline</tt>. That is, when they are <a name="idd1e92047"></a><a name="idd1e92054"></a><a name="idd1e92059"></a><a name="idd1e92066"></a><a name="idd1e92073"></a><a name="idd1e92082"></a><a name="idd1e92088"></a>called, the compiler will attempt to expand the function inline (<a class="docLink" href="ch07lev1sec6.html#ch07lev1sec6">Section 7.6</a>, p. <a class="docLink" href="ch07lev1sec6.html#ch07lev1sec6">256</a>). We can also explicitly declare a member function as <tt>inline</tt>:</P>
<pre>
     class Screen {
     public:
         typedef std::string::size_type index;
         // <span class="docEmphItalicAlt">implicitly</span> <span class="docEmphasis">inline</span> <span class="docEmphItalicAlt">when defined inside the class declaration</span>
         char get() const { return contents[cursor]; }
         // <span class="docEmphItalicAlt">explicitly declared as</span> <span class="docEmphasis">inline</span>; <span class="docEmphItalicAlt">will be defined outside the class declaration</span>
         inline char get(index ht, index wd) const;
         // <span class="docEmphasis">inline</span> <span class="docEmphItalicAlt">not specified in class declaration, but can be defined</span> <span class="docEmphasis">inline</span> <span class="docEmphItalicAlt">later</span>
         index get_cursor() const;
         // ...
      };
     // <span class="docEmphasis">inline</span> <span class="docEmphItalicAlt">declared in the class declaration; no need to repeat on the definition</span>
     char Screen::get(index r, index c) const
     {
         index row = r * width;    // <span class="docEmphItalicAlt">compute the row location</span>
         return contents[row + c]; // <span class="docEmphItalicAlt">offset by</span> <span class="docEmphasis">c</span> <span class="docEmphItalicAlt">to fetch specified character</span>
     }
     // <span class="docEmphItalicAlt">not declared as</span> <span class="docEmphasis">inline</span> <span class="docEmphItalicAlt">in the class declaration, but ok to make</span> <span class="docEmphasis">inline</span> <span class="docEmphItalicAlt">in definition</span>
     inline Screen::index Screen::get_cursor() const
     {
         return cursor;
     }
</pre><br>
<p class="docText">We can specify that a member is <tt>inline</tt> as part of its declaration inside the class body. Alternatively, we can specify <tt>inline</tt> on the function definition that appears outside the class body. It is legal to specify <tt>inline</tt> both on the declaration and definition. One advantage of defining <tt>inline</tt> functions outside the class is that it can make the class easier to read.</p>
<a name="ch12note04"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> As with other <tt>inline</tt>s, the definition of an <tt>inline</tt> member function must be visible in every source file that calls the function. The definition for an <tt>inline</tt> member function that is not defined within the class body ordinarily should be placed in the same header file in which the class definition appears.</p></td></tr></table><br>
</p></div><br>


<a name="ch12lev2sec4"></a>
<H4 class="docSection2Title">12.1.4. Class Declarations versus Definitions</H4>
<p class="docText">A class is completely defined once the closing curly brace appears. Once the class is defined, all the class members are known. The size required to store an object of the class is known as well. A class may be defined only once in a given source file. When a class is defined in multiple files, the definition in each file must be identical.</p>
<p class="docText">By putting class definitions in header files, we can ensure that a class is defined the same way in each file that uses it. By using header guards (<a class="docLink" href="ch02lev1sec9.html#ch02lev2sec31">Section 2.9.2</a>, p. <a class="docLink" href="ch02lev1sec9.html#ch02lev2sec31">69</a>), <a name="idd1e92229"></a><a name="idd1e92236"></a><a name="idd1e92241"></a><a name="idd1e92244"></a><a name="idd1e92249"></a><a name="idd1e92254"></a><a name="idd1e92257"></a><a name="idd1e92260"></a><a name="idd1e92265"></a>we ensure that even if the header is included more than once in the same file, the class definition will be seen only once.</P>
<a name="ch12sb05"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<H2 class="docSidebarTitle">Exercises Section 12.1.3</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q1"></a><b>Exercise 12.8:</b></TD><td><p class="docText">Define <tt>Sales_item::avg_price</tt> as an inline function.</P>
</TD></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q2"></a><B>Exercise 12.9:</b></TD><td><p class="docText">Write your own version of the <tt>Screen</tt> class presented in this section, giving it a constructor to create a <tt>Screen</tt> from values for height, width, and the contents of the screen.</p>
</td></tr><TR valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q3"></a><b>Exercise 12.10:</b></TD><td><p class="docText">Explain each member in the following class:</p>
<pre>
     class Record {
         typedef std::size_t size;
         Record(): byte_count(0) { }
         Record(size s): byte_count(s) { }
         Record(std::string s): name(s), byte_count(0) { }
         size byte_count;
         std::string name;
     public:
         size get_count() const { return byte_count; }
         std::string get_name() const { return name; }
     };
</pre><BR>
</td></TR></table></p>
</blockquote>
</td></tr></table></p><br>
<p class="docText">It is possible to declare a class without defining it:</p>
<pre>
     class Screen; // <span class="docEmphItalicAlt">declaration of the Screen class</span>
</pre><br>
<p class="docText">This declaration, sometimes referred to as a <b><a name="ch12term15"></a><a class="docLink" href="ch12lev1sec8.html#gloss12_15">forward declaration</a></b>, introduces the name <tt>Screen</tt> into the program and indicates that <tt>Screen</tt> refers to a class type. After a declaration and before a definition is seen, the type <tt>Screen</tt> is an <span class="docEmphStrong">incompete type</span>it's known that <tt>Screen</tt> is a type but not known what members that type contains.</p>
<a name="ch12note05"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> An <span class="docEmphRoman"><a name="ch12term17"></a><a class="docLink" href="ch12lev1sec8.html#gloss12_17">incomplete type</a></span> can be used only in limited ways. Objects of the type may not be defined. An incomplete type may be used to define only pointers or references to the type or to declare (but not define) functions that use the type as a paremeter or return type.</P></td></TR></table><br>
</p></div><BR>
<p class="docText">A class must be fully defined before objects of that type are created. The class must be definedand not just declaredso that the compiler can know how much storage to reserve for an object of that class type. Similarly, the class must be defined before a reference or pointer is used to access a member of the type.</P>
<a name="ch12lev3sec11"></a>
<h5 class="docSection3Title">Using Class Declarations for Class Members</h5>
<p class="docText">A data member can be specified to be of a class type only if the definition for the class has already been seen. If the type is incomplete, a data member can be only a pointer or a reference to that class type.</p>
<p class="docText"><a name="idd1e92386"></a><a name="idd1e92391"></a>Because a class is not defined until its class body is complete, a class cannot have data members of its own type. However, a class is considered declared as soon as its class name has been seen. Therefore, a class can have data members that are pointers or references to its own type:</p>
<pre>
     class LinkScreen {
         Screen window;
         LinkScreen *next;
         LinkScreen *prev;
     };
</pre><br>
<a name="ch12note06"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><td valign="top"><p class="docText"> A common use of class forward declarations is to write classes that are mutually dependent on one another. We'll see an example of such usage in <a class="docLink" href="ch13lev1sec4.html#ch13lev1sec4">Section 13.4</a> (p. <a class="docLink" href="ch13lev1sec4.html#ch13lev1sec4">486</a>).</p></td></TR></table><BR>
</p></div><br>
<a name="ch12sb06"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Exercises Section 12.1.4</h2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa4q1"></a><B>Exercise 12.11:</b></td><TD><p class="docText">Define a pair of classes <tt>X</tt> and <tt>Y</tt>, in which <tt>X</tt> has a pointer to <tt>Y</tt>, and <tt>Y</tt> has an object of type <tt>X</tt>.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa4q2"></a><b>Exercise 12.12:</b></td><td><p class="docText">Explain the difference between a class declaration and definition. When would you use a class declaration? A class definition?</p>
</td></tr></table></p>
</blockquote>
</td></TR></table></P><br>


<a name="ch12lev2sec5"></a>
<H4 class="docSection2Title">12.1.5. Class Objects</h4>
<p class="docText">When we define a class, we are defining a type. Once a class is defined, we can define objects of that type. Storage is allocated when we define objects, but (ordinarily) not when we define types:</p>
<pre>
     class Sales_item {
     public:
         // <span class="docEmphItalicAlt">operations on</span> <span class="docEmphasis">Sales_item</span> <span class="docEmphItalicAlt">objects</span>
     private:
         std::string isbn;
         unsigned units_sold;
         double revenue;
     };
</pre><BR>
<p class="docText">defines a new type, but does not allocate any storage. When we define an object</P>
<pre>
     Sales_item item;
</pre><br>
<p class="docText">the compiler allocates an area of storage sufficient to contain a <tt>Sales_item</tt> object. The name <tt>item</tt> refers to that area of storage. Each object has its own copy of the class data members. Modifying the data members of <tt>item</tt> does not change the data members of any other <tt>Sales_item</tt> object.</p>
<a name="ch12lev3sec12"></a>
<h5 class="docSection3Title">Defining Objects of Class Type</h5>
<p class="docText"><a name="idd1e92525"></a><a name="idd1e92532"></a><a name="idd1e92539"></a><a name="idd1e92545"></a><a name="idd1e92550"></a><a name="idd1e92556"></a><a name="idd1e92563"></a>After a class type has been defined, the type can be used in two ways:</p>
<UL><li><p class="docList">Using the class name directly as a type name</P></LI><li><p class="docList">Specifying the keyword <tt>class</tt> or <tt>struct</tt>, followed by the class name:</p><pre>
     Sales_item item1;       // <span class="docEmphItalicAlt">default initialized object of type</span> <span class="docEmphasis">Sales_item</span>
     class Sales_item item1; // <span class="docEmphItalicAlt">equivalent definition of</span> <span class="docEmphasis">item1</span>
</pre><br></LI></UL>
<p class="docText">Both methods of referring to a class type are equivalent. The second method is inherited from C and is also valid in C++. The first, more concise form was introduced by C++ to make class types easier to use.</p>

<a name="ch12lev3sec13"></a>
<h5 class="docSection3Title">Why a Class Definition Ends in a Semicolon</h5>
<p class="docText">We noted on page <a class="docLink" href="ch02lev1sec8.html#ch02lev2sec26">64</a> that a class definition ends with a semicolon. A semicolon is required because we can follow a class definition by a list of object definitions. As always, a definition must end in a semicolon:</p>
<pre>
class Sales_item { /* ... */ };
class Sales_item { /* ... */ } accum, trans;
</pre><BR>
<a name="ch12note07"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><td valign="top"><p class="docText"> Ordinarily, it is a bad idea to define an object as part of a class definition. Doing so obscures what's happening. It is confusing to readers to combine definitions of two different entitiesthe class and a variablein a single statement.</P></td></TR></table><br>
</p></div><br>



<a href="21001535.html"><img src="images/pixel.gif" alt="" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch12.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch12lev1sec2.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>