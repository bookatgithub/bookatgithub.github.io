<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 12.4.&nbsp; Constructors</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch12lev1sec3.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch12lev1sec5.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch12lev1sec4"></a>
<h3 class="docSection1Title">12.4. Constructors</h3>
<p class="docText">Constructors (<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec12">Section 2.3.3</a>, p. <a class="docLink" href="ch02lev1sec3.html#ch02lev2sec12">49</a>) are special member functions that are executed whenever we create new objects of a class type. The job of a constructor is to ensure that the data members of each object start out with sensible initial values. <a class="docLink" href="ch07lev1sec7.html#ch07lev2sec24">Section 7.7.3</a> (p. <a class="docLink" href="ch07lev1sec7.html#ch07lev2sec24">262</a>) showed how we define a constructor:</P>
<pre>
     class Sales_item {
     public:
         // <span class="docEmphItalicAlt">operations on</span> <span class="docEmphasis">Sales_itemobjects</span>
         // <span class="docEmphItalicAlt">default constructor needed to initialize members of built-in type</span>
         Sales_item(): units_sold(0), revenue(0.0) { }
     private:
         std::string isbn;
         unsigned units_sold;
         double revenue;
     };
</pre><BR>
<p class="docText">This constructor uses the constructor initializer list to initialize the <tt>units_sold</tt> and <tt>revenue</tt> members. The <tt>isbn</tt> member is implicitly initialized by the <tt>string</tt> <span class="docEmphRoman"><a name="ch12term12"></a><a class="docLink" href="ch12lev1sec8.html#gloss12_12">default constructor</a></span> as an empty string.</p>
<p class="docText"><a name="idd1e94549"></a><a name="idd1e94554"></a><a name="idd1e94559"></a><a name="idd1e94564"></a><a name="idd1e94569"></a><a name="idd1e94574"></a><a name="idd1e94582"></a><a name="idd1e94590"></a>Constructors have the same name as the name of the class and may not specify a return type. Like any other function, they may define zero or more parameters.</P>
<a name="ch12lev2sec16"></a>
<h4 class="docSection2Title">Constructors May Be Overloaded</h4>
<p class="docText">There is no constraint on the number of constructors we may declare for a class, provided that the parameter list of each constructor is unique. How can we know which or how many constructors to define? Ordinarily, constructors differ in ways that allow the user to specify differing ways to initialize the data members.</P>
<p class="docText">For example, we might logically extend our <tt>Sales_item</tt> class by providing two additional constructors: one that would let users provide an initial value for the <tt>isbn</tt> and another that would let them initialize the object by reading an <tt>istream</tt> object:</P>
<pre>
     class Sales_item;
     // <span class="docEmphItalicAlt">other members as before</span>
     public:
         // <span class="docEmphItalicAlt">added constructors to initialize from a</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">or an</span> <span class="docEmphasis">istream</span>
         Sales_item(const std::string&amp;);
         Sales_item(std::istream&amp;);
         Sales_item();
     };
</pre><br>

<a name="ch12lev2sec17"></a>
<h4 class="docSection2Title">Arguments Determine Which Constructor to Use</h4>
<p class="docText">Our class now defines three constructors. We could use any of these constructors when defining new objects:</p>
<pre>
     // <span class="docEmphItalicAlt">uses the default constructor:</span>
     // <span class="docEmphasis">isbn</span> <span class="docEmphItalicAlt">is the empty string;</span> <span class="docEmphasis">units_soldand revenue</span> <span class="docEmphItalicAlt">are 0</span>
     Sales_item empty;
     // <span class="docEmphItalicAlt">specifies an explicit</span> <span class="docEmphasis">isbn</span>; <span class="docEmphItalicAlt">units_soldand revenue</span> <span class="docEmphItalicAlt">are 0</span>
     Sales_item Primer_3rd_Ed("0-201-82470-1");
     // <span class="docEmphItalicAlt">reads values from the standard input into</span> <span class="docEmphasis">isbn,</span> <span class="docEmphItalicAlt">units_sold</span>, <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">revenue</span>
     Sales_item Primer_4th_ed(cin);
</pre><br>
<p class="docText">The argument type(s) used to initialize an object determines which constructor is used. In the definition of <tt>empty</tt>, there is no initializer, so the default constructor is run. The constructor that takes a single <tt>string</tt> argument is used to initialize <tt>Primer_3rd_ed;</tt> the one that takes a reference to an <tt>istream</tt> initializes <tt>Primer_4th_ed</tt>.</P>

<a name="ch12lev2sec18"></a>
<h4 class="docSection2Title">Constructors Are Executed Automatically</H4>
<p class="docText">The compiler runs a constructor whenever an object of the type is created:</P>
<pre>
     // <span class="docEmphItalicAlt">constructor that takes a</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">used to create and initialize variable</span>
     Sales_item Primer_2nd_ed("0-201-54848-8");
     // <span class="docEmphItalicAlt">default constructor used to initialize unnamed object on the heap</span>
     Sales_item *p = new Sales_item();
</pre><br>
<p class="docText"><a name="idd1e94745"></a><a name="idd1e94750"></a><a name="idd1e94757"></a><a name="idd1e94760"></a><a name="idd1e94765"></a>In the first case, the constructor that takes a <tt>string</tt> is run to initialize the variable named <tt>Primer_2nd_ed</tt>. In the second case, a new <tt>Sales_item</tt> object is allocated dynamically. Assuming that the allocation succeeds, then the object is initialized by running the default constructor.</p>

<a name="ch12lev2sec19"></a>
<h4 class="docSection2Title">Constructors for <tt>const</tt> Objects</H4>
<p class="docText">A constructor may not be declared as <tt>const</tt> (<a class="docLink" href="ch07lev1sec7.html#ch07lev2sec22">Section 7.7.1</a>, p. <a class="docLink" href="ch07lev1sec7.html#ch07lev2sec22">260</a>):</P>
<pre>
     class Sales_item {
     public:
         Sales_item() const;    // <span class="docEmphItalicAlt">error</span>
     };
</pre><br>
<p class="docText">There is no need for a <tt>const</tt> constructor. When we create a <tt>const</tt> object of a class type, an ordinary constructor is run to initialize the <tt>const</tt> object. The job of the constructor is to initialize an object. A constructor is used to initialize an object regardless of whether the object is <tt>const</tt>.</p>
<a name="ch12sb11"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Exercises Section 12.4</h2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa8q1"></a><B>Exercise 12.19:</b></td><TD><p class="docText">Provide one or more constructors that allows the user of this class to specify initial values for none or all of the data elements of this class:</p>
<pre>
     class NoName {
     public:
         // <span class="docEmphItalicAlt">constructor(s) go here ...</span>
     private:
         std::string *pstring;
         int         ival;
         double      dval;
     };
</pre><br>
<p class="docText">Explain how you decided how many constructors were needed and what parameters they should take.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa8q2"></a><b>Exercise 12.20:</b></td><td><p class="docText">Choose one of the following abstractions (or an abstraction of your own choosing). Determine what data is needed in the class. Provide an appropriate set of constructors. Explain your decisions.</p>
<pre>
     (a) Book        (b) Date      (c) Employee
     (d) Vehicle    (e) Object    (f) Tree
</pre><br>
</td></TR></table></P>
</blockquote>
</td></TR></table></p><br>

<a name="ch12lev2sec20"></a>
<H4 class="docSection2Title">12.4.1. The Constructor Initializer</H4>
<p class="docText">Like any other function, a constructor has a name, a parameter list, and a function body. Unlike other functions, a constructor may also contain a constructor initializer list:</p>
<pre>
     // <span class="docEmphItalicAlt">recommended way to write constructors using a constructor initializer</span>
     Sales_item::Sales_item(const string &amp;book):
          isbn(book), units_sold(0), revenue(0.0) { }
</pre><br>
<p class="docText"><a name="idd1e94894"></a><a name="idd1e94901"></a><a name="idd1e94906"></a><a name="idd1e94911"></a>The constructor initializer starts with a colon, which is followed by a comma-separated list of data members each of which is followed by an initializer inside parentheses. This constructor initializes the <tt>isbn</tt> member to the value of its <tt>book</tt> parameter and initializes <tt>units_sold</tt> and <tt>revenue</tt> to 0. As with any member function, constructors can be defined inside or outside of the class. The constructor initializer is specified only on the constructor definition, not its declaration.</p>
<a name="ch12note15"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><TD valign="top"><p class="docText"> The constructor initializer is a feature that many reasonably experienced C++ programmers have not mastered.</P></td></tr></table><br>
</P></div><BR>
<p class="docText">One reason constructor initializers are hard to understand is that it is usually legal to omit the initializer list and <span class="docEmphasis">assign</span> values to the data members inside the constructor body. For example, we could write the <tt>Sales_item</tt> constructor that takes a <tt>string</tt> as</p>
<pre>
     // <span class="docEmphItalicAlt">legal but sloppier way to write the constructor:</span>
     // <span class="docEmphItalicAlt">no constructor initializer</span>
     Sales_item::Sales_item(const string &amp;book)
     {
         isbn = book;
         units_sold = 0;
         revenue = 0.0;
     }
</pre><br>
<p class="docText">This constructor assigns, but does not explicitly initialize, the members of class <tt>Sales_item</tt>. Regardless of the lack of an explicit initializer, the <tt>isbn</tt> member is initialized before the constructor is executed. This constructor implicitly uses the default <tt>string</tt> constructor to initialize <tt>isbn</tt>. When the body of the constructor is executed, the <tt>isbn</tt> member already has a value. That value is overwritten by the assignment inside the constructor body.</p>
<p class="docText">Conceptually, we can think of a constructor as executing in two phases: (1) the initialization phase and (2) a general computation phase. The computation phase consists of all the statements within the body of the constructor.</p>
<a name="ch12note16"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><td valign="top"><p class="docText"> Data members of class type are <span class="docEmphasis">always</span> initialized in the initialization phase, regardless of whether the member is initialized explicitly in the constructor initializer list. Initialization happens <span class="docEmphasis">before</span> the computation phase begins.</p></TD></tr></table><BR>
</p></div><br>
<p class="docText">Each member that is not explicitly mentioned in the constructor initializer is initialized using the same rules as those used to initialize variables (<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec13">Section 2.3.4</a>, p. <a class="docLink" href="ch02lev1sec3.html#ch02lev2sec13">50</a>). Data members of class type are initialized by running the type's default constructor. The initial value of members of built-in or compound type depend on the scope of the object: At local scope those members are uninitialized, at global scope they are initialized to 0.</p>
<p class="docText"><a name="idd1e95010"></a><a name="idd1e95019"></a><a name="idd1e95026"></a><a name="idd1e95033"></a><a name="idd1e95038"></a>The two versions of the <tt>Sales_item</tt> constructor that we wrote in this section have the same effect: Whether we initialized the members in the constructor initializer list or assigned to them inside the constructor body, the end result is the same. After the constructor completes, the three data members hold the same values. The difference is that the version that uses the constructor initializer <span class="docEmphasis">initializes</span> its data members. The version that does not define a constructor initializer <span class="docEmphasis">assigns</span> values to the data members in the body of the constructor. How significant this distinction is depends on the type of the data member.</p>
<a name="ch12lev3sec20"></a>
<h5 class="docSection3Title">Constructor Initializers Are Sometimes Required</h5>
<p class="docText">If an initializer is not provided for a class member, then the compiler implicitly uses the default constructor for the member's type. If that class does not have a default constructor, then the attempt by the compiler to use it will fail. In such cases, an initializer must be provided in order to initialize the data member.</p>
<a name="ch12note17"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> Some members <span class="docEmphasis">must</span> be initialized in the constructor initializer. For such members, assigning to them in the constructor body doesn't work. Members of a class type that do not have a default constructor and members that are <tt>const</tt> or reference types <span class="docEmphasis">must</span> be initialized in the constructor initializer <span class="docEmphasis">regardless of type</span>.</p></TD></TR></table><br>
</P></div><br>
<p class="docText">Because members of built-in type are not implicitly initialized, it may seem that it doesn't matter whether these members are initialized or assigned. With two exceptions, using an initializer is equivalent to assigning to a nonclass data member both in result and in performance.</p>
<p class="docText">For example, the following constructor is in error:</P>
<pre>
     class ConstRef {
     public:
         ConstRef(int ii);
     private:
         int i;
         const int ci;
         int &amp;ri;
     };
     // <span class="docEmphItalicAlt">no explicit constructor initializer: error</span> <span class="docEmphasis">ri</span> <span class="docEmphItalicAlt">is uninitialized</span>
     ConstRef::ConstRef(int ii)
     {              // <span class="docEmphItalicAlt">assignments:</span>
          i = ii;   // <span class="docEmphItalicAlt">ok</span>
          ci = ii;  // <span class="docEmphItalicAlt">error: cannot assign to a</span> <span class="docEmphasis">const</span>
          ri = i;   // <span class="docEmphItalicAlt">assigns to</span> <span class="docEmphasis">ri</span> <span class="docEmphItalicAlt">which was not bound to an object</span>
     }
</pre><BR>
<p class="docText">Remember that we can initialize but not assign to <tt>const</tt> objects or objects of reference type. By the time the body of the constructor begins executing, initialization is complete. Our only chance to initialize <tt>const</tt> or reference data members is in the constructor initializer. The correct way to write the constructor is</p>
<pre>
     // <span class="docEmphItalicAlt">ok: explicitly initialize reference and</span> <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">members</span>
     ConstRef::ConstRef(int ii): i(ii), ci(i), ri(ii) { }
</pre><br>
<a name="ch12sb12"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Advice: Use Constructor Initializers</h2>
<p class="docText"><a name="idd1e95153"></a><a name="idd1e95156"></a><a name="idd1e95161"></a><a name="idd1e95164"></a><a name="idd1e95169"></a><span class="docEmphStrong">In many classes, the distinction between initialization and assignment is strictly a matter of low-level efficiency: A data member is initialized and assigned when it could have been initialized directly. More important than the efficiency issue is the fact that some data members must be initialized.</span></P>
<a name="ch12note18"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> <span class="docEmphStrong">We must use an initializer for any <tt>const</tt> or reference member or for any member of a class type that does not have a default constructor.</span></P></td></tr></table><br>
</p></div><BR>
<p class="docText"><span class="docEmphStrong">By routinely using constructor initializers, we can avoid being surprised by compile-time errors when we have a class with a member that requires a constructor initializer.</span></p>
</td></TR></table></p><br>

<a name="ch12lev3sec21"></a>
<H5 class="docSection3Title">Order of Member Initialization</h5>
<p class="docText">Not surprisingly, each member may be named only once in the constructor initializer. After all, what might it mean to give a member two initial values? What may be more surprising is that the constructor initializer list specifies only the values used to initialize the members, not the order in which those initializations are performed. The order in which members are initialized is the order in which the members are defined. The first member is initialized first, then the next, and so on.</P>
<a name="ch12note19"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> The order of initialization often doesn't matter. However, if one member is initialized in terms of another, then the order in which members are initialized is crucially important.</p></td></tr></table><br>
</p></div><br>
<p class="docText">Consider the following class:</p>
<pre>
     class X {
         int i;
         int j;
     public:
         // <span class="docEmphItalicAlt">run-time error: i is initialized before j</span>
         X(int val): j(val), i(j) { }
     };
</pre><br>
<p class="docText">In this case, the constructor initializer is written to make it <span class="docEmphasis">appear</span> as if <tt>j</tt> is initialized with <tt>val</tt> and then <tt>j</tt> is used to initialize <tt>i</tt>. However, <tt>i</tt> is initialized first. The effect of this initializer is to initialize <tt>i</tt> with the as yet uninitialized value of <tt>j</tt>!</P>
<p class="docText">Some compilers are kind enough to generate a warning if the data members are listed in the constructor initializer in a different order from the order in which the members are declared.</P>
<a name="ch12note20"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><TD valign="top"><p class="docText"> It is a good idea to write constructor initializers in the same order as the members are declared. Moreover, when possible, avoid using members to initialize other members.</P></td></tr></table><br>
</p></div><br>
<p class="docText">It is often the case that we can avoid any problems due to order of execution for initializers by (re)using the constructor's parameters rather than using the object's data members. For example, it would be better to write the constructor for <tt>X</tt> as</P>
<pre>
     X(int val): i(val), j(val) { }
</pre><br>
<p class="docText"><a name="idd1e95276"></a><a name="idd1e95281"></a>In this version, the order in which <tt>i</tt> and <tt>j</tt> are initialized doesn't matter.</P>

<a name="ch12lev3sec22"></a>
<H5 class="docSection3Title">Initializers May Be Any Expression</h5>
<p class="docText">An initializer may be an arbitrarily complex expression. As an example, we could give our <tt>Sales_item</tt> class a new constructor that takes a <tt>string</tt> representing the <tt>isbn</tt>, an <tt>unsigned</tt> representing the number of books sold, and a <tt>double</tt> representing the price at which each of these books was sold:</p>
<pre>
     Sales_item(const std::string &amp;book, int cnt, double price):
         isbn(book), units_sold(cnt), revenue(cnt * price) { }
</pre><br>
<p class="docText">This initializer for <tt>revenue</tt> uses the parameters representing price and number sold to calculate the object's <tt>revenue</tt> member.</P>

<a name="ch12lev3sec23"></a>
<H5 class="docSection3Title">Initializers for Data Members of Class Type</h5>
<p class="docText">When we initialize a member of class type, we are specifying arguments to be passed to one of the constructors of that member's type. We can use any of that type's constructors. For example, our <tt>Sales_item</tt> class could initialize <tt>isbn</tt> using any of the <tt>string</tt> constructors (<a class="docLink" href="ch09lev1sec6.html#ch09lev2sec18">Section 9.6.1</a>, p. <a class="docLink" href="ch09lev1sec6.html#ch09lev2sec18">338</a>). Instead of using the empty string, we might decide that the default value for <tt>isbn</tt> should be a value that represents an impossibly high value for an ISBN. We could initialize <tt>isbn</tt> to a string of ten 9s:</p>
<pre>
     // <span class="docEmphItalicAlt">alternative definition for</span> <span class="docEmphasis">Sales_item</span> <span class="docEmphItalicAlt">default constructor</span>
     Sales_item(): isbn(10, '9'), units_sold(0), revenue(0.0) {}
</pre><br>
<p class="docText">This initializer uses the <tt>string</tt> constructor that takes a count and a character and generates a <tt>string</tt> holding that character repeated that number of times.</p>
<a name="ch12sb13"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Exercises Section 12.4.1</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><td align="right" class="docText" width="50"><a name="ch12qa9q1"></a><B>Exercise 12.21:</b></td><td><p class="docText">Write the default constructor using a constructor initializer for class that contains the following members: a <tt>const string</tt>, an <tt>int</tt>, a <tt>double*</tt>, and an <tt>ifstream&amp;</tt>. Initialize the <tt>string</tt> to hold the name of the class.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa9q2"></a><b>Exercise 12.22:</b></td><td><p class="docText">The following initializer is in error. Identify and fix the problem.</p>
<pre>
     struct X {
         X (int i, int j): base(i), rem(base % j) { }
         int rem, base;
     };
</pre><br>
</td></TR><TR valign="top"><td align="right" class="docText" width="50"><a name="ch12qa9q3"></a><B>Exercise 12.23:</b></td><td><p class="docText">Assume we have a class named <tt>NoDefault</tt> that has a constructor that takes an <tt>int</tt> but no default constructor. Define a class <tt>C</tt> that has a member of type <tt>NoDefault</tt>. Define the default constructor for <tt>C</tt>.</P>
</TD></tr></table></p>
</blockquote>
</td></tr></table></p><BR>


<a name="ch12lev2sec21"></a>
<h4 class="docSection2Title">12.4.2. Default Arguments and Constructors</H4>
<p class="docText"><a name="idd1e95474"></a><a name="idd1e95479"></a><a name="idd1e95484"></a><a name="idd1e95489"></a><a name="idd1e95492"></a>Let's look again at our definitions for the default constructor and the constructor that takes a <tt>string</tt>:</P>
<pre>
     Sales_item(const std::string &amp;book):
               isbn(book), units_sold(0), revenue(0.0) { }
     Sales_item(): units_sold(0), revenue(0.0) { }
</pre><br>
<p class="docText">These constructors are almost the same: The only difference is that the constructor that takes a <tt>string</tt> parameter uses the parameter to initialize <tt>isbn</tt>. The default constructor (implicitly) uses the <tt>string</tt> default constructor to initialize <tt>isbn</tt>.</p>
<p class="docText">We can combine these constructors by supplying a default argument for the <tt>string</tt> initializer:</p>
<pre>
     class Sales_item {
     public:
         // <span class="docEmphItalicAlt">default argument for book is the empty string</span>
         Sales_item(const std::string &amp;book = ""):
                   isbn(book), units_sold(0), revenue(0.0) { }
         Sales_item(std::istream &amp;is);
         // <span class="docEmphItalicAlt">as before</span>
     };
</pre><BR>
<p class="docText">Here we define only two constructors, one of which provides a default argument for its parameter. The constructor that takes a default argument for its single <tt>string</tt> parameter will be run for either of these definitions:</P>
<pre>
     Sales_item empty;
     Sales_item Primer_3rd_Ed("0-201-82470-1");
</pre><br>
<p class="docText">In the case of <tt>empty</tt>, the default argument is used, whereas <tt>Primer_3rd_ed</tt> supplies an explicit argument.</p>
<p class="docText">Each version of our class provides the same interface: They both initialize a <tt>Sales_item</tt> to the same values given a <tt>string</tt> or given no initializer.</p>
<a name="ch12note21"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><TD valign="top"><p class="docText"> We prefer to use a default argument because it reduces code duplication.</p></td></TR></table><br>
</P></div><br>

<a name="ch12lev2sec22"></a>
<h4 class="docSection2Title">12.4.3. The Default Constructor</h4>
<p class="docText">The default constructor is used whenever we define an object but do not supply an initializer. A constructor that supplies default arguments for all its parameters also defines the default constructor.</p>
<a name="ch12lev3sec24"></a>
<h5 class="docSection3Title">The Synthesized Default Constructor</h5>
<p class="docText">If a class defines even one constructor, then the compiler will not generate the default constructor. The basis for this rule is that if a class requires control to initialize an object in one case, then the class is likely to require control in all cases.</p>
<a name="ch12sb14"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 12.4.2</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch12qa10q1"></a><b>Exercise 12.24:</b></TD><td><p class="docText"><a name="idd1e95612"></a><a name="idd1e95617"></a><a name="idd1e95622"></a><a name="idd1e95627"></a><a name="idd1e95631"></a><a name="idd1e95634"></a>Using the version of <tt>Sales_item</tt> from page <a class="docLink" href="#ch12lev2sec21">458</a> that defined two constructors, one of which has a default argument for its single <tt>string</tt> parameter, determine which constructor is used to initialize each of the following variables and list the values of the data members in each object:</p>
<pre>
     Sales_item first_item(cin);

     int main() {
         Sales_item next;
         Sales_item last("9-999-99999-9");
     }
</pre><BR>
</TD></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa10q2"></a><b>Exercise 12.25:</b></td><TD><p class="docText">Logically, we might want to supply <tt>cin</tt> as a default argument to the constructor that takes an <tt>istream&amp;</tt>. Write the constructor declaration that uses <tt>cin</tt> as a default argument.</p>
</TD></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa10q3"></a><b>Exercise 12.26:</b></TD><TD><p class="docText">Would it be legal for both the constructor that takes a <tt>string</tt> and the one that takes an <tt>istream&amp;</tt> to have default arguments? If not, why not?</p>
</td></tr></table></p>
</blockquote>
</TD></tr></table></p><BR>
<a name="ch12note22"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> The compiler generates a default constructor automatically only if a class defines <span class="docEmphasis">no</span> constructors.</p></td></tr></table><br>
</p></div><br>
<p class="docText">The <b><a name="ch12term25"></a><a class="docLink" href="ch12lev1sec8.html#gloss12_25">synthesized default constructor</a></b> initializes members using the same rules as those that apply for how variables are initialized. Members that are of class type are initialized by running each member's own default constructor. Members of built-in or compound type, such as pointers and arrays, are initialized only for objects that are defined at global scope. When objects are defined at local scope, then members of built-in or compound type are <span class="docEmphasis">uninitialized</span>.</p>
<a name="ch12note23"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><td valign="top"><p class="docText"> If a class contains data members of built-in or compound type, then the class should not rely on the synthesized default constructor. It should define its own constructor to initialize these members.</P></TD></tr></table><BR>
</p></div><br>
<p class="docText">Moreover, every constructor should provide initializers for members of built-in or compound type. A constructor that does not initialize a member of built-in or compound type leaves that member in an undefined state. Using an undefined member in any way other than as the target of an assignment is an error. If every constructor sets every member to an explicit, known state, then member functions can distinguish between an empty object and one that has actual values.</P>

<a name="ch12lev3sec25"></a>
<H5 class="docSection3Title">Classes Should Usually Define a Default Constructor</h5>
<p class="docText">In certain cases, the default constructor is applied implicitly by the compiler. If the class has no default constructor, then the class may not be used in these contexts. To illustrate the cases where a default constructor is required, assume we have a class named <tt>NoDefault</tt> that does not define its own default constructor but <a name="idd1e95740"></a><a name="idd1e95747"></a><a name="idd1e95752"></a><a name="idd1e95757"></a>does have a constructor that takes a <tt>string</tt> argument. Because the class defines a constructor, the compiler will not synthesize the default constructor. The fact that <tt>NoDefault</tt> has no default constructor means:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">Every constructor for every class that has a <tt>NoDefault</tt> member must explicitly initialize the <tt>NoDefault</tt> member by passing an initial <tt>string</tt> value to the <tt>NoDefault</tt> constructor.</p></div></li><LI><div style="font-weight:normal"><p class="docList">The compiler will not synthesize the default constructor for classes that have members of type <tt>NoDefault</tt>. If such classes want to provide a default, they must define one explicitly, and that constructor must explicitly initialize their <tt>NoDefault</tt> member.</p></div></LI><LI><div style="font-weight:normal"><p class="docList">The <tt>NoDefault</tt> type may not be used as the element type for a dynamically allocated array.</p></div></li><li><div style="font-weight:normal"><p class="docList">Statically allocated arrays of type <tt>NoDefault</tt> must provide an explicit initializer for each element.</P></div></LI><li><div style="font-weight:normal"><p class="docList">If we have a container such as <tt>vector</tt> that holds <tt>NoDefault</tt> objects, we cannot use the constructor that takes a size without also supplying an element initializer.</p></div></li></ol></div>
<a name="ch12note24"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><TD valign="top"><p class="docText"> In practice, it is almost always right to provide a default constructor if other constructors are being defined. Ordinarily the initial values given to the members in the default constructor should indicate that the object is &quot;empty.&quot;</p></td></TR></table><br>
</P></div><br>

<a name="ch12lev3sec26"></a>
<h5 class="docSection3Title">Using the Default Constructor</h5>
<a name="ch12note25"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> A common mistake among programmers new to C++ is to declare an object initialized with the default constructor as follows:</p></td></tr></table><br>
<pre>
     // <span class="docEmphItalicAlt">oops! declares a function, not an object</span>
     Sales_item myobj();
</pre><br>
</P></div><BR>
<p class="docText">The declaration of <tt>myobj</tt> compiles without complaint. However, when we try to use <tt>myobj</tt></p>
<pre>
     Sales_item myobj();   // <span class="docEmphItalicAlt">ok: but defines a function, not an object</span>
     if (myobj.same_isbn(Primer_3rd_ed))   // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">myobj</span> <span class="docEmphItalicAlt">is a function</span>
</pre><BR>
<p class="docText">the compiler complains that we cannot apply member access notation to a function! The problem is that our definition of <tt>myobj</tt> is interpreted by the compiler as a declaration of a function taking no parameters and returning an object of type <tt>Sales_item</tt>hardly what we intended! The correct way to define an object using the default constructor is to leave off the trailing, empty parentheses:</p>
<pre>
     // <span class="docEmphItalicAlt">ok: defines a class object ...</span>
     Sales_item myobj;
</pre><br>
<p class="docText"><a name="idd1e95908"></a><a name="idd1e95913"></a><a name="idd1e95918"></a><a name="idd1e95921"></a>On the other hand, this code is fine:</P>
<pre>
     // <span class="docEmphItalicAlt">ok: create an unnamed, empty</span> <span class="docEmphasis">Sales_itemand</span> <span class="docEmphItalicAlt">use to initialize</span> <span class="docEmphasis">myobj</span>
     Sales_item myobj = Sales_item();
</pre><BR>
<p class="docText">Here we create and value-initialize a <tt>Sales_item</tt> object and to use it to initialize <tt>myobj</tt>. The compiler value-initializes a <tt>Sales_item</tt> by running its default constructor.</p>
<a name="ch12sb15"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 12.4.3</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch12qa11q1"></a><b>Exercise 12.27:</b></td><td><p class="docText">Which, if any, of the following statements are untrue? Why?</P>
<div style="font-weight:bold"><ol class="docList" type="a"><LI><div style="font-weight:normal"><p class="docList">A class must provide at least one constructor.</p></div></li><li><div style="font-weight:normal"><p class="docList">A default constructor is a constructor with no parameters for its parameter list.</p></div></LI><li><div style="font-weight:normal"><p class="docList">If there are no meaningful default values for a class, the class should not provide a default constructor.</p></div></LI><li><div style="font-weight:normal"><p class="docList">If a class does not define a default constructor, the compiler generates one automatically, initializing each data member to the default value of its associated type.</p></div></LI></ol></div>
</td></TR></table></p>
</blockquote>
</td></tr></table></p><br>


<a name="ch12lev2sec23"></a>
<h4 class="docSection2Title">12.4.4. Implicit Class-Type Conversions</h4>
<p class="docText">As we saw in <a class="docLink" href="ch05lev1sec12.html#ch05lev1sec12">Section 5.12</a> (p. <a class="docLink" href="ch05lev1sec12.html#ch05lev1sec12">178</a>), the language defines several automatic conversions among the built-in types. We can also define how to implicitly convert an object from another type to our class type or to convert from our class type to another type. We'll see in <a class="docLink" href="ch14lev1sec9.html#ch14lev1sec9">Section 14.9</a> (p. <a class="docLink" href="ch14lev1sec9.html#ch14lev1sec9">535</a>) how to define conversions <span class="docEmphasis">from</span> a class type to another type. To define an implicit conversion <span class="docEmphasis">to</span> a class type, we need to define an appropriate constructor.</p>
<a name="ch12note26"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> A constructor that can be called with a single argument defines an implicit conversion from the parameter type to the class type.</P></TD></tr></table><BR>
</p></div><br>
<p class="docText">Let's look again at the version of <tt>Sales_item</tt> that defined two constructors:</P>
<pre>
     class Sales_item {
     public:
         // <span class="docEmphItalicAlt">default argument for book is the empty string</span>
         Sales_item(const std::string &amp;book = ""):
                   isbn(book), units_sold(0), revenue(0.0) { }
         Sales_item(std::istream &amp;is);
         // <span class="docEmphItalicAlt">as before</span>
      };
</pre><BR>
<p class="docText">Each of these constructors defines an implicit conversion. Accordingly, we can use a <tt>string</tt> or an <tt>istream</tt> where an object of type <tt>Sales_item</tt> is expected:</p>
<pre>
     string null_book = "9-999-99999-9";
     // <span class="docEmphItalicAlt">ok: builds a</span> <span class="docEmphasis">Sales_itemwith</span> <span class="docEmphItalicAlt">0</span> <span class="docEmphasis">units_soldand revenue</span> <span class="docEmphItalicAlt">from</span>
     // <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">isbn</span> <span class="docEmphItalicAlt">equal to</span> <span class="docEmphasis">null_book</span>
     item.same_isbn(null_book);
</pre><br>
<p class="docText"><a name="idd1e96107"></a><a name="idd1e96114"></a><a name="idd1e96120"></a><a name="idd1e96125"></a>This program uses an object of type <tt>string</tt> as the argument to the <tt>Sales_item same_isbn</tt> function. That function expects a <tt>Sales_item</tt> object as its argument. The compiler uses the <tt>Sales_item</tt> constructor that takes a <tt>string</tt> to generate a new <tt>Sales_item</tt> object from <tt>null_book</tt>. That newly generated (temporary) <tt>Sales_item</tt> is passed to <tt>same_isbn</tt>.</p>
<p class="docText">Whether this behavior is desired depends on how we think our users will use the conversion. In this case, it might be a good idea. The <tt>string</tt> in <tt>book</tt> probably represents a nonexistent <tt>ISBN</tt>, and the call to <tt>same_isbn</tt> can detect whether the <tt>Sales_item</tt> in <tt>item</tt> represents a null <tt>Sales_item</tt>. On the other hand, our user might have mistakenly called <tt>same_isbn</tt> on <tt>null_book</tt>.</p>
<p class="docText">More problematic is the conversion from <tt>istream</tt> to <tt>Sales_item:</tt></p>
<pre>
     // <span class="docEmphItalicAlt">ok: uses the</span> <span class="docEmphasis">Sales_item istream</span> <span class="docEmphItalicAlt">constructor to build an object</span>
      // <span class="docEmphItalicAlt">to pass to</span> <span class="docEmphasis">same_isbn</span>
     item.same_isbn(cin);
</pre><BR>
<p class="docText">This code implicitly converts <tt>cin</tt> to a <tt>Sales_item</tt>. This conversion executes the <tt>Sales_item</tt> constructor that takes an <tt>istream</tt>. That constructor creates a (temporary) <tt>Sales_item</tt> object by reading the standard input. That object is then passed to <tt>same_isbn</tt>.</p>
<p class="docText">This <tt>Sales_item</tt> object is a temporary (<a class="docLink" href="ch07lev1sec3.html#ch07lev2sec14">Section 7.3.2</a>, p. <a class="docLink" href="ch07lev1sec3.html#ch07lev2sec14">247</a>). We have no access to it once <tt>same_isbn</tt> finishes. Effectively, we have constructed an object that is discarded after the test is complete. This behavior is almost surely a mistake.</P>
<a name="ch12lev3sec27"></a>
<H5 class="docSection3Title">Supressing Implicit Conversions Defined by Constructors</h5>
<p class="docText">We can prevent the use of a constructor in a context that requries an implicit conversion by declaring the constructor <tt>explicit</tt>:</p>
<pre>
     class Sales_item {
     public:
         // <span class="docEmphItalicAlt">default argument for book is the empty string</span>
         explicit Sales_item(const std::string &amp;book = ""):
                   isbn(book), units_sold(0), revenue(0.0) { }
         explicit Sales_item(std::istream &amp;is);
         // <span class="docEmphItalicAlt">as before</span>
     };
</pre><br>
<p class="docText">The <tt>explicit</tt> keyword is used only on the constructor declaration inside the class. It is not repeated on a definition made outside the class body:</P>
<pre>
     // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">explicit</span> <span class="docEmphItalicAlt">allowed only on constructor declaration in class header</span>
     explicit Sales_item::Sales_item(istream&amp; is)
     {
         is &gt;&gt; *this; // <span class="docEmphItalicAlt">uses</span> <span class="docEmphasis">Sales_iteminput</span> <span class="docEmphItalicAlt">operator to read the members</span>
     }
</pre><BR>
<p class="docText">Now, neither constructor can be used to implicitly create a <tt>Sales_item</tt> object. Neither of our previous uses will compile:</p>
<pre>
     item.same_isbn(null_book); // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">constructor is</span> <span class="docEmphasis">explicit</span>
     item.same_isbn(cin);       // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">istream</span> <span class="docEmphItalicAlt">constructor is</span> <span class="docEmphasis">explicit</span>
</pre><br>
<a name="ch12note27"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> When a constructor is declared <tt>explicit</tt>, the compiler will <span class="docEmphasis">not</span> use it as a conversion operator.</P></td></tr></table><BR>
</p></div><BR>

<a name="ch12lev3sec28"></a>
<h5 class="docSection3Title">Explicitly Using Constructors for Conversions</h5>
<p class="docText">An <span class="docEmphRoman"><a name="ch12term14"></a><a class="docLink" href="ch12lev1sec8.html#gloss12_14"><span class="docEmphRoman"><tt>explicit</tt> constructor</span></a></span> can be used to generate a conversion as long as we do so explicitly:</p>
<pre>
     string null_book = "9-999-99999-9";
     // <span class="docEmphItalicAlt">ok: builds a</span> <span class="docEmphasis">Sales_itemwith</span> <span class="docEmphItalicAlt">0</span> <span class="docEmphasis">units_soldand revenue</span> <span class="docEmphItalicAlt">from</span>
     // <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">isbn</span> <span class="docEmphItalicAlt">equal to</span> <span class="docEmphasis">null_book</span>
     item.same_isbn(Sales_item(null_book));
</pre><br>
<p class="docText">In this code, we create a <tt>Sales_item</tt> from <tt>null_book</tt>. Even though the constructor is <tt>explicit</tt>, this usage is allowed. Making a constructor <tt>explicit</tt> turns off only the use of the constructor implicitly. Any constructor can be used to explicitly create a temporary object.</p>
<a name="ch12note28"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><td valign="top"><p class="docText"> Ordinarily, single-parameter constructors should be <tt>explicit</tt> unless there is an obvious reason to want to define an implicit conversion. Making constructors <tt>explicit</tt> may avoid mistakes, and a user can explicitly construct an object when a conversion is useful.</p></td></tr></table><BR>
</P></div><br>
<a name="ch12sb16"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Exercises Section 12.4.4</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa12q1"></a><b>Exercise 12.28:</b></td><TD><p class="docText">Explain whether the <tt>Sales_item</tt> constructor that takes a <tt>string</tt> should be explicit. What would be the benefits of making the constructor explicit? What would be the drawbacks?</p>
</TD></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa12q2"></a><b>Exercise 12.29:</b></TD><TD><p class="docText">Explain what operations happen during the following definitions:</p>
<pre>
     string null_isbn = "9-999-99999-9";
     Sales_item null1(null_isbn);
     Sales_item null("9-999-99999-9");
</pre><br>
</td></tr><TR valign="top"><td align="right" class="docText" width="50"><a name="ch12qa12q3"></a><b>Exercise 12.30:</b></TD><td><p class="docText">Compile the following code:</p>
<pre>
     f(const vector&lt;int&gt;&amp;);
     int main() {
         vector&lt;int&gt; v2;
         f(v2);  // <span class="docEmphItalicAlt">should be ok</span>
         f(42);  // <span class="docEmphItalicAlt">should be an error</span>
         return 0;
     }
</pre><BR>
<p class="docText">What can we infer about the <tt>vector</tt> constructors based on the error on the second call to <tt>f</tt>? If the call succeeded, then what would you conclude?</p>
</TD></tr></table></p>
</blockquote>
</td></tr></table></p><br>


<a name="ch12lev2sec24"></a>
<h4 class="docSection2Title">12.4.5. Explicit Initialization of Class Members</h4>
<p class="docText"><a name="idd1e96523"></a><a name="idd1e96528"></a>Although most objects are initialized by running an appropriate constructor, it is possible to initialize the data members of simple nonabstract classes directly. Members of classes that define no constructors and all of whose data members are <tt>public</tt> may be initialized in the same way that we initialize array elements:</p>
<pre>
     struct Data {
         int ival;
         char *ptr;
     };
     // <span class="docEmphasis">val1.ival = 0; val1.ptr = 0</span>
     Data val1 = { 0, 0 };

     // <span class="docEmphasis">val2.ival = 1024;</span>
     // <span class="docEmphasis">val2.ptr = "Anna Livia Plurabelle"</span>
     Data val2 = { 1024, "Anna Livia Plurabelle" };
</pre><br>
<p class="docText">The initializers are used in the declaration order of the data members. The following, for example, is an error because <tt>ival</tt> is declared before <tt>ptr</tt>:</p>
<pre>
     // <span class="docEmphItalicAlt">error: can't use</span> "<span class="docEmphasis">Anna Livia Plurabelle</span>" <span class="docEmphItalicAlt">to initialize the</span> <span class="docEmphasis">int ival</span>
     Data val2 = { "Anna Livia Plurabelle" , 1024 };
</pre><br>
<p class="docText">This form of initialization is inherited from C and is supported for compatibility with C programs. There are three significant drawbacks to explicitly initializing the members of an object of class type:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><LI><div style="font-weight:normal"><p class="docList">It requires that all the data members of the class be <tt>public</tt>.</P></div></li><LI><div style="font-weight:normal"><p class="docList">It puts the burden on the programmer to initialize every member of every object. Such initialization is tedious and error-prone because it is easy to forget an initializer or to supply an inappropriate initializer.</p></div></li><LI><div style="font-weight:normal"><p class="docList">If a member is added or removed, all initializations have to be found and updated correctly.</P></div></li></ol></div>
<a name="ch12note29"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><TD valign="top"><p class="docText"> It is almost always better to define and use constructors. When we provide a default constructor for the types we define, we allow the compiler to automatically run that constructor, ensuring that every class object is properly initialized prior to the first use of that object.</p></TD></TR></table><br>
</p></div><br>
<a name="ch12sb17"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<h2 class="docSidebarTitle">Exercises Section 12.4.5</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><td align="right" class="docText" width="50"><a name="ch12qa13q1"></a><b>Exercise 12.31:</b></TD><td><p class="docText">The data members of <tt>pair</tt> are <tt>public</tt>, yet this code doesn't compile. Why?</p>
<pre>
     pair&lt;int, int&gt; p2 = {0, 42}; // <span class="docEmphItalicAlt">doesn't compile, why?</span>
</pre><BR>
</td></TR></table></p>
</blockquote>
</td></tr></table></p><br>


<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch12lev1sec3.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch12lev1sec5.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>