<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Keyterm&nbsp;Defined Terms</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch13lev1sec6.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch14.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch13lev1sec7"></a>
<h3 class="docSection1Title">Defined Terms</h3>
<p class="docText"></P>

<a name="gloss13_01"></a><dl class="docList"><dt><B><a class="docLink" href="ch13.html#ch13term1">assignment operator</a></b></dt><dd><p class="docText">The assignment operator can be overloaded to define what it means to assign one object of a class type to another of the same type. The assignment operator must be a member of its class and should return a reference to its object. The compiler synthesizes the assignment operator if the class does not explicitly define one.</p></dd><BR><br></dl>
<a name="gloss13_02"></a><dl class="docList"><dt><b><a class="docLink" href="ch13.html#ch13term2">copy constructor</a></b></dt><dd><p class="docText">Constructor that initializes a new object as a copy of another object of the same type. The copy constructor is applied implicitly to pass objects to or from a function by value. If we do not define the copy constructor, the compiler synthesizes one for us.</P></dd><BR><br></dl>
<a name="gloss13_03"></a><dl class="docList"><dt><b><a class="docLink" href="ch13.html#ch13term3">copy control</a></b></dt><dd><p class="docText">Special members that control what happens when object of class type are copied, assigned, and destroyed. The compiler synthesizes appropriate definitions for these operations if the class does not otherwise define them.</p></dd><br><br></dl>
<a name="gloss13_04"></a><dl class="docList"><dt><B><a class="docLink" href="ch13.html#ch13term4">destructor</a></b></dt><dd><p class="docText">Special member function that cleans up an object when the object goes out of scope or is deleted. The compiler automatically destroys each member. Members <a name="idd1e103397"></a><a name="idd1e103402"></a><a name="idd1e103410"></a><a name="idd1e103415"></a><a name="idd1e103420"></a><a name="idd1e103423"></a><a name="idd1e103428"></a><a name="idd1e103431"></a><a name="idd1e103434"></a><a name="idd1e103437"></a><a name="idd1e103440"></a><a name="idd1e103445"></a><a name="idd1e103448"></a><a name="idd1e103451"></a><a name="idd1e103454"></a><a name="idd1e103460"></a><a name="idd1e103463"></a><a name="idd1e103466"></a><a name="idd1e103469"></a>of class type are destroyed by invoking their destructor; no explicit work is done to destroy members of built-in or compound type. In particular, the object pointed to by a pointer member is not deleted by the automatic work done by the destructor.</p></dd><BR><BR></dl>
<a name="gloss13_05"></a><dl class="docList"><dt><b><a class="docLink" href="ch13lev1sec2.html#ch13term5">memberwise assignment</a></b></dt><dd><p class="docText">Term used to describe how the synthesized assignment operator works. The assignment operator assigns, member by member, from the old object to the new. Members of built-in or compound type are assigned directly. Those that are of class type are assigned by using the member's assignment operator.</p></dd><br><BR></dl>
<a name="gloss13_06"></a><dl class="docList"><dt><B><a class="docLink" href="ch13lev1sec1.html#ch13term6">memberwise initialization</a></b></dt><dd><p class="docText">Term used to described how the synthesized copy constructor works. The constructor copies, member by member, from the old object to the new. Members of built-in or compound type are copied directly. Those that are of class type are copied by using the member's copy constructor.</p></dd><br><br></dl>
<a name="gloss13_07"></a><dl class="docList"><dt><b><a class="docLink" href="ch13lev1sec2.html#ch13term7">overloaded operator</a></b></dt><dd><p class="docText">Function that redefines one of the C++ operators to operate on object(s) of class type. This chapter showed how to define the assignment operator; <a class="docLink" href="ch14.html#ch14">Chapter 14</a> covers overloaded operators in more detail.</P></dd><br><br></dl>
<a name="gloss13_08"></a><dl class="docList"><dt><B><a class="docLink" href="ch13lev1sec5.html#ch13term8">reference count</a></b></dt><dd><p class="docText">Synonym for use count.</p></dd><br><BR></dl>
<a name="gloss13_09"></a><dl class="docList"><dt><b><a class="docLink" href="ch13lev1sec3.html#ch13term9">Rule of Three</a></b></dt><dd><p class="docText">Shorthand for the rule of thumb that if a class needs a nontrivial destructor then it almost surely also needs to define its own copy constructor and an assignment operator.</P></dd><br><br></dl>
<a name="gloss13_10"></a><dl class="docList"><dt><b><a class="docLink" href="ch13lev1sec5.html#ch13term10">smart pointer</a></b></dt><dd><p class="docText">A class that behaves like a pointer but provides other functionality as well. One common form of smart pointer takes a pointer to a dynamically allocated object and assumes responsibility for deleting that object. The user allocates the object, but the smart pointer class deletes it. Smart pointer classes require that the class implement the copy-control members to manage a pointer to the shared object. That object is deleted only when the last smart pointer pointing to it is destroyed. Use counting is the most popular way to implement smart pointer classes.</p></dd><br><br></dl>
<a name="gloss13_11"></a><dl class="docList"><dt><b><a class="docLink" href="ch13lev1sec2.html#ch13term11">synthesized assignment operator</a></b></dt><dd><p class="docText">A version of the assignment operator created (synthesized) by the compiler for classes that do not explicitly define one. The synthesized assignment operator memberwise assigns the right-hand operand to the left.</p></dd><br><br></dl>
<a name="gloss13_12"></a><dl class="docList"><dt><b><a class="docLink" href="ch13lev1sec1.html#ch13term12">synthesized copy constructor</a></b></dt><dd><p class="docText">The copy constructor created (synthesized) by the compiler for classes that do not explicitly define the copy constructor. The synthesized copy constructor memberwise initializes the new object from the existing one.</p></dd><br><BR></dl>
<a name="gloss13_13"></a><dl class="docList"><dt><B><a class="docLink" href="ch13lev1sec5.html#ch13term13">use count</a></b></dt><dd><p class="docText">Programming technique used in copy-control members. A use count is stored along with a shared object. A separate class is created that points to the shared object and manages the use count. The constructors, other than the copy constructor, set the state of the shared object and set the use count to one. Each time a new copy is madeeither in the copy constructor or the assignment operatorthe use count is incremented. When an object is destroyed either in the destructor or as the left-hand side of the assignment operatorthe use count is decremented. The assignment operator and the destructor check whether the decremented use count has gone to zero and, if so, they destroy the object.</p></dd><BR><br></dl>
<a name="gloss13_14"></a><dl class="docList"><dt><b><a class="docLink" href="ch13lev1sec5.html#ch13term14">value semantics</a></b></dt><dd><p class="docText">Description of the copy-control behavior of classes that mimic the way arithmetic types are copied. Copies of valuelike objects are independent: Changes made to a copy have no effect on the original object. A valuelike class that has a pointer member must define its own copy-control members. The copy-control operations copy the object to which the pointer points. Valuelike classes that contain only other valuelike classes or built-in types often can rely on the synthesized copy-control members.</P></dd><BR><br></dl>


<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch13lev1sec6.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch14.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>