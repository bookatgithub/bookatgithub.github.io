<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 14.1.&nbsp; Defining an Overloaded Operator</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch14.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch14lev1sec2.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch14lev1sec1"></a>
<h3 class="docSection1Title">14.1. Defining an Overloaded Operator</h3>
<p class="docText">Overloaded operators are functions with special names: the keyword <tt>operator</tt> followed by the symbol for the operator being defined. Like any other function, an overloaded operator has a return type and a parameter list.</P>
<pre>
     Sales_item operator+(const Sales_item&amp;, const Sales_item&amp;);
</pre><BR>
<p class="docText">declares the addition operator that can be used to &quot;add&quot; two <tt>Sales_item</tt> objects and yields a copy of a <tt>Sales_item</tt> object.</p>
<p class="docText">With the exception of the function-call operator, an overloaded operator has the same number of parameters (including the implicit <tt>this</tt> pointer for member functions) as the operator has operands. The function-call operator takes any number of operands.</P>
<a name="ch14lev2sec1"></a>
<h4 class="docSection2Title">Overloaded Operator Names</h4>
<p class="docText"><a class="docLink" href="#ch14table01">Table 14.1</a> on the next page lists the operators that may be overloaded. Those that may not be overloaded are listed in <a class="docLink" href="#ch14table02">Table 14.2</a>.</P>
<a name="ch14table01"></a><P><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 14.1. Overloadable Operators</h5></caption><colgroup><col width="75"><col width="75"><col width="75"><col width="75"><col width="75"><col width="75"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>+</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>-</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>*</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>/</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>%</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>^</tt></p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>&amp;</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>|</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>~</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>!</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>,</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>=</tt></p></TD></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>&lt;</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>&gt;</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>&lt;=</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>&gt;=</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>++</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>--</tt></p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>&lt;&lt;</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>&gt;&gt;</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>==</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>!=</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>&amp;&amp;</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>||</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>+=</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>-=</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>/=</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>%=</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>^=</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>&amp;=</tt></p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>|=</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>*=</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>&lt;&lt;=</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>&gt;&gt;=</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>[]</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>()</tt></p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>-&gt;</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>-&gt;*</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>new</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>new []</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>delete</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>delete []</tt></P></td></tr></table></P><BR>
<a name="ch14table02"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 14.2. Operators That Cannot Be Overloaded</h5></caption><colgroup><col width="125"><col width="125"><col width="125"><col width="125"></colgroup><thead></thead><tr><td class="docTableCell" align="center" valign="top"><p class="docText"><tt>::</tt></P></td><TD class="docTableCell" align="center" valign="top"><p class="docText"><tt>.*</tt></P></td><td class="docTableCell" align="center" valign="top"><p class="docText"><tt>.</tt></p></TD><TD class="docTableCell" align="center" valign="top"><p class="docText"><tt>?:</tt></p></td></tr></table></p><BR>
<p class="docText">New operators may not be created by concatenating other legal symbols. For example, it would be illegal to attempt to define an <tt>operator**</tt> to provide exponentiation. Overloading <tt>new</tt> and <tt>delete</tt> is described in <a class="docLink" href="ch18.html#ch18">Chapter 18</a> (p. <a class="docLink" href="ch18.html#ch18">753</a>).</p>

<a name="ch14lev2sec2"></a>
<h4 class="docSection2Title">Overloaded Operators Must Have an Operand of Class Type</H4>
<p class="docText"><a name="idd1e104241"></a><a name="idd1e104246"></a><a name="idd1e104251"></a><a name="idd1e104256"></a><a name="idd1e104261"></a>The meaning of an operator for the built-in types may not be changed. For example, the built-in integer addition operation cannot be redefined:</p>
<pre>
     // <span class="docEmphasis">error: cannot redefine built-in operator for ints</span>
     int operator+(int, int);
</pre><br>
<p class="docText">Nor may additional operators be defined for the built-in data types. For example, an <tt>operator+</tt> taking two operands of array types cannot be defined.</P>
<a name="ch14note01"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> An overloaded operator must have at least one operand of class or enumeration (<a class="docLink" href="ch02lev1sec7.html#ch02lev1sec7">Section 2.7</a>, p. <a class="docLink" href="ch02lev1sec7.html#ch02lev1sec7">62</a>) type. This rule enforces the requirement that an overloaded operator may not redefine the meaning of the operators when applied to objects of built-in type.</p></td></tr></table><br>
</p></div><br>

<a name="ch14lev2sec3"></a>
<h4 class="docSection2Title">Precedence and Associativity Are Fixed</h4>
<p class="docText">The precedence (<a class="docLink" href="ch05lev1sec10.html#ch05lev2sec14">Section 5.10.1</a>, p. <a class="docLink" href="ch05lev1sec10.html#ch05lev2sec14">168</a>), associativity, or number of operands of an operator cannot be changed. Regardless of the type of the operands and regardless of the definition of what the operations do, this expression</p>
<pre>
     x == y +z;
</pre><br>
<p class="docText">always binds the arguments <tt>y</tt> and <tt>z</tt> to <tt>operator+</tt> and uses that result as the right-hand operand to <tt>operator==</tt>.</P>
<p class="docText">Four symbols (<tt>+, -, *</tt>, and <tt>&amp;)</tt> serve as both unary and binary operators. Either or both of these operators can be overloaded. Which operator is being defined is controlled by the number of operands. Default arguments for overloaded operators are illegal, except for <tt>operator()</tt>, the function-call operator.</P>

<a name="ch14lev2sec4"></a>
<h4 class="docSection2Title">Short-Ciruit Evaluation Is Not Preserved</H4>
<p class="docText"><a name="idd1e104355"></a><a name="idd1e104361"></a><a name="idd1e104366"></a><a name="idd1e104371"></a><a name="idd1e104376"></a><a name="idd1e104381"></a><a name="idd1e104388"></a>Overloaded operators make no guarantees about the order in which operands are evaluated. In particular, the operand-evaluation guarantees of the built-in logical AND, logical OR (<a class="docLink" href="ch05lev1sec2.html#ch05lev1sec2">Section 5.2</a>, p. <a class="docLink" href="ch05lev1sec2.html#ch05lev1sec2">152</a>), and comma (<a class="docLink" href="ch05lev1sec9.html#ch05lev1sec9">Section 5.9</a>, p. <a class="docLink" href="ch05lev1sec9.html#ch05lev1sec9">168</a>) operators are not preserved. Both operands to an overloaded version of <tt>&amp;&amp;</tt> or <tt>||</tt> are always evaluated. The order in which those operands are evaluated is not stipulated. The order in which the operands to the comma are evaluated is also not defined. For this reason, it is usually a bad idea to overload <tt>&amp;&amp;, ||</tt>, or the comma operator.</p>

<a name="ch14lev2sec5"></a>
<h4 class="docSection2Title">Class Member versus Nonmember</H4>
<p class="docText">Most overloaded operators may be defined as ordinary nonmember functions or as class member functions.</P>
<a name="ch14note02"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> Overloaded functions that are members of a class may appear to have one less parameter than the number of operands. Operators that are member functions have an implicit <tt>this</tt> parameter that is bound to the first operand.</P></td></TR></table><BR>
</p></div><br>
<p class="docText">An overloaded unary operator has no (explicit) parameter if it is a member function and one parameter if it is a nonmember function. Similarly, an overloaded binary operator would have one parameter when defined as a member and two parameters when defined as a nonmember function.</p>
<p class="docText">The <tt>Sales_item</tt> class offers a good example of member and nonmember binary operators. We know that the class has an addition operator. Because it has an addition operator, we ought to define a compound-assignment (<tt>+=</tt>) operator as well. This operator will add the value of one <tt>Sales_item</tt> object into another.</P>
<p class="docText">Ordinarily we define the arithmetic and relational operators as nonmember functions and we define assignment operators as members:</P>
<pre>
     // <span class="docEmphItalicAlt">member binary operator: left-hand operand bound to implicit this pointer</span>
     Sales_item&amp; Sales_item::operator+=(const Sales_item&amp;);
     // <span class="docEmphItalicAlt">nonmember binary operator: must declare a parameter for each operand</span>
     Sales_item operator+(const Sales_item&amp;, const Sales_item&amp;);
</pre><br>
<p class="docText">Both addition and compound assignment are binary operators, yet these functions define a different number of parameters. The reason for the discrepancy is the <tt>this</tt> pointer.</p>
<p class="docText">When an operator is a member function, <tt>this</tt> points to the left-hand operand. Thus, the nonmember <tt>operator+</tt> defines two parameters, both references to <tt>const Sales_item</tt> objects. Even though compound assignment is a binary operator, the member compound-assignment operator takes only one (explicit) parameter. When the operator is used, a pointer to the left-hand operand is automatically bound to <tt>this</tt> and the right-hand operand is bound to the function's sole parameter.</p>
<p class="docText">It is also worth noting that compound assignment returns a reference and the addition operator returns a <tt>Sales_item</tt> object. This difference matches the return types of these operators when applied to arithmetic types: Addition yields an rvalue and compound assignment returns a reference to the left-hand operand.</p>

<a name="ch14lev2sec6"></a>
<H4 class="docSection2Title">Operator Overloading and Friendship</h4>
<p class="docText"><a name="idd1e104505"></a><a name="idd1e104510"></a><a name="idd1e104515"></a>When operators are defined as nonmember functions, they often must be made friends (<a class="docLink" href="ch12lev1sec5.html#ch12lev1sec5">Section 12.5</a>, p. <a class="docLink" href="ch12lev1sec5.html#ch12lev1sec5">465</a>) of the class(es) on which they operate. We'll see later in this chapter two reasons why operators might be defined as nonmembers. In such cases, the operator often needs access to the private parts of the class.</p>
<p class="docText">Our <tt>Sales_item</tt> class is again a good example of why some operators need to be friends. It defines one member operator and has three nonmember operators. Those nonmember operators, which need access to the private data members, are declared as friends:</P>
<pre>
     class Sales_item {
         friend std::istream&amp; operator&gt;&gt;
                       (std::istream&amp;, Sales_item&amp;);
         friend std::ostream&amp; operator&lt;&lt;
                       (std::ostream&amp;, const Sales_item&amp;);
     public:
         Sales_item&amp; operator+=(const Sales_item&amp;);
     };
         Sales_item operator+(const Sales_item&amp;, const Sales_item&amp;);
</pre><br>
<p class="docText">That the input and output operators need access to the <tt>private</tt> data should not be surprising. After all, they read and write those members. On the other hand, there is no need to make the addition operator a friend. It can be implemented using the <tt>public</tt> member <tt>operator+=</tt>.</p>

<a name="ch14lev2sec7"></a>
<H4 class="docSection2Title">Using Overloaded Operators</h4>
<p class="docText">We can use an overloaded operator in the same way that we'd use the operator on operands of built-in type. Assuming <tt>item1</tt> and <tt>item2</tt> are <tt>Sales_item</tt> objects, we might print their sum in the same way that we'd print the sum of two <tt>int</tt>s:</P>
<pre>
     cout &lt;&lt; item1 + item2 &lt;&lt; endl;
</pre><br>
<p class="docText">This expression implicitly calls the <tt>operator+</tt> that we defined for <tt>Sales_items</tt>.</p>
<p class="docText">We also can call an overloaded operator function in the same way that we call an ordinary function: We name the function and pass an appropriate number of arguments of the appropriate type:</p>
<pre>
     // <span class="docEmphasis">equivalent direct call to nonmember operator function</span>
     cout &lt;&lt; operator+(item1, item2) &lt;&lt; endl;
</pre><br>
<p class="docText">This call has the same effect as the expression that added <tt>item1</tt> and <tt>item2</tt>.</p>
<p class="docText">We call a member operator function the same way we call any other member function: We name an object on which to run the function and then use the dot or arrow operator to fetch the function we wish to call passing the required number and type of arguments. In the case of a binary member operator function, we must pass a single operand:</p>
<pre>
     item1 += item2;            // <span class="docEmphasis">expression based "call"</span>
     item1.operator+=(item2);   // <span class="docEmphasis">equivalent call to member operator function</span>
</pre><br>
<p class="docText"><a name="idd1e104626"></a><a name="idd1e104631"></a>Each of these statements adds the value of <tt>item2</tt> into <tt>item1</tt>. In the first case, we implicitly call the overloaded operator function using expression syntax. In the second, we call the member operator function on the object <tt>item1</tt>.</p>
<a name="ch14sb01"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 14.1</h2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><td align="right" class="docText" width="50"><a name="ch14qa1q1"></a><B>Exercise 14.1:</b></td><td><p class="docText">In what ways does an overloaded operator differ from a built-in operator? In what ways are overloaded operators the same as the built-in operators?</P>
</TD></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa1q2"></a><b>Exercise 14.2:</b></td><TD><p class="docText">Write declarations for the overloaded input, output, addition and compound-assignment operators for <tt>Sales_item</tt>.</p>
</TD></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa1q3"></a><b>Exercise 14.3:</b></TD><TD><p class="docText">Explain the following program, assuming that the <tt>Sales_item</tt> constructor that takes a <tt>string</tt> is not <tt>explicit</tt>. Explain what happens if that constructor is <tt>explicit</tt>.</p>
<pre>
     string null_book = "9-999-99999-9";
     Sales_item item(cin);
     item += null_book;
</pre><br>
</td></tr><TR valign="top"><td align="right" class="docText" width="50"><a name="ch14qa1q4"></a><b>Exercise 14.4:</b></TD><td><p class="docText">Both the <tt>string</tt> and <tt>vector</tt> types define an overloaded <tt>==</tt> that can be used to compare objects of those types. Identify which version of <tt>==</tt> is applied in each of the following expressions:</p>
<pre>
     string s; vector&lt;string&gt; svec1, svec2;
     "cobble" == "stone"
     svec1[0] == svec2[0];
     svec1 == svec2
</pre><BR>
</td></TR></table></p>
</blockquote>
</td></tr></table></p><br>

<a name="ch14lev2sec8"></a>
<h4 class="docSection2Title">14.1.1. Overloaded Operator Design</h4>
<p class="docText">When designing a class there are some useful rules of thumb to keep in mind when deciding which, if any, overloaded operators to provide.</p>
<a name="ch14lev3sec1"></a>
<h5 class="docSection3Title">Don't Overload Operators with Built-in Meanings</h5>
<p class="docText">The assignment, address of, and comma operators have default meanings for operands of class types. If there is no overloaded version specified, the compiler defines its own version of these operators:</p>
<ul><li><p class="docList">The synthesized assignment operator (<a class="docLink" href="ch13lev1sec2.html#ch13lev1sec2">Section 13.2</a>, p. <a class="docLink" href="ch13lev1sec2.html#ch13lev1sec2">482</a>) does memberwise assignment: It uses each member's own assignment operator to assign each member in turn.</P></LI><li><p class="docList">By default the address of (<tt>&amp;</tt>) and comma (<tt>,</tt>) operators execute on class type objects the same way they do on objects of built-in type. The address of operator returns the address in memory of the object to which it is applied. The comma operator evaluates each expression from left to right and returns the value of its rightmost operand.</P></li><li><p class="docList"><a name="idd1e104782"></a><a name="idd1e104787"></a><a name="idd1e104794"></a><a name="idd1e104801"></a><a name="idd1e104808"></a><a name="idd1e104815"></a><a name="idd1e104823"></a><a name="idd1e104831"></a><a name="idd1e104836"></a><a name="idd1e104844"></a><a name="idd1e104852"></a><a name="idd1e104859"></a><a name="idd1e104866"></a><a name="idd1e104873"></a><a name="idd1e104880"></a><a name="idd1e104888"></a><a name="idd1e104893"></a>The built-in logical AND (<tt>&amp;&amp;</tt>) and OR(<tt>||)</tt> operators apply short-circuit evaluation (<a class="docLink" href="ch05lev1sec2.html#ch05lev1sec2">Section 5.2</a>, p. <a class="docLink" href="ch05lev1sec2.html#ch05lev1sec2">152</a>). If the operator is redefined, the short-circuit nature of the operators is lost.</P></LI></ul>
<p class="docText">The meaning of these operators can be changed by redefining them for operands of a given class type.</p>
<a name="ch14note03"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></TD><td valign="top"><p class="docText"> It is usually <span class="docEmphasis">not</span> a good idea to overload the comma, address-of, logical AND, or logical OR operators. These operators have built-in meanings that are useful and become inaccessible if we define our own versions.</P></TD></tr></table><br>
</p></div><BR>
<p class="docText">We sometimes must define our own version of assignment. When we do so, it should behave analogously to the synthesized operators: After an assignment, the values in the left-hand and right-hand operands should be the same and the operator should return a reference to its left-hand operand. Overloaded assignment should customize the built-in meaning of assignment, not circumvent it.</P>

<a name="ch14lev3sec2"></a>
<h5 class="docSection3Title">Most Operators Have No Meaning for Class Objects</h5>
<p class="docText">Operators other than assignment, address-of, and comma have no meaning when applied to an operand of class type unless an overloaded definition is provided. When designing a class, we decide which, if any, operators to support.</p>
<p class="docText">The best way to design operators for a class is first to design the class' public interface. Once the interface is defined, it is possible to think about which operations should be defined as overloaded operators. Those operations with a logical mapping to an operator are good candidates. For example,</p>
<UL><li><p class="docList">An operation to test for equality should use <tt>operator==</tt>.</p></LI><li><p class="docList">Input and output are normally done by overloading the shift operators.</p></LI><li><p class="docList">An operation to test whether the object is empty could be represented by the logical NOT operator, <tt>operator!</tt>.</P></li></ul>

<a name="ch14lev3sec3"></a>
<h5 class="docSection3Title">Compound Assignment Operators</h5>
<p class="docText">If a class has an arithmetic (<a class="docLink" href="ch05lev1sec1.html#ch05lev1sec1">Section 5.1</a>, p. <a class="docLink" href="ch05lev1sec1.html#ch05lev1sec1">149</a>) or bitwise (<a class="docLink" href="ch05lev1sec3.html#ch05lev1sec3">Section 5.3</a>, p. <a class="docLink" href="ch05lev1sec3.html#ch05lev1sec3">154</a>) operator, then it is usually a good idea to provide the corresponding compound-assignment operator as well. For example, our <tt>Sales_item</tt> class defined the <tt>+</tt> operator. Logically, it also should define <tt>+=</tt>. Needless to say, the <tt>+=</tt> operator should be defined to behave the same way the built-in operators do: Compound assignment should behave as <tt>+</tt> followed by <tt>=</tt>.</p>

<a name="ch14lev3sec4"></a>
<h5 class="docSection3Title">Equality and Relational Operators</h5>
<p class="docText">Classes that will be used as the key type of an associative container should define the <tt>&lt;</tt> operator. The associative containers by default use the <tt>&lt;</tt> operator of the key type. Even if the type will be stored only in a sequential container, the class ordinarily should define the equality (<tt>==</tt>) and less-than (<tt>&lt;</tt>) operators. The reason <a name="idd1e105030"></a><a name="idd1e105038"></a><a name="idd1e105046"></a><a name="idd1e105051"></a>is that many algorithms assume that these operators exist. As an example, the <tt>sort</tt> algorithm uses <tt>&lt;</tt> and <tt>find</tt> uses <tt>==</tt>.</p>
<a name="ch14sb02"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Caution: Use Operator Overloading Judiciously</h2>
<p class="docText"><span class="docEmphStrong">Each operator has an associated meaning from its use on the built-in types. Binary <tt>+</tt>, for example, is strongly identified with addition. Mapping binary <tt>+</tt> to an analogous operation for a class type can provide a convenient notational shorthand. For example, the library <tt>string</tt> type, following a convention common to many programming languages, uses <tt>+</tt> to represent concatenation&quot;adding&quot; one string to the other.</span></P>
<p class="docText"><span class="docEmphStrong">Operator overloading is most useful when there is a logical mapping of a built-in operator to an operation on our type. Using overloaded operators rather than inventing named operations can make our programs more natural and intuitive. Overuse or outright abuse of operator overloading can make our classes incomprehensible.</span></P>
<p class="docText"><span class="docEmphStrong">Obvious abuses of operator overloading rarely happen in practice. As an example, no responsible programmer would define <tt>operator+</tt> to perform subtraction. More common, but still inadvisable, are uses that contort an operator's &quot;normal&quot; meaning to force a fit to a given type. Operators should be used only for operations that are likely to be unambiguous to users. An operator with ambiguous meaning, in this sense, is one that supports equally well a number of different interpretations.</span></p>
<a name="ch14note04"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></TD><TD valign="top"><p class="docText"> <span class="docEmphStrong">When the meaning of an overloaded operator is not obvious, it is better to give the operation a name. It is also usually better to use a named function rather than an operator for operations that are rarely done. If the operation is unusual, the brevity of using an operator is unnecessary.</span></p></td></tr></table><br>
</p></div><BR>
</td></TR></table></P><br>
<p class="docText">If the class defines the equality operator, it should also define <tt>!=</tt>. Users of the class will assume that if they can compare for equality, they can also compare for inequality. The same argument applies to the other relational operators as well. If the class defines <tt>&lt;</tt>, then it probably should define all four relational operators (<tt>&gt;, &gt;=, &lt;</tt>, and <tt>&lt;=)</tt>.</p>

<a name="ch14lev3sec5"></a>
<h5 class="docSection3Title">Choosing Member or Nonmember Implementation</H5>
<p class="docText">When designing the overloaded operators for a class, we must choose whether to make each operator a class member or an ordinary nonmember function. In some cases, the programmer has no choice; the operator must be a member. In other cases, there are some rules of thumb that can help guide the decision. The following guidelines can be of help when deciding whether to make an operator a member or an ordinary nonmember function:</P>
<ul><li><p class="docList">The assignment (<tt>=</tt>), subscript (<tt>[]</tt>), call (<tt>()</tt>), and member access arrow (<tt>-&gt;</tt>) operators must be defined as members. Defining any of these operators as a nonmember function is flagged at compile time as an error.</p></li><LI><p class="docList">Like assignment, the compound-assignment operators ordinarily ought to be members of the class. Unlike assignment, they are not required to be so and the compiler will not complain if a nonmember compound-assignment operator is defined.</p></li><LI><p class="docList"><a name="idd1e105164"></a><a name="idd1e105171"></a><a name="idd1e105179"></a>Other operators that change the state of their object or that are closely tied to their given typesuch as increment, decrement, and dereferenceusually should be members of the class.</p></li><LI><p class="docList">Symmetric operators, such as the arithmetic, equality, relational, and bitwise operators, are best defined as ordinary nonmember functions.</p></LI></ul>
<a name="ch14sb03"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 14.1.1</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa2q1"></a><b>Exercise 14.5:</b></td><td><p class="docText">List the operators that must be members of a class.</p>
</TD></TR><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch14qa2q2"></a><b>Exercise 14.6:</b></td><TD><p class="docText">Explain why and whether each of the following operators should be class members:</P>
<pre>
     (a) + (b) += (c) ++ (d) -&gt; (e) &lt;&lt; (f) &amp;&amp; (g) == (h) ()
</pre><br>
</td></tr></table></p>
</blockquote>
</td></TR></table></p><BR>



<a href="21001535.html"><img src="images/pixel.gif" alt="" width="1" height="1" border="0"></a><UL></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch14.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch14lev1sec2.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>