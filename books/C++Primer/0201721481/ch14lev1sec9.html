<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 14.9.&nbsp; Conversions and Class Types</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch14lev1sec8.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch14lev1sec10.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch14lev1sec9"></a>
<h3 class="docSection1Title">14.9. Conversions and Class Types</h3>
<p class="docText">In <a class="docLink" href="ch12lev1sec4.html#ch12lev2sec23">Section 12.4.4</a> (p. <a class="docLink" href="ch12lev1sec4.html#ch12lev2sec23">461</a>) we saw that a non<tt>explicit</tt> constructor that can be called with one argument defines an implicit conversion. The compiler will use that conversion when an object of the argument type is supplied and an object of the class type is needed. Such constructors define conversions to the class type.</P>
<a name="ch14sb13"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Exercises Section 14.8.3</h2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><td align="right" class="docText" width="50"><a name="ch14qa12q1"></a><b>Exercise 14.37:</b></td><td><p class="docText"><a name="idd1e109421"></a>Using the library function objects and adaptors, define an object to:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><LI><div style="font-weight:normal"><p class="docList">Find all values that are greater than 1024.</p></div></LI><LI><div style="font-weight:normal"><p class="docList">Find all strings that are not equal to <tt>pooh</tt>.</p></div></li><li><div style="font-weight:normal"><p class="docList">Multiply all values by 2.</P></div></LI></ol></div>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa12q2"></a><B>Exercise 14.38:</b></td><td><p class="docText">In the last call to <tt>count_if</tt> we used <tt>not1</tt> to negate the result from <tt>bind2nd</tt> of <tt>(less_equal&lt;int&gt;(), 10)</tt>. Why did we use <tt>not1</tt> rather than <tt>not2</tt>.</P>
</td></tr><TR valign="top"><td align="right" class="docText" width="50"><a name="ch14qa12q3"></a><B>Exercise 14.39:</b></td><td><p class="docText">Use library function objects in place of <tt>GT_cls</tt> to find the words of a specified length.</p>
</td></tr></table></p>
</blockquote>
</td></tr></table></p><br>
<p class="docText">In addition to defining conversions <span class="docEmphasis">to</span> a class type, we can also define conversions <span class="docEmphasis">from</span> the class type. That is, we can define a conversion operator that, given an object of the class type, will generate an object of another type. As with other conversions, the compiler will apply this conversion automatically. Before showing how to define such conversions, we'll look at why they might be useful.</p>
<a name="ch14lev2sec30"></a>
<h4 class="docSection2Title">14.9.1. Why Conversions Are Useful</h4>
<p class="docText">Assume that we want to define a class, which we'll name <tt>SmallInt</tt>, to implement safe small integers. Our class will allow us to define objects that could hold the same range of values as an 8-bit unsigned <tt>char</tt>that is, 0 to 255. This class would catch under- and overflow errors and so would be safer to use than a built-in <tt>unsigned char</tt>.</P>
<p class="docText">We'd want our class to define all the same operations as are supported by an <tt>unsigned char</tt>. In particular, we'd want to define the five arithmetic operators (<tt>+, -, *, /</tt>, and <tt>%)</tt> and the corresponding compound-assignment operators; the four relational operators (<tt>&lt;, &lt;=, &gt;</tt>, and <tt>&gt;=);</tt> and the equality operators (<tt>==</tt> and <tt>!=</tt>). Evidently, we'd need to define 16 operators.</P>
<a name="ch14lev3sec18"></a>
<h5 class="docSection3Title">Supporting Mixed-Type Expressions</H5>
<p class="docText">Moreover, we'd like to be able to use these operators in mixed-mode expressions. For example, it should be possible to add two <tt>SmallInt</tt> objects and also possible to add any of the arithmetic types to a <tt>SmallInt</tt>. We could come close by defining three instances for each operator:</p>
<pre>
     int operator+(int, const SmallInt&amp;);
     int operator+(const SmallInt&amp;, int);
     SmallInt operator+(const SmallInt&amp;, const SmallInt&amp;);
</pre><br>
<p class="docText">Because there is a conversion to <tt>int</tt> from any of the arithmetic types, these three functions would cover our desire to support mixed mode use of <tt>SmallInt</tt> objects. However, this design only approximates the behavior of built-in integer <a name="idd1e109572"></a><a name="idd1e109577"></a><a name="idd1e109582"></a><a name="idd1e109587"></a>arithmetic. It wouldn't properly handle mixed-mode operations for the floating-point types, nor would it properly support addition of <tt>long, unsigned int</tt>, or <tt>unsigned long</tt>. The problem is that this design converts all arithmetic types even those bigger than <tt>int</tt>to <tt>int</tt> and does an <tt>int</tt> addition.</P>

<a name="ch14lev3sec19"></a>
<H5 class="docSection3Title">Conversions Reduce the Number of Needed Operators</h5>
<p class="docText">Even ignoring the issue of floating-point or large integral operands, if we implemented this design, we'd have to define 48 operators! Fortunately, C++ provides a mechanism by which a class can define its own conversions that can be applied to objects of its class type. For <tt>SmallInt</tt>, we could define a conversion from <tt>SmallInt</tt> to type <tt>int</tt>. If we define the conversion, then we won't need to define any of the arithmetic, relational, or equality operators. Given a conversion to <tt>int</tt>, a <tt>SmallInt</tt> object could be used anywhere an <tt>int</tt> could be used.</p>
<p class="docText">If there were a conversion to <tt>int</tt>, then</p>
<pre>
     SmallInt si(3);
     si + 3.14159;         // <span class="docEmphItalicAlt">convert</span> <span class="docEmphasis">si</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">int</span>, <span class="docEmphItalicAlt">then convert to</span> <span class="docEmphasis">double</span>
</pre><br>
<p class="docText">would be resolved by</p>
<div style="font-weight:bold"><ol class="docList" type="1"><LI><div style="font-weight:normal"><p class="docList">Converting <tt>si</tt> to an <tt>int</tt>.</p></div></LI><LI><div style="font-weight:normal"><p class="docList">Converting the resulting <tt>int</tt> to <tt>double</tt> and adding it to the double literal constant <tt>3.14159</tt>, yielding a <tt>double</tt> value.</p></div></li></ol></div>


<a name="ch14lev2sec31"></a>
<h4 class="docSection2Title">14.9.2. Conversion Operators</H4>
<p class="docText">A <B><a name="ch14term4"></a><a class="docLink" href="ch14lev1sec11.html#gloss14_04">conversion operator</a></b> is a special kind of class member function. It defines a conversion that converts a value of a class type to a value of some other type. A conversion operator is declared in the class body by specifying the keyword <tt>operator</tt> followed by the type that is the target type of the conversion:</p>
<pre>
     class SmallInt {
     public:
         SmallInt(int i = 0): val(i)
         { if (i &lt; 0 || i &gt; 255)
            throw std::out_of_range("Bad SmallInt initializer");
         }
         operator int() const { return val; }
     private:
         std::size_t val;
     };
</pre><br>
<p class="docText">A conversion function takes the general form</p>
<pre>
     operator <span class="docEmphasis">type()</span>;
</pre><br>
<p class="docText">where <span class="docEmphasis">type</span> represents the name of a built-in type, a class type, or a name defined by a typedef. Conversion functions can be defined for any type (other than <tt>void</tt>) that <a name="idd1e109743"></a>could be a function return type. In particular, conversions to an array or function type are not permitted. Conversions to pointer typesboth data and function pointersand to reference types are allowed.</P>
<a name="ch14note25"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> A conversion function must be a member function. The function may not specify a return type, and the parameter list must be empty.</P></td></TR></table><br>
</p></div><br>
<p class="docText">All of the following declarations are errors:</p>
<pre>
     operator int(SmallInt &amp;);            // <span class="docEmphItalicAlt">error: nonmember</span>

     class SmallInt {
     public:
         int operator int();              // <span class="docEmphItalicAlt">error: return type</span>
         operator int(int = 0);           // <span class="docEmphItalicAlt">error: parameter list</span>
         // ...
     };
</pre><br>
<p class="docText">Although a conversion function does not specify a return type, each conversion function must explicitly return a value of the named type. For example, <tt>operator int</tt> returns an <tt>int</tt>; if we defined an <tt>operator Sales_item</tt>, it would return a <tt>Sales_item;</tt> and so on.</p>
<a name="ch14note26"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><td valign="top"><p class="docText"> Conversion operations ordinarily should not change the object they are converting. As a result, conversion operators usually should be defined as <tt>const</tt> members.</p></td></TR></table><BR>
</p></div><BR>
<a name="ch14lev3sec20"></a>
<h5 class="docSection3Title">Using a Class-Type Conversion</h5>
<p class="docText">Once a conversion exists, the compiler will call it automatically (<a class="docLink" href="ch05lev1sec12.html#ch05lev2sec25">Section 5.12.1</a>, p. <a class="docLink" href="ch05lev1sec12.html#ch05lev2sec25">179</a>) in the same places that a built-in conversion would be used:</P>
<UL><li><p class="docList">In expressions:</p><pre>
     SmallInt si;
     double dval;
     si &gt;= dval          // <span class="docEmphasis">si</span> <span class="docEmphItalicAlt">converted to</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">and then convert to</span> <span class="docEmphasis">double</span>
</pre><br></li><li><p class="docList">In conditions:</P><pre>
     if (si)                // <span class="docEmphasis">si</span> <span class="docEmphItalicAlt">converted to</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">and then convert to</span> <span class="docEmphasis">bool</span>
</pre><br></LI><LI><p class="docList">When passing arguments to or returning values from a function:</p><pre>
     int calc(int);
     SmallInt si;
     int i = calc(si);      // <span class="docEmphItalicAlt">convert</span> <span class="docEmphasis">si</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">and call</span> <span class="docEmphasis">calc</span>
</pre><br></li><LI><p class="docList">As operands to overloaded operators:</P><pre>
     // <span class="docEmphItalicAlt">convert</span> <span class="docEmphasis">si</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">then call opeator&lt;&lt; on the</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">value</span>
     cout &lt;&lt; si &lt;&lt; endl;
</pre><br></li><li><p class="docList"><a name="idd1e109936"></a><a name="idd1e109941"></a>In an explicit cast:</p><pre>
     int ival;
     SmallInt si = 3.541; //
     <span class="docEmphItalicAlt">instruct compiler to cast si to int</span>
     ival = static_cast&lt;int&gt;(si) + 3;
</pre><BR></li></ul>

<a name="ch14lev3sec21"></a>
<H5 class="docSection3Title">Class-Type Conversions and Standard Conversions</h5>
<p class="docText">When using a conversion function, the converted type need not exactly match the needed type. A class-type conversion can be followed by a standard conversion (<a class="docLink" href="ch05lev1sec12.html#ch05lev2sec27">Section 5.12.3</a>, p. <a class="docLink" href="ch05lev1sec12.html#ch05lev2sec27">181</a>) if needed to obtain the desired type. For example, in the comparison between a <tt>SmallInt</tt> and a <tt>double</tt></p>
<pre>
     SmallInt si;
     double dval;
     si &gt;= dval // <span class="docEmphasis">si</span> <span class="docEmphItalicAlt">converted to</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">and then convert to</span> <span class="docEmphasis">double</span>
</pre><BR>
<p class="docText"><tt>si</tt> is first converted from a <tt>SmallInt</tt> to an <tt>int</tt>, and then the <tt>int</tt> value is converted to <tt>double</tt>.</p>

<a name="ch14lev3sec22"></a>
<H5 class="docSection3Title">Only One Class-Type Conversion May Be Applied</h5>
<a name="ch14note27"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> A class-type conversion may not be followed by another class-type conversion. If more than one class-type conversion is needed then the code is in error.</p></td></tr></table><br>
</p></div><br>
<p class="docText">For example, assume we had another class, <tt>Integral</tt>, that could be converted to <tt>SmallInt</tt> but that had no conversion to <tt>int</tt>:</p>
<pre>
     // <span class="docEmphItalicAlt">class to hold unsigned integral values</span>
     class Integral {
     public:
         Integral(int i = 0): val(i) { }
         operator SmallInt() const { return val % 256; }
     private:
         std::size_t val;
     };
</pre><BR>
<p class="docText">We could use an <tt>Integral</tt> where a <tt>SmallInt</tt> is needed, but not where an <tt>int</tt> is required:</P>
<pre>
     int calc(int);
     Integral intVal;
     SmallInt si(intVal);  // <span class="docEmphItalicAlt">ok: convert</span> <span class="docEmphasis">intVal</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">SmallInt</span> <span class="docEmphItalicAlt">and copy to</span> <span class="docEmphasis">si</span>
     int i = calc(si);     // <span class="docEmphItalicAlt">ok: convert</span> <span class="docEmphasis">si</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">and call</span> <span class="docEmphasis">calc</span>
     int j = calc(intVal); // <span class="docEmphasis">error: no conversion to int from Integral</span>
</pre><br>
<p class="docText">When we create <tt>si</tt>, we use the <tt>SmallInt</tt> copy constructor. First <tt>int_val</tt> is converted to a <tt>SmallInt</tt> by invoking the <tt>Integral</tt> conversion operator to generate a temporary value of type <tt>SmallInt</tt>. The (synthesized) <tt>SmallInt</tt> copy constructor then uses that value to initialize <tt>si</tt>.</P>
<p class="docText"><a name="idd1e110138"></a><a name="idd1e110145"></a><a name="idd1e110152"></a>The first call to <tt>calc</tt> is also okay: The argument <tt>si</tt> is automatically converted to <tt>int</tt>, and the <tt>int</tt> value is passed to the function.</p>
<p class="docText">The second call is an error: There is no direct conversion from <tt>Integral</tt> to <tt>int</tt>. To get an <tt>int</tt> from an <tt>Integral</tt> would require two class-type conversions: first from <tt>Integral</tt> to <tt>SmallInt</tt> and then from <tt>SmallInt</tt> to <tt>int</tt>. However, the language allows only one class-type conversion, so the call is in error.</p>

<a name="ch14lev3sec23"></a>
<H5 class="docSection3Title">Standard Conversions Can Precede a Class-Type Conversion</H5>
<p class="docText">When using a constructor to perform an implicit conversion (<a class="docLink" href="ch12lev1sec4.html#ch12lev2sec23">Section 12.4.4</a>, p. <a class="docLink" href="ch12lev1sec4.html#ch12lev2sec23">462</a>), the parameter type of the constructor need not exactly match the type supplied. For example, the following code invokes the constructor <tt>SmallInt(int)</tt> defined in class <tt>SmallInt</tt> to convert <tt>sobj</tt> to the type <tt>SmallInt</tt>:</p>
<pre>
     void calc(SmallInt);
     short sobj;
     // <span class="docEmphasis">sobj</span> <span class="docEmphItalicAlt">promoted from</span> <span class="docEmphasis">short</span> <span class="docEmphItalicAlt">to int</span>
     // <span class="docEmphItalicAlt">that</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">converted to</span> <span class="docEmphasis">SmallInt</span> <span class="docEmphItalicAlt">through the</span> <span class="docEmphasis">SmallInt(int)</span> <span class="docEmphItalicAlt">constructor</span>
     calc(sobj);
</pre><br>
<p class="docText">If needed, a standard conversion sequence can be applied to an argument before a constructor is called to perform a class-type conversion. To call the function <tt>calc()</tt>, a standard conversion is applied to convert <tt>dobj</tt> from type <tt>double</tt> to type <tt>int</tt>. The <tt>SmallInt(int)</tt> constructor is then invoked to convert the result of the conversion to the type <tt>SmallInt</tt>.</p>
<a name="ch14sb14"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Exercises Section 14.9.2</H2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa13q1"></a><b>Exercise 14.40:</b></TD><TD><p class="docText">Write operators that could convert a <tt>Sales_item</tt> to <tt>string</tt> and to <tt>double</tt>. What values do you think these operators should return? Do you think these conversions are a good idea? Explain why or why not.</p>
</td></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch14qa13q2"></a><b>Exercise 14.41:</b></td><TD><p class="docText">Explain the difference between these two conversion operators:</p>
<pre>
     class Integral {
     public:
         const int();
         int() const;
     };
</pre><br>
<p class="docText">Are either of these conversions too restricted? If so, how might you make the conversion more general?</P>
</td></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa13q3"></a><b>Exercise 14.42:</b></td><td><p class="docText">Define a conversion operator to <tt>bool</tt> for the <tt>CheckoutRecord</tt> class from the exercises in <a class="docLink" href="ch14lev1sec2.html#ch14sb04">Section 14.2.1</a> (p. <a class="docLink" href="ch14lev1sec2.html#ch14sb04">515</a>).</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa13q4"></a><b>Exercise 14.43:</b></td><td><p class="docText">Explain what the <tt>bool</tt> conversion operator does. Is that the only possible meaning for this conversion for the <tt>CheckoutRecord</tt> type? Explain whether you think this conversion is a good use of a conversion operation.</P>
</TD></tr></table></P>
</blockquote>
</td></tr></table></P><BR>


<a name="ch14lev2sec32"></a>
<h4 class="docSection2Title">14.9.3. Argument Matching and Conversions</h4>
<a name="ch14note28"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></TD><td valign="top"><p class="docText"><a name="idd1e110385"></a><a name="idd1e110390"></a><a name="idd1e110397"></a><a name="idd1e110404"></a><a name="idd1e110409"></a><a name="idd1e110416"></a><a name="idd1e110423"></a> The rest of this chapter covers a somewhat advanced topic. It can be safely skipped on first reading.</P></TD></tr></table><br>
</p></div><BR>
<p class="docText">Class-type conversions can be a boon to implementing and using classes. By defining a conversion to <tt>int</tt> for <tt>SmallInt</tt>s, we made the class easier to implement and easier to use. The <tt>int</tt> conversion lets users of <tt>SmallInt</tt> use all the arithmetic and relational operators on <tt>SmallInt</tt> objects. Moreover, users can safely write expressions that intermix <tt>SmallInt</tt>s and other arithmetic types. The class implementor's job is made much easier by defining a single conversion operator instead of having to define 48 (or more) overloaded operators.</P>
<p class="docText">Class-type conversions can also be a great source of compile-time errors. Problems arise when there are multiple ways to convert from one type to another. If there are several class-type conversions that could be used, the compiler must figure out which one to use for a given expression. In this section, we look at how class-type conversions are used to match an argument to its corresponding parameter. We look first at how parameters are matched for functions that are not overloaded and then look at overloaded functions.</p>
<a name="ch14note29"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></TD><td valign="top"><p class="docText"> Used carefully, class-type conversions can greatly simplify both class and user code. Used too freely, they can lead to mysterious compile-time errors that can be hard to understand and hard to avoid.</p></TD></tr></table><br>
</P></div><br>
<a name="ch14lev3sec24"></a>
<H5 class="docSection3Title">Argument Matching and Multiple Conversion Operators</h5>
<p class="docText">To illustrate how conversions on values of class type interact with function matching, we'll add two additional conversions to our <tt>SmallInt</tt> class. We'll add a second constructor that takes a <tt>double</tt> and also define a second conversion operator to convert <tt>SmallInt</tt> to <tt>double</tt>:</p>
<pre>
     // <span class="docEmphItalicAlt">unwise class definition:</span>
     // <span class="docEmphItalicAlt">multiple constructors and conversion operators to and from the built-in types</span>
     // <span class="docEmphItalicAlt">can lead to ambiguity problems</span>
     class SmallInt {
     public:
         // <span class="docEmphItalicAlt">conversions to</span> <span class="docEmphasis">SmallInt</span> <span class="docEmphItalicAlt">from</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">double</span>
         SmallInt(int = 0);
         SmallInt(double);
         // <span class="docEmphItalicAlt">Conversions to</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">or</span> <span class="docEmphasis">double</span> <span class="docEmphItalicAlt">from</span> <span class="docEmphasis">SmallInt</span>
         // <span class="docEmphasis">Usually it is unwise to define conversions to multiple arithmetic types</span>
         operator int() const { return val; }
         operator double() const { return val; }
         // ...
     private:
         std::size_t val;
     };
</pre><br>
<a name="ch14note30"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"><a name="idd1e110546"></a><a name="idd1e110550"></a><a name="idd1e110554"></a><a name="idd1e110558"></a> Ordinarily it is a bad idea to give a class conversions to or from two built-in types. We do so here to illustrate the pitfalls involved.</p></td></tr></table><br>
</p></div><BR>
<p class="docText">Consider the simple case where we call a function that is not overloaded:</P>
<pre>
     void compute(int);
     void fp_compute(double);
     void extended_compute(long double);
     SmallInt si;
     compute(si);          // <span class="docEmphasis">SmallInt::operator int() const</span>
     fp_compute(si);       // <span class="docEmphasis">SmallInt::operator double() const</span>
     extended_compute(si); // <span class="docEmphItalicAlt">error: ambiguous</span>
</pre><br>
<p class="docText">Either conversion operator could be used in the call to <tt>compute</tt>:</P>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList"><tt>operator int</tt> generates an exact match to the parameter type.</p></div></LI><LI><div style="font-weight:normal"><p class="docList"><tt>operator double</tt> followed by the standard conversion from <tt>double</tt> to <tt>int</tt> matches the parameter type.</p></div></li></ol></div>
<p class="docText">An exact match is a better conversion than one that requires a standard conversion. Hence, the first conversion sequence is better. The conversion function <tt>SmallInt::operator int()</tt> is chosen to convert the argument.</p>
<p class="docText">Similarly, in the second call, <tt>fp_compute</tt> could be called using either conversion. However, the conversion to <tt>double</tt> is an exact match; it requires no additional standard conversion.</p>
<p class="docText">The final call to <tt>extended_compute</tt> is ambiguous. Either conversion function could be used, but each would have to be followed by a standard conversion to get to <tt>long double</tt>. Hence, neither conversion is better than the other, so the call is ambiguous.</p>
<a name="ch14note31"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><td valign="top"><p class="docText"> If two conversion operators could be used in a call, then the rank of the standard conversion (<a class="docLink" href="ch07lev1sec8.html#ch07lev2sec30">Section 7.8.4</a>, p. <a class="docLink" href="ch07lev1sec8.html#ch07lev2sec30">272</a>), if any, <span class="docEmphasis">following</span> the conversion function is used to select the best match.</p></td></TR></table><BR>
</p></div><br>

<a name="ch14lev3sec25"></a>
<h5 class="docSection3Title">Argument Matching and Conversions by Constructors</h5>
<p class="docText">Just as there might be two conversion operators, there can also be two constructors that might be applied to convert a value to the target type of a conversion.</P>
<p class="docText">Consider the <tt>manip</tt> function, which takes an argument of type <tt>SmallInt</tt>:</p>
<pre>
     void manip(const SmallInt &amp;);
     double d; int i; long l;
     manip(d);     // <span class="docEmphItalicAlt">ok: use</span> <span class="docEmphasis">SmallInt(double)</span> <span class="docEmphItalicAlt">to convert the argument</span>
     manip(i);     // <span class="docEmphItalicAlt">ok: use</span> <span class="docEmphasis">SmallInt(int)</span> <span class="docEmphItalicAlt">to convert the argument</span>
     manip(l);     // <span class="docEmphItalicAlt">error: ambiguous</span>
</pre><br>
<p class="docText">In the first call, we could use either of the <tt>SmallInt</tt> constructors to convert <tt>d</tt> to a value of type <tt>SmallInt</tt>. The <tt>int</tt> constructor requires a standard conversion on <tt>d</tt>, whereas the <tt>double</tt> constructor is an exact match. Because an exact match is better than a standard conversion, the constructor <tt>SmallInt(double)</tt> is used for the conversion.</P>
<p class="docText">In the second call, the reverse is true. The <tt>SmallInt(int)</tt> constructor provides an exact matchno additional conversion is needed. To call the <tt>SmallInt</tt> constructor that takes a <tt>double</tt> would require that <tt>i</tt> first be converted to <tt>double</tt>. For this call, the <tt>int</tt> constructor would be used to convert the argument.</p>
<p class="docText">The third call is ambiguous. Neither constructor is an exact match for <tt>long</tt>. Each would require that the argument be converted before using the constructor:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><LI><div style="font-weight:normal"><p class="docList">standard conversion (<tt>long</tt> to <tt>double</tt>) followed by <tt>SmallInt(double)</tt></p></div></LI><li><div style="font-weight:normal"><p class="docList">standard conversion (<tt>long</tt> to <tt>int</tt>) followed by <tt>SmallInt(int)</tt></p></div></li></ol></div>
<p class="docText">These conversion sequences are indistinguishable, so the call is ambiguous.</p>
<a name="ch14note32"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> When two constructor-defined conversions could be used, the rank of the standard conversion, if any, required on the constructor argument is used to select the best match.</p></td></tr></table><br>
</P></div><BR>

<a name="ch14lev3sec26"></a>
<h5 class="docSection3Title">Ambiguities When Two Classes Define Conversions</H5>
<p class="docText">When two classes define conversions to each other, ambiguities are likely:</p>
<pre>
     class Integral;
     class SmallInt {
     public:
         SmallInt(Integral); // <span class="docEmphItalicAlt">convert from</span> <span class="docEmphasis">Integral to SmallInt</span>
         // ...
      };
     class Integral {
     public:
         operator SmallInt() const; // <span class="docEmphItalicAlt">convert from</span> <span class="docEmphasis">SmallInt</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphItalicAlt">Integral</span>
         // ...
      };
     void compute(SmallInt);
     Integral int_val;
     compute(int_val);  // <span class="docEmphItalicAlt">error: ambiguous</span>
</pre><br>
<p class="docText">The argument <tt>int_val</tt> can be converted to a <tt>SmallInt</tt> in two different ways. The compiler could use the <tt>SmallInt</tt> constructor that takes an <tt>Integral</tt> object or it could use the <tt>Integral</tt> conversion operation that converts an <tt>Integral</tt> to a <tt>SmallInt</tt>. Because these two functions are equally good, the call is in error.</P>
<p class="docText">In this case, we cannot use a cast to resolve the ambiguitythe cast itself could use either the conversion operation or the constructor. Instead, we would need to explicitly call the conversion operator or the constructor:</P>
<pre>
     compute(int_val.operator SmallInt());   // <span class="docEmphItalicAlt">ok: use conversion operator</span>
     compute(SmallInt(int_val));             // <span class="docEmphItalicAlt">ok: use</span> <span class="docEmphasis">SmallInt</span> <span class="docEmphItalicAlt">constructor</span>
</pre><br>
<p class="docText"><a name="idd1e110877"></a><a name="idd1e110882"></a>Moreover, conversions that we might think would be ambiguous can be legal for what seem like trivial reasons. For example, our <tt>SmallInt</tt> class constructor copies its <tt>Integral</tt> argument. If we change the constructor so that it takes a reference to <tt>const Integral</tt></p>
<pre>
     class SmallInt {
     public:
     SmallInt(const Integral&amp;);
     };
</pre><br>
<p class="docText">our call to <tt>compute(int_val)</tt> is no longer ambiguous! The reason is that using the <tt>SmallInt</tt> constructor requires binding a reference to <tt>int_val</tt>, whereas using class <tt>Integral</tt>'s conversion operator avoids this extra step. This small difference is enough to tip the balance in favor of using the conversion operator.</p>
<a name="ch14note33"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></TD><TD valign="top"><p class="docText"> The best way to avoid ambiguities or surprises is to avoid writing pairs of classes where each offers an implicit conversion to the other.</p></td></tr></table><BR>
</P></div><br>
<a name="ch14sb15"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Caution: Avoid Overuse of Conversion Functions</h2>
<p class="docText"><span class="docEmphStrong">As with using overloaded operators, judicious use of conversion operators can greatly simplify the job of a class designer and make using a class easier. However, there are two potential pitfalls: Defining too many conversion operators can lead to ambiguous code, and some conversions can be confusing rather than helpful.</span></p>
<p class="docText"><span class="docEmphStrong">The best way to avoid ambiguities is to ensure that there is at most one way to convert one type to another. The best way to do that is to limit the number of conversion operators. In particular there should be only one conversion to a built-in type.</span></P>
<p class="docText"><span class="docEmphStrong">Conversion operators can be misleading when they are used where there is no obvious single mapping between the class type and the conversion type. In such cases, providing a conversion function may be confusing to the user of the class.</span></p>
<p class="docText"><span class="docEmphStrong">As an example, if we had a class that represented a <tt>Date</tt>, we might think it would be a good idea to provide a conversion from <tt>Date</tt> to <tt>int</tt>. However, what value should the conversion function return? The function might return the julian date, which is the sequence number of the current date starting from 0 as January 1. But should the year precede the day or follow it? That is, would January 31, 1986 be represented as 1986031 or 311986? Alternatively, the conversion operator might return an <tt>int</tt> representing the day count since some epoch point. The counter might count days since January 1, 1971 or some other starting point.</span></p>
<p class="docText"><span class="docEmphStrong">The problem is that whatever choice is made, the use of <tt>Date</tt> objects will be ambiguous because there is no single one-to-one mapping between an object of type <tt>Date</tt> and a value of type <tt>int</tt>. In such cases, it is better not to define the conversion operator. Instead, the class ought to define one or more ordinary members to extract the information in these various forms.</span></P>
</td></TR></table></p><br>


<a name="ch14lev2sec33"></a>
<h4 class="docSection2Title">14.9.4. Overload Resolution and Class Arguments</h4>
<p class="docText">As we have just seen, the compiler automatically applies a class conversion operator or constructor when needed to convert an argument to a function. Class <a name="idd1e110983"></a><a name="idd1e110989"></a><a name="idd1e110994"></a><a name="idd1e110999"></a><a name="idd1e111004"></a><a name="idd1e111011"></a>conversion operators, therefore, are considered during function resolution. Function overload resolution (<a class="docLink" href="ch07lev1sec8.html#ch07lev2sec28">Section 7.8.2</a>, p. <a class="docLink" href="ch07lev1sec8.html#ch07lev2sec28">269</a>) consists of three steps:</p>
<a name="ch14pro01"></a>



<table border="0" class="docText"><tr><td width="25" valign="top"><div class="docText"><b>1. </b></div></td><td><div class="docText">Determine the set of candidate functions: These are the functions with the same name as the function being called.<br><br>
</div></td></TR><TR><td width="25" valign="top"><div class="docText"><B>2. </b></div></td><td><div class="docText">Select the viable functions: These are the candidate functions for which the number and type of the function's parameters match the arguments in the call. When selecting the viable functions, the compiler also determines which conversion operations, if any, are needed to match each parameter.<BR><BR>
</div></td></tr><tr><td width="25" valign="top"><div class="docText"><b>3. </b></div></TD><td><div class="docText">The best match function is selected. To determine the best match, the type conversions needed to convert argument(s) to the type of the corresponding parameter(s) are ranked. For arguments and parameters of class type, the set of possible conversions includes class-type conversions.<BR><BR>
</div></td></tr></table>
<a name="ch14lev3sec27"></a>
<h5 class="docSection3Title">Standard Conversions Following Conversion Operator</H5>
<p class="docText">Which function is the best match can depend on whether one or more class-type conversions are involved in matching different functions.</P>
<a name="ch14note34"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> If two functions in the overload set can be matched <span class="docEmphasis">using the same conversion function</span>, then the rank of the standard conversion sequence that follows or precedes the conversion is used to determine which function has the best match.</p></td></TR></table><br>
<p class="docText">Otherwise, if <span class="docEmphasis">different conversion operations</span> could be used, then the conversions are considered equally good matches, regardless of the rank of any standard conversions that might or might not be required.</p>
</P></div><br>
<p class="docText">On page <a class="docLink" href="#ch14lev2sec32">541</a> we looked at the effect of class-type conversions on calls to functions that are not overloaded. Now, we'll look at similar calls but assume that the functions are overloaded:</P>
<pre>
     void compute(int);
     void compute(double);
     void compute(long double);
</pre><br>
<p class="docText">Assuming we use our original <tt>SmallInt</tt> class that only defines one conversion operatorthe conversion to <tt>int</tt>then if we pass a <tt>SmallInt</tt> to <tt>compute</tt>, the call is matched to the version of <tt>compute</tt> that takes an <tt>int</tt>.</p>
<p class="docText">All three <tt>compute</tt> functions are viable:</p>
<ul><li><p class="docList"><tt>compute(int)</tt> is viable because <tt>SmallInt</tt> has a conversion to <tt>int</tt>. That conversion is an exact match for the parameter.</p></li><li><p class="docList"><tt>compute(double)</tt> and <tt>compute(long double)</tt> are also viable, by using the conversion to <tt>int</tt> followed by the appropriate standard conversion to either <tt>double</tt> or <tt>long double</tt>.</p></li></ul>
<p class="docText">Because all three functions would be matched using the <span class="docEmphasis">same</span> class-type conversion, the rank of the standard conversion, if any, is used to determine the best <a name="idd1e111148"></a><a name="idd1e111155"></a>match. Because an exact match is better than a standard conversion, the function <tt>compute(int)</tt> is chosen as the best viable function.</p>
<a name="ch14note35"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> The standard conversion sequence following a class-type conversion is used as a selection criterion only if the two conversion sequences use the same conversion operation.</p></td></TR></table><BR>
</p></div><br>

<a name="ch14lev3sec28"></a>
<h5 class="docSection3Title">Multiple Conversions and Overload Resolution</h5>
<p class="docText">We can now see one reason why adding a conversion to <tt>double</tt> is a bad idea. If we use the revised <tt>SmallInt</tt> class that defines conversions to both <tt>int</tt> and <tt>double</tt>, then calling <tt>compute</tt> on a <tt>SmallInt</tt> value is ambiguous:</p>
<pre>
     class SmallInt {
     public:
         // <span class="docEmphItalicAlt">Conversions to</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">or</span> <span class="docEmphasis">double</span> <span class="docEmphItalicAlt">from</span> <span class="docEmphasis">SmallInt</span>
         // <span class="docEmphItalicAlt">Usually it is unwise to define conversions to multiple arithmetic types</span>
         operator int() const { return val; }
         operator double() const { return val; }
         // ...
     private:
         std::size_t val;
     };
     void compute(int);
     void compute(double);
     void compute(long double);
     SmallInt si;
     compute(si);    // <span class="docEmphItalicAlt">error: ambiguous</span>
</pre><BR>
<p class="docText">In this case we could use the <tt>operator int</tt> to convert <tt>si</tt> and call the version of <tt>compute</tt> that takes an <tt>int</tt>. Or we could use <tt>operator double</tt> to convert <tt>si</tt> and call <tt>compute(double)</tt>.</p>
<p class="docText">The compiler will not attempt to distinguish between two different class-type conversions. In particular, even if one of the calls required a standard conversion following the class-type conversion and the other were an exact match, the compiler would still flag the call as an error.</P>

<a name="ch14lev3sec29"></a>
<H5 class="docSection3Title">Explicit Constructor Call to Disambiguate</h5>
<p class="docText">A programmer who is faced with an ambiguous conversion can use a cast to indicate explicitly which conversion operation to apply:</p>
<pre>
     void compute(int);
     void compute(double);
     SmallInt si;
     compute(static_cast&lt;int&gt;(si)); // <span class="docEmphItalicAlt">ok: convert and call</span> <span class="docEmphasis">compute(int)</span>
</pre><br>
<p class="docText">This call is now legal because it explicitly says which conversion operation to apply to the argument. The type of the argument is forced to <tt>int</tt> by the cast. That type exactly matches the parameter of the first version of <tt>compute</tt> that takes an <tt>int</tt>.</P>

<a name="ch14lev3sec30"></a>
<H5 class="docSection3Title">Standard Conversions and Constructors</h5>
<p class="docText"><a name="idd1e111298"></a><a name="idd1e111305"></a><a name="idd1e111312"></a><a name="idd1e111317"></a><a name="idd1e111322"></a>Let's look at overload resolution when multiple conversion constructors exist:</p>
<pre>
     class SmallInt {
     public:
         SmallInt(int = 0);
     };
     class Integral {
     public:
         Integral(int = 0);
     };
     void manip(const Integral&amp;);
     void manip(const SmallInt&amp;);
     manip(10); // <span class="docEmphItalicAlt">error: ambiguous</span>
</pre><br>
<p class="docText">The problem is that both classes, <tt>Integral</tt> and <tt>SmallInt</tt>, provide constructors that take an <tt>int</tt>. Either constructor could be used to match a version of <tt>manip</tt>. Hence, the call is ambiguous: It could mean convert the <tt>int</tt> to <tt>Integral</tt> and call the first version of <tt>manip</tt>, or it could mean convert the <tt>int</tt> to a <tt>SmallInt</tt> and call the second version.</p>
<p class="docText">This call would be ambiguous even if one of the classes defined a constructor that required a standard conversion for the argument. For example, if <tt>SmallInt</tt> defined a constructor that took a <tt>short</tt> instead of an <tt>int</tt>, the call <tt>manip(10)</tt> would require a standard conversion from <tt>int</tt> to <tt>short</tt> before using that constructor. The fact that one call requires a standard conversion and the other does not is immaterial when selecting among overloaded versions of a call. The compiler will not prefer the direct constructor; the call would still be ambiguous.</P>

<a name="ch14lev3sec31"></a>
<h5 class="docSection3Title">Explicit Constructor Call to Disambiguate</h5>
<p class="docText">The caller can disambiguate by explicitly constructing a value of the desired type:</P>
<pre>
     manip(SmallInt(10));    // <span class="docEmphItalicAlt">ok: call manip(SmallInt)</span>
     manip(Integral(10));    // <span class="docEmphItalicAlt">ok: call manip(Integral)</span>
</pre><br>
<a name="ch14note36"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><td valign="top"><p class="docText"> Needing to use a constructor or a cast to convert an argument in a call to an overloaded function is a sign of bad design.</p></td></tr></table><br>
</p></div><br>


<a name="ch14lev2sec34"></a>
<h4 class="docSection2Title">14.9.5. Overloading, Conversions, and Operators</h4>
<p class="docText">Overloaded operators are overloaded functions. The same process that is used to resolve a call to an overloaded function is used to determine which operator built-in or class-typeto apply to a given expression. Given code such as</p>
<pre>
     ClassX sc;
     int iobj = sc + 3;
</pre><br>
<a name="ch14sb16"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<H2 class="docSidebarTitle">Exercises Section 14.9.4</h2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa14q1"></a><B>Exercise 14.44:</b></TD><td><p class="docText">Show the possible class-type conversion sequences for each of the following initializations. What is the outcome of each initialization?</p>
<pre>
     class LongDouble {
         operator double();
         operator float();
     };
     LongDouble ldObj;
     (a) int ex1 = ldObj;    (b) float ex2 = ldObj;
</pre><br>
</td></tr><TR valign="top"><td align="right" class="docText" width="50"><a name="ch14qa14q2"></a><B>Exercise 14.45:</b></TD><td><p class="docText">Which <tt>calc()</tt> function, if any, is selected as the best viable function for the following call? Show the conversion sequences needed to call each function and explain why the best viable function is selected.</p>
<pre>
     class LongDouble {
     public
         LongDouble(double);
         // ...
     };
     void calc(int);
     void calc(LongDouble);
     double dval;

     calc(dval); // <span class="docEmphItalicAlt">which function?</span>
</pre><br>
</TD></TR></table></p>
</blockquote>
</td></tr></table></p><BR>
<p class="docText">there are four possibilities:</p>
<a name="ch14pro02"></a><ul class="doclist" start=""><li>There is an overloaded addition operator that matches <tt>ClassX</tt> and <tt>int</tt>.<BR><br>
</li><LI>There are conversions to convert <tt>sc</tt> and/or to convert an <tt>int</tt> to types for which <tt>+</tt> is defined. If so, this expression will use the conversion(s) followed by applying the appropriate addition operator.<br><BR>
</li><li>The expression is ambiguous because both a conversion operator and an overloaded version of <tt>+</tt> are defined.<br><br>
</li><li>The expression is invalid because there is neither a conversion nor an over-loaded <tt>+</tt> to use.<br><br>
</li></ul>
<a name="ch14lev3sec32"></a>
<h5 class="docSection3Title">Overload Resolution and Operators</h5>
<a name="ch14note37"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> The fact that member and nonmember functions are possible changes how the set of candidate functions is selected.</p></td></TR></table><BR>
</p></div><br>
<p class="docText">Overload resolution (<a class="docLink" href="ch07lev1sec8.html#ch07lev2sec28">Section 7.8.2</a>, p. <a class="docLink" href="ch07lev1sec8.html#ch07lev2sec28">269</a>) for operators follows the usual three-step process:</p>
<a name="ch14pro03"></a>



<table border="0" class="docText"><tr><td width="25" valign="top"><div class="docText"><B>1. </b></div></td><TD><div class="docText">Select the candidate functions.<BR><br>
</div></td></tr><TR><TD width="25" valign="top"><div class="docText"><b>2. </b></div></td><td><div class="docText"><a name="idd1e111565"></a><a name="idd1e111570"></a>Select the viable functions including identifying potential conversions sequences for each argument.<br><BR>
</div></td></tr><TR><td width="25" valign="top"><div class="docText"><b>3. </b></div></TD><td><div class="docText">Select the best match function.<BR><br>
</div></td></tr></table>

<a name="ch14lev3sec33"></a>
<h5 class="docSection3Title">Candidate Functions for Operators</h5>
<p class="docText">As usual, the set of candidate functions consists of all functions that have the name of the function being used, and that are visible from the place of the call. In the case of an operator used in an expression, the candidate functions include the built-in versions of the operator along with all the ordinary nonmember versions of that operator. In addition, if the left-hand operand has class type, then the candidate set will contain the overloaded versions of the operator, if any, defined by that class.</p>
<a name="ch14note38"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> Ordinarily, the candidate set for a call includes only member functions or nonmember functions but not both. When resolving the use of an operator, it is possible for both nonmember and member versions of the operator to be candidates.</p></td></TR></table><BR>
</p></div><BR>
<p class="docText">When resolving a call to a named function (as opposed to the use of an operator), the call itself determines the scope of names that will be considered. If the call is through an object of a class type (or through a reference or pointer to such an object), then only the member functions of that class are considered. Member and nonmember functions with the same name do <span class="docEmphasis">not</span> overload one another. When we use an overloaded operator, the call does not tell us anything about the scope of the operator function that is being used. Therefore, both member and nonmember versions must be considered.</p>
<a name="ch14sb17"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<h2 class="docSidebarTitle">Caution: Conversions and Operators</h2>
<p class="docText"><span class="docEmphStrong">Correctly designing the overloaded operators, conversion constructors, and conversion functions for a class requires some care. In particular, ambiguities are easy to generate if a class defines both conversion operators and overloaded operators. A few rules of thumb can be helpful:</span></p>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList"><span class="docEmphStrong">Never define mutually converting classesthat is, if class <tt>Foo</tt> has a constructor that takes an object of class <tt>Bar</tt>, do not give class <tt>Bar</tt> a conversion operator to type <tt>Foo</tt></span>.</p></div></LI><li><div style="font-weight:normal"><p class="docList"><span class="docEmphStrong">Avoid conversions to the built-in arithmetic types. In particular, if you do define a conversion to an arithmetic type, then</span></P><UL><li><p class="docList"><span class="docEmphStrong">Do not define overloaded versions of the operators that take arithmetic types. If users need to use these operators, the conversion operation will convert objects of your type, and then the built-in operators can be used.</span></p></li><LI><p class="docList"><span class="docEmphStrong">Do not define a conversion to more than one arithmetic type. Let the standard conversions provide conversions to the other arithmetic types.</span></P></li></ul></div></li></ol></div>
<p class="docText"><span class="docEmphStrong">The easiest rule of all: Avoid defining conversion functions and limit nonexplicit constructors to those that are &quot;obviously right.&quot;</span></p>
</TD></tr></table></p><BR>

<a name="ch14lev3sec34"></a>
<h5 class="docSection3Title">Conversions Can Cause Ambiguity with Built-In Operators</h5>
<p class="docText"><a name="idd1e111671"></a><a name="idd1e111676"></a><a name="idd1e111681"></a>Let's extend our <tt>SmallInt</tt> class once more. This time, in addition to a conversion operator to <tt>int</tt> and a constructor from <tt>int</tt>, we'll give our class an overloaded addition operator:</P>
<pre>
     class SmallInt {
     public:
         SmallInt(int = 0); // <span class="docEmphItalicAlt">convert from</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">SmallInt</span>
         // <span class="docEmphItalicAlt">conversion to</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">from</span> <span class="docEmphasis">SmallInt</span>
         operator int() const { return val; }
         // <span class="docEmphItalicAlt">arithmetic operators</span>
         friend SmallInt
         operator+(const SmallInt&amp;, const SmallInt&amp;);
     private:
          std::size_t val;
     };
</pre><br>
<p class="docText">Now we could use this class to add two <tt>SmallInts</tt>, but we will run into ambiguity problems if we attempt to perform mixed-mode arithmetic:</P>
<pre>
     SmallInt s1, s2;
     SmallInt s3 = s1 + s2;         // <span class="docEmphItalicAlt">ok: uses overloaded</span> <span class="docEmphasis">operator+</span>
     int i = s3 + 0;                // <span class="docEmphItalicAlt">error: ambiguous</span>
</pre><br>
<p class="docText">The first addition uses the overloaded version of <tt>+</tt> that takes two <tt>SmallInt</tt> values. The second addition is ambiguous. The problem is that we could convert <tt>0</tt> to a <tt>SmallInt</tt> and use the <tt>SmallInt</tt> version of <tt>+</tt>, or we could convert <tt>s3</tt> to <tt>int</tt> and use the built-in addition operator on <tt>int</tt>s.</p>
<a name="ch14note39"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> Providing both conversion functions to an arithmetic type and over-loaded operators for the same class type may lead to ambiguities between the overloaded operators and the built-in operators.</p></td></tr></table><br>
</p></div><br>

<a name="ch14lev3sec35"></a>
<H5 class="docSection3Title">Viable Operator Functions and Conversions</H5>
<p class="docText">We can understand the behavior of these two calls by listing the viable functions for each call. In the first call, there are two viable addition operators:</p>
<UL><li><p class="docList"><tt>operator+(const SmallInt&amp;, const SmallInt&amp;)</tt></p></LI><LI><p class="docList">The built-in <tt>operator+(int, int)</tt></p></li></ul>
<p class="docText">The first addition requires no conversions on either argument <tt>s1</tt> and <tt>s2</tt> match exactly the types of the parameters. Using the built-in addition operator for this addition would require conversions on both arguments. Hence, the overloaded operator is a better match for both arguments and is the one that is called. For the second addition</p>
<pre>
     int i = s3 + 0;          // <span class="docEmphItalicAlt">error: ambiguous</span>
</pre><br>
<p class="docText">the same two functions are viable. In this case, the overloaded version of <tt>+</tt> matches the first argument exactly, but the built-in version is an exact match for the second argument. The first viable function is better for the left operand, whereas the second viable function is better for the right operand. The call is flagged as ambiguous because no best viable function can be found.</P>
<a name="ch14sb18"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<h2 class="docSidebarTitle">Exercises Section 14.9.5</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch14qa15q1"></a><b>Exercise 14.46:</b></td><td><p class="docText">Which <tt>operator+</tt>, if any, is selected as the best viable function for the addition operation in <tt>main</tt>? List the candidate functions, the viable functions, and the type conversions on the arguments for each viable function.</p>
<pre>
     class Complex {
         Complex(double);
         // ...
     };
     class LongDouble {
         friend LongDouble operator+(LongDouble&amp;, int);
     public:
         LongDouble(int);
         operator double();
         LongDouble operator+(const complex &amp;);
         // ...
      };
     LongDouble operator+(const LongDouble &amp;, double);
     LongDouble ld(16.08);
     double res = ld + 15.05; // <span class="docEmphItalicAlt">which operator+ ?</span>
</pre><BR>
</td></tr></table></P>
</blockquote>
</td></tr></table></P><br>



<a href="21001535.html"><img src="images/pixel.gif" alt="" width="1" height="1" border="0"></a><UL></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch14lev1sec8.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch14lev1sec10.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>