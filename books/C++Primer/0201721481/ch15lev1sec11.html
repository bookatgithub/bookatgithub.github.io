<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Keyterm&nbsp;Defined Terms</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch15lev1sec10.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch16.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch15lev1sec11"></a>
<h3 class="docSection1Title">Defined Terms</h3>
<p class="docText"></P>

<a name="gloss15_01"></a><dl class="docList"><dt><B><a class="docLink" href="ch15lev1sec6.html#ch15term1">abstract base class</a></b></dt><dd><p class="docText">Class that has or inherits one or more pure virtual functions. It is not possible to create objects of an abstract base-class type. Abstract base classes exist to define an interface. Derived classes will complete the type by defining type-specific implementations for the pure virtuals defined in the base.</p></dd><BR><br></dl>
<a name="gloss15_02"></a><dl class="docList"><dt><b><a class="docLink" href="ch15lev1sec1.html#ch15term2">base class</a></b></dt><dd><p class="docText">Class from which another class inherits. The members of the base class become members of the derived class.</P></dd><BR><br></dl>
<a name="gloss15_03"></a><dl class="docList"><dt><b><a class="docLink" href="ch15lev1sec2.html#ch15term3">class derivation list</a></b></dt><dd><p class="docText">Used by a class definition to indicate that the class is a derived class. A derivation list includes an optional access level and names the base class. If no access label is specified, the type of inheritance depends on the keyword used to define the derived class. By default, if the derived class is defined with the <tt>struct</tt> keyword, then the base class is inherited <tt>public</tt>ly. If the class is defined using the <tt>class</tt> keyword, then the base class is inherited <tt>private</tt>ly.</p></dd><br><br></dl>
<a name="gloss15_04"></a><dl class="docList"><dt><B><a class="docLink" href="ch15lev1sec1.html#ch15term4">derived class</a></b></dt><dd><p class="docText">A class that inherits from another class. The members of the base class are also members of the derived class. A derived class can redefine the members of its base and can define new members. A derived-class scope is nested in the scope of its base class(es), so the derived class can access members of the base class directly. Members defined in the derived with the same name as members in the base hide those base members; in particular, member functions in the derived do not overload members from the base. A hidden member in the base can be accessed using the scope operator.</p></dd><BR><BR></dl>
<a name="gloss15_05"></a><dl class="docList"><dt><b><a class="docLink" href="ch15lev1sec4.html#ch15term5">direct base class</a></b></dt><dd><p class="docText">Synonym for immediate base class.</p></dd><br><BR></dl>
<a name="gloss15_06"></a><dl class="docList"><dt><B><a class="docLink" href="ch15lev1sec1.html#ch15term6">dynamic binding</a></b></dt><dd><p class="docText">Delaying until run time the selection of which function to run. In C++, dynamic binding refers to the run-time choice of which <tt>virtual</tt> function to run based on the underlying type of the object to which a reference or pointer is bound.</p></dd><br><br></dl>
<a name="gloss15_07"></a><dl class="docList"><dt><b><a class="docLink" href="ch15lev1sec2.html#ch15term7">dynamic type</a></b></dt><dd><p class="docText"><a name="idd1e123169"></a><a name="idd1e123175"></a><a name="idd1e123180"></a><a name="idd1e123185"></a><a name="idd1e123190"></a><a name="idd1e123193"></a><a name="idd1e123198"></a><a name="idd1e123203"></a><a name="idd1e123206"></a><a name="idd1e123209"></a><a name="idd1e123212"></a><a name="idd1e123215"></a><a name="idd1e123220"></a><a name="idd1e123223"></a><a name="idd1e123226"></a><a name="idd1e123229"></a><a name="idd1e123232"></a><a name="idd1e123237"></a><a name="idd1e123240"></a><a name="idd1e123245"></a><a name="idd1e123250"></a><a name="idd1e123253"></a><a name="idd1e123256"></a><a name="idd1e123259"></a><a name="idd1e123262"></a><a name="idd1e123267"></a><a name="idd1e123272"></a><a name="idd1e123275"></a>Type at run time. Pointers and references to base-class types can be bound to objects of derived type. In such cases the static type is reference (or pointer) to base, but the dynamic type is reference (or pointer) to derived.</P></dd><br><br></dl>
<a name="gloss15_08"></a><dl class="docList"><dt><B><a class="docLink" href="ch15lev1sec8.html#ch15term8">handle class</a></b></dt><dd><p class="docText">Class that provides an interface to another class. Commonly used to allocate and manage a pointer to an object of an inheritance hierarchy.</p></dd><br><BR></dl>
<a name="gloss15_09"></a><dl class="docList"><dt><b><a class="docLink" href="ch15lev1sec2.html#ch15term9">immediate base class</a></b></dt><dd><p class="docText">A base class from which a derived class inherits directly. The immediate base is the class named in the derivation list. The immediate base may itself be a derived class.</P></dd><br><br></dl>
<a name="gloss15_10"></a><dl class="docList"><dt><b><a class="docLink" href="ch15lev1sec2.html#ch15term10">indirect base class</a></b></dt><dd><p class="docText">A base class that is not immediate. A class from which the immediate base class inherits, directly or indirectly, is an indirect base class to the derived class.</p></dd><br><br></dl>
<a name="gloss15_11"></a><dl class="docList"><dt><b><a class="docLink" href="ch15lev1sec1.html#ch15term11">inheritance hierarchy</a></b></dt><dd><p class="docText">Term used to describe the relationships among classes related by inheritance that share a common base class.</p></dd><br><br></dl>
<a name="gloss15_12"></a><dl class="docList"><dt><b><a class="docLink" href="part04.html#ch15term12">object-oriented programming</a></b></dt><dd><p class="docText">Term used to describe programs that use data abstraction, inheritance, and dynamic binding.</p></dd><br><BR></dl>
<a name="gloss15_13"></a><dl class="docList"><dt><B><a class="docLink" href="ch15lev1sec1.html#ch15term13">polymorphism</a></b></dt><dd><p class="docText">A term derived from a Greek word that means &quot;many forms.&quot; In object-oriented programming, polymorphism refers to the ability to obtain type-specific behavior based on the dynamic type of a reference or pointer.</p></dd><BR><br></dl>
<a name="gloss15_14"></a><dl class="docList"><dt><b><a class="docLink" href="ch15lev1sec2.html#ch15term14">private inheritance</a></b></dt><dd><p class="docText">A form of implementation inheritance in which the <tt>public</tt> and <tt>protected</tt> members of a <tt>private</tt> base class are <tt>private</tt> in the derived.</P></dd><BR><br></dl>
<a name="gloss15_15"></a><dl class="docList"><dt><b><a class="docLink" href="ch15lev1sec2.html#ch15term15">protected access label</a></b></dt><dd><p class="docText">Members defined after a <tt>protected</tt> label may be accessed by class members and friends and by the members (but not friends) of a derived class. <tt>protected</tt> members are not accessible to ordinary users of the class.</p></dd><br><br></dl>
<a name="gloss15_16"></a><dl class="docList"><dt><B><a class="docLink" href="ch15lev1sec2.html#ch15term16">protected inheritance</a></b></dt><dd><p class="docText">In <tt>protected</tt> inheritance the <tt>protected</tt> and <tt>public</tt> members of the base class are <tt>protected</tt> in the derived class.</p></dd><BR><BR></dl>
<a name="gloss15_17"></a><dl class="docList"><dt><b><a class="docLink" href="ch15lev1sec2.html#ch15term17">public inheritance</a></b></dt><dd><p class="docText">The <tt>public</tt> interface of the base class is part of the <tt>public</tt> interface of the derived class.</p></dd><br><BR></dl>
<a name="gloss15_18"></a><dl class="docList"><dt><B><a class="docLink" href="ch15lev1sec6.html#ch15term18">pure virtual</a></b></dt><dd><p class="docText">A virtual function declared in the class header using <tt>=0</tt> at the end of the function's parameter list. A pure virtual is one that need not be (but may be) defined by the class. A class with a pure virtual is an abstract class. If a derived class does not define its own version of an inherited pure virtual, then the derived class is abstract as well.</p></dd><br><br></dl>
<a name="gloss15_19"></a><dl class="docList"><dt><b><a class="docLink" href="ch15lev1sec4.html#ch15term19">refactoring</a></b></dt><dd><p class="docText">Redesigning programs to collect related parts into a single abstraction, replacing the original code by uses of the new abstraction. In OO programs, refactoring frequently happens when redesigning the classes in an inheritance hierarchy. Refactoring often occurs in response to a change in requirements. In general, classes are refactored to move data or function members to the highest common point in the hierarchy to avoid code duplication.</P></dd><br><br></dl>
<a name="gloss15_20"></a><dl class="docList"><dt><B><a class="docLink" href="ch15lev1sec7.html#ch15term20">sliced</a></b></dt><dd><p class="docText">Term used to describe what happens when an object of derived type is used to initialize or assign an object of the base type. The derived portion of the object is &quot;sliced down,&quot; leaving only the base portion, which is assigned to the base.</p></dd><br><BR></dl>
<a name="gloss15_21"></a><dl class="docList"><dt><b><a class="docLink" href="ch15lev1sec2.html#ch15term21">static type</a></b></dt><dd><p class="docText">Compile-time type. Static type of an object is the same as its dynamic type. The dynamic type of an object to which a reference or pointer refers may differ from the static type of the reference or pointer.</P></dd><br><br></dl>
<a name="gloss15_22"></a><dl class="docList"><dt><b><a class="docLink" href="ch15lev1sec1.html#ch15term22">virtual function</a></b></dt><dd><p class="docText">A member function that defines type-specific behavior. Calls to a virtual made through a reference or pointer are resolved at run time, based on the type of the object to which the reference or pointer is bound.</p></dd><br><br></dl>


<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch15lev1sec10.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch16.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>