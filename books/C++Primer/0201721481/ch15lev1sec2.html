<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 15.2.&nbsp; Defining Base and Derived Classes</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch15lev1sec1.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch15lev1sec3.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch15lev1sec2"></a>
<h3 class="docSection1Title">15.2. Defining Base and Derived Classes</h3>
<p class="docText">In many ways, base and derived classes are defined like other classes we have already seen. However, there are some additional features that are required when defining classes in an inheritance hierarchy. This section will present those features. Subsequent sections will see how use of these features impacts classes and the programs we write using inherited classes.</P>
<a name="ch15lev2sec3"></a>
<H4 class="docSection2Title">15.2.1. Defining a Base Class</h4>
<p class="docText">Like any other class, a base class has data and function members that define its interface and implementation. In the case of our (very simplified) bookstore pricing application, our <tt>Item_base</tt> class defines the <tt>book</tt> and <tt>net_price</tt> functions and needs to store an ISBN and the standard price for the book:</P>
<pre>
     // <span class="docEmphItalicAlt">Item sold at an undiscounted price</span>
     // <span class="docEmphItalicAlt">derived classes will define various discount strategies</span>
     class Item_base {
     public:
         Item_base(const std::string &amp;book = "",
                   double sales_price = 0.0):
                          isbn(book), price(sales_price) { }
         std::string book() const { return isbn; }
         // <span class="docEmphItalicAlt">returns total sales price for a specified number of items</span>
         // <span class="docEmphItalicAlt">derived classes will override and apply different discount algorithms</span>
         virtual double net_price(std::size_t n) const
                    { return n * price; }
         virtual ~Item_base() { }
     private:
         std::string isbn;     // <span class="docEmphItalicAlt">identifier for the item</span>
     protected:
         double price;         // <span class="docEmphItalicAlt">normal, undiscounted price</span>
     };
</pre><br>
<p class="docText"><a name="idd1e112834"></a><a name="idd1e112839"></a><a name="idd1e112848"></a><a name="idd1e112857"></a><a name="idd1e112862"></a><a name="idd1e112867"></a><a name="idd1e112874"></a><a name="idd1e112881"></a>For the most part, this class looks like others we have seen. It defines a constructor along with the functions we have already described. That constructor uses default arguments (<a class="docLink" href="ch07lev1sec4.html#ch07lev2sec17">Section 7.4.1</a>, p. <a class="docLink" href="ch07lev1sec4.html#ch07lev2sec17">253</a>), which allows it to be called with zero, one, or two arguments. It initializes the data members from these arguments.</p>
<p class="docText">The new parts are the <tt>protected</tt> access label and the use of the <tt>virtual</tt> keyword on the destructor and the <tt>net_price</tt> function. We'll explain virtual destructors in <a class="docLink" href="ch15lev1sec4.html#ch15lev2sec15">Section 15.4.4</a> (p. <a class="docLink" href="ch15lev1sec4.html#ch15lev2sec15">587</a>), but for now it is worth noting that classes used as the root class of an inheritance hierarchy generally define a virtual destructor.</P>
<a name="ch15lev3sec1"></a>
<H5 class="docSection3Title">Base-Class Member Functions</h5>
<p class="docText">The <tt>Item_base</tt> class defines two functions, one of which is preceded by the keyword <tt>virtual</tt>. The purpose of the <tt>virtual</tt> keyword is to enable dynamic binding. By default, member functions are nonvirtual. Calls to nonvirtual functions are resolved at compile time. To specify that a function is virtual, we precede its return type by the keyword <tt>virtual</tt>. Any non<tt>static</tt> member function, other than a constructor, may be virtual. The <tt>virtual</tt> keyword appears only on the member-function declaration inside the class. The <tt>virtual</tt> keyword may not be used on a function definition that appears outside the class body.</p>
<p class="docText">We'll have more to say about virtual functions in <a class="docLink" href="#ch15lev2sec6">Section 15.2.4</a> (p. <a class="docLink" href="#ch15lev2sec6">566</a>).</p>
<a name="ch15note02"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><TD valign="top"><p class="docText"> A base class usually should define as virtual any function that a derived class will need to redefine.</P></td></tr></table><br>
</P></div><BR>

<a name="ch15lev3sec2"></a>
<h5 class="docSection3Title">Access Control and Inheritance</h5>
<p class="docText">In a base class, the <tt>public</tt> and <tt>private</tt> labels have their ordinary meanings: User code may access the <tt>public</tt> members and may not access the <tt>private</tt> members of the class. The <tt>private</tt> members are accessible only to the members and friends of the base class. A derived class has the same access as any other part of the program to the <tt>public</tt> and <tt>private</tt> members of its base class: It may access the <tt>public</tt> members and has no access to the <tt>private</tt> members.</p>
<p class="docText">Sometimes a class used as a base class has members that it wants to allow its derived classes to access, while still prohibiting access to those same members by other users. The <b><a name="ch15term15"></a><a class="docLink" href="ch15lev1sec11.html#gloss15_15"><span class="docEmphStrong"><tt>protected</tt></span> access label</a></b> is used for such members. A <tt>protected</tt> member may be accessed by a derived object but may not be accessed by general users of the type.</P>
<p class="docText">Our <tt>Item_base</tt> class expects its derived classes to redefine the <tt>net_price</tt> function. To do so, those classes will need access to the <tt>price</tt> member. Derived classes are expected to access <tt>isbn</tt> in the same way as ordinary users: through the <tt>book</tt> access function. Hence, the <tt>isbn</tt> member is <tt>private</tt> and is inaccessible to classes that inherit from <tt>Item_base</tt>.</p>
<a name="ch15sb01"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<h2 class="docSidebarTitle">Exercises Section 15.2.1</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><td align="right" class="docText" width="50"><a name="ch15qa1q1"></a><b>Exercise 15.1:</b></td><td><p class="docText"><a name="idd1e113052"></a><a name="idd1e113058"></a><a name="idd1e113065"></a><a name="idd1e113071"></a><a name="idd1e113076"></a>What is a virtual member?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa1q2"></a><b>Exercise 15.2:</b></td><td><p class="docText">Define the <tt>protected</tt> access label. How does it differ from <tt>private?</tt></p></TD></TR><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch15qa1q3"></a><b>Exercise 15.3:</b></td><TD><p class="docText">Define your own version of the <tt>Item_base</tt> class.</P></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa1q4"></a><b>Exercise 15.4:</b></TD><td><p class="docText">A library has different kinds of materials that it lends outbooks, CDs, DVDs, and so forth. Each of the different kinds of lending material has different check-in, check-out, and overdue rules. The following class defines a base class that we might use for this application. Identify which functions are likely to be defined as virtual and which, if any, are likely to be common among all lending materials. (Note: we assume that <tt>LibMember</tt> is a class representing a customer of the library, and <tt>Date</tt> is a class representing a calendar day of a particular year.)</P>
<pre>
     class Library {
     public:
         bool check_out(const LibMember&amp;);
         bool check_in (const LibMember&amp;);
         bool is_late(const Date&amp; today);
         double apply_fine();
         ostream&amp; print(ostream&amp; = cout);
         Date due_date() const;
         Date date_borrowed() const;
         string title() const;
         const LibMember&amp; member() const;
     };
</pre><BR>
</td></tr></table></p>
</blockquote>
</TD></TR></table></p><br>


<a name="ch15lev2sec4"></a>
<h4 class="docSection2Title">15.2.2. <tt>protected</tt> Members</h4>
<p class="docText">The <tt>protected</tt> access label can be thought of as a blend of <tt>private</tt> and <tt>public</tt>:</P>
<ul><li><p class="docList">Like <tt>private</tt> members, <tt>protected</tt> members are inaccessible to users of the class.</P></li><li><p class="docList">Like <tt>public</tt> members, the <tt>protected</tt> members are accessible to classes derived from this class.</P></li></UL>
<p class="docText">In addition, <tt>protected</tt> has another important property:</p>
<ul><li><p class="docList">A derived object may access the <tt>protected</tt> members of its base class <span class="docEmphasis">only</span> through a derived object. The derived class has no special access to the <tt>protected</tt> members of base type objects.</p></li></ul>
<p class="docText">As an example, let's assume that <tt>Bulk_item</tt> defines a member function that takes a reference to a <tt>Bulk_item</tt> object and a reference to an <tt>Item_base</tt> object. This function may access the <tt>protected</tt> members of its own object as well as those of its <tt>Bulk_item</tt> parameter. However, it has no special access to the <tt>protected</tt> members in its <tt>Item_base</tt> parameter:</p>
<pre>
     void Bulk_item::memfcn(const Bulk_item &amp;d, const Item_base &amp;b)
     {
         // <span class="docEmphItalicAlt">attempt to use</span> <span class="docEmphasis">protected</span> <span class="docEmphItalicAlt">member</span>
         double ret = price;   // <span class="docEmphItalicAlt">ok: uses</span> <span class="docEmphasis">this-&gt;price</span>
         ret = d.price; // <span class="docEmphItalicAlt">ok: uses</span> <span class="docEmphasis">price</span> <span class="docEmphItalicAlt">from a</span> <span class="docEmphasis">Bulk_item</span> <span class="docEmphItalicAlt">object</span>
         ret = b.price; // <span class="docEmphItalicAlt">error: no access to</span> <span class="docEmphasis">price</span> <span class="docEmphItalicAlt">from an</span> <span class="docEmphasis">Item_base</span>
     }
</pre><br>
<p class="docText"><a name="idd1e113277"></a><a name="idd1e113282"></a><a name="idd1e113287"></a><a name="idd1e113290"></a><a name="idd1e113295"></a><a name="idd1e113298"></a><a name="idd1e113303"></a><a name="idd1e113308"></a>The use of <tt>d.price</tt> is okay, because the reference to <tt>price</tt> is through an object of type <tt>Bulk_item</tt>. The use of <tt>b.price</tt> is illegal because <tt>Bulk_item</tt> has no special access to objects of type <tt>Item_base</tt>.</p>
<a name="ch15sb02"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Key Concept: Class Design and Protected Members</H2>
<p class="docText"><span class="docEmphStrong">In the absence of inheritance, a class has two kinds of users: members of the class itself and the users of that class. This separation between kinds of users is reflected in the division of the class into <tt>private</tt> and <tt>public</tt> access levels. Users may access only the <tt>public</tt> interface; class members and friends may access both the <tt>public</tt> and <tt>private</tt> members.</span></P>
<p class="docText"><span class="docEmphStrong">Under inheritance, there is now a third kind of user of a class: programmers who will define new classes that are derived from the class. The provider of a derived class often (but not always) needs access to the (ordinarily <tt>private</tt></span><span class="docEmphStrong">) base-class implementation. To allow that access while still preventing general access to the implementation, an additional access label, <tt>protected</tt></span><span class="docEmphStrong">, is provided. The data and function members in a <tt>protected</tt> section of a class remain inaccessible to the general program, yet are accessible to the derived class. Anything placed within a <tt>private</tt> section of the base class is accessible only to the class itself and its friends. The <tt>private</tt> members are not accessible to the derived classes.</span></p>
<p class="docText"><span class="docEmphStrong">When designing a class to serve as a base class, the criteria for designating a member as <tt>public</tt> do not change: It is still the case that interface functions should be <tt>public</tt> and data generally should not be <tt>public</tt></span><span class="docEmphStrong">. A class designed to be inherited from must decide which parts of the implementation to declare as <tt>protected</tt> and which should be <tt>private</tt></span><span class="docEmphStrong">. A member should be made <tt>private</tt> if we wish to prevent subsequently derived classes from having access to that member. A member should be made <tt>protected</tt> if it provides an operation or data that a derived class will need to use in its implementation. In other words, the interface to the derived type is the combination of both the <tt>protected</tt> and <tt>public</tt> members.</span></P>
</td></tr></table></P><BR>

<a name="ch15lev2sec5"></a>
<h4 class="docSection2Title">15.2.3. Derived Classes</h4>
<p class="docText">To define a derived class, we use a <b><a name="ch15term3"></a><a class="docLink" href="ch15lev1sec11.html#gloss15_03">class derivation list</a></b> to specify the base class(es). A class derivation list names one or more base classes and has the form</p>
<pre>
     class <span class="docEmphasis">classname: access-label base-class</span>
</pre><br>
<p class="docText">where <span class="docEmphasis">access-label</span> is one of <tt>public, protected</tt>, or <tt>private</tt>, and <span class="docEmphasis">base-class</span> is the name of a previously defined class. As we'll see, a derivation list might name more than one base class. Inheritance from a single base class is most common and is the topic of this chapter. <a class="docLink" href="ch17lev1sec3.html#ch17lev1sec3">Section 17.3</a> (p. <a class="docLink" href="ch17lev1sec3.html#ch17lev1sec3">731</a>) covers use of multiple base classes.</P>
<p class="docText"><a name="idd1e113454"></a><a name="idd1e113460"></a><a name="idd1e113465"></a><a name="idd1e113470"></a><a name="idd1e113475"></a><a name="idd1e113480"></a>We'll have more to say about the access label used in a derivation list in <a class="docLink" href="#ch15lev2sec7">Section 15.2.5</a> (p. <a class="docLink" href="#ch15lev2sec7">570</a>). For now, what's useful to know is that the access label determines the access to the inherited members. When we want to inherit the interface of a base class, then the derivation should be <tt>public</tt>.</p>
<p class="docText">A derived class inherits the members of its base class and may define additional members of its own. Each derived object contains two parts: those members that it inherits from its base and those it defines itself. Typically, a derived class (re)defines only those aspects that differ from or extend the behavior of the base.</P>
<a name="ch15lev3sec3"></a>
<H5 class="docSection3Title">Defining a Derived Class</h5>
<p class="docText">In our bookstore application, we will derive <tt>Bulk_item</tt> from <tt>Item_base</tt>, so <tt>Bulk_item</tt> will inherit the <tt>book, isbn</tt>, and <tt>price</tt> members. <tt>Bulk_item</tt> must redefine its <tt>net_price</tt> function and define the data members needed for that operation:</p>
<pre>
     // <span class="docEmphItalicAlt">discount kicks in when a specified number of copies of same book are sold</span>
     // <span class="docEmphItalicAlt">the discount is expressed as a fraction used to reduce the normal price</span>
     class Bulk_item : public Item_base {
     public:
         // <span class="docEmphItalicAlt">redefines base version so as to implement bulk purchase discount policy</span>
         double net_price(std::size_t) const;
     private:
         std::size_t min_qty; // <span class="docEmphItalicAlt">minimum purchase for discount to apply</span>
         double discount;     // <span class="docEmphItalicAlt">fractional discount to apply</span>
      };
</pre><br>
<p class="docText">Each <tt>Bulk_item</tt> object contains four data elements: It inherits <tt>isbn</tt> and <tt>price</tt> from <tt>Item_base</tt> and defines <tt>min_qty</tt> and <tt>discount</tt>. These latter two members specify the minimum quantity and the discount to apply once that number of copies are purchased. The <tt>Bulk_item</tt> class also needs to define a constructor, which we shall do in <a class="docLink" href="ch15lev1sec4.html#ch15lev1sec4">Section 15.4</a> (p. <a class="docLink" href="ch15lev1sec4.html#ch15lev1sec4">580</a>).</P>

<a name="ch15lev3sec4"></a>
<H5 class="docSection3Title">Derived Classes and <tt>virtual</tt> Functions</h5>
<p class="docText">Ordinarily, derived classes redefine the virtual functions that they inherit, although they are not requried to do so. If a derived class does not redefine a virtual, then the version it uses is the one defined in its base class.</p>
<p class="docText">A derived type must include a declaration for each inherited member it intends to redefine. Our <tt>Bulk_item</tt> class says that it will redefine the <tt>net_price</tt> function but will use the inherited version of <tt>book</tt>.</p>
<p class="docText">With one exception, the declaration (<a class="docLink" href="ch07lev1sec4.html#ch07lev1sec4">Section 7.4</a>, p. <a class="docLink" href="ch07lev1sec4.html#ch07lev1sec4">251</a>)of a virtual function in the derived class must exactly match the way the function is defined in the base. That exception applies to virtuals that return a reference (or pointer) to a type that is itself a base class. A virtual function in a derived class can return a reference (or pointer) to a class that is <tt>public</tt>ly derived from the type returned by the base-class function.</p>
<p class="docText">For example, the <tt>Item_base</tt> class might define a virtual function that returned an <tt>Item_base*</tt>. If it did, then the instance defined in the <tt>Bulk_item</tt> class could <a name="idd1e113629"></a>be defined to return either an <tt>Item_base*</tt> or a <tt>Bulk_item*</tt>. We'll see an example of this kind of virtual in <a class="docLink" href="ch15lev1sec9.html#ch15lev1sec9">Section 15.9</a> (p. <a class="docLink" href="ch15lev1sec9.html#ch15lev1sec9">607</a>).</P>
<a name="ch15note03"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> Once a function is declared as virtual in a base class it remains virtual; nothing the derived classes do can change the fact that the function is virtual. When a derived class redefines a virtual, it may use the <tt>virtual</tt> keyword, but it is not required to do so.</P></td></TR></table><br>
</p></div><br>

<a name="ch15lev3sec5"></a>
<h5 class="docSection3Title">Derived Objects Contain Their Base Classes as Subobjects</h5>
<p class="docText">A derived object consists of multiple parts: the (non<tt>static)</tt> members defined in the derived class itself plus the subobjects made up of the (non<tt>static)</tt> members of its base class. We can think of our <tt>Bulk_item</tt> class as consisting of two parts as represented in <a class="docLink" href="#ch15fig01">Figure 15.1</a>.</p>
<a name="ch15fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 15.1. Conceptual Structure of a <tt>Bulk_item</tt> Object</h5>

<p class="docText">
<img border="0" alt="" width="223" height="157" SRC="images/0201721481/graphics/15fig01.gif;400478"></p>

</center></p><br>
<a name="ch15note04"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> There is no requirement that the compiler lay out the base and derived parts of an object contiguously. Hence, <a class="docLink" href="#ch15fig01">Figure 15.1</a> is a conceptual, not physical, representation of how classes work.</p></td></TR></table><BR>
</p></div><br>

<a name="ch15lev3sec6"></a>
<h5 class="docSection3Title">Functions in the Derived May Use Members from the Base</h5>
<p class="docText">As with any member function, a derived class function can be defined inside the class or outside, as we do here for the <tt>net_price</tt> function:</p>
<pre>
     // <span class="docEmphItalicAlt">if specified number of items are purchased, use discounted price</span>
     double Bulk_item::net_price(size_t cnt) const
     {
         if (cnt &gt;= min_qty)
             return cnt * (1 - discount) * price;
         else
             return cnt * price;
     }
</pre><BR>
<p class="docText">This function generates a discounted price: If the given quantity is more than <tt>min_qty</tt>, we apply the <tt>discount</tt> (which was stored as a fraction) to the <tt>price</tt>.</p>
<a name="ch15note05"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"><a name="idd1e113748"></a><a name="idd1e113753"></a><a name="idd1e113758"></a><a name="idd1e113763"></a><a name="idd1e113768"></a><a name="idd1e113773"></a><a name="idd1e113778"></a><a name="idd1e113783"></a><a name="idd1e113788"></a><a name="idd1e113793"></a><a name="idd1e113798"></a><a name="idd1e113801"></a><a name="idd1e113804"></a><a name="idd1e113809"></a><a name="idd1e113812"></a><a name="idd1e113815"></a> Because each derived object has a base-class part, classes may access the <tt>public</tt> and <tt>protected</tt> members of its base class as if those members were members of the derived class itself.</P></TD></tr></table><br>
</p></div><br>

<a name="ch15lev3sec7"></a>
<H5 class="docSection3Title">A Class Must Be Defined to Be Used as a Base Class</h5>
<p class="docText">A class must be defined before it can be used as a base class. Had we declared, but not defined, <tt>Item_base</tt>, we could not use it as our base class:</p>
<pre>
     class Item_base; // <span class="docEmphasis">declared but not defined</span>
     // <span class="docEmphasis">error: Item_base must be defined</span>
     class Bulk_item : public Item_base { ... };
</pre><BR>
<p class="docText">The reason for this restriction should already be easy to see: Each derived class contains, and may access, the members of its base class. To use those members, the derived class must konw what they are. One implication of this rule is that it is impossible to derive a class from itself.</p>

<a name="ch15lev3sec8"></a>
<h5 class="docSection3Title">Using a Derived Class as a Base Class</H5>
<p class="docText">A base class can itself be a derived class:</p>
<pre>
     class Base { /* ... */ };
     class D1: public Base { /* ... */ };
     class D2: public D1 { /* ... */ };
</pre><BR>
<p class="docText">Each class inherits all the members of its base class. The most derived type inherits the members of its base, which in turn inherits the members of its base and so on up the inheritance chain. Effectively, the most derived object contains a subobject for each of its <b><a name="ch15term9"></a><a class="docLink" href="ch15lev1sec11.html#gloss15_09">immediate-base</a></b> and <b><a name="ch15term10"></a><a class="docLink" href="ch15lev1sec11.html#gloss15_10">indirect-base</a></b> classes.</p>

<a name="ch15lev3sec9"></a>
<h5 class="docSection3Title">Declarations of Derived Classes</h5>
<p class="docText">If we need to declare (but not yet define) a derived class, the declaration contains the class name but does not include its derivation list. For example, the following forward declaration of <tt>Bulk_item</tt> results in a compile-time error:</p>
<pre>
     // <span class="docEmphasis">error: a forward declaration must not include the derivation list</span>
     class Bulk_item : public Item_base;
</pre><br>
<p class="docText">The correct forward declarations are:</p>
<pre>
     // <span class="docEmphasis">forward declarations of both derived and nonderived class</span>
     class Bulk_item;
     class Item_base;
</pre><br>


<a name="ch15lev2sec6"></a>
<h4 class="docSection2Title">15.2.4. <tt>virtual</tt> and Other Member Functions</h4>
<p class="docText">By default, function calls in C++ do not use dynamic binding. To trigger dynamic binding, two conditions must be met: First, only member functions that are specified as virtual can be dynamically bound. By default, member functions are not <a name="idd1e113925"></a><a name="idd1e113930"></a><a name="idd1e113933"></a><a name="idd1e113938"></a><a name="idd1e113943"></a>virtual; nonvirtual functions are not dynamically bound. Second, the call must be made through a reference or a pointer to a base-class type. To understand this requirement, we need to understand what happens when we use a reference or pointer to an object that has a type from an inheritance hierarchy.</p>
<a name="ch15sb03"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<h2 class="docSidebarTitle">Exercises Section 15.2.3</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch15qa2q1"></a><B>Exercise 15.5:</b></td><td><p class="docText">Which of the following declarations, if any, are incorrect?</p>
<pre>
     class Base { ... };

     (a) class Derived : public Derived { ... };
     (b) class Derived : Base { ... };
     (c) class Derived : private Base { ... };
     (d) class Derived : public Base;
     (e) class Derived inherits Base { ... };
</pre><br>
</td></TR><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch15qa2q2"></a><B>Exercise 15.6:</b></td><td><p class="docText">Write your own version of the <tt>Bulk_item</tt> class.</p></TD></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q3"></a><b>Exercise 15.7:</b></td><TD><p class="docText">We might define a type to implement a limited discount strategy. This class would give a discount for books purchased up to a limit. If the number of copies purchased exceeds that limit, then the normal price should be applied to any books purchased beyond the limit. Define a class that implements this strategy.</p></td></TR></table></p>
</blockquote>
</td></TR></table></p><BR>
<a name="ch15lev3sec10"></a>
<h5 class="docSection3Title">Derived to Base Conversions</h5>
<p class="docText">Because every derived object contains a base part, we can bind a base-type reference to the base-class part of a derived object. We can also use a pointer to base to point to a derived object:</p>
<pre>
     // <span class="docEmphItalicAlt">function with an</span> <span class="docEmphasis">Item_base</span> <span class="docEmphItalicAlt">reference parameter</span>
     double print_total(const Item_base&amp;, size_t);
     Item_base item;           // <span class="docEmphItalicAlt">object of base type</span>
     // <span class="docEmphItalicAlt">ok: use pointer or reference to</span> <span class="docEmphasis">Item_base</span> <span class="docEmphItalicAlt">to refer to an</span> <span class="docEmphasis">Item_base</span> <span class="docEmphItalicAlt">object</span>
     print_total(item, 10);    // <span class="docEmphItalicAlt">passes reference to an</span> <span class="docEmphasis">Item_base</span> <span class="docEmphItalicAlt">object</span>
     Item_base *p = &amp;item;     // <span class="docEmphasis">p</span> <span class="docEmphItalicAlt">points to an</span> <span class="docEmphasis">Item_base</span> <span class="docEmphItalicAlt">object</span>

     Bulk_item bulk;           // <span class="docEmphItalicAlt">object of derived type</span>
     // <span class="docEmphItalicAlt">ok: can bind a pointer or reference to</span> <span class="docEmphasis">Item_base</span> <span class="docEmphItalicAlt">to a</span> <span class="docEmphasis">Bulk_item</span> <span class="docEmphItalicAlt">object</span>
     print_total(bulk, 10);    // <span class="docEmphItalicAlt">passes reference to the</span> <span class="docEmphasis">Item_base</span> <span class="docEmphItalicAlt">part of</span> <span class="docEmphasis">bulk</span>
     p = &amp;bulk;                // <span class="docEmphasis">p</span> <span class="docEmphItalicAlt">points to the</span> <span class="docEmphasis">Item_base</span> <span class="docEmphItalicAlt">part of</span> <span class="docEmphasis">bulk</span>
</pre><br>
<p class="docText">This code uses the same base-type pointer to point to an object of the base type and to an object of the derived type. It also calls a function that expects a reference to the base type, passing an object of the base-class type and also passing an object of the derived type. Both uses are fine, because every derived object has a base part.</p>
<p class="docText">Because we can use a base-type pointer or reference to refer to a derived-type object, when we use a base-type reference or pointer, we don't know the type of the object to which the pointer or reference is bound: A base-type reference or pointer might refer to an object of base type or an object of derived type. Regardless of <a name="idd1e114111"></a><a name="idd1e114114"></a><a name="idd1e114119"></a><a name="idd1e114126"></a><a name="idd1e114129"></a><a name="idd1e114134"></a><a name="idd1e114139"></a>which actual type the object has, the compiler treats the object as if it is a base type object. Treating a derived object as if it were a base is safe, because every derived object has a base subobject. Also, the derived class inherits the operations of the base class, meaning that any operation that might be performed on a base object is available through the derived object as well.</p>
<a name="ch15note06"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> The crucial point about references and pointers to base-class types is that the <b><a name="ch15term21"></a><a class="docLink" href="ch15lev1sec11.html#gloss15_21">static type</a></b>the type of the reference or pointer, which is knowable at compile timeand the <b><a name="ch15term7"></a><a class="docLink" href="ch15lev1sec11.html#gloss15_07">dynamic type</a></b>the type of the object to which the pointer or reference is bound, which is knowable only at run timemay differ.</P></TD></tr></table><BR>
</p></div><br>

<a name="ch15lev3sec11"></a>
<H5 class="docSection3Title">Calls to <tt>virtual</tt> Functions May Be Resolved at Run time</H5>
<p class="docText">Binding a base-type reference or pointer to a derived object has no effect on the underlying object. The object itself is unchanged and remains a derived object. The fact that the actual type of the object might differ from the static type of the reference or pointer addressing that object is the key to dynamic binding in C++.</p>
<p class="docText">When a virtual function is called through a reference or pointer, the compiler generates code to <span class="docEmphasis">decide at run time</span> which function to call. The function that is called is the one that corresponds to the dynamic type. As an example, let's look again at the <tt>print_total</tt> function:</p>
<pre>
     // <span class="docEmphItalicAlt">calculate and print price for given number of copies, applying any discounts</span>
     void print_total(ostream &amp;os,
                      const Item_base &amp;item, size_t n)
     {
         os &lt;&lt; "ISBN: " &lt;&lt; item.book() // <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">Item_base::book</span>
            &lt;&lt; "\tnumber sold: " &lt;&lt; n &lt;&lt; "\ttotal price: "
            // <span class="docEmphItalicAlt">virtual call: which version of</span> <span class="docEmphasis">net_price</span> <span class="docEmphItalicAlt">to call is resolved at run time</span>
            &lt;&lt; item.net_price(n) &lt;&lt; endl;
     }
</pre><br>
<p class="docText">Because the <tt>item</tt> parameter is a reference and <tt>net_price</tt> is virtual, the version of <tt>net_price</tt> that is called in <tt>item.net_price(n)</tt> depends at run time on the actual type of the argument bound to the <tt>item</tt> parameter:</p>
<pre>
     Item_base base;
     Bulk_item derived;
     // <span class="docEmphasis">print_total</span> <span class="docEmphItalicAlt">makes a virtual call to</span> <span class="docEmphasis">net_price</span>
     print_total(cout, base, 10);     // <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">Item_base::net_price</span>
     print_total(cout, derived, 10);  // <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">Bulk_item::net_price</span>
</pre><br>
<p class="docText">In the first call, the <tt>item</tt> parameter is bound, at run time, to an object of type <tt>Item_base</tt>. As a result, the call to <tt>net_price</tt> inside <tt>print_total</tt> calls the version defined in <tt>Item_base</tt>. In the second call, <tt>item</tt> is bound to an object of type <tt>Bulk_item</tt>. In this call, the version of <tt>net_price</tt> called from <tt>print_total</tt> will be the one defined by the <tt>Bulk_item</tt> class.</P>
<a name="ch15sb04"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<h2 class="docSidebarTitle">Key Concept: Polymorphism in C++</h2>
<p class="docText"><a name="idd1e114290"></a><a name="idd1e114297"></a><a name="idd1e114302"></a><a name="idd1e114307"></a><a name="idd1e114315"></a><a name="idd1e114320"></a><a name="idd1e114325"></a><a name="idd1e114328"></a><a name="idd1e114333"></a><a name="idd1e114338"></a><a name="idd1e114343"></a><a name="idd1e114348"></a><span class="docEmphStrong">The fact that the static and dynamic types of references and pointers can differ is the cornerstone of how C++ supports polymorphism.</span></p>
<p class="docText"><span class="docEmphStrong">When we call a function defined in the base class through a base-class reference or pointer, we do not know the precise type of the object on which the function is executed. The object on which the function executes might be of the base type or it might be an object of a derived type.</span></P>
<p class="docText"><span class="docEmphStrong">If the function called is nonvirtual, then regardless of the actual object type, the function that is executed is the one defined by the base type. If the function is virtual, then the decision as to which function to run is delayed until run time. The version of the virtual function that is run is the one defined by the type of the object to which the reference is bound or to which the pointer points.</span></P>
<p class="docText"><span class="docEmphStrong">From the perspective of the code that we write, we need not care. As long as the classes are designed and implemented correctly, the operations will do the right thing whether the actual object is of base or derived type.</span></p>
<p class="docText"><span class="docEmphStrong">On the other hand, an object is not polymorphicits type is known and unchanging. The dynamic type of an object (as opposed to a reference or pointer) is always the same as the static type of the object. The function that is run, virtual or nonvirtual, is the one defined by the type of the object.</span></p>
<a name="ch15note07"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> <span class="docEmphStrong">Virtuals are resolved at run time <span class="docEmphasis">only</span> if the call is made through a reference or pointer. Only in these cases is it possible for an object's dynamic type to be unknown until run time.</span></P></td></tr></table><BR>
</p></div><BR>
</td></tr></table></p><br>

<a name="ch15lev3sec12"></a>
<h5 class="docSection3Title">Non<tt>virtual</tt> Calls Are Resolved at Compile Time</h5>
<p class="docText">Regardless of the actual type of the argument passed to <tt>print_total</tt>, the call of <tt>book</tt> is resolved at compile time to <tt>Item_base::book</tt>.</p>
<a name="ch15note08"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> Even if <tt>Bulk_item</tt> defined its own version of the <tt>book</tt> function, this call would call the one from the base class.</p></TD></TR></table><br>
</P></div><br>
<p class="docText">Nonvirtual functions are <span class="docEmphasis">always</span> resolved at compile time based on the type of the object, reference, or pointer from which the function is called. The type of <tt>item</tt> is reference to <tt>const Item_base</tt>, so a call to a nonvirtual function on that object will call the one from <tt>Item_base</tt> regardless of the type of the actual object to which <tt>item</tt> refers at run time.</p>

<a name="ch15lev3sec13"></a>
<H5 class="docSection3Title">Overriding the Virtual Mechanism</H5>
<p class="docText">In some cases, we want to override the virtual mechanism and force a call to use a particular version of a virtual function. We can do so by using the scope operator:</p>
<pre>
     Item_base *baseP = &amp;derived;
     // <span class="docEmphItalicAlt">calls version from the base class regardless of the dynamic type of</span> <span class="docEmphasis">baseP</span>
     double d = baseP-&gt;Item_base::net_price(42);
</pre><br>
<p class="docText">This code forces the call to <tt>net_price</tt> to be resolved to the version defined in <tt>Item_base</tt>. The call will be resolved at compile time.</p>
<a name="ch15note09"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><TD valign="top"><p class="docText"><a name="idd1e114477"></a><a name="idd1e114482"></a><a name="idd1e114487"></a><a name="idd1e114492"></a><a name="idd1e114497"></a><a name="idd1e114502"></a><a name="idd1e114507"></a><a name="idd1e114512"></a> Only code inside member functions should ever need to use the scope operator to override the virtual mechanism.</P></td></tr></table><br>
</P></div><BR>
<p class="docText">Why might we wish to override the virtual mechanism? The most common reason is when a derived-class virtual calls the version from the base. In such cases, the base-class version might do work common to all types in the hierarchy. Each derived type adds only whatever is particular to its own type.</p>
<p class="docText">For example, we might define a <tt>Camera</tt> hierarchy with a virtual <tt>display</tt> operation. The <tt>display</tt> function in the <tt>Camera</tt> class would display information common to all <tt>Camera</tt>s. A derived class, such as <tt>PerspectiveCamera</tt>, would need to display both that common information and the information unique to <tt>PerspectiveCamera</tt>. Rather than duplicate the <tt>Camera</tt> operations within <tt>PerspectiveCamera</tt>'s implementation of <tt>display</tt>, we could explicitly invoke the <tt>Camera</tt> version to display the common information. In a case such as this one, we'd know exactly which instance to invoke, so there would be no need to go through the virtual mechanism.</p>
<a name="ch15note10"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> When a derived virtual calls the base-class version, it <span class="docEmphasis">must</span> do so explicitly using the scope operator. If the derived function neglected to do so, then the call would be resolved at run time and would be a call to itself, resulting in an infinite recursion.</P></td></tr></table><BR>
</p></div><BR>

<a name="ch15lev3sec14"></a>
<h5 class="docSection3Title">Virtual Functions and Default Arguments</h5>
<p class="docText">Like any other function, a virtual function can have default arguments. As usual, the value, if any, of a default argument used in a given call is determined at compile time. If a call omits an argument that has a default value, then the value that is used is the one defined by the type through which the function is called, irrespective of the object's dynamic type. When a virtual is called through a reference or pointer to base, then the default argument is the value specified in the declaration of the virtual in the base class. If a virtual is called through a pointer or reference to derived, the default argument is the one declared in the version in the derived class.</p>
<p class="docText">Using different default arguments in the base and derived versions of the same virtual is almost guaranteed to cause trouble. Problems are likely to arise when the virtual is called through a reference or pointer to base, but the version that is executed is the one defined by the derived. In such cases, the default argument defined for the base version of the virtual will be passed to the derived version, which was defined using a different default argument.</p>


<a name="ch15lev2sec7"></a>
<h4 class="docSection2Title">15.2.5. Public, Private, and Protected Inheritance</h4>
<p class="docText">Access to members defined within a derived class is controlled in exactly the same way as access is handled for any other class (<a class="docLink" href="ch12lev1sec1.html#ch12lev2sec2">Section 12.1.2</a>, p. <a class="docLink" href="ch12lev1sec1.html#ch12lev2sec2">432</a>). A derived class may define zero or more access labels that specify the access level of the members following that label. Access to the members the class inherits is controlled by a <a name="idd1e114602"></a><a name="idd1e114607"></a><a name="idd1e114612"></a><a name="idd1e114615"></a>combination of the access level of the member in the base class and the access label used in the derived class' derivation list.</p>
<a name="ch15sb05"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 15.2.4</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch15qa3q1"></a><b>Exercise 15.8:</b></TD><td><p class="docText">Given the following classes, explain each <tt>print</tt> function:</p>
<pre>
     struct base {
        string name() { return basename; }
        virtual void print(ostream &amp;os) { os &lt;&lt; basename; }
     private:
           string basename;
     };

     struct derived {
        void print() { print(ostream &amp;os); os &lt;&lt; " " &lt;&lt; mem; }
     private:
           int mem;
     };
</pre><BR>
<p class="docText">If there is a problem in this code, how would you fix it?</P>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa3q2"></a><b>Exercise 15.9:</b></TD><td><p class="docText">Given the classes in the previous exercise and the following objects, determine which function is called at run time:</P>
<pre>
     base bobj;    base *bp1 = &amp;base;  base &amp;br1 = bobj;
     derived dobj; base *bp2 = &amp;doboj; base &amp;br2 = dobj;

     (a) bobj.print(); (b) dobj.print();   (c) bp1-&gt;name();
     (d) bp2-&gt;name();  (e) br1.print();    (f) br2.print();
</pre><BR>
</td></tr></table></p>
</blockquote>
</TD></TR></table></p><br>
<a name="ch15note11"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> Each class controls access to the members it defines. A derived class may further restrict but may not loosen the access to the members that it inherits.</P></td></tr></table><BR>
</p></div><BR>
<p class="docText">The base class itself specifies the minimal access control for its own members. If a member is <tt>private</tt> in the base class, then only the base class and its friends may access that member. The derived class has no access to the <tt>private</tt> members of its base class, nor can it make those members accessible to its own users. If a base class member is <tt>public</tt> or <tt>protected</tt>, then the access label used in the derivation list determines the access level of that member in the derived class:</p>
<ul><li><p class="docList">In <b><a name="ch15term17"></a><a class="docLink" href="ch15lev1sec11.html#gloss15_17"><span class="docEmphStrong"><tt>public</tt> inheritance</span></a></b>, the members of the base retain their access levels: The <tt>public</tt> members of the base are <tt>public</tt> members of the derived and the <tt>protected</tt> members of the base are <tt>protected</tt> in the derived.</p></li><li><p class="docList">In <b><a name="ch15term16"></a><a class="docLink" href="ch15lev1sec11.html#gloss15_16"><span class="docEmphStrong"><tt>protected</tt> inheritance</span></a></b>, the <tt>public</tt> and <tt>protected</tt> members of the base class are <tt>protected</tt> members in the derived class.</p></li><li><p class="docList">In <b><a name="ch15term14"></a><a class="docLink" href="ch15lev1sec11.html#gloss15_14"><span class="docEmphStrong"><tt>private</tt> inheritance</span></a></b>, all the members of the base class are <tt>private</tt> in the derived class.</p></LI></UL>
<p class="docText"><a name="idd1e114757"></a>As an example, consider the following hierarchy:</p>
<pre>
     class Base {
     public:
         void basemem();   // <span class="docEmphasis">public</span> <span class="docEmphItalicAlt">member</span>
     protected:
         int i;            // <span class="docEmphasis">protected</span> <span class="docEmphItalicAlt">member</span>
         // ...
     };
     struct Public_derived : public Base {
         int use_base() { return i; } // <span class="docEmphItalicAlt">ok: derived classes can access</span> <span class="docEmphasis">i</span>
         // ...
     };
     struct Private_derived : private Base {
         int use_base() { return i; } // <span class="docEmphItalicAlt">ok: derived classes can access</span> <span class="docEmphasis">i</span>
     };
</pre><BR>
<p class="docText">All classes that inherit from <tt>Base</tt> have the same access to the members in <tt>Base</tt>, regardless of the access label in their derivation lists. The derivation access label controls the access that <span class="docEmphasis">users</span> of the derived class have to the members inherited from <tt>Base</tt>:</p>
<pre>
     Base b;
     Public_derived d1;
     Private_derived d2;
     b.basemem();   // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">basemem</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">public</span>
     d1.basemem();  // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">basemem</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">public</span> <span class="docEmphItalicAlt">in the derived class</span>
     d2.basemem();  // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">basemem</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">private</span> <span class="docEmphItalicAlt">in the derived class</span>
</pre><br>
<p class="docText">Both <tt>Public_derived</tt> and <tt>Private_derived</tt> inherit the <tt>basemem</tt> function. That member retains its access level when the inheritance is <tt>public</tt>, so <tt>d1</tt> can call <tt>basemem</tt>. In <tt>Private_derived</tt>, the members of <tt>Base</tt> are <tt>private</tt>; users of <tt>Private_derived</tt> may not call <tt>basemem</tt>.</P>
<p class="docText">The derivation access label also controls access from indirectly derived classes:</P>
<pre>
     struct Derived_from Private : public Private_derived {
         // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">Base::i</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">private</span> <span class="docEmphItalicAlt">in</span> <span class="docEmphasis">Private_derived</span>
         int use_base() { return i; }
     };
     struct Derived_from_Public : public Public_derived {
         // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">Base::i</span> <span class="docEmphItalicAlt">remains</span> <span class="docEmphasis">protected</span> <span class="docEmphItalicAlt">in</span> <span class="docEmphasis">Public_derived</span>
         int use_base() { return i; }
     };
</pre><br>
<p class="docText">Classes derived from <tt>Public_derived</tt> may access <tt>i</tt> from the <tt>Base</tt> class because that member remains a <tt>protected</tt> member in <tt>Public_derived</tt>. Classes derived from <tt>Private_derived</tt> have no such access. To them all the members that <tt>Private_base</tt> inherited from <tt>Base</tt> are <tt>private</tt>.</p>
<a name="ch15lev3sec15"></a>
<h5 class="docSection3Title">Interface versus Implementation Inheritance</h5>
<p class="docText"><a name="idd1e114974"></a><a name="idd1e114981"></a><a name="idd1e114984"></a><a name="idd1e114992"></a><a name="idd1e114997"></a><a name="idd1e115000"></a><a name="idd1e115003"></a><a name="idd1e115008"></a><a name="idd1e115013"></a><a name="idd1e115016"></a><a name="idd1e115019"></a><a name="idd1e115022"></a>A <tt>public</tt>ly derived class inherits the interface of its base class; it has the same interface as its base class. In well-designed class hierarchies, objects of a <tt>public</tt>ly derived class can be used wherever an object of the base class is expected.</p>
<p class="docText">Classes derived using either <tt>private</tt> or <tt>protected</tt> do not inherit the base-class interface. Instead, these derivations are often referred to as implementation inheritance. The derived class uses the inherited class in its implementation but does not expose the fact of the inheritance as part of its interface.</P>
<p class="docText">As we'll see in <a class="docLink" href="ch15lev1sec3.html#ch15lev1sec3">Section 15.3</a> (p. <a class="docLink" href="ch15lev1sec3.html#ch15lev1sec3">577</a>), whether a class uses interface or implementation inheritance has important implications for users of the derived class.</p>
<a name="ch15note12"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> By far the most common form of inheritance is <tt>public</tt>.</P></TD></tr></table><br>
</p></div><br>
<a name="ch15sb06"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Key Concept: Inheritance versus Composition</h2>
<p class="docText"><span class="docEmphStrong">The design of inheritance hierarchies is a complex topic in its own right and well beyond the scope of this language primer. However, there is one important design guide that is so fundamental that every programmer should be familiar with it.</span></p>
<p class="docText"><span class="docEmphStrong">When we define one class as publicly inherited from another, the derived class should reflect a so-called &quot;Is A&quot; relationship to the base class. In our bookstore example, our base class represents the concept of a book sold at a stipulated price. Our <tt>Bulk_item</tt> is a kind of book, but one with a different pricing strategy.</span></P>
<p class="docText"><span class="docEmphStrong">Another common relationship among types is a so-called &quot;Has A&quot; relationship. Our bookstore classes have a price and they have an ISBN. Types related by a &quot;Has A&quot; relationship imply membership. Thus, our bookstore classes are composed from members representing the price and the ISBN.</span></p>
</TD></tr></table></p><br>

<a name="ch15lev3sec16"></a>
<h5 class="docSection3Title">Exempting Individual Members</h5>
<p class="docText">When inheritance is <tt>private</tt> or <tt>protected</tt>, the access level of members of the base may be more restrictive in the derived class than it was in the base:</p>
<pre>
     class Base {
     public:
         std::size_t size() const { return n; }
     protected:
         std::size_t n;
     };
     class Derived : private Base { . . . };
</pre><br>
<a name="ch15note13"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> The derived class can restore the access level of an inherited member. The access level cannot be made more or less restrictive than the level originally specified within the base class.</p></TD></TR></table><br>
</P></div><br>
<p class="docText">In this hierarchy, <tt>size</tt> is <tt>public</tt> in <tt>Base</tt> but <tt>private</tt> in <tt>Derived</tt>. To make <a name="idd1e115136"></a><a name="idd1e115141"></a><a name="idd1e115146"></a><a name="idd1e115154"></a><a name="idd1e115159"></a><a name="idd1e115164"></a><a name="idd1e115173"></a><a name="idd1e115178"></a><a name="idd1e115183"></a><tt>size public</tt> in <tt>Derived</tt> we can add a <tt>using</tt> declaration for it to a <tt>public</tt> section in <tt>Derived</tt>. By changing the definition of <tt>Derived</tt> as follows, we can make the <tt>size</tt> member accessible to users and <tt>n</tt> accessible to classes subsequently derived from <tt>Derived</tt>:</p>
<pre>
     class Derived : private Base {
     public:
        // <span class="docEmphItalicAlt">maintain access levels for members related to the size of the object</span>
        using Base::size;
     protected:
         using Base::n;
         // ...
      };
</pre><BR>
<p class="docText">Just as we can use a <tt>using</tt> declaration (<a class="docLink" href="ch03lev1sec1.html#ch03lev1sec1">Section 3.1</a>, p. <a class="docLink" href="ch03lev1sec1.html#ch03lev1sec1">78</a>) to use names from the <tt>std</tt> namespace, we may also use a <tt>using</tt> declaration to access a name from a base class. The form is the same except that the left-hand side of the scope operator is a class name instead of a namespace name.</P>

<a name="ch15lev3sec17"></a>
<h5 class="docSection3Title">Default Inheritance Protection Levels</h5>
<p class="docText">In <a class="docLink" href="ch02lev1sec8.html#ch02lev1sec8">Section 2.8</a> (p. <a class="docLink" href="ch02lev1sec8.html#ch02lev1sec8">65</a>) we learned that classes defined with the <tt>struct</tt> and <tt>class</tt> keywords have different default access levels. Similarly, the default inheritance access level differs depending on which keyword is used to define the derived class. A derived class defined using the <tt>class</tt> keyword has <tt>private</tt> inheritance. A class is defined with the <tt>struct</tt> keyword, has <tt>public</tt> inheritance:</p>
<pre>
     class Base { /* ... */ };
     struct D1 : Base { /* ... */ };   // <span class="docEmphasis">public</span> <span class="docEmphItalicAlt">inheritance by default</span>
     class D2 : Base { /* ... */ };    // <span class="docEmphasis">private</span>       <span class="docEmphItalicAlt">inheritance by default</span>
</pre><br>
<p class="docText">It is a common misconception to think that there are deeper differences between classes defined using the <tt>struct</tt> keyword and those defined using <tt>class</tt>. The only differences are the default protection level for members and the default protection level for a derivation. There are no other distinctions:</p>
<pre>
     class D3 : public Base {
     public:
         /* ... */
     };
     // <span class="docEmphItalicAlt">equivalent definition of</span> <span class="docEmphasis">D3</span>
     struct D3 : Base {      // <span class="docEmphItalicAlt">inheritance</span> <span class="docEmphasis">public</span> <span class="docEmphItalicAlt">by default</span>
         /* ... */           // <span class="docEmphItalicAlt">initial member access</span> <span class="docEmphasis">public</span> <span class="docEmphItalicAlt">by default</span>
     };
     struct D4 : private Base {
     private:
         /* ... */
     };
     // <span class="docEmphItalicAlt">equivalent definition of</span> <span class="docEmphasis">D4</span>
     class D4 : Base {   // <span class="docEmphItalicAlt">inheritance</span> <span class="docEmphasis">private</span> <span class="docEmphItalicAlt">by default</span>
     /* ... */           // <span class="docEmphItalicAlt">initial member access</span> <span class="docEmphasis">private</span> <span class="docEmphItalicAlt">by default</span>
     };
</pre><BR>
<a name="ch15note14"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><td valign="top"><p class="docText"><a name="idd1e115364"></a><a name="idd1e115369"></a><a name="idd1e115374"></a> Although private inheritance is the default when using the <tt>class</tt> keyword, it is also relatively rare in practice. Because private inheritance is so rare, it is usually a good idea to explicitly specify <tt>private</tt>, rather than rely on the default. Being explicit makes it clear that private inheritance is intended and not an oversight.</p></TD></TR></table><br>
</p></div><br>
<a name="ch15sb07"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<h2 class="docSidebarTitle">Exercises Section 15.2.5</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch15qa4q1"></a><b>Exercise 15.10:</b></TD><td><p class="docText">In the exercises to <a class="docLink" href="#ch15lev2sec3">Section 15.2.1</a> (p. <a class="docLink" href="#ch15lev2sec3">562</a>) you wrote a base class to represent the lending policies of a library. Assume the library offers the following kinds of lending materials, each with its own check-out and check-in policy. Organize these items into an inheritance hierarchy:</p>
<pre>
     book                     audio book                  record
     children's puppet        sega video game             video
     cdrom book               nintendo video game        rental book
     sony play stationvideo game
</pre><br>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q2"></a><b>Exercise 15.11:</b></td><td><p class="docText">Choose one of the following general abstractions containing a family of types (or choose one of your own). Organize the types into an inheritance hierarchy:</p>
<pre><a name="PLID25"></a><div class="v1"><a href="ch15lev1sec2.html#PLID25">[View full width]</a></div>
     (a) Graphical file formats (such as gif, tiff, jpeg, bmp)
     (b) Geometric primitives (such as box, circle, sphere, cone)
     (c) C++ language types (such as class, function, member
<img border="0" width="14" height="9" alt="" align="left" src="images/ccc.gif"> function)
</pre><br>
</td></TR><TR valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q3"></a><B>Exercise 15.12:</b></td><td><p class="docText">For the class you chose in the previous exercise, identify some of the likely virtual functions as well as <tt>public</tt> and <tt>protected</tt> members.</P></TD></tr></table></p>
</blockquote>
</td></tr></table></p><BR>


<a name="ch15lev2sec8"></a>
<h4 class="docSection2Title">15.2.6. Friendship and Inheritance</H4>
<p class="docText">As with any other class, a base or derived class can make other class(es) or function(s) friends (<a class="docLink" href="ch12lev1sec5.html#ch12lev1sec5">Section 12.5</a>, p. <a class="docLink" href="ch12lev1sec5.html#ch12lev1sec5">465</a>). Friends may access the class' <tt>private</tt> and <tt>protected</tt> data.</P>
<a name="ch15note15"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><TD valign="top"><p class="docText"> Friendship is not inherited. Friends of the base have no special access to members of its derived classes. If a base class is granted friendship, only the base has special access. Classes derived from that base have no access to the class granting friendship.</p></td></tr></table><br>
</P></div><br>
<p class="docText">Each class controls friendship to its own members:</p>
<pre>
     class Base {
         friend class Frnd;
     protected:
         int i;
     };
     // <span class="docEmphasis">Frnd</span> <span class="docEmphItalicAlt">has no access to members in</span> <span class="docEmphasis">D1</span>
     class D1 : public Base {
     protected:
         int j;
     };
     class Frnd {
     public:
        int mem(Base b) { return b.i; }  // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">Frnd is friend to</span> <span class="docEmphasis">Base</span>
        int mem(D1 d) { return d.i; }    // <span class="docEmphItalicAlt">error: friendship doesn't inherit</span>
     };
     // <span class="docEmphasis">D2</span> <span class="docEmphItalicAlt">has no access to members in</span> <span class="docEmphasis">Base</span>
     class D2 : public Frnd {
     public:
        int mem(Base b) { return b.i; } // <span class="docEmphItalicAlt">error: friendship doesn't inherit</span>
     };
</pre><BR>
<p class="docText"><a name="idd1e115532"></a><a name="idd1e115539"></a><a name="idd1e115548"></a><a name="idd1e115553"></a><a name="idd1e115560"></a><a name="idd1e115567"></a>If a derived class wants to grant access to its members to the friends of its base class, the derived class must do so explicitly: Friends of the base have no special access to types derived from that base class. Similarly, if a base and its derived types all need access to another class, that class must specifically grant access to the base and each derived class.</p>

<a name="ch15lev2sec9"></a>
<h4 class="docSection2Title">15.2.7. Inheritance and Static Members</H4>
<p class="docText">If a base class defines a <tt>static</tt> member (<a class="docLink" href="ch12lev1sec6.html#ch12lev1sec6">Section 12.6</a>, p. <a class="docLink" href="ch12lev1sec6.html#ch12lev1sec6">467</a>) there is only one such member defined for the entire hierarchy. Regardless of the number of classes derived from the base class, there exists a single instance of each <tt>static</tt> member. <tt>static</tt> members obey normal access control: If the member is <tt>private</tt> in the base class, then derived classes have no access to it. Assuming the member is accessible, we can access the <tt>static</tt> member either through the base or derived class. As usual, we can use either the scope operator or the dot or arrow member access operators.</p>
<pre>
     struct Base {
         static void statmem(); // <span class="docEmphasis">public</span> <span class="docEmphItalicAlt">by default</span>
     };
     struct Derived : Base {
         void f(const Derived&amp;);
     };
     void Derived::f(const Derived &amp;derived_obj)
     {
        Base::statmem();      // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">Base</span> <span class="docEmphItalicAlt">defines</span> <span class="docEmphasis">statmem</span>
        Derived::statmem();   // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">Derived</span> <span class="docEmphItalicAlt">in herits</span> <span class="docEmphasis">statmem</span>
        // <span class="docEmphItalicAlt">ok: derived objects can be used to access static from base</span>
        derived_obj.statmem();     // <span class="docEmphItalicAlt">accessed through</span> <span class="docEmphasis">Derived</span> <span class="docEmphItalicAlt">object</span>
        statmem();                 // <span class="docEmphItalicAlt">accessed through this class</span>
</pre><BR>
<a name="ch15sb08"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 15.2.7</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa5q1"></a><b>Exercise 15.13:</b></td><td><p class="docText"><a name="idd1e115673"></a><a name="idd1e115678"></a>Given the following classes, list all the ways a member function in <tt>C1</tt> might access the <tt>static</tt> members of <tt>ConcreteBase</tt>. List all the ways an object of type <tt>C2</tt> might access those members.</p>
<pre>
     struct ConcreteBase {
         static std::size_t object_count();
     protected:
         static std::size_t obj_count;
     };
     struct C1 : public ConcreteBase { /* . . . */ };
     struct C2 : public ConcreteBase { /* . . . */ };
</pre><br>
</TD></TR></table></p>
</blockquote>
</TD></tr></table></p><BR>


<a href="21001535.html"><img src="images/pixel.gif" alt="" width="1" height="1" border="0"></a><UL></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch15lev1sec1.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch15lev1sec3.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>