<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 15.9.&nbsp; Text Queries Revisited</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch15lev1sec8.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch15lev1sec10.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch15lev1sec9"></a>
<h3 class="docSection1Title">15.9. Text Queries Revisited</h3>
<p class="docText">As a final example of inheritance, we'll extend our text query application from <a class="docLink" href="ch10lev1sec6.html#ch10lev1sec6">Section 10.6</a> (p. <a class="docLink" href="ch10lev1sec6.html#ch10lev1sec6">379</a>). The class we developed there let us look for occurrences of a given word in a text file. We'd like to extend the system to support more complex queries.</P>
<p class="docText">For illustration purposes, we'll run queries against the following simple story:</P>
<pre>
     <span class="docEmphStrong">Alice Emma has long flowing red hair.</span>
     <span class="docEmphStrong">Her Daddy says when the wind blows</span>
     <span class="docEmphStrong">through her hair, it looks almost alive,</span>
     <span class="docEmphStrong">like a fiery bird in flight.</span>
     <span class="docEmphStrong">A beautiful fiery bird, he tells her,</span>
     <span class="docEmphStrong">magical but untamed.</span>
     <span class="docEmphStrong">"Daddy, shush, there is no such thing,"</span>
     <span class="docEmphStrong">she tells him, at the same time wanting</span>
     <span class="docEmphStrong">him to tell her more.</span>
     <span class="docEmphStrong">Shyly, she asks, "I mean, Daddy, is there?"</span>
</pre><br>
<p class="docText">Our system should support:</P>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">Word queries that find a single word. All lines in which the word appears should be displayed in ascending order:</p><pre>
     <span class="docEmphStrong">Executed Query for:</span>
     <span class="docEmphStrong">Daddy match occurs 3 times:</span>
     <span class="docEmphStrong">(line 2) Her Daddy says when the wind blows</span>
     <span class="docEmphStrong">(line 7) "Daddy, shush, there is no such thing,"</span>
     <span class="docEmphStrong">(line 10) Shyly, she asks, "I mean, Daddy, is there?"</span>
</pre><BR></div></LI><li><div style="font-weight:normal"><p class="docList">Not queries, using the <tt>~</tt> operator. All lines that do not match the query are displayed:</p><pre>
     <span class="docEmphStrong">Executed Query for: ~(Alice)</span>
     <span class="docEmphStrong">match occurs 9 times:</span>
     <span class="docEmphStrong">(line 2) Her Daddy says when the wind blows</span>
     <span class="docEmphStrong">(line 3) through her hair, it looks almost alive,</span>
     <span class="docEmphStrong">(line 4) like a fiery bird in flight. ...</span>
</pre><br></div></li><li><div style="font-weight:normal"><p class="docList">Or queries, using the <tt>|</tt> operator. All lines in which either of two queries match are displayed:</P><pre>
     <span class="docEmphStrong">Executing Query for: (hair | Alice)</span>
     <span class="docEmphStrong">match occurs 2 times:</span>
     <span class="docEmphStrong">(line 1) Alice Emma has long flowing red hair.</span>
     <span class="docEmphStrong">(line 3) through her hair, it looks almost alive,</span>
</pre><br></div></LI><LI><div style="font-weight:normal"><p class="docList">And queries, using the <tt>&amp;</tt> operator. All lines in which both queries match are displayed.</p><pre>
     <span class="docEmphStrong">Executed query: (hair &amp; Alice)</span>
     <span class="docEmphStrong">match occurs 1 time:</span>
     <span class="docEmphStrong">(line 1) Alice Emma has long flowing red hair.</span>
</pre><br></div></li></ol></div>
<p class="docText">Moreover, these elements can be combined, as in</P>
<pre>
     <span class="docEmphStrong">fiery &amp; bird | wind</span>
</pre><BR>
<p class="docText">Our system will not be sophisticated enough to read these expressions. Instead, we'll build them up inside a C++ program. Hence, we'll evaluate compound expressions such as this example using normal C++ precedence rules. The evaluation of this query will match a line in which <tt>fiery</tt> and <tt>bird</tt> appear or one in which <tt>wind</tt> appears. It will not match a line on which <tt>fiery</tt> or <tt>bird</tt> appears alone:</p>
<pre>
     <span class="docEmphStrong">Executing Query for: ((fiery &amp; bird) | wind)</span>
     <span class="docEmphStrong">match occurs 3 times:</span>
     <span class="docEmphStrong">(line 2) Her Daddy says when the wind blows</span>
     <span class="docEmphStrong">(line 4) like a fiery bird in flight.</span>
     <span class="docEmphStrong">(line 5) A beautiful fiery bird, he tells her,</span>
</pre><br>
<p class="docText">Our output will print the query, using parentheses to indicate the way in which the query was interpreted. As with our original implementation, our system must be smart enough not to display the same line more than once.</p>
<a name="ch15lev2sec24"></a>
<h4 class="docSection2Title">15.9.1. An Object-Oriented Solution</H4>
<p class="docText"><a name="idd1e120611"></a><a name="idd1e120616"></a><a name="idd1e120620"></a><a name="idd1e120627"></a><a name="idd1e120631"></a><a name="idd1e120638"></a><a name="idd1e120645"></a><a name="idd1e120652"></a><a name="idd1e120656"></a><a name="idd1e120660"></a><a name="idd1e120668"></a><a name="idd1e120673"></a><a name="idd1e120679"></a><a name="idd1e120684"></a><a name="idd1e120691"></a><a name="idd1e120697"></a><a name="idd1e120704"></a>We might think that we could use the <tt>TextQuery</tt> class from page <a class="docLink" href="ch10lev1sec6.html#ch10lev2sec19">382</a> to represent our word queries. We might then derive our other queries from that class.</p>
<p class="docText">However, this design would be flawed. Conceptually, a &quot;not&quot; query is not a kind of word query. Instead, a not query &quot;has a&quot; query (word query or any other kind of query) whose value it negates.</p>
<p class="docText">This observation suggests that we model our different kinds of queries as independent classes that share a common base class:</P>
<pre>
     WordQuery // <span class="docEmphItalicAlt">Shakespeare</span>
     NotQuery  // <span class="docEmphItalicAlt">~Shakespeare</span>
     OrQuery   // <span class="docEmphItalicAlt">Shakespeare | Marlowe</span>
     AndQuery  // <span class="docEmphItalicAlt">William &amp; Shakespeare</span>
</pre><br>
<p class="docText">Instead of inheriting from <tt>TextQuery</tt>, we will use that class to hold the file and build the associated <tt>word_map</tt>. We'll use the query classes to build up expressions that will ultimately run queries against the file in a <tt>TextQuery</tt> object.</p>
<a name="ch15lev3sec41"></a>
<H5 class="docSection3Title">Abstract Interface Class</h5>
<p class="docText">We have identified four kinds of query classes. These classes are conceptually siblings. Each class shares the same abstract interface, which suggests that we'll need to define an abstract base class (<a class="docLink" href="ch15lev1sec6.html#ch15lev1sec6">Section 15.6</a>, p. <a class="docLink" href="ch15lev1sec6.html#ch15lev1sec6">595</a>) to represent the operations performed by a query. We'll name our abstract class <tt>Query_base</tt>, indicating that its role is to serve as the root of our query hierarchy.</P>
<p class="docText">We'll derive <tt>WordQuery</tt> and <tt>NotQuery</tt> directly from our abstract base. The <tt>AndQuery</tt> and <tt>OrQuery</tt> classes share one property that the other classes in our system do not: They each have two operands. To model this fact, we'll add another abstract class, named <tt>BinaryQuery</tt>, to our hierarchy to represent queries with two operands. The <tt>AndQuery</tt> and <tt>OrQuery</tt> classes will inherit from the <tt>BinaryQuery</tt> class, which in turn will inherit from <tt>Query_base</tt>. These decisions give us the class design represented in <a class="docLink" href="#ch15fig03">Figure 15.3</a> on the next page.</p>
<a name="ch15fig03"></a><p><center>
<h5 class="docFigureTitle">Figure 15.3. <tt>Query_base</tt> Inheritance Hierarchy</h5>

<p class="docText">
<img border="0" alt="" width="445" height="207" SRC="images/0201721481/graphics/15fig03.gif;400478"></p>

</center></p><br>

<a name="ch15lev3sec42"></a>
<h5 class="docSection3Title">Operations</h5>
<p class="docText">Our <tt>Query_base</tt> classes exist mostly to represent kinds of queries; they do little actual work. We'll reuse our <tt>TextQuery</tt> class to store the file, build the query <tt>map</tt>, and search for each word. Our query types need only two operations:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">An <tt>eval</tt> operation to return the <tt>set</tt> of matching line numbers. This operation takes a <tt>TextQuery</tt> object on which to execute the query.</p></div></li><LI><div style="font-weight:normal"><p class="docList">A <tt>display</tt> operation that takes a reference to an <tt>ostream</tt> and prints the query that a given object performs on that stream.</P></div></li></ol></div>
<p class="docText">We'll define each of these operations as pure <tt>virtual</tt> functions (<a class="docLink" href="ch15lev1sec6.html#ch15lev1sec6">Section 15.6</a>, p. <a class="docLink" href="ch15lev1sec6.html#ch15lev1sec6">595</a>) in the <tt>Query_base</tt> class. Each of our derived classes will have to define its own version of these functions.</P>


<a name="ch15lev2sec25"></a>
<h4 class="docSection2Title">15.9.2. A Valuelike Handle</h4>
<p class="docText"><a name="idd1e120889"></a><a name="idd1e120897"></a><a name="idd1e120905"></a><a name="idd1e120913"></a><a name="idd1e120921"></a><a name="idd1e120929"></a><a name="idd1e120937"></a><a name="idd1e120942"></a><a name="idd1e120950"></a><a name="idd1e120954"></a><a name="idd1e120962"></a><a name="idd1e120970"></a><a name="idd1e120978"></a>Our program will deal with evaluating queries, not with building them. However, we need to be able to create queries in order to run our program. The simplest way to do so is to write C++ expressions to create queries directly. For example, we'd like to be able to write code such as</P>
<pre>
     Query q = Query("fiery") &amp; Query("bird") | Query("wind");
</pre><BR>
<p class="docText">to generate the compound query previously described.</p>
<p class="docText">This problem description implicitly suggests that user-level code won't use our inherited classes directly. Instead, we'll define a handle class named <tt>Query</tt>, which will hide the hierarchy. User code will execute in terms of the handle; user code will only indirectly manipulate <tt>Query_base</tt> objects.</p>
<p class="docText">As with our <tt>Sales_item</tt> handle, our <tt>Query</tt> handle will hold a pointer to an object of a type in an inheritance hierarchy. The <tt>Query</tt> class will also point to a use count, which we'll use to manage the object to which the handle points.</p>
<p class="docText">In this case, our handle will completely hide the underlying inheritance hierarchy. Users will create and manipulate <tt>Query_base</tt> objects only indirectly through operations on <tt>Query</tt> objects. We'll define three overloaded operators on <tt>Query</tt> objects and a <tt>Query</tt> constructor that will dynamically allocate a new <tt>Query_base</tt> object. Each operator will bind the generated <tt>Query_base</tt> object to a <tt>Query</tt> handle: The <tt>&amp;</tt> operator will generate a <tt>Query</tt> bound to a new <tt>AndQuery</tt>; the <tt>|</tt> operator will generate a <tt>Query</tt> bound to a new <tt>OrQuery</tt>; and the <tt>~</tt> operator will generate a <tt>Query</tt> bound to a new <tt>NotQuery</tt>. We'll give <tt>Query</tt> a constructor that takes a <tt>string</tt>. This constructor will generate a new <tt>WordQuery</tt>.</p>
<p class="docText">The <tt>Query</tt> class will provide the same operations as the <tt>Query_base</tt> classes: <tt>eval</tt> to evaluate the associated query, and <tt>display</tt> to print the query. It will define an overloaded output operator to display the associated query.</p>
<a name="ch15table01"></a><P><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 15.1. Query Program Design: A Recap</H5></caption><colgroup><col width="100"><col width="425"></colgroup><thead></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>TextQuery</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Class that reads a specified file and builds an associated lookup map. That class provides a <tt>query_text</tt> operation that takes a <tt>string</tt> argument and returns a <tt>set</tt> of line numbers on which the argument appears.</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>Query_base</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Abstract base class for the query classes.</P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>Query</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Use-counted handle class, which points to an object of a type derived from <tt>Query_base</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>WordQuery</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Class derived from <tt>Query_base</tt> that looks for a given word.</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>NotQuery</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Class derived from <tt>Query_base</tt> that returns the set of lines in which its <tt>Query</tt> operand does not appear.</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>BinaryQuery</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Abstract base type derived from <tt>Query_base</tt> that represents queries with two <tt>Query</tt> operands.</P></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>OrQuery</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Class derived from <tt>BinaryQuery</tt> that returns the union of the line numbers in which its two operands appear.</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>AndQuery</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Class derived from <tt>BinaryQuery</tt> that returns the intersection of the line numbers in which its two operands appear.</P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>q1 &amp; q2</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns a <tt>Query</tt> bound to a new <tt>AndQuery</tt> object that holds <tt>q1</tt> and <tt>q2</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>q1 | q2</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns a <tt>Query</tt> bound to a new <tt>OrQuery</tt> object that holds <tt>q1</tt> and <tt>q2</tt>.</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>~q</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Returns a <tt>Query</tt> bound to a new <tt>NotQuery</tt> object that holds <tt>q</tt>.</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>Query q(s)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Binds the <tt>Query q</tt> to a new <tt>WordQuery</tt> that holds the <tt>string s</tt>.</P></td></TR></table></P><br>
<a name="ch15lev3sec43"></a>
<h5 class="docSection3Title">Our Design: A Recap</h5>
<a name="ch15note30"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> It is often the case, especially when new to designing object-oriented systems, that understanding the design is the hardest part. Once we're comfortable with the design, the implementation flows naturally.</p></TD></tr></table><br>
</P></div><br>
<p class="docText">It is important to realize that much of the work in this application consists of building objects to represent the user's query. As illustrated in <a class="docLink" href="#ch15fig04">Figure 15.4</a> on the following page, an expression such as</p>
<a name="ch15fig04"></a><P><center>
<h5 class="docFigureTitle">Figure 15.4. Objects Created by <tt>Query</tt> Expressions</H5>

<p class="docText">
<img border="0" alt="" width="481" height="227" SRC="images/0201721481/graphics/15fig04.gif;400478"></p>

</center></p><br>
<pre>
     Query q = Query("fiery") &amp; Query("bird") | Query("wind");
</pre><br>
<p class="docText">generates ten objects: five <tt>Query_base</tt> objects and their associated handles. The five <tt>Query_base</tt> objects are three <tt>WordQuery</tt>s, an <tt>OrQuery</tt>, and an <tt>AndQuery</tt>.</p>
<p class="docText">Once the tree of objects is built up, evaluating (or displaying) a given query is basically a process (managed for us by the compiler) of following these links, asking each object in the tree to evaluate (or display) itself. For example, if we call <tt>eval</tt> on <tt>q</tt> (i.e., on the root of this tree), then <tt>eval</tt> will ask the <tt>OrQuery</tt> to which it points to <tt>eval</tt> itself. Evaluating this <tt>OrQuery</tt> calls <tt>eval</tt> on its two operands, which in turn calls <tt>eval</tt> on the <tt>AndQuery</tt> and <tt>WordQuery</tt> that looks for the word <tt>wind</tt>, and so on.</p>
<pre>
     <span class="docEmphasis">Objects Created by the Expression</span>
     Query("fiery") &amp; Query("bird") | Query("wind");
</pre><br>
<a name="ch15sb22"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 15.9.2</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch15qa15q1"></a><b>Exercise 15.39:</b></TD><td><p class="docText"><a name="idd1e121447"></a>Given that <tt>s1, s2, s3</tt> and <tt>s4</tt> are all <tt>string</tt>s, determine what objects are created in the following uses of the <tt>Query</tt> class:</p>
<pre>
     (a) Query(s1) | Query(s2) &amp; ~ Query(s3);
     (b) Query(s1) | (Query(s2) &amp; ~ Query(s3));
     (c) (Query(s1) &amp; (Query(s2)) | (Query(s3) &amp; Query(s4)));
</pre><BR>
</TD></tr></table></p>
</blockquote>
</td></tr></table></p><BR>


<a name="ch15lev2sec26"></a>
<h4 class="docSection2Title">15.9.3. The <tt>Query_base</tt> Class</H4>
<p class="docText">Now that we've explained our design, we'll start our implementation by defining the <tt>Query_base</tt> class:</P>
<pre>
     // <span class="docEmphItalicAlt">private, abstract class acts as a base class for concrete query types</span>
     class Query_base {
         friend class Query;
     protected:
         typedef TextQuery::line_no line_no;
         virtual ~Query_base() { }
     private:
         // <span class="docEmphasis">eval</span> <span class="docEmphItalicAlt">returns the |set| of lines that this Query matches</span>
         virtual std::set&lt;line_no&gt;
             eval(const TextQuery&amp;) const = 0;
         // <span class="docEmphasis">display</span> <span class="docEmphItalicAlt">prints the query</span>
         virtual std::ostream&amp;
             display(std::ostream&amp; = std::cout) const = 0;
     };
</pre><br>
<p class="docText"><a name="idd1e121517"></a>The class defines two interface members: <tt>eval</tt> and <tt>display</tt>. Both are pure <tt>virtual</tt> functions (<a class="docLink" href="ch15lev1sec6.html#ch15lev1sec6">Section 15.6</a>, p. <a class="docLink" href="ch15lev1sec6.html#ch15lev1sec6">595</a>), which makes this class abstract. There will be no objects of type <tt>Query_base</tt> in our applications.</p>
<p class="docText">Users and the derived classes will use the <tt>Query_base</tt> class only through the <tt>Query</tt> handle. Therefore, we made our <tt>Query_base</tt> interface <tt>private</tt>. The (<tt>virtual</tt>) destructor (<a class="docLink" href="ch15lev1sec4.html#ch15lev2sec15">Section 15.4.4</a>, p. <a class="docLink" href="ch15lev1sec4.html#ch15lev2sec15">587</a>) and the typedef are <tt>protected</tt> so that the derived types can access these members. The destructor is used (implicitly) by the derived-class destructors and so must be accessible to them.</p>
<p class="docText">We grant friendship to the <tt>Query</tt> handle class. Members of that class will call the virtuals in <tt>Query_base</tt> and so must have access to them.</P>

<a name="ch15lev2sec27"></a>
<H4 class="docSection2Title">15.9.4. The <tt>Query</tt> Handle Class</h4>
<p class="docText">Our <tt>Query</tt> handle will be similar to the <tt>Sales_item</tt> class in that it will hold a pointer to the <tt>Query_base</tt> and a pointer to a use count. As in the <tt>Sales_item</tt> class, the copy-control members of <tt>Query</tt> will manage the use count and the <tt>Query_base</tt> pointer.</p>
<p class="docText">Unlike the <tt>Sales_item</tt> class, <tt>Query</tt> will provide the only interface to the <tt>Query_base</tt> hierarchy. Users will not directly access any of the members of <tt>Query_base</tt> or its derived classes. This design decision leads to two differences between <tt>Query</tt> and <tt>Sales_item</tt>. The first is that the <tt>Query</tt> class won't define overloaded versions of dereference and arrow operators. The <tt>Query_base</tt> class has no <tt>public</tt> members. If the <tt>Query</tt> handle defined the dereference or arrow operators, they would be of no use! Any attempt to use those operators to access a <tt>Query_base</tt> member would fail. Instead, <tt>Query</tt> must define its own versions of the <tt>Query_base</tt> interface functions <tt>eval</tt> and <tt>display</tt>.</p>
<p class="docText">The other difference results from how we intend objects of the hierarchy to be created. Our design says that objects derived from <tt>Query_base</tt> will be created only through operations on the <tt>Query</tt> handle. This difference results in different constructors being required for the <tt>Query</tt> class than were used in the <tt>Sales_item</tt> handle.</p>
<a name="ch15lev3sec44"></a>
<H5 class="docSection3Title">The <tt>Query</tt> Class</h5>
<p class="docText">Given the preceeding design, the <tt>Query</tt> class itself is quite simple:</p>
<pre>
     // <span class="docEmphItalicAlt">handle class to manage the</span> <span class="docEmphasis">Query_base</span> <span class="docEmphItalicAlt">inheritance hierarchy</span>
     class Query {
         // <span class="docEmphItalicAlt">these operators need access to the</span> <span class="docEmphasis">Query_base*</span> <span class="docEmphItalicAlt">constructor</span>
         friend Query operator~(const Query &amp;);
         friend Query operator|(const Query&amp;, const Query&amp;);
         friend Query operator&amp;(const Query&amp;, const Query&amp;);
     public:
         Query(const std::string&amp;); // <span class="docEmphItalicAlt">builds a new</span> <span class="docEmphasis">WordQuery</span>
         // <span class="docEmphItalicAlt">copy control to manage pointers and use counting</span>
         Query(const Query &amp;c): q(c.q), use(c.use) { ++*use; }
         ~Query() { decr_use(); }
         Query&amp; operator=(const Query&amp;);
     // <span class="docEmphItalicAlt">interface functions: will call corresponding</span> <span class="docEmphasis">Query_base</span> <span class="docEmphItalicAlt">operations</span>
     std::set&lt;TextQuery::line_no&gt;
       eval(const TextQuery &amp;t) const { return q-&gt;eval(t); }
     std::ostream &amp;display(std::ostream &amp;os) const
                             { return q-&gt;display(os); }
     private:
         Query(Query_base *query): q(query),
                                   use(new std::size_t(1)) { }
         Query_base *q;
         std::size_t *use;
         void decr_use()
         { if (--*use == 0) { delete q; delete use; } }
     };
</pre><BR>
<p class="docText"><a name="idd1e121731"></a><a name="idd1e121741"></a><a name="idd1e121751"></a>We start by naming as friends the operators that create <tt>Query</tt> objects. We'll see shortly why these operators need to be friends.</p>
<p class="docText">In the <tt>public</tt> interface for <tt>Query</tt>, we declare, but cannot yet define, the constructor that takes a <tt>string</tt>. That constructor creates a <tt>WordQuery</tt> object, so we cannot define the constructor until we have defined the <tt>WordQuery</tt> class.</p>
<p class="docText">The next three members handle copy control and are the same as the corresponding members of the <tt>Sales_item</tt> class.</P>
<p class="docText">The last two <tt>public</tt> members represent the interface for <tt>Query_base</tt>. In each case, the <tt>Query</tt> operation uses its <tt>Query_base</tt> pointer to call the respective <tt>Query_base</tt> operation. These operations are virtual. The actual version that is called is determined at run time and will depend on the type of the object to which <tt>q</tt> points.</p>
<p class="docText">The <tt>private</tt> implementation of <tt>Query</tt> includes a constructor that takes a pointer to a <tt>Query_base</tt> object. This constructor stores in <tt>q</tt> the pointer it is given and allocates a new use counter, which it initializes to one. This constructor is <tt>private</tt> because we don't intend general user code to define <tt>Query_base</tt> objects. Instead, the constructor is needed for the operators that create <tt>Query</tt> objects. Because the constructor is <tt>private</tt>, the operators had to be made friends.</P>

<a name="ch15lev3sec45"></a>
<h5 class="docSection3Title">The <tt>Query</tt> Overloaded Operators</h5>
<p class="docText">The <tt>|, &amp;</tt> and <tt>~</tt> operators create <tt>OrQuery, AndQuery</tt>, and <tt>NotQuery</tt> objects, respectively:</p>
<pre>
     inline Query operator&amp;(const Query &amp;lhs, const Query &amp;rhs)
     {
         return new AndQuery(lhs, rhs);
     }
     inline Query operator|(const Query &amp;lhs, const Query &amp;rhs)
     {
          return new OrQuery(lhs, rhs);
     }
     inline Query operator~(const Query &amp;oper)
     {
         return new NotQuery(oper);
     }
</pre><br>
<p class="docText"><a name="idd1e121869"></a><a name="idd1e121874"></a><a name="idd1e121879"></a><a name="idd1e121887"></a>Each of these operations dynamically allocates a new object of a type derived from <tt>Query_base</tt>. The <tt>return</tt> (implicitly) uses the <tt>Query</tt> constructor that takes a pointer to a <tt>Query_base</tt> to create the <tt>Query</tt> object from the <tt>Query_base</tt> pointer that the operation allocates. For example the <tt>return</tt> statement in the <tt>~</tt> operator is equivalent to</p>
<pre>
     // <span class="docEmphItalicAlt">allocate a new</span> <span class="docEmphasis">Not Query</span> <span class="docEmphItalicAlt">object</span>
     // <span class="docEmphItalicAlt">convert the resulting pointer to</span> <span class="docEmphasis">NotQuery</span> <span class="docEmphItalicAlt">to a pointer to</span> <span class="docEmphasis">Query_base</span>
     Query_base *tmp = new NotQuery(expr);

     return Query(tmp); // <span class="docEmphasis">use Query constructor that takes a pointer to Query_base</span>
</pre><br>
<p class="docText">There is no operator to create a <tt>WordQuery</tt>. Instead, we gave our <tt>Query</tt> class a constructor that takes a <tt>string</tt>. That constructor generates a <tt>WordQuery</tt> to look for the given <tt>string</tt>.</p>

<a name="ch15lev3sec46"></a>
<h5 class="docSection3Title">The <tt>Query</tt> Output Operator</h5>
<p class="docText">We'd like users to be able to print <tt>Query</tt>s using the normal (overloaded) output operator. However, we also need the print operation to be virtualprinting a <tt>Query</tt> should print the <tt>Query_base</tt> object to which the <tt>Query</tt> points. There's only one problem: only member functions can be virtual, but the output operator cannot be a member of the <tt>Query_base</tt> classes (<a class="docLink" href="ch14lev1sec2.html#ch14lev2sec9">Section 14.2.1</a>, p. <a class="docLink" href="ch14lev1sec2.html#ch14lev2sec9">514</a>).</p>
<p class="docText">To obtain the necessary virtual behavior, our <tt>Query_base</tt> classes defined a virtual <tt>display</tt> member, which the <tt>Query</tt> output operator will use:</p>
<pre>
     inline std::ostream&amp;
     operator&lt;&lt;(std::ostream &amp;os, const Query &amp;q)
     {
         return q.display(os);
     }
</pre><br>
<p class="docText">When we write</p>
<pre>
     Query andq = Query(sought1) &amp; Query(sought2);
     cout &lt;&lt; "\nExecuted query: " &lt;&lt; andq &lt;&lt; endl;
</pre><BR>
<p class="docText">the Query output operator is invoked. That operator calls</P>
<pre>
     q.display(os)
</pre><br>
<p class="docText">with q referring to the Query object that points to this AndQuery, an dos bound to cout. When we write</P>
<pre>
     Query name(sought);
     cout &lt;&lt; "\nExecuted Query for: " &lt;&lt; name &lt;&lt; endl;
</pre><br>
<p class="docText">the <tt>WordQuery</tt> instance of <tt>display</tt> is called. More generally, a call</p>
<pre>
     Query query = some_query;
     cout &lt;&lt; query &lt;&lt; endl;
</pre><BR>
<p class="docText">invokes the instance of <tt>display</tt> associated with the object that <tt>query</tt> addresses at that point in the execution of our program.</P>


<a name="ch15lev2sec28"></a>
<h4 class="docSection2Title">15.9.5. The Derived Classes</h4>
<p class="docText"><a name="idd1e122077"></a><a name="idd1e122083"></a>We next need to implement our concrete query classes. The one interesting part about these classes is how they are represented. The <tt>WordQuery</tt> class is most straightforward. Its job is to hold the search word.</p>
<p class="docText">The other classes operate on one or two <tt>Query</tt> operands. A <tt>NotQuery</tt> negates the result of another <tt>Query</tt>. Both <tt>AndQuery</tt> and <tt>OrQuery</tt> have two operands, which are actually stored in their common base class, <tt>BinaryQuery</tt>.</p>
<p class="docText">In each of these classes, the operand(s) could be an object of any of the concrete <tt>Query_base</tt> classes: A <tt>NotQuery</tt> could be applied to a <tt>WordQuery</tt>, an <tt>AndQuery</tt>, an <tt>OrQuery</tt>, or another <tt>NotQuery</tt>. To allow this flexibility, the operands must be stored as pointers to <tt>Query_base</tt> that might point to any one of the concrete <tt>Query_base</tt> classes.</p>
<p class="docText">However, rather than storing a <tt>Query_base</tt> pointer, our classes will themselves use the <tt>Query</tt> handle. Just as user code is simplified by using a handle, we can simplify our own class code by using the same handle class. We'll make the <tt>Query</tt> operand <tt>const</tt> because once a given <tt>Query_base</tt> object is built, there are no operations that can change the operand(s).</P>
<p class="docText">Now that we know the design for these classes, we can implement them.</p>
<a name="ch15lev3sec47"></a>
<H5 class="docSection3Title">The <tt>WordQuery</tt> Class</H5>
<p class="docText">A <tt>WordQuery</tt> is a kind of <tt>Query_base</tt> that looks for a specified word in a given query map:</p>
<pre>
     class WordQuery: public Query_base {
         friend class Query; // <span class="docEmphasis">Query</span> <span class="docEmphItalicAlt">uses the</span> <span class="docEmphasis">WordQuery</span> <span class="docEmphItalicAlt">constructor</span>
         WordQuery(const std::string &amp;s): query_word(s) { }
         // <span class="docEmphasis">concrete class: WordQuery defines all inherited pure virtual functions</span>
         std::set&lt;line_no&gt; eval(const TextQuery &amp;t) const
                                 { return t.run_query(query_word); }
         std::ostream&amp; display (std::ostream &amp;os) const
                                   { return os &lt;&lt; query_word; }
         std::string query_word; // <span class="docEmphItalicAlt">word for which to search</span>
      };
</pre><br>
<p class="docText">Like <tt>Query_base, WordQuery</tt> has no <tt>public</tt> members; <tt>WordQuery</tt> must make <tt>Query</tt> a friend to allow <tt>Query</tt> to access the <tt>WordQuery</tt> constructor.</p>
<p class="docText">Each of the concrete query classes must define the inherited pure virtual functions. The <tt>WordQuery</tt> operations are simple enough to define in the class body. The <tt>eval</tt> member calls the <tt>query_text</tt> member of its <tt>TextQuery</tt> parameter passing it the <tt>string</tt> that was used to create this <tt>WordQuery</tt>. To <tt>display</tt> a <tt>WordQuery</tt>, we print the <tt>query_word</tt>.</P>

<a name="ch15lev3sec48"></a>
<H5 class="docSection3Title">The <tt>NotQuery</tt> Class</h5>
<p class="docText">A <tt>NotQuery</tt> holds a <tt>const Query</tt>, which it negates:</p>
<pre>
     class NotQuery: public Query_base {
         friend Query operator~(const Query &amp;);
         NotQuery(Query q): query(q) { }
          // <span class="docEmphItalicAlt">concrete class:</span> <span class="docEmphasis">NotQuery</span> <span class="docEmphItalicAlt">defines all inherited pure virtual functions</span>
          std::set&lt;line_no&gt; eval(const TextQuery&amp;) const;
          std::ostream&amp; display(std::ostream &amp;os) const
                { return os &lt;&lt; "~(" &lt;&lt; query &lt;&lt; ")"; }
          const Query query;
     };
</pre><br>
<p class="docText"><a name="idd1e122289"></a>The <tt>Query</tt> overloaded <tt>~</tt> operator is made a friend to allow that operator to create a new <tt>NotQuery</tt> object. To <tt>display</tt> a <tt>NotQuery</tt>, we print the <tt>~</tt> symbol followed by the underlying <tt>Query</tt>. We parenthesize the output to ensure that precedence is clear to the reader.</p>
<a name="ch15note31"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><td valign="top"><p class="docText"> The use of the output operator in the <tt>display</tt> operation is ultimately a virtual call to a <tt>Query_base</tt> object:</p></TD></tr></table><BR>
<pre>
     // <span class="docEmphItalicAlt">uses the</span> <span class="docEmphasis">Query</span> <span class="docEmphItalicAlt">output operator, which calls</span> <span class="docEmphasis">Query::display</span>
     // <span class="docEmphItalicAlt">that funtion makes a</span> <span class="docEmphasis">virtual</span> <span class="docEmphItalicAlt">call to</span> <span class="docEmphasis">Query_base::display</span>
     { return os &lt;&lt; "~(" &lt;&lt; query &lt;&lt; ")"
</pre><br>
</p></div><br>
<p class="docText">The <tt>eval</tt> member is complicated enough that we will implement it outside the class body. The <tt>eval</tt> function appears in <a class="docLink" href="#ch15lev2sec29">Section 15.9.6</a> (p. <a class="docLink" href="#ch15lev2sec29">620</a>).</p>

<a name="ch15lev3sec49"></a>
<h5 class="docSection3Title">The <tt>BinaryQuery</tt> Class</h5>
<p class="docText">The <tt>BinaryQuery</tt> class is an abstract class that holds the data needed by the two query types, <tt>AndQuery</tt> and <tt>OrQuery</tt>, that operate on two operands:</p>
<pre>
     class BinaryQuery: public Query_base {
     protected:
         BinaryQuery(Query left, Query right, std::string op):
               lhs(left), rhs(right), oper(op) { }
         // <span class="docEmphItalicAlt">abstract class:</span> <span class="docEmphasis">BinaryQuery</span> <span class="docEmphItalicAlt">doesn't define</span> <span class="docEmphasis">eval</span>
         std::ostream&amp; display(std::ostream &amp;os) const
         { return os &lt;&lt; "(" &lt;&lt; lhs &lt;&lt; " " &lt;&lt; oper &lt;&lt; " "
                                  &lt;&lt; rhs &lt;&lt; ")"; }
         const Query lhs, rhs; // <span class="docEmphItalicAlt">right- and left-hand operands</span>
         const std::string oper; // <span class="docEmphItalicAlt">name of the operator</span>
      };
</pre><br>
<p class="docText">The data in a <tt>BinaryQuery</tt> are the two <tt>Query</tt> operands and the operator symbol to use when displaying the query. These data are all declared <tt>const</tt>, because the contents of a query should not change once it has been constructed. The constructor takes the two operands and the operator symbol, which it stores in the appropriate data members.</p>
<p class="docText">To <tt>display</tt> a <tt>BinaryOperator</tt>, we print the parenthesized expression consisting of the left-hand operand, followed by the operator, followed by the right-hand operand. As when we displayed a <tt>NotQuery</tt>, the overloaded <tt>&lt;&lt;</tt> operator that is used to print <tt>left</tt> and <tt>right</tt> ultimately makes a virtual call to the underlying <tt>Query_base display</tt>.</p>
<a name="ch15note32"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><TD valign="top"><p class="docText"><a name="idd1e122463"></a><a name="idd1e122469"></a> The <tt>BinaryQuery</tt> class does not define the <tt>eval</tt> function and so inherits a pure virtual. As such, <tt>BinaryQuery</tt> is also an abstract class, and we cannot create objects of <tt>BinaryQuery</tt> type.</p></TD></tr></table><br>
</P></div><BR>

<a name="ch15lev3sec50"></a>
<h5 class="docSection3Title">The <tt>AndQuery</tt> and <tt>OrQuery</tt> Classes</h5>
<p class="docText">The <tt>AndQuery</tt> and <tt>OrQuery</tt> classes are nearly identical:</p>
<pre>
     class AndQuery: public BinaryQuery {
         friend Query operator&amp;(const Query&amp;, const Query&amp;);
         AndQuery (Query left, Query right):
                               BinaryQuery(left, right, "&amp;") { }
         // <span class="docEmphItalicAlt">concrete class:</span> <span class="docEmphasis">And Query</span> <span class="docEmphItalicAlt">inherits</span> <span class="docEmphasis">display</span> <span class="docEmphItalicAlt">and defines remaining pure virtual</span>
         std::set&lt;line_no&gt; eval(const TextQuery&amp;) const;
     };
         class OrQuery: public BinaryQuery {
             friend Query operator|(const Query&amp;, const Query&amp;);
             OrQuery(Query left, Query right):
                         BinaryQuery(left, right, "|") { }
             // <span class="docEmphItalicAlt">concrete class:</span> <span class="docEmphasis">OrQuery</span> <span class="docEmphItalicAlt">inherits</span> <span class="docEmphasis">display</span> <span class="docEmphItalicAlt">and defines remaining pure virtual</span>
             std::set&lt;line_no&gt; eval(const TextQuery&amp;) const;
     };
</pre><br>
<p class="docText">These classes make the respective operator a friend and define a constructor to create their <tt>BinaryQuery</tt> base part with the appropriate operator. They inherit the <tt>BinaryQuery</tt> definition of <tt>display</tt>, but each defines its own version of the <tt>eval</tt> function.</p>
<a name="ch15sb23"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<H2 class="docSidebarTitle">Exercises Section 15.9.5</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch15qa16q1"></a><B>Exercise 15.40:</b></td><td><p class="docText">For the expression built in <a class="docLink" href="#ch15fig04">Figure 15.4</a> (p. <a class="docLink" href="#ch15fig04">612</a>)</p>
<div style="font-weight:bold"><ol class="docList" type="a"><li><div style="font-weight:normal"><p class="docList">List the constructors executed in processing this expression.</P></div></li><li><div style="font-weight:normal"><p class="docList">List the calls to <tt>display</tt> and to the overloaded <tt>&lt;&lt;</tt> operator that are made in executing <tt>cout &lt;&lt; q</tt>.</P></div></li><li><div style="font-weight:normal"><p class="docList">List the calls to <tt>eval</tt> made when evaluating <tt>q.eval</tt>.</P></div></li></ol></div>
</TD></tr></table></p>
</blockquote>
</td></tr></table></p><br>


<a name="ch15lev2sec29"></a>
<h4 class="docSection2Title">15.9.6. The <tt>eval</tt> Functions</h4>
<p class="docText">The heart of the query class hierarchy are the <tt>eval</tt> virtual functions. Each of these functions calls <tt>eval</tt> on its operand(s) and then applies its own logic: The <tt>AndQuery eval</tt> operation returns the union of the results of its two operands; <tt>OrQuery</tt> returns the intersection. The <tt>NotQuery</tt> is more complicated: It must return the line numbers not in its operand's set.</p>
<a name="ch15lev3sec51"></a>
<h5 class="docSection3Title"><tt>OrQuery::eval</tt></h5>
<p class="docText"><a name="idd1e122662"></a><a name="idd1e122670"></a><a name="idd1e122678"></a>An <tt>OrQuery</tt> merges the set of line numbers returned by its two operandsits result is the union of the results for its two operands:</p>
<pre>
     // <span class="docEmphItalicAlt">returns union of its operands' result sets</span>
     set&lt;TextQuery::line_no&gt;
     OrQuery::eval(const TextQuery&amp; file) const
     {
             // <span class="docEmphItalicAlt">virtual calls through the</span> <span class="docEmphasis">Query</span> <span class="docEmphItalicAlt">handle to get result sets for the operands</span>
             set&lt;line_no&gt; right = rhs.eval(file),
                         ret_lines = lhs.eval(file); // <span class="docEmphItalicAlt">destination to hold results</span>
             // <span class="docEmphItalicAlt">inserts the lines from</span> <span class="docEmphasis">right</span> <span class="docEmphItalicAlt">that aren't already in</span> <span class="docEmphasis">ret_lines</span>
             ret_lines.insert(right.begin(), right.end());

             return ret_lines;
     }
</pre><br>
<p class="docText">The <tt>eval</tt> function starts by calling <tt>eval</tt> on each of its <tt>Query</tt> operands. Those calls call <tt>Query::eval</tt>, which in turn makes a virtual call to <tt>eval</tt> on the underlying <tt>Query_base</tt> object. Each of these calls yields a <tt>set</tt> of line numbers in which its operand appears. We then call <tt>insert</tt> on <tt>ret_lines</tt>, passing a pair of iterators denoting the <tt>set</tt> returned from evaluating the right-hand operand. Because <tt>ret_lines</tt> is a <tt>set</tt>, this call adds the elements from <tt>right</tt> that are not also in <tt>left</tt> into <tt>ret_lines</tt>. After the call to <tt>insert, ret_lines</tt> contains each line number that was in either of the <tt>left</tt> or <tt>right</tt> sets. We complete the function by returning <tt>ret_lines</tt>.</P>

<a name="ch15lev3sec52"></a>
<H5 class="docSection3Title"><tt>AndQuery::eval</tt></h5>
<p class="docText">The <tt>AndQuery</tt> version of <tt>eval</tt> uses one of the library algorithms that performs setlike operations. These algorithms are described in the Library Appendix, in <a class="docLink" href="app01lev1sec2.html#app01lev2sec8">Section A.2.8</a> (p. <a class="docLink" href="app01lev1sec2.html#app01lev2sec8">821</a>):</P>
<pre>
     // <span class="docEmphItalicAlt">returns intersection of its operands' result sets</span>
     set&lt;TextQuery::line_no&gt;
     AndQuery::eval(const TextQuery&amp; file) const
     {
          // <span class="docEmphItalicAlt">virtual calls through the</span> <span class="docEmphasis">Query</span> <span class="docEmphItalicAlt">handle to get result sets for the operands</span>
          set&lt;line_no&gt; left = lhs.eval(file),
                             right = rhs.eval(file);
          set&lt;line_no&gt; ret_lines; // <span class="docEmphItalicAlt">destination to hold results</span>
          // <span class="docEmphItalicAlt">writes intersection of two ranges to a destination iterator</span>
          // <span class="docEmphItalicAlt">destination iterator in this call adds elements to</span> <span class="docEmphItalicAlt">ret</span>
          set_intersection(left.begin(), left.end(),
                        right.begin(), right.end(),
                        inserter(ret_lines, ret_lines.begin()));
          return ret_lines;
     }
</pre><br>
<p class="docText">This version of <tt>eval</tt> uses the <tt>set_intersection</tt> algorithm to find the lines in common to both queries: That algorithm takes five iterators: The first four denote <a name="idd1e122841"></a>two input ranges, and the last denotes a destination. The algorithm writes each element that is in both of the two input ranges into the destination. The destination in this call is an insert iterator (<a class="docLink" href="ch11lev1sec3.html#ch11lev2sec7">Section 11.3.1</a>, p. <a class="docLink" href="ch11lev1sec3.html#ch11lev2sec7">406</a>) which inserts new elements into <tt>ret_lines</tt>.</p>

<a name="ch15lev3sec53"></a>
<H5 class="docSection3Title"><tt>NotQuery::eval</tt></H5>
<p class="docText"><tt>NotQuery</tt> finds each line of the text within which the operand is not found. To support this function, we need the <tt>TextQuery</tt> class to add a member to return the size of the file, so that we can know what line numbers exist.</p>
<pre>
     // <span class="docEmphItalicAlt">returns lines not in its operand's result set</span>
     set&lt;TextQuery::line_no&gt;
     NotQuery::eval(const TextQuery&amp; file) const
     {
          // <span class="docEmphItalicAlt">virtual call through the</span> <span class="docEmphasis">Query</span> <span class="docEmphItalicAlt">handle to</span> <span class="docEmphasis">eval</span>
          set&lt;TextQuery::line_no&gt; has_val = query.eval(file);
          set&lt;line_no&gt; ret_lines;
          // <span class="docEmphItalicAlt">for each line in the input file, check whether that line is in</span> <span class="docEmphasis">has_val</span>
         // <span class="docEmphItalicAlt">if not, add that line number to</span> <span class="docEmphasis">ret_lines</span>
         for (TextQuery::line_no n = 0; n != file.size(); ++n)
             if (has_val.find(n) == has_val.end())
                 ret_lines.insert(n);
         return ret_lines;
     }
</pre><br>
<p class="docText">As in the other <tt>eval</tt> functions, we start by calling <tt>eval</tt> on this object's operand. That call returns the <tt>set</tt> of line numbers on which the operand appears. What we want is the <tt>set</tt> of line numbers on which the operand does not appear. We obtain that <tt>set</tt> by looking at each line number in the input file. We use the <tt>size</tt> member that must be added to <tt>TextQuery</tt> to control the <tt>for</tt> loop. That loop adds each line number to <tt>ret_lines</tt> that does not appear in <tt>has_val</tt>. Once we've processed all the line numbers, we return <tt>ret_lines</tt>.</p>
<a name="ch15sb24"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Exercises Section 15.9.6</H2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa18q2"></a><b>Exercise 15.41:</b></TD><TD><p class="docText">Implement the <tt>Query</tt> and <tt>Query_base</tt> classes, and add the needed <tt>size</tt> operation to the <tt>TextQuery</tt> class from <a class="docLink" href="ch10.html#ch10">Chapter 10</a>. Test your application by evaluating and printing a query such as the one in <a class="docLink" href="#ch15fig04">Figure 15.4</a> (p. <a class="docLink" href="#ch15fig04">612</a>).</p></td></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch15qa18q3"></a><b>Exercise 15.42:</b></td><TD><p class="docText">Design and implement one of the following enhancements:</p>
<div style="font-weight:bold"><ol class="docList" type="a"><li><div style="font-weight:normal"><p class="docList">Introduce support for evaluating words based on their presence within the same sentence rather than the same line.</P></div></li><LI><div style="font-weight:normal"><p class="docList">Introduce a history system in which the user can refer to a previous query by number, possibly adding to it or combining it with another.</p></div></li><li><div style="font-weight:normal"><p class="docList">Rather than displaying the count of matches and all the matching lines, allow the user to indicate a range of lines to display, both for intermediate query evaluation and the final query.</p></div></li></ol></div>
</td></tr></table></p>
</blockquote>
</td></tr></table></p><br>



<a href="21001535.html"><img src="images/pixel.gif" alt="" width="1" height="1" border="0"></a><ul></UL></TD></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch15lev1sec8.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch15lev1sec10.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>