<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 16.1.&nbsp; Template Definitions</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch16.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch16lev1sec2.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch16lev1sec1"></a>
<h3 class="docSection1Title">16.1. Template Definitions</h3>
<p class="docText">Let's imagine that we want to write a function to compare two values and indicate whether the first is less than, equal to, or greater than the second. In practice, we'd want to define several such functions, each of which could compare values of a given type. Our first attempt might be to define several overloaded functions:</P>
<pre>
     // <span class="docEmphItalicAlt">returns 0 if the values are equal</span>, <span class="docEmphasis">-1</span> <span class="docEmphItalicAlt">if</span> <span class="docEmphasis">v1</span> <span class="docEmphItalicAlt">is smaller</span>, <span class="docEmphasis">1</span> <span class="docEmphItalicAlt">if</span> <span class="docEmphasis">v2</span> <span class="docEmphItalicAlt">is smaller</span>
     int compare(const string &amp;v1, const string &amp;v2)
     {
         if (v1 &lt; v2) return -1;
         if (v2 &lt; v1) return 1;
         return 0;
     }
     int compare(const double &amp;v1, const double &amp;v2)
     {
         if (v1 &lt; v2) return -1;
         if (v2 &lt; v1) return 1;
         return 0;
     }
</pre><BR>
<p class="docText">These functions are nearly identical: The only difference between them is the type of their parameters. The function body is the same in each function.</p>
<p class="docText">Having to repeat the body of the function for each type that we compare is tedious and error-prone. More importantly, we need to know <span class="docEmphasis">in advance</span> all the types that we might ever want to <tt>compare</tt>. This strategy cannot work if we want to be able to use the function on types that we don't know about.</P>
<a name="ch16lev2sec1"></a>
<h4 class="docSection2Title">16.1.1. Defining a Function Template</h4>
<p class="docText"><a name="idd1e123771"></a><a name="idd1e123778"></a><a name="idd1e123784"></a><a name="idd1e123789"></a><a name="idd1e123792"></a><a name="idd1e123798"></a><a name="idd1e123803"></a><a name="idd1e123810"></a><a name="idd1e123815"></a><a name="idd1e123818"></a><a name="idd1e123823"></a><a name="idd1e123826"></a><a name="idd1e123831"></a><a name="idd1e123836"></a>Rather than defining a new function for each type, we can define a single <B><a name="ch16term3"></a><a class="docLink" href="ch16lev1sec9.html#gloss16_03">function template</a></b>. A function template is a type-independent function that is used as a formula for generating a type-specific version of the function. For example, we might write a function template named <tt>compare</tt>, which would tell the compiler how to generate specific versions of <tt>compare</tt> for the types that we want to compare.</P>
<p class="docText">The following is a template version of <tt>compare</tt>:</p>
<pre>
     // <span class="docEmphItalicAlt">implement</span> <span class="docEmphasis">strcmp-</span><span class="docEmphItalicAlt">like generic compare function</span>
     // <span class="docEmphItalicAlt">returns 0 if the values are equal</span>, <span class="docEmphasis">1</span> <span class="docEmphItalicAlt">if</span> <span class="docEmphasis">v1</span> <span class="docEmphItalicAlt">is larger</span>, <span class="docEmphasis">-1</span> <span class="docEmphItalicAlt">if</span> <span class="docEmphasis">v1</span> <span class="docEmphItalicAlt">is smaller</span>
     template &lt;typename T&gt;
     int compare(const T &amp;v1, const T &amp;v2)
     {
         if (v1 &lt; v2) return -1;
         if (v2 &lt; v1) return 1;
         return 0;
     }
</pre><br>
<p class="docText">A template definition starts with the keyword <tt>template</tt> followed by a <b><a name="ch16term14"></a><a class="docLink" href="ch16lev1sec9.html#gloss16_14">template parameter list</a></b>, which is a comma-separated list of one or more <b><a name="ch16term13"></a><a class="docLink" href="ch16lev1sec9.html#gloss16_13">template parameters</a></b> bracketed by the less-than (<tt>&lt;</tt>) and greater-than (<tt>&gt;</tt>) tokens.</p>
<a name="ch16note01"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><td valign="top"><p class="docText"> The template parameter list cannot be empty.</p></td></TR></table><BR>
</p></div><br>
<a name="ch16lev3sec1"></a>
<h5 class="docSection3Title">Template Parameter List</h5>
<p class="docText">The template parameter list acts much like a function parameter list. A function parameter list defines local variable(s) of a specified type but leaves those variables uninitialized. At run time, arguments are supplied that initialize the parameters.</P>
<p class="docText">Analogously, template parameters represent types or values we can use in the definition of a class or function. For example, our <tt>compare</tt> function declares one type parameter named <tt>T</tt>. Inside <tt>compare</tt>, we can use the name <tt>T</tt> to refer to a type. Which <span class="docEmphasis">actual type</span> <tt>T</tt> represents is determined by the compiler based on how the function is used.</p>
<p class="docText">A template parameter can be a <b><a name="ch16term16"></a><a class="docLink" href="ch16lev1sec9.html#gloss16_16">type parameter</a></b>, which represents a type, or a <B><a name="ch16term8"></a><a class="docLink" href="ch16lev1sec9.html#gloss16_08">nontype parameter</a></b>, which represents a constant expression. A nontype parameter is declared following a type specifier. We'll see more about nontype parameters in <a class="docLink" href="#ch16lev2sec5">Section 16.1.5</a> (p. <a class="docLink" href="#ch16lev2sec5">632</a>). A type parameter is defined following the keyword <tt>class</tt> or <tt>typename</tt>. For example, <tt>class T</tt> is a type parameter named <tt>T</tt>. There is no difference between <tt>class</tt> and <tt>typename</tt> in this context.</p>

<a name="ch16lev3sec2"></a>
<h5 class="docSection3Title">Using a Function Template</H5>
<p class="docText">When we use a function template, the compiler infers what <b><a name="ch16term11"></a><a class="docLink" href="ch16lev1sec9.html#gloss16_11">template argument(s)</a></b> to bind to the template parameter(s). Once the compiler determines the actual template argument(s), it <span class="docEmphStrong">instantiates</span> an instance of the function template for us. <a name="idd1e124001"></a><a name="idd1e124007"></a>Essentially, the compiler figures out what type to use in place of each type parameter and what value to use in place of each nontype parameter. Having deduced the actual template arguments, it generates and compiles a version of the function using those arguments in place of the corresponding template parameters. The compiler takes on the tedium of (re)writing the function for each type we use.</P>
<p class="docText">Given the calls</p>
<pre>
     int main ()
     {
         // <span class="docEmphasis">T</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">int;</span>
         // <span class="docEmphItalicAlt">compiler instantiates</span> <span class="docEmphasis">int compare(const int&amp;, const int&amp;)</span>
         cout &lt;&lt; compare(1, 0) &lt;&lt; endl;
         // <span class="docEmphasis">T</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">string;</span>
         // <span class="docEmphItalicAlt">compiler instantiates</span> <span class="docEmphasis">int compare(const string&amp;, const string&amp;)</span>
         string s1 = "hi", s2 = "world";
         cout &lt;&lt; compare(s1, s2) &lt;&lt; endl;
         return 0;
     }
</pre><br>
<p class="docText">the compiler will instantiate two different versions of <tt>compare</tt>. The compiler will create one version that replaces <tt>T</tt> by <tt>int</tt> and a second version that uses <tt>string</tt> in place of <tt>T</tt>.</p>

<a name="ch16lev3sec3"></a>
<h5 class="docSection3Title"><tt>inline</tt> Function Templates</h5>
<p class="docText">A function template can be declared <tt>inline</tt> in the same way as a nontemplate function. The specifier is placed following the template parameter list and before the return type. It is not placed in front of the <tt>template</tt> keyword.</p>
<pre>
     // <span class="docEmphItalicAlt">ok: inline specifier follows template parameter list</span>
     template &lt;typename T&gt; inline T min(const T&amp;, const T&amp;);
     // <span class="docEmphItalicAlt">error: incorrect placement of inline specifier</span>
     inline template &lt;typename T&gt; T min(const T&amp;, const T&amp;);
</pre><br>
<a name="ch16sb01"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 16.1.1</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch16qa1q1"></a><b>Exercise 16.1:</b></TD><td><p class="docText">Write a template that returns the absolute value of its parameter. Call the template on values of at least three different types. Note: until we discuss how the compiler handles template <span class="docEmphRoman"><a name="ch16term6"></a><a class="docLink" href="ch16lev1sec9.html#gloss16_06">instantiation</a></span> in <a class="docLink" href="ch16lev1sec3.html#ch16lev1sec3">Section 16.3</a> (p. <a class="docLink" href="ch16lev1sec3.html#ch16lev1sec3">643</a>), you should put each template definition and all uses of that template in the same file.</p>
</TD></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa1q2"></a><b>Exercise 16.2:</b></td><td><p class="docText">Write a function template that takes a reference to an <tt>ostream</tt> and a value, and writes the value to the stream. Call the function on at least four different types. Test your program by writing to <tt>cout</tt>, to a file, and to a <tt>stringstream</tt>.</P>
</td></TR><TR valign="top"><td align="right" class="docText" width="50"><a name="ch16qa1q3"></a><b>Exercise 16.3:</b></td><TD><p class="docText">When we called <tt>compare</tt> on two <tt>string</tt>s, we passed two <tt>string</tt> objects, which we initialized from string literals. What would happen if we wrote:</P>
<pre>
     compare ("hi", "world");
</pre><br>
</td></tr></table></p>
</blockquote>
</TD></tr></table></p><BR>


<a name="ch16lev2sec2"></a>
<h4 class="docSection2Title">16.1.2. Defining a Class Template</h4>
<p class="docText"><a name="idd1e124186"></a><a name="idd1e124189"></a><a name="idd1e124194"></a><a name="idd1e124199"></a><a name="idd1e124205"></a>Just as we can define function templates, we can also define class templates.</P>
<a name="ch16note02"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> To illustrate class templates, we'll implement our own version of the standard library <tt>queue</tt> (<a class="docLink" href="ch09lev1sec7.html#ch09lev1sec7">Section 9.7</a>, p. <a class="docLink" href="ch09lev1sec7.html#ch09lev1sec7">348</a>) class. User programs ought to use the standard <tt>queue</tt> class, not the one we define here.</p></td></tr></table><br>
</p></div><br>
<p class="docText">Our <tt>Queue</tt> must be able to hold objects of different types, so we'll define it as a <b><a name="ch16term1"></a><a class="docLink" href="ch16lev1sec9.html#gloss16_01">class template</a></b>. The operations our <tt>Queue</tt> will support are a subset of the interface of the standard <tt>queue</tt>:</p>
<ul><li><p class="docList"><tt>push</tt> to add an item to the back of the queue</P></LI><li><p class="docList"><tt>pop</tt> to remove the item at the head of the queue</P></li><li><p class="docList"><tt>front</tt> to return a reference to the element at the head of the queue</P></LI><li><p class="docList"><tt>empty</tt> to indicate whether there are any elements in the queue</p></li></ul>
<p class="docText">We'll look at how we might implement our <tt>Queue</tt> in <a class="docLink" href="ch16lev1sec4.html#ch16lev1sec4">Section 16.4</a> (p. <a class="docLink" href="ch16lev1sec4.html#ch16lev1sec4">647</a>), but we can start by defining its interface:</p>
<pre>
     template &lt;class Type&gt; class Queue {
     public:
         Queue ();                // <span class="docEmphItalicAlt">default constructor</span>
         Type &amp;front ();          // <span class="docEmphItalicAlt">return element from head of</span> <span class="docEmphasis">Queue</span>
         const Type &amp;front () const;
         void push (const Type &amp;); // <span class="docEmphItalicAlt">add element to back of</span> <span class="docEmphasis">Queue</span>
         void pop();              // <span class="docEmphItalicAlt">remove element from head of</span> <span class="docEmphasis">Queue</span>
         bool empty() const;      // <span class="docEmphItalicAlt">true if no elements in the</span> <span class="docEmphasis">Queue</span>
     private:
         // ...
     };
</pre><BR>
<p class="docText">A class template is a template, so it must begin with the keyword <tt>template</tt> followed by a template parameter list. Our <tt>Queue</tt> template takes a single template type parameter named <tt>Type</tt>.</p>
<p class="docText">With the exception of the template parameter list, the definition of a class template looks like any other class. A class template may define data, function, and type members; it may use access labels to control access to those members; it defines constructors and destructors; and so on. In the definition of the class and its members, we can use the template parameters as stand-ins for types or values that will be supplied when the class is used.</P>
<p class="docText">For example, our <tt>Queue</tt> template has one template type parameter. We can use that parameter anywhere a type name can be used. In this template definition, we use <tt>Type</tt> to name the return type from the overloaded <tt>front</tt> operations and as the parameter type for the <tt>push</tt> operation.</P>
<a name="ch16lev3sec4"></a>
<h5 class="docSection3Title">Using a Class Template</h5>
<p class="docText"><a name="idd1e124363"></a><a name="idd1e124368"></a><a name="idd1e124373"></a><a name="idd1e124376"></a><a name="idd1e124381"></a><a name="idd1e124384"></a><a name="idd1e124389"></a><a name="idd1e124394"></a><a name="idd1e124399"></a>In contrast to calling a function template, when we use a class template, we must explicitly specify arguments for the template parameters:</p>
<pre>
     Queue&lt;int&gt; qi;                 // <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">that holds</span> int<span class="docEmphasis">s</span>
     Queue&lt; vector&lt;double&gt; &gt; qc;    // <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">that holds</span> <span class="docEmphasis">vectors</span> <span class="docEmphItalicAlt">of</span> <span class="docEmphasis">double</span><span class="docEmphItalicAlt">s</span>
     Queue&lt;string&gt; qs;              // <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">that holds</span> <span class="docEmphasis">string</span><span class="docEmphItalicAlt">s</span>
</pre><BR>
<p class="docText">The compiler uses the arguments to instantiate a type-specific version of the class. Essentially, the compiler rewrites our <tt>Queue</tt> class replacing <tt>Type</tt> by the specified actual type provided by the user. In this case, the compiler will instantiate three classes: a version of <tt>Queue</tt> with <tt>Type</tt> replaced by <tt>int</tt>, a second <tt>Queue</tt> class that uses <tt>vector&lt;double&gt;</tt> in place of <tt>Type</tt>, and a third that replaces <tt>Type</tt> by <tt>string</tt>.</P>
<a name="ch16sb02"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 16.1.2</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch16qa2q4"></a><b>Exercise 16.4:</b></td><TD><p class="docText">What is a function template? What is a class template?</p>
</TD></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q5"></a><b>Exercise 16.5:</b></td><td><p class="docText">Define a function template to return the larger of two values.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q6"></a><b>Exercise 16.6:</b></td><TD><p class="docText">Similar to our a simplified version of <tt>queue</tt>, write a class template named <tt>List</tt> that is a simplified version of the standard <tt>list</tt> class.</P>
</td></TR></table></p>
</blockquote>
</td></TR></table></P><br>


<a name="ch16lev2sec3"></a>
<h4 class="docSection2Title">16.1.3. Template Parameters</h4>
<p class="docText">As with a function parameter, the name chosen by the programmer for a template parameter has no intrinsic meaning. In our example, we named <tt>compare</tt>'s template type parameter <tt>T</tt>, but we could have named it anything:</p>
<pre>
     // <span class="docEmphItalicAlt">equivalent template definition</span>
     template &lt;class Glorp&gt;
     int compare(const Glorp &amp;v1, const Glorp &amp;v2)
     {
         if (v1 &lt; v2) return -1;
         if (v2 &lt; v1) return 1;
         return 0;
     }
</pre><br>
<p class="docText">This code defines the same <tt>compare</tt> template as before.</P>
<p class="docText">The only meaning we can ascribe to a template parameter is to distinguish whether the parameter is a type parameter or a nontype parameter. If it is a type parameter, then we know that the parameter represents an as yet unknown type. If it is a nontype parameter, we know it is an as yet unknown value.</p>
<p class="docText">When we wish to use the type or value that a template parameter represents, we use the same name as the corresponding template parameter. For example, all references to <tt>Glorp</tt> in the <tt>compare</tt> function template will be resolved to the same type when the function is instantiated.</P>
<a name="ch16lev3sec5"></a>
<H5 class="docSection3Title">Template Parameter Scope</h5>
<p class="docText"><a name="idd1e124582"></a><a name="idd1e124587"></a><a name="idd1e124592"></a><a name="idd1e124597"></a><a name="idd1e124602"></a><a name="idd1e124609"></a>The name of a template parameter can be used after it has been declared as a template parameter and until the end of the template declaration or definition.</p>
<p class="docText">Template parameters follow normal name-hiding rules. A template parameter with the same name as an object, function, or type declared in global scope hides the global name:</p>
<pre>
     typedef double T;
     template &lt;class T&gt; T calc(const T &amp;a, const T &amp;b)
     {
          // <span class="docEmphasis">tmp</span> <span class="docEmphItalicAlt">has the type of the template parameter</span> <span class="docEmphasis">T</span>
          // <span class="docEmphItalicAlt">not that of the global typedef</span>
          T tmp = a;
          // ...
          return tmp;
     }
</pre><BR>
<p class="docText">The global typedef that defines <tt>T</tt> as <tt>double</tt> is hidden by the type parameter named <tt>T</tt>. Thus, <tt>tmp</tt> is not a <tt>double</tt>. Instead, the type of <tt>tmp</tt> is whatever type gets bound to the template parameter <tt>T</tt>.</P>

<a name="ch16lev3sec6"></a>
<h5 class="docSection3Title">Restrictions on the Use of a Template Parameter Name</h5>
<p class="docText">A name used as a template parameter may not be reused within the template:</p>
<pre>
     template &lt;class T&gt; T calc(const T &amp;a, const T &amp;b)
     {
         typedef double T; // <span class="docEmphItalicAlt">error: redeclares template parameter T</span>
         T tmp = a;
         // ...
         return tmp;
     }
</pre><br>
<p class="docText">This restriction also means that the name of a template parameter can be used only once within the same template parameter list:</P>
<pre>
     // <span class="docEmphItalicAlt">error: illegal reuse of template parameter name</span> <span class="docEmphasis">V</span>
     template &lt;class V, class V&gt; V calc(const V&amp;, const V&amp;) ;
</pre><br>
<p class="docText">Of course, just as we can reuse function parameter names, the name of a template parameter can be reused across different templates:</p>
<pre>
     // <span class="docEmphItalicAlt">ok: reuses parameter type name across different templates</span>
     template &lt;class T&gt; T calc (const T&amp;, const T&amp;) ;
     template &lt;class T&gt; int compare(const T&amp;, const T&amp;) ;
</pre><BR>

<a name="ch16lev3sec7"></a>
<h5 class="docSection3Title">Template Declarations</h5>
<p class="docText">As with any other function or class, we can declare a template without defining it. A declaration must indicate that the function or class is a template:</P>
<pre>
     // <span class="docEmphItalicAlt">declares</span> <span class="docEmphasis">compare</span> <span class="docEmphItalicAlt">but does not define it</span>
     template &lt;class T&gt; int compare(const T&amp;, const T&amp;) ;
</pre><br>
<p class="docText"><a name="idd1e124731"></a><a name="idd1e124738"></a><a name="idd1e124743"></a><a name="idd1e124746"></a>The names of the template parameters need not be the same across declarations and the definition of the same template:</P>
<pre>
     // <span class="docEmphItalicAlt">all three uses of calc refer to the same function template</span>
     // <span class="docEmphItalicAlt">forward declarations of the template</span>
     template &lt;class T&gt; T calc(const T&amp;, const T&amp;) ;
     template &lt;class U&gt; U calc(const U&amp;, const U&amp;) ;
     // <span class="docEmphItalicAlt">actual definition of the template</span>
     template &lt;class Type&gt;
     Type calc(const Type&amp; a, const Type&amp; b) { /* ... */ }
</pre><br>
<p class="docText">Each template type parameter must be preceded either by the keyword <tt>class</tt> or <tt>typename</tt>; each nontype parameter must be preceded by a type name. It is an error to omit the keyword or a type specifier:</p>
<pre>
     // <span class="docEmphItalicAlt">error: must precede</span> <span class="docEmphasis">U</span> <span class="docEmphItalicAlt">by either</span> <span class="docEmphasis">typename</span> <span class="docEmphItalicAlt">or</span> <span class="docEmphasis">class</span>
     template &lt;typename T, U&gt; T calc (const T&amp;, const U&amp;) ;
</pre><br>
<a name="ch16sb03"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 16.1.3</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa3q1"></a><b>Exercise 16.7:</b></td><TD><p class="docText">Explain each of the following function template definitions and identify whether any are illegal. Correct each error that you find.</P>
<pre>
     (a) template &lt;class T, U, typename V&gt; void f1(T, U, V) ;
     (b) template &lt;class T&gt; T f2(int &amp;T) ;
     (c) inline template &lt;class T&gt; T foo(T, unsigned int*) ;
     (d) template &lt;class T&gt; f4 (T, T) ;
     (e) typedef char Ctype ;
         template &lt;typename Ctype&gt; Ctype f5(Ctype a) ;
</pre><br>
</TD></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch16qa3q2"></a><B>Exercise 16.8:</b></td><td><p class="docText">Explain which, if any, of the following declarations are errors and why.</p>
<pre>
     (a) template &lt;class Type&gt; Type bar(Type, Type) ;
         template &lt;class Type&gt; Type bar(Type, Type) ;
     (b) template &lt;class T1, class T2&gt; void bar(T1, T2) ;
         template &lt;class C1, typename C2&gt; void bar(C1, C2) ;
</pre><br>
</td></TR><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch16qa3q3"></a><B>Exercise 16.9:</b></td><td><p class="docText">Write a template that acts like the library <tt>find</tt> algorithm. Your template should take a single type parameter that will name the type for a pair of iterators that should be parameters to the function. Use your function to find a given value in a <tt>vector&lt;int&gt;</tt> and in a <tt>list&lt;string&gt;</tt>.</p>
</TD></TR></table></p>
</blockquote>
</td></tr></table></p><BR>


<a name="ch16lev2sec4"></a>
<h4 class="docSection2Title">16.1.4. Template Type Parameters</h4>
<p class="docText">Type parameters consist of the keyword <tt>class</tt> or the keyword <tt>typename</tt> followed by an identifier. In a template parameter list, these keywords have the same meaning: They indicate that the name that follows represents a type.</P>
<p class="docText"><a name="idd1e124883"></a><a name="idd1e124892"></a>A template type parameter can be used as a type specifier anywhere in the template, in exactly the same way as a built-in or class type specifier. In particular, it can be used to name the return type or a function parameter type, and for variable declarations or casts inside the function body:</p>
<pre>
     // <span class="docEmphItalicAlt">ok: same type used for the return type and both parameters</span>
     template &lt;class T&gt; T calc (const T&amp; a, const T&amp; b)
     {
          // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">tmp</span> <span class="docEmphItalicAlt">will have same type as the parameters &amp; return type</span>
          T tmp = a;
          // ...
          return tmp;
     }
</pre><br>
<a name="ch16lev3sec8"></a>
<H5 class="docSection3Title">Distinction Between <tt>typename</tt> and <tt>class</tt></h5>
<p class="docText">In a function template parameter list, the keywords <tt>typename</tt> and <tt>class</tt> have the same meaning and can be used interchangeably. Both keywords can be used in the same template parameter list:</P>
<pre>
     // <span class="docEmphItalicAlt">ok: no distinction between typename and class in template parameter list</span>
     template &lt;typename T, class U&gt; calc (const T&amp;, const U&amp;);
</pre><br>
<p class="docText">It may seem more intuitive to use the keyword <tt>typename</tt> instead of the keyword <tt>class</tt> to designate a template type parameter; after all, we can use built-in (nonclass types) types as the actual type parameter. Moreover, <tt>typename</tt> more clearly indicates that the name that follows is a type name. However, the keyword <tt>typename</tt> was added to C++ as part of Standard C++, so older programs are more likely to use the keyword <tt>class</tt> exclusively.</p>

<a name="ch16lev3sec9"></a>
<h5 class="docSection3Title">Designating Types inside the Template Definition</h5>
<p class="docText">In addition to defining data or function members, a class may define type members. For example, the library container classes define various types, such as <tt>size_type</tt>, that allow us to use the containers in a machine-independent way. When we want to use such types inside a function template, we must tell the compiler that the name we are using refers to a type. We must be explicit because the compiler (and a reader of our program) cannot tell by inspection when a name defined by a type parameter is a type or a value. As an example, consider the following function:</p>
<pre>
     template &lt;class Parm, class U&gt;
     Parm fcn(Parm* array, U value)
     {
         Parm: :size_type * p; // <span class="docEmphItalicAlt">If Parm::size_type is a type, then a declaration</span>
                              // <span class="docEmphItalicAlt">If Parm::size_type is an object, then multiplication</span>
     }
</pre><br>
<p class="docText">We know that <tt>size_type</tt> must be a member of the type bound to <tt>Parm</tt>, but we do not know whether <tt>size_type</tt> is the name of a type or a data member. By default, the compiler assumes that such names name data members, not types.</p>
<p class="docText"><a name="idd1e125004"></a><a name="idd1e125007"></a><a name="idd1e125012"></a>If we want the compiler to treat <tt>size_type</tt> as a type, then we must explicitly tell the compiler to do so:</p>
<pre>
     template &lt;class Parm, class U&gt;
     Parm fcn(Parm* array, U value)
     {
         typename Parm::size_type * p; // <span class="docEmphItalicAlt">ok: declares</span> <span class="docEmphasis">p</span> <span class="docEmphItalicAlt">to be a pointer</span>
     }
</pre><br>
<p class="docText">We tell the compiler to treat a member as a type by prefixing uses of the member name with the keyword <tt>typename</tt>. By writing <tt>typename Parm::size_type</tt> we say that member <tt>size_type</tt> of the type bound to <tt>Parm</tt> is the name of a type. Of course, this declaration puts an obligation on the types used to instantiate <tt>fcn</tt>: Those types must have a member named <tt>size_type</tt> that is a type.</p>
<a name="ch16note03"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="84" height="51" SRC="images/0201721481/graphics/tip.jpg;400478"></TD><TD valign="top"><p class="docText"> If there is any doubt as to whether <tt>typename</tt> is necessary to indicate that a name is a type, it is a good idea to specify it. There is no harm in specifying <tt>typename</tt> before a type, so if the <tt>typename</tt> was unnecessary, it won't matter.</p></TD></tr></table><br>
</P></div><BR>
<a name="ch16sb04"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 16.1.4</h2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch16qa4q1"></a><B>Exercise 16.10:</b></td><td><p class="docText">What, if any, are the differences between a type parameter that is declared as a <tt>typename</tt> and one that is declared as a <tt>class</tt>?</p>
</TD></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa4q2"></a><b>Exercise 16.11:</b></td><TD><p class="docText">When must <tt>typename</tt> be used?</p>
</td></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa4q3"></a><B>Exercise 16.12:</b></td><TD><p class="docText">Write a function template that takes a pair of values that represent iterators of unknown type. Find the value that occurs most frequently in the sequence.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa4q4"></a><b>Exercise 16.13:</b></td><td><p class="docText">Write a function that takes a reference to a container and prints the elements in that container. Use the container's <tt>size_type</tt> and <tt>size</tt> members to control the loop that prints the elements.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa4q5"></a><B>Exercise 16.14:</b></TD><td><p class="docText">Rewrite the function from the previous exercise to use iterators returned from <tt>begin</tt> and <tt>end</tt> to control the loop.</P>
</td></tr></table></P>
</blockquote>
</TD></tr></table></p><br>


<a name="ch16lev2sec5"></a>
<h4 class="docSection2Title">16.1.5. Nontype Template Parameters</h4>
<p class="docText">A template parameter need not be a type. In this section we'll look at nontype parameters as used by function templates. We'll look at nontype parameters for class templates in <a class="docLink" href="ch16lev1sec4.html#ch16lev2sec19">Section 16.4.2</a> (p. <a class="docLink" href="ch16lev1sec4.html#ch16lev2sec19">655</a>) after we've seen more about how class templates are implemented.</P>
<p class="docText">Nontype parameters are replaced by values when the function is called. The type of that value is specified in the template parameter list. For example, the following function template declares <tt>array_init</tt> as a function template with one type and one nontype template parameter. The function itself takes a single parameter, which is a reference to an array (<a class="docLink" href="ch07lev1sec2.html#ch07lev2sec9">Section 7.2.4</a>, p. <a class="docLink" href="ch07lev1sec2.html#ch07lev2sec9">240</a>):</p>
<pre>
     // <span class="docEmphItalicAlt">initialize elements of an array to zero</span>
     template &lt;class T, size_t N&gt; void array_init(T (&amp;parm)[N])
     {
         for (size_t i = 0; i != N; ++i) {
             parm[i] = 0;
         }
     }
</pre><BR>
<p class="docText"><a name="idd1e125201"></a><a name="idd1e125206"></a><a name="idd1e125213"></a><a name="idd1e125218"></a>A template nontype parameter is a constant value inside the template definition. A nontype parameter can be used when constant expressions are requiredfor example, as we do hereto specify the size of an array.</P>
<p class="docText">When <tt>array_init</tt> is called, the compiler figures out the value of the nontype parameter from the array argument:</p>
<pre>
     int x[42];
     double y[10];
     array_init(x);  // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">array_init(int(&amp;)[42]</span>
     array_init(y);  // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">array_init(double(&amp;)[10]</span>
</pre><br>
<p class="docText">The compiler will instantiate a separate version of <tt>array_init</tt> for each kind of array used in a call to <tt>array_init</tt>. For the program above, the compiler instantiates two versions of <tt>array_init:</tt> The first instance has its parameter bound to <tt>int[42]</tt>, and in the other, that parameter is bound to <tt>double[10]</tt>.</p>
<a name="ch16lev3sec10"></a>
<H5 class="docSection3Title">Type Equivalence and Nontype Parameters</H5>
<p class="docText">Expressions that evaluate to the same value are considered equivalent template arguments for a template nontype parameter. The following calls to <tt>array_init</tt> both refer to the same instantiation, <tt>array_init&lt;int, 42&gt;</tt>:</p>
<pre>
     int x[42];
     const int sz = 40;
     int y[sz + 2];
     array_init(x);  // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">array_init(int(&amp;)[42])</span>
     array_init(y);  // <span class="docEmphItalicAlt">equivalent instantiation</span>
</pre><br>
<a name="ch16sb05"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Exercises Section 16.1.5</h2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q1"></a><B>Exercise 16.15:</b></td><TD><p class="docText">Write a function template that can determine the size of an array.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q2"></a><b>Exercise 16.16:</b></td><td><p class="docText">Rewrite the <tt>printValues</tt> function from page <a class="docLink" href="ch07lev1sec2.html#ch07note10">240</a> as a function template that could be used to print the contents of arrays of varying sizes.</p>
</td></tr></table></p>
</blockquote>
</td></TR></table></P><br>


<a name="ch16lev2sec6"></a>
<H4 class="docSection2Title">16.1.6. Writing Generic Programs</h4>
<p class="docText">When we write a template, the code may not be overtly type-specific, but template code always makes some assumptions about the types that will be used. For example, although our <tt>compare</tt> function is technically valid for any type, in practice the instantiated version might be illegal.</p>
<p class="docText"><a name="idd1e125350"></a><a name="idd1e125355"></a><a name="idd1e125360"></a><a name="idd1e125365"></a><a name="idd1e125370"></a><a name="idd1e125375"></a>Whether the generated program is legal depends on the operations used in the function and the operations supported by the type or types used. Our <tt>compare</tt> function has has three statements:</P>
<pre>
     if (v1 &lt; v2) return -1; // <span class="docEmphItalicAlt">&lt; on two objects of type</span> <span class="docEmphasis">T</span>
     if (v2 &lt; v1) return 1;  // <span class="docEmphItalicAlt">&lt; on two objects of type</span> <span class="docEmphasis">T</span>
     return 0;               // <span class="docEmphItalicAlt">return</span> <span class="docEmphasis">int;</span> <span class="docEmphItalicAlt">not dependent on</span> <span class="docEmphasis">T</span>
</pre><BR>
<p class="docText">The first two statements contain code that implicitly depends on the parameter type. The <tt>if</tt> tests use the <tt>&lt;</tt> operator on the parameters. The type of those parameters isn't known until the compiler sees a call to <tt>compare</tt> and <tt>T</tt> is bound to an actual type. Which <tt>&lt;</tt> operator is used depends entirely on the argument type.</p>
<p class="docText">If we call <tt>compare</tt> on an object that does not support the <tt>&lt;</tt> operator, then the call will be invalid:</p>
<pre>
     Sales_item item1, item2;
     // <span class="docEmphItalicAlt">error: no &lt; on Sales_item</span>
     cout &lt;&lt; compare(item1, item2) &lt;&lt; endl;
</pre><br>
<p class="docText">The program is in error. The <tt>Sales_item</tt> type does not define the <tt>&lt;</tt> operator, so the program won't compile.</p>
<a name="ch16note04"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></TD><TD valign="top"><p class="docText"> The operations performed inside a function template constrains the types that can be used to instantiate the function. It is up to the programmer to guarantee that the types used as the function arguments actually support any operations that are used, and that those operations behave correctly in the context in which the template uses them.</p></td></tr></table><BR>
</P></div><br>
<a name="ch16lev3sec11"></a>
<h5 class="docSection3Title">Writing Type-Independent Code</h5>
<p class="docText">The art of writing good generic code is beyond the scope of this language primer. However, there is one overall guideline that is worth noting.</p>
<a name="ch16note05"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></TD><td valign="top"><p class="docText"> When writing template code, it is useful to keep the number of requirements placed on the argument types as small as possible.</p></TD></tr></table><BR>
</p></div><br>
<p class="docText">Simple though it is, our <tt>compare</tt> function illustrates two important principles for writing generic code:</p>
<ul><li><p class="docList">The parameters to the template are <tt>const</tt> references.</p></li><li><p class="docList">The tests in the body use only <tt>&lt;</tt> comparisons.</p></li></ul>
<p class="docText">By making the parameters <tt>const</tt> references, we allow types that do not allow copying. Most typesincluding the built-in types and, except for the IO types, all the library types we've useddo allow copying. However, there can be class types that do not allow copying. By making our parameters <tt>const</tt> references, we ensure that such types can be used with our <tt>compare</tt> function. Moreover, if <tt>compare</tt> is called with large objects, then this design will also make the function run faster.</p>
<p class="docText">Some readers might think it would be more natural for the comparisons to be done using both the <tt>&lt;</tt> and <tt>&gt;</tt> operators:</p>
<pre>
     // <span class="docEmphItalicAlt">expected comparison</span>
     if (v1 &lt; v2) return -1;
     if (v1 &gt; v2) return 1;
     return 0;
</pre><BR>
<p class="docText"><a name="idd1e125545"></a><a name="idd1e125550"></a><a name="idd1e125555"></a><a name="idd1e125560"></a><a name="idd1e125565"></a><a name="idd1e125570"></a><a name="idd1e125573"></a>However, by writing the code as</P>
<pre>
     // <span class="docEmphItalicAlt">expected comparison</span>
     if (v1 &lt; v2) return -1;
     if (v2 &lt; v1) return 1; // <span class="docEmphItalicAlt">equivalent to</span> <span class="docEmphasis">v1 &gt; v2</span>
     return 0;
</pre><br>
<p class="docText">we reduce the requirements on types that can be used with our <tt>compare</tt> function. Those types must support <tt>&lt;</tt>, but they need not also support <tt>&gt;</tt>.</P>
<a name="ch16sb06"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<H2 class="docSidebarTitle">Exercises Section 16.1.6</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa6q1"></a><b>Exercise 16.17:</b></TD><td><p class="docText">In the &quot;Key Concept&quot; box on page <a class="docLink" href="ch03lev1sec3.html#ch03sb09">95</a>, we noted that as a matter of habit C++ programmers prefer using <tt>!=</tt> to using <tt>&lt;</tt>. Explain the rationale for this habit.</P>
</TD></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa6q2"></a><B>Exercise 16.18:</b></TD><td><p class="docText">In this section we noted that we deliberately wrote the test in <tt>compare</tt> to avoid requiring a type to have both the <tt>&lt;</tt> and <tt>&gt;</tt> operators. On the other hand, we tend to assume that types will have both <tt>==</tt> and <tt>!=</tt>. Explain why this seeming discrepancy in treatment actually reflects good programming style.</p>
</td></tr></table></P>
</blockquote>
</td></tr></table></P><br>
<a name="ch16sb07"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<H2 class="docSidebarTitle">Caution: Compile-Time Errors at Link-Time</h2>
<p class="docText"><span class="docEmphStrong">In general, when compiling a template, there are three stages during which the compiler might flag an error: The first is when we compile the template definition itself. The compiler generally can't find many errors at this stage. Syntax errors, such as forgetting a semicolon or misspelling a variable name, can be detected.</span></p>
<p class="docText"><span class="docEmphStrong">The second error-detection time is when the compiler sees a use of the template. At this stage, there is still not much the compiler can check. For a call to a function template, many compilers check only that the number and types of the arguments are appropriate. The compiler can detect that there are too many or too few arguments. It can also detect whether two arguments that are supposed to have the same type do so. For a class template, the compiler can check that the right number of template arguments are provided but not much else.</span></p>
<p class="docText"><span class="docEmphStrong">The third time when errors are generated is during instantiation. It is only then that type-related errors can be found. Depending on how the compiler manages instantiation, which we'll cover on page <a class="docLink" href="ch16lev1sec3.html#ch16lev1sec3">643</a>, these errors may be reported at link time.</span></p>
<p class="docText"><span class="docEmphStrong">It is important to realize that when we compile a template definition, we do not know much about how valid the program is. Similarly, we may obtain compiler errors even after we have successfully compiled each file that uses the template. It is not uncommon to detect errors only during instantiation, which may happen at link-time.</span></p>
</td></tr></table></p><br>



<a href="21001535.html"><img src="images/pixel.gif" alt="" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch16.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch16lev1sec2.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>