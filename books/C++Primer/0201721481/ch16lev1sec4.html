<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 16.4.&nbsp; Class Template Members</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch16lev1sec3.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch16lev1sec5.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch16lev1sec4"></a>
<h3 class="docSection1Title">16.4. Class Template Members</h3>
<p class="docText">So far we have seen only how to declare the interface members of our <tt>Queue</tt> class template. In this section, we'll look at how we might implement the class.</P>
<a name="ch16note10"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> The standard library implements <tt>queue</tt> as an adaptor (<a class="docLink" href="ch09lev1sec7.html#ch09lev1sec7">Section 9.7</a>, p. <a class="docLink" href="ch09lev1sec7.html#ch09lev1sec7">348</a>) on top of another container. To emphasize the programming points involved in using a lower-level data structure, we'll implement our <tt>Queue</tt> class as a linked list. In practice, using a library container in our implementation would probably be a better decision.</P></TD></tr></table><br>
</p></div><br>
<a name="ch16lev2sec14"></a>
<h4 class="docSection2Title"><tt>Queue</tt> Implementation Strategy</H4>
<p class="docText">Our implementation, shown in <a class="docLink" href="#ch16fig01">Figure 16.1</a> on the next page, uses two classes:</p>
<a name="ch16fig01"></a><P><center>
<H5 class="docFigureTitle">Figure 16.1. <tt>Queue</tt> Implementation</h5>

<p class="docText">
<img border="0" alt="" width="461" height="116" SRC="images/0201721481/graphics/16fig01.gif;400478"></p>

</center></p><BR>
<div style="font-weight:bold"><ol class="docList" type="1"><LI><div style="font-weight:normal"><p class="docList">Class <tt>QueueItem</tt> will represent a node in <tt>Queue</tt>'s linked list. This class has two data members: <tt>item</tt> and <tt>next</tt>:</p><ul><li><p class="docList"><tt>item</tt> holds the value of the element in the <tt>Queue</tt>; its type varies with each instance of <tt>Queue</tt>.</p></LI><li><p class="docList"><tt>next</tt> is a pointer to the next <tt>QueueItem</tt> object in the queue.</p></LI></ul><p class="docList">Each element in the <tt>Queue</tt> is stored in a <tt>QueueItem</tt> object.</p></div></LI><li><div style="font-weight:normal"><p class="docList">Class <tt>Queue</tt> will provide the interface functions described in <a class="docLink" href="ch16lev1sec1.html#ch16lev2sec2">Section 16.1.2</a> (p. <a class="docLink" href="ch16lev1sec1.html#ch16lev2sec2">627</a>). The <tt>Queue</tt> class will also have two data members: <tt>head</tt> and <tt>tail</tt>. These members are pointers to <tt>QueueItem</tt>.</P></div></li></ol></div>
<p class="docText">As do the standard containers, our <tt>Queue</tt> class will copy the values it's given.</p>

<a name="ch16lev2sec15"></a>
<h4 class="docSection2Title">The <tt>QueueItem</tt> Class</h4>
<p class="docText"><a name="idd1e127863"></a><a name="idd1e127869"></a><a name="idd1e127875"></a>We'll start our implementation by writing the <tt>QueueItem</tt> class:</p>
<pre>
     template &lt;class Type&gt; class QueueItem {
     // <span class="docEmphItalicAlt">private class: no public section</span>
         QueueItem(const Type &amp;t): item(t), next(0) { }
         Type item;           // <span class="docEmphItalicAlt">value stored in this element</span>
         QueueItem *next;     // <span class="docEmphItalicAlt">pointer to next element in the</span> <span class="docEmphasis">Queue</span>
     };
</pre><br>
<p class="docText">As it stands, this class is already complete: It holds two data elements, which its constructor initializes. Like <tt>Queue, QueueItem</tt> is a class template. The class uses its template parameter to name the type of its <tt>item</tt> member. The value of each element in the <tt>Queue</tt> will be stored in <tt>item</tt>.</p>
<p class="docText">Each time we instantiate a <tt>Queue</tt> class, the same version of <tt>QueueItem</tt> will be instantiated as well. For example, if we create <tt>Queue&lt;int&gt;</tt>, then a companion class, <tt>QueueItem&lt;int&gt;</tt>, will be instantiated.</p>
<p class="docText">Class <tt>QueueItem</tt> is a private classit has no public interface. We intend this class to be used to implement <tt>Queue</tt> and have not built it for general use. Hence, it has no public members. We'll need to make class <tt>Queue</tt> a friend of <tt>QueueItem</tt> so that its members can access the members of <tt>QueueItem</tt>. We'll see how to do so in <a class="docLink" href="#ch16lev2sec21">Section 16.4.4</a> (p. <a class="docLink" href="#ch16lev2sec21">658</a>).</p>
<a name="ch16note11"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> Inside the scope of a class template, we may refer to the class using its unqualified name.</P></td></TR></table><br>
</p></div><BR>

<a name="ch16lev2sec16"></a>
<H4 class="docSection2Title">The <tt>Queue</tt> Class</h4>
<p class="docText">We can now flesh out our <tt>Queue</tt> class:</p>
<pre>
     template &lt;class Type&gt; class Queue {
     public:
         // <span class="docEmphItalicAlt">empty</span> <span class="docEmphasis">Queue</span>
         Queue(): head(0), tail(0) { }
         // <span class="docEmphItalicAlt">copy control to manage pointers to</span> <span class="docEmphasis">QueueItem</span><span class="docEmphItalicAlt">s in the</span> <span class="docEmphasis">Queue</span>
         Queue(const Queue &amp;Q): head(0), tail(0)
                                       { copy_elems(Q); }
         Queue&amp; operator=(const Queue&amp;);
         ~Queue() { destroy(); }
              // <span class="docEmphItalicAlt">return element from head of</span> <span class="docEmphasis">Queue</span>
         // <span class="docEmphItalicAlt">unchecked operation: front on an empty</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">is undefined</span>
         Type&amp; front()             { return head-&gt;item; }
         const Type &amp;front() const { return head-&gt;item; }
         void push(const Type &amp;);       // <span class="docEmphItalicAlt">add element to back of</span> <span class="docEmphasis">Queue</span>
         void pop ();                    // <span class="docEmphItalicAlt">remove element from head of</span> <span class="docEmphasis">Queue</span>
         bool empty () const {           // <span class="docEmphItalicAlt">true if no elements in the</span> <span class="docEmphasis">Queue</span>
             return head == 0;
         }
     private:
         QueueItem&lt;Type&gt; *head;         // <span class="docEmphItalicAlt">pointer to first element in</span> <span class="docEmphasis">Queue</span>
         QueueItem&lt;Type&gt; *tail;         // <span class="docEmphItalicAlt">pointer to last element in</span> <span class="docEmphasis">Queue</span>
         // <span class="docEmphItalicAlt">utility functions used by copy constructor, assignment, and destructor</span>
         void destroy();                // <span class="docEmphItalicAlt">delete all the elements</span>
         void copy_elems(const Queue&amp;); // <span class="docEmphItalicAlt">copy elements from parameter</span>
     };
</pre><br>
<p class="docText"><a name="idd1e128059"></a><a name="idd1e128064"></a>In addition to the interface members, we have added the three copy-control members (<a class="docLink" href="ch13.html#ch13">Chapter 13</a>) and associated utility functions used by those members. The <tt>private</tt> utility functions <tt>destroy</tt> and <tt>copy_elems</tt> will do the work of freeing the elements in the <tt>Queue</tt> and copying elements from another <tt>Queue</tt> into this one. The copy-control members are needed to manage the data members, <tt>head</tt> and <tt>tail</tt>, which are pointers to the first and last elements in the <tt>Queue</tt>. These elements are values of type <tt>QueueItem&lt;Type&gt;</tt>.</p>
<p class="docText">The class implements several of its member functions:</p>
<UL><li><p class="docList">The default constructor sets both <tt>head</tt> and <tt>tail</tt> pointers to zero, indicating that the <tt>Queue</tt> is currently empty.</P></LI><li><p class="docList">The copy constructor initializes <tt>head</tt> and <tt>tail</tt>, and calls <tt>copy_elems</tt> to copy the elements from its initializer.</p></li><LI><p class="docList">The <tt>front</tt> functions return the value at the head of the <tt>Queue</tt>. These functions do no checking: As with the analogous operations in the standard <tt>queue</tt>, users may not run <tt>front</tt> on an empty <tt>Queue</tt>.</P></li><li><p class="docList">The <tt>empty</tt> function returns the result of comparing <tt>head</tt> with zero. If <tt>head</tt> is zero, the <tt>Queue</tt> is empty; otherwise, it is not.</p></li></UL>

<a name="ch16lev2sec17"></a>
<h4 class="docSection2Title">References to a Template Type in the Scope of the Template</h4>
<p class="docText">For the most part, this class definition should be familiar. It differs little from other classes that we have defined. What is new is the use (or lack thereof) of the template type parameter in references to the <tt>Queue</tt> and <tt>QueueItem</tt> types.</P>
<p class="docText">Ordinarily, when we use the name of a class template, we must specify the template parameters. There is one exception to this rule: Inside the scope of the class itself, we may use the unqualified name of the class template. For example, in the declarations of the default and copy constructor the name <tt>Queue</tt> is a shorthand notation that stands for <tt>Queue&lt;Type&gt;</tt>. Essentially the compiler infers that when we refer to the name of the class, we are referring to the same version. Hence, the copy constructor definition is really equivalent to writing:</p>
<pre>
     Queue&lt;Type&gt;(const Queue&lt;Type&gt; &amp;Q): head(0), tail(0)
                 { copy_elems(Q); }
</pre><br>
<p class="docText">The compiler performs no such inference for the template parameter(s) for other templates used within the class. Hence, we must specify the type parameter when declaring pointers to the companion <tt>QueueItem</tt> class:</P>
<pre>
     QueueItem&lt;Type&gt; *head;    // <span class="docEmphItalicAlt">pointer to first element in</span> <span class="docEmphasis">Queue</span>
     QueueItem&lt;Type&gt; *tail;    // <span class="docEmphItalicAlt">pointer to last element in</span> <span class="docEmphasis">Queue</span>
</pre><br>
<p class="docText">These declarations say that for a given instantiation of class <tt>Queue, head</tt> and <tt>tail</tt> point to an object of type <tt>QueueItem</tt> instantiated for the same template parameter. That is, the type of <tt>head</tt> and <tt>tail</tt> inside the <tt>Queue&lt;int&gt;</tt> instantiation is <tt>QueueItem&lt;int&gt;*</tt>. It would be an error to omit the template parameter in the definition of the <tt>head</tt> and <tt>tail</tt> members:</P>
<pre>
     QueueItem *head;        // <span class="docEmphItalicAlt">error: which version of</span> <span class="docEmphasis">QueueItem?</span>
     QueueItem *tail;        // <span class="docEmphItalicAlt">error: which version of</span> <span class="docEmphasis">QueueItem?</span>
</pre><br>
<a name="ch16sb12"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 16.4</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa10q1"></a><b>Exercise 16.30:</b></td><td><p class="docText">Identify which, if any, of the following class template declarations (or declaration pairs) are illegal.</p>
<pre>
     (a) template &lt;class Type&gt; class C1;
         template &lt;class Type, int size&gt; class C1;
     (b) template &lt;class T, U, class V&gt; class C2;
     (c) template &lt;class C1, typename C2&gt; class C3 { };
     (d) template &lt;typename myT, class myT&gt; class C4 { };
     (e) template &lt;class Type, int *ptr&gt; class C5;
         template &lt;class T, int *pi&gt; class C5;
</pre><BR>
</TD></tr><TR valign="top"><td align="right" class="docText" width="50"><a name="ch16qa10q2"></a><b>Exercise 16.31:</b></TD><TD><p class="docText">The following definition of <tt>List</tt> is incorrect. How would you fix it?</p>
<pre>
     template &lt;class elemType&gt; class ListItem;
     template &lt;class elemType&gt; class List {
     public:
         List&lt;elemType&gt;();
         List&lt;elemType&gt;(const List&lt;elemType&gt; &amp;);
         List&lt;elemType&gt;&amp; operator=(const List&lt;elemType&gt; &amp;);
         ~List();
         void insert(ListItem *ptr, elemType value);
         ListItem *find(elemType value);
     private:
         ListItem *front;
         ListItem *end;
     };
</pre><br>
</td></tr></table></p>
</blockquote>
</TD></tr></table></P><BR>

<a name="ch16lev2sec18"></a>
<h4 class="docSection2Title">16.4.1. Class-Template Member Functions</h4>
<p class="docText"><a name="idd1e128329"></a><a name="idd1e128336"></a><a name="idd1e128343"></a><a name="idd1e128353"></a><a name="idd1e128363"></a><a name="idd1e128371"></a>The definition of a member function of a class template has the following form:</p>
<UL><LI><p class="docList">It must start with the keyword <tt>template</tt> followed by the template parameter list for the class.</p></li><li><p class="docList">It must indicate the class of which it is a member.</p></LI><li><p class="docList">The class name must include its template parameters.</p></LI></ul>
<p class="docText">From these rules, we can see that a member function of class <tt>Queue</tt> defined outside the class will start as</p>
<pre>
     template &lt;class T&gt; <span class="docEmphasis">ret-type</span> Queue&lt;T&gt;::<span class="docEmphasis">member-name</span>
</pre><BR>
<a name="ch16lev3sec19"></a>
<h5 class="docSection3Title">The <tt>destroy</tt> Function</H5>
<p class="docText">To illustrate a class template member function defined outside its class, let's look at the <tt>destroy</tt> function:</p>
<pre>
     template &lt;class Type&gt; void Queue&lt;Type&gt;::destroy()
     {
         while (!empty())
             pop();
     }
</pre><br>
<p class="docText">This definition can be read from left to right as:</p>
<ul><li><p class="docList">Defining a function template with a single type parameter named <tt>Type</tt></p></li><li><p class="docList">that returns <tt>void</tt>,</p></li><li><p class="docList">which is in the scope of the <tt>Queue&lt;Type&gt;</tt> class template.</p></li></UL>
<p class="docText">The use of <tt>Queue&lt;Type&gt;</tt> preceding the scope operator (<tt>::</tt>) names the class to which the member function belongs.</P>
<p class="docText">Following the member-function name is the function definition. In the case of <tt>destroy</tt>, the function body looks very much like an ordinary nontemplate function definition. Its job is to walk the list of entries in this <tt>Queue</tt>, calling <tt>pop</tt> to remove each item.</p>

<a name="ch16lev3sec20"></a>
<H5 class="docSection3Title">The <tt>pop</tt> Function</h5>
<p class="docText">The <tt>pop</tt> member removes the value at the front of the <tt>Queue</tt>:</p>
<pre>
     template &lt;class Type&gt; void Queue&lt;Type&gt;::pop()
     {
         // <span class="docEmphItalicAlt">pop is unchecked: Popping off an empty</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">is undefined</span>
         QueueItem&lt;Type&gt;* p = head; // <span class="docEmphItalicAlt">keep pointer to</span> <span class="docEmphasis">head</span> <span class="docEmphItalicAlt">so we can delete it</span>
         head = head-&gt;next;         // <span class="docEmphasis">head</span> <span class="docEmphItalicAlt">now points to next element</span>
         delete p;                  // <span class="docEmphItalicAlt">delete old</span> <span class="docEmphasis">head</span> <span class="docEmphItalicAlt">element</span>
      }
</pre><BR>
<p class="docText"><a name="idd1e128548"></a><a name="idd1e128558"></a><a name="idd1e128568"></a><a name="idd1e128576"></a>The <tt>pop</tt> function assumes that users do not call <tt>pop</tt> on an empty <tt>Queue</tt>. The job of <tt>pop</tt> is to remove the element at the start of the <tt>Queue</tt>. We must reset the <tt>head</tt> pointer to point to the next element in the <tt>Queue</tt>, and then delete the element that had been at the <tt>head</tt>. The only tricky part is remembering to keep a separate pointer to that element so we can delete it after resetting the <tt>head</tt> pointer.</P>

<a name="ch16lev3sec21"></a>
<h5 class="docSection3Title">The <tt>push</tt> Function</h5>
<p class="docText">The <tt>push</tt> member places a new item at the back of the queue:</p>
<pre>
     template &lt;class Type&gt; void Queue&lt;Type&gt;::push(const Type &amp;val)
     {
         // <span class="docEmphItalicAlt">allocate a new</span> <span class="docEmphasis">QueueItem</span> <span class="docEmphItalicAlt">object</span>
         QueueItem&lt;Type&gt; *pt = new QueueItem&lt;Type&gt;(val);
         // <span class="docEmphItalicAlt">put item onto existing queue</span>
         if (empty())
             head = tail = pt; // <span class="docEmphItalicAlt">the queue now has only one element</span>
         else {
             tail-&gt;next = pt; // <span class="docEmphItalicAlt">add new element to end of the queue</span>
             tail = pt;
         }
     }
</pre><br>
<p class="docText">This function starts by allocating a new <tt>QueueItem</tt>, which is initialized from the value we were passed. There's actually a surprising bit of work going on in this statement:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><LI><div style="font-weight:normal"><p class="docList">The <tt>QueueItem</tt> constructor copies its argument into the <tt>QueueItem</tt>'s <tt>item</tt> member. As do the standard containers, our <tt>Queue</tt> class stores copies of the elements it is given.</p></div></LI><LI><div style="font-weight:normal"><p class="docList">If <tt>item</tt> is a class type, the initialization of <tt>item</tt> uses the copy constructor of whatever type <tt>item</tt> has.</p></div></li><li><div style="font-weight:normal"><p class="docList">The <tt>QueueItem</tt> constructor also initializes the <tt>next</tt> pointer to 0 to indicate that this element points to no other <tt>QueueItem</tt>.</P></div></LI></ol></div>
<p class="docText">Because we're adding the element at the end of the <tt>Queue</tt>, setting <tt>next</tt> to 0 is eactly what we want.</p>
<p class="docText">Having created and initialized a new element, we must next hook it into the <tt>Queue</tt>. If the <tt>Queue</tt> is empty, then both <tt>head</tt> and <tt>tail</tt> should point to this new element. If there are already other elements in the <tt>Queue</tt>, then we make the current <tt>tail</tt> element point to this new element. The old <tt>tail</tt> is no longer the last element, which we indicate by making <tt>tail</tt> point to the newly constructed element as well.</p>

<a name="ch16lev3sec22"></a>
<h5 class="docSection3Title">The <tt>copy</tt> Function</h5>
<p class="docText">Aside from the assignment operator, which we leave as an exercise, the only remaining function to write is <tt>copy_elems</tt>. This function is designed to be used by the assignment operator and copy constructor. Its job is to copy the elements from its parameter into this <tt>Queue</tt>:</P>
<pre>
     template &lt;class Type&gt;
     void Queue&lt;Type&gt;::copy_elems(const Queue &amp;orig)
     {
         // <span class="docEmphItalicAlt">copy elements from</span> <span class="docEmphasis">orig</span> <span class="docEmphItalicAlt">into this</span> <span class="docEmphasis">Queue</span>
         // <span class="docEmphItalicAlt">loop stops when</span> <span class="docEmphasis">pt == 0,</span> <span class="docEmphItalicAlt">which happens when we reach</span> <span class="docEmphasis">orig.tail</span>
         for (QueueItem&lt;Type&gt; *pt = orig.head; pt; pt = pt-&gt;next)
             push(pt-&gt;item); // <span class="docEmphItalicAlt">copy the element</span>
      }
</pre><br>
<p class="docText"><a name="idd1e128794"></a><a name="idd1e128799"></a><a name="idd1e128806"></a><a name="idd1e128813"></a><a name="idd1e128818"></a><a name="idd1e128825"></a>We copy the elements in a <tt>for</tt> loop that starts by setting <tt>pt</tt> equal to the parameter's <tt>head</tt> pointer. The <tt>for</tt> continues until <tt>pt</tt> is 0, which happens after we get to the element that is the last one in <tt>orig</tt>. For each element in <tt>orig</tt>, we <tt>push</tt> a copy of value in that element onto this <tt>Queue</tt> and advance <tt>pt</tt> to point to the next element in <tt>orig</tt>.</p>

<a name="ch16lev3sec23"></a>
<H5 class="docSection3Title">Instantiation of Class-Template Member Functions</h5>
<p class="docText">Member functions of class templates are themselves function templates. Like any other function template, a member function of a class template is used to generate instantiations of that member. Unlike other function templates, the compiler does not perform template-argument deduction when instantiating class template member functions. Instead, the template parameters of a class template member function are determined by the type of the object on which the call is made. For example, when we call the <tt>push</tt> member of an object of type <tt>Queue&lt;int&gt;</tt>, the <tt>push</tt> function that is instantiated is</p>
<pre>
     void Queue&lt;int&gt;::push(const int &amp;val)
</pre><BR>
<p class="docText">The fact that member-function template parameters are fixed by the template arguments of the object means that calling a class template member function is more flexible than comparable calls to function templates. Normal conversions are allowed on arguments to function parameters that were defined using the template parameter:</p>
<pre>
     Queue&lt;int&gt; qi; // <span class="docEmphItalicAlt">instantiates class</span> <span class="docEmphasis">Queue&lt;int&gt;</span>
     short s = 42;
     int i = 42;
     // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">s</span> <span class="docEmphItalicAlt">converted to</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">and passed to</span> <span class="docEmphasis">push</span>
     qi.push(s); // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">Queue&lt;int&gt;::push(const int&amp;)</span>
     qi.push(i); // <span class="docEmphItalicAlt">uses</span> <span class="docEmphasis">Queue&lt;int&gt;::push(const int&amp;)</span>
     f(s);       // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">f(const short&amp;)</span>
     f(i);       // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">f(const int&amp;)</span>
</pre><BR>

<a name="ch16lev3sec24"></a>
<h5 class="docSection3Title">When Classes and Members Are Instantiated</h5>
<p class="docText">Member functions of a class template are instantiated only for functions that are used by the program. If a function is never used, then that member function is never instantiated. This behavior implies that types used to instantiate a template need to meet only the requirements of the operations that are actually used. As an example, recall the sequential container constructor (<a class="docLink" href="ch09lev1sec1.html#ch09lev2sec1">Section 9.1.1</a>, p. <a class="docLink" href="ch09lev1sec1.html#ch09lev2sec1">309</a>) that takes <a name="idd1e128961"></a>only a size parameter. That constructor uses the default constructor for the element type. If we have a type that does not define the default constructor, we may still define a container to hold this type. However, we may not use the constructor that takes only a size.</p>
<p class="docText">When we define an object of a template type, that definition causes the class template to be instantiated. Defining an object also instantiates whichever constructor was used to initialize the object, along with any members called by that constructor:</p>
<pre>
     // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">Queue&lt;int&gt;</span> <span class="docEmphItalicAlt">class and</span> <span class="docEmphasis">Queue&lt;int&gt;::Queue()</span>
     Queue&lt;string&gt; qs;
     qs.push("hello"); // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">Queue&lt;int&gt;::push</span>
</pre><br>
<p class="docText">The first statement instantiates the <tt>Queue&lt;string&gt;</tt> class and its default constructor. The next statement instantiates the <tt>push</tt> member function.</p>
<p class="docText">The instantiation of the <tt>push</tt> member:</p>
<pre>
     template &lt;class Type&gt; void Queue&lt;Type&gt;::push(const Type &amp;val)
     {
          // <span class="docEmphItalicAlt">allocate a new</span> <span class="docEmphasis">QueueItem</span> <span class="docEmphItalicAlt">object</span>
          QueueItem&lt;Type&gt; *pt = new QueueItem&lt;Type&gt;(val);
          // <span class="docEmphasis">put item onto existing queue</span>
          if (empty())
              head = tail = pt;    // <span class="docEmphItalicAlt">the queue now has only one element</span>
          else {
              tail-&gt;next = pt;     // <span class="docEmphItalicAlt">add new element to end of the queue</span>
              tail = pt;
          }
     }
</pre><br>
<p class="docText">in turn instantiates the companion <tt>QueueItem&lt;string&gt;</tt> class and its constructor.</p>
<p class="docText">The <tt>QueueItem</tt> members in <tt>Queue</tt> are pointers. Defining a pointer to a class template doesn't instantiate the class; the class is instantiated only when we use such a pointer. Thus, <tt>QueueItem</tt> is not instantiated when we create a <tt>Queue</tt> object. Instead, the <tt>QueueItem</tt> class is instanatiated when a <tt>Queue</tt> member such as <tt>front, push</tt>, or <tt>pop</tt> is used.</p>
<a name="ch16sb13"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Exercises Section 16.4.1</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><td align="right" class="docText" width="50"><a name="ch16qa11q1"></a><b>Exercise 16.32:</b></TD><TD><p class="docText">Implement the assignment operator for class <tt>Queue</tt>.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa11q2"></a><B>Exercise 16.33:</b></td><TD><p class="docText">Explain how the <tt>next</tt> pointers in the newly created <tt>Queue</tt> get set during the <tt>copy_elems</tt> function.</P>
</td></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch16qa11q3"></a><B>Exercise 16.34:</b></td><td><p class="docText">Write the member function definitions of the <tt>List</tt> class that you defined for the exercises in <a class="docLink" href="ch16lev1sec1.html#ch16lev2sec2">Section 16.1.2</a> (p. <a class="docLink" href="ch16lev1sec1.html#ch16lev2sec2">628</a>).</p>
</td></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa11q4"></a><B>Exercise 16.35:</b></td><td><p class="docText">Write a generic version of the <tt>CheckedPtr</tt> class described in <a class="docLink" href="ch14lev1sec7.html#ch14lev1sec7">Section 14.7</a> (p. <a class="docLink" href="ch14lev1sec7.html#ch14lev1sec7">526</a>).</P>
</td></TR></table></p>
</blockquote>
</td></tr></table></p><br>


<a name="ch16lev2sec19"></a>
<h4 class="docSection2Title">16.4.2. Template Arguments for Nontype Parameters</h4>
<p class="docText"><a name="idd1e129159"></a><a name="idd1e129164"></a><a name="idd1e129171"></a><a name="idd1e129176"></a><a name="idd1e129183"></a><a name="idd1e129189"></a>Now that we've seen more about how class templates are implemented, we can look at nontype parameters for class templates. We'll do so by defining a new version of the <tt>Screen</tt> class first introduced in <a class="docLink" href="ch12.html#ch12">Chapter 12</a>. In this case, we'll redefine <tt>Screen</tt> to be a template, parameterized by its height and width:</p>
<pre>
     template &lt;int hi, int wid&gt;
     class Screen {
     public:
         // <span class="docEmphItalicAlt">template nontype parameters used to initialize data members</span>
         Screen(): screen(hi * wid, '#'), cursor (0),
                   height(hi), width(wid) { }
         // ...
     private:
         std::string            screen;
         std::string::size_type cursor;
         std::string::size_type height, width;
     };
</pre><br>
<p class="docText">This template has two parameters, both of which are nontype parameters. When users define <tt>Screen</tt> objects, they must provide a constant expression to use for each of these parameters. The class uses these parameters in the default constructor to set the size of the default <tt>Screen</tt>.</p>
<p class="docText">As with any class template, the parameter values must be explicitly stated whenever we use the <tt>Screen</tt> type:</p>
<pre>
     Screen&lt;24,80&gt; hp2621; // <span class="docEmphItalicAlt">screen 24 lines by 80 characters</span>
</pre><br>
<p class="docText">The object <tt>hp2621</tt> uses the template instantiation <tt>Screen&lt;24, 80&gt;</tt>. The template argument for <tt>hi</tt> is 24, and the argument for <tt>wid</tt> is 80. In both cases, the template argument is a constant expression.</p>
<a name="ch16note12"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><td valign="top"><p class="docText"> Nontype template arguments must be compile-time constant expressions.</p></TD></TR></table><br>
</p></div><br>

<a name="ch16lev2sec20"></a>
<h4 class="docSection2Title">16.4.3. Friend Declarations in Class Templates</h4>
<p class="docText">There are three kinds of friend declarations that may appear in a class template. Each kind of declaration declares friendship to one or more entities:</P>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">A friend declaration for an ordinary nontemplate class or function, which grants friendship to the specific named class or function.</P></div></LI><li><div style="font-weight:normal"><p class="docList">A friend declaration for a class template or function template, which grants access to all instances of the friend.</p></div></li><LI><div style="font-weight:normal"><p class="docList">A friend declaration that grants access only to a specific instance of a class or function template.</P></div></li></ol></div>
<a name="ch16sb14"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Exercises Section 16.4.2</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><td align="right" class="docText" width="50"><a name="ch16qa12q1"></a><b>Exercise 16.36:</b></TD><td><p class="docText"><a name="idd1e129307"></a><a name="idd1e129314"></a><a name="idd1e129321"></a><a name="idd1e129328"></a>Explain what instantiations, if any, are caused by each labeled statement.</P>
<pre>
     template &lt;class T&gt; class Stack { };
     void f1(Stack&lt;char&gt;);                   // <span class="docEmphItalicAlt">(a)</span>
     class Exercise {
         Stack&lt;double&gt; &amp;rsd;                 // <span class="docEmphItalicAlt">(b)</span>
         Stack&lt;int&gt; si;                      // <span class="docEmphItalicAlt">(c)</span>
     };
     int main() {
         Stack&lt;char&gt; *sc;                    // <span class="docEmphItalicAlt">(d)</span>
         f1(*sc);                            // <span class="docEmphItalicAlt">(e)</span>
         int iObj = sizeof(Stack&lt; string &gt;); // <span class="docEmphItalicAlt">(f)</span>
     }
</pre><br>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa12q2"></a><b>Exercise 16.37:</b></td><td><p class="docText">Identify which, if any, of the following template instantiations are valid. Explain why the instantiation isn't valid.</p>
<pre>
     template &lt;class T, int size&gt; class Array { /* . . . */ };
     template &lt;int hi, int wid&gt; class Screen { /* . . . */ };
     (a) const int hi = 40, wi = 80; Screen&lt;hi, wi+32&gt; sObj;
     (b) const int arr_size = 1024; Array&lt;string, arr_size&gt; a1;
     (c) unsigned int asize = 255; Array&lt;int, asize&gt; a2;
     (e) const double db = 3.1415; Array&lt;double, db&gt; a3;
</pre><br>
</td></tr></table></p>
</blockquote>
</TD></TR></table></p><BR>
<a name="ch16lev3sec25"></a>
<h5 class="docSection3Title">Ordinary Friends</h5>
<p class="docText">A nontemplate class or function can be a friend to a class template:</P>
<pre>
     template &lt;class Type&gt; class Bar {
         // <span class="docEmphItalicAlt">grants access to ordinary, nontemplate class and function</span>
         friend class FooBar;
         friend void fcn();
         // ...
     };
</pre><BR>
<p class="docText">This declaration says that the members of <tt>FooBar</tt> and the function <tt>fcn</tt> may access the <tt>private</tt> and <tt>protected</tt> members of any instantiation of class <tt>Bar</tt>.</p>

<a name="ch16lev3sec26"></a>
<h5 class="docSection3Title">General Template Friendship</h5>
<p class="docText">A friend can be a class or function template:</p>
<pre>
     template &lt;class Type&gt; class Bar {
         // <span class="docEmphItalicAlt">grants access to</span> <span class="docEmphasis">Foo1</span> <span class="docEmphItalicAlt">or</span> <span class="docEmphasis">templ_fcn1 parameterized</span> <span class="docEmphItalicAlt">by any type</span>
         template &lt;class T&gt; friend class Foo1;
         template &lt;class T&gt; friend void templ_fcn1(const T&amp;);
         // ...
     };
</pre><br>
<p class="docText"><a name="idd1e129448"></a><a name="idd1e129455"></a>These friend declarations use a different type parameter than does the class itself. That type parameter refers to the type parameter of <tt>Foo1</tt> and <tt>templ_fcn1</tt>. In both these cases, an unlimited number of classes and functions are made friends to <tt>Bar</tt>. The friend declaration for <tt>Foo1</tt> says that any instance of <tt>Foo1</tt> may access the private elements of any instance of <tt>Bar</tt>. Similarly, any instance of <tt>templ_fcn1</tt> may access any instance of <tt>Bar</tt>.</P>
<p class="docText">This friend declaration establishes a one-to-many mapping between each instantiation of <tt>Bar</tt> and its friends, <tt>Foo1</tt> and <tt>templ_fcn1</tt>. For each instantiation of <tt>Bar</tt>, all instantiations of <tt>Foo1</tt> or <tt>templ_fcn1</tt> are friends.</p>

<a name="ch16lev3sec27"></a>
<H5 class="docSection3Title">Specific Template Friendship</H5>
<p class="docText">Rather than making all instances of a template a friend, a class can grant access to only a specific instance:</p>
<pre>
     template &lt;class T&gt; class Foo2;
     template &lt;class T&gt; void templ_fcn2(const T&amp;);
     template &lt;class Type&gt; class Bar {
          // <span class="docEmphItalicAlt">grants access to a single specific instance parameterized by</span> <span class="docEmphasis">char*</span>
          friend class Foo2&lt;char*&gt;;
          friend void templ_fcn2&lt;char*&gt;(char* const &amp;);
          // ...
     };
</pre><br>
<p class="docText">Even though <tt>Foo2</tt> itself is a class template, friendship is extended only to the specific instance of <tt>Foo2</tt> that is parameterized by <tt>char*</tt>. Similarly, the friend declaration for <tt>templ_fcn2</tt> says that only the instance of that function parameterized by <tt>char*</tt> is a friend to class <tt>Bar</tt>. The specific instantiations of <tt>Foo2</tt> and <tt>templ_fcn2</tt> parameterized by <tt>char*</tt> can access every instantiation of <tt>Bar</tt>.</p>
<p class="docText">More common are friend declarations of the following form:</P>
<pre>
     template &lt;class T&gt; class Foo3;
     template &lt;class T&gt; void templ_fcn3(const T&amp;);
     template &lt;class Type&gt; class Bar {
         // <span class="docEmphItalicAlt">each instantiation of</span> <span class="docEmphasis">Bar</span> <span class="docEmphItalicAlt">grants access to the</span>
         // <span class="docEmphItalicAlt">version of</span> <span class="docEmphasis">Foo3</span> <span class="docEmphItalicAlt">or</span> <span class="docEmphasis">templ_fcn3 instantiated</span> <span class="docEmphItalicAlt">with the same type</span>
         friend class Foo3&lt;Type&gt;;
         friend void templ_fcn3&lt;Type&gt;(const Type&amp;);
         // ...
     };
</pre><BR>
<p class="docText">These friends define friendship between a particular instantiation of <tt>Bar</tt> and the instantiation of <tt>Foo3</tt> or <tt>templ_fcn3</tt> that uses the same template argument. Each instantiation of <tt>Bar</tt> has a single associated <tt>Foo3</tt> and <tt>templ_fcn3</tt> friend:</p>
<pre>
     Bar&lt;int&gt; bi;    // <span class="docEmphasis">Foo3&lt;int&gt;</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">templ_fcn3&lt;int&gt;</span> <span class="docEmphItalicAlt">are friends</span>
     Bar&lt;string&gt; bs; // <span class="docEmphasis">Foo3&lt;string&gt;, templ_fcn3&lt;string&gt;</span> <span class="docEmphItalicAlt">are friends</span>
</pre><br>
<p class="docText">Only those versions of <tt>Foo3</tt> or <tt>templ_fcn3</tt> that have the same template argument as a given instantiation of <tt>Bar</tt> are friends. Thus, <tt>Foo3&lt;int&gt;</tt> may access the private parts of <tt>Bar&lt;int&gt;</tt> but not of <tt>Bar&lt;string&gt;</tt> or any other instantiation of <tt>Bar</tt>.</p>

<a name="ch16lev3sec28"></a>
<h5 class="docSection3Title">Declaration Dependencies</H5>
<p class="docText"><a name="idd1e129672"></a><a name="idd1e129679"></a><a name="idd1e129684"></a><a name="idd1e129689"></a>When we grant access to all instances of a given template, there need not be a declaration for that class or function template in scope. Essentially, the compiler treats the friend declaration as a declaration of the class or function as well.</p>
<p class="docText">When we want to restrict friendship to a specific instantiation, then the class or function must have been declared before it can be used in a friend declaration:</p>
<pre>
     template &lt;class T&gt; class A;
     template &lt;class T&gt; class B {
     public:
         friend class A&lt;T&gt;;      // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">A</span> <span class="docEmphItalicAlt">is known to be a template</span>
         friend class C;         // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">C</span> <span class="docEmphItalicAlt">must be an ordinary, nontemplate class</span>
         template &lt;class S&gt; friend class D; // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">D</span> <span class="docEmphItalicAlt">is a template</span>
         friend class E&lt;T&gt;;      // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">E</span> <span class="docEmphItalicAlt">wasn't declared as a template</span>
         friend class F&lt;int&gt;;    // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">F</span> <span class="docEmphItalicAlt">wasn't declared as a template</span>
      };
</pre><BR>
<p class="docText">If we have not previously told the compiler that the friend is a template, then the compiler will infer that the friend is an ordinary nontemplate class or function.</p>


<a name="ch16lev2sec21"></a>
<h4 class="docSection2Title">16.4.4. <tt>Queue</tt> and <tt>QueueItem</tt> Friend Declarations</H4>
<p class="docText">Our <tt>QueueItem</tt> class is not intended to be used by the general program: All its members are private. In order for <tt>Queue</tt> to use <tt>QueueItem, QueueItem</tt> must make <tt>Queue</tt> a friend.</p>
<a name="ch16lev3sec29"></a>
<H5 class="docSection3Title">Making a Class Template a Friend</h5>
<p class="docText">As we have just seen, when making a class template a friend, the class designer must decide how wide to make that friendship. In the case of <tt>QueueItem</tt>, we need to decide whether <tt>QueueItem</tt> should grant friendship to all <tt>Queue</tt> instances or only to a specific instance.</p>
<p class="docText">Making every <tt>Queue</tt> a friend of each <tt>QueueItem</tt> is too broad. It makes no sense to allow a <tt>Queue</tt> instantiated with the type <tt>string</tt> to access members of a <tt>QueueItem</tt> instantiated with type <tt>double</tt>. The <tt>Queue&lt;string&gt;</tt> instantiation should be a friend only to the instantiation of the <tt>QueueItem</tt> for <tt>string</tt>s. That is, we want a one-to-one mapping between a <tt>Queue</tt> and <tt>QueueItem</tt> for each type of <tt>Queue</tt> that is instantiated:</p>
<pre>
     // <span class="docEmphItalicAlt">declaration that</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">is a template needed for friend declaration in</span> <span class="docEmphasis">QueueItem</span>
     template &lt;class Type&gt; class Queue;
     template &lt;class Type&gt; class QueueItem {
         friend class Queue&lt;Type&gt;;
         // ...
      };
</pre><br>
<p class="docText">This declaration establishes the desired one-to-one mapping; only the <tt>Queue</tt> class that is instantiated with the same type as <tt>QueueItem</tt> is made a friend.</p>

<a name="ch16lev3sec30"></a>
<h5 class="docSection3Title">The <tt>Queue</tt> Output Operator</h5>
<p class="docText"><a name="idd1e129874"></a><a name="idd1e129879"></a><a name="idd1e129884"></a>One operation that might be useful to add to our <tt>Queue</tt> interface is the ability to print the contents of a <tt>Queue</tt> object. We'll do so by providing an overloaded instance of the output operator. This operator will walk the list of elements in the <tt>Queue</tt> and print the value in each element. We'll print the elements inside a pair of brackets.</p>
<p class="docText">Because we want to be able to print the contents of <tt>Queues</tt> of any type, we need to make the output operator a template as well:</p>
<pre>
     template &lt;class Type&gt;
     ostream&amp; operator&lt;&lt;(ostream &amp;os, const Queue&lt;Type&gt; &amp;q)
     {
         os &lt;&lt; "&lt; ";
         QueueItem&lt;Type&gt; *p;
         for (p = q.head; p; p = p-&gt;next)
                 os &lt;&lt; p-&gt;item &lt;&lt; " ";
         os &lt;&lt;"&gt;";
         return os;
     }
</pre><br>
<p class="docText">If a <tt>Queue</tt> of type <tt>int</tt> contains the values 3, 5, 8, and 13, the output of this <tt>Queue</tt> displays as follows:</p>
<pre>
     <span class="docEmphStrong"><tt>&lt;3 5 8 13 &gt;</tt></span>
</pre><br>
<p class="docText">If the <tt>Queue</tt> is empty, the <tt>for</tt> loop body is never executed. The effect will be to print an empty pair of brackets if the <tt>Queue</tt> is empty.</p>

<a name="ch16lev3sec31"></a>
<H5 class="docSection3Title">Making a Function Template a Friend</H5>
<p class="docText">The output operator needs to be a friend of both the <tt>Queue</tt> and <tt>QueueItem</tt> classes. It uses the <tt>head</tt> member of class <tt>Queue</tt> and the <tt>next</tt> and <tt>item</tt> members of class <tt>QueueItem</tt>. Our classes grant friendship to the specific instance of the output operator instantiated with the same type:</p>
<pre>
     // <span class="docEmphItalicAlt">function template declaration must precede friend declaration in</span> QueueItem
     template &lt;class T&gt;
     std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Queue&lt;T&gt;&amp;);
     template &lt;class Type&gt; class QueueItem {
         friend class Queue&lt;Type&gt;;
         // <span class="docEmphItalicAlt">needs access to</span> <span class="docEmphasis">item</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">next</span>
         friend std::ostream&amp;
         operator&lt;&lt; &lt;Type&gt; (std::ostream&amp;, const Queue&lt;Type&gt;&amp;);
         // ...
     };
     template &lt;class Type&gt; class Queue {
         // <span class="docEmphItalicAlt">needs access to</span> <span class="docEmphasis">head</span>
         friend std::ostream&amp;
         operator&lt;&lt; &lt;Type&gt; (std::ostream&amp;, const Queue&lt;Type&gt;&amp;);
     };
</pre><BR>
<p class="docText"><a name="idd1e130007"></a><a name="idd1e130014"></a><a name="idd1e130021"></a><a name="idd1e130028"></a><a name="idd1e130031"></a><a name="idd1e130036"></a>Each friend declaration grants access to the corresponding instantiation of the <tt>operator&lt;&lt;</tt>. That is, the output operator that prints a <tt>Queue&lt;int&gt;</tt> is a friend to class <tt>Queue&lt;int&gt;</tt> (and <tt>QueueItem&lt;int&gt;)</tt>. It is not a friend to any other <tt>Queue</tt> type.</p>

<a name="ch16lev3sec32"></a>
<h5 class="docSection3Title">Type Dependencies and the Output Operator</H5>
<p class="docText">The <tt>Queue</tt> output <tt>operator&lt;&lt;</tt> relies on the <tt>operator&lt;&lt;</tt> of <tt>item</tt> to actually print each element:</P>
<pre>
     os &lt;&lt; p-&gt;item &lt;&lt; " ";
</pre><br>
<p class="docText">When we use <tt>p-&gt;item</tt> as an operand of the <tt>&lt;&lt;</tt> operator, we are using the <tt>&lt;&lt;</tt> defined for whatever type <tt>item</tt> has.</p>
<p class="docText">This code is an example of a type dependency between <tt>Queue</tt> and the element type that <tt>Queue</tt> holds. In effect, each type bound to <tt>Queue</tt> that uses the <tt>Queue</tt> output operator must itself have an output operator. There is no language mechanism to specify or enforce that dependency in the definition of <tt>Queue</tt> itself. It is legal to create a <tt>Queue</tt> for a class that does not define the output operator but it is a compile-time (or link-time) error to print a <tt>Queue</tt> holding such a type.</p>
<a name="ch16sb15"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Exercises Section 16.4.4</H2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa13q1"></a><b>Exercise 16.38:</b></TD><TD><p class="docText">Write a <tt>Screen</tt> class template that uses nontype parameters to define the height and width of the <tt>Screen</tt>.</p>
</td></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch16qa13q2"></a><b>Exercise 16.39:</b></td><TD><p class="docText">Implement input and output operators for the template <tt>Screen</tt> class.</p>
</td></TR><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch16qa13q3"></a><b>Exercise 16.40:</b></td><td><p class="docText">Which, if any, friends are necessary in class <tt>Screen</tt> to make the input and output operators work? Explain why each friend declaration, if any, was needed.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa13q4"></a><b>Exercise 16.41:</b></td><td><p class="docText">The friend declaration for <tt>operator&lt;&lt;</tt> in class <tt>Queue</tt> was</p>
<pre>
     friend std::ostream&amp;
     operator&lt;&lt; &lt;Type&gt; (std::ostream&amp;, const Queue&lt;Type&gt;&amp;);
</pre><br>
<p class="docText">What would be the effect of writing the <tt>Queue</tt> parameter as <tt>const Queue&amp;</tt> rather than <tt>const Queue&lt;Type&gt;&amp;?</tt></P>
</TD></tr><TR valign="top"><td align="right" class="docText" width="50"><a name="ch16qa13q5"></a><b>Exercise 16.42:</b></TD><TD><p class="docText">Write an input operator that reads an <tt>istream</tt> and puts the values it reads into a <tt>Queue</tt>.</p>
</td></tr></table></p>
</blockquote>
</td></TR></table></p><BR>


<a name="ch16lev2sec22"></a>
<H4 class="docSection2Title">16.4.5. Member Templates</h4>
<p class="docText">Any class (template or otherwise) may have a member that is itself a class or function template. Such members are referred to as <b><a name="ch16term7"></a><a class="docLink" href="ch16lev1sec9.html#gloss16_07">member templates</a></b>. Member templates may not be virtual.</p>
<p class="docText">One example of a member template is the <tt>assign</tt> (<a class="docLink" href="ch09lev1sec3.html#ch09lev2sec13">Section 9.3.8</a>, p. <a class="docLink" href="ch09lev1sec3.html#ch09lev2sec13">328</a>) member of the standard containers. The version <tt>assign</tt> that takes two iterators uses a <a name="idd1e130257"></a><a name="idd1e130262"></a><a name="idd1e130267"></a>template parameter to represent the type of its iterator parameters. Another member template example is the container constructor that takes two iterators (<a class="docLink" href="ch09lev1sec1.html#ch09lev2sec1">Section 9.1.1</a>, p. <a class="docLink" href="ch09lev1sec1.html#ch09lev2sec1">307</a>). This constructor and the <tt>assign</tt> member allow containers to be built from sequences of different but compatible element types and/or different container types. Having implemented our own <tt>Queue</tt> class, we now can understand the design of these standard container members a bit better.</P>
<p class="docText">Consider the <tt>Queue</tt> copy constructor: It takes a single parameter that is a reference to a <tt>Queue&lt;Type&gt;</tt>. If we wanted to create a <tt>Queue</tt> by copying elements from a <tt>vector</tt>, we could not do so; there is no conversion from <tt>vector</tt> to <tt>Queue</tt>. Similarly, if we wanted to copy elements from a <tt>Queue&lt;short&gt;</tt> into a <tt>Queue&lt;int&gt;</tt>, we could not do so. Again, even though we can convert a <tt>short</tt> to an <tt>int</tt>, there is no conversion from <tt>Queue&lt;short&gt;</tt> to <tt>Queue&lt;int&gt;</tt>. The same logic applies to the <tt>Queue</tt> assignment operator, which also takes a parameter of type <tt>Queue&lt;Type&gt;&amp;</tt>.</P>
<p class="docText">The problem is that the copy constructor and assignment operator fix both the container and element type. We'd like to define a constructor and an <tt>assign</tt> member that allow both the container and element type to vary. When we need a parameter type to vary, we need to define a function template. In this case, we'll define the constructor and <tt>assign</tt> member to take a pair of iterators that denote a range in some other sequence. These functions will have a single template type parameter that represents an iterator type.</p>
<a name="ch16note13"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></TD><td valign="top"><p class="docText"> The standard <tt>queue</tt> class does not define these members: <tt>queue</tt> doesn't support building or assigning a <tt>queue</tt> from another container. We define these members here for illustration purposes only.</p></TD></tr></table><br>
</P></div><br>
<a name="ch16lev3sec33"></a>
<H5 class="docSection3Title">Defining a Member Template</h5>
<p class="docText">A template member declaration looks like the declaration of any template:</p>
<pre>
     template &lt;class Type&gt; class Queue {
     public:
         // <span class="docEmphItalicAlt">construct a</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">from a pair of iterators on some sequence</span>
         template &lt;class It&gt;
         Queue(It beg, It end):
               head(0), tail(0) { copy_elems(beg, end); }
         // <span class="docEmphItalicAlt">replace current</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">by contents delimited by a pair of iterators</span>
         template &lt;class Iter&gt; void assign(Iter, Iter);
         // <span class="docEmphItalicAlt">rest of</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">class as before</span>
     private:
         // <span class="docEmphItalicAlt">version of copy to be used by</span> <span class="docEmphasis">assign</span> <span class="docEmphItalicAlt">to copy elements from iterator range</span>
         template &lt;class Iter&gt; void copy_elems(Iter, Iter);
     };
</pre><br>
<p class="docText">The member declaration starts with its own template parameter list. The constructor and <tt>assign</tt> member each have a single template type parameter. These functions use that type parameter as the type for their function parameters, which are iterators denoting a range of elements to copy.</p>

<a name="ch16lev3sec34"></a>
<h5 class="docSection3Title">Defining a Member Template Outside the Class</h5>
<p class="docText"><a name="idd1e130423"></a><a name="idd1e130428"></a><a name="idd1e130435"></a>Like nontemplate members, a member template can be defined inside or outside of its enclosing class or class template definition. We have defined the constructor inside the class body. Its job is to copy the elements from the iterator range formed by its iterator arguments. It does so by calling the iterator version of <tt>copy_elems</tt> to do the actual copy.</p>
<p class="docText">When we define a member template outside the scope of a class template, we must include both template parameter lists:</p>
<pre>
     template &lt;class T&gt; template &lt;class Iter&gt;
     void Queue&lt;T&gt;::assign(Iter beg, Iter end)
     {
         destroy();            // <span class="docEmphItalicAlt">remove existing elements in this</span> <span class="docEmphasis">Queue</span>
         copy_elems(beg, end); // <span class="docEmphItalicAlt">copy elements from the input range</span>
     }
</pre><br>
<p class="docText">When a member template is a member of a class template, then its definition must include the class-template parameters as well as its own template parameters. The class-template parameter list comes first, followed by the member's own template parameter list. The definition of <tt>assign</tt> starts with</p>
<pre>
     template &lt;class T&gt; template &lt;class Iter&gt;
</pre><br>
<p class="docText">The first template parameter list <tt>template&lt;class T&gt;</tt>is that of the class template. The second template parameter list <tt>template&lt;class Iter&gt;</tt>is that of the member template.</p>
<p class="docText">The actions of our <tt>assign</tt> function are quite simple: It first calls <tt>destroy</tt>, which, as we've seen, frees the existing members of this <tt>Queue</tt>. The <tt>assign</tt> member then calls a new utility function named <tt>copy_elems</tt> to do the work of copying elements from the input range. That function is also a member template:</p>
<pre>
     template &lt;class Type&gt; template &lt;class It&gt;
     void Queue&lt;Type&gt;::copy_elems(It beg, It end)
     {
         while (beg != end) {
            push(*beg);
            ++beg;
         }
     }
</pre><BR>
<p class="docText">The iterator version of <tt>copy_elems</tt> walks through an input range denoted by a pair of iterators. It calls <tt>push</tt> on each element in that range, which actually adds the element to the <tt>Queue</tt>.</P>
<a name="ch16note14"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><TD valign="top"><p class="docText"> Because <tt>assign</tt> erases elements in the existing container, it is essential that the iterators passed to <tt>assign</tt> refer to elements in a different container. The standard container <tt>assign</tt> members and iterator constructors have the same restrictions.</P></td></tr></table><br>
</p></div><br>

<a name="ch16lev3sec35"></a>
<H5 class="docSection3Title">Member Templates Obey Normal Access Control</h5>
<p class="docText"><a name="idd1e130548"></a><a name="idd1e130553"></a><a name="idd1e130558"></a><a name="idd1e130563"></a>A member template follows the same access rules as any other class members. If the member template is private, then only member functions and friends of the class can use that member template. Because the function member template <tt>assign</tt> is a public member, it can be used by the entire program; <tt>copy_elems</tt> is private, so it can be accessed only by the friends and members of <tt>Queue</tt>.</P>

<a name="ch16lev3sec36"></a>
<H5 class="docSection3Title">Member Templates and Instantiation</h5>
<p class="docText">Like any other member, a member template is instantiated only when it is used in a program. The instantiation of member templates of class templates is a bit more complicated than the instantiation of plain member functions of class templates. Member templates have two kinds of template parameters: Those that are defined by the class and those defined by the member template itself. The class template parameters are fixed by the type of the object through which the function is called. The template parameters defined by the member act like parameters of ordinary function templates. These parameters are resolved through normal template argument deduction (<a class="docLink" href="ch16lev1sec2.html#ch16lev2sec10">Section 16.2.1</a>, p. <a class="docLink" href="ch16lev1sec2.html#ch16lev2sec10">637</a>).</p>
<p class="docText">To understand how instantiation works, let's look at uses of these members to copy and assign elements from an array of <tt>short</tt>s or a <tt>vector&lt;int&gt;:</tt></p>
<pre>
     short a[4] = { 0, 3, 6, 9 };
     // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">Queue&lt;int&gt;::Queue(short *, short *)</span>
     Queue&lt;int&gt; qi(a, a + 4); // <span class="docEmphItalicAlt">copies elements from</span> <span class="docEmphasis">a</span> <span class="docEmphItalicAlt">into</span> <span class="docEmphasis">qi</span>
     vector&lt;int&gt; vi(a, a + 4);
     // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">Queue&lt;int&gt;::assign(vector&lt;int&gt;::iterator,</span>
     //                                 vector&lt;int&gt;::iterator)
     qi.assign(vi.begin(), vi.end());
</pre><BR>
<p class="docText">Because we are constructing an object of type <tt>Queue&lt;int&gt;</tt>, we know that the compiler will instantiate the iterator-based constructor for <tt>Queue&lt;int&gt;</tt>. The type of the constructor's own template parameter is deduced by the compiler from the type of <tt>a</tt> and <tt>a +4</tt>. That type is pointer to <tt>short</tt>. Thus, the definition of <tt>qi</tt> instantiates</P>
<pre>
     void Queue&lt;int&gt;::Queue(short *, short *);
</pre><br>
<p class="docText">The effect of this constructor is to copy the elements of type <tt>short</tt> from the array named <tt>a</tt> into <tt>qi</tt>.</p>
<p class="docText">The call to <tt>assign</tt> instantiates a member of <tt>qi</tt>, which has type <tt>Queue&lt;int&gt;</tt>. Thus, this call instantiates the <tt>Queue&lt;int&gt;</tt> member named <tt>assign</tt>. That function is itself a function template. As with any other function template, the compiler deduces the template argument for <tt>assign</tt> from the arguments to the call. The type deduced is <tt>vector&lt;int&gt;::iterator</tt>, meaning that this call instantiates</p>
<pre>
     void Queue&lt;int&gt;::assign(vector&lt;int&gt;::iterator,
                             vector&lt;int&gt;::iterator);
</pre><br>


<a name="ch16lev2sec23"></a>
<H4 class="docSection2Title">16.4.6. The Complete <tt>Queue</tt> Class</h4>
<p class="docText"><a name="idd1e130713"></a>For completeness, here is the final definition of our <tt>Queue</tt> class:</p>
<pre>
     // <span class="docEmphItalicAlt">declaration that</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">is a template needed for friend declaration in</span> <span class="docEmphasis">QueueItem</span>
     template &lt;class Type&gt; class Queue;
     // <span class="docEmphItalicAlt">function template declaration must precede friend declaration in</span> <span class="docEmphasis">QueueItem</span>
     template &lt;class T&gt;
     std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Queue&lt;T&gt;&amp;);
     template &lt;class Type&gt; class QueueItem {
         friend class Queue&lt;Type&gt;;
         // <span class="docEmphItalicAlt">needs access to</span> <span class="docEmphasis">item</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">next</span>
         friend std::ostream&amp;     // <span class="docEmphItalicAlt">defined on page 659</span>
         operator&lt;&lt; &lt;Type&gt; (std::ostream&amp;, const Queue&lt;Type&gt;&amp;);
     // <span class="docEmphItalicAlt">private class: no public section</span>
         QueueItem(const Type &amp;t): item(t), next(0) { }
         Type item;           // <span class="docEmphItalicAlt">value stored in this element</span>
         QueueItem *next;     // <span class="docEmphItalicAlt">pointer to next element in the</span> <span class="docEmphasis">Queue</span>
     };
     template &lt;class Type&gt; class Queue {
         // <span class="docEmphItalicAlt">needs access to</span> <span class="docEmphasis">head</span>
         friend std::ostream&amp; // <span class="docEmphItalicAlt">defined on page 659</span>
         operator&lt;&lt; &lt;Type&gt; (std::ostream&amp;, const Queue&lt;Type&gt;&amp;);
     public:
         // <span class="docEmphItalicAlt">empty</span> <span class="docEmphasis">Queue</span>
         Queue(): head(0), tail(0) { }
         // <span class="docEmphItalicAlt">construct a</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">from a pair of iterators on some sequence</span>
         template &lt;class It&gt;
         Queue(It beg, It end):
               head(0), tail(0) { copy_elems(beg, end); }
         // <span class="docEmphItalicAlt">copy control to manage pointers to</span> <span class="docEmphasis">QueueItem</span><span class="docEmphItalicAlt">s in the</span> <span class="docEmphasis">Queue</span>
         Queue(const Queue &amp;Q): head(0), tail(0)
                                       { copy_elems(Q); }
         Queue&amp; operator=(const Queue&amp;); // <span class="docEmphItalicAlt">left as exercise for the reader</span>
         ~Queue() { destroy(); }
         // <span class="docEmphItalicAlt">replace current</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">by contents delimited by a pair of iterators</span>
         template &lt;class Iter&gt; void assign(Iter, Iter);
         // <span class="docEmphItalicAlt">return element from head of</span> <span class="docEmphasis">Queue</span>
         // <span class="docEmphItalicAlt">unchecked operation: front on an empty</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">is undefined</span>
         Type&amp; front()             { return head-&gt;item; }
         const Type &amp;front() const { return head-&gt;item; }
         void push(const Type &amp;);// <span class="docEmphItalicAlt">defined on page 652</span>
         void pop();             // <span class="docEmphItalicAlt">defined on page 651</span>
         bool empty() const {           // <span class="docEmphItalicAlt">true if no elements in the</span> <span class="docEmphasis">Queue</span>
             return head == 0;
     }
     private:
         QueueItem&lt;Type&gt; *head;   // <span class="docEmphItalicAlt">pointer to first element in</span> <span class="docEmphasis">Queue</span>
         QueueItem&lt;Type&gt; *tail;   // <span class="docEmphItalicAlt">pointer to last element in</span> <span class="docEmphasis">Queue</span>
     // <span class="docEmphItalicAlt">utility functions used by copy constructor, assignment, and destructor</span>
     void destroy();                // <span class="docEmphItalicAlt">defined on page 651</span>
     void copy_elems(const Queue&amp;); // <span class="docEmphItalicAlt">defined on page 652</span>
     // <span class="docEmphItalicAlt">version of copy to be used by</span> <span class="docEmphasis">assign</span> <span class="docEmphItalicAlt">to copy elements from iterator range</span>
     // <span class="docEmphItalicAlt">defined on page 662</span>
     template &lt;class Iter&gt; void copy_elems(Iter, Iter);
     };
     // <span class="docEmphItalicAlt">Inclusion Compilation Model: include member function definitions as well</span>
     #include "Queue.cc"
</pre><BR>
<p class="docText"><a name="idd1e130886"></a><a name="idd1e130893"></a><a name="idd1e130900"></a>Members that are not defined in the class itself can be found in earlier sections of this chapter; the comment following such members indicates the page on which the definition can be found.</p>
<a name="ch16sb16"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<H2 class="docSidebarTitle">Exercises Section 16.4.6</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa14q1"></a><b>Exercise 16.43:</b></td><td><p class="docText">Add the <tt>assign</tt> member and a constructor that takes a pair of iterators to your <tt>List</tt> class.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa14q2"></a><b>Exercise 16.44:</b></TD><TD><p class="docText">We implemented our own <tt>Queue</tt> class in order to illustrate how class templates are implemented. One way in which our implementation could be simplified would be to define <tt>Queue</tt> on top of one of the existing library container types. That way, we could avoid having to manage the allocation and deallocation of the <tt>Queue</tt> elements. Reimplement <tt>Queue</tt> using <tt>std::list</tt> to hold the actual <tt>Queue</tt> elements.</p>
</TD></tr></table></p>
</blockquote>
</TD></TR></table></p><br>

<a name="ch16lev2sec24"></a>
<h4 class="docSection2Title">16.4.7. <tt>static</tt> Members of Class Templates</h4>
<p class="docText">A class template can declare <tt>static</tt> members (<a class="docLink" href="ch12lev1sec6.html#ch12lev1sec6">Section 12.6</a>, p. <a class="docLink" href="ch12lev1sec6.html#ch12lev1sec6">467</a>) in the same way as any other class:</p>
<pre>
     template &lt;class T&gt; class Foo {
     public:
        static std::size_t count() { return ctr; }
        // <span class="docEmphItalicAlt">other interface members</span>
     private:
        static std::size_t ctr;
        // <span class="docEmphItalicAlt">other implementation members</span>
     };
</pre><BR>
<p class="docText">defines a class template named <tt>Foo</tt> that among other members has a <tt>public static</tt> member function named <tt>count</tt> and a <tt>private static</tt> data member named <tt>ctr</tt>.</p>
<p class="docText">Each instantiation of class <tt>Foo</tt> has its own <tt>static</tt> member:</P>
<pre>
     // <span class="docEmphItalicAlt">Each object shares the same</span> <span class="docEmphasis">Foo&lt;int&gt;::ctrand Foo&lt;int&gt;::count</span> <span class="docEmphItalicAlt">members</span>
     Foo&lt;int&gt; fi, fi2, fi3;
     // <span class="docEmphItalicAlt">has</span> <span class="docEmphasis">static</span> <span class="docEmphItalicAlt">members</span> <span class="docEmphasis">Foo&lt;string&gt;::ctrand Foo&lt;string&gt;::count</span>
     Foo&lt;string&gt; fs;
</pre><BR>
<p class="docText"><a name="idd1e131053"></a><a name="idd1e131062"></a><a name="idd1e131071"></a><a name="idd1e131080"></a><a name="idd1e131089"></a>Each instantiation represents a distinct type, so there is one <tt>static</tt> shared among the objects of any given instantiation. Hence, any objects of type <tt>Foo&lt;int&gt;</tt> share the same <tt>static</tt> member <tt>ctr</tt>. Objects of type <tt>Foo&lt;string&gt;</tt> share a different <tt>ctr</tt> member.</p>
<a name="ch16lev3sec37"></a>
<h5 class="docSection3Title">Using a <tt>static</tt> Member of a Class Template</h5>
<p class="docText">As usual, we can access a <tt>static</tt> member of a class template through an object of the class type or by using the scope operator to access the member directly. Of course, when we attempt to use the <tt>static</tt> member through the class, we must refer to an actual instantiation:</P>
<pre>
     Foo&lt;int&gt; fi, fi2;              // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">Foo&lt;int&gt;</span> <span class="docEmphItalicAlt">class</span>
     size_t ct = Foo&lt;int&gt;::count(); // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">Foo&lt;int&gt;::count</span>
     ct = fi.count();               // <span class="docEmphItalicAlt">ok: uses</span> <span class="docEmphasis">Foo&lt;int&gt;::count</span>
     ct = fi2.count();              // <span class="docEmphItalicAlt">ok: uses</span> <span class="docEmphasis">Foo&lt;int&gt;::count</span>
     ct = Foo::count();             // <span class="docEmphItalicAlt">error: which template instantiation?</span>
</pre><BR>
<p class="docText">Like any other member function, a <tt>static</tt> member function is instantiated only if it is used in a program.</p>

<a name="ch16lev3sec38"></a>
<h5 class="docSection3Title">Defining a <tt>static</tt> Member</h5>
<p class="docText">As with any other <tt>static</tt> data member, there must be a definition for the data member that appears outside the class. In the case of a class template <tt>static</tt>, the member definition must inidicate that it is for a class template:</p>
<pre>
     template &lt;class T&gt;
     size_t Foo&lt;T&gt;::ctr = 0; // <span class="docEmphItalicAlt">define and initialize</span> <span class="docEmphasis">ctr</span>
</pre><BR>
<p class="docText">A <tt>static</tt> data member is defined like any other member of a class template that is defined outside the class. It begins with the keyword <tt>template</tt> followed by the class template parameter list and the class name. In this case, the name of the <tt>static</tt> data member is prefixed by <tt>Foo&lt;T&gt;::</tt>, which indicates that the member belongs to the class template <tt>Foo</tt>.</p>



<a href="21001535.html"><img src="images/pixel.gif" alt="" width="1" height="1" border="0"></a><ul></UL></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch16lev1sec3.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch16lev1sec5.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>