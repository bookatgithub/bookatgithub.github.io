<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 17.1.&nbsp; Exception Handling</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch17.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch17lev1sec2.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch17lev1sec1"></a>
<h3 class="docSection1Title">17.1. Exception Handling</h3>
<p class="docText">Exception handling allows independently developed parts of a program to communicate about and handle problems that arise during execution of the program. One part of the program can detect a problem that that part of the program cannot resolve. The problem-detecting part can pass the problem along to another part that is prepared to handle what went wrong.</P>
<a name="ch17note01"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> Exceptions let us separate problem detection from problem resolution. The part of the program that detects a problem need not know how to deal with it.</P></TD></tr></table><br>
</p></div><br>
<p class="docText">In C++, exception handling relies on the problem-detecting part throwing an object to a handler. The type and contents of that object allow the two parts to communicate about what went wrong.</p>
<p class="docText"><a class="docLink" href="ch06lev1sec13.html#ch06lev1sec13">Section 6.13</a> (p. <a class="docLink" href="ch06lev1sec13.html#ch06lev1sec13">215</a>) introduced the basic concepts and mechanics of using exceptions in C++. In that section, we hypothesized that a more complex bookstore application might use exceptions to communicate about problems. For example, the <tt>Sales_item</tt> addition operator might throw an exception if the <tt>isbn</tt> members of its operands didn't match:</P>
<pre><a name="PLID0"></a><div class="v1"><a href="ch17lev1sec1.html#PLID0">[View full width]</a></div>
     // <span class="docEmphItalicAlt">throws exception if both objects do not refer to the same</span> <span class="docEmphasis">isbn</span>
     Sales_item
     operator+(const Sales_item&amp; lhs, const Sales_item&amp; rhs)
     {
         if (!lhs.same_isbn(rhs))
             throw runtime_error("Data must refer to same ISBN");
         // <span class="docEmphItalicAlt">ok, if we're still here the ISBNs are the same so it's okay to do the addition</span>
         Sales_item ret(lhs);                   // <span class="docEmphItalicAlt">copy</span> <span class="docEmphasis">lhs</span> <span class="docEmphItalicAlt">into a local object that we'll
<img border="0" width="14" height="9" alt="" align="left" src="images/ccc.gif"> return</span>
         ret += rhs;                            // <span class="docEmphItalicAlt">add in the contents of</span> <span class="docEmphasis">rhs</span>
         return ret;                            // <span class="docEmphItalicAlt">return a copy of</span> <span class="docEmphasis">ret</span>
     }
</pre><br>
<p class="docText"><a name="idd1e134546"></a><a name="idd1e134551"></a><a name="idd1e134556"></a><a name="idd1e134562"></a>Those parts of the program that added <tt>Sales_item</tt> objects would use a <tt>TRy</tt> block in order to catch an exception if one occured:</P>
<pre>
     // <span class="docEmphItalicAlt">part of the application that interacts with the user</span>
     Sales_item item1, item2, sum;
     while (cin &gt;&gt; item1 &gt;&gt; item2) {       // <span class="docEmphItalicAlt">read two transactions</span>
         try {
             sum = item1 + item2;         // <span class="docEmphItalicAlt">calculate their sum</span>
             // <span class="docEmphItalicAlt">use</span> <span class="docEmphasis">sum</span>
         } catch (const runtime_error &amp;e) {
           cerr &lt;&lt; e.what() &lt;&lt; " Try again.\n"
                &lt;&lt; endl;
         }
     }
</pre><br>
<p class="docText">In this section we'll expand our coverage of these basics and cover some additional exception-handling facilities. Effective use of exception handling requires understanding what happens when an exception is thrown, what happens when it is caught, and the meanings of the objects used to communicate what went wrong.</p>
<a name="ch17lev2sec1"></a>
<h4 class="docSection2Title">17.1.1. Throwing an Exception of Class Type</H4>
<p class="docText">An exception is <B><a name="ch17term20"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_20">raised</a></b> by <b><a name="ch17term25"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_25">throwing</a></b> an object. The type of that object determines which handler will be invoked. The selected handler is the one nearest in the call chain that matches the type of the object.</p>
<p class="docText">Exceptions are thrown and caught in ways that are similar to how arguments are passed to functions. An exception can be an object of any type that can be passed to a nonreference parameter, meaning that it must be possible to copy objects of that type.</p>
<p class="docText">Recall that when we pass an argument of array or function type, that argument is automatically converted to an pointer. The same automatic conversion happens for objects that are thrown. As a consequence, there are no exceptions of array or function types. Instead, if we <tt>throw</tt> an array, the thrown object is converted to a pointer to the first element in the array. Similarly, if we throw a function, the function is converted to a pointer to the function (<a class="docLink" href="ch07lev1sec9.html#ch07lev1sec9">Section 7.9</a>, p. <a class="docLink" href="ch07lev1sec9.html#ch07lev1sec9">276</a>).</P>
<p class="docText">When a <tt>throw</tt> is executed, the statement(s) following the <tt>throw</tt> are not executed. Instead, control is transferred from the <tt>tHRow</tt> to the matching <tt>catch</tt>. That <tt>catch</tt> might be local to the same function or might be in a function that directly or indirectly called the function in which the exception occurred. The fact that control passes from one location to another has two important implications:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">Functions along the call chain are prematurely exited. <a class="docLink" href="#ch17lev2sec2">Section 17.1.2</a> (p. <a class="docLink" href="#ch17lev2sec2">691</a>) discusses what happens when functions are exited due to an exception.</P></div></li><LI><div style="font-weight:normal"><p class="docList">In general, the storage that is local to a block that throws an exception is not around when the exception is handled.</p></div></li></ol></div>
<p class="docText">Because local storage is freed while handling an exception, the object that is thrown is not stored locally. Instead, the <tt>throw</tt> expression is used to initialize <a name="idd1e134671"></a><a name="idd1e134674"></a><a name="idd1e134679"></a>a special object referred to as the <b><a name="ch17term9"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_09">exception object</a></b>. The exception object is managed by the compiler and is guaranteed to reside in space that will be accessible to whatever <tt>catch</tt> is invoked. This object is created by a <tt>throw</tt>, and is initialized as a copy of the expression that is thrown. The exception object is passed to the corresponding <tt>catch</tt> and is destroyed after the exception is completely handled.</p>
<a name="ch17note02"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> The exception object is created by copying the result of the thrown expression; that result must be of a type that can be copied.</p></td></TR></table><BR>
</p></div><BR>
<a name="ch17lev3sec1"></a>
<h5 class="docSection3Title">Exception Objects and Inheritance</h5>
<p class="docText">In practice, many applications throw expressions whose type comes from an inheritance hierarchy. As we'll see in <a class="docLink" href="#ch17lev2sec7">Section 17.1.7</a> (p. <a class="docLink" href="#ch17lev2sec7">697</a>), the standard exceptions (<a class="docLink" href="ch06lev1sec13.html#ch06lev1sec13">Section 6.13</a>, p. <a class="docLink" href="ch06lev1sec13.html#ch06lev1sec13">215</a>) are defined in an inheritance hierarchy. What's important to know at this point is how the form of the <tt>tHRow</tt> expression interacts with types related by inheritance.</P>
<a name="ch17note03"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> When an exception is thrown, the static, compile-time type of the thrown object determines the type of the exception object.</P></td></TR></table><BR>
</p></div><br>
<p class="docText">Ordinarily, the fact that the object is thrown using its static type is not an issue. When we throw an exception, we usually construct the object we are going to throw at the throw point. That object represents what went wrong, so we know the precise exception type.</p>

<a name="ch17lev3sec2"></a>
<H5 class="docSection3Title">Exceptions and Pointers</H5>
<p class="docText">The one case where it matters that a throw expression throws the static type is if we dereference a pointer in a throw. The result of dereferencing a pointer is an object whose type matches the type of the pointer. If the pointer points to a type from an inheritance hierarchy, it is possible that the type of the object to which the pointer points is different from the type of the pointer. Regardless of the object's actual type, the type of the exception object matches the static type of the pointer. If that pointer is a base-class type pointer that points to a derived-type object, then that object is sliced down (<a class="docLink" href="ch15lev1sec3.html#ch15lev2sec10">Section 15.3.1</a>, p. <a class="docLink" href="ch15lev1sec3.html#ch15lev2sec10">577</a>); only the base-class part is thrown.</p>
<p class="docText">A problem more serious than slicing the object may arise if we <tt>throw</tt> the pointer itself. In particular, it is always an error to <tt>throw</tt> a pointer to a local object for the same reasons as it is an error to return a pointer to a local object (<a class="docLink" href="ch07lev1sec3.html#ch07lev2sec14">Section 7.3.2</a>, p. <a class="docLink" href="ch07lev1sec3.html#ch07lev2sec14">249</a>) from a function. When we <tt>throw</tt> a pointer, we must be certain that the object to which the pointer points will exist when the handler is entered.</P>
<p class="docText">If we <tt>throw</tt> a pointer to a local object and the handler is in another function, then the object to which the pointer points will no longer exist when the handler is executed. Even if the handler is in the same function, we must be sure that the object to which the pointer points exists at the site of the <tt>catch</tt>. If the pointer points to an object in a block that is exited before the <tt>catch</tt>, then that local object will have been destroyed before the <tt>catch</tt>.</p>
<a name="ch17note04"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></TD><td valign="top"><p class="docText"><a name="idd1e134798"></a><a name="idd1e134803"></a><a name="idd1e134808"></a><a name="idd1e134813"></a><a name="idd1e134816"></a><a name="idd1e134822"></a> It is usually a bad idea to <tt>tHRow</tt> a pointer: Throwing a pointer requires that the object to which the pointer points exist wherever the corresponding handler resides.</p></td></tr></table><br>
</p></div><br>
<a name="ch17sb01"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 17.1.1</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch17qa1q1"></a><B>Exercise 17.1:</b></td><TD><p class="docText">What is the type of the exception object in the following <tt>throw</tt>s:</p>
<pre>
     (a) range_error r("error");  (b) exception *p = &amp;r;
         throw r;                     throw *p;
</pre><BR>
</TD></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch17qa1q2"></a><b>Exercise 17.2:</b></td><TD><p class="docText">What would happen if the second <tt>throw</tt> were written as <tt>tHRow p</tt>?</P></td></tr></table></p>
</blockquote>
</TD></TR></table></p><br>


<a name="ch17lev2sec2"></a>
<h4 class="docSection2Title">17.1.2. Stack Unwinding</h4>
<p class="docText">When an exception is thrown, execution of the current function is suspended and the search begins for a matching <tt>catch</tt> clause. The search starts by checking whether the <tt>tHRow</tt> itself is located inside a <tt>try</tt> block. If so, the <tt>catch</tt> clauses associated with that <tt>try</tt> are examined to see if one of them matches the thrown object. If a matching <tt>catch</tt> is found, the exception is handled. If no <tt>catch</tt> is found, the current function is exitedits memory is freed and local objects are destroyedand the search continues in the calling function.</P>
<p class="docText">If the call to the function that threw is in a <tt>try</tt> block, then the <tt>catch</tt> clauses associated with that <tt>try</tt> are examined. If a matching <tt>catch</tt> is found, the exception is handled. If no matching <tt>catch</tt> is found, the calling function is also exited, and the search continues in the function that called this one.</P>
<p class="docText">This process, known as <b><a name="ch17term23"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_23">stack unwinding</a></b>, continues up the chain of nested function calls until a <tt>catch</tt> clause for the exception is found. As soon as a <tt>catch</tt> clause that can handle the exception is found, that <tt>catch</tt> is entered, and execution continues within this handler. When the <tt>catch</tt> completes, execution continues at the point immediately after the last <tt>catch</tt> clause associated with that <tt>TRy</tt> block.</p>
<a name="ch17lev3sec3"></a>
<h5 class="docSection3Title">Destructors Are Called for Local Objects</h5>
<p class="docText">During stack unwinding, the function containing the <tt>throw</tt>, and possibly other functions in the call chain, are exited prematurely. In general, these functions will have created local objects that ordinarily would be destroyed when the function exited. When a function is exited due to an exception, the compiler guarantees that the local objects are properly destroyed. As each function exits, its local storage is freed. Before releasing the memory, any local object that was created before the exception occurred is destroyed. If the local object is of class type, the destructor for this object is called automatically. As usual, the compiler does no work to destroy an object of built-in type.</p>
<a name="ch17note05"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"><a name="idd1e134967"></a><a name="idd1e134971"></a><a name="idd1e134976"></a><a name="idd1e134981"></a><a name="idd1e134986"></a><a name="idd1e134990"></a> During stack unwinding, the memory used by local objects is freed and destructors for local objects of class type are run.</p></td></tr></table><BR>
</P></div><br>
<p class="docText">If a block directly allocates a resource, and the exception occurs before that resource is freed, that resource will not be freed during stack unwinding. For example, a block might dynamically allocate memory through a call to <tt>new</tt>. If the block exits due to an exception, the compiler does not <tt>delete</tt> the pointer. The allocated memory will not be freed.</P>
<p class="docText">Resources allocated by an object of class type generally will be properly freed. Destructors for local objects are run; resources allocated by class-type objects ordinarily are freed by their destructor. <a class="docLink" href="#ch17lev2sec8">Section 17.1.8</a> (p. <a class="docLink" href="#ch17lev2sec8">700</a>) describes a programming technique that uses classes to manage resource allocation in the face of exceptions.</p>

<a name="ch17lev3sec4"></a>
<h5 class="docSection3Title">Destructors Should Never <tt>tHRow</tt> Exceptions</H5>
<p class="docText">Destructors are often executed during stack unwinding. When destructors are executing, the exception has been raised but not yet handled. It is unclear what should happen if a destructor itself throws a new exception during this process. Should the new exception supersede the earlier exception that has not yet been handled? Should the exception in the destructor be ignored?</p>
<p class="docText">The answer is that while stack unwinding is in progress for an exception, a destructor that throws another exception of its own that it does not also handle, causes the library <b><a name="ch17term24"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_24"><span class="docEmphStrong"><tt>terminate</tt></span></a></b> function is called. Ordinarily, <tt>terminate</tt> calls <b><a name="ch17term1"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_01"><span class="docEmphStrong"><tt>abort</tt></span></a></b>, forcing an abnormal exit from the entire program.</p>
<p class="docText">Because <tt>terminate</tt> ends the program, it is usually a very bad idea for a destructor to do anything that might cause an exception. In practice, because destructors free resources, it is unlikely that they throw exceptions. The standard library types all guarantee that their destructors will not raise an exception.</p>

<a name="ch17lev3sec5"></a>
<H5 class="docSection3Title">Exceptions and Constructors</h5>
<p class="docText">Unlike destructors, it is often the case that something done inside a constructor might throw an exception. If an exception occurs while constructing an object, then the object might be only partially constructed. Some of its members might have been initialized, and others might not have been initialized before the exception occurs. Even if the object is only partially constructed, we are guaranteed that the constructed members will be properly destroyed.</P>
<p class="docText">Similarly, an exception might occur when initializing the elements of an array or other container type. Again, we are guaranteed that the constructed elements will be destroyed.</P>

<a name="ch17lev3sec6"></a>
<h5 class="docSection3Title">Uncaught Exceptions Terminate the Program</h5>
<p class="docText">An exception cannot remain unhandled. An exception is an important enough event that the program cannot continue executing normally. If no matching <tt>catch</tt> is found, then the program calls the library <tt>terminate</tt> function.</p>


<a name="ch17lev2sec3"></a>
<H4 class="docSection2Title">17.1.3. Catching an Exception</H4>
<p class="docText"><a name="idd1e135087"></a><a name="idd1e135092"></a><a name="idd1e135099"></a><a name="idd1e135106"></a><a name="idd1e135113"></a><a name="idd1e135121"></a><a name="idd1e135126"></a><a name="idd1e135133"></a><a name="idd1e135141"></a>The <b><a name="ch17term12"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_12">exception specifier</a></b> in a <b><a name="ch17term4"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_04">catch clause</a></b> looks like a parameter list that contains exactly one parameter. The exception specifier is a type name followed by an optional parameter name.</p>
<p class="docText">The type of the specifier determines what kinds of exceptions the handler can <tt>catch</tt>. The type must be a complete type: It must either be a built-in type or a programmer-defined type that has already been defined. A forward declaration for the type is not sufficient.</p>
<p class="docText">An exception specifier can omit the parameter name when a <tt>catch</tt> needs to know only the type of the exception in order to handle it. If the handler needs information beyond what type of exception occurred, then its exception specifier will include a parameter name. The <tt>catch</tt> uses the name to get access to the exception object.</P>
<a name="ch17lev3sec7"></a>
<h5 class="docSection3Title">Finding a Matching Handler</h5>
<p class="docText">During the search for a matching <tt>catch</tt>, the<tt>catch</tt> that is found is not necessarily the one that matches the exception best. Instead, the <tt>catch</tt> that is selected is the first <tt>catch</tt> found that can handle the exception. As a consequence, in a list of <tt>catch</tt> clauses, the most specialized <tt>catch</tt> must appear first.</P>
<p class="docText">The rules for when an exception matches a <tt>catch</tt> exception specifier are much more restrictive than the rules used for matching arguments with parameter types. Most conversions are not allowedthe types of the exception and the <tt>catch</tt> specifier must match exactly with only a few possible differences:</p>
<ul><LI><p class="docList">Conversions from non<tt>const</tt> to <tt>const</tt> are allowed. That is, a <tt>throw</tt> of a non<tt>const</tt> object can match a <tt>catch</tt> specified to take a <tt>const</tt> reference.</P></li><li><p class="docList">Conversions from derived type to base type are allowed.</p></li><li><p class="docList">An array is converted to a pointer to the type of the array; a function is converted to the appropriate pointer to function type.</p></li></ul>
<p class="docText">No other conversions are allowed when looking for a matching <tt>catch</tt>. In particular, neither the standard arithmetic conversions nor conversions defined for class types are permitted.</p>

<a name="ch17lev3sec8"></a>
<h5 class="docSection3Title">Exception Specifiers</h5>
<p class="docText">When a <tt>catch</tt> is entered, the <tt>catch</tt> parameter is initialized from the exception object. As with a function parameter, the exception-specifier type might be a reference. The exception object itself is a copy of the object that was thrown. Whether the exception object is copied again into the <tt>catch</tt> site depends on the exception-specifier type.</p>
<p class="docText">If the specifier is not a reference, then the exception object is copied into the <tt>catch</tt> parameter. The <tt>catch</tt> operates on a local copy of the exception object. Any changes made to the <tt>catch</tt> parameter are made to the copy, not to the exception object itself. If the specifier is a reference, then like a reference parameter, there <a name="idd1e135275"></a><a name="idd1e135282"></a><a name="idd1e135289"></a>is no separate <tt>catch</tt> object; the <tt>catch</tt> parameter is just another name for the exception object. Changes made to the <tt>catch</tt> parameter are made to the exception object.</p>

<a name="ch17lev3sec9"></a>
<H5 class="docSection3Title">Exception Specifiers and Inheritance</H5>
<p class="docText">Like a parameter declaration, an exception specifier for a base class can be used to <tt>catch</tt> an exception object of a derived type. Again, like a parameter declaration, the static type of the exception specifier determines the actions that the <tt>catch</tt> clause may perform. If the exception object thrown is of derived-class type but is handled by a <tt>catch</tt> that takes a base-class type, then the <tt>catch</tt> cannot use any members that are unique to the derived type.</p>
<a name="ch17note06"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></TD><TD valign="top"><p class="docText"> Usually, a <tt>catch</tt> clause that handles an exception of a type related by inheritance ought to define its parameter as a reference.</p></td></tr></table><br>
</p></div><BR>
<p class="docText">If the <tt>catch</tt> parameter is a reference type, then the <tt>catch</tt> object accesses the exception object directly. The static type of the <tt>catch</tt> object and the dynamic type of the exception object to which it refers might differ. If the specifier is not a reference, then the <tt>catch</tt> object is a copy of the exception object. If the <tt>catch</tt> object in an object of the base type and the exception object has derived type, then the exception object is sliced down (<a class="docLink" href="ch15lev1sec3.html#ch15lev2sec10">Section 15.3.1</a>, p. <a class="docLink" href="ch15lev1sec3.html#ch15lev2sec10">577</a>) to its base-class subobject.</p>
<p class="docText">Moreover, as we saw in <a class="docLink" href="ch15lev1sec2.html#ch15lev2sec6">Section 15.2.4</a> (p. <a class="docLink" href="ch15lev1sec2.html#ch15lev2sec6">566</a>), objects (as opposed to references) are not polymorphic. When we use a virtual function on an object rather than through a reference, the object's static and dynamic type are the same; the fact that the function is virtual makes no difference. Dynamic binding happens only for calls through a reference or pointer, not calls on an object.</P>

<a name="ch17lev3sec10"></a>
<H5 class="docSection3Title">Ordering of Catch Clauses Must Reflect Type Hierarchy</h5>
<p class="docText">When exception types are organized in class hierarchies, users may choose the level of granularity with which their applications will deal with an exception. For example, an application that merely wants to do cleanup and exit might define a single <span class="docEmphRoman"><a name="ch17term26"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_26">try block</a></span> that encloses the code in <tt>main</tt> with a <tt>catch</tt> such as the following:</p>
<pre>
    catch(exception &amp;e) {
        // <span class="docEmphItalicAlt">do cleanup</span>
        // <span class="docEmphItalicAlt">print a message</span>
        cerr &lt;&lt; "Exiting: " &lt;&lt; e.what() &lt;&lt; endl;
        size_t status_indicator = 42;  // <span class="docEmphItalicAlt">set and return an</span>
        return(status_indicator);      // <span class="docEmphItalicAlt">error indicator</span>
    }
</pre><br>
<p class="docText">Other programs with more rigorous uptime requirements might need finer control over exceptions. Such applications will clear whatever caused the exception and continue processing.</P>
<p class="docText">Because <tt>catch</tt> clauses are matched in the order in which they appear, programs that use exceptions from an inheritance hierarchy must order their <tt>catch</tt> clauses so that handlers for a derived type occurs before a <tt>catch</tt> for its base type.</P>
<a name="ch17note07"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"><a name="idd1e135429"></a><a name="idd1e135434"></a><a name="idd1e135437"></a> Multiple <tt>catch</tt> clauses with types related by inheritance must be ordered from most derived type to least derived.</p></td></TR></table><br>
</p></div><BR>
<a name="ch17sb02"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<h2 class="docSidebarTitle">Exercises Section 17.1.3</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch17qa2q1"></a><b>Exercise 17.3:</b></td><td><p class="docText">Explain why this <tt>try</tt> block is incorrect. Correct it.</p>
<pre>
          try {
              // <span class="docEmphItalicAlt">use of the C++ standard library</span>
          } catch(exception) {
              // ...
          } catch(const runtime_error &amp;re) {
              // ...
          } catch(overflow_error eobj) { /* ... */ }
</pre><br>
</td></TR></table></P>
</blockquote>
</td></TR></table></p><br>


<a name="ch17lev2sec4"></a>
<H4 class="docSection2Title">17.1.4. Rethrow</H4>
<p class="docText">It is possible that a single <tt>catch</tt> cannot completely handle an exception. After some corrective actions, a <tt>catch</tt> may decide that the exception must be handled by a function further up the chain of function calls. A <tt>catch</tt> can pass the exception out to another <tt>catch</tt> further up the list of function calls by <b><a name="ch17term21"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_21">rethrowing</a></b> the exception. A rethrow is a <tt>throw</tt> that is not followed by a type or an expression:</p>
<pre>
    throw;
</pre><br>
<p class="docText">An empty <tt>throw</tt> rethrows the exception object. An empty <tt>tHRow</tt> can appear only in a <tt>catch</tt> or in a function called (directly or indirectly) from a <tt>catch</tt>. If an empty <tt>throw</tt> is encountered when a handler is not active, <tt>terminate</tt> is called.</P>
<p class="docText">Although the rethrow does not specify its own exception, an exception object is still passed up the chain. The exception that is thrown is the original exception object, not the <tt>catch</tt> parameter. When a <tt>catch</tt> parameter is a base type, then we cannot know the actual type thrown by a rethrow expression. That type depends on the dynamic type of the exception object, not the static type of the <tt>catch</tt> parameter. For example, a rethrow from a <tt>catch</tt> with a parameter of base type might actually <tt>tHRow</tt> an object of the derived type.</p>
<p class="docText">In general, a <tt>catch</tt> might change its parameter. If, after changing its parameter, the <tt>catch</tt> rethrows the exception, then those changes will be propagated only if the exception specifier is a reference:</p>
<pre>
    catch (my_error &amp;eObj) {        // <span class="docEmphItalicAlt">specifier is a reference type</span>
        eObj.status = severeErr;    // <span class="docEmphItalicAlt">modifies the exception object</span>
        throw; // <span class="docEmphItalicAlt">the</span> <span class="docEmphasis">status</span> <span class="docEmphItalicAlt">member of the exception object is</span> <span class="docEmphasis">severeErr</span>
    } catch (other_error eObj) {    // <span class="docEmphItalicAlt">specifier is a nonreference type</span>
        eObj.status = badErr;       // <span class="docEmphItalicAlt">modifies local copy only</span>
        throw; // <span class="docEmphItalicAlt">the</span> <span class="docEmphasis">status</span> <span class="docEmphItalicAlt">member of the exception rethrown is unchanged</span>
    }
</pre><br>

<a name="ch17lev2sec5"></a>
<H4 class="docSection2Title">17.1.5. The Catch-All Handler</H4>
<p class="docText"><a name="idd1e135614"></a><a name="idd1e135622"></a><a name="idd1e135630"></a><a name="idd1e135638"></a><a name="idd1e135646"></a>A function may want to perform some action before it exits with a thrown exception, even though it cannot handle the exception that is thrown. Rather than provide a specific <tt>catch</tt> clause for every possible exception, and because we can't know all the exceptions that might be thrown, we can use a <b><a name="ch17term3"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_03">catch-all</a></b> <tt>catch</tt> clause. A catch-all clause has the form <tt>(...)</tt>. For example:</p>
<pre>
     // <span class="docEmphItalicAlt">matches any exception that might be thrown</span>
     catch (...) {
         // <span class="docEmphItalicAlt">place our code here</span>
     }
</pre><br>
<p class="docText">A catch-all clause matches any type of exception.</p>
<p class="docText">A <tt>catch(...)</tt> is often used in combination with a rethrow expression. The <tt>catch</tt> does whatever local work can be done and then rethrows the exception:</P>
<pre>
    void manip() {
       try {
           // <span class="docEmphItalicAlt">actions that cause an exception to be thrown</span>
       }
       catch (...) {
           // <span class="docEmphItalicAlt">work to partially handle the exception</span>
           throw;
       }
    }
</pre><br>
<p class="docText">A <tt>catch(...)</tt> clause can be used by itself or as one of several catch clauses.</p>
<a name="ch17note08"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><td valign="top"><p class="docText"> If a <tt>catch(...)</tt> is used in combination with other <tt>catch</tt> clauses, it must be last; otherwise, any <tt>catch</tt> clause that followed it could never be matched.</P></td></tr></table><br>
</p></div><br>

<a name="ch17lev2sec6"></a>
<h4 class="docSection2Title">17.1.6. Function Try Blocks and Constructors</h4>
<p class="docText">In general, exceptions can occur at any point in the program's execution. In particular, an exception might occur in a constructor, or while processing a constructor initializer. Constructor initializers are processed before the constructor body is entered. A <tt>catch</tt> clause inside the constructor body cannot handle an exception that might occur while processing a constructor initializer.</p>
<p class="docText">To handle an exception from a constructor initializer, we must write the constructor as a <b><a name="ch17term14"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_14">function <span class="docEmphStrong"><tt>try</tt></span> block</a></b>. A function try block lets us associate a group of <tt>catch</tt> clauses with the function as a whole. As an example, we might wrap our <tt>Handle</tt> constructor from <a class="docLink" href="ch16.html#ch16">Chapter 16</a> in a try block to detect a failure in <tt>new</tt>:</p>
<pre>
    template &lt;class T&gt; Handle&lt;T&gt;::Handle(T *p)
    try : ptr(p), use(new size_t(1))
    {
         // <span class="docEmphItalicAlt">empty function body</span>
    }  catch(const std::bad_alloc &amp;e)
           { handle_out_of_memory(e); }
</pre><br>
<a name="ch17sb03"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<h2 class="docSidebarTitle">Exercises Section 17.1.5</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch17qa3q1"></a><B>Exercise 17.4:</b></td><td><p class="docText"><a name="idd1e135785"></a><a name="idd1e135791"></a>Given a basic C++ program,</p>
<pre>
     int main() {
         // <span class="docEmphItalicAlt">use of the C++ standard library</span>
     }
</pre><br>
<p class="docText">modify <tt>main</tt> to catch any exception thrown by functions in the C++ standard library. The handlers should print the error message associated with the exception before calling <tt>abort</tt> (defined in the header <tt>cstdlib</tt>) to terminate <tt>main</tt>.</p>
</TD></tr><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch17qa3q2"></a><b>Exercise 17.5:</b></td><td><p class="docText">Given the following exception types and <tt>catch</tt> clauses, write a <tt>tHRow</tt> expression that creates an exception object that could be caught by each <tt>catch</tt> clause.</P>
<pre>
    (a) class exceptionType { };
        catch(exceptionType *pet) { }
    (b) catch(...) { }
    (c) enum mathErr { overflow, underflow, zeroDivide };
        catch(mathErr &amp;ref) { }
    (d) typedef int EXCPTYPE;
        catch(EXCPTYPE) { }
</pre><br>
</td></tr></table></p>
</blockquote>
</TD></tr></table></p><BR>
<p class="docText">Notice that the keyword <tt>try</tt> precedes the member initialization list, and the compound statement of the try block encompasses the constructor function body. The <tt>catch</tt> clause can handle exceptions thrown either from within the member initialization list or from within the constructor body.</p>
<a name="ch17note09"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> The only way for a constructor to handle an exception from a constructor initializer is to write the constructor as a function try block.</p></td></tr></table><br>
</p></div><br>

<a name="ch17lev2sec7"></a>
<h4 class="docSection2Title">17.1.7. Exception Class Hierarchies</h4>
<p class="docText"><a class="docLink" href="ch06lev1sec13.html#ch06lev1sec13">Section 6.13</a> (p. <a class="docLink" href="ch06lev1sec13.html#ch06lev1sec13">215</a>) introduced the standard-library exception classes. What that section did not cover is that these classes are related by inheritance. The inheritance hierarchy is portrayed in <a class="docLink" href="#ch17fig01">Figure 17.1</a> on the following page.</p>
<a name="ch17fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 17.1. Standard <tt>exception</tt> Class Hierarchy</H5>

<p class="docText">
<img border="0" alt="" width="475" height="331" SRC="images/0201721481/graphics/17fig01.gif;400478"></P>

</center></p><BR>
<p class="docText">The only operation the <tt>exception</tt> types define is a virtual member named <tt>what</tt>. That function returns a <tt>const char*</tt>. It typically returns the message used when constructing the exception object at the throw site. Because <tt>what</tt> is virtual if we catch a base-type reference, a call to the <tt>what</tt> function will execute the version appropriate to the dynamic type of the exception object.</p>
<a name="ch17lev3sec11"></a>
<h5 class="docSection3Title">Exception Classes for a Bookstore Application</H5>
<p class="docText">The standard exception classes can be used for quite a number of applications. In addition, applications often extend the <tt>exception</tt> hierarchy by deriving additional types from <tt>exception</tt> or one of the intermediate base classes. These newly derived classes can represent exception types specific to the application domain.</P>
<p class="docText"><a name="idd1e135941"></a><a name="idd1e135946"></a><a name="idd1e135952"></a>If we were building a real bookstore application, our classes would have been much more complex than the ones presented in this primer. One way in which they might be more elaborate would be in their handling of exceptions. In fact, we probably would have defined our own hierarchy of exceptions to represent application-specific problems that might arise. Our design might include classes such as</p>
<pre>
    // <span class="docEmphItalicAlt">hypothetical exception classes for a bookstore application</span>
    class out_of_stock: public std::runtime_error {
    public:
        explicit out_of_stock(const std::string &amp;s):
                           std::runtime_error(s) { }
    };
    class isbn_mismatch: public std::logic_error {
    public:
        explicit isbn_mismatch(const std::string &amp;s):
                              std::logic_error(s) { }
        isbn_mismatch(const std::string &amp;s,
            const std::string &amp;lhs, const std::string &amp;rhs):
            std::logic_error(s), left(lhs), right(rhs) { }
        const std::string left, right;
        // <span class="docEmphItalicAlt"><a class="docLink" href="#ch17lev2sec10">Section 17.1.10</a> (p. <a class="docLink" href="#ch17lev2sec10">706</a>) explains the destructor and why we need one</span>
        virtual ~isbn_mismatch() throw() { }
    };
</pre><br>
<p class="docText"><a name="idd1e135978"></a><a name="idd1e135982"></a><a name="idd1e135987"></a>Here we defined our application-specific exception types by deriving them from the standard exception classes. As with any hierarchy, we can think of the exception classes as being organized into layers. As the hierarchy becomes deeper, each layer becomes a more specific exception. For example, the first and most general layer of the hierarchy is represented by class <tt>exception</tt>. All we know when we catch an object of this type is that something has gone wrong.</p>
<p class="docText">The second layer specializes <tt>exception</tt> into two broad categories: run-time or logic errors. Our bookstore exception classes represent an even more specialized layer. The class <tt>out_of_stock</tt> represents something that can go wrong at run time that is particular to our application. It would be used to signal that an order cannot be fulfilled. The <tt>isbn_mismatch</tt> exception is a more particular form of <tt>logic_error</tt>. In principle, a program could detect that the ISBNs don't match by calling <tt>same_isbn</tt>.</p>

<a name="ch17lev3sec12"></a>
<h5 class="docSection3Title">Using Programmer-Defined Exception Types</H5>
<p class="docText">We use our own exception classes in the same way that we use one of the standard library classes. One part of the program throws an object of one of these types, and another part catches and handles the indicated problem. As an example, we might define the overloaded addition operator for our <tt>Sales_item</tt> class to <tt>throw</tt> an error of type <tt>isbn_mismatch</tt> if it detected that the ISBNs didn't match:</P>
<pre>
     // <span class="docEmphItalicAlt">throws exception if both objects do not refer to the same</span> <span class="docEmphasis">isbn</span>
     Sales_item
     operator+(const Sales_item&amp; lhs, const Sales_item&amp; rhs)
     {
         if (!lhs.same_isbn(rhs))
             throw isbn_mismatch("isbn mismatch",
                                 lhs.book(), rhs.book());
         Sales_item ret(lhs);  // <span class="docEmphItalicAlt">copy</span> <span class="docEmphasis">lhs</span> <span class="docEmphItalicAlt">into a local object that we'll return</span>
         ret += rhs;           // <span class="docEmphItalicAlt">add in the contents of</span> <span class="docEmphasis">rhs</span>
         return ret;           // <span class="docEmphItalicAlt">return</span> <span class="docEmphasis">ret</span> <span class="docEmphItalicAlt">by value</span>
     }
</pre><BR>
<p class="docText">Code that uses the addition operator could then detect this error, write an appropriate error message, and continue:</p>
<pre>
     // <span class="docEmphItalicAlt">use hypothetical bookstore exceptions</span>
     Sales_item item1, item2, sum;
     while (cin &gt;&gt; item1 &gt;&gt; item2) {    // <span class="docEmphItalicAlt">read two transactions</span>
         try {
             sum = item1 + item2;       // <span class="docEmphItalicAlt">calculate their sum</span>
             // <span class="docEmphItalicAlt">use</span> <span class="docEmphasis">sum</span>
         } catch (const isbn_mismatch &amp;e) {
           cerr &lt;&lt; e.what() &lt;&lt; ": left isbn(" &lt;&lt; e.left
                &lt;&lt; ") right isbn(" &lt;&lt; e.right &lt;&lt; ")"
                &lt;&lt; endl;
         }
</pre><br>


<a name="ch17lev2sec8"></a>
<h4 class="docSection2Title">17.1.8. Automatic Resource Deallocation</H4>
<p class="docText"><a name="idd1e136107"></a><a name="idd1e136112"></a><a name="idd1e136117"></a><a name="idd1e136122"></a><a name="idd1e136127"></a><a name="idd1e136130"></a><a name="idd1e136135"></a><a name="idd1e136140"></a><a name="idd1e136144"></a><a name="idd1e136147"></a>In <a class="docLink" href="#ch17lev2sec2">Section 17.1.2</a> (p. <a class="docLink" href="#ch17lev2sec2">691</a>) we saw that local objects are automatically destroyed when an exception occurs. The fact that destructors are run has important implication for the design of applications. It also is one (among many) reasons why we encourage the use of the standard library classes. Consider the following function:</P>
<pre>
     void f()
     {
         vector&lt;string&gt; v;                   // <span class="docEmphItalicAlt">local</span> <span class="docEmphasis">vector</span>
         string s;
         while (cin &gt;&gt; s)
             v.push_back(s);                 // <span class="docEmphItalicAlt">populate the</span> <span class="docEmphasis">vector</span>
         string *p = new string[v.size()];   // <span class="docEmphItalicAlt">dynamic array</span>
         // <span class="docEmphItalicAlt">remaining processing</span>
         // <span class="docEmphItalicAlt">it is possible that an exception occurs in this code</span>
         // <span class="docEmphItalicAlt">function cleanup is bypassed if an exception occurs</span>
         delete [] p;
     }   // <span class="docEmphasis">v</span> <span class="docEmphItalicAlt">destroyed automatically when the function exits</span>
</pre><br>
<p class="docText">This function defines a local <tt>vector</tt> and dynamically allocates an array. Under normal execution, both the array and the <tt>vector</tt> are destroyed before the function exits. The array is freed by the last statement in the function, and the <tt>vector</tt> is automatically destroyed when the function ends.</p>
<p class="docText">However, if an exception occurs inside the function, then the <tt>vector</tt> will be destroyed but the array will not be freed. The problem is that the array is not freed automatically. An exception that occurs after the <tt>new</tt> but before the corresponding <tt>delete</tt> leaves the array undestroyed. No matter when an exception occurs, we are guaranteed that the <tt>vector</tt> destructor is run.</p>
<a name="ch17lev3sec13"></a>
<h5 class="docSection3Title">Using Classes to Manage Resource Allocation</H5>
<p class="docText">The fact that destructors are run leads to an important programming technique that makes programs more <b><a name="ch17term10"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_10">exception safe</a></b>. By exception safe, we mean that the programs operate correctly even if an exception occurs. In this case, the &quot;safety&quot; comes from ensuring that any resouce that is allocated is properly freed if an exception occurs.</p>
<p class="docText">We can guarantee that resources are properly freed by defining a class to encapsulate the acquisition and release of a resource. This technique is often referred to as &quot;resource allocation is initialization,&quot; often abreviated as RAII.</P>
<p class="docText">The resource-managing class should be designed so that the constructor acquires the resource and the destructor frees it. When we want to allocate the resource, we define an object of that class type. If no exception occurs, then the resource will be freed when the object that acquired the resource goes out of scope. More importantly, if an exception occurs after the object is created but before it goes out of scope, then the compiler ensures that the object is destroyed as part of unwinding the scope in which the object was defined.</p>
<p class="docText">The following class is a prototypical example in which the constructor acquires a resource and the destructor releases it:</p>
<pre>
    class Resource {
    public:
        Resource(parms p): r(allocate(p)) { }
        ~Resource() { release(r); }
        // <span class="docEmphItalicAlt">also need to define copy and assignment</span>
    private:
        resource_type *r;           // <span class="docEmphItalicAlt">resource managed by this type</span>
        resource_type *allocate(parms p);     // <span class="docEmphItalicAlt">allocate this resource</span>
        void release(resource_type*);         // <span class="docEmphItalicAlt">free this resource</span>
    };
</pre><BR>
<p class="docText">The <tt>Resource</tt> class is a type that allocates and deallocates a resource. It holds data member(s) that represent that resource. The constructor for <tt>Resource</tt> allocates the resource, and the destructor frees it. When we use this class</p>
<pre>
    void fcn()
    {
       Resource res(args);   // <span class="docEmphItalicAlt">allocates</span> <span class="docEmphasis">resource_type</span>
       // <span class="docEmphItalicAlt">code that might throw an exception</span>
       // <span class="docEmphItalicAlt">if exception occurs, destructor for</span> <span class="docEmphasis">res</span> <span class="docEmphItalicAlt">is run automatically</span>
       // ...
    }  // <span class="docEmphasis">res</span> <span class="docEmphItalicAlt">goes out of scope and is destroyed automatically</span>
</pre><BR>
<p class="docText">the resource is automatically freed. If the function terminates normally, then the resource is freed when the <tt>Resource</tt> object goes out of scope. If the function is exited prematurely by an exception, the destructor for <tt>Resource</tt> is run by the compiler as part of the exception handling process.</p>
<a name="ch17note10"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><td valign="top"><p class="docText"> Programs in which exceptions are possible and that allocate resources should use classes to manage those resources. As described in this section, using classes to manage acquisition and deallocation ensures that resources are freed if an exception occurs.</p></td></tr></table><br>
</p></div><br>
<a name="ch17sb04"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<h2 class="docSidebarTitle">Exercises Section 17.1.8</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch17qa4q1"></a><B>Exercise 17.6:</b></td><td><p class="docText">Given the following function, explain what happens when the exception occurs.</p>
<pre>
     void exercise(int *b, int *e)
     {
         vector&lt;int&gt; v(b, e);
         int *p = new int[v.size()];
         ifstream in("ints");
         // <span class="docEmphItalicAlt">exception occurs here</span>
         // ...
     }
</pre><br>
</td></TR><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch17qa4q2"></a><B>Exercise 17.7:</b></td><td><p class="docText">There are two ways to make the previous code exception-safe. Describe them and implement them.</p></TD></TR></table></p>
</blockquote>
</td></tr></table></p><BR>


<a name="ch17lev2sec9"></a>
<h4 class="docSection2Title">17.1.9. The <tt>auto_ptr</tt> Class</h4>
<p class="docText"><a name="idd1e136371"></a><a name="idd1e136379"></a><a name="idd1e136385"></a>The standard-library <B><a name="ch17term2"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_02"><span class="docEmphStrong"><tt>auto_ptr</tt></span></a></b> class is an example of the exception-safe &quot;resource allocation is initialization&quot; technique described in the previous subsection. The <tt>auto_ptr</tt> class is a template that takes a single type parameter. It provides exception safety for dynamically allocated objects. The <tt>auto_ptr</tt> class is defined in the <tt>memory</tt> header.</p>
<a name="ch17note11"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></TD><td valign="top"><p class="docText"> <tt>auto_ptr</tt> can be used only to manage single objects returned from <tt>new</tt>. It does not manage dynamically allocated arrays.</p></td></tr></table><br>
<p class="docText">As we'll see, <tt>auto_ptr</tt> has unusual behavior when copied or assigned. As a result, <tt>auto_ptrs</tt> may not be stored in the library container types.</p>
</p></div><br>
<p class="docText">An <tt>auto_ptr</tt> may hold only a pointer to an object and may not be used to point to a dynamically allocated array. Using an <tt>auto_ptr</tt> to point to a dynamically allocated array results in undefined run-time behavior.</p>
<p class="docText">Each <tt>auto_ptr</tt> is either unbound or it points to an object. When an <tt>auto_ptr</tt> points to an object, it can be said to &quot;own&quot; that object. When the <tt>auto_ptr</tt> goes out of scope or is otherwise destroyed, then the dynamically allocated object to which the <tt>auto_ptr</tt> points is automatically deallocated.</p>
<a name="ch17lev3sec14"></a>
<h5 class="docSection3Title">Using <tt>auto_ptr</tt> for Exception-Safe Memory Allocation</h5>
<p class="docText">If memory is acquired through a normal pointer and an exception occurs before a <tt>delete</tt> is executed, then that memory won't be freed automatically:</p>
<pre>
     void f()
     {
        int *ip = new int(42);     // <span class="docEmphItalicAlt">dynamically allocate a new object</span>
        // <span class="docEmphItalicAlt">code that throws an exception that is not caught inside</span> <span class="docEmphasis">f</span>
        delete ip;                 // <span class="docEmphItalicAlt">return the memory before exiting</span>
     }
</pre><BR>
<p class="docText">If an exception happens between the <tt>new</tt> and the <tt>delete</tt>, and if that exception is not caught locally, then the <tt>delete</tt> will not be executed. The memory will never be returned.</P>
<p class="docText">If we use an <tt>auto_ptr</tt> instead, the memory will be freed automatically, even if the block is exited prematurely:</p>
<pre>
     void f()
     {
        auto_ptr&lt;int&gt; ap(new int(42)); // <span class="docEmphItalicAlt">allocate a new object</span>
        // <span class="docEmphItalicAlt">code that throws an exception that is not caught inside</span> <span class="docEmphasis">f</span>
     }
              // <span class="docEmphasis">auto_ptr</span> <span class="docEmphItalicAlt">freed automatically when function ends</span>
</pre><BR>
<p class="docText">In this case, the compiler ensures that the destructor for <tt>ap</tt> is run before the stack is unwound past <tt>f</tt>.</p>
<a name="ch17table01"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 17.1. Class <tt>auto_ptr</tt></H5></caption><colgroup><col width="150"><col width="350"></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>auto_ptr&lt;T&gt; ap;</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Create an unbound <tt>auto_ptr</tt> named <tt>ap</tt>.</P></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>auto_ptr&lt;T&gt; ap(p);</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Create an <tt>auto_ptr</tt> named <tt>ap</tt> that owns the object pointed to by the pointer <tt>p</tt>. This constructor is <tt>explicit</tt>.</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>auto_ptr&lt;T&gt; ap1(ap2);</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Create an <tt>auto_ptr</tt> named <tt>ap1</tt> that holds the pointer originally stored in <tt>ap2</tt>. TRansfers ownership to <tt>ap1</tt>; <tt>ap2</tt> becomes an unbound <tt>auto_ptr</tt>.</p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>ap1 = ap2</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Transfers ownership from <tt>ap2</tt> to <tt>ap1</tt>. Deletes the object to which <tt>ap1</tt> points and makes <tt>ap1</tt> point to the object to which <tt>ap2</tt> points, making <tt>ap2</tt> unbound.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>~ap</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Destructor. Deletes the object to which <tt>ap</tt> points.</p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>*ap</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns a reference to the object to which <tt>ap</tt> is bound.</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>ap-&gt;</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Returns the pointer that <tt>ap</tt> holds.</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>ap.reset(p)</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">If the pointer <tt>p</tt> is not the same value as <tt>ap</tt> holds, then it deletes the object to which <tt>ap</tt> points and binds <tt>ap</tt> to <tt>p</tt>.</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>ap.release()</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Returns the pointer that <tt>ap</tt> had held and makes <tt>ap</tt> unbound.</p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>ap.get()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns the pointer that <tt>ap</tt> holds.</p></td></tr></table></p><br>

<a name="ch17lev3sec15"></a>
<h5 class="docSection3Title"><tt>auto_ptr</tt> Is a Template and Can Hold Pointers of Any Type</h5>
<p class="docText"><a name="idd1e136770"></a><a name="idd1e136777"></a>The <tt>auto_ptr</tt> class is a template taking a single type parameter. That type names the type of the object to which the <tt>auto_ptr</tt> may be bound. Thus, we can create <tt>auto_ptrs</tt> of any type:</p>
<pre>
    auto_ptr&lt;string&gt; ap1(new string("Brontosaurus"));
</pre><br>

<a name="ch17lev3sec16"></a>
<h5 class="docSection3Title">Binding an <tt>auto_ptr</tt> to a Pointer</H5>
<p class="docText">In the most common case, we initialize an <tt>auto_ptr</tt> to the address of an object returned by a <tt>new</tt> expression:</P>
<pre>
    auto_ptr&lt;int&gt; pi(new int(1024));
</pre><br>
<p class="docText">This statement initializes <tt>pi</tt> to the address of the object created by the <tt>new</tt> expression. This <tt>new</tt> expression initializes that <tt>int</tt> to the value 1,024.</P>
<p class="docText">The constructor that takes a pointer is an <tt>explicit</tt> (<a class="docLink" href="ch12lev1sec4.html#ch12lev2sec23">Section 12.4.4</a>, p. <a class="docLink" href="ch12lev1sec4.html#ch12lev2sec23">462</a>) constructor, so we must use the direct form of initialization to create an <tt>auto_ptr:</tt></p>
<pre>
    // <span class="docEmphItalicAlt">error: constructor that takes a pointer is explicit and can't be used implicitly</span>
    auto_ptr&lt;int&gt; pi = new int(1024);
    auto_ptr&lt;int&gt; pi(new int(1024)); // <span class="docEmphItalicAlt">ok: uses direct initialization</span>
</pre><br>
<p class="docText">The object created by the <tt>new</tt> expression to which <tt>pi</tt> refers is deleted automatically when <tt>pi</tt> goes out of scope. If <tt>pi</tt> is a local object, the object to which <tt>pi</tt> refers is deleted at the end of the block in which <tt>pi</tt> is defined. If an exception occurs, then <tt>pi</tt> also goes out of scope. The destructor for <tt>pi</tt> will be run automatically as <a name="idd1e136893"></a><a name="idd1e136902"></a><a name="idd1e136909"></a>part of handling the exception. If <tt>pi</tt> is a global object, the object to which <tt>pi</tt> refers is deleted at the end of the program.</P>

<a name="ch17lev3sec17"></a>
<H5 class="docSection3Title">Using an <tt>auto_ptr</tt></h5>
<p class="docText">Suppose we wish to access a <tt>string</tt> operation. With an ordinary <tt>string</tt> pointer, we'd do the following:</p>
<pre>
    string *pstr_type = new string("Brontosaurus");
    if (pstr_type-&gt;empty())
        // <span class="docEmphItalicAlt">oops, something wrong</span>
</pre><br>
<p class="docText">The <tt>auto_ptr</tt> class defines overloaded versions of the dereference (<tt>*</tt>) and arrow (<tt>-&gt;</tt>) operators (<a class="docLink" href="ch14lev1sec6.html#ch14lev1sec6">Section 14.6</a>, p. <a class="docLink" href="ch14lev1sec6.html#ch14lev1sec6">523</a>). Because <tt>auto_ptr</tt> defines these operators, we can use an <tt>auto_ptr</tt> in some ways that are similar to using a built-in pointer:</p>
<pre>
     // <span class="docEmphItalicAlt">normal pointer operations for dereference and arrow</span>
     *ap1 = "TRex";       // <span class="docEmphItalicAlt">assigns a new value to the object to which</span> <span class="docEmphasis">ap1</span> <span class="docEmphasis">points</span>
     string s = *ap1;     // <span class="docEmphItalicAlt">initializes s as a copy of the object to which</span> <span class="docEmphasis">ap1</span> <span class="docEmphItalicAlt">points</span>
     if (ap1-&gt;empty())    // <span class="docEmphItalicAlt">runs</span> <span class="docEmphasis">empty</span> <span class="docEmphItalicAlt">on the</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">to which</span> <span class="docEmphasis">ap1</span> <span class="docEmphItalicAlt">points</span>
</pre><br>
<p class="docText">The primary purpose of <tt>auto_ptr</tt> is to support ordinary pointerlike behavior while ensuring that the object to which an <tt>auto_ptr</tt> object refers is automatically deleted. As we'll see, the fact that objects are automatically deleted leads to significant differences between <tt>auto_ptrs</tt> and ordinary pointers with respect to how we copy and access their address value.</P>

<a name="ch17lev3sec18"></a>
<h5 class="docSection3Title">Copy and Assignment on <tt>auto_ptr</tt> Are Destructive Operations</H5>
<a name="ch17note12"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> There is a crucially important difference between how <tt>auto_ptr</tt> and built-in pointers treat copy and assignment. When we copy an <tt>auto_ptr</tt> or assign its value to another <tt>auto_ptr</tt>, ownership of the underlying object is transferred from the original to the copy. The original <tt>auto_ptr</tt> is reset to an unbound state.</P></td></tr></table><br>
</p></div><BR>
<p class="docText">Copying (or assigning) ordinary pointers copies (assigns) the address. After the copy (assignment), both pointers point to the same object. After copying (or assigning) <tt>auto_ptrs</tt>, the original points to no object and the new <tt>auto_ptr</tt> (left-hand <tt>auto_ptr)</tt> owns the underlying object:</p>
<pre>
     auto_ptr&lt;string&gt; ap1(new string("Stegosaurus"));
     // <span class="docEmphItalicAlt">after the copy</span> <span class="docEmphasis">ap1</span> <span class="docEmphItalicAlt">is unbound</span>
     auto_ptr&lt;string&gt; ap2(ap1);  // <span class="docEmphItalicAlt">ownership transferred from</span> <span class="docEmphasis">ap1</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">ap2</span>
</pre><br>
<p class="docText">When we copy or assign an <tt>auto_ptr</tt>, the right-hand <tt>auto_ptr</tt> relinquishes all responsibility for the underlying object and is reset to be an unbound <tt>auto_ptr</tt>. In our example, it is <tt>ap2</tt> that deletes the <tt>string</tt> object, and not <tt>ap1</tt>. After the copy, <tt>ap1</tt> no longer refers to any object.</P>
<p class="docText"><a name="idd1e137131"></a><a name="idd1e137138"></a><a name="idd1e137147"></a><a name="idd1e137154"></a>Unlike other copy or assignment operations, <tt>auto_ptr</tt> copy and assignment change the right-hand operand. As a result, both the left- and right-hand operands to assignment must be modifiable lvalues.</p>

<a name="ch17lev3sec19"></a>
<h5 class="docSection3Title">Assignment Deletes the Object Pointed To by the Left Operand</H5>
<p class="docText">In addition to transferring ownership from the right-hand to the left-hand operand, assignment also deletes the object to which the left-hand operand originally referredprovided that the two objects are different. As usual, self-assignment has no effect.</p>
<pre>
     auto_ptr&lt;string&gt; ap3(new string("Pterodactyl"));
     // <span class="docEmphItalicAlt">object pointed to by</span> <span class="docEmphasis">ap3</span> <span class="docEmphItalicAlt">is deleted and ownership transferred from</span> <span class="docEmphasis">ap2</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">ap3;</span>
     ap3 = ap2;  // <span class="docEmphItalicAlt">after the assignment,</span> <span class="docEmphasis">ap2</span> <span class="docEmphItalicAlt">is unbound</span>
</pre><BR>
<p class="docText">After the assignment of <tt>ap2</tt> to <tt>ap3</tt>,</p>
<ul><li><p class="docList">the object to which <tt>ap3</tt> had pointed is deleted;</p></li><li><p class="docList"><tt>ap3</tt> is set to point to the object to which <tt>ap2</tt> pointed; and</p></li><li><p class="docList"><tt>ap2</tt> is an unbound <tt>auto_ptr</tt>.</p></li></ul>
<a name="ch17note13"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><TD valign="top"><p class="docText"> Because copy and assignment are destructive operations, <tt>auto_ptrs</tt> <span class="docEmphasis">cannot</span> be stored in the standard containers. The library container classes require that two objects be equal after a copy or assignment. This requirement is not met by <tt>auto_ptr</tt>. If we assign <tt>ap2</tt> to <tt>ap1</tt>, then after the assignment <tt>ap1 != ap2</tt>. Similarly for copy.</p></td></TR></table><BR>
</p></div><br>

<a name="ch17lev3sec20"></a>
<h5 class="docSection3Title">The Default <tt>auto_ptr</tt> Constructor</h5>
<p class="docText">If no initializer is given, the <tt>auto_ptr</tt> is <span class="docEmphasis">unbound</span>; it doesn'trefertoanobject:</p>
<pre>
     auto_ptr&lt;int&gt; p_auto;  // <span class="docEmphasis">p_auto</span><span class="docEmphItalicAlt">doesn't refer to any object</span>
</pre><BR>
<p class="docText">By default, the internal pointer value of an <tt>auto_ptr</tt> is set to 0. Dereferencing an unbound <tt>auto_ptr</tt> has the same effect as dereferencing an unbound pointerthe program is in error and what happens is undefined:</p>
<pre>
    *p_auto = 1024;  // <span class="docEmphItalicAlt">error: dereference</span> <span class="docEmphasis">auto_ptr</span> <span class="docEmphItalicAlt">that doesn't point to an object</span>
</pre><BR>

<a name="ch17lev3sec21"></a>
<H5 class="docSection3Title">Testing an <tt>auto_ptr</tt></h5>
<p class="docText">To check whether a pointer is unbound, we can test the pointer directly in a condition, which has the effect of determining whether the pointer is 0. In contrast, we cannot test an <tt>auto_ptr</tt> directly.</p>
<pre>
    // <span class="docEmphItalicAlt">error: cannot use an</span> <span class="docEmphasis">auto_ptr</span> <span class="docEmphItalicAlt">as a condition</span>
    if (p_auto)
        *p_auto = 1024;
</pre><br>
<p class="docText"><a name="idd1e137357"></a><a name="idd1e137366"></a>The <tt>auto_ptr</tt> type does not define a conversion to a type that can be used as a condition. Instead, to test the <tt>auto_ptr</tt>, we must use its <tt>get</tt> member, which returns the underlying pointer contained in the <tt>auto_ptr:</tt></P>
<pre>
    // <span class="docEmphItalicAlt">revised test to guarantee</span> <span class="docEmphasis">p_auto</span> <span class="docEmphItalicAlt">refers to an object</span>
    if (p_auto.get())
        *p_auto = 1024;
</pre><BR>
<p class="docText">To determine whether the <tt>auto_ptr</tt> object refers to an object, we can compare the return from <tt>get</tt> with 0.</p>
<a name="ch17note14"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></TD><td valign="top"><p class="docText"> <tt>get</tt> should be used only to interrogate an <tt>auto_ptr</tt> or to use the returned pointer value. <tt>get</tt> should not be used as an argument to create another <tt>auto_ptr</tt>.</p></TD></tr></table><br>
</P></div><br>
<p class="docText">Using <tt>get</tt> member to initialize another <tt>auto_ptr</tt> violates the class design principle that only one <tt>auto_ptr</tt> holds a given pointer at any one time. If two <tt>auto_ptrs</tt> hold the same pointer, then the pointer will be <tt>delete</tt>d twice.</P>

<a name="ch17lev3sec22"></a>
<h5 class="docSection3Title">The <tt>reset</tt> Operation</h5>
<p class="docText">Another difference between <tt>auto_ptr</tt> and a built-in pointer is that we cannot assign an address (or other pointer) directly to an <tt>auto_ptr:</tt></p>
<pre>
     p_auto = new int(1024); // <span class="docEmphItalicAlt">error: cannot assign a pointer to an</span> <span class="docEmphasis">auto_ptr</span>
</pre><br>
<p class="docText">Instead, we must call <tt>reset</tt> to change the pointer:</p>
<pre>
     // <span class="docEmphItalicAlt">revised test to guarantee</span> <span class="docEmphasis">p_auto</span> <span class="docEmphItalicAlt">refers to an object</span>
     if (p_auto.get())
         *p_auto = 1024;
     else
         // <span class="docEmphItalicAlt">reset</span> <span class="docEmphasis">p_auto</span> <span class="docEmphItalicAlt">to a new object</span>
         p_auto.reset(new int(1024));
</pre><br>
<p class="docText">To unset the <tt>auto_ptr</tt> object, we could pass 0 to <tt>reset</tt>.</p>
<a name="ch17note15"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> Calling <tt>reset</tt> on an <tt>auto_ptr</tt> deletes the object (if any) to which the <tt>auto_ptr</tt> refers before binding the <tt>auto_ptr</tt> to another object. However, just as self-assignment has no effect, if we call <tt>reset</tt> on the same pointer that the <tt>auto_ptr</tt> already holds, then there is no effect; the object is not deleted.</p></TD></TR></table><br>
</P></div><br>


<a name="ch17lev2sec10"></a>
<h4 class="docSection2Title">17.1.10. Exception Specifications</H4>
<p class="docText">When looking at an ordinary function declaration, it is not possible to determine what exceptions the function might throw. However, it can be useful to know whether and which exceptions a function might throw in order to write appropriate <tt>catch</tt> clauses. An <B><a name="ch17term11"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_11">exception specification</a></b> specifies that if the function throws an exception, the exception it throws will be one of the exceptions included in the specification, or it will be a type derived from one of the listed exceptions.</p>
<a name="ch17sb05"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Caution: <tt>Auto_ptr</tt> Pitfalls</H2>
<p class="docText"><a name="idd1e137566"></a><span class="docEmphStrong">The <tt>auto_ptr</tt> class template provides a measure of safety and convenience for handling dynamically allocated memory. To use <tt>auto_ptr</tt> correctly, we must adhere to the restrictions that the class imposes:</span></p>
<div style="font-weight:bold"><ol class="docList" type="1"><LI><div style="font-weight:normal"><p class="docList"><span class="docEmphStrong">Do not use an <tt>auto_ptr</tt> to hold a pointer to a statically allocated object. Otherwise, when the <tt>auto_ptr</tt> itself is destroyed, it will attempt to delete a pointer to a nondynamically allocated object, resulting in undefined behavior.</span></P></div></li><li><div style="font-weight:normal"><p class="docList"><span class="docEmphStrong">Never use two <tt>auto_ptrs</tt> to refer to the same object. One obvious way to make this mistake is to use the same pointer to initialize or to <tt>reset</tt> two different <tt>auto_ptr</tt> objects. A more subtle way to make this mistake would be to use the result from <tt>get</tt> on one <tt>auto_ptr</tt> to initialize or <tt>reset</tt> another.</span></p></div></LI><LI><div style="font-weight:normal"><p class="docList"><span class="docEmphStrong">Do not use an <tt>auto_ptr</tt> to hold a pointer to a dynamically allocated array. When the <tt>auto_ptr</tt> is destroyed, it frees only a single objectit uses the plain <tt>delete</tt> operator, not the array <tt>delete []</tt> operator.</span></p></div></li><li><div style="font-weight:normal"><p class="docList"><span class="docEmphStrong">Do not store an <tt>auto_ptr</tt> in a container. Containers require that the types they hold define copy and assignment to behave similarly to how those operations behave on the built-in types: After the copy (or assignment), the two objects must have the same value. <tt>auto_ptr</tt> does not meet this requirement.</span></p></div></LI></ol></div>
</td></tr></table></P><br>
<a name="ch17sb06"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<H2 class="docSidebarTitle">Exercises Section 17.1.9</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch17qa5q1"></a><b>Exercise 17.8:</b></td><td><p class="docText">Which of the following <tt>auto_ptr</tt> declarations are illegal or likely to result in subsequent program error? Explain what the problem is with each one.</p>
<pre>
     int ix = 1024, *pi = &amp;ix, *pi2 = new int(2048);
     typedef auto_ptr&lt;int&gt; IntP;
     (a) IntP p0(ix);               (b) IntP p1(pi);
     (c) IntP p2(pi2);              (d) IntP p3(&amp;ix);
     (e) IntP p4(new int(2048));    (f) IntP p5(p2.get());
</pre><br>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch17qa5q2"></a><B>Exercise 17.9:</b></TD><td><p class="docText">Assuming <tt>ps</tt> is a pointer to <tt>string</tt>, what is the difference, if any, between the following two invocations of <tt>assign</tt> (<a class="docLink" href="ch09lev1sec6.html#ch09lev2sec19">Section 9.6.2</a>, p. <a class="docLink" href="ch09lev1sec6.html#ch09lev2sec19">339</a>)? Which do you think is preferable? Why?</P>
<pre>
     (a) ps.get()-&gt;assign("Danny");  (b) ps-&gt;assign("Danny");
</pre><br>
</td></TR></table></P>
</blockquote>
</td></tr></table></p><br>
<a name="ch17lev3sec23"></a>
<h5 class="docSection3Title">Defining an Exception Specification</H5>
<p class="docText">An exception specification follows the function parameter list. An exception specification is the keyword <tt>throw</tt> followed by a (possibly empty) list of exception types enclosed in parentheses:</P>
<pre>
     void recoup(int) throw(runtime_error);
</pre><BR>
<p class="docText">This declaration says that <tt>recoup</tt> is a function taking an <tt>int</tt>, and returning<tt>void</tt>. If <tt>recoup</tt> throws an exception, that exception will be a <tt>runtime_error</tt> or an exception of a type derived from <tt>runtime_error</tt>.</p>
<p class="docText"><a name="idd1e137754"></a><a name="idd1e137761"></a><a name="idd1e137767"></a><a name="idd1e137773"></a><a name="idd1e137778"></a><a name="idd1e137783"></a>An empty specification list says that the function does not throw any exception:</p>
<pre>
     void no_problem() throw();
</pre><BR>
<p class="docText">An exception specification is part of the function's interface. The function definition and any declarations of the function must have the same specification.</P>
<a name="ch17note16"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> If a function declaration does not specify an exception specification, the function can throw exceptions of any type.</p></td></TR></table><br>
</p></div><BR>

<a name="ch17lev3sec24"></a>
<h5 class="docSection3Title">Violating the Exception Specification</H5>
<p class="docText">Unfortunately, it is not possible to know at compile time whether or which exceptions a program will throw. Violations of a function's exception specification can be detected only at run time.</p>
<p class="docText">If a function throws an exception not listed in its specification, the library function <b><a name="ch17term27"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_27"><span class="docEmphStrong"><tt>unexpected</tt></span></a></b> is invoked. By default, <tt>unexpected</tt> calls <tt>terminate</tt>, which ordinarily aborts the program.</p>
<a name="ch17note17"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> The compiler cannot and does not attempt to verify exception specifications at compile time.</p></td></tr></table><br>
</p></div><BR>
<p class="docText">Even if a casual reading of a function's code indicates that it <span class="docEmphasis">might</span> throw an exception missing from the specification, the compiler will not complain:</P>
<pre>
     void f() throw()          // <span class="docEmphItalicAlt">promise not to throw any exception</span>
     {
         throw exception();    // <span class="docEmphItalicAlt">violates exception specification</span>
     }
</pre><br>
<p class="docText">Instead, the compiler generates code to ensure that <tt>unexpected</tt> is called if an exception violating the exception specification is thrown.</P>

<a name="ch17lev3sec25"></a>
<h5 class="docSection3Title">Specifying that the Function Does Not Throw</h5>
<p class="docText">Because an exception specification cannot be checked at compile time, the practical utility of exception specifications is often limited.</P>
<a name="ch17note18"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><td valign="top"><p class="docText"> One important case when an exception specification is useful is if a function can guarantee that it will not throw any exceptions.</p></TD></tr></table><BR>
</P></div><br>
<p class="docText">Specifying that a function will not <tt>throw</tt> any exceptions can be helpful both to users of the function and to the compiler: Knowing that a function will not <tt>throw</tt> simplifies the task of writing exception-safe code that calls that function. We can know that we need not worry about exceptions when calling it. Moreover, if the compiler knows that no exceptions will be thrown, it can perform optimizations that are suppressed for code that might throw.</P>

<a name="ch17lev3sec26"></a>
<H5 class="docSection3Title">Exception Specifications and Member Functions</h5>
<p class="docText"><a name="idd1e137897"></a><a name="idd1e137902"></a><a name="idd1e137907"></a>As with nonmember functions, an exception specification on a member function declaration follows the function parameter list. For example, the class <tt>bad_alloc</tt> from the C++ standard library is defined so that all its member functions have an empty exception specification. These members promise not to throw an exception:</p>
<pre>
     // <span class="docEmphItalicAlt">ilustrative definition of library</span> <span class="docEmphasis">bad_alloc</span> <span class="docEmphItalicAlt">class</span>
     class bad_alloc : public exception {
     public:
         bad_alloc() throw();
         bad_alloc(const bad_alloc &amp;) throw();
         bad_alloc &amp; operator=(const
         bad_alloc &amp;) throw();
         virtual ~bad_alloc() throw();
         virtual const char* what() const throw();
     };
</pre><br>
<p class="docText">Notice that the exception specification follows the <tt>const</tt> qualifier in <tt>const</tt> member function declarations.</p>

<a name="ch17lev3sec27"></a>
<H5 class="docSection3Title">Exception Specifications and Destructors</h5>
<p class="docText">In <a class="docLink" href="#ch17lev2sec7">Section 17.1.7</a> (p. <a class="docLink" href="#ch17lev2sec7">697</a>) we showed two hypothetical bookstore application exception classes. The <tt>isbn_mismatch</tt> class defines its destructor as</p>
<pre>
     class isbn_mismatch: public std::logic_error {
     public:
         virtual ~isbn_mismatch() throw() { }
     };
</pre><BR>
<p class="docText">and said that we would explain this usage here.</p>
<p class="docText">The <tt>isbn_mismatch</tt> class inherits from <tt>logic_error</tt>, which is one of the standard exception classes. The destructors for the standard exception classes include an empty <tt>throw()</tt> specifier; they promise that they will not throw any exceptions. When we inherit from one of these classes, then our destructor must also promise not to throw any exceptions.</P>
<p class="docText">Our <tt>out_of_stock</tt> class had no members, and so its synthesized destructor does nothing that might throw an exception. Hence, the compiler can know that the synthesized destructor will abide by the promise not to throw.</p>
<p class="docText">The <tt>isbn_mismatch</tt> class has two members of class <tt>string</tt>, which means that the synthesized destructor for <tt>isbn_mismatch</tt> calls the <tt>string</tt> destructor. The C++ standard stipulates that <tt>string</tt> destructor, like any other library class destructor, will not throw an exception. However, the library destructors do not define exception specifications. In this case, we know, but the compiler doesn't, that the <tt>string</tt> destructor won't throw. We must define our own destructor to reinstate the promise that the destructor will not throw.</P>

<a name="ch17lev3sec28"></a>
<h5 class="docSection3Title">Exception Specifications and Virtual Functions</h5>
<p class="docText">A virtual function in a base class may have an exception specification that differs from the exception specification of the corresponding virtual in a derived class. <a name="idd1e138017"></a><a name="idd1e138022"></a><a name="idd1e138027"></a>However, the exception specification of a derived-class virtual function must be either equally or more restrictive than the exception specification of the corresponding base-class virtual function.</p>
<p class="docText">This restriction ensures that when a pointer to a base-class type is used to call a derived virtual function, the exception specification of the derived class adds no new exceptions to those that the base said could be thrown. For example,</p>
<pre>
     class Base {
     public:
         virtual double f1(double) throw ();
         virtual int f2(int) throw (std::logic_error);
         virtual std::string f3() throw
               (std::logic_error, std::runtime_error);
     };
     class Derived : public Base {
     public:
         // <span class="docEmphItalicAlt">error: exception specification is less restrictive than</span> <span class="docEmphasis">Base::f1</span><span class="docEmphItalicAlt">'s</span>
         double f1(double) throw (std::underflow_error);

         // <span class="docEmphItalicAlt">ok: same exception specification as</span> <span class="docEmphasis">Base::f2</span>
         int f2(int) throw (std::logic_error);
         // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">Derived f3</span> <span class="docEmphItalicAlt">is more restrictive</span>
         std::string f3() throw ();
     };
</pre><br>
<p class="docText">The declaration of <tt>f1</tt> in the derived class is an error because its exception specification adds an exception to those listed in the version of <tt>f1</tt> in the base class. The reason that the derived class may not add to the specfication list is users of the hierarchy should be able to write code that depends on the specification list. If a call is made through a base pointer or reference, then only the exceptions specified in the base should be of concern to a user of these classes.</p>
<p class="docText">By restricting which exceptions the derived classes will throw to those listed by the base class, we can write our code knowing what exceptions we must handle. Our code can rely on the fact that the list of exceptions in the base class is a superset of the list of exceptions that a derived-class version of the virtual might throw. As an example, when calling <tt>f3</tt>, we know we need to handle only <tt>logic_error</tt> or <tt>runtime_error:</tt></p>
<pre>
     // <span class="docEmphItalicAlt">guarantees not to throw exceptions</span>
     void compute(Base *pb) throw()
     {
         try {
             // <span class="docEmphItalicAlt">may throw exception of type</span> <span class="docEmphasis">std::logic_error</span>
             // <span class="docEmphItalicAlt">or</span> <span class="docEmphasis">std::runtime_error</span>
             pb-&gt;f3();
         } catch (const logic_error &amp;le)   { /* ... */ }
           catch (const runtime_error &amp;re) { /* ... */ }
     }
</pre><br>
<p class="docText">The function <tt>compute</tt> uses the specification in the base class in deciding what exceptions it might need to catch.</p>


<a name="ch17lev2sec11"></a>
<h4 class="docSection2Title">17.1.11. Function Pointer Exception Specifications</h4>
<p class="docText"><a name="idd1e138121"></a><a name="idd1e138126"></a><a name="idd1e138131"></a>An exception specification is part of a function type. As such, exception specifications can be provided in the definition of a pointer to function:</p>
<pre>
     void (*pf)(int) throw(runtime_error);
</pre><br>
<p class="docText">This declaration says that <tt>pf</tt> points to a function that takes an <tt>int</tt>, returns a<tt>void</tt>, and that can throw exceptions only of type <tt>runtime_error</tt>. If no specification is provided, then the pointer may point at a function with matching type that could throw any kind of exception.</P>
<p class="docText">When a pointer to function with an exception specification is initialized from (or assigned to) another pointer (or to the address of a function), the exception specifications of both pointers do not have to be identical. However, the specification of the source pointer must be at least as restrictive as the specification of the destination pointer</P>
<pre>
     void recoup(int) throw(runtime_error);
     // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">recoup</span> <span class="docEmphItalicAlt">is as restrictive as</span> <span class="docEmphasis">pf1</span>
     void (*pf1)(int) throw(runtime_error) = recoup;
     // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">recoup</span> <span class="docEmphItalicAlt">is more restrictive than</span> <span class="docEmphasis">pf2</span>
     void (*pf2)(int) throw(runtime_error, logic_error) = recoup;
     // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">recoup</span> <span class="docEmphItalicAlt">is less restrictive than</span> <span class="docEmphasis">pf3</span>
     void (*pf3)(int) throw() = recoup;
     // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">recoup</span> <span class="docEmphItalicAlt">is more restrictive than</span> <span class="docEmphasis">pf4</span>
     void (*pf4)(int) = recoup;
</pre><br>
<p class="docText">The third initialization is an error. The pointer declaration says that <tt>pf3</tt> points to a function that will not throw any exceptions. However, <tt>recoup</tt> says it can throw exceptions of type <tt>runtime_error</tt>. The <tt>recoup</tt> function throws exception types beyond those specified by <tt>pf3</tt>. The <tt>recoup</tt> function is not a valid initializer for <tt>pf3</tt>, and a compile-time error is issued.</P>
<a name="ch17sb07"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<H2 class="docSidebarTitle">Exercises Section 17.1.11</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch17qa6q1"></a><b>Exercise 17.10:</b></TD><td><p class="docText">What exceptions can a function throw if it has an exception specification of the form <tt>tHRow()</tt>? If it has no exception specification?</P></td></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch17qa6q2"></a><B>Exercise 17.11:</b></td><td><p class="docText">Which, if either, of the following initializations is in error? Why?</p>
<pre>
     void example() throw(string);
     (a) void (*pf1)() = example;
     (b) void (*pf2)() throw() = example;
</pre><br>
</TD></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch17qa6q3"></a><b>Exercise 17.12:</b></td><TD><p class="docText">Which exceptions might the following functions throw?</p>
<pre>
     (a) void operate() throw(logic_error);
     (b) int op(int) throw(underflow_error, overflow_error);
     (c) char manip(string) throw();
     (d) void process();
</pre><BR>
</td></tr></table></p>
</blockquote>
</td></tr></table></p><br>


<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch17.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch17lev1sec2.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>