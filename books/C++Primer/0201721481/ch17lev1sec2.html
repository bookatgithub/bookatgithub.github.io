<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 17.2.&nbsp; Namespaces</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch17lev1sec1.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch17lev1sec3.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch17lev1sec2"></a>
<h3 class="docSection1Title">17.2. Namespaces</h3>
<p class="docText"><a name="idd1e138304"></a><a name="idd1e138309"></a><a name="idd1e138315"></a><a name="idd1e138318"></a><a name="idd1e138323"></a><a name="idd1e138328"></a>Every name defined in a given scope must be unique within that scope. This requirement can be difficult to satisfy for large, complex applications. Such applications tend to have many names defined in the global scope. Complex programs composed of independently developed libraries are even more likely to encounter name collisionsthe same name is used in our own code or (more often) in the code supplied to us by independent producers.</P>
<p class="docText">Libraries tend to define a large number of global namesprimarily names of templates, types and functions. When writing an application using libraries from many different vendors, it is almost inevitable that some of these names will clash. This name-clashing problem is known as the <B><a name="ch17term19"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_19">namespace pollution</a></b> problem.</p>
<p class="docText">Traditionally, programmers avoided namespace pollution by making names of global entities very long, often prefixing the names in their program with specific character sequences:</P>
<pre>
     class cplusplus_primer_Query { ... };
     ifstream&amp;
     cplusplus_primer_open_file(ifstream&amp;, const string&amp;);
</pre><br>
<p class="docText">This solution is far from ideal: It can be cumbersome for programmers to write and read programs that use such long names. <b><a name="ch17term17"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_17">Namespaces</a></b> provide a much more controlled mechanism for preventing name collisions. Namespaces partition the global namespace, making it easier to use independently produced libraries. A namespace is a scope. By defining a library's names inside a namespace, library authors (and users) can avoid the limitations inherent in global names.</P>
<a name="ch17lev2sec12"></a>
<H4 class="docSection2Title">17.2.1. Namespace Definitions</h4>
<p class="docText">A namespace definition begins with the keyword <tt>namespace</tt> followed by the namespace name.</p>
<pre>
     namespace cplusplus_primer {
         class Sales_item { /* ... */};
         Sales_item operator+(const Sales_item&amp;,
                              const Sales_item&amp;);
         class Query {
         public:
             Query(const std::string&amp;);
             std::ostream &amp;display(std::ostream&amp;) const;
             // ...
         };
         class Query_base { /* ... */};
     }
</pre><br>
<p class="docText">This code defines a namespace named <tt>cplusplus_primer</tt> with four members: two classes, an overloaded <tt>+</tt> operator, and a function.</p>
<p class="docText">As with other names, the name of a namespace must be unique within the scope in which the namespace is defined. Namespaces may be defined at global <a name="idd1e138382"></a><a name="idd1e138387"></a><a name="idd1e138392"></a><a name="idd1e138397"></a>scope or inside another namespace. They may not be defined inside a function or a class.</p>
<p class="docText">Following the namespace name is a block of declarations and definitions delimited by curly braces. Any declaration that can appear at global scope can be put into a namespace: classes, variables (with their initializations), functions (with their definitions), templates, and other namespaces.</P>
<a name="ch17note19"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> A namespace scope does not end with a semicolon.</p></TD></TR></table><br>
</p></div><br>
<a name="ch17lev3sec29"></a>
<h5 class="docSection3Title">Each Namespace Is a Scope</H5>
<p class="docText">The entities defined in a namespace are called namespace members. Just as is the case for any scope, each name in a namespace must refer to a unique entity within that namespace. Because different namespaces introduce different scopes, different namespaces may have members with the same name.</p>
<p class="docText">Names defined in a namespace may be accessed directly by other members of the namespace. Code outside the namespace must indicate the namespace in which the name is defined:</p>
<pre>
     cplusplus_primer::Query q =
                     cplusplus_primer::Query("hello");
     q.display(cout);
     // ...
</pre><BR>
<p class="docText">If another namespace (say, <tt>AddisonWesley</tt>) also provides a <tt>TextQuery</tt> class and we want to use that class instead of the one defined in <tt>cplusplus_primer</tt>, we can do so by modifying our code as follows:</p>
<pre>
     AddisonWesley::Query q = AddisonWesley::Query("hello");
     q.display(cout);
     // ...
</pre><br>

<a name="ch17lev3sec30"></a>
<H5 class="docSection3Title">Using Namespace Members from Outside the Namespace</h5>
<p class="docText">Of course, always referring to a namespace member using the qualified name</P>
<pre>
     namespace_name::member_name
</pre><br>
<p class="docText">can be cumbersome. Just as we've been doing for names defined in the <tt>std</tt> namespace, we can write a <tt>using</tt> declaration (<a class="docLink" href="ch03lev1sec1.html#ch03lev1sec1">Section 3.1</a>, p. <a class="docLink" href="ch03lev1sec1.html#ch03lev1sec1">78</a>) to obtain direct access to names we know we'll use frequently:</p>
<pre>
     using cplusplus_primer::Query;
</pre><br>
<p class="docText">After this <tt>using</tt> declaration, our program can use the name <tt>Query</tt> directly without the <tt>cplusplus_primer</tt> qualifier. We'll see other ways to simplify access in <a class="docLink" href="#ch17lev2sec15">Section 17.2.4</a> (p. <a class="docLink" href="#ch17lev2sec15">720</a>).</p>

<a name="ch17lev3sec31"></a>
<h5 class="docSection3Title">Namespaces Can Be Discontiguous</h5>
<p class="docText"><a name="idd1e138517"></a><a name="idd1e138524"></a><a name="idd1e138529"></a><a name="idd1e138536"></a><a name="idd1e138543"></a><a name="idd1e138548"></a>Unlike other scopes, a namespace can be defined in several parts. A namespace is made up of the sum of its separately defined parts; a namespace is cumulative. The separate parts of a namespace can be spread over multiple files. Namespace definitions in different text files are also cumulative. Of course, the usual restriction continues to apply that names are visible only in the files in which they are declared. So, if one part of the namespace requires a name defined in another file, that name must still be declared.</p>
<p class="docText">Writing a namespace definition</p>
<pre>
     namespace <span class="docEmphasis">namespace_name</span> {
     // <span class="docEmphItalicAlt">declarations</span>
     }
</pre><br>
<p class="docText">either defines a new namespace or adds to an existing one.</p>
<p class="docText">If the name <span class="docEmphasis">namespace_name</span> does not refer to a previously defined namespace, then a new namespace with that name is created. Otherwise, this definition opens an existing namespace and adds these new declarations to that namespace.</p>

<a name="ch17lev3sec32"></a>
<h5 class="docSection3Title">Separation of Interface and Implementation</h5>
<p class="docText">The fact that namespace definitions can be discontiguous means that we can compose a namespace from separate interface and implementation files. Thus, a namespace can be organized in the same way that we manage our own class and function definitions:</P>
<div style="font-weight:bold"><ol class="docList" type="1"><LI><div style="font-weight:normal"><p class="docList">Namespace members that define classes and declarations for the functions and objects that are part of the class interface can be put into header files. These headers can be included by files that use namespace members.</p></div></LI><li><div style="font-weight:normal"><p class="docList">The definitions of namepsace members can be put in separate source files.</p></div></LI></ol></div>
<p class="docText">Organizing our namespaces this way also satisfies the requirement that various entitiesnon-inline functions, static data members, variables, and so forthmay be defined only once in a program. This requirement applies equally to names defined in a namespace. By separating the interface and implementation, we can ensure that the functions and other names we need are defined only once, but the same declaration will be seen whenever the entity is used.</P>
<a name="ch17note20"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><td valign="top"><p class="docText"> Namespaces that define multiple, unrelated types should use separate files to represent each type that the namespace defines.</P></td></TR></table><BR>
</p></div><br>

<a name="ch17lev3sec33"></a>
<h5 class="docSection3Title">Defining the Primer Namespace</H5>
<p class="docText">Using this strategy for separating interface and implementation, we might define the <tt>cplusplus_primer</tt> library in several separate files. The declarations for <tt>Sales_item</tt> and its related functions that we built in <a class="docLink" href="part01.html#part01">Part I</a> (p. <a class="docLink" href="part01.html#part01">31</a>) would be placed in <tt>Sales_item.h</tt>, those for the <tt>Query</tt> classes of <a class="docLink" href="ch15.html#ch15">Chapter 15</a> (p. <a class="docLink" href="ch15.html#ch15">557</a>) in <tt>Query.h</tt>, and so on. The corresponding implementation files would be in files such as <tt>Sales_item.cc</tt> and <tt>Query.cc:</tt></P>
<pre>
     // <span class="docEmphItalicAlt">---- Sales_item.h ----</span>
     namespace cplusplus_primer {
         class Sales_item { /* ... */};
         Sales_item operator+(const Sales_item&amp;,
                              const Sales_item&amp;);
         // <span class="docEmphItalicAlt">declarations for remaining functions in the</span> <span class="docEmphasis">Sales_item</span> <span class="docEmphItalicAlt">interface</span>
     }
     // <span class="docEmphItalicAlt">---- Query.h ----</span>
     namespace cplusplus_primer {
         class Query {
         public:
             Query(const std::string&amp;);
             std::ostream &amp;display(std::ostream&amp;) const;
             // ...
         };
         class Query_base { /* ... */};
     }
     // <span class="docEmphItalicAlt">---- Sales_item.cc ----</span>
     #include "Sales_item.h"
     namespace cplusplus_primer {
     // <span class="docEmphItalicAlt">definitions for</span> <span class="docEmphasis">Sales_item</span> <span class="docEmphItalicAlt">members and overloaded operators</span>
     }
     // <span class="docEmphItalicAlt">---- Query.cc ----</span>
     #include "Query.h"
     namespace cplusplus_primer {
         // <span class="docEmphItalicAlt">definitions for</span> <span class="docEmphasis">Query</span> <span class="docEmphItalicAlt">members and related functions</span>
     }
</pre><br>
<p class="docText">This program organization gives both the developers and users of our library the needed modularity. Each class is still organized into its own interface and implementation files. A user of one class need not compile names related to the others. We can hide the implementations from our users, while allowing the files <tt>Sales_item.cc</tt> and <tt>user.cc</tt> to be compiled and linked into one program without causing any compile-time or link-time error. Developers of the library can work independently on the implementation of each type.</p>
<p class="docText">A program using our library would include whichever headers it needed. The names in those headers are defined inside the <tt>cplusplus_primer</tt> namespace:</p>
<pre>
     // <span class="docEmphItalicAlt">---- user.cc ----</span>
     // <span class="docEmphItalicAlt">defines the</span> <span class="docEmphasis">cplusplus_primer::Sales_item</span> <span class="docEmphItalicAlt">class</span>
     #include "Sales_item.h"
     int main()
     {
         // ...
         cplusplus_primer::Sales_item trans1, trans2;
         // ...
         return 0;
     }
</pre><br>

<a name="ch17lev3sec34"></a>
<H5 class="docSection3Title">Defining Namespace Members</h5>
<p class="docText"><a name="idd1e138741"></a><a name="idd1e138748"></a><a name="idd1e138751"></a><a name="idd1e138756"></a><a name="idd1e138761"></a><a name="idd1e138768"></a>Functions defined inside a namespace may use the short form for names defined in the same namespace:</p>
<pre>
     namespace cplusplus_primer {
     // <span class="docEmphItalicAlt">members defined inside the namespace may use unqualified names</span>
     std::istream&amp;
     operator&gt;&gt;(std::istream&amp; in, Sales_item&amp; s)
     {
         // ...
     }
</pre><BR>
<p class="docText">It is also possible to define a namespace member outside its namespace definition. We do so in ways that are similar to defining class members outside a class: The namespace declaration of the name must be in scope, and the definition must specify the namespace to which the name belongs:</p>
<pre>
     // <span class="docEmphItalicAlt">namespace members defined outside the namespace must use qualified names</span>
     cplusplus_primer::Sales_item
     cplusplus_primer::operator+(const Sales_item&amp; lhs,
                                 const Sales_item&amp; rhs)
     {
         Sales_item ret(lhs);
         // ...
     }
</pre><br>
<p class="docText">This definition should look similar to class member functions defined outside a class. The return type and function name are qualified by the namespace name. Once the fully qualified function name is seen, we are in the scope of the namespace. Thus, references to namespace members in the parameter list and the function body can use unqualified names to reference <tt>Sales_item</tt>.</P>

<a name="ch17lev3sec35"></a>
<h5 class="docSection3Title">Members May Not Be Defined in Unrelated Namespaces</H5>
<p class="docText">Although a namespace member can be defined outside its namespace definition, there are restrictions on where this definition can appear. Only namespaces enclosing the member declaration can contain its definition. For example, <tt>operator+</tt> could be defined in either the <tt>cplusplus_primer</tt> namespace or at global scope. It may not be defined in an unrelated namespace.</p>

<a name="ch17lev3sec36"></a>
<h5 class="docSection3Title">The Global Namespace</h5>
<p class="docText">Names defined at global scopenames declared outside any class, function, or namespaceare defined inside the <b><a name="ch17term15"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_15">global namespace</a></b>. The global namespace is implicitly declared and exists in every program. Each file that defines entities at global scope adds those names to the global namespace.</p>
<p class="docText">The <span class="docEmphRoman"><a name="ch17term22"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_22">scope operator</a></span> can be used to refer to members of the global namespace. Because the global namespace is implicit, it does not have a name; the notation</p>
<pre>
     ::member_name
</pre><br>
<p class="docText">refers to a member of the global namespace.</p>
<a name="ch17sb08"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 17.2.1</h2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><td align="right" class="docText" width="50"><a name="ch17qa7q1"></a><B>Exercise 17.13:</b></td><td><p class="docText"><a name="idd1e138861"></a><a name="idd1e138866"></a>Define the bookstore exception classes described in <a class="docLink" href="ch17lev1sec1.html#ch17lev2sec7">Section 17.1.7</a> (p. <a class="docLink" href="ch17lev1sec1.html#ch17lev2sec7">697</a>) as members of namespace named <tt>Bookstore</tt>.</P></TD></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch17qa7q2"></a><b>Exercise 17.14:</b></td><TD><p class="docText">Define <tt>Sales_item</tt> and its operators inside the <tt>Bookstore</tt> namespace. Define the addition operator to throw an exception.</p></TD></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch17qa7q3"></a><b>Exercise 17.15:</b></TD><TD><p class="docText">Write a program that uses the <tt>Sales_item</tt> addition operator and handles any exceptions. Make this program a member of another namespace named <tt>MyApp</tt>. This program should use the exception classes defined in the <tt>Bookstore</tt> namespace by the previous exercise.</p></td></tr></table></p>
</blockquote>
</TD></tr></table></p><BR>


<a name="ch17lev2sec13"></a>
<h4 class="docSection2Title">17.2.2. Nested Namespaces</h4>
<p class="docText">A nested namespace is a nested scopeits scope is nested within the namespace that contains it. Names in nested namespaces follow the normal rules: Names declared in an enclosing namespace are hidden by declarations of the same name in a nested namespace. Names defined inside a nested namespace are local to that namespace. Code in the outer parts of the enclosing namespace may refer to a name in a nested namespace only through its qualified name.</P>
<p class="docText">Nested namespaces can improve the organization of code in a library:</p>
<pre>
     namespace cplusplus_primer {
         // <span class="docEmphItalicAlt">first nested namespace:</span>
         // <span class="docEmphItalicAlt">defines the</span> <span class="docEmphasis">Query</span> <span class="docEmphItalicAlt">portion of the library</span>
         namespace QueryLib {
             class Query { /* ... */ };
             Query operator&amp;(const Query&amp;, const Query&amp;);
             // ...
         }
         // <span class="docEmphItalicAlt">second nested namespace:</span>
         // <span class="docEmphItalicAlt">defines the</span> <span class="docEmphasis">Sales_item</span> <span class="docEmphItalicAlt">portion of the library</span>
         namespace Bookstore {
             class Item_base { /* ... */ };
             class Bulk_item : public Item_base { /* ... */ };
             // ...
         }
     }
</pre><BR>
<p class="docText">The <tt>cplusplus_primer</tt> namespace now contains two nested namespaces: the namespaces named <tt>QueryLib</tt> and <tt>Bookstore</tt>.</p>
<p class="docText">Nested namespaces are useful when a library provider needs to prevent names in each part of a library from colliding with names in other parts of the library.</p>
<p class="docText">The name of a member in a nested namespace is formed from the names of the enclosing namespace(s) and the name of the nested namespace. For example, the name of the class declared in the nested namespace <tt>QueryLib</tt> is</p>
<pre>
     cplusplus_primer::QueryLib::Query
</pre><br>
<a name="ch17sb09"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 17.2.2</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch17qa8q1"></a><b>Exercise 17.16:</b></TD><TD><p class="docText"><a name="idd1e139003"></a><a name="idd1e139008"></a><a name="idd1e139015"></a><a name="idd1e139018"></a>Organize the programs you have written to answer the questions in each chapter into its own namespace. That is, namespace <tt>chapterrefinheritance</tt> would contain code for the <tt>Query</tt> programs and <tt>chapterrefalgs</tt> would contain the <tt>TextQuery</tt> code. Using this structure, compile the <tt>Query</tt> code examples.</p></TD></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch17qa8q2"></a><B>Exercise 17.17:</b></td><td><p class="docText">Over the course of this primer, we defined two different classes named <tt>Sales_item:</tt> the initial simple class defined and used in <a class="docLink" href="part01.html#part01">Part I</a>, and the handle class defined in <a class="docLink" href="ch15lev1sec8.html#ch15lev2sec21">Section 15.8.1</a> that interfaced to the <tt>Item_base</tt> inheritance hierarchy. Define two namespaces nested inside the <tt>cplusplus_primer</tt> namespace that could be used to distinguish these two class definitions.</p></td></tr></table></P>
</blockquote>
</td></TR></table></P><br>

<a name="ch17lev2sec14"></a>
<h4 class="docSection2Title">17.2.3. Unnamed Namespaces</h4>
<p class="docText">A namespace may be unnamed. An <B><a name="ch17term28"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_28">unnamed namespace</a></b> is a namespace that is defined without a name. An unnamed namespace begins with the keyword <tt>namespace</tt>. Following the <tt>namespace</tt> keyword is a block of declarations delimited by curly braces.</P>
<a name="ch17note21"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> Unnamed namespaces are not like other namespaces; the definition of an unnamed namespace is local to a particular file and never spans multiple text files.</p></td></TR></table><br>
</p></div><BR>
<p class="docText">An unnamed namespace may be discontiguous within a given file but does not span files. Each file has its own unnamed namespace.</p>
<p class="docText">Unnamed namespaces are used to declare entities that are local to a file. Variables defined in an unnamed namespace are created when the program is started and exist until the program ends.</P>
<p class="docText">Names defined in an unnamed namespace are used directly; after all, there is no namespace name with which to qualify them. It is not possible to use the scope operator to refer to members of unnamed namespaces.</p>
<p class="docText">Names defined in an unnamed namespace are visible only to the file containing the namespace. If another file contains an unnamed namespace, the namespaces are unrelated. Both unnamed namespaces could define the same name, and the definitions would refer to different entities.</p>
<p class="docText">Names defined in an unnamed namespace are found in the same scope as the scope at which the namespace is defined. If an unnamed namespace is defined at the outermost scope in the file, then names in the unnamed namespace must differ from names defined at global scope:</p>
<pre>
     int i;   // <span class="docEmphItalicAlt">global declaration for</span> <span class="docEmphasis">i</span>
     namespace {
         int i;
     }
     // <span class="docEmphItalicAlt">error: ambiguous defined globally and in an unnested, unnamed namespace</span>
     i = 10;
</pre><br>
<p class="docText">An unnamed namespace, like any other namespace, may be nested inside another <a name="idd1e139129"></a><a name="idd1e139134"></a><a name="idd1e139143"></a><a name="idd1e139148"></a>namespace. If the unnamed namespace is nested, then names in it are accessed in the normal way, using the enclosing namespace name(s):</p>
<pre>
     namespace local {
        namespace {
            int i;
        }
     }
        // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">i</span> <span class="docEmphItalicAlt">defined in a nested unnamed namespace is distinct from global</span> <span class="docEmphasis">i</span>
        local::i = 42;
</pre><br>
<a name="ch17note22"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><td valign="top"><p class="docText"> If a header defines an unnamed namespace then the names in that namespace will define different local entities in each file that includes the header.</p></td></TR></table><BR>
</p></div><BR>
<p class="docText">In all other ways, the members of an unnamed namespace are normal program entities.</p>
<a name="ch17sb10"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<h2 class="docSidebarTitle">Unnamed Namespaces Replace File Statics</h2>
<p class="docText"><span class="docEmphStrong">Prior to the introduction of namespaces in standard C++, programs had to declare names as <tt>static</tt> to make them local to a file. The use of <b><a name="ch17term13"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_13">file statics</a></b> is inherited from C. In C, a global entity declared <tt>static</tt> is invisible outside the file in which it is declared.</span></p>
<a name="ch17note23"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></TD><TD valign="top"><p class="docText"> <span class="docEmphStrong">The use of file static declarations is <span class="docEmphasis">deprecated</span> by the C++ standard. A deprecated feature is one that may not be supported in future releases. File statics should be avoided and unnamed namespaces used instead.</span></p></td></tr></table><BR>
</P></div><br>
</td></tr></table></p><BR>
<a name="ch17sb11"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Exercises Section 17.2.3</h2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch17qa9q1"></a><b>Exercise 17.18:</b></td><td><p class="docText">Why would you define your own namespace in your programs? When might you use an unnamed namespace?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch17qa9q2"></a><b>Exercise 17.19:</b></td><td><p class="docText">Suppose we have the following declaration of the <tt>operator*</tt> that is a member of the nested namespace <tt>cplusplus_primer::MatrixLib:</tt></p>
<pre>
     namespace cplusplus_primer {
         namespace MatrixLib {
             class matrix { /* ... */ };
             matrix operator*
                    (const matrix &amp;, const matrix &amp;);
             // ...
         }
     }
</pre><br>
<p class="docText">How would you define this operator in global scope? Provide only the prototype for the operator's definition.</P>
</TD></tr></table></P>
</blockquote>
</td></tr></table></P><BR>

<a name="ch17lev2sec15"></a>
<h4 class="docSection2Title">17.2.4. Using Namespace Members</h4>
<p class="docText"><a name="idd1e139272"></a><a name="idd1e139275"></a><a name="idd1e139281"></a><a name="idd1e139284"></a><a name="idd1e139291"></a><a name="idd1e139296"></a>Referring to namespace members as <tt>namespace_name::member_name</tt> is admittedly cumbersome, especially if the namespace name is long. Fortunately, there are ways to make it easier to use namespace members. Our programs have used one of these ways, <tt>using</tt> declarations (<a class="docLink" href="ch03lev1sec1.html#ch03lev1sec1">Section 3.1</a>, p. <a class="docLink" href="ch03lev1sec1.html#ch03lev1sec1">78</a>). The others, namespace aliases and <tt>using</tt> directives, will be described in this section.</p>
<a name="ch17note24"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="images/0201721481/graphics/bestpractices.jpg;400478"></td><TD valign="top"><p class="docText"> Header files should not contain <tt>using</tt> directives or <tt>using</tt> declarations except inside functions or other scopes. A header that includes a <tt>using</tt> directive or declaration at its top level scope has the effect of injecting that name into the file that includes the header. Headers should define only the names that are part of its interface, not names used in its own implementation.</P></td></tr></table><br>
</P></div><BR>
<a name="ch17lev3sec37"></a>
<h5 class="docSection3Title"><tt>using</tt> Declarations, a Recap</h5>
<p class="docText">The programs in this book that use names from the standard library generally assume that an appropriate <b><a name="ch17term29"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_29"><span class="docEmphStrong"><tt>using</tt> declaration</span></a></b> has been made:</p>
<pre>
     map&lt;string, vector&lt; pair&lt;size_t, size_t&gt; &gt; &gt; word_map;
</pre><BR>
<p class="docText">assumes that the following <tt>using</tt> declarations have been made:</p>
<pre>
     using std::map;
     using std::pair;
     using std::size_t;
     using std::string;
     using std::vector;
</pre><br>
<p class="docText">A <tt>using</tt> declaration introduces only one namespace member at a time. It allows us to be very specific regarding which names are used in our programs.</P>

<a name="ch17lev3sec38"></a>
<h5 class="docSection3Title">Scope of a <tt>using</tt> Declaration</h5>
<p class="docText">Names introduced in a <tt>using</tt> declaration obey normal scope rules. The name is visible from the point of the <tt>using</tt> declaration to the end of the scope in which the declaration is found. Entities with the same name defined in an outer scope are hidden.</P>
<p class="docText">The shorthand name may be used only within the scope in which it is declared and in scopes nested within that scope. Once the scope ends, the fully qualified name must be used.</p>
<p class="docText">A <tt>using</tt> declaration can appear in global, local, or namespace scope. A <tt>using</tt> declaration in class scope is limited to names defined in a base class of the class being defined.</P>

<a name="ch17lev3sec39"></a>
<h5 class="docSection3Title">Namespace Aliases</h5>
<p class="docText">A <b><a name="ch17term18"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_18">namespace alias</a></b> can be used to associate a shorter synonym with a namespace name. For example, a long namespace name such as</p>
<pre>
     namespace cplusplus_primer { /* ... */ };
</pre><br>
<p class="docText"><a name="idd1e139428"></a><a name="idd1e139433"></a><a name="idd1e139440"></a><a name="idd1e139445"></a>can be associated with a shorter synonym as follows:</p>
<pre>
     namespace primer = cplusplus_primer;
</pre><br>
<p class="docText">A namespace alias declaration begins with the keyword <tt>namespace</tt>, followed by the (shorter) name of the namespace alias, followed by the <tt>=</tt> sign, followed by the original namespace name and a semicolon. It is an error if the original namespace name has not already been defined as a namespace.</p>
<p class="docText">A namespace alias can also refer to a nested namespace. Rather than writing</p>
<pre>
     cplusplus_primer::QueryLib::Query tq;
</pre><br>
<p class="docText">we could define and use an alias for <tt>cplusplus_primer::QueryLib:</tt></p>
<pre>
     namespace Qlib = cplusplus_primer::QueryLib;
     Qlib::Query tq;
</pre><br>
<a name="ch17note25"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><TD valign="top"><p class="docText"> A namespace can have many synonyms, or aliases. All the aliases and the original namespace name can be used interchangeably.</p></td></TR></table><BR>
</p></div><br>

<a name="ch17lev3sec40"></a>
<h5 class="docSection3Title"><tt>using</tt> Directives</h5>
<p class="docText">Like a <tt>using</tt> declaration, a <span class="docEmphStrong"><tt>using</tt> directive</span> allows us to use the shorthand form of a namespace name. Unlike a <tt>using</tt> declaration, we retain no control over which names are made visiblethey all are.</p>

<a name="ch17lev3sec41"></a>
<H5 class="docSection3Title">The Form of a <tt>using</tt> Directive</h5>
<p class="docText">A <tt>using</tt> directive begins with the keyword <tt>using</tt>, followed by the keyword <tt>namespace</tt>, followed by a namespace name. It is an error if the name is not a previously defined namespace name.</P>
<p class="docText">A <tt>using</tt> directive makes all the names from a specific namespace visible without qualification. The short form names can be used from the point of the <tt>using</tt> directive to the end of the scope in which the <tt>using</tt> directive appears.</P>
<p class="docText">A <tt>using</tt> directive may appear in namespace, function, or block scope. It may not appear in a class scope.</p>
<a name="ch17note26"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></TD><td valign="top"><p class="docText"> It can be tempting to write programs with <tt>using</tt> directives, but doing so reintroduces all the problems inherent in name collisions when using multiple libraries.</p></td></tr></table><BR>
</p></div><br>

<a name="ch17lev3sec42"></a>
<H5 class="docSection3Title"><tt>using</tt> Directives and Scope</h5>
<p class="docText">The scope of names introduced by a <tt>using</tt> directive is more complicated than those for <tt>using</tt> declarations. A <tt>using</tt> declaration puts the name directly in the same scope in which the <tt>using</tt> declaration itself appears. It is as if the <tt>using</tt> <a name="idd1e139596"></a><a name="idd1e139605"></a>declaration is a local alias for the namespace member. Because the declaration is localized, the chance of collisions is minimized.</p>
<a name="ch17note27"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> A <tt>using</tt> directive does not declare local aliases for the namespace member names. Rather, it has the effect of lifting the namespace members into the nearest scope that contains both the namespace itself and the <tt>using</tt> directive.</p></td></tr></table><br>
</p></div><br>
<p class="docText">In the simplest case, assume we have a namespace <tt>A</tt> and a function <tt>f</tt>, both defined at global scope. If <tt>f</tt> has a <tt>using</tt> directive for <tt>A</tt>, then in <tt>f</tt> it will be as if the names in <tt>A</tt> appeared in the global scope prior to the definition of <tt>f</tt>:</p>
<pre>
    // <span class="docEmphItalicAlt">namespace</span> <span class="docEmphasis">A</span> <span class="docEmphItalicAlt">and function</span> <span class="docEmphasis">f</span> <span class="docEmphItalicAlt">are defined at global scope</span>
    namespace A {
        int i, j;
    }
    void f()
    {
        using namespace A;      // <span class="docEmphItalicAlt">injects names from</span> <span class="docEmphasis">A</span> <span class="docEmphItalicAlt">into the global scope</span>
        cout &lt;&lt; i * j &lt;&lt; endl; // <span class="docEmphItalicAlt">uses</span> <span class="docEmphasis">i</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">j</span> <span class="docEmphItalicAlt">from namespace</span> <span class="docEmphasis">A</span>
        //...
    }
</pre><br>
<a name="ch17note28"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="84" height="51" SRC="images/0201721481/graphics/tip.jpg;400478"></TD><TD valign="top"><p class="docText"> One place where <tt>using</tt> directives are useful is in the implementation files for the namespace itself.</p></TD></tr></table><br>
</P></div><BR>

<a name="ch17lev3sec43"></a>
<h5 class="docSection3Title"><tt>using</tt> Directives Example</h5>
<p class="docText">Let's look at an example:</p>
<pre>
    namespace blip {
        int bi = 16, bj = 15, bk = 23;
        // <span class="docEmphItalicAlt">other declarations</span>
    }
    int bj = 0; // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">bj</span> <span class="docEmphItalicAlt">inside</span> <span class="docEmphasis">blip</span> <span class="docEmphItalicAlt">is hidden inside a namespace</span>
    void manip()
    {

         // <span class="docEmphItalicAlt">using directive - names in</span> <span class="docEmphasis">blip</span> <span class="docEmphItalicAlt">"added" to global scope</span>
         using namespace blip;
                         // <span class="docEmphItalicAlt">clash between</span> <span class="docEmphasis">::bj</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">blip::bj</span>
                         // <span class="docEmphItalicAlt">detected only if</span> <span class="docEmphasis">bj</span> <span class="docEmphItalicAlt">is used</span>
         ++bi;           // <span class="docEmphItalicAlt">sets</span> <span class="docEmphasis">blip::bi</span> <span class="docEmphItalicAlt">to 17</span>
         ++bj;           // <span class="docEmphItalicAlt">error: ambiguous</span>
                         // <span class="docEmphItalicAlt">global</span> <span class="docEmphasis">bj</span> <span class="docEmphItalicAlt">or</span> <span class="docEmphasis">blip::bj</span><span class="docEmphItalicAlt">?</span>
         ++::bj;         // <span class="docEmphItalicAlt">ok: sets global</span> <span class="docEmphasis">bj</span> <span class="docEmphItalicAlt">to 1</span>
         ++blip::bj;     // <span class="docEmphItalicAlt">ok: sets</span> <span class="docEmphasis">blip::bj</span> <span class="docEmphItalicAlt">to 16</span>
         int bk = 97;    // <span class="docEmphItalicAlt">local</span> <span class="docEmphasis">bk</span> <span class="docEmphItalicAlt">hides</span> <span class="docEmphasis">blip::bk</span>
         ++bk;           // <span class="docEmphItalicAlt">sets local</span> <span class="docEmphasis">bk</span> <span class="docEmphItalicAlt">to 98</span>
    }
</pre><br>
<p class="docText"><a name="idd1e139849"></a><a name="idd1e139858"></a>The <tt>using</tt> directive in <tt>manip</tt> makes all the names in <tt>blip</tt> directly accessible to <tt>manip</tt>: The function can refer to the names of these members, using their short form.</p>
<p class="docText">The members of <tt>blip</tt> appear as if they were defined in the scope in which both <tt>blip</tt> and <tt>manip</tt> are defined. Given that <tt>blip</tt> is defined at global scope, then the members of <tt>blip</tt> appear as if they were declared in global scope. Because the names are in different scopes, local declarations within <tt>manip</tt> may hide some of the namespace member names. The local variable <tt>bk</tt> hides the namespace member <tt>blip::bk</tt>. Referring to <tt>bk</tt> within <tt>manip</tt> is not ambiguous; it refers to the local variable <tt>bk</tt>.</P>
<p class="docText">It is possible for names in the namespace to conflict with other names defined in the enclosing scope. For example, the <tt>blip</tt> member <tt>bj</tt> appears to <tt>manip</tt> as if it were declared at global scope. However, there is another object named <tt>bj</tt> in global scope. Such conflicts are permitted; but to use the name, we must explicitly indicate which version is wanted. Therefore, the use of <tt>bj</tt> within <tt>manip</tt> is ambiguous: The name refers both to the global variable and to the member of namespace <tt>blip</tt>.</p>
<p class="docText">To use a name such as <tt>bj</tt>, we must use the scope operator to indicate which name is wanted. We would write <tt>::bj</tt> to obtain the variable defined in global scope. To use the <tt>bj</tt> defined in <tt>blip</tt>, we must use its qualified name, <tt>blip::bj</tt>.</P>
<a name="ch17sb12"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 17.2.4</H2>
<blockquote>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch17qa10q3"></a><b>Exercise 17.20:</b></td><TD><p class="docText">Explain the differences between <tt>using</tt> declarations and <tt>using</tt> directives.</p></td></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch17qa10q4"></a><B>Exercise 17.21:</b></td><TD><p class="docText">Consider the following code sample:</p>
<pre>
    namespace Exercise {
        int ivar = 0;
        double dvar = 0;
        const int limit = 1000;
    }
    int ivar = 0;
    // <span class="docEmphItalicAlt">position 1</span>
    void manip() {
         // <span class="docEmphItalicAlt">position 2</span>
         double dvar = 3.1416;
         int iobj = limit + 1;
         ++ivar;
         ++::ivar;
    }
</pre><br>
<p class="docText">What are the effects of the declarations and expressions in this code sample if <tt>using</tt> declarations for all the members of namespace <tt>Exercise</tt> are located at the location labeled <span class="docEmphasis">position 1</span>? At <span class="docEmphasis">position 2</span> instead? Now answer the same question but replace the <tt>using</tt> declarations with a <tt>using</tt> directive for namespace <tt>Exercise</tt>.</p>
</td></tr></table></p>
</blockquote>
</td></tr></table></p><br>
<a name="ch17sb13"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Caution: Avoid <tt>Using</tt> Directives</H2>
<p class="docText"><a name="idd1e140043"></a><a name="idd1e140050"></a><a name="idd1e140055"></a><a name="idd1e140060"></a><b><a name="ch17term30"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_30"><span class="docEmphStrong"><tt>using</tt></span> directives</a></b>, <span class="docEmphStrong">which inject all the names from a namespace, are deceptively simple to use: With only a single statement, all the member names of a namespace are suddenly visible. Although this approach may seem simple, it can introduce its own problems. If an application uses many libraries, and if the names within these libraries are made visible with <tt>using</tt> directives, then we are back to square one, and the global namespace pollution problem reappears.</span></P>
<p class="docText"><span class="docEmphStrong">Moreover, it is possible that a working program will fail to compile when a new version of the library is introduced. This problem can arise if a new version introduces a name that conflicts with a name that the application is using.</span></p>
<p class="docText"><span class="docEmphStrong">Another problem is that ambiguity errors caused by <tt>using</tt> directives are detected only at the point of use. This late detection means that conflicts can arise long after introducing a particular library. If the program begins using a new part of the library, previously undetected collisions may arise.</span></p>
<p class="docText"><span class="docEmphStrong">Rather than relying on a <tt>using</tt> directive, it is better to use a <tt>using</tt> declaration for each namespace name used in the program. Doing so reduces the number of names injected into the namespace. Ambiguity errors caused by <tt>using</tt> declarations are detected at the point of declaration, not use, and so are easier to find and fix.</span></P>
</TD></tr></table></p><br>


<a name="ch17lev2sec16"></a>
<h4 class="docSection2Title">17.2.5. Classes, Namespaces, and Scope</h4>
<p class="docText">As we've noted, namespaces are scopes. As in any other scope, names are visible from the point of their declaration. Names remain visible through any nested scopes until the end of the block in which they were introduced.</P>
<p class="docText">Name lookup for names used inside a namespace follows the normal C++ lookup rules: When looking for a name, we look outward through the enclosing scopes. An enclosing scope for a name used inside a namespace might be one or more nested namespaces ending finally with the all-encompassing global namespace. Only names that have been declared before the point of use that are in blocks that are still open are considered:</p>
<pre>
    namespace A {
        int i;
        namespace B {
            int i;        // <span class="docEmphItalicAlt">hides</span> <span class="docEmphasis">A::i</span> <span class="docEmphItalicAlt">within</span> <span class="docEmphasis">B</span>
            int j;
            int f1()
            {
                int j;    // <span class="docEmphasis">j</span> <span class="docEmphItalicAlt">is local to</span> <span class="docEmphasis">f1</span> <span class="docEmphItalicAlt">and hides</span> <span class="docEmphasis">A::B::j</span>
                return i; // <span class="docEmphItalicAlt">returns</span> <span class="docEmphasis">B::i</span>
            }
        } // <span class="docEmphItalicAlt">namespace</span> <span class="docEmphasis">B</span> <span class="docEmphItalicAlt">is closed and names in it are no longer visible</span>
        int f2() {
           return j;     // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">j</span> <span class="docEmphItalicAlt">is not defined</span>
        }
        int j = i;      // <span class="docEmphItalicAlt">initialized from</span> <span class="docEmphasis">A::i</span>
    }
</pre><BR>
<p class="docText">Names used in a class member definition are resolved in much the same way, with one important difference: If the name is not local to the member function, we first try to resolve the name to a class member before looking in the outer scopes.</P>
<p class="docText">As we saw in <a class="docLink" href="ch12lev1sec3.html#ch12lev1sec3">Section 12.3</a> (p. <a class="docLink" href="ch12lev1sec3.html#ch12lev1sec3">444</a>), members defined inside a class may use names that appear textually after the definition. For example, a constructor defined inside the class body may initialize the data members even if the declaration of those members appears after the constructor definition. When a name is used in a class scope, we look first in the member itself, then in the class, including any base classes. Only after exhausting the class(es) do we examine the enclosing scopes. When a class is wrapped in a namespace, the same lookup happens: Look first in the member, then the class (including base classes), then look in the enclosing scopes, one or more of which might be a namespace:</p>
<pre>
    namespace A {
        int i;
        int k;
        class C1 {
        public:
            C1(): i(0), j(0) { }   // <span class="docEmphItalicAlt">ok: initializes</span> <span class="docEmphasis">C1::i</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">C1::j</span>
            int f1()
            {
                 return k;        // <span class="docEmphItalicAlt">returns</span> <span class="docEmphasis">A::k</span>
            }
            int f2()
            {
                return h;        // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">h</span> <span class="docEmphItalicAlt">is not defined</span>
            }
            int f3();
        private:
           int i;                // <span class="docEmphItalicAlt">hides</span> <span class="docEmphasis">A::i</span> <span class="docEmphItalicAlt">within</span> <span class="docEmphasis">C1</span>
           int j;
        };
        int h = i;               // <span class="docEmphItalicAlt">initialized from</span> <span class="docEmphasis">A::i</span>
     }
     // <span class="docEmphItalicAlt">member</span> <span class="docEmphasis">f3</span> <span class="docEmphItalicAlt">is defined outside class</span> <span class="docEmphasis">C1</span> <span class="docEmphItalicAlt">and outside namespace</span> <span class="docEmphasis">A</span>
     int A::C1::f3()
     {
         return h;               // <span class="docEmphItalicAlt">ok: returns</span> <span class="docEmphasis">A::h</span>
     }
</pre><br>
<p class="docText">With the exception of member definitions, scopes are always searched upward: A name must be declared before it can be used. Hence, the <tt>return</tt> in <tt>f2</tt> will not compile. It attempts to reference the name <tt>h</tt> from namespace <tt>A</tt>, but <tt>h</tt> has not yet been defined. Had that name been defined in <tt>A</tt> before the definition of <tt>C1</tt>, the use of <tt>h</tt> would be legal. Similarly, the use of <tt>h</tt> inside <tt>f3</tt> is okay, because <tt>f3</tt> is defined after <tt>A::h</tt> has been defined.</p>
<a name="ch17note29"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="84" height="51" SRC="images/0201721481/graphics/tip.jpg;400478"></td><td valign="top"><p class="docText"> The order in which scopes are examined to find a name can be inferred from the qualified name of a function. The qualified name indicates, in reverse order, the scopes that are searched.</p></TD></tr></table><br>
</P></div><br>
<p class="docText"><a name="idd1e140314"></a><a name="idd1e140317"></a><a name="idd1e140324"></a>The qualifiers <tt>A::C1::f3</tt> indicate the reverse order in which the class scopes and namespace scopes are to be searched. The first scope searched is that of the function <tt>f3</tt>. Then the class scope of its enclosing class <tt>C1</tt> is searched. The scope of the namespace <tt>A</tt> is searched last before the scope containing the definition of <tt>f3</tt> is examined.</p>
<a name="ch17lev3sec44"></a>
<H5 class="docSection3Title">Argument-Dependent Lookup and Class Type Parameters</h5>
<p class="docText">Consider the following simple program:</P>
<pre>
    std::string s;
    // <span class="docEmphItalicAlt">ok: calls</span> <span class="docEmphasis">std::getline(std::istream&amp;, const std::string&amp;)</span>
    getline(std::cin, s);
</pre><br>
<p class="docText">The program uses the <tt>std::string</tt> type, yet it refers without qualification to the <tt>getline</tt> function. Why can we use this function without a specific <tt>std::</tt> qualifier or a <tt>using</tt> declaration?</p>
<p class="docText">It turns out that there is an important exception to the rule that namespace names are hidden.</p>
<a name="ch17note30"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="84" height="51" SRC="images/0201721481/graphics/tip.jpg;400478"></td><td valign="top"><p class="docText"> Functions, including overloaded operators, that take parameters of a class type (or pointer or reference to a class type), and that are defined in the same namespace as the class itself, are visible when an object of (or reference or pointer to) the class type is used as an argument.</p></td></tr></table><br>
</p></div><BR>
<p class="docText">When the compiler sees the use of the <tt>getline</tt> function</P>
<pre>
    getline(std::cin, s);
</pre><br>
<p class="docText">it looks for a matching function in the current scope, the scopes enclosing the call to <tt>getline</tt>, <span class="docEmphasis">and in the namespace(s) in which the type of</span> <tt>cin</tt> <span class="docEmphasis">and the</span> <tt>string</tt> <span class="docEmphasis">type are defined</span>. Hence, it looks in the namespace <tt>std</tt> and finds the <tt>getline</tt> function defined by the <tt>string</tt> type.</P>
<p class="docText">The reason that functions are made visible if they have a parameter of the class type is to allow nonmember functions that are conceptually part of a class' interface to be used without requiring a separate <tt>using</tt> declaration. Being able to use nonmember operations is particularly useful for operator functions.</p>
<p class="docText">For example, consider the following simple program:</p>
<pre>
    std::string s;
    cin &gt;&gt; s;
</pre><BR>
<p class="docText">In absence of this exception to the lookup rules, we would have to write either:</P>
<pre>
    using std::operator&gt;&gt;;        // <span class="docEmphItalicAlt">need to allow</span> <span class="docEmphasis">cin &gt;&gt; s</span>
    std::operator&gt;&gt;(std::cin, s); // <span class="docEmphItalicAlt">ok: explicitly use</span> <span class="docEmphasis">std::&gt;&gt;</span>
</pre><br>
<p class="docText">Either of these declarations is awkward and would make simple uses of <tt>string</tt>s and the IO library more complicated.</p>

<a name="ch17lev3sec45"></a>
<h5 class="docSection3Title">Implicit Friend Declarations and Namespaces</h5>
<p class="docText"><a name="idd1e140486"></a><a name="idd1e140493"></a><a name="idd1e140498"></a><a name="idd1e140503"></a><a name="idd1e140508"></a>Recall that when a class declares a friend function (<a class="docLink" href="ch12lev1sec5.html#ch12lev1sec5">Section 12.5</a>, p. <a class="docLink" href="ch12lev1sec5.html#ch12lev1sec5">465</a>), a declaration for the function need not be visible. If there isn't a declaration already visible, then the friend declaration has the effect of putting a declaration for that function or class into the surrounding scope. If a class is defined inside a namespace, then an otherwise undeclared friend function is declared in the same namespace:</p>
<pre>
    namespace A {
        class C {
            friend void f(const C&amp;); // <span class="docEmphItalicAlt">makes</span> <span class="docEmphasis">f</span> <span class="docEmphItalicAlt">a member of namespace</span> <span class="docEmphasis">A</span>
        };
    }
</pre><BR>
<p class="docText">Because the friend takes an argument of a class type and is implicitly declared in the same namespace as the class, it can be used without using an explicit name-space qualifier:</p>
<pre>
    // <span class="docEmphasis">f2</span> <span class="docEmphItalicAlt">defined at global scope</span>
    void f2()
    {
         A::C cobj;
         f(cobj); // <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">A::f</span>
    }
</pre><BR>


<a name="ch17lev2sec17"></a>
<H4 class="docSection2Title">17.2.6. Overloading and Namespaces</h4>
<p class="docText">As we've seen, each namespace maintains its own scope. As a consequence, functions that are members of two distinct namespaces do not overload one another. However, a given namespace can contain a set of overloaded function members.</p>
<p class="docText">In general, function matching (<a class="docLink" href="ch07lev1sec8.html#ch07lev2sec28">Section 7.8.2</a>, p. <a class="docLink" href="ch07lev1sec8.html#ch07lev2sec28">269</a>) within a namespace happens in the same manner as we've already seen:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><LI><div style="font-weight:normal"><p class="docList">Find the set of candidate functions. A function is a candidate if a declaration for it is visible at the time of the call and if it has the same name as the called function.</P></div></li><li><div style="font-weight:normal"><p class="docList">Select the viable functions from the set of candidates. A function is viable if it has the same number of parameters as the call has arguments and if each parameter could be matched by the corresponding argument.</p></div></li><LI><div style="font-weight:normal"><p class="docList">Select the single best match from the viable set and generate code to call that function. If the viable set is empty, then the call is in error, having no match. If the viable set is nonempty and there is no best match, then the call is ambiguous.</p></div></li></ol></div>
<a name="ch17lev3sec46"></a>
<H5 class="docSection3Title">Candidate Functions and Namespaces</h5>
<p class="docText">Namespaces can have two impacts on function matching. One of these should be obvious: A <tt>using</tt> declaration or directive can add functions to the candidate set. The other is much more subtle.</p>
<p class="docText"><a name="idd1e140611"></a><a name="idd1e140616"></a><a name="idd1e140623"></a>As we saw in the previous section, name lookup for functions that have one or more class-type parameters includes the namespace in which each parameter's class is defined. This rule also impacts how we determine the candidate set. Each namespace that defines a class used as a parameter (and those that define its base class(es)) is searched for candidate functions. Any functions in those namespaces that have the same name as the called function are added to the candidate set. These functions are added <span class="docEmphasis">even though they otherwise are not visible at the point of the call.</span> Functions with the matching name in those namespaces are added to the candidate set:</P>
<pre>
    namespace NS {
        class Item_base { /* ... */ };
        void display(const Item_base&amp;) { }
    }
    // <span class="docEmphasis">Bulk_item</span><span class="docEmphItalicAlt">'s base class is declared in namespace NS</span>
    class Bulk_item : public NS::Item_base { };
    int main() {
        Bulk_item book1;
        display(book1);
        return 0;
    }
</pre><br>
<p class="docText">The argument, <tt>book1</tt>, to the <tt>display</tt> function has class type <tt>Bulk_item</tt>. The candidate functions for the call to <tt>display</tt> are not only the functions with declarations that are visible where the function <tt>display</tt> is called, but also the functions in the namespace where the class <tt>Bulk_item</tt> and its base class <tt>Item_base</tt> are declared. The function <tt>display(const Item_base&amp;)</tt> declared in namespace <tt>NS</tt> is added to the set of candidate functions.</P>

<a name="ch17lev3sec47"></a>
<h5 class="docSection3Title">Overloading and <tt>using</tt> Declarations</h5>
<p class="docText">A <tt>using</tt> declaration declares a name. As we saw in <a class="docLink" href="ch15lev1sec5.html#ch15lev2sec19">Section 15.5.3</a> (p. <a class="docLink" href="ch15lev1sec5.html#ch15lev2sec19">592</a>), there is no way to write a <tt>using</tt> declaration to refer to a specific function declaration:</p>
<pre>
    using NS::print(int); // <span class="docEmphItalicAlt">error: cannot specify parameter list</span>
    using NS::print;      // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">using</span> <span class="docEmphItalicAlt">declarations specify names only</span>
</pre><br>
<p class="docText">If a function is overloaded within a namespace, then a <tt>using</tt> declaration for the name of that function declares <span class="docEmphasis">all</span> the functions with that name. If there are <tt>print</tt> functions for <tt>int</tt> and <tt>double</tt> in the namespace NS, then a <tt>using</tt> declaration for <tt>NS::print</tt> makes both functions visible in the current scope.</p>
<p class="docText">A <tt>using</tt> declaration incorporates all versions of an overloaded function to ensure that the interface of the namespace is not violated. The author of a library provided different functions for a reason. Allowing users to selectively ignore some but not all of the functions from a set of overloaded functions could lead to surprising program behavior.</p>
<p class="docText">The functions introduced by a <tt>using</tt> declaration overload any other declarations of the functions with the same name already present in the scope where the <tt>using</tt> declaration appears.</p>
<p class="docText"><a name="idd1e140759"></a><a name="idd1e140766"></a>If the <tt>using</tt> declaration introduces a function in a scope that already has a function of the same name with the same parameter list, then the <tt>using</tt> declaration is in error. Otherwise, the <tt>using</tt> declaration defines additional overloaded instances of the given name. The effect is to increase the set of candidate functions.</p>

<a name="ch17lev3sec48"></a>
<h5 class="docSection3Title">Overloading and <tt>using</tt> Directives</h5>
<p class="docText">A <tt>using</tt> directive lifts the namespace members into the enclosing scope. If a namespace function has the same name as a function declared in the scope at which the namespace is placed, then the namespace member is added to the overload set:</p>
<pre>
    namespace libs_R_us {
        extern void print(int);
        extern void print(double);
    }
    void print(const std::string &amp;);
    // <span class="docEmphasis">using</span> <span class="docEmphItalicAlt">directive:</span>
    using namespace libs_R_us;
    // <span class="docEmphItalicAlt">using directive added names to the candidate set for calls to</span> <span class="docEmphasis">print:</span>
    // <span class="docEmphasis">print(int)</span> <span class="docEmphItalicAlt">from</span> <span class="docEmphasis">libs_R_us</span>
    // <span class="docEmphasis">print(double)</span> <span class="docEmphItalicAlt">from</span> <span class="docEmphasis">libs_R_us</span>
    // <span class="docEmphasis">print(const std::string &amp;)</span> <span class="docEmphItalicAlt">declared explicitly</span>
    void fooBar(int ival)
    {
         print("Value: "); // <span class="docEmphItalicAlt">calls global</span> <span class="docEmphasis">print(const string &amp;)</span>
         print(ival);      // <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">libs_R_us::print(int)</span>
    }
</pre><br>

<a name="ch17lev3sec49"></a>
<h5 class="docSection3Title">Overloading across Multiple <tt>using</tt> Directives</H5>
<p class="docText">If many <tt>using</tt> directives are present, then the names from each namespace become part of the candidate set:</P>
<pre>
    namespace AW {
        int print(int);
    }
    namespace Primer {
        double print(double);
    }
    // <span class="docEmphasis">using</span> <span class="docEmphItalicAlt">directives:</span>
    // <span class="docEmphItalicAlt">form an overload set of functions from different namespaces</span>
    using namespace AW;
    using namespace Primer;
    long double print(long double);
    int main() {
        print(1);   // <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">AW::print(int)</span>
        print(3.1); // <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">Primer::print(double)</span>
        return 0;
    }
</pre><br>
<p class="docText"><a name="idd1e140896"></a><a name="idd1e140901"></a><a name="idd1e140906"></a>The overload set for the function <tt>print</tt> in global scope contains the functions <tt>print(int), print(double)</tt>, and <tt>print(long double)</tt>. These functions are all part of the overload set considered for the function calls in <tt>main</tt>, even though these functions were originally declared in different namespace scopes.</P>
<a name="ch17sb14"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<H2 class="docSidebarTitle">Exercises Section 17.2.6</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch17qa11q1"></a><b>Exercise 17.22:</b></TD><td><p class="docText">Given the following code, determine which function, if any, matches the call to <tt>compute</tt>. List the candidate and viable functions. What type conversion sequence, if any, is applied to the argument to match the parameter in each viable function?</P>
<pre>
    namespace primerLib {
        void compute();
        void compute(const void *);
    }
    using primerLib::compute;
    void compute(int);
    void compute(double, double = 3.4);
    void compute(char*, char* = 0);

    int main()
    {
        compute(0);
        return 0;
    }
</pre><BR>
<p class="docText">What would happen if the <tt>using</tt> declaration were located in <tt>main</tt> before the call to <tt>compute</tt>? Answer the same questions as before.</p>
</td></tr></table></P>
</blockquote>
</TD></tr></table></p><br>


<a name="ch17lev2sec18"></a>
<h4 class="docSection2Title">17.2.7. Namespaces and Templates</H4>
<p class="docText">Declaring a template within a namespace impacts how template specializations (<a class="docLink" href="ch16lev1sec6.html#ch16lev1sec6">Section 16.6</a>, p. <a class="docLink" href="ch16lev1sec6.html#ch16lev1sec6">671</a>) are declared: An explicit specialization of a template must be declared in the namespace in which the generic template is defined. Otherwise, the specialization would have a different name than the template it specialized.</p>
<p class="docText">There are two ways to define a specialization: One is to reopen the namespace and add the definition of the specialization, which we can do because namespace definitions are discontiguous, Alternatively, we could define the specialization in the same way that we can define any namespace member outside its namespace definition: by defining the specialization using the template name qualified by the name of the namespace.</p>
<a name="ch17note31"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></TD><td valign="top"><p class="docText"> To provide our own specializations of templates defined in a namespace, we must ensure that the specialization definition is defined as being in the namespace containing the original template definition.</P></td></tr></table><br>
</p></div><br>


<a href="21001535.html"><img src="images/pixel.gif" alt="" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch17lev1sec1.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch17lev1sec3.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>