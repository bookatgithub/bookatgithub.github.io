<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 17.3.&nbsp; Multiple and Virtual Inheritance</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch17lev1sec2.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch17lev1sec4.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch17lev1sec3"></a>
<h3 class="docSection1Title">17.3. Multiple and Virtual Inheritance</h3>
<p class="docText"><a name="idd1e141005"></a><a name="idd1e141009"></a><a name="idd1e141014"></a><a name="idd1e141019"></a><a name="idd1e141023"></a><a name="idd1e141030"></a><a name="idd1e141035"></a><a name="idd1e141040"></a><a name="idd1e141044"></a><a name="idd1e141051"></a>Most C++ applications use <tt>public</tt> inheritance from a single base class. In some cases, however, single inheritance is inadequate, either because it fails to model the problem domain or the model it imposes is unnecessarily complex.</P>
<p class="docText">In these cases, <B><a name="ch17term16"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_16">multiple inheritance</a></b> may model the application more directly. Multiple inheritance is the ability to derive a class from more than one immediate base class. A multiply derived class inherits the properties of all its parents. Although simple in concept, the details of intertwining multiple base classes can present tricky design-level and implementation-level problems.</p>
<a name="ch17lev2sec19"></a>
<H4 class="docSection2Title">17.3.1. Multiple Inheritance</h4>
<p class="docText">This section uses a pedagogical example of a zoo animal hierarchy. Our zoo animals exist at different levels of abstraction. There are the individual animals, distinguished by their names, such as <tt>Ling-ling, Mowgli</tt>, and <tt>Balou</tt>. Each animal belongs to a species; Ling-Ling, for example, is a giant panda. Species, in turn, are members of families. A giant panda is a member of the bear family. Each family, in turn, is a member of the animal kingdomin this case, the more limited kingdom of a particular zoo.</p>
<p class="docText">Each level of abstraction contains data and operations that support a wider category of users. We'll define an abstract <tt>ZooAnimal</tt> class to hold information that is common to all the zoo animals and provides the public interface. The <tt>Bear</tt> class will contain information that is unique to the <tt>Bear</tt> family, and so on.</P>
<p class="docText">In addition to the actual zoo-animal classes, there are auxiliary classes that encapsulate various abstractions such as endangered animals. In our implementation of a <tt>Panda</tt> class, for example, a <tt>Panda</tt> is multiply derived from <tt>Bear</tt> and <tt>Endangered</tt>.</P>
<a name="ch17lev3sec50"></a>
<h5 class="docSection3Title">Defining Multiple Classes</h5>
<p class="docText">To support multiple inheritance, the derivation list</p>
<pre>
    class Bear : public ZooAnimal {
    };
</pre><br>
<p class="docText">is extended to support a comma-separated list of base classes:</p>
<pre>
    class Panda : public Bear, public Endangered {
    };
</pre><BR>
<p class="docText">The derived class specifies (either explicitly or implicitly) the access level <tt>public, protected</tt>, or <tt>private</tt> for each of its base classes. As with single inheritance, a class may be used as a base class under multiple inheritance only after it has been defined. There is no language-imposed limit on the number of base classes from which a class can be derived. A base class may appear only once in a given derivation list.</p>

<a name="ch17lev3sec51"></a>
<H5 class="docSection3Title">Multiply Derived Classes Inherit State from Each Base Class</H5>
<p class="docText"><a name="idd1e141147"></a><a name="idd1e141152"></a><a name="idd1e141159"></a><a name="idd1e141164"></a><a name="idd1e141169"></a><a name="idd1e141174"></a><a name="idd1e141181"></a>Under multiple inheritance, objects of a derived class contain a base-class subobject (<a class="docLink" href="ch15lev1sec2.html#ch15lev2sec5">Section 15.2.3</a>, p. <a class="docLink" href="ch15lev1sec2.html#ch15lev2sec5">565</a>) for each of its base classes. When we write</p>
<pre>
Panda ying_yang("ying_yang");
</pre><br>
<p class="docText">the object <tt>ying_yang</tt> is composed of a <tt>Bear</tt> class subobject (which itself contains a <tt>ZooAnimal</tt> base-class subobject), an <tt>Endangered</tt> class subobject, and the non<tt>static</tt> data members, if any, declared within the <tt>Panda</tt> class (see <a class="docLink" href="#ch17fig02">Figure 17.2</a>).</p>
<a name="ch17fig02"></a><P><center>
<H5 class="docFigureTitle">Figure 17.2. Multiple Inheritance <tt>Panda</tt> Hierarchy</h5>

<p class="docText">
<img border="0" alt="" width="420" height="264" SRC="images/0201721481/graphics/17fig02.gif;400478"></p>

</center></p><br>

<a name="ch17lev3sec52"></a>
<H5 class="docSection3Title">Derived Constructors Initialize All Base Classes</h5>
<p class="docText">Constructing an object of derived type involves constructing and initializing all its base subobjects. As is the case for inheriting from a single base class (<a class="docLink" href="ch15lev1sec4.html#ch15lev2sec12">Section 15.4.1</a>, p. <a class="docLink" href="ch15lev1sec4.html#ch15lev2sec12">580</a>), derived constructors may pass values to zero or more of their base classes in the constructor initializer:</p>
<pre>
    // <span class="docEmphItalicAlt">explicitly initialize both base classes</span>
    Panda::Panda(std::string name, bool onExhibit)
          : Bear(name, onExhibit, "Panda"),
            Endangered(Endangered::critical) { }
    // <span class="docEmphItalicAlt">implicitly use</span> <span class="docEmphasis">Bear</span> <span class="docEmphItalicAlt">default constructor to initialize the</span> <span class="docEmphasis">Bear</span> <span class="docEmphItalicAlt">subobject</span>
    Panda::Panda()
          : Endangered(Endangered::critical) { }
</pre><BR>

<a name="ch17lev3sec53"></a>
<h5 class="docSection3Title">Order of Construction</h5>
<p class="docText">The constructor initializer controls only the values that are used to initialize the base classes, not the order in which the base classes are constructed. The base-class <a name="idd1e141287"></a><a name="idd1e141292"></a><a name="idd1e141297"></a><a name="idd1e141304"></a><a name="idd1e141311"></a>constructors are invoked in the order in which they appear in the class derivation list. For <tt>Panda</tt>, the order of base-class initialization is:</P>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList"><tt>ZooAnimal</tt>, the ultimate base class up the hierarchy from <tt>Panda</tt>'s immediate base class <tt>Bear</tt></P></div></li><li><div style="font-weight:normal"><p class="docList"><tt>Bear</tt>, the first immediate base class</p></div></li><li><div style="font-weight:normal"><p class="docList"><tt>Endangered</tt>, the second immediate base, which itself has no base class</p></div></li><li><div style="font-weight:normal"><p class="docList"><tt>Panda</tt>; the members of <tt>Panda</tt> itself are initialized, and then the body of its constructor is run.</p></div></li></ol></div>
<a name="ch17note32"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><TD valign="top"><p class="docText"> The order of constructor invocation is not affected by whether the base class appears in the constructor initializer list or the order in which base classes appear within that list.</p></TD></tr></table><br>
</P></div><BR>
<p class="docText">For example, in <tt>Panda</tt>'s default constructor, the <tt>Bear</tt> default constructor is invoked implicitly; it does not appear in the constructor initializer list. Even so, <tt>Bear</tt>'s default constructor is invoked prior to the explicitly listed constructor of <tt>Endangered</tt>.</p>

<a name="ch17lev3sec54"></a>
<h5 class="docSection3Title">Order of Destruction</h5>
<p class="docText">Destructors are always invoked in the reverse order from which the constructors are run. In our example, the order in which the destructors are called is <tt>~Panda, ~Endangered, ~Bear, ~ZooAnimal</tt>.</p>
<a name="ch17sb15"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<H2 class="docSidebarTitle">Exercises Section 17.3.1</H2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch17qa12q1"></a><B>Exercise 17.23:</b></TD><td><p class="docText">Which, if any, of the following declarations are in error. Explain why.</p>
<pre>
    (a) class CADVehicle : public CAD, Vehicle { ... };
    (b) class DoublyLinkedList:
              public List, public List { ... };
    (c) class iostream: public istream, public ostream { ... };
</pre><br>
</td></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch17qa12q2"></a><B>Exercise 17.24:</b></td><td><p class="docText">Given the following class hierarchy, in which each class defines a default constructor,</P>
<pre>
    class A { ... };
    class B : public A { ... };
    class C : public B { ... };
    class X { ... };
    class Y { ... };
    class Z : public X, public Y { ... };
    class MI : public C, public Z { ... };
</pre><br>
<p class="docText">what is the order of constructor execution for the following definition?</P>
<pre>
    MI mi;
</pre><br>
</td></tr></table></p>
</blockquote>
</td></tr></table></p><br>


<a name="ch17lev2sec20"></a>
<h4 class="docSection2Title">17.3.2. Conversions and Multiple Base Classes</h4>
<p class="docText"><a name="idd1e141461"></a><a name="idd1e141468"></a><a name="idd1e141473"></a><a name="idd1e141478"></a><a name="idd1e141483"></a><a name="idd1e141488"></a>Under single inheritance, a pointer or a reference to a derived class can be converted automatically to a pointer or a reference to a base class. The same holds true with multiple inheritance. A pointer or reference to a derived class can be converted to a pointer or reference to any of its base classes. For example, a <tt>Panda</tt> pointer or reference could be converted to a pointer or a reference to <tt>ZooAnimal, Bear</tt>, or <tt>Endangered:</tt></p>
<pre>
    // <span class="docEmphItalicAlt">operations that take references to base classes of type</span> <span class="docEmphasis">Panda</span>
    void print(const Bear&amp;);
    void highlight(const Endangered&amp;);
    ostream&amp; operator&lt;&lt;(ostream&amp;, const ZooAnimal&amp;);
    Panda ying_yang("ying_yang");    // <span class="docEmphItalicAlt">create a</span> <span class="docEmphasis">Panda</span> <span class="docEmphItalicAlt">object</span>
    print(ying_yang);      // <span class="docEmphItalicAlt">passes</span> <span class="docEmphasis">Panda</span> <span class="docEmphItalicAlt">as reference to</span> <span class="docEmphasis">Bear</span>
    highlight(ying_yang);  // <span class="docEmphItalicAlt">passes</span> <span class="docEmphasis">Panda</span> <span class="docEmphItalicAlt">as reference to</span> <span class="docEmphasis">Endangered</span>
    cout &lt;&lt; ying_yang &lt;&lt; endl;  // <span class="docEmphItalicAlt">passes</span> <span class="docEmphasis">Panda</span> <span class="docEmphItalicAlt">as reference to</span> <span class="docEmphasis">ZooAnimal</span>
</pre><br>
<p class="docText">Under multiple inheritance, there is a greater possibility of encountering an ambiguous conversion. The compiler makes no attempt to distinguish between base classes in terms of a derived-class conversion. Converting to each base class is equally good. For example, if there was an overloaded version of <tt>print</tt></p>
<pre>
    void print(const Bear&amp;);
    void print(const Endangered&amp;);
</pre><BR>
<p class="docText">an unqualified invocation of print with a Panda object</P>
<pre>
    Panda ying_yang("ying_yang");
    print(ying_yang);              // <span class="docEmphItalicAlt">error: ambiguous</span>
</pre><br>
<p class="docText">results in a compile-time error that the call is ambiguous.</P>
<a name="ch17sb16"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<H2 class="docSidebarTitle">Exercises Section 17.3.2</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch17qa13q1"></a><b>Exercise 17.25:</b></TD><td><p class="docText">Given the following class hierarchy, in which each class defines a default constructor,</P>
<pre>
    class X { ... };
    class A { ... };
    class B : public A { ... };
    class C : private B { ... };
    class D : public X, public C { ... };
</pre><BR>
<p class="docText">which, if any, of the following conversions are not permitted?</p>
<pre>
    D *pd = new D;
    (a) X *px = pd; (c) B *pb = pd;
    (b) A *pa = pd; (d) C *pc = pd;
</pre><br>
</td></TR></table></P>
</blockquote>
</td></tr></table></p><br>
<a name="ch17lev3sec55"></a>
<H5 class="docSection3Title">Virtual Functions under Multiple Inheritance</h5>
<p class="docText"><a name="idd1e141629"></a><a name="idd1e141634"></a><a name="idd1e141641"></a><a name="idd1e141646"></a><a name="idd1e141653"></a><a name="idd1e141660"></a><a name="idd1e141667"></a>To see how the virtual function mechanism is affected by multiple inheritance, let's assume that our classes define the virtual members listed in <a class="docLink" href="#ch17table02">Table 17.2</a>.</p>
<a name="ch17table02"></a><P><table cellspacing="0" class="allBorders" border="1" RULES="groups" cellpadding="5"><caption><h5 class="docTableTitle">Table 17.2. Virtual Function in the ZooAnimal/Endangered Classes</h5></caption><colgroup><col width="100"><col width="400"></colgroup><thead><TR><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Function</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Class Defining Own Version</P></th></tr></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>print</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>ZooAnimal::ZooAnimal</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>Bear::Bear</tt></P></TD></tr><TR><td class="docTableCell" align="left" valign="top">&nbsp;</td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>Endangered::Endangered</tt></P></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>Panda::Panda</tt></p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>highlight</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>Endangered::Endangered</tt></p></td></tr><tr><TD class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>Panda::Panda</tt></P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>toes</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>Bear::Bear</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>Panda::Panda</tt></p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>cuddle</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>Panda::Panda</tt></p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText">destructor</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>ZooAnimal::ZooAnimal</tt></p></TD></tr><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>Endangered::Endangered</tt></p></TD></TR></table></p><br>

<a name="ch17lev3sec56"></a>
<h5 class="docSection3Title">Lookup Based on Type of Pointer or Reference</h5>
<p class="docText">As with single inheritance, a pointer or reference to a base class can be used to access only members defined (or inherited) in the base. It cannot access members introduced in the derived class.</P>
<p class="docText">When a class inherits from multiple base classes, there is no implied relationship between those base classes. Using a pointer to one base does not allow access to members of another base.</p>
<p class="docText">As an example, we could use a pointer or reference to a <tt>Bear, ZooAnimal, Endangered</tt>, or <tt>Panda</tt> to access a <tt>Panda</tt> object. The type of the pointer we use determines which operations are accessible. If we use a <tt>ZooAnimal</tt> pointer, only the operations defined in that class are usable. The <tt>Bear</tt>-specific, <tt>Panda</tt>-specific, and <tt>Endangered</tt> portions of the <tt>Panda</tt> interface are inaccessible. Similarly, a <tt>Bear</tt> pointer or reference knows only about the <tt>Bear</tt> and <tt>ZooAnimal</tt> members; an <tt>Endangered</tt> pointer or reference is limited to the <tt>Endangered</tt> members:</p>
<pre>
    Bear *pb = new Panda("ying_yang");
    pb-&gt;print(cout); // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">Panda::print(ostream&amp;)</span>
    pb-&gt;cuddle();    // <span class="docEmphItalicAlt">error: not part of</span> <span class="docEmphasis">Bear</span> <span class="docEmphItalicAlt">interface</span>
    pb-&gt;highlight(); // <span class="docEmphItalicAlt">error: not part</span> <span class="docEmphItalicAlt">of</span> <span class="docEmphasis">Bear</span> <span class="docEmphItalicAlt">interface</span>
    delete pb;       // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">Panda::~Panda()</span>
</pre><BR>
<p class="docText">If the <tt>Panda</tt> object had been assigned to a <tt>ZooAnimal</tt> pointer, this set of calls would resolve exactly the same way.</p>
<p class="docText"><a name="idd1e141935"></a><a name="idd1e141940"></a><a name="idd1e141945"></a><a name="idd1e141950"></a>When a <tt>Panda</tt> is used via an <tt>Endangered</tt> pointer or reference, the Panda-specific and <tt>Bear</tt> portions of the <tt>Panda</tt> interface are inaccessible:</p>
<pre>
    Endangered *pe = new Panda("ying_yang");
    pe-&gt;print(cout);  // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">Panda::print(ostream&amp;)</span>
    pe-&gt;toes();       // <span class="docEmphItalicAlt">error: not part of</span> <span class="docEmphasis">Endangered</span> <span class="docEmphItalicAlt">interface</span>
    pe-&gt;cuddle();     // <span class="docEmphItalicAlt">error: not part of</span> <span class="docEmphasis">Endangered</span> <span class="docEmphItalicAlt">interface</span>
    pe-&gt;highlight();  // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">Endangered::highlight()</span>
    delete pe;        // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">Panda::~Panda()</span>
</pre><BR>

<a name="ch17lev3sec57"></a>
<h5 class="docSection3Title">Determining Which Virtual Destructor to Use</H5>
<p class="docText">Assuming all the root base classes properly define their destructors as virtual, then the handling of the virtual destructor is consistent regardless of the pointer type through which we delete the object:</p>
<pre>
    // <span class="docEmphItalicAlt">each pointer points to a</span> <span class="docEmphasis">Panda</span>
    delete pz; // <span class="docEmphasis">pz</span> <span class="docEmphItalicAlt">is a</span> <span class="docEmphasis">ZooAnimal*</span>
    delete pb; // <span class="docEmphasis">pb</span> <span class="docEmphItalicAlt">is a</span> <span class="docEmphasis">Bear*</span>
    delete pp; // <span class="docEmphasis">pp</span> <span class="docEmphItalicAlt">is a</span> <span class="docEmphasis">Panda*</span>
    delete pe; // <span class="docEmphasis">pe</span> <span class="docEmphItalicAlt">is a</span> <span class="docEmphasis">Endangered*</span>
</pre><br>
<p class="docText">Assuming each of these pointers points to a <tt>Panda</tt> object, the exact same order of destructor invocations occurs in each case. The order of destructor invocations is the reverse of the constructor order: The <tt>Panda</tt> destructor is invoked through the virtual mechanism. Following execution of the <tt>Panda</tt> destructor, the <tt>Endangered, Bear</tt>, then <tt>ZooAnimal</tt> destructors are invoked in turn.</p>
<a name="ch17sb17"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 17.3.2</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch17qa14q1"></a><b>Exercise 17.26:</b></td><TD><p class="docText">On page <a class="docLink" href="#ch17lev3sec55">735</a> we presented a series of calls made through a <tt>Bear</tt> pointer that pointed to a <tt>Panda</tt> object. We noted that if the pointer had been a <tt>ZooAnimal</tt> pointer the calls would resolve the same way. Explain why.</P></td></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch17qa14q2"></a><B>Exercise 17.27:</b></TD><td><p class="docText">Assume we have two base classes, <tt>Base1</tt> and <tt>Base2</tt>, each of which defines a virtual member named <tt>print</tt> and a virtual destructor. From these base classes we derive the following classes each of which redefines the <tt>print</tt> function:</p>
<pre>
    class D1 : public Base1 { /* ... */ };
    class D2 : public Base2 { /* ... */ };
    class MI : public D1, public D2 { /* ... */ };
</pre><br>
<p class="docText">Using the following pointers determine which function is used in each call:</p>
<pre>
    Base1 *pb1 = new MI; Base2 *pb2 = new MI;
    D1 *pd1 = new MI; D2 *pd2 = new MI;

    (a) pb1-&gt;print(); (b) pd1-&gt;print(); (c) pd2-&gt;print();
    (d) delete pb2;   (e) delete pd1;   (f) delete pd2;
</pre><br>
</TD></tr><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch17qa14q3"></a><b>Exercise 17.28:</b></td><td><p class="docText">Write the class definitions that correspond to <a class="docLink" href="#ch17table02">Table 17.2</a> (p. <a class="docLink" href="#ch17table02">735</a>).</P></TD></tr></table></p>
</blockquote>
</td></tr></table></P><br>


<a name="ch17lev2sec21"></a>
<h4 class="docSection2Title">17.3.3. Copy Control for Multiply Derived Classes</H4>
<p class="docText"><a name="idd1e142182"></a><a name="idd1e142191"></a><a name="idd1e142199"></a><a name="idd1e142206"></a><a name="idd1e142211"></a><a name="idd1e142216"></a><a name="idd1e142221"></a><a name="idd1e142226"></a><a name="idd1e142231"></a><a name="idd1e142236"></a><a name="idd1e142246"></a><a name="idd1e142251"></a><a name="idd1e142259"></a><a name="idd1e142264"></a>The memberwise initialization, assignment and destruction (<a class="docLink" href="ch13.html#ch13">Chapter 13</a>) of a multiply derived class behaves in the same way as under single inheritance. Each base class is implicitly constructed, assigned or destroyed, using that base class' own copy constructor, assignment operator or destructor.</p>
<p class="docText">Let's assume that <tt>Panda</tt> uses the default copy control members. Using the default copy constructor, the initialization of <tt>ling_ling</tt></p>
<pre>
    Panda ying_yang("ying_yang");  // <span class="docEmphItalicAlt">create a</span> <span class="docEmphasis">Panda</span> <span class="docEmphItalicAlt">object</span>
    Panda ling_ling = ying_yang;   // <span class="docEmphItalicAlt">uses copy constructor</span>
</pre><BR>
<p class="docText">invokes the <tt>Bear</tt> copy constructor, which in turn runs the <tt>ZooAnimal</tt> copy constructor prior to executing the <tt>Bear</tt> copy constructor. Once the <tt>Bear</tt> portion of <tt>ling_ling</tt> is constructed, the <tt>Endangered</tt> copy constructor is run to create that part of the object. Finally, the <tt>Panda</tt> copy constructor is run.</p>
<p class="docText">The synthesized assignment operator behaves similarly to the copy constructor. It assigns the <tt>Bear</tt> (and through <tt>Bear</tt>, the <tt>ZooAnimal</tt>) parts of the object first. Next, it assigns the <tt>Endangered</tt> part, and finally the <tt>Panda</tt> part.</P>
<p class="docText">The synthesized destructor destroys each member of the <tt>Panda</tt> object and calls the destructors for the base class parts, in reverse order from construction.</p>
<a name="ch17note33"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="84" height="51" SRC="images/0201721481/graphics/tip.jpg;400478"></td><td valign="top"><p class="docText"> As is the case for single inheritance (<a class="docLink" href="ch15lev1sec4.html#ch15lev2sec14">Section 15.4.3</a>, p. <a class="docLink" href="ch15lev1sec4.html#ch15lev2sec14">584</a>), if a class with multiple bases defines its own destructor, that destructor is responsible only for cleaning up the derived class. If the derived class defines its own copy constructor or assignment operator, then the class is responsible for copying (assigning) all the base class subparts. The base parts are automatically copied or assigned only if the derived class uses the synthesized versions of these members.</p></td></tr></table><br>
</p></div><br>

<a name="ch17lev2sec22"></a>
<h4 class="docSection2Title">17.3.4. Class Scope under Multiple Inheritance</H4>
<p class="docText">Class scope (<a class="docLink" href="ch15lev1sec5.html#ch15lev1sec5">Section 15.5</a>, p. <a class="docLink" href="ch15lev1sec5.html#ch15lev1sec5">590</a>) is more complicated in multiple inheritance because a derived scope may be enclosed by multiple base class scopes. As usual, name lookup for a name used in a member function starts in the function itself. If the name is not found locally, then lookup continues in the member's class and then searches each base class in turn. Under multiple inheritance, the search simultaneously examines all the base-class inheritance subtreesin our example, both the <tt>Endangered</tt> and the <tt>Bear</tt>/<tt>ZooAnimal</tt> subtrees are examined in parallel. If the name is found in more than one subtree, then the use of that name must explicitly specify which base class to use. Otherwise, the use of the name is ambiguous.</P>
<a name="ch17note34"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="images/0201721481/graphics/beware.jpg;400478"></td><TD valign="top"><p class="docText"> When a class has multiple base classes, name lookup happens simultaneously through all the immediate base classes. It is possible for a multiply derived class to inherit a member with the same name from two or more base classes. Unqualified uses of that name are ambiguous.</P></td></tr></table><br>
</p></div><br>
<a name="ch17lev3sec58"></a>
<H5 class="docSection3Title">Multiple Base Classes Can Lead to Ambiguities</h5>
<p class="docText"><a name="idd1e142405"></a><a name="idd1e142412"></a><a name="idd1e142419"></a><a name="idd1e142426"></a><a name="idd1e142431"></a><a name="idd1e142436"></a><a name="idd1e142443"></a>Assume both <tt>Bear</tt> and <tt>Endangered</tt> define a member named <tt>print</tt>. If <tt>Panda</tt> does not define that member, then a statement such as the following</P>
<pre>
    ying_yang.print(cout);
</pre><BR>
<p class="docText">results in a compile-time error.</p>
<p class="docText">The derivation of <tt>Panda</tt>, which results in Panda having two members named <tt>print</tt>, is perfectly legal. The derivation results in only a <span class="docEmphasis">potential</span> ambiguity. That ambiguity is avoided if no <tt>Panda</tt> object ever calls <tt>print</tt>. The error would also be avoided if each call to <tt>print</tt> specifically indicated which version of <tt>print</tt> was wanted<tt>Bear::print</tt> or <tt>Endangered::print</tt>. An error is issued only if there is an ambiguous attempt to use the member.</p>
<p class="docText">If a declaration is found only in one base-class subtree, then the identifier is resolved and the lookup algorithm concludes. For example, class <tt>Endangered</tt> might have an operation to return the given estimated population of its object. If so, the following call</p>
<pre>
    ying_yang.population();
</pre><BR>
<p class="docText">would compile without complaint. The name <tt>population</tt> would be found in the <tt>Endangered</tt> base class and does not appear in <tt>Bear</tt> or any of its base classes.</P>

<a name="ch17lev3sec59"></a>
<h5 class="docSection3Title">Name Lookup Happens First</h5>
<p class="docText">Although the ambiguity of the two inherited <tt>print</tt> members is reasonably obvious, it might be more surprising to learn that an error would be generated even if the two inherited functions had different parameter lists. Similarly, it would be an error even if the <tt>print</tt> function were private in one class and public or protected in the other. Finally, if <tt>print</tt> were defined in <tt>ZooAnimal</tt> and not <tt>Bear</tt>, the call would still be in error.</p>
<p class="docText">As always, name lookup happens in two steps (<a class="docLink" href="ch07lev1sec8.html#ch07lev2sec27">Section 7.8.1</a>, p. <a class="docLink" href="ch07lev1sec8.html#ch07lev2sec27">268</a>): First the compiler finds a matching declaration (or, in this case, two matching declarations, which causes the ambiguity). Only then does the compiler decide whether the declaration it found is legal.</p>

<a name="ch17lev3sec60"></a>
<H5 class="docSection3Title">Avoiding User-Level Ambiguities</h5>
<p class="docText">We could resolve the <tt>print</tt> ambiguity by specifying which class to use:</p>
<pre>
    ying_yang.Endangered::print(cout);
</pre><BR>
<p class="docText">The best way to avoid potential ambiguities is to define a version of the function in the derived class that resolves the ambiguity. For example, we should give our <tt>Panda</tt> class a <tt>print</tt> function that chooses which version of <tt>print</tt> to use:</p>
<pre>
    std::ostream&amp; Panda::print(std::ostream &amp;os) const

    {
        Bear::print(os);        // <span class="docEmphItalicAlt">print the</span> <span class="docEmphasis">Bear</span> <span class="docEmphItalicAlt">part</span>
        Endangered::print(os);  // <span class="docEmphItalicAlt">print the</span> <span class="docEmphasis">Endangered</span> <span class="docEmphItalicAlt">part</span>
        return os;
    }
</pre><br>
<a name="ch17sb18"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Code for Exercises to Section 17.3.4</h2>
<pre>
   struct Base1 {
       void print(int) const;
    protected:
       int    ival;
       double dval;
       char   cval;
    private:
        int   *id;
    };
    struct Base2 {
        void print(double) const;
    protected:
        double fval;
    private:
        double dval;
    };
    struct Derived : public Base1 {
        void print(std::string) const;
    protected:
        std::string sval;
        double      dval;
    };
    struct MI : public Derived, public Base2 {
        void print(std::vector&lt;double&gt;);
    protected:
        int                  *ival;
        std::vector&lt;double&gt;  dvec;
    };
</pre><br>
</td></tr></table></p><br>
<a name="ch17sb19"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 17.3.4</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch17qa15q1"></a><b>Exercise 17.29:</b></TD><td><p class="docText">Given the class hierarchy in the box on this page and the following <tt>MI::foo</tt> member function skeleton,</p>
<pre>
    int ival;
    double dval;

    void MI::foo(double dval) { int id; /* ... */ }
</pre><BR>
<div style="font-weight:bold"><ol class="docList" type="a"><LI><div style="font-weight:normal"><p class="docList">identify the member names visible from within <tt>MI</tt>. Are there any names visible from more than one base class?</p></div></li><li><div style="font-weight:normal"><p class="docList">identify the set of members visible from within <tt>MI::foo</tt>.</p></div></li></ol></div>
</TD></tr><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch17qa15q2"></a><b>Exercise 17.30:</b></td><td><p class="docText">Given the hierarchy in the box on page <a class="docLink" href="#ch17sb18">739</a>, why is this call to <tt>print</tt> an error?</P>
<pre>
    MI mi;
    mi.print(42);
</pre><BR>
<p class="docText">Revise <tt>MI</tt> to allow this call to <tt>print</tt> to compile and execute correctly.</p>
</td></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch17qa15q3"></a><b>Exercise 17.31:</b></td><TD><p class="docText">Using the class hierarchy in the box on page <a class="docLink" href="#ch17sb18">739</a>, identify which of the following assignments, if any, are in error:</p>
<pre>
    void MI::bar() {
        int sval;
        // <span class="docEmphItalicAlt">exercise questions occur here ...</span>
    }
    (a) dval = 3.14159;   (d) fval = 0;
    (b) cval = 'a';       (e) sval = *ival; (c) id = 1;
</pre><br>
</TD></tr><TR valign="top"><td align="right" class="docText" width="50"><a name="ch17qa15q4"></a><b>Exercise 17.32:</b></td><td><p class="docText">Using the class hierarchy defined in the box on page <a class="docLink" href="#ch17sb18">739</a> and the following skeleton of the <tt>MI::foobar</tt> member function</p>
<pre>
    void MI::foobar(double cval)
    {
        int dval;
        // <span class="docEmphItalicAlt">exercise questions occur here ...</span>
    }
</pre><br>
<div style="font-weight:bold"><ol class="docList" type="a"><li><div style="font-weight:normal"><p class="docList">assign to the local instance of <tt>dval</tt> the sum of the <tt>dval</tt> member of <tt>Base1</tt> and the <tt>dval</tt> member of <tt>Derived</tt>.</p></div></li><li><div style="font-weight:normal"><p class="docList">assign the value of the last element in <tt>MI::dvec</tt> to <tt>Base2::fval</tt>.</p></div></li><li><div style="font-weight:normal"><p class="docList">assign <tt>cval</tt> from <tt>Base1</tt> to the first character in <tt>sval</tt> from <tt>Derived</tt>.</P></div></LI></ol></div>
</td></TR></table></p>
</blockquote>
</td></TR></table></P><br>


<a name="ch17lev2sec23"></a>
<h4 class="docSection2Title">17.3.5. Virtual Inheritance</h4>
<p class="docText"><a name="idd1e142812"></a><a name="idd1e142818"></a><a name="idd1e142824"></a>Under multiple inheritance, a base class can occur multiple times in the derivation hierarchy. In fact, our programs have already used a class that inherits from the same base class more than once through its inheritance hierarchy.</p>
<p class="docText">Each of the IO library classes inherits from a common abstract base class. That abstract class manages the condition state of the stream and holds the buffer that the stream reads or writes. The <tt>istream</tt> and <tt>ostream</tt> classes inherit directly from this common base class. The library defines another class, named <tt>iostream</tt>, that inherits from both <tt>istream</tt> and <tt>ostream</tt>. The <tt>iostream</tt> class can both read and write a stream. A simplified version of the IO inheritance hierarchy is illustrated in <a class="docLink" href="#ch17fig03">Figure 17.3</a> on the facing page.</p>
<a name="ch17fig03"></a><P><center>
<h5 class="docFigureTitle">Figure 17.3. Virtual Inheritance <tt>iostream</tt> Hierarchy (Simplified)</H5>

<p class="docText">
<img border="0" alt="" width="425" height="228" SRC="images/0201721481/graphics/17fig03.gif;400478"></P>

</center></p><br>
<p class="docText">As we know, a multiply inherited class inherits state and action from each of its parents. If the IO types used normal inheritance, then each <tt>iostream</tt> object would contain two <tt>ios</tt> subobjects: one instance contained within its <tt>istream</tt> subobject and the other within its <tt>ostream</tt> subobject. From a design perspective, this implementation is just wrong: The <tt>iostream</tt> class wants to read to and write <a name="idd1e142890"></a><a name="idd1e142896"></a><a name="idd1e142901"></a><a name="idd1e142907"></a><a name="idd1e142912"></a><a name="idd1e142915"></a><a name="idd1e142920"></a><a name="idd1e142923"></a>from a single buffer; it wants the condition state to be shared across input and output operations. If there are two separate <tt>ios</tt> objects, this sharing is not possible.</p>
<p class="docText">In C++ we solve this kind of problem by using <B><a name="ch17term32"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_32">virtual inheritance</a></b>. Virtual inheritance is a mechanism whereby a class specifies that it is willing to share the state of its virtual base class. Under virtual inheritance, only one, shared base-class subobject is inherited for a given virtual base regardless of how many times the class occurs as a virtual base within the derivation hierarchy. The shared base-class subobject is called a <B><a name="ch17term31"></a><a class="docLink" href="ch17lev1sec5.html#gloss17_31">virtual base class</a></b>.</p>
<p class="docText">The <tt>istream</tt> and <tt>ostream</tt> classes inherit virtually from their base class. By making their base class virtual, <tt>istream</tt> and <tt>ostream</tt> specify that if some other class, such as <tt>iostream</tt>, inherits from both of them, then only one copy of their common base class will be present in the derived class. We make a base class virtual by including the keyword <tt>virtual</tt> in the derivation list:</p>
<pre>
    class istream : public virtual ios { ... };
    class ostream : virtual public ios { ... };

    // <span class="docEmphasis">iostream</span> <span class="docEmphItalicAlt">inherits only one copy of its</span> <span class="docEmphasis">ios</span> <span class="docEmphItalicAlt">base class</span>
    class iostream: public istream, public ostream { ... };
</pre><br>
<a name="ch17lev3sec61"></a>
<h5 class="docSection3Title">A Different Panda Class</H5>
<p class="docText">For the purposes of illustrating virtual inheritance, we'll continue to use the <tt>Panda</tt> class as a pedagogical example. Within zoological circles, for more than 100 years there has been an occasionally fierce debate as to whether the <tt>Panda</tt> belongs to the <tt>Raccoon</tt> or the <tt>Bear</tt> family. Because software design is primarily a service industry, our most practical solution is to derive <tt>Panda</tt> from both:</p>
<pre>
    class Panda : public Bear,
                  public Raccoon, public Endangered {
    };
</pre><br>
<p class="docText"><a name="idd1e143011"></a><a name="idd1e143016"></a><a name="idd1e143021"></a>Our virtual inheritance <tt>Panda</tt> hierarchy is pictured in <a class="docLink" href="#ch17fig04">Figure 17.4</a>. If we examine that hierarchy, we notice a nonintuitive aspect of virtual inheritance: The virtual derivation (in our case, of <tt>Bear</tt> and <tt>Raccoon</tt>) has to be made prior to any actual need for it to be present. Virtual inheritance becomes necessary only with the declaration of <tt>Panda</tt>, but if <tt>Bear</tt> and <tt>Raccoon</tt> are not already virtually derived, the designer of the <tt>Panda</tt> class is out of luck.</P>
<a name="ch17fig04"></a><p><center>
<h5 class="docFigureTitle">Figure 17.4. Virtual Inheritance <tt>Panda</tt> Hierarchy</H5>

<p class="docText">
<img border="0" alt="" width="435" height="222" SRC="images/0201721481/graphics/17fig04.gif;400478"></p>

</center></P><br>
<p class="docText">In practice, the requirement that an intermediate base class specify its inheritance as virtual rarely causes any problems. Ordinarily, a class hierarachy that uses virtual inheritance is designed at one time by either one individual or a project design group. It is exceedingly rare for a class to be developed independently that needs a virtual base in one of its base classes and in which the developer of the new base class cannot change the existing hierarchy.</p>


<a name="ch17lev2sec24"></a>
<h4 class="docSection2Title">17.3.6. Virtual Base Class Declaration</h4>
<p class="docText">A base class is specified as being derived through virtual inheritance by modifying its declaration with the keyword <tt>virtual</tt>. For example, the following declarations make <tt>ZooAnimal</tt> a virtual base class of both <tt>Bear</tt> and <tt>Raccoon</tt>:</p>
<pre>
    // <span class="docEmphItalicAlt">the order of the keywords public and virtual is not significant</span>
    class Raccoon : public virtual ZooAnimal { /* ... */ };
    class Bear : virtual public ZooAnimal { /* ... */ };
</pre><br>
<a name="ch17note35"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"> Specifying virtual derivation has an impact only in classes derived from the class that specifies a virtual base. Rather than affecting objects of the derived class' own type, it is a statement about the derived class' relationship to its own, future derived class.</p></td></TR></table><BR>
</p></div><BR>
<p class="docText">The <tt>virtual</tt> specifier states a willingness to share a single instance of the named <a name="idd1e143117"></a><a name="idd1e143122"></a><a name="idd1e143127"></a><a name="idd1e143132"></a><a name="idd1e143137"></a><a name="idd1e143142"></a>base class within a subsequently derived class.</p>
<p class="docText">Any class that can be specified as a base class also could be specified as a virtual base class. A virtual base may contain any class element normally supported by a nonvirtual base class.</p>
<a name="ch17lev3sec62"></a>
<H5 class="docSection3Title">Normal Conversions to Base Are Supported</H5>
<p class="docText">An object of the derived class can be manipulated as usual through a pointer or a reference to a base-class type even though the base class is virtual. For example, all of the following <tt>Panda</tt> base class conversions execute correctly even though <tt>Panda</tt> inherits its <tt>ZooAnimal</tt> part as a virtual base:</p>
<pre>
    void dance(const Bear*);
    void rummage(const Raccoon*);
    ostream&amp; operator&lt;&lt;(ostream&amp;, const ZooAnimal&amp;);
    Panda ying_yang;
    dance(&amp;ying_yang);   // <span class="docEmphItalicAlt">ok: converts address to pointer to</span> <span class="docEmphasis">Bear</span>
    rummage(&amp;ying_yang); // <span class="docEmphItalicAlt">ok: converts address to pointer to</span> <span class="docEmphasis">Raccoon</span>
    cout &lt;&lt; ying_yang;   // <span class="docEmphItalicAlt">ok: passes</span> <span class="docEmphasis">ying_yang</span> <span class="docEmphItalicAlt">as a</span> <span class="docEmphasis">ZooAnimal</span>
</pre><br>

<a name="ch17lev3sec63"></a>
<h5 class="docSection3Title">Visibility of Virtual Base-Class Members</h5>
<p class="docText">Multiple-inheritance hierarchies using virtual bases pose fewer ambiguity problems than do those without virtual inheritance.</p>
<a name="ch17note36"></a><div class="docNote"><P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></TD><td valign="top"><p class="docText"> Members in the shared virtual base can be accessed unambiguously and directly. Similarly, if a member from the virtual base is redefined along only one derivation path, then that redefined member can be accessed directly. Under a nonvirtual derivation, both kinds of access would be ambiguous.</p></td></TR></table><BR>
</p></div><br>
<p class="docText">Assume a member named <tt>X</tt> is inherited through more than one derivation path. There are three possibilities:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">If in each path <tt>X</tt> represents the same virtual base class member, then there is no ambiguity because a single instance of the member is shared.</P></div></li><li><div style="font-weight:normal"><p class="docList">If in one path <tt>X</tt> is a member of the virtual base class member and in another path <tt>X</tt> is a member of a subsequently derived class, there is also no ambiguitythe specialized derived class instance is given precedence over the shared virtual base class instance.</P></div></li><li><div style="font-weight:normal"><p class="docList">If along each inheritance path <tt>X</tt> represents a different member of a subsequently derived class, then the direct access of the member is ambiguous.</P></div></li></ol></div>
<p class="docText">As in a nonvirtual multiple inheritance hierarchy, ambiguities of this sort are best resolved by the class providing an overriding instance in the derived class.</P>
<a name="ch17sb20"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Exercises Section 17.3.6</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch17qa17q1"></a><b>Exercise 17.33:</b></td><td><p class="docText"><a name="idd1e143271"></a><a name="idd1e143278"></a><a name="idd1e143283"></a><a name="idd1e143290"></a>Given the following class hierarchy, which inherited members can be accessed without qualification from within the <tt>VMI</tt> class? Which require qualification? Explain your reasoning.</p>
<pre>
    class Base {
    public:
        bar(int);
    protected:
        int ival;
    };
    class Derived1 : virtual public Base {
    public:
        bar(char);
        foo(char);
    protected:
        char cval;
    };
    class Derived2 : virtual public Base {
    public:
        foo(int);
    protected:
        int ival;
        char cval;
    };
    class VMI : public Derived1, public Derived2 { };
</pre><br>
</TD></TR></table></p>
</blockquote>
</TD></tr></table></p><BR>


<a name="ch17lev2sec25"></a>
<H4 class="docSection2Title">17.3.7. Special Initialization Semantics</h4>
<p class="docText">Ordinarily each class initializes only its own direct base class(es). This initialization strategy fails when applied to a virtual base class. If the normal rules were used, then the virtual base might be initialized multiple times. The class would be initialized along each inheritance path that contains the virtual base. In our <tt>ZooAnimal</tt> example, using normal initialization rules would result in both <tt>Bear</tt> and <tt>Raccoon</tt> attempting to initialize the <tt>ZooAnimal</tt> part of a <tt>Panda</tt> object.</p>
<p class="docText">To solve this duplicate-initialization problem, classes that inherit from a class that has a virtual base have special handling for initialization. In a virtual derivation, the virtual base is initialized by the <span class="docEmphasis">most derived constructor</span>. In our example, when we create a <tt>Panda</tt> object, the <tt>Panda</tt> constructor alone controls how the <tt>ZooAnimal</tt> base class is initialized.</p>
<p class="docText">Although the virtual base is initialized by the most derived class, any classes that inherit immediately or indirectly from the virtual base usually also have to provide their own initializers for that base. As long as we can create independent objects of a type derived from a virtual base, that class must initialize its virtual base. These initializers are used only when we create objects of the intermediate type.</p>
<p class="docText"><a name="idd1e143355"></a><a name="idd1e143360"></a>In our hierarchy, we could have objects of type <tt>Bear, Raccoon</tt>, or <tt>Panda</tt>. When a <tt>Panda</tt> is created, it is the most derived type and controls initialization of the shared <tt>ZooAnimal</tt> base. When a <tt>Bear</tt> (or a <tt>Raccoon</tt>) is created, there is no further derived type involved. In this case, the <tt>Bear</tt> (or <tt>Raccoon</tt>) constructors directly initialize their <tt>ZooAnimal</tt> base as usual:</p>
<pre>
    Bear::Bear(std::string name, bool onExhibit):
             ZooAnimal(name, onExhibit, "Bear") { }
    Raccoon::Raccoon(std::string name, bool onExhibit)
           : ZooAnimal(name, onExhibit, "Raccoon") { }
</pre><BR>
<p class="docText">The <tt>Panda</tt> constructor also initializes the <tt>ZooAnimal</tt> base, even though it is not an immediate base class:</p>
<pre>
    Panda::Panda(std::string name, bool onExhibit)
          : ZooAnimal(name, onExhibit, "Panda"),
            Bear(name, onExhibit),
            Raccoon(name, onExhibit),
            Endangered(Endangered::critical),
            sleeping_flag(false) { }
</pre><BR>
<p class="docText">When a <tt>Panda</tt> is created, it is this constructor that initializes the <tt>ZooAnimal</tt> part of the <tt>Panda</tt> object.</P>
<a name="ch17lev3sec64"></a>
<h5 class="docSection3Title">How a Virtually Inherited Object Is Constructed</h5>
<p class="docText">Let's look at how objects under virtual inheritance are constructed.</p>
<pre>
Bear winnie("pooh");    // <span class="docEmphasis">Bear</span> <span class="docEmphItalicAlt">constructor initializes</span> <span class="docEmphasis">ZooAnimal</span>
Raccoon meeko("meeko"); // <span class="docEmphasis">Raccoon</span> <span class="docEmphItalicAlt">constructor initializes</span> <span class="docEmphasis">ZooAnimal</span>
Panda yolo("yolo");     // <span class="docEmphasis">Panda</span> <span class="docEmphItalicAlt">constructor initializes</span> <span class="docEmphasis">ZooAnimal</span>
</pre><BR>
<p class="docText">When a <tt>Panda</tt> object is created,</P>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">The <tt>ZooAnimal</tt> part is constructed first, using the initializers specified in the <tt>Panda</tt> constructor initializer list.</p></div></li><li><div style="font-weight:normal"><p class="docList">Next, the <tt>Bear</tt> part is constructed. The initializers for <tt>ZooAnimal Bear</tt>'s constructor initializer list are ignored.</P></div></li><li><div style="font-weight:normal"><p class="docList">Then the <tt>Raccoon</tt> part is constructed, again ignoring the <tt>ZooAnimal</tt> initializers.</P></div></li><li><div style="font-weight:normal"><p class="docList">Finally, the <tt>Panda</tt> part is constructed.</P></div></li></ol></div>
<p class="docText">If the <tt>Panda</tt> constructor does not explicitly initialize the <tt>ZooAnimal</tt> base class, then the <tt>ZooAnimal</tt> default constructor is used. If <tt>ZooAnimal</tt> doesn't have a default constructor, then the code is in error. The compiler will issue an error message when the definition of <tt>Panda</tt>'s constructor is compiled.</P>

<a name="ch17lev3sec65"></a>
<h5 class="docSection3Title">Constructor and Destructor Order</h5>
<a name="ch17note37"></a><div class="docNote"><p>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" SRC="images/0201721481/graphics/note.jpg;400478"></td><td valign="top"><p class="docText"><a name="idd1e143547"></a><a name="idd1e143552"></a><a name="idd1e143559"></a><a name="idd1e143564"></a> Virtual base classes are always constructed prior to nonvirtual base classes regardless of where they appear in the inheritance hierarchy.</p></td></tr></table><br>
</p></div><br>
<p class="docText">For example, in the following whimsical <tt>TeddyBear</tt> derivation, there are two virtual base classes: the <tt>ToyAnimal</tt> base class and the indirect <tt>ZooAnimal</tt> base class from which <tt>Bear</tt> is derived:</P>
<pre>
   class Character { /* ... */ };
   class BookCharacter : public Character { /* ... */ };
   class ToyAnimal { /* ... */ };
   class TeddyBear : public BookCharacter,
                     public Bear, public virtual ToyAnimal
                     { /* ... */ };
</pre><BR>
<a name="ch17fig05"></a><p><center>
<H5 class="docFigureTitle">Figure 17.5. Virtual Inheritance <tt>TeddyBear</tt> Hierarchy</h5>

<p class="docText">
<img border="0" alt="" width="425" height="213" SRC="images/0201721481/graphics/17fig05.gif;400478"></p>

</center></P><BR>
<p class="docText">The immediate base classes are examined in declaration order to determine whether there are any virtual base classes. In our example, the inheritance subtree of <tt>BookCharacter</tt> is examined first, then that of <tt>Bear</tt>, and finally that of <tt>ToyAnimal</tt>. Each subtree is examined starting at the root class down to the most derived class.</p>
<p class="docText">The order in which the virtual base classes are constructed for <tt>TeddyBear</tt> is <tt>ZooAnimal</tt> followed by <tt>ToyAnimal</tt>. Once the virtual base classes are constructed, the nonvirtual base-class constructors are invoked in declaration order: <tt>BookCharacter</tt>, which causes the <tt>Character</tt> constructor to be invoked, and then <tt>Bear</tt>. Thus, to create a <tt>TeddyBear</tt>, the constructors are invoked in the following order:</p>
<pre>
    ZooAnimal();           // <span class="docEmphasis">Bear</span><span class="docEmphItalicAlt">'s virtual base class</span>
    ToyAnimal();           // <span class="docEmphItalicAlt">immediate virtual base class</span>
    Character();           // <span class="docEmphasis">BookCharacter</span><span class="docEmphItalicAlt">'s nonvirtual base class</span>
    BookCharacter();       // <span class="docEmphItalicAlt">immediate nonvirtual base class</span>
    Bear();                // <span class="docEmphItalicAlt">immediate nonvirtual base class</span>
    TeddyBear();           // <span class="docEmphItalicAlt">most derived class</span>
</pre><br>
<p class="docText"><a name="idd1e143677"></a><a name="idd1e143682"></a><a name="idd1e143689"></a><a name="idd1e143696"></a><a name="idd1e143701"></a>where the initializers used for <tt>ZooAnimal</tt> and <tt>ToyAnimal</tt> are specified by the most derived class <tt>TeddyBear</tt>.</p>
<p class="docText">The same construction order is used in the synthesized copy constructor; the base classes also are assigned in this order in the synthesized assignment operator. The order of base-class destructor calls is guaranteed to be the reverse order of constructor invocation.</p>
<a name="ch17sb21"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<H2 class="docSidebarTitle">Exercises Section 17.3.7</h2>
<blockquote>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch17qa18q1"></a><B>Exercise 17.34:</b></td><td><p class="docText">There is one case in which a derived class need not supply initializers for its virtual base class(es). What is this case?</p></td></TR><tr valign="top"><td align="right" class="docText" width="50"><a name="ch17qa18q2"></a><B>Exercise 17.35:</b></td><td><p class="docText">Given the following class hierarchy,</P>
<pre>
    class Class { ... };
    class Base : public Class { ... };
    class Derived1 : virtual public Base { ... };
    class Derived2 : virtual public Base { ... };
    class MI : public Derived1,
               public Derived2 { ... };
    class Final : public MI, public Class { ... };
</pre><br>
<div style="font-weight:bold"><ol class="docList" type="a"><LI><div style="font-weight:normal"><p class="docList">What is the order of constructor and destructor for the definition of a <tt>Final</tt> object?</p></div></li><li><div style="font-weight:normal"><p class="docList">How many <tt>Base</tt> subobjects are in a <tt>Final</tt> object? How many <tt>Class</tt> subobjects?</p></div></li><li><div style="font-weight:normal"><p class="docList">Which of the following assignments is a compile-time error?</p></div></li></ol></div>
<pre>
    Base     *pb;      Class     *pc;
    MI       *pmi;     Derived2  *pd2;

    (a) pb = new Class;           (c) pmi = pb;
    (b) pc = new Final;           (d) pd2 = pmi;
</pre><br>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch17qa18q3"></a><B>Exercise 17.36:</b></TD><td><p class="docText">Given the previous hierarchy, and assuming that <tt>Base</tt> defines the following three constructors, define the classes that inherit from <tt>Base</tt>, giving each class the same three constructors. Each constructor should use its argument to initialize its <tt>Base</tt> part.</P>
<pre>
    struct Base {
        Base();
        Base(std::string);
        Base(const Base&amp;);
    protected:
        std::string name;
    };
</pre><br>
</td></TR></table></P>
</blockquote>
</td></tr></table></p><br>



<ul></UL></td></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch17lev1sec2.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch17lev1sec4.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>