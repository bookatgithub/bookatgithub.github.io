<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Keyterm&nbsp;Defined Terms</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch18lev1sec8.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=app01.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch18lev1sec9"></a>
<h3 class="docSection1Title" id="432172-897">Defined Terms</h3>
<p class="docText"></P>

<a name="gloss18_01"></a><dl class="docList"><dt><B><a class="docLink" href="ch18lev1sec1.html#ch18term1">allocator class</a></b></dt><dd><p class="docText">Standard library class that supports type-specific allocation of raw, unconstructed memory. The <tt>allocator</tt> class is a class template that defines member functions to <tt>allocate, deallocate, construct</tt>, and <tt>destroy</tt> objects of the <tt>allocator</tt>'s template parameter type.</p></dd><BR><br></dl>
<a name="gloss18_02"></a><dl class="docList"><dt><b><a class="docLink" href="ch18lev1sec5.html#ch18term2">anonymous union</a></b></dt><dd><p class="docText">Unnamed union that is not used to define an object. Members of the anonymous union are referred to directly. These unions may not have member functions and may not have private or protected members.</P></dd><BR><br></dl>
<a name="gloss18_03"></a><dl class="docList"><dt><b><a class="docLink" href="ch18lev1sec7.html#ch18term3">bit-field</a></b></dt><dd><p class="docText">Class member with an signed or unsigned integral type that specifies the number of bits to allocate to the member. Bit-fields defined in consecutive order in the <a name="idd1e153977"></a><a name="idd1e153984"></a><a name="idd1e153991"></a><a name="idd1e153999"></a><a name="idd1e154003"></a><a name="idd1e154011"></a><a name="idd1e154014"></a><a name="idd1e154018"></a><a name="idd1e154021"></a><a name="idd1e154024"></a><a name="idd1e154027"></a><a name="idd1e154032"></a><a name="idd1e154037"></a><a name="idd1e154040"></a><a name="idd1e154044"></a><a name="idd1e154052"></a><a name="idd1e154057"></a>class are, if possible, compacted into a common integral value.</p></dd><br><br></dl>
<a name="gloss18_04"></a><dl class="docList"><dt><B>delete expression</b></dt><dd><p class="docText">A <tt>delete</tt> expression destroys a dynamically allocated object of a specified type and frees the memory used by that object. A <tt>delete[]</tt> expression destroys the elements of a dynamically allocated array of a specified type and frees the memory used by the array. These expressions use the corresponding version of the library or class-specific <tt>operator delete</tt> functions to free raw memory that held the object or array.</p></dd><BR><BR></dl>
<a name="gloss18_05"></a><dl class="docList"><dt><b><a class="docLink" href="ch18lev1sec5.html#ch18term5">discriminant</a></b></dt><dd><p class="docText">Programming technique that uses an object to determine which actual type is held in a union at any given time.</p></dd><br><BR></dl>
<a name="gloss18_06"></a><dl class="docList"><dt><B><a class="docLink" href="ch18lev1sec2.html#ch18term6">dynamic_cast</a></b></dt><dd><p class="docText">Operator that performs a checked cast from a base type to a derived type. The base type must define at least one <tt>virtual</tt> function. The operator checks the dynamic type of the object to which the reference or pointer is bound. If the object type is the same as the type of the cast (or a type derived from that type), then the cast is done. Otherwise, a zero pointer is returned for a pointer cast, or an exception is thrown for a cast of a reference.</p></dd><br><br></dl>
<a name="gloss18_07"></a><dl class="docList"><dt><b><a class="docLink" href="ch18lev1sec1.html#ch18term7">freelist</a></b></dt><dd><p class="docText">Memory management technique that involves preallocating unconstructed memory to hold objects that will be created as needed. When objects are freed, their memory is put back on the free list rather than being returned to the system.</P></dd><br><br></dl>
<a name="gloss18_08"></a><dl class="docList"><dt><B><a class="docLink" href="ch18lev1sec7.html#ch18term8">linkage directive</a></b></dt><dd><p class="docText">Mechanism used to allow functions written in a different language to be called from a C++ program. All compilers must support calling C and C++ functions. It is compiler-dependent whether any other languages are supported.</p></dd><br><BR></dl>
<a name="gloss18_09"></a><dl class="docList"><dt><b><a class="docLink" href="ch18lev1sec6.html#ch18term9">local class</a></b></dt><dd><p class="docText">Class defined inside a function. A local class is visible only inside the function in which it is defined. All members of the class must be defined inside the class body. There can be no static members of a local class. Local class members may not access the local variables defined in the enclosing function. They may use type names, static variables, or enumerators defined in the enclosing function.</P></dd><br><br></dl>
<a name="gloss18_10"></a><dl class="docList"><dt><b>member operators new and delete</b></dt><dd><p class="docText">Class member functions that override the default memory allocation performed by the global library <tt>operator new</tt> and <tt>operator delete</tt> functions. Both object (<tt>new</tt>) and array (<tt>new[]</tt>) forms of these functions may be defined. The member <tt>new</tt> and <tt>delete</tt> functions are implicitly declared as <tt>static</tt>. These operators allocate (deal-locate) memory. They are used automatically by <tt>new</tt> (<tt>delete</tt>) expressions, which handle object initialization and destruction.</p></dd><br><br></dl>
<a name="gloss18_11"></a><dl class="docList"><dt><b><a class="docLink" href="ch18lev1sec4.html#ch18term11">nested class</a></b></dt><dd><p class="docText">Class defined inside another class. A nested class is defined inside its enclosing scope: Nested-class names must be unique within the class scope in which they are defined but can be reused in scopes outside the enclosing class. Access to the nested class outside the enclosing class requires use of the scope operator to specify the scope(s) in which the class is nested.</p></dd><br><br></dl>
<a name="gloss18_12"></a><dl class="docList"><dt><b><a class="docLink" href="ch18lev1sec4.html#ch18term12">nested type</a></b></dt><dd><p class="docText">Synonym for nested class.</p></dd><br><BR></dl>
<a name="gloss18_13"></a><dl class="docList"><dt><B>new expression</b></dt><dd><p class="docText">A <tt>new</tt> expression allocates and constructs an object of a specified type. A <tt>new[]</tt> expression allocates and constructs an array of objects. These expressions use the corresponding version of the library <tt>operator new</tt> functions to allocate raw memory in which the expression constructs an object or array of the specified type.</p></dd><BR><br></dl>
<a name="gloss18_14"></a><dl class="docList"><dt><b><a class="docLink" href="ch18lev1sec1.html#ch18term14">operator delete</a></b></dt><dd><p class="docText">A library function that frees untyped, unconstructed memory allocated by <tt>operator new</tt>. The library <tt>operator delete[]</tt> frees memory used to hold an array that was allocated by <tt>operator new[]</tt>.</P></dd><BR><br></dl>
<a name="gloss18_15"></a><dl class="docList"><dt><b><a class="docLink" href="ch18lev1sec1.html#ch18term15">operator new</a></b></dt><dd><p class="docText">A library function that allocates untyped, unconstructed memory of a given size. The library function <tt>operator new[]</tt> allocates raw memory for arrays. These library functions provide a more <a name="idd1e154216"></a><a name="idd1e154219"></a><a name="idd1e154224"></a><a name="idd1e154230"></a><a name="idd1e154236"></a><a name="idd1e154241"></a><a name="idd1e154244"></a><a name="idd1e154247"></a><a name="idd1e154250"></a><a name="idd1e154254"></a><a name="idd1e154259"></a><a name="idd1e154262"></a>primitive allocation mechanism than the library <tt>allocator</tt> class. Modern C++ programs should use the <tt>allocator</tt> classes rather than these library functions.</p></dd><br><br></dl>
<a name="gloss18_16"></a><dl class="docList"><dt><B><a class="docLink" href="ch18lev1sec1.html#ch18term16">placement new expression</a></b></dt><dd><p class="docText">The form of <tt>new</tt> that constructs its object in specified memory. It does no allocation; instead, it takes an argument that specifies where the object should be constructed. It is a lower-level analog of the behavior provided by the <tt>construct</tt> member of the <tt>allocator</tt> class.</p></dd><BR><BR></dl>
<a name="gloss18_17"></a><dl class="docList"><dt><b><a class="docLink" href="ch18lev1sec3.html#ch18term17">pointer to member</a></b></dt><dd><p class="docText">Pointer that encapsulates the class type as well as the member type to which the pointer points. The definition of a pointer to member must specify the class name as well as the type of the member(s) to which the pointer may point:</p>
<pre>
     TC::*pmem = &amp;C::member;
</pre><br>
<p class="docText">This statement defines <tt>pmem</tt> as a pointer that can point to members of the class named <span class="docEmphasis">C</span> that have type <span class="docEmphasis">T</span> and initializes it to point to the member in <span class="docEmphasis">C</span> named <span class="docEmphasis">member</span>. When the pointer is dereferenced, it must be bound to an object of or pointer to type <span class="docEmphasis">C</span>:</P>
<pre>
     <span class="docEmphasis">classobj</span>.*pmem;
     <span class="docEmphasis">classptr</span>-&gt;*pmem;
</pre><BR>
<p class="docText">fetches <span class="docEmphasis">member</span> from the object <span class="docEmphasis">classobj</span> of the object pointed to by <span class="docEmphasis">classptr</span>.</p></dd><br><br></dl>
<a name="gloss18_18"></a><dl class="docList"><dt><b><a class="docLink" href="ch18lev1sec7.html#ch18term18">portable</a></b></dt><dd><p class="docText">Term used to describe a program that can be moved to a new machine with relatively little effort.</P></dd><br><br></dl>
<a name="gloss18_19"></a><dl class="docList"><dt><B>run-time type identification</b></dt><dd><p class="docText">Term used to describe the language and library facilities that allow the dynamic type of a reference or pointer to be obtained at run time. The RTTI operators, <tt>typeid</tt> and <tt>dynamic_cast</tt>, provide the dynamic type only for references or pointers to class types with virtual functions. When applied to other types, the type returned is the static type of the reference or pointer.</p></dd><br><BR></dl>
<a name="gloss18_20"></a><dl class="docList"><dt><b><a class="docLink" href="ch18lev1sec2.html#ch18term20">typeid</a></b></dt><dd><p class="docText">Unary operator that takes an expression and returns a reference to an object of the library type named <tt>type_info</tt> that describes the type of the expression. When the expression is an object of a type that has virtual functions, then the dynamic type of the expression is returned. If the type is a reference, pointer, or other type that does not define virtual functions, then the type returned is the static type of the reference, pointer, or object.</P></dd><br><br></dl>
<a name="gloss18_21"></a><dl class="docList"><dt><b>type_info</b></dt><dd><p class="docText">Library type that describes a type. The <tt>type_info</tt> class is inherently machine-dependent, but any library must define <tt>type_info</tt> with members listed in <a class="docLink" href="ch18lev1sec2.html#ch18table02">Table 18.2</a> (p. <a class="docLink" href="ch18lev1sec2.html#ch18table02">779</a>). <tt>type_info</tt> objects may not be copied.</p></dd><br><br></dl>
<a name="gloss18_22"></a><dl class="docList"><dt><b><a class="docLink" href="ch18lev1sec5.html#ch18term22">union</a></b></dt><dd><p class="docText">Classlike aggregate type that may define multiple data members, only one of which can have a value at any one point. Members of a union must be simple types: They can be a built-in or compound type or a class type that does not define a constructor, destructor, or the assignment operator. Unions may have member functions, including constructors and destructors. A union may not serve as a base class.</p></dd><br><br></dl>
<a name="gloss18_23"></a><dl class="docList"><dt><b><a class="docLink" href="ch18lev1sec7.html#ch18term23">volatile</a></b></dt><dd><p class="docText">Type qualifier that signifies to the compiler that a variable might be changed outside the direct control of the program. It is a signal to the compiler that it may not perform certain optimizations.</p></dd><br><BR></dl>


<UL></ul></TD></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch18lev1sec8.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=app01.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>