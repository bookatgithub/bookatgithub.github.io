<html>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<head>
<title>app03.html</title>
<link rel="STYLESHEET" type="text/css" href="images/css1.css">
<link rel="STYLESHEET" type="text/css" href="images/css2.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app02lev1sec2.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=app03lev1sec1.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<div style=""><div><a name="app03"></a><h2 id="title-ID0EVRPM" class="docAppendixTitle">C. Introduction to Qt Jambi</h2>




<ul><li><p class="docList"><a name="iddle1264"></a><a name="iddle3386"></a><a name="iddle3388"></a><a name="iddle3396"></a><a name="iddle6140"></a><a name="iddle7895"></a><a name="iddle7898"></a><span class="docEmphasis"><a class="docLink" href="app03lev1sec1.html#app03lev1sec1">Getting Started with Qt Jambi</a></span></p></li><li><p class="docList"><span class="docEmphasis"><a class="docLink" href="app03lev1sec2.html#app03lev1sec2">Using Qt Jambi in the Eclipse IDE</a></span></p></li><li><p class="docList"><span class="docEmphasis"><a class="docLink" href="app03lev1sec3.html#app03lev1sec3">Integrating C++ Components with Qt Jambi</a></span></p></li></ul>
<p class="docText"><a name="Qt Jambi"></a>&#81;t J&#97;mbi is the &#74;ava ed&#105;tion of &#116;he Qt application de&#118;elopment framework. At th&#101; heart of Qt Jambi are the C++ libraries that fo&#114;m Qt, ma&#100;e &#97;vailable to Java pr&#111;grammers thr&#111;ugh the Java Native Interface (J&#78;I). Although considerable effort has gon&#101; into making Qt Jambi integrate smoot&#104;ly with Java and to make its API natural to use for J&#97;va progra&#109;mers, C++/Qt pro&#103;ramm&#101;rs &#119;ill still find &#116;he API familiar and predi&#99;table. All the classes are documented using &#74;avado&#99; at <tt>http://doc.t&#114;olltech.com/qtjamb&#105;/</tt>.</p>
<p class="docText"><a name="GUI programmers"></a>Until now, J&#97;va GUI programmers have ha&#100; to make do with AWT, Swing, SWT, and si&#109;ilar GUI class libraries, none of which ar&#101; as convenient to use or as powerful as Qt. For example, in th&#101; tr&#97;ditional &#74;ava GU&#73; libr&#97;ries, connect&#105;ng a user action, s&#117;ch as clicking a button, to a corr&#101;sp&#111;nd&#105;ng method i&#110;volv&#101;s writing an event listener c&#108;ass; in Qt Jambi, only one line of code is requi&#114;ed to achieve the same thing. And Qt's layout managers are much easier t&#111; use than Swing's <tt>BoxLayout</tt> and <tt>GridBagLayout</tt><a name="they produce"></a>, an&#100; t&#104;ey pro&#100;u&#99;e better-loo&#107;ing results.</p>
<p class="docText"><a name="dock windows"></a>Qt Jamb&#105; applications can have ma&#105;n windows with menu bars, toolbars, dock windows, and a &#115;tatus b&#97;r, just lik&#101; Qt applicati&#111;ns written in C++. T&#104;ey also have the native lo&#111;k and feel of the plat&#102;orm they are running on, and they respect &#116;he user's preferences regarding t&#104;emes, c&#111;lo&#114;s, font&#115;, and so o&#110;. With the f&#117;ll power of Qt und&#101;r the hood, Qt Jambi applications can t&#97;ke advant&#97;ge of Qt's p&#111;werful 2D g&#114;aphics archit&#101;cture (notably the gr&#97;phics view framework) and of ext&#101;nsions such as OpenGL.</p>
<p class="docText"><a name="are not"></a>The benefits &#111;f Qt Jambi are not limited to Java programmers. In p&#97;rticular, &#67;++ programm&#101;rs &#99;an make thei&#114; custom Qt componen&#116;s available to Java program&#109;ers using the same generator tool that Trollt&#101;ch &#117;ses to mak&#101; the Qt &#65;PI available in Qt J&#97;mbi.</p>
<p class="docText"><a name="start using"></a>In this appendix, we will show how Ja&#118;a programmers can start using Qt J&#97;mbi to create GUI applications. Then we will show how to m&#97;ke use of Qt Jambi in Eclipse, which integrates <span class="docEmphasis">Qt Designer</span><a name="make custom"></a>, and fi&#110;a&#108;ly we will s&#104;ow how &#116;o make cu&#115;tom C++ components ava&#105;lable to Qt Jambi p&#114;ogrammers. This appendix <a name="iddle1983"></a><a name="iddle2143"></a><a name="iddle2601"></a><a name="iddle2753"></a><a name="iddle2765"></a><a name="iddle3189"></a><a name="iddle3280"></a><a name="iddle3376"></a><a name="iddle3809"></a><a name="iddle3862"></a><a name="iddle4096"></a><a name="iddle4117"></a><a name="iddle4929"></a><a name="iddle7445"></a><a name="iddle7466"></a><a name="iddle7468"></a><a name="iddle7836"></a><a name="Jambi requires"></a>assumes t&#104;at you &#97;re famili&#97;r with C++/Qt prog&#114;amming and w&#105;th Java. Qt Jambi requires Jav&#97; 1.5 or later.</p>




<a name="app03lev1sec1"></a>
<h3 class="docSection1Title" id="-100000">Getting Started with Qt Jambi</h3>
<p class="docText"><a name="will develop"></a>In this section, we will develop a &#115;mall Java application that presents the win&#100;ow shown in <a class="docLink" href="#app03fig01">Figure C.1</a><a name="its window"></a>. Apart from its window title, the Jambi F&#105;nd dial&#111;g h&#97;s the same &#97;ppearanc&#101; and b&#101;havior as the Find dial&#111;g we created back in <a class="docLink" href="ch02.html#ch02">Chapter 2</a><a name="By reusing"></a>. By re&#117;sing the s&#97;me exampl&#101;, we can more easi&#108;y see the differ&#101;nces and similar&#105;ties between C++/Qt and Qt Jambi programming. While r&#101;viewing the code, we will discuss t&#104;e conceptual differences between &#67;++ and Java a&#115; they ar&#105;se.</p>
<a name="app03fig01"></a><p><center>

<h5 class="docFigureTitle"><a name="Jambi Find"></a>Figu&#114;e C.1. The &#74;ambi Find dial&#111;g</h5>

<p class="docText">
<img border="0" id="" width="329" height="126" src="images/NzlkOW1jM2FhMDc4L2lwdHJnZTFnMTRzOXIvMy83cG5haGdtZGouL3NqaWNiaXBmaQ--.jpg" alt="" /></p>



</center></p><br />
<p class="docText"><a name="implementation of"></a>The impleme&#110;tation of the Jambi Find application &#105;s done i&#110; a &#115;ingle file call&#101;d <tt>FindDial&#111;g.java</tt><a name="by piece"></a>. We will review the conte&#110;ts of this file piece by &#112;iece, starting with the <tt>import</tt> de&#99;larations.</p>
<div class="docText"><pre>import com.trolltech.qt.core.*;
import com.trolltech.qt.gui.*;</pre></div><br />
<p class="docText">Between them, these two <tt>import</tt><a name="and GUI"></a> &#100;e&#99;larations m&#97;ke all of Q&#116;'s core an&#100; GUI class&#101;s available to Java. Ad&#100;itional sets of classes can be ma&#100;e &#97;vailable &#119;ith similar <tt>import</tt> d&#101;clarations (e.&#103;., <tt>import com.trolltech.qt.opengl.*</tt>).</p>
<div class="docText"><pre>public class FindDialog extends QDialog {</pre></div><br />
<p class="docText">T&#104;e <tt>FindDialog</tt> class is a subclass of <tt>QDialog</tt><a name="signals in"></a>, like in t&#104;e C++ version of the example. In C++, we declare si&#103;nals in the header file, relying on the <tt>moc</tt><a name="introspection facilities"></a> tool to gene&#114;ate th&#101; su&#112;por&#116;ing code. &#73;n Qt Jambi, Java's &#105;ntrospection faci&#108;ities are used to implement the signa&#108;s and slots &#109;echanism. Bu&#116; we still ne&#101;d some &#109;eans of declaring signals, and this is done &#117;sing the <tt>Signal</tt><span class="docEmphasis"><tt>N</tt></span> classes:</p>
<div class="docText"><pre>    public Signal2&lt;String, Qt.CaseSensitivity&gt; findNext =
            new Signal2&lt;String, Qt.CaseSensitivity&gt;();

    public Signal2&lt;String, Qt.CaseSensitivity&gt; findPrevious =
            new Signal2&lt;String, Qt.CaseSensitivity&gt;();</pre></div><br />
<p class="docText">There are te&#110; <tt>Signal</tt><span class="docEmphasis"><tt>N</tt></span> classesâ€”<tt>Signal0</tt>, <tt>Signal1&lt;T1&gt;</tt>, ..., <tt>Signal9&lt;T1,</tt> ...,<tt>T9&gt;</tt><a name="and the"></a>. The numb&#101;rs in their names indicate how many argumen&#116;s they ta&#107;e, and the t&#121;pe&#115; <tt>T1</tt>, ..., <tt>T9</tt><a name="of the"></a> spec&#105;fy the type&#115; of the arguments. Here, we &#104;ave declared two signals, <a name="iddle1744"></a><a name="iddle2757"></a><a name="iddle5755"></a><a name="iddle5903"></a><a name="iddle7455"></a><a name="iddle7469"></a><a name="iddle7528"></a><a name="iddle7538"></a><a name="iddle7540"></a><a name="iddle7789"></a><a name="two arguments"></a>each takin&#103; two a&#114;gumen&#116;s. In both cases, the fir&#115;t argument &#105;s a Java <tt>String</tt><a name="and the"></a>, and the seco&#110;d argument is of type <tt>Qt.CaseSensit&#105;vity</tt><a name="enum type"></a>, a Java enum type. Wherever a <tt>QString</tt><a name="needed in"></a> is ne&#101;ded in the Qt API, in Qt Jambi we us&#101; a <tt>S&#116;ring</tt> ins&#116;ead.</p>
<p class="docText">Unli&#107;e the othe&#114; <tt>Signal</tt><span class="docEmphasis"><tt>N</tt></span> classes, <tt>S&#105;gnal0</tt><a name="no arguments"></a> is not a generi&#99; class. To create a signal with no arguments, we use <tt>Signa&#108;0</tt> like this:</p>
<div class="docText"><pre>    public Signal0 somethingHappened = new Signal0();</pre></div><br />
<p class="docText"><a name="we are"></a>H&#97;ving crea&#116;ed the signals &#119;e need, we are no&#119; ready to see the implementation of the const&#114;uctor. The method is quite long, so we &#119;ill look at it in three parts.</p>
<div class="docText"><pre>    public FindDialog(QWidget parent) {
        super(parent);

        label = new QLabel(tr("Find &amp;what:"));
        lineEdit = new QLineEdit();
        label.setBuddy(lineEdit);

        caseCheckBox = new QCheckBox(tr("Match &amp;case"));
        backwardCheckBox = new QCheckBox(tr("Search &amp;backward"));

        findButton = new QPushButton(tr("&amp;Find"));
        findButton.setDefault(true);
        findButton.setEnabled(false);

        closeButton = new QPushButton(tr("Close"));</pre></div><br />
<p class="docText"><a name="compared to"></a>The only differ&#101;nces between creating the widgets in Java compared &#116;o C++ are th&#101; sm&#97;ll detail&#115; of synt&#97;x. Note that <tt>tr()</tt> retur&#110;s a <tt>String</tt>, not a <tt>QStrin&#103;</tt>.</p>
<div class="docText"><pre>        lineEdit.textChanged.connect(this, "enableFindButton(String)");
        findButton.clicked.connect(this, "findClicked()");
        closeButton.clicked.connect(this, "reject()");</pre></div><br />
<p class="docText"><a name="is somewhat"></a>The syntax for signalâ€“slot conne&#99;tions in Qt J&#97;mbi is som&#101;what differe&#110;t than in C++/Q&#116;, but it is still short and simple. &#73;n general, the syntax is</p>
<div class="docText"><pre><span class="docEmphasis">sender</span>.<span class="docEmphasis">signalName</span>.connect(<span class="docEmphasis">receiver</span>, "<span class="docEmphasis">slotName</span>(<span class="docEmphasis">T1</span>, ..., <span class="docEmphasis">TN</span>)");</pre></div><br />
<p class="docText"><a name="If a"></a>Unlike in &#67;++/Qt, we don't need to specify a s&#105;gnature for the signal. If a signal has more par&#97;meters th&#97;n the slot&#115; it conn&#101;ct&#115; to, the add&#105;tional parameters are ig&#110;ored. Furthermore, in Qt Jambi, the signa&#108;â€“slot mecha&#110;i&#115;m is not limited to <tt>Q&#79;bject</tt><a name="inherits"></a> subclasses: Any c&#108;ass that inherits <tt>QSignalE&#109;itter</tt><a name="and any"></a> can emit signals, and any method of any cl&#97;ss can be a slot.</p>
<div class="docText"><pre>        QHBoxLayout topLeftLayout = new QHBoxLayout();
        topLeftLayout.addWidget(label);
        topLeftLayout.addWidget(lineEdit);

        QVBoxLayout leftLayout = new QVBoxLayout();
        leftLayout.addLayout(topLeftLayout);
        leftLayout.addWidget(caseCheckBox);
        leftLayout.addWidget(backwardCheckBox);
        QVBoxLayout rightLayout = new QVBoxLayout();
        rightLayout.addWidget(findButton);
        rightLayout.addWidget(closeButton);
        rightLayout.addStretch();

        QHBoxLayout mainLayout = new QHBoxLayout();
        mainLayout.addLayout(leftLayout);
        mainLayout.addLayout(rightLayout);
        setLayout(mainLayout);

        setWindowTitle(tr("Jambi Find"));
        setFixedHeight(sizeHint().height());
    }</pre></div><br />
<p class="docText"><a name="iddle2371"></a><a name="iddle2751"></a><a name="iddle2760"></a><a name="iddle2879"></a><a name="iddle3393"></a><a name="iddle3405"></a><a name="iddle3500"></a><a name="The layout"></a>The layout code is practically ide&#110;tical to the C++ original, with the same layout classes work&#105;ng in ex&#97;ctly the s&#97;me way. Qt J&#97;mbi can al&#115;o use forms cre&#97;ted with <span class="docEmphasis">Qt Designer</span>, using <tt>&#106;uic</tt><a name="interface compiler"></a> (the Java user interface compiler), as w&#101; wi&#108;l see in the &#110;ext &#115;ection.</p>
<div class="docText"><pre>    private void findClicked() {
        String text = lineEdit.text();
        Qt.CaseSensitivity cs = caseCheckBox.isChecked()
                ? Qt.CaseSensitivity.CaseSensitive
                : Qt.CaseSensitivity.CaseInsensitive;
        if (backwardCheckBox.isChecked()) {
            findPrevious.emit(text, cs);
        } else {
            findNext.emit(text, cs);
        }
    }</pre></div><br />
<p class="docText"><a name="Java syntax"></a>The Jav&#97; syntax for referring to enu&#109; values is a bit more verbose than in C++, b&#117;t it is easy to understand. To emit a sign&#97;l, we call the <tt>emit()</tt> method on a <tt>Signal</tt><span class="docEmphasis"><tt>N</tt></span><a name="the program"></a> object, pass&#105;ng argu&#109;ents of the c&#111;rr&#101;ct &#116;ypes. The type-chec&#107;ing is done when t&#104;e program is compiled.</p>
<div class="docText"><pre>    private void enableFindButton(String text) {
        findButton.setEnabled(text.length() == 0);
    }</pre></div><br />
<p class="docText">The <tt>ena&#98;leFindBut&#116;on()</tt><a name="as the"></a> metho&#100; is essent&#105;ally the sa&#109;e as the C++ original.</p>
<div class="docText"><pre>    private QLabel label;
    private QLineEdit lineEdit;
    private QCheckBox caseCheckBox;
    private QCheckBox backwardCheckBox;
    private QPushButton findButton;
    private QPushButton closeButton;</pre></div><br />
<p class="docText"><a name="the book"></a>In keeping &#119;ith the code in the rest of the book, we have de&#99;lared all the widgets as private fiel&#100;s of the class. This is purely a matter of sty&#108;e; nothing i&#115; stoppi&#110;g &#117;s from dec&#108;aring in the co&#110;structor itself tho&#115;e widgets that are referred t&#111; on&#108;y in the con&#115;tructor. For ex&#97;mple, we could have de&#99;lared <tt>label</tt> and <tt>closeButton</tt><a name="referred to"></a> in the co&#110;structor since they are no&#116; referred to anywhere els&#101;, and they would <a name="iddle1265"></a><a name="iddle1554"></a><a name="iddle1595"></a><a name="iddle2426"></a><a name="iddle2453"></a><a name="iddle3190"></a><a name="iddle3329"></a><a name="iddle3330"></a><a name="iddle3382"></a><a name="iddle3785"></a><a name="iddle4102"></a><a name="iddle4263"></a><a name="iddle5010"></a><a name="iddle5184"></a><a name="iddle5197"></a><a name="iddle5588"></a><a name="iddle6086"></a><a name="iddle6905"></a><a name="iddle7058"></a><a name="iddle7479"></a><a name="iddle7896"></a><a name="iddle7899"></a><a name="iddle8500"></a><a name="iddle8575"></a><a name="uses the"></a>not be garbage-collected when the cons&#116;ructor f&#105;nishes. &#84;his wo&#114;ks bec&#97;use Qt Jambi uses the s&#97;me parentâ€“child ownership mec&#104;anism as C++/Qt, so once the <tt>label</tt> and <tt>closeButton</tt> &#97;re laid ou&#116;, the <tt>Find&#68;ialog</tt><a name="of them"></a> form takes own&#101;rship of t&#104;em, and behind the scenes it keeps a refer&#101;nce to them to keep them ali&#118;e. Qt Jambi deletes child widgets recursively, so &#105;f a top-level window is deleted, the window i&#110; t&#117;rn delete&#115; all its &#99;hild widget&#115; and layout&#115;, which delete theirs, &#97;nd so on, until cleanup is complete.</p>
<a name="app03sb01"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>

<h2 class="docSidebarTitle">Using Ja&#118;a's Resourc&#101; Sy&#115;tem</h2>
<p class="docText"><a name="is fully"></a>Qt Jambi is ful&#108;y aware of Java's resou&#114;ce system, unlike many &#111;f Java's standard classes. Java resources &#97;re identified by a <tt>classpath:</tt><a name="Anywhere a"></a> prefix. Anywhere a f&#105;le name could be used in the Qt Jambi API, a Java resource can be &#115;pecifi&#101;d i&#110;s&#116;ead. For e&#120;ample:</p>
<div class="docText"><pre>QIcon icon = new QIcon("classpath:/images/icon.png");
if (!icon.isNull()) {
    ...
}</pre></div><br />
<p class="docText"><a name="the icon"></a>To find t&#104;e icon, Qt Jambi will l&#111;ok in every <tt>images</tt><a name="of every"></a> directory of &#101;ve&#114;y dire&#99;tory or <tt>.jar</tt> file spec&#105;fied in the <tt>CLASS&#80;ATH</tt> environment variabl&#101;. As soon as an image file called <tt>icon.png</tt> &#105;s found, the search stops and the file is used.</p>
<p class="docText"><a name="above example"></a>No exc&#101;ption is raised if the file isn't found. In the &#97;bove exam&#112;le, i&#102; <tt>ico&#110;.p&#110;g</tt> is not fo&#117;nd, <tt>icon.isNull()</tt> will return <tt>true</tt>. &#67;lasses like <tt>QImage</tt> and <tt>QPixm&#97;p</tt><a name="a file"></a>, which ha&#118;e construc&#116;ors that take a fil&#101; name argument, h&#97;ve an <tt>isNull()</tt><a name="file was"></a> method that can be tested to s&#101;e if the file was read success&#102;ully. In the case of <tt>QFile</tt>, we can check <tt>QFile.erro&#114;()</tt> to see if the file was read.</p>
</td></tr></table></p><br />
<p class="docText"><a name="unlike AWT"></a>Qt Jambi makes full use of Java's g&#97;rbage-col&#108;ection fun&#99;tionality, s&#111; un&#108;ike AWT, Swing, &#97;nd SWT, if the last refere&#110;ce to a top-level window is delete&#100;, t&#104;e wind&#111;w will be sc&#104;eduled f&#111;r garbage collection, and no &#101;xplicit call to <tt>dispose()</tt><a name="as in"></a> is ne&#99;essary. This approach is very convenient &#97;nd works the same as in C++/Qt. The main caveat is that for S&#68;I (single do&#99;ument inter&#102;ace) &#97;pplicati&#111;ns, we must keep a &#114;eference to &#101;ach top-level window that is created, &#116;o preven&#116; them fro&#109; being garbage-col&#108;ected. (In C++/Qt, SDI appl&#105;cations normally use the <tt>Qt::WA_DeleteO&#110;Close</tt><a name="memory leaks"></a> attribute to prevent memory leaks.)</p>
<div class="docText"><pre>    public static void main(String[] args) {
        QApplication.initialize(args);
        FindDialog dialog = new FindDialog(null);
        dialog.show();
        QApplication.exec();
    }
}</pre></div><br />
<p class="docText"><a name="have provided"></a>&#70;or convenience, we have pr&#111;vided the <tt>FindDialog</tt><a name="with a"></a> with a <tt>main()</tt><a name="instantiates a"></a> method t&#104;at ins&#116;antiate&#115; a dialo&#103; and p&#111;ps it up. The <tt>&#105;mport com.trollte&#99;h.qt.gui.*</tt> declaration <a name="iddle1406"></a><a name="iddle1700"></a><a name="iddle1723"></a><a name="iddle1810"></a><a name="iddle2654"></a><a name="iddle2992"></a><a name="iddle3216"></a><a name="iddle3575"></a><a name="iddle3669"></a><a name="iddle4081"></a><a name="iddle4723"></a><a name="iddle4804"></a><a name="iddle4862"></a><a name="iddle5156"></a><a name="iddle5279"></a><a name="iddle5342"></a><a name="iddle6332"></a><a name="iddle6457"></a><a name="iddle6471"></a><a name="iddle6997"></a><a name="iddle7572"></a><a name="iddle7790"></a><a name="iddle8042"></a><a name="iddle8415"></a><a name="that a"></a>ensures that a static <tt>QAp&#112;lic&#97;tion</tt><a name="call"></a> obje&#99;t is available. When a Qt J&#97;mbi application start&#115;, we must call <tt>QApplication.initialize()</tt><a name="allows the"></a> a&#110;d pass it the command-line argumen&#116;s. This allows the <tt>QApplication</tt> object to handle the argu&#109;ents it recognizes, such as <tt>-font</tt> and <tt>-style</tt>.</p>
<p class="docText">When we create t&#104;e <tt>Find&#68;ialog</tt>, we pa&#115;s <tt>null</tt><a name="Once the"></a> a&#115; parent &#116;o signify th&#97;t the dialog is a top-le&#118;el window. Once the <tt>main()</tt><a name="of scope"></a> metho&#100; i&#115; finish&#101;d, the dial&#111;g will go ou&#116; of scope and be garbage-collected. The ca&#108;l to <tt>QApplication.exec()</tt> starts off the event loop, and ret&#117;rns control to the <tt>main()</tt> method o&#110;ly when the user closes the dialog.</p>
<p class="docText"><a name="there are"></a>The Qt Jambi A&#80;I &#105;s very s&#105;milar t&#111; th&#101; C++/Qt API, but t&#104;ere are some differenc&#101;s. For example, in C++, the <tt>QWidget::map&#84;o()</tt><a name="the following"></a> memb&#101;r f&#117;nction has the fol&#108;owing signature:</p>
<div class="docText"><pre>QPoint mapTo(QWidget *widget, const QPoint &amp;point) const;</pre></div><br />
<p class="docText">The <tt>Q&#87;idget</tt><a name="as a"></a> is passed as a non-cons&#116; pointer, whereas the <tt>QPoint</tt><a name="is passed"></a> is passed as a &#99;onst reference. In Qt Jambi, the equivalent m&#101;thod has the signature</p>
<div class="docText"><pre>public final QPoint mapTo(QWidget widget, QPoint point) { ... }</pre></div><br />
<p class="docText"><a name="does not"></a>Because Java does not h&#97;ve pointe&#114;s, ther&#101; is &#110;o &#118;isual distinction &#105;n method signatur&#101;s to indicate whether an object p&#97;ssed to a m&#101;th&#111;d can be modif&#105;ed by the me&#116;hod. In theory, the <tt>ma&#112;To()</tt><a name="could alter"></a> method could a&#108;ter either parameter since they are both referenc&#101;s, but Qt Jambi promises not to alter the <tt>QPoint</tt><a name="the context"></a> &#97;rgument, s&#105;nce in C++ &#105;t is pas&#115;ed as a c&#111;nstant refe&#114;ence. From the context, it is &#117;sually clear which parameters are alterable an&#100; w&#104;ich ar&#101; not. In case o&#102; doubt, we can ref&#101;r to the documentation &#116;o clarify the situation.</p>
<p class="docText"><a name="arguments that"></a>In a&#100;dition to not altering arguments that ar&#101; passed by value or as constant references in C++, Qt Ja&#109;bi also prom&#105;ses tha&#116; the retu&#114;n valu&#101; of any non-<tt>voi&#100;</tt><a name="as a"></a> method, w&#104;ich in C++ would be returned as a value or a&#115; a const&#97;nt refere&#110;ce, is &#97;n independe&#110;t copy, so altering it will not lead t&#111; any side effect&#115;.</p>
<p class="docText"><a name="a"></a>We mentioned earlier that in Qt Jambi, where&#118;er a <tt>QString</tt> would be used in C++/Qt, a &#74;ava <tt>St&#114;ing</tt> is &#117;sed inste&#97;d. This kin&#100; of cor&#114;espondenc&#101; also applies to the <tt>QC&#104;ar</tt> cla&#115;s, which &#104;as two Java eq&#117;ivalents: <tt>char</tt> and <tt>java.&#108;ang.Character</tt>. There are similar corre&#115;pondences regarding some of Qt's contai&#110;er classes: <tt>QHash</tt> is replaced by <tt>java.ut&#105;l.HashMap</tt>, <tt>QList</tt> and <tt>QVector</tt> by <tt>java.util.List</tt>, and <tt>QMap</tt> by <tt>java.&#117;til.Sorte&#100;M&#97;p</tt>. In addit&#105;on, <tt>QThr&#101;ad</tt> is repla&#99;ed by <tt>java.lang.Thread</tt>.</p>
<p class="docText"><a name="of"></a>&#84;he Qt model/view architecture and &#116;he datab&#97;se API mak&#101; extensive u&#115;e of <tt>QVariant</tt><a name="needed in"></a>. S&#117;ch a type isn't needed in J&#97;va because all Java objects have <tt>java.lang.Obje&#99;t</tt><a name="so throughout"></a> as an ancestor, so throughout Qt Jambi's API, <tt>QVar&#105;ant</tt><a name="is replaced"></a> is replaced by <tt>java.lang.Object</tt><a name="methods that"></a>. The extra methods &#116;hat <tt>QVar&#105;ant</tt><a name="are available"></a> pro&#118;ides are av&#97;ilable as &#115;tatic meth&#111;ds in <tt>com.troll&#116;ech.qt.QVariant</tt>.</p>
<p class="docText"><a name="and we"></a>We have now finished reviewing a sm&#97;ll Qt Jamb&#105; applic&#97;tion, and we di&#115;cussed many of the co&#110;ceptual differenc&#101;s between Qt Jambi and C++/Q&#116; programming. Building and running a Qt Jambi appli&#99;ation is no different from any other <a name="iddle1596"></a><a name="iddle2332"></a><a name="iddle2427"></a><a name="iddle2939"></a><a name="iddle3137"></a><a name="iddle3251"></a><a name="iddle3277"></a><a name="iddle4360"></a><a name="iddle6109"></a>Java application, exce&#112;t th&#97;t the <tt>CLAS&#83;PATH</tt><a name="directory where"></a> &#101;nv&#105;ronment variabl&#101; must specify th&#101; directory where Qt J&#97;mbi is ins&#116;alled. We &#109;ust compile the class &#117;sing a Java compiler &#97;nd then we can execute the class using a &#74;ava interpreter. For example:</p>
<div class="docText"><pre>export CLASSPATH=$CLASSPATH:$HOME/qtjambi/qtjambi.jar:$PWD
javac FindDialog.java
java FindDialog</pre></div><br />
<p class="docText"><a name="the"></a>Here we have used t&#104;e Bash shell to set the <tt>CLASSPATH</tt><a name="We include"></a> environmen&#116; variable; other command-line interpreters may require a &#100;i&#102;fer&#101;nt &#115;yntax. W&#101; include the cur&#114;ent directory in &#116;he <tt>CLASSPATH</tt> so that the <tt>FindDialog</tt> clas&#115; itself &#99;an be found. O&#110; Mac OS X, the c&#111;mmand-line op&#116;ion <tt>-XstartOnFirstThread</tt> &#109;ust be supplied to <tt>java</tt><a name="execute the"></a> to address a threadi&#110;g issue with Apple's Java virtual machine. On W&#105;ndows, we execute the application like this:</p>
<div class="docText"><pre>set CLASSPATH=%CLASSPATH%;%JAMBIPATH%\qtjambi.jar;%CD%
javac FindDialog.java
java FindDialog</pre></div><br />
<p class="docText"><a name="also be"></a>Qt Jambi can al&#115;o be use&#100; w&#105;thin an &#73;DE. In &#116;he next sect&#105;on, we will look at how to edit, buil&#100;, and test a Qt Jambi application using &#116;he popul&#97;r Eclipse &#73;DE.</p>

</div></div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app02lev1sec2.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=app03lev1sec1.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>