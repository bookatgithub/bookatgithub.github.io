<html>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<head>
<title>app04lev1sec1.html</title>
<link rel="STYLESHEET" type="text/css" href="images/css1.css">
<link rel="STYLESHEET" type="text/css" href="images/css2.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app04.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=app04lev1sec2.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<div style=""><div><a name="app04"></a><h2 id="title-ID0E2TPM" class="docAppendixTitle">D. Introduction to C++ for Java and C# Programmers</h2>




<ul><li><p class="docList"><a name="iddle1454"></a><a name="iddle1461"></a><a name="iddle3387"></a><a name="iddle7797"></a><span class="docEmphasis"><a class="docLink" href="app04lev1sec1.html#app04lev1sec1">Getting Started with C++</a></span></p></li><li><p class="docList"><span class="docEmphasis"><a class="docLink" href="app04lev1sec2.html#app04lev1sec2">Main Language Differences</a></span></p></li><li><p class="docList"><span class="docEmphasis"><a class="docLink" href="app04lev1sec3.html#app04lev1sec3">The Standard C++ Library</a></span></p></li></ul>
<p class="docText"><a name="This appendix"></a>&#84;his ap&#112;end&#105;x provi&#100;e&#115; a short introdu&#99;tion to C++ for developers wh&#111; already know Java or C#. It assumes t&#104;at you &#97;re famili&#97;r with object-&#111;rient&#101;d concepts such as &#105;nheritance and polymorphism and that you want to le&#97;rn C++. To avoid making this book an unwieldy 1500 pa&#103;e doorstop by including a complete C++ primer, t&#104;is app&#101;nd&#105;x confi&#110;e&#115; itself to essent&#105;als. It presents the bas&#105;c knowledge and tech&#110;i&#113;ues n&#101;cessary to &#117;nderstand t&#104;e programs present&#101;d in the rest of the book, &#119;ith enough information to start developing &#99;ross-platform C++ GUI applications using Qt.</p>
<p class="docText"><a name="time of"></a>At the time of thi&#115; writin&#103;, C++ is t&#104;e only &#114;ealis&#116;ic option f&#111;r developing cros&#115;-platform, high-performance, objec&#116;-oriente&#100; G&#85;I applications. Its d&#101;tractors usu&#97;lly point out that Java or C#, &#119;hich dropped C compatibility, is nicer to use; &#105;n fact, Bjarne Stroustrup, the invent&#111;r of C++, noted in <span class="docEmphasis"><a name="Design and"></a>The Design and Evolution of C++</span><a name="struggling to"></a> (Addison-Wesl&#101;y, 1994) t&#104;at &quot;wit&#104;in C++, th&#101;re &#105;s a much smaller &#97;nd cleaner language strugg&#108;ing to get out&quot;.</p>
<p class="docText"><a name="usually stick"></a>Fortunately, when we program with Qt, we us&#117;ally stic&#107; to a subse&#116; of C++ that is very c&#108;ose to the utopian la&#110;guage envisioned by Strou&#115;trup, leaving us free to conc&#101;ntrate on the problem at hand. Furthermore, &#81;t extends C++ in several respects, through &#105;ts inno&#118;ative &quot;sign&#97;ls and slo&#116;s&quot; mechan&#105;sm, its Uni&#99;ode support, and its <tt>foreac&#104;</tt> keyword.</p>
<p class="docText"><a name="how to"></a>In the first section of th&#105;s appen&#100;i&#120;, we wi&#108;l see how to combine C++ sou&#114;ce files to obtain an ex&#101;cutable program. This will lead us to e&#120;plore core C++ concepts such as compilation &#117;nits, header files, object files, and librariesâ€”&#97;nd to get f&#97;miliar wi&#116;h the C++ pr&#101;pr&#111;cessor, com&#112;iler, and link&#101;r.</p>
<p class="docText"><a name="important language"></a>Then we will turn to the most importa&#110;t &#108;anguage di&#102;ferenc&#101;s betw&#101;en C++, Java, and C#: how to defi&#110;e classes, how to use pointers a&#110;d references, how to ov&#101;rload operators, how to use the prepr&#111;ce&#115;sor, and &#115;o on. Alt&#104;ough t&#104;e C++ syntax is sup&#101;rficially similar &#116;o that of Java and C#, the underlying conce&#112;ts d&#105;ffer in &#115;ubtle ways. At the s&#97;me time, as an inspira&#116;ional source for Java and <a name="iddle1718"></a><a name="iddle1890"></a><a name="iddle2922"></a><a name="iddle3570"></a><a name="iddle3658"></a><a name="iddle4083"></a><a name="including similar"></a>C#, the C++ language ha&#115; a lot in common with these two lang&#117;ages, including similar data types, the same arithmeti&#99; operators, and the same basic control flow statement&#115;.</p>
<p class="docText"><a name="is devoted"></a>The las&#116; section &#105;s devot&#101;d t&#111; the St&#97;ndard C++ library, which prov&#105;des ready-made functionality that ca&#110; b&#101; us&#101;d in a&#110;y C++ program. T&#104;e library is the result of more th&#97;n thirty years of evolution, and as such it &#112;rovides a wide range of approache&#115; including procedural, object-orient&#101;d, a&#110;d &#102;unc&#116;ional pr&#111;gramming sty&#108;es, and both macros and templates. Comp&#97;red with the libraries provided with Java a&#110;d &#67;#, the Stand&#97;rd C++ library is qu&#105;te narrow i&#110; scope; for example, it has no su&#112;port for GUI programming, multithreadin&#103;, databases, internationalization, network&#105;ng, XML, or Unicode. To develop in these areas, C++ programm&#101;rs &#97;re expect&#101;d t&#111; us&#101; various (o&#102;ten platform-&#115;pecific) third-party libraries.</p>
<p class="docText"><a name="where Qt"></a>This is where Qt &#115;aves th&#101; da&#121;. Qt began as a cr&#111;ss-plat&#102;orm GUI toolkit (a set of cl&#97;sses that makes it possible to write portable &#103;raphical user interface applications) &#98;ut rapidly evolved into a full-blown application developm&#101;nt &#102;ram&#101;wo&#114;k that &#112;artly extends a&#110;d partly replaces &#116;he Standard C++ library. Although this b&#111;ok &#117;ses Qt, it i&#115; useful to know wh&#97;t the Standa&#114;d C++ library has to offer, since &#121;ou may have to work with code that uses it.</p>




<a name="app04lev1sec1"></a>
<h3 class="docSection1Title" id="-100000">Getting Started with C++</h3>
<p class="docText"><a name="A C"></a>A C++ pr&#111;gram consists of one or more <span class="docEmphasis">compilation &#117;nits</span><a name="unit is"></a>. Each compilation unit is a separate source code file, typically w&#105;th a <tt>.cpp</tt><a name="common extensions"></a> &#101;xt&#101;ns&#105;on (othe&#114; common e&#120;tensions are <tt>.&#99;c</tt> and <tt>.cxx</tt><a name="the compiler"></a>) that the compiler processes in one run. For &#101;ac&#104; compi&#108;ation unit, the compi&#108;er generates a&#110; <span class="docEmphasis">object file</span>, with the ext&#101;nsion <tt>.obj</tt> (on Windows) or <tt>.o</tt><a name="object file"></a> (on Un&#105;x and Mac OS X). The object file is a binary file that cont&#97;ins machine code for the architecture on which the progr&#97;m will run.</p>
<p class="docText">&#79;nce all the <tt>.c&#112;p</tt><a name="together to"></a> fi&#108;es have bee&#110; comp&#105;led, we can combine the objec&#116; files together to create an executable usi&#110;g &#97; special p&#114;ogram called the <span class="docEmphasis">li&#110;ker</span><a name="resolves the"></a>. T&#104;e linker concatenates t&#104;e object files and resolves the memory &#97;ddresses of functions and other s&#121;mbols referenced in the comp&#105;lation &#117;nits.</p>
<p class="docText">When &#98;uilding a p&#114;ogram, &#101;xactly one comp&#105;lation unit must cont&#97;in a <tt>main()</tt><a name="any class"></a> function that serves as the program's &#101;nt&#114;y poin&#116;. This function doesn't &#98;elong to any cl&#97;ss; it is a <span class="docEmphasis">global function</span><a name="shown schematically"></a>. The process &#105;s shown schematically in <a class="docLink" href="#app04fig01">Figure D.1</a>.</p>
<a name="app04fig01"></a><p><center>

<h5 class="docFigureTitle"><a name="compilation process"></a>Figure D.1. T&#104;e C++ compilation process (on Windows)</h5>

<p class="docText">
<img border="0" id="" width="324" height="114" src="images/NzlkOW1jM2FhMDc4L2lwdHJnZTFnMTRzOXIvMy83aXBpcGhncDEvZzBhc2NpX2QuZl9m.jpg" alt="" /></p>


</center></p><br />
<p class="docText"><a name="Unlike Java"></a>U&#110;like Java, where each source file must contain exa&#99;tly one clas&#115;, C++ lets u&#115; organi&#122;e th&#101; compilation un&#105;ts as we want. We can implem&#101;nt several classes in the same <tt>.cpp</tt><a name="the implementation"></a> file, or &#115;pread t&#104;e impl&#101;ment&#97;tion of a class across &#115;everal <tt>.cpp</tt><a name="we can"></a> files, and we can give the so&#117;rce files any names we like. When we make a chang&#101; in one particular <tt>.cpp</tt><a name="relink the"></a> file, we need to &#114;ecompile only that file and then relink the application to create a new e&#120;e&#99;utable.</p>
<p class="docText"><a name="iddle1209"></a><a name="iddle1519"></a><a name="iddle1699"></a><a name="iddle1889"></a><a name="iddle3196"></a><a name="iddle3656"></a><a name="iddle7677"></a><a name="iddle7747"></a><a name="iddle7752"></a><a name="iddle7763"></a><a name="iddle7798"></a><a name="the source"></a>Befo&#114;e we go &#102;urt&#104;er, let's quickl&#121; review the source cod&#101; of a trivial C++ program that compute&#115; the squ&#97;re of an in&#116;eger. The prog&#114;am consists of &#116;wo compilation units: <tt>main.cpp</tt> and <tt>&#115;quare.cpp</tt>.</p>
<p class="docText">Here's <tt>square.cpp</tt>:</p>
<div class="docText"><pre><span class="docEmphRomanAlt">1</span> double square(double n)
<span class="docEmphRomanAlt">2</span> {
<span class="docEmphRomanAlt">3</span>     return n * n;
<span class="docEmphRomanAlt">4</span> }</pre></div><br />
<p class="docText">This file si&#109;ply contains a global function called <tt>square()</tt> that return&#115; the square of its parameter.</p>
<p class="docText">Here's <tt>main.cpp</tt>:</p>
 <div class="docText"><pre> <span class="docEmphRomanAlt">1</span> #include &lt;cstdlib&gt;
 <span class="docEmphRomanAlt">2</span> #include &lt;iostream&gt;

 <span class="docEmphRomanAlt">3</span> double square(double);

 <span class="docEmphRomanAlt">4</span> int main(int argc, char *argv[])
 <span class="docEmphRomanAlt">5</span> {
 <span class="docEmphRomanAlt">6</span>     if (argc != 2) {
 <span class="docEmphRomanAlt">7</span>         std::cerr &lt;&lt; "Usage: square &lt;number&gt;" &lt;&lt; std::endl;
 <span class="docEmphRomanAlt">8</span>         return 1;
 <span class="docEmphRomanAlt">9</span>     }

<span class="docEmphRomanAlt">10</span>     double n = std::strtod(argv[1], 0);
<span class="docEmphRomanAlt">11</span>     std::cout &lt;&lt; "The square of " &lt;&lt; argv[1] &lt;&lt; " is "
<span class="docEmphRomanAlt">12</span>               &lt;&lt; square(n) &lt;&lt; std::endl;
<span class="docEmphRomanAlt">13</span>     return 0;
<span class="docEmphRomanAlt">14</span> }</pre></div><br />
<p class="docText">The <tt>main.cpp</tt> sour&#99;e file conta&#105;ns the <tt>m&#97;in()</tt> functi&#111;n's &#100;efini&#116;ion. In C++, this function takes a&#110; <tt>int</tt> and a <tt>char *</tt><a name="as"></a> array (an array of ch&#97;racter st&#114;ings) a&#115; parameters. The p&#114;ogram's name is &#97;vailable as <tt>argv[0]</tt> and the command-&#108;ine arguments as <tt>argv[1]</tt>, <tt>argv[2]</tt>, ..., <tt>argv[argc - 1]</tt>. The &#112;arameter names <tt>argc</tt> (&quot;argument count&quot;) and <tt>argv</tt><a name="can define"></a> (&quot;argument v&#97;lues&quot;) are conventional. If the program doesn't access the com&#109;and-line arg&#117;ments, we c&#97;n define <tt>m&#97;in()</tt> with no &#112;arameters.</p>
<p class="docText"><a name="iddle1017"></a><a name="iddle1028"></a><a name="iddle1407"></a><a name="iddle1456"></a><a name="iddle1720"></a><a name="iddle1724"></a><a name="iddle2409"></a><a name="iddle2876"></a><a name="iddle3003"></a><a name="iddle3571"></a><a name="iddle3979"></a><a name="iddle4553"></a><a name="iddle6998"></a><a name="iddle7693"></a><a name="iddle7741"></a><a name="iddle7753"></a>The <tt>ma&#105;n()</tt> function uses <tt>strtod()</tt> (&quot;s&#116;ring to <tt>double</tt>&quot;), <tt>cout</tt> (C++'s standard output s&#116;ream), and <tt>&#99;err</tt><a name="to a"></a> (C++'s stand&#97;rd error stream) fro&#109; the Standard C++ &#108;ibrary to convert the comma&#110;d-line argument to a <tt>double</tt><a name="text to"></a> an&#100; to print text to the console. Strings, num&#98;ers, and end-of-line markers (<tt>endl</tt><a name="using the"></a>) are output using the <tt>&lt;&lt;</tt><a name="which is"></a> o&#112;era&#116;or, which &#105;s also u&#115;ed for b&#105;t-shifting. To ac&#99;ess this standard functi&#111;nality, we need the <tt>#include</tt><a name="lines "></a> di&#114;ectiv&#101;s o&#110; lines 1 and 2.</p>
<p class="docText"><a name="the functions"></a>&#65;ll the functions a&#110;d most other items in the St&#97;ndard C++ library are in the <tt>std</tt><a name="is to"></a> namespace. One way to acces&#115; an item in a namespace is to prefix its name with the name&#115;pace's name using the <tt>::</tt> operator. In C++, the <tt>::</tt><a name="a complex"></a> operator separ&#97;tes the co&#109;ponents of a &#99;omplex name. &#78;amespaces &#109;ake large multi-person p&#114;ojects easier because the&#121; help avoid name conflicts. We cov&#101;r t&#104;em lat&#101;r in t&#104;is append&#105;x.</p>
<p class="docText">The declaration on line 3 is a <span class="docEmphasis">function protot&#121;pe</span><a name="the given"></a>. It tells the compiler that a func&#116;ion exists with the given parameters and return &#118;alue. The actual function can be located in the same compilation unit &#111;r i&#110; a&#110;o&#116;her comp&#105;lation unit. Witho&#117;t the function prototy&#112;e, the compiler wouldn't let us call t&#104;e func&#116;ion on li&#110;e 12. Pa&#114;ameter names &#105;n function prototypes a&#114;e optional.</p>
<p class="docText"><a name="from platform"></a>The procedure to compile the p&#114;ogram varies from platform to platform. For e&#120;ample, to compile on Solaris with the Sun C++ compiler, we w&#111;ul&#100; t&#121;pe &#116;he follo&#119;ing commands:</p>
<div class="docText"><pre>CC -c main.cpp
CC -c square.cpp
CC main.o square.o -o square</pre></div><br />
<p class="docText">The fir&#115;t two lines invoke &#116;he compiler to generate <tt>.o</tt> files for the <tt>.cpp</tt><a name="called"></a> f&#105;les. The &#116;hird lin&#101; invokes the li&#110;ker a&#110;d generates an executable call&#101;d <tt>square</tt><a name="run as"></a>, which we can run as follows:</p>
<div class="docText"><pre>./square 64</pre></div><br />
<p class="docText"><a name="of the"></a>This run of &#116;he program outputs the following message to the console:</p>
<div class="docText"><pre>The square of 64 is 4096</pre></div><br />
<p class="docText"><a name="To compile"></a>To c&#111;mpile the program, you probably want to ge&#116; help fro&#109; your local C++ &#103;uru. F&#97;iling thi&#115;, you can still re&#97;d the rest of this app&#101;ndix without compiling anything a&#110;d &#102;oll&#111;w the inst&#114;uctions &#105;n <a class="docLink" href="ch01.html#ch01">Chapter 1</a><a name="your first"></a> to compile your first &#67;++/Qt application. Qt provides tools t&#104;at make it easy to build applications on al&#108; platforms.</p>
<p class="docText"><a name="to our"></a>Back to our program: In a real-world application, we would normal&#108;y put the <tt>sq&#117;are()</tt><a name="file in"></a> funct&#105;on prot&#111;ty&#112;e in a separate &#102;ile and include th&#97;t file in all the compilation units where we ne&#101;d t&#111; ca&#108;l the function. Such &#97; file is called a <span class="docEmphasis">heade&#114; file</span> and usually has a <tt>.h</tt> exte&#110;sion (<tt>.hh</tt>, <tt>.hpp</tt>, and <tt>.hxx</tt><a name="our example"></a> are also commo&#110;). If we redo our example using th&#101; header file approach, we would create a file &#99;alled <tt>squar&#101;.h</tt> w&#105;th the f&#111;ll&#111;wing &#99;ontents:</p>
<div class="docText"><pre><span class="docEmphRomanAlt">1</span> #ifndef SQUARE_H
<span class="docEmphRomanAlt">2</span> #define SQUARE_H

<span class="docEmphRomanAlt">3</span> double square(double);

<span class="docEmphRomanAlt">4</span> #endif</pre></div><br />
<p class="docText"><a name="iddle1457"></a><a name="iddle1927"></a><a name="iddle2065"></a><a name="iddle2407"></a><a name="iddle3145"></a><a name="iddle3197"></a><a name="iddle3311"></a><a name="iddle4418"></a><a name="iddle7694"></a>The header file &#105;s bracketed by three pre&#112;roc&#101;ss&#111;r directiv&#101;s (<tt>#ifnde&#102;</tt>, <tt>#define</tt>, and <tt>#endif</tt><a name="only once"></a>). These &#100;irectives ensure that th&#101; header file is processed only once, ev&#101;n if the header file is included s&#101;ve&#114;al tim&#101;s i&#110; t&#104;e same compilation &#117;nit (a situation that can arise whe&#110; header files include other h&#101;ad&#101;r f&#105;les). By conv&#101;ntion, the p&#114;eprocessor symb&#111;l used to accomplish this is derived from the &#102;ile name (in our example, <tt>SQUARE_H</tt><a name="later in"></a>). W&#101; will come back to the preprocessor later in thi&#115; append&#105;x.</p>
<p class="docText">The ne&#119; <tt>main.cpp</tt> fil&#101; lo&#111;ks like this:</p>
<div class="docText"><pre> <span class="docEmphRomanAlt">1</span> #include &lt;cstdlib&gt;
 <span class="docEmphRomanAlt">2</span> #include &lt;iostream&gt;

 <span class="docEmphRomanAlt">3</span> #include "square.h"

 <span class="docEmphRomanAlt">4</span> int main(int argc, char *argv[])
 <span class="docEmphRomanAlt">5</span> {
 <span class="docEmphRomanAlt">6</span>     if (argc != 2) {
 <span class="docEmphRomanAlt">7</span>         std::cerr &lt;&lt; "Usage: square &lt;number&gt;" &lt;&lt; std::endl;
 <span class="docEmphRomanAlt">8</span>         return 1;
 <span class="docEmphRomanAlt">9</span>     }

<span class="docEmphRomanAlt">10</span>     double n = std::strtod(argv[1], 0);
<span class="docEmphRomanAlt">11</span>     std::cout &lt;&lt; "The square of " &lt;&lt; argv[1] &lt;&lt; " is "
<span class="docEmphRomanAlt">12</span>               &lt;&lt; square(n) &lt;&lt; std::endl;
<span class="docEmphRomanAlt">13</span>     return 0;
<span class="docEmphRomanAlt">14</span> }</pre></div><br />
<p class="docText">Th&#101; <tt>#include</tt> directive on li&#110;e 3 expands to the contents of the file <tt>&#115;quare.h</tt>. &#68;irectives &#116;hat start with a <tt>#</tt><a name="takes place"></a> ar&#101; picked up by the &#67;++ preprocessor before the compi&#108;ation proper takes place. In the old &#100;ays, the preprocessor was a separa&#116;e program that the programmer invoked m&#97;nually be&#102;ore &#114;unnin&#103; the c&#111;mpiler. Mod&#101;rn compilers hand&#108;e the preprocessor step implicitly.</p>
<p class="docText">The <tt>#&#105;nclude</tt><a name="and "></a> &#100;i&#114;ectives o&#110; lines 1 and 2 &#101;xpand to the content&#115; of the <tt>cstdlib</tt> and <tt>iostream</tt><a name="are part"></a> header file&#115;, which are part of the Standard C++ lib&#114;ary. Standard header files have no <tt>.h</tt><a name="The angle"></a> suffix. T&#104;e angl&#101; br&#97;ckets aro&#117;nd the fil&#101; names indicate &#116;hat the header f&#105;les are located in a standard loca&#116;ion on th&#101; sy&#115;tem, and do&#117;ble quotes tell th&#101; compiler to look in the current di&#114;ectory. Includes are normally gathe&#114;ed at the top of a <tt>.cpp</tt> file.</p>
<p class="docText">Unlike <tt>.cpp</tt><a name="are not"></a> fil&#101;s, header files are not compilation unit&#115; in thei&#114; own ri&#103;ht an&#100; d&#111; not produce &#97;ny object files. Header &#102;iles may only contain declar&#97;tions tha&#116; enable d&#105;fferent compila&#116;ion units to comm&#117;nicate with each other. Consequent&#108;y, it would be inappropriate to put the <tt>squa&#114;e()</tt><a name="in a"></a> function's implementation in a header &#102;ile. If we did so in our example, nothing bad would happen, &#98;ecause we i&#110;c&#108;ude <tt>square.&#104;</tt> only o&#110;ce, bu&#116; if we included <tt>square.h</tt> f&#114;om several <tt>.cpp</tt> files, <a name="iddle2185"></a><a name="iddle2323"></a><a name="iddle2645"></a><a name="iddle3541"></a><a name="iddle3566"></a><a name="iddle4428"></a><a name="iddle7422"></a><a name="iddle7695"></a><a name="iddle7729"></a><a name="iddle7957"></a><a name="iddle8318"></a><a name="iddle8322"></a>we would get mul&#116;iple imp&#108;ementatio&#110;s of t&#104;e <tt>square()</tt> func&#116;ion (one per <tt>.cpp</tt><a name="multiple "></a> file that incl&#117;des it). The linker would then complai&#110; about multiple (identical) definitions of <tt>s&#113;uare()</tt><a name="if we"></a> and refuse to generate an executable. Conversely, if we de&#99;lare a funct&#105;on but n&#101;ve&#114; imple&#109;ent it, the link&#101;r complains about &#97;n &quot;unresolved symbol&quot;.</p>
<p class="docText"><a name="of object"></a>So far, we have as&#115;umed th&#97;t an execu&#116;able consists ex&#99;lusively of obj&#101;ct files. In practice, it of&#116;en also links against libraries that impl&#101;ment ready-made functionality. There a&#114;e two main types of libraries:</p>
<ul><li><p class="docList"><span class="docEmphasis">Static libraries</span><a name="they were"></a> are put d&#105;rectly &#105;nto the &#101;xe&#99;utable, as th&#111;ugh they w&#101;re object &#102;iles. This ensures that the library cannot &#103;et lo&#115;t but in&#99;reases the size of th&#101; execu&#116;able.</p></li><li><p class="docList"><span class="docEmphasis">Dynamic libraries</span><a name="on the"></a> (also calle&#100; shared libraries or DLLs) are locate&#100; at a standard location on the user's &#109;achine and are automatically loaded at application startup.</p></li></ul>
<p class="docText">For the <tt>squa&#114;e</tt><a name="the Standard"></a> prog&#114;am, we l&#105;nk agai&#110;s&#116; the Standa&#114;d C++ library, which is im&#112;lemented as a dynamic libra&#114;y on mo&#115;t platf&#111;rms. Qt itse&#108;f is a collection of libr&#97;ries that can be built either as static o&#114; as dynamic libraries (the defaul&#116; is dynamic).</p>

</div></div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app04.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=app04lev1sec2.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>