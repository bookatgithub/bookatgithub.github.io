<html>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<head>
<title>app04lev1sec2.html</title>
<link rel="STYLESHEET" type="text/css" href="images/css1.css">
<link rel="STYLESHEET" type="text/css" href="images/css2.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app04lev1sec1.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=app04lev1sec3.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<div style=""><div><a name="app04lev1sec2"></a>
<h3 class="docSection1Title" id="-100000">Main Language Differences</h3>
<p class="docText"><a name="We will"></a>&#87;e will now &#116;ake a mor&#101; st&#114;uctur&#101;d look &#97;t the areas where C++ di&#102;fers from Java and C#. Many of the lang&#117;age diffe&#114;ences &#97;re due to C++'s compil&#101;d nature and c&#111;mmitment to performa&#110;ce. Thus, C++ does not check array bou&#110;ds at run-time, and there is no garba&#103;e collector to reclaim unused dynamically allocated memory.</p>
<p class="docText"><a name="sake of"></a>&#70;o&#114; the sa&#107;e of brevi&#116;y, C++ const&#114;ucts that are &#110;early identical to t&#104;eir Java and C# counterparts are not reviewed. In &#97;ddition, s&#111;me &#67;++ topics are no&#116; covered here be&#99;ause they are not necessary when &#112;rogramming using Qt. Among &#116;hese are defining template classes and f&#117;nctions, defining union types, and using &#101;xc&#101;pt&#105;ons. For &#116;he whole &#115;tory, refer t&#111; a book such as <span class="docEmphasis"><a name="Programming Language"></a>T&#104;e C++ Programming Language</span> by Bjarne Str&#111;us&#116;rup (Addi&#115;on-Wesley, 2000) o&#114; <span class="docEmphasis">C++ for Java Progra&#109;mers</span> by Mark Allen Weiss (Prentice Hall, 2003).</p>
<a name="app04lev2sec1"></a>
<h4 id="title-ID0EWVPM" class="docSection2Title">Primitive Data Types</h4>
<p class="docText"><a name="similar to"></a>&#84;he primitive data types offered b&#121; the C++ language are similar to those fo&#117;nd in Java or C#. <a class="docLink" href="#app04fig02">Figure D.2</a><a name="definitions on"></a> lists C++'s primitive types and their defini&#116;ions on t&#104;e plat&#102;orm&#115; suppor&#116;ed by Qt 4.</p>
<a name="app04fig02"></a><p><table cellspacing="0" class="allBorders" border="1"><caption><h5 class="docTableTitle">Figure D.2. P&#114;imitive C++ types</h5></caption><colgroup align="left" span="2"><col width="100" /><col width="300" /></colgroup><thead><tr><th scope="col" class="docTableCell thead" align="center" valign="top" style="background-color:#E6E6E6">C++ Type</th><th scope="col" class="docTableCell thead" align="center" valign="top" style="background-color:#E6E6E6">&#68;escription</th></tr></thead><tr><td class="docTableCell" align="left" valign="top"><tt>bool</tt></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">Boolean value</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><tt>char</tt></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">8-b&#105;t integ&#101;r</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><tt>s&#104;ort</tt></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">16-bit integer</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><tt>&#105;nt</tt></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">32-bit int&#101;ger</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><tt>long</tt></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">32-bit or 64-bit integer</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><tt>&#108;ong long</tt><sup class="docFootnote"><a class="docLink" href="#app04fn01">[*]</a></sup></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">64-bit integer</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><tt>float</tt></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">32-bit floating-poin&#116; value (IEEE 754)</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><tt>double</tt></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">64-bit floating-point value (IEEE 754)</span></td></tr></table></p><br /><blockquote><p class="docFootnote"><sup><a name="app04fn01">[*]</a></sup> Microsoft &#99;alls the non-standard (but due to be standardized) <tt>l&#111;ng &#108;ong</tt> type <tt>__in&#116;64</tt>. In Qt pro&#103;rams, <tt>&#113;longlong</tt><a name="Qt platforms"></a> is avai&#108;able as an alternative that work&#115; on all Qt platforms.</p></blockquote>
<p class="docText">By default, the <tt>short</tt>, <tt>int</tt>, <tt>long</tt>, &#97;nd <tt>long lo&#110;g</tt><a name="hold negative"></a> &#100;ata types a&#114;e signed, m&#101;aning that they can hold &#110;egative values as well as positiv&#101; values. If we only need to store nonn&#101;gative integers, we can put the <tt>unsigned</tt> k&#101;yw&#111;rd &#105;n front &#111;f t&#104;e type. Whereas a <tt>s&#104;ort</tt> can hold &#97;ny value between -32768 and +32767, an <tt>unsigned</tt> <a name="iddle1040"></a><a name="iddle1316"></a><a name="iddle1450"></a><a name="iddle1527"></a><a name="iddle2404"></a><a name="iddle3253"></a><a name="iddle3595"></a><a name="iddle4401"></a><a name="iddle4568"></a><a name="iddle6744"></a><a name="iddle7598"></a><a name="iddle8377"></a><tt>s&#104;ort</tt> go&#101;s f&#114;om 0 to 65535. The righ&#116;-shift opera&#116;or <tt>&gt;&gt;</tt> has unsigned (&quot;fill with 0s&quot;) semant&#105;cs if one of the operands is unsi&#103;ned.</p>
<p class="docText">The <tt>bool</tt> type can take the values <tt>true</tt> and <tt>f&#97;lse</tt>. In addition, numeric types can be used where a <tt>bool</tt> is expec&#116;ed, with t&#104;e rule &#116;hat 0 mean&#115; <tt>false</tt> a&#110;d any non-zer&#111; value means <tt>true</tt>.</p>
<p class="docText">The <tt>char</tt><a name="used as"></a> &#116;ype is used for storing ASCII charac&#116;ers and 8-b&#105;t integ&#101;rs (bytes). When u&#115;ed as an integer, &#105;t can be signed or unsigne&#100;, depending on the pl&#97;tform. The types <tt>signed char</tt> and <tt>unsigned c&#104;ar</tt><a name="unambiguous alternatives"></a> are available as unambiguous alternatives to <tt>char</tt><a name="a"></a>. Qt p&#114;ovide&#115; a <tt>QChar</tt><a name="type that"></a> &#116;ype that &#115;tores 16-b&#105;t Unicode &#99;haracters.</p>
<p class="docText"><a name="types are"></a>Instances of &#98;uilt-in types are not initialized &#98;y default. W&#104;en we c&#114;eate an <tt>i&#110;t</tt><a name="value could"></a> variable, it&#115; value could conc&#101;ivably be 0, but could just as likely be -209486515. Fortunat&#101;ly, most compilers warn us when we attempt to read th&#101; contents of an uninitialized variable, an&#100; w&#101; ca&#110; u&#115;e tools &#115;uch as Rational Pu&#114;ifyPlus and Valgrind to &#100;etect uninitialized memo&#114;y acce&#115;ses and &#111;ther m&#101;mory-rela&#116;ed problems at run-time.</p>
<p class="docText">In mem&#111;ry, the numeric types (except <tt>&#108;ong</tt><a name="but their"></a>) have identical sizes on the diff&#101;rent platforms supported by Qt, but their re&#112;res&#101;nt&#97;tion vari&#101;s d&#101;pend&#105;ng on the system's by&#116;e order. On big-endian archite&#99;tures (such a&#115; PowerP&#67; and SPARC), the 32-bit va&#108;ue <tt>0x12345678</tt><a name="bytes"></a> is stored a&#115; the four bytes <tt>0x12 0x34 0x56 0x78</tt><a name="This makes"></a>, &#119;hereas on little-endian architectures (such as Intel x86), &#116;he byte sequence is reversed. T&#104;is makes a difference in prog&#114;ams th&#97;t copy mem&#111;ry &#97;reas onto &#100;isk or tha&#116; send binary data over t&#104;e network. Qt's <tt>QDataStream</tt> &#99;lass, presen&#116;ed in <a class="docLink" href="ch12.html#ch12">Chapter 12</a><a name="in a"></a>, can &#98;e used to store &#98;inary data in a plat&#102;orm-independent &#119;ay.</p>

<a name="app04lev2sec2"></a>

<h4 id="title-ID0EQAAO" class="docSection2Title">Class Definitions</h4>
<p class="docText"><a name="iddle1592"></a><a name="iddle1775"></a><a name="iddle1780"></a><a name="iddle1789"></a><a name="iddle2060"></a><a name="iddle2877"></a><a name="iddle3222"></a><a name="iddle4369"></a><a name="iddle4371"></a><a name="iddle4453"></a><a name="iddle4551"></a><a name="iddle4554"></a><a name="iddle4560"></a><a name="iddle7799"></a><a name="but there"></a>Class definitions in C++ are similar to those i&#110; Java and C#, but there are several differences &#116;o be aware of. We will study these differenc&#101;s u&#115;ing a se&#114;ies of &#101;xa&#109;ples. Let's start with a c&#108;ass that represent &#97;n (<span class="docEmphasis">x</span>, <span class="docEmphasis">y</span>) coordinate pair:</p>
<div class="docText"><div class="codeSegmentsExpansionLinks">
              Code View:</div><pre class="">#ifndef POINT2D_H
#define POINT2D_H

class Point2D
{
public:
    Point2D() {
        xVal = 0;
        yVal = 0;
    }
    Point2D(double x, double y) {
        xVal = x;
        yVal = y;
    }

    void setX(double x) { xVal = x; }
    void setY(double y) { yVal = y; }
    double x() const { return xVal; }
    double y() const { return yVal; }

private:
    double xVal;
    double yVal;
};

#endif

					  </pre></div><br />
<p class="docText"><a name="definition would"></a>The precedi&#110;g &#99;lass defini&#116;ion would a&#112;pear in a he&#97;der file, typically called <tt>poin&#116;2d.h</tt><a name="exhibits the"></a>. The example exhibits the following C++ idiosy&#110;crasies:</p>
<ul><li><p class="docList"><a name="A class"></a>A class definition is di&#118;ided into public, protected, and private sectio&#110;s, &#97;nd ends wi&#116;h a semic&#111;lo&#110;. If no s&#101;ction is speci&#102;ied, the default is private. (For compa&#116;ibility &#119;ith C, C++ provi&#100;es a <tt>struc&#116;</tt><a name="is identical"></a> keyword that is id&#101;ntical to <tt>class</tt><a name="that the"></a> except that the d&#101;fault is public if no section is sp&#101;cified.)</p></li><li><p class="docList"><a name="and one"></a>The class has two cons&#116;ructors (one that has no parameters and one &#116;hat has t&#119;o). If we decla&#114;ed no c&#111;ns&#116;ructor, C++ would automa&#116;ically supply one with no pa&#114;ameters and an empty body.</p></li><li><p class="docList">The gette&#114; funct&#105;ons <tt>x()</tt> an&#100; <tt>y()</tt><a name="means that"></a> are declar&#101;d to be &#99;onst. This means that they don't (&#97;nd can't) modify the member variabl&#101;s or call non-const member functions (s&#117;ch as <tt>setX()</tt> and <tt>setY()</tt>).</p></li></ul>
<p class="docText"><a name="class definition"></a>The preceding func&#116;ions wer&#101; im&#112;lem&#101;nt&#101;d inl&#105;ne, as part of the cl&#97;ss definition. An alternative is to provid&#101; on&#108;y function &#112;rototy&#112;es in t&#104;e header file and to im&#112;lement the functions in a <tt>.cpp</tt><a name="like this"></a> file. Usin&#103; this approach, the header file would l&#111;ok like this:</p>
<div class="docText"><pre>#ifndef POINT2D_H
#define POINT2D_H

class Point2D
{
public:
    Point2D();
    Point2D(double x, double y);

    void setX(double x);
    void setY(double y);
    double x() const;
    double y() const;

private:
    double xVal;
    double yVal;
};

#endif</pre></div><br />
<p class="docText">The functions would then be implem&#101;nt&#101;d i&#110; <tt>p&#111;in&#116;2d.cpp</tt>:</p>
<div class="docText"><div class="codeSegmentsExpansionLinks">
              Code View:</div><pre class="">#include "point2d.h"

Point2D::Point2D()
{
    xVal = 0.0;
    yVal = 0.0;
}

Point2D::Point2D(double x, double y)
{
    xVal = x;
    yVal = y;
}

void Point2D::setX(double x)
{
    xVal = x;
}

void Point2D::setY(double y)
{
    yVal = y;
}

double Point2D::x() const
{
    return xVal;
}

double Point2D::y() const
{
    return yVal;
}

					  </pre></div><br />
<p class="docText">We start by in&#99;luding <tt>point2d.h</tt><a name="parse member"></a> because the co&#109;piler needs the class definition befo&#114;e it ca&#110; p&#97;rse member funct&#105;on impleme&#110;tations. Then we im&#112;lement <a name="iddle1009"></a><a name="iddle1018"></a><a name="iddle1790"></a><a name="iddle2061"></a><a name="iddle3567"></a><a name="iddle3994"></a><a name="iddle4372"></a><a name="iddle4384"></a><a name="iddle7411"></a><a name="iddle7820"></a><a name="iddle8319"></a><a name="function name"></a>the functions, prefixi&#110;g the function name with the class name using the <tt>::</tt> o&#112;erator.</p>
<p class="docText"><a name="seen how"></a>We have seen how to implem&#101;nt &#97; function &#105;nline a&#110;d &#110;ow how to imple&#109;ent it in a <tt>.cpp</tt><a name="The two"></a> file. Th&#101; two approaches are semant&#105;cally e&#113;uiva&#108;ent, but when w&#101; call a functio&#110; that is declared inlin&#101;, most compilers simply expand the fun&#99;tion's body instead of generating an actual f&#117;nction call. This normally leads to faster code, but might increase th&#101; si&#122;e of &#121;ou&#114; appli&#99;ation. For this reaso&#110;, only ve&#114;y short functions should be im&#112;lem&#101;nt&#101;d inl&#105;ne; longer f&#117;nctions should always be implemented in &#97; <tt>.cpp</tt><a name="we forget"></a> file. In addition, if we forget to i&#109;plement a function and try to call it, the linker will co&#109;plain about an unresolved symbol.</p>
<p class="docText"><a name="to use"></a>Now, let's try to use the class.</p>
<div class="docText"><pre>#include "point2d.h"

int main()
{
    Point2D alpha;
    Point2D beta(0.666, 0.875);

    alpha.setX(beta.y());
    beta.setY(alpha.x());

    return 0;
}</pre></div><br />
<p class="docText"><a name="without using"></a>&#73;n C++, va&#114;iable&#115; of any t&#121;pe&#115; can be decl&#97;red directly without using <tt>ne&#119;</tt><a name="using the"></a>. The first variable is initialized using &#116;he defau&#108;t <tt>Point2D</tt><a name="initialized using"></a> co&#110;structor (t&#104;e constructor t&#104;at has no parameters). The se&#99;ond variable is initialized using &#116;he second constructor. Access to an object's mem&#98;er is performed using the <tt>.</tt> (dot) operator.</p>
<p class="docText"><a name="types such"></a>Variables declar&#101;d t&#104;is way &#98;ehave like &#74;ava/C# p&#114;imitive types suc&#104; as <tt>int</tt> and <tt>double</tt><a name="variable are"></a>. Fo&#114; example, when we use the assignmen&#116; operato&#114;, the co&#110;tent&#115; of the variable ar&#101; copied—not just a re&#102;erence to an object. And &#105;f we modify a variable later on, any other v&#97;riables that were assigned from it are left unchanged.</p>
<p class="docText"><a name="inheritance and"></a>&#65;s an obj&#101;ct-&#111;ri&#101;nt&#101;d language, C++ s&#117;pports inheritanc&#101; and polymorphism. To illustrate h&#111;w i&#116; works, we &#119;ill review the exam&#112;le of a <tt>Sh&#97;pe</tt><a name="class and"></a> abstract base class and a subclass called <tt>&#67;ircle</tt><a name="start with"></a>. Let's start with the base class:</p>
<div class="docText"><pre>#ifndef SHAPE_H
#define SHAPE_H

#include "point2d.h"

class Shape
{
public:
    Shape(Point2D center) { myCenter = center; }

    virtual void draw() = 0;

protected:
    Point2D myCenter;
};

#endif</pre></div><br />
<p class="docText"><a name="iddle1565"></a><a name="iddle2235"></a><a name="iddle3260"></a><a name="iddle4077"></a><a name="iddle4082"></a><a name="iddle4452"></a><a name="iddle4550"></a><a name="iddle4559"></a><a name="iddle4567"></a><a name="iddle8459"></a><a name="appears in"></a>The defi&#110;ition appears in a header file called <tt>shap&#101;.h</tt><a name="the class"></a>. Since the class definition refers to the <tt>Point2D</tt> cla&#115;s, we inc&#108;ude <tt>point2d.&#104;</tt>.</p>
<p class="docText">The <tt>Sh&#97;pe</tt> class h&#97;s no base class. Unlike &#74;ava and C#, C++ doesn't pr&#111;vide an <tt>Object</tt> class from which all c&#108;asses are i&#109;plicitly de&#114;ived. Qt provide&#115; <tt>QObject</tt> as a natu&#114;al base class for all kinds of ob&#106;ects.</p>
<p class="docText">The <tt>draw()</tt> function decl&#97;ration has two interesting features: It cont&#97;ins the <tt>virtual</tt> keyword, and it ends with <tt>= 0</tt>. The <tt>virtual</tt><a name="Like in"></a> keywor&#100; i&#110;d&#105;cates t&#104;at the &#102;unction may b&#101; reimplement&#101;d in subclasses. Like in C#, C++ member funct&#105;ons are&#110;'t &#114;eimpleme&#110;table by def&#97;ult. The bizarre <tt>= 0</tt><a name="is a"></a> synt&#97;x indicates that the function is a <span class="docEmphasis">p&#117;re virtual function</span><a name="be implemented"></a>—a function that has no defa&#117;lt implementation and that must be implemented in subclasses. The c&#111;nc&#101;pt &#111;f a&#110; &quot;i&#110;terf&#97;ce&quot; in Java and C# maps to a c&#108;ass with only pure virtual functions in C++.</p>
<p class="docText">Here'&#115; the def&#105;nition &#111;f the <tt>Circ&#108;e</tt> subclass:</p>
<div class="docText"><pre>#ifndef CIRCLE_H
#define CIRCLE_H

#include "shape.h"

class Circle : public Shape
{
public:
    Circle(Point2D center, double radius = 0.5)
        : Shape(center) {
        myRadius = radius;
    }

    void draw() {
        // do something here
    }

private:
    double myRadius;
};

#endif</pre></div><br />
<p class="docText">The <tt>Cir&#99;le</tt> class is publicly derived from <tt>Sha&#112;e</tt>, meaning that all public members of <tt>Shape</tt> remain &#112;ublic in <tt>Circle</tt><a name="the access"></a>. C++ also supports protected and pr&#105;vate inheritance, which restrict the ac&#99;ess of the ba&#115;e class'&#115; public &#97;nd protec&#116;ed members.</p>
<p class="docText"><a name="takes the"></a>The c&#111;nstructor takes two pa&#114;ameters. The second para&#109;eter is opti&#111;na&#108; and takes the valu&#101; 0.5 if no&#116; specified. The constructor p&#97;sses the <tt>center</tt><a name="base class"></a> parameter to th&#101; base class's constructor using a special syntax b&#101;tween the function signature and the function body. &#73;n the &#98;ody, we init&#105;alize t&#104;e <tt>myRa&#100;ius</tt> member <a name="iddle1019"></a><a name="iddle1290"></a><a name="iddle1566"></a><a name="iddle2232"></a><a name="iddle2233"></a><a name="iddle2236"></a><a name="iddle3469"></a><a name="iddle3950"></a><a name="iddle4206"></a><a name="iddle7731"></a><a name="iddle7889"></a><a name="iddle8241"></a><a name="also have"></a>v&#97;riable. We could also have initiali&#122;ed the variable on the same line as &#116;he base c&#108;ass constr&#117;ctor initializat&#105;on:</p>
<div class="docText"><pre>    Circle(Point2D center, double radius = 0.5)
        : Shape(center), myRadius(radius) { }</pre></div><br />
<p class="docText"><a name="On the"></a>On the ot&#104;er hand, C++ doesn'&#116; allow us to initialize a member variable in the cl&#97;ss definition, so the following code is wrong:</p>
<div class="docText"><pre>// WON'T COMPILE
private:
    double myRadius = 0.5;
};</pre></div><br />
<p class="docText">The <tt>dra&#119;()</tt><a name="the same"></a> function has the same signature as the virtual <tt>d&#114;aw()</tt><a name="declared in"></a> fun&#99;tion declar&#101;d i&#110; <tt>S&#104;ape</tt><a name="polymorphically when"></a>. It is a reim&#112;lementation and i&#116; will be invoked poly&#109;orphically &#119;hen <tt>draw()</tt> is c&#97;lled on a <tt>Circle</tt> in&#115;tance through &#97; <tt>Shape</tt> reference or &#112;ointer. C++ has no <tt>override</tt><a name="have a"></a> keyw&#111;rd like in C#. Nor does C++ have a <tt>super</tt> or <tt>bas&#101;</tt><a name="to call"></a> keyword that refers to the base class. If we ne&#101;d t&#111; ca&#108;l the base i&#109;plementati&#111;n of a fu&#110;ction, we can p&#114;efix the function name with the base class name an&#100; t&#104;e <tt>::</tt> oper&#97;tor. For example:</p>
<div class="docText"><pre>class LabeledCircle : public Circle
{
public:
    void draw() {
        Circle::draw();
        drawLabel();
    }
    ...
};</pre></div><br />
<p class="docText"><a name="be derived"></a>C++ sup&#112;orts multip&#108;e inheritance, meaning that &#97; class can be derived from several classes at &#116;he same time. The syntax is as follows:</p>
<div class="docText"><pre>class <span class="docEmphasis">DerivedClass</span> : public <span class="docEmphasis">BaseClass1</span>, public <span class="docEmphasis">BaseClass2</span>, ...,
                     public <span class="docEmphasis">BaseClassN</span>
{
    ...
};</pre></div><br />
<p class="docText"><a name="with instances"></a>By default, functi&#111;ns and variables declared in a class are associ&#97;ted with i&#110;s&#116;ances of &#116;hat clas&#115;. We can also declare &#115;tatic member f&#117;nctions and static member v&#97;riables, w&#104;ich ca&#110; be us&#101;d without a&#110; instance. For exa&#109;ple:</p>
<div class="docText"><pre>#ifndef TRUCK_H
#define TRUCK_H

class Truck
{
public:
    Truck() { ++counter; }
    ~Truck() { --counter; }
    static int instanceCount() { return counter; }

private:
    static int counter;
};

#endif</pre></div><br />
<p class="docText"><a name="iddle2114"></a><a name="iddle2745"></a><a name="iddle3568"></a><a name="iddle4373"></a><a name="iddle6820"></a><a name="iddle7725"></a><a name="iddle8320"></a><a name="variable"></a>The static member variable <tt>counter</tt><a name="of how"></a> keeps trac&#107; of how many <tt>Truck</tt><a name="instances exist"></a> instances exist at any time. The <tt>T&#114;uck</tt><a name="The destructor"></a> constructor increments it. The dest&#114;uctor, &#114;ecogn&#105;zable b&#121; th&#101; tilde (<tt>~</tt><a name="In C"></a>) prefix, d&#101;crement&#115; it. In C++, the destructor is automatically i&#110;v&#111;ke&#100; when a st&#97;tically allocated va&#114;iable goes out of scope or w&#104;en a variable allocated using <tt>new</tt> is delete&#100;. This is similar to the <tt>fina&#108;ize()</tt><a name="being called"></a> method in Java, except that we can rely &#111;n i&#116; being ca&#108;led at a spe&#99;ific point i&#110; time.</p>
<p class="docText"><a name="a single"></a>A sta&#116;ic member variable has a sin&#103;le existence in a class: Such variable&#115; are &quot;cla&#115;s varia&#98;les&quot; rather than &quot;inst&#97;nce variables&quot;. Each st&#97;tic member variable must be defi&#110;ed in a <tt>.cpp</tt> file (but without r&#101;peating the <tt>static</tt> keyword). For example:</p>
<div class="docText"><pre>#include "truck.h"

int Truck::counter = 0;</pre></div><br />
<p class="docText"><a name="at link"></a>Failing to d&#111; this would result in an &quot;unresolved symbol&quot; err&#111;r a&#116; link tim&#101;. Th&#101; <tt>in&#115;tanceCoun&#116;()</tt><a name="the class"></a> static function can b&#101; accessed from outside the class, prefixed b&#121; th&#101; cl&#97;ss name. For examp&#108;e:</p>
<div class="docText"><pre>#include &lt;iostream&gt;

#include "truck.h"

int main()
{
    Truck truck1;
    Truck truck2;

    std::cout &lt;&lt; Truck::instanceCount() &lt;&lt; " equals 2" &lt;&lt; std::endl;

    return 0;
}</pre></div><br />

<a name="app04lev2sec3"></a>
<h4 id="title-ID0EIXAO" class="docSection2Title">Pointers</h4>
<p class="docText">A <span class="docEmphasis">pointer</span><a name="an object"></a> in C++ is a v&#97;riable that stores the memory addr&#101;ss of an object (instead of stori&#110;g the object directly). Java and C# have a similar c&#111;ncept, that of a &quot;reference&quot;, but the syntax is diffe&#114;ent. We &#119;ill start by &#115;tudyin&#103; a con&#116;rived example that &#105;llustrates pointers &#105;n action:</p>
<div class="docText"><pre> <span class="docEmphRomanAlt">1</span> #include "point2d.h"

 <span class="docEmphRomanAlt">2</span> int main()
 <span class="docEmphRomanAlt">3</span> {
 <span class="docEmphRomanAlt">4</span>     Point2D alpha;
 <span class="docEmphRomanAlt">5</span>     Point2D beta;
 <span class="docEmphRomanAlt">6</span>     Point2D *ptr;

 <span class="docEmphRomanAlt">7</span>     ptr = &amp;alpha;
 <span class="docEmphRomanAlt">8</span>     ptr-&gt;setX(1.0);
 <span class="docEmphRomanAlt">9</span>     ptr-&gt;setY(2.5);

<span class="docEmphRomanAlt">10</span>     ptr = &amp;beta;
<span class="docEmphRomanAlt">11</span>     ptr-&gt;setX(4.0);
<span class="docEmphRomanAlt">12</span>     ptr-&gt;setY(4.5);

<span class="docEmphRomanAlt">13</span>     ptr = 0;

<span class="docEmphRomanAlt">14</span>     return 0;
<span class="docEmphRomanAlt">15</span> }</pre></div><br />
<p class="docText"><a name="iddle1006"></a><a name="iddle1007"></a><a name="iddle1010"></a><a name="iddle1415"></a><a name="iddle2889"></a><a name="iddle3611"></a><a name="iddle3780"></a><a name="iddle3786"></a><a name="iddle3995"></a><a name="iddle4069"></a><a name="iddle7064"></a><a name="iddle7684"></a><a name="on the"></a>The example reli&#101;s o&#110; t&#104;e <tt>Point2D</tt><a name="the previous"></a> class f&#114;om the prev&#105;ous subsection. Lines 4 and 5 de&#102;ine two objects of type <tt>Point2D</tt><a name="These objects"></a>. The&#115;e objects are initialized to (0, 0) by the default <tt>Point2D</tt> &#99;onstructor.</p>
<p class="docText"><a name="a pointer"></a>Line 6 defines a pointer to a <tt>Poin&#116;2D</tt><a name="syntax for"></a> object. &#84;he syn&#116;ax for po&#105;nters u&#115;es an asterisk in &#102;ront of the variable &#110;ame. Since we did not ini&#116;ialize t&#104;e poin&#116;er, it contains a ra&#110;dom m&#101;mory address. This is &#115;olved on line 7 by assigning <tt>alpha</tt>'s add&#114;ess to the pointer. The unary <tt>&amp;</tt><a name="is typically"></a> opera&#116;or returns the memory address of a&#110; o&#98;ject. An add&#114;ess is &#116;ypicall&#121; a 32-bit or a 64-bi&#116; integer value specifyin&#103; the offset of an object in memor&#121;.</p>
<p class="docText"><a name="the"></a>On &#108;ines 8 and 9, we &#97;ccess the <tt>alpha</tt> obje&#99;t through the <tt>pt&#114;</tt> pointer. Because <tt>ptr</tt><a name="the"></a> is a &#112;ointer and not an object, we must use the <tt>-&gt;</tt> (ar&#114;ow) operator instead of the <tt>.</tt> (dot) operato&#114;.</p>
<p class="docText">On line 10, we assign <tt>beta</tt><a name="we perform"></a>'s address to the pointer. F&#114;om the&#110; o&#110;, a&#110;y &#111;peration &#119;e perform through the poin&#116;er will affect the <tt>beta</tt> object.</p>
<p class="docText"><a name="keyword for"></a>&#76;ine 13 sets &#116;he point&#101;r to be &#97; null pointer. C++ has n&#111; keyword for repr&#101;senting a pointer t&#104;at does not point to an object; instead, we use the val&#117;e 0 (or the symbolic constant <tt>NULL</tt><a name="Trying to"></a>, which expands to 0). Trying &#116;o use a nu&#108;l pointer r&#101;su&#108;ts in a cras&#104; with an e&#114;ror message such as &quot;Segment&#97;tion fault&quot;, &quot;General protection faul&#116;&quot;, or &quot;Bus er&#114;or&quot;. Usi&#110;g a debugger, &#119;e can find out which li&#110;e of code caused the cr&#97;sh.</p>
<p class="docText"><a name="end of"></a>At the end of the function, the <tt>a&#108;pha</tt><a name="object holds"></a> object holds the coordinate pair (1.0, 2.5), wh&#101;reas <tt>beta</tt> holds (4.0, 4.5).</p>
<p class="docText"><a name="often used"></a>Pointers are often u&#115;ed to st&#111;re &#111;bj&#101;ct&#115; allocated dynam&#105;cally using <tt>new</tt><a name="we say"></a>. In C++ ja&#114;gon, we say that these objects are all&#111;ca&#116;ed on the &quot;&#104;eap&quot;, where&#97;s local variable&#115; (variables defined inside a func&#116;ion) are stored on the &quot;stack&quot;.</p>
<p class="docText">Here's a code &#115;nippet that illustrates dynamic memory al&#108;ocation using <tt>new</tt>:</p>
<div class="docText"><pre>#include "point2d.h"

int main()
{
    Point2D *point = new Point2D;
    point-&gt;setX(1.0);
    point-&gt;setY(2.5);
    delete point;

    return 0;
}</pre></div><br />
<p class="docText"><a name="iddle1776"></a><a name="iddle2088"></a><a name="iddle2881"></a><a name="iddle3996"></a><a name="iddle4118"></a><a name="iddle5439"></a><a name="iddle5600"></a><a name="iddle7550"></a><a name="iddle7685"></a>The <tt>new</tt><a name="We store"></a> operator returns the memor&#121; ad&#100;r&#101;ss &#111;f a &#110;ewly allocate&#100; object. We store the a&#100;dress in a pointer variable and a&#99;cess the obj&#101;ct &#116;hrough that poi&#110;ter. W&#104;en we are done with the object, we release &#105;ts memory using the <tt>delete</tt><a name="garbage collector"></a> operat&#111;r. Unlike Java and C#, C++ has no garbage c&#111;llector; dynamically allocated objects must be &#101;xp&#108;icitly rel&#101;as&#101;d u&#115;ing <tt>delete</tt> &#119;hen we don't need them anym&#111;re. <a class="docLink" href="ch02.html#ch02">Chapter 2</a> describes Qt's pare&#110;t–&#99;hild mechan&#105;sm, which great&#108;y simplifies m&#101;mory management in C++ prog&#114;ams.</p>
<p class="docText">If we forget to call <tt>delete</tt><a name="would not"></a>, the memory is &#107;ept around until the program finishe&#115;. This would not be an issue in the preceding &#101;xa&#109;ple, because &#119;e allocate o&#110;l&#121; one ob&#106;ect, but in a prog&#114;am that allocates new objects all t&#104;e time, &#116;his coul&#100; cause the pr&#111;gram to keep a&#108;locating memory until the machin&#101;'s memory is exhausted. O&#110;ce an object is deleted, t&#104;e pointer variable still holds the address of the obje&#99;t. Such a poin&#116;er is a &quot;da&#110;g&#108;ing pointe&#114;&quot; and shoul&#100; not be us&#101;d to access the object. Qt provides a &quot;smart&quot; &#112;oin&#116;er, <tt>QPoin&#116;er&lt;T&gt;</tt>, that automatic&#97;lly sets itself to 0 i&#102; the <tt>QObject</tt> it points to i&#115; deleted.</p>
<p class="docText"><a name="constructor and"></a>In the precedi&#110;g example, we invoked the default constr&#117;ctor and called <tt>setX()</tt> and <tt>setY()</tt> to initialize the object. We could have used &#116;he two-pa&#114;amete&#114; const&#114;uctor &#105;nstead:</p>
<div class="docText"><pre>Point2D *point = new Point2D(1.0, 2.5);</pre></div><br />
<p class="docText">The exa&#109;ple didn't require the use of <tt>&#110;ew</tt> and <tt>delete</tt><a name="the stack"></a>. We could just as well have all&#111;ca&#116;ed the ob&#106;ect on the st&#97;ck as follows:</p>
<div class="docText"><pre>Point2D point;
point.setX(1.0);
point.setY(2.5);</pre></div><br />
<p class="docText"><a name="this are"></a>&#79;bjects allocated like this are automatica&#108;ly freed at the end of the block in which they appe&#97;r.</p>
<p class="docText"><a name="intend to"></a>If we don't intend to modify the ob&#106;ect through the pointer, we can decl&#97;re the poi&#110;t&#101;r c&#111;ns&#116;. For example:</p>
<div class="docText"><pre>const Point2D *ptr = new Point2D(1.0, 2.5);
double x = ptr-&gt;x();
double y = ptr-&gt;y();

// WON'T COMPILE
ptr-&gt;setX(4.0);
*ptr = Point2D(4.0, 4.5);</pre></div><br />
<p class="docText"><a name="The"></a>T&#104;e <tt>ptr</tt><a name="can be"></a> const pointer &#99;an be used only to call const member functions s&#117;ch as <tt>x()</tt> and <tt>&#121;()</tt><a name="is good"></a>. It &#105;s good style to de&#99;lare pointers cons&#116; when we don't intend to mo&#100;ify the object using them. &#70;urthermore, if the object itself is const, w&#101; have <a name="iddle1008"></a><a name="iddle1011"></a><a name="iddle2744"></a><a name="iddle3781"></a><a name="iddle6821"></a><a name="store its"></a>no choice but to use a const pointer to store its addres&#115;. The use &#111;f <tt>c&#111;ns&#116;</tt><a name="that can"></a> provide&#115; information to th&#101; compiler that can lead to e&#97;rly bug detection and perform&#97;nce gains. &#67;# has a <tt>cons&#116;</tt><a name="closest Java"></a> keyword that is ve&#114;y similar to that o&#102; C++. The closest Java e&#113;uivalent is <tt>final</tt><a name="from calling"></a>, but it only protect&#115; variables from assignment, not from calling &quot;non-con&#115;t&quot; member functions on it.</p>
<p class="docText"><a name="In an"></a>Pointers can be used with built-in typ&#101;s a&#115; well as &#119;ith classes. &#73;n an e&#120;pressio&#110;, the unary <tt>*</tt><a name="value of"></a> op&#101;rator returns the value of t&#104;e obje&#99;t associate&#100; with the p&#111;inter. For ex&#97;mple:</p>
<div class="docText"><pre>int i = 10;
int j = 20;

int *p = &amp;i;
int *q = &amp;j;

std::cout &lt;&lt; *p &lt;&lt; " equals 10" &lt;&lt; std::endl;
std::cout &lt;&lt; *q &lt;&lt; " equals 20" &lt;&lt; std::endl;

*p = 40;

std::cout &lt;&lt; i &lt;&lt; " equals 40" &lt;&lt; std::endl;

p = q;
*p = 100;

std::cout &lt;&lt; i &lt;&lt; " equals 40" &lt;&lt; std::endl;
std::cout &lt;&lt; j &lt;&lt; " equals 100" &lt;&lt; std::endl;</pre></div><br />
<p class="docText">The <tt>-&gt;</tt><a name="be used"></a> operator, which can be used to &#97;ccess an object's members through a poin&#116;er, is pure syntactic sugar. Instead of <tt>ptr-&gt;me&#109;ber</tt><a name="we can"></a>, we can also write <tt>(*ptr).member</tt><a name="are necessary"></a>. The parent&#104;eses a&#114;e nece&#115;sary be&#99;ause the <tt>.</tt><a name="has precedence"></a> (dot) &#111;perator h&#97;s precedence ov&#101;r the unary <tt>*</tt> operator.</p>
<p class="docText"><a name="the extent"></a>Point&#101;rs &#104;ad a po&#111;r repu&#116;ation in C and C++, to th&#101; extent that Java is oft&#101;n advertised as having no po&#105;nters. In reality, C++ pointers &#97;re conceptually similar to Java and C# references exc&#101;pt &#116;hat we ca&#110; u&#115;e point&#101;rs to iterat&#101; through memo&#114;y, as we will see later in this section. F&#117;rthermor&#101;, th&#101; inclusion of &quot;co&#112;y on write&quot; contai&#110;er classes in Q&#116;, along with C++'s ability to instantiate any cla&#115;s on the stack, means that we can often avoid pointers.</p>

<a name="app04lev2sec4"></a>
<h4 id="title-ID0ECFBO" class="docSection2Title">References</h4>
<p class="docText"><a name="the concept"></a>&#73;n addition to pointers, C++ also supports the con&#99;ept of a &quot;refe&#114;ence&quot;. L&#105;ke a poi&#110;t&#101;r, a C++ referenc&#101; stores the add&#114;ess of an object. Here are the main d&#105;fferen&#99;es:</p>
<ul><li><p class="docList">Referenc&#101;s are decl&#97;red using <tt>&amp;</tt> instead &#111;f <tt>*</tt>.</p></li><li><p class="docList">The reference must be init&#105;alized and can't be reassigned later.</p></li><li><p class="docList"><a name="is no"></a>The ob&#106;ect associated with a reference is di&#114;ectly accessible; there is no special syntax such as <tt>*</tt> or <tt>-&gt;</tt>.</p></li><li><p class="docList">A r&#101;fe&#114;ence c&#97;nnot be nu&#108;l.</p></li></ul>
<p class="docText"><a name="iddle3753"></a><a name="most types"></a>Referenc&#101;s are gene&#114;ally used when de&#99;laring parameters. For most types, C++ uses call-by-value as i&#116;s defaul&#116; paramet&#101;r-passing mec&#104;anism, meaning that &#119;hen an argument is passed t&#111; a function, the function rece&#105;ves a brand new copy of the object. Here's the de&#102;inition of a function that receives its parameters through c&#97;ll-by-valu&#101;:</p>
<div class="docText"><pre>#include &lt;cstdlib&gt;

double manhattanDistance(Point2D a, Point2D b)
{
    return std::abs(b.x() - a.x()) + std::abs(b.y() - a.y());
}</pre></div><br />
<p class="docText">We &#119;ould then in&#118;oke the fun&#99;tion as follows:</p>
<div class="docText"><pre>Point2D broadway(12.5, 40.0);
Point2D harlem(77.5, 50.0);
double distance = manhattanDistance(broadway, harlem);</pre></div><br />
<p class="docText"><a name="as pointers"></a>&#67; programmers avoid need&#108;ess copy operations by declaring thei&#114; param&#101;te&#114;s as pointers i&#110;stead of as &#118;alues:</p>
<div class="docText"><pre>double manhattanDistance(const Point2D *ap, const Point2D *bp)
{
    return std::abs(bp-&gt;x() - ap-&gt;x()) + std::abs(bp-&gt;y() - ap-&gt;y());
}</pre></div><br />
<p class="docText"><a name="pass addresses"></a>They must then pass addresses inst&#101;ad of values when calling the function:</p>
<div class="docText"><pre>double distance = manhattanDistance(&amp;broadway, &amp;harlem);</pre></div><br />
<p class="docText"><a name="to make"></a>C++ i&#110;troduced references to make th&#101; syntax less cumbersome and to prevent the caller f&#114;om pas&#115;ing a nu&#108;l pointer. I&#102; we u&#115;e referenc&#101;s instead of po&#105;nters, the function looks like this:</p>
<div class="docText"><pre>double manhattanDistance(const Point2D &amp;a, const Point2D &amp;b)
{
    return std::abs(b.x() - a.x()) + std::abs(b.y() - a.y());
}</pre></div><br />
<p class="docText"><a name="The declaration"></a>The de&#99;laration of &#97; referenc&#101; is similar &#116;o that of a pointer, w&#105;th <tt>&amp;</tt> instead of <tt>*</tt><a name="we actually"></a>. But when we a&#99;tually use the reference, we can f&#111;rget that it is a memory addr&#101;ss and treat it like an ordinary variable. In add&#105;tion, ca&#108;ling a func&#116;ion that &#116;akes ref&#101;renc&#101;s as argument&#115; doesn't require any speci&#97;l care (no <tt>&amp;</tt> o&#112;era&#116;or).</p>
<p class="docText"><a name="in all"></a>All in all, by repl&#97;cing <tt>Point2D</tt> with <tt>co&#110;st Point2D &amp;</tt><a name="function call"></a> in the para&#109;eter list, we reduced the overhead of &#116;he function call: Instead of copying 256 bits (the siz&#101; of four <tt>double</tt><a name="on the"></a>s), we copy only 64 or 128 bits, depend&#105;ng on th&#101; ta&#114;get pl&#97;tform's po&#105;nter size.</p>
<p class="docText"><a name="modifying the"></a>Th&#101; previous &#101;xample used const references, p&#114;event&#105;ng the f&#117;nction from m&#111;difyin&#103; the objects associated with the refe&#114;ences. When this kind of side eff&#101;ct is desired, we can pass a non-co&#110;st reference or pointer. For example:</p>
<div class="docText"><pre>void transpose(Point2D &amp;point)
{
    double oldX = point.x();
    point.setX(point.y());
    point.setY(oldX);
}</pre></div><br />
<p class="docText"><a name="iddle1221"></a><a name="iddle4374"></a><a name="iddle8211"></a><a name="we need"></a>In some cases, we ha&#118;e a referen&#99;e and we need &#116;o call a f&#117;nction th&#97;t takes a poin&#116;er, or vice versa. To c&#111;nvert a reference to a pointer, w&#101; ca&#110; s&#105;mply use th&#101; unary <tt>&amp;</tt> operat&#111;r:</p>
<div class="docText"><pre>Point2D point;
Point2D &amp;ref = point;
Point2D *ptr = &amp;ref;</pre></div><br />
<p class="docText">To convert &#97; pointer to a reference, there is &#116;he unary <tt>*</tt> operator:</p>
<div class="docText"><pre>Point2D point;
Point2D *ptr = &amp;point;
Point2D &amp;ref = *ptr;</pre></div><br />
<p class="docText"><a name="they can"></a>References and pointe&#114;s are represented the same way in memory, &#97;nd they ca&#110; o&#102;ten &#98;e used inte&#114;changeab&#108;y, which begs the question of &#119;hen to use which. On the one hand, &#114;efere&#110;c&#101;s have a more c&#111;nveni&#101;nt syntax; on the othe&#114; hand, pointers can be reassigned a&#116; any time to point to another object, they c&#97;n hold a null value, and their more explicit syntax i&#115; often a &#98;lessing in &#100;i&#115;guise. F&#111;r these re&#97;sons, pointers tend to prevai&#108;, with references used almost exclu&#115;ively f&#111;r d&#101;claring func&#116;ion parameters, in con&#106;unction with <tt>const</tt>.</p>

<a name="app04lev2sec5"></a>
<h4 id="title-ID0EPKBO" class="docSection2Title">Arrays</h4>
<p class="docText"><a name="declared by"></a>Arrays in C++ are decla&#114;ed by specifying the number of it&#101;ms in the array within brackets in the variable de&#99;laration <span class="docEmphasis">after</span><a name="arrays are"></a> the variable name. Two-dimensional arrays ar&#101; po&#115;sible u&#115;ing an a&#114;ray of &#97;rrays. Here's t&#104;e definition of a o&#110;e-dimensional array containing t&#101;n i&#116;ems of ty&#112;e <tt>int</tt>:</p>
<div class="docText"><pre>int fibonacci[10];</pre></div><br />
<p class="docText"><a name="The items"></a>The item&#115; are access&#105;ble as <tt>fibonacci[0]</tt>, <tt>fibonacci[1]</tt>, ..., <tt>fibonacc&#105;[9]</tt><a name="want to"></a>. Often we want to initialize the arr&#97;y as we define it:</p>
<div class="docText"><pre>int fibonacci[10] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 };</pre></div><br />
<p class="docText"><a name="such cases"></a>In such cases, we can t&#104;en omit the array size, since the co&#109;piler can de&#100;u&#99;e it from the &#110;u&#109;ber of initializers:</p>
<div class="docText"><pre>int fibonacci[] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 };</pre></div><br />
<p class="docText">St&#97;tic initialization also works &#102;or complex types, such as <tt>Point2D</tt>:</p>
<div class="docText"><pre>Point2D triangle[] = {
    Point2D(0.0, 0.0), Point2D(1.0, 0.0), Point2D(0.5, 0.866)
};</pre></div><br />
<p class="docText"><a name="iddle1777"></a><a name="iddle2424"></a><a name="iddle4375"></a><a name="iddle7512"></a><a name="later on"></a>If we h&#97;ve no inte&#110;t&#105;on of altering th&#101; array lat&#101;r on, we can m&#97;ke it const:</p>
<div class="docText"><pre>const int fibonacci[] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 };</pre></div><br />
<p class="docText"><a name="items an"></a>To find out how many items an array cont&#97;ins, we can use the <tt>sizeof()</tt> operator as follow&#115;:</p>
<div class="docText"><pre>int n = sizeof(fibonacci) / sizeof(fibonacci[0]);</pre></div><br />
<p class="docText">The <tt>sizeof()</tt><a name="number of"></a> operator returns the size of i&#116;s argume&#110;t &#105;n bytes. &#84;he num&#98;er of items in an arr&#97;y is its size in bytes divid&#101;d by the size of one &#111;f i&#116;s items. B&#101;cause this is &#99;umbersome to ty&#112;e, a common alternative &#105;s to declare a constant and to use it for de&#102;ining the array:</p>
<div class="docText"><pre>enum { NFibonacci = 10 };

const int fibonacci[NFibonacci] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 };</pre></div><br />
<p class="docText"><a name="the constant"></a>It would have been tempting &#116;o declare the constant as a <tt>const int</tt><a name="We will"></a> vari&#97;ble. Unfor&#116;unately, &#115;ome com&#112;ile&#114;s have issues w&#105;th const variables a&#115; array size specifiers. We will explain t&#104;e <tt>enum</tt><a name="this appendix"></a> &#107;eyword la&#116;er in this append&#105;x.</p>
<p class="docText"><a name="an array"></a>Iterating thro&#117;gh an array is normally &#100;one using an integer. For exa&#109;ple:</p>
<div class="docText"><pre>for (int i = 0; i &lt; NFibonacci; ++i)
    std::cout &lt;&lt; fibonacci[i] &lt;&lt; std::endl;</pre></div><br />
<p class="docText"><a name="It is"></a>It is also possible to traverse the array usin&#103; a pointer:</p>
<div class="docText"><pre>const int *ptr = &amp;fibonacci[0];
while (ptr != &amp;fibonacci[10]) {
    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;
    ++ptr;
}</pre></div><br />
<p class="docText"><a name="the pointer"></a>We initialize the po&#105;nter wi&#116;h the add&#114;ess of &#116;he first &#105;tem and loop until w&#101; reach the &quot;one past &#116;he last&quot; item (the &quot;eleventh&quot; item, <tt>f&#105;bonacc&#105;[10]</tt><a name="each iteration"></a>). At each &#105;teration, t&#104;e <tt>++</tt> operator advan&#99;es the pointer to the ne&#120;t item.</p>
<p class="docText">Instead of <tt>&amp;fibonacci[0]</tt>, we coul&#100; also have written <tt>fibonacci</tt><a name="alone is"></a>. This is because the nam&#101; of an array used alone is automatically convert&#101;d i&#110;t&#111; a p&#111;in&#116;er to the firs&#116; item in the array. Si&#109;ilarly, we could substitute <tt>fibonacci + 10</tt> for <tt>&amp;fibon&#97;cci[10]</tt><a name="around as"></a>. This w&#111;rk&#115; the other w&#97;y around as well: We &#99;an retrieve the contents of the c&#117;rrent item using either <tt>*ptr</tt> or <tt>ptr[0]</tt> and &#99;ould access the next item using <tt>*(ptr + 1)</tt> or <tt>ptr[1]</tt>. This princ&#105;ple is sometimes called &quot;equivalence of poin&#116;ers and a&#114;rays&quot;.</p>
<p class="docText"><a name="does not"></a>T&#111; pr&#101;ve&#110;t what it consi&#100;ers to be a gratuito&#117;s inefficiency, C++ does not let us pa&#115;s array&#115; to func&#116;ions by value. Inste&#97;d, they must be passe&#100; by address. &#70;or example:</p>
<div class="docText"><pre>#include &lt;iostream&gt;

void printIntegerTable(const int *table, int size)
{
    for (int i = 0; i &lt; size; ++i)
        std::cout &lt;&lt; table[i] &lt;&lt; std::endl;
}

int main()
{
    const int fibonacci[10] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 };
    printIntegerTable(fibonacci, 10);
    return 0;
}</pre></div><br />
<p class="docText"><a name="iddle1031"></a><a name="iddle1153"></a><a name="iddle1836"></a><a name="iddle2089"></a><a name="iddle3779"></a><a name="iddle3999"></a><a name="iddle7756"></a><a name="iddle7764"></a><a name="iddle7958"></a><a name="iddle8416"></a><a name="iddle8419"></a><a name="we want"></a>Ironically, although C++ doesn't gi&#118;e us any choice about whether we want to pass an array by &#97;ddress or by value, it gives us some freedom in the <span class="docEmphasis">synta&#120;</span> u&#115;ed to de&#99;lare the par&#97;meter typ&#101;. Instead of <tt>&#99;onst int *table</tt>, we could also have wri&#116;ten <tt>const int table[]</tt> to declare a point&#101;r-t&#111;-co&#110;stant-<tt>int</tt> p&#97;rameter. Similarl&#121;, the <tt>argv</tt> parameter to <tt>m&#97;in()</tt> can be declared as either <tt>char *argv[]</tt> o&#114; <tt>char **argv</tt>.</p>
<p class="docText"><a name="loop through"></a>To copy an array into another array, &#111;ne approach is to loop through the array:</p>
<div class="docText"><pre>const int fibonacci[NFibonacci] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 };
int temp[NFibonacci];

for (int i = 0; i &lt; NFibonacci; ++i)
    temp[i] = fibonacci[i];</pre></div><br />
<p class="docText"><a name="types such"></a>For basic &#100;a&#116;a types s&#117;ch as <tt>int</tt><a name="also use"></a>, w&#101; ca&#110; also use <tt>memc&#112;y()</tt><a name="which copies"></a>, which copies a &#98;lock of memory. For example:</p>
<div class="docText"><pre>std::memcpy(temp, fibonacci, sizeof(fibonacci));</pre></div><br />
<p class="docText"><a name="declare a"></a>When we de&#99;lare a C++ arra&#121;, th&#101; size mu&#115;t be a cons&#116;ant.<sup class="docFootnote"><a class="docLink" href="#app04fn02">[*]</a></sup><a name="we want"></a>
 If we want to create an array of a v&#97;riable size, we have several options.</p><blockquote><p class="docFootnote"><sup><a name="app04fn02">[*]</a></sup><a name="should not"></a> &#83;ome compilers allow variables in t&#104;at context, but this feature should not be relied upon in porta&#98;le program&#115;.</p></blockquote>
<ul><li><p class="docList"><span class="docEmphStrong">We can d&#121;na&#109;ically allo&#99;ate the array:</span></p><div class="docText"><pre>int *fibonacci = new int[n];</pre></div><p class="docList">Th&#101; <tt>new []</tt><a name="of items"></a> operator allocates a ce&#114;tain number of items at consecutive memo&#114;y loca&#116;ions and &#114;eturns a point&#101;r to th&#101; first item. Thanks to the &quot;eq&#117;ivalence of pointers and arrays&quot; p&#114;inciple, the items can be accessed through the point&#101;r as <tt>fibonacci[0]</tt>, <tt>fibonacci[1]</tt>, ..., <tt>fibonacci[n - 1]</tt><a name="the memory"></a>. When we have finished u&#115;ing the &#97;rray, we sh&#111;ul&#100; r&#101;lease the mem&#111;ry it consumes using the <tt>&#100;elete []</tt> operator:</p><div class="docText"><pre>delete [] fibonacci;</pre></div></li><li><p class="docList"><span class="docEmphStrong">We can u&#115;e the st&#97;ndard vec&#116;or&lt;T&gt; class:</span></p><div class="docText"><pre>#include &lt;vector&gt;

std::vector&lt;int&gt; fibonacci(n);</pre></div><p class="docList"><a name="iddle1529"></a><a name="iddle1538"></a><a name="iddle1809"></a><a name="iddle3188"></a><a name="iddle6473"></a><a name="iddle7420"></a><a name="iddle7793"></a>Items a&#114;e accessible u&#115;ing the <tt>[]</tt> operator, just like wi&#116;h a plain C++ array. With <tt>vector&lt;T&gt;</tt> (where <tt>T</tt><a name="in the"></a> i&#115; the type of the items stored in the vect&#111;r), we can resize the array at a&#110;y &#116;ime usin&#103; <tt>resi&#122;e()</tt><a name="contain angle"></a> an&#100; we ca&#110; copy it using &#116;he assignment operator. C&#108;asses that &#99;ontain angl&#101; brackets (<tt>&lt;&gt;</tt><a name="are called"></a>) in t&#104;eir name are called &#116;emplate classes.</p></li><li><p class="docList"><span class="docEmphStrong"><a name="use Qt"></a>We can use Qt's QV&#101;ctor&lt;T&gt; class:</span></p><div class="docText"><pre>#include &lt;QVector&gt;

QVector&lt;int&gt; fibonacci(n);</pre></div><p class="docList"><tt>QVector&lt;T&gt;</tt><a name="API is"></a>'s API is very s&#105;milar to that of <tt>vector&lt;T&gt;</tt><a name="also supports"></a>, but it also support&#115; iteration using Qt's <tt>foreach</tt><a name="and uses"></a> keyword and &#117;ses impli&#99;it data shar&#105;ng (&quot;copy &#111;n w&#114;ite&quot;) as a memory an&#100; speed opt&#105;mization. <a class="docLink" href="ch11.html#ch11">Chapter 11</a><a name="the Standard"></a> presents Qt's container cl&#97;sses and e&#120;p&#108;ains how they r&#101;late to the S&#116;andard C++ containers.</p></li></ul>
<p class="docText"><a name="avoid built"></a>You might be t&#101;mpted to avoid built-in arrays whenev&#101;r possible and use <tt>vector&lt;T&gt;</tt> or <tt>QVector&lt;T&gt;</tt><a name="because sooner"></a> instea&#100;. It is nonetheless worthwhile understanding h&#111;w t&#104;e buil&#116;-in array&#115; work be&#99;ause sooner or l&#97;ter you might want &#116;o use them in highly optimized code, or n&#101;ed &#116;hem to in&#116;erface with exis&#116;ing C libraries.</p>

<a name="app04lev2sec6"></a>
<h4 id="title-ID0EZZBO" class="docSection2Title">Character Strings</h4>
<p class="docText"><a name="strings in"></a>&#84;he most basic way to repres&#101;nt character strings in C++ is to use &#97;n array of <tt>char</tt><a name="demonstrate how"></a>s terminated by a null byte ('/ 0'). The followi&#110;g four functions demonstrate how these kin&#100;s &#111;f s&#116;rings wo&#114;k:</p>
<div class="docText"><pre>void hello1()
{
    const char str[] = {
        'H', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '\0'
    };
    std::cout &lt;&lt; str &lt;&lt; std::endl;
}

void hello2()
{
    const char str[] = "Hello world!";
    std::cout &lt;&lt; str &lt;&lt; std::endl;
}

void hello3()
{
    std::cout &lt;&lt; "Hello world!" &lt;&lt; std::endl;
}

void hello4()
{
    const char *str = "Hello world!";
    std::cout &lt;&lt; str &lt;&lt; std::endl;
}</pre></div><br />
<p class="docText"><a name="iddle1452"></a><a name="iddle1528"></a><a name="iddle2425"></a><a name="iddle5898"></a><a name="iddle8299"></a><a name="we declare"></a>In th&#101; first fun&#99;tion, we declare the string as an &#97;rray and initialize it the hard way. Notice th&#101; '/0' te&#114;minat&#111;r at the end, w&#104;ich indi&#99;ates the end of the string. &#84;he second function has a similar &#97;rray definition, but this time we use a strin&#103; literal to initialize the array. In C++, string li&#116;erals ar&#101; si&#109;ply <tt>const ch&#97;r</tt><a name="an implicit"></a> arrays w&#105;th an implic&#105;t '/0' terminator. The th&#105;rd function uses a string literal direct&#108;y, without g&#105;ving it &#97; name. Once translat&#101;d int&#111; machine language instruction&#115;, it is identical to the previous two &#102;unctions.</p>
<p class="docText"><a name="The fourth"></a>The fourth function is a bit di&#102;ferent in that it creates not only an (ano&#110;y&#109;ous) array, bu&#116; also a po&#105;nter va&#114;iable called <tt>str</tt><a name="the address"></a> th&#97;t stores the address &#111;f the array's first item. In spite of t&#104;is, the &#115;emanti&#99;s of the function are i&#100;ent&#105;cal to the previous three f&#117;nctions, and an optimizing compiler wou&#108;d eliminate the superfluous <tt>str</tt> variable.</p>
<p class="docText"><a name="that take"></a>&#70;unctions that take C++ strings as argument&#115; usuall&#121; ta&#107;e either a <tt>&#99;har *</tt> or a <tt>cons&#116; char *</tt>. Here's a &#115;hort program that ill&#117;strates the use of both:</p>
<div class="docText"><pre>#include &lt;cctype&gt;
#include &lt;iostream&gt;

void makeUppercase(char *str)
{
    for (int i = 0; str[i] != '\0'; ++i)
        str[i] = std::toupper(str[i]);
}

void writeLine(const char *str)
{
    std::cout &lt;&lt; str &lt;&lt; std::endl;
}

int main(int argc, char *argv[])
{
    for (int i = 1; i &lt; argc; ++i) {
        makeUppercase(argv[i]);
        writeLine(argv[i]);
    }
    return 0;
}</pre></div><br />
<p class="docText">In C++, the <tt>ch&#97;r</tt><a name="easily store"></a> type nor&#109;ally holds a&#110; 8-bit value. &#84;his means that we &#99;an easily store ASCII, ISO 8859-1 (Latin-1), and ot&#104;er 8-bit-encoded strings in &#97; <tt>char</tt><a name="Unicode characters"></a> array, but that we can't store arbitrary Unic&#111;de characters without resorting to multibyte seq&#117;ences. Qt p&#114;ovide&#115; the pow&#101;rf&#117;l <tt>QString</tt> class, which s&#116;ores Unicode strings as sequenc&#101;s of 16-bit <tt>QChar</tt>s and intern&#97;lly uses t&#104;e impl&#105;cit data sharing (&quot;c&#111;py on w&#114;ite&quot;) optimization. <a class="docLink" href="ch11.html#ch11">Chapter 11</a> and <a class="docLink" href="ch18.html#ch18">Chapter 18</a> &#101;xplain <tt>QString</tt> in more detail.</p>

<a name="app04lev2sec7"></a>
<h4 id="title-ID0EE4BO" class="docSection2Title">Enumerations</h4>
<p class="docText"><a name="named constants"></a>C++ has a&#110; enumeration feature for declaring a set &#111;f named constants similar to that provided by C# a&#110;d &#114;ecent &#118;ersions of &#74;ava. Le&#116;'s suppose th&#97;t we want to store &#100;ays of the week in a program:</p>
<div class="docText"><pre>enum DayOfWeek {
    Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday
};</pre></div><br />
<p class="docText"><a name="header file"></a>Nor&#109;ally, we woul&#100; p&#117;t this declaration in &#97; header file, or even in&#115;ide a class. The preceding declaration &#105;s superficially equivalent to the fo&#108;lowing constant definitions:</p>
<div class="docText"><pre>const int Sunday    = 0;
const int Monday    = 1;
const int Tuesday   = 2;
const int Wednesday = 3;
const int Thursday  = 4;
const int Friday    = 5;
const int Saturday  = 6;</pre></div><br />
<p class="docText"><a name="parameters of"></a>By using the enu&#109;eration construct, we can later declare variables or pa&#114;amete&#114;s of ty&#112;e <tt>Da&#121;Of&#87;eek</tt><a name="will ensure"></a> and the co&#109;piler will ensure that on&#108;y values from the <tt>DayOfWeek</tt><a name="assigned to"></a> enumerat&#105;on are a&#115;signed &#116;o it. For exa&#109;ple:</p>
<div class="docText"><pre>DayOfWeek day = Sunday;</pre></div><br />
<p class="docText"><a name="If we"></a>If we don't care abo&#117;t type safety, we can also write</p>
<div class="docText"><pre>int day = Sunday;</pre></div><br />
<p class="docText"><a name="to refer"></a>Noti&#99;e that to refer to the <tt>Sund&#97;y</tt><a name="from the"></a> constant from the <tt>DayOfWeek</tt> enum, we simply write <tt>Sund&#97;y</tt>, not <tt>DayOfWeek::Sunday</tt>.</p>
<p class="docText"><a name="constants of"></a>By default, the compiler ass&#105;gns con&#115;ecutiv&#101; in&#116;eger val&#117;es to the cons&#116;ants of an enu&#109;, starting at 0. We can specify other values if we wa&#110;t:</p>
<div class="docText"><pre>enum DayOfWeek {
    Sunday    = 628,
    Monday    = 616,
    Tuesday   = 735,
    Wednesday = 932,
    Thursday  = 852,
    Friday    = 607,
    Saturday  = 845
};</pre></div><br />
<p class="docText"><a name="of an"></a>&#73;f we d&#111;n't specify &#116;he value of a&#110; enum item, the item takes the va&#108;ue of the preceding item, plu&#115; 1. Enums are sometimes used to declare intege&#114; constants, in which case we normally omit the name of the enum:</p>
<div class="docText"><pre>enum {
    FirstPort = 1024,
    MaxPorts  = 32767
};</pre></div><br />
<p class="docText"><a name="of options"></a>Another &#102;req&#117;ent use of &#101;nu&#109;s is to repre&#115;ent sets of opti&#111;ns. Let's consider the &#101;xample of a Find dialog, with four &#99;heckboxes c&#111;nt&#114;olling the s&#101;arch algorithm (<span class="docEmphRomanAlt">&#87;ildcard syntax</span>, <span class="docEmphRomanAlt">Case sensitive</span>, <span class="docEmphRomanAlt">S&#101;arch backward</span>, and <span class="docEmphRomanAlt">Wrap around</span><a name="where the"></a>). W&#101; can represent this by an &#101;num where the constants are powers of 2:</p>
<div class="docText"><pre>enum FindOption {
    NoOptions      = 0x00000000,
    WildcardSyntax = 0x00000001,
    CaseSensitive  = 0x00000002,
    SearchBackward = 0x00000004,
    WrapAround     = 0x00000008
};</pre></div><br />
<p class="docText"><a name="iddle1032"></a><a name="iddle1154"></a><a name="iddle5029"></a><a name="iddle8256"></a><a name="using the"></a>Each option is o&#102;ten &#99;alled a &quot;flag&quot;. &#87;e can comb&#105;ne flag&#115; using the bitw&#105;se <tt>|</tt> or <tt>|=</tt> operator:</p>
<div class="docText"><pre>int options = NoOptions;
if (wilcardSyntaxCheckBox-&gt;isChecked())
    options |= WildcardSyntax;
if (caseSensitiveCheckBox-&gt;isChecked())
    options |= CaseSensitive;
if (searchBackwardCheckBox-&gt;isChecked())
    options |= SearchBackwardSyntax;
if (wrapAroundCheckBox-&gt;isChecked())
    options |= WrapAround;</pre></div><br />
<p class="docText"><a name="whether a"></a>We can &#116;est whether a flag is set using the bitwise <tt>&amp;</tt> o&#112;era&#116;or:</p>
<div class="docText"><pre>if (options &amp; CaseSensitive) {
    // case-sensitive search
}</pre></div><br />
<p class="docText"><a name="of type"></a>A vari&#97;ble of type <tt>Fi&#110;dOption</tt><a name="can contain"></a> can co&#110;tain only one flag at a time. &#84;he result of combining several flags using <tt>|</tt><a name="plain integer"></a> is a p&#108;ain integer. Unfortunately, this is not type-safe: Th&#101; compiler won't complain if a function expecting a combination of <tt>&#70;i&#110;d&#79;ption</tt><a name="through an"></a>s thro&#117;gh an <tt>int</tt> p&#97;rameter rece&#105;ves <tt>Saturday</tt> instead. &#81;t uses <tt>QFlags&lt;T&gt;</tt><a name="class is"></a> to provide type &#115;afety f&#111;r i&#116;s own flag type&#115;. The class is als&#111; available when we de&#102;ine custom flag types. See the <tt>QFl&#97;gs&lt;T&gt;</tt> online documentation for details.</p>

<a name="app04lev2sec8"></a>
<h4 id="title-ID0EZCCO" class="docSection2Title">Typedefs</h4>
<p class="docText"><a name="to a"></a>C++ let&#115; us give an alias to a data type using the <tt>typedef</tt> key&#119;ord. For exam&#112;le, i&#102; we u&#115;e <tt>QVect&#111;r&lt;Poin&#116;2D&gt;</tt><a name="are unfortunate"></a> a lot and want to save &#97; few keystrokes (or are unfortunate enou&#103;h to b&#101; st&#117;ck with a Norw&#101;gian keyboar&#100; and have troub&#108;e locating the angle brackets), we can put this type&#100;ef declaration in one of our header f&#105;les:</p>
<div class="docText"><pre>typedef QVector&lt;Point2D&gt; PointVector;</pre></div><br />
<p class="docText">From then on, we can use <tt>PointVector</tt> as a shorthand f&#111;r <tt>Q&#86;ector&lt;Po&#105;nt2D&gt;</tt><a name="type appears"></a>. Not&#105;ce that &#116;he new name for the typ&#101; appears after t&#104;e old name. The typedef syntax delib&#101;ra&#116;ely mimi&#99;s that of variable de&#99;larations.</p>
<p class="docText">In Q&#116;, typedefs are used mainly for t&#104;ree reasons:</p>
<ul><li><p class="docText"><span class="docEmphasis">Convenience:</span> Qt &#100;eclares <tt>uint</tt> and <tt>QWidgetL&#105;st</tt> as typedefs for <tt>unsigned int</tt> &#97;nd <tt>QList&lt;Q&#87;idget *&gt;</tt> to s&#97;ve a few ke&#121;st&#114;okes.</p></li><li><p class="docText"><span class="docEmphasis">Platform dif&#102;erences:</span> <a name="iddle1317"></a><a name="iddle1451"></a><a name="iddle1453"></a><a name="iddle1460"></a><a name="iddle1490"></a><a name="iddle1778"></a><a name="iddle2405"></a><a name="iddle3596"></a><a name="iddle4012"></a><a name="iddle7724"></a><a name="iddle8430"></a>C&#101;rtain types need differ&#101;nt &#100;e&#102;initions on d&#105;fferent platfor&#109;s. For example, <tt>qlonglong</tt> is defi&#110;ed as <tt>__int64</tt> on Windows and &#97;s <tt>long long</tt> on other platforms.</p></li><li><p class="docText"><span class="docEmphasis">Compatibility:</span> The <tt>QIc&#111;nSet</tt> class from Qt 3 was renamed <tt>QIcon</tt><a name="Qt "></a> in Qt 4. To help Q&#116; 3 users po&#114;t thei&#114; appli&#99;ations to Qt 4, <tt>&#81;IconS&#101;t</tt><a name="a typedef"></a> is provided a&#115; a typedef for <tt>QIcon</tt><a name="compatibility is"></a> when Qt 3 c&#111;mp&#97;tibility &#105;s enabled.</p></li></ul>

<a name="app04lev2sec9"></a>
<h4 id="title-ID0ECICO" class="docSection2Title">Type Conversions</h4>
<p class="docText"><a name="provides several"></a>C++ &#112;rovides sev&#101;ral syntaxes for casting val&#117;es from one type to another. The tr&#97;ditional syntax, inherited from C, involve&#115; putting the resulting type in parentheses before &#116;he value &#116;o conver&#116;:</p>
<div class="docText"><pre>const double Pi = 3.14159265359;
int x = (int)(Pi * 100);
std::cout &lt;&lt; x &lt;&lt; " equals 314" &lt;&lt; std::endl;</pre></div><br />
<p class="docText"><a name="is very"></a>This syn&#116;ax is ver&#121; powerful. It can &#98;e used to change the types o&#102; pointers, to remove <tt>const</tt><a name="much more"></a>, and muc&#104; more. F&#111;r e&#120;ample:</p>
<div class="docText"><pre>short j = 0x1234;
if (*(char *)&amp;j == 0x12)
    std::cout &lt;&lt; "The byte order is big-endian" &lt;&lt; std::endl;</pre></div><br />
<p class="docText">In the pr&#101;cedi&#110;g example, we cast a <tt>short *</tt> to &#97; <tt>char *</tt> and we use the unary <tt>*</tt><a name="On big"></a> operat&#111;r to access the byte at the given memo&#114;y location. On big-endian systems, that byte is <tt>0x12</tt>; on little-endi&#97;n systems, &#105;t is <tt>0x34</tt><a name="represented the"></a>. Si&#110;c&#101; po&#105;nters and &#114;eferences a&#114;e represented the same &#119;ay, it should &#99;ome as no sur&#112;rise th&#97;t the precedi&#110;g code can be rewritten using a ref&#101;rence cast:</p>
<div class="docText"><pre>short j = 0x1234;
if ((char &amp;)j == 0x12)
    std::cout &lt;&lt; "The byte order is big-endian" &lt;&lt; std::endl;</pre></div><br />
<p class="docText"><a name="a primitive"></a>If the da&#116;a type is a class name, a typedef, or a &#112;rimitive type that can be expressed as a single al&#112;han&#117;meric tok&#101;n, w&#101; ca&#110; use the co&#110;structor synt&#97;x as a cast:</p>
<div class="docText"><pre>int x = int(Pi * 100);</pre></div><br />
<p class="docText"><a name="casts is"></a>Casting pointers and refere&#110;c&#101;s u&#115;ing the traditio&#110;al C-style cas&#116;s is a kind of extreme sp&#111;rt, on par with paragliding and &#101;levator surfing, because the compiler lets us cast &#97;ny pointer (or reference) type into any oth&#101;r p&#111;in&#116;er (or ref&#101;re&#110;ce) ty&#112;e. For that reas&#111;n, C++ introduced four new-style casts with mo&#114;e prec&#105;se sema&#110;tics. For p&#111;inters and r&#101;ferences, the new-style &#99;asts are preferable to the risky C-style casts and &#97;re used in this book.</p>
<ul><li><p class="docList"><tt>static_cast&lt;T&gt;()</tt> can be used to cast a pointe&#114;-to-<tt>A</tt> to a pointer-to-<tt>B</tt>, with the constraint that class <tt>B</tt> m&#117;st be a sub&#99;lass of clas&#115; <tt>A</tt>. For ex&#97;mple:</p><div class="docText"><pre>A *obj = new B;
B *b = static_cast&lt;B *&gt;(obj);
b-&gt;someFunctionDeclaredInB();</pre></div><p class="docList"><a name="iddle1769"></a><a name="iddle1779"></a><a name="iddle2318"></a><a name="iddle2324"></a><a name="iddle3960"></a><a name="iddle4088"></a><a name="iddle5435"></a><a name="iddle5491"></a><a name="iddle6833"></a><a name="iddle6978"></a><a name="iddle7000"></a><a name="iddle8032"></a><a name="iddle8480"></a>If th&#101; object isn't &#97;n instance of <tt>B</tt>, using th&#101; resulting pointer can lead to obscu&#114;e cras&#104;es.</p></li><li><p class="docList"><tt>dyn&#97;mic_cast&lt;T&gt;()</tt> is simil&#97;r to <tt>static_cast&lt;T&gt;()</tt><a name="object associated"></a>, excep&#116; that it uses run-time type informa&#116;ion (RTTI) to check that the object &#97;ssociated with the pointer is an ins&#116;ance of class <tt>B</tt><a name="not the"></a>. If this is not the case, the cast returns a nu&#108;l pointer. F&#111;r e&#120;a&#109;ple:</p><div class="docText"><pre>A *obj = new B;
B *b = dynamic_cast&lt;B *&gt;(obj);
if (b)
    b-&gt;someFunctionDeclaredInB();</pre></div><p class="docList">On some c&#111;mpilers, <tt>dy&#110;amic_cast&lt;T&gt;()</tt><a name="dynamic library"></a> doesn't work &#97;cross dynamic library boundaries. It &#97;lso relie&#115; on the c&#111;mpiler sup&#112;orting RTTI, &#97; feature that programmers &#99;an turn off to reduce the size of their exe&#99;utables. Qt solves these problems &#98;y providing <tt>qobject_cast&lt;T&gt;()</tt><a name="for"></a> for <tt>QObject</tt> subclasses.</p></li><li><p class="docList"><tt>const_cast&lt;T&gt;()</tt><a name="removes a"></a> ad&#100;s &#111;r r&#101;mo&#118;es a <tt>const</tt><a name="to a"></a> q&#117;alifier to a p&#111;inter or refere&#110;ce. For example:</p><div class="docText"><pre>int MyClass::someConstFunction() const
{
    if (isDirty()) {
        MyClass *that = const_cast&lt;MyClass *&gt;(this);
        that-&gt;recomputeInternalData();
    }
    ...
}</pre></div><p class="docList">In the previous examp&#108;e, we cast aw&#97;y the <tt>cons&#116;</tt> qualifier o&#102; the <tt>this</tt> poin&#116;er to call the non-const member funct&#105;on <tt>recomputeInternalData()</tt><a name="avoided by"></a>. Doing so is not &#114;ecommended and can normally be avoided b&#121; using the <tt>mutable</tt> keyword, as explained in <a class="docLink" href="ch04.html#ch04">Chapter 4</a>.</p></li><li><p class="docList"><tt>reinterpret_c&#97;st&lt;T&gt;()</tt><a name="type to"></a> conve&#114;ts any &#112;oin&#116;er or ref&#101;renc&#101; type to any other s&#117;ch type. For example:</p><div class="docText"><pre>short j = 0x1234;
if (reinterpret_cast&lt;char &amp;&gt;(j) == 0x12)
    std::cout &lt;&lt; "The byte order is big-endian" &lt;&lt; std::endl;</pre></div></li></ul>
<p class="docText"><a name="an"></a>In Java and C#, any refere&#110;c&#101; ca&#110; be st&#111;red a&#115; an <tt>Object</tt><a name="it provides"></a> reference if needed. C++ &#100;oesn't have any universal base class, b&#117;t it provides a special data type, <tt>void *</tt>, that s&#116;ores the address of an instance of any type. A <tt>void *</tt> must be cast b&#97;ck to anot&#104;er typ&#101; (us&#105;ng <tt>stat&#105;c_cast&lt;T&gt;()</tt>) before it ca&#110; be used.</p>
<p class="docText"><a name="we don"></a>C++ &#112;rovides many ways to ca&#115;t types, &#98;ut most of t&#104;e time we don't even n&#101;ed a cast. When &#117;sing container classes such as <tt>vector&lt;T&gt;</tt> &#111;r <tt>QVector&lt;T&gt;</tt><a name="the"></a>, we can speci&#102;y the <tt>T</tt><a name="extract items"></a> type and extract items without cas&#116;s. In addition, for primitive types, certain conversions occ&#117;r implici&#116;ly (e.g., fro&#109; <tt>char</tt><a name="to"></a> to <tt>int</tt><a name="custom types"></a>), a&#110;d &#102;or custom type&#115; <a name="iddle1029"></a><a name="iddle2681"></a><a name="iddle3756"></a><a name="iddle3966"></a><a name="iddle3967"></a><a name="iddle4183"></a><a name="iddle4188"></a><a name="iddle4203"></a><a name="iddle4370"></a><a name="iddle7757"></a><a name="iddle7775"></a><a name="iddle7779"></a><a name="can define"></a>we can define &#105;mplicit conversions by providing &#97; one-param&#101;te&#114; constructor. &#70;or examp&#108;e:</p>
<div class="docText"><pre>class MyInteger
{
public:
    MyInteger();
    MyInteger(int i);
    ...
};

int main()
{
    MyInteger n;
    n = 5;
    ...
}</pre></div><br />
<p class="docText"><a name="disable it"></a>For some one-parameter constr&#117;ctors, the automatic conversion makes little se&#110;se. We can disable it by declaring the co&#110;structor with the <tt>explicit</tt> keyword:</p>
<div class="docText"><pre>class MyVector
{
public:
    explicit MyVector(int size);
    ...
};</pre></div><br />

<a name="app04lev2sec10"></a>
<h4 id="title-ID0EWUCO" class="docSection2Title">Operator Overloading</h4>
<p class="docText"><a name="that we"></a>C++ allows &#117;s to overl&#111;ad &#102;unc&#116;ions, mea&#110;ing &#116;hat we can decl&#97;re several functions with the same name in the same &#115;cope, as &#108;ong as they &#104;ave differ&#101;nt para&#109;eter lists. In addition, C++ s&#117;pports <span class="docEmphasis">operator overloading</span>—the p&#111;ssibility of assigning special sema&#110;tics to built-in operators (such as <tt>+</tt>, <tt>&lt;&lt;</tt>, and <tt>[]</tt>) when they are u&#115;ed with &#99;ustom types.</p>
<p class="docText"><a name="When we"></a>&#87;e have alr&#101;ad&#121; seen a &#102;ew examples of over&#108;oaded operators. When we used <tt>&lt;&lt;</tt> to output text &#116;o <tt>cout</tt> or <tt>&#99;err</tt><a name="of the"></a>, we didn't &#116;rigger C++'s left-sh&#105;ft operator, but ra&#116;her a special version of the oper&#97;tor that takes an <tt>ostream</tt> object (such as <tt>cout</tt> and <tt>&#99;err</tt><a name="a stream"></a>) on the left side and a string (alternativ&#101;ly, a number or a stream manipulator such as <tt>endl</tt><a name="side and"></a>) on &#116;he right &#115;ide and &#116;hat retu&#114;ns the <tt>&#111;stream</tt><a name="calls in"></a> ob&#106;ect, allowing multiple ca&#108;ls in a row.</p>
<p class="docText"><a name="The beauty"></a>The beauty of operator overload&#105;ng is th&#97;t we can ma&#107;e custom type&#115; behave just like &#98;uilt-in types. To show h&#111;w operator overloading work&#115;, we will overload <tt>+=</tt>, <tt>-=</tt>, <tt>+</tt>, and <tt>-</tt><a name="on"></a> to work on <tt>Po&#105;nt2D</tt> objects:</p>
<div class="docText"><div class="codeSegmentsExpansionLinks">
              Code View:</div><pre class="">#ifndef POINT2D_H
#define POINT2D_H

class Point2D
{
public:
    Point2D();
    Point2D(double x, double y);

    void setX(double x);
    void setY(double y);
    double x() const;
    double y() const;

    Point2D &amp;operator+=(const Point2D &amp;other) {
        xVal += other.xVal;
        yVal += other.yVal;
        return *this;
    }
    Point2D &amp;operator-=(const Point2D &amp;other) {
        xVal -= other.xVal;
        yVal -= other.yVal;
        return *this;
    }

private:
    double xVal;
    double yVal;
};

inline Point2D operator+(const Point2D &amp;a, const Point2D &amp;b)
{
    return Point2D(a.x() + b.x(), a.y() + b.y());
}

inline Point2D operator-(const Point2D &amp;a, const Point2D &amp;b)
{
    return Point2D(a.x() - b.x(), a.y() - b.y());
}

#endif

					  </pre></div><br />
<p class="docText"><a name="iddle8033"></a><a name="can be"></a>Operators can be implemented e&#105;ther as &#109;ember funct&#105;ons or a&#115; global &#102;unctions. In o&#117;r example, we implemented <tt>+=</tt> a&#110;d <tt>-=</tt> as member functions, and <tt>+</tt> and <tt>-</tt> as glob&#97;l functio&#110;s.</p>
<p class="docText">&#84;he <tt>+=</tt> and <tt>-=</tt> ope&#114;ators take a ref&#101;rence to another <tt>Po&#105;nt2D</tt> object and increment or d&#101;crement the <span class="docEmphasis">x</span>- and <span class="docEmphasis">y</span><a name="return"></a>-coordinates of t&#104;e current object based on the other o&#98;ject. They r&#101;tu&#114;n <tt>*this</tt><a name="the current"></a>, &#119;hich denote&#115; a referenc&#101; to the current &#111;bject (<tt>this</tt> is of type <tt>Point2D *</tt><a name="such as"></a>). Return&#105;ng a ref&#101;re&#110;ce al&#108;ows us to write exot&#105;c code such as</p>
<div class="docText"><pre>a += b += c;</pre></div><br />
<p class="docText">The <tt>+</tt> and <tt>-</tt> ope&#114;ators take two parameters and return a <tt>Point2D</tt><a name="existing object"></a> ob&#106;ect by value (not a reference to an existin&#103; object). The <tt>inline</tt><a name="header file"></a> keyword allows us to put these function defi&#110;i&#116;ions in t&#104;e head&#101;r f&#105;le. If the fu&#110;ction's body ha&#100; been longer, we would put a func&#116;ion prot&#111;ty&#112;e in the heade&#114; file and &#116;he function definition (with&#111;ut the <tt>inline</tt> keyword) in a <tt>.c&#112;p</tt> file.</p>
<p class="docText"><a name="iddle2052"></a><a name="iddle3997"></a><a name="iddle6819"></a><a name="iddle8402"></a><a name="snippet shows"></a>The following code snippet shows all four overl&#111;aded operators in action:</p>
<div class="docText"><pre>Point2D alpha(12.5, 40.0);
Point2D beta(77.5, 50.0);

alpha += beta;
beta -= alpha;

Point2D gamma = alpha + beta;
Point2D delta = beta - alpha;</pre></div><br />
<p class="docText"><a name="also invoke"></a>We can also invoke t&#104;e <tt>oper&#97;tor</tt><a name="functions just"></a> funct&#105;ons jus&#116; like any &#111;ther f&#117;nctions:</p>
<div class="docText"><pre>Point2D alpha(12.5, 40.0);
Point2D beta(77.5, 50.0);

alpha.operator+=(beta);
beta.operator-=(alpha);

Point2D gamma = operator+(alpha, beta);
Point2D delta = operator-(beta, alpha);</pre></div><br />
<p class="docText"><a name="in C"></a>Operator overl&#111;ading in C++ is a complex topi&#99;, but we can go &#97; long way w&#105;thout kno&#119;ing all the deta&#105;ls. It is still important to unde&#114;stand the fundamentals of operator overl&#111;ading because several Qt classes (including <tt>&#81;String</tt> and <tt>QVector&lt;T&gt;</tt><a name="this feature"></a>) use this feature to prov&#105;de a sim&#112;le a&#110;d &#109;ore natural &#115;yntax for s&#117;ch operations as conc&#97;tenation and append.</p>

<a name="app04lev2sec11"></a>
<h4 id="title-ID0EN1CO" class="docSection2Title">Value Types</h4>
<p class="docText">Java and C# di&#115;tingui&#115;h betwe&#101;n value types &#97;nd referenc&#101; types.</p>
<ul><li><p class="docText"><span class="docEmphasis">Value types:</span> These a&#114;e primitive types such as <tt>char</tt>, <tt>int</tt>, and <tt>f&#108;oat</tt><a name="created using"></a>, as well as C# structs. What characterizes them is t&#104;at they aren't created using <tt>new</tt><a name="a copy"></a> and the assig&#110;m&#101;nt &#111;pe&#114;ator p&#101;rform&#115; a copy of the value held b&#121; the variable. For examp&#108;e:</p><div class="docText"><pre>int i = 5;
int j = 10;
i = j;</pre></div></li><li><p class="docText"><span class="docEmphasis">Referenc&#101; ty&#112;es:</span> These ar&#101; classes such &#97;s <tt>Integer</tt> (in Java), <tt>String</tt>, and <tt>MyVeryOwn&#67;lass</tt>. Instances are created using <tt>new</tt><a name="to obtain"></a>. The assi&#103;nment operator copies only a reference t&#111; the object; to obtain a deep copy, we must call <tt>clo&#110;e()</tt> (&#105;n Java) o&#114; <tt>Clone()</tt> (&#105;n C#). For e&#120;ample:</p><div class="docText"><pre>Integer i = new Integer(5);
Integer j = new Integer(10);
i = j.clone();</pre></div></li></ul>
<p class="docText"><a name="and those"></a>In C++, all t&#121;pes can be used as &quot;re&#102;erence types&quot;, and &#116;hose tha&#116; are copy&#97;ble can be used as &quot;val&#117;e types&quot; as well. For exam&#112;le, C++ doesn't need any <tt>&#73;nteger</tt> class, because we can use point&#101;rs and <tt>new</tt> as follows:</p>
<div class="docText"><pre>int *i = new int(5);
int *j = new int(10);
*i = *j;</pre></div><br />
<p class="docText"><a name="iddle1235"></a><a name="iddle1785"></a><a name="iddle1882"></a><a name="iddle4174"></a><a name="iddle4368"></a>Unlike Java and C#, C++ t&#114;eats user-defined classes in the same way as buil&#116;-in types:</p>
<div class="docText"><pre>Point2D *i = new Point2D(5, 5);
Point2D *j = new Point2D(10, 10);
*i = *j;</pre></div><br />
<p class="docText"><a name="that our"></a>&#73;f we w&#97;nt to make &#97; C++ class co&#112;yable, we must en&#115;ure that our class has a co&#112;y constructor and an assignm&#101;nt &#111;pe&#114;ator. The copy &#99;onstructor is invok&#101;d when we initialize a&#110; object with another object of the same &#116;ype. C++ provides two equivalent syntaxes for this:</p>
<div class="docText"><pre>Point2D i(20, 20);

Point2D j(i);      // first syntax
Point2D k = i;     // second syntax</pre></div><br />
<p class="docText"><a name="is invoked"></a>The as&#115;ignment operator is invoked when we use the as&#115;ignmen&#116; operato&#114; on an e&#120;i&#115;ting variable:</p>
<div class="docText"><pre>Point2D i(5, 5);
Point2D j(10, 10);
j = i;</pre></div><br />
<p class="docText"><a name="define a"></a>&#87;hen we define a class, the C++ c&#111;mpiler automatically provide&#115; a copy c&#111;ns&#116;ructor and &#97;n assignment &#111;perator that perform &#109;ember-by-member copying. For the <tt>Point2D</tt><a name="this is"></a> cla&#115;s, this is as though we had written the following code in t&#104;e class definition:</p>
<div class="docText"><pre>class Point2D
{
public:
    ...
    Point2D(const Point2D &amp;other)
        : xVal(other.xVal), yVal(other.yVal) { }

    Point2D &amp;operator=(const Point2D &amp;other) {
        xVal = other.xVal;
        yVal = other.yVal;
        return *this;
    }
    ...

private:
    double xVal;
    double yVal;
};</pre></div><br />
<p class="docText"><a name="the default"></a>For some classes, the default copy co&#110;s&#116;ructor a&#110;d &#97;ssignmen&#116; operator are un&#115;uitable. This typic&#97;lly occurs if the class uses dynamic memory. To &#109;ake <a name="iddle1289"></a><a name="iddle2923"></a><a name="iddle2926"></a><a name="iddle4020"></a><a name="iddle4388"></a><a name="class copyable"></a>the clas&#115; copyab&#108;e, we must then i&#109;plement the copy constru&#99;tor and the assignment ope&#114;ator ourselves.</p>
<p class="docText"><a name="the copy"></a>For classes that do&#110;'t need to be copyable, we can disable &#116;he copy constructor and assignment operator by mak&#105;ng them &#112;riv&#97;te. If we ac&#99;identally a&#116;tempt to copy instanc&#101;s of such a clas&#115;, the compiler reports an error. For ex&#97;mple:</p>
<div class="docText"><pre>class BankAccount
{
public:
    ...

private:
    BankAccount(const BankAccount &amp;other);
    BankAccount &amp;operator=(const BankAccount &amp;other);
};</pre></div><br />
<p class="docText"><a name="to be"></a>In Qt, &#109;any classes &#97;re designed t&#111; be used as val&#117;e classes. These have a copy cons&#116;ructor and an assignment ope&#114;ator, and are normally instantiated on the stack wi&#116;hout <tt>new</tt>. This is the case for <tt>QDateTime</tt>, <tt>QImage</tt>, <tt>QString</tt>, and contai&#110;e&#114; class&#101;s s&#117;ch as <tt>QLis&#116;&lt;T&gt;</tt>, <tt>QVector&lt;T&gt;</tt>, and <tt>Q&#77;ap&lt;K, T&gt;</tt>.</p>
<p class="docText">Other classes f&#97;ll in the &quot;reference type&quot; category, not&#97;bly <tt>QObje&#99;t</tt> and its sub&#99;lasses (<tt>QWidget</tt>, <tt>QT&#105;mer</tt>, <tt>QTcpSoc&#107;et</tt>, etc.). These have virtual functions a&#110;d cannot be copied. For example, a <tt>QWidge&#116;</tt> represents a specific window or control on-sc&#114;een. If there are 75 <tt>QWidget</tt><a name="classes are"></a> instances in &#109;emory, there &#97;re also 75 wi&#110;d&#111;ws &#111;r cont&#114;ols on-screen. These cl&#97;sses are typically instantiated using the <tt>n&#101;w</tt> o&#112;era&#116;or.</p>

<a name="app04lev2sec12"></a>
<h4 id="title-ID0EGCDO" class="docSection2Title">Global Variables and Functions</h4>
<p class="docText"><a name="belong to"></a>C++ lets us declare &#102;unctions and &#118;ariables that don't belong to an&#121; classes and that are accessible fr&#111;m any other function. We have se&#101;n several examples of global functions, includi&#110;g <tt>&#109;ain()</tt><a name="thread reentrancy"></a>, the prog&#114;am's en&#116;ry point. &#71;lobal variabl&#101;s are rarer, becau&#115;e they compromise modularity and &#116;hread re&#101;nt&#114;ancy. It is still &#105;mportant &#116;o understand them because you might encoun&#116;er them in code written by reform&#101;d C programmers and other C++ users.</p>
<p class="docText"><a name="global functions"></a>To il&#108;ustrate how global functions and variables work, we will study a small pro&#103;ram t&#104;at pri&#110;t&#115; a list o&#102; 128 pseudo-random &#110;umbers using a quick-&#97;nd-dirty algorithm. The program's source &#99;ode is sprea&#100; o&#118;er two <tt>.cpp</tt> files.</p>
<p class="docText"><a name="source file"></a>The &#102;irst source f&#105;le is <tt>random.cpp</tt>:</p>
<div class="docText"><pre>int randomNumbers[128];

static int seed = 42;

static int nextRandomNumber()
{
    seed = 1009 + (seed * 2011);
    return seed;
}
void populateRandomArray()
{
    for (int i = 0; i &lt; 128; ++i)
        randomNumbers[i] = nextRandomNumber();
}</pre></div><br />
<p class="docText"><a name="iddle1719"></a><a name="iddle2046"></a><a name="iddle2070"></a><a name="iddle2692"></a><a name="iddle2694"></a><a name="iddle7726"></a><a name="iddle7730"></a><a name="The file"></a>Th&#101; file declares two global variables (<tt>random&#78;umbers</tt> and <tt>seed</tt><a name="global functions"></a>) and two global functions (<tt>next&#82;andomNumber()</tt> and <tt>populateRandomArray()</tt><a name="of the"></a>). Two of &#116;he decla&#114;ation&#115; contai&#110; t&#104;e <tt>static</tt> keywo&#114;d; these are vi&#115;ible only within the current comp&#105;lation &#117;nit (<tt>rando&#109;.cpp</tt>) and are said to have <span class="docEmphasis">&#115;tatic linkage</span><a name="unit in"></a>. T&#104;e two others can be accessed from &#97;ny compilation unit in the program; these ha&#118;e <span class="docEmphasis">external linkage</span>.</p>
<p class="docText"><a name="helper functions"></a>Static linkage is ideal for help&#101;r functions and internal variables that should not be use&#100; i&#110; o&#116;her comp&#105;lation &#117;nits. It redu&#99;es the risks of having coll&#105;ding identifiers (global variables with th&#101; sa&#109;e name or glo&#98;al functions &#119;ith the same signatu&#114;e in different compilation &#117;nits) and prevents malicious or o&#116;herwise ill-advised users from accessing the int&#101;rnals of a compilation unit.</p>
<p class="docText">Let's now look at the seco&#110;d &#102;ile, <tt>&#109;ain.cpp</tt><a name="linkage in"></a>, whic&#104; uses t&#104;e two global varia&#98;les declared with exte&#114;nal linkage in <tt>random.cpp</tt>:</p>
<div class="docText"><pre>#include &lt;iostream&gt;

extern int randomNumbers[128];

void populateRandomArray();

int main()
{
    populateRandomArray();
    for (int i = 0; i &lt; 128; ++i)
        std::cout &lt;&lt; randomNumbers[i] &lt;&lt; std::endl;
    return 0;
}</pre></div><br />
<p class="docText"><a name="before we"></a>We &#100;e&#99;lare the ext&#101;rnal variabl&#101;s and &#102;unctions before we call them. T&#104;e external variable declaration (wh&#105;ch makes an external variable visible in the curr&#101;nt compilation unit) for <tt>randomNumbers</tt> starts wit&#104; the <tt>ex&#116;ern</tt> keyw&#111;rd. &#87;ithout <tt>ex&#116;ern</tt><a name="variable"></a>, the comp&#105;ler would think it has to deal w&#105;th a variable <span class="docEmphasis">definition</span><a name="would complain"></a>, and the link&#101;r w&#111;ul&#100; comp&#108;ain because th&#101; same variable is defined i&#110; two compilation units (<tt>random.&#99;pp</tt> and <tt>main.cpp</tt><a name="be declared"></a>). Variables can be declared as man&#121; times as we want, but they may be defined only once. The defini&#116;ion is wh&#97;t causes t&#104;e comp&#105;ler to r&#101;serve spa&#99;e for the variable.</p>
<p class="docText"><a name="The"></a>The <tt>po&#112;ulateRandomArray()</tt><a name="declared using"></a> function is de&#99;lared using &#97; function &#112;rototy&#112;e. The <tt>ex&#116;ern</tt><a name="is optional"></a> keyword is optiona&#108; for functions.</p>
<p class="docText"><a name="in a"></a>Typically, we would put t&#104;e external variable and function decl&#97;rations in a header file and include it in all th&#101; fi&#108;es that nee&#100; t&#104;em:</p>
<div class="docText"><pre>#ifndef RANDOM_H
#define RANDOM_H
extern int randomNumbers[128];

void populateRandomArray();

#endif</pre></div><br />
<p class="docText"><a name="iddle3612"></a><a name="iddle3980"></a><a name="iddle4019"></a><a name="iddle7727"></a>We h&#97;ve already se&#101;n how <tt>static</tt><a name="member variables"></a> can &#98;e used to declare member variables and func&#116;ions tha&#116; are not a&#116;tached to a s&#112;ecific i&#110;stance of the class, and now &#119;e have seen how to use it to declar&#101; functions and variables with static linka&#103;e. There is one more use of the <tt>static</tt><a name="declare a"></a> keyw&#111;rd &#116;hat shou&#108;d be noted i&#110; p&#97;ssing. In C++, we can declar&#101; a local variable s&#116;atic. Such variables are initialized the first &#116;ime the f&#117;nction is &#99;alled and hold their val&#117;e between func&#116;ion invocations. For example:</p>
<div class="docText"><pre>void nextPrime()
{
    static int n = 1;

    do {
        ++n;
    } while (!isPrime(n));

    return n;
}</pre></div><br />
<p class="docText"><a name="except that"></a>Static l&#111;cal variables are similar to global variabl&#101;s, except that they are only visible in&#115;ide the function where they are define&#100;.</p>

<a name="app04lev2sec13"></a>
<h4 id="title-ID0EJIDO" class="docSection2Title">Namespaces</h4>
<p class="docText"><a name="clashes in"></a>N&#97;mespaces &#97;re a mecha&#110;i&#115;m for redu&#99;ing the risks of name clashes in C++ p&#114;ograms. Name clashes are often an issue in &#108;arge progr&#97;ms that us&#101; several third-&#112;arty li&#98;raries. In your own prog&#114;ams, you can choose whether y&#111;u want to use namespaces.</p>
<p class="docText"><a name="namespace around"></a>Typically, we put a namespace a&#114;ound all the declarations in a header file to en&#115;ure tha&#116; the iden&#116;ifiers d&#101;cl&#97;red in that header f&#105;le don't leak into the gl&#111;bal namespace. For example:</p>
<div class="docText"><pre>#ifndef SOFTWAREINC_RANDOM_H
#define SOFTWAREINC_RANDOM_H

namespace SoftwareInc
{
    extern int randomNumbers[128];

    void populateRandomArray();
}

#endif</pre></div><br />
<p class="docText"><a name="have also"></a>(Notice th&#97;t we have a&#108;so renamed &#116;he preproce&#115;sor macro used &#116;o avoid multiple inclusions, reducing the r&#105;sk of a name clash with a header file o&#102; the same name but located in a differe&#110;t directory.)</p>
<p class="docText"><a name="iddle1020"></a><a name="iddle4021"></a><a name="iddle4389"></a><a name="iddle6020"></a><a name="iddle7742"></a><a name="The namespace"></a>The namespace syntax is simil&#97;r to that o&#102; a cl&#97;ss, but it d&#111;es&#110;'t end &#119;ith a semicolon. Here's the ne&#119; <tt>random.cpp</tt> file:</p>
<div class="docText"><pre>#include "random.h"

int SoftwareInc::randomNumbers[128];

static int seed = 42;

static int nextRandomNumber()
{
    seed = 1009 + (seed * 2011);
    return seed;
}

void SoftwareInc::populateRandomArray()
{
    for (int i = 0; i &lt; 128; ++i)
        randomNumbers[i] = nextRandomNumber();
}</pre></div><br />
<p class="docText"><a name="can be"></a>Unlike classes, namespaces can &#98;e &quot;reopened&quot; &#97;t any time. &#70;or examp&#108;e:</p>
<div class="docText"><pre>namespace Alpha
{
    void alpha1();
    void alpha2();
}

namespace Beta
{
    void beta1();
}

namespace Alpha
{
    void alpha3();
}</pre></div><br />
<p class="docText"><a name="makes it"></a>This makes it poss&#105;ble to define hundre&#100;s of classes, located in as many header &#102;iles, as part of a single namespace. Using thi&#115; trick, the Standard C++ library puts all its identif&#105;ers in t&#104;e <tt>std</tt> n&#97;mespace. I&#110; Q&#116;, namespaces are used f&#111;r global-like ide&#110;tifiers such as <tt>Qt::AlignBottom</tt> a&#110;d <tt>&#81;t::y&#101;llow</tt><a name="namespace but"></a>. F&#111;r historic&#97;l reasons, Qt classes do not belong t&#111; any namespace but are prefixed wit&#104; the letter 'Q'.</p>
<p class="docText"><a name="declared in"></a>To refer to an ident&#105;fier declared in a namespace from outside the namespace, we pr&#101;fi&#120; i&#116; with the &#110;a&#109;e of the namespace (an&#100; <tt>::</tt><a name="are aimed"></a>). Alternatively, we can use &#111;ne of the following &#116;hree mec&#104;anism&#115;, which are aime&#100; at reducin&#103; the number of keystrokes w&#101; must type.</p>
<ul><li><p class="docList"><span class="docEmphStrong">We can defi&#110;e a namespace alias:</span></p><div class="docText"><pre>namespace ElPuebloDeLaReinaDeLosAngeles
{
    void beverlyHills();
    void culverCity();
    void malibu();
    void santaMonica();
}

namespace LA = ElPuebloDeLaReinaDeLosAngeles;</pre></div><p class="docList"><a name="iddle3198"></a><a name="iddle4419"></a><a name="iddle8368"></a><a name="iddle8369"></a><a name="used instead"></a>After the alias defi&#110;ition, the alias can be used instead of the orig&#105;nal nam&#101;.</p></li><li><p class="docList"><span class="docEmphStrong">We &#99;an import a s&#105;ngle id&#101;ntifier fr&#111;m a namespace:</span></p><div class="docText"><pre>int main()
{
    using ElPuebloDeLaReinaDeLosAngeles::beverlyHills;

    beverlyHills();
    ...
}</pre></div><p class="docList">The <tt>u&#115;ing</tt><a name="namespace without"></a> declaration allows us to access a given ide&#110;t&#105;fier fr&#111;m a na&#109;espace without &#104;aving to prefix it with the name &#111;f the namespace.</p></li><li><p class="docList"><span class="docEmphStrong"><a name="an entire"></a>We can import an ent&#105;re namespace with a single directive:</span></p><div class="docText"><pre>int main()
{
    using namespace ElPuebloDeLaReinaDeLosAngeles;

    santaMonica();
    malibu();
    ...
}</pre></div><p class="docList"><a name="name clashes"></a>Wi&#116;h this approach, name clashes are more likely to occur. If the com&#112;ile&#114; compl&#97;ins about &#97;n ambiguo&#117;s name (e.g., two classes wi&#116;h the same name defined in &#116;wo different namespaces), we can always qualify the &#105;dentif&#105;er with &#116;he name of the &#110;amespace when &#114;eferring to it.</p></li></ul>

<a name="app04lev2sec14"></a>
<h4 id="title-ID0ECODO" class="docSection2Title">The Preprocessor</h4>
<p class="docText"><a name="The C"></a>The C++ prepr&#111;cessor is a program that convert&#115; a <tt>.cpp</tt><a name="containing"></a> source file containing <tt>#</tt><a name="as"></a> directives (suc&#104; as <tt>#include</tt>, <tt>#ifndef</tt>, and <tt>#endif</tt><a name="directives perform"></a>) into a source file that c&#111;nt&#97;ins no suc&#104; direc&#116;ives. The&#115;e directives per&#102;orm simple text&#117;al operations on the source file, such as condit&#105;onal co&#109;pilation, fi&#108;e inclusion, a&#110;d macro expans&#105;on. Normally, the preproce&#115;sor is invoked automatica&#108;ly by the compiler, but most systems still offer a way to in&#118;oke it alone (often through a <tt>-E</tt> or <tt>/E</tt> compiler option).</p>
<ul><li><p class="docList">The <tt>#i&#110;c&#108;ude</tt><a name="of the"></a> direct&#105;ve expa&#110;d&#115; to the cont&#101;nts of the file spec&#105;fied within angle brackets (<tt>&lt;&gt;</tt>) or doub&#108;e quotes (<tt>""</tt><a name="a standard"></a>), de&#112;end&#105;ng on wheth&#101;r the head&#101;r file is installed at a standa&#114;d location or is part of the curr&#101;nt project. The file name may contai&#110; <tt>..</tt> and <tt>/</tt><a name="For example"></a> (which Windows compilers correctly interpret a&#115; a direc&#116;ory sepa&#114;ator). F&#111;r e&#120;ample:</p><div class="docText"><pre>#include "../shared/globaldefs.h"</pre></div></li><li><p class="docList"><a name="iddle1730"></a><a name="iddle2066"></a><a name="iddle2067"></a><a name="iddle2363"></a><a name="iddle2366"></a><a name="iddle2408"></a><a name="iddle3142"></a><a name="iddle3649"></a><a name="iddle8286"></a>The <tt>#defi&#110;e</tt> directiv&#101; defines a macro. Occurrences of t&#104;e macr&#111; ap&#112;earing afte&#114; the <tt>#define</tt> &#100;irective are re&#112;laced with the macro's defini&#116;ion. For example, the directive</p><div class="docText"><pre>#define PI 3.14159265359</pre></div><p class="docList"><a name="token"></a>tells the preprocess&#111;r to replace all future occurrences of the &#116;oken <tt>PI</tt><a name="compilation unit"></a> i&#110; t&#104;e curr&#101;nt &#99;ompilation unit with t&#104;e token <tt>3.14159265359</tt><a name="clashes with"></a>. To av&#111;id clashes with variable and class names, i&#116; is commo&#110; p&#114;actice to &#103;ive macros all-u&#112;percase names. It is possible to defin&#101; macros that take arguments:</p><div class="docText"><pre>#define SQUARE(x) ((x) * (x))</pre></div><p class="docList"><a name="In the"></a>In the m&#97;cro body, it is good style to surround all occurrenc&#101;s of the parameters with parentheses, as well as the enti&#114;e body, &#116;o avoid p&#114;oblem&#115; with op&#101;rator prece&#100;ence. Af&#116;er all, we want <tt>7 * SQUARE(2 + 3)</tt><a name="to"></a> to expand to <tt>7 * ((2 + 3) * (2 + 3))</tt><a name="to"></a>, not to <tt>7 * 2 + 3 * 2 + 3</tt>.</p><p class="docList"><a name="command line"></a>C++ &#99;ompilers no&#114;mally &#97;llow us to de&#102;ine macros on the &#99;ommand line, using the <tt>-D</tt> or <tt>/D</tt> opt&#105;on. For example:</p><div class="docText"><pre>CC -DPI=3.14159265359 -c main.cpp</pre></div><p class="docList"><a name="the old"></a>Macros were very popula&#114; in the old days, before type&#100;efs, enums, constants, inline functions, and &#116;emplate&#115; were in&#116;roduced. &#78;owadays, th&#101;ir most importa&#110;t role is to protec&#116; header files against multiple inclusions.</p></li><li><p class="docList">Mac&#114;os can &#98;e undefine&#100; at any poin&#116; using <tt>#unde&#102;</tt>:</p><div class="docText"><pre>#undef PI</pre></div><p class="docList"><a name="since the"></a>This is useful if we want to redef&#105;ne a macro, since the prepr&#111;cessor doesn't let us define the same macro twice. &#73;t is also useful to control conditional co&#109;pilation.</p></li><li><p class="docList"><a name="skipped using"></a>Po&#114;tions &#111;f c&#111;de &#99;an be processed or sk&#105;pped using <tt>#if</tt>, <tt>#elif</tt>, <tt>#else</tt>, a&#110;d <tt>#endif</tt>, based on the nume&#114;ic val&#117;e of macro&#115;. For example:</p><div class="docText"><pre>#define NO_OPTIM         0
#define OPTIM_FOR_SPEED  1
#define OPTIM_FOR_MEMORY 2

#define OPTIMIZATION     OPTIM_FOR_MEMORY

...

#if OPTIMIZATION == OPTIM_FOR_SPEED
typedef int MyInt;
#elif OPTIMIZATION == OPTIM_FOR_MEMORY
typedef short MyInt;
#else
typedef long long MyInt;
#endif</pre></div><p class="docList"><a name="iddle2458"></a><a name="iddle3143"></a><a name="iddle3146"></a>In the pr&#101;cedi&#110;g example, only the second <tt>t&#121;pedef</tt> declaration would be proc&#101;ssed by the compiler, resulting in <tt>My&#73;nt</tt> being defined as a synonym for <tt>s&#104;ort</tt>. By &#99;hanging the &#100;e&#102;ini&#116;ion of the <tt>OP&#84;IMIZATION</tt><a name="to be"></a> macro, we get dif&#102;erent programs. If a macro isn'&#116; defined, &#105;ts valu&#101; is taken to b&#101; 0.</p><p class="docList"><a name="conditional compilation"></a>Anoth&#101;r approach to conditional &#99;ompilation is to test whether a macro is defi&#110;ed. This can be done using the using the <tt>&#100;efined()</tt> operator as follows:</p><div class="docText"><pre>#define OPTIM_FOR_MEMORY

...

#if defined(OPTIM_FOR_SPEED)
typedef int MyInt;
#elif defined(OPTIM_FOR_MEMORY)
typedef short MyInt;
#else
typedef long long MyInt;
#endif</pre></div></li><li><p class="docList"><a name="preprocessor recognizes"></a>For convenience, th&#101; pr&#101;pr&#111;ce&#115;sor rec&#111;gnizes <tt>#ifd&#101;f X</tt><a name="and"></a> and <tt>#ifndef X</tt><a name="for"></a> as synonym&#115; for <tt>#if defined(X)</tt> and <tt>#if !defi&#110;e&#100;(X)</tt><a name="protect a"></a>. &#84;o protect &#97; header file against m&#117;ltiple inclusions, we wrap its contents wit&#104; the following idiom:</p><div class="docText"><pre>#ifndef MYHEADERFILE_H
#define MYHEADERFILE_H

...

#endif</pre></div><p class="docList">The first time the &#104;eader file is included, the symb&#111;l <tt>MYHEADERFILE_H</tt> is not defined, s&#111; th&#101; co&#109;piler proce&#115;ses the &#99;ode between <tt>#ifndef</tt> a&#110;d <tt>#endif</tt><a name="is included"></a>. The se&#99;ond and any subsequent times the header file &#105;s inclu&#100;e&#100;, <tt>MYHEADERFILE_&#72;</tt> is defi&#110;ed, so the en&#116;ire <tt>#ifndef ... #endif</tt> block is skipp&#101;d.</p></li><li><p class="docList">The <tt>#error</tt><a name="at compile"></a> directive emits a user-defi&#110;ed error message at compile time. This is oft&#101;n u&#115;ed in co&#110;j&#117;nction wi&#116;h conditional co&#109;pilation to report an impossi&#98;le case. For example:</p><div class="docText"><pre>class UniChar
{
public:
#if BYTE_ORDER == BIG_ENDIAN
    uchar row;
    uchar cell;
#elif BYTE_ORDER == LITTLE_ENDIAN
    uchar cell;
    uchar row;
#else
#error "BYTE_ORDER must be BIG_ENDIAN or LITTLE_ENDIAN"
#endif
};</pre></div></li></ul>
<p class="docText"><a name="iddle1042"></a><a name="iddle1287"></a><a name="iddle1458"></a><a name="iddle2646"></a><a name="iddle3281"></a><a name="iddle3305"></a><a name="iddle4097"></a><a name="iddle4784"></a><a name="iddle5304"></a><a name="iddle5374"></a><a name="iddle5899"></a><a name="iddle7696"></a><a name="alone on"></a>Unlike most oth&#101;r C++ &#99;onstructs, w&#104;ere whitespac&#101; is irrelev&#97;nt, preprocessor directives stand &#97;lone on a line and require no semicolon. Very &#108;ong directives can be split across multiple lines b&#121; ending every line except &#116;he last w&#105;th a bac&#107;slash.</p>


</div></div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app04lev1sec1.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=app04lev1sec3.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>