<html>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<head>
<title>ch05lev1sec4.html</title>
<link rel="STYLESHEET" type="text/css" href="images/css1.css">
<link rel="STYLESHEET" type="text/css" href="images/css2.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec3.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=part02.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<div style=""><div><a name="ch05lev1sec4"></a>

<h3 class="docSection1Title" id="-100000">Double Buffering</h3>
<p class="docText"><a name="iddle2609"></a><a name="iddle2948"></a><a name="iddle3409"></a><a name="iddle4121"></a><a name="iddle4200"></a><a name="iddle4356"></a><a name="iddle5685"></a><a name="iddle6686"></a><a name="iddle6980"></a><a name="Double buffering"></a>&#68;ouble buff&#101;ri&#110;g &#105;s a GUI programming techniq&#117;e that consists of rendering a wid&#103;et to &#97;n off-scre&#101;n p&#105;xmap and c&#111;py&#105;ng the pixmap on&#116;o the display. &#87;ith earlier versions of Q&#116;, this technique was frequently used to eliminate &#102;licker and to provide a snappier user interface.</p>
<p class="docText">&#73;n Qt 4, <tt>QWidget</tt><a name="so we"></a> handles this automatically, s&#111; we &#114;arely &#110;e&#101;d to worry abo&#117;t widgets flickering. Still, explicit &#100;o&#117;ble buffe&#114;ing re&#109;ains beneficial if the wi&#100;g&#101;t's render&#105;ng is complex and is n&#101;eded repeatedly. We c&#97;n then store a pixmap permanently with the widg&#101;t, always ready for the next paint event, an&#100; copy the pixmap to the widget wheneve&#114; we rec&#101;iv&#101; a p&#97;int event. It is especial&#108;y helpful when we want to make small mo&#100;i&#102;ica&#116;ions, suc&#104; as drawing a rubber &#98;and, withou&#116; recomputing the w&#104;ole widg&#101;t's rendering over and over.</p>
<p class="docText"><a name="will round"></a>We &#119;ill round off this chapter by reviewing t&#104;e <tt>Plotter</tt> custom widget shown in <a class="docLink" href="#ch05fig07">Figures 5.7</a> and <a class="docLink" href="#ch05fig09">5.9</a><a name="aspects of"></a>. &#84;his widget uses double buffering and demo&#110;s&#116;rates so&#109;e other aspe&#99;ts of Qt programming, incl&#117;ding keyboard event handli&#110;g, &#109;anual layou&#116;, and coor&#100;ina&#116;e system&#115;.</p>
<a name="ch05fig07"></a><p><center>

<h5 class="docFigureTitle">Figure 5.7. Zo&#111;ming &#105;n on the <tt>Plotter</tt> w&#105;dget</h5>
<p class="docText"><div class="st1"><a target="_blank" href="images/MXJkcjcvYWd0Yy8xMC84bXBlaTlzNzQ5YTk3ZzMzcHBpX290c2gvdHJsYWx0Y3AyZWpnLg--.jpg">[View full size image]</a></div><img border="0" id="" width="500" height="176" src="images/MXJkcjcvYWd0Yy8xMC84bXBlaTlzNzQ5YTk3ZzMzcGkub3RzaC9ncnBqbHRjcDJl.jpg" alt="" /></p>
</center></p><br />
<p class="docText"><a name="needed a"></a>For a real application that nee&#100;ed a graphing or plotting widg&#101;t, rather than creating a custom widget as we are doing here, &#119;e would most &#108;ikely use o&#110;e &#111;f the third p&#97;rty widgets that are available. Fo&#114; examp&#108;e, we might u&#115;e Graph&#80;ak from <a class="docLink" target="_blank" href="http://www.ics.com/">http://www.ics.com/</a>, KD Ch&#97;rt from <a class="docLink" target="_blank" href="http://www.kdab.net/">http://www.kdab.net/</a>, or &#81;wt from <a class="docLink" target="_blank" href="http://qwt.sourceforge.net/">http://qwt.sourceforge.net/</a>.</p>
<p class="docText">&#84;he <tt>Plotter</tt><a name="of coordinates"></a> widg&#101;t displays one or m&#111;re curves specified as vectors of c&#111;ordinates. The user can draw a ru&#98;ber band on the image, and the <tt>Plotter</tt><a name="enclosed by"></a> will zoom in on the area enclo&#115;ed by th&#101; ru&#98;ber band. Th&#101; user draws th&#101; rubber band by clicking a point on th&#101; gr&#97;ph, draggi&#110;g &#116;he mouse to anothe&#114; posit&#105;on with the left m&#111;use bu&#116;ton held down, and releasing the m&#111;use button. Qt provide&#115; the <tt>QRubberBand</tt><a name="it ourselves"></a> class for drawing rubber bands, but here we dr&#97;w it ourselves to have finer control over the look, and to demo&#110;s&#116;rate dou&#98;le bufferi&#110;g.</p>
<p class="docText"><a name="user can"></a>The user can zo&#111;m in repeatedly by d&#114;awing &#97; rubber ba&#110;d &#109;ultiple times, z&#111;om&#105;ng out using the <span class="docEmphRomanAlt">&#90;oom O&#117;t</span> button and then zooming back &#105;n using the <a name="iddle4334"></a><a name="iddle5599"></a><a name="iddle6486"></a><a name="iddle7869"></a><span class="docEmphRomanAlt">Zoom In</span> button. The <span class="docEmphRomanAlt">Zoom &#73;n</span> and <span class="docEmphRomanAlt">Zoom Out</span><a name="they don"></a> buttons appear the firs&#116; time they become available so that they don't clutter the d&#105;splay i&#102; the &#117;ser doesn'&#116; zoom the graph.</p>
<p class="docText"><a name="The"></a>The <tt>Plo&#116;ter</tt><a name="hold the"></a> widget can hold the da&#116;a for any &#110;u&#109;ber of curve&#115;. It also maintains a s&#116;ack of <tt>Pl&#111;tSett&#105;ngs</tt><a name="of which"></a> object&#115;, each of which corresponds to a par&#116;icular zoom level.</p>
<p class="docText">Let's review t&#104;e class, starting with <tt>plotter.h</tt>:</p>
<div class="docText"><pre>#ifndef PLOTTER_H
#define PLOTTER_H

#include &lt;QMap&gt;
#include &lt;QPixmap&gt;
#include &lt;QVector&gt;
#include &lt;QWidget&gt;

class QToolButton;
class PlotSettings;

class Plotter : public QWidget
{
    Q_OBJECT

public:
    Plotter(QWidget *parent = 0);

    void setPlotSettings(const PlotSettings &amp;settings);
    void setCurveData(int id, const QVector&lt;QPointF&gt; &amp;data);
    void clearCurve(int id);
    QSize minimumSizeHint() const;
    QSize sizeHint() const;

public slots:
    void zoomIn();
    void zoomOut();</pre></div><br />
<p class="docText"><a name="Qt classes"></a>We start by in&#99;luding the header files for the Qt classes that are used &#105;n the pl&#111;tt&#101;r's &#104;eader file, and forwar&#100;-declaring the classes that &#104;ave po&#105;nters o&#114; refer&#101;nces i&#110; t&#104;e header.</p>
<p class="docText">I&#110; the <tt>Plot&#116;er</tt><a name="for setting"></a> class, we provide three public functio&#110;s for setting up the pl&#111;t, and two public slots for zooming &#105;n and out. We also reimplement <tt>minimumSizeHint()</tt> &#97;nd <tt>sizeHi&#110;t()</tt> &#102;rom <tt>&#81;Widget</tt>. W&#101; store a curve's points as a <tt>&#81;Ve&#99;tor&lt;QPointF&gt;</tt>, &#119;here <tt>QPoint&#70;</tt> is a float&#105;ng-poin&#116; version of <tt>Q&#80;oint</tt>.</p>
<div class="docText"><pre>protected:
    void paintEvent(QPaintEvent *event);
    void resizeEvent(QResizeEvent *event);
    void mousePressEvent(QMouseEvent *event);
    void mouseMoveEvent(QMouseEvent *event);
    void mouseReleaseEvent(QMouseEvent *event);
    void keyPressEvent(QKeyEvent *event);
    void wheelEvent(QWheelEvent *event);</pre></div><br />
<p class="docText"><a name="iddle3762"></a><a name="iddle4315"></a><a name="iddle4326"></a><a name="iddle4332"></a><a name="iddle4333"></a><a name="iddle4336"></a><a name="iddle5585"></a><a name="iddle7596"></a><a name="iddle7597"></a><a name="the"></a>In th&#101; protected section of t&#104;e class, we declare all the <tt>QWidg&#101;t</tt> event handlers that we want to reimplement.</p>
<div class="docText"><pre>private:
    void updateRubberBandRegion();
    void refreshPixmap();
    void drawGrid(QPainter *painter);
    void drawCurves(QPainter *painter);

    enum { Margin = 50 };

    QToolButton *zoomInButton;
    QToolButton *zoomOutButton;
    QMap&lt;int, QVector&lt;QPointF&gt; &gt; curveMap;
    QVector&lt;PlotSettings&gt; zoomStack;
    int curZoom;
    bool rubberBandIsShown;
    QRect rubberBandRect;
    QPixmap pixmap;
};</pre></div><br />
<p class="docText"><a name="we declare"></a>In the priv&#97;te section of the class, we declare a few functions for &#112;ain&#116;ing the w&#105;dget, a c&#111;nstant, and seve&#114;al member variables. The <tt>Marg&#105;n</tt><a name="the graph"></a> const&#97;nt is used &#116;o provid&#101; some spacing ar&#111;un&#100; the grap&#104;.</p>
<p class="docText"><a name="the member"></a>Among the membe&#114; variables is <tt>pixmap</tt> of type <tt>QPi&#120;map</tt><a name="what is"></a>. This variable holds a copy of the whole &#119;idget's rendering, identical to what is shown o&#110;-screen. The plot is always drawn onto this off-sc&#114;een pi&#120;m&#97;p first; th&#101;n the pixmap is copie&#100; onto the wi&#100;g&#101;t.</p>
<div class="docText"><pre>class PlotSettings
{
public:
    PlotSettings();

    void scroll(int dx, int dy);
    void adjust();
    double spanX() const { return maxX - minX; }
    double spanY() const { return maxY - minY; }

    double minX;
    double maxX;
    int numXTicks;
    double minY;
    double maxY;
    int numYTicks;

private:
    static void adjustAxis(double &amp;min, double &amp;max, int &amp;numTicks);
};

#endif</pre></div><br />
<p class="docText"><a name="The"></a>T&#104;e <tt>Plot&#83;etting&#115;</tt><a name="the range"></a> class s&#112;ecifies &#116;he range of t&#104;e <span class="docEmphasis">x</span>- and <span class="docEmphasis">y</span><a name="the number"></a>-axes and &#116;he number of ticks for these axes. <a class="docLink" href="#ch05fig08">Figure 5.8</a> s&#104;ows the correspondence be&#116;ween a <tt>PlotSettings</tt> object and a <tt>Plotter</tt> w&#105;dget.</p>
<a name="ch05fig08"></a><p><center>

<h5 class="docFigureTitle">Fi&#103;ure 5.8. <tt>P&#108;otSetting&#115;</tt>'s member variables</h5>

<p class="docText">
<img border="0" id="" width="204" height="176" src="images/MXJkcjcvYWd0Yy8xMC84bXBlaTlzNzQ5YTk3ZzMzcGlnZmlzaC9mNWk1Z2MwLjA-.jpg" alt="" /></p>


</center></p><br />
<p class="docText"><a name="iddle1275"></a><a name="iddle2447"></a><a name="iddle2667"></a><a name="iddle3518"></a><a name="iddle4249"></a><a name="iddle4337"></a><a name="iddle5759"></a><a name="iddle6580"></a><a name="iddle6582"></a><a name="iddle6601"></a><a name="iddle7128"></a><a name="iddle7131"></a><a name="iddle7322"></a><a name="iddle7510"></a><a name="iddle8546"></a><a name="iddle8572"></a><a name="iddle8597"></a>By conv&#101;ntion, <tt>numXTicks</tt> and <tt>&#110;u&#109;YTicks</tt> are o&#102;f by &#111;ne; if <tt>numXT&#105;cks</tt> is 5, <tt>P&#108;otter</tt> will actually d&#114;aw six tick mark&#115; on the <span class="docEmphasis">x</span>-axis. This simplifies t&#104;e calculations later on.</p>
<p class="docText">Now let's review the imple&#109;entation file:</p>
<div class="docText"><pre>Plotter::Plotter(QWidget *parent)
    : QWidget(parent)
{
    setBackgroundRole(QPalette::Dark);
    setAutoFillBackground(true);
    setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    setFocusPolicy(Qt::StrongFocus);
    rubberBandIsShown = false;

    zoomInButton = new QToolButton(this);
    zoomInButton-&gt;setIcon(QIcon(":/images/zoomin.png"));
    zoomInButton-&gt;adjustSize();
    connect(zoomInButton, SIGNAL(clicked()), this, SLOT(zoomIn()));

    zoomOutButton = new QToolButton(this);
    zoomOutButton-&gt;setIcon(QIcon(":/images/zoomout.png"));
    zoomOutButton-&gt;adjustSize();
    connect(zoomOutButton, SIGNAL(clicked()), this, SLOT(zoomOut()));

    setPlotSettings(PlotSettings());
}</pre></div><br />
<p class="docText">The <tt>setBackgroundRole()</tt> call tells <tt>QWidg&#101;t</tt><a name="color for"></a> to use the &quot;dark&quot; component &#111;f t&#104;e pale&#116;te as the &#99;olor for erasing the widget, inste&#97;d of the &quot;window&quot; comp&#111;ne&#110;t. &#84;his gi&#118;es Qt a default color t&#104;at it c&#97;n use to fill any newly &#114;evealed p&#105;xels when the widget i&#115; resized to a larger size, before <tt>pain&#116;Event()</tt><a name="paint the"></a> even has the chance to paint the new pixels. We al&#115;o need to call <tt>setAutoFillBackground(true)</tt><a name="their parent"></a> to e&#110;a&#98;le this mec&#104;anism. (&#66;y default, child widg&#101;ts inherit the background f&#114;om the&#105;r paren&#116; widget.)</p>
<p class="docText">T&#104;e <tt>setSizePoli&#99;y()</tt> call sets t&#104;e widget's &#115;ize policy to <tt>QS&#105;zePolicy::Expanding</tt><a name="manager that"></a> in both directio&#110;s. This tells any layout manager that is re&#115;ponsible for the widget <a name="iddle1121"></a><a name="iddle2791"></a><a name="iddle2798"></a><a name="iddle3457"></a><a name="iddle3514"></a><a name="iddle4350"></a><a name="iddle4410"></a><a name="iddle4498"></a><a name="iddle5657"></a><a name="iddle5767"></a><a name="iddle6072"></a><a name="iddle6498"></a><a name="iddle6591"></a><a name="iddle6908"></a><a name="iddle6913"></a><a name="iddle7225"></a><a name="iddle7288"></a><a name="iddle7506"></a><a name="iddle7796"></a><a name="iddle7908"></a><a name="iddle8560"></a><a name="iddle8593"></a><a name="can also"></a>that the widget is esp&#101;cially willing to grow, but can also shrink. This set&#116;ing is ty&#112;ica&#108; for widget&#115; that can take up a lot &#111;f screen space. The default is <tt>QSiz&#101;Po&#108;icy::Prefer&#114;ed</tt><a name="both directions"></a> in b&#111;th di&#114;ectio&#110;s, which means t&#104;at the widget prefe&#114;s to be the size of its size hin&#116;, but it can be shrunk to its mini&#109;um size hint or expanded indefinitely if ne&#99;essary.</p>
<p class="docText">The <tt>setFocusPolicy(Qt::StrongFocus)</tt><a name="pressing"></a> call mak&#101;s t&#104;e widg&#101;t a&#99;cept focus by clicking o&#114; by pressing <span class="docEmphRomanAlt">Tab</span><a name="When the"></a>. When the <tt>Plott&#101;r</tt><a name="will receive"></a> h&#97;s focus, it &#119;ill receive &#101;vent&#115; for key &#112;resses. The <tt>P&#108;otter</tt><a name="understands a"></a> widget u&#110;derstands a few keys: <span class="docEmphRomanAlt">+</span> to zoom &#105;n; <span class="docEmphRomanAlt">-</span> to zoom out; and the arrow keys to sc&#114;oll up, down, left, and right.</p>
<a name="ch05fig09"></a><p><center>

<h5 class="docFigureTitle">Figure 5.9. Scrolling the <tt>&#80;lotter</tt> widget</h5>
<p class="docText"><div class="st1"><a target="_blank" href="images/MXJkcjcvYWd0Yy8xMC84bXBlaTlzNzQ5YTk3ZzMzcHBpX290c2gvdHJsYWx0Y3A0ZWpnLg--.jpg">[View full size image]</a></div><img border="0" id="" width="500" height="172" src="images/MXJkcjcvYWd0Yy8xMC84bXBlaTlzNzQ5YTk3ZzMzcGkub3RzaC9ncnBqbHRjcDRl.jpg" alt="" /></p>
</center></p><br />
<p class="docText">Still in the cons&#116;ructor, w&#101; cr&#101;at&#101; two <tt>QTool&#66;utton</tt><a name="zoom in"></a>s, each with an icon. These butto&#110;s &#97;llow the u&#115;er to zo&#111;m in a&#110;d &#111;ut. The but&#116;ons' icons are sto&#114;ed in a resource file, so any applicati&#111;n that uses the <tt>Plotter</tt><a name="in its"></a> widget w&#105;ll need this entry in its <tt>.pro</tt> file:</p>
<div class="docText"><pre>RESOURCES = plotter.qrc</pre></div><br />
<p class="docText"><a name="have used"></a>The reso&#117;rce file is similar to the one we have used for the Spre&#97;dsheet ap&#112;lic&#97;tion:</p>
<div class="docText"><pre>&lt;RCC&gt;
&lt;qresource&gt;
    &lt;file&gt;images/zoomin.png&lt;/file&gt;
    &lt;file&gt;images/zoomout.png&lt;/file&gt;
&lt;/qresource&gt;
&lt;/RCC&gt;</pre></div><br />
<p class="docText">The <tt>a&#100;justSize()</tt><a name="sizes to"></a> calls on the bu&#116;tons set their sizes to be &#116;hat of th&#101;ir &#115;ize hin&#116;s. The buttons are n&#111;t p&#117;t in a layout; instead, &#119;e will position them &#109;anually in the <tt>Plotter</tt><a name="must specify"></a>'s resize ev&#101;nt. Since we are not using any layout&#115;, we must specify the buttons' parent &#101;xplicitly by passing <tt>this</tt><a name="the"></a> to the <tt>QToolButton</tt> constructor.</p>
<p class="docText">T&#104;e call &#116;o <tt>setPlo&#116;Setting&#115;()</tt> at the end completes th&#101; initialization.</p>
<div class="docText"><pre>void Plotter::setPlotSettings(const PlotSettings &amp;settings)
{
    zoomStack.clear();
    zoomStack.append(settings);
    curZoom = 0;
    zoomInButton-&gt;hide();
    zoomOutButton-&gt;hide();
    refreshPixmap();
}</pre></div><br />
<p class="docText"><a name="iddle1557"></a><a name="iddle3046"></a><a name="iddle3048"></a><a name="iddle3293"></a><a name="iddle4354"></a><a name="iddle4355"></a><a name="iddle6527"></a><a name="iddle6620"></a><a name="iddle6638"></a><a name="iddle7434"></a><a name="iddle8330"></a><a name="iddle8463"></a><a name="iddle8736"></a><a name="iddle8737"></a>The <tt>setP&#108;otSetting&#115;()</tt> functi&#111;n i&#115; used to specify &#116;he <tt>PlotS&#101;ttings</tt> to u&#115;e for displayin&#103; the plot. It is called by the <tt>Plott&#101;r</tt><a name="plotter starts"></a> constructor and can be called &#98;y users of the class. The plotter starts out at its defaul&#116; zoom level. Each time the user zooms in, a new <tt>&#80;l&#111;tS&#101;tt&#105;ngs</tt><a name="instance is"></a> instance is created &#97;nd put onto the zoom s&#116;ack. The z&#111;om &#115;tack is &#114;epresent&#101;d b&#121; two me&#109;ber variables:</p>
<ul><li><p class="docList"><tt>z&#111;omStack</tt><a name="different zoom"></a> holds the diff&#101;rent zoom settings as a <tt>QVe&#99;tor&lt;PlotSettings&gt;</tt>.</p></li><li><p class="docList"><tt>curZoom</tt><a name="the current"></a> holds the cur&#114;ent <tt>PlotSettings</tt>'s index in t&#104;e <tt>zoom&#83;tack</tt>.</p></li></ul>
<p class="docText">&#65;fter th&#101; call to <tt>setPlotSetting&#115;()</tt>, the zoom stack contains only one &#101;nt&#114;y, and t&#104;e <span class="docEmphRomanAlt">Zoom &#73;n</span> and <span class="docEmphRomanAlt">Zo&#111;m O&#117;t</span><a name="we call"></a> buttons are hidden. &#84;hese buttons wil&#108; not be shown until we cal&#108; <tt>show()</tt> on them in the <tt>zoomIn()</tt> and <tt>zoom&#79;ut()</tt> slots. (Normally, it is sufficient to call <tt>show()</tt><a name="all the"></a> on the top-le&#118;el widget to show all the children. But when we explicitly call <tt>hi&#100;e()</tt> &#111;n a &#99;hild widget, &#105;t is hidden u&#110;til we call <tt>show()</tt> on it.)</p>
<p class="docText">The call &#116;o <tt>refres&#104;Pixma&#112;()</tt> is n&#101;cessary to &#117;pdate the &#100;isplay. Us&#117;ally, we would call <tt>up&#100;ate()</tt><a name="want to"></a>, but here we do &#116;hings slightly differently because we wan&#116; to keep a <tt>QPixmap</tt> up-to-date at all times. A&#102;ter regenerating the pixmap, <tt>refreshPixm&#97;p()</tt> calls <tt>up&#100;a&#116;e()</tt> to copy &#116;he pixmap onto th&#101; widget.</p>
<div class="docText"><pre>void Plotter::zoomOut()
{
    if (curZoom &gt; 0) {
        --curZoom;
        zoomOutButton-&gt;setEnabled(curZoom &gt; 0);
        zoomInButton-&gt;setEnabled(true);
        zoomInButton-&gt;show();
        refreshPixmap();
   }
}</pre></div><br />
<p class="docText">The <tt>zoom&#79;ut()</tt><a name="is zoomed"></a> slot zoom&#115; out if t&#104;e grap&#104; is zoomed in. It decr&#101;me&#110;ts the cur&#114;ent zoom l&#101;vel and enables the <span class="docEmphRomanAlt">Zoom Out</span><a name="zoomed out"></a> button d&#101;pending on whether t&#104;e graph can be zoomed out any more or n&#111;t. The <span class="docEmphRomanAlt">Zoom In</span><a name="is enabled"></a> button is enabled and shown, and the display &#105;s updat&#101;d w&#105;th a cal&#108; to <tt>refreshPixm&#97;p()</tt>.</p>
<div class="docText"><pre>void Plotter::zoomIn()
{
    if (curZoom &lt; zoomStack.count() - 1) {
        ++curZoom;
        zoomInButton-&gt;setEnabled(curZoom &lt; zoomStack.count() - 1);
        zoomOutButton-&gt;setEnabled(true);
        zoomOutButton-&gt;show();
        refreshPixmap();
    }
}</pre></div><br />
<p class="docText"><a name="iddle1609"></a><a name="iddle3844"></a><a name="iddle3846"></a><a name="iddle4338"></a><a name="iddle4342"></a><a name="iddle4349"></a><a name="iddle4351"></a><a name="iddle5343"></a><a name="iddle6536"></a><a name="iddle6627"></a><a name="iddle7177"></a><a name="iddle7492"></a><a name="iddle7497"></a><a name="the"></a>If the user has previously zoom&#101;d i&#110; a&#110;d &#116;hen out again, t&#104;e <tt>Plot&#83;etting&#115;</tt><a name="for the"></a> for the ne&#120;t zoom level will be in &#116;he zoom stack, and we can zoom &#105;n. (Otherwise, it is still possible to zoom in using a rubber band.)</p>
<p class="docText"><a name="increments"></a>The &#115;lot increments <tt>curZoom</tt><a name="move one"></a> to move one level deeper into th&#101; zo&#111;m s&#116;ack, sets &#116;he <span class="docEmphRomanAlt">Zoom In</span><a name="zoom in"></a> button enab&#108;ed or disabled depending on w&#104;ether &#105;t's poss&#105;ble to z&#111;om in any fu&#114;ther, a&#110;d ena&#98;les and shows the <span class="docEmphRomanAlt">Zoom Ou&#116;</span> button. Again, we call <tt>refreshP&#105;xmap()</tt><a name="the latest"></a> to make the plotter use the latest zoom &#115;ettings.</p>
<div class="docText"><pre>void Plotter::setCurveData(int id, const QVector&lt;QPointF&gt; &amp;data)
{
    curveMap[id] = data;
    refreshPixmap();
}</pre></div><br />
<p class="docText">The <tt>setCurveData()</tt><a name="If a"></a> function sets the curve &#100;ata for a given curve ID. If a curve with the same ID already &#101;xi&#115;ts in <tt>cu&#114;veMap</tt><a name="curve data"></a>, &#105;t is replaced with the new c&#117;rve data; otherwise, the new curve is s&#105;mply in&#115;erted. T&#104;e <tt>curv&#101;Map</tt> mem&#98;er variabl&#101; is of t&#121;pe <tt>QMa&#112;&lt;int, QVector&lt;QPointF&gt; &gt;</tt>.</p>
<div class="docText"><pre>void Plotter::clearCurve(int id)
{
    curveMap.remove(id);
    refreshPixmap();
}</pre></div><br />
<p class="docText">The <tt>cle&#97;rCurve()</tt> function removes the specified cu&#114;ve from the curve map.</p>
<div class="docText"><pre>QSize Plotter::minimumSizeHint() const
{
    return QSize(6 * Margin, 4 * Margin);
}</pre></div><br />
<p class="docText">The <tt>minimumSizeHint()</tt> func&#116;ion is similar to <tt>sizeHint()</tt>. Just as <tt>sizeHint()</tt> specifies a &#119;idget's idea&#108; size, <tt>minim&#117;mSizeHin&#116;()</tt><a name="a widget"></a> specifies a widget's idea&#108; minimum size. A layout never resiz&#101;s a &#119;idget below &#105;ts mini&#109;um size hint.</p>
<p class="docText"><a name="value we"></a>The val&#117;e we retur&#110; is 300 x 200 (since <tt>M&#97;rgin</tt><a name="and some"></a> equals 50) to allow f&#111;r the margin on all four &#115;ides and some space for the pl&#111;t itself. Below that size, the pl&#111;t would be too small to be usefu&#108;.</p>
<div class="docText"><pre>QSize Plotter::sizeHint() const
{
    return QSize(12 * Margin, 8 * Margin);
}</pre></div><br />
<p class="docText"><a name="In"></a>In <tt>sizeHin&#116;()</tt><a name="an "></a>, we retur&#110; a&#110; &quot;ideal&quot; size in p&#114;oportion to the <tt>Margin</tt><a name="and with"></a> co&#110;s&#116;ant and w&#105;th the s&#97;me pleasing 3:2 &#97;spect rat&#105;o we used f&#111;r the <tt>mini&#109;umSizeHint()</tt>.</p>
<p class="docText">This finishes the &#114;eview of the <tt>Plotter</tt>'s public funct&#105;ons and slots. Now let's review the protected event hand&#108;ers.</p>
<div class="docText"><pre>void Plotter::paintEvent(QPaintEvent * /* event */)
{
    QStylePainter painter(this);
    painter.drawPixmap(0, 0, pixmap);

    if (rubberBandIsShown) {
        painter.setPen(palette().light().color());
        painter.drawRect(rubberBandRect.normalized()
                                       .adjusted(0, 0, -1, -1));
    }

    if (hasFocus()) {
        QStyleOptionFocusRect option;
        option.initFrom(this);
        option.backgroundColor = palette().dark().color();
        painter.drawPrimitive(QStyle::PE_FrameFocusRect, option);
    }
}</pre></div><br />
<p class="docText"><a name="iddle1122"></a><a name="iddle1496"></a><a name="iddle1600"></a><a name="iddle2267"></a><a name="iddle2276"></a><a name="iddle2279"></a><a name="iddle2541"></a><a name="iddle2792"></a><a name="iddle2799"></a><a name="iddle3213"></a><a name="iddle3646"></a><a name="iddle3889"></a><a name="iddle4062"></a><a name="iddle4221"></a><a name="iddle4223"></a><a name="iddle4292"></a><a name="iddle4319"></a><a name="iddle4346"></a><a name="iddle4800"></a><a name="iddle4813"></a><a name="iddle5310"></a><a name="iddle5405"></a><a name="iddle5524"></a><a name="iddle5594"></a><a name="iddle5668"></a><a name="iddle5671"></a><a name="iddle5968"></a><a name="iddle5974"></a><a name="iddle5977"></a><a name="iddle5998"></a><a name="iddle6002"></a><a name="iddle6557"></a><a name="iddle6631"></a><a name="iddle6656"></a><a name="iddle6659"></a><a name="iddle6661"></a><a name="iddle7801"></a><a name="iddle8465"></a><a name="iddle8650"></a><a name="iddle8724"></a><a name="page_128"></a>Normally, <tt>paintEvent()</tt><a name="here all"></a> is the place where we perform a&#108;l the drawi&#110;g. &#66;ut here a&#108;l the plot drawing is done b&#101;forehand in <tt>refreshPixma&#112;()</tt><a name="entire plot"></a>, so w&#101; ca&#110; r&#101;nder t&#104;e enti&#114;e plot simply b&#121; copyin&#103; the pixmap onto the widget at &#112;osition (0, 0).</p>
<p class="docText"><a name="top of"></a>If the rubber band is visible, we d&#114;aw it on top of the plot. We use the &quot;l&#105;ght&quot; component from the widget's current color gr&#111;up &#97;s the pen c&#111;lo&#114; to ensure good cont&#114;ast with the &quot;dark&quot; background. &#78;otice that &#119;e draw direc&#116;ly on the &#119;idget, leaving &#116;he off-sc&#114;een pixm&#97;p untouched. U&#115;ing <tt>QRect::normalized()</tt><a name="has positive"></a> ens&#117;res that the rubber band rectangle ha&#115; positive width and height (swapping coordi&#110;ates if necessary), and <tt>adjusted()</tt><a name="pixel to"></a> reduces the size of the &#114;ectan&#103;le by &#111;ne &#112;ixel to allow for its ow&#110; 1-pixel-wide outline.</p>
<p class="docText"><a name="the"></a>If t&#104;e <tt>Plot&#116;er</tt> has fo&#99;us, a focus re&#99;tangle is drawn using t&#104;e widg&#101;t style's <tt>dra&#119;Primitive()</tt> function wi&#116;h <tt>QStyle::PE_FrameFocusR&#101;ct</tt> as its first argument and a <tt>QStyle&#79;ptionFocusRect</tt><a name="based on"></a> object as its second &#97;rgument. The focus rectangle's drawing options are &#105;nitial&#105;zed bas&#101;d o&#110; the <tt>Plotter</tt><a name="widget "></a> widge&#116; (by the <tt>initFrom()</tt><a name="color must"></a> call). The background co&#108;or must be s&#112;eci&#102;ied &#101;xplicitly.</p>
<p class="docText"><a name="we want"></a>Whe&#110; w&#101; want &#116;o paint using the &#99;urrent style, we can either call a <tt>QStyle</tt> f&#117;nction directly, for example,</p>
<div class="docText"><pre>style()-&gt;drawPrimitive(QStyle::PE_FrameFocusRect, &amp;option, &amp;painter,
                          this);</pre></div><br />
<p class="docText">or use a <tt>Q&#83;tylePainter</tt> instead of a normal <tt>QPainter</tt>, as w&#101; have done in <tt>Plotter</tt>, and paint more con&#118;eniently u&#115;ing tha&#116;.</p>
<p class="docText">The <tt>QWid&#103;et::style()</tt><a name="draw the"></a> func&#116;ion returns the style that should b&#101; us&#101;d t&#111; dr&#97;w the widget. I&#110; Q&#116;, a widget style is &#97; subclass of <tt>Q&#83;tyle</tt>. The built-in styles include <tt>&#81;WindowsStyle</tt>, <tt>QWi&#110;dowsXPStyle</tt>, <tt>QWindowsVistaSty&#108;e</tt>, <tt>QMotifStyle</tt>, <tt>QCDEStyle</tt>, <tt>QMacStyle</tt>, <tt>QPlastiqueStyle</tt>, and <tt>Q&#67;leanlook&#115;Style</tt><a name="functions in"></a>. E&#97;ch style r&#101;implement&#115; the virtual functions in <tt>QStyle</tt><a name="the platform"></a> &#116;o perfor&#109; the drawing &#105;n the co&#114;rect way for the p&#108;atform the &#115;tyle is emu&#108;ating. <tt>QStylePainter</tt>'s <tt>&#100;rawPrimitive()</tt> function calls the <tt>QSt&#121;le</tt><a name="be used"></a> function of the same name, which &#99;an be used for drawing &quot;primitive eleme&#110;ts&quot; <a name="iddle1987"></a><a name="iddle2533"></a><a name="iddle2554"></a><a name="iddle3490"></a><a name="iddle3628"></a><a name="iddle3758"></a><a name="iddle3913"></a><a name="iddle4344"></a><a name="iddle4348"></a><a name="iddle4744"></a><a name="iddle6546"></a><a name="iddle6573"></a><a name="iddle6603"></a><a name="iddle6891"></a><a name="iddle7337"></a><a name="iddle7800"></a><a name="iddle7812"></a><a name="iddle7857"></a><a name="iddle8601"></a><a name="usually the"></a>such as panels, buttons, and focus rectan&#103;les. T&#104;e widg&#101;t s&#116;yle is usually the same for all &#119;idgets in an application (<tt>QApplica&#116;ion::styl&#101;()</tt><a name="it can"></a>), bu&#116; it can be &#111;verridde&#110; o&#110; a per-w&#105;dget basis usin&#103; <tt>QWidget::setStyle()</tt>.</p>
<p class="docText">By subclas&#115;ing <tt>QStyle</tt><a name="done to"></a>, it is possible to de&#102;ine a custom style. This can be do&#110;e to give a distinctive look to an application or a &#115;uite of &#97;pplicati&#111;ns, &#97;s we will see in <a class="docLink" href="ch19.html#ch19">Chapter 19</a><a name="While it"></a>. W&#104;ile it is generally advisable to use &#116;he targe&#116; platfor&#109;'s native loo&#107; and feel, Qt offers a &#108;ot of flexi&#98;ility if you want to be &#97;dventurous.</p>
<p class="docText"><a name="almost exclusively"></a>Qt's buil&#116;-in widgets rely almost exclusively on <tt>QSty&#108;e</tt><a name="paint themselves"></a> to paint themselves. This is why they look like na&#116;ive widgets on all platforms supported by Qt. C&#117;stom widgets can be made style-aware either by us&#105;ng <tt>QSty&#108;e</tt><a name="child widgets"></a> to paint t&#104;emsel&#118;es or by using built-in Qt w&#105;dgets as child widgets. For <tt>P&#108;otter</tt><a name="both approaches"></a>, we us&#101; a c&#111;mb&#105;nation of b&#111;th &#97;pproaches: The foc&#117;s rectangle is drawn u&#115;ing <tt>QStyle</tt> (via a <tt>QStylePa&#105;nter</tt>), and the <span class="docEmphRomanAlt">Zoom In</span> and <span class="docEmphRomanAlt">Zo&#111;m Out</span> buttons are built-in Qt widgets.</p>
<div class="docText"><pre>void Plotter::resizeEvent(QResizeEvent * /* event */)
{
    int x = width() - (zoomInButton-&gt;width()
                       + zoomOutButton-&gt;width() + 10);
    zoomInButton-&gt;move(x, 5);
    zoomOutButton-&gt;move(x + zoomInButton-&gt;width() + 5, 5);
    refreshPixmap();
}</pre></div><br />
<p class="docText">Whenever t&#104;e <tt>Plotter</tt> widget is resized, Qt generates a &quot;resize&quot; &#101;ve&#110;t. &#72;ere, &#119;e reimplement <tt>resize&#69;vent()</tt> to place the <span class="docEmphRomanAlt">Zoom I&#110;</span> a&#110;d <span class="docEmphRomanAlt">&#90;o&#111;m Out</span> buttons &#97;t the top r&#105;ght of the <tt>Plot&#116;er</tt> widget.</p>
<p class="docText">We move t&#104;e <span class="docEmphRomanAlt">Zoom In</span> button and the <span class="docEmphRomanAlt">Zo&#111;m Out</span><a name="and with"></a> button to be side by side, sepa&#114;ated by a 5-pixel gap and with a 5-pixel offset from &#116;he top and right edges of the parent &#119;idget.</p>
<p class="docText"><a name="stay rooted"></a>If we w&#97;nted the b&#117;ttons to s&#116;ay rooted to th&#101; top-left corner, whose co&#111;rd&#105;nates a&#114;e (0, 0), we wo&#117;ld simply have mo&#118;ed them the&#114;e in the <tt>Pl&#111;tter</tt><a name="depend on"></a> c&#111;nstructor. But we want to tr&#97;ck the top-right corner, whose co&#111;rdinates depend on the size &#111;f the widget. Because of this, it's necessary to &#114;eimpl&#101;me&#110;t <tt>&#114;esizeEvent()</tt><a name="to set"></a> and to set t&#104;e buttons' position ther&#101;.</p>
<p class="docText">We &#100;i&#100;n'&#116; set any posi&#116;ions for &#116;he buttons &#105;n the <tt>Plott&#101;r</tt><a name="a widget"></a> constructor. This isn'&#116; a problem, since Qt always generates a resize ev&#101;nt before a widget is shown for the first tim&#101;.</p>
<p class="docText"><a name="An alternative"></a>An alternative to reimplementing <tt>resizeEv&#101;nt()</tt><a name="out the"></a> &#97;nd laying &#111;ut &#116;he child widgets manually would &#104;ave been to use a l&#97;yout mana&#103;er (e.g., <tt>&#81;Gr&#105;dLayout</tt><a name="a layout"></a>). Using a l&#97;yout woul&#100; have been a l&#105;ttle more comp&#108;icated and would have consumed more r&#101;sources; on the other hand, i&#116; would gracefully handle right-to-left layouts, necess&#97;ry for languages such as Arabic and Hebrew.</p>
<p class="docText">A&#116; the end, w&#101; ca&#108;l <tt>refreshP&#105;xmap()</tt> to redraw the pixma&#112; at the new size.</p>
<div class="docText"><pre>void Plotter::mousePressEvent(QMouseEvent *event)
{
    QRect rect(Margin, Margin,
               width() - 2 * Margin, height() - 2 * Margin);

    if (event-&gt;button() == Qt::LeftButton) {
        if (rect.contains(event-&gt;pos())) {
            rubberBandIsShown = true;
            rubberBandRect.setTopLeft(event-&gt;pos());
            rubberBandRect.setBottomRight(event-&gt;pos());
            updateRubberBandRegion();
            setCursor(Qt::CrossCursor);
        }
    }
}</pre></div><br />
<p class="docText"><a name="iddle1841"></a><a name="iddle1956"></a><a name="iddle2529"></a><a name="iddle3897"></a><a name="iddle3906"></a><a name="iddle4205"></a><a name="iddle4343"></a><a name="iddle4731"></a><a name="iddle4738"></a><a name="iddle5667"></a><a name="iddle5670"></a><a name="iddle6540"></a><a name="iddle6585"></a><a name="iddle6807"></a><a name="iddle6922"></a><a name="iddle6981"></a><a name="iddle7176"></a><a name="iddle7278"></a><a name="displaying a"></a>When the user p&#114;esses &#116;he left m&#111;us&#101; button, we st&#97;rt displa&#121;ing a rub&#98;er band. This involv&#101;s setting <tt>rubberB&#97;ndIsShown</tt> to <tt>true</tt>, initializing th&#101; <tt>rubberBandRect</tt><a name="mouse pointer"></a> member variable with the current mo&#117;se pointer position, scheduling a paint event &#116;o paint t&#104;e rubb&#101;r b&#97;nd, and changing the m&#111;use cursor to have a c&#114;ossha&#105;r shape.</p>
<p class="docText">&#84;he <tt>rub&#98;erBandRect</tt> variabl&#101; is &#111;f type <tt>&#81;Rect</tt>. A <tt>QRect</tt> can &#98;e defined either as an (<span class="docEmphasis">x</span>, <span class="docEmphasis">y</span>, <span class="docEmphasis">width</span>, <span class="docEmphasis">height</span>) &#113;uadruple—where (<span class="docEmphasis">x</span>, <span class="docEmphasis">y</span>) is the position o&#102; the top-left corner and <span class="docEmphasis">width</span> x <span class="docEmphasis">height</span><a name="coordinate pair"></a> &#105;s the size of the rectangle—or as a top-left and a bottom-righ&#116; coordin&#97;te pair. He&#114;e, we ha&#118;e used the coordi&#110;ate pair represent&#97;tion. We se&#116; the poin&#116; where th&#101; user c&#108;icked as bo&#116;h the top-left corner &#97;nd the bottom-right &#99;orner. Then we call <tt>updateRubberBandRe&#103;ion()</tt><a name="area covered"></a> to force a repaint of the (ti&#110;y) area covered by the rubber band.</p>
<p class="docText">Qt &#112;rovides two mechanisms for controlling the m&#111;us&#101; cu&#114;sor's s&#104;ape:</p>
<ul><li><p class="docList"><tt>QWidget::setCursor()</tt><a name="mouse hovers"></a> s&#101;ts the cursor shape to use whe&#110; t&#104;e mous&#101; ho&#118;ers over a particular &#119;idget. If no c&#117;rsor is set for a wid&#103;et, the pa&#114;ent widget's cursor is use&#100;. The default for top-level widgets is an ar&#114;ow cursor.</p></li><li><p class="docList"><tt>QApplication::setOverrideCursor()</tt><a name="the cursor"></a> se&#116;s the cursor shape for the entire application, ove&#114;ridin&#103; the c&#117;rsors set &#98;y individual widgets until <tt>rest&#111;reOverrideCursor()</tt> is called.</p></li></ul>
<p class="docText">In <a class="docLink" href="ch04.html#ch04">Chapter 4</a>, we ca&#108;led <tt>QAppli&#99;ation::setOv&#101;rr&#105;deCursor()</tt> w&#105;th <tt>Qt::Wa&#105;tCursor</tt> to cha&#110;ge th&#101; application's cursor to th&#101; standard wait cursor.</p>
<div class="docText"><pre>void Plotter::mouseMoveEvent(QMouseEvent *event)
{
    if (rubberBandIsShown) {
        updateRubberBandRegion();
        rubberBandRect.setBottomRight(event-&gt;pos());
        updateRubberBandRegion();
    }
}</pre></div><br />
<p class="docText"><a name="the left"></a>When the user moves &#116;he mouse cursor while holding down the left button, we fi&#114;st call <tt>updateRubberBandRegion()</tt><a name="to schedule"></a> to schedule a paint event &#116;o repain&#116; the area &#119;here the rub&#98;er band was, then we recompute <tt>rubb&#101;rBandRect</tt><a name="for the"></a> to account for the mo&#117;se move, an&#100; f&#105;nally w&#101; call <tt>updateRu&#98;berBandRe&#103;ion()</tt><a name="second time"></a> a second t&#105;me to <a name="iddle1957"></a><a name="iddle2538"></a><a name="iddle3898"></a><a name="iddle3917"></a><a name="iddle3918"></a><a name="iddle4063"></a><a name="iddle4345"></a><a name="iddle5672"></a><a name="iddle6552"></a><a name="iddle6633"></a><a name="iddle8321"></a><a name="This effectively"></a>repain&#116; the area where the rubber band has moved to. This &#101;ffectively erases the rubber band an&#100; redraws it at the new coordinates.</p>
<p class="docText"><a name="mouse upward"></a>If the u&#115;er moves the mouse upward or leftward, it's likely &#116;hat <tt>rubb&#101;rB&#97;ndRect</tt><a name="left of"></a>'s n&#111;minal bottom-rig&#104;t corner will end up abo&#118;e or to the l&#101;ft &#111;f i&#116;s top-left corner. I&#102; thi&#115; occurs, the <tt>QRect</tt><a name="We used"></a> &#119;ill have a negativ&#101; width or height. We &#117;sed <tt>QRect::normalized()</tt> in <tt>p&#97;intEvent()</tt><a name="to obtain"></a> to ensure that the top-left and bottom-&#114;ight coordinates are adjusted to obt&#97;in a nonne&#103;ativ&#101; wi&#100;th and height.</p>
<div class="docText"><div class="codeSegmentsExpansionLinks">
              Code View:</div><pre class="">void Plotter::mouseReleaseEvent(QMouseEvent *event)
{
    if ((event-&gt;button() == Qt::LeftButton) &amp;&amp; rubberBandIsShown) {
        rubberBandIsShown = false;
        updateRubberBandRegion();
        unsetCursor();

        QRect rect = rubberBandRect.normalized();
        if (rect.width() &lt; 4 || rect.height() &lt; 4)
            return;
        rect.translate(-Margin, -Margin);

        PlotSettings prevSettings = zoomStack[curZoom];
        PlotSettings settings;
        double dx = prevSettings.spanX() / (width() - 2 * Margin);
        double dy = prevSettings.spanY() / (height() - 2 * Margin);
        settings.minX = prevSettings.minX + dx * rect.left();
        settings.maxX = prevSettings.minX + dx * rect.right();
        settings.minY = prevSettings.maxY - dy * rect.bottom();
        settings.maxY = prevSettings.maxY - dy * rect.top();
        settings.adjust();

        zoomStack.resize(curZoom + 1);
        zoomStack.append(settings);
        zoomIn();
    }
}

					  </pre></div><br />
<p class="docText"><a name="the user"></a>Whe&#110; the user releases t&#104;e left &#109;ouse button, &#119;e erase the r&#117;bber band and restor&#101; th&#101; standard arr&#111;w cursor. If th&#101; rubber band is at least 4 x 4, we perf&#111;rm the zoom. If the rubber band is smal&#108;er than that, it's likely that the user clicked the widget by &#109;istake or to give it focus, so we do nothing.</p>
<p class="docText"><a name="is because"></a>The code to perf&#111;rm &#116;he zoom i&#115; a bit co&#109;plicated. This is because we dea&#108; with widget coordinates and plott&#101;r c&#111;or&#100;i&#110;ates at the &#115;ame tim&#101;. Most of the &#119;ork we perform here &#105;s to convert the <tt>rubberBandRect</tt><a name="from widget"></a> from wid&#103;et coordinates to plott&#101;r coordinates. Once we ha&#118;e done the conversion, we call <tt>PlotSettings::adjust()</tt><a name="the numbers"></a> to roun&#100; t&#104;e numb&#101;rs &#97;nd find a sensible num&#98;er of ticks for each axis. <a class="docLink" href="#ch05fig10">Figures 5.10</a> and <a class="docLink" href="#ch05fig11">5.11</a><a name="the process"></a> i&#108;lustrate t&#104;e proc&#101;ss.</p>
<a name="ch05fig10"></a><p><center>

<h5 class="docFigureTitle">&#70;igure 5.10. C&#111;nv&#101;rting the r&#117;bber band from &#119;idget to plotter coordina&#116;es</h5>

<p class="docText">
<img border="0" id="" width="474" height="174" src="images/MXJkcjcvYWd0Yy8xMC84bXBlaTlzNzQ5YTk3ZzMzcGlnZmlzaC9mMGk1Z2MwLjE-.jpg" alt="" /></p>


</center></p><br />
<a name="ch05fig11"></a><p><center>

<h5 class="docFigureTitle"><a name="rubber band"></a>Figure 5.11. Adjusting plotter coordi&#110;ates and zooming in on the rubber &#98;and</h5>

<p class="docText">
<img border="0" id="" width="400" height="148" src="images/MXJkcjcvYWd0Yy8xMC84bXBlaTlzNzQ5YTk3ZzMzcGlnZmlzaC9mMWk1Z2MwLjE-.jpg" alt="" /></p>


</center></p><br />
<p class="docText"><a name="zoom is"></a>Then we perform the zoom. The zoom is achieved by pushi&#110;g &#116;he new <tt>Pl&#111;tS&#101;ttings</tt><a name="zoom stack"></a> that we have j&#117;st calculated on top of the zoom &#115;tack an&#100; c&#97;lling <tt>zoo&#109;In()</tt> to do the job.<a name="iddle2519"></a><a name="iddle3422"></a><a name="iddle3423"></a><a name="iddle4341"></a><a name="iddle6530"></a></p>
<div class="docText"><div class="codeSegmentsExpansionLinks">
              Code View:</div><pre class="">void Plotter::keyPressEvent(QKeyEvent *event)
{
    switch (event-&gt;key()) {
    case Qt::Key_Plus:
        zoomIn();
        break;
    case Qt::Key_Minus:
        zoomOut();
        break;
    case Qt::Key_Left:
        zoomStack[curZoom].scroll(-1, 0);
        refreshPixmap();
        break;
    case Qt::Key_Right:
        zoomStack[curZoom].scroll(+1, 0);
        refreshPixmap();
        break;
    case Qt::Key_Down:
        zoomStack[curZoom].scroll(0, -1);
        refreshPixmap();
        break;
    case Qt::Key_Up:
        zoomStack[curZoom].scroll(0, +1);
        refreshPixmap();
        break;
    default:
        QWidget::keyPressEvent(event);
    }
}

					  </pre></div><br />
<p class="docText"><a name="iddle1155"></a><a name="iddle2071"></a><a name="iddle2095"></a><a name="iddle2560"></a><a name="iddle3880"></a><a name="iddle3923"></a><a name="iddle4352"></a><a name="iddle4353"></a><a name="iddle5248"></a><a name="iddle5718"></a><a name="iddle6483"></a><a name="iddle6639"></a><a name="iddle6646"></a><a name="iddle6982"></a><a name="iddle7054"></a><a name="iddle8331"></a><a name="iddle8344"></a><a name="iddle8537"></a><a name="and the"></a>W&#104;en the &#117;ser presses a &#107;ey and the <tt>Pl&#111;tter</tt> widget has focus, t&#104;e <tt>keyPressEvent()</tt><a name="to six"></a> function is ca&#108;led. We reimplement it here to respond to &#115;ix keys: <span class="docEmphRomanAlt">+</span>, <span class="docEmphRomanAlt">-</span>, <span class="docEmphRomanAlt">Up</span>, <span class="docEmphRomanAlt">Down</span>, <span class="docEmphRomanAlt">Left</span>, and <span class="docEmphRomanAlt">Right</span><a name="the user"></a>. If the user pressed a &#107;ey that we &#97;re not han&#100;l&#105;ng, we call the base class implem&#101;ntation. For simplicity, we igno&#114;e the <span class="docEmphRomanAlt">S&#104;ift</span>, <span class="docEmphRomanAlt">Ct&#114;l</span>, and <span class="docEmphRomanAlt">A&#108;t</span> modifier keys, which &#97;re availa&#98;le through <tt>QKe&#121;Event::&#109;odifiers()</tt>.</p>
<div class="docText"><pre>void Plotter::wheelEvent(QWheelEvent *event)
{
    int numDegrees = event-&gt;delta() / 8;
    int numTicks = numDegrees / 15;

    if (event-&gt;orientation() == Qt::Horizontal) {
        zoomStack[curZoom].scroll(numTicks, 0);
    } else {
        zoomStack[curZoom].scroll(0, numTicks);
    }
    refreshPixmap();
}</pre></div><br />
<p class="docText"><a name="provide only"></a>Wheel event&#115; occur when a mouse wheel is turned. Most mice p&#114;ovide only a vertical wheel, b&#117;t some also have a horizontal wheel. Qt supports both kinds o&#102; whe&#101;l. W&#104;eel ev&#101;nts go to the wi&#100;get that has the focus. &#84;he <tt>del&#116;a()</tt><a name="function returns"></a> functi&#111;n r&#101;turns the &#100;i&#115;tance the whee&#108; was rotated i&#110; eighths of a degree. M&#105;ce typically work in steps of 15 degrees. &#72;ere, we scroll by the requested number of ti&#99;ks by modifying the topmost item on the zoom stack an&#100; u&#112;dat&#101; th&#101; display using <tt>refr&#101;shPixmap()</tt>.</p>
<p class="docText"><a name="common use"></a>The most &#99;ommon use of &#116;he mouse &#119;heel is to sc&#114;oll a scroll bar. Whe&#110; w&#101; use <tt>QS&#99;rollArea</tt> (covered in <a class="docLink" href="ch06.html#ch06">Chapter 6</a><a name="provide scroll"></a>) to p&#114;ovide scroll bars, <tt>QScrollArea</tt><a name="reimplement"></a> handl&#101;s the mouse wheel eve&#110;ts automatically, so we don't &#110;eed to reimplement <tt>wheelEvent()</tt> ourselves.</p>
<p class="docText"><a name="the event"></a>T&#104;is fin&#105;shes th&#101; im&#112;lementation of th&#101; event handlers. Now l&#101;t's &#114;eview &#116;he priva&#116;e functions.</p>
<div class="docText"><pre>void Plotter::updateRubberBandRegion()
{
    QRect rect = rubberBandRect.normalized();
    update(rect.left(), rect.top(), rect.width(), 1);
    update(rect.left(), rect.top(), 1, rect.height());
    update(rect.left(), rect.bottom(), rect.width(), 1);
    update(rect.right(), rect.top(), 1, rect.height());
}</pre></div><br />
<p class="docText">&#84;he <tt>upd&#97;teRubberBand()</tt> func&#116;ion is called from <tt>mo&#117;sePressEvent()</tt>, <tt>mouseMoveEvent()</tt>, and <tt>mou&#115;eReleaseEvent()</tt><a name="four calls"></a> to erase or redraw the rubber b&#97;nd. It consists of four calls to <tt>update()</tt><a name="the four"></a> that schedule &#97; paint event for the four small <a name="iddle1276"></a><a name="iddle2256"></a><a name="iddle2448"></a><a name="iddle2732"></a><a name="iddle3211"></a><a name="iddle4340"></a><a name="iddle4347"></a><a name="iddle5544"></a><a name="iddle5586"></a><a name="iddle6583"></a><a name="iddle6822"></a><a name="iddle7132"></a><a name="iddle8547"></a><a name="band "></a>rectangular areas &#116;hat are c&#111;ve&#114;ed by t&#104;e rubber band (two ver&#116;ical and two horizontal lines).</p>
<div class="docText"><pre>void Plotter::refreshPixmap()
{
    pixmap = QPixmap(size());
    pixmap.fill(this, 0, 0);

    QPainter painter(&amp;pixmap);
    painter.initFrom(this);
    drawGrid(&amp;painter);
    drawCurves(&amp;painter);
    update();
}</pre></div><br />
<p class="docText">Th&#101; <tt>re&#102;res&#104;Pixma&#112;()</tt><a name="redraws the"></a> function redraw&#115; the plo&#116; onto the off-&#115;creen pixmap an&#100; updates the disp&#108;ay. We resize the pixmap to have t&#104;e same size as the widget and fill &#105;t with the widget's erase color. This color is the &quot;da&#114;k&quot; comp&#111;ne&#110;t &#111;f the palette, becau&#115;e of the call to <tt>setBackgroundRole()</tt> in &#116;he <tt>Plott&#101;r</tt> c&#111;ns&#116;ructor. If the &#98;ackground &#105;s a non-soli&#100; brush, <tt>QP&#105;xmap::fill()</tt><a name="pixmap will"></a> needs to know the offset i&#110; the widget where the pi&#120;map will end up to align the brush pattern &#99;orrectly. Here, the pixmap corresponds to the ent&#105;re widg&#101;t, s&#111; we &#115;pecify position (0, 0).</p>
<p class="docText"><a name="Then we"></a>Then &#119;e create a <tt>QPainter</tt><a name="on the"></a> to draw on the pixm&#97;p. The <tt>init&#70;r&#111;m()</tt><a name="sets the"></a> c&#97;ll sets the pa&#105;nter's p&#101;n, background, &#97;nd font to the same o&#110;es as the <tt>Plotter</tt> widget. N&#101;xt, we call <tt>drawGrid()</tt> and <tt>drawCurves()</tt> t&#111; perform the drawing. At the end, w&#101; call <tt>update()</tt><a name="pixmap is"></a> to schedule a paint event for the whol&#101; wi&#100;g&#101;t. T&#104;e pixmap is copied t&#111; the widget i&#110; t&#104;e <tt>pain&#116;Event()</tt> fu&#110;ction (p. <a class="docLink" href="#page_128">128</a>).</p>
<div class="docText"><div class="codeSegmentsExpansionLinks">
              Code View:</div><pre class="">void Plotter::drawGrid(QPainter *painter)
{
    QRect rect(Margin, Margin,
               width() - 2 * Margin, height() - 2 * Margin);
    if (!rect.isValid())
        return;

    PlotSettings settings = zoomStack[curZoom];
    QPen quiteDark = palette().dark().color().light();
    QPen light = palette().light().color();

    for (int i = 0; i &lt;= settings.numXTicks; ++i) {
         int x = rect.left() + (i * (rect.width() - 1)
                                  / settings.numXTicks);
         double label = settings.minX + (i * settings.spanX()
                                           / settings.numXTicks);
         painter-&gt;setPen(quiteDark);
         painter-&gt;drawLine(x, rect.top(), x, rect.bottom());
         painter-&gt;setPen(light);
         painter-&gt;drawLine(x, rect.bottom(), x, rect.bottom() + 5);
         painter-&gt;drawText(x - 50, rect.bottom() + 5, 100, 20,
                              Qt::AlignHCenter | Qt::AlignTop,
                              QString::number(label));
    }
    for (int j = 0; j &lt;= settings.numYTicks; ++j) {
        int y = rect.bottom() - (j * (rect.height() - 1)
                                   / settings.numYTicks);
        double label = settings.minY + (j * settings.spanY()
                                          / settings.numYTicks);
        painter-&gt;setPen(quiteDark);
        painter-&gt;drawLine(rect.left(), y, rect.right(), y);
        painter-&gt;setPen(light);
        painter-&gt;drawLine(rect.left() - 5, y, rect.left(), y);
        painter-&gt;drawText(rect.left() - Margin, y - 10, Margin - 5, 20,
                             Qt::AlignRight | Qt::AlignVCenter,
                             QString::number(label));
    }
    painter-&gt;drawRect(rect.adjusted(0, 0, -1, -1));
}

					  </pre></div><br />
<p class="docText"><a name="iddle1137"></a><a name="iddle2250"></a><a name="iddle2286"></a><a name="iddle2805"></a><a name="iddle4339"></a><a name="iddle5035"></a><a name="iddle5538"></a>The <tt>&#100;r&#97;wGrid()</tt><a name="the curves"></a> function draws t&#104;e grid behind the c&#117;rves and the axes. The area on which w&#101; draw the grid is specified by <tt>rect</tt><a name="return immediately"></a>. If th&#101; widget isn't large enoug&#104; to accommodate the graph, we return immedia&#116;ely.</p>
<p class="docText">The f&#105;rst <tt>for</tt><a name="the ticks"></a> &#108;oop draws t&#104;e grid's vertical lines an&#100; the ticks along the <span class="docEmphasis">x</span>-axi&#115;. The sec&#111;nd <tt>&#102;or</tt><a name="along the"></a> l&#111;op dr&#97;ws the gri&#100;'s horizo&#110;tal lines an&#100; the ticks along the <span class="docEmphasis">y</span><a name="the end"></a>-axi&#115;. At the end, we draw a rectangle along the m&#97;rgins. The <tt>drawText()</tt><a name="tick marks"></a> function is used to draw the nu&#109;bers corresponding to the tick marks on both axes.</p>
<p class="docText"><a name="The calls"></a>The ca&#108;ls to <tt>drawT&#101;xt()</tt><a name="following syntax"></a> &#104;ave th&#101; following syntax:</p>
<div class="docText"><pre>painter-&gt;drawText(<span class="docEmphasis">x</span>, <span class="docEmphasis">y</span>, <span class="docEmphasis">width</span>, <span class="docEmphasis">height</span>, <span class="docEmphasis">alignment</span>, <span class="docEmphasis">text</span>);</pre></div><br />
<p class="docText">where (<span class="docEmphasis"><tt>&#120;</tt></span>, <span class="docEmphasis"><tt>y</tt></span>, <span class="docEmphasis"><tt>width</tt></span>, <span class="docEmphasis"><tt>height</tt></span><a name="a rectangle"></a>) define &#97; rectangl&#101;, <span class="docEmphasis"><tt>al&#105;gnment</tt></span> &#116;he position of th&#101; te&#120;t within that r&#101;ctangle, and <span class="docEmphasis"><tt>t&#101;xt</tt></span><a name="rectangle in"></a> the text to draw. In this e&#120;ample, we have calculated the rectang&#108;e in which to draw the text manually; a more adaptable alt&#101;rnative would involve calculating t&#104;e text'&#115; boundi&#110;g &#114;ectangle using <tt>QFon&#116;Metrics</tt>.</p>
<div class="docText"><div class="codeSegmentsExpansionLinks">
              Code View:</div><pre class="">void Plotter::drawCurves(QPainter *painter)
{
    static const QColor colorForIds[6] = {
        Qt::red, Qt::green, Qt::blue, Qt::cyan, Qt::magenta, Qt::yellow
    };
    PlotSettings settings = zoomStack[curZoom];
    QRect rect(Margin, Margin,
               width() - 2 * Margin, height() - 2 * Margin);
    if (!rect.isValid())
        return;

    painter-&gt;setClipRect(rect.adjusted(+1, +1, -1, -1));

    QMapIterator&lt;int, QVector&lt;QPointF&gt; &gt; i(curveMap);
    while (i.hasNext()) {
        i.next();

        int id = i.key();
        QVector&lt;QPointF&gt; data = i.value();
        QPolygonF polyline(data.count());
        for (int j = 0; j &lt; data.count(); ++j) {
            double dx = data[j].x() - settings.minX;
            double dy = data[j].y() - settings.minY;
            double x = rect.left() + (dx * (rect.width() - 1)
                                         / settings.spanX());
            double y = rect.bottom() - (dy * (rect.height() - 1)
                                           / settings.spanY());
            polyline[j] = QPointF(x, y);
        }
        painter-&gt;setPen(colorForIds[uint(id) % 6]);
        painter-&gt;drawPolyline(polyline);
    }
}

					  </pre></div><br />
<p class="docText"><a name="iddle1619"></a><a name="iddle2273"></a><a name="iddle3414"></a><a name="iddle4328"></a><a name="iddle4331"></a><a name="iddle4382"></a><a name="iddle5530"></a><a name="iddle5557"></a><a name="iddle7048"></a><a name="iddle7141"></a><a name="iddle8385"></a>The <tt>drawCurves()</tt><a name="top of"></a> function draw&#115; the cur&#118;es on top of &#116;he grid. W&#101; start by call&#105;ng <tt>setC&#108;ipRect()</tt> to set t&#104;e <tt>QPaint&#101;r</tt><a name="the margins"></a>'s clip region to the re&#99;tangle that contains the curves (excluding &#116;he margins and the frame around the graph). <tt>QPa&#105;nter</tt><a name="pixels outside"></a> will then ignore drawing operations on pixels outside the &#97;rea.</p>
<p class="docText"><a name="and for"></a>Next, w&#101; it&#101;ra&#116;e over all the curves using a Jav&#97;-style iterator, and for e&#97;ch curve, w&#101; it&#101;ra&#116;e over its consti&#116;uent <tt>QPo&#105;ntF</tt><a name="call the"></a>s. We call the iter&#97;tor's <tt>key()</tt> function to &#114;etrieve the curve's ID, and its <tt>value()</tt> f&#117;nction to retrieve the corresponding curv&#101; data as a <tt>QVector&lt;QPointF&gt;</tt>. The inner <tt>for</tt> l&#111;op converts each <tt>QPointF</tt><a name="the"></a> from plotter coor&#100;i&#110;a&#116;es to wid&#103;et coordinates a&#110;d stores them in the <tt>poly&#108;ine</tt> variab&#108;e.</p>
<p class="docText"><a name="Once we"></a>Once we ha&#118;e converte&#100; all the point&#115; of a cur&#118;e to widget coordinates, &#119;e set the pen color for the &#99;urve (using one of a set of pr&#101;defined colors) and c&#97;ll <tt>drawPolyline()</tt><a name="a line"></a> to draw a line that goes through all th&#101; curve's points.</p>
<p class="docText"><a name="is the"></a>This is the complete <tt>Plotter</tt> class. &#65;ll that &#114;emain&#115; are a fe&#119; functions in <tt>PlotSetting&#115;</tt>.</p>
<div class="docText"><pre>PlotSettings::PlotSettings()
{
    minX = 0.0;
    maxX = 10.0;
    numXTicks = 5;

    minY = 0.0;
    maxY = 10.0;
    numYTicks = 5;
}</pre></div><br />
<p class="docText">The <tt>PlotSettings</tt><a name="five tick"></a> constructor init&#105;alizes &#98;oth axes to &#116;he range 0 &#116;o 10 with five tick mark&#115;.</p>
<div class="docText"><pre>void PlotSettings::scroll(int dx, int dy)
{
    double stepX = spanX() / numXTicks;
    minX += dx * stepX;
    maxX += dx * stepX;

    double stepY = spanY() / numYTicks;
    minY += dy * stepY;
    maxY += dy * stepY;
}</pre></div><br />
<p class="docText"><a name="iddle1119"></a><a name="iddle1120"></a><a name="iddle4329"></a><a name="iddle4330"></a>The <tt>scr&#111;ll()</tt> func&#116;ion increme&#110;ts (or decrement&#115;) <tt>minX</tt>, <tt>maxX</tt>, <tt>minY</tt>, and <tt>maxY</tt><a name="ticks times"></a> by the interval between &#116;wo ticks times a given number. This function is used to implem&#101;nt scrolling in <tt>Plotter::keyPressEv&#101;nt()</tt>.</p>
<div class="docText"><pre>void PlotSettings::adjust()
{
    adjustAxis(minX, maxX, numXTicks);
    adjustAxis(minY, maxY, numYTicks);
}</pre></div><br />
<p class="docText">&#84;he <tt>adj&#117;st()</tt> functi&#111;n is called from <tt>&#109;ouseReleaseEvent()</tt> to round t&#104;e <tt>minX</tt>, <tt>&#109;axX</tt>, <tt>minY</tt>, and <tt>&#109;axY</tt><a name="ticks appropriate"></a> values t&#111; &quot;nice&quot; values and &#116;o determ&#105;ne the number of ti&#99;ks appropriate for eac&#104; axis. The private function <tt>a&#100;justAxis()</tt><a name="a time"></a> does its work one ax&#105;s at a time.</p>
<div class="docText"><pre>void PlotSettings::adjustAxis(double &amp;min, double &amp;max, int &amp;numTicks)
{
    const int MinTicks = 4;
    double grossStep = (max - min) / MinTicks;
    double step = std::pow(10.0, std::floor(std::log10(grossStep)));

    if (5 * step &lt; grossStep) {
        step *= 5;
    } else if (2 * step &lt; grossStep) {
        step *= 2;
    }

    numTicks = int(std::ceil(max / step) - std::floor(min / step));
    if (numTicks &lt; MinTicks)
        numTicks = MinTicks;
    min = std::floor(min / step) * step;
    max = std::ceil(max / step) * step;
}</pre></div><br />
<p class="docText">The <tt>adjustAxis()</tt> function converts its <tt>min</tt> and <tt>max</tt> par&#97;meters into &quot;nice&quot; numbers and sets its <tt>numTicks</tt><a name="to be"></a> parameter to th&#101; nu&#109;ber of ticks &#105;t calcu&#108;ates to be appropria&#116;e for the given [<tt>min</tt>, <tt>max</tt>] range. Because <tt>a&#100;j&#117;stAxis()</tt><a name="to modify"></a> ne&#101;ds &#116;o modify the actua&#108; variables (<tt>&#109;inX</tt>, <tt>maxX</tt>, <tt>numXTicks</tt>, etc.) a&#110;d no&#116; just copies, its parameters are non-con&#115;t references.</p>
<p class="docText">Most of t&#104;e code in <tt>adjustAxis()</tt><a name="between two"></a> simply attempts to de&#116;ermine an appropriate value for the inte&#114;val be&#116;ween two &#116;icks (the &quot;&#115;tep&quot;). To obtain nice numbers alo&#110;g the axis, we must selec&#116; the step &#119;ith care. For &#101;xa&#109;ple, a step value of 3.8 would &#108;ead to an ax&#105;s with multiples o&#102; 3.8, which is difficu&#108;t for people to relate to. For axe&#115; labeled in decimal notation, &quot;&#110;ice&quot; step values are numbers of the form 10<span class="docEmphasis"><sup>n</sup></span>, 2·10<span class="docEmphasis"><sup>n</sup></span><a name="or "></a>, &#111;r 5·10<span class="docEmphasis"><sup>n</sup></span>.</p>
<p class="docText"><a name="by computing"></a>We start by computing the &quot;gross step&quot;, a kind &#111;f m&#97;ximum for &#116;he step v&#97;lue. Then we find &#116;he corresponding number o&#102; the &#102;orm 10<span class="docEmphasis"><sup>&#110;</sup></span><a name="is smaller"></a> t&#104;at is smaller than o&#114; equal &#116;o the gross step. W&#101; do this by ta&#107;ing the decimal logarithm of the gross &#115;tep, rounding that value down to a w&#104;ole number, then raising 10 to the power of this rounde&#100; number. For example, if the gross step is 236, we co&#109;pute log 236 = 2.37291...; the&#110; w&#101; ro&#117;nd it down to 2 and obtain 10<sup>2</sup> = 100 as the c&#97;ndidate step value of the form 10<span class="docEmphasis"><sup>&#110;</sup></span>.</p>
<p class="docText"><a name="use it"></a>O&#110;c&#101; we &#104;ave the fi&#114;st can&#100;ida&#116;e step value, we can us&#101; it to calculate the other t&#119;o candidates: 2·10<span class="docEmphasis"><sup>n</sup></span> and 5·10<span class="docEmphasis"><sup>n</sup></span><a name="two candidates"></a>. For the precedi&#110;g example, the other two candidates a&#114;e 200 and 500. The 500 candidate is larger than the gross step, so we ca&#110;'t &#117;se it. But 200 i&#115; smalle&#114; than 236, so we use 200 for the &#115;tep size in this example.</p>
<p class="docText">I&#116;'s fairly &#101;as&#121; to &#99;alculate <tt>numTicks</tt>, <tt>min</tt>, an&#100; <tt>m&#97;x</tt> from the step val&#117;e. The new <tt>min</tt> value &#105;s obtained by ro&#117;nding the original <tt>min</tt><a name="new"></a> down to the ne&#97;rest multiple of the step, and the new <tt>max</tt><a name="to the"></a> value is obtained by r&#111;unding up to the nearest multiple of the step. &#84;he new <tt>&#110;u&#109;Ticks</tt> is the &#110;umber of intervals betwee&#110; the rounded <tt>m&#105;n</tt> and <tt>ma&#120;</tt> v&#97;lues. For e&#120;ample, if <tt>min</tt> is 240 &#97;nd <tt>max</tt><a name="with five"></a> is 1184 u&#112;on ent&#101;ring &#116;he function, the new range becom&#101;s [200, 1200], with five tick marks.</p>
<p class="docText"><a name="algorithm will"></a>This algorit&#104;m will give suboptimal results in some cases. A more s&#111;phisticated algorithm is described in Paul S. &#72;eck&#98;ert's artic&#108;e &quot;Nice Numb&#101;rs for Graph La&#98;els&quot;, published in <span class="docEmphasis">Graphics Gems</span> (Mo&#114;gan Ka&#117;fmann, 1990).</p>
<p class="docText">Thi&#115; chapte&#114; brings us to th&#101; en&#100; of <a class="docLink" href="part01.html#part01">Part I</a><a name="widget and"></a> of t&#104;e book. It exp&#108;ained how to customize an existin&#103; Qt widget and how to b&#117;ild a widget from the ground up usi&#110;g <tt>QWidget</tt><a name="as the"></a> as the base class. We alre&#97;dy saw how &#116;o lay out &#99;hild widget&#115; using layout managers i&#110; <a class="docLink" href="ch02.html#ch02">Chapter 2</a><a name="will explore"></a>, and we will explore the t&#104;eme fu&#114;ther i&#110; <a class="docLink" href="ch06.html#ch06">Chapter 6</a>.</p>
<p class="docText"><a name="this point"></a>A&#116; this point, &#119;e know enoug&#104; to write comple&#116;e GUI applications u&#115;ing Qt. In <a class="docLink" href="part02.html#part02">Parts II</a> and <a class="docLink" href="part03.html#part03">III</a><a name="we can"></a>, we will explo&#114;e Qt in greater depth so tha&#116; we can make full use of Qt's power.</p>

</div></div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec3.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=part02.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>