<html>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<head>
<title>ch06lev1sec4.html</title>
<link rel="STYLESHEET" type="text/css" href="images/css1.css">
<link rel="STYLESHEET" type="text/css" href="images/css2.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch06lev1sec3.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch06lev1sec5.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<div style=""><div><a name="ch06lev1sec4"></a>
<h3 class="docSection1Title" id="-100000">Scrolling Areas</h3>
<p class="docText"><a name="The"></a>&#84;he <tt>QSc&#114;ollAr&#101;a</tt><a name="a scrollable"></a> c&#108;ass provides a scrolla&#98;le viewport and two scroll bars. If we want to add &#115;croll b&#97;rs to a wid&#103;et, it &#105;s much simpler t&#111; us&#101; a <tt>QScrol&#108;Area</tt><a name="to instantiate"></a> than to in&#115;tantiate our own <tt>QScrollBa&#114;</tt>s and implement the scrolling func&#116;ionality ourselves.</p>
<p class="docText">The way to use <tt>QScrollAr&#101;a</tt> is to call <tt>setWidget()</tt><a name="scroll bars"></a> with the widget to which we want &#116;o add scr&#111;ll &#98;ars. <tt>QScrol&#108;Area</tt><a name="make it"></a> automatically repa&#114;ents the widget to ma&#107;e it a chil&#100; o&#102; the &#118;iewport (accessible thr&#111;ug&#104; <tt>QScrollArea::view&#112;ort()</tt><a name="the"></a>) if it isn'&#116; already. For example, if we want &#115;croll bars around the <tt>IconEditor</tt> widge&#116; we developed in <a class="docLink" href="ch05.html#ch05">Chapter 5</a> (as shown in <a class="docLink" href="#ch06fig11">Figure 6.11</a>), w&#101; can write this:</p>
<div class="docText"><pre>int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    IconEditor *iconEditor = new IconEditor;
    iconEditor-&gt;setIconImage(QImage(":/images/mouse.png"));

    QScrollArea scrollArea;
    scrollArea.setWidget(iconEditor);
    scrollArea.viewport()-&gt;setBackgroundRole(QPalette::Dark);
    scrollArea.viewport()-&gt;setAutoFillBackground(true);
    scrollArea.setWindowTitle(QObject::tr("Icon Editor"));

    scrollArea.show();
    return app.exec();
}</pre></div><br />
<a name="ch06fig11"></a><p><center>

<h5 class="docFigureTitle">Figure 6.11. Resizing a <tt>QSc&#114;ollAr&#101;a</tt></h5>
<p class="docText"><div class="st1"><a target="_blank" href="images/MXJkcjcvYWd0Yy8xMC84bXBlaTlzNzQ5YTk3ZzMzbHBwaW8ub25zaC9zLWlyY2NlaXRkYWx0Z2Fsam1f.jpg">[View full size image]</a></div><img border="0" id="" width="500" height="277" src="images/MXJkcjcvYWd0Yy8xMC84bXBlaTlzNzQ5YTk3ZzMzbHBpb29ucy9oc2ktcmNlY2l0ZGFsanBnbS4-.jpg" alt="" /></p>
</center></p><br />
<p class="docText"><a name="iddle3062"></a><a name="iddle5719"></a><a name="iddle5723"></a><a name="iddle5724"></a><a name="iddle5726"></a><a name="iddle7380"></a><a name="iddle8438"></a><a name="iddle8449"></a>T&#104;e <tt>QScr&#111;llArea</tt> (shown schematic&#97;lly in <a class="docLink" href="#ch06fig12">Figure 6.12</a><a name="size or"></a>) presents the widg&#101;t a&#116; its curr&#101;nt &#115;ize or uses the s&#105;ze hint &#105;f the widg&#101;t hasn't been r&#101;sized yet. By ca&#108;ling <tt>setWidgetResizabl&#101;(true)</tt>, we can tell <tt>QScrollArea</tt><a name="of any"></a> to automatically resize t&#104;e widget to take advantage of any ext&#114;a spac&#101; be&#121;on&#100; its size hint.</p>
<a name="ch06fig12"></a><p><center>

<h5 class="docFigureTitle">&#70;igure 6.12. <tt>QScrollArea</tt>'s cons&#116;ituent w&#105;dgets</h5>

<p class="docText">
<img border="0" id="" width="231" height="168" src="images/MXJkcjcvYWd0Yy8xMC84bXBlaTlzNzQ5YTk3ZzMzcGlnZmlzaC9mMmk2Z2MwLjE-.jpg" alt="" /></p>


</center></p><br />
<p class="docText"><a name="iddle2189"></a><a name="iddle2190"></a><a name="iddle3737"></a><a name="iddle4649"></a><a name="iddle4675"></a><a name="iddle4962"></a><a name="iddle5315"></a><a name="iddle5321"></a><a name="iddle5325"></a><a name="iddle5332"></a><a name="iddle5720"></a><a name="iddle5721"></a><a name="iddle6067"></a><a name="iddle7050"></a><a name="iddle7163"></a><a name="iddle7211"></a><a name="iddle7237"></a><a name="iddle7371"></a><a name="iddle7378"></a><a name="iddle8097"></a><a name="iddle8143"></a><a name="iddle8639"></a><a name="the scroll"></a>B&#121; de&#102;ault, the scro&#108;l bars are d&#105;splayed o&#110;ly wh&#101;n the viewport is small&#101;r than the child widget. We can force th&#101; scroll bars to always be shown by setting scroll bar pol&#105;cies:</p>
<div class="docText"><pre>scrollArea.setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
scrollArea.setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);</pre></div><br />
<p class="docText"><tt>QScrollArea</tt> inherits much of its functionality fr&#111;m <tt>Q&#65;bstrac&#116;ScrollA&#114;ea</tt>. Classes such as <tt>QTe&#120;tEdit</tt> and <tt>QAbstractItemView</tt> (the bas&#101; cl&#97;ss of Qt's i&#116;em view c&#108;asses) derive from <tt>QAbs&#116;ractScr&#111;llArea</tt>, so w&#101; don't &#110;eed to wrap them in a <tt>&#81;ScrollArea</tt> to get scroll b&#97;rs.</p>

</div></div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch06lev1sec3.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch06lev1sec5.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>