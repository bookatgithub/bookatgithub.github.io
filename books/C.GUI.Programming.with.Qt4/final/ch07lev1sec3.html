<html>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<head>
<title>ch07lev1sec3.html</title>
<link rel="STYLESHEET" type="text/css" href="images/css1.css">
<link rel="STYLESHEET" type="text/css" href="images/css2.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch07lev1sec2.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch08.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<div style=""><div><a name="ch07lev1sec3"></a>
<h3 class="docSection1Title" id="-100000">Staying Responsive during Intensive Processing</h3>
<p class="docText"><a name="When we"></a>&#87;hen we cal&#108; <tt>QApplicat&#105;on::exec()</tt><a name="event loop"></a>, &#119;e start Qt's e&#118;ent loop. Qt issues a few events on sta&#114;tup to show and paint the widgets. After th&#97;t, the even&#116; loop is r&#117;nning, constantly &#99;hecking to see w&#104;ether any events have occurred and di&#115;patching these events to <tt>QObj&#101;ct</tt><a name="in the"></a>s in the application.</p>
<p class="docText"><a name="generated and"></a>While one eve&#110;t is being processed, additional &#101;ve&#110;t&#115; may be g&#101;ne&#114;ated and appended to Qt'&#115; event queue. If we spend too much time process&#105;ng a par&#116;icular e&#118;ent, the user inter&#102;ace will become u&#110;responsive. For e&#120;ample, any events generated by the window syste&#109; while the application is saving a file to disk will n&#111;t be processed until the file is saved. During the s&#97;ve, the app&#108;ication wi&#108;l not respo&#110;d &#116;o requests from the wind&#111;w system to repaint itself.</p>
<p class="docText"><a name="multiple threads"></a>O&#110;e &#115;olutio&#110; is to use m&#117;ltiple threads: o&#110;e thread for the applic&#97;tion's user interface and another threa&#100; to perform file saving (or a&#110;y other time-consuming operation). This way, the appli&#99;ation's user &#105;nterfa&#99;e will stay r&#101;sp&#111;nsive while the fi&#108;e is being saved. We will see how to achieve this in <a class="docLink" href="ch14.html#ch14">Chapter 14</a>.</p>
<p class="docText">A simpler &#115;olutio&#110; i&#115; to make freq&#117;ent calls to <tt>QAppli&#99;ation::processEvents()</tt><a name="process any"></a> in the file savi&#110;g code. This function tells Qt to process any pe&#110;ding events, and then returns con&#116;rol to the caller. In fact, <tt>QApplication::exec()</tt> is littl&#101; mo&#114;e than &#97; <tt>while</tt> loo&#112; aro&#117;nd a <tt>processEvents()</tt> function c&#97;ll.</p>
<p class="docText"><a name="iddle2648"></a><a name="iddle4943"></a><a name="iddle5002"></a><a name="iddle5635"></a><a name="iddle5636"></a><a name="iddle5637"></a><a name="iddle5639"></a><a name="iddle7267"></a><a name="iddle7299"></a><a name="iddle7660"></a><a name="iddle8522"></a><a name="iddle8669"></a><a name="the user"></a>Here's an example of how we can keep the user inte&#114;face r&#101;sp&#111;nsive usin&#103; <tt>process&#69;vents()</tt>, based on the file saving c&#111;de for <tt>Spreadsheet</tt> (p. <a class="docLink" href="ch04lev1sec3.html#ch04lev1sec3">84</a>):</p>
<div class="docText"><pre>bool Spreadsheet::writeFile(const QString &amp;fileName)
{
    QFile file(fileName);
    ...
    QApplication::setOverrideCursor(Qt::WaitCursor);
    for (int row = 0; row &lt; RowCount; ++row) {
        for (int column = 0; column &lt; ColumnCount; ++column) {
            QString str = formula(row, column);
            if (!str.isEmpty())
                out &lt;&lt; quint16(row) &lt;&lt; quint16(column) &lt;&lt; str;
        }
        qApp-&gt;processEvents();
    }
    QApplication::restoreOverrideCursor();
    return true;
}</pre></div><br />
<p class="docText"><a name="the user"></a>O&#110;e danger with this approach i&#115; that the user might close the main window while the ap&#112;lic&#97;tion is st&#105;ll savi&#110;g, &#111;r even click <span class="docEmphRomanAlt">File|Save</span><a name="resulting in"></a> a second &#116;ime, resulting in undefined beha&#118;ior. The eas&#105;est sol&#117;tion to this probl&#101;m is to repl&#97;ce</p>
<div class="docText"><pre>qApp-&gt;processEvents();</pre></div><br />
<p class="docText">with</p>
<div class="docText"><pre>qApp-&gt;processEvents(QEventLoop::ExcludeUserInputEvents);</pre></div><br />
<p class="docText">telling Qt to ignore mouse and key &#101;vents.</p>
<p class="docText">Often, we want &#116;o show a <tt>QProgressDialog</tt> while a l&#111;ng-running operation is taking place. <tt>QProgr&#101;ss&#68;ialog</tt><a name="about the"></a> has a &#112;rog&#114;ess ba&#114; that keeps the user infor&#109;ed about the application's progress. <tt>QProgres&#115;Dialog</tt><a name="also provides"></a> &#97;lso provi&#100;es a <span class="docEmphRomanAlt">Cance&#108;</span><a name="allows the"></a> button that allows t&#104;e user to abort the operation. Here'&#115; the code for saving a Spread&#115;heet file using this approach:</p>
<div class="docText"><div class="codeSegmentsExpansionLinks">
              Code View:</div><pre class="">bool Spreadsheet::writeFile(const QString &amp;fileName)
{
    QFile file(fileName);
    ...
    QProgressDialog progress(this);
    progress.setLabelText(tr("Saving %1").arg(fileName));
    progress.setRange(0, RowCount);
    progress.setModal(true);

    for (int row = 0; row &lt; RowCount; ++row) {
        progress.setValue(row);
        qApp-&gt;processEvents();
        if (progress.wasCanceled()) {
            file.remove();
            return false;
        }
        for (int column = 0; column &lt; ColumnCount; ++column) {
            QString str = formula(row, column);
            if (!str.isEmpty())
                out &lt;&lt; quint16(row) &lt;&lt; quint16(column) &lt;&lt; str;
        }
    }
    return true;
}

					  </pre></div><br />
<p class="docText"><a name="iddle2549"></a><a name="iddle2558"></a><a name="iddle2989"></a><a name="iddle3141"></a><a name="iddle4296"></a><a name="iddle4863"></a><a name="iddle5475"></a><a name="iddle5638"></a><a name="iddle6357"></a><a name="iddle7364"></a><a name="iddle8085"></a><a name="iddle8089"></a><a name="iddle8734"></a><a name="create a"></a>We create a <tt>QProgr&#101;ssDialog</tt> with <tt>NumRows</tt> as the total number of steps. Then, for e&#97;ch row, we c&#97;ll <tt>setVal&#117;e()</tt> to updat&#101; th&#101; progress bar. <tt>QProgre&#115;sDialog</tt><a name="value by"></a> automatically computes a percentage by divi&#100;i&#110;g &#116;he current &#112;rogress va&#108;ue by the total number of steps. We &#99;all <tt>QApplication::processEvents()</tt><a name="or any"></a> to process any repa&#105;nt events or any user clicks or key presses (e.&#103;., to allow the user to click <span class="docEmphRomanAlt">Cancel</span>). If the user clicks <span class="docEmphRomanAlt">Cance&#108;</span>, we abort th&#101; sa&#118;e and remov&#101; th&#101; file.</p>
<p class="docText">We don't call <tt>show()</tt> on the <tt>QP&#114;ogressDialog</tt><a name="turns out"></a> because progress dialogs do th&#97;t for them&#115;elves. I&#102; the ope&#114;ation turns out &#116;o be short, presumably because the file t&#111; save is small or because the machine is fast, <tt>&#81;ProgressDialog</tt><a name="itself at"></a> will detect this &#97;nd will not show itself at all.</p>
<p class="docText">In addition to multithreadi&#110;g &#97;nd using <tt>Q&#80;r&#111;gr&#101;ssDialog</tt><a name="dealing with"></a>, there is a complete&#108;y different way of dealing with long-running operations: Ins&#116;ead of pe&#114;formi&#110;g the proce&#115;sing when t&#104;e user requests, we can defe&#114; the processing until the applic&#97;tion is idle. This can work if the processing ca&#110; be safely interrupted and resumed, s&#105;nce we c&#97;nnot pred&#105;ct how l&#111;ng &#116;he application will be idle.</p>
<p class="docText"><a name="approach can"></a>In Qt, this &#97;pproach can be implemented by using a 0-millisecond &#116;imer. The&#115;e timer&#115; time out wheneve&#114; there are no pend&#105;ng events. Here's an exa&#109;ple <tt>timerEvent()</tt> implementation that &#115;hows the idle processing approach:</p>
<div class="docText"><pre>void Spreadsheet::timerEvent(QTimerEvent *event)
{
    if (event-&gt;timerId() == myTimerId) {
        while (step &lt; MaxStep &amp;&amp; !qApp-&gt;hasPendingEvents()) {
            performStep(step);
            ++step;
        }
    } else {
        QTableWidget::timerEvent(event);
    }
}</pre></div><br />
<p class="docText">If <tt>has&#80;endingEvents()</tt> returns <tt>true</tt><a name="processing will"></a>, we stop processing and g&#105;ve cont&#114;ol bac&#107; to Qt. The p&#114;ocess&#105;ng will resume when Qt has hand&#108;ed all its pending events.</p>

</div></div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch07lev1sec2.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch08.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>