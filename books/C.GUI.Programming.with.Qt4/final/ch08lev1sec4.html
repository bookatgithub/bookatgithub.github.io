<html>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<head>
<title>ch08lev1sec4.html</title>
<link rel="STYLESHEET" type="text/css" href="images/css1.css">
<link rel="STYLESHEET" type="text/css" href="images/css2.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch08lev1sec3.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch08lev1sec5.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<div style=""><div><a name="ch08lev1sec4"></a>
<h3 class="docSection1Title" id="-100000">Item-Based Rendering with Graphics View</h3>
<p class="docText"><a name="Drawing using"></a>&#68;rawing usi&#110;g <tt>&#81;Pa&#105;nter</tt><a name="for custom"></a> is &#105;deal for custom widgets and for d&#114;awing one or just a few items. Fo&#114; graph&#105;cs in wh&#105;ch we need t&#111; hand&#108;e anything from a handful up to t&#101;ns of thousands of i&#116;ems, and we want the user to be able to cli&#99;k, drag, and select items, Qt's graphics view classes provide the solut&#105;on we ne&#101;d.</p>
<p class="docText"><a name="graphics view"></a>T&#104;e grap&#104;ics vi&#101;w architecture consists of a sce&#110;e, represented by the <tt>QG&#114;aphic&#115;Scene</tt> c&#108;ass, and items in the scen&#101;, repres&#101;nted by <tt>QGraphic&#115;Item</tt><a name="by showing"></a> subclasses. The scene (along with &#105;ts item) is made visible to users by showing t&#104;em in a view, <a name="iddle1278"></a><a name="iddle2824"></a><a name="iddle2962"></a><a name="iddle4253"></a><a name="iddle4789"></a><a name="iddle5136"></a><a name="iddle8026"></a><a name="iddle8195"></a>represented by the <tt>QGraphic&#115;View</tt><a name="shown in"></a> cl&#97;ss. The sam&#101; sc&#101;ne &#99;an be shown in more than one v&#105;ew—for example, to show different parts of a large sce&#110;e, &#111;r t&#111; show t&#104;e scene un&#100;er different transformat&#105;ons. This is illustrated schematically i&#110; <a class="docLink" href="#ch08fig14">Figure 8.14</a>.</p>
<a name="ch08fig14"></a><p><center>

<h5 class="docFigureTitle">Figure 8.14. One scene can serve multiple vie&#119;s</h5>

<p class="docText">
<img border="0" id="" width="480" height="242" src="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzZmlncGNmaDRnMDgvaTFpcy4-.jpg" alt="" /></p>


</center></p><br />
<p class="docText">Several predefined <tt>QGraphicsItem</tt> su&#98;classes ar&#101; pr&#111;vi&#100;e&#100;, including <tt>QGraphic&#115;LineItem</tt>, <tt>QGraphicsPixmapItem</tt>, <tt>Q&#71;ra&#112;hic&#115;SimpleTextIt&#101;m</tt> (for s&#116;yled plain text), and <tt>QGr&#97;phicsTextItem</tt> (for rich text); see <a class="docLink" href="#ch08fig15">Figure 8.15</a>. We ca&#110; also create our own custom <tt>QGraphic&#115;Item</tt> subclasses, as we will see later in this section.<sup class="docFootnote"><a class="docLink" href="#ch08fn01">[*]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="ch08fn01">[*]</a></sup><a name="scenes as"></a> Qt 4.4 is expec&#116;ed to sup&#112;ort &#97;dding wid&#103;ets t&#111; graphics scenes as thou&#103;h they were graphics items, includi&#110;g &#116;he abili&#116;y to apply tr&#97;nsformations to t&#104;em.</p></blockquote>
<a name="ch08fig15"></a><p><center>

<h5 class="docFigureTitle">Figure 8.15. Graphics view items available &#105;n Qt 4.3</h5>

<p class="docText">
<img border="0" id="" width="415" height="350" src="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzZmlncGNmaDVnMDgvaTFpcy4-.jpg" alt="" /></p>


</center></p><br />
<p class="docText">A <tt>QGraphicsScene</tt><a name="has three"></a> holds a colle&#99;tion of graphics items. A scene has three layer&#115;: a background layer, an item layer, and a foreground l&#97;yer. The ba&#99;kground and &#102;ore&#103;roun&#100; are normally specified &#98;y <tt>QBrush</tt>es, but it is possible to reimplement <tt>&#100;r&#97;wBackgro&#117;nd()</tt> or <tt>drawFo&#114;eground()</tt><a name="a pixmap"></a> &#102;or complete control. If we want t&#111; use a pixmap as a background, &#119;e could simply create a texture <tt>QBrush</tt><a name="that pixmap"></a> based on that pixmap. T&#104;e foreground brush could be set to a semi-&#116;ranspar&#101;nt &#119;hite to give &#97; faded eff&#101;ct, or to be a cross pat&#116;ern to provide a grid overlay.</p>
<p class="docText"><a name="are selected"></a>The scene ca&#110; t&#101;ll &#117;s which items &#104;ave collided, whic&#104; are selected, and which are at &#97; particular point or in a particular regi&#111;n. A scene's graphics items are either t&#111;p-level (the scene is their parent) or children (their pa&#114;ent is &#97;nother it&#101;m). A&#110;y &#116;ransformations applied to an item are &#97;utomatically applied to its children.</p>
<p class="docText"><a name="The graphics"></a>T&#104;e grap&#104;ics vi&#101;w archite&#99;ture provides t&#119;o ways of grouping items. One is to si&#109;ply make an item a child of another item. &#65;nother way is to use a <tt>QGraphicsItemGroup</tt><a name="item to"></a>. Adding an it&#101;m to a group does not cause it to be tr&#97;nsformed &#105;n any wa&#121;; th&#101;se &#103;roups are convenient for handli&#110;g multiple items as though they were a single it&#101;m.</p>
<p class="docText">A <tt>&#81;Gr&#97;phicsView</tt><a name="a widget"></a> is a widget t&#104;at presents a s&#99;ene, providing scroll bars if nece&#115;sary and capable of applying tran&#115;formations that affect how the scene <a name="iddle1870"></a><a name="iddle3355"></a><a name="iddle4155"></a><a name="iddle5148"></a><a name="iddle7035"></a><a name="iddle7372"></a><a name="iddle8446"></a><a name="iddle8450"></a><a name="as aids"></a>is &#114;endered. This is useful to support zooming and r&#111;ta&#116;ing as ai&#100;s &#102;or v&#105;ewing the scene.</p>
<p class="docText">By de&#102;ault, <tt>QGraphicsView</tt><a name="can be"></a> renders using Qt's built-in 2D pa&#105;nt engi&#110;e, &#98;ut it can be changed to us&#101; an OpenGL widge&#116; with a single <tt>setViewport()</tt><a name="to print"></a> &#99;all after it has been constructed. I&#116; is also easy to print a scene, or parts of a scene, as &#119;e will discuss in the next section where we see seve&#114;al tec&#104;nique&#115; for pri&#110;t&#105;ng using Qt.</p>
<p class="docText"><a name="and item"></a>The architecture u&#115;es three different coordinate syst&#101;ms—&#118;iewport co&#111;rdinates, s&#99;ene coordinates, and it&#101;m coordina&#116;es—with functions for mapping from one coordin&#97;te system to another. Viewport coordinates are coordi&#110;ates inside the <tt>QGraphicsView</tt><a name="used for"></a>'s viewport. &#83;cene &#99;oordinates &#97;re logica&#108; coordinat&#101;s that are used for positioni&#110;g top-level items on the scene. Item coor&#100;i&#110;a&#116;es are speci&#102;ic to ea&#99;h item and are centere&#100; about an item-local (0, 0) point; these remain unchan&#103;ed when we move the item on the scen&#101;. In practice, we usually only care about the scene &#99;oordinates (&#102;or p&#111;si&#116;ioning t&#111;p-level items) and item coord&#105;nates (for positioning child items &#97;nd for dra&#119;ing items). Dr&#97;wing each item in t&#101;rms of its o&#119;n local coordinate system &#109;eans that we do not have to worr&#121; about where an item is in the scene or what transfo&#114;mations have been applied to it.</p>
<p class="docText"><a name="view classes"></a>&#84;he gra&#112;hic&#115; view cl&#97;sses are s&#116;raightforward to use and &#111;ffer a great deal of functionalit&#121;. To &#105;ntrodu&#99;e some of what can be do&#110;e with them, we w&#105;ll review two examples. The firs&#116; example is a simple diagram editor, which &#119;ill show <a name="iddle2119"></a><a name="iddle2579"></a><a name="iddle3559"></a><a name="iddle5137"></a><a name="iddle7843"></a><a name="The second"></a>how to create items and how to ha&#110;dle user interaction. The second exa&#109;ple is an ann&#111;ta&#116;ed map pr&#111;gr&#97;m that shows how to handle large numbers of grap&#104;ics objects and how to render them eff&#105;cientl&#121; at &#100;iffer&#101;nt zoom &#108;evels.</p>
<p class="docText"><a name="The Diagram"></a>The Diagram application shown &#105;n <a class="docLink" href="#ch08fig16">Figure 8.16</a><a name="to create"></a> allows users to create no&#100;es and links. Nodes are graphics items that show p&#108;ain text inside a rounded rectangle, whereas links are line&#115; that co&#110;n&#101;ct &#112;air&#115; of nodes. Nodes that are selecte&#100; are shown with a dashed outline drawn w&#105;th a thi&#99;ker pen than &#117;sual. We will begin by l&#111;oking at li&#110;ks, since they are the simpl&#101;st, then nodes, and then we wi&#108;l see how they are used in context.</p>
<a name="ch08fig16"></a><p><center>

<h5 class="docFigureTitle"><a name="The Diagram"></a>Fi&#103;ure 8.16. The Diagram application</h5>
<p class="docText"><div class="st1"><a target="_blank" href="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzZ3BmYWlwY3RoNmcwOC9pMXNsLl9q.jpg">[View full size image]</a></div><img border="0" id="" width="500" height="359" src="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzZmlqcGNnaDZnMDgvaTFwcy4-.jpg" alt="" /></p>
</center></p><br />
<div class="docText"><pre>class Link : public QGraphicsLineItem
{
public:
    Link(Node *fromNode, Node *toNode);
    ~Link();

    Node *fromNode() const;
    Node *toNode() const;

    void setColor(const QColor &amp;color);
    QColor color() const;

    void trackNodes();

private:
    Node *myFromNode;
    Node *myToNode;
};</pre></div><br />
<p class="docText">The <tt>Link</tt> class is deri&#118;ed from <tt>QGr&#97;phicsLin&#101;It&#101;m</tt>, w&#104;ich represents a line i&#110; a <tt>QGraphicsScene</tt><a name="connects and"></a>. A link has three m&#97;in attrib&#117;tes: the tw&#111; node&#115; it connect&#115; and the color used to draw its line. &#87;e don't need a <tt>QColor</tt><a name="for reasons"></a> member variable to &#115;tore the color, for reasons that will become appa&#114;ent shortly. <tt>QGraphicsItem</tt> is not <a name="iddle3560"></a><a name="iddle3561"></a><a name="iddle3562"></a><a name="iddle3563"></a><a name="iddle3946"></a><a name="iddle5127"></a><a name="iddle5129"></a><a name="iddle5437"></a><a name="iddle7149"></a><a name="iddle7222"></a><a name="iddle7394"></a><a name="iddle8172"></a>a <tt>QObject</tt><a name="to"></a> subclas&#115;, but if w&#101; wa&#110;t&#101;d t&#111; add signals and &#115;lots to <tt>Link</tt><a name="using multiple"></a>, there is nothing to stop us fro&#109; using multi&#112;le i&#110;heri&#116;ance with <tt>QObje&#99;t</tt>.</p>
<p class="docText">The <tt>trackNodes()</tt><a name="the user"></a> function i&#115; used to update the line's endpoints, when t&#104;e user drags a connected node into a differen&#116; position.</p>
<div class="docText"><pre>Link::Link(Node *fromNode, Node *toNode)
{
    myFromNode = fromNode;
    myToNode = toNode;

    myFromNode-&gt;addLink(this);
    myToNode-&gt;addLink(this);

    setFlags(QGraphicsItem::ItemIsSelectable);
    setZValue(-1);

    setColor(Qt::darkRed);
    trackNodes();
}</pre></div><br />
<p class="docText"><a name="link is"></a>When a link is constructed, it adds i&#116;self to t&#104;e node&#115; it conn&#101;ct&#115;. Each node holds a set of li&#110;ks, and can have any number of connecting links. G&#114;aphic&#115; items h&#97;ve several flags, but i&#110; this cas&#101; we only want &#108;inks to be selectable so that the user can select an&#100; then delete them.</p>
<p class="docText">Every graphics ite&#109; has an (<span class="docEmphasis">x</span>, <span class="docEmphasis">y</span>) position, and a <span class="docEmphasis">z</span><a name="is in"></a> value that specifies how far forwa&#114;d or ba&#99;k it is in the &#115;cene. Si&#110;c&#101; we are going to draw our line&#115; from the center of one no&#100;e &#116;o the cen&#116;er of another node, &#119;e give the line &#97; negative <span class="docEmphasis">z</span><a name="value so"></a> value so that it will alw&#97;ys be drawn underneat&#104; the nodes it connects. As a result, links w&#105;ll appear as lines between the nearest edges of the node&#115; they co&#110;n&#101;ct.</p>
<p class="docText"><a name="end of"></a>&#65;t the en&#100; of the constructor, we set an init&#105;al line color and then set the line's endpoi&#110;t&#115; by call&#105;ng <tt>trackNodes()</tt>.</p>
<div class="docText"><pre>Link::~Link()
{
    myFromNode-&gt;removeLink(this);
    myToNode-&gt;removeLink(this);
}</pre></div><br />
<p class="docText"><a name="a link"></a>Whe&#110; a link is dest&#114;oyed, it removes itself from the &#110;odes it is connect&#105;ng.</p>
<div class="docText"><pre>void Link::setColor(const QColor &amp;color)
{
    setPen(QPen(color, 1.0));
}</pre></div><br />
<p class="docText"><a name="the given"></a>When the link's color is set, we simply change its pen, usi&#110;g the given color and a line width of 1. The <tt>setPen()</tt> f&#117;nction is &#105;nherit&#101;d f&#114;om <tt>QGr&#97;phicsLineItem</tt>. The <tt>colo&#114;()</tt> getter simply returns the pen's color.</p>
<div class="docText"><pre>void Link::trackNodes()
{
    setLine(QLineF(myFromNode-&gt;pos(), myToNode-&gt;pos()));
}</pre></div><br />
<p class="docText"><a name="iddle4026"></a><a name="iddle4392"></a><a name="iddle4588"></a><a name="iddle4871"></a><a name="iddle5111"></a><a name="iddle5123"></a><a name="iddle5479"></a><a name="iddle7840"></a><a name="iddle8156"></a><a name="iddle8196"></a><a name="page_200"></a>The <tt>QGr&#97;phicsIte&#109;::pos()</tt><a name="its graphics"></a> functio&#110; retu&#114;ns the posi&#116;ion of its graphics item relative to th&#101; scene (for top-leve&#108; items) or to the parent item (for child items).</p>
<p class="docText">For the <tt>Link</tt><a name="the painting"></a> &#99;lass, we can rely on its base class to handle the painting: <tt>QGra&#112;hic&#115;LineIt&#101;m</tt> d&#114;aws a l&#105;ne (using <tt>pen()</tt>) between &#116;wo points in the scene.</p>
<p class="docText">For the <tt>Node</tt><a name="difference between"></a> class, we will handle &#97;ll the gra&#112;hic&#115; ourselves. Another &#100;iffer&#101;nce between nodes a&#110;d links is that nodes are more inte&#114;active. We will begin by reviewing the <tt>Node</tt><a name="it is"></a> &#100;eclaration, breaking it into a few pieces since i&#116; is quite &#108;ong.</p>
<div class="docText"><pre>class Node : public QGraphicsItem
{
    Q_DECLARE_TR_FUNCTIONS(Node)

public:
    Node();</pre></div><br />
<p class="docText">For the <tt>&#78;ode</tt> class, w&#101; us&#101; <tt>QGraphicsItem</tt><a name="base class"></a> as the base c&#108;ass. The <tt>Q_DECLARE_TR_FUNCTIONS()</tt> macro is used to ad&#100; a <tt>&#116;r()</tt> functi&#111;n to th&#105;s class, eve&#110; though it is not a <tt>QObject</tt><a name="use"></a> subcl&#97;ss. This is simply a convenience that allows us to use <tt>tr()</tt><a name="rather than"></a> &#114;ather than the static <tt>QObject::tr()</tt> or <tt>QCoreAppl&#105;cation::translate()</tt>.</p>
<div class="docText"><pre>    void setText(const QString &amp;text);
    QString text() const;
    void setTextColor(const QColor &amp;color);
    QColor textColor() const;
    void setOutlineColor(const QColor &amp;color);
    QColor outlineColor() const;
    void setBackgroundColor(const QColor &amp;color);
    QColor backgroundColor() const;</pre></div><br />
<p class="docText"><a name="are simply"></a>These functions are simply g&#101;tt&#101;rs &#97;nd setter&#115; for the &#112;rivate members. We provide cont&#114;ol of the color of the text, the node's outlin&#101;, an&#100; t&#104;e node's backgr&#111;und.</p>
<div class="docText"><pre>    void addLink(Link *link);
    void removeLink(Link *link);</pre></div><br />
<p class="docText"><a name="we saw"></a>A&#115; we saw earlier, these functions are &#99;alled by the <tt>Link</tt> class to add or remove th&#101;mselves from a node.</p>
<div class="docText"><pre>    QRectF boundingRect() const;
    QPainterPath shape() const;
    void paint(QPainter *painter,
               const QStyleOptionGraphicsItem *option, QWidget *widget);</pre></div><br />
<p class="docText">When we cre&#97;te <tt>QGraphicsItem</tt> subclasses that we want to draw manually, we no&#114;mally &#114;eimpl&#101;me&#110;t <tt>&#98;oundingRect()</tt> and <tt>paint()</tt>. If we don't &#114;eimplement <tt>shape()</tt>, the base class &#105;mpleme&#110;t&#97;tion will fall &#98;ack on the <tt>boun&#100;ingRect()</tt>. In thi&#115; case, we have reimplemented <tt>s&#104;ape()</tt><a name="account the"></a> to return a more accurate shape that takes into ac&#99;ount the node's rounded corners.</p>
<p class="docText"><a name="iddle3353"></a><a name="iddle3908"></a><a name="iddle4028"></a><a name="iddle5118"></a><a name="iddle5119"></a><a name="iddle5128"></a><a name="iddle7223"></a><a name="the bounding"></a>&#84;he gra&#112;hic&#115; view ar&#99;hitecture u&#115;es the bounding &#114;ectangle to determine whether an item nee&#100;s &#116;o be draw&#110;. This ena&#98;les <tt>QGraphicsView</tt><a name="fraction of"></a> &#116;o display arbitrarily large scene&#115; very quickly, when only a f&#114;action of the items are visible at &#97;ny given time. The shape is used for determining whether a po&#105;nt is in&#115;ide an i&#116;em, or whe&#116;her two i&#116;ems collide.</p>
<div class="docText"><pre>protected:
    void mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event);
    QVariant itemChange(GraphicsItemChange change,
                        const QVariant &amp;value);</pre></div><br />
<p class="docText"><a name="Properties dialog"></a>In the Diagram appl&#105;cation, we will provide a Properties dialog fo&#114; editi&#110;g &#97; node's position, co&#108;ors, and text. As an add&#101;d convenienc&#101;, we will let the user change the text by do&#117;ble-clicking the node.</p>
<p class="docText"><a name="sure that"></a>If a node is moved, &#119;e must make sure that any associated links are updated ac&#99;ordingly. We &#114;eimpl&#101;me&#110;t &#116;he <tt>itemChange()</tt><a name="take care"></a> handler to take care of &#116;his; it is called whenever the item's properties (including its p&#111;si&#116;ion) chan&#103;e. The reason &#119;e don't use <tt>mouseMoveEv&#101;nt()</tt><a name="when the"></a> for this purpose &#105;s because it is not called when the node i&#115; moved programmatically.</p>
<div class="docText"><pre>private:
    QRectF outlineRect() const;
    int roundness(double size) const;

    QSet&lt;Link *&gt; myLinks;
    QString myText;
    QColor myTextColor;
    QColor myBackgroundColor;
    QColor myOutlineColor;
};</pre></div><br />
<p class="docText"><a name="The"></a>The <tt>outlineRect()</tt><a name="returns the"></a> private &#102;unction returns the rectangle drawn by the <tt>Node</tt>, &#119;hereas <tt>roun&#100;n&#101;ss()</tt><a name="an appropriate"></a> &#114;eturn&#115; an appropriate round&#110;ess coefficient based on the width or height of th&#101; re&#99;tangle.</p>
<p class="docText">Just &#97;s a <tt>Link</tt> keeps &#116;rack of the node&#115; it connects, a <tt>Node</tt><a name="the links"></a> keep&#115; track of its links. When a node &#105;s deleted, all the links associated with the n&#111;de are deleted as well.</p>
<p class="docText"><a name="look at"></a>We are now ready to look at <tt>&#78;ode</tt>'s imple&#109;entation, st&#97;rting as u&#115;ual wit&#104; the constructor.</p>
<div class="docText"><pre>Node::Node()
{
    myTextColor = Qt::darkGreen;
    myOutlineColor = Qt::darkBlue;
    myBackgroundColor = Qt::white;

    setFlags(ItemIsMovable | ItemIsSelectable);
}</pre></div><br />
<p class="docText"><a name="iddle1100"></a><a name="iddle4030"></a><a name="iddle4032"></a><a name="iddle4038"></a><a name="iddle4040"></a><a name="iddle4041"></a><a name="iddle4416"></a><a name="iddle4915"></a><a name="iddle5124"></a><a name="iddle5133"></a><a name="iddle6859"></a><a name="iddle7345"></a><a name="iddle7356"></a><a name="iddle8324"></a><a name="and selectable"></a>We in&#105;tialize the colors, and make node &#105;tems bo&#116;h movabl&#101; and s&#101;lectable. The <span class="docEmphasis">z</span><a name="the node"></a> v&#97;lue will default to 0, and we le&#97;ve the node's position in the sc&#101;ne to be set by the caller.</p>
<div class="docText"><pre>Node::~Node()
{
    foreach (Link *link, myLinks)
        delete link;
}</pre></div><br />
<p class="docText"><a name="link is"></a>The destructor d&#101;letes all the node's links. Whenever a link &#105;s destr&#111;ye&#100;, i&#116; removes &#105;tself from the node&#115; it is connected to. We iterate &#111;ve&#114; (a copy &#111;f) the set o&#102; links rather t&#104;an use <tt>qDeleteAll()</tt><a name="side effects"></a> to avoid side ef&#102;ects, since the set of links is indir&#101;ctly accessed by the <tt>Link</tt> destructor.</p>
<div class="docText"><pre>void Node::setText(const QString &amp;text)
{
    prepareGeometryChange();
    myText = text;
    update();
}</pre></div><br />
<p class="docText"><a name="that affects"></a>Whenever w&#101; change a graphics item in a way that affects its appea&#114;ance, w&#101; mu&#115;t call <tt>u&#112;dat&#101;()</tt><a name="to schedule"></a> to schedule a repa&#105;nt. And in cases such as this where the item's &#98;ounding re&#99;tangle migh&#116; change (beca&#117;se the new text migh&#116; be shorter or longer than t&#104;e current text), we must call <tt>prepare&#71;eometryChange()</tt><a name="doing anything"></a> immediately before doing anyt&#104;ing that will affect the item's bounding rectangle.</p>
<p class="docText"><a name="will skip"></a>We will skip the <tt>t&#101;xt()</tt>, <tt>&#116;extColo&#114;()</tt>, <tt>outli&#110;e&#67;olor()</tt>, and <tt>backgroundColor()</tt> getters &#115;ince they simply return their correspondin&#103; priv&#97;te member.</p>
<div class="docText"><pre>void Node::setTextColor(const QColor &amp;color)
{
    myTextColor = color;
    update();
}</pre></div><br />
<p class="docText">&#87;hen we set the text's &#99;olor, we must call <tt>update()</tt><a name="painted using"></a> t&#111; schedule a repaint so th&#97;t the item is painted using the ne&#119; color. We don't need to call <tt>prepareGeometryChang&#101;()</tt><a name="item is"></a>, because the size of the item is not affected b&#121; a c&#111;lo&#114; chang&#101;. We &#119;ill omit the setters for the outl&#105;ne and background colors since they are structurally the same &#97;s this set&#116;er.</p>
<div class="docText"><pre>void Node::addLink(Link *link)
{
    myLinks.insert(link);
}

void Node::removeLink(Link *link)
{
    myLinks.remove(link);
}</pre></div><br />
<p class="docText"><a name="to the"></a>Here w&#101; simply add or re&#109;ove the given l&#105;nk to the node's set of l&#105;nks.</p>
<div class="docText"><pre>QRectF Node::outlineRect() const
{
    const int Padding = 8;
    QFontMetricsF metrics = qApp-&gt;font();
    QRectF rect = metrics.boundingRect(myText);
    rect.adjust(-Padding, -Padding, +Padding, +Padding);
    rect.translate(-rect.center());
    return rect;
}</pre></div><br />
<p class="docText"><a name="iddle1370"></a><a name="iddle1660"></a><a name="iddle4033"></a><a name="iddle4036"></a><a name="iddle4042"></a><a name="iddle4189"></a><a name="iddle5115"></a><a name="iddle5132"></a><a name="iddle5573"></a><a name="iddle7414"></a><a name="a rectangle"></a>We use this private function to ca&#108;culate a rectangle that encompasses the node'&#115; text with an 8-pixel margin. The bounding rectangle returned by the font m&#101;tr&#105;cs func&#116;ion alwa&#121;s h&#97;s (0, 0) as its top-left corner. Since we w&#97;nt the text centered on the item's center &#112;oin&#116;, we trans&#108;ate the rectangle so &#116;hat its cent&#101;r is at (0, 0).</p>
<p class="docText"><a name="of pixels"></a>Although we thi&#110;k and calculate in terms of pixels, the unit i&#115; in a sense notional. The scene (or the parent it&#101;m) may be scaled, rotated, sheared, or simpl&#121; af&#102;ect&#101;d b&#121; an&#116;ialiasing, so the actual numb&#101;r of pixels that appears on the screen may be d&#105;fferen&#116;.</p>
<div class="docText"><pre>QRectF Node::boundingRect() const
{
    const int Margin = 1;
    return outlineRect().adjusted(-Margin, -Margin, +Margin, +Margin);
}</pre></div><br />
<p class="docText">The <tt>boun&#100;ing&#82;ect()</tt><a name="called by"></a> func&#116;ion is called by <tt>QGraphicsView</tt><a name="use the"></a> to &#100;etermine whether the item need&#115; to be drawn. We use the outline rectangle, but with a bit &#111;f additional margin, since the rectangle we return &#102;rom &#116;his func&#116;ion must &#97;llow for a&#116; least half the width of the pen i&#102; an outline is going to be drawn.</p>
<div class="docText"><pre>QPainterPath Node::shape() const
{
    QRectF rect = outlineRect();

    QPainterPath path;
    path.addRoundRect(rect, roundness(rect.width()),
                      roundness(rect.height()));
    return path;
}</pre></div><br />
<p class="docText"><a name="The"></a>The <tt>sha&#112;e()</tt><a name="called by"></a> fu&#110;c&#116;ion is called by <tt>QGra&#112;hicsView</tt><a name="collision detection"></a> fo&#114; fine-grained collision detection. O&#102;ten, we can omit it and leave the item to calcul&#97;te the shape itself based on the boun&#100;ing rectangle. Here we reimplement &#105;t to ret&#117;rn a <tt>QPain&#116;erPath</tt><a name="areas that"></a> t&#104;at rep&#114;esents a rounded rect&#97;ngle. As a consequence, clicking t&#104;e corn&#101;r a&#114;eas that fall out&#115;ide the rounde&#100; rectangle but ins&#105;de the bounding rectan&#103;le <span class="docEmphasis">won't</span> select the item.</p>
<p class="docText"><a name="we can"></a>When we create a round&#101;d rectangle, we can pass optional arguments to spec&#105;fy the r&#111;un&#100;e&#100;n&#101;ss of the corners. &#87;e calculate suitable values using the <tt>roundn&#101;ss()</tt> &#112;riv&#97;te function.</p>
<div class="docText"><pre>void Node::paint(QPainter *painter,
                 const QStyleOptionGraphicsItem *option,
                 QWidget * /* widget */)
{
    QPen pen(myOutlineColor);
    if (option-&gt;state &amp; QStyle::State_Selected) {
        pen.setStyle(Qt::DotLine);
        pen.setWidth(2);
    }
    painter-&gt;setPen(pen);
    painter-&gt;setBrush(myBackgroundColor);

    QRectF rect = outlineRect();
    painter-&gt;drawRoundRect(rect, roundness(rect.width()),
                           roundness(rect.height()));

    painter-&gt;setPen(myTextColor);
    painter-&gt;drawText(rect, Qt::AlignCenter, myText);
}</pre></div><br />
<p class="docText"><a name="iddle2218"></a><a name="iddle2284"></a><a name="iddle2526"></a><a name="iddle3352"></a><a name="iddle3535"></a><a name="iddle3899"></a><a name="iddle4034"></a><a name="iddle4035"></a><a name="iddle4037"></a><a name="iddle4213"></a><a name="iddle5120"></a><a name="iddle5144"></a><a name="iddle5145"></a><a name="iddle5536"></a><a name="iddle6000"></a>T&#104;e <tt>paint()</tt><a name="is selected"></a> functio&#110; is where we draw the item. &#73;f the item is selected, we change th&#101; pen's style to be a dotted line and make it thic&#107;er; otherwise, the default of a solid 1-pixel line is used. We also set &#116;he brush &#116;o use the &#98;ackground &#99;olor.</p>
<p class="docText"><a name="same size"></a>Then we &#100;raw a rounded rect&#97;ngle the same size as the outline rectangle, bu&#116; using th&#101; ro&#117;nding factors retu&#114;ned by the <tt>round&#110;ess()</tt><a name="the outline"></a> private function. F&#105;nally, we draw the text centered within the &#111;utline rectangle on top of the rounded r&#101;ctangle.</p>
<p class="docText">The <tt>option</tt><a name="type"></a> parameter of type <tt>QS&#116;yleOpti&#111;nG&#114;aphic&#115;Item</tt><a name="several public"></a> is &#97;n unusual class for Qt because it prov&#105;des several public member variables. These in&#99;lude the cur&#114;ent la&#121;out directi&#111;n, font &#109;etrics, palette, rectangle, state (sel&#101;cted, &quot;has focus&quot;, and many others), &#116;he transformation matrix, and the level of detai&#108;. Here we have checked the <tt>state</tt><a name="member to"></a> member to see wh&#101;th&#101;r t&#104;e node &#105;s selec&#116;ed.</p>
<div class="docText"><pre>QVariant Node::itemChange(GraphicsItemChange change,
                          const QVariant &amp;value)
{
    if (change == ItemPositionHasChanged) {
        foreach (Link *link, myLinks)
            link-&gt;trackNodes();
    }
    return QGraphicsItem::itemChange(change, value);
}</pre></div><br />
<p class="docText"><a name="user drags"></a>Whenever the user drags a node, t&#104;e <tt>itemChange()</tt><a name="is called"></a> handler is called with <tt>ItemPos&#105;tionHa&#115;Change&#100;</tt><a name="are positioned"></a> as the fir&#115;t argument. &#84;o ensure that the link lines are &#112;ositioned correctly, we iterate &#111;ver the node's set of links and tell each &#111;ne to update its line's endpoints. At the end, &#119;e call the ba&#115;e class &#105;mpleme&#110;t&#97;tion to ensure that it also gets &#110;otified.</p>
<div class="docText"><pre>void Node::mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event)
{
    QString text = QInputDialog::getText(event-&gt;widget(),
                           tr("Edit Text"), tr("Enter new text:"),
                           QLineEdit::Normal, myText);
    if (!text.isEmpty())
        setText(text);
}</pre></div><br />
<p class="docText"><a name="iddle2120"></a><a name="iddle2121"></a><a name="iddle4039"></a><a name="iddle4044"></a><a name="iddle5323"></a><a name="iddle6970"></a><a name="iddle7850"></a><a name="pop up"></a>If the user double-clicks the no&#100;e, &#119;e pop up a dia&#108;og that shows the curren&#116; text and allows the&#109; to change it. If the user clicks <span class="docEmphRomanAlt">Cancel</span><a name="if the"></a>, &#97;n empty string is returned; therefo&#114;e, we apply the change only if the strin&#103; is non-empty. We will see how other node prop&#101;rt&#105;es (such &#97;s the node'&#115; colors) &#99;an be changed shortly.</p>
<div class="docText"><pre>int Node::roundness(double size) const
{
    const int Diameter = 12;
    return 100 * Diameter / int(size);
}</pre></div><br />
<p class="docText">The <tt>rou&#110;dness()</tt><a name="that the"></a> function returns appropria&#116;e roundi&#110;g &#102;actors &#116;o ensure that the n&#111;de's corners are quarter-ci&#114;cles with diameter 12. The rounding fac&#116;ors must be in the range 0 (square) to 99 (fully rounded).</p>
<p class="docText"><a name="two custom"></a>We ha&#118;e now seen the implementation of two custom gra&#112;hic&#115; item cl&#97;sses. Now i&#116; is time t&#111; see how they are actually used. &#84;he Diagram application is a standard main w&#105;ndow ap&#112;lic&#97;tion with menus and a to&#111;lbar. We won't l&#111;ok at all the details of th&#101; implementation, but ins&#116;ead concentrate on those relevant &#116;o the graphics view architecture. We will begin by look&#105;ng at an &#101;xt&#114;act fr&#111;m t&#104;e <tt>QMainWindow</tt> subclass's def&#105;nition.</p>
<div class="docText"><div class="codeSegmentsExpansionLinks">
              Code View:</div><pre class="">class DiagramWindow : public QMainWindow
{
    Q_OBJECT

public:
    DiagramWindow();

private slots:
    void addNode();
    void addLink();
    void del();
    void cut();
    void copy();
    void paste();
    void bringToFront();
    void sendToBack();
    void properties();
    void updateActions();

private:
    typedef QPair&lt;Node *, Node *&gt; NodePair;

    void createActions();
    void createMenus();
    void createToolBars();
    void setZValue(int z);
    void setupNode(Node *node);
    Node *selectedNode() const;
    Link *selectedLink() const;
    NodePair selectedNodePair() const;

    QMenu *fileMenu;
    QMenu *editMenu;
    QToolBar *editToolBar;
    QAction *exitAction;
    ...
    QAction *propertiesAction;

    QGraphicsScene *scene;
    QGraphicsView *view;

    int minZ;
    int maxZ;
    int seqNumber;
};

					  </pre></div><br />
<p class="docText"><a name="iddle2122"></a><a name="iddle5143"></a><a name="iddle6979"></a><a name="of most"></a>The purpose of most of t&#104;e priv&#97;te slots s&#104;ould be cl&#101;ar from &#116;heir names. The <tt>propert&#105;es()</tt><a name="if a"></a> slot is used to pop up the Prop&#101;rties dialog if a node is selec&#116;ed, or a <tt>QColorDialog</tt><a name="if a"></a> if a link is selected. The <tt>updat&#101;Ac&#116;ions()</tt><a name="used to"></a> slo&#116; is used t&#111; en&#97;ble or disable actions de&#112;ending on what items are selected.</p>
<div class="docText"><pre>DiagramWindow::DiagramWindow()
{
    scene = new QGraphicsScene(0, 0, 600, 500);

    view = new QGraphicsView;
    view-&gt;setScene(scene);
    view-&gt;setDragMode(QGraphicsView::RubberBandDrag);
    view-&gt;setRenderHints(QPainter::Antialiasing
                         | QPainter::TextAntialiasing);
    view-&gt;setContextMenuPolicy(Qt::ActionsContextMenu);
    setCentralWidget(view);

    minZ = 0;
    maxZ = 0;
    seqNumber = 0;

    createActions();
    createMenus();
    createToolBars();

    connect(scene, SIGNAL(selectionChanged()),
            this, SLOT(updateActions()));

    setWindowTitle(tr("Diagram"));
    updateActions();
}</pre></div><br />
<p class="docText"><a name="begin by"></a>We begin by &#99;reating a gr&#97;phics sce&#110;e, with an origi&#110; of (0, 0), a wi&#100;th of 600, and a height of 500. Then we &#99;reate a graphics view to visualize &#116;he scene. In <a name="iddle1103"></a><a name="iddle1377"></a><a name="iddle2124"></a><a name="iddle2125"></a><a name="iddle2136"></a><a name="iddle7406"></a>the next example, instead &#111;f using <tt>QGraphicsView</tt> directly, we will subclass it to customize &#105;ts beha&#118;ior.</p>
<p class="docText"><a name="more than"></a>Select&#97;ble items &#99;an be select&#101;d by clicking them. To s&#101;lect more than one item at a time, the user can c&#108;ick the ite&#109;s while pres&#115;ing <span class="docEmphRomanAlt">Ctrl</span>. Setting th&#101; drag mode to <tt>Q&#71;raphicsView::RubberBandDr&#97;g</tt><a name="also select"></a> means that the user can also select items by dragging a ru&#98;ber band over them.</p>
<p class="docText">The <tt>minZ</tt> and <tt>maxZ</tt> numbers are use&#100; by the <tt>sendToBack()</tt> and <tt>bringToFr&#111;nt()</tt><a name="initial text"></a> &#102;unc&#116;ions. The &#115;equenc&#101; number is used to give a unique i&#110;itial text to each node the user add&#115;.</p>
<p class="docText"><a name="we enable"></a>The sig&#110;a&#108;–slot connection ensure&#115; that whene&#118;er the scene's selection change&#115;, we enable or disable the applic&#97;tion's actions so that only actions that make sen&#115;e are available. We call <tt>updateActions()</tt> to set the actions' initial &#101;na&#98;led states.</p>
<div class="docText"><pre>void DiagramWindow::addNode()
{
    Node *node = new Node;
    node-&gt;setText(tr("Node %1").arg(seqNumber + 1));
    setupNode(node);
}</pre></div><br />
<p class="docText"><a name="create a"></a>&#87;hen the us&#101;r a&#100;ds a new node, we create a ne&#119; instance of the <tt>Node</tt><a name="a default"></a> class, give it a default text, and then pa&#115;s the no&#100;e &#116;o <tt>setupNode()</tt><a name="to finish"></a> &#116;o position a&#110;d select it. We use a sepa&#114;ate function to finish addin&#103; a node because we will need this fun&#99;tionality again when implementing <tt>paste()</tt>.</p>
<div class="docText"><pre>void DiagramWindow::setupNode(Node *node)
{
    node-&gt;setPos(QPoint(80 + (100 * (seqNumber % 5)),
                 80 + (50 * ((seqNumber / 5) % 7))));
    scene-&gt;addItem(node);
    ++seqNumber;

    scene-&gt;clearSelection();
    node-&gt;setSelected(true);
    bringToFront();
}</pre></div><br />
<p class="docText"><a name="This function"></a>This function positions &#97; newly add&#101;d o&#114; paste&#100; n&#111;de in the scene. The use &#111;f the sequence number ensures that new n&#111;de&#115; are add&#101;d in d&#105;fferent positio&#110;s rather than on top of e&#97;ch other. We clear the current &#115;election and select just the newly added nod&#101;. The <tt>bringToFront()</tt><a name="that the"></a> call ensures that the new n&#111;de &#105;s farth&#101;r f&#111;rw&#97;rd than any other node.</p>
<div class="docText"><pre>void DiagramWindow::bringToFront()
{
    ++maxZ;
    setZValue(maxZ);
}
void DiagramWindow::sendToBack()
{
    --minZ;
    setZValue(minZ);
}

void DiagramWindow::setZValue(int z)
{
    Node *node = selectedNode();
    if (node)
        node-&gt;setZValue(z);
}</pre></div><br />
<p class="docText"><a name="iddle1099"></a><a name="iddle2123"></a><a name="iddle2131"></a><a name="iddle2132"></a><a name="iddle2133"></a><a name="iddle2134"></a><a name="iddle2135"></a><a name="iddle5130"></a><a name="iddle5140"></a><a name="iddle7079"></a><a name="iddle7080"></a><a name="iddle7081"></a><a name="iddle7082"></a><a name="iddle7098"></a><a name="iddle7393"></a><a name="iddle7395"></a>Th&#101; <tt>bringToFront()</tt><a name="increments the"></a> slot increments the <tt>max&#90;</tt> v&#97;lue, and th&#101;n sets &#116;he current&#108;y selected node's <span class="docEmphasis">z</span> value &#116;o <tt>maxZ</tt>. The <tt>sendToBack()</tt> slot use&#115; <tt>minZ</tt><a name="of the"></a> and has the opposite effect. Both are d&#101;fined in terms of the <tt>setZ&#86;alue()</tt> pri&#118;ate functi&#111;n.</p>
<div class="docText"><pre>Node *DiagramWindow::selectedNode() const
{
    QList&lt;QGraphicsItem *&gt; items = scene-&gt;selectedItems();
    if (items.count() == 1) {
        return dynamic_cast&lt;Node *&gt;(items.first());
    } else {
        return 0;
    }
}</pre></div><br />
<p class="docText"><a name="items in"></a>T&#104;e list &#111;f all selected items in the scene &#105;s available by calling <tt>QGraphicsScene::selectedItem&#115;()</tt>. The <tt>sel&#101;ct&#101;dNode()</tt><a name="just one"></a> &#102;unction is de&#115;igned to return a single no&#100;e if just one node &#105;s selected, and a null pointer otherwise. If there is exact&#108;y one selected item, the cast will produce a <tt>Node</tt> pointer if the item is a <tt>&#78;ode</tt><a name="is a"></a>, and a nu&#108;l pointer i&#102; the &#105;tem is a <tt>&#76;ink</tt>.</p>
<p class="docText">There is also a <tt>selectedLink()</tt> fun&#99;tion, which returns a pointer to the selected <tt>Link</tt><a name="item and"></a> i&#116;em if the&#114;e is ex&#97;ctly one sele&#99;ted item and it is a li&#110;k.</p>
<div class="docText"><pre>void DiagramWindow::addLink()
{
    NodePair nodes = selectedNodePair();
    if (nodes == NodePair())
        return;

    Link *link = new Link(nodes.first, nodes.second);
    scene-&gt;addItem(link);
}</pre></div><br />
<p class="docText"><a name="can add"></a>The user can add a &#108;ink if exactly two nodes are select&#101;d. If the <tt>selectedNodePa&#105;r()</tt><a name="The link"></a> function returns the two selected nodes, we create a new link. The lin&#107;'s constru&#99;tor will mak&#101; th&#101; li&#110;k line's endpoints go from the &#99;enter of the first node to the center of the &#115;econd n&#111;de.</p>
<div class="docText"><pre>DiagramWindow::NodePair DiagramWindow::selectedNodePair() const
{
    QList&lt;QGraphicsItem *&gt; items = scene-&gt;selectedItems();
    if (items.count() == 2) {
        Node *first = dynamic_cast&lt;Node *&gt;(items.first());
        Node *second = dynamic_cast&lt;Node *&gt;(items.last());
        if (first &amp;&amp; second)
            return NodePair(first, second);
    }
    return NodePair();
}</pre></div><br />
<p class="docText"><a name="iddle2073"></a><a name="iddle2128"></a><a name="iddle2130"></a><a name="iddle2906"></a><a name="iddle4546"></a><a name="iddle4831"></a><a name="This function"></a>&#84;his func&#116;ion is similar to the <tt>s&#101;lectedNode()</tt><a name="saw earlier"></a> function we saw earlier. If t&#104;ere are exactly two selected items, an&#100; they are both nodes, the pair of them is r&#101;turned; otherwise, a pair of null pointers is re&#116;urned.</p>
<div class="docText"><pre>void DiagramWindow::del()
{
    QList&lt;QGraphicsItem *&gt; items = scene-&gt;selectedItems();
    QMutableListIterator&lt;QGraphicsItem *&gt; i(items);
    while (i.hasNext()) {
        Link *link = dynamic_cast&lt;Link *&gt;(i.next());
        if (link) {
            delete link;
            i.remove();
        }
    }

    qDeleteAll(items);
}</pre></div><br />
<p class="docText"><a name="slot deletes"></a>Th&#105;s slot d&#101;le&#116;es any se&#108;ected items, whether they are node&#115;, links, or a mixture of both. When a node is deleted, i&#116;s destru&#99;tor deletes &#97;ny links that are &#97;ssociated w&#105;th it. To avoid double-deleting links, we del&#101;te the link items before deleting the n&#111;des.</p>
<div class="docText"><pre>void DiagramWindow::properties()
{
    Node *node = selectedNode();
    Link *link = selectedLink();

    if (node) {
        PropertiesDialog dialog(node, this);
        dialog.exec();
    } else if (link) {
        QColor color = QColorDialog::getColor(link-&gt;color(), this);
        if (color.isValid())
            link-&gt;setColor(color);
    }
}</pre></div><br />
<p class="docText">If the user triggers the <span class="docEmphRomanAlt">Propert&#105;es</span><a name="This dialog"></a> action and a node is selected, we invoke the Propert&#105;es dial&#111;g. T&#104;is dia&#108;og allows t&#104;e user to change the node's text, posi&#116;ion, and colors. Because <tt>PropertiesDialog</tt> o&#112;era&#116;es direc&#116;ly on a <tt>Node</tt><a name="modally and"></a> &#112;ointer, we can &#115;imply execute it modally and leave &#105;t to take care of itself.</p>
<p class="docText">If a link is sele&#99;ted, we use Qt's built-in <tt>QColorDialog::getC&#111;lor()</tt><a name="the user"></a> static convenience function to pop up a &#99;olor dialog. &#73;f the &#117;ser choos&#101;s a &#99;olor, we set that as the link's color.</p>
<p class="docText"><a name="iddle1622"></a><a name="iddle1626"></a><a name="iddle1873"></a><a name="iddle1992"></a><a name="iddle2085"></a><a name="iddle2126"></a><a name="iddle2127"></a><a name="iddle2129"></a><a name="iddle3976"></a><a name="iddle4278"></a><a name="iddle4717"></a><a name="iddle4817"></a><a name="iddle4819"></a><a name="iddle4827"></a><a name="iddle5937"></a><a name="iddle5959"></a><a name="iddle7348"></a><a name="iddle7619"></a><a name="iddle7981"></a><a name="the changes"></a>I&#102; a node's properties or a link's color w&#101;re &#99;hanged, the c&#104;anges are made th&#114;ough sett&#101;r functions, and these cal&#108; <tt>update()</tt><a name="is repainted"></a> to ensure that the node &#111;r link is repainted with its new settings.</p>
<p class="docText"><a name="want to"></a>Use&#114;s often want to cut, copy, and paste graphics items i&#110; t&#104;is typ&#101; of &#97;pplicati&#111;n, and one way to suppor&#116; this is to represent items text&#117;ally, as we &#119;ill see when &#119;e review the releva&#110;t code. We only h&#97;ndle nodes, because it would not mak&#101; sense to copy or paste links, which &#111;nly exist in relation to nodes.</p>
<div class="docText"><pre>void DiagramWindow::cut()
{
    Node *node = selectedNode();
    if (!node)
        return;

    copy();
    delete node;
}</pre></div><br />
<p class="docText">The <span class="docEmphRomanAlt">Cut</span><a name="clipboard and"></a> &#97;ction is a two-part process: Copy the selected item into the clipboard an&#100; d&#101;le&#116;e the ite&#109;. The copy is p&#101;rformed using the <tt>&#99;opy()</tt><a name="slot associated"></a> slot associated with the <span class="docEmphRomanAlt">Copy</span><a name="deletion uses"></a> action, and the delet&#105;on uses &#67;++'s standar&#100; <tt>dele&#116;e</tt><a name="on the"></a> operator, r&#101;lying on the node'&#115; destructor to delete any link&#115; that are connected to th&#101; node and to remove the node from the scene.</p>
<div class="docText"><pre>void DiagramWindow::copy()
{
    Node *node = selectedNode();
    if (!node)
        return;

    QString str = QString("Node %1 %2 %3 %4")
                  .arg(node-&gt;textColor().name())
                  .arg(node-&gt;outlineColor().name())
                  .arg(node-&gt;backgroundColor().name())
                  .arg(node-&gt;text());
    QApplication::clipboard()-&gt;setText(str);
}</pre></div><br />
<p class="docText">The <tt>QC&#111;lo&#114;::name()</tt> f&#117;nction re&#116;urns a <tt>QS&#116;ring</tt> that contains an HTML-style co&#108;or string in &quot;#<span class="docEmphasis">RRGGBB</span><a name="in the"></a>&quot; format, with each color compon&#101;nt &#114;epres&#101;nted b&#121; a hexa&#100;ecimal value in the rang&#101; <tt>0x00</tt> to <tt>0xFF</tt><a name="to the"></a> (0 to 255). We write a strin&#103; to the clipboard, which is a single line &#111;f text starting with the word &quot;Node&quot;, then the n&#111;de'&#115; three c&#111;lo&#114;s, and f&#105;nally the node's text, with a space &#98;etween each part. For example:</p>
<div class="docText"><pre>Node #aa0000 #000080 #ffffff Red herring</pre></div><br />
<p class="docText">This text is decod&#101;d b&#121; th&#101; <tt>paste()</tt> func&#116;ion:</p>
<div class="docText"><pre>void DiagramWindow::paste()
{
    QString str = QApplication::clipboard()-&gt;text();
    QStringList parts = str.split(" ");
    if (parts.count() &gt;= 5 &amp;&amp; parts.first() == "Node") {
        Node *node = new Node;
        node-&gt;setText(QStringList(parts.mid(4)).join(" "));
        node-&gt;setTextColor(QColor(parts[1]));
        node-&gt;setOutlineColor(QColor(parts[2]));
        node-&gt;setBackgroundColor(QColor(parts[3]));
        setupNode(node);
    }
}</pre></div><br />
<p class="docText"><a name="iddle1591"></a><a name="iddle2137"></a><a name="iddle2574"></a><a name="iddle3977"></a><a name="iddle4828"></a><a name="iddle8336"></a>We split the clip&#98;oard's text into a <tt>QStringList</tt><a name="To be"></a>. Using th&#101; preceding exa&#109;ple, this would give us the list [&quot;Node&quot;, &quot;#aa0000&quot;, &quot;#000080&quot;, &quot;#ffffff&quot;, &quot;Red&quot;, &quot;h&#101;rring&quot;]. To be a valid node, there must be at least five e&#108;ements in t&#104;e list: &#116;he word &quot;N&#111;de&quot;, &#116;he three colors, and at least one word of te&#120;t. If this is the case, we create a new node, &#115;etting &#105;ts text &#116;o be the space-&#115;eparated c&#111;ncatenation of the fift&#104; and subsequent elements. We set t&#104;e colors to be the second, third, and f&#111;urth elements, using the <tt>QColor</tt> constructor t&#104;at acc&#101;pt&#115; the nam&#101;s r&#101;turned by <tt>QColor::name()</tt>.</p>
<p class="docText">For &#99;ompleteness, here is the <tt>updateActions()</tt><a name="disable the"></a> slot that is u&#115;ed to en&#97;ble and di&#115;able the ac&#116;ions in the <span class="docEmphRomanAlt">Edit</span> &#109;enu and the context menu:</p>
<div class="docText"><pre>void DiagramWindow::updateActions()
{
    bool hasSelection = !scene-&gt;selectedItems().isEmpty();
    bool isNode = (selectedNode() != 0);
    bool isNodePair = (selectedNodePair() != NodePair());

    cutAction-&gt;setEnabled(isNode);
    copyAction-&gt;setEnabled(isNode);
    addLinkAction-&gt;setEnabled(isNodePair);
    deleteAction-&gt;setEnabled(hasSelection);
    bringToFrontAction-&gt;setEnabled(isNode);
    sendToBackAction-&gt;setEnabled(isNode);
    propertiesAction-&gt;setEnabled(isNode);

    foreach (QAction *action, view-&gt;actions())
        view-&gt;removeAction(action);

    foreach (QAction *action, editMenu-&gt;actions()) {
        if (action-&gt;isEnabled())
            view-&gt;addAction(action);
    }
}</pre></div><br />
<p class="docText"><a name="the Diagram"></a>We have n&#111;w finished the review of the Diagram applica&#116;ion and can turn our attention to the second graph&#105;cs view example, Cityscape.</p>
<p class="docText"><a name="application shown"></a>The Cityscape appli&#99;ation shown &#105;n <a class="docLink" href="#ch08fig17">Figure 8.17</a><a name="in a"></a> prese&#110;t&#115; a ficti&#116;ious map of the major build&#105;ngs, blocks, and parks in a city, with the most important &#111;ne&#115; annota&#116;ed with their na&#109;es. It allows the user t&#111; scroll and zoom &#116;he map using the mouse and t&#104;e keyboard. We will begin by showing &#116;he <tt>Cityscape</tt><a name="which provides"></a> class, which provides the application's main window.</p>

<p class="docText"></p><a name="ch08fig17"></a><p><center>

<h5 class="docFigureTitle"><a name="Cityscape application"></a>F&#105;gure 8.17. Th&#101; Ci&#116;yscape a&#112;pli&#99;ation at two different &#122;oom levels</h5>
<p class="docText"><div class="st1"><a target="_blank" href="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzZ3BmYWlwY3RoN2cwOC9pMXNsLl9q.jpg">[View full size image]</a></div><img border="0" id="" width="500" height="202" src="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzZmlqcGNnaDdnMDgvaTFwcy4-.jpg" alt="" /></p>
</center></p><br />
<div class="docText"><pre>class Cityscape : public QMainWindow
{
    Q_OBJECT

public:
    Cityscape();

private:
    void generateCityBlocks();

    QGraphicsScene *scene;
    CityView *view;
};</pre></div><br />
<p class="docText"><a name="iddle1571"></a><a name="iddle1589"></a><a name="iddle1590"></a><a name="iddle5112"></a><a name="iddle7841"></a><a name="application has"></a>The application has no menus or toolbars; it simp&#108;y displays &#116;he annot&#97;ted map using a <tt>Cit&#121;View</tt> w&#105;dget. The <tt>CityView</tt> class is deri&#118;ed from <tt>QGraphicsView</tt>.</p>
<div class="docText"><pre>Cityscape::Cityscape()
{
    scene = new QGraphicsScene(-22.25, -22.25, 1980, 1980);
    scene-&gt;setBackgroundBrush(QColor(255, 255, 238));
    generateCityBlocks();

    view = new CityView;
    view-&gt;setScene(scene);
    setCentralWidget(view);

    setWindowTitle(tr("Cityscape"));
}</pre></div><br />
<p class="docText">The constructor creates a <tt>QGraphic&#115;Scene</tt> and calls <tt>generateCityBlocks()</tt><a name="and "></a> to gene&#114;ate a map. The map consists of about 2000 blocks and 200 annotations.</p>
<p class="docText"><a name="the"></a>We w&#105;ll firs&#116; look at t&#104;e <tt>City&#66;lock</tt> gra&#112;hics item subclass, then the <tt>Annot&#97;tion</tt> graphics item subclass, and finally t&#104;e <tt>City&#86;iew</tt> grap&#104;ics view s&#117;bclass.</p>
<div class="docText"><pre>class CityBlock : public QGraphicsItem
{
public:
    enum Kind { Park, SmallBuilding, Hospital, Hall, Building, Tower,
                LShapedBlock, LShapedBlockPlusSmallBlock, TwoBlocks,
                BlockPlusTwoSmallBlocks };

    CityBlock(Kind kind);

    QRectF boundingRect() const;
    void paint(QPainter *painter,
               const QStyleOptionGraphicsItem *option, QWidget *widget);

private:
    int kind;
    QColor color;
    QPainterPath shape;
};</pre></div><br />
<p class="docText"><a name="iddle1369"></a><a name="iddle1572"></a><a name="iddle1573"></a><a name="iddle5116"></a><a name="the city"></a>A city bloc&#107; has a kind, a color, and a shape. Since the city bl&#111;cks are not selectable, we have not b&#111;thered to reimplement &#116;he <tt>shape()</tt> function like we did for the <tt>Node</tt> class in the prev&#105;ous exa&#109;ple.</p>
<div class="docText"><div class="codeSegmentsExpansionLinks">
              Code View:</div><pre class="">CityBlock::CityBlock(Kind kind)
{
    this-&gt;kind = kind;

    int green = 96 + (std::rand() % 64);
    int red = 16 + green + (std::rand() % 64);
    int blue = 16 + (std::rand() % green);
    color = QColor(red, green, blue);

    if (kind == Park) {
        color = QColor(192 + (std::rand() % 32), 255,
                       192 + (std::rand() % 16));
        shape.addRect(boundingRect());
    } else if (kind == SmallBuilding) {
        ...
    } else if (kind == BlockPlusTwoSmallBlocks) {
        int w1 = (std::rand() % 10) + 8;
        int h1 = (std::rand() % 28) + 8;
        int w2 = (std::rand() % 10) + 8;
        int h2 = (std::rand() % 10) + 8;
        int w3 = (std::rand() % 6) + 8;
        int h3 = (std::rand() % 6) + 8;
        int y = (std::rand() % 4) - 16;
        shape.addRect(QRectF(-16, -16, w1, h1));
        shape.addRect(QRectF(-16 + w1 + 4, y, w2, h2));
        shape.addRect(QRectF(-16 + w1 + 4,
                             y + h2 + 4 + (std::rand() % 4), w3, h3));
    }
}

					  </pre></div><br />
<p class="docText"><a name="generates a"></a>The cons&#116;ructor s&#101;ts &#97; random color and generates a suitabl&#101; <tt>QPainterPath</tt><a name="node represents"></a> depending on w&#104;at kin&#100; o&#102; block the node re&#112;resent&#115;.</p>
<div class="docText"><pre>QRectF CityBlock::boundingRect() const
{
    return QRectF(-20, -20, 40, 40);
}</pre></div><br />
<p class="docText"><a name="iddle1161"></a><a name="iddle1166"></a><a name="iddle1574"></a><a name="iddle3356"></a><a name="iddle3536"></a><a name="iddle4212"></a><a name="iddle5113"></a><a name="iddle5114"></a><a name="iddle5121"></a><a name="iddle5274"></a><a name="iddle6001"></a><a name="iddle7842"></a><a name="occupies a"></a>Each block occupies a 40 x 40 squ&#97;re, with its center at (0, 0).</p>
<div class="docText"><pre>void CityBlock::paint(QPainter *painter,
                      const QStyleOptionGraphicsItem *option,
                      QWidget * /* widget */)
{
    if (option-&gt;levelOfDetail &lt; 4.0) {
        painter-&gt;fillPath(shape, color);
    } else {
        QLinearGradient gradient(QPoint(-20, -20), QPoint(+20, +20));
        int coeff = 105 + int(std::log(option-&gt;levelOfDetail - 4.0));
        gradient.setColorAt(0.0, color.lighter(coeff));
        gradient.setColorAt(1.0, color.darker(coeff));
        painter-&gt;fillPath(shape, gradient);
    }
}</pre></div><br />
<p class="docText">In <tt>paint()</tt>, we draw the shape using t&#104;e given <tt>QPainter</tt>. We distingui&#115;h two cases:</p>
<ul><li><p class="docList"><a name="a solid"></a>If the zoom factor is less than 4.0, we us&#101; a s&#111;li&#100; c&#111;lo&#114; to fill the shape.</p></li><li><p class="docList"><a name="If the"></a>If the zoom &#102;actor is 4.0 or more, we use a <tt>QLinearGradient</tt><a name="the shape"></a> to fill t&#104;e shap&#101; to &#103;ive a subtle l&#105;ghting eff&#101;ct.</p></li></ul>
<p class="docText">The <tt>levelOfDet&#97;il</tt><a name="of the"></a> member of the <tt>QStyleOptionGraphicsIte&#109;</tt><a name="zoom factor"></a> class stores a floating-point value that tells us what the zoom &#102;actor is. A value of 1.0 means that the sc&#101;ne &#105;s being &#118;iewed at it&#115; natura&#108; size, a value of 0.5 means that the sc&#101;ne has been zoomed out to half i&#116;s natura&#108; size, and a v&#97;lue of 2.5 means &#116;hat the scene has been &#122;oomed in to tw&#111; and a half times its natural size. Usi&#110;g the &quot;level of detail&quot; information allow&#115; us to use faster drawing algorithms for scenes that are &#122;oom&#101;d o&#117;t too much &#116;o show an&#121; detail.</p>
<p class="docText">The <tt>CityBlock</tt><a name="the fact"></a> graphics &#105;tem class works perfectly, but the fact that the it&#101;ms &#97;re scaled &#119;hen the scene is &#122;oomed r&#97;ises the question of what happens to items t&#104;at draw text. Normally, we don't want the text t&#111; scale with the scene. The graphic&#115; view architecture provide a general solution to this probl&#101;m, t&#104;rough &#116;he <tt>ItemI&#103;nore&#115;Transformations</tt> flag. This &#105;s what we use in the <tt>Annotation</tt> class:</p>
<div class="docText"><pre>class Annotation : public QGraphicsItem
{
public:
    Annotation(const QString &amp;text, bool major = false);

    void setText(const QString &amp;text);
    QString text() const;

    QRectF boundingRect() const;
    void paint(QPainter *painter,
               const QStyleOptionGraphicsItem *option, QWidget *widget);

private:
    QFont font;
    QString str;
    bool major;
    double threshold;
    int y;
};</pre></div><br />
<p class="docText"><a name="iddle1162"></a><a name="iddle1165"></a><a name="iddle4417"></a><a name="iddle5125"></a><a name="iddle5126"></a><a name="iddle5131"></a><a name="iddle5134"></a><a name="iddle7221"></a><a name="iddle7344"></a><a name="iddle7396"></a><a name="iddle8325"></a>The con&#115;tructo&#114; takes &#97; text and a <tt>bool</tt> flag, ca&#108;led <tt>major</tt><a name="a minor"></a>, that spe&#99;ifies whether the annotation is &#97; major or a minor annotation. This will affect the size &#111;f the font.</p>
<div class="docText"><pre>Annotation::Annotation(const QString &amp;text, bool major)
{
    font = qApp-&gt;font();
    font.setBold(true);
    if (major) {
        font.setPointSize(font.pointSize() + 2);
        font.setStretch(QFont::SemiExpanded);
    }

    if (major) {
        threshold = 0.01 * (40 + (std::rand() % 40));
    } else {
        threshold = 0.01 * (100 + (std::rand() % 100));
    }

    str = text;
    this-&gt;major = major;
    y = 20 - (std::rand() % 40);

    setZValue(1000);
    setFlag(ItemIgnoresTransformations, true);
}</pre></div><br />
<p class="docText"><a name="font to"></a>In the constructor, we begin by setting the &#102;ont to be bigger and bolder if this is a major annot&#97;tion, pres&#117;mably one &#116;hat refe&#114;s to an &#105;mportant building or landmark. Th&#101; threshold below which the anno&#116;ation wi&#108;l not be sho&#119;n is calculated pseud&#111;-rand&#111;mly, with a lower threshol&#100; for major annotations, so less &#105;mportant ones will disappear firs&#116; as the scene is zoomed out.</p>
<p class="docText">The <span class="docEmphasis">z</span><a name="annotations are"></a> value is set to 1000 to ensure &#116;hat anno&#116;ations a&#114;e on to&#112; of e&#118;erything else, and we use the <tt>It&#101;mIgnoresTransformations</tt><a name="ensure that"></a> flag to en&#115;ure tha&#116; the anno&#116;ation does n&#111;t change s&#105;ze no matter how much the scene &#105;s zoomed.</p>
<div class="docText"><pre>void Annotation::setText(const QString &amp;text)
{
    prepareGeometryChange();
    str = text;
    update();
}</pre></div><br />
<p class="docText"><a name="shorter than"></a>If the annotation's &#116;ext is changed, it might be longer or shorter t&#104;an before, so we must notify the graphics view a&#114;chite&#99;ture that th&#101; it&#101;m's &#103;eometry may change.</p>
<div class="docText"><pre>QRectF Annotation::boundingRect() const
{
    QFontMetricsF metrics(font);
    QRectF rect = metrics.boundingRect(str);
    rect.moveCenter(QPointF(0, y));
    rect.adjust(-4, 0, +4, 0);
    return rect;
}</pre></div><br />
<p class="docText"><a name="iddle1163"></a><a name="iddle1164"></a><a name="iddle1368"></a><a name="iddle1371"></a><a name="iddle1586"></a><a name="iddle2808"></a><a name="iddle4211"></a><a name="iddle5037"></a><a name="iddle5117"></a><a name="iddle5122"></a><a name="iddle5142"></a><a name="iddle7844"></a><a name="We get"></a>We get the font m&#101;trics for the annotation's font, and use the&#109; to calculat&#101; th&#101; text'&#115; bounding &#114;ectangle. We then move the recta&#110;gle's center point to the anno&#116;ation's <span class="docEmphasis">y</span><a name="the rectangle"></a> offset, and make the rectangle slightly w&#105;der. The extra pixels on the left and right sides of the bound&#105;ng rect&#97;ngle will &#103;ive t&#104;e text &#115;ome margin from the edge&#115;.</p>
<div class="docText"><pre>void Annotation::paint(QPainter *painter,
                       const QStyleOptionGraphicsItem *option,
                       QWidget * /* widget */)
{
    if (option-&gt;levelOfDetail &lt;= threshold)
        return;

    painter-&gt;setFont(font);

    QRectF rect = boundingRect();

    int alpha = int(30 * std::log(option-&gt;levelOfDetail));
    if (alpha &gt;= 32)
        painter-&gt;fillRect(rect, QColor(255, 255, 255, qMin(alpha, 63)));

    painter-&gt;setPen(Qt::white);
    painter-&gt;drawText(rect.translated(+1, +1), str,
                      QTextOption(Qt::AlignCenter));
    painter-&gt;setPen(Qt::blue);
    painter-&gt;drawText(rect, str, QTextOption(Qt::AlignCenter));
}</pre></div><br />
<p class="docText"><a name="the scene"></a>If the scene is zoomed out beyond the annotation's t&#104;resho&#108;d, we don't pa&#105;nt the ann&#111;tation at al&#108;. And if the scene is zoomed in s&#117;fficiently, we start by painting a semi-tra&#110;sparent white rectangle; this helps &#116;he text stand out when drawn on top of a dark block.</p>
<p class="docText"><a name="in blue"></a>We draw the text &#116;wice, onc&#101; in &#119;hite and onc&#101; in &#98;lue. The white text is offset by on&#101; pixel horizontally and vertically to cr&#101;at&#101; a s&#104;adow effec&#116; that makes t&#104;e text easier to read.</p>
<p class="docText"><a name="and annotations"></a>Having s&#101;en how the blocks and annota&#116;ions are done, we can now move on to the las&#116; aspect of the Cityscape application, the custom <tt>Q&#71;ra&#112;hic&#115;View</tt> su&#98;class:</p>
<div class="docText"><pre>class CityView : public QGraphicsView
{
    Q_OBJECT

public:
    CityView(QWidget *parent = 0);
protected:
    void wheelEvent(QWheelEvent *event);
};</pre></div><br />
<p class="docText"><a name="iddle1160"></a><a name="iddle1587"></a><a name="iddle1588"></a><a name="iddle2561"></a><a name="iddle4216"></a><a name="iddle4433"></a><a name="iddle4451"></a><a name="iddle5135"></a><a name="iddle5147"></a><a name="iddle5503"></a><a name="iddle5602"></a><a name="iddle5607"></a><a name="iddle6354"></a><a name="iddle6647"></a><a name="iddle7033"></a><a name="iddle8536"></a>By de&#102;ault, the <tt>QGraphicsView</tt><a name="does not"></a> cl&#97;ss provides scroll bars that appear automatically when nee&#100;e&#100;, b&#117;t does not prov&#105;de any mean&#115; of zooming the scene it is being &#117;sed to view. For this reason, we have created the tiny <tt>&#67;ityView</tt><a name="ability to"></a> subclass to provide the user with the abili&#116;y to zoom in and out using the mouse wheel.</p>
<div class="docText"><pre>CityView::CityView(QWidget *parent)
    : QGraphicsView(parent)
{
    setDragMode(ScrollHandDrag);
}</pre></div><br />
<p class="docText"><a name="is required"></a>Setting the d&#114;ag mod&#101; is &#97;ll that is &#114;equir&#101;d to support scrolli&#110;g by dragging.</p>
<div class="docText"><pre>void CityView::wheelEvent(QWheelEvent *event)
{
    double numDegrees = -event-&gt;delta() / 8.0;
    double numSteps = numDegrees / 15.0;
    double factor = std::pow(1.125, numSteps);
    scale(factor, factor);
}</pre></div><br />
<p class="docText"><a name="user rolls"></a>When the user rolls the mou&#115;e wheel, &#119;heel events &#97;re generated; we sim&#112;ly have to calc&#117;late an appropriate scaling facto&#114; and call <tt>QGraphicsView::scale()</tt><a name="scale the"></a>. The mathemati&#99;al formula is a bit tricky, but basically we scale the sce&#110;e up or down by a factor of 1.125 for every mouse wheel step.</p>
<p class="docText"><a name="That completes"></a>That c&#111;mp&#108;etes our tw&#111; gr&#97;phics vie&#119; examples. Qt's graphics view architecture i&#115; very rich, so bear in mind that it has a lot more &#116;o offer t&#104;an we h&#97;ve had the space to &#99;over. There is suppor&#116; for drag and drop, and graphic&#115; items can have tooltips and custom cursors. Ani&#109;ation effects can be achieved in a number of ways—for e&#120;ample, by associating <tt>QGraphicsItemAnimation</tt><a name="the items"></a>&#115; with th&#101; it&#101;ms &#116;hat we wa&#110;t to animate and p&#101;rforming the animation using a <tt>QTimeLin&#101;</tt><a name="is also"></a>. It &#105;s also p&#111;ssible to a&#99;hieve animation by cr&#101;ating custom graphic&#115; item subclasses that are derived from <tt>QObject</tt> (thro&#117;gh multiple inheritance) and that rei&#109;plement <tt>QObject::timerEvent()</tt>.</p>

</div></div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch08lev1sec3.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch08lev1sec5.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>