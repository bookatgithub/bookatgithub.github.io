<html>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<head>
<title>ch10lev1sec3.html</title>
<link rel="STYLESHEET" type="text/css" href="images/css1.css">
<link rel="STYLESHEET" type="text/css" href="images/css2.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch10lev1sec2.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch10lev1sec4.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<div style=""><div><a name="ch10lev1sec3"></a>
<h3 class="docSection1Title" id="-100000">Implementing Custom Models</h3>
<p class="docText"><a name="predefined models"></a>&#81;t's &#112;red&#101;fi&#110;e&#100; models offer a conv&#101;nient means of handling and viewing data. Howeve&#114;, some d&#97;ta source&#115; cannot be used effi&#99;iently using the p&#114;edefined mode&#108;s, and for these situations it is nec&#101;ssary to create custom models optimized for the under&#108;ying data source.</p>
<p class="docText"><a name="embark on"></a>Before we embark on creating custom mode&#108;s, let's firs&#116; review t&#104;e key c&#111;nc&#101;pts used in Qt's model/view ar&#99;hitecture. Every data element in a model has a model &#105;ndex an&#100; a &#115;et of attributes, &#99;alled <span class="docEmphasis">roles</span><a name="can take"></a>, that can t&#97;ke arbitrary values. We saw earlier in th&#101; chapter that the most commonl&#121; used roles are <tt>Qt::DisplayRole</tt> &#97;nd <tt>Qt::EditRole</tt>. Other roles are used for supplementary data (e.g., <tt>&#81;t::T&#111;ol&#84;ipRol&#101;</tt>, <tt>Qt::&#83;tatusTipRole</tt>, and <tt>Q&#116;::WhatsThisRole</tt>), and yet others &#102;or c&#111;nt&#114;olling basi&#99; display attribute&#115; (such as <tt>Qt::FontRole</tt>, <tt>&#81;t::TextAlignmentRole</tt>, <tt>&#81;t::TextColorRole</tt>, and <tt>Qt::BackgroundC&#111;lorRole</tt>).</p>
<p class="docText"><a name="the row"></a>For a list model, the only relevant &#105;ndex co&#109;ponent is th&#101; ro&#119; number, acce&#115;sible from <tt>QModelIndex::row()</tt><a name="index components"></a>. F&#111;r a table model, the relevant index comp&#111;ne&#110;t&#115; are the row and &#99;olumn numbers, acce&#115;sible from <tt>QModelIndex::row()</tt> a&#110;d <tt>QModelIndex::column()</tt><a name="which is"></a>. For both li&#115;t and table models, every item's parent is the root, w&#104;ich is represented by an invalid <tt>QMo&#100;e&#108;Index</tt><a name="show how"></a>. The f&#105;rst two &#101;xa&#109;ples in this section show how to implem&#101;nt custom table models.</p>
<p class="docText"><a name="table model"></a>A tree model is similar to a table mo&#100;e&#108;, with the fo&#108;lowing differe&#110;ces. L&#105;ke a table model, the parent &#111;f top-level items is the ro&#111;t (an invalid <tt>QModelIndex</tt><a name="other item"></a>), but every other i&#116;em's parent is some other item in the hierarchy. Pa&#114;ents a&#114;e acce&#115;sible f&#114;om <tt>QMo&#100;elIndex::parent()</tt><a name="each an"></a>. Every item ha&#115; its role data, and zero or more children, e&#97;ch an item &#105;n its ow&#110; right. Sin&#99;e items can have other i&#116;ems as children, it is possible to repre&#115;ent recursive (tree-like) data structures, as &#116;he final example in this section will show. <a class="docLink" href="#ch10fig09">Figure 10.9</a><a name="shows a"></a> sho&#119;s a schematic of the different models.</p>
<a name="ch10fig09"></a><p><center>

<h5 class="docFigureTitle"><a name="view of"></a>Figure 10.9. Schematic view of Qt's m&#111;de&#108;s</h5>

<p class="docText">
<img border="0" id="" width="490" height="226" src="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzZmlncGNmaDlnMTAvaTBpcy4-.jpg" alt="" /></p>


</center></p><br />
<p class="docText"><a name="first example"></a>The first &#101;xa&#109;ple in this s&#101;ction is a read-onl&#121; table model that shows currency values in relation to ea&#99;h other. The a&#112;pli&#99;ation is shown in <a class="docLink" href="#ch10fig10">Figure 10.10</a>.</p>
<a name="ch10fig10"></a><p><center>

<h5 class="docFigureTitle">Figure 10.10. T&#104;e Currenc&#105;es application</h5>
<p class="docText"><div class="st1"><a target="_blank" href="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzcC50cmVpcF9jaGNjZXUvbnJzc2FpZ2ps.jpg">[View full size image]</a></div><img border="0" id="" width="500" height="199" src="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzZ3JlaXBjLmhjZWN1L3Juc3NqaXA-.jpg" alt="" /></p>
</center></p><br />
<p class="docText"><a name="iddle1937"></a><a name="we want"></a>The application co&#117;ld be implemented using a si&#109;ple table, but we want to use a custom model to take adv&#97;ntage of certain properties of the data to minimize storage. &#73;f we w&#101;re &#116;o store t&#104;e 162 curr&#101;ntly traded currencies i&#110; a table, we would need to store 162 x 162 = 26244 v&#97;lues; with &#116;he custo&#109; <tt>CurrencyMode&#108;</tt><a name="to store"></a> shown in this secti&#111;n, we need to st&#111;re only 162 values (the value of each c&#117;rrency in relation to the U.S. do&#108;lar).</p>
<p class="docText">The <tt>CurrencyModel</tt> class will be used with a standard <tt>QTa&#98;leView</tt>. The <tt>&#67;urrencyM&#111;de&#108;</tt> is populat&#101;d with a <tt>QMap&lt;QString, do&#117;ble&gt;</tt><a name="is the"></a>; each key is a currency code &#97;nd each va&#108;ue is the va&#108;ue of the currency &#105;n U.S. dollars. Here's a &#99;ode snippet that shows how the map is popula&#116;ed and how the model is used:</p>
<div class="docText"><pre>    QMap&lt;QString, double&gt; currencyMap;
    currencyMap.insert("AUD", 1.3259);
    currencyMap.insert("CHF", 1.2970);
    ...
    currencyMap.insert("SGD", 1.6901);
    currencyMap.insert("USD", 1.0000);

    CurrencyModel currencyModel;
    currencyModel.setCurrencyMap(currencyMap);

    QTableView tableView;
    tableView.setModel(&amp;currencyModel);
    tableView.setAlternatingRowColors(true);</pre></div><br />
<p class="docText"><a name="iddle1685"></a><a name="iddle1936"></a><a name="iddle1938"></a><a name="iddle1939"></a><a name="iddle1943"></a><a name="iddle3866"></a><a name="iddle4624"></a><a name="iddle4626"></a><a name="iddle4645"></a><a name="iddle4671"></a><a name="iddle4678"></a><a name="iddle6977"></a><a name="iddle7824"></a><a name="of the"></a>Now we can look at the im&#112;lementation of the model, starting w&#105;th its header:</p>
<div class="docText"><pre>class CurrencyModel : public QAbstractTableModel
{
public:
    CurrencyModel(QObject *parent = 0);

    void setCurrencyMap(const QMap&lt;QString, double&gt; &amp;map);
    int rowCount(const QModelIndex &amp;parent) const;
    int columnCount(const QModelIndex &amp;parent) const;
    QVariant data(const QModelIndex &amp;index, int role) const;
    QVariant headerData(int section, Qt::Orientation orientation,
                        int role) const;
private:
    QString currencyAt(int offset) const;

    QMap&lt;QString, double&gt; currencyMap;
};</pre></div><br />
<p class="docText">We have chosen to subclass <tt>QAbstr&#97;ctTableM&#111;de&#108;</tt><a name="matches our"></a> for our mod&#101;l s&#105;nce that most closely matches our data &#115;ource. Qt provides several model base classes, including <tt>QAbs&#116;ractLis&#116;Model</tt>, <tt>QA&#98;stractTableModel</tt>, and <tt>&#81;AbstractI&#116;emModel</tt>; see <a class="docLink" href="#ch10fig11">Figure 10.11</a>. The <tt>QAbstractItemMod&#101;l</tt><a name="used to"></a> class is used to support a wide variety o&#102; models, including those that are base&#100; on recursive data structures, while the <tt>QAbst&#114;actLi&#115;tModel</tt> &#97;nd <tt>QAbstr&#97;ctTableM&#111;del</tt> classes are provi&#100;ed for convenienc&#101; wh&#101;n u&#115;ing one-di&#109;ensional or two-dimen&#115;ional data sets.</p>
<a name="ch10fig11"></a><p><center>

<h5 class="docFigureTitle">Figure 10.11. Inh&#101;ritance tree for the abstract m&#111;del classes</h5>

<p class="docText">
<img border="0" id="" width="281" height="82" src="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzZmlncGNmaDBnMTAvaTFpcy4-.jpg" alt="" /></p>


</center></p><br />
<p class="docText">For a read-only table model, we &#109;ust reimplement three functions: <tt>rowCount()</tt>, <tt>columnCount()</tt>, and <tt>data()</tt>. In this &#99;ase, we have a&#108;so reimple&#109;ented <tt>heade&#114;Data()</tt>, a&#110;d we provide a function to initial&#105;ze the data (<tt>setCurrencyMap()</tt>).</p>
<div class="docText"><pre>CurrencyModel::CurrencyModel(QObject *parent)
    : QAbstractTableModel(parent)
{
}</pre></div><br />
<p class="docText"><a name="except pass"></a>We do not need t&#111; do &#97;nything i&#110; the cons&#116;ructor, exc&#101;pt pass the <tt>parent</tt><a name="parameter to"></a> paramet&#101;r to the base class.</p>
<div class="docText"><pre>int CurrencyModel::rowCount(const QModelIndex &amp; /* parent */) const
{
    return currencyMap.count();
}
int CurrencyModel::columnCount(const QModelIndex &amp; /* parent */) const
{
    return currencyMap.count();
}</pre></div><br />
<p class="docText"><a name="iddle1138"></a><a name="iddle1680"></a><a name="iddle1941"></a><a name="iddle2008"></a><a name="iddle2009"></a><a name="iddle2177"></a><a name="iddle4630"></a><a name="iddle5400"></a><a name="iddle5404"></a><a name="iddle6037"></a><a name="iddle6075"></a><a name="iddle6972"></a><a name="iddle7995"></a><a name="table model"></a>Fo&#114; this table model, the row and column counts are &#116;he number of currencies in the currency map. The <tt>pare&#110;t</tt><a name="has no"></a> &#112;ara&#109;eter has no m&#101;an&#105;ng for a table model; it is there &#98;ecause <tt>rowCount()</tt> and <tt>columnCount()</tt> are inheri&#116;ed from t&#104;e more &#103;eneric <tt>QAbst&#114;actItemM&#111;del</tt> base class, which supports hierar&#99;hies.</p>
<div class="docText"><pre>QVariant CurrencyModel::data(const QModelIndex &amp;index, int role) const
{
    if (!index.isValid())
        return QVariant();

    if (role == Qt::TextAlignmentRole) {
        return int(Qt::AlignRight | Qt::AlignVCenter);
    } else if (role == Qt::DisplayRole) {
        QString rowCurrency = currencyAt(index.row());
        QString columnCurrency = currencyAt(index.column());

        if (currencyMap.value(rowCurrency) == 0.0)
            return "####";

        double amount = currencyMap.value(columnCurrency)
                        / currencyMap.value(rowCurrency);

        return QString("%1").arg(amount, 0, 'f', 4);
    }
    return QVariant();
}</pre></div><br />
<p class="docText">The <tt>data()</tt><a name="item is"></a> function returns the value of any of &#97;n item's roles. The item is specified as a <tt>QModelIndex</tt><a name="components of"></a>. &#70;or a table model, the interesting components of a <tt>&#81;Mo&#100;e&#108;Index</tt> are i&#116;s row and &#99;olumn number, available using <tt>row()</tt> and <tt>&#99;olumn()</tt>.</p>
<p class="docText">If the role is <tt>Qt::TextAlignment&#82;ole</tt><a name="role is"></a>, &#119;e return an a&#108;ignment suitable f&#111;r numbers. If t&#104;e display role is <tt>Qt::DisplayRole</tt><a name="currency and"></a>, &#119;e look up the value for each currency and calculate th&#101; exchange rate.</p>
<p class="docText"><a name="a"></a>We could return the calculated value &#97;s a <tt>double</tt><a name="we would"></a>, but then we would have no control over how ma&#110;y &#100;e&#99;imal places &#119;ere shown (un&#108;ess we use a custom delegate). Instead, w&#101; return the value as a string, formatted a&#115; we want.</p>
<div class="docText"><pre>QVariant CurrencyModel::headerData(int section,
                                   Qt::Orientation /* orientation */,
                                   int role) const
{
    if (role != Qt::DisplayRole)
        return QVariant();
    return currencyAt(section);
}</pre></div><br />
<p class="docText"><a name="iddle1303"></a><a name="iddle1570"></a><a name="iddle1576"></a><a name="iddle1935"></a><a name="iddle1940"></a><a name="iddle1942"></a><a name="iddle1944"></a><a name="iddle2573"></a><a name="iddle3000"></a><a name="iddle3006"></a><a name="iddle3417"></a><a name="iddle4636"></a><a name="iddle4642"></a><a name="iddle6886"></a><a name="iddle7164"></a>&#84;he <tt>hea&#100;erData()</tt><a name="horizontal and"></a> f&#117;nction is called by the &#118;iew to populate its horizontal and vertic&#97;l headers. The <tt>section</tt><a name="parameter is"></a> parameter is the row o&#114; column number (depending on the or&#105;entation). Since the rows and columns have the s&#97;me curren&#99;y codes, we do &#110;o&#116; care abo&#117;t the orientation and simply re&#116;urn the code of the currency fo&#114; the gi&#118;en section &#110;umber.</p>
<div class="docText"><pre>void CurrencyModel::setCurrencyMap(const QMap&lt;QString, double&gt; &amp;map)
{
    currencyMap = map;
    reset();
}</pre></div><br />
<p class="docText"><a name="can change"></a>The call&#101;r can change t&#104;e currency map usi&#110;g <tt>setCurrencyMap()</tt>. The <tt>&#81;AbstractItemModel::reset()</tt><a name="tells any"></a> call tells any &#118;iews that are using the model that all their da&#116;a is inva&#108;id; this for&#99;es them to re&#113;uest &#102;resh data for the item&#115; that are visible.</p>
<div class="docText"><pre>QString CurrencyModel::currencyAt(int offset) const
{
    return (currencyMap.begin() + offset).key();
}</pre></div><br />
<p class="docText">The <tt>currencyAt()</tt><a name="in the"></a> funct&#105;on retu&#114;ns the &#107;ey (the currency c&#111;de) at the give&#110; offset in the currency &#109;ap. We use an STL-style iterator to fin&#100; the item and call <tt>key()</tt> on it.</p>
<p class="docText"><a name="is not"></a>As we have just se&#101;n, it is not difficult to create read-only models, and d&#101;pe&#110;d&#105;ng on th&#101; na&#116;ure of the underlying &#100;ata, there are potential saving&#115; in memo&#114;y and s&#112;eed with a well-de&#115;igned mode&#108;. The next example, the Cities applic&#97;tion shown in <a class="docLink" href="#ch10fig12">Figure 10.12</a><a name="entered by"></a>, is also table-based, bu&#116; this time all the data is entered b&#121; the user.</p>
<a name="ch10fig12"></a><p><center>

<h5 class="docFigureTitle">Figure 10.12. The Cities application</h5>

<p class="docText">
<img border="0" id="" width="500" height="252" src="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzdHBpcGNoLmVjaS9pc3Nnag--.jpg" alt="" /></p>



</center></p><br />
<p class="docText"><a name="indicating the"></a>&#84;his ap&#112;lic&#97;tion is us&#101;d t&#111; store values indicating the di&#115;tance between any two cities. Like the previ&#111;us &#101;xa&#109;ple, we could simply u&#115;e a <tt>QTableWidget</tt><a name="a custom"></a> an&#100; store one item for every &#99;ity pair. However, a custom mode&#108; could be more efficient, because the distance f&#114;om any city <span class="docEmphasis">A</span><a name="different city"></a> to any different city <span class="docEmphasis">B</span> is the same whether travelin&#103; from <span class="docEmphasis">&#65;</span> to <span class="docEmphasis">B</span> or f&#114;om <span class="docEmphasis">B</span> to <span class="docEmphasis">&#65;</span>, so the i&#116;ems are mirrored along the main diagon&#97;l.</p>
<p class="docText"><a name="simple table"></a>To see how a custom model compares with a simple t&#97;ble, let us &#97;ssume tha&#116; we have three ci&#116;ies, <span class="docEmphasis">A</span>, <span class="docEmphasis">B</span><a name="and"></a>, and <span class="docEmphasis">C</span><a name="store a"></a>. &#73;f we store a value for every co&#109;bination, we would need to store nine values. A car&#101;fully designed model would require only &#116;he three items (<span class="docEmphasis">A</span>, <span class="docEmphasis">B</span>), (<span class="docEmphasis">A</span>, <span class="docEmphasis">C</span>), and (<span class="docEmphasis">B</span>, <span class="docEmphasis">C</span>).</p>
<p class="docText"><a name="we set"></a>Here's how we set up and &#117;se the mod&#101;l:</p>
<div class="docText"><pre>    QStringList cities;
    cities &lt;&lt; "Arvika" &lt;&lt; "Boden" &lt;&lt; "Eskilstuna" &lt;&lt; "Falun"
           &lt;&lt; "Filipstad" &lt;&lt; "Halmstad" &lt;&lt; "Helsingborg" &lt;&lt; "Karlstad"
           &lt;&lt; "Kiruna" &lt;&lt; "Kramfors" &lt;&lt; "Motala" &lt;&lt; "Sandviken"
           &lt;&lt; "Skara" &lt;&lt; "Stockholm" &lt;&lt; "Sundsvall" &lt;&lt; "Trelleborg";

    CityModel cityModel;
    cityModel.setCities(cities);

    QTableView tableView;
    tableView.setModel(&amp;cityModel);
    tableView.setAlternatingRowColors(true);</pre></div><br />
<p class="docText"><a name="iddle1575"></a><a name="iddle4679"></a><a name="iddle7825"></a><a name="for the"></a>W&#101; mu&#115;t reimp&#108;ement the same functions as we did fo&#114; the previous example. In addition, we mu&#115;t also r&#101;im&#112;lement <tt>&#115;etData()</tt> and <tt>flags()</tt><a name="is the"></a> t&#111; make the model editable. Here &#105;s the class definition:</p>
<div class="docText"><pre>class CityModel : public QAbstractTableModel
{
    Q_OBJECT

public:
    CityModel(QObject *parent = 0);

    void setCities(const QStringList &amp;cityNames);
    int rowCount(const QModelIndex &amp;parent) const;
    int columnCount(const QModelIndex &amp;parent) const;
    QVariant data(const QModelIndex &amp;index, int role) const;
    bool setData(const QModelIndex &amp;index, const QVariant &amp;value,
                 int role);
    QVariant headerData(int section, Qt::Orientation orientation,
                        int role) const;
    Qt::ItemFlags flags(const QModelIndex &amp;index) const;

private:
    int offsetOf(int row, int column) const;

    QStringList cities;
    QVector&lt;int&gt; distances;
};</pre></div><br />
<p class="docText"><a name="iddle1577"></a><a name="iddle1578"></a><a name="iddle1579"></a><a name="iddle1581"></a><a name="iddle1583"></a><a name="iddle1684"></a><a name="iddle2007"></a><a name="iddle2010"></a><a name="iddle2999"></a><a name="iddle4627"></a><a name="iddle4631"></a><a name="iddle4637"></a><a name="iddle4646"></a><a name="iddle6976"></a>For this model, w&#101; are using two data structures: <tt>cities</tt> of type <tt>&#81;StringList</tt> to hold the city names, and <tt>dista&#110;c&#101;s</tt> o&#102; typ&#101; <tt>QV&#101;ctor&lt;int&gt;</tt> to hold th&#101; distance between each uniqu&#101; pa&#105;r of cit&#105;es.</p>
<div class="docText"><pre>CityModel::CityModel(QObject *parent)
    : QAbstractTableModel(parent)
{
}</pre></div><br />
<p class="docText">The cons&#116;ructor does &#110;othing beyond pass&#105;ng on the <tt>parent</tt> parameter to the &#98;ase class.</p>
<div class="docText"><pre>int CityModel::rowCount(const QModelIndex &amp; /* parent */) const
{
    return cities.count();
}
int CityModel::columnCount(const QModelIndex &amp; /* parent */) const
{
    return cities.count();
}</pre></div><br />
<p class="docText"><a name="of rows"></a>Since we have a square grid of cities, the n&#117;mber of rows and columns is the number of cities in our list.</p>
<div class="docText"><pre>QVariant CityModel::data(const QModelIndex &amp;index, int role) const
{
    if (!index.isValid())
        return QVariant();

    if (role == Qt::TextAlignmentRole) {
        return int(Qt::AlignRight | Qt::AlignVCenter);
    } else if (role == Qt::DisplayRole) {
        if (index.row() == index.column())
            return 0;
        int offset = offsetOf(index.row(), index.column());
        return distances[offset];
    }
    return QVariant();
}</pre></div><br />
<p class="docText">The <tt>data()</tt><a name="in"></a> &#102;unc&#116;ion is si&#109;ilar to what &#119;e did in <tt>Curr&#101;ncyModel</tt><a name="are the"></a>. It returns 0 &#105;f the row and column are the same, because that corresp&#111;nd&#115; to the c&#97;se where the two c&#105;ties are th&#101; same; otherwise, it finds the entry &#102;or the given row and &#99;olumn in the <tt>distances</tt><a name="returns the"></a> vector and returns the &#100;istance for that particular pair of cities.</p>
<div class="docText"><pre>QVariant CityModel::headerData(int section,
                               Qt::Orientation /* orientation */,
                               int role) const
{
    if (role == Qt::DisplayRole)
        return cities[section];
    return QVariant();
}</pre></div><br />
<p class="docText"><a name="iddle1580"></a><a name="iddle1585"></a><a name="iddle1909"></a><a name="iddle2020"></a><a name="iddle2341"></a><a name="iddle2778"></a><a name="iddle3007"></a><a name="iddle3357"></a><a name="iddle3358"></a><a name="iddle3359"></a><a name="iddle4629"></a><a name="iddle4634"></a><a name="iddle4635"></a><a name="iddle4648"></a><a name="iddle6044"></a><a name="iddle6055"></a><a name="iddle6056"></a><a name="iddle6057"></a><a name="iddle7179"></a><a name="iddle7180"></a>T&#104;e <tt>head&#101;rD&#97;ta()</tt><a name="with every"></a> functi&#111;n i&#115; simple because we have a square ta&#98;le with every row having an identical column header. &#87;e simply r&#101;tu&#114;n the name of the c&#105;ty at the gi&#118;en offset in the <tt>cities</tt><a name="string list"></a> s&#116;ring list.</p>
<div class="docText"><pre>bool CityModel::setData(const QModelIndex &amp;index,
                        const QVariant &amp;value, int role)
{
    if (index.isValid() &amp;&amp; index.row() != index.column()
            &amp;&amp; role == Qt::EditRole) {
        int offset = offsetOf(index.row(), index.column());
        distances[offset] = value.toInt();

        QModelIndex transposedIndex = createIndex(index.column(),
                                                  index.row());
        emit dataChanged(index, index);
        emit dataChanged(transposedIndex, transposedIndex);
        return true;
    }
    return false;
}</pre></div><br />
<p class="docText">The <tt>setData()</tt><a name="called when"></a> function is called &#119;hen the user edits an item. Providi&#110;g the model index is valid, the two cities are differen&#116;, and the d&#97;ta elemen&#116; to modif&#121; is &#116;he <tt>Qt::EditRole</tt><a name="function stores"></a>, the function stor&#101;s the value the user ent&#101;re&#100; i&#110; the <tt>dist&#97;nces</tt> vector.</p>
<p class="docText">T&#104;e <tt>createIndex()</tt><a name="it to"></a> function is used to gen&#101;rate a model index. We need i&#116; to get the model index of the item o&#110; the other side of the main diagonal that corresponds w&#105;th the i&#116;em being &#115;et, sinc&#101; bo&#116;h items must show the same data. The <tt>cr&#101;ateIndex()</tt><a name="the column"></a> function takes the row &#98;efore the c&#111;lu&#109;n; here we invert &#116;he paramete&#114;s to get the model index of the di&#97;gonally opposite item to the one specifi&#101;d by <tt>index</tt>.</p>
<p class="docText">We emit the <tt>da&#116;aChanged()</tt><a name="was changed"></a> signal with the model index o&#102; the &#105;tem tha&#116; was chan&#103;ed. Th&#105;s signal takes two model indexes be&#99;ause it is possible for a change to affect a rectangu&#108;ar region o&#102; mor&#101; than one row a&#110;d column, so the &#105;ndexes passed are the i&#110;dex of the top-left and &#98;ottom-right items of those that have changed. W&#101; also emit the <tt>dataChanged()</tt><a name="that the"></a> signal for the tran&#115;posed i&#110;d&#101;x t&#111; en&#115;ure that the view will refresh the item. F&#105;nally, we return <tt>true</tt> or <tt>false</tt> to indicate wh&#101;th&#101;r t&#104;e edit succeed&#101;d.</p>
<div class="docText"><pre>Qt::ItemFlags CityModel::flags(const QModelIndex &amp;index) const
{
    Qt::ItemFlags flags = QAbstractItemModel::flags(index);
    if (index.row() != index.column())
        flags |= Qt::ItemIsEditable;
    return flags;
}</pre></div><br />
<p class="docText">The mode&#108; uses the <tt>flags()</tt><a name="with an"></a> function to co&#109;municate what can be done with an item (e.g., whet&#104;er it is editable). The default implementation from <tt>Q&#65;bstractTableModel</tt> returns <tt>Qt::ItemIsSelectable | Qt::Ite&#109;IsEnabled</tt><a name="the"></a>. W&#101; ad&#100; t&#104;e <tt>Qt::It&#101;mIsEditable</tt> <a name="iddle1345"></a><a name="iddle1360"></a><a name="iddle1582"></a><a name="iddle1584"></a><a name="iddle2567"></a><a name="iddle4125"></a><a name="iddle4643"></a><a name="iddle6008"></a><a name="iddle6887"></a><a name="iddle7140"></a><a name="diagonals "></a>flag for all items exc&#101;pt those lying on the diagona&#108;s (which are &#97;lways 0).</p>
<div class="docText"><pre>void CityModel::setCities(const QStringList &amp;cityNames)
{
    cities = cityNames;
    distances.resize(cities.count() * (cities.count() - 1) / 2);
    distances.fill(0);
    reset();
}</pre></div><br />
<p class="docText"><a name="If a"></a>If a &#110;ew list of citi&#101;s is given, w&#101; set the private <tt>QStringList</tt><a name="new list"></a> &#116;o the new list, resize and clear the <tt>distances</tt><a name="call"></a> vect&#111;r, and call <tt>QAbstractItemModel::reset()</tt><a name="be refetched"></a> to no&#116;ify any views that their visible items must be refetched.</p>
<div class="docText"><pre>int CityModel::offsetOf(int row, int column) const
{
    if (row &lt; column)
        qSwap(row, column);
    return (row * (row - 1) / 2) + column;
}</pre></div><br />
<p class="docText">The <tt>offs&#101;tO&#102;()</tt><a name="of a"></a> pri&#118;ate functi&#111;n c&#111;mputes the index o&#102; a given city pair in the <tt>distances</tt> vector. For e&#120;a&#109;ple, if we had &#99;ities <span class="docEmphasis">A</span>, <span class="docEmphasis">B</span>, <span class="docEmphasis">C</span>, and <span class="docEmphasis">D</span>, &#97;nd the user updat&#101;d row 3, column 1 (<span class="docEmphasis">B</span> to <span class="docEmphasis">D</span><a name="updated row"></a>), the of&#102;set would be 3 x (3 - 1)/2 + 1 = 4. If the user had instead &#117;pdated row 1, column 3 (<span class="docEmphasis">D</span> to <span class="docEmphasis">B</span>), thanks to the <tt>qSwap()</tt><a name="and an"></a> call, exactly the same c&#97;lculation would be performed a&#110;d &#97;n identic&#97;l offset w&#111;ul&#100; be returned. <a class="docLink" href="#ch10fig13">Figure 10.13</a><a name="table model"></a> illustrates t&#104;e relationships between cities, distances, &#97;nd the cor&#114;espon&#100;ing &#116;able model.</p>
<a name="ch10fig13"></a><p><center>

<h5 class="docFigureTitle">F&#105;gure 10.13. The <tt>cities</tt> and <tt>distance&#115;</tt><a name="and the"></a> data structures and the table &#109;odel</h5>

<p class="docText">
<img border="0" id="" width="488" height="116" src="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzZmlncGNmaDNnMTAvaTFpcy4-.jpg" alt="" /></p>


</center></p><br />
<p class="docText"><a name="that shows"></a>The last example in this section is a mode&#108; that shows the parse tree for a given Boolean expressio&#110;. A &#66;oolean e&#120;p&#114;essio&#110; is either a simple alphan&#117;meric identifier, such as &quot;bravo&quot;, a complex express&#105;on buil&#116; from sim&#112;ler exp&#114;essions &#117;sing the &quot;&amp;&amp;&quot;, &quot;||&quot;, or &quot;!&quot; operators, or a parenthesi&#122;ed expression. For e&#120;ample, &quot;a || (b &amp;&amp; !c)&quot; is a Boolean expressio&#110;.</p>
<p class="docText"><a name="The Boolean"></a>The Boolean Parser application, show&#110; i&#110; <a class="docLink" href="#ch10fig14">Figure 10.14</a><a name="four classes"></a>, c&#111;ns&#105;sts of f&#111;ur classes:</p>
<ul><li><p class="docList"><tt>BooleanWindow</tt><a name="a window"></a> is a &#119;indow that lets the user enter a Boolean e&#120;p&#114;essio&#110; and &#115;hows the co&#114;responding parse tr&#101;e.</p></li><li><p class="docList"><a name="iddle1358"></a><a name="iddle4027"></a><a name="iddle4029"></a><tt>BooleanParser</tt> ge&#110;erates a parse tree from a Bo&#111;lean expression.</p></li><li><p class="docList"><tt>BooleanModel</tt> is a tree model t&#104;at enc&#97;psulates &#97; parse tre&#101;.</p></li><li><p class="docList"><tt>No&#100;e</tt> represents an item &#105;n a parse tree.</p></li></ul>
<a name="ch10fig14"></a><p><center>

<h5 class="docFigureTitle">Figure 10.14. The Boole&#97;n Parser a&#112;pli&#99;ation</h5>

<p class="docText">
<img border="0" id="" width="451" height="348" src="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzZ2oub2FpcHNjaG5iZW8vYWxzcmVwcHI-.jpg" alt="" /></p>



</center></p><br />
<p class="docText">Let's start with &#116;he <tt>Node</tt> class:</p>
<div class="docText"><pre>class Node
{
public:
    enum Type { Root, OrExpression, AndExpression, NotExpression, Atom,
                Identifier, Operator, Punctuator };

    Node(Type type, const QString &amp;str = "");
    ~Node();

    Type type;
    QString str;
    Node *parent;
    QList&lt;Node *&gt; children;
};</pre></div><br />
<p class="docText"><a name="parent "></a>Every n&#111;de has a type, a string (whi&#99;h may be empty), a parent (which may be nu&#108;l), and a list of child nodes (which may be empty).</p>
<div class="docText"><pre>Node::Node(Type type, const QString &amp;str)
{
    this-&gt;type = type;
    this-&gt;str = str;
    parent = 0;
}</pre></div><br />
<p class="docText"><a name="iddle1346"></a><a name="iddle1347"></a><a name="iddle1603"></a><a name="iddle2086"></a><a name="iddle3051"></a><a name="iddle4031"></a><a name="iddle4625"></a><a name="iddle4916"></a><a name="iddle7823"></a><a name="type and"></a>&#84;he constructor simply initializes the node'&#115; type an&#100; s&#116;ring, and &#115;ets the &#112;arent to null (no pare&#110;t). Because all the data is public, code that uses <tt>Node</tt> ca&#110; m&#97;nipulate &#116;he type, string, par&#101;nt, and childr&#101;n directly.</p>
<div class="docText"><pre>Node::~Node()
{
    qDeleteAll(children);
}</pre></div><br />
<p class="docText">The <tt>qDeleteAll()</tt> fun&#99;tion iterates over a container of poi&#110;ters and calls <tt>delete</tt><a name="so if"></a> on each one. &#73;t does not set the pointers to null, so if it is used outs&#105;de of a d&#101;st&#114;uctor &#105;t is com&#109;on to follow it with a call to <tt>clear()</tt> on t&#104;e container that holds the pointers.</p>
<p class="docText"><a name="items "></a>Now that we h&#97;ve define&#100; o&#117;r data items (each repre&#115;ented by a <tt>N&#111;de</tt>), we are ready to creat&#101; a model:</p>
<div class="docText"><pre>class BooleanModel : public QAbstractItemModel
{
public:
    BooleanModel(QObject *parent = 0);
    ~BooleanModel();

    void setRootNode(Node *node);

    QModelIndex index(int row, int column,
                      const QModelIndex &amp;parent) const;
    QModelIndex parent(const QModelIndex &amp;child) const;

    int rowCount(const QModelIndex &amp;parent) const;
    int columnCount(const QModelIndex &amp;parent) const;
    QVariant data(const QModelIndex &amp;index, int role) const;
    QVariant headerData(int section, Qt::Orientation orientation,
                        int role) const;
private:
    Node *nodeFromIndex(const QModelIndex &amp;index) const;

    Node *rootNode;
};</pre></div><br />
<p class="docText">This time we have used <tt>QAbs&#116;ractItemModel</tt><a name="convenience subclass"></a> as the base class rather than its conveni&#101;nce subclass <tt>QAbstractTableModel</tt><a name="want to"></a>, because we want to creat&#101; a h&#105;erarch&#105;cal mod&#101;l. T&#104;e essential functions tha&#116; we must reimplement remain the same, e&#120;c&#101;pt &#116;hat we must also i&#109;plement <tt>index()</tt> a&#110;d <tt>parent()</tt>. To set t&#104;e model's data, we have a <tt>setRootNode()</tt> function t&#104;at must be called with a parse tree's root no&#100;e.</p>
<div class="docText"><pre>BooleanModel::BooleanModel(QObject *parent)
    : QAbstractItemModel(parent)
{
    rootNode = 0;
}</pre></div><br />
<p class="docText"><a name="iddle1348"></a><a name="iddle1353"></a><a name="iddle1354"></a><a name="iddle1357"></a><a name="iddle3205"></a><a name="iddle3286"></a><a name="iddle4043"></a><a name="iddle4639"></a><a name="iddle4644"></a><a name="iddle6888"></a><a name="iddle7307"></a><a name="iddle8479"></a><a name="node to"></a>In the model's constructor, we just need to set the root &#110;o&#100;e &#116;o a safe n&#117;ll value a&#110;d pass on the <tt>pare&#110;t</tt><a name="to the"></a> to the base class.</p>
<div class="docText"><pre>BooleanModel::~BooleanModel()
{
    delete rootNode;
}</pre></div><br />
<p class="docText"><a name="we delete"></a>In the destructor, &#119;e delete the &#114;oot no&#100;e. If the &#114;oot node &#104;as children, each of these is del&#101;ted, and so on recursively, b&#121; the <tt>Node</tt> destructor.</p>
<div class="docText"><pre>void BooleanModel::setRootNode(Node *node)
{
    delete rootNode;
    rootNode = node;
    reset();
}</pre></div><br />
<p class="docText"><a name="a new"></a>When a &#110;ew root node is set, we begin by deleting any previou&#115; root no&#100;e (&#97;nd all of i&#116;s childr&#101;n). Then we set the new r&#111;ot node and call <tt>reset()</tt><a name="data for"></a> to notify any v&#105;ews tha&#116; they mus&#116; refetch the data f&#111;r any &#118;isible items.</p>
<div class="docText"><pre>QModelIndex BooleanModel::index(int row, int column,
                                const QModelIndex &amp;parent) const
{
    if (!rootNode || row &lt; 0 || column &lt; 0)
        return QModelIndex();
    Node *parentNode = nodeFromIndex(parent);
    Node *childNode = parentNode-&gt;children.value(row);
    if (!childNode)
        return QModelIndex();
    return createIndex(row, column, childNode);
}</pre></div><br />
<p class="docText">The <tt>index()</tt> function is reimpl&#101;mented from <tt>QAbstractI&#116;emModel</tt><a name="model or"></a>. It is called whenever the mode&#108; or the view needs to create a <tt>QModelIndex</tt> f&#111;r a &#112;art&#105;cular c&#104;ild it&#101;m (or a top-level item if <tt>par&#101;nt</tt> is an invalid <tt>QModelIndex</tt><a name="because"></a>). For table and list model&#115;, we don't &#110;e&#101;d to re&#105;mplement &#116;his function, because <tt>QAbstractListMo&#100;el</tt>'s and <tt>QAbstractTableModel</tt>'s defa&#117;lt implementations normally suffice.</p>
<p class="docText">In our <tt>&#105;ndex()</tt><a name="an invalid"></a> implementation, if no parse tree i&#115; set, we r&#101;tu&#114;n an in&#118;alid <tt>QMode&#108;Index</tt>. Otherwise, we creat&#101; a <tt>QModelIndex</tt><a name="with a"></a> with the given row and column &#97;nd with a <tt>N&#111;de *</tt><a name="requested child"></a> &#102;or the requ&#101;sted c&#104;ild. For hierarchical models, kno&#119;ing the row and column of an item relative to it&#115; parent is not enough to uniquely identif&#121; it; we must also know <span class="docEmphasis">who</span><a name="to the"></a> its parent is. To solve this, we ca&#110; s&#116;ore a poi&#110;t&#101;r t&#111; the internal node &#105;n the <tt>QModelIndex</tt>. <tt>QModelIndex</tt><a name="gives us"></a> g&#105;ves us t&#104;e opti&#111;n of sto&#114;ing a <tt>void *</tt> &#111;r an <tt>int</tt><a name="to the"></a> in addit&#105;on to the row and column numbers.</p>
<p class="docText">The <tt>Node *</tt><a name="the child"></a> for the &#99;hild is obtained through the parent node'&#115; <tt>children</tt> list. The parent node is extracted from the <tt>pare&#110;t</tt> &#109;odel index u&#115;ing the <tt>&#110;o&#100;eFromInd&#101;x()</tt> private function:</p>
<div class="docText"><pre>Node *BooleanModel::nodeFromIndex(const QModelIndex &amp;index) const
{
    if (index.isValid()) {
        return static_cast&lt;Node *&gt;(index.internalPointer());
    } else {
        return rootNode;
    }
}</pre></div><br />
<p class="docText"><a name="iddle1350"></a><a name="iddle1351"></a><a name="iddle1355"></a><a name="iddle1356"></a><a name="iddle1683"></a><a name="iddle2005"></a><a name="iddle2011"></a><a name="iddle3262"></a><a name="iddle4255"></a><a name="iddle4264"></a><a name="iddle4628"></a><a name="iddle4632"></a><a name="iddle4640"></a><a name="iddle4647"></a><a name="iddle5401"></a><a name="iddle6975"></a>The <tt>nodeFr&#111;mI&#110;d&#101;x()</tt> function ca&#115;ts the given ind&#101;x's <tt>void *</tt> to a <tt>Node *</tt><a name="since an"></a>, or return&#115; the root node if the index is invali&#100;, since an invalid model index is used to rep&#114;esent the root in a model.</p>
<div class="docText"><pre>int BooleanModel::rowCount(const QModelIndex &amp;parent) const
{
    if (parent.column() &gt; 0)
        return 0;
    Node *parentNode = nodeFromIndex(parent);
    if (!parentNode)
        return 0;
    return parentNode-&gt;children.count();
}</pre></div><br />
<p class="docText"><a name="a given"></a>The number of rows for a given &#105;tem is s&#105;mply ho&#119; many childr&#101;n i&#116; has.</p>
<div class="docText"><pre>int BooleanModel::columnCount(const QModelIndex &amp; /* parent */) const
{
    return 2;
}</pre></div><br />
<p class="docText"><a name="column holds"></a>The number of columns is fixed a&#116; 2. The first column holds the node types; t&#104;e seco&#110;d &#99;olumn holds the node v&#97;lues.</p>
<div class="docText"><pre>QModelIndex BooleanModel::parent(const QModelIndex &amp;child) const
{
    Node *node = nodeFromIndex(child);
    if (!node)
        return QModelIndex();
    Node *parentNode = node-&gt;parent;
    if (!parentNode)
        return QModelIndex();
    Node *grandparentNode = parentNode-&gt;parent;
    if (!grandparentNode)
        return QModelIndex();

    int row = grandparentNode-&gt;children.indexOf(parentNode);
    return createIndex(row, 0, parentNode);
}</pre></div><br />
<p class="docText">Retrieving t&#104;e parent <tt>QMode&#108;Index</tt><a name="work than"></a> from a child is a bit more work than finding a par&#101;nt's child. We can easily retrieve the &#112;arent node using <tt>nodeFromI&#110;d&#101;x()</tt> a&#110;d &#103;oing &#117;p using the <tt>Node</tt><a name="position of"></a>'s parent &#112;ointer, but to obtain the row number (the posi&#116;ion of th&#101; pa&#114;ent among &#105;ts siblings), we n&#101;ed to go back to the grand&#112;arent and find the parent's i&#110;dex position in its parent's (i.e., the c&#104;ild's grandparent's) list of children.</p>
<div class="docText"><div class="codeSegmentsExpansionLinks">
              Code View:</div><pre class="">QVariant BooleanModel::data(const QModelIndex &amp;index, int role) const
{
    if (role != Qt::DisplayRole)
        return QVariant();

    Node *node = nodeFromIndex(index);
    if (!node)
        return QVariant();

    if (index.column() == 0) {
        switch (node-&gt;type) {
        case Node::Root:
             return tr("Root");
        case Node::OrExpression:
            return tr("OR Expression");
        case Node::AndExpression:
            return tr("AND Expression");
        case Node::NotExpression:
            return tr("NOT Expression");
        case Node::Atom:
            return tr("Atom");
        case Node::Identifier:
            return tr("Identifier");
        case Node::Operator:
            return tr("Operator");
        case Node::Punctuator:
            return tr("Punctuator");
        default:
            return tr("Unknown");
        }
    } else if (index.column() == 1) {
        return node-&gt;str;
    }
    return QVariant();
}

					  </pre></div><br />
<p class="docText"><a name="iddle1352"></a><a name="iddle2178"></a><a name="iddle2998"></a><a name="iddle4638"></a><a name="iddle6038"></a>In <tt>data()</tt><a name="the"></a>, we retr&#105;eve the <tt>&#78;ode *</tt><a name="access the"></a> for the &#114;eques&#116;ed item a&#110;d we use it to access the underlying &#100;ata. If the caller wants a value for any &#114;ole ex&#99;ept <tt>Qt::Displ&#97;yRole</tt><a name="or if"></a> or if we c&#97;nnot retrieve a <tt>No&#100;e</tt><a name="given model"></a> for the given m&#111;del index, we return an invalid <tt>QVariant</tt><a name="the column"></a>. If the c&#111;lumn is 0, we return the name of the node'&#115; type; if the column is 1, we return the node's value (i&#116;s string).</p>
<div class="docText"><pre>QVariant BooleanModel::headerData(int section,
                                  Qt::Orientation orientation,
                                  int role) const
{
    if (orientation == Qt::Horizontal &amp;&amp; role == Qt::DisplayRole) {
        if (section == 0) {
            return tr("Node");
        } else if (section == 1) {
            return tr("Value");
        }
    }
    return QVariant();
}</pre></div><br />
<p class="docText"><a name="iddle1285"></a><a name="iddle1344"></a><a name="iddle1349"></a><a name="iddle1359"></a><a name="iddle1980"></a><a name="iddle2012"></a><a name="iddle2077"></a><a name="iddle2632"></a><a name="iddle2813"></a><a name="iddle3008"></a><a name="iddle4633"></a><a name="iddle6023"></a><a name="iddle6051"></a><a name="iddle6076"></a><a name="iddle6078"></a><a name="iddle6397"></a><a name="iddle7996"></a><a name="iddle8009"></a><a name="iddle8171"></a><a name="iddle8217"></a>&#73;n our <tt>&#104;eader&#68;ata()</tt> reimpl&#101;mentation, we return appr&#111;priate horizontal header labels. The <tt>QTreeVi&#101;w</tt><a name="so we"></a> c&#108;ass, which i&#115; used to visualize h&#105;erarchical mod&#101;ls, has no vertical hea&#100;er, so we ignore that possibility.</p>
<p class="docText"><a name="the"></a>&#78;ow that we have covered the <tt>Node</tt> and <tt>BooleanM&#111;del</tt><a name="user changes"></a> classes, let's see how the root node is created w&#104;en the &#117;ser chang&#101;s t&#104;e text &#105;n the line editor:</p>
<div class="docText"><pre>void BooleanWindow::booleanExpressionChanged(const QString &amp;expr)
{
    BooleanParser parser;
    Node *rootNode = parser.parse(expr);
    booleanModel-&gt;setRootNode(rootNode);
}</pre></div><br />
<p class="docText"><a name="the application"></a>When t&#104;e user changes the text in the application's lin&#101; ed&#105;tor, the &#109;ain window's <tt>booleanExp&#114;essionC&#104;anged()</tt><a name="parsed and"></a> slot is called. In this slot, t&#104;e user's text is parsed and &#116;he parser returns a pointer to the ro&#111;t node of the parse tree.</p>
<p class="docText"><a name="not shown"></a>We ha&#118;e not shown &#116;he <tt>Boole&#97;nParser</tt><a name="The full"></a> c&#108;ass becaus&#101; it is not relevant for GUI or mod&#101;l/view programming. The full source for t&#104;is exa&#109;ple is provi&#100;ed w&#105;th the book'&#115; examples.</p>
<p class="docText"><a name="When implementing"></a>When implementing t&#114;ee models such as <tt>Boolean&#77;odel</tt><a name="be quite"></a>, it can be quite easy to make mistakes, r&#101;sulting in strange behavior of <tt>QTreeView</tt><a name="help find"></a>. To help find and solve p&#114;oblem&#115; in cust&#111;m d&#97;ta models, &#97; <tt>ModelTest</tt><a name="series of"></a> class is available from &#84;rolltech Labs. The class performs a series of tests on t&#104;e mode&#108; to catch co&#109;mon errors. To us&#101; <tt>Mode&#108;Test</tt>, download it from <a class="docLink" target="_blank" href="http://labs.trolltech.com/page/Projects/Itemview/Modeltest">http://labs.trolltech.com/page/Projects/Itemview/Modeltest</a><a name="in the"></a> and &#102;ollow the instructions &#103;iven in the <tt>README</tt> file.</p>
<p class="docText"><a name="different custom"></a>In this section, we ha&#118;e seen how to create three different &#99;ustom model&#115;. Many mo&#100;e&#108;s are much s&#105;mpler than those shown here, wi&#116;h one-to-one correspondences betw&#101;en &#105;tems an&#100; mode&#108; indexes. Further m&#111;del/view examples are provided wit&#104; Qt itself, along with extens&#105;ve documentation.</p>

</div></div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch10lev1sec2.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch10lev1sec4.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>