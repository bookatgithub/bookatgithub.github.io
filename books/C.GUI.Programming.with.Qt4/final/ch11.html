<html>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<head>
<title>ch11.html</title>
<link rel="STYLESHEET" type="text/css" href="images/css1.css">
<link rel="STYLESHEET" type="text/css" href="images/css2.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch10lev1sec4.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch11lev1sec1.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<div style=""><div><a name="ch11"></a>

<h2 id="title-ID0E1KOM" class="docChapterTitle">11. Container Classes</h2>



<p class="docText">
<img border="0" id="" width="170" height="100" src="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzcmduZV9laXBjX2hwaDExL2FjcnNvdGouZXBw.jpg" alt="" /></p>



<ul><li><p class="docList"><a name="iddle1128"></a><a name="iddle1455"></a><a name="iddle1820"></a><a name="iddle2894"></a><a name="iddle4880"></a><a name="iddle7577"></a><a name="iddle7692"></a><a name="iddle7704"></a><a name="iddle7765"></a><span class="docEmphasis"><a class="docLink" href="ch11lev1sec1.html#ch11lev1sec1">Sequential Containers</a></span></p></li><li><p class="docList"><span class="docEmphasis"><a class="docLink" href="ch11lev1sec2.html#ch11lev1sec2">Associative Containers</a></span></p></li><li><p class="docList"><span class="docEmphasis"><a class="docLink" href="ch11lev1sec3.html#ch11lev1sec3">Generic Algorithms</a></span></p></li><li><p class="docList"><span class="docEmphasis"><a class="docLink" href="ch11lev1sec4.html#ch11lev1sec4">Strings, Byte Arrays, and Variants</a></span></p></li></ul>
<p class="docText"><a name="Container classes"></a>&#67;ontainer &#99;lasses are g&#101;ne&#114;al-pur&#112;ose template classes that store it&#101;ms of a given type in memory. C++ already of&#102;ers &#109;any contain&#101;rs as part of t&#104;e Standa&#114;d Template Library (STL), which is &#105;ncluded in the Standa&#114;d C++ library.</p>
<p class="docText"><a name="its own"></a>Qt provides its own container cl&#97;sses, so for Qt programs we can use both the Qt and the STL containers. T&#104;e main &#97;dvantage&#115; of the Q&#116; contain&#101;rs are that they beha&#118;e the same on all platforms and that they are implici&#116;ly share&#100;. I&#109;plicit sharing, or &quot;co&#112;y on write&quot;, is an op&#116;imization that makes i&#116; possible to pass entire cont&#97;iners as values without any significant performa&#110;ce cost. The Qt containers also feature easy-to-&#117;se iterat&#111;r c&#108;asses insp&#105;red by J&#97;va, they can be streamed &#117;sing <tt>QDataStream</tt><a name="they usually"></a>, and they usually result in less c&#111;de &#105;n the ex&#101;cutable tha&#110; the corr&#101;sponding STL cont&#97;iners. Finally, on some hardware plat&#102;orms supported by Qt/Embedded Linux, the Qt co&#110;tainers are the only ones available.</p>
<p class="docText">Qt offers both se&#113;uent&#105;al cont&#97;iners suc&#104; as <tt>QVe&#99;tor&lt;T&gt;</tt>, <tt>QLinkedList&lt;T&gt;</tt>, and <tt>QLi&#115;t&lt;T&gt;</tt>, and associative containers such as <tt>QMap&lt;K, T&gt;</tt> a&#110;d <tt>&#81;Ha&#115;h&lt;K, T&gt;</tt><a name="associative containers"></a>. Conceptually, th&#101; sequent&#105;al containers store items one aft&#101;r another, whereas the assoc&#105;ative containers store key–value pairs.</p>
<p class="docText"><a name="that perform"></a>Qt a&#108;so provides generic algorithms that perform operation&#115; on arbi&#116;rary con&#116;ainers. F&#111;r e&#120;ample, the <tt>qSort()</tt> algorithm sort&#115; a sequential container, and <tt>qBinaryFind()</tt><a name="algorithms are"></a> &#112;erf&#111;rm&#115; a binary se&#97;rch on a sorted se&#113;uential container. These al&#103;orithms are similar to those offer&#101;d by the STL.</p>
<p class="docText"><a name="STL containers"></a>If you are already f&#97;miliar with the STL containers and have STL available on your ta&#114;get pl&#97;tforms, yo&#117; might wan&#116; to use th&#101;m instead of, or in addit&#105;on to, the Qt containers. For more informa&#116;ion abou&#116; the STL c&#108;asses and functions, a &#103;ood place to star&#116; is SGI's STL web site: <a class="docLink" target="_blank" href="http://www.sgi.com/tech/stl/">http://www.sgi.com/tech/stl/</a>.</p>
<p class="docText">In this chapt&#101;r, we will also look at <tt>QString</tt>, <tt>QBy&#116;eArray</tt>, and <tt>QVariant</tt><a name="with containers"></a>, since they ha&#118;e a lot in common with containers. <tt>QString</tt><a name="Unicode string"></a> is a 16-bit Unicode &#115;tring u&#115;ed thro&#117;ghout Qt's &#65;PI. <tt>QByt&#101;Array</tt> is an array of 8-&#98;it <tt>char</tt>s useful for storing raw binary data. <tt>QVaria&#110;t</tt><a name="value types"></a> &#105;s a type &#116;hat can store most &#67;++ and Qt value types.</p>




<a name="ch11lev1sec1"></a>

<h3 class="docSection1Title" id="-100000">Sequential Containers</h3>
<p class="docText"><a name="iddle1022"></a><a name="iddle1184"></a><a name="iddle1218"></a><a name="iddle1786"></a><a name="iddle1815"></a><a name="iddle1835"></a><a name="iddle1886"></a><a name="iddle2057"></a><a name="iddle3569"></a><a name="iddle4171"></a><a name="iddle4180"></a><a name="iddle5276"></a><a name="iddle6469"></a><a name="iddle7108"></a><a name="iddle8418"></a><a name="A"></a>A <tt>Q&#86;ector&lt;T&gt;</tt><a name="data structure"></a> is an array-like data str&#117;cture that stores its items at adjacent positio&#110;s in memory, as <a class="docLink" href="#ch11fig01">Figure 11.1</a><a name="distinguishes a"></a> illustrates. What distingu&#105;shes a vector from a plain C++ array is that a vector know&#115; its own &#115;ize and &#99;an be resize&#100;. A&#112;pending ext&#114;a items to the end of a vector is fairly eff&#105;cient, w&#104;ereas &#105;nserting &#105;tems at the front &#111;r in the middle of a vecto&#114; can be expensive.</p>
<a name="ch11fig01"></a><p><center>

<h5 class="docFigureTitle">Figure 11.1. A vec&#116;or of <tt>double</tt>s</h5>

<p class="docText">
<img border="0" id="" width="282" height="41" src="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzZmlncGNmaDFnMTEvaTBpcy4-.jpg" alt="" /></p>


</center></p><br />
<p class="docText"><a name="are going"></a>If we know in advance how ma&#110;y items we are going to need, we can g&#105;ve the v&#101;ct&#111;r a&#110; i&#110;itial size when we define it &#97;nd use the <tt>[]</tt><a name="to the"></a> operator to assign a value to the it&#101;ms; &#111;th&#101;rwise, we mu&#115;t either resiz&#101; the vector later on or a&#112;pend items. Here's an example w&#104;ere we specify the initial size:</p>
<div class="docText"><pre>QVector&lt;double&gt; vect(3);
vect[0] = 1.0;
vect[1] = 0.540302;
vect[2] = -0.416147;</pre></div><br />
<p class="docText"><a name="and using"></a>Here's the same &#101;xample, this time starting with an empty vector and using t&#104;e <tt>appe&#110;d()</tt> &#102;unc&#116;ion to ap&#112;end items at the end:</p>
<div class="docText"><pre>QVector&lt;double&gt; vect;
vect.append(1.0);
vect.append(0.540302);
vect.append(-0.416147);</pre></div><br />
<p class="docText">We can also use t&#104;e <tt>&lt;&lt;</tt> operator instead of <tt>append()</tt>:</p>
<div class="docText"><pre>vect &lt;&lt; 1.0 &lt;&lt; 0.540302 &lt;&lt; -0.416147;</pre></div><br />
<p class="docText"><a name="is to"></a>One way to iterat&#101; ov&#101;r t&#104;e vector's &#105;tems is to use <tt>[]</tt> and <tt>&#99;ount()</tt>:</p>
<div class="docText"><pre>double sum = 0.0;
for (int i = 0; i &lt; vect.count(); ++i)
    sum += vect[i];</pre></div><br />
<p class="docText"><a name="assigned an"></a>Vector entries that are crea&#116;ed without being assigned an exp&#108;icit value are initialized using the item class's default construc&#116;or. Basic types and pointer types are initialized to zero.</p>
<p class="docText"><a name="at the"></a>In&#115;erting &#105;tems at &#116;he begin&#110;i&#110;g or in the midd&#108;e of a <tt>QVector&lt;T&gt;</tt><a name="large vectors"></a>, or removing items from the&#115;e posit&#105;ons, can &#98;e inefficient &#102;or large vecto&#114;s. For this reason, Qt also offer&#115; <tt>QLinkedList&lt;T&gt;</tt><a name="a data"></a>, a data structure that st&#111;res its items at non-adjacent locations in memor&#121;, as illustrated by <a class="docLink" href="#ch11fig02">Figure 11.2</a><a name="lists don"></a>. Unlike vectors, linked lists don't su&#112;por&#116; random a&#99;cess, but the&#121; pr&#111;vide &quot;constant time&quot; in&#115;ertions and removals.</p>

<p class="docText"></p><a name="ch11fig02"></a><p><center>

<h5 class="docFigureTitle"><a name="A linked"></a>Figure 11.2. A linked list of <tt>dou&#98;le</tt>s</h5>

<p class="docText">
<img border="0" id="" width="433" height="47" src="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzZmlncGNmaDJnMTEvaTBpcy4-.jpg" alt="" /></p>


</center></p><br />
<p class="docText"><a name="iddle1030"></a><a name="iddle1152"></a><a name="iddle1181"></a><a name="iddle1219"></a><a name="iddle1232"></a><a name="iddle1781"></a><a name="iddle1816"></a><a name="iddle1818"></a><a name="iddle1823"></a><a name="iddle1825"></a><a name="iddle1878"></a><a name="iddle2098"></a><a name="iddle2411"></a><a name="iddle2997"></a><a name="iddle3229"></a><a name="iddle3369"></a><a name="iddle3592"></a><a name="iddle4386"></a><a name="iddle4569"></a><a name="iddle5278"></a><a name="iddle5440"></a><a name="iddle5652"></a><a name="iddle5883"></a><a name="iddle5960"></a><a name="iddle6428"></a><a name="iddle7690"></a><a name="iddle8149"></a><a name="iddle8400"></a>Linked &#108;ists do not &#112;rovide the <tt>[]</tt><a name="are also"></a> o&#112;erator, so ite&#114;ators must be used to traverse the&#105;r items. Iterators are also used to speci&#102;y the position of items. For example, th&#101; following code inserts the string &quot;Tote Hosen&quot; b&#101;tw&#101;en &quot;&#67;lash&quot; and &quot;R&#97;mones&quot;:</p>
<div class="docText"><pre>QLinkedList&lt;QString&gt; list;
list.append("Clash");
list.append("Ramones");

QLinkedList&lt;QString&gt;::iterator i = list.find("Ramones");
list.insert(i, "Tote Hosen");</pre></div><br />
<p class="docText"><a name="detailed look"></a>We w&#105;ll take a more detailed look at iterat&#111;rs later in this section.</p>
<p class="docText">The <tt>QList&lt;T&gt;</tt><a name="benefits of"></a> sequen&#116;ial cont&#97;iner is an &quot;&#97;rray-list&quot; that comb&#105;nes the most importa&#110;t benefits of <tt>QVector&lt;T&gt;</tt> and <tt>QLi&#110;kedList&lt;T&gt;</tt><a name="its interface"></a> in a single class. It supp&#111;rts random access, and its interface is index-b&#97;sed like <tt>QVector</tt><a name="end of"></a>'s. Inserting or removing an item at either en&#100; o&#102; a <tt>QL&#105;st&lt;T&gt;</tt><a name="and inserting"></a> is v&#101;ry &#102;ast, and inserting in the mi&#100;dle is fast for lists with up to about one thousand ite&#109;s. Unless we w&#97;nt to perf&#111;rm inserti&#111;ns in the mi&#100;dle of huge lists or need t&#104;e list's items to occupy consecutive addr&#101;sses in memory, <tt>QList&lt;T&gt;</tt> is usua&#108;ly the most appropriate general-purpose container class to use.</p>
<p class="docText">T&#104;e <tt>QStr&#105;ngList</tt> &#99;lass is a sub&#99;lass of <tt>QLis&#116;&lt;QString&gt;</tt><a name="functions it"></a> that is widely used in Qt'&#115; API. In addition to the functions it inh&#101;ri&#116;s from it&#115; base class, it prov&#105;des some ex&#116;ra functions that make the class more ve&#114;satile for string handling. We disc&#117;ss <tt>QStringList</tt><a name="in the"></a> in the last section of thi&#115; chapter (p. <a class="docLink" href="ch11lev1sec4.html#page_290">290</a>).</p>
<p class="docText"><tt>QStack&lt;T&gt;</tt> and <tt>QQueue&lt;T&gt;</tt><a name="more examples"></a> are two more exa&#109;ples of conv&#101;ni&#101;nc&#101; su&#98;classes. <tt>QStack&lt;T&gt;</tt><a name="a vector"></a> is a vector that prov&#105;des <tt>push()</tt>, <tt>pop()</tt>, and <tt>top()</tt>. <tt>QQueue&lt;T&gt;</tt> is a lis&#116; that pro&#118;ides <tt>enque&#117;e()</tt>, <tt>dequeue()</tt>, and <tt>head()</tt>.</p>
<p class="docText"><a name="type"></a>Fo&#114; all the co&#110;tainer classes seen so far, th&#101; value type <tt>T</tt><a name="like"></a> can be a basic type l&#105;ke <tt>int</tt> or <tt>double</tt><a name="constructor "></a>, a pointer type, or a clas&#115; that has a default constructor (a constructor that takes n&#111; ar&#103;umen&#116;s), a copy c&#111;ns&#116;ructor, and an assignment &#111;perator. Classes that qualify include <tt>QByteA&#114;ray</tt>, <tt>QD&#97;teTime</tt>, <tt>QR&#101;gExp</tt>, <tt>&#81;String</tt>, an&#100; <tt>QVariant</tt>. Qt classes that are d&#101;rived from <tt>QObject</tt><a name="constructor and"></a> do not qualify, because the&#121; lack a copy constructor and an assignment &#111;perator. This is no problem in p&#114;actic&#101;, si&#110;c&#101; we &#99;an simply store pointers to <tt>QO&#98;ject</tt> types rather than the objects themselves.</p>
<p class="docText">The valu&#101; ty&#112;e <tt>T</tt><a name="we must"></a> c&#97;n also be a container, in &#119;hich case we must remembe&#114; to separate consecutive angl&#101; brackets with spaces; otherwise, the c&#111;mpiler will choke on what it thinks is a <tt>&gt;&gt;</tt> operator. F&#111;r example:</p>
<div class="docText"><pre>QList&lt;QVector&lt;double&gt; &gt; list;</pre></div><br />
<p class="docText"><a name="iddle1233"></a><a name="iddle1782"></a><a name="iddle1813"></a><a name="iddle1879"></a><a name="iddle3363"></a><a name="iddle3365"></a><a name="iddle3391"></a><a name="iddle3926"></a><a name="iddle3953"></a><a name="iddle4052"></a><a name="iddle5277"></a><a name="iddle5280"></a><a name="iddle5422"></a><a name="iddle6474"></a><a name="iddle6785"></a><a name="to the"></a>In addition to the types just mentio&#110;e&#100;, a &#99;ontainer's v&#97;lue type c&#97;n be any custom class that meet&#115; the criteria described earlier. Here is an exa&#109;ple of such a &#99;lass:</p>
<div class="docText"><pre>class Movie
{
public:
    Movie(const QString &amp;title = "", int duration = 0);

    void setTitle(const QString &amp;title) { myTitle = title; }
    QString title() const { return myTitle; }
    void setDuration(int duration) { myDuration = duration; }
    QString duration() const { return myDuration; }

private:
    QString myTitle;
    int myDuration;
};</pre></div><br />
<p class="docText"><a name="it can"></a>The cla&#115;s has a cons&#116;ructor that req&#117;ires no arguments (although it c&#97;n take up to two). It also has a copy &#99;onstructor and an assignment operator, both implicitly pr&#111;vided by C++. For this class, a memb&#101;r-b&#121;-me&#109;ber copy is s&#117;fficient, &#115;o there is no need to im&#112;lement our own copy constructor and assi&#103;nmen&#116; operato&#114;.</p>
<p class="docText"><a name="Qt provides"></a>Qt provides two ca&#116;egories of i&#116;erators for traversing the i&#116;ems stored in a container: Java-style ite&#114;ators and STL-style iterators. The Java-style iterators &#97;re easier to use, whereas the STL-style iterators can b&#101; co&#109;bined with Q&#116;'s and STL'&#115; generi&#99; algorithms and are more powerful.</p>
<p class="docText"><a name="container class"></a>For ea&#99;h container class, there are two Java-style iterator type&#115;: a read-o&#110;l&#121; itera&#116;or and a read-&#119;rite iterator. Their valid positio&#110;s are shown in <a class="docLink" href="#ch11fig03">Figure 11.3</a><a name="iterator classes"></a>. The read-onl&#121; iterator classes are <tt>QVectorItera&#116;or&lt;T&gt;</tt>, <tt>QLinkedListIterator&lt;T&gt;</tt>, and <tt>QListIterator&lt;T&gt;</tt>. The corr&#101;sp&#111;nd&#105;ng read-&#119;rite iterat&#111;rs have <tt>Mutable</tt> in their na&#109;e (e.g., <tt>QMutableVectorIterator&lt;T&gt;</tt>). In this discussion, we &#119;ill concent&#114;ate on <tt>&#81;List</tt><a name="same API"></a>'s iter&#97;tors; the iterators &#102;or linked lists and vect&#111;rs have the same API.</p>
<a name="ch11fig03"></a><p><center>

<h5 class="docFigureTitle">Figure 11.3. Valid pos&#105;tions for Java-style iterators</h5>

<p class="docText">
<img border="0" id="" width="260" height="47" src="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzZmlncGNmaDNnMTEvaTBpcy4-.jpg" alt="" /></p>


</center></p><br />
<p class="docText"><a name="in mind"></a>The first thing &#116;o keep in mind when using Java-style iterators is th&#97;t they don'&#116; point di&#114;ectly &#97;t items. In&#115;tead, they can be located b&#101;fore the first item, after the last item, or betwe&#101;n t&#119;o items. A typ&#105;cal iteration &#108;oop looks like this:</p>
<div class="docText"><pre>QList&lt;double&gt; list;
...
QListIterator&lt;double&gt; i(list);
while (i.hasNext()) {
    do_something(i.next());
}</pre></div><br />
<p class="docText"><a name="iddle2985"></a><a name="iddle2990"></a><a name="iddle3954"></a><a name="iddle4016"></a><a name="iddle4053"></a><a name="iddle4423"></a><a name="iddle5419"></a><a name="iddle6786"></a><a name="iddle6854"></a><a name="iddle8103"></a><a name="this point"></a>&#84;he iterator is initialized with t&#104;e container to traverse. At this point, &#116;he iterator is located just before the first ite&#109;. The call to <tt>hasNext()</tt> returns <tt>true</tt><a name="right of"></a> if there is an item to the righ&#116; of the it&#101;ra&#116;or. The <tt>ne&#120;t()</tt><a name="of the"></a> &#102;unction returns the item to t&#104;e right of the iterator and advances the iterator t&#111; th&#101; ne&#120;t valid posit&#105;on.</p>
<p class="docText"><a name="is similar"></a>Iterating back&#119;ard is similar, except that we must first c&#97;ll <tt>toBack()</tt> to position the iterator after &#116;he last item:</p>
<div class="docText"><pre>QListIterator&lt;double&gt; i(list);
i.toBack();
while (i.hasPrevious()) {
    do_something(i.previous());
}</pre></div><br />
<p class="docText">The <tt>hasPrevious()</tt> function retu&#114;ns <tt>true</tt><a name="the iterator"></a> if there is an item to the left of the iterator; <tt>p&#114;eviou&#115;()</tt><a name="returns the"></a> return&#115; the ite&#109; to the left o&#102; the iterator and moves the iter&#97;tor back by one position. Another way t&#111; th&#105;nk abou&#116; the <tt>next()</tt> and <tt>previo&#117;s()</tt><a name="that they"></a> iterators is th&#97;t they return the item that the iterator h&#97;s just jumped over, as <a class="docLink" href="#ch11fig04">Figure 11.4</a> illustrates.</p>
<a name="ch11fig04"></a><p><center>

<h5 class="docFigureTitle"><a name="Effect of"></a>Figure 11.4. E&#102;fect of <tt>previous()</tt> and <tt>next()</tt> on a Java-style it&#101;rator</h5>

<p class="docText">
<img border="0" id="" width="267" height="61" src="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzZmlncGNmaDRnMTEvaTBpcy4-.jpg" alt="" /></p>


</center></p><br />
<p class="docText"><a name="The following"></a>Mutable iterators provide functions to i&#110;s&#101;rt, &#109;odify, and re&#109;ove items wh&#105;le iterating. The followi&#110;g loop removes all the negative nu&#109;bers from a l&#105;st:</p>
<div class="docText"><pre>QMutableListIterator&lt;double&gt; i(list);
while (i.hasNext()) {
    if (i.next() &lt; 0.0)
        i.remove();
}</pre></div><br />
<p class="docText">The <tt>r&#101;move()</tt><a name="last item"></a> function &#97;lways operates o&#110; the last item that was jump&#101;d over. It also works when itera&#116;ing backward:</p>
<div class="docText"><pre>QMutableListIterator&lt;double&gt; i(list);
i.toBack();
while (i.hasPrevious()) {
    if (i.previous() &lt; 0.0)
        i.remove();
}</pre></div><br />
<p class="docText">Similarly, the mutable Java-style itera&#116;ors provide a <tt>setValue()</tt><a name="how we"></a> function that modifies the last i&#116;em that w&#97;s jumped o&#118;er. Here's ho&#119; we would rep&#108;ace negative numbers with their absol&#117;te value:</p>
<div class="docText"><pre>QMutableListIterator&lt;double&gt; i(list);
while (i.hasNext()) {
    int val = i.next();
    if (val &lt; 0.0)
        i.setValue(-val);
}</pre></div><br />
<p class="docText"><a name="iddle1304"></a><a name="iddle1772"></a><a name="iddle1797"></a><a name="iddle1826"></a><a name="iddle2392"></a><a name="iddle3228"></a><a name="iddle3321"></a><a name="iddle3366"></a><a name="iddle3370"></a><a name="iddle4056"></a><a name="iddle4165"></a><a name="iddle4167"></a><a name="iddle4169"></a><a name="iddle4614"></a><a name="iddle5803"></a><a name="iddle6470"></a><a name="iddle6776"></a><a name="iddle7361"></a><a name="iddle7513"></a><a name="iddle7768"></a><a name="item at"></a>It is also possible to insert &#97;n item at t&#104;e curr&#101;nt iterato&#114; position by ca&#108;ling <tt>insert()</tt><a name="between the"></a>. The iterator is then a&#100;vanced to point between the new it&#101;m and the following item.</p>
<p class="docText"><a name="to the"></a>In addition to &#116;he Java-style iterators, every sequential container clas&#115; <tt>C&lt;T&gt;</tt> has t&#119;o STL-style i&#116;erator t&#121;pe&#115;: <tt>C&lt;T&gt;::iterator</tt> and <tt>C&lt;T&gt;::const_iterator</tt>. T&#104;e difference between the two is tha&#116; <tt>const_it&#101;ra&#116;or</tt> doesn't let us mo&#100;ify th&#101; data.</p>
<p class="docText">A container's <tt>begin()</tt><a name="item in"></a> fu&#110;ction returns an STL-style it&#101;rator that refers to the first ite&#109; in the container (e.g., <tt>list[0]</tt><a name="whereas"></a>), whereas <tt>end()</tt><a name="iterator to"></a> returns an iter&#97;tor to the &quot;&#111;ne &#112;ast &#116;he last&quot; i&#116;em (e.g., <tt>list[5]</tt><a name="a list"></a> for a list of size 5). <a class="docLink" href="#ch11fig05">Figure 11.5</a> shows th&#101; valid positions for STL-style it&#101;ra&#116;ors. If a c&#111;ntainer is em&#112;ty, <tt>begi&#110;()</tt> equals <tt>end()</tt><a name="has any"></a>. This ca&#110; be used to see wh&#101;ther the container has any items, al&#116;hough it is usually more convenient to call <tt>isEmpty()</tt> for thi&#115; purpos&#101;.</p>
<a name="ch11fig05"></a><p><center>

<h5 class="docFigureTitle">Fi&#103;ure 11.5. V&#97;lid posit&#105;ons for STL-style iterato&#114;s</h5>

<p class="docText">
<img border="0" id="" width="304" height="63" src="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzZmlncGNmaDVnMTEvaTBpcy4-.jpg" alt="" /></p>


</center></p><br />
<p class="docText"><a name="after that"></a>The STL-style iterator syntax i&#115; modele&#100; a&#102;ter that of C++ p&#111;inters into &#97;n array. We can use the <tt>++</tt> and <tt>--</tt><a name="the unary"></a> opera&#116;ors to move to the next or previous item, and &#116;he unary <tt>*</tt> operator to retrieve the cu&#114;rent item. For <tt>QVector&lt;T&gt;</tt>, the <tt>iterator</tt> and <tt>cons&#116;_iterato&#114;</tt> types &#97;re merely &#116;ypedefs &#102;or <tt>T *</tt> and <tt>const T *</tt>. (This is poss&#105;ble because <tt>QVector&lt;T&gt;</tt> stores its items in c&#111;ns&#101;cu&#116;ive memory loca&#116;ions.)</p>
<p class="docText"><a name="a"></a>The foll&#111;wing example replace&#115; each value in a <tt>QList&lt;double&gt;</tt> with its absolute val&#117;e:</p>
<div class="docText"><pre>QList&lt;double&gt;::iterator i = list.begin();
while (i != list.end()) {
    *i = qAbs(*i);
    ++i;
}</pre></div><br />
<p class="docText"><a name="we want"></a>A few Qt functions return a container. If we want to ite&#114;ate over the return value of a function using an ST&#76;-style it&#101;ra&#116;or, we mus&#116; take a co&#112;y of the container and iterate &#111;ver the copy. For example, the following code is t&#104;e corr&#101;ct &#119;ay to iterate ov&#101;r the <tt>QLis&#116;&lt;int&gt;</tt> returned by <tt>QSplitter::size&#115;()</tt>:</p>
<div class="docText"><pre>QList&lt;int&gt; list = splitter-&gt;sizes();
QList&lt;int&gt;::const_iterator i = list.begin();
while (i != list.end()) {
    do_something(*i);
    ++i;
}</pre></div><br />
<p class="docText"><a name="iddle1773"></a><a name="iddle1798"></a><a name="iddle1805"></a><a name="iddle1821"></a><a name="iddle1884"></a><a name="iddle3184"></a><a name="iddle3367"></a><a name="iddle4057"></a><a name="iddle6777"></a><a name="iddle7410"></a><a name="iddle7416"></a><a name="code is"></a>The following code is wrong:</p>
<div class="docText"><pre>// WRONG
QList&lt;int&gt;::const_iterator i = splitter-&gt;sizes().begin();
while (i != splitter-&gt;sizes().end()) {
    do_something(*i);
    ++i;
}</pre></div><br />
<p class="docText">This is because <tt>QSp&#108;itter::sizes()</tt> returns a new <tt>QList&lt;int&gt;</tt><a name="the return"></a> by value every ti&#109;e it is called. If we don't store the return valu&#101;, C++ a&#117;tomatica&#108;ly destroy&#115; it befo&#114;e we have even started iterating, leav&#105;ng us with a dangling iterator. To make matters wor&#115;e, each t&#105;me the l&#111;op is run, <tt>QS&#112;litter::sizes()</tt><a name="must generate"></a> &#109;ust generate a new copy &#111;f the list because of the <tt>splitter-&gt;size&#115;().end()</tt><a name="using STL"></a> call. In summary: When using STL-style iterato&#114;s, always iterate on a copy of a container returned by &#118;alue.</p>
<p class="docText"><a name="we don"></a>With r&#101;ad-&#111;nl&#121; Ja&#118;a-style iterators, we don't need to ta&#107;e a copy. The iterator takes a copy for us behind &#116;he scene&#115;, ensuri&#110;g that we al&#119;ays iterate ove&#114; the data that the func&#116;ion first returned. For exa&#109;ple:</p>
<div class="docText"><pre>QListIterator&lt;int&gt; i(splitter-&gt;sizes());
while (i.hasNext()) {
    do_something(i.next());
}</pre></div><br />
<p class="docText"><a name="to an"></a>Copying a container like this sounds expens&#105;ve, but it isn't, thanks to an optimization called <span class="docEmphasis">impl&#105;cit sha&#114;ing</span><a name="Qt container"></a>. Th&#105;s means &#116;hat copy&#105;ng a Qt container is about &#97;s fast as copying a single pointer. Only if one of t&#104;e copi&#101;s i&#115; changed i&#115; data actually co&#112;ied—and this is all handled a&#117;tomatically behind the scenes. For t&#104;is reason, implicit sharing is sometimes c&#97;lled &quot;copy on write&quot;.</p>
<p class="docText"><a name="an optimization"></a>The beauty of implicit sharing &#105;s that i&#116; is an opt&#105;mizati&#111;n t&#104;at we don't need t&#111; think about; it simply works, without re&#113;uiri&#110;g &#97;ny programmer interve&#110;tion. At th&#101; same time, implicit sharing enc&#111;urages a clean programming style wh&#101;re objects are returned by value. Conside&#114; the following function:</p>
<div class="docText"><pre>QVector&lt;double&gt; sineTable()
{
    QVector&lt;double&gt; vect(360);
    for (int i = 0; i &lt; 360; ++i)
        vect[i] = std::sin(i / (2 * M_PI));
    return vect;
}</pre></div><br />
<p class="docText">The call to the function looks like this:</p>
<div class="docText"><pre>QVector&lt;double&gt; table = sineTable();</pre></div><br />
<p class="docText"><a name="iddle1245"></a><a name="iddle1305"></a><a name="iddle1768"></a><a name="iddle1771"></a><a name="iddle1774"></a><a name="iddle1803"></a><a name="iddle2050"></a><a name="iddle2393"></a><a name="iddle2822"></a><a name="iddle3368"></a><a name="iddle3955"></a><a name="iddle4054"></a><a name="iddle4058"></a><a name="iddle4178"></a><a name="iddle6778"></a><a name="iddle6787"></a><a name="iddle7705"></a><a name="iddle7766"></a><a name="as a"></a>STL, in &#99;omparison, e&#110;c&#111;ur&#97;ges us to p&#97;ss the vector as a non-cons&#116; reference to avoid the copy that takes place when th&#101; fu&#110;c&#116;ion's return value i&#115; stored in a vari&#97;ble:</p>
<div class="docText"><pre>void sineTable(std::vector&lt;double&gt; &amp;vect)
{
    vect.resize(360);
    for (int i = 0; i &lt; 360; ++i)
        vect[i] = std::sin(i / (2 * M_PI));
}</pre></div><br />
<p class="docText"><a name="write and"></a>The call then becomes more tedious &#116;o write and less clear to read:</p>
<div class="docText"><pre>std::vector&lt;double&gt; table;
sineTable(table);</pre></div><br />
<p class="docText"><a name="implicit sharing"></a>Qt uses i&#109;plicit sharing for all of its containers and for m&#97;ny other classes, including <tt>QByteArray</tt>, <tt>QBrush</tt>, <tt>QFont</tt>, <tt>QImage</tt>, <tt>&#81;Pi&#120;m&#97;p</tt>, and <tt>QStr&#105;ng</tt><a name="both as"></a>. This &#109;akes these classes very efficient t&#111; pass by value, both as function parameters and a&#115; return &#118;alues.</p>
<p class="docText"><a name="Implicit sharing"></a>Impl&#105;cit sharing is &#97; guarantee fr&#111;m Qt that the data won't be &#99;opied if we don't modify it. To get the best &#111;ut of implicit sharing, we can ado&#112;t a couple of new programming habits. One habit is to u&#115;e the <tt>at()</tt><a name="than the"></a> &#102;unc&#116;ion rath&#101;r t&#104;an the <tt>[]</tt><a name="for read"></a> operator for r&#101;ad-only access on a (non-const) vector o&#114; list. S&#105;nce Qt's &#99;ontainers cannot tell &#119;hether <tt>[]</tt><a name="it assumes"></a> appears on the l&#101;ft side of an assignme&#110;t or not, it assumes the worst &#97;nd forces a deep copy to occur—whereas <tt>at()</tt><a name="of an"></a> isn't allowe&#100; on the left side of an assignment.</p>
<p class="docText"><a name="container with"></a>&#65; simila&#114; issue &#97;rises whe&#110; w&#101; iterate over a cont&#97;iner with STL-style iterators. Wheneve&#114; we cal&#108; <tt>begin()</tt> or <tt>en&#100;()</tt><a name="to occur"></a> on a &#110;on-c&#111;nst container, Qt forces a &#100;eep copy to occur if the &#100;ata is shared. To prevent &#116;his inefficiency, the solution is to use <tt>const_i&#116;erator</tt>, <tt>c&#111;ns&#116;Begin()</tt>, an&#100; <tt>c&#111;nstEnd()</tt> whenever possi&#98;le.</p>
<p class="docText"><a name="over items"></a>Qt provides one last method for iterating &#111;ve&#114; items &#105;n a sequent&#105;al container: the <tt>f&#111;reach</tt><a name="like this"></a> loop. It looks like this:</p>
<div class="docText"><pre>QLinkedList&lt;Movie&gt; list;
...
foreach (Movie movie, list) {
    if (movie.title() == "Citizen Kane") {
        std::cout &lt;&lt; "Found Citizen Kane" &lt;&lt; std::endl;
        break;
    }
}</pre></div><br />
<p class="docText">The <tt>&#102;oreach</tt> pseudo-keyword is implement&#101;d in terms of the standard <tt>for</tt> l&#111;op. At each iteration of the loop, the iteration vari&#97;ble (<tt>movie</tt><a name="item in"></a>) &#105;s set to &#97; new item, s&#116;arting a&#116; the first item in the container and p&#114;ogressing forward. The <tt>foreach</tt><a name="loop automatically"></a> loop automatically takes a c&#111;py &#111;f t&#104;e container when &#116;he loop is entere&#100;, and for this rea&#115;on the loop is not affected i&#102; the container is modified during iteration.</p>

<p class="docText"></p><a name="ch11sb01"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>

<h2 class="docSidebarTitle"><a name="Sharing Works"></a>How Implicit Shar&#105;ng Works</h2>
<p class="docText"><a name="iddle1229"></a><a name="iddle1247"></a><a name="iddle1806"></a><a name="iddle2051"></a><a name="iddle3185"></a><a name="iddle5752"></a><a name="iddle5753"></a><a name="iddle5897"></a><a name="iddle5957"></a><a name="iddle6813"></a><a name="iddle7417"></a><a name="iddle8243"></a><a name="sharing works"></a>Implicit sharing works automatically behi&#110;d &#116;he scene&#115;, so we do&#110;'t &#104;ave to do anything in o&#117;r code to make this optimization happen. But since it's &#110;i&#99;e to know how &#116;hings work, we wi&#108;l study an exa&#109;ple and see what happens under the h&#111;od. The example uses <tt>QString</tt>, one of &#81;t's many implicitly shared classes.</p>
<div class="docText"><pre>QString str1 = "Humpty";
QString str2 = str1;</pre></div><br />
<p class="docText">We set <tt>str1</tt> to &quot;Hu&#109;pty&quot; and <tt>str2</tt> to be equal to <tt>str1</tt>. At this point, both <tt>QString</tt><a name="Along with"></a> ob&#106;ects poi&#110;t &#116;o the sam&#101; in&#116;ernal data structure in memory. Alon&#103; with the character data, the data structure holds a &#114;efere&#110;c&#101; count that in&#100;icates how man&#121; <tt>QString</tt><a name="data structure"></a>s point to the sa&#109;e data structure. Since both <tt>str1</tt> and <tt>str2</tt> poin&#116; to the same data, the reference count is 2.</p>
<div class="docText"><pre>str2[0] = 'D';</pre></div><br />
<p class="docText">When &#119;e modify <tt>str2</tt><a name="ensure that"></a>, it first makes a deep copy of the data, to ensure &#116;hat <tt>str1</tt> a&#110;d <tt>&#115;tr2</tt><a name="applies the"></a> poin&#116; to diffe&#114;ent data structures, and it then appl&#105;es the change to its own copy of the data. T&#104;e refe&#114;ence c&#111;unt of <tt>str1</tt>'s d&#97;ta (&quot;Humpty&quot;) becomes 1, and &#116;he reference count of <tt>str2</tt><a name="of "></a>'s &#100;ata (&quot;Dumpty&quot;) is set to 1. A referenc&#101; count of 1 means that the data isn't shared.</p>
<div class="docText"><pre>str2.truncate(4);</pre></div><br />
<p class="docText"><a name="modify"></a>If we m&#111;dify <tt>str2</tt> again, no copying takes place beca&#117;se the ref&#101;re&#110;c&#101; co&#117;nt of <tt>str2</tt>'s data is 1. The <tt>truncat&#101;()</tt> function operates directly on <tt>str2</tt>'s data, re&#115;ulting &#105;n the st&#114;ing &quot;Dump&quot;. The refere&#110;ce co&#117;nt stays at 1.</p>
<div class="docText"><pre>str1 = str2;</pre></div><br />
<p class="docText">When we assign <tt>str2</tt> to <tt>str1</tt>, &#116;he reference count for <tt>str1</tt>'s data go&#101;s down to 0, which means that no <tt>QSt&#114;ing</tt><a name="from memory"></a> is using the &quot;Humpty&quot; data anymore. The data is then free&#100; f&#114;om mem&#111;ry. &#66;oth <tt>QStr&#105;ng</tt><a name="s point"></a>s point to &quot;Dump&quot;, which now h&#97;s a reference count of 2.</p>
<p class="docText"><a name="is often"></a>Data sharing is often &#100;i&#115;regard&#101;d as an opti&#111;n in m&#117;ltithreaded program&#115;, because of race conditions i&#110; the reference counting. With Qt, t&#104;is is not an issue. Internally, the cont&#97;iner clas&#115;es use a&#115;sembly &#108;anguage in&#115;tructions to perform atomic refe&#114;ence counting. This technology is available to &#81;t u&#115;ers thr&#111;ugh the <tt>QS&#104;aredData</tt> and <tt>QSh&#97;redDataPointer</tt> classes.</p>
</td></tr></table></p><br />
<p class="docText">T&#104;e <tt>break</tt> and <tt>continue</tt><a name="statements are"></a> loop s&#116;atements are supported. If the body consis&#116;s of a single statement, the braces are unnecessary. Just &#108;ike a <tt>for</tt> st&#97;tement, th&#101; it&#101;ra&#116;ion variable can be define&#100; outside the loop, like this:</p>
<div class="docText"><pre>QLinkedList&lt;Movie&gt; list;
Movie movie;
...
foreach (movie, list) {
    if (movie.title() == "Citizen Kane") {
        std::cout &lt;&lt; "Found Citizen Kane" &lt;&lt; std::endl;
        break;
    }
}</pre></div><br />
<p class="docText"><a name="iddle1239"></a><a name="iddle1817"></a><a name="iddle3230"></a><a name="iddle3761"></a><a name="iddle4179"></a><a name="iddle4186"></a><a name="iddle5344"></a><a name="iddle5575"></a><a name="iddle7514"></a><a name="iddle8387"></a><a name="only option"></a>Defining the iteration &#118;ariable ou&#116;side the &#108;oop is the onl&#121; option for c&#111;ntainers that hold data types tha&#116; contain a comma (e.g., <tt>QPair&lt;QString, &#105;nt&gt;</tt>).</p>

</div></div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch10lev1sec4.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch11lev1sec1.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>