<html>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<head>
<title>ch11lev1sec2.html</title>
<link rel="STYLESHEET" type="text/css" href="images/css1.css">
<link rel="STYLESHEET" type="text/css" href="images/css2.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch11lev1sec1.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch11lev1sec3.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<div style=""><div><a name="ch11lev1sec2"></a>
<h3 class="docSection1Title" id="-100000">Associative Containers</h3>
<p class="docText"><a name="An associative"></a>&#65;n assoc&#105;ative c&#111;nt&#97;iner hold&#115; an arbitrary number of items of t&#104;e same type, indexed by a key. Q&#116; provide&#115; two mai&#110; associat&#105;ve container clas&#115;es: <tt>QMap&lt;K, T&gt;</tt> and <tt>QHash&lt;K, T&gt;</tt>.</p>
<p class="docText">A <tt>QMap&lt;K, T&gt;</tt><a name="data structure"></a> i&#115; a data structure that stores key–v&#97;lue pairs in ascending key order, as illust&#114;ated in <a class="docLink" href="#ch11fig06">Figure 11.6</a><a name="arrangement makes"></a>. This arrangement makes it possible to prov&#105;de good &#108;ookup and i&#110;s&#101;rt&#105;on performance, and key-or&#100;er iteration. Internally, <tt>QMap&lt;K, T&gt;</tt> i&#115; implem&#101;nt&#101;d as a skip-l&#105;st.</p>
<a name="ch11fig06"></a><p><center>

<h5 class="docFigureTitle">Figure 11.6. A map &#111;f <tt>QString</tt> to <tt>int</tt></h5>

<p class="docText">
<img border="0" id="" width="227" height="103" src="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzZmlncGNmaDZnMTEvaTBpcy4-.jpg" alt="" /></p>


</center></p><br />
<p class="docText"><a name="is to"></a>One simp&#108;e way to insert items into a map is to call <tt>in&#115;ert()</tt>:</p>
<div class="docText"><pre>QMap&lt;QString, int&gt; map;
map.insert("eins", 1);
map.insert("sieben", 7);
map.insert("dreiundzwanzig", 23);</pre></div><br />
<p class="docText"><a name="value to"></a>Alternatively, we can simply assign a value to a give&#110; key as follows:</p>
<div class="docText"><pre>map["eins"] = 1;
map["sieben"] = 7;
map["dreiundzwanzig"] = 23;</pre></div><br />
<p class="docText">The <tt>[]</tt> operator can be used for b&#111;th &#105;nserti&#111;n a&#110;d &#114;etrieval. If <tt>[]</tt><a name="in a"></a> is used to re&#116;rieve a value for a non-existent key in &#97; non-const &#109;ap, a new item &#119;ill be created w&#105;th the given key &#97;nd an empty value. To avoid accidenta&#108;ly creating empty values, we can use the <tt>va&#108;ue()</tt> function to retrieve items instead &#111;f <tt>[]</tt>:</p>
<div class="docText"><pre>int val = map.value("dreiundzwanzig");</pre></div><br />
<p class="docText"><a name="iddle1234"></a><a name="iddle1783"></a><a name="iddle1787"></a><a name="iddle1804"></a><a name="iddle1839"></a><a name="iddle1880"></a><a name="iddle2058"></a><a name="iddle2152"></a><a name="iddle2993"></a><a name="iddle3231"></a><a name="iddle3235"></a><a name="iddle3459"></a><a name="iddle3936"></a><a name="iddle4170"></a><a name="iddle4175"></a><a name="iddle5154"></a><a name="iddle5155"></a><a name="iddle5417"></a><a name="iddle6885"></a><a name="iddle7486"></a><a name="iddle7680"></a><a name="iddle8312"></a><a name="iddle8403"></a><a name="returned using"></a>If the key doesn't exist, a default value is return&#101;d u&#115;ing the &#118;alue type's &#100;e&#102;ault constructor, and no new item is crea&#116;ed. For basic and pointer types, zero is retur&#110;e&#100;. W&#101; can s&#112;ecify an&#111;ther default value a&#115; the second argument to <tt>value()</tt>, for exam&#112;le:</p>
<div class="docText"><pre>int seconds = map.value("delay", 30);</pre></div><br />
<p class="docText">This is equivalent to</p>
<div class="docText"><pre>int seconds = 30;
if (map.contains("delay"))
    seconds = map.value("delay");</pre></div><br />
<p class="docText">The <tt>K</tt> and <tt>T</tt> data type&#115; of a <tt>QMap&lt;K, T&gt;</tt> can be basic data types like <tt>int</tt> and <tt>&#100;o&#117;ble</tt><a name="a copy"></a>, point&#101;r t&#121;pe&#115;, or classes that have a defa&#117;lt constructor, a copy constructor, and &#97;n assignm&#101;nt &#111;perator. I&#110; add&#105;tion, the <tt>K</tt><a name="provide an"></a> type must provide &#97;n <tt>operator&lt;()</tt> since <tt>QMap&lt;K, T&gt;</tt><a name="key order"></a> uses this &#111;perator to store the items in ascen&#100;ing key order.</p>
<p class="docText"><tt>QMap&lt;K, T&gt;</tt><a name="has a"></a> has a couple of convenience func&#116;ions, <tt>key&#115;()</tt> and <tt>val&#117;es()</tt><a name="especially useful"></a>, that ar&#101; es&#112;ecially useful when dealing &#119;ith small data sets. They return <tt>QList</tt><a name="of a"></a>s of a map'&#115; keys an&#100; v&#97;lues.</p>
<p class="docText"><a name="to an"></a>Maps are normal&#108;y single-valued: If a new &#118;alue is assigned to an existing key, t&#104;e old value is replaced by the new value, ensur&#105;ng that no two items share the same key. It is po&#115;sible to have multiple key–value pairs with the same key by usin&#103; the <tt>i&#110;s&#101;rt&#77;ulti()</tt> func&#116;ion or the <tt>QMultiMap&lt;K, T&gt;</tt> convenience &#115;ubclass. <tt>QMap&lt;K, T&gt;</tt> has a <tt>values(const K &amp;)</tt> overload t&#104;at ret&#117;rns a <tt>QLis&#116;</tt><a name="a given"></a> of all the va&#108;ues for a given key. For e&#120;ample:</p>
<div class="docText"><pre>QMultiMap&lt;int, QString&gt; multiMap;
multiMap.insert(1, "one");
multiMap.insert(1, "eins");
multiMap.insert(1, "uno");

QList&lt;QString&gt; vals = multiMap.values(1);</pre></div><br />
<p class="docText">A <tt>QHash&lt;K, T&gt;</tt><a name="hash table"></a> is a data struct&#117;re that stores key–value pairs in a hash tabl&#101;. Its interface is almost identical to that of <tt>Q&#77;ap&lt;K, T&gt;</tt>, but it has different requirement&#115; for the <tt>&#75;</tt><a name="lookups than"></a> templa&#116;e type an&#100; u&#115;ually provides much faster loo&#107;ups than <tt>QMap&lt;K, T&gt;</tt> can achieve. Another difference is that <tt>QHa&#115;h&lt;K, T&gt;</tt> is u&#110;o&#114;dered.</p>
<p class="docText"><a name="any value"></a>In add&#105;tion to the stand&#97;rd requirements on any v&#97;lue type stored in a container, the <tt>K</tt><a name="a"></a> type &#111;f a <tt>QHash&lt;K, T&gt;</tt> needs to provide an <tt>&#111;perator==()</tt> and be supported by a global <tt>qHash()</tt><a name="already provides"></a> &#102;unc&#116;ion that &#114;eturn&#115; a hash v&#97;lue for a key. Qt already prov&#105;des <tt>qHash()</tt><a name="functions for"></a> functions for integer types, point&#101;r t&#121;pe&#115;, <tt>QChar</tt>, <tt>QStrin&#103;</tt>, and <tt>QByteArra&#121;</tt>.</p>
<p class="docText"><tt>QHash&lt;K, T&gt;</tt><a name="a prime"></a> automatically allocates a pr&#105;me number of buckets for its intern&#97;l hash table and resizes this as items are ins&#101;rted or removed. It is also possible to f&#105;ne-tune &#112;erf&#111;rm&#97;nce by cal&#108;ing <tt>reserve()</tt><a name="specify the"></a> to specify the numbe&#114; of items expected to be stored in the hash &#97;nd <tt>squeez&#101;()</tt><a name="number of"></a> to &#115;hrink the hash &#116;able based o&#110; the current nu&#109;ber of items. A common idiom is to call <tt>reserve()</tt> wi&#116;h the <a name="iddle1462"></a><a name="iddle1802"></a><a name="iddle1814"></a><a name="iddle1824"></a><a name="iddle1827"></a><a name="iddle3234"></a><a name="iddle3364"></a><a name="iddle3371"></a><a name="iddle3392"></a><a name="iddle3415"></a><a name="iddle3418"></a><a name="iddle3934"></a><a name="iddle3956"></a><a name="iddle4017"></a><a name="iddle4055"></a><a name="iddle4424"></a><a name="iddle4798"></a><a name="iddle5345"></a><a name="iddle5416"></a><a name="iddle5420"></a><a name="iddle5740"></a><a name="iddle6788"></a><a name="iddle7362"></a><a name="iddle7397"></a><a name="iddle7485"></a><a name="iddle7769"></a><a name="iddle8386"></a><a name="iddle8391"></a><a name="then insert"></a>maximum number of items we expect, then ins&#101;rt the data, and finally call <tt>squeeze()</tt><a name="than expected"></a> to &#109;inimize mem&#111;ry &#117;sage if th&#101;re &#119;ere fewer items than expected.</p>
<p class="docText"><a name="be assigned"></a>Hashes a&#114;e normally single-valued, but multiple values can be a&#115;signed &#116;o the sam&#101; key us&#105;ng the <tt>ins&#101;rtMulti()</tt> function or the <tt>QM&#117;ltiHash&lt;K, T&gt;</tt> convenience su&#98;class.</p>
<p class="docText">Besides <tt>QHash&lt;K, T&gt;</tt>, Qt also provi&#100;es a <tt>QCache&lt;K, T&gt;</tt><a name="objects associated"></a> class that can be used t&#111; ca&#99;he objects a&#115;sociat&#101;d w&#105;th a key, and a <tt>QSet&lt;K&gt;</tt><a name="only stores"></a> container that only sto&#114;es keys. Internally, both rely on <tt>QHash&lt;&#75;, T&gt;</tt> and bo&#116;h have th&#101; same requireme&#110;ts for the <tt>&#75;</tt> type as <tt>QHash&lt;K, T&gt;</tt>.</p>
<p class="docText"><a name="stored in"></a>The eas&#105;est way to iterate through all the key–va&#108;ue pairs stored in an associat&#105;ve container is to use a Java-style iterator. Because the itera&#116;ors must &#103;ive a&#99;cess to both &#97; key and a v&#97;lue, the Java-style iterators for a&#115;sociative containers work slightly differ&#101;nt&#108;y from thei&#114; sequent&#105;al counterparts. &#84;he main difference is that the <tt>&#110;ext()</tt><a name="and"></a> and <tt>previous()</tt><a name="an object"></a> functions &#114;eturn an object that represents a key–value pair, rat&#104;er than simply a value. The key and value compo&#110;e&#110;t&#115; are acc&#101;ss&#105;ble from this object as <tt>key()</tt> and <tt>value()</tt>. For ex&#97;mple:</p>
<div class="docText"><pre>QMap&lt;QString, int&gt; map;
...
int sum = 0;
QMapIterator&lt;QString, int&gt; i(map);
while (i.hasNext())
    sum += i.next().value();</pre></div><br />
<p class="docText"><a name="we need"></a>If we need to access both the key and the &#118;alue, we can &#115;imply i&#103;nore the retur&#110; value of <tt>nex&#116;()</tt> or <tt>previous()</tt> and use the iterato&#114;'s <tt>key()</tt> and <tt>value()</tt> functions, which operate on &#116;he last item that was jumped over:</p>
<div class="docText"><pre>QMapIterator&lt;QString, int&gt; i(map);
while (i.hasNext()) {
    i.next();
    if (i.value() &gt; largestValue) {
        largestKey = i.key();
        largestValue = i.value();
    }
}</pre></div><br />
<p class="docText">Mutable iterators have &#97; <tt>setValue()</tt> function that modifies the value associated with the cur&#114;ent it&#101;m:</p>
<div class="docText"><pre>QMutableMapIterator&lt;QString, int&gt; i(map);
while (i.hasNext()) {
    i.next();
    if (i.value() &lt; 0.0)
        i.setValue(-i.value());
}</pre></div><br />
<p class="docText">S&#84;L-styl&#101; it&#101;rators also provide <tt>key()</tt> a&#110;d <tt>value()</tt> functions. With the non-cons&#116; iterato&#114; types, <tt>&#118;alue()</tt><a name="we iterate"></a> returns &#97; non-const refere&#110;ce, allowing us to change the va&#108;ue as we iterate. Note that although these &#105;terators are called &quot;STL-style&quot;, <a name="iddle1125"></a><a name="iddle1129"></a><a name="iddle1306"></a><a name="iddle1326"></a><a name="iddle1659"></a><a name="iddle1795"></a><a name="iddle1796"></a><a name="iddle2024"></a><a name="iddle2394"></a><a name="iddle2823"></a><a name="iddle2895"></a><a name="iddle3460"></a><a name="iddle3760"></a><a name="iddle4244"></a><a name="iddle4780"></a><a name="iddle5026"></a><a name="iddle5027"></a><a name="iddle5418"></a><a name="iddle6096"></a><a name="iddle7755"></a><a name="iddle7758"></a><a name="iddle8404"></a>they deviate signi&#102;icantly from the <tt>std::map&lt;K, T&gt;</tt> iterators, which are based o&#110; <tt>s&#116;d::pair&lt;K, T&gt;</tt>.</p>
<p class="docText">&#84;he <tt>for&#101;ac&#104;</tt><a name="but only"></a> loop also works on associative containe&#114;s, but only on the value component of the key–va&#108;ue pairs. If &#119;e need both t&#104;e key and &#116;he value components o&#102; the items, we can call the <tt>keys()</tt> &#97;nd <tt>values(const K &amp;)</tt> functions in nested <tt>f&#111;reach</tt> loops as follows:</p>
<div class="docText"><pre>QMultiMap&lt;QString, int&gt; map;
...
foreach (QString key, map.keys()) {
    foreach (int value, map.values(key)) {
        do_something(key, value);
    }
}</pre></div><br />

</div></div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch11lev1sec1.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch11lev1sec3.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>