<html>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<head>
<title>ch11lev1sec4.html</title>
<link rel="STYLESHEET" type="text/css" href="images/css1.css">
<link rel="STYLESHEET" type="text/css" href="images/css2.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch11lev1sec3.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch12.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<div style=""><div><a name="ch11lev1sec4"></a>
<h3 class="docSection1Title" id="-100000">Strings, Byte Arrays, and Variants</h3>
<p class="docText"><tt>&#81;St&#114;ing</tt>, <tt>QB&#121;te&#65;rray</tt><a name="and"></a>, an&#100; <tt>QVariant</tt><a name="classes that"></a> are three cl&#97;sses that have many things in common with cont&#97;iners and &#116;hat can b&#101; used a&#115; alternatives to c&#111;ntainers in some contexts. Als&#111;, like the containers, these classes u&#115;e implicit sharing as a memory and speed &#111;ptimization.</p>
<p class="docText"><a name="will start"></a>We will start with <tt>QString</tt><a name="interface but"></a>. &#69;very GUI pro&#103;ram u&#115;es stri&#110;g&#115;, not only for the user i&#110;terface but often also as data structure&#115;. C++ nativ&#101;ly &#112;rovides two &#107;inds of strings: t&#114;aditional C-style '\0'-terminated char&#97;cter arrays and the <tt>std::string</tt> cl&#97;ss. Unlike these, <tt>QString</tt><a name="and Latin"></a> holds 16-bit Unicode values. Unic&#111;de contains ASCII and Latin-1 as a subset, with their usual &#110;u&#109;eric values. &#66;ut since <tt>&#81;St&#114;ing</tt><a name="writing most"></a> is 16-bit, it can represent &#116;housands of other characters for writing most of t&#104;e worl&#100;'s &#108;anguages. See <a class="docLink" href="ch18.html#ch18">Chapter 18</a> f&#111;r more &#105;nformation about Unicode.</p>
<p class="docText">When using <tt>&#81;String</tt><a name="details as"></a>, we don't ne&#101;d to worry about such arcane details as allo&#99;ating enough memory or ensuring that the data is '\0'-termin&#97;ted. Conce&#112;tua&#108;ly, <tt>QString</tt><a name="vector of"></a>&#115; can be t&#104;ought of as a vector of <tt>QCh&#97;r</tt>s. A <tt>QString</tt><a name="The"></a> can embed '\0' characters. The <tt>length()</tt> fu&#110;c&#116;ion retu&#114;ns the size of t&#104;e entire stri&#110;g, including emb&#101;dded '\0' characters.</p>
<p class="docText"><tt>QSt&#114;ing</tt> provides a binary <tt>+</tt> opera&#116;or to concatenate two strings and a <tt>+=</tt> operator to append one &#115;tring t&#111; an&#111;th&#101;r. B&#101;cause <tt>QString</tt><a name="building up"></a> automatically pr&#101;allocates memory at the end of the string d&#97;ta, buildi&#110;g &#117;p a string by repeated&#108;y appending char&#97;cters is very fast. Here'&#115; an example that combines <tt>+</tt><a name="and"></a> and <tt>+=</tt>:</p>
<div class="docText"><pre>QString str = "User: ";
str += userName + "\n";</pre></div><br />
<p class="docText"><a name="also a"></a>There &#105;s also a <tt>QString::append()</tt><a name="that does"></a> function that &#100;oes the same thing as the <tt>+=</tt> operator:</p>
<div class="docText"><pre>str = "User: ";
str.append(userName);
str.append("\n");</pre></div><br />
<p class="docText"><a name="use"></a>A completely diff&#101;re&#110;t &#119;ay to combin&#101; st&#114;ings is to use <tt>QString</tt>'s <tt>spr&#105;ntf()</tt> function:</p>
<div class="docText"><pre>str.sprintf("%s %.1f%%", "perfect competition", 100.0);</pre></div><br />
<p class="docText"><a name="iddle1023"></a><a name="iddle1202"></a><a name="iddle3826"></a><a name="iddle4076"></a><a name="iddle4910"></a><a name="iddle5909"></a><a name="iddle5924"></a><a name="iddle5927"></a><a name="iddle5934"></a><a name="iddle5944"></a><a name="iddle5947"></a><a name="iddle5950"></a><a name="iddle6104"></a><a name="iddle7274"></a><a name="iddle8106"></a><a name="iddle8113"></a><a name="iddle8118"></a><a name="format specifiers"></a>This function supports the sam&#101; fo&#114;mat sp&#101;cifier&#115; as the C++ library's <tt>sp&#114;intf()</tt> function. In the precedi&#110;g example, <tt>str</tt> is assigned &quot;perf&#101;ct competition 100.0%&quot;.</p>
<p class="docText"><a name="strings or"></a>Yet another way to build a string from o&#116;her strings or from numbers is to use <tt>arg()</tt>:</p>
<div class="docText"><pre>str = QString("%1 %2 (%3s-%4s)")
      .arg("permissive").arg("society").arg(1950).arg(1970);</pre></div><br />
<p class="docText"><a name="by "></a>In th&#105;s examp&#108;e, &quot;%1&quot; is replac&#101;d b&#121; &quot;pe&#114;missive&quot;, &quot;%2&quot; is replaced by &quot;so&#99;iety&quot;, &quot;%3&quot; is replaced by &quot;1950&quot;, and &quot;%4&quot; is replaced by &quot;1970&quot;. The result is &quot;permissive s&#111;ci&#101;ty (1950&#115;-1970s)&quot;. There are <tt>arg()</tt><a name="have extra"></a> ove&#114;loads to handle &#118;arious data types. Some overl&#111;ads have extra parameters for c&#111;ntrolling the field width, the numeri&#99;al base, or the floating-point precision. In g&#101;ne&#114;al, <tt>arg()</tt><a name="much better"></a> &#105;s a much &#98;etter solu&#116;ion than <tt>sprintf()</tt><a name="reorder the"></a>, because it is type-sa&#102;e, fully supports Unicode, and allows trans&#108;ators to re&#111;rd&#101;r the &quot;%<span class="docEmphasis">n</span>&quot; par&#97;meters.</p>
<p class="docText"><tt>QString</tt><a name="can convert"></a> can &#99;onvert numbers into strings usi&#110;g the <tt>QString::number()</tt> static f&#117;nction:</p>
<div class="docText"><pre>str = QString::number(59.6);</pre></div><br />
<p class="docText"><a name="the"></a>Or using the <tt>setNum()</tt> function:</p>
<div class="docText"><pre>str.setNum(59.6);</pre></div><br />
<p class="docText"><a name="reverse conversion"></a>The reve&#114;se conversion, from a string to a number, is achieved using <tt>toInt()</tt>, <tt>to&#76;ongLong()</tt>, <tt>&#116;oDouble()</tt>, &#97;nd so on. Fo&#114; examp&#108;e:</p>
<div class="docText"><pre>bool ok;
double d = str.toDouble(&amp;ok);</pre></div><br />
<p class="docText">These functions accept an optiona&#108; pointer to a <tt>bool</tt> variable and set the variable to <tt>true</tt> or <tt>&#102;als&#101;</tt><a name="these functions"></a> de&#112;ending on th&#101; success of the c&#111;nversion. If the co&#110;version fails, these functions r&#101;turn zero.</p>
<p class="docText"><a name="often want"></a>Once we have a string, we often want t&#111; extract parts of it. The <tt>mid()</tt><a name="first argument"></a> function returns the &#115;ubstri&#110;g &#115;tartin&#103; at a g&#105;ven position (the first arg&#117;ment) and of up to a given length (the se&#99;ond argumen&#116;). For exam&#112;le, the foll&#111;wing &#99;ode prints &quot;pays&quot; to the console:<sup class="docFootnote"><a class="docLink" href="#ch11fn01">[*]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="ch11fn01">[*]</a></sup> &#84;he convenient <tt>qDebug() &lt;&lt; arg</tt><a name="the"></a> syntax used here re&#113;uires the inclusion of the <tt>&lt;QtDebug&gt;</tt> header file, w&#104;ereas the <tt>qDebug("...", arg)</tt><a name="includes at"></a> syntax is available in any file &#116;hat incl&#117;des at lea&#115;t one Qt &#104;eader.</p></blockquote>
<div class="docText"><pre>QString str = "polluter pays principle";
qDebug() &lt;&lt; str.mid(9, 4);</pre></div><br />
<p class="docText"><a name="omit the"></a>&#73;f we omit the second argumen&#116;, <tt>mid()</tt><a name="ending at"></a> returns the substring starting at th&#101; gi&#118;en positio&#110; and &#101;nding at th&#101; end of the string. F&#111;r example, the following &#99;ode prints &quot;pays principle&quot; to the cons&#111;le:</p>
<div class="docText"><pre>QString str = "polluter pays principle";
qDebug() &lt;&lt; str.mid(9);</pre></div><br />
<p class="docText"><a name="iddle1485"></a><a name="iddle2410"></a><a name="iddle3207"></a><a name="iddle3232"></a><a name="iddle3528"></a><a name="iddle3613"></a><a name="iddle5901"></a><a name="iddle5912"></a><a name="iddle5915"></a><a name="iddle5916"></a><a name="iddle5918"></a><a name="iddle5921"></a><a name="iddle5930"></a><a name="iddle5932"></a><a name="iddle5933"></a><a name="iddle5941"></a><a name="iddle5952"></a><a name="iddle5955"></a><a name="iddle6857"></a><a name="iddle6880"></a><a name="iddle6951"></a><a name="iddle7721"></a><a name="iddle8120"></a><a name="iddle8133"></a><a name="There are"></a>There are also <tt>left()</tt> and <tt>right()</tt><a name="perform a"></a> functions that perform &#97; similar j&#111;b. B&#111;th &#97;ccept a nu&#109;ber of characters, <span class="docEmphasis">n</span><a name="return the"></a>, and return the first or l&#97;st <span class="docEmphasis">n</span><a name="the console"></a> characters of the string. For example, the followi&#110;g &#99;ode prints &quot;p&#111;lluter princ&#105;ple&quot; to the cons&#111;le:</p>
<div class="docText"><pre>QString str = "polluter pays principle";
qDebug() &lt;&lt; str.left(8) &lt;&lt; " " &lt;&lt; str.right(9);</pre></div><br />
<p class="docText"><a name="out whether"></a>If we want to find out &#119;hether a string contains a particular charact&#101;r, substring, or regular expression, we can u&#115;e one of <tt>QString</tt>'s <tt>indexOf()</tt> functions:</p>
<div class="docText"><pre>QString str = "the middle bit";
int i = str.indexOf("middle");</pre></div><br />
<p class="docText">This w&#105;ll set <tt>i</tt> &#116;o 4. The <tt>ind&#101;xO&#102;()</tt><a name="and case"></a> fun&#99;tion returns -1 on failure, and accept&#115; an optional start position and case-sensitivity fl&#97;g.</p>
<p class="docText"><a name="a string"></a>If we jus&#116; want to c&#104;eck wheth&#101;r a string s&#116;arts or ends with something, we ca&#110; use the <tt>startsWith()</tt> and <tt>end&#115;With()</tt> functions:</p>
<div class="docText"><pre>if (url.startsWith("http:") &amp;&amp; url.endsWith(".png"))
    ...</pre></div><br />
<p class="docText"><a name="faster than"></a>The preceding &#99;ode is both simpler and faster than the foll&#111;wi&#110;g &#99;ode:</p>
<div class="docText"><pre>if (url.left(5) == "http:" &amp;&amp; url.right(4) == ".png")
    ...</pre></div><br />
<p class="docText"><a name="with the"></a>String c&#111;mp&#97;rison with the <tt>==</tt> operator is cas&#101;-sensitive. If we are comparing user-visible str&#105;ngs, <tt>loc&#97;leAwareC&#111;mpare()</tt><a name="make the"></a> is usua&#108;ly the right choice, a&#110;d if we want to make the comp&#97;risons case-insensitive, we can u&#115;e <tt>toUpper()</tt><a name="or"></a> or <tt>toLower()</tt>. For exa&#109;ple:</p>
<div class="docText"><pre>if (fileName.toLower() == "readme.txt")
    ...</pre></div><br />
<p class="docText"><a name="want to"></a>If we want to replace a certain part of a string by another s&#116;ring, we c&#97;n use <tt>repl&#97;ce()</tt>:</p>
<div class="docText"><pre>QString str = "a cloudy day";
str.replace(2, 6, "sunny");</pre></div><br />
<p class="docText"><a name="result is"></a>The res&#117;lt is &quot;a sun&#110;y day&quot;. The co&#100;e can be rewritten to use <tt>remove()</tt> and <tt>insert()</tt>:</p>
<div class="docText"><pre>str.remove(2, 6);
str.insert(2, "sunny");</pre></div><br />
<p class="docText"><a name="the string"></a>Fi&#114;st, we r&#101;mo&#118;e six characters starti&#110;g at positio&#110; 2, resulting in the string &quot;a &#100;ay&quot; (with two spaces), and then we in&#115;ert &quot;sunny&quot; at position 2.</p>
<p class="docText">There are ov&#101;rloaded versions of <tt>replace()</tt><a name="their first"></a> that re&#112;lac&#101; al&#108; occurrenc&#101;s o&#102; their first argument with thei&#114; second argument. For example, here'&#115; how to r&#101;pl&#97;ce all occurrences o&#102; &quot;&amp;&quot; with &quot;&amp;amp;&quot; in &#97; string:</p>
<div class="docText"><pre>str.replace("&amp;", "&amp;amp;");</pre></div><br />
<p class="docText"><a name="iddle3322"></a><a name="iddle3397"></a><a name="iddle3534"></a><a name="iddle5902"></a><a name="iddle5917"></a><a name="iddle5920"></a><a name="iddle5935"></a><a name="iddle5938"></a><a name="iddle5956"></a><a name="iddle5961"></a><a name="iddle7477"></a><a name="iddle7593"></a><a name="iddle7620"></a><a name="iddle8225"></a><a name="iddle8540"></a><a name="page_290"></a><a name="as spaces"></a>One very frequent need i&#115; to strip the whitespace (such as spaces, t&#97;bs, and newlines) from a string. <tt>QString</tt><a name="both ends"></a> has a func&#116;ion that eliminates whitespace from both ends of a string:</p>
<div class="docText"><pre>QString str = "   BOB \t THE \nDOG \n";
qDebug() &lt;&lt; str.trimmed();</pre></div><br />
<p class="docText">St&#114;ing <tt>st&#114;</tt> can be &#100;e&#112;ict&#101;d as</p>
<p><table cellspacing="0" class="allBorders" border="1"><colgroup align="left" span="20"><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">B</span></td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">O</span></td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">B</span></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">\t</span></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">T</span></td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">H</span></td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">E</span></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">\n</span></td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">D</span></td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">O</span></td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">G</span></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">\n</span></td></tr></table></p><br />
<p class="docText">The string re&#116;urned by <tt>trimmed()</tt> is</p>
<p><table cellspacing="0" class="allBorders" border="1"><colgroup align="left" span="15"><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">B</span></td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">O</span></td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">B</span></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">\t</span></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">T</span></td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">H</span></td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">E</span></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">\n</span></td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">D</span></td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">O</span></td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">G</span></td></tr></table></p><br />
<p class="docText"><a name="to replace"></a>When handling user in&#112;ut, w&#101; of&#116;en also want to repl&#97;ce every sequ&#101;nce of one or m&#111;re internal whitespace characters w&#105;th single spaces, in addition to stripping whit&#101;space from both ends. This is what the <tt>simplified()</tt> function does:</p>
<div class="docText"><pre>QString str = "   BOB \t THE \nDOG \n";
qDebug() &lt;&lt; str.simplified();</pre></div><br />
<p class="docText"><a name="returned by"></a>&#84;he str&#105;ng retu&#114;ned by <tt>&#115;implif&#105;ed()</tt> is</p>
<p><table cellspacing="0" class="allBorders" border="1"><colgroup align="left" span="11"><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /><col width="20" /></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">B</span></td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">O</span></td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">B</span></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">T</span></td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">H</span></td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">E</span></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">D</span></td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">O</span></td><td class="docTableCell" align="left" valign="top" style="background-color:#E6E6E6"><span class="docEmphRomanAlt">G</span></td></tr></table></p><br />
<p class="docText">A string can be split &#105;nto a <tt>QStringList</tt> of substrings using <tt>QString::sp&#108;it()</tt>:</p>
<div class="docText"><pre>QString str = "polluter pays principle";
QStringList words = str.split(" ");</pre></div><br />
<p class="docText"><a name="three substrings"></a>In the pr&#101;ce&#100;ing &#101;xample, we split &#116;he string &quot;polluter pays princip&#108;e&quot; into three substrings: &quot;polluter&quot;, &quot;pays&quot;, and &quot;princi&#112;le&quot;. The <tt>split()</tt><a name="function has"></a> function has an optiona&#108; second argument that specifies whether empty substr&#105;ngs sho&#117;ld be kept (&#116;he defau&#108;t) or discar&#100;ed.</p>
<p class="docText"><a name="in a"></a>The items in a <tt>QSt&#114;ingList</tt><a name="be joined"></a> can be joined to form a single string us&#105;ng <tt>join()</tt>. &#84;he arg&#117;ment to <tt>join()</tt><a name="to create"></a> is ins&#101;rted b&#101;tween each pair o&#102; joined strings. For examp&#108;e, here's how to create a single string that is composed of al&#108; the strings contained in a <tt>QStringLi&#115;t</tt><a name="separated by"></a> sorte&#100; i&#110;t&#111; al&#112;habetical order and separat&#101;d by newlines:</p>
<div class="docText"><pre>words.sort();
str = words.join("\n");</pre></div><br />
<p class="docText"><a name="a string"></a>When dealing with strings, &#119;e often need &#116;o determ&#105;ne whether a st&#114;ing is emp&#116;y or not. This is done by calling <tt>i&#115;Empty()</tt> or by checking whether <tt>length()</tt> is 0.</p>
<p class="docText">The &#99;onversion from <tt>const char *</tt> strings to <tt>QString</tt> is &#97;utomatic in most cases, for example:</p>
<div class="docText"><pre>str += " (1870)";</pre></div><br />
<p class="docText"><a name="iddle1445"></a><a name="iddle1770"></a><a name="iddle1801"></a><a name="iddle1832"></a><a name="iddle2014"></a><a name="iddle2853"></a><a name="iddle2854"></a><a name="iddle4793"></a><a name="iddle4796"></a><a name="iddle4797"></a><a name="iddle5605"></a><a name="iddle5747"></a><a name="iddle5913"></a><a name="iddle5914"></a><a name="iddle5942"></a><a name="iddle5949"></a><a name="iddle6448"></a><a name="iddle8102"></a><a name="iddle8117"></a><a name="iddle8411"></a>Here we add a <tt>const char *</tt> to a <tt>QString</tt> with&#111;ut &#102;orm&#97;lity. To ex&#112;lic&#105;tly convert a <tt>const char *</tt> to a <tt>QString</tt>, simp&#108;y use a <tt>QString</tt> cast, or call <tt>fromAscii()</tt> or <tt>fromLatin1()</tt>. (See <a class="docLink" href="ch18.html#ch18">Chapter 18</a><a name="in other"></a> fo&#114; an exp&#108;anation of &#104;andling &#108;iteral strings in o&#116;her encodings.)</p>
<p class="docText">To conv&#101;rt a <tt>QString</tt> to a <tt>const char *</tt>, use <tt>&#116;oAscii()</tt> or <tt>toLatin1()</tt>. These functions return a <tt>QByte&#65;rray</tt>, which can be converted int&#111; a <tt>c&#111;ns&#116; char *</tt> usi&#110;g <tt>&#81;ByteArray::data()</tt> or <tt>QByteAr&#114;ay::constData()</tt>. For example:</p>
<div class="docText"><pre>printf("User: %s\n", str.toAscii().data());</pre></div><br />
<p class="docText">For conveni&#101;nc&#101;, Qt &#112;rovides the <tt>&#113;Printable()</tt><a name="sequence"></a> mac&#114;o that performs the sam&#101; as the sequence <tt>toAscii().co&#110;stData()</tt>:</p>
<div class="docText"><pre>printf("User: %s\n", qPrintable(str));</pre></div><br />
<p class="docText"><a name="call"></a>When we call <tt>data()</tt> or <tt>cons&#116;Data()</tt> on a <tt>QByteArray</tt>, the returned string is own&#101;d b&#121; th&#101; <tt>QB&#121;te&#65;rray</tt><a name="Qt will"></a> object. This means that we do&#110;'t need to worry about memory l&#101;ak&#115;; Qt will &#114;eclaim the memory f&#111;r us. On the o&#116;her hand, we must be careful not to use t&#104;e pointer for too long. If the <tt>&#81;ByteArray</tt><a name="is not"></a> is not stored in a variable, it will be autom&#97;tically deleted at the end of the stateme&#110;t.</p>
<p class="docText">&#84;he <tt>QBy&#116;eArray</tt><a name="a very"></a> c&#108;ass has a ve&#114;y similar API to <tt>QString</tt><a name="such as"></a>. Functions such a&#115; <tt>left()</tt>, <tt>right()</tt>, <tt>mid()</tt>, <tt>toLower()</tt>, <tt>toUpper()</tt>, <tt>trimmed()</tt>, &#97;nd <tt>simpli&#102;ied()</tt> &#101;xist in <tt>QBy&#116;eArray</tt> with the s&#97;me semantics as their <tt>QSt&#114;ing</tt> counterparts. <tt>QByteArray</tt><a name="text strings"></a> is useful for &#115;toring raw binary data and 8-bit encoded t&#101;xt strings. In general, we recommend using <tt>QStr&#105;ng</tt> for s&#116;oring te&#120;t &#114;ather &#116;han <tt>QByteArray</tt> because <tt>QStri&#110;g</tt> supports Unicode.</p>
<p class="docText">For conveni&#101;nc&#101;, <tt>QB&#121;teArray</tt><a name="the last"></a> au&#116;omatically ensures &#116;hat the &quot;one past the last&quot; b&#121;te is always '\0', making it easy to pa&#115;s a <tt>QByteArray</tt> to a function taking &#97; <tt>const char *</tt>. <tt>QByteArray</tt><a name="store arbitrary"></a> also supports embedded '\0' c&#104;aract&#101;rs, &#97;llowing u&#115; to use i&#116; to store arbitrary binary data.</p>
<p class="docText"><a name="of different"></a>In som&#101; situations, we need to store data of differen&#116; types in &#116;he same v&#97;riable. One ap&#112;roach is to encod&#101; the data as a <tt>QByteArray</tt> o&#114; a <tt>QString</tt><a name="value or"></a>. For example, a string could hold a t&#101;xtual value or a numeric value in string form. &#84;hese approaches give complete flexibility, but do aw&#97;y with som&#101; of &#67;++'s benefit&#115;, in part&#105;cular type safety and &#101;fficiency. Qt provides a much cleaner way o&#102; han&#100;l&#105;ng variables that &#99;an hold differe&#110;t types: <tt>QVariant</tt>.</p>
<p class="docText">The <tt>QVar&#105;ant</tt><a name="hold values"></a> class can hold values of many Qt types, includi&#110;g <tt>QBrush</tt>, <tt>QColor</tt>, <tt>QCursor</tt>, <tt>QDateTime</tt>, <tt>QF&#111;nt</tt>, <tt>QKeySequence</tt>, <tt>QPalette</tt>, <tt>QPen</tt>, <tt>Q&#80;i&#120;m&#97;p</tt>, <tt>QPoint</tt>, <tt>Q&#82;ect</tt>, <tt>&#81;Region</tt>, <tt>QSize</tt>, and <tt>&#81;String</tt>, as well as basic C++ numeric types such as <tt>&#100;o&#117;ble</tt> and <tt>in&#116;</tt>. The <tt>QVariant</tt> cla&#115;s can also hold c&#111;ntainers: <tt>QMap&lt;QString, QV&#97;riant&gt;</tt>, <tt>QStringList</tt>, and <tt>QList&lt;QVariant&gt;</tt>.</p>
<p class="docText">The &#105;tem view classes, the database module, and <tt>QSett&#105;ngs</tt><a name="database data"></a> use variants extensively, allowing us to read and w&#114;ite it&#101;m d&#97;ta, databa&#115;e data, a&#110;d user preferences for a&#110;y <tt>QVariant</tt><a name="We already"></a>-compatible type. We &#97;lready sa&#119; an example o&#102; this in <a name="iddle1784"></a><a name="iddle1788"></a><a name="iddle1881"></a><a name="iddle1976"></a><a name="iddle2059"></a><a name="iddle4584"></a><a name="iddle5183"></a><a name="iddle6101"></a><a name="iddle6137"></a><a name="iddle8101"></a><a name="iddle8253"></a><a name="iddle8392"></a><a name="page_292"></a><a class="docLink" href="ch03.html#ch03">Chapter 3</a><a name="passed a"></a>, wher&#101; we pass&#101;d a <tt>QRect</tt>, a <tt>QStringList</tt><a name="a couple"></a>, and a &#99;ouple of <tt>bool</tt>s as variants to <tt>QSettings::setValue()</tt>, and &#114;etrieved them later as variants.</p>
<p class="docText"><a name="using"></a>It is possible t&#111; create arbitrarily complex data structures us&#105;ng <tt>QVar&#105;ant</tt> by n&#101;st&#105;ng valu&#101;s of container types:</p>
<div class="docText"><pre>QMap&lt;QString, QVariant&gt; pearMap;
pearMap["Standard"] = 1.95;
pearMap["Organic"] = 2.25;

QMap&lt;QString, QVariant&gt; fruitMap;
fruitMap["Orange"] = 2.10;
fruitMap["Pineapple"] = 3.85;
fruitMap["Pear"] = pearMap;</pre></div><br />
<p class="docText"><a name="map with"></a>H&#101;re we have created a map with string keys (produ&#99;t names) and v&#97;lues that &#97;re either floa&#116;ing-point numbers (&#112;rices) or maps. The top-l&#101;vel map contains three keys: &quot;Orange&quot;, &quot;&#80;ear&quot;, and &quot;Pineapple&quot;. The value associated with the &quot;Pea&#114;&quot; key is a map that contains two keys (&quot;Standard&quot; and &quot;&#79;rganic&quot;). When &#105;terati&#110;g &#111;ve&#114; a map that holds variant val&#117;es, we need to use <tt>type()</tt><a name="that we"></a> to check the type that a varian&#116; holds so &#116;hat we ca&#110; resp&#111;nd appropria&#116;ely.</p>
<p class="docText"><a name="very seductive"></a>Creating data structures lik&#101; this can be very seductive since we &#99;an organize the data in any way we like. But the conv&#101;nience of <tt>QVariant</tt><a name="As a"></a> comes at the e&#120;p&#101;ns&#101; of &#101;ff&#105;ciency and readability. As a rule, it is &#117;sually worth defining a proper C++ class to store ou&#114; data w&#104;eneve&#114; possible.</p>
<p class="docText"><tt>QVarian&#116;</tt><a name="by Qt"></a> is used by Qt'&#115; meta-object system and &#105;s therefore part of the <span class="docEmphasis">QtCo&#114;e</span> module. Nonetheless, when we link against the <span class="docEmphasis">QtGu&#105;</span> module, <tt>QVariant</tt> can store GUI-related types such as <tt>Q&#67;olor</tt>, <tt>QFon&#116;</tt>, <tt>QIcon</tt>, <tt>QI&#109;age</tt>, and <tt>QPix&#109;ap</tt>:</p>
<div class="docText"><pre>QIcon icon("open.png");
QVariant variant = icon;</pre></div><br />
<p class="docText">To retrie&#118;e the value of a GUI-relate&#100; type from a <tt>QVariant</tt>, we can use the <tt>QVa&#114;iant::v&#97;lue&lt;T&gt;()</tt> temp&#108;ate member func&#116;ion as follows:</p>
<div class="docText"><pre>QIcon icon = variant.value&lt;QIcon&gt;();</pre></div><br />
<p class="docText">The <tt>va&#108;ue&lt;T&gt;()</tt> function also works for conve&#114;ting between non-G&#85;I data types and <tt>QVariant</tt>, but in practice we no&#114;mally use the <tt>to...()</tt> conversion functions (e.g., <tt>toSt&#114;ing()</tt>) fo&#114; non-GU&#73; type&#115;.</p>
<p class="docText"><tt>QVaria&#110;t</tt><a name="they provide"></a> can also be used to st&#111;re custom data types, assuming they prov&#105;de a def&#97;ult const&#114;uctor and a copy c&#111;nstructor. F&#111;r this to work, we must first &#114;egister the type using the <tt>Q_DECLARE_MET&#65;TYPE()</tt><a name="typically in"></a> macro, typically in a header file below the class defini&#116;ion:</p>
<div class="docText"><pre>Q_DECLARE_METATYPE(BusinessCard)</pre></div><br />
<p class="docText"><a name="us to"></a>This enables us to write code such as this:</p>
<div class="docText"><pre>BusinessCard businessCard;
QVariant variant = QVariant::fromValue(businessCard);
...
if (variant.canConvert&lt;BusinessCard&gt;()) {
    BusinessCard card = variant.value&lt;BusinessCard&gt;();
    ...
}</pre></div><br />
<p class="docText"><a name="iddle1024"></a><a name="iddle1037"></a><a name="iddle1130"></a><a name="iddle1332"></a><a name="iddle1467"></a><a name="iddle1799"></a><a name="iddle1819"></a><a name="iddle1829"></a><a name="iddle2857"></a><a name="iddle2896"></a><a name="iddle3820"></a><a name="iddle4245"></a><a name="iddle4781"></a><a name="iddle4881"></a><a name="iddle5576"></a><a name="iddle5680"></a><a name="iddle6447"></a><a name="iddle6461"></a><a name="iddle6462"></a><a name="iddle6463"></a><a name="iddle7759"></a><a name="iddle8393"></a><a name="iddle8406"></a><a name="iddle8471"></a><a name="of a"></a>Because of a co&#109;piler limit&#97;tion, thes&#101; te&#109;plate membe&#114; functions are not availab&#108;e for MSVC 6. If you need to use th&#105;s compi&#108;er, use the <tt>q&#86;ariantFromVal&#117;e()</tt>, <tt>qVariantValue&lt;T&gt;()</tt>, a&#110;d <tt>qVariantCanConvert&lt;T&gt;()</tt> globa&#108; functions instead.</p>
<p class="docText">If the custom data type &#104;as <tt>&lt;&lt;</tt> and <tt>&gt;&gt;</tt> operators for writing to and rea&#100;ing from a <tt>QDataStream</tt>, we can register t&#104;em usi&#110;g <tt>&#113;Regi&#115;terMet&#97;TypeStreamOperators&lt;T&gt;()</tt><a name="data types"></a>. This makes i&#116; possible to store preferences of c&#117;stom data &#116;ypes usi&#110;g <tt>QSe&#116;tings</tt>, among &#111;ther things. For e&#120;ample:</p>
<div class="docText"><pre>qRegisterMetaTypeStreamOperators&lt;BusinessCard&gt;("BusinessCard");</pre></div><br />
<p class="docText"><a name="Qt containers"></a>This chapter focused on th&#101; Qt containers, as well as on <tt>QString</tt>, <tt>QByt&#101;Array</tt>, and <tt>QVariant</tt><a name="other containers"></a>. In addition to &#116;hese cla&#115;ses, Qt a&#108;so provide&#115; a few ot&#104;er containers. One is <tt>QPair&lt;&#84;1, T2&gt;</tt><a name="similar to"></a>, which simply stores two values and is s&#105;milar t&#111; <tt>st&#100;::pair&lt;T1, T2&gt;</tt>. Anot&#104;er is <tt>QBitArray</tt><a name="section of"></a>, &#119;hich we will use in the first section of <a class="docLink" href="ch21.html#ch21">Chapter 21</a>. Fi&#110;ally, there is <tt>QVarLengthArray&lt;&#84;, Prealloc&gt;</tt><a name="to"></a>, a low-level alternative to <tt>QVector&lt;T&gt;</tt><a name="its overhead"></a>. Beca&#117;se it preallocates memory on the stack and isn't implicitly shared, i&#116;s overhe&#97;d is less t&#104;an tha&#116; of <tt>QVect&#111;r&lt;T&gt;</tt><a name="making it"></a>, making it more approp&#114;iate for tight loops.</p>
<p class="docText"><a name="few not"></a>Qt's algorithms, incl&#117;ding a few &#110;o&#116; covered here, su&#99;h as <tt>qCopyBackward()</tt> and <tt>qE&#113;ual()</tt><a name="described in"></a>, are described in Q&#116;'s documentation at <a class="docLink" target="_blank" href="http://doc.trolltech.com/4.3/qtalgorithms.html">http://doc.trolltech.com/4.3/qtalgorithms.html</a><a name="time complexity"></a>. And for m&#111;re details of Qt's containers, incl&#117;ding information on their time complexity an&#100; g&#114;owth s&#116;rategie&#115;, see <a class="docLink" target="_blank" href="http://doc.trolltech.com/4.3/containers.html">http://doc.trolltech.com/4.3/containers.html</a>.</p>

</div></div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch11lev1sec3.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch12.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>