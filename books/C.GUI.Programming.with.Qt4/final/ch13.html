<html>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<head>
<title>ch13.html</title>
<link rel="STYLESHEET" type="text/css" href="images/css1.css">
<link rel="STYLESHEET" type="text/css" href="images/css2.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch12lev1sec5.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch13lev1sec1.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<div style=""><div><a name="ch13"></a>

<h2 id="title-ID0EZPOM" class="docChapterTitle">13. Databases</h2>



<p class="docText">
<img border="0" id="" width="150" height="161" src="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzcmduZV9laXBjX2hwaDEzL2FjcnNvdGouZXBw.jpg" alt="" /></p>



<ul><li><p class="docList"><a name="iddle1694"></a><a name="iddle1739"></a><a name="iddle2026"></a><a name="iddle2039"></a><a name="iddle2294"></a><a name="iddle3094"></a><a name="iddle3223"></a><a name="iddle3815"></a><a name="iddle3968"></a><a name="iddle4120"></a><a name="iddle4184"></a><a name="iddle4399"></a><a name="iddle6168"></a><a name="iddle6170"></a><a name="iddle7671"></a><a name="iddle7672"></a><a name="iddle7900"></a><a name="iddle7940"></a><span class="docEmphasis"><a class="docLink" href="ch13lev1sec1.html#ch13lev1sec1">Connecting and Querying</a></span></p></li><li><p class="docList"><span class="docEmphasis"><a class="docLink" href="ch13lev1sec2.html#ch13lev1sec2">Viewing Tables</a></span></p></li><li><p class="docList"><span class="docEmphasis"><a class="docLink" href="ch13lev1sec3.html#ch13lev1sec3">Editing Records Using Forms</a></span></p></li><li><p class="docList"><span class="docEmphasis"><a class="docLink" href="ch13lev1sec4.html#ch13lev1sec4">Presenting Data in Tabular Forms</a></span></p></li></ul>
<p class="docText"><a name="The"></a>&#84;he <span class="docEmphasis">QtS&#113;l</span><a name="a platform"></a> mod&#117;le provid&#101;s a &#112;latform- and database-indep&#101;ndent interface for accessing SQL databases. T&#104;is int&#101;rf&#97;ce is support&#101;d by a s&#101;t of classes that use Qt's m&#111;del/view architecture to provi&#100;e database integration with the u&#115;er interface. This chapter assumes familiarity with Qt's mod&#101;l/v&#105;ew clas&#115;es, cove&#114;ed in <a class="docLink" href="ch10.html#ch10">Chapter 10</a>.</p>
<p class="docText"><a name="database connection"></a>A &#100;atabase connect&#105;on is represented by a <tt>QSqlDa&#116;abase</tt><a name="The Qt"></a> ob&#106;ect. Qt us&#101;s drivers &#116;o communicate wi&#116;h the various database APIs. The Qt D&#101;sktop Edition includes the fo&#108;lowing drivers:</p>
<p><table cellspacing="0" class="allBorders" border="1"><colgroup align="left" span="2"><col width="75" /><col width="275" /></colgroup><thead><tr><th scope="col" class="docTableCell thead" align="center" valign="top" style="background-color:#E6E6E6">Driver</th><th scope="col" class="docTableCell thead" align="center" valign="top" style="background-color:#E6E6E6">Database</th></tr></thead><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QDB2</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">IBM DB2 version 7.1and &#108;ater</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QIBASE</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">Borland InterBase</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QMYSQL</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">MySQL</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QOCI</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">Oracle (Oracle Ca&#108;l Interfac&#101;)</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QO&#68;BC</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">ODBC (inc&#108;udes Micro&#115;oft SQL Server)</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QPSQL</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">Po&#115;tgreSQL 7.3 and later</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QSQLITE</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">SQLite version 3</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">Q&#83;QLIT&#69;2</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">SQLite vers&#105;on 2</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QTDS</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">Sybas&#101; Adaptive Ser&#118;er</span></td></tr></table></p><br />
<p class="docText"><a name="of the"></a>Due to license restrictions, not all of the driv&#101;rs are provided with the Qt Open Sou&#114;ce Edition. When configuring Qt, we can c&#104;oose between including the SQL drivers in&#115;ide Qt i&#116;self and &#98;uilding th&#101;m a&#115; plugins. Qt is supplied w&#105;th the SQLite database, a public domain i&#110;-p&#114;ocess &#100;atabase.<sup class="docFootnote"><a class="docLink" href="#ch13fn01">[*]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="ch13fn01">[*]</a></sup><a name="Qt can"></a> SQ&#76; support must be enabl&#101;d when Qt is built. For e&#120;ample, Qt can be compiled with support for S&#81;Lite built-in by passing the <tt>-qt-&#115;ql-sqlite</tt> command-line option to the <tt>co&#110;f&#105;gure</tt><a name="in the"></a> sc&#114;ipt or &#98;y setting t&#104;e appropriate option in th&#101; Qt installer.</p></blockquote>
<p class="docText"><a name="iddle1089"></a><a name="iddle1759"></a><a name="iddle1900"></a><a name="iddle2028"></a><a name="iddle3660"></a><a name="iddle3765"></a><a name="iddle3867"></a><a name="iddle4153"></a><a name="iddle5804"></a><a name="iddle5805"></a><a name="iddle5811"></a><a name="iddle5814"></a><a name="iddle5815"></a><a name="iddle5816"></a><a name="iddle5817"></a><a name="iddle5847"></a><a name="iddle5855"></a><a name="iddle7192"></a><a name="iddle7240"></a><a name="iddle7280"></a><a name="iddle7360"></a><a name="the"></a>For users who are comfor&#116;able wit&#104; SQL sy&#110;tax, the <tt>QSql&#81;uery</tt><a name="a means"></a> clas&#115; provides a means of directly executi&#110;g arbitrary SQL statements and &#104;andling their results. For users who prefer a h&#105;gher-level database interface that avoids SQL synt&#97;x, <tt>QSqlTab&#108;eModel</tt> and <tt>&#81;Sq&#108;Relationa&#108;TableModel</tt><a name="the same"></a> provide suitable abstraction&#115;. These classes represent an SQL table in &#116;he same w&#97;y as Qt's ot&#104;er model c&#108;asses (covered in <a class="docLink" href="ch10.html#ch10">Chapter 10</a><a name="They can"></a>). T&#104;ey can be used stand-alone to trav&#101;rse and edit data in c&#111;de, or they can be attached to views through &#119;hich end-users can view and edit the data themselves.</p>
<p class="docText"><a name="makes it"></a>Q&#116; also mak&#101;s i&#116; straigh&#116;forward &#116;o program the common database idioms, suc&#104; as masterâ€“detail and drill-down, and to view da&#116;abase ta&#98;les using f&#111;rms or GUI t&#97;bles, as the ex&#97;mples in this chapter will demonst&#114;ate.</p>




<a name="ch13lev1sec1"></a>
<h3 class="docSection1Title" id="-100000">Connecting and Querying</h3>
<p class="docText"><a name="execute SQL"></a>To execute SQL queries, we must first &#101;stablish a connection with a database. &#84;ypically, database connections are set up in &#97; separate &#102;unc&#116;ion that &#119;e call at app&#108;ication startup. For example:</p>
<div class="docText"><pre>bool createConnection()
{
    QSqlDatabase db = QSqlDatabase::addDatabase("QMYSQL");
    db.setHostName("mozart.konkordia.edu");
    db.setDatabaseName("musicdb");
    db.setUserName("gbatstone");
    db.setPassword("T17aV44");
    if (!db.open()) {
        QMessageBox::critical(0, QObject::tr("Database Error"),
                              db.lastError().text());
        return false;
    }
    return true;
}</pre></div><br />
<p class="docText">First, we &#99;all <tt>QSqlDatabase::addDatabase()</tt> to create a <tt>QSqlDatabase</tt> object. The f&#105;rst arg&#117;ment to <tt>ad&#100;Database()</tt><a name="the database"></a> sp&#101;cifies &#119;hich database driver Qt must use to ac&#99;ess the database. In this case, we use MySQL.</p>
<p class="docText"><a name="the database"></a>Next, &#119;e set the database host name, the database name, the user &#110;ame, and the password, and we open the conn&#101;ct&#105;on. If <tt>op&#101;n()</tt> f&#97;ils, we sho&#119; an error message.</p>
<p class="docText">Typically, we wo&#117;ld call <tt>createConnection()</tt> in <tt>ma&#105;n()</tt>:</p>
<div class="docText"><pre>int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    if (!createConnection())
        return 1;
    ...
    return app.exec();
}</pre></div><br />
<p class="docText"><a name="iddle1833"></a><a name="iddle2030"></a><a name="iddle2659"></a><a name="iddle2773"></a><a name="iddle3239"></a><a name="iddle3317"></a><a name="iddle3479"></a><a name="iddle4018"></a><a name="iddle4425"></a><a name="iddle5823"></a><a name="iddle5827"></a><a name="iddle5828"></a><a name="iddle5829"></a><a name="iddle5830"></a><a name="iddle5831"></a><a name="iddle5834"></a><a name="iddle5835"></a><a name="iddle5836"></a><a name="iddle5837"></a><a name="iddle6422"></a><a name="iddle6452"></a><a name="iddle6927"></a><a name="iddle7063"></a><a name="iddle7076"></a><a name="iddle7231"></a><a name="iddle8389"></a><a name="iddle8412"></a>Once a &#99;onnection i&#115; established, we &#99;an use <tt>QSqlQuery</tt><a name="For example"></a> to exe&#99;ute any SQL statement that the und&#101;rlying database supports. For exa&#109;ple, here's how to execute a <tt>SELECT</tt> statement:</p>
<div class="docText"><pre>QSqlQuery query;
query.exec("SELECT title, year FROM cd WHERE year &gt;= 1998");</pre></div><br />
<p class="docText">After the <tt>ex&#101;c()</tt> call, we can navigate through the query's resu&#108;t set:</p>
<div class="docText"><pre>while (query.next()) {
    QString title = query.value(0).toString();
    int year = query.value(1).toInt();
    std::cerr &lt;&lt; qPrintable(title) &lt;&lt; ": " &lt;&lt; year &lt;&lt; std::endl;
}</pre></div><br />
<p class="docText">We cal&#108; <tt>next()</tt> once t&#111; po&#115;ition t&#104;e <tt>QSqlQuery</tt> on the <span class="docEmphasis">fi&#114;st</span> record of the result set. Subsequent &#99;alls to <tt>next()</tt><a name="each time"></a> &#97;dvance th&#101; record pointer &#98;y one record e&#97;ch time, until the end is reache&#100;, at which point <tt>next()</tt> returns <tt>false</tt><a name="the query"></a>. I&#102; the result set is empty (or if the query &#102;ailed), the first call to <tt>next()</tt> will return <tt>false</tt>.</p>
<p class="docText">The <tt>va&#108;ue()</tt><a name="the value"></a> functio&#110; r&#101;tu&#114;ns the &#118;alue of a field as a <tt>QVariant</tt><a name="in the"></a>. &#84;he fields are numbered from 0 in the orde&#114; given &#105;n the <tt>SE&#76;ECT</tt><a name="The"></a> stateme&#110;t. The <tt>QVa&#114;iant</tt><a name="hold many"></a> class can hold many C++ and Qt &#116;ypes, including <tt>int</tt> and <tt>QString</tt><a name="different types"></a>. Th&#101; different types of data that can b&#101; stored in a database are ma&#112;ped &#105;nto the &#99;orrespondi&#110;g &#67;++ and Qt types and stored i&#110; <tt>QVariant</tt>s. For example, a <tt>VARCHAR</tt> is repre&#115;ented a&#115; a <tt>QStri&#110;g</tt> and a <tt>DATET&#73;ME</tt> as a <tt>QDateTim&#101;</tt>.</p>
<p class="docText"><tt>QSqlQuery</tt> provides som&#101; other functions to navigate through t&#104;e result set: <tt>first()</tt>, <tt>last()</tt>, <tt>previous()</tt>, and <tt>seek()</tt><a name="be slower"></a>. These functions a&#114;e convenient, but for some databases they can &#98;e slower an&#100; m&#111;re &#109;emory-hungr&#121; than <tt>next()</tt><a name="operating on"></a>. For an easy optimizati&#111;n when operating on large data sets, &#119;e can call <tt>QS&#113;lQue&#114;y::setForw&#97;rdOnly(true)</tt> before c&#97;lling <tt>exec()</tt>, and then only use <tt>ne&#120;t()</tt> for navigating through the resu&#108;t set.</p>
<p class="docText"><a name="to"></a>Earlier we specified the SQL qu&#101;ry as an argument to <tt>QSqlQuery::exec()</tt><a name="to the"></a>, but we can al&#115;o pass i&#116; directl&#121; to &#116;he const&#114;uctor, which executes it immedia&#116;ely:</p>
<div class="docText"><pre>QSqlQuery query("SELECT title, year FROM cd WHERE year &gt;= 1998");</pre></div><br />
<p class="docText"><a name="calling"></a>We can check for an error by ca&#108;ling <tt>isAct&#105;ve()</tt> on th&#101; query:</p>
<div class="docText"><pre>if (!query.isActive())
    QMessageBox::warning(this, tr("Database Error"),
                         query.lastError().text());</pre></div><br />
<p class="docText"><a name="error occurs"></a>&#73;f no error oc&#99;urs, the query will become &quot;active&quot; and w&#101; can use <tt>next()</tt> to navigate thro&#117;gh the result set.</p>
<p class="docText">Doing an <tt>INSERT</tt> is almost as easy as p&#101;rforming a <tt>SELECT</tt>:</p>
<div class="docText"><pre>QSqlQuery query("INSERT INTO cd (id, artistid, title, year) "
                "VALUES (203, 102, 'Living in America', 2002)");</pre></div><br />
<p class="docText"><a name="iddle1087"></a><a name="iddle1225"></a><a name="iddle1330"></a><a name="iddle1710"></a><a name="iddle1760"></a><a name="iddle2029"></a><a name="iddle2032"></a><a name="iddle2033"></a><a name="iddle2828"></a><a name="iddle3346"></a><a name="iddle3482"></a><a name="iddle4071"></a><a name="iddle4317"></a><a name="iddle4415"></a><a name="iddle5807"></a><a name="iddle5812"></a><a name="iddle5818"></a><a name="iddle5825"></a><a name="iddle5826"></a><a name="iddle5832"></a><a name="iddle5833"></a><a name="iddle6961"></a><a name="iddle8177"></a><a name="iddle8189"></a><a name="iddle8295"></a><a name="iddle8395"></a>After this, <tt>numRowsAffected()</tt><a name="the SQL"></a> r&#101;tu&#114;ns the &#110;u&#109;ber of rows t&#104;at were affected b&#121; the SQL statement (or -1 on e&#114;ror).</p>
<p class="docText"><a name="If we"></a>If &#119;e need to ins&#101;rt a lot of rec&#111;rds, or if we &#119;ant to avoid converting values to strings (a&#110;d escaping them correctly), we can use <tt>prepa&#114;e()</tt><a name="a query"></a> to specify a query that contains place&#104;olders and then bind the values we want to insert. &#81;t s&#117;pports bo&#116;h the Ora&#99;le-style and &#116;he ODBC-style syntax for placeho&#108;ders for all databases, using native support where it is avail&#97;ble and si&#109;ulating it o&#116;herwise. Here'&#115; an example t&#104;at uses the Oracle-style syntax with n&#97;med placeholders:</p>
<div class="docText"><pre>QSqlQuery query;
query.prepare("INSERT INTO cd (id, artistid, title, year) "
              "VALUES (:id, :artistid, :title, :year)");
query.bindValue(":id", 203);
query.bindValue(":artistid", 102);
query.bindValue(":title", "Living in America");
query.bindValue(":year", 2002);
query.exec();</pre></div><br />
<p class="docText"><a name="same example"></a>Here's the same exa&#109;ple using ODBC-style positional placeholders:</p>
<div class="docText"><pre>QSqlQuery query;
query.prepare("INSERT INTO cd (id, artistid, title, year) "
              "VALUES (?, ?, ?, ?)");
query.addBindValue(203);
query.addBindValue(102);
query.addBindValue("Living in America");
query.addBindValue(2002);
query.exec();</pre></div><br />
<p class="docText">After t&#104;e call to <tt>exec()</tt>, we can call <tt>bindValue()</tt> or <tt>addBindValue()</tt> to &#98;ind new val&#117;es, and the&#110; c&#97;ll <tt>exec()</tt> ag&#97;in to execute the query with the new va&#108;ues.</p>
<p class="docText"><a name="strings that"></a>Placeholders are often used to speci&#102;y bi&#110;a&#114;y data or s&#116;rings that contain &#110;on-ASCII or non-La&#116;in-1 characters. Behind the scenes, Qt uses Unicode &#119;ith those databases that support Unicode, and for tho&#115;e that don't, Qt transparently converts strings to t&#104;e appr&#111;pr&#105;ate enc&#111;di&#110;g.</p>
<p class="docText"><a name="databases where"></a>Qt supports SQL transac&#116;ions on databases where they are available. To sta&#114;t a tra&#110;s&#97;ction, we call <tt>transa&#99;tion()</tt> on the <tt>QSqlDa&#116;abase</tt><a name="call either"></a> object that represent&#115; the database connection. To fini&#115;h the transaction, we call either <tt>commit()</tt> or <tt>rollback()</tt><a name="foreign key"></a>. For exa&#109;ple, here's how we would look up a foreign key and execute an <tt>INSER&#84;</tt> state&#109;ent inside a &#116;ransact&#105;on:</p>
<div class="docText"><pre>QSqlDatabase::database().transaction();
QSqlQuery query;
query.exec("SELECT id FROM artist WHERE name = 'Gluecifer'");
if (query.next()) {
    int artistId = query.value(0).toInt();
    query.exec("INSERT INTO cd (id, artistid, title, year) "
               "VALUES (201, " + QString::number(artistId)
               + ", 'Riding the Tiger', 1997)");
}
QSqlDatabase::database().commit();</pre></div><br />
<p class="docText"><a name="iddle1090"></a><a name="iddle1337"></a><a name="iddle2025"></a><a name="iddle2062"></a><a name="iddle2094"></a><a name="iddle2293"></a><a name="iddle2976"></a><a name="iddle2977"></a><a name="iddle2982"></a><a name="iddle3240"></a><a name="iddle3939"></a><a name="iddle3978"></a><a name="iddle5806"></a><a name="iddle5809"></a><a name="iddle5810"></a><a name="iddle5820"></a><a name="iddle5856"></a><a name="iddle7077"></a><a name="iddle8345"></a>The <tt>Q&#83;qlDatabase::database()</tt> func&#116;ion returns a <tt>QSqlDatabase</tt> object representing the c&#111;nn&#101;ct&#105;on we creat&#101;d in <tt>c&#114;eateConnection()</tt>. If a t&#114;ansaction cannot be started, <tt>QSql&#68;atabase::transaction()</tt> returns <tt>false</tt>. Some da&#116;abases don't support transactions. For those, the <tt>transact&#105;on()</tt>, <tt>comm&#105;t()</tt>, and <tt>ro&#108;lback()</tt><a name="database supports"></a> func&#116;ions do n&#111;thing. We can test &#119;hether a database supports transactions using <tt>hasFea&#116;ure()</tt> on th&#101; <tt>QS&#113;lDriver</tt><a name="the database"></a> associa&#116;ed with the data&#98;ase:</p>
<div class="docText"><pre>QSqlDriver *driver = QSqlDatabase::database().driver();
if (driver-&gt;hasFeature(QSqlDriver::Transactions))
    ...</pre></div><br />
<p class="docText"><a name="the database"></a>Several other database features c&#97;n be tested for, including whet&#104;er the database supports BLOBs (binary la&#114;ge objects), Unicode, and prepared q&#117;eries.</p>
<p class="docText"><a name="It is"></a>It i&#115; also po&#115;sible t&#111; ac&#99;ess the low-level database driver h&#97;ndle and the low-level handle to a query's result &#115;et, usin&#103; <tt>QSql&#68;river::handle()</tt> and <tt>QSqlR&#101;sult::handle()</tt><a name="are dangerous"></a>. Ho&#119;ever, both functions are da&#110;gerous unless you kno&#119; exactly what you are doing and are very careful. See t&#104;eir documentation for examples and an explanation of &#116;he risks.</p>
<p class="docText"><a name="the examples"></a>&#73;n the &#101;xa&#109;ples so far, w&#101; have assumed that the applicati&#111;n is using a single database connect&#105;on. If we &#119;ant to creat&#101; multiple conn&#101;ctions, we c&#97;n pass a name as a second argument to <tt>ad&#100;Database()</tt>. For example:</p>
<div class="docText"><pre>QSqlDatabase db = QSqlDatabase::addDatabase("QPSQL", "OTHER");
db.setHostName("saturn.mcmanamy.edu");
db.setDatabaseName("starsdb");
db.setUserName("hilbert");
db.setPassword("ixtapa7");</pre></div><br />
<p class="docText">We can then r&#101;trieve a pointer to the <tt>QSqlDatabase</tt> object by pa&#115;sing the name to <tt>QSqlDatabase::database()</tt>:</p>
<div class="docText"><pre>QSqlDatabase db = QSqlDatabase::database("OTHER");</pre></div><br />
<p class="docText">To execute queries using t&#104;e othe&#114; conne&#99;tion, we pass &#116;he <tt>QSqlD&#97;tabase</tt> object to the <tt>QSqlQue&#114;y</tt> constructor:</p>
<div class="docText"><pre>QSqlQuery query(db);
query.exec("SELECT id FROM artist WHERE name = 'Mando Diao'");</pre></div><br />
<p class="docText"><a name="more than"></a>Multiple connections are &#117;seful if w&#101; wa&#110;t to perfor&#109; more than one tr&#97;nsaction at a time, since ea&#99;h connection can handle only a s&#105;ngle active transaction. When we use multiple database conn&#101;ctions, we can still have one unnamed connect&#105;on, and <tt>Q&#83;qlQu&#101;ry</tt><a name="none is"></a> &#119;ill use that &#99;onnection if none is specifi&#101;d.</p>
<p class="docText">In addition to <tt>QSqlQuery</tt>, Qt pr&#111;vi&#100;e&#115; the <tt>QSqlTableMode&#108;</tt><a name="SQL for"></a> class as a higher-le&#118;el interface, allowing us to avoid u&#115;ing raw SQL for performing the most &#99;ommon SQL operations (<tt>SELECT</tt>, <tt>INSERT</tt>, <tt>UPDATE</tt>, and <tt>DELETE</tt>). The class &#99;an also be used <a name="iddle2031"></a><a name="iddle2742"></a><a name="iddle3236"></a><a name="iddle3584"></a><a name="iddle5284"></a><a name="iddle5840"></a><a name="iddle5862"></a><a name="iddle5863"></a><a name="iddle5865"></a><a name="iddle5869"></a><a name="iddle5871"></a><a name="iddle5875"></a><a name="iddle5877"></a><a name="iddle6184"></a><a name="iddle6804"></a><a name="iddle6928"></a><a name="iddle7065"></a><a name="iddle7181"></a><a name="iddle7214"></a><a name="iddle7342"></a><a name="iddle7884"></a><a name="iddle7922"></a><a name="iddle8390"></a><a name="or it"></a>stand-alone to manipulate a database wi&#116;hout any &#71;UI &#105;nvolve&#109;ent, or it can &#98;e used as a data source for <tt>QListView</tt> &#111;r <tt>QTableView</tt>.</p>
<p class="docText">Here's an example that use&#115; <tt>QSqlTa&#98;leModel</tt> to &#112;erform &#97; <tt>SELECT</tt>:</p>
<div class="docText"><pre>QSqlTableModel model;
model.setTable("cd");
model.setFilter("year &gt;= 1998");
model.select();</pre></div><br />
<p class="docText">This is equ&#105;valent to the query</p>
<div class="docText"><pre>SELECT * FROM cd WHERE year &gt;= 1998</pre></div><br />
<p class="docText"><a name="by retrieving"></a>Navigatin&#103; through the result set is done by retrievi&#110;g a given record using <tt>QSqlTableMode&#108;::record()</tt><a name="accessing individual"></a> and by accessing individual fields using <tt>value()</tt>:</p>
<div class="docText"><pre>for (int i = 0; i &lt; model.rowCount(); ++i) {
    QSqlRecord record = model.record(i);
    QString title = record.value("title").toString();
    int year = record.value("year").toInt();
    std::cerr &lt;&lt; qPrintable(title) &lt;&lt; ": " &lt;&lt; year &lt;&lt; std::endl;
}</pre></div><br />
<p class="docText">Th&#101; <tt>QS&#113;lRec&#111;rd::&#118;alue()</tt><a name="When operating"></a> funct&#105;on takes either a field name or &#97; field index. When operating on large data s&#101;ts, &#105;t is rec&#111;mmend&#101;d that fie&#108;ds are specified by their indexe&#115;. For example:</p>
<div class="docText"><pre>int titleIndex = model.record().indexOf("title");
int yearIndex = model.record().indexOf("year");
for (int i = 0; i &lt; model.rowCount(); ++i) {
    QSqlRecord record = model.record(i);
    QString title = record.value(titleIndex).toString();
    int year = record.value(yearIndex).toInt();
    std::cerr &lt;&lt; qPrintable(title) &lt;&lt; ": " &lt;&lt; year &lt;&lt; std::endl;
}</pre></div><br />
<p class="docText"><a name="To insert"></a>To insert a record into a database ta&#98;le, we call <tt>insertRow()</tt><a name="a new"></a> to creat&#101; a new empty row (record), and we use <tt>setData()</tt><a name="set the"></a> to s&#101;t t&#104;e valu&#101;s o&#102; eac&#104; column (field):</p>
<div class="docText"><pre>QSqlTableModel model;
model.setTable("cd");
int row = 0;
model.insertRows(row, 1);
model.setData(model.index(row, 0), 113);
model.setData(model.index(row, 1), "Shanghai My Heart");
model.setData(model.index(row, 2), 224);
model.setData(model.index(row, 3), 2003);
model.submitAll();</pre></div><br />
<p class="docText">After t&#104;e call to <tt>submitAll()</tt><a name="depending on"></a>, the record might be moved &#116;o a diffe&#114;ent ro&#119; position, depend&#105;ng on how the table is &#111;rdered. The <tt>subm&#105;tAll()</tt> call will return <tt>false</tt> if the inser&#116;ion failed.</p>
<p class="docText"><a name="iddle5864"></a><a name="iddle5866"></a><a name="iddle5870"></a><a name="iddle6862"></a><a name="iddle7066"></a><a name="iddle7182"></a><a name="SQL model"></a>An important differenc&#101; between an SQL model and a standard model is that fo&#114; an SQL &#109;odel we must &#99;all <tt>submitA&#108;l()</tt> to have an&#121; changes written to the da&#116;abase.</p>
<p class="docText">To update a record, we must first position the <tt>QS&#113;lTab&#108;eModel</tt> on t&#104;e record we wa&#110;t to modify (&#101;.g., using <tt>select()</tt><a name="to change"></a>). We then ext&#114;act the record, update the fields &#119;e want to change, and write our chang&#101;s back to the database:</p>
<div class="docText"><pre>QSqlTableModel model;
model.setTable("cd");
model.setFilter("id = 125");
model.select();
if (model.rowCount() == 1) {
    QSqlRecord record = model.record(0);
    record.setValue("title", "Melody A.M.");
    record.setValue("year", record.value("year").toInt() + 1);
    model.setRecord(0, record);
    model.submitAll();
}</pre></div><br />
<p class="docText"><a name="the specified"></a>If there is a record that matches the &#115;pecifi&#101;d f&#105;lter, we &#114;etrie&#118;e it using <tt>QSqlTableModel::record()</tt><a name="original record"></a>. We apply &#111;ur changes and overwrite the original reco&#114;d with &#111;ur &#109;odified record.</p>
<p class="docText"><a name="also possible"></a>&#73;t is also possibl&#101; to perform an update u&#115;ing <tt>setData()</tt><a name="indexes that"></a>, just as we would do for a non-SQL m&#111;del. The model indexes that we retrie&#118;e are for a given row and column:</p>
<div class="docText"><pre>model.select();
if (model.rowCount() == 1) {
    model.setData(model.index(0, 1), "Melody A.M.");
    model.setData(model.index(0, 3),
                  model.data(model.index(0, 3)).toInt() + 1);
    model.submitAll();
}</pre></div><br />
<p class="docText"><a name="Deleting a"></a>Deleting a record is similar to upda&#116;ing:</p>
<div class="docText"><pre>model.setTable("cd");
model.setFilter("id = 125");
model.select();
if (model.rowCount() == 1) {
    model.removeRows(0, 1);
    model.submitAll();
}</pre></div><br />
<p class="docText">The <tt>r&#101;mo&#118;eRows()</tt><a name="the row"></a> call &#116;akes the &#114;ow number of the first record &#116;o delete and the number of records to delete. The nex&#116; example &#100;e&#108;etes all the re&#99;ords that match the fi&#108;ter:</p>
<div class="docText"><pre>model.setTable("cd");
model.setFilter("year &lt; 1990");
model.select();
if (model.rowCount() &gt; 0) {
    model.removeRows(0, model.rowCount());
    model.submitAll();
}</pre></div><br />
<p class="docText"><a name="iddle2614"></a><a name="iddle4472"></a><a name="iddle5857"></a><a name="iddle6013"></a><a name="iddle6185"></a><a name="iddle7041"></a><a name="iddle7923"></a>The <tt>QSqlQuery</tt> and <tt>QSqlTableModel</tt><a name="provide an"></a> cl&#97;sses provide an interface between &#81;t and an SQL database. Using these classes, we ca&#110; create forms that present da&#116;a to user&#115; and tha&#116; let them &#105;nsert, u&#112;date, and dele&#116;e records.</p>
<p class="docText"><a name="the line"></a>For projects that use the SQL classes, we mu&#115;t add th&#101; li&#110;e</p>
<div class="docText"><pre>QT += sql</pre></div><br />
<p class="docText">to their <tt>.p&#114;o</tt><a name="application is"></a> file. This wi&#108;l ensure that the application is linke&#100; against the <span class="docEmphasis">QtSql</span> library.</p>

</div></div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch12lev1sec5.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch13lev1sec1.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>