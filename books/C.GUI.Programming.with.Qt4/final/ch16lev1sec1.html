<html>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<head>
<title>ch16lev1sec1.html</title>
<link rel="STYLESHEET" type="text/css" href="images/css1.css">
<link rel="STYLESHEET" type="text/css" href="images/css2.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch16.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch16lev1sec2.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<div style=""><div><a name="ch16"></a>

<h2 id="title-ID0EBWOM" class="docChapterTitle">16. XML</h2>



<p class="docText">
<img border="0" id="" width="150" height="152" src="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzcmduZV9laXBjX2hwaDE2L2FjcnNvdGouZXBw.jpg" alt="" /></p>



<ul><li><p class="docList"><a name="iddle2196"></a><a name="iddle2722"></a><a name="iddle3769"></a><a name="iddle6145"></a><a name="iddle6165"></a><a name="iddle6172"></a><a name="iddle6178"></a><a name="iddle6179"></a><a name="iddle6708"></a><a name="iddle7021"></a><a name="iddle7032"></a><a name="iddle7893"></a><a name="iddle8707"></a><a name="iddle8726"></a><a name="iddle8730"></a><span class="docEmphasis"><a class="docLink" href="ch16lev1sec1.html#ch16lev1sec1">Reading XML with QXmlStreamReader</a></span></p></li><li><p class="docList"><span class="docEmphasis"><a class="docLink" href="ch16lev1sec2.html#ch16lev1sec2">Reading XML with DOM</a></span></p></li><li><p class="docList"><span class="docEmphasis"><a class="docLink" href="ch16lev1sec3.html#ch16lev1sec3">Reading XML with SAX</a></span></p></li><li><p class="docList"><span class="docEmphasis"><a class="docLink" href="ch16lev1sec4.html#ch16lev1sec4">Writing XML</a></span></p></li></ul>
<p class="docText"><a name="XML "></a>&#88;ML (eXtensi&#98;le Markup L&#97;nguage) is &#97; general-p&#117;rpose text file format that is popula&#114; for data interchange and data storag&#101;. It &#119;as develope&#100; by th&#101; World Wid&#101; Web Consortium (W3C) as a lightweight alter&#110;ative to SGML (Standard Gene&#114;alized Markup Language). The syntax is simil&#97;r to HTML, but XML is a metalanguage and as such does n&#111;t m&#97;ndate spe&#99;ific tags, at&#116;ributes, &#111;r entities. The XM&#76;-compliant version of HTML is called XHTML.</p>
<p class="docText"><a name="popular SVG"></a>For the p&#111;pu&#108;ar SVG (Scal&#97;ble Vector Graph&#105;cs) XML form&#97;t, the <span class="docEmphasis">QtSvg</span><a name="provides classes"></a> module provides classes that &#99;an load and render SVG images. Fo&#114; rendering documents that use the MathML (Mathemati&#99;al Markup Language) XML format, the <tt>QtMmlWidget</tt> from &#81;t S&#111;lu&#116;ions can &#98;e used.</p>
<p class="docText">For g&#101;neral XML process&#105;ng, Qt provides the <span class="docEmphasis">QtXml</span> module, which is the subj&#101;ct &#111;f t&#104;is chapter.<sup class="docFootnote"><a class="docLink" href="#ch16fn01">[*]</a></sup> &#84;he <span class="docEmphasis">QtXml</span> module off&#101;rs three distinct APIs for rea&#100;ing XML documents:</p><blockquote><p class="docFootnote"><sup><a name="ch16fn01">[*]</a></sup><a name="providing support"></a> Qt 4.4 is expect&#101;d to include additional high-level classes for h&#97;ndling XML, providing support for XQuery and X&#80;a&#116;h, in a sep&#97;rate modu&#108;e called <span class="docEmphasis">Qt&#88;mlPatterns</span>.</p></blockquote>
<ul><li><p class="docList"><tt>QXmlStreamReader</tt><a name="reading well"></a> is a fa&#115;t parser for reading well-formed XML.</p></li><li><p class="docList"><a name="which the"></a>DOM (Docu&#109;ent Object M&#111;de&#108;) converts an X&#77;L document into a tr&#101;e structure, which the application ca&#110; then navigate.</p></li><li><p class="docList"><a name="application through"></a>SAX (Simple API for X&#77;L) reports &quot;parsing events&quot; directly to the application th&#114;ough virtual functions.</p></li></ul>
<p class="docText">The <tt>QXmlStreamReader</tt><a name="use and"></a> class is the f&#97;stest and &#101;as&#105;est to u&#115;e and of&#102;ers an API that is consistent wi&#116;h the rest of Qt. It is ideal for writing one-&#112;ass &#112;ars&#101;rs. DOM's main be&#110;efit i&#115; that it lets us navigate a tree repr&#101;sentation of the XML documen&#116; in any order, allowing us to implement &#109;ulti-pass parsing algorithms. Some applications eve&#110; u&#115;e the DO&#77; tree as th&#101;ir &#112;rimary data structure. SA&#88; is provided mainly for historical reasons; using <tt>QXml&#83;trea&#109;Reader</tt><a name="to simpler"></a> usua&#108;ly leads to simpler &#97;nd faster code.</p>
<p class="docText">For writ&#105;ng XML files, Qt also offers three op&#116;ions:</p>
<ul><li><p class="docList"><a name="iddle1539"></a><a name="iddle1707"></a><a name="iddle2197"></a><a name="iddle2310"></a><a name="iddle2395"></a><a name="iddle2397"></a><a name="iddle2418"></a><a name="iddle3283"></a><a name="iddle4510"></a><a name="iddle6709"></a><a name="iddle6710"></a><a name="iddle6711"></a><a name="iddle6712"></a><a name="iddle6713"></a><a name="iddle6714"></a><a name="iddle6715"></a><a name="iddle6716"></a><a name="iddle6717"></a><a name="iddle6718"></a><a name="iddle6719"></a><a name="iddle6725"></a><a name="iddle6729"></a><a name="iddle6773"></a><a name="iddle7713"></a><a name="iddle7716"></a>We can use a <tt>QXmlStreamWriter</tt>.</p></li><li><p class="docList"><a name="in memory"></a>We can repres&#101;nt the data as a DOM tree in memo&#114;y and ask the tree to write itself to a file.</p></li><li><p class="docList"><a name="We can"></a>We ca&#110; g&#101;ne&#114;ate th&#101; XM&#76; by hand.</p></li></ul>
<p class="docText">Using <tt>QXmlStreamWriter</tt><a name="far the"></a> is by f&#97;r the easiest approach, and is more reli&#97;ble than h&#97;nd-genera&#116;ing XML. Using DOM &#116;o produce XM&#76; really makes sense only if &#97; DOM tree is already used as the app&#108;ication's primary data structure. All three a&#112;proaches to reading and writing XML are shown in t&#104;is cha&#112;ter.</p>




<a name="ch16lev1sec1"></a>
<h3 class="docSection1Title" id="-100000">Reading XML with QXmlStreamReader</h3>
<p class="docText">&#85;sing <tt>QX&#109;lStreamRea&#100;er</tt><a name="the fastest"></a> is the fastest &#97;nd easiest way to read XML in Qt. Because the parser w&#111;rk&#115; increm&#101;ntally, it is p&#97;rticularly useful fo&#114; finding all occurrenc&#101;s of a given tag in an XML document, for read&#105;ng very large files that may not fit in memory, &#97;nd for populating custom data structures to reflec&#116; an XML do&#99;ument's cont&#101;nt&#115;.</p>
<p class="docText">The <tt>QXm&#108;StreamReader</tt> parser works &#105;n terms of the tokens listed in <a class="docLink" href="#ch16fig01">Figure 16.1</a>. Each time the <tt>re&#97;dNext()</tt><a name="the current"></a> fun&#99;tion is call&#101;d, the next &#116;oken is read &#97;nd becomes the current token. The cur&#114;ent token's properties depend &#111;n the token's type and are accessible u&#115;ing the getter functions listed in the table.</p>
<a name="ch16fig01"></a><p><table cellspacing="0" class="allBorders" border="1"><caption><h5 class="docTableTitle">Figure 16.1. The <tt>QXm&#108;StreamRea&#100;e&#114;</tt>'s toke&#110;s</h5></caption><colgroup align="left" span="3"><col width="125" /><col width="150" /><col width="275" /></colgroup><thead><tr><th scope="col" class="docTableCell thead" align="center" valign="top" style="background-color:#E6E6E6">&#84;oken Type</th><th scope="col" class="docTableCell thead" align="center" valign="top" style="background-color:#E6E6E6">Example</th><th scope="col" class="docTableCell thead" align="center" valign="top" style="background-color:#E6E6E6">Getter F&#117;nctions</th></tr></thead><tr><td class="docTableCell" align="left" valign="top"><tt>StartDocument</tt></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">N/A</span></td><td class="docTableCell" align="left" valign="top"><tt>isStandaloneDocument()</tt></td></tr><tr><td class="docTableCell" align="left" valign="top"><tt>EndDocu&#109;ent</tt></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">N/A</span></td><td class="docTableCell" align="left" valign="top"><tt>isSta&#110;d&#97;loneDocument()</tt></td></tr><tr><td class="docTableCell" align="left" valign="top"><tt>StartEl&#101;ment</tt></td><td class="docTableCell" align="left" valign="top"><tt>&lt;&#105;tem&gt;</tt></td><td class="docTableCell" align="left" valign="top"><tt>namespaceUri()</tt><span class="docEmphRomanAlt">,</span> <tt>name()</tt><span class="docEmphRomanAlt">,</span> <tt>at&#116;ributes()</tt><span class="docEmphRomanAlt">,</span> <tt>namespaceDeclarations()</tt></td></tr><tr><td class="docTableCell" align="left" valign="top"><tt>End&#69;lement</tt></td><td class="docTableCell" align="left" valign="top"><tt>&lt;/item&gt;</tt></td><td class="docTableCell" align="left" valign="top"><tt>namespaceUri()</tt>, <tt>name()</tt></td></tr><tr><td class="docTableCell" align="left" valign="top"><tt>Characters</tt></td><td class="docTableCell" align="left" valign="top"><tt>AT&amp;amp;T</tt></td><td class="docTableCell" align="left" valign="top"><tt>te&#120;t()</tt><span class="docEmphRomanAlt">,</span> <tt>isWhitespace()</tt><span class="docEmphRomanAlt">,</span> <tt>isCDATA()</tt></td></tr><tr><td class="docTableCell" align="left" valign="top"><tt>Comment</tt></td><td class="docTableCell" align="left" valign="top"><tt>&lt;!-- fix --&gt;</tt></td><td class="docTableCell" align="left" valign="top"><tt>text()</tt></td></tr><tr><td class="docTableCell" align="left" valign="top"><tt>&#68;TD</tt></td><td class="docTableCell" align="left" valign="top"><tt>&lt;!DOCTYPE ...&gt;</tt></td><td class="docTableCell" align="left" valign="top"><tt>&#116;ext()</tt><span class="docEmphRomanAlt">,</span> <tt>nota&#116;ionDecl&#97;rations()</tt><span class="docEmphRomanAlt">,</span> <tt>e&#110;tityDeclarations()</tt></td></tr><tr><td class="docTableCell" align="left" valign="top"><tt>Ent&#105;tyReference</tt></td><td class="docTableCell" align="left" valign="top"><tt>&amp;trade;</tt></td><td class="docTableCell" align="left" valign="top"><tt>name()</tt><span class="docEmphRomanAlt">,</span> <tt>text()</tt></td></tr><tr><td class="docTableCell" align="left" valign="top"><tt>ProcessingInstructi&#111;n</tt></td><td class="docTableCell" align="left" valign="top"><tt>&lt;?a&#108;ert?&gt;</tt></td><td class="docTableCell" align="left" valign="top"><tt>proces&#115;ingInstruction&#84;arget()</tt><span class="docEmphRomanAlt">,</span> <tt>proc&#101;ssingInstructionD&#97;ta()</tt></td></tr><tr><td class="docTableCell" align="left" valign="top"><tt>Invalid</tt></td><td class="docTableCell" align="left" valign="top"><tt>&gt;&amp;&lt;!</tt></td><td class="docTableCell" align="left" valign="top"><tt>error()</tt><span class="docEmphRomanAlt">,</span> <tt>errorString()</tt></td></tr></table></p><br />
<p class="docText">Cons&#105;der the following XML document:</p>
<div class="docText"><pre>&lt;doc&gt;
    &lt;quote&gt;Einmal ist keinmal&lt;/quote&gt;
&lt;/doc&gt;</pre></div><br />
<p class="docText"><a name="iddle2642"></a><a name="iddle3318"></a><a name="iddle3338"></a><a name="iddle6403"></a><a name="iddle6721"></a><a name="iddle6722"></a><a name="iddle6728"></a><a name="iddle7722"></a><a name="iddle8221"></a><a name="iddle8713"></a><a name="page_389"></a>If we par&#115;e this document, each <tt>readNext()</tt><a name="with extra"></a> call will produ&#99;e a new token, &#119;ith extra in&#102;orm&#97;tion avai&#108;able using getter functions:</p>
<div class="docText"><pre>StartDocument
StartElement (name() == "doc")
StartElement (name() == "quote")
Characters (text() == "Einmal ist keinmal")
EndElement (name() == "quote")
EndElement (name() == "doc")
EndDocument</pre></div><br />
<p class="docText">Aft&#101;r each <tt>readNext()</tt> call, we can test for the cu&#114;rent t&#111;ke&#110;'s type usin&#103; <tt>isStartElemen&#116;()</tt>, <tt>isCharacters()</tt>, and similar functions, or sim&#112;ly using <tt>state()</tt>.</p>
<p class="docText"><a name="use"></a>We will review an example &#116;hat shows how to use <tt>QXmlStreamReader</tt><a name="format and"></a> to par&#115;e an ad hoc XML file format and render its content&#115; in a <tt>QTr&#101;eW&#105;dget</tt><a name="of a"></a>. Th&#101; fo&#114;mat we will parse is that of a book &#105;ndex, with index entries and sub-entries. &#72;ere'&#115; the boo&#107; index file th&#97;t is displayed in the <tt>&#81;TreeWidget</tt> in <a class="docLink" href="#ch16fig02">Figure 16.2</a>:</p>
<div class="docText"><pre>&lt;?xml version="1.0"?&gt;
&lt;bookindex&gt;
    &lt;entry term="sidebearings"&gt;
        &lt;page&gt;10&lt;/page&gt;
        &lt;page&gt;34-35&lt;/page&gt;
        &lt;page&gt;307-308&lt;/page&gt;
    &lt;/entry&gt;
    &lt;entry term="subtraction"&gt;
        &lt;entry term="of pictures"&gt;
            &lt;page&gt;115&lt;/page&gt;
            &lt;page&gt;244&lt;/page&gt;
        &lt;/entry&gt;
        &lt;entry term="of vectors"&gt;
            &lt;page&gt;9&lt;/page&gt;
        &lt;/entry&gt;
    &lt;/entry&gt;
&lt;/bookindex&gt;</pre></div><br />
<a name="ch16fig02"></a><p><center>

<h5 class="docFigureTitle"><a name="XML Stream"></a>Fi&#103;ure 16.2. The XML Stream Reader appli&#99;ation</h5>

<p class="docText">
<img border="0" id="" width="302" height="258" src="images/M2cvMTdhYTdyZDBwYy9laW0vc2c4dDE5cjk0NzkzcmdkYWxhaXBjLWhyc3htL3RfbXNyZWouZXBl.jpg" alt="" /></p>



</center></p><br />
<p class="docText"><a name="the application"></a>We will begin by looking at an extract from the ap&#112;lication's <tt>main()</tt><a name="to see"></a> function, to see how the XML read&#101;r i&#115; used in &#99;ontext, and t&#104;en we w&#105;ll look at the reader's impleme&#110;tation.</p>
<div class="docText"><pre>int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    QStringList args = QApplication::arguments();
    ...
    QTreeWidget treeWidget;
    ...
    XmlStreamReader reader(&amp;treeWidget);
    for (int i = 1; i &lt; args.count(); ++i)
        reader.readFile(args[i]);
    return app.exec();
}</pre></div><br />
<p class="docText"><a name="iddle6809"></a><a name="iddle8714"></a><a name="shown in"></a>The application shown in <a class="docLink" href="#ch16fig02">Figure 16.2</a><a name="by creating"></a> begins by crea&#116;ing a <tt>QTr&#101;eW&#105;dget</tt>. It then crea&#116;es an <tt>XmlStrea&#109;Reader</tt><a name="parse each"></a>, passing it the tree w&#105;dget and asking it to parse each file sp&#101;cified on the command line.</p>
<div class="docText"><pre>class XmlStreamReader
{
public:
    XmlStreamReader(QTreeWidget *tree);

    bool readFile(const QString &amp;fileName);

private:
    void readBookindexElement();
    void readEntryElement(QTreeWidgetItem *parent);
    void readPageElement(QTreeWidgetItem *parent);
    void skipUnknownElement();

    QTreeWidget *treeWidget;
    QXmlStreamReader reader;
};</pre></div><br />
<p class="docText">The <tt>Xm&#108;StreamReader</tt><a name="constructor and"></a> class provides two public funct&#105;ons: the &#99;onstructor &#97;nd <tt>parseF&#105;le()</tt>. The c&#108;ass uses a <tt>QXmlStreamReader</tt> i&#110;stance to parse the XML file, and populates the <tt>QT&#114;eeWid&#103;et</tt><a name="is done"></a> to &#114;eflect the XML d&#97;ta that is read. Th&#101; parsing is done using recu&#114;sive descent:</p>
<ul><li><p class="docList"><tt>readBooki&#110;dexElement()</tt> parses a <tt>&lt;bookindex&gt;...&lt;/book&#105;ndex&gt;</tt> element that contains zero or more <tt>&lt;ent&#114;y&gt;</tt> elem&#101;nt&#115;.</p></li><li><p class="docList"><a name="iddle6726"></a><a name="iddle6727"></a><a name="iddle6768"></a><a name="iddle6774"></a><a name="iddle7195"></a><a name="iddle8715"></a><a name="iddle8718"></a><tt>readEn&#116;ryEleme&#110;t()</tt> parses an <tt>&lt;e&#110;try&gt;...&lt;/entry&gt;</tt> element that cont&#97;ins zero o&#114; more <tt>&lt;p&#97;ge&gt;</tt> elements and zer&#111; or more <tt>&lt;entry&gt;</tt> el&#101;ments nested to any dep&#116;h.</p></li><li><p class="docList"><tt>readPageElement()</tt> parses a <tt>&lt;page&gt;...&lt;/page&gt;</tt> &#101;lement.</p></li><li><p class="docList"><tt>skipUnknownElement()</tt> skips an unrecogn&#105;zed element.</p></li></ul>
<p class="docText">We will now look at the <tt>XmlStreamReade&#114;</tt> class'&#115; implem&#101;nt&#97;tion, begi&#110;ning with the constructor.</p>
<div class="docText"><pre>XmlStreamReader::XmlStreamReader(QTreeWidget *tree)
{
    treeWidget = tree;
}</pre></div><br />
<p class="docText"><a name="which"></a>&#84;he constructor is used only to &#101;st&#97;blish whi&#99;h <tt>QTreeWidget</tt><a name="place in"></a> t&#104;e reader s&#104;ould use. All the action take&#115; place in the <tt>readFile()</tt> function (&#99;alled from <tt>main()</tt><a name="will look"></a>), which we will look at in three parts.</p>
<div class="docText"><pre>bool XmlStreamReader::readFile(const QString &amp;fileName)
{
    QFile file(fileName);
    if (!file.open(QFile::ReadOnly | QFile::Text)) {
        std::cerr &lt;&lt; "Error: Cannot read file " &lt;&lt; qPrintable(fileName)
                  &lt;&lt; ": " &lt;&lt; qPrintable(file.errorString())
                  &lt;&lt; std::endl;
        return false;
    }
    reader.setDevice(&amp;file);</pre></div><br />
<p class="docText">The <tt>rea&#100;File()</tt><a name="it outputs"></a> function begins by trying to open t&#104;e file. &#73;f it f&#97;ils, it out&#112;uts &#97;n error message and retu&#114;ns <tt>false</tt><a name="If the"></a>. If the file is opened successful&#108;y, it is set a&#115; the <tt>QXm&#108;StreamReade&#114;</tt>'s input device.</p>
<div class="docText"><pre>    reader.readNext();
    while (!reader.atEnd()) {
        if (reader.isStartElement()) {
            if (reader.name() == "bookindex") {
                readBookindexElement();
            } else {
                reader.raiseError(QObject::tr("Not a bookindex file"));
            }
        } else {
            reader.readNext();
        }
    }</pre></div><br />
<p class="docText">T&#104;e <tt>QXmlStreamReader</tt>'s <tt>readN&#101;xt()</tt><a name="the next"></a> function reads the next token fr&#111;m the input stream. If a token is success&#102;ully read and the end of the XML file has n&#111;t b&#101;en &#114;eache&#100;, t&#104;e function enters the <tt>while</tt><a name="of the"></a> lo&#111;p. Because of the structure of the inde&#120; f&#105;les, we k&#110;ow that inside &#116;his loop there are &#106;ust three possibilities: A <tt>&lt;boo&#107;index&gt;</tt><a name="been read"></a> start tag has just been read, &#97;nother start tag has been read (in which case the file is not a bo&#111;k index), or some other token has been rea&#100;.</p>
<p class="docText"><a name="iddle1246"></a><a name="iddle2454"></a><a name="iddle2461"></a><a name="iddle5230"></a><a name="iddle5233"></a><a name="iddle6720"></a><a name="iddle6723"></a><a name="iddle6741"></a><a name="iddle6760"></a><a name="iddle8716"></a><a name="start tag"></a>I&#102; we h&#97;ve the cor&#114;ect st&#97;rt tag, we call <tt>readBookind&#101;xElement()</tt> to continue processing. Otherwise, w&#101; ca&#108;l <tt>QXmlStre&#97;mReader::raiseError()</tt> &#119;ith an error message. The n&#101;xt time <tt>atEnd()</tt> is called (&#105;n the <tt>while</tt> loop condition), it will return <tt>true</tt><a name="after an"></a>. Thi&#115; ensures that parsing stops as soon as possib&#108;e after an error has been encountered. The error can be queried l&#97;ter by cal&#108;ing <tt>error()</tt> a&#110;d <tt>&#101;rr&#111;rString()</tt> on the <tt>QFile</tt><a name="right away"></a>. An &#97;lternative would have been to return righ&#116; away whe&#110; w&#101; detect an er&#114;or in the book &#105;ndex file. Using <tt>raiseError()</tt><a name="use the"></a> is usual&#108;y more convenient, because it lets &#117;s use the same error-reporting mechanism for l&#111;w-level XML parsing errors, which are raised aut&#111;ma&#116;ically w&#104;en <tt>QXm&#108;StreamRea&#100;er</tt><a name="invalid XML"></a> runs into in&#118;alid XML, and for application-specific e&#114;rors.</p>
<div class="docText"><pre>    file.close();
    if (reader.hasError()) {
        std::cerr &lt;&lt; "Error: Failed to parse file "
                  &lt;&lt; qPrintable(fileName) &lt;&lt; ": "
                  &lt;&lt; qPrintable(reader.errorString()) &lt;&lt; std::endl;
        return false;
    } else if (file.error() != QFile::NoError) {
        std::cerr &lt;&lt; "Error: Cannot read file " &lt;&lt; qPrintable(fileName)
                  &lt;&lt; ": " &lt;&lt; qPrintable(file.errorString())
                  &lt;&lt; std::endl;
        return false;
    }
    return true;
}</pre></div><br />
<p class="docText"><a name="was a"></a>O&#110;c&#101; the pr&#111;cessing ha&#115; finished, the file is close&#100;. If there was a parser e&#114;ror or a file error, the function outputs an erro&#114; message and returns <tt>false</tt><a name="it returns"></a>; otherwise, it returns <tt>&#116;rue</tt><a name="a successful"></a> to re&#112;ort &#97; successf&#117;l parse.</p>
<div class="docText"><pre>void XmlStreamReader::readBookindexElement()
{
    reader.readNext();
    while (!reader.atEnd()) {
        if (reader.isEndElement()) {
            reader.readNext();
            break;
        }

        if (reader.isStartElement()) {
            if (reader.name() == "entry") {
                readEntryElement(treeWidget-&gt;invisibleRootItem());
            } else {
                skipUnknownElement();
            }
        } else {
            reader.readNext();
        }
    }
}</pre></div><br />
<p class="docText"><a name="iddle1251"></a><a name="iddle3289"></a><a name="iddle6764"></a><a name="iddle8717"></a>Th&#101; <tt>readBookindexElement()</tt><a name="responsible for"></a> is re&#115;ponsible for reading the main part of the file. It st&#97;rts by ski&#112;pin&#103; the current tok&#101;n (which at &#116;his point can be only a <tt>&lt;bookindex&gt;</tt> s&#116;art tag) and then loops over the in&#112;ut.</p>
<p class="docText"><a name="the"></a>If an end tag is read, it can be on&#108;y the <tt>&lt;/bookindex&gt;</tt> tag, since otherwise, <tt>QXmlStreamRea&#100;e&#114;</tt> would &#104;ave re&#112;ort&#101;d an error (<tt>Unexp&#101;ctedElementError</tt><a name="tag and"></a>). In that case, we skip the tag &#97;nd break o&#117;t of the lo&#111;p. Otherwise, &#119;e should have a t&#111;p-level index <tt>&lt;entry&gt;</tt> st&#97;rt tag. If this is the case, we call <tt>readEnt&#114;yElement()</tt> to process the entry's data; if not, we c&#97;ll <tt>skipUnknownElement()</tt>. Using <tt>skipUnknownElement()</tt> rather than &#99;alling <tt>rais&#101;Er&#114;or()</tt><a name="in the"></a> mea&#110;s &#116;hat if we extend the book i&#110;dex format in the future to include new tag&#115;, this re&#97;der will c&#111;ntinue to w&#111;rk, since it &#119;ill simply ignore the tags it does not &#114;ecognize.</p>
<p class="docText">The <tt>readEntryElement()</tt> takes a <tt>Q&#84;reeWidgetItem *</tt> argument that iden&#116;ifies a parent item. We pass <tt>QTreeWidget::invisibleRootItem()</tt><a name="items root"></a> as t&#104;e pare&#110;t &#116;o make th&#101; ne&#119; items root items. In <tt>readEntryEleme&#110;t()</tt>, we will call <tt>readEntryElement()</tt> recursively, with a d&#105;fferen&#116; parent.</p>
<div class="docText"><div class="codeSegmentsExpansionLinks">
              Code View:</div><pre class="">void XmlStreamReader::readEntryElement(QTreeWidgetItem *parent)
{
    QTreeWidgetItem *item = new QTreeWidgetItem(parent);
    item-&gt;setText(0, reader.attributes().value("term").toString());

    reader.readNext();
    while (!reader.atEnd()) {
        if (reader.isEndElement()) {
            reader.readNext();
            break;
        }

        if (reader.isStartElement()) {
            if (reader.name() == "entry") {
                readEntryElement(item);
            } else if (reader.name() == "page") {
                readPageElement(item);
            } else {
                skipUnknownElement();
            }
        } else {
            reader.readNext();
        }
    }
}

					  </pre></div><br />
<p class="docText">T&#104;e <tt>readEntryElemen&#116;()</tt> function i&#115; called whenever an <tt>&lt;entry&gt;</tt><a name="widget item"></a> star&#116; tag is encountered. We want a tree widget i&#116;em to be created for every index entry, so we &#99;reate a new <tt>QTreeWidgetItem</tt><a name="its first"></a>, and set its first column's &#116;ext to be &#116;he entry'&#115; term at&#116;ribute's &#116;ext.</p>
<p class="docText"><a name="next token"></a>Once the entry has been a&#100;ded to the tree, the next &#116;oken is r&#101;ad. &#73;f it is an end t&#97;g, we skip the tag a&#110;d break out of the loop. If a st&#97;rt tag is encountered, it will be an <tt>&lt;&#101;ntry&gt;</tt><a name="tag "></a> tag (signifying a sub-entry), a <tt>&lt;page&gt;</tt><a name="number for"></a> tag (a &#112;age number for <a name="iddle1231"></a><a name="iddle6724"></a><a name="iddle6763"></a><a name="iddle6779"></a><a name="iddle7516"></a><a name="iddle8719"></a><a name="iddle8720"></a><a name="or an"></a>this entry), or an unknown tag. If th&#101; st&#97;rt tag is a &#115;ub-entr&#121;, we &#99;all <tt>readEntryElement()</tt> recurs&#105;vely. If the tag is a <tt>&lt;page&gt;</tt> tag, we call <tt>readPageElement()</tt>.</p>
<div class="docText"><pre>void XmlStreamReader::readPageElement(QTreeWidgetItem *parent)
{
    QString page = reader.readElementText();
    if (reader.isEndElement())
        reader.readNext();

    QString allPages = parent-&gt;text(1);
    if (!allPages.isEmpty())
        allPages += ", ";
    allPages += page;
    parent-&gt;setText(1, allPages);
}</pre></div><br />
<p class="docText">The <tt>r&#101;ad&#80;a&#103;eElement()</tt> functio&#110; is called &#119;henever we get a <tt>&lt;page&gt;</tt><a name="the entry"></a> tag. It is p&#97;ssed the tree item that corresponds to the e&#110;try to which the page text belongs. We begin by rea&#100;ing the text between the <tt>&lt;page&gt;</tt> and <tt>&lt;/&#112;age&gt;</tt> &#116;ags. On su&#99;cess, the <tt>rea&#100;E&#108;ementText()</tt><a name="on the"></a> function will leave the pa&#114;ser on the <tt>&lt;/page&gt;</tt> tag, which we must skip.</p>
<p class="docText"><a name="We begin"></a>The pages are sto&#114;ed in t&#104;e tree &#119;idget item's second c&#111;lumn. We begin by &#101;xtracting the text &#116;hat is already there. If the text is not emp&#116;y, we append a comma to it, ready for the new page text. We &#116;hen append the new text and update the column's &#116;ext acco&#114;dingl&#121;.</p>
<div class="docText"><pre>void XmlStreamReader::skipUnknownElement()
{
    reader.readNext();
    while (!reader.atEnd()) {
        if (reader.isEndElement()) {
            reader.readNext();
            break;
        }

        if (reader.isStartElement()) {
            skipUnknownElement();
        } else {
            reader.readNext();
        }
    }
}</pre></div><br />
<p class="docText"><a name="until we"></a>Fi&#110;a&#108;ly, when unknown tags are encountered, we &#107;eep reading until we get the unknown ele&#109;ent's end tag, &#119;hich we also &#115;kip. This means t&#104;at we will skip &#111;ver well-formed b&#117;t unrecognized elements, and read as &#109;uch of the recognizable data as possible from the XML file.</p>
<p class="docText"><a name="as the"></a>The exa&#109;ple presented here could be used as the basis for similar XML &#114;ecurs&#105;ve desc&#101;nt &#112;ars&#101;rs. Nonetheless, sometimes implemen&#116;ing a parser like this can be tricky, if a <tt>readNe&#120;t()</tt><a name="missing or"></a> &#99;all is missi&#110;g or o&#117;t of place. Some p&#114;ogrammers address the problem b&#121; using assertions in their code. For exam&#112;le, at the beginning of <tt>readBookindexE&#108;ement()</tt>, we could add the line</p>
<div class="docText"><pre>Q_ASSERT(reader.isStartElement() &amp;&amp; reader.name() == "bookindex");</pre></div><br />
<p class="docText"><a name="iddle2198"></a><a name="iddle3204"></a><a name="iddle4059"></a><a name="iddle4490"></a><a name="iddle4580"></a><a name="iddle6015"></a><a name="iddle8380"></a><a name="iddle8496"></a><a name="iddle8659"></a><a name="iddle8710"></a>A similar assertion could b&#101; ma&#100;e &#105;n the <tt>re&#97;dEntryEl&#101;ment()</tt> and <tt>readPageEle&#109;ent()</tt> functions. For <tt>skipUnkno&#119;nElement()</tt>, we &#119;ould simply &#97;ssert that we have a &#115;tart eleme&#110;t.</p>
<p class="docText">A <tt>QXmlStreamReader</tt> can ta&#107;e input from any <tt>QIODevice</tt>, incl&#117;ding <tt>QFile</tt>, <tt>QBuffer</tt>, <tt>QProcess</tt>, and <tt>QTcpSocket</tt><a name="the data"></a>. Some inp&#117;t sources may not be able to provide the data that the pa&#114;ser ne&#101;ds &#119;hen it needs &#105;t—for ex&#97;mple, due to network latenc&#121;. It is still possible to use <tt>QXmlStreamRea&#100;e&#114;</tt><a name="under such"></a> under &#115;uch circumstances; m&#111;re informa&#116;ion on this is provided in the refere&#110;ce documentation for <tt>QXmlStreamR&#101;ader</tt><a name="heading "></a> under the heading &quot;Incr&#101;mental Parsing&quot;.</p>
<p class="docText">The <tt>QXmlStreamReader</tt><a name="used in"></a> class &#117;sed in thi&#115; applic&#97;tion is pa&#114;t of th&#101; <span class="docEmphasis">QtXml</span><a name="to the"></a> library. To link against th&#105;s library, we must add this line to the <tt>.pr&#111;</tt> fi&#108;e:</p>
<div class="docText"><pre>QT += xml</pre></div><br />
<p class="docText"><a name="will see"></a>In the nex&#116; two sections, we w&#105;ll see how t&#111; write the same application with &#68;OM and SAX.</p>

</div></div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch16.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch16lev1sec2.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>