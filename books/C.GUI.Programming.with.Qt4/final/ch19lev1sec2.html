<html>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<head>
<title>ch19lev1sec2.html</title>
<link rel="STYLESHEET" type="text/css" href="images/css1.css">
<link rel="STYLESHEET" type="text/css" href="images/css2.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch19lev1sec1.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch20.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<div style=""><div><a name="ch19lev1sec2"></a>
<h3 class="docSection1Title" id="-100000">Subclassing QStyle</h3>
<p class="docText"><a name="The"></a>&#84;he <tt>QSt&#121;le</tt><a name="introduced with"></a> &#99;lass was int&#114;oduce&#100; with Qt 2.0 to &#112;rovide a means &#111;f encapsulating an applic&#97;tion's loo&#107; and feel. C&#108;asses such as <tt>QWindow&#115;Style</tt>, <tt>QMotifStyl&#101;</tt>, and <tt>QCDEStyle</tt><a name="the look"></a> implemented t&#104;e look and feel for the platforms and d&#101;sktop environments on which Qt ran &#97;t the time. Qt 4.3 provides eight styles, in addition to &#116;he <tt>QStyl&#101;</tt> ab&#115;tract b&#97;se class a&#110;d the conve&#110;ience ba&#115;e class <tt>QCommonStyle</tt>. <a class="docLink" href="#ch19fig16">Figure 19.16</a> shows how the&#121; re&#108;ate to each &#111;ther.</p>
<a name="ch19fig16"></a><p><center>

<h5 class="docFigureTitle">F&#105;gure 19.16. Inherita&#110;ce tree for Q&#116;'s built-in styles</h5>

<p class="docText">
<img border="0" id="" width="479" height="188" src="images/NzlkOW1jM2FhMDc4L2lwdHJnZTFnMTRzOXIvMy83cC45aGZpZmcvaXMxaWNnMTY-.jpg" alt="" /></p>


</center></p><br />
<p class="docText">For Qt deve&#108;opers, the <tt>QStyle</tt><a name="and feel"></a> architecture makes it possible to &#100;evelop a custom look and feel by subclassing <tt>QSt&#121;le</tt><a name="We can"></a> &#111;r o&#110;e &#111;f t&#104;e existing styl&#101;s. We can p&#101;rform minor customizations on an ex&#105;sting s&#116;yle (e.g., <tt>QW&#105;ndowsStyle</tt>), or we &#99;an develop an e&#110;tire custom style from &#115;cratch.</p>
<p class="docText">The <tt>QStyle</tt> API consists of f&#117;nctions for drawing graphical elements (<tt>drawPr&#105;mitive()</tt>, <tt>drawControl()</tt>, <tt>drawComplexControl()</tt>, etc.) and for quer&#121;in&#103; the s&#116;yle (<tt>pixe&#108;Metrics()</tt>, <tt>st&#121;leHint()</tt>, <tt>&#104;itTest()</tt>, etc.). The <tt>QStyle</tt> &#109;ember functions typically take a <tt>QStyleOp&#116;ion</tt> obje&#99;t that holds &#98;oth general informati&#111;n about the <a name="iddle1497"></a><a name="iddle1601"></a><a name="iddle2246"></a><a name="iddle3214"></a><a name="iddle3647"></a><a name="iddle3890"></a><a name="iddle4228"></a><a name="iddle4321"></a><a name="iddle4739"></a><a name="iddle4801"></a><a name="iddle4814"></a><a name="iddle4841"></a><a name="iddle5312"></a><a name="iddle5406"></a><a name="iddle5595"></a><a name="iddle5976"></a><a name="iddle5996"></a><a name="iddle6562"></a><a name="iddle6604"></a><a name="iddle6632"></a><a name="iddle6657"></a><a name="iddle6660"></a><a name="iddle6662"></a><a name="iddle7334"></a><a name="iddle7338"></a><a name="iddle7802"></a><a name="iddle8466"></a><a name="iddle8651"></a><a name="iddle8725"></a><a name="text of"></a>wid&#103;et to be drawn (such as its pale&#116;te) and widget-specific i&#110;formation (e.g., the text of a &#98;utton). The functions also take an optional pointer to a <tt>QWidget</tt>, t&#111; ca&#116;er to sit&#117;ations wh&#101;n t&#104;e <tt>QStyleOption</tt> do&#101;sn't provide all the nec&#101;ssary information.</p>
<p class="docText">Suppose we want to cre&#97;te a <tt>MyPus&#104;Butto&#110;</tt><a name="push button"></a> class, which w&#111;uld l&#111;ok like a standard Qt push button but w&#105;thout deriving from <tt>QPushButton</tt><a name="the relationship"></a>. (This ex&#97;mple is rather contrived, but it will help us to clari&#102;y the relationship between widgets and styles.) I&#110; t&#104;e <tt>MyPu&#115;hButto&#110;</tt><a name="would set"></a> p&#97;int event handle&#114;, we would set up a <tt>QStyleOpti&#111;n</tt> (actually, a <tt>QStyleOptionButton</tt>) a&#110;d &#99;all <tt>QStyle::d&#114;awControl()</tt> as fo&#108;lows:</p>
<div class="docText"><pre>void MyPushButton::paintEvent(QPaintEvent * /* event */)
{
    QPainter painter(this);

    QStyleOptionButton option;
    option.initFrom(this);
    if (isFlat())
        option.features |= QStyleOptionButton::Flat;
    option.text = text();

    style()-&gt;drawControl(QStyle::CE_PushButton, &amp;option, &amp;painter,
                         this);
}</pre></div><br />
<p class="docText">The <tt>QStyleOpti&#111;n::initFrom()</tt><a name="the fundamental"></a> function initia&#108;izes the fundamental member variables t&#104;at represent a widget, such as <tt>rect</tt>, <tt>state</tt><a name="and"></a> (enabled, f&#111;cused, etc.), and <tt>palette</tt><a name="specific to"></a>. Member variables specif&#105;c to <tt>QSt&#121;le&#79;ptionButto&#110;</tt><a name="be initialized"></a> m&#117;st be initialized &#109;anually. In the <tt>MyPushButto&#110;</tt> example, we initialize <tt>features</tt> and <tt>te&#120;t</tt> &#97;nd let <tt>ico&#110;</tt> and <tt>&#105;conSize</tt> ta&#107;e their default values.</p>
<p class="docText">The <tt>QWid&#103;et::style()</tt><a name="style is"></a> function returns the &#97;ppropriate style for drawing the widget. The styl&#101; is normally set for the entire application &#117;sing <tt>QApp&#108;ication::se&#116;Style()</tt><a name="to override"></a>, bu&#116; it is als&#111; possible t&#111; override it fo&#114; individual widgets using <tt>QWid&#103;et::se&#116;Style()</tt>.</p>
<p class="docText"><a name="iddle1378"></a><a name="iddle1437"></a><a name="iddle1488"></a><a name="iddle2247"></a><a name="iddle2569"></a><a name="iddle4575"></a><a name="iddle5407"></a><a name="iddle5642"></a><a name="iddle5994"></a><a name="iddle6005"></a>Th&#101; <tt>drawControl()</tt> &#102;unction is re&#105;mplemented by th&#101; various <tt>QStyle</tt> subclasses to dr&#97;w <tt>QPushButton</tt> and other simple widgets. A typical implementati&#111;n might look like this:</p>
<div class="docText"><pre>void QMotifStyle::drawControl(ControlElement element,
                              const QStyleOption *option,
                              QPainter *painter,
                              const QWidget *widget) const
{
    switch (element) {
    case CE_CheckBox:
        ...
    case CE_RadioButton:
        ...
    case CE_PushButton:
        if (const QStyleOptionButton *buttonOption =
                qstyleoption_cast&lt;const QStyleOptionButton *&gt;(option)) {
           // draw push button
        }
        break;
        ...
    }
}</pre></div><br />
<p class="docText">The first parameter, <tt>eleme&#110;t</tt><a name="is"></a>, &#105;ndicat&#101;s t&#104;e type &#111;f widget to &#100;raw. If the type is <tt>&#67;E_PushButton</tt>, the style attempts to ca&#115;t the <tt>op&#116;ion</tt> para&#109;eter to <tt>QStyleOptionBu&#116;ton</tt><a name="push button"></a>. If the ca&#115;t is successful, it draws the push butto&#110; described by <tt>QStyleOpti&#111;nButton</tt>. The cast from <tt>const QStyleOptio&#110; *</tt> to <tt>const QStyleOptionButton *</tt> is pe&#114;forme&#100; u&#115;ing <tt>qst&#121;le&#111;ption_cast&lt;&#84;&gt;()</tt>, which returns a null p&#111;inter if <tt>option</tt> doesn't poin&#116; to a <tt>QSty&#108;eOptionBu&#116;ton</tt> instance.</p>
<p class="docText">Inste&#97;d of relying &#111;n the <tt>QStyleOption</tt>, a <tt>QStyle</tt> &#115;ubclass may also query the widge&#116; directly:</p>
<div class="docText"><pre>case CE_PushButton:
    if (const QPushButton *button =
            qobject_cast&lt;const QPushButton *&gt;(widget)) {
       // draw push button
    }
    break;</pre></div><br />
<p class="docText"><a name="is tied"></a>The drawback with this vers&#105;on is that the style code is tied to <tt>QPushButton</tt><a name="be used"></a> &#97;nd thus ca&#110;n&#111;t b&#101; us&#101;d to re&#110;der, say, a <tt>MyPush&#66;utton</tt><a name="the built"></a>. For this reason, the buil&#116;-in <tt>QStyl&#101;</tt><a name="subclasses use"></a> su&#98;classes use th&#101; <tt>QStyleOpti&#111;n</tt><a name="possible to"></a> parameter whenever possi&#98;le to obtain information abou&#116; the widget to draw, and resort to using the <tt>Q&#87;idget</tt><a name="only if"></a> parameter only if that is the only thing that will pro&#118;ide the req&#117;ired info&#114;matio&#110;.</p>
<p class="docText"><a name="code for"></a>I&#110; the rest &#111;f this section, we wi&#108;l review the code for the Bron&#122;e st&#121;le &#115;hown in <a class="docLink" href="#ch19fig17">Figure 19.17</a><a name="buttons with"></a>. The Bro&#110;ze st&#121;le features round buttons wit&#104; a gradient background, unconventional placement &#111;f spin box buttons, extravagant &#99;heckmarks, and a &quot;brushed bronze&quot; background. To impleme&#110;t &#116;his, it us&#101;s a&#100;v&#97;nced 2D graphic&#115; features such as anti&#97;liasing, semi-transparency, li&#110;e&#97;r gradien&#116;s, and composi&#116;ion modes.</p>

<p class="docText"></p><a name="ch19fig17"></a><p><center>

<h5 class="docFigureTitle">Figure 19.17. &#87;idgets in the Bronze style</h5>

<p class="docText">
<img border="0" id="" width="432" height="126" src="images/NzlkOW1jM2FhMDc4L2lwdHJnZTFnMTRzOXIvMy83dHBwcHJodW91c2gvYmlzbmN6YnRvZS4tZ25q.jpg" alt="" /></p>



</center></p><br />
<p class="docText"><a name="iddle1379"></a><a name="iddle6658"></a><a name="iddle7873"></a>&#72;ere is the <tt>BronzeStyle</tt> &#99;lass definition:</p>
<div class="docText"><div class="codeSegmentsExpansionLinks">
              Code View:</div><pre class="">class BronzeStyle : public QWindowsStyle
{
    Q_OBJECT

public:
    BronzeStyle() {}

    void polish(QPalette &amp;palette);
    void polish(QWidget *widget);
    void unpolish(QWidget *widget);
    int styleHint(StyleHint which, const QStyleOption *option,
                  const QWidget *widget = 0,
                  QStyleHintReturn *returnData = 0) const;
    int pixelMetric(PixelMetric which, const QStyleOption *option,
                    const QWidget *widget = 0) const;
    void drawPrimitive(PrimitiveElement which,
                       const QStyleOption *option, QPainter *painter,
                       const QWidget *widget = 0) const;
    void drawComplexControl(ComplexControl which,
                            const QStyleOptionComplex *option,
                            QPainter *painter,
                            const QWidget *widget = 0) const;
    QRect subControlRect(ComplexControl whichControl,
                         const QStyleOptionComplex *option,
                         SubControl whichSubControl,
                         const QWidget *widget = 0) const;
public slots:
    QIcon standardIconImplementation(StandardPixmap which,
                                     const QStyleOption *option,
                                     const QWidget *widget = 0) const;
private:
    void drawBronzeFrame(const QStyleOption *option,
                         QPainter *painter) const;
    void drawBronzeBevel(const QStyleOption *option,
                         QPainter *painter) const;
    void drawBronzeCheckBoxIndicator(const QStyleOption *option,
                                     QPainter *painter) const;
    void drawBronzeSpinBoxButton(SubControl which,
                                 const QStyleOptionComplex *option,
                                 QPainter *painter) const;
};

					  </pre></div><br />
<p class="docText"><a name="iddle1319"></a><a name="iddle1388"></a><a name="iddle4246"></a><a name="iddle4376"></a><a name="iddle4378"></a><a name="iddle4842"></a><a name="iddle5313"></a><a name="iddle5579"></a><a name="iddle5981"></a><a name="iddle5983"></a><a name="iddle5984"></a><a name="iddle5989"></a><a name="iddle7698"></a><a name="iddle7700"></a><a name="iddle8314"></a><a name="an existing"></a>When creating a custom style, we usually ba&#115;e it on an existing style so that we do&#110;'t &#104;ave to &#100;o &#101;ve&#114;ything from &#115;cratch. For this e&#120;ample, we chose <tt>QWindows&#83;tyle</tt><a name="style doesn"></a>, &#116;he class&#105;c Windows style. Even &#116;hough the Br&#111;nze style do&#101;sn't look much like the Windows &#115;tyle, there is a large body of c&#111;de in <tt>QWindowsStyle</tt> and its base class <tt>QCommo&#110;S&#116;yle</tt><a name="any style"></a> that &#99;an be reused &#97;s is to imp&#108;ement just about any s&#116;yle we can imagine. This i&#115; why <tt>QMacStyle</tt> is derived from <tt>QWindowsStyle</tt><a name="look very"></a> &#101;ve&#110; t&#104;ough they loo&#107; very differe&#110;t.</p>
<p class="docText"><tt>BronzeStyle</tt><a name="public functions"></a> reimpl&#101;ments several public functions decla&#114;ed by <tt>QStyle</tt><a name="The"></a>. The <tt>polish()</tt> and <tt>unpoli&#115;h()</tt><a name="called when"></a> functions are called when the style is installed o&#114; unins&#116;alled. Th&#101;y m&#97;ke it poss&#105;ble to tweak the widg&#101;ts or the pale&#116;te. The other public functions are either &#113;uery &#102;unc&#116;ions (<tt>styleHint()</tt>, <tt>pixe&#108;Metric()</tt>, <tt>subControlRe&#99;t()</tt><a name="functions that"></a>) or functions that draw a graphica&#108; element (<tt>drawPrimitive()</tt>, <tt>drawComplexControl()</tt>).</p>
<p class="docText"><tt>BronzeSt&#121;le</tt> also provides a public slot called <tt>standar&#100;IconImplementation()</tt><a name="is invoked"></a>. This slot is discovered b&#121; Qt &#117;sing intr&#111;sp&#101;ct&#105;on and is invoke&#100; when necess&#97;ry as though it had been a virtual function. Qt &#115;ometim&#101;s u&#115;es this idiom to &#97;dd functions &#116;hat should have been virtual without br&#101;aking binary compatibility with earlier &#81;t 4 releases. It is expected t&#104;at Qt 5 will replace the <tt>standardIconImplement&#97;tion()</tt> slot &#119;ith a <tt>standa&#114;dIcon()</tt> &#118;irtual fun&#99;tion.</p>
<p class="docText">The <tt>Bronz&#101;Style</tt><a name="private functions"></a> class also de&#99;lares a few private functions. These will b&#101; ex&#112;lai&#110;ed a&#102;ter we have cover&#101;d the public functions.</p>
<div class="docText"><pre>void BronzeStyle::polish(QPalette &amp;palette)
{
    QPixmap backgroundImage(":/images/background.png");
    QColor bronze(207, 155, 95);
    QColor veryLightBlue(239, 239, 247);
    QColor lightBlue(223, 223, 239);
    QColor darkBlue(95, 95, 191);

    palette = QPalette(bronze);
    palette.setBrush(QPalette::Window, backgroundImage);
    palette.setBrush(QPalette::BrightText, Qt::white);
    palette.setBrush(QPalette::Base, veryLightBlue);
    palette.setBrush(QPalette::AlternateBase, lightBlue);
    palette.setBrush(QPalette::Highlight, darkBlue);
    palette.setBrush(QPalette::Disabled, QPalette::Highlight,
                     Qt::darkGray);
}</pre></div><br />
<p class="docText"><a name="is its"></a>One &#111;f the outstanding characteri&#115;tics of the Bronze style is its color scheme. N&#111; matter what colors the user has set on their window syste&#109;, the Bronze s&#116;yle has a &#98;ronze appe&#97;rance. A cu&#115;tom style's color sc&#104;eme can be se&#116; up in one of two ways: We can ignore the widg&#101;t's <tt>&#81;Pa&#108;ette</tt><a name="light bronze"></a> and draw everyth&#105;ng using our f&#97;vorite colors (bronze, light bronze, da&#114;k bronze, etc.), or we can reimplement <tt>QStyle::&#112;olish(QPalette &amp;)</tt><a name="second approach"></a> to adjust the application's or widge&#116;'s palette and then use the palette. The second &#97;pproach i&#115; more fl&#101;xi&#98;le because &#119;e can <a name="iddle1389"></a><a name="iddle1391"></a><a name="iddle1393"></a><a name="iddle2512"></a><a name="iddle2738"></a><a name="iddle3069"></a><a name="iddle4377"></a><a name="iddle4379"></a><a name="iddle5982"></a><a name="iddle5987"></a><a name="iddle5990"></a><a name="iddle6088"></a><a name="iddle7803"></a><a name="iddle8313"></a><a name="iddle8315"></a><a name="iddle8502"></a><a name="scheme in"></a>override &#116;he color scheme in a &#115;ubclass (say, <tt>SilverStyle</tt>) by reimpleme&#110;t&#105;ng <tt>poli&#115;h()</tt>.</p>
<p class="docText"><a name="of polishing"></a>The conc&#101;pt of p&#111;lishing is generalized to w&#105;dgets. When a style is applied t&#111; a widget, <tt>polish(QWidget *)</tt><a name="is called"></a> is called, allowing us t&#111; perform last-minute customizations:</p>
<div class="docText"><pre>void BronzeStyle::polish(QWidget *widget)
{
    if (qobject_cast&lt;QAbstractButton *&gt;(widget)
            || qobject_cast&lt;QAbstractSpinBox *&gt;(widget))
        widget-&gt;setAttribute(Qt::WA_Hover, true);
}</pre></div><br />
<p class="docText">Here, we reimpleme&#110;t <tt>&#112;oli&#115;h(QWidg&#101;t *)</tt><a name="the"></a> t&#111; set the <tt>Qt::WA_&#72;over</tt><a name="on buttons"></a> attribute on butt&#111;ns and spin boxes. When this attri&#98;ute is set, a &#112;ain&#116; event is gener&#97;ted when the mous&#101; enters or leaves the area o&#99;cupied by a widget. This gives us the opportunit&#121; to paint a widget different&#108;y depending on whether or not the mouse is hove&#114;ing ov&#101;r i&#116;.</p>
<p class="docText"><a name="created and"></a>This fun&#99;tion is call&#101;d after &#116;he widget has been created and b&#101;fore it is shown for the first tim&#101;, us&#105;ng the c&#117;rrent style. It is then &#111;nly ev&#101;r called if the current s&#116;yle is dynamically changed.</p>
<div class="docText"><pre>void BronzeStyle::unpolish(QWidget *widget)
{
    if (qobject_cast&lt;QAbstractButton *&gt;(widget)
            || qobject_cast&lt;QAbstractSpinBox *&gt;(widget))
        widget-&gt;setAttribute(Qt::WA_Hover, false);
}</pre></div><br />
<p class="docText">Just as <tt>pol&#105;sh(QWidget *)</tt><a name="is applied"></a> is called when a style is applied to a widget, <tt>un&#112;olish(QWidget *)</tt><a name="of"></a> is called whenever the style is dy&#110;a&#109;ically chan&#103;ed. Th&#101; pu&#114;pose of <tt>unp&#111;lish()</tt> is to und&#111; the effects of the <tt>poli&#115;h()</tt><a name="state to"></a> so tha&#116; the widg&#101;t is in a sta&#116;e to be polished by th&#101; new style. Well-behaved styles t&#114;y to undo what they did in their <tt>poli&#115;h()</tt> function.</p>
<p class="docText">A common use of <tt>polish(QWidget *)</tt><a name="on a"></a> is to instal&#108; our style subclass as an event filter on a widget. This is necess&#97;ry for som&#101; mo&#114;e adva&#110;c&#101;d customizat&#105;ons; for example, <tt>QWindow&#115;VistaStyle</tt> and <tt>QMacStyle</tt><a name="to animate"></a> use this tech&#110;i&#113;ue to &#97;nimate defaul&#116; buttons.</p>
<div class="docText"><pre>int BronzeStyle::styleHint(StyleHint which, const QStyleOption *option,
                           const QWidget *widget,
                           QStyleHintReturn *returnData) const
{
    switch (which) {
    case SH_DialogButtonLayout:
        return int(QDialogButtonBox::MacLayout);
    case SH_EtchDisabledText:
        return int(true);
    case SH_DialogButtonBox_ButtonsHaveIcons:
        return int(true);
    case SH_UnderlineShortcut:
        return int(false);
    default:
        return QWindowsStyle::styleHint(which, option, widget,
                                        returnData);
    }
}</pre></div><br />
<p class="docText"><a name="iddle1387"></a><a name="iddle1390"></a><a name="iddle1423"></a><a name="iddle1546"></a><a name="iddle4311"></a><a name="iddle4811"></a><a name="iddle4946"></a><a name="iddle5980"></a><a name="iddle5985"></a><a name="iddle5992"></a><a name="iddle7699"></a><a name="iddle7701"></a>The <tt>sty&#108;eHint()</tt><a name="some hints"></a> function returns some hi&#110;ts about the look and feel provi&#100;ed by the style. Fo&#114; example, we return <tt>MacLayout</tt><a name="for"></a> for <tt>SH_DialogButtonLayout</tt><a name="that we"></a> to si&#103;nify &#116;hat we wa&#110;t <tt>&#81;Di&#97;logButtonB&#111;x</tt><a name="follow the"></a> to follow the Mac &#79;S X guidelines, with <span class="docEmphRomanAlt">OK</span> to the right of <span class="docEmphRomanAlt">C&#97;ncel</span>. The r&#101;tu&#114;n type of <tt>s&#116;yleHint()</tt> is <tt>int</tt><a name="as integers"></a>. Fo&#114; the few style hints that cannot b&#101; represented as intege&#114;s, <tt>styleHint()</tt> provides a pointer to &#97; <tt>QStyleHintReturn</tt> object that can be used.</p>
<div class="docText"><pre>int BronzeStyle::pixelMetric(PixelMetric which,
                             const QStyleOption *option,
                             const QWidget *widget) const
{
    switch (which) {
    case PM_ButtonDefaultIndicator:
        return 0;
    case PM_IndicatorWidth:
    case PM_IndicatorHeight:
        return 16;
    case PM_CheckBoxLabelSpacing:
        return 8;
    case PM_DefaultFrameWidth:
        return 2;
    default:
        return QWindowsStyle::pixelMetric(which, option, widget);
    }
}</pre></div><br />
<p class="docText">The <tt>pixe&#108;Metric()</tt><a name="pixels that"></a> fun&#99;tion return&#115; a dimen&#115;ion in p&#105;xels that is used f&#111;r a user interface &#101;lement. By reimplementing this function, we affe&#99;t both the dr&#97;wing of th&#101; built-in Qt &#119;idgets and their si&#122;e hints.</p>
<p class="docText">We return 0 for <tt>P&#77;_ButtonDefaultIndicator</tt><a name="default buttons"></a> beca&#117;se we don't want to reserve any extra spacing around default butto&#110;s (the default is 1 pixel in <tt>QWindowsStyle</tt>). Fo&#114; check&#98;oxes, <tt>PM_Ind&#105;catorW&#105;dth</tt> and <tt>&#80;M_Indic&#97;torHeight</tt><a name="small square"></a> control the size o&#102; the indicator (usually a small sq&#117;are), and <tt>PM_&#67;heckBoxL&#97;belSpacing</tt><a name="to its"></a> &#99;ontrols the spacing &#98;etween the checkbox indicator and &#116;he text to its right (see <a class="docLink" href="#ch19fig18">Figure 19.18</a>). Finally, <tt>P&#77;_DefaultFrameWidth</tt><a name="of the"></a> defines the widt&#104; of the line used around <tt>QFrame</tt>, <tt>QPushButton</tt>, <tt>QSpi&#110;B&#111;x</tt><a name="other widgets"></a>, a&#110;d &#109;any other wi&#100;gets. &#70;or other <tt>PM_</tt><span class="docEmphasis"><tt>&#120;xx</tt></span><a name="we inherit"></a> values, we inherit the pixe&#108; metric val&#117;e from the &#98;ase class.</p>
<a name="ch19fig18"></a><p><center>

<h5 class="docFigureTitle"><a name="of a"></a>Figure 19.18. St&#114;ucture of &#97; <tt>QCheckBox</tt></h5>
<p class="docText"><div class="st1"><a target="_blank" href="images/NzlkOW1jM2FhMDc4L2lwdHJnZTFnMTRzOXIvMy83aXBfOWhnZnQvYWwxc2NpaWcuZjE4.jpg">[View full size image]</a></div><img border="0" id="" width="500" height="183" src="images/NzlkOW1jM2FhMDc4L2lwdHJnZTFnMTRzOXIvMy83cC45aGZpZmcvaXMxaWNnMTg-.jpg" alt="" /></p>
</center></p><br />
<div class="docText"><pre>QIcon BronzeStyle::standardIconImplementation(StandardPixmap which,
        const QStyleOption *option, const QWidget *widget) const
{
    QImage image = QWindowsStyle::standardPixmap(which, option, widget)
                   .toImage();
    if (image.isNull())
        return QIcon();
    QPalette palette;
    if (option) {
        palette = option-&gt;palette;
    } else if (widget) {
        palette = widget-&gt;palette();
    }
    QPainter painter(&amp;image);
    painter.setOpacity(0.25);
    painter.setCompositionMode(QPainter::CompositionMode_SourceAtop);
    painter.fillRect(image.rect(), palette.highlight());
    painter.end();

    return QIcon(QPixmap::fromImage(image));
}</pre></div><br />
<p class="docText"><a name="iddle1386"></a><a name="iddle1727"></a><a name="iddle2275"></a><a name="iddle2277"></a><a name="iddle5192"></a><a name="iddle5500"></a><a name="iddle5978"></a><a name="iddle5986"></a><a name="iddle7092"></a><a name="iddle7583"></a><a name="iddle7703"></a><a name="iddle8209"></a><a name="explained earlier"></a>As explaine&#100; earlier, Qt invokes the <tt>sta&#110;dardIconImplementation()</tt><a name="used in"></a> slot to obtain &#116;he standard icons that should be used in user interf&#97;ces. We cal&#108; the base cl&#97;ss's <tt>stand&#97;rdPixmap()</tt><a name="try to"></a> &#116;o obtain the icon a&#110;d try to give it &#97; slight blue tint, to make it blend in w&#105;th the r&#101;st &#111;f the styl&#101;. The ti&#110;ting is achieved by drawing a 25% &#111;paque blue color on top of the exi&#115;ting icon. By using the <tt>SourceAtop</tt><a name="stay transparent"></a> compo&#115;ition mode, we make sure that the existing transparent &#97;reas stay &#116;ranspar&#101;nt, &#105;nstead &#111;f beco&#109;ing 25% blue and 75% transparent. &#87;e describe composition modes in the &quot;<a class="docLink" href="ch08lev1sec3.html#ch08lev1sec3">High-Quality Rendering with QImage</a>&quot; s&#101;ct&#105;on of <a class="docLink" href="ch08.html#ch08">Chapter 8</a> (p. <a class="docLink" href="ch08lev1sec3.html#ch08fig13">195</a>).</p>
<div class="docText"><pre>void BronzeStyle::drawPrimitive(PrimitiveElement which,
                                const QStyleOption *option,
                                QPainter *painter,
                                const QWidget *widget) const
{
    switch (which) {
    case PE_IndicatorCheckBox:
        drawBronzeCheckBoxIndicator(option, painter);
        break;
    case PE_PanelButtonCommand:
        drawBronzeBevel(option, painter);
        break;
    case PE_Frame:
        drawBronzeFrame(option, painter);
        break;
    case PE_FrameDefaultButton:
        break;
    default:
        QWindowsStyle::drawPrimitive(which, option, painter, widget);
    }
}</pre></div><br />
<p class="docText"><a name="iddle1385"></a><a name="iddle2245"></a><a name="iddle4576"></a><a name="iddle5643"></a><a name="iddle5975"></a>Q&#116; calls the <tt>dr&#97;wPrimitive()</tt><a name="are typically"></a> function &#116;o draw &quot;primitive&quot; user interface &#101;lements. These elements are typically us&#101;d by several widgets. For example, <tt>PE_IndicatorCheck&#66;ox</tt> is used by <tt>QCheckBox</tt>, <tt>QGroupBox</tt>, and <tt>Q&#73;temD&#101;le&#103;ate</tt> t&#111; dr&#97;w a checkbox i&#110;dicator.</p>
<p class="docText">In t&#104;e Bronze style, we reimplement <tt>&#100;r&#97;wPrimiti&#118;e()</tt> to provide a c&#117;stom look to checkb&#111;x indicators, push &#98;uttons, and frames. For exa&#109;ple, <a class="docLink" href="#ch19fig19">Figure 19.19</a> shows the structure of a <tt>QPushButton</tt> which &#116;he Bronze style must handle. The <tt>drawBronzeCheck&#66;oxIndic&#97;tor()</tt>, <tt>drawB&#114;onzeB&#101;ve&#108;()</tt>, and <tt>drawBronz&#101;Frame()</tt> functions &#97;re private functions that we will r&#101;vi&#101;w l&#97;ter.</p>
<a name="ch19fig19"></a><p><center>

<h5 class="docFigureTitle">Figure 19.19. St&#114;ucture of &#97; <tt>QPushButton</tt></h5>
<p class="docText"><div class="st1"><a target="_blank" href="images/NzlkOW1jM2FhMDc4L2lwdHJnZTFnMTRzOXIvMy83aXBfOWhnZnQvYWwxc2NpaWcuZjE5.jpg">[View full size image]</a></div><img border="0" id="" width="500" height="98" src="images/NzlkOW1jM2FhMDc4L2lwdHJnZTFnMTRzOXIvMy83cC45aGZpZmcvaXMxaWNnMTk-.jpg" alt="" /></p>
</center></p><br />
<p class="docText">For <tt>PE_FrameDefaul&#116;Button</tt><a name="frame around"></a>, we simply do nothing, because we d&#111;n't want to draw an extra frame ar&#111;und default buttons. For all other p&#114;imiti&#118;e elements, &#119;e simply for&#119;ard the call &#116;o the base cl&#97;ss.</p>
<div class="docText"><pre>void BronzeStyle::drawComplexControl(ComplexControl which,
                                     const QStyleOptionComplex *option,
                                     QPainter *painter,
                                     const QWidget *widget) const
{
    if (which == CC_SpinBox) {
        drawBronzeSpinBoxButton(SC_SpinBoxDown, option, painter);
        drawBronzeSpinBoxButton(SC_SpinBoxUp, option, painter);

        QRect rect = subControlRect(CC_SpinBox, option,
                                    SC_SpinBoxEditField)
                     .adjusted(-1, 0, +1, 0);
        painter-&gt;setPen(QPen(option-&gt;palette.mid(), 1.0));
        painter-&gt;drawLine(rect.topLeft(), rect.bottomLeft());
        painter-&gt;drawLine(rect.topRight(), rect.bottomRight());
    } else {
        return QWindowsStyle::drawComplexControl(which, option, painter,
                                                 widget);
    }
}</pre></div><br />
<p class="docText"><a name="iddle1392"></a><a name="iddle5265"></a><a name="iddle5786"></a><a name="iddle5988"></a><a name="iddle7614"></a><a name="iddle7815"></a>Qt calls the <tt>drawComplexCon&#116;rol()</tt><a name="widgets that"></a> function to draw widgets that consist of mu&#108;tiple subc&#111;nt&#114;ols—notably <tt>QSp&#105;nBox</tt><a name="want to"></a>. Sinc&#101; we want to give a radically new look &#116;o <tt>QSpinBox</tt><a name="we reimplement"></a>, we reimplement <tt>&#100;rawComplexControl()</tt><a name="the"></a> and handle the <tt>CC_SpinBox</tt> c&#97;se.</p>
<p class="docText"><a name="draw a"></a>To draw a <tt>QSpinBox</tt><a name="the frame"></a> we must draw the up and down buttons and &#116;he frame &#97;round the &#101;nt&#105;re spin &#98;ox. (The structure of a <tt>QSp&#105;nBox</tt> is shown in <a class="docLink" href="#ch19fig20">Figure 19.20</a><a name="drawing an"></a>.) Since &#116;he code required for drawing an up &#98;utton is al&#109;ost identic&#97;l to that for d&#114;awing a down butt&#111;n, we have factored it out in&#116;o the <tt>drawBronzeSpinBoxButton()</tt><a name="entire spin"></a> private &#102;unction. The function also draws the frame around the &#101;ntire spin box.</p>
<a name="ch19fig20"></a><p><center>

<h5 class="docFigureTitle">Figure 19.20. Structure of a <tt>QSpinBox</tt></h5>
<p class="docText"><div class="st1"><a target="_blank" href="images/NzlkOW1jM2FhMDc4L2lwdHJnZTFnMTRzOXIvMy83aXBfOWhnZnQvYWwxc2NpaWcuZjIw.jpg">[View full size image]</a></div><img border="0" id="" width="500" height="128" src="images/NzlkOW1jM2FhMDc4L2lwdHJnZTFnMTRzOXIvMy83cC45aGZpZmcvaXMxaWNnMjA-.jpg" alt="" /></p>
</center></p><br />
<p class="docText"><tt>QS&#112;inB&#111;x</tt> u&#115;es a <tt>QLi&#110;e&#69;dit</tt><a name="so we"></a> to represent the &#101;ditable part of the wi&#100;get, so we don't &#110;e&#101;d t&#111; draw that par&#116; of the widg&#101;t. However, to cleanly separate &#116;he <tt>QLineEdit</tt><a name="lines at"></a> and the spin box buttons, we d&#114;aw two light brown vertical lines at the edg&#101; of the <tt>QLineEdit</tt>. The <tt>QLineEdit</tt><a name="by calling"></a>'s geometry is &#111;bt&#97;ined by ca&#108;ling <tt>subCo&#110;t&#114;olRect()</tt> with <tt>SC_S&#112;inBoxEdi&#116;Field</tt><a name="third argument"></a> as the third argument.</p>
<div class="docText"><div class="codeSegmentsExpansionLinks">
              Code View:</div><pre class="">QRect BronzeStyle::subControlRect(ComplexControl whichControl,
                                  const QStyleOptionComplex *option,
                                  SubControl whichSubControl,
                                  const QWidget *widget) const
{
    if (whichControl == CC_SpinBox) {
        int frameWidth = pixelMetric(PM_DefaultFrameWidth, option,
                                     widget);

        int buttonWidth = 16;

        switch (whichSubControl) {
        case SC_SpinBoxFrame:
            return option-&gt;rect;
        case SC_SpinBoxEditField:
            return option-&gt;rect.adjusted(+buttonWidth, +frameWidth,
                                         -buttonWidth, -frameWidth);
        case SC_SpinBoxDown:
            return visualRect(option-&gt;direction, option-&gt;rect,
                              QRect(option-&gt;rect.x(), option-&gt;rect.y(),
                                    buttonWidth,
                                    option-&gt;rect.height()));
        case SC_SpinBoxUp:
            return visualRect(option-&gt;direction, option-&gt;rect,
                              QRect(option-&gt;rect.right() - buttonWidth,
                                    option-&gt;rect.y(),
                                    buttonWidth,
                                    option-&gt;rect.height()));
        default:
            return QRect();
        }
    } else {
        return QWindowsStyle::subControlRect(whichControl, option,
                                             whichSubControl, widget);
    }
}

					  </pre></div><br />
<p class="docText"><a name="iddle1198"></a><a name="iddle1383"></a><a name="iddle2242"></a><a name="iddle3015"></a><a name="iddle3509"></a><a name="iddle5040"></a><a name="iddle5991"></a><a name="iddle6940"></a><a name="iddle6941"></a><a name="iddle6958"></a><a name="iddle8473"></a><a name="Qt calls"></a>Qt calls the <tt>su&#98;ControlRe&#99;t()</tt><a name="determine where"></a> function t&#111; determine w&#104;ere the su&#98;controls of a widget a&#114;e located. For example, <tt>QSpinBox</tt><a name="it to"></a> c&#97;lls it to determine where to place it&#115; <tt>QLineEdit</tt><a name="find out"></a>. It is also used when reacting to mous&#101; ev&#101;nt&#115;, to find &#111;ut &#119;hich subcontrol was c&#108;icked. In addition, we ca&#108;led it ourselves when implementing <tt>d&#114;awCom&#112;lex&#67;ontrol()</tt><a name="again from"></a>, and w&#101; will call it ag&#97;in from <tt>drawBronzeSpinBoxB&#117;tton()</tt>.</p>
<p class="docText"><a name="spin box"></a>In our reimplementation, we ch&#101;ck whether the widget is a spin box, and if this i&#115; the case, we return meaningful rectangles for the spin b&#111;x's &#102;ram&#101;, ed&#105;t field, &#100;own button, and &#117;p button. <a class="docLink" href="#ch19fig20">Figure 19.20</a><a name="For the"></a> shows how these recta&#110;gles relate to each other. For the othe&#114; widge&#116;s, includ&#105;ng <tt>QPushButto&#110;</tt>, we re&#108;y on the base class's implementation.</p>
<p class="docText">Th&#101; rectangles we return for <tt>SC_SpinBoxD&#111;wn</tt> and <tt>SC_SpinBoxUp</tt> are passed through <tt>&#81;Style::visualRect()</tt>. Calls to <tt>visualRect()</tt> have the foll&#111;wi&#110;g &#115;yntax:</p>
<div class="docText"><pre>visualRect(<span class="docEmphasis">direction</span>, <span class="docEmphasis">outerRect</span>, <span class="docEmphasis">logicalRect</span>)</pre></div><br />
<p class="docText">I&#102; the <span class="docEmphasis"><tt>&#100;irectio&#110;</tt></span> is <tt>Qt::LeftToRigh&#116;</tt>, then <span class="docEmphasis"><tt>logicalRect</tt></span> is returned u&#110;c&#104;anged; &#111;therw&#105;se, <span class="docEmphasis"><tt>logicalRect</tt></span> is fl&#105;pped with respect to <span class="docEmphasis"><tt>outerRect</tt></span><a name="used for"></a>. &#84;his ensures that graphical elements are mir&#114;ored in right-to-left mode, which is used for la&#110;guages such as Arabic and Hebrew. For s&#121;mm&#101;tr&#105;c eleme&#110;t&#115; such as <tt>SC_Spi&#110;BoxFrame</tt> an&#100; <tt>SC_SpinBoxEditField</tt><a name="no effect"></a>, flipping w&#111;ul&#100; h&#97;ve no effect, so we don't b&#111;ther c&#97;lling <tt>visualRect()</tt><a name="a style"></a>. To test a style in right-t&#111;-left mode, we can simply pass &#116;he <tt>-reverse</tt><a name="option to"></a> command-line option to an application &#116;hat uses the style. <a class="docLink" href="#ch19fig21">Figure 19.21</a><a name="Bronze style"></a> shows the Bronze style &#105;n right-&#116;o-left mo&#100;e.</p>
<a name="ch19fig21"></a><p><center>

<h5 class="docFigureTitle"><a name="The Bronze"></a>&#70;i&#103;ure 19.21. The Bron&#122;e style in right-&#116;o-left mode</h5>

<p class="docText">
<img border="0" id="" width="371" height="321" src="images/NzlkOW1jM2FhMDc4L2lwdHJnZTFnMTRzOXIvMy83ZXBycmhzb2VlL3ZzYmljbnpyLmplZ3At.jpg" alt="" /></p>



</center></p><br />
<p class="docText"><a name="from"></a>This completes our revi&#101;w o&#102; the &#112;ublic funct&#105;ons reimplemented f&#114;om <tt>QWindowsStyle</tt><a name="private drawing"></a>. &#84;he next four functions are private drawing func&#116;ions.</p>
<div class="docText"><pre>void BronzeStyle::drawBronzeFrame(const QStyleOption *option,
                                  QPainter *painter) const
{
    painter-&gt;save();
    painter-&gt;setRenderHint(QPainter::Antialiasing, true);
    painter-&gt;setPen(QPen(option-&gt;palette.foreground(), 1.0));
    painter-&gt;drawRect(option-&gt;rect.adjusted(+1, +1, -1, -1));
    painter-&gt;restore();
}</pre></div><br />
<p class="docText"><a name="iddle1174"></a><a name="iddle1381"></a><a name="iddle2240"></a><a name="iddle5041"></a><a name="iddle5549"></a><a name="iddle5554"></a><a name="iddle5564"></a><a name="iddle5644"></a><a name="iddle6920"></a><a name="iddle7011"></a><a name="iddle7305"></a><a name="iddle7809"></a>The <tt>drawBronzeFrame()</tt> function was c&#97;lled from <tt>drawPrimitive()</tt> to draw a <tt>PE_Frame</tt><a name="a"></a> primitive element. &#84;his is &#117;sed to dra&#119; the frame ar&#111;un&#100; a <tt>QFr&#97;me</tt> (or a subclass, such as <tt>QTr&#101;eView</tt>) when the frame shape is <tt>QFr&#97;me::Styled&#80;a&#110;el</tt>. (The other f&#114;ame shapes, such a&#115; <tt>Box</tt>, <tt>Panel</tt>, and <tt>VLine</tt>, are &#100;rawn directly by <tt>QFrame</tt> without going thro&#117;gh the style.)</p>
<p class="docText"><a name="outline around"></a>The frame we draw is an antialiased 1-p&#105;xel-wide outline around the widget, using the palette's fo&#114;egrou&#110;d &#98;rush (avail&#97;ble throu&#103;h the <tt>QSt&#121;leOption</tt>'s <tt>palette</tt><a name="an integer"></a> membe&#114; variable). Since the rectangle is antialiase&#100; a&#110;d &#105;s located o&#110; an i&#110;teger coordinate, th&#101; resulting effect is a blur&#114;ed 2-pixel-wide outline, which is precisely what w&#101; want for the Bronze style.</p>
<p class="docText"><a name="we leave"></a>To ensu&#114;e that &#119;e leave the <tt>Q&#80;a&#105;nter</tt><a name="same state"></a> in &#116;he same state as we &#103;ot it, we call <tt>save()</tt><a name="before we"></a> befo&#114;e we call <tt>setRenderHint()</tt> and <tt>setPen()</tt>, a&#110;d &#99;all <tt>restore()</tt><a name="This is"></a> &#97;t the end. This is n&#101;cessary be&#99;ause Qt optimizes drawing by reusing the s&#97;me <tt>QPainter</tt><a name="draw several"></a> to draw several graph&#105;cal elements.</p>
<p class="docText">The next function we will study is <tt>d&#114;awBronzeBevel()</tt>, which draws the background of a <tt>QPushBut&#116;on</tt>:</p>
<div class="docText"><pre>void BronzeStyle::drawBronzeBevel(const QStyleOption *option,
                                  QPainter *painter) const
{
    QColor buttonColor = option-&gt;palette.button().color();
    int coeff = (option-&gt;state &amp; State_MouseOver) ? 115 : 105;

    QLinearGradient gradient(0, 0, 0, option-&gt;rect.height());
    gradient.setColorAt(0.0, option-&gt;palette.light().color());
    gradient.setColorAt(0.2, buttonColor.lighter(coeff));
    gradient.setColorAt(0.8, buttonColor.darker(coeff));
    gradient.setColorAt(1.0, option-&gt;palette.dark().color());</pre></div><br />
<p class="docText"><a name="iddle2947"></a><a name="iddle3557"></a><a name="iddle5275"></a><a name="iddle5997"></a><a name="iddle6006"></a>We sta&#114;t by se&#116;ting up t&#104;e <tt>QLin&#101;arGra&#100;ient</tt><a name="light at"></a> that is us&#101;d to fill the background. The grad&#105;ent is l&#105;ght at t&#104;e top and &#100;ark at th&#101; bottom, and goes through i&#110;termediate shades of b&#114;onze in between. The interm&#101;diate steps at 0.2 and 0.8 contribute to giving the button a &#102;ake 3&#68; effect. The <tt>&#99;oeff</tt><a name="a "></a> factor &#99;ontrols how &#109;uch of a 3D look the butto&#110; should have. When th&#101; mouse hovers over the button, we us&#101; 115% as &#116;he <tt>coeff</tt> &#116;o make the bu&#116;ton rise up slightl&#121;.</p>
<div class="docText"><pre>    double penWidth = 1.0;
    if (const QStyleOptionButton *buttonOpt =
            qstyleoption_cast&lt;const QStyleOptionButton *&gt;(option)) {
        if (buttonOpt-&gt;features &amp; QStyleOptionButton::DefaultButton)
            penWidth = 2.0;
    }</pre></div><br />
<p class="docText"><a name="and a"></a>The Bronze st&#121;le uses a 2-pixel-wide outline around def&#97;ult buttons and a 1-pixel-wide outline otherw&#105;se. To find out whether the push button is a default button, &#119;e cast <tt>optio&#110;</tt> t&#111; a <tt>c&#111;ns&#116; QStyleOptio&#110;Button *</tt> and check it&#115; <tt>features</tt> member variable.</p>
<div class="docText"><pre>    QRect roundRect = option-&gt;rect.adjusted(+1, +1, -1, -1);
    if (!roundRect.isValid())
        return;

    int diameter = 12;
    int cx = 100 * diameter / roundRect.width();
    int cy = 100 * diameter / roundRect.height();</pre></div><br />
<p class="docText"><a name="be used"></a>We &#100;e&#102;ine &#115;ome more va&#114;iables that wi&#108;l be used below to draw the button. T&#104;e <tt>cx</tt> and <tt>cy</tt><a name="to be"></a> coefficients &#115;pecify how rounded we want &#116;he push button corners to be. They are computed in t&#101;rm&#115; of <tt>diam&#101;te&#114;</tt><a name="rounded corners"></a>, which &#115;pecifies t&#104;e rounded c&#111;rners' desired diameters.</p>
<div class="docText"><pre>    painter-&gt;save();
    painter-&gt;setPen(Qt::NoPen);
    painter-&gt;setBrush(gradient);
    painter-&gt;drawRoundRect(roundRect, cx, cy);

    if (option-&gt;state &amp; (State_On | State_Sunken)) {
        QColor slightlyOpaqueBlack(0, 0, 0, 63);
        painter-&gt;setBrush(slightlyOpaqueBlack);
        painter-&gt;drawRoundRect(roundRect, cx, cy);
    }

    painter-&gt;setRenderHint(QPainter::Antialiasing, true);
    painter-&gt;setPen(QPen(option-&gt;palette.foreground(), penWidth));
    painter-&gt;setBrush(Qt::NoBrush);
    painter-&gt;drawRoundRect(roundRect, cx, cy);
    painter-&gt;restore();
}</pre></div><br />
<p class="docText"><a name="iddle1384"></a><a name="iddle2243"></a><a name="the drawing"></a>Fi&#110;a&#108;ly, we perfo&#114;m the drawing. &#87;e start by dr&#97;wing the background using the <tt>QLinearGr&#97;dient</tt><a name="that we"></a> that we defined earlier in the func&#116;ion. If the button is currently press&#101;d (or is a toggle button in its &quot;on&quot; state), we dr&#97;w a 75% transp&#97;rent blac&#107; color on t&#111;p o&#102; it to ma&#107;e it a bit darker.</p>
<p class="docText"><a name="have drawn"></a>Once we have drawn &#116;he background, we turn on antialiasi&#110;g &#116;o obtain &#115;mooth roun&#100;ed c&#111;rners, we set an appropr&#105;ate pen, we clear the brush, and we dr&#97;w the outline.</p>
<div class="docText"><div class="codeSegmentsExpansionLinks">
              Code View:</div><pre class="">void BronzeStyle::drawBronzeSpinBoxButton(SubControl which,
        const QStyleOptionComplex *option, QPainter *painter) const
{
    PrimitiveElement arrow = PE_IndicatorArrowLeft;
    QRect buttonRect = option-&gt;rect;
    if ((which == SC_SpinBoxUp)
            != (option-&gt;direction == Qt::RightToLeft)) {
        arrow = PE_IndicatorArrowRight;
        buttonRect.translate(buttonRect.width() / 2, 0);
    }
    buttonRect.setWidth((buttonRect.width() + 1) / 2);

    QStyleOption buttonOpt(*option);

    painter-&gt;save();
    painter-&gt;setClipRect(buttonRect, Qt::IntersectClip);
    if (!(option-&gt;activeSubControls &amp; which))
        buttonOpt.state &amp;= ~(State_MouseOver | State_On | State_Sunken);
    drawBronzeBevel(&amp;buttonOpt, painter);

    QStyleOption arrowOpt(buttonOpt);
    arrowOpt.rect = subControlRect(CC_SpinBox, option, which)
                    .adjusted(+3, +3, -3, -3);
    if (arrowOpt.rect.isValid())
        drawPrimitive(arrow, &amp;arrowOpt, painter);
    painter-&gt;restore();
}

					  </pre></div><br />
<p class="docText">The <tt>drawBronzeSpinBoxBu&#116;ton()</tt><a name="draws the"></a> function draws the up or down button of a spin box, d&#101;pe&#110;d&#105;ng on wh&#101;th&#101;r <tt>which</tt> is <tt>&#83;C_SpinBoxD&#111;wn</tt> or <tt>SC_SpinBoxUp</tt><a name="on the"></a>. We start by se&#116;ting up t&#104;e arro&#119; to draw on the bu&#116;ton (a left or a righ&#116; arrow) and the rectangle in wh&#105;ch we draw the button.</p>
<p class="docText">If <tt>which</tt> is <tt>SC_SpinB&#111;xDown</tt> (or <tt>which</tt> is <tt>SC_SpinB&#111;xUp</tt><a name="we use"></a> and the layout direction is right-to-le&#102;t), we &#117;se a left a&#114;row (<tt>PE_&#73;ndic&#97;torArrowLeft</tt><a name="of the"></a>) and w&#101; draw the button i&#110; the left half of the spin box's &#114;ectan&#103;le; ot&#104;erwise, we &#117;se a right arrow and w&#101; draw the button in t&#104;e right half.</p>
<p class="docText">To draw the button, we call <tt>drawBron&#122;eBevel()</tt> with a <tt>QStyleOption</tt><a name="spin box"></a> that correctly &#114;eflects the state of the spin box button we want &#116;o draw. Fo&#114; examp&#108;e, if the mou&#115;e is hov&#101;ring &#111;ver the spin box bu&#116; not over the spin box button corresp&#111;nd&#105;ng to <tt>wh&#105;ch</tt>, we clear &#116;he <tt>State_MouseOver</tt>, <tt>&#83;tate_On</tt>, and <tt>State_Sunken</tt> flags from th&#101; <tt>QStyleOption</tt><a name="buttons behave"></a>'s state. This is nec&#101;ssary to ensure that the two spin box buttons beh&#97;ve independently of each other.</p>
<p class="docText"><a name="iddle1382"></a><a name="iddle1548"></a><a name="iddle2241"></a><a name="iddle2278"></a><a name="iddle2285"></a><a name="iddle5537"></a><a name="iddle5979"></a><a name="any drawing"></a>Before we perform an&#121; dr&#97;wing, we ca&#108;l <tt>setClipR&#101;ct()</tt><a name="the clipping"></a> &#116;o set the clipping rec&#116;angle on the <tt>QPainter</tt><a name="This is"></a>. This i&#115; because we want to draw only th&#101; le&#102;t or &#114;ight half of a but&#116;on bevel, no&#116; the entire button beve&#108;.</p>
<p class="docText"><a name="we draw"></a>Finally, at the end, we draw the arrow by calling <tt>d&#114;awPrimitive()</tt>. The <tt>QStyleOption</tt><a name="to draw"></a> used to draw the arro&#119; is set up with a rectangle that corresponds to the spin box b&#117;tton's rec&#116;angle (<tt>SC_&#83;pinB&#111;xU&#112;</tt> or <tt>SC_SpinBoxD&#111;wn</tt>) but is a bit smaller, to obt&#97;in a smaller arrow.</p>
<div class="docText"><div class="codeSegmentsExpansionLinks">
              Code View:</div><pre class="">void BronzeStyle::drawBronzeCheckBoxIndicator(
        const QStyleOption *option, QPainter *painter) const
{
    painter-&gt;save();
    painter-&gt;setRenderHint(QPainter::Antialiasing, true);

    if (option-&gt;state &amp; State_MouseOver) {
        painter-&gt;setBrush(option-&gt;palette.alternateBase());
    } else {
        painter-&gt;setBrush(option-&gt;palette.base());
    }
    painter-&gt;drawRoundRect(option-&gt;rect.adjusted(+1, +1, -1, -1));

    if (option-&gt;state &amp; (State_On | State_NoChange)) {
        QPixmap pixmap;
        if (!(option-&gt;state &amp; State_Enabled)) {
            pixmap.load(":/images/checkmark-disabled.png");
        } else if (option-&gt;state &amp; State_NoChange) {
            pixmap.load(":/images/checkmark-partial.png");
        } else {
            pixmap.load(":/images/checkmark.png");
        }

        QRect pixmapRect = pixmap.rect()
                                 .translated(option-&gt;rect.topLeft())
                                 .translated(+2, -6);
        QRect painterRect = visualRect(option-&gt;direction, option-&gt;rect,
                                       pixmapRect);
        if (option-&gt;direction == Qt::RightToLeft) {
            painter-&gt;scale(-1.0, +1.0);
            painterRect.moveLeft(-painterRect.right() - 1);
        }
        painter-&gt;drawPixmap(painterRect, pixmap);
    }
    painter-&gt;restore();
}

					  </pre></div><br />
<p class="docText">Although the <tt>dr&#97;wBronzeC&#104;eckBo&#120;Ind&#105;cator()</tt><a name="indicator is"></a> code &#109;ight look complex at first sight, drawing a che&#99;kbox indicator is actually quite simple: We draw a &#114;ectangle using <tt>drawRoundRect()</tt><a name="using"></a>, &#97;nd we draw the checkmark using <tt>drawPixmap()</tt><a name="different background"></a>. The complications arise be&#99;ause we want &#116;o use a di&#102;fer&#101;nt &#98;ackground color when th&#101; mouse hovers ove&#114; the checkbox indicator, beca&#117;se we dist&#105;nguish &#98;etween normal checkmar&#107;s, disabled c&#104;eckmarks, and partial chec&#107;marks (for tri-state checkboxes), and because we f&#108;ip the checkmark in right-to-left mode (by flipping &#116;he <tt>QPainter</tt>'s coordinate system).</p>

<p class="docText"></p><a name="ch19sb01"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>

<h2 class="docSidebarTitle">QStyle&#79;ption Versi&#111;ni&#110;g</h2>
<p class="docText"><a name="iddle1320"></a><a name="iddle5995"></a><a name="iddle5999"></a><a name="iddle6007"></a><a name="iddle8431"></a>&#84;he inf&#111;rmation that <tt>&#81;Style</tt><a name="around using"></a> ne&#101;ds to draw a widget is passed a&#114;ound u&#115;ing <tt>QSt&#121;leOption</tt> and it&#115; subclasses (<tt>QSt&#121;leOptionButton</tt>, <tt>QStyle&#79;ptionComboBox</tt>, <tt>QStyleOptionFrame</tt>, et&#99;.). For performance reasons, the data is stored in publi&#99; member variables.</p>
<p class="docText"><a name="new member"></a>To ensure binary compatibility across all Qt 4 v&#101;rs&#105;ons, Tro&#108;ltech cann&#111;t a&#100;d ne&#119; member variables to these &#99;lasses until Qt 5. To allow enhancements in futur&#101; Qt 4.<span class="docEmphasis">&#120;</span> r&#101;leases, <tt>QStyl&#101;Option</tt> has a <tt>&#118;ersion</tt><a name="be used"></a> variable that can be used t&#111; distinguish between differen&#116; versions of the same class. When new data member&#115; are needed, Trolltech adds them to a subclass id&#101;nt&#105;fied by &#116;he same <tt>t&#121;pe</tt><a name="a different"></a> &#98;ut with a differ&#101;nt <tt>version</tt><a name="For example"></a>. For exa&#109;ple, Qt 4.1 introduced <tt>QStyleOptionFrameV2</tt><a name="derived from"></a>, w&#104;ich is &#100;e&#114;ived from <tt>QSt&#121;leOptionFrame</tt><a name="also provides"></a> &#98;ut also provides a <tt>features</tt> member varia&#98;le that the style can query. The <tt>QStyleOpti&#111;nFrameV2</tt> subclass is of <tt>type SO_Fra&#109;e</tt>, but its <tt>version</tt> is 2 instead of 1.</p>
<p class="docText">In a <tt>QStyle</tt> subclass, we can u&#115;e <tt>QStyl&#101;Op&#116;ionFram&#101;</tt> as &#117;sual, and if we w&#97;nt to access the <tt>features</tt><a name="can write"></a> var&#105;able, which is defined onl&#121; in &#118;ersion 2 of t&#104;e class, we can w&#114;ite code &#115;uch as this:</p>
<div class="docText"><pre>if (const QStyleOptionFrame *frameOption =
            qstyleoption_cast&lt;const QStyleOptionFrame *&gt;(option)) {
    QStyleOptionFrameV2 frameOptionV2(*frameOption);

    int lineWidth = frameOptionV2.lineWidth;
    bool flat = (frameOptionV2.features &amp; QStyleOptionFrameV2::Flat);
    ...
}</pre></div><br />
<p class="docText">The <tt>QStyle&#79;ptionFrameV2</tt><a name="and version"></a> copy constructor accepts both ve&#114;sion 1 and version 2 instances of the class. If a ve&#114;sion 1 object is supplied, the copy constructor will initial&#105;ze the <tt>f&#101;at&#117;res</tt> field &#119;ith a defaul&#116; value of <tt>None</tt>; otherw&#105;se, it will copy the <tt>feat&#117;res</tt> field from <tt>frameOption</tt> obje&#99;t.</p>
<p class="docText"><a name="a copy"></a>Another wa&#121; to &#97;chieve the sa&#109;e effect, but without perf&#111;rming a copy, is to use <tt>qst&#121;leoption_cast&lt;T&gt;()</tt> to distinguish &#98;etween different versions:</p>
<div class="docText"><pre>if (const QStyleOptionFrame *frameOption =
        qstyleoption_cast&lt;const QStyleOptionFrame *&gt;(option)) {
    int lineWidth = frameOption.lineWidth;
    bool flat = false;

    if (const QStyleOptionFrame *frameOptionV2 =
            qstyleoption_cast&lt;const QStyleOptionFrameV2 *&gt;(option))
        flat = (frameOptionV2.features &amp; QStyleOptionFrameV2::Flat);
    ...
}</pre></div><br />
<p class="docText">In Qt 5, the <tt>feat&#117;res</tt> variable will most probably be moved to <tt>QStyleOptionFrame</tt><a name="between major"></a>, becaus&#101; Qt &#100;o&#101;s n&#111;t m&#97;intain bina&#114;y compatibility between maj&#111;r releases.</p>
</td></tr></table></p><br />
<p class="docText"><a name="iddle4740"></a><a name="iddle4904"></a><a name="iddle4976"></a><a name="iddle6405"></a><a name="iddle7335"></a>We have now completed t&#104;e impl&#101;me&#110;tation of ou&#114; Bronze <tt>QS&#116;yle</tt> subclass. In the screenshots shown in <a class="docLink" href="#ch19fig17">Figure 19.17</a>, &#97; <tt>QDateEdit</tt> and a <tt>QTreeWidget</tt><a name="we have"></a> are sh&#111;wn, both of which use the Bronze st&#121;le even though we have not written a&#110;y &#99;ode specifi&#99;ally for the&#109;. This is beca&#117;se <tt>QDateEdi&#116;</tt>, <tt>QDoubleSpinBox</tt><a name="widgets are"></a>, a&#110;d some other widgets are all &quot;s&#112;in b&#111;xe&#115;&quot;, and so make use of t&#104;e Bronze st&#121;le code for rendering &#116;hemselves; similarly, <tt>QTreeWid&#103;et</tt><a name="other widget"></a> and all other widget classes that are derive&#100; from <tt>QFrame</tt><a name="get the"></a> get the custom look defined b&#121; th&#101; Br&#111;nz&#101; st&#121;le.</p>
<p class="docText"><a name="style presented"></a>The Bro&#110;ze style &#112;resented in this sec&#116;ion can e&#97;sily be us&#101;d in a&#110; appli&#99;ation, by linking it in and calling</p>
<div class="docText"><pre>QApplication::setStyle(new BronzeStyle);</pre></div><br />
<p class="docText"><a name="the application"></a>in th&#101; application's <tt>main()</tt><a name="have a"></a> function. Wi&#100;gets that aren't handled explicitly by t&#104;e Bronze style will have a classic Windows look. Custom &#115;tyles c&#97;n also be c&#111;mp&#105;led as p&#108;ugins and used afte&#114;wards in <span class="docEmphasis">Qt Designer</span><a name="In"></a> to &#112;review forms using that style. In <a class="docLink" href="ch21.html#ch21">Chapter 21</a><a name="available as"></a>, we will &#115;how how &#116;o make th&#101; Bronz&#101; style &#97;vailable as a Qt plugin.</p>
<p class="docText"><a name="about "></a>Although the sty&#108;e developed here is only about 300 lines o&#102; code, be aware that developing a fully funct&#105;onal custom style is a major undertaking that typically requir&#101;s 3000 t&#111; 5000 li&#110;e&#115; of C++ cod&#101;. For this r&#101;ason, it is often &#101;asier and more convenient to us&#101; Qt &#115;tyle sh&#101;ets whenev&#101;r poss&#105;ble, or to use a hybr&#105;d approach, combining style sheet&#115; and a custom <tt>QStyle</tt>. If you plan to create &#97; custom <tt>QStyle</tt><a name="document"></a>, implementing styles and &#115;tyle-aw&#97;re widget&#115; is cove&#114;ed in d&#101;pth in the &#100;ocument <a class="docLink" target="_blank" href="http://doc.trolltech.com/4.3/style-reference.html">http://doc.trolltech.com/4.3/style-reference.html</a>.</p>

</div></div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch19lev1sec1.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch20.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>