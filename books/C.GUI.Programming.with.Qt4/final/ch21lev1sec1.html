<html>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<head>
<title>ch21lev1sec1.html</title>
<link rel="STYLESHEET" type="text/css" href="images/css1.css">
<link rel="STYLESHEET" type="text/css" href="images/css2.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch21.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch21lev1sec2.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<div style=""><div><a name="ch21"></a>

<h2 id="title-ID0ENEPM" class="docChapterTitle">21. Creating Plugins</h2>



<p class="docText">
<img border="0" id="" width="180" height="131" src="images/NzlkOW1jM2FhMDc4L2lwdHJnZTFnMTRzOXIvMy83ZXBwdDFocF9lcl8vMmlzY2Nob25lYS5wZ3Jq.jpg" alt="" /></p>



<ul><li><p class="docList"><a name="iddle2183"></a><a name="iddle2321"></a><a name="iddle3200"></a><a name="iddle3539"></a><a name="iddle3542"></a><a name="iddle4465"></a><a name="iddle4493"></a><a name="iddle5263"></a><a name="iddle7421"></a><span class="docEmphasis"><a class="docLink" href="ch21lev1sec1.html#ch21lev1sec1">Extending Qt with Plugins</a></span></p></li><li><p class="docList"><span class="docEmphasis"><a class="docLink" href="ch21lev1sec2.html#ch21lev1sec2">Making Applications Plugin-Aware</a></span></p></li><li><p class="docList"><span class="docEmphasis"><a class="docLink" href="ch21lev1sec3.html#ch21lev1sec3">Writing Application Plugins</a></span></p></li></ul>
<p class="docText"><a name="Dynamic libraries"></a>&#68;ynamic lib&#114;aries (&#97;lso calle&#100; s&#104;ared librarie&#115; or DLLs) are independ&#101;nt modules that are stored in a separate fi&#108;e on disk an&#100; c&#97;n be accessed by mu&#108;tiple application&#115;. Programs usually specify wh&#105;ch dynamic libraries they need at link tim&#101;, in which case the libraries are automatically loade&#100; when the application starts. This approach usually in&#118;olves addi&#110;g &#116;he libra&#114;y and p&#111;ssibly its &#105;nclude path to the app&#108;ication's <tt>.pro</tt><a name="including the"></a> file and including the rele&#118;ant header&#115; in the s&#111;urce files. For e&#120;ample:</p>
<div class="docText"><pre>LIBS        += -ldb_cxx
INCLUDEPATH += /usr/local/BerkeleyDB.4.2/include</pre></div><br />
<p class="docText"><a name="alternative is"></a>The alte&#114;native is to dynamically load th&#101; library when it is required, and then reso&#108;ve the symbols that we want to use from it. Qt provid&#101;s the <tt>QLibrary</tt><a name="of a"></a> class to achieve this in a platform-ind&#101;pe&#110;d&#101;nt &#109;anner. Given &#116;he stem of a li&#98;rary's name, <tt>QLibrary</tt><a name="the library"></a> searc&#104;es the platform's standard loca&#116;ions for &#116;he libra&#114;y, looking for a&#110; appro&#112;riate file. For example, given the &#110;ame <tt>mimetype</tt>, it will look for <tt>mimetype.&#100;ll</tt> on Windows, <tt>mimetype.so</tt> on Linux, and <tt>mimetype.dyl&#105;b</tt> on Mac OS X.</p>
<p class="docText"><a name="use of"></a>Modern GUI applications can often be ex&#116;ended by &#116;he use of &#112;lug&#105;ns. A plu&#103;in is a dynamic l&#105;brary that implements a pa&#114;ticular interface to provide optional ex&#116;ra funct&#105;onalit&#121;. For examp&#108;e, in <a class="docLink" href="ch05.html#ch05">Chapter 5</a><a name="custom widget"></a>, we created a plug&#105;n to integrate a custom widget with <span class="docEmphasis">&#81;t Designer</span> (p. <a class="docLink" href="ch05lev1sec3.html#ch05lev1sec3">117</a>).</p>
<p class="docText"><a name="including image"></a>Qt reco&#103;nizes its own set of plugin interfaces for var&#105;ous domains, including image formats, database dr&#105;vers, wi&#100;g&#101;t s&#116;yles, tex&#116; encodings, and &#97;ccessibility. This chapter's fir&#115;t section explains how to ext&#101;nd &#81;t w&#105;th Qt plugins.</p>
<p class="docText"><a name="possible to"></a>It is &#97;lso possible to creat&#101; application-specific plu&#103;ins for particular Qt appli&#99;ations. Qt makes writing such plugins easy through i&#116;s plugin framework, which adds crash safety &#97;nd conven&#105;ence to <tt>&#81;Li&#98;rary</tt><a name="last two"></a>. In the &#108;ast two sections of t&#104;is chapter, we show how to &#109;ake an application support plugins and how t&#111; cr&#101;at&#101; a custom plug&#105;n for an applicati&#111;n.</p>




<a name="ch21lev1sec1"></a>

<h3 class="docSection1Title" id="-100000">Extending Qt with Plugins</h3>
<p class="docText"><a name="iddle1380"></a><a name="iddle1394"></a><a name="iddle1397"></a><a name="iddle2570"></a><a name="iddle4361"></a><a name="iddle4616"></a><a name="iddle4680"></a><a name="iddle4681"></a><a name="iddle4682"></a><a name="iddle4683"></a><a name="iddle4911"></a><a name="iddle4913"></a><a name="iddle5034"></a><a name="iddle5185"></a><a name="iddle5186"></a><a name="iddle5202"></a><a name="iddle5209"></a><a name="iddle5215"></a><a name="iddle5216"></a><a name="iddle5246"></a><a name="iddle5408"></a><a name="iddle5583"></a><a name="iddle5687"></a><a name="iddle5689"></a><a name="iddle5709"></a><a name="iddle5821"></a><a name="iddle5822"></a><a name="iddle5972"></a><a name="iddle6003"></a><a name="iddle6271"></a><a name="iddle6278"></a><a name="iddle6676"></a><a name="iddle6680"></a><a name="iddle7859"></a><a name="Qt can"></a>Qt can be extended with a varie&#116;y of plugin types, the most common b&#101;ing database drivers, image formats, styles, &#97;nd text codecs. For each type of plugin, we normally need at &#108;east two cl&#97;sses: a plu&#103;in wr&#97;pper clas&#115; that implem&#101;nts the generi&#99; plugin API functions, and one or m&#111;re &#104;andle&#114; classes t&#104;at each imple&#109;ent the API for a particular t&#121;pe of plugin. The handlers are acc&#101;ssed through the wrapper class. These c&#108;asses are shown in <a class="docLink" href="#ch21fig01">Figure 21.1</a>.</p>
<a name="ch21fig01"></a><p><table cellspacing="0" class="allBorders" border="1"><caption><h5 class="docTableTitle"><a name="plugin and"></a>Figure 21.1. Qt plugin and handle&#114; class&#101;s</h5></caption><colgroup align="left" span="2"><col width="180" /><col width="200" /></colgroup><thead><tr><th scope="col" class="docTableCell thead" align="center" valign="top" style="background-color:#E6E6E6">P&#108;ugin Class</th><th scope="col" class="docTableCell thead" align="center" valign="top" style="background-color:#E6E6E6"><a name="Base Class"></a>&#72;and&#108;er Base Class</th></tr></thead><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QAcce&#115;sibleBridgePlugin</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QAcce&#115;sibleBridge</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QAccessiblePlugin</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QAccessi&#98;leInterfa&#99;e</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QDecorati&#111;nPlugin<sup class="docFootnote"><a class="docLink" href="#ch21tn01">[*]</a></sup></span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QDeco&#114;ation<sup class="docFootnote"><a class="docLink" href="#ch21tn01">[*]</a></sup></span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QFo&#110;tEnginePlugin</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QAbstrac&#116;FontEngine</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QIconEnginePlug&#105;nV2</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QIconEngineV2</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QImageIOPlugin</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QImag&#101;IOHandler</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QInputContextPlugin</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QInpu&#116;Context</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">&#81;Kb&#100;D&#114;iverP&#108;ugin<sup class="docFootnote"><a class="docLink" href="#ch21tn01">[*]</a></sup></span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QWSKeybo&#97;rdHandler<sup class="docFootnote"><a class="docLink" href="#ch21tn01">[*]</a></sup></span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QMouseDr&#105;verPlugin<sup class="docFootnote"><a class="docLink" href="#ch21tn01">[*]</a></sup></span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QWSMouseHand&#108;er<sup class="docFootnote"><a class="docLink" href="#ch21tn01">[*]</a></sup></span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QPictur&#101;Fo&#114;matPlugin</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">N/A</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QSc&#114;eenDriverPlu&#103;in<sup class="docFootnote"><a class="docLink" href="#ch21tn01">[*]</a></sup></span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QScreen<sup class="docFootnote"><a class="docLink" href="#ch21tn01">[*]</a></sup></span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QScriptExtensionP&#108;ugin</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">N/A</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QSqlDriverPlugin</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QSqlDriver</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QStyleP&#108;ugin</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QStyle</span></td></tr><tr><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QTextCodecPlugin</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">QTextCodec</span></td></tr></table></p><br /><blockquote><p class="docFootnote"><sup><a name="ch21tn01">[*]</a></sup> Avai&#108;able only in Qt/Embedded Linux.</p></blockquote>
<p class="docText"><a name="implement two"></a>To demons&#116;rate how &#116;o extend &#81;t w&#105;th plug&#105;ns, we will implemen&#116; two plugins in this secti&#111;n. The first is a very simple <tt>QStyle</tt><a name="we developed"></a> &#112;lug&#105;n for th&#101; Bronz&#101; style &#119;e developed in <a class="docLink" href="ch19.html#ch19">Chapter 19</a><a name="Windows cursor"></a>. The second is a plugin that c&#97;n read monochrome Windows &#99;ursor files.</p>
<p class="docText">Creating a <tt>QStyle</tt><a name="developed the"></a> plugin is ver&#121; easy, provided we have already deve&#108;oped the st&#121;le &#105;tself. A&#108;l we need ar&#101; three fil&#101;s: a <tt>.pro</tt><a name="seen before"></a> file that &#105;s rather different from the ones &#119;e have seen b&#101;fo&#114;e, and small <tt>.h</tt> and <tt>.cpp</tt><a name="a"></a> &#102;iles to prov&#105;de a <tt>QStylePlugin</tt><a name="acts as"></a> subcl&#97;ss that acts as a wrapper for the styl&#101;. We will begin with the <tt>.h</tt> file:</p>
<div class="docText"><pre>class BronzeStylePlugin : public QStylePlugin
{
public:
    QStringList keys() const;
    QStyle *create(const QString &amp;key);
};</pre></div><br />
<p class="docText"><a name="iddle1395"></a><a name="iddle1396"></a><a name="iddle1891"></a><a name="iddle2687"></a><a name="iddle3461"></a><a name="iddle4480"></a><a name="iddle4596"></a><a name="iddle7932"></a><a name="page_493"></a><a name="All plugins"></a>All plugins at least pr&#111;vide a <tt>keys()</tt><a name="a"></a> function and a <tt>create()</tt> function. The <tt>keys()</tt><a name="returns a"></a> &#102;unc&#116;ion retu&#114;ns a li&#115;t of the &#111;bject&#115; that the plugin can cr&#101;ate. For style plugins, the k&#101;ys &#97;re case-in&#115;ensitive, so &quot;mystyl&#101;&quot; and &quot;M&#121;Style&quot; are treated t&#104;e same. The <tt>create()</tt><a name="be the"></a> function retu&#114;ns an object given a key; the key must be the same as o&#110;e of those in the list returned by <tt>keys()</tt>.</p>
<p class="docText">The <tt>.cp&#112;</tt><a name="and simple"></a> fil&#101; is &#97;lmost as s&#109;all and simp&#108;e as the <tt>.h</tt> file.</p>
<div class="docText"><pre>QStringList BronzeStylePlugin::keys() const
{
    return QStringList() &lt;&lt; "Bronze";
}</pre></div><br />
<p class="docText">The <tt>keys()</tt><a name="we offer"></a> f&#117;nction returns a list of sty&#108;es provided by the plugin. Here, w&#101; of&#102;er o&#110;ly on&#101; style, &#99;alled &quot;Bronze&quot;.</p>
<div class="docText"><pre>QStyle *BronzeStylePlugin::create(const QString &amp;key)
{
    if (key.toLower() == "bronze")
        return new BronzeStyle;
    return 0;
}</pre></div><br />
<p class="docText"><a name="a"></a>If the key is &quot;Bronze&quot; (re&#103;ardless of case), we create a <tt>Bronz&#101;Style</tt> object and return it.</p>
<p class="docText">At the &#101;nd of the <tt>.cpp</tt> file, we must add the following mac&#114;o to ex&#112;ort &#116;he style &#112;rop&#101;rly:</p>
<div class="docText"><pre>Q_EXPORT_PLUGIN2(bronzestyleplugin, BronzeStylePlugin)</pre></div><br />
<p class="docText">Th&#101; first argument to <tt>Q_E&#88;PORT_PLUGIN2()</tt><a name="version number"></a> is the base name of the target l&#105;brary, e&#120;c&#108;uding any ext&#101;nsion, pref&#105;x, or version number. By default, <tt>qmake</tt><a name="of the"></a> use&#115; the name of the current di&#114;ectory as the base name; this can be ov&#101;rriden using the <tt>TARGET</tt><a name="the"></a> entry in the <tt>.pro</tt><a name="The second"></a> fi&#108;e. The secon&#100; a&#114;gumen&#116; to <tt>Q_EXPO&#82;T_PLUGIN2()</tt><a name="class name"></a> is t&#104;e plugin's class name.</p>
<p class="docText">Th&#101; <tt>.pro</tt><a name="is different"></a> file is different for p&#108;ugins than &#102;or a&#112;plications, so we &#119;ill finish by lo&#111;king at the Bronze st&#121;le's <tt>.pro</tt> file:</p>
<div class="docText"><pre>TEMPLATE      = lib
CONFIG       += plugin
HEADERS       = ../bronze/bronzestyle.h \
                bronzestyleplugin.h
SOURCES       = ../bronze/bronzestyle.cpp \
                bronzestyleplugin.cpp
RESOURCES     = ../bronze/bronze.qrc
DESTDIR       = $$[QT_INSTALL_PLUGINS]/styles</pre></div><br />
<p class="docText"><a name="iddle1098"></a><a name="iddle1733"></a><a name="iddle1932"></a><a name="iddle1969"></a><a name="iddle1973"></a><a name="iddle2044"></a><a name="iddle2104"></a><a name="iddle2439"></a><a name="iddle2578"></a><a name="iddle3175"></a><a name="iddle3304"></a><a name="iddle4463"></a><a name="iddle4741"></a><a name="iddle4853"></a><a name="iddle5210"></a><a name="iddle5214"></a><a name="iddle5415"></a><a name="iddle6118"></a><a name="iddle6150"></a><a name="iddle6851"></a><a name="iddle7336"></a><a name="iddle7806"></a><a name="iddle7846"></a>By defaul&#116;, <tt>.pro</tt> files use the <tt>app</tt> template, but here we must specify &#116;he <tt>lib</tt> template because a plugin is a library, not a stand-alone ap&#112;lic&#97;tion. The <tt>C&#79;NFIG</tt><a name="is not"></a> line is &#117;sed to tel&#108; Qt that the library is n&#111;t just a plain library, but &#97; plugin library. The <tt>DESTDIR</tt><a name="plugin should"></a> specifies t&#104;e dire&#99;tory where t&#104;e plugin shoul&#100; go. Al&#108; Qt plugins must go in the appropriate <tt>plugin&#115;</tt> subdirectory where Qt was ins&#116;alled; this path is built into <tt>qmake</tt> and ava&#105;lable from the <tt>$$[QT_INSTALL_PLUGINS]</tt><a name="in Qt"></a> variable. Since &#111;ur &#112;lug&#105;n provi&#100;e&#115; a new style, &#119;e put it in Qt's <tt>plugins/styles</tt><a name="types is"></a> &#100;irectory. The list of dir&#101;ct&#111;ry &#110;ames and plugi&#110; type&#115; is available at <a class="docLink" target="_blank" href="http://doc.trolltech.com/4.3/plugins-howto.html">http://doc.trolltech.com/4.3/plugins-howto.html</a>.</p>
<p class="docText"><a name="are different"></a>Plugins built for Qt &#105;n release mode and debug mode are &#100;ifferent, so if both versions &#111;f Qt are installed, it is wise to specify which one to us&#101; in &#116;he <tt>.pro</tt> fi&#108;e—for examp&#108;e, by adding &#116;he line</p>
<div class="docText"><pre>CONFIG += release</pre></div><br />
<p class="docText"><a name="style plugin"></a>Onc&#101; the Bronz&#101; style plugin is built, it is read&#121; fo&#114; use. Ap&#112;lications can &#117;se the style by specif&#121;ing it in code. For example:</p>
<div class="docText"><pre>QApplication::setStyle("Bronze");</pre></div><br />
<p class="docText"><a name="also use"></a>W&#101; can also use the style without &#99;hanging the application's source code at all, simp&#108;y by running the application with the <tt>-style</tt><a name="For example"></a> option. For e&#120;a&#109;ple:</p>
<div class="docText"><pre>./spreadsheet -style bronze</pre></div><br />
<p class="docText">When <span class="docEmphasis">Qt D&#101;si&#103;ner</span><a name="automatically looks"></a> i&#115; run, it automatica&#108;ly looks for plugins. &#73;f it finds a style plugin, it wil&#108; offer the o&#112;tio&#110; to pr&#101;view u&#115;ing the style in its <span class="docEmphRomanAlt">Form|Pr&#101;view in</span> submenu.</p>
<p class="docText"><a name="that use"></a>Applications t&#104;at use Qt plugins must be deployed with the plugins they &#97;re intended to use. Qt plugins must be placed in &#115;pecifi&#99; subdirecto&#114;ies (e.g., <tt>&#112;lug&#105;ns/styles</tt> f&#111;r custom styles). Q&#116; applications search for plugins in th&#101; <tt>pl&#117;gins</tt><a name="want to"></a> dire&#99;tory in the director&#121; where &#116;he application's executable resides. If w&#101; want to deploy Qt plugins in a d&#105;fferent directory, the plugins search path can be augmented &#98;y calling <tt>QCoreApplication::addLibraryPath()</tt><a name="the"></a> at startup or by se&#116;ting the <tt>&#81;T_P&#76;UGIN_PAT&#72;</tt> env&#105;ronment variabl&#101; before launching t&#104;e application.</p>
<p class="docText"><a name="will tackle"></a>Now that we have seen a very &#115;imple p&#108;ugin, we wil&#108; tackle one that is a b&#105;t more challen&#103;ing: an image format plugin for Wi&#110;dows cursor (<tt>.cur</tt>) files. (The format is shown &#105;n <a class="docLink" href="#ch21fig02">Figure 21.2</a><a name="of the"></a>.) Windows cursor files can hold several images of t&#104;e same cursor at different sizes. Once the cursor plug&#105;n is bui&#108;t and insta&#108;led, Qt will &#98;e able to re&#97;d <tt>.cur</tt> files and acc&#101;ss individual cursor&#115; (e.g., through <tt>QImage</tt>, <tt>QImageReader</tt>, or <tt>Q&#77;ovie</tt><a name="any of"></a>), and w&#105;ll be ab&#108;e to write the curs&#111;rs out &#105;n any of Qt's other i&#109;age file formats, such as BMP, JPEG, and PNG.</p>
<a name="ch21fig02"></a><p><center>

<h5 class="docFigureTitle">Fi&#103;ure 21.2. The <tt>.cur</tt> file format</h5>

<p class="docText">
<img border="0" id="" width="498" height="233" src="images/NzlkOW1jM2FhMDc4L2lwdHJnZTFnMTRzOXIvMy83cC4xaGZpZmcvaXMyaWNnMDI-.jpg" alt="" /></p>


</center></p><br />
<p class="docText"><a name="plugin wrappers"></a>New image format pl&#117;gin wrappers must subclass <tt>QImageIOPlugin</tt><a name="a few"></a> and r&#101;im&#112;lem&#101;nt &#97; few virtu&#97;l functions:</p>
<div class="docText"><pre>class CursorPlugin : public QImageIOPlugin
{
public:
    QStringList keys() const;
    Capabilities capabilities(QIODevice *device,
                              const QByteArray &amp;format) const;
    QImageIOHandler *create(QIODevice *device,
                            const QByteArray &amp;format) const;
};</pre></div><br />
<p class="docText"><a name="iddle1475"></a><a name="iddle1892"></a><a name="iddle1970"></a><a name="iddle1971"></a><a name="iddle1972"></a><a name="iddle3462"></a><a name="iddle5211"></a><a name="iddle5212"></a><a name="iddle5213"></a><a name="The"></a>&#84;he <tt>keys()</tt><a name="a list"></a> function r&#101;turns a list of the image formats t&#104;e plug&#105;n suppo&#114;ts. The <tt>form&#97;t</tt><a name="of the"></a> parameter o&#102; the <tt>capabilities()</tt> and <tt>create()</tt><a name="that list"></a> functi&#111;ns can be assumed to have a value fr&#111;m that list.</p>
<div class="docText"><pre>QStringList CursorPlugin::keys() const
{
    return QStringList() &lt;&lt; "cur";
}</pre></div><br />
<p class="docText"><a name="image format"></a>Our plugin supports only on&#101; image format, so it returns a list with just one name. Ideally, th&#101; na&#109;e should be t&#104;e file &#101;xt&#101;nsion used &#98;y the format. When dealing with fo&#114;mats with several extensions (suc&#104; as <tt>.jpg</tt> &#97;nd <tt>.jpeg</tt><a name="for the"></a> fo&#114; JPEG), we ca&#110; retu&#114;n a list with several entries fo&#114; the same format, one for each extension.</p>
<div class="docText"><pre>QImageIOPlugin::Capabilities
CursorPlugin::capabilities(QIODevice *device,
                           const QByteArray &amp;format) const
{
    if (format == "cur")
        return CanRead;

    if (format.isEmpty()) {
        CursorHandler handler;
        handler.setDevice(device);
        if (handler.canRead())
            return CanRead;
    }

    return 0;
}</pre></div><br />
<p class="docText">The <tt>c&#97;pabilities()</tt><a name="capable of"></a> function returns what the image ha&#110;dler is capable of doing with the given image format. There are &#116;hree cap&#97;bilities (<tt>&#67;anRead</tt>, <tt>Ca&#110;W&#114;ite</tt>, and <tt>C&#97;nReadIncremental</tt><a name="that apply"></a>), and the r&#101;turn value is a bitwise OR of t&#104;ose th&#97;t apply.</p>
<p class="docText"><a name="is "></a>If &#116;he format is &quot;cur&quot;, ou&#114; implementation re&#116;urns <tt>CanRead</tt><a name="format is"></a>. If no form&#97;t is given, we create a cursor handler and chec&#107; whether it is capable of reading the data from the gi&#118;en device. The <tt>canRead()</tt><a name="function only"></a> function only peeks at the d&#97;ta, seeing &#119;hether it re&#99;ognizes the &#102;ile, &#119;ithout changing t&#104;e file pointer. A capa&#98;ility of 0 means that the file cannot be read or &#119;ritten by th&#105;s handl&#101;r.</p>
<div class="docText"><pre>QImageIOHandler *CursorPlugin::create(QIODevice *device,
                                      const QByteArray &amp;format) const
{
    CursorHandler *handler = new CursorHandler;
    handler-&gt;setDevice(device);
    handler-&gt;setFormat(format);
    return handler;
}</pre></div><br />
<p class="docText"><a name="iddle1959"></a><a name="iddle1960"></a><a name="iddle2688"></a><a name="iddle3959"></a><a name="iddle4597"></a><a name="iddle5203"></a><a name="iddle7845"></a><a name="cursor file"></a>When a cu&#114;sor file is opened (&#101;.g., by <tt>QImageReader</tt><a name="plugin wrapper"></a>), the plug&#105;n wrapper's <tt>create()</tt><a name="with "></a> function will be called wi&#116;h the device pointer and with &quot;cur&quot; as the format. We creat&#101; a <tt>CursorHandler</tt><a name="with the"></a> instance and set it up with t&#104;e spec&#105;fied de&#118;ice and for&#109;at. The calle&#114; takes own&#101;rship of the hand&#108;er and will delete it when it is no long&#101;r r&#101;qu&#105;red. If multiple fi&#108;es are to be read, a f&#114;esh handler will be created &#102;or each one.</p>
<div class="docText"><pre>Q_EXPORT_PLUGIN2(cursorplugin, CursorPlugin)</pre></div><br />
<p class="docText">At the end of the <tt>.cpp</tt> file, we us&#101; the <tt>Q_EXPORT_PLUGIN2()</tt><a name="parameter is"></a> macro to ensure that Qt recog&#110;izes the plugin. The first parameter is an a&#114;bitra&#114;y name &#116;hat we wa&#110;t &#116;o give to the plugi&#110;. The second &#112;arameter is the plugin class name.</p>
<p class="docText">Subclassi&#110;g <tt>&#81;Im&#97;geIOPlugin</tt><a name="is done"></a> is str&#97;ightforward. The rea&#108; work of the plugin is done in &#116;he handler. Image format handlers must subcl&#97;ss <tt>QImageIOHandler</tt><a name="the header"></a> and reimpl&#101;ment some or all of its public functions. Let's star&#116; with the &#104;eader:</p>
<div class="docText"><pre>class CursorHandler : public QImageIOHandler
{
public:
    CursorHandler();

    bool canRead() const;
    bool read(QImage *image);
    bool jumpToNextImage();
    int currentImageNumber() const;
    int imageCount() const;

private:
    enum State { BeforeHeader, BeforeImage, AfterLastImage, Error };

    void readHeaderIfNecessary() const;
    QBitArray readBitmap(int width, int height, QDataStream &amp;in) const;
    void enterErrorState() const;

    mutable State state;
    mutable int currentImageNo;
    mutable int numImages;
};</pre></div><br />
<p class="docText"><a name="all the"></a>&#84;he sig&#110;a&#116;ures of all the publi&#99; functions are fixed. W&#101; have omitted several functions that w&#101; do&#110;'t &#110;eed t&#111; reimpleme&#110;t for a read-only handler, i&#110; particular <tt>write()</tt><a name="variables are"></a>. The member variables a&#114;e declared with the <tt>mutable</tt><a name="keyword because"></a> keyword because they ar&#101; modified inside const functions.</p>
<div class="docText"><pre>CursorHandler::CursorHandler()
{
    state = BeforeHeader;
    currentImageNo = 0;
    numImages = 0;
}</pre></div><br />
<p class="docText"><a name="iddle1468"></a><a name="iddle1947"></a><a name="iddle1961"></a><a name="iddle1962"></a><a name="iddle1964"></a><a name="iddle1966"></a><a name="iddle3156"></a><a name="iddle4294"></a><a name="iddle5204"></a><a name="iddle5205"></a><a name="iddle5206"></a><a name="iddle5208"></a><a name="iddle5235"></a><a name="iddle6751"></a><a name="handler is"></a>&#87;hen the ha&#110;d&#108;er is const&#114;ucted, &#119;e begin by setting its &#115;tate. We set the current cur&#115;or image number to the first cursor, but s&#105;nce we s&#101;t <tt>n&#117;mImages</tt><a name="it is"></a> to 0 it &#105;s clear that we ha&#118;e no images yet.</p>
<div class="docText"><pre>bool CursorHandler::canRead() const
{
    if (state == BeforeHeader) {
        return device()-&gt;peek(4) == QByteArray("\0\0\2\0", 4);
    } else {
        return state != Error;
    }
}</pre></div><br />
<p class="docText">The <tt>canRead()</tt><a name="whether the"></a> &#102;unction can be called at any time to de&#116;ermine whether the image handler can read more dat&#97; from the device. If the function is called before we have read any &#100;a&#116;a, while w&#101; ar&#101; st&#105;ll in the <tt>Be&#102;oreHeader</tt><a name="signature that"></a> s&#116;ate, we check for the particular s&#105;gnatur&#101; th&#97;t identifies Wind&#111;ws cursor files. &#84;he <tt>QIODevice::peek()</tt> call reads the fi&#114;st four bytes <span class="docEmphasis">without</span> changing the devi&#99;e's file pointer. If <tt>canRead()</tt> is called later on, we r&#101;turn <tt>true</tt> unless an error has occurred.</p>
<div class="docText"><pre>int CursorHandler::currentImageNumber() const
{
    return currentImageNo;
}</pre></div><br />
<p class="docText"><a name="at which"></a>This tri&#118;ial functi&#111;n r&#101;tu&#114;ns the &#110;umber of the cu&#114;sor at which the device file &#112;ointer is positioned.</p>
<p class="docText"><a name="for the"></a>Once the handler is const&#114;ucted, &#105;t is pos&#115;ible for the us&#101;r to ca&#108;l any of its public functions, in a&#110;y order. This is a pote&#110;tial problem since we must assume that we can only rea&#100; serially, so we need to read the file header on&#99;e before doi&#110;g &#97;nything e&#108;se. We solve &#116;he problem b&#121; calling the <tt>readHeaderI&#102;Necessary()</tt><a name="been read"></a> function in t&#104;ose fu&#110;c&#116;ions that depend o&#110; the head&#101;r having been read.</p>
<div class="docText"><pre>int CursorHandler::imageCount() const
{
    readHeaderIfNecessary();
    return numImages;
}</pre></div><br />
<p class="docText"><a name="the number"></a>This funct&#105;on returns the number of images in the f&#105;le. For a valid file where no reading errors have &#111;ccurred, it will return a count of at least 1.</p>
<p class="docText"><a name="function is"></a>The next &#102;unc&#116;ion is qu&#105;te invo&#108;ved, so we wi&#108;l review it in piece&#115;:</p>
<div class="docText"><pre>bool CursorHandler::read(QImage *image)
{
    readHeaderIfNecessary();

    if (state != BeforeImage)
        return false;</pre></div><br />
<p class="docText"><a name="The"></a>The <tt>read()</tt><a name="the data"></a> function re&#97;ds the data for whichever image begins at th&#101; cu&#114;rent d&#101;vice pointer po&#115;ition. If the &#102;ile's header is read successful&#108;y, or after an image <a name="iddle1449"></a><a name="iddle1933"></a><a name="iddle2403"></a><a name="iddle4879"></a><a name="iddle4893"></a><a name="iddle4898"></a><a name="iddle7136"></a><a name="iddle7515"></a><a name="iddle8425"></a><a name="been read"></a>has been read and t&#104;e device pointer is at the start of another image, we can re&#97;d the next image.</p>
<div class="docText"><pre>    quint32 size;
    quint32 width;
    quint32 height;
    quint16 numPlanes;
    quint16 bitsPerPixel;
    quint32 compression;

    QDataStream in(device());
    in.setByteOrder(QDataStream::LittleEndian);
    in &gt;&gt; size;
    if (size != 40) {
        enterErrorState();
        return false;
    }
    in &gt;&gt; width &gt;&gt; height &gt;&gt; numPlanes &gt;&gt; bitsPerPixel &gt;&gt; compression;
    height /= 2;

    if (numPlanes != 1 || bitsPerPixel != 1 || compression != 0) {
        enterErrorState();
        return false;
    }

    in.skipRawData((size - 20) + 8);</pre></div><br />
<p class="docText">We create a <tt>QDataStream</tt><a name="to match"></a> to read the device. We must &#115;et the b&#121;te &#111;rd&#101;r t&#111; match that s&#112;ecified by the <tt>.cur</tt><a name="need to"></a> fi&#108;e format specification. There is &#110;o &#110;e&#101;d to se&#116; a <tt>QDataStream</tt><a name="does not"></a> ver&#115;ion number since the format of &#105;ntegers and floating-point numbers do&#101;s not vary between data stream versions. Ne&#120;t, we read in various items of cursor header data, and we s&#107;ip the irr&#101;le&#118;ant parts o&#102; the &#104;eader and the 8-byt&#101; color table using <tt>QDat&#97;Stream::skipRawData()</tt>.</p>
<p class="docText"><a name="iddle1206"></a><a name="iddle1333"></a><a name="iddle1800"></a><a name="iddle4782"></a><a name="iddle4785"></a><a name="the height"></a>We must account for all th&#101; fo&#114;mat's i&#100;iosy&#110;crasies—&#102;or example, halving the heigh&#116; because the <tt>.cur</tt><a name="the actual"></a> format gives a height that is tw&#105;ce as high as the actual image's height. The <tt>b&#105;tsPerPixel</tt> and <tt>compression</tt><a name="and "></a> values are always 1 and 0 in a monochrome <tt>.cur</tt><a name="have any"></a> file. If &#119;e have any pr&#111;bl&#101;ms, &#119;e call <tt>enter&#69;rrorState()</tt><a name="and return"></a> and &#114;eturn <tt>false</tt>.</p>
<div class="docText"><pre>    QBitArray xorBitmap = readBitmap(width, height, in);
    QBitArray andBitmap = readBitmap(width, height, in);

    if (in.status() != QDataStream::Ok) {
        enterErrorState();
        return false;
    }</pre></div><br />
<p class="docText"><a name="items in"></a>Th&#101; next items in the file are two b&#105;tmaps, o&#110;e &#97;n XOR mask and the oth&#101;r an A&#78;D mask. We read these into <tt>QBitArray</tt><a name="rather than"></a>s ra&#116;her than into <tt>QBitmap</tt>s. A <tt>QBitmap</tt><a name="painted on"></a> is a class des&#105;gned to be drawn on and painted on-screen, &#98;ut what we need here is a plain array of bits.</p>
<p class="docText"><a name="reading the"></a>When we are done &#119;ith reading &#116;he file, w&#101; ch&#101;ck &#116;he <tt>QDataStrea&#109;</tt>'s status. This works beca&#117;se if a <tt>QDataStream</tt><a name="can only"></a> enters an error st&#97;te, it stay&#115; in that &#115;tate and c&#97;n only return zeros. F&#111;r example, if reading &#102;ails on the first bit array, the attempt to &#114;ead the second will result in an empty <tt>QBitArray</tt>.</p>
<div class="docText"><pre>    *image = QImage(width, height, QImage::Format_ARGB32);

    for (int i = 0; i &lt; int(height); ++i) {
        for (int j = 0; j &lt; int(width); ++j) {
            QRgb color;
            int bit = (i * width) + j;

            if (andBitmap.testBit(bit)) {
                if (xorBitmap.testBit(bit)) {
                    color = 0x7F7F7F7F;
                } else {
                    color = 0x00FFFFFF;
                }
            } else {
                if (xorBitmap.testBit(bit)) {
                    color = 0xFFFFFFFF;
                } else {
                    color = 0xFF000000;
                }
            }
            image-&gt;setPixel(j, i, color);
        }
    }</pre></div><br />
<p class="docText">&#87;e construct a new <tt>QImage</tt><a name="to"></a> of the correct size and assign it to <tt>*im&#97;ge</tt><a name="AND bit"></a>. Then we &#105;terate &#111;ve&#114; every &#112;ixel in the XOR a&#110;d AND bit arrays a&#110;d convert them into 32-bit ARGB color s&#112;eci&#102;ica&#116;ions. The AND and X&#79;R bit arrays are used as &#115;hown in the following table to obt&#97;in the color of each cursor pixel:</p>
<p><table cellspacing="0" class="allBorders" border="1"><colgroup align="left" span="3"><col width="50" /><col width="50" /><col width="180" /></colgroup><thead><tr><th scope="col" class="docTableCell thead" align="center" valign="top" style="background-color:#E6E6E6"><a name="iddle1965"></a><a name="iddle1968"></a><a name="iddle3407"></a><a name="iddle5207"></a><a name="iddle6769"></a>&#65;ND</th><th scope="col" class="docTableCell thead" align="center" valign="top" style="background-color:#E6E6E6">XOR</th><th scope="col" class="docTableCell thead" align="left" valign="top" style="background-color:#E6E6E6">Result</th></tr></thead><tr><td class="docTableCell" align="center" valign="top"><span class="docEmphRomanAlt">1</span></td><td class="docTableCell" align="center" valign="top"><span class="docEmphRomanAlt">1</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">Inverted background pixel</span></td></tr><tr><td class="docTableCell" align="center" valign="top"><span class="docEmphRomanAlt">1</span></td><td class="docTableCell" align="center" valign="top"><span class="docEmphRomanAlt">0</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">Transpare&#110;t pixel</span></td></tr><tr><td class="docTableCell" align="center" valign="top"><span class="docEmphRomanAlt">0</span></td><td class="docTableCell" align="center" valign="top"><span class="docEmphRomanAlt">1</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">White pixel</span></td></tr><tr><td class="docTableCell" align="center" valign="top"><span class="docEmphRomanAlt">0</span></td><td class="docTableCell" align="center" valign="top"><span class="docEmphRomanAlt">0</span></td><td class="docTableCell" align="left" valign="top"><span class="docEmphRomanAlt">Black pixel</span></td></tr></table></p><br />
<p class="docText"><a name="are no"></a>Black, white, and t&#114;anspa&#114;ent pi&#120;e&#108;s are no pro&#98;lem, but there is no &#119;ay to obtain an inverted b&#97;ckground pixel using an ARGB colo&#114; speci&#102;ica&#116;ion without &#107;nowing the co&#108;or of the original background pixe&#108;. As a substitute, we use a semi-transpar&#101;nt gray color (<tt>0x7F7F7F7F</tt>).</p>
<div class="docText"><pre>    ++currentImageNo;
    if (currentImageNo == numImages)
        state = AfterLastImage;
    return true;
}</pre></div><br />
<p class="docText"><a name="have finished"></a>Once we have finished &#114;eading the image, we update the current image number a&#110;d &#117;pdate the &#115;tate if &#119;e have reach&#101;d the last &#105;mage. At that point, the devi&#99;e will be positioned at the next image or at the end o&#102; the &#102;ile.</p>
<div class="docText"><pre>bool CursorHandler::jumpToNextImage()
{
    QImage image;
    return read(&amp;image);
}</pre></div><br />
<p class="docText"><a name="The"></a>&#84;he <tt>jumpToN&#101;xtImage()</tt><a name="used to"></a> &#102;unction is used to sk&#105;p an image. For simplicity, we simply call <tt>rea&#100;()</tt><a name="ignore the"></a> and ignore the resulting <tt>QImage</tt><a name="in the"></a>. A m&#111;re efficient implementation would u&#115;e the in&#102;orm&#97;tion stor&#101;d i&#110; the <tt>.cur</tt><a name="to the"></a> f&#105;le header to sk&#105;p directly to the appropriate offset in the fi&#108;e.</p>
<div class="docText"><pre>void CursorHandler::readHeaderIfNecessary() const
{
    if (state != BeforeHeader)
        return;

    quint16 reserved;
    quint16 type;
    quint16 count;

    QDataStream in(device());
    in.setByteOrder(QDataStream::LittleEndian);

    in &gt;&gt; reserved &gt;&gt; type &gt;&gt; count;
    in.skipRawData(16 * count);

    if (in.status() != QDataStream::Ok || reserved != 0
            || type != 2 || count == 0) {
        enterErrorState();
        return;
    }
        state = BeforeImage;
        currentImageNo = 0;
        numImages = int(count);
    }</pre></div><br />
<p class="docText"><a name="iddle1963"></a><a name="iddle1967"></a><a name="iddle2412"></a><a name="iddle4783"></a><a name="iddle6759"></a><a name="iddle7133"></a>The <tt>readH&#101;ad&#101;rIfNec&#101;ssary()</tt> privat&#101; function is called from <tt>im&#97;geCount()</tt> and <tt>read()</tt><a name="not"></a>. If the file's header &#104;as already been read, the state &#105;s not <tt>BeforeHeader</tt><a name="stream on"></a> and we return immedi&#97;tely. Othe&#114;wise, w&#101; op&#101;n a &#100;ata stream &#111;n the device, read in som&#101; generic data (including the n&#117;mber of cu&#114;sors i&#110; the file), &#97;nd set the state to <tt>&#66;eforeImage</tt>. At the end, the devic&#101;'s file pointer is positioned before the f&#105;rst image.</p>
<div class="docText"><pre>void CursorHandler::enterErrorState() const
{
    state = Error;
    currentImageNo = 0;
    numImages = 0;
}</pre></div><br />
<p class="docText"><a name="images and"></a>If an error occurs, we assume th&#97;t there are no valid images and set the state to <tt>Error</tt>. Onc&#101; in &#116;he <tt>Error</tt> &#115;tate, th&#101; ha&#110;dler's state c&#97;nnot change.</p>
<div class="docText"><div class="codeSegmentsExpansionLinks">
              Code View:</div><pre class="">QBitArray CursorHandler::readBitmap(int width, int height,
                                    QDataStream &amp;in) const
{
    QBitArray bitmap(width * height);
    quint32 word = 0;
    quint8 byte;

    for (int i = 0; i &lt; height; ++i) {
        for (int j = 0; j &lt; width; ++j) {
            if ((j % 32) == 0) {
                word = 0;
                for (int k = 0; k &lt; 4; ++k) {
                    in &gt;&gt; byte;
                    word = (word &lt;&lt; 8) | byte;
                }
            }

            bitmap.setBit(((height - i - 1) * width) + j,
                          word &amp; 0x80000000);
            word &lt;&lt;= 1;
        }
    }
    return bitmap;
}

					  </pre></div><br />
<p class="docText">The <tt>readBi&#116;map()</tt><a name="to read"></a> function is used to read a cursor'&#115; AND and &#88;OR masks. Th&#101;se masks have tw&#111; unusual feat&#117;res. First, they store the ro&#119;s from bottom to top, instead of the more common t&#111;p-to-bottom approach. Second, t&#104;e endianness of the data appears to be reversed from that used &#101;ve&#114;ywher&#101; el&#115;e in <tt>.cur</tt><a name="of this"></a> &#102;iles. In view &#111;f this, we must invert &#116;he <span class="docEmphasis">y</span><a name="in the"></a>-coordinate in the <tt>setB&#105;t()</tt><a name="read in"></a> call, a&#110;d &#119;e read in the mask values o&#110;e byte at a tim&#101;, bit-shifting and masking to e&#120;tract their correct values.</p>
<p class="docText"><a name="iddle2113"></a><a name="iddle2627"></a><a name="iddle3257"></a><a name="iddle4362"></a><a name="iddle4481"></a><a name="iddle4566"></a><a name="iddle4583"></a><a name="iddle8001"></a><a name="iddle8003"></a><a name="iddle8453"></a><a name="iddle8458"></a><a name="build the"></a>T&#111; build the plugin, we must use a <tt>.pro</tt><a name="used for"></a> file that is ve&#114;y similar to the one we used for the Bronze st&#121;le &#112;lug&#105;n shown &#101;ar&#108;ier (p. <a class="docLink" href="#page_493">493</a>):</p>
<div class="docText"><pre>TEMPLATE      = lib
CONFIG       += plugin
HEADERS       = cursorhandler.h \
                cursorplugin.h
SOURCES       = cursorhandler.cpp \
                cursorplugin.cpp
DESTDIR       = $$[QT_INSTALL_PLUGINS]/imageformats</pre></div><br />
<p class="docText"><a name="Plugins for"></a>This comp&#108;etes the Windows &#99;ursor plugin. Plugins for other image fo&#114;mats w&#111;ul&#100; foll&#111;w the same &#112;attern, although some &#109;ight implement more of the <tt>QImageIOHandler</tt><a name="other kinds"></a> A&#80;I, in particular the functions used for writing &#105;mages. Plugins of other kinds follow the patt&#101;rn &#111;f h&#97;ving a plu&#103;in wr&#97;pper that exp&#111;rts one or seve&#114;al handlers that provide the u&#110;d&#101;rl&#121;ing func&#116;ionality.</p>

</div></div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch21.html><img src="images/prev.gif" width="20" height="20" border="0" align="absmiddle" alt="Previous Page"></a>
<a href=ch21lev1sec2.html><img src="images/next.gif" width="20" height="20" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>