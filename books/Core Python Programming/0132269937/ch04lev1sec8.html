<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 4.8.&nbsp; Categorizing the Standard Types</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch04lev1sec7.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch04lev1sec9.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a name="ch04lev1sec8"></a>
<h3 id="title-IDA4X1KN" class="docSection1Title">4.8. Categorizing the Standard Types</H3>
<p class="docText">If we were to be maximally verbose in describing the standard types, we would probably call them something like Python's &quot;basic built-in data object primitive types.&quot;</p>
<UL><LI><p class="docList">&quot;Basic,&quot; indicating that these are the standard or core types that Python provides</P></LI><li><p class="docList">&quot;Built-in,&quot; due to the fact that these types come by default in Python</p></li><LI><p class="docList">&quot;Data,&quot; because they are used for general data storage</p></LI><li><p class="docList">&quot;Object,&quot; because objects are the default abstraction for data and functionality</P></li><LI><p class="docList"><a name="iddle1145"></a><a name="iddle1490"></a><a name="iddle1493"></a><a name="iddle1523"></a><a name="iddle3176"></a><a name="iddle3677"></a><a name="iddle3941"></a><a name="iddle3973"></a>&quot;Primitive,&quot; because these types provide the lowest-level granularity of data storage</P></li><li><p class="docList">&quot;Types,&quot; because that's what they are: data types!</p></li></UL>
<p class="docText">However, this description does not really give you an idea of how each type works or what functionality applies to them. Indeed, some of them share certain characteristics, such as how they function, and others share commonality with regard to how their data values are accessed. We should also be interested in whether the data that some of these types hold can be updated and what kind of storage they provide.</p>
<p class="docText">There are three different models we have come up with to help categorize the standard types, with each model showing us the interrelationships between the types. These models help us obtain a better understanding of how the types are related, as well as how they work.</p>
<a name="ch04lev2sec18"></a>
<H4 id="title-IDAV01KN" class="docSection2Title">4.8.1. Storage Model</h4>
<p class="docText">The first way we can categorize the types is by how many objects can be stored in an object of this type. Python's types, as well as types from most other languages, can hold either single or multiple values. A type which holds a single literal object we will call <span class="docEmphasis">atomic</span> or <span class="docEmphasis">scalar</span> storage, and those which can hold multiple objects we will refer to as <span class="docEmphasis">container</span> storage. (Container objects are also referred to as <span class="docEmphasis">composite</span> or <span class="docEmphasis">compound</span> objects in the documentation, but some of these refer to objects other than types, such as class instances.) Container types bring up the additional issue of whether different types of objects can be stored. All of Python's container types can hold objects of different types. <a class="docLink" href="#ch04table06">Table 4.6</a> categorizes Python's types by storage model.</p>
<a name="ch04table06"></a><p><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 4.6. Types Categorized by the Storage Model</H5></caption><colgroup align="left" span="2"><col width="100"><col width="400"></colgroup><thead><tr><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Storage Model Category</span></p></th><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Python Types That Fit Category</span></p></th></tr></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText">Scalar/atom</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Numbers (all numeric types), strings (all are literals)</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText">Container</P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Lists, tuples, dictionaries</p></TD></tr></table></P><BR>
<p class="docText">Although strings may seem like a container type since they &quot;contain&quot; characters (and usually more than one character), they are not considered as such <a name="iddle2337"></a><a name="iddle2357"></a><a name="iddle3013"></a><a name="iddle3196"></a><a name="iddle3943"></a><a name="iddle4371"></a>because Python does not have a character type (see <a class="docLink" href="#ch04lev1sec8">Section 4.8</a>). Thus strings are self-contained literals.</P>

<a name="ch04lev2sec19"></a>
<H4 id="title-IDAI51KN" class="docSection2Title">4.8.2. Update Model</h4>
<p class="docText">Another way of categorizing the standard types is by asking the question, &quot;Once created, can objects be changed, or can their values be updated?&quot; When we introduced Python types early on, we indicated that certain types allow their values to be updated and others do not. <span class="docEmphasis">Mutable</span> objects are those whose values can be changed, and <span class="docEmphasis">immutable</span> objects are those whose values cannot be changed. <a class="docLink" href="#ch04table07">Table 4.7</a> illustrates which types support updates and which do not.</p>
<a name="ch04table07"></a><p><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 4.7. Types Categorized by the Update Model</h5></caption><colgroup align="left" span="2"><col width="150"><col width="300"></colgroup><thead><TR><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Update Model Category</span></p></th><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Python Types That Fit Category</span></P></th></tr></thead><TR><TD class="docTableCell" align="left" valign="top"><p class="docText">Mutable</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Lists, dictionaries</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText">Immutable</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Numbers, strings, tuples</P></TD></tr></table></p><br>
<p class="docText">Now after looking at the table, a thought that must immediately come to mind is, &quot;Wait a minute! What do you mean that numbers and strings are immutable? I've done things like the following&quot;:</p>
<div class="docText"><pre>x = 'Python numbers and strings'
x = 'are immutable?!? What gives?'
i = 0
i = i + 1</pre></div><br>
<p class="docText">&quot;They sure as heck don't look immutable to me!&quot; That is true to some degree, but looks can be deceiving. What is really happening behind the scenes is that the original objects are actually being replaced in the above examples. Yes, that is right. Read that again.</p>
<p class="docText">Rather than referring to the original objects, new objects with the new values were allocated and (re)assigned to the original variable names, and the old objects were garbage-collected. One can confirm this by using the <tt>id()</tt> BIF to compare object identities before and after such assignments.</p>
<p class="docText"><a name="iddle2338"></a>If we added calls to <tt>id()</tt> in our example above, we may be able to see that the objects are being changed, as below:</p>
<div class="docText"><pre>&gt;&gt;&gt; x = 'Python numbers and strings'
&gt;&gt;&gt; <span class="docEmphStrong">print</span> id(x)
16191392
&gt;&gt;&gt; x = 'are immutable?!? What gives?'
&gt;&gt;&gt; <span class="docEmphStrong">print</span> id(x)
16191232
&gt;&gt;&gt; i = 0
&gt;&gt;&gt; <span class="docEmphStrong">print</span> id(i)
7749552
&gt;&gt;&gt; i = i + 1
&gt;&gt;&gt; <span class="docEmphStrong">print</span> id(i)
7749600</pre></div><br>
<p class="docText">Your mileage will vary with regard to the object IDs as they will differ between executions. On the flip side, lists can be modified without replacing the original object, as illustrated in the code below:</p>
<div class="docText"><pre>&gt;&gt;&gt; aList = ['ammonia', 83, 85, 'lady']
&gt;&gt;&gt; aList
['ammonia', 83, 85, 'lady']
&gt;&gt;&gt;
&gt;&gt;&gt; aList[2]
85
&gt;&gt;&gt;
&gt;&gt;&gt; id(aList)
135443480
&gt;&gt;&gt;
&gt;&gt;&gt; aList[2] = aList[2] + 1
&gt;&gt;&gt; aList[3] = 'stereo'
&gt;&gt;&gt; aList
['ammonia', 83, 86, 'stereo']
&gt;&gt;&gt;
&gt;&gt;&gt; id(aList)
135443480
&gt;&gt;&gt;
&gt;&gt;&gt; aList.append('gaudy')
&gt;&gt;&gt; aList.append(aList[2] + 1)
&gt;&gt;&gt; aList
['ammonia', 83, 86, 'stereo', 'gaudy', 87]
&gt;&gt;&gt;
&gt;&gt;&gt; id(aList)
135443480</pre></div><br>
<p class="docText">Notice how for each change, the ID for the list remained the same.</p>

<a name="ch04lev2sec20"></a>

<H4 id="title-IDAOE2KN" class="docSection2Title">4.8.3. Access Model</h4>
<p class="docText"><a name="iddle1050"></a><a name="iddle1715"></a><a name="iddle2775"></a><a name="iddle3720"></a><a name="iddle3938"></a>Although the previous two models of categorizing the types are useful when being introduced to Python, they are not the primary models for differentiating the types. For that purpose, we use the access model. By this, we mean, how do we access the values of our stored data? There are three categories under the access model: <span class="docEmphasis">direct</span>, <span class="docEmphasis">sequence</span>, and <span class="docEmphasis">mapping</span>. The different access models and which types fall into each respective category are given in <a class="docLink" href="#ch04table08">Table 4.8</a>.</P>
<a name="ch04table08"></a><p><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 4.8. Types Categorized by the Access Model</h5></caption><colgroup align="left" span="2"><col width="200"><col width="200"></colgroup><thead><TR><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Access Model Category</span></p></th><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Types That Fit Category</span></P></th></TR></thead><TR><TD class="docTableCell" align="left" valign="top"><p class="docText">Direct</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Numbers</P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText">Sequence</p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Strings, lists, tuples</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText">Mapping</p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Dictionaries</p></td></tr></table></P><BR>
<p class="docText">Direct types indicate single-element, non-container types. All numeric types fit into this category.</p>
<p class="docText">Sequence types are those whose elements are sequentially accessible via index values starting at 0. Accessed items can be either single elements or in groups, better known as slices. Types that fall into this category include strings, lists, and tuples. As we mentioned before, Python does not support a character type, so, although strings are literals, they are a sequence type because of the ability to access substrings sequentially.</p>
<p class="docText">Mapping types are similar to the indexing properties of sequences, except instead of indexing on a sequential numeric offset, elements (values) are unordered and accessed with a key, thus making mapping types a set of hashed key-value pairs.</p>
<p class="docText">We will use this primary model in the next chapter by presenting each access model type and what all types in that category have in common (such as operators and BIFs), then discussing each Python standard type that fits into those categories. Any operators, BIFs, and methods unique to a specific type will be highlighted in their respective sections.</p>
<p class="docText">So why this side trip to view the same data types from differing perspectives? Well, first of all, why categorize at all? Because of the high-level data structures that Python provides, we need to differentiate the &quot;primitive&quot; types from those that provide more functionality. Another reason is to be clear on what the expected behavior of a type should be. For example, if we minimize the number of times we ask ourselves, &quot;What are the differences <a name="iddle1252"></a><a name="iddle1322"></a><a name="iddle3942"></a><a name="iddle3974"></a><a name="iddle4294"></a><a name="iddle4372"></a>between lists and tuples again?&quot; or &quot;What types are immutable and which are not?&quot; then we have done our job. And finally, certain categories have general characteristics that apply to all types in a certain category. A good craftsman (and craftswoman) should know what is available in his or her toolboxes.</p>
<p class="docText">The second part of our inquiry asks, &quot;Why all these different models or perspectives&quot;? It seems that there is no one way of classifying all of the data types. They all have crossed relationships with each other, and we feel it best to expose the different sets of relationships shared by all the types. We also want to show how each type is unique in its own right. No two types map the same across all categories. (Of course, all numeric subtypes do, so we are categorizing them together.) Finally, we believe that understanding all these relationships will ultimately play an important implicit role during development. The more you know about each type, the more you are apt to use the correct ones in the parts of your application where they are the most appropriate, and where you can maximize performance.</p>
<p class="docText">We summarize by presenting a cross-reference chart (see <a class="docLink" href="#ch04table09">Table 4.9</a>) that shows all the standard types, the three different models we use for categorization, and where each type fits into these models.</p>
<a name="ch04table09"></a><p><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 4.9. Categorizing the Standard Types</h5></caption><colgroup align="left" span="4"><col width="100"><col width="100"><col width="100"><col width="100"></colgroup><thead><tr><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Data Type</span></p></th><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Storage Model</span></P></th><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Update Model</span></p></th><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Access Model</span></P></th></tr></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText">Numbers</P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Scalar</P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Immutable</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Direct</P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText">Strings</p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Scalar</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Immutable</p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Sequence</p></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">Lists</P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Container</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Mutable</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Sequence</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">Tuples</P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Container</p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Immutable</P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Sequence</P></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText">Dictionaries</p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Container</P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Mutable</p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Mapping</p></td></tr></table></p><BR>


</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch04lev1sec7.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch04lev1sec9.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>