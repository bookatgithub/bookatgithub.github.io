<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 6.1.&nbsp; Sequences</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch06.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch06lev1sec2.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a href="14051536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a><a name="ch06lev1sec1"></a>

<h3 id="title-IDARU5OB" class="docSection1Title">6.1. Sequences</H3>
<p class="docText"><a name="iddle2824"></a><a name="iddle2828"></a><a name="iddle3270"></a><a name="iddle3295"></a><a name="iddle3731"></a><a name="iddle3735"></a><a name="iddle3746"></a><a name="iddle3931"></a>Sequence types all share the same access model: ordered set with sequentially indexed offsets to get to each element. Multiple elements may be selected by using the slice operators, which we will explore in this chapter. The numbering scheme used starts from zero (0) and ends with one less than the length of the sequencethe reason for this is because we began at 0. <a class="docLink" href="#ch06fig01">Figure 6-1</a> illustrates how sequence items are stored.</p>
<a name="ch06fig01"></a><P><center>

<H5 class="docFigureTitle">Figure 6.1. How sequence elements are stored and accessed</H5>

<p class="docText">
<img border="0" alt="" width="400" height="107" SRC="images/chun_fig06_01.jpg"></P>


</center></p><br>
<a name="ch06lev2sec1"></a>
<h4 id="title-IDARX5OB" class="docSection2Title">6.1.1. Standard Type Operators</H4>
<p class="docText">The standard type operators (see <a class="docLink" href="ch04lev1sec5.html#ch04lev1sec5">Section 4.5</a>) generally work with all sequence types. Of course, one must comparisons with a grain of salt when dealing with objects of mixed types, but the remaining operations will work as advertised.</p>

<a name="ch06lev2sec2"></a>
<H4 id="title-IDAIY5OB" class="docSection2Title">6.1.2. Sequence Type Operators</h4>
<p class="docText">A list of all the operators applicable to all sequence types is given in <a class="docLink" href="#ch06table01">Table 6.1</a>. The operators appear in hierarchical order from highest to lowest with the levels alternating between shaded and not.</P>
<a name="ch06table01"></a><p><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 6.1. Sequence Type Operators</H5></caption><colgroup align="left" span="2"><col width="170"><col width="290"></colgroup><thead><tr><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Sequence Operator</span></p></th><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Function</span></p></th></tr></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>seq</tt></span><tt>[</tt><span class="docEmphasis"><tt>ind</tt></span><tt>]</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Element located at index <span class="docEmphasis"><tt>ind</tt></span> of <span class="docEmphasis"><tt>seq</tt></span></p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>seq</tt></span><tt>[</tt><span class="docEmphasis"><tt>ind1</tt></span> <tt>:</tt> <span class="docEmphasis"><tt>ind2</tt></span><tt>]</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Elements from <span class="docEmphasis"><tt>ind1</tt></span> up to but not including <span class="docEmphasis"><tt>ind2</tt></span> of <span class="docEmphasis"><tt>seq</tt></span></p></td></tr><tr><td class="docTableCell" align="left" valign="top" style="background-color:#DDDDDD"><p class="docText"><span class="docEmphasis"><tt>seq</tt></span> <tt>*</tt> <span class="docEmphasis"><tt>expr</tt></span></p></td><td class="docTableCell" align="left" valign="top" style="background-color:#DDDDDD"><p class="docText"><span class="docEmphasis"><tt>seq</tt></span> repeated <span class="docEmphasis"><tt>expr</tt></span> times</P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>seq1</tt></span> <tt>+</tt> <span class="docEmphasis"><tt>seq2</tt></span></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Concatenates sequences <span class="docEmphasis"><tt>seq1</tt></span> and <span class="docEmphasis"><tt>seq2</tt></span></P></TD></TR><TR><td class="docTableCell" align="left" valign="top" style="background-color:#DDDDDD"><p class="docText"><span class="docEmphasis"><tt>obj</tt></span> <span class="docEmphStrong"><tt>in</tt></span> <span class="docEmphasis"><tt>seq</tt></span></p></td><TD class="docTableCell" align="left" valign="top" style="background-color:#DDDDDD"><p class="docText">Tests if <span class="docEmphasis"><tt>obj</tt></span> is a member of sequence <span class="docEmphasis"><tt>seq</tt></span></p></TD></tr><TR><td class="docTableCell" align="left" valign="top" style="background-color:#DDDDDD"><p class="docText"><span class="docEmphasis"><tt>obj</tt></span> <span class="docEmphStrong">not in</span> <span class="docEmphasis"><tt>seq</tt></span></P></TD><td class="docTableCell" align="left" valign="top" style="background-color:#DDDDDD"><p class="docText">Tests if <span class="docEmphasis"><tt>obj</tt></span> is not a member of sequence <span class="docEmphasis"><tt>seq</tt></span></p></td></tr></table></P><br>
<a name="ch06lev3sec1"></a>
<h5 id="title-IDAS55OB" class="docSection3Title">Membership (<tt>in, not in</tt>)</H5>
<p class="docText">Membership test operators are used to determine whether an element is <span class="docEmphasis">in</span> or is a member of a sequence. For strings, this test is whether a character is in a string, and for lists and tuples, it is whether an object is an element of those sequences. The <span class="docEmphStrong"><tt>in</tt></span> and <span class="docEmphStrong"><tt>not in</tt></span> operators are Boolean in nature; they return <tt>true</tt> if the membership is confirmed and <tt>False</tt> otherwise.</p>
<p class="docText">The syntax for using the membership operators is as follows:</p>
<div class="docText"><pre><span class="docEmphasis">obj</span> [<span class="docEmphStrong">not</span>] <span class="docEmphStrong">in</span> <span class="docEmphasis">sequence</span></pre></div><BR>

<a name="ch06lev3sec2"></a>

<H5 id="title-IDAIBAPB" class="docSection3Title">Concatenation (<tt>+</tt>)</h5>
<p class="docText"><a name="iddle1027"></a><a name="iddle1495"></a><a name="iddle2586"></a><a name="iddle3292"></a><a name="iddle3643"></a><a name="iddle3726"></a><a name="iddle3742"></a>This operation allows us to take one sequence and join it with another sequence of the same type. The syntax for using the concatenation operator is as follows:</p>
<div class="docText"><pre><span class="docEmphasis">sequence1</span> + <span class="docEmphasis">sequence2</span></pre></div><br>
<p class="docText">The resulting expression is a new sequence that contains the combined contents of sequences <span class="docEmphasis">sequence1</span> and <span class="docEmphasis">sequence2</span>. Note, however, that although this appears to be the simplest way conceptually to merge the contents of two sequences together, it is not the fastest or most efficient.</p>
<p class="docText">For strings, it is less memory-intensive to hold all of the substrings in a list or iterable and use one final <tt>join()</tt> string method call to merge them together. Similarly for lists, it is recommend that readers use the <tt>extend()</tt> list method instead of concatenating two or more lists together. Concatenation comes in handy when you need to merge two sequences together on the fly and cannot rely on mutable object built-in methods that do not have a return value (or more accurately, a return value of <tt>None</tt>). There is an example of this case in the section below on slicing.</p>

<a name="ch06lev3sec3"></a>
<h5 id="title-IDAHEAPB" class="docSection3Title">Repetition ( * )</h5>
<p class="docText">The repetition operator is useful when consecutive copies of sequence elements are desired. The syntax for using the repetition operator is as follows:</p>
<div class="docText"><pre><span class="docEmphasis">sequence * copies_int</span></pre></div><br>
<p class="docText"><a name="iddle3744"></a><a name="iddle3839"></a>The number of copies, <span class="docEmphasis"><tt>copies_int</tt></span>, must be an integer (prior to 1.6, long integers were not allowed). As with the concatenation operator, the object returned is newly allocated to hold the contents of the multiply replicated objects.</p>

<a name="ch06lev3sec4"></a>
<h5 id="title-IDAVFAPB" class="docSection3Title">Slices ( <tt>[ ], [ : ], [ : : ]</tt> )</h5>
<p class="docText">To put it simply: <span class="docEmphasis">sequences</span> are data structures that hold objects in an ordered manner. You can get access to individual elements with an index and pair of brackets, or a consecutive group of elements with the brackets and colons giving the indices of the elements you want starting from one index and going up to but not including the ending index.</P>
<p class="docText">Now we are going to explain exactly what we just said in full detail. Sequences are structured data types whose elements are placed sequentially in an ordered manner. This format allows for individual element access by index offset or by an index range of indices to select groups of sequential elements in a sequence. This type of access is called <span class="docEmphasis">slicing</span>, and the slicing operators allow us to perform such access.</p>
<p class="docText">The syntax for accessing an individual element is:</P>
<div class="docText"><pre><span class="docEmphasis">sequence[index]</span></pre></div><br>
<p class="docText"><span class="docEmphasis"><tt>sequence</tt></span> is the name of the sequence and <span class="docEmphasis"><tt>index</tt></span> is the offset into the sequence where the desired element is located. Index values can be positive, ranging from 0 to the maximum index (which is length of the sequence less one). Using the <tt>len()</tt> function (which we will formally introduce in the next section), this gives an index with the range <tt>0 &lt;=</tt> <span class="docEmphasis"><tt>index</tt></span> <tt>&lt;= len (</tt><span class="docEmphasis"><tt>sequence</tt></span><tt>)-1</tt>.</P>
<p class="docText">Alternatively, negative indexes can be used, ranging from -1 to the negative length of the sequence, <tt>-len(</tt><span class="docEmphasis"><tt>sequence</tt></span><tt>)</tt>, i.e., <tt>-len(</tt><span class="docEmphasis"><tt>sequence</tt></span><tt>) &lt;=</tt> <span class="docEmphasis"><tt>index</tt></span> <tt>&lt;= -1</tt>. The difference between the positive and negative indexes is that positive indexes start from the beginning of the sequences and negative indexes work backward from the end.</p>
<p class="docText">Attempting to retrieve a sequence element with an index outside of the length of the sequence results in an <tt>IndexError</tt> exception:</P>
<div class="docText"><pre>&gt;&gt;&gt; names = ('Faye', 'Leanna', 'Daylen')
&gt;&gt;&gt; <span class="docEmphStrong">print</span> names[4]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
IndexError: tuple index out of range</pre></div><br>
<p class="docText">Because Python is object oriented, you can also directly access an element of a sequence (without first having to assign it to a variable) like this:</P>
<div class="docText"><pre>&gt;&gt;&gt; <span class="docEmphStrong">print</span> ('Faye', 'Leanna', 'Daylen')[1]
Leanna</pre></div><BR>
<p class="docText">This comes in handy especially in cases where you have called a function and know that you are going to get back a sequence as a return value but are only interested in one or more elements and not the whole thing. So how do we select multiple elements?</P>
<p class="docText">Accessing a group of elements is similar to accessing just a single item. Starting and ending indexes may be given, separated by a colon ( <tt>:</tt> ). The syntax for accessing a group of elements is:</P>
<div class="docText"><pre><span class="docEmphasis">sequence</span>[<span class="docEmphasis">starting_index</span>:<span class="docEmphasis">ending_index</span>]</pre></div><br>
<p class="docText">Using this syntax, we can obtain a &quot;slice&quot; of elements in <span class="docEmphasis"><tt>sequence</tt></span> from the <span class="docEmphasis"><tt>starting_index</tt></span> up to but not including the element at the <span class="docEmphasis"><tt>ending_index</tt></span> index. Both <span class="docEmphasis"><tt>starting_index</tt></span> and <span class="docEmphasis"><tt>ending_index</tt></span> are optional, and if not provided, or if <tt>None</tt> is used as an index, the slice will go from the beginning of the sequence or until the end of the sequence, respectively.</p>
<p class="docText">In <a class="docLink" href="#ch06fig02">Figures 6-2</a> to <a class="docLink" href="#ch06fig06">6-6</a>, we take an entire sequence (of soccer players) of length 5, and explore how to take various slices of such a sequence.</p>
<a name="ch06fig02"></a><P><center>

<h5 class="docFigureTitle">Figure 6-2. Entire sequence:<tt>sequence</tt> or <tt>sequence[:]</tt></H5>

<p class="docText">
<img border="0" alt="" width="400" height="225" SRC="images/chun_fig06_02.jpg"></p>


</center></P><br>
<a name="ch06fig03"></a><P><center>

<H5 class="docFigureTitle">Figure 6-3. Sequence slice: <tt>sequence[0:3]</tt> or <tt>sequence[:3]</tt></h5>

<p class="docText">
<img border="0" alt="" width="400" height="225" SRC="images/chun_fig06_03.jpg"></p>


</center></p><br>
<a name="ch06fig04"></a><P><center>

<h5 class="docFigureTitle">Figure 6-4. Sequence slice: <tt>sequence[2:5]</tt> or <tt>sequence[2:]</tt></h5>

<p class="docText">
<img border="0" alt="" width="400" height="225" SRC="images/chun_fig06_04.jpg"></P>


</center></p><br>
<a name="ch06fig05"></a><p><center>

<H5 class="docFigureTitle">Figure 6-5. Sequence slice: <tt>sequence[1:3]</tt></H5>

<p class="docText">
<img border="0" alt="" width="400" height="226" SRC="images/chun_fig06_05.jpg"></p>


</center></p><br>
<a name="ch06fig06"></a><p><center>

<h5 class="docFigureTitle">Figure 6-6. Sequence slice: <tt>sequence[3]</tt></h5>

<p class="docText">
<img border="0" alt="" width="380" height="213" SRC="images/chun_fig06_06.jpg"></p>


</center></p><br>

<a name="ch06lev3sec5"></a>

<h5 id="title-IDADPAPB" class="docSection3Title">Extended Slicing with Stride Indices</h5>
<p class="docText"><a name="iddle1927"></a><a name="iddle3748"></a><a name="iddle3842"></a><a name="iddle3983"></a>The final slice syntax for sequences, known as <span class="docEmphasis">extended slicing</span>, involves a third index known as a <span class="docEmphasis">stride</span>. You can think of a stride index like a &quot;step&quot; value as the third element of a call to the <tt>range()</tt> built-in function or a <span class="docEmphStrong"><tt>for</tt></span> loop in languages like C/C++, Perl, PHP, and Java.</p>
<p class="docText">Extended slice syntax with stride indices has actually been around for a long time, built into the Python virtual machine but accessible only via extensions. This syntax was even made available in Jython (and its predecessor JPython) long before version 2.3 of the C interpreter gave everyone else access to it. Here are a few examples:</P>

<p class="docText">
<img border="0" alt="" width="50" height="47" SRC="images/2_3.jpg"></p>


<p class="docText">Here are a few examples:</P>
<div class="docText"><pre>&gt;&gt;&gt; s = 'abcdefgh'
&gt;&gt;&gt; s[::-1]            # think of it as 'reverse'
'hgfedcba'
&gt;&gt;&gt; s[::2]             # think of it as skipping by 2
'aceg'</pre></div><br>

<a name="ch06lev3sec6"></a>

<H5 id="title-IDAZRAPB" class="docSection3Title">More on Slice Indexing</h5>
<p class="docText"><a name="iddle2409"></a><a name="iddle3840"></a>The slice index syntax is more flexible than the single element index. The starting and ending indices can exceed the length of the string. In other words, the starting index can start off well left of 0, that is, an index of -100 does not exist, but does not produce an error. Similarly, an index of 100 as an ending index of a sequence with fewer than 100 elements is also okay, as shown here:</P>
<div class="docText"><pre>&gt;&gt;&gt; ('Faye', 'Leanna', 'Daylen')[-100:100]
('Faye', 'Leanna', 'Daylen')</pre></div><br>
<p class="docText">Here is another problem: we want to take a string and display it in a loop. Each time through we would like to chop off the last character. Here is a snippet of code that does what we want:</P>
<div class="docText"><pre>&gt;&gt;&gt; s = 'abcde'
&gt;&gt;&gt; i = -1
&gt;&gt;&gt; <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span> range(-1, -len(s), -1):
...     <span class="docEmphStrong">print</span> s[:i]
...
abcd
abc
ab
a</pre></div><BR>
<p class="docText">However, what if we wanted to display the entire string at the first iteration? Is there a way we can do it without adding an additional <span class="docEmphStrong"><tt>print</tt></span> s before our loop? What if we wanted to programmatically specify no index, meaning all the way to the end? There is no real way to do that with an index as we are using negative indices in our example, and <tt>-1</tt> is the &quot;smallest&quot; index. We cannot use <tt>0</tt>, as that would be interpreted as the first element and would not display anything:</P>
<div class="docText"><pre>&gt;&gt;&gt; s[:0]
''</pre></div><BR>
<p class="docText">Our solution is another tip: using <tt>None</tt> as an index has the same effect as a missing index, so you can get the same functionality programmatically, i.e., when you are using a variable to index through a sequence but also want to be able to access the first or last elements:</p>
<div class="docText"><pre>&gt;&gt;&gt; s = 'abcde'
&gt;&gt;&gt; <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span> [None] + range(-1, -len(s), -1):
...     <span class="docEmphStrong">print</span> s[:i]
...
abcde
abcd
abc
ab
a</pre></div><br>
<p class="docText"><a name="iddle1297"></a><a name="iddle1534"></a><a name="iddle2192"></a><a name="iddle2206"></a><a name="iddle2221"></a><a name="iddle2677"></a><a name="iddle2691"></a><a name="iddle3721"></a><a name="iddle3727"></a><a name="iddle3979"></a><a name="iddle4240"></a><a name="iddle4248"></a>So it works the way we want now. Before parting ways for now, we wanted to point out that this is one of the places where we could have created a list <tt>[None]</tt> and used the <tt>extend()</tt> method to add the <tt>range()</tt> output, or create a list with the <tt>range()</tt> elements and inserted <tt>None</tt> at the beginning, but we are (horribly) trying to save several lines of code here. Mutable object built-in methods like <tt>extend()</tt> do not have a return value, so we could not have used:</p>
<div class="docText"><pre>&gt;&gt;&gt; <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span> [None].extend(range(-1, -len(s), -1)):
...     <span class="docEmphStrong">print</span> s[:i]
...
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: iteration over non-sequence</pre></div><BR>
<p class="docText">The reason for the error is that <tt>[None].extend(...)</tt> returns <tt>None</tt>, which is neither a sequence nor an iterable. The only way we could do it without adding extra lines of code is with the list concatenation above.</p>


<a name="ch06lev2sec3"></a>
<H4 id="title-IDAEZAPB" class="docSection2Title">6.1.3. Built-in Functions (BIFs)</h4>
<p class="docText">Before we look at sequence type BIFs, we wanted to let you know that you will be seeing the term <span class="docEmphasis">iterable</span> mixed in with sequence. The reason for this is that iterables are more generalized and include data types like sequences, iterators, or any object supporting iteration.</P>
<p class="docText">Because Python's <span class="docEmphStrong"><tt>for</tt></span> loops can iterate over any iterable type, it will seem like iterating over a pure sequence, even if it isn't one. Also, many of Python's BIFs that previously only accepted sequences as arguments have been upgraded to take iterators and iterator-like objects as well, hence the basket term, &quot;iterable.&quot;</p>
<p class="docText">We will discuss in detail in this chapter BIFs that have a strong tie to sequences. We will discuss BIFs that apply more specifically to iteration in loops in <a class="docLink" href="ch08.html#ch08">Chapter 8</a>, &quot;<a class="docLink" href="ch08.html#ch08">Conditionals and Loops</a>.&quot;</P>
<a name="ch06lev3sec7"></a>
<H5 id="title-IDAK0APB" class="docSection3Title">Conversion/Casting</h5>
<p class="docText">The <tt>list()</tt>, <tt>str()</tt>, and <tt>tuple()</tt> BIFs are used to convert from any sequence type to another. You can also think of them as <span class="docEmphasis">casting</span> if coming over from another language, but there really is no conversion or casting going on. These &quot;converters&quot; are really factory functions (introduced in <a class="docLink" href="ch04.html#ch04">Chapter 4</a>) that take an object and (shallow) copy its contents into a newly generated object of the desired type. <a class="docLink" href="#ch06table02">Table 6.2</a> lists the sequence type conversion functions.</p>

<p class="docText"></p><a name="ch06table02"></a><p><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 6.2. Sequence Type <span class="docEmphasis">Conversion</span> Factory Functions</h5></caption><colgroup align="left" span="2"><col width="130"><col width="330"></colgroup><thead><tr><th class="thead" scope="col" align="left" valign="top"><p class="docText"><a name="iddle2193"></a><a name="iddle2205"></a><a name="iddle2222"></a><a name="iddle2659"></a><a name="iddle2678"></a><a name="iddle2692"></a><a name="iddle2820"></a><a name="iddle2917"></a><a name="iddle3237"></a><a name="iddle3653"></a><a name="iddle3734"></a><a name="iddle3980"></a><a name="iddle4085"></a><a name="iddle4241"></a><a name="iddle4249"></a><span class="docEmphasis">Function</span></P></th><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Operation</span></p></th></tr></thead><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>list(</tt><span class="docEmphasis"><tt>iter</tt></span><tt>)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Converts <span class="docEmphasis"><tt>iter</tt></span>able to a list</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>str(</tt><span class="docEmphasis"><tt>obj</tt></span><tt>)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Converts <span class="docEmphasis"><tt>obj</tt></span> to string (a printable string representation)</p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>unicode(</tt><span class="docEmphasis"><tt>obj</tt></span><tt>)</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Converts <span class="docEmphasis"><tt>obj</tt></span> to a Unicode string (using default encoding)</P></td></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>basestring()</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Abstract factory function serves only as parent class of <tt>str</tt> and <tt>unicode</tt>, so cannot be called/instantiated (see <a class="docLink" href="ch06lev1sec2.html#ch06lev1sec2">Section 6.2</a>)</p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>tuple(</tt><span class="docEmphasis"><tt>iter</tt></span><tt>)</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Converts <span class="docEmphasis"><tt>iter</tt></span>able to a tuple</P></td></tr></table></p><br>
<p class="docText">Again, we use the term &quot;convert&quot; loosely. But why doesn't Python just convert our argument object into another type? Recall from <a class="docLink" href="ch04.html#ch04">Chapter 4</a> that once Python objects are created, we cannot change their identity or their type. If you pass a list to <tt>list()</tt>, a (shallow) copy of the list's objects will be made and inserted into the new list. This is also similar to how the concatenation and repetition operators that we have seen previously do their work.</P>
<p class="docText">A shallow copy is where only references are copied...no new objects are made! If you also want copies of the objects (including recursively if you have container objects in containers), you will need to learn about deep copies. More information on shallow and deep copies is available toward the end of this chapter.</p>
<p class="docText">The <tt>str()</tt> function is most popular when converting an object into something printable and works with other types of objects, not just sequences. The same thing applies for the Unicode version of <tt>str()</tt>, <tt>unicode()</tt>. The <tt>list()</tt> and <tt>tuple()</tt> functions are useful to convert from one to another (lists to tuples and vice versa). However, although those functions are applicable for strings as well since strings are sequences, using <tt>tuple()</tt> and <tt>list()</tt> to turn strings into tuples or lists (of characters) is not common practice.</p>

<a name="ch06lev3sec8"></a>
<H5 id="title-IDAQMBPB" class="docSection3Title">Operational</h5>
<p class="docText">Python provides the following operational BIFs for sequence types (see <a class="docLink" href="#ch06table03">Table 6.3</a> below). Note that <tt>len()</tt>, <tt>reversed()</tt>, and <tt>sum()</tt> can only accept sequences while the rest can take iterables. Alternatively, <tt>max()</tt> and <tt>min()</tt> can also take a list of arguments</p>

<p class="docText"></p><a name="ch06table03"></a><P><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 6.3. Sequence Type <span class="docEmphasis">Operational</span> Built-in Functions</h5></caption><colgroup align="left" span="2"><col width="170"><col width="380"></colgroup><thead><tr><th class="thead" scope="col" align="left" valign="top"><p class="docText"><a name="iddle1813"></a><a name="iddle2660"></a><a name="iddle2821"></a><a name="iddle2918"></a><a name="iddle3654"></a><a name="iddle3880"></a><a name="iddle4086"></a><a name="iddle4561"></a><span class="docEmphasis">Function</span></p></th><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Operation</span></p></th></tr></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>enumerate(</tt><span class="docEmphasis"><tt>iter</tt></span><tt>)</tt><sup class="docFootnote"><a class="docLink" href="#ch06fna">[a]</a></sup></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Takes an <span class="docEmphasis"><tt>iter</tt></span>able and returns an enumerate object (also an iterator) which generates 2-tuple elements (index, item) of <span class="docEmphasis"><tt>iter</tt></span> (PEP 279)</p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>len(</tt><span class="docEmphasis"><tt>seq</tt></span><tt>)</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Returns length (number of items) of <span class="docEmphasis"><tt>seq</tt></span></P></td></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>max(</tt><span class="docEmphasis"><tt>iter, key=</tt></span><tt>None)</tt> or <tt>max(</tt><span class="docEmphasis"><tt>arg0, arg1..., key=</tt></span><tt>None)</tt><sup class="docFootnote"><a class="docLink" href="#ch06fnb">[b]</a></sup></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns &quot;largest&quot; element in <span class="docEmphasis"><tt>iter</tt></span> or returns &quot;largest&quot; of (<span class="docEmphasis"><tt>arg0, arg1, ...</tt></span>); if <span class="docEmphasis"><tt>key</tt></span> is present, it should be a callback to pass to the <tt>sort()</tt> method for testing</p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>min(</tt><span class="docEmphasis"><tt>iter, key=</tt></span><tt>None) or min(</tt><span class="docEmphasis"><tt>arg0, arg1.... key=</tt></span><tt>None)</tt><sup class="docFootnote"><a class="docLink" href="#ch06fnb">[b]</a></sup></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Returns &quot;smallest&quot; element in <span class="docEmphasis"><tt>iter;</tt></span> returns &quot;smallest&quot; of (<span class="docEmphasis"><tt>arg0, arg1, ...</tt></span>); if <span class="docEmphasis"><tt>key</tt></span> is present, it should be a callback to pass to the <tt>sort()</tt> method for testing</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>reversed(</tt><span class="docEmphasis"><tt>seq</tt></span><tt>)</tt><sup class="docFootnote"><a class="docLink" href="#ch01fnc">[c]</a></sup></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Takes <span class="docEmphasis"><tt>sequence</tt></span> and returns an iterator that traverses that sequence in reverse order (PEP 322)</P></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>sorted(</tt><span class="docEmphasis"><tt>iter, func=</tt></span><tt>None</tt>, <span class="docEmphasis"><tt>key=</tt></span><tt>None</tt>, <span class="docEmphasis"><tt>reverse</tt></span><tt>=False)</tt><sup class="docFootnote"><a class="docLink" href="#ch01fnc">[c]</a></sup></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Takes an iterable <span class="docEmphasis"><tt>iter</tt></span> and returns a sorted list; optional arguments <span class="docEmphasis"><tt>func, key</tt></span>, and <span class="docEmphasis"><tt>reverse</tt></span> are the same as for the <tt>list.sort()</tt> built-in method</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sum(</tt><span class="docEmphasis"><tt>seq, init=</tt></span><tt>0)</tt><sup class="docFootnote"><a class="docLink" href="#ch06fna">[a]</a></sup></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns the sum of the numbers of <span class="docEmphasis"><tt>seq</tt></span> and optional <span class="docEmphasis"><tt>init</tt></span>ial value; it is equivalent to <tt>reduce (operator.add,</tt> <span class="docEmphasis"><tt>seq</tt></span>, <span class="docEmphasis"><tt>init</tt></span><tt>)</tt></p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>zip(</tt><span class="docEmphasis"><tt>[it0, it1,... itN]</tt></span><tt>)</tt><sup class="docFootnote"><a class="docLink" href="#ch01fnd">[d]</a></sup></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Returns a list of tuples whose elements are members of each iterable passed into it, i.e., <tt>[(</tt><span class="docEmphasis"><tt>it0</tt></span><tt>[0]</tt>, <span class="docEmphasis"><tt>it1</tt></span><tt>[0],...</tt> <span class="docEmphasis"><tt>itN</tt></span><tt>[0]), (</tt><span class="docEmphasis"><tt>it0</tt></span><tt>[1]</tt>, <span class="docEmphasis"><tt>it1</tt></span><tt>[1],...</tt> <span class="docEmphasis"><tt>itN</tt></span><tt>[1]),... (</tt><span class="docEmphasis"><tt>it0</tt></span><tt>[n],</tt> <span class="docEmphasis"><tt>it1</tt></span><tt>[n],...</tt> <span class="docEmphasis"><tt>itN</tt></span><tt>[n])],</tt> where <tt>n</tt> is the minimum cardinality of all of the iterables</P></td></TR></table></P><BR><blockquote><p class="docFootnote"><sup><a name="ch06fna">[a]</a></sup> New in <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec3">Python 2.3</a>.</P></blockquote><blockquote><p class="docFootnote"><sup><a name="ch06fnb">[b]</a></sup> key argument new in Python 2.5.</p></blockquote><blockquote><p class="docFootnote"><sup><a name="ch01fnc">[c]</a></sup> New in <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec4">Python 2.4</a>.</p></blockquote><blockquote><p class="docFootnote"><sup><a name="ch01fnd">[d]</a></sup> New in Python 2.0; more flexibility added in <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec4">Python 2.4</a>.</p></blockquote>
<p class="docText"><a name="iddle1138"></a><a name="iddle3290"></a><a name="iddle3313"></a><a name="iddle3537"></a><a name="iddle3992"></a><a name="iddle3994"></a><a name="iddle4003"></a><a name="iddle4028"></a><a name="iddle4048"></a>We will provide some examples of using these functions with each sequence type in their respective sections.</P>



<a href="14051536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch06.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch06lev1sec2.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>