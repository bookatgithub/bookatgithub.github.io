<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 6.3.&nbsp; Strings and Operators</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch06lev1sec2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch06lev1sec4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a href="14051536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a><a name="ch06lev1sec3"></a>
<h3 id="title-IDACRFZF" class="docSection1Title">6.3. Strings and Operators</H3>
<a name="ch06lev2sec5"></a>
<h4 id="title-IDALRFZF" class="docSection2Title">6.3.1. Standard Type Operators</H4>
<p class="docText">In <a class="docLink" href="ch04.html#ch04">Chapter 4</a>, we introduced a number of operators that apply to most objects, including the standard types. We will take a look at how some of those apply to strings. For a brief introduction, here are a few examples using strings:</P>
<div class="docText"><pre>&gt;&gt;&gt; str1 = 'abc'
&gt;&gt;&gt; str2 = 'lmn'
&gt;&gt;&gt; str3 = 'xyz'
&gt;&gt;&gt; str1 &lt; str2
True
&gt;&gt;&gt; str2 != str3
True
&gt;&gt;&gt; str1 &lt; str3 <span class="docEmphStrong">and</span> str2 == 'xyz'
False</pre></div><BR>
<p class="docText">When using the value comparison operators, strings are compared lexicographically (ASCII value order).</P>

<a name="ch06lev2sec6"></a>
<h4 id="title-IDANSFZF" class="docSection2Title">6.3.2. Sequence Operators</h4>
<a name="ch06lev3sec12"></a>
<h5 id="title-IDAWSFZF" class="docSection3Title">Slices ( <tt>[ ]</tt> and <tt>[ : ]</tt> )</H5>
<p class="docText">Earlier in <a class="docLink" href="ch06lev1sec1.html#ch06lev2sec1">Section 6.1.1</a>, we examined how we can access individual or a group of elements from a sequence. We will apply that knowledge to strings in this section. In particular, we will look at:</p>
<UL><li><p class="docList">Counting forward</P></li><LI><p class="docList">Counting backward</P></li><li><p class="docList">Default/missing indexes</p></li></UL>
<p class="docText">For the following examples, we use the single string <tt>'abcd'</tt>. Provided in the figure is a list of positive and negative indexes that indicate the position in which each character is located within the string itself.</p>

<p class="docText">
<img border="0" alt="" width="122" height="75" SRC="images/171equ01.jpg"></p>


<p class="docText">Using the length operator, we can confirm that its length is 4:</P>
<div class="docText"><pre>&gt;&gt;&gt; aString = 'abcd'
&gt;&gt;&gt; len(aString)
4</pre></div><br>
<p class="docText">When counting forward, indexes start at 0 to the left and end at one less than the length of the string (because we started from zero). In our example, the final index of our string is:</p>
<div class="docText"><pre>final_index       = len(aString) - 1
                  = 4 - 1
                  = 3</pre></div><br>
<p class="docText">We can access any substring within this range. The slice operator with a single argument will give us a single character, and the slice operator with a range, i.e., using a colon ( <tt>:</tt> ), will give us multiple consecutive characters. Again, for any ranges <tt>[</tt><span class="docEmphasis"><tt>start</tt></span><tt>:</tt><span class="docEmphasis"><tt>end</tt></span><tt>]</tt>, we will get all characters starting at offset <span class="docEmphasis"><tt>start</tt></span> up to, but not including, the character at <span class="docEmphasis"><tt>end</tt></span>. In other words, for all characters <span class="docEmphasis"><tt>x</tt></span> in the range <tt>[</tt><span class="docEmphasis"><tt>start</tt></span><tt>:</tt><span class="docEmphasis"><tt>end</tt></span><tt>]</tt>, <span class="docEmphasis"><tt>start</tt></span> <tt>&lt;= x &lt;</tt> <span class="docEmphasis"><tt>end</tt></span>.</P>
<div class="docText"><pre> &gt;&gt;&gt; aString[0]
'a'
&gt;&gt;&gt; aString[1:3]
'bc'
&gt;&gt;&gt; aString[2:4]
'cd'
&gt;&gt;&gt; aString[4]
Traceback (innermost last):
  File "&lt;stdin&gt;", line 1, in ?
IndexError: string index out of range</pre></div><BR>
<p class="docText">Any index outside our valid index range (in our example, 0 to 3) results in an error. Above, our access of <tt>aString[2:4]</tt> was valid because that returns characters at indexes 2 and 3, i.e., <tt>'c'</tt> and <tt>'d'</tt>, but a direct access to the character at index 4 was invalid.</p>
<p class="docText"><a name="iddle2829"></a><a name="iddle2832"></a><a name="iddle3271"></a><a name="iddle3732"></a><a name="iddle4017"></a>When counting backward, we start at index -1 and move toward the beginning of the string, ending at negative value of the length of the string. The final index (the first character) is located at:</p>
<div class="docText"><pre> final_index     = -len(aString)
                 = -4
&gt;&gt;&gt; aString[-1]
'd'
&gt;&gt;&gt; aString[-3:-1]
'bc'
&gt;&gt;&gt; aString[-4]
'a'</pre></div><br>
<p class="docText">When either a starting or an ending index is missing, they default to the beginning or end of the string, respectively.</p>
<div class="docText"><pre>&gt;&gt;&gt; aString[2:]
'cd'
&gt;&gt;&gt; aString[1:]
'bcd'
&gt;&gt;&gt; aString[:-1]
'abc'
&gt;&gt;&gt; aString[:]
'abcd'</pre></div><br>
<p class="docText">Notice how the omission of both indices gives us a copy of the entire string.</p>

<a name="ch06lev3sec13"></a>
<h5 id="title-IDAYYFZF" class="docSection3Title">Membership (<span class="docEmphStrong"><tt>in, not in</tt></span>)</h5>
<p class="docText">The membership question asks whether a (sub)string appears in a (nother) string. <tt>true</tt> is returned if that character appears in the string and <tt>False</tt> otherwise. Note that the membership operation is not used to determine if a substring is within a string. Such functionality can be accomplished by using the string methods or string module functions <tt>find()</tt> or <tt>index()</tt> (and their brethren <tt>rfind()</tt> and <tt>rindex()</tt>).</p>

<p class="docText">
<img border="0" alt="" width="50" height="47" SRC="images/2_3.jpg"></p>


<p class="docText">Below are a few more examples of strings and the membership operators. Note that prior to <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec3">Python 2.3</a>, the <span class="docEmphStrong"><tt>in</tt></span> (and <span class="docEmphStrong"><tt>not</tt></span> <span class="docEmphStrong"><tt>in</tt></span>) operators for strings only allowed a single character check, such as the second example below (is '<tt>n</tt>' a substring of '<tt>abcd</tt>'). In 2.3, this was opened up to all strings, not just characters.</p>
<div class="docText"><pre>&gt;&gt;&gt; 'bc' <span class="docEmphStrong">in</span> 'abcd'
True
&gt;&gt;&gt; 'n' <span class="docEmphStrong">in</span> 'abcd'
False
&gt;&gt;&gt; 'nm' <span class="docEmphStrong">not in</span> 'abcd'
True</pre></div><BR>
<p class="docText">In <a class="docLink" href="#ch06list01">Example 6.1</a>, we will be using the following predefined strings found in the <tt>string</tt> module:</p>
<div class="docText"><pre>&gt;&gt;&gt; <span class="docEmphStrong">import</span> string
&gt;&gt;&gt; string.uppercase
'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
&gt;&gt;&gt; string.lowercase
'abcdefghijklmnopqrstuvwxyz'
&gt;&gt;&gt; string.letters
'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
&gt;&gt;&gt; string.digits
'0123456789'</pre></div><BR>
<p class="docText"><a class="docLink" href="#ch06list01">Example 6.1</a> is a small script called <tt>idcheck.py</tt> which checks for valid Python identifiers. As we now know, Python identifiers must start with an alphabetic character. Any succeeding characters may be alphanumeric.</p>
<a name="ch06list01"></a><H5 id="title-IDAS2FZF" class="docExampleTitle">Example 6.1. ID Check (<tt>idcheck.py</tt>)</h5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>


<p class="docText"><span class="docEmphasis">Tests for identifier validity. First symbol must be alphabetic and remaining symbols must be alphanumeric. This tester program only checks identifiers that are at least two characters in length.</span></P>

<pre>1  #!usr/bin/env python
2
3  <span class="docEmphStrong">import</span> string
4
5  alphas = string.letters + '_'
6  nums = string.digits
7
8  <span class="docEmphStrong">print</span> 'Welcome to the Identifier Checker v1.0'
9  <span class="docEmphStrong">print</span> 'Testees must be at least 2 chars long.'
10 myInput = raw_input('Identifier to test? ')
11
12 <span class="docEmphStrong">if</span> len(myInput) &gt; 1:
13
14     <span class="docEmphStrong">if</span> myInput[0] <span class="docEmphStrong">not in</span> alphas:
15         <span class="docEmphStrong">print</span> '''invalid: first symbol must be
16             alphabetic'''
17     <span class="docEmphStrong">else:</span>
18         <span class="docEmphStrong">for</span> otherChar in myInput[1:]:
19
20              <span class="docEmphStrong">if</span> otherChar not in alphas + nums:
21                  <span class="docEmphStrong">print</span> '''invalid: remaining
22                     symbols must be alphanumeric'''
23                  <span class="docEmphStrong">break</span>
24         <span class="docEmphStrong">else:</span>
25             <span class="docEmphStrong">print</span> "okay as an identifier"</pre><BR>

</TD></tr></table></p>
<p class="docText">The example also shows use of the string concatenation operator ( <tt>+</tt> ) introduced later in this section.</p>
<p class="docText">Running this script several times produces the following output:</P>
<div class="docText"><pre>$ python idcheck.py
Welcome to the Identifier Checker v1.0
Testees must be at least 2 chars long.
Identifier to test? counter
okay as an identifier
$
$ python idcheck.py
Welcome to the Identifier Checker v1.0
Testees must be at least 2 chars long.
Identifier to test? 3d_effects
invalid: first symbol must be alphabetic</pre></div><br>
<p class="docText">Let us take apart the application line by line.</P>
<a name="ch06lev4sec1"></a>
<h5 id="title-IDAQ5FZF" class="docSection4Title">Lines 36</H5>
<p class="docText">Import the <tt>string</tt> module and use some of the predefined strings to put together valid alphabetic and numeric identifier strings that we will test against.</p>

<a name="ch06lev4sec2"></a>
<H5 id="title-IDACAGZF" class="docSection4Title">Lines 812</H5>
<p class="docText">Print the salutation and prompt for user input. The <span class="docEmphStrong"><tt>if</tt></span> statement on line 12 filters out all identifiers or candidates shorter than two characters in length.</p>

<a name="ch06lev4sec3"></a>
<h5 id="title-IDATAGZF" class="docSection4Title">Lines 1416</h5>
<p class="docText">Check to see if the first symbol is alphabetic. If it is not, display the output indicating the result and perform no further processing.</p>

<a name="ch06lev4sec4"></a>
<H5 id="title-IDA5AGZF" class="docSection4Title">Lines 1718</h5>
<p class="docText">Otherwise, loop to check the other characters, starting from the second symbol to the end of the string.</p>

<a name="ch06lev4sec5"></a>
<H5 id="title-IDALBGZF" class="docSection4Title">Lines 2023</h5>
<p class="docText">Check to see if each remaining symbol is alphanumeric. Note how we use the concatenation operator (see below) to create the set of valid characters. As soon as we find an invalid character, display the result and perform no further processing by exiting the loop with <span class="docEmphStrong"><tt>break</tt></span>.</p>
<a name="ch06note01"></a><div class="docNote"><p class="docNoteTitle">Core Tip: Performance</p><P><table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top">

<img border="0" alt="" align="LEFT" width="50" height="47" SRC="images/core_tip.jpg">



</td><td valign="top"><p class="docText"><a name="iddle2753"></a><a name="iddle3409"></a><span class="docEmphasis">In general, repeat performances of operations or functions as arguments in a loop are unproductive as far as performance is concerned.</span></p><div class="docText"><pre><span class="docEmphStrong">while</span> i &lt; len(myString):
         <span class="docEmphStrong">print</span> 'character %d is:', myString[i]</pre></div><br><p class="docText"><span class="docEmphasis">The loop above wastes valuable time recalculating the length of string <tt>myString</tt>. This function call occurs for each loop iteration. If we simply save this value once, we can rewrite our loop so that it is more productive.</span></p><div class="docText"><pre>length = len(myString)
<span class="docEmphStrong">while</span> i &lt; length:
    <span class="docEmphStrong">print</span>'character %d is:', myString[i]</pre></div><br><p class="docText"><span class="docEmphasis">The same idea applies for this loop above in <a class="docLink" href="#ch06list01">Example 6.1</a>.</span></p><div class="docText"><pre><span class="docEmphStrong">for</span> otherChar <span class="docEmphStrong">in</span> myInput[1:]:
     <span class="docEmphStrong">if</span> otherChar <span class="docEmphStrong">not in</span> alphas + nums:</pre></div><br><p class="docText"><span class="docEmphasis">The <span class="docEmphStrong"><tt>for</tt></span> loop beginning on line 18 contains an <span class="docEmphStrong"><tt>if</tt></span> statement that concatenates a pair of strings. These strings do not change throughout the course of the application, yet this calculation must be performed for each loop iteration. If we save the new string first, we can then reference that string rather than make the same calculations over and over again:</span></p><div class="docText"><pre>alphnums = alphas + nums
<span class="docEmphStrong">for</span> otherChar <span class="docEmphStrong">in</span> myInput[1:]:
    <span class="docEmphStrong">if</span> otherChar <span class="docEmphStrong">not</span> <span class="docEmphStrong">in</span> alphnums:
        :</pre></div><br></td></TR></table></p></div><BR>

<a name="ch06lev4sec6"></a>
<h5 id="title-IDAPGGZF" class="docSection4Title">Lines 2425</H5>
<p class="docText">It may be somewhat premature to show you a <span class="docEmphStrong"><tt>for-else</tt></span> loop statement, but we are going to give it a shot anyway. (For a full treatment, see <a class="docLink" href="ch08.html#ch08">Chapter 8</a>). The <span class="docEmphStrong"><tt>else</tt></span> statement for a <span class="docEmphStrong"><tt>for</tt></span> loop is optional and, if provided, will execute if the loop finished in completion without being &quot;broken&quot; out of by <span class="docEmphStrong"><tt>break</tt></span>. In our application, if all remaining symbols check out okay, then we have a valid identifier name. The result is displayed to indicate as such, completing execution.</p>
<p class="docText">This application is not without its flaws, however. One problem is that the identifiers tested must have length greater than 1. Our application &quot;as is&quot; is not reflective of the true range of Python identifiers, which may be of length 1. Another problem with our application is that it does not take into consideration Python keywords, which are reserved names that cannot be used for identifiers. We leave these two tasks as exercises for the reader (see <a class="docLink" href="ch06lev1sec22.html#ch06qa1q2">Exercise 6-2</a>).</P>


<a name="ch06lev3sec14"></a>

<h5 id="title-IDADIGZF" class="docSection3Title">Concatenation ( <tt>+</tt> )</H5>
<a name="ch06lev4sec7"></a>
<H5 id="title-IDAOIGZF" class="docSection4Title">Runtime String Concatenation</H5>
<p class="docText"><a name="iddle1028"></a><a name="iddle1496"></a><a name="iddle2587"></a><a name="iddle4002"></a>We can use the concatenation operator to create new strings from existing ones. We have already seen the concatenation operator in action above in <a class="docLink" href="#ch06list01">Example 6-1</a>. Here are a few more examples:</P>
<div class="docText"><pre>&gt;&gt;&gt; 'Spanish' + 'Inquisition'
'SpanishInquisition'
&gt;&gt;&gt;
&gt;&gt;&gt; 'Spanish' + ' ' + 'Inquisition'
'Spanish Inquisition'
&gt;&gt;&gt;
&gt;&gt;&gt; s = 'Spanish' + ' ' + 'Inquisition' + ' Made Easy'
&gt;&gt;&gt; s
'Spanish Inquisition Made Easy'
&gt;&gt;&gt;
&gt;&gt;&gt; <span class="docEmphStrong">import</span> string
&gt;&gt;&gt; string.upper(s[:3] + s[20])    # archaic (see below)
'SPAM'</pre></div><br>
<p class="docText">The last example illustrates using the concatenation operator to put together a pair of slices from string <tt>s</tt>, the &quot;Spa&quot; from &quot;Spanish&quot; and the &quot;M&quot; from &quot;Made.&quot; The extracted slices are concatenated and then sent to the <tt>string.upper()</tt> function to convert the new string to all uppercase letters. String methods were added to Python back in 1.6 so such examples can be replaced with a single call to the final string method (see example below). There is really no longer a need to import the <tt>string</tt> module unless you are trying to access some of the older string constants which that module defines.</p>
<p class="docText">Note: Although easier to learn for beginners, we recommend not using string concatenation when performance counts. The reason is that for every string that is part of a concatenation, Python has to allocate new memory for all strings involved, including the result. Instead, we recommend you either use the string format operator ( <tt>%</tt> ), as in the examples below, or put all of the substrings in a list, and using one <tt>join()</tt> call to put them all together:</p>
<div class="docText"><pre>&gt;&gt;&gt; '%s %s' % ('Spanish', 'Inquisition')
'Spanish Inquisition'
&gt;&gt;&gt;
&gt;&gt;&gt; s = ' '.join(('Spanish', 'Inquisition', 'Made Easy'))
&gt;&gt;&gt; s
'Spanish Inquisition Made Easy'
&gt;&gt;&gt;
&gt;&gt;&gt; # no need to <span class="docEmphStrong">import</span> string to use string.upper():
&gt;&gt;&gt; ('%s%s' % (s[:3], s[20])).upper()
'SPAM'</pre></div><BR>

<a name="ch06lev4sec8"></a>

<h5 id="title-IDAILGZF" class="docSection4Title">Compile-Time String Concatenation</H5>
<p class="docText"><a name="iddle3641"></a><a name="iddle4041"></a>The above syntax using the addition operator performs the string concatenation at runtime, and its use is the norm. There is a less frequently used syntax that is more of a programmer convenience feature. Python's syntax allows you to create a single string from multiple string literals placed adjacent to each other in the body of your source code:</p>
<div class="docText"><pre>&gt;&gt;&gt; foo = "Hello" 'world!'
&gt;&gt;&gt; foo
'Helloworld!'</pre></div><BR>
<p class="docText">It is a convenient way to split up long strings without unnecessary backslash escapes. As you can see from the above, you can mix quotation types on the same line. Another good thing about this feature is that you can add comments too, like this example:</p>
<div class="docText"><pre>&gt;&gt;&gt; f = urllib.urlopen('http://'  # protocol
... 'localhost'                   # hostname
... ':8000'                       # port
... '/cgi-bin/friends2.py')       # file</pre></div><BR>
<p class="docText">As you can imagine, here is what <tt>urlopen()</tt> really gets as input:</P>
<div class="docText"><pre>&gt;&gt;&gt; 'http://' 'localhost' ':8000' '/cgi-bin/friends2.py'
'http://localhost:8000/cgi-bin/friends2.py'</pre></div><br>

<a name="ch06lev4sec9"></a>
<h5 id="title-IDACNGZF" class="docSection4Title">Regular String Coercion to Unicode</h5>
<p class="docText">When concatenating regular and Unicode strings, regular strings are converted to Unicode first before the operation occurs:</p>
<div class="docText"><pre>&gt;&gt;&gt; 'Hello' + u' ' + 'World' + u'!'
u'Hello World!'</pre></div><BR>


<a name="ch06lev3sec15"></a>
<h5 id="title-IDAXNGZF" class="docSection3Title">Repetition ( <tt>*</tt> )</h5>
<p class="docText">The repetition operator creates new strings, concatenating multiple copies of the same string to accomplish its functionality:</P>
<div class="docText"><pre>&gt;&gt;&gt; 'Ni!' * 3
'Ni!Ni!Ni!'
&gt;&gt;&gt;
&gt;&gt;&gt; '*'*40
'****************************************'
&gt;&gt;&gt;
&gt;&gt;&gt; print '-' * 20, 'Hello World!', '-' * 20
-------------------- Hello World! --------------------
&gt;&gt;&gt; who = 'knights'
&gt;&gt;&gt; who * 2
'knightsknights'

&gt;&gt;&gt; who
'knights'</pre></div><br>
<p class="docText"><a name="iddle1535"></a><a name="iddle2084"></a><a name="iddle3256"></a><a name="iddle3308"></a><a name="iddle3984"></a><a name="iddle4051"></a>As with any standard operator, the original variable is unmodified, as indicated in the final dump of the object above.</p>



<a href="14051536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch06lev1sec2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch06lev1sec4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>