<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 6.4.&nbsp; String-Only Operators</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch06lev1sec3.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch06lev1sec5.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a href="14051536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a><a name="ch06lev1sec4"></a>
<h3 id="title-IDAZZBK" class="docSection1Title">6.4. String-Only Operators</H3>
<a name="ch06lev2sec7"></a>
<h4 id="title-IDAC0BK" class="docSection2Title">6.4.1. Format Operator ( <tt>%</tt> )</H4>
<p class="docText">Python features a string format operator. This operator is unique to strings and makes up for the lack of having functions from C's <tt>printf()</tt> family. In fact, it even uses the same symbol, the percent sign (<tt>%</tt>), and supports all the <tt>printf()</tt> formatting codes.</P>
<p class="docText">The syntax for using the format operator is as follows:</P>
<div class="docText"><pre><span class="docEmphasis">format_string</span> % (<span class="docEmphasis">arguments_to_convert</span>)</pre></div><BR>
<p class="docText">The <span class="docEmphasis"><tt>format_string</tt></span> on the left-hand side is what you would typically find as the first argument to <tt>printf()</tt>: the format string with any of the embedded <tt>%</tt> codes. The set of valid codes is given in <a class="docLink" href="#ch06table04">Table 6.4</a>. The <span class="docEmphasis"><tt>arguments_to_convert</tt></span> parameter matches the remaining arguments you would send to <tt>printf()</tt>, namely the set of variables to convert and display.</p>
<a name="ch06table04"></a><p><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 6.4. Format Operator Conversion Symbols</H5></caption><colgroup align="left" span="2"><col width="130"><col width="360"></colgroup><thead><tr><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Format Symbol</span></P></th><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Conversion</span></p></th></TR></thead><tr><TD class="docTableCell" align="center" valign="top"><p class="docText"><tt>%c</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Character (integer [ASCII value] or string of length 1)</p></td></TR><tr><td class="docTableCell" align="center" valign="top"><p class="docText"><tt>%r</tt><sup class="docFootnote"><a class="docLink" href="#ch06fna1">[a]</a></sup></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">String conversion via <tt>repr()</tt> prior to formatting</p></TD></TR><tr><td class="docTableCell" align="center" valign="top"><p class="docText"><tt>%s</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">String conversion via <tt>str()</tt> prior to formatting</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText"><tt>%d / %i</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Signed decimal integer</p></TD></tr><TR><td class="docTableCell" align="center" valign="top"><p class="docText"><tt>%u</tt><sup class="docFootnote"><a class="docLink" href="#ch06fnb1">[b]</a></sup></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Unsigned decimal integer</P></TD></TR><tr><td class="docTableCell" align="center" valign="top"><p class="docText"><tt>%o</tt><sup class="docFootnote"><a class="docLink" href="#ch06fnb1">[b]</a></sup></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">(Unsigned) octal integer</P></td></TR><tr><TD class="docTableCell" align="center" valign="top"><p class="docText"><tt>%x</tt><sup class="docFootnote"><a class="docLink" href="#ch06fnb1">[b]</a></sup><tt>/ %X</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">(Unsigned) hexadecimal integer (lower/UPPERcase letters)</p></td></TR><tr><td class="docTableCell" align="center" valign="top"><p class="docText"><tt>%e / %E</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Exponential notation (with lowercase '<tt>e</tt>'/UPPERcase 'E')</p></TD></TR><tr><td class="docTableCell" align="center" valign="top"><p class="docText"><tt>%f / %F</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Floating point real number (fraction truncates naturally)</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText"><tt>%g / %G</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">The shorter of <tt>%e</tt> and <tt>%f/%E%</tt> and <tt>%F%</tt></p></TD></tr><TR><td class="docTableCell" align="center" valign="top"><p class="docText"><tt>%%</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Percent character ( <tt>%</tt> ) unescaped</P></TD></TR></table></p><br><blockquote><p class="docFootnote"><sup><a name="ch06fna1">[a]</a></sup> New in Python 2.0; likely unique only to Python.</p></blockquote><blockquote><p class="docFootnote"><sup><a name="ch06fnb1">[b]</a></sup> <tt>%u/%o/%x/%X</tt> of negative int will return a signed string in <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec4">Python 2.4</a>.</P></blockquote>
<p class="docText">Python supports two formats for the input arguments. The first is a tuple (introduced in <a class="docLink" href="ch02lev1sec8.html#ch02lev1sec8">Section 2.8</a>, formally in 6.15), which is basically the set of arguments to convert, just like for C's <tt>printf()</tt>. The second format that Python supports is a dictionary (<a class="docLink" href="ch07.html#ch07">Chapter 7</a>). A dictionary is basically a set of hashed key-value pairs. The keys are requested in the <span class="docEmphasis"><tt>format_string</tt></span>, and the corresponding values are provided when the string is formatted.</p>
<p class="docText">Converted strings can either be used in conjunction with the <span class="docEmphStrong"><tt>print</tt></span> statement to display out to the user or saved into a new string for future processing or displaying to a graphical user interface.</P>
<p class="docText">Other supported symbols and functionality are listed in <a class="docLink" href="#ch06table05">Table 6.5</a>.</p>
<a name="ch06table05"></a><P><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 6.5. Format Operator Auxiliary Directives</H5></caption><colgroup align="left" span="2"><col width="100"><col width="350"></colgroup><thead><TR><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Symbol</span></p></th><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Functionality</span></p></th></tr></thead><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>*</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Argument specifies width or precision</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText">-</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Use left justification</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">+</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Use a plus sign ( + ) for positive numbers</p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>&lt;</tt><span class="docEmphasis"><tt>sp</tt></span><tt>&gt;</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Use space-padding for positive numbers</p></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>#</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Add the octal leading zero ('<tt>0</tt>') or hexadecimal leading '<tt>0x</tt>' or '<tt>0X</tt>', depending on whether '<tt>x</tt>' or '<tt>X</tt>' were used.</P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>0</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Use zero-padding (instead of spaces) when formatting numbers</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>%</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">'<tt>%%</tt>' leaves you with a single literal '<tt>%</tt>'</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>(var)</tt></span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Mapping variable (dictionary arguments)</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>m.n</tt></span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>m</tt></span> is the minimum total width and <span class="docEmphasis"><tt>n</tt></span> is the number of digits to display after the decimal point (if applicable)</p></TD></tr></table></P><br>
<p class="docText">As with C's <tt>printf()</tt>, the asterisk symbol ( <tt>*</tt> ) may be used to dynamically indicate the width and precision via a value in argument tuple. Before we get to our examples, one more word of caution: long integers are more than likely too large for conversion to standard integers, so we recommend using exponential notation to get them to fit.</P>
<p class="docText"><a name="iddle1920"></a><a name="iddle2055"></a><a name="iddle2326"></a><a name="iddle2492"></a><a name="iddle3128"></a>Here are some examples using the string format operator:</p>
<a name="ch06lev3sec16"></a>
<H5 id="title-IDAYLCK" class="docSection3Title">Hexadecimal Output</h5>
<div class="docText"><pre>&gt;&gt;&gt; "%x" % 108
'6c'
&gt;&gt;&gt;
&gt;&gt;&gt; "%X" % 108
'6C'
&gt;&gt;&gt;
&gt;&gt;&gt; "%#X" % 108
'0X6C'
&gt;&gt;&gt;
&gt;&gt;&gt; "%#x" % 108
'0x6c'</pre></div><BR>

<a name="ch06lev3sec17"></a>
<H5 id="title-IDAKMCK" class="docSection3Title">Floating Point and Exponential Notation Output</H5>
<div class="docText"><pre>&gt;&gt;&gt;
&gt;&gt;&gt; '%f' % 1234.567890
'1234.567890'
&gt;&gt;&gt;
&gt;&gt;&gt; '%.2f' % 1234.567890
'1234.57'
&gt;&gt;&gt;
&gt;&gt;&gt; '%E' % 1234.567890
'1.234568E+03'
&gt;&gt;&gt;
&gt;&gt;&gt; '%e' % 1234.567890
'1.234568e+03'
&gt;&gt;&gt;
&gt;&gt;&gt; '%g' % 1234.567890
'1234.57'
&gt;&gt;&gt;
&gt;&gt;&gt; '%G' % 1234.567890
'1234.57'
&gt;&gt;&gt;
&gt;&gt;&gt; "%e" % (1111111111111111111111L)
'1.111111e+21'</pre></div><BR>

<a name="ch06lev3sec18"></a>
<h5 id="title-IDA2MCK" class="docSection3Title">Integer and String Output</h5>
<div class="docText"><pre>&gt;&gt;&gt; "%+d" % 4
'+4'
&gt;&gt;&gt;

&gt;&gt;&gt; "%+d" % -4
'-4'
&gt;&gt;&gt;
&gt;&gt;&gt; "we are at %d%%" % 100
'we are at 100%'
&gt;&gt;&gt;
&gt;&gt;&gt; 'Your host is: %s' % 'earth'
'Your host is: earth'
&gt;&gt;&gt;
&gt;&gt;&gt; 'Host: %s\tPort: %d' % ('mars', 80)
'Host: mars    Port: 80'
&gt;&gt;&gt;
&gt;&gt;&gt; num = 123
&gt;&gt;&gt; 'dec: %d/oct: %#o/hex: %#X' % (num, num, num)
'dec: 123/oct: 0173/hex: 0X7B'
&gt;&gt;&gt;
&gt;&gt;&gt; "MM/DD/YY = %02d/%02d/%d" % (2, 15, 67)
'MM/DD/YY = 02/15/67'
&gt;&gt;&gt;
&gt;&gt;&gt; w, p = 'Web', 'page'
&gt;&gt;&gt; 'http://xxx.yyy.zzz/%s/%s.html' % (w, p)
'http://xxx.yyy.zzz/Web/page.html'</pre></div><br>
<p class="docText"><a name="iddle1617"></a><a name="iddle4004"></a>The previous examples all use tuple arguments for conversion. Below, we show how to use a dictionary argument for the format operator:</P>
<div class="docText"><pre>&gt;&gt;&gt; 'There are %(howmany)d %(lang)s Quotation Symbols' % \
...     {'lang': 'Python', 'howmany': 3}
'There are 3 Python Quotation Symbols'</pre></div><br>

<a name="ch06lev3sec19"></a>
<H5 id="title-IDAHOCK" class="docSection3Title">Amazing Debugging Tool</h5>
<p class="docText">The string format operator is not only a cool, easy-to-use, and familiar feature, but a great and useful debugging tool as well. Practically all Python objects have a string presentation (either evaluatable from <tt>repr()</tt> or <tt>'',</tt>or printable from <tt>str()</tt>). The <span class="docEmphStrong"><tt>print</tt></span> statement automatically invokes the <tt>str()</tt> function for an object. This gets even better. When you are defining your own objects, there are hooks for you to create string representations of your object such that <tt>repr()</tt> and <tt>str()</tt> (and <tt>''</tt> and <span class="docEmphStrong"><tt>print</tt></span>) return an appropriate string as output. And if worse comes to worst and neither <tt>repr()</tt> or <tt>str()</tt> is able to display an object, the Pythonic default is at least to give you something of the format:</P>
<div class="docText"><pre>&lt;... <span class="docEmphasis">something that is useful</span> ...&gt;</pre></div><br>


<a name="ch06lev2sec8"></a>

<P><table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><td width="60" valign="top">

<img border="0" alt="" width="50" height="47" SRC="images/2_4.jpg">


</td><td valign="top"><h4 id="title-IDA2PCK" class="docSection2Title">6.4.2. String Templates: Simpler Substitution</H4></td></tr></table></P>

<p class="docText"><a name="iddle3291"></a><a name="iddle3538"></a><a name="iddle3988"></a><a name="iddle4029"></a><a name="iddle4050"></a><a name="iddle4145"></a>The string format operator has been a mainstay of Python and will continue to be so. One of its drawbacks, however, is that it is not as intuitive to the new Python programmer not coming from a C/C++ background. Even for current developers using the dictionary form can accidentally leave off the type format symbol, i.e., <tt>%(lang)</tt> vs. the more correct <tt>%(lang)s</tt>. In addition to remembering to put in the correct formatting directive, the programmer must also <span class="docEmphasis">know</span> the type, i.e., is it a string, an integer, etc.</p>
<p class="docText">The justification of the new string templates is to do away with having to remember such details and use string substitution much like those in current shell-type scripting languages, the dollar sign ( <tt>$</tt> ).</p>
<p class="docText">The <tt>string</tt> module is temporarily resurrected from the dead as the new <tt>Template</tt> class has been added to it. <tt>Template</tt> objects have two methods, <tt>substitute()</tt> and <tt>safe_substitute()</tt>. The former is more strict, throwing <tt>KeyError</tt> exceptions for missing keys while the latter will keep the substitution string intact when there is a missing key:</p>
<div class="docText"><pre>&gt;&gt;&gt; <span class="docEmphStrong">from</span> string <span class="docEmphStrong">import</span> Template
&gt;&gt;&gt; s = Template('There are ${howmany} ${lang} Quotation Symbols')
&gt;&gt;&gt;
&gt;&gt;&gt; <span class="docEmphStrong">print</span> s.substitute(lang='Python', howmany=3)
There are 3 Python Quotation Symbols
&gt;&gt;&gt;
&gt;&gt;&gt; <span class="docEmphStrong">print</span> s.substitute(lang='Python')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
  File "/usr/local/lib/python2.4/string.py", line 172, in substitute
    <span class="docEmphStrong">return</span> self.pattern.sub(convert, self.template)
  File "/usr/local/lib/python2.4/string.py", line 162, in convert
    val = mapping[named]
KeyError: 'howmany'
&gt;&gt;&gt;
&gt;&gt;&gt; <span class="docEmphStrong">print</span> s.safe_substitute(lang='Python')
There are ${howmany} Python Quotation Symbols</pre></div><BR>
<p class="docText">The new string templates were added to Python in version 2.4. More information about them can be found in the Python Library Reference Manual and PEP 292.</P>

<a name="ch06lev2sec9"></a>
<h4 id="title-IDA0TCK" class="docSection2Title">6.4.3. Raw String Operator ( r / R )</h4>
<p class="docText">The purpose of raw strings, introduced back in version 1.5, is to counteract the behavior of the special escape characters that occur in strings (see the subsection below on what some of these characters are). In raw strings, all characters are taken verbatim with no translation to special or non-printed characters.</p>
<p class="docText"><a name="iddle3604"></a>This feature makes raw strings absolutely convenient when such behavior is desired, such as when composing regular expressions (see the <tt>re</tt> module documentation). Regular expressions (REs) are strings that define advanced search patterns for strings and usually consist of special symbols to indicate characters, grouping and matching information, variable names, and character classes. The syntax for REs contains enough symbols already, but when you have to insert additional symbols to make special characters act like normal characters, you end up with a virtual &quot;alphanumersymbolic&quot; soup! Raw strings lend a helping hand by not requiring all the normal symbols needed when composing RE patterns.</p>
<p class="docText">The syntax for raw strings is exactly the same as for normal strings with the exception of the raw string operator, the letter &quot;<span class="docEmphStrong"><tt>r</tt></span>,&quot; which precedes the quotation marks. The &quot;<span class="docEmphStrong"><tt>r</tt></span>&quot; can be lowercase (<span class="docEmphStrong"><tt>r</tt></span>) or uppercase (<span class="docEmphStrong"><tt>R</tt></span>) and must be placed immediately preceding the first quote mark.</p>
<p class="docText">In the first of our three examples, we really want a backslash followed by an '<tt>n</tt>' as opposed to a NEWLINE character:</p>
<div class="docText"><pre>&gt;&gt;&gt; '\n'
'\n'
&gt;&gt;&gt; <span class="docEmphStrong">print</span> '\n'

&gt;&gt;&gt; r'\n'
'\\n'
&gt;&gt;&gt; <span class="docEmphStrong">print</span> r'\n'
\n</pre></div><br>
<p class="docText">Next, we cannot seem to open our README file. Why not? Because the <tt>\t</tt> and <tt>\r</tt> are taken as special symbols which really are not part of our filename, but are <span class="docEmphasis">four</span> individual characters that are part of our file pathname.</p>
<div class="docText"><pre>&gt;&gt;&gt; f = open('C:\windows\temp\readme.txt', 'r')

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
    f = open('C:\windows\temp\readme.txt', 'r')
IOError: [Errno 2] No such file or directory: 'C:\\win-
dows\\temp\readme.txt'
&gt;&gt;&gt; f = open(r'C:\windows\temp\readme.txt', 'r')
&gt;&gt;&gt; f.readline()
'Table of Contents (please check timestamps for last
 update!)\n'
&gt;&gt;&gt; f.close()</pre></div><br>
<p class="docText"><a name="iddle1436"></a><a name="iddle2219"></a><a name="iddle3323"></a><a name="iddle3923"></a><a name="iddle3995"></a><a name="iddle4058"></a><a name="iddle4344"></a>Finally, we are (ironically) looking for a raw pair of characters <tt>\n</tt> and not NEWLINE. In order to find it, we are attempting to use a simple regular expression that looks for backslash-character pairs that are normally single special whitespace characters:</p>
<div class="docText"><pre>  &gt;&gt;&gt; <span class="docEmphStrong">import</span> re
  &gt;&gt;&gt; m = re.search('\\[rtfvn]', r'Hello World!\n')
  &gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
  ...
  &gt;&gt;&gt; m = re.search(r'\\[rtfvn]', r'Hello World!\n')
  &gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
  ...
  '\\n'</pre></div><br>

<a name="ch06lev2sec10"></a>
<h4 id="title-IDACZCK" class="docSection2Title">6.4.4. Unicode String Operator ( u / U )</H4>
<p class="docText">The Unicode string operator, uppercase (<span class="docEmphStrong"><tt>U</tt></span>) and lowercase (<span class="docEmphStrong"><tt>u</tt></span>), introduced with Unicode string support in Python 1.6, takes standard strings or strings with Unicode characters in them and converts them to a full Unicode string object. More details on Unicode strings are available in Section 6.7.4. In addition, Unicode support is available via string methods (<a class="docLink" href="ch06lev1sec6.html#ch06lev1sec6">Section 6.6</a>) and the regular expression engine. Here are some examples:</p>
<div class="docText"><pre>  u'abc'         U+0061 U+0062 U+0063
  u'\u1234'      U+1234
  u'abc\u1234\n' U+0061 U+0062 U+0063 U+1234 U+0012</pre></div><BR>
<p class="docText">The Unicode operator can also accept raw Unicode strings if used in conjunction with the raw string operator discussed in the previous section. The Unicode operator must precede the raw string operator.</p>
<div class="docText"><pre>ur'Hello\nWorld!'</pre></div><BR>


<a href="14051536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch06lev1sec3.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch06lev1sec5.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>