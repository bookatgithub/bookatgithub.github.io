<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 9.3.&nbsp; File Built-in Methods</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch09lev1sec2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch09lev1sec4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a name="ch09lev1sec3"></a>
<h3 id="title-IDAFPA1D" class="docSection1Title">9.3. File Built-in Methods</H3>
<p class="docText">Once <tt>open()</tt> has completed successfully and returned a file object, all subsequent access to the file transpires with that &quot;handle.&quot; File methods come in four different categories: input, output, movement within a file, which we will call &quot;intra-file motion,&quot; and miscellaneous. A summary of all file methods can be found in <a class="docLink" href="#ch09table03">Table 9.3</a>. We will now discuss each category.</p>
<a name="ch09lev2sec3"></a>
<H4 id="title-IDAZPA1D" class="docSection2Title">9.3.1. Input</H4>
<p class="docText">The <tt>read()</tt> method is used to read bytes directly into a string, reading at most the number of bytes indicated. If no <span class="docEmphasis"><tt>size</tt></span> is given (the default value is set to integer <tt>-1</tt>) or <span class="docEmphasis"><tt>size</tt></span> is negative, the file will be read to the end. It will be phased out and eventually removed in a future version of Python.</P>
<p class="docText">The <tt>readline()</tt> method reads one line of the open file (reads all bytes until a line-terminating character like NEWLINE is encountered). The line, including termination character(s), is returned as a string. Like <tt>read()</tt>, there is also an optional <span class="docEmphasis"><tt>size</tt></span> option, which, if not provided, defaults to <tt>-1</tt>, meaning read until the line-ending characters (or EOF) are found. If present, it is possible that an incomplete line is returned if it exceeds <span class="docEmphasis"><tt>size</tt></span> bytes.</P>
<p class="docText">The <tt>readlines()</tt> method does not return a string like the other two input methods. Instead, it reads all (remaining) lines and returns them as a list of strings. Its optional argument, <span class="docEmphasis"><tt>sizhint</tt></span>, is a hint on the maximum size desired in bytes. If provided and greater than zero, approximately <span class="docEmphasis"><tt>sizhint</tt></span> bytes in whole lines are read (perhaps slightly more to round up to the next buffer size) and returned as a list.</p>
<p class="docText"><a name="iddle2000"></a><a name="iddle2008"></a><a name="iddle2019"></a><a name="iddle2020"></a><a name="iddle2669"></a><a name="iddle3374"></a><a name="iddle3552"></a><a name="iddle4535"></a><a name="iddle4538"></a><a name="iddle4551"></a>In <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec1">Python 2.1</a>, a new type of object was used to efficiently iterate over a set of lines from a file: the <tt>xreadlines</tt> object (found in the <tt>xreadlines</tt> module). Calling <span class="docEmphasis"><tt>file</tt></span><tt>.xreadlines()</tt> was equivalent to <tt>xreadlines.xreadlines</tt>(<span class="docEmphasis"><tt>file</tt></span>). Instead of reading all the lines in at once, <tt>xreadlines()</tt> reads in chunks at a time, and thus were optimal for use with <span class="docEmphStrong"><tt>for</tt></span> loops in a memory-conscious way. However, with the introduction of iterators and the new file iteration in <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec3">Python 2.3</a>, it was no longer necessary to have an <tt>xreadlines()</tt> method because it is the same as using <tt>iter</tt>(<span class="docEmphasis"><tt>file</tt></span>), or in a <span class="docEmphStrong"><tt>for</tt></span> loop, is replaced by <span class="docEmphStrong"><tt>for</tt></span> <tt>eachLine</tt> <span class="docEmphStrong"><tt>in</tt></span> <span class="docEmphasis"><tt>file</tt></span>. Easy come, easy go.</p>

<p class="docText">
<img border="0" alt="" id="195131084202" width="50" height="47" SRC="images/2_1_2_3.jpg"></p>


<p class="docText">Another odd bird is the <tt>readinto()</tt> method, which reads the given number of bytes into a writable buffer object, the same type of object returned by the unsupported <tt>buffer()</tt> built-in function. (Since <tt>buffer()</tt> is not supported, neither is <tt>readinto()</tt>.)</P>

<a name="ch09lev2sec4"></a>
<h4 id="title-IDAFWA1D" class="docSection2Title">9.3.2. Output</H4>
<p class="docText">The <tt>write()</tt> built-in method has the opposite functionality as <tt>read()</tt> and <tt>readline()</tt>. It takes a string that can consist of one or more lines of text data or a block of bytes and writes the data to the file.</p>
<p class="docText">The <tt>writelines()</tt> method operates on a list just like <tt>readlines()</tt>, but takes a list of strings and writes them out to a file. Line termination characters are not inserted between each line, so if desired, they must be added to the end of each line before <tt>writelines()</tt> is called.</P>
<p class="docText">Note that there is no &quot;<tt>writeline()</tt>&quot; method since it would be equivalent to calling <tt>write()</tt> with a single line string terminated with a NEWLINE character.</p>
<a name="ch09note01"></a><div class="docNote"><p class="docNoteTitle">Core Note: Line separators are preserved</P><P><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top">
<img border="0" alt="" id="195131084202" align="LEFT" width="50" height="50" SRC="images/core_note.jpg">


</td><td valign="top"><p class="docText"><span class="docEmphasis">When reading lines in from a file using file input methods like</span> <tt>read()</tt> <span class="docEmphasis">or</span> <tt>readlines()</tt><span class="docEmphasis">, Python does not remove the line termination characters. It is up to the programmer. For example, the following code is fairly common to see in Python code:</span></P><div class="docText"><pre>f = open('myFile', 'r')
data = [line.strip() for line in f.readlines()]
f.close()</pre></div><br><p class="docText"><span class="docEmphasis">Similarly, output methods like</span> <tt>write()</tt> <span class="docEmphasis">or</span> <tt>writelines()</tt> <span class="docEmphasis">do not add line terminators for the programmer... you have to do it yourself before writing the data to the file.</span></p></TD></tr></table></p></div><br>

<a name="ch09lev2sec5"></a>

<H4 id="title-IDA3YA1D" class="docSection2Title">9.3.3. Intra-file Motion</H4>
<p class="docText"><a name="iddle1995"></a><a name="iddle1999"></a><a name="iddle2013"></a><a name="iddle2072"></a><a name="iddle2560"></a><a name="iddle2573"></a><a name="iddle2751"></a><a name="iddle2757"></a><a name="iddle3705"></a><a name="iddle4138"></a>The <tt>seek()</tt> method (analogous to the <tt>fseek()</tt> function in C) moves the file pointer to different positions within the file. The offset in bytes is given along with a <span class="docEmphasis">relative offset</span> location, <span class="docEmphasis"><tt>whence</tt></span>. A value of <tt>0</tt>, the default, indicates distance from the beginning of a file (note that a position measured from the beginning of a file is also known as the <span class="docEmphasis">absolute offset</span>), a value of <tt>1</tt> indicates movement from the current location in the file, and a value of <tt>2</tt> indicates that the offset is from the end of the file. If you have used <tt>fseek()</tt> as a C programmer, the values <tt>0</tt>, <tt>1</tt>, and <tt>2</tt> correspond directly to the constants <tt>SEEK_SET</tt>, <tt>SEEK_CUR</tt>, and <tt>SEEK_END</tt>, respectively. Use of the <tt>seek()</tt> method comes into play when opening a file for read and write access.</p>
<p class="docText"><tt>tell()</tt> is a complementary method to <tt>seek()</tt>; it tells you the current location of the filein bytes from the beginning of the file.</p>

<a name="ch09lev2sec6"></a>
<h4 id="title-IDAA3A1D" class="docSection2Title">9.3.4. File Iteration</h4>
<p class="docText">Going through a file line by line is simple:</p>
<div class="docText"><pre><span class="docEmphStrong">for</span> eachLine in <span class="docEmphStrong">f</span>:
     :</pre></div><br>
<p class="docText">Inside this loop, you are welcome to do whatever you need to with <tt>eachLine</tt>, representing a single line of the text file (which includes the trailing line separators).</p>
<p class="docText">Before <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec2">Python 2.2</a>, the best way to read in lines from a file was using <span class="docEmphasis"><tt>file</tt></span><tt>.readlines()</tt> to read in all the data, giving the programmer the ability to free up the file resource as quickly as possible. If that was not a concern, then programmers could call <span class="docEmphasis"><tt>file</tt></span><tt>.readline()</tt> to read in one line at a time. For a brief time, <span class="docEmphasis"><tt>file</tt></span><tt>.xreadlines()</tt> was the most efficient way to read in a file.</p>
<p class="docText">Things all changed in 2.2 when Python introduced iterators and file iteration. In file iteration, file objects became their own iterators, meaning that users could now iterate through lines of a file using a <span class="docEmphStrong"><tt>for</tt></span> loop without having to call <tt>read*()</tt> methods. Alternatively, the iterator next method, <span class="docEmphasis"><tt>file</tt></span><tt>.next()</tt> could be called as well to read in the next line in the file. Like all other iterators, Python will raise <tt>StopIteration</tt> when no more lines are available.</p>

<p class="docText">
<img border="0" alt="" id="195131084202" width="50" height="48" SRC="images/2_2.jpg"></p>


<p class="docText">So remember, if you see this type of code, this is the &quot;old way of doing it,&quot; and you can safely remove the call to <tt>readline()</tt>.</p>
<div class="docText"><pre><span class="docEmphStrong">for</span> eachLine <span class="docEmphStrong">in</span> f.readline():
     :</pre></div><br>
<p class="docText"><a name="iddle1427"></a><a name="iddle1982"></a><a name="iddle1988"></a><a name="iddle1989"></a><a name="iddle1996"></a><a name="iddle2015"></a><a name="iddle2029"></a><a name="iddle2061"></a><a name="iddle2548"></a><a name="iddle4227"></a>File iteration is more efficient, and the resulting Python code is easier to write (and read). Those of you new to Python now are getting all the great new features and do not have to worry about the past.</P>

<a name="ch09lev2sec7"></a>
<h4 id="title-IDAXCB1D" class="docSection2Title">9.3.5. Others</H4>
<p class="docText">The <tt>close()</tt> method completes access to a file by closing it. The Python garbage collection routine will also close a file when the file object reference has decreased to zero. One way this can happen is when only one reference exists to a file, say, <tt>fp = open(...)</tt>, and <tt>fp</tt> is reassigned to another file object before the original file is explicitly closed. Good programming style suggests closing the file before reassignment to another file object. It is possible to lose output data that is buffered if you do not explicitly close a file.</p>
<p class="docText">The <tt>fileno()</tt> method passes back the file descriptor to the open file. This is an integer argument that can be used in lower-level operations such as those featured in the <tt>os</tt> module, i.e., <tt>os.read()</tt>.</P>
<p class="docText">Rather than waiting for the (contents of the) output buffer to be written to disk, calling the <tt>flush()</tt> method will cause the contents of the internal buffer to be written (or flushed) to the file immediately. <tt>isatty()</tt> is a Boolean built-in method that returns <tt>true</tt> if the file is a tty-like device and <tt>False</tt> otherwise. The <tt>TRuncate()</tt> method truncates the file to the size at the current file position or the given <span class="docEmphasis"><tt>size</tt></span> in bytes.</p>

<a name="ch09lev2sec8"></a>
<H4 id="title-IDADEB1D" class="docSection2Title">9.3.6. File Method Miscellany</H4>
<p class="docText">We will now reprise our first file example from <a class="docLink" href="ch02.html#ch02">Chapter 2</a>:</P>
<div class="docText"><pre>filename = raw_input('Enter file name: ')
f = open(filename, 'r')
allLines = f.readlines()
f.close()
<span class="docEmphStrong">for</span> eachLine <span class="docEmphStrong">in</span> allLines:
    <span class="docEmphStrong">print</span> eachLine,  # suppress <span class="docEmphStrong">print</span>'s NEWLINE</pre></div><BR>
<p class="docText">We originally described how this program differs from most standard file access in that all the lines are read ahead of time before any display to the screen occurs. Obviously, this is not advantageous if the file is large. In that case, it may be a good idea to go back to the tried-and-true way of reading and displaying one line at a time using a file iterator:</p>
<div class="docText"><pre>filename = raw_input('Enter file name: ')
f = open(filename, 'r')
<span class="docEmphStrong">for</span> eachLine <span class="docEmphStrong">in</span> f:
    <span class="docEmphStrong">print</span> eachLine,
f.close()</pre></div><br>
<a name="ch09note02"></a><div class="docNote"><p class="docNoteTitle">Core Note: Line separators and other file system inconsistencies</p><P><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top">
<img border="0" alt="" id="195131084202" align="LEFT" width="50" height="50" SRC="images/core_note.jpg">


</td><TD valign="top"><p class="docText"><a name="iddle1164"></a><a name="iddle1165"></a><a name="iddle2001"></a><a name="iddle2005"></a><a name="iddle2670"></a><a name="iddle2763"></a><a name="iddle2984"></a><a name="iddle3073"></a><a name="iddle3075"></a><a name="iddle3441"></a><a name="iddle4365"></a><a name="iddle4516"></a><span class="docEmphasis">One of the inconsistencies of operating systems is the line separator character that their file systems support. On POSIX (Unix family or Mac OS X) systems, the line separator is the NEWLINE ( <tt>\n</tt> ) character. For old MacOS, it is the RETURN ( <tt>\r</tt> ), and DOS and Win32 systems use both ( <tt>\r\n</tt> ). Check your operating system to determine what your line separator(s) are</span>.</p><p class="docText"><span class="docEmphasis">Other differences include the file pathname separator (POSIX uses &quot;/&quot;, DOS and Windows use &quot;\&quot;, and the old MacOS uses &quot;:&quot;), the separator used to delimit a set of file pathnames, and the denotations for the current and parent directories.</span></P><p class="docText"><span class="docEmphasis">These inconsistencies generally add an irritating level of annoyance when creating applications that run on all three platforms (and more if more architectures and operating systems are supported). Fortunately, the designers of the <tt>os</tt> module in Python have thought of this for us. The <tt>os</tt> module has five attributes that you may find useful. They are listed in <a class="docLink" href="#ch09table02">Table 9.2</a>.</span></P><a name="ch09table02"></a><p><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 9.2. <tt>OS</tt> Module Attributes to Aid in Multi-platform Development</h5></caption><colgroup align="left" span="2"><col width="150"><col width="300"></colgroup><thead><tr><th class="thead" scope="col" align="left" valign="bottom"><p class="docText"><tt>os</tt> <span class="docEmphasis">Module</span></P></th><th class="thead" scope="col" align="left" valign="top">&nbsp;</th></tr><tr><th class="thead" scope="col" align="left" valign="bottom"><p class="docText"><span class="docEmphasis">Attribute</span></P></th><th class="thead" scope="col" align="left" valign="bottom"><p class="docText"><span class="docEmphasis">Description</span></p></th></tr></thead><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>linesep</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">String used to separate lines in a file</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sep</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">String used to separate file pathname components</p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>pathsep</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">String used to delimit a set of file pathnames</P></td></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>curdir</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">String name for current working directory</p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pardir</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">String name for parent (of current working directory)</P></td></tr></table></p><br><p class="docText"><span class="docEmphasis">Regardless of your platform, these variables will be set to the correct values when you import the <tt>os</tt> module: One less headache to worry about.</span></P></td></tr></table></P></div><br>
<p class="docText">We would also like to remind you that the comma placed at the end of the <span class="docEmphStrong"><tt>print</tt></span> statement is to suppress the NEWLINE character that <span class="docEmphStrong"><tt>print</tt></span> normally adds at the end of output. The reason for this is because every line from the text file already contains a NEWLINE. <tt>readline()</tt> and <a name="iddle3706"></a><a name="iddle4139"></a><a name="iddle4228"></a><tt>readlines()</tt> do not strip off any whitespace characters in your line (see exercises.) If we omitted the comma, then your text file display would be doublespaced one NEWLINE which is part of the input and another added by the <span class="docEmphStrong"><tt>print</tt></span> statement.</p>
<p class="docText">File objects also have a <tt>truncate()</tt> method, which takes one optional argument, <span class="docEmphasis"><tt>size</tt></span>. If it is given, then the file will be truncated to, at most, <span class="docEmphasis"><tt>size</tt></span> bytes. If you call <tt>TRuncate()</tt> without passing in a size, it will default to the current location in the file. For example, if you just opened the file and call <tt>TRuncate()</tt>, your file will be effectively deleted, truncated to zero bytes because upon opening a file, the &quot;read head&quot; is on byte 0, which is what <tt>tell()</tt> returns.</p>
<p class="docText">Before moving on to the next section, we will show two more examples, the first highlighting output to files (rather than input), and the second performing both file input and output as well as using the <tt>seek()</tt> and <tt>tell()</tt> methods for file positioning.</p>
<div class="docText"><pre>filename = raw_input('Enter file name: ')
fobj = open(filename, 'w')
<span class="docEmphStrong">while</span> True:
   aLine = raw_input("Enter a line ('.' to quit): ")
   <span class="docEmphStrong">if</span> aLine != ".":
     fobj.write('%s%s' % (aLine, os.linesep)
   <span class="docEmphStrong">else:</span>
     break
fobj.close()</pre></div><br>
<p class="docText">Here we ask the user for one line at a time, and send them out to the file. Our call to the <tt>write()</tt> method must contain a NEWLINE because <tt>raw_input()</tt> does not preserve it from the user input. Because it may not be easy to generate an end-of-file character from the keyboard, the program uses the period ( . ) as its end-of-file character, which, when entered by the user, will terminate input and close the file.</p>
<p class="docText">The second example opens a file for read and write, creating the file from scratch (after perhaps truncating an already existing file). After writing data to the file, we move around within the file using <tt>seek()</tt>. We also use the <tt>tell()</tt> method to show our movement.</p>
<div class="docText"><pre>&gt;&gt;&gt; f = open('/tmp/x', 'w+')
&gt;&gt;&gt; f.tell()
0
&gt;&gt;&gt; f.write('test line 1\n')  # add 12-char string [0-11]
&gt;&gt;&gt; f.tell()
12
&gt;&gt;&gt; f.write('test line 2\n')  # add 12-char string [12-23]
&gt;&gt;&gt; f.tell()                  # tell us current file location (end))
24

&gt;&gt;&gt; f.seek(-12, 1)             # move back 12 bytes
&gt;&gt;&gt; f.tell()                   # to beginning of line 2
12
&gt;&gt;&gt; f.readline()
'test line 2\012'
&gt;&gt;&gt; f.seek(0, 0)               # move back to beginning
&gt;&gt;&gt; f.readline()
'test line 1\012'
&gt;&gt;&gt; f.tell()                   # back to line 2 again
12
&gt;&gt;&gt; f.readline()
'test line 2\012'
&gt;&gt;&gt; f.tell()                   # at the end again
24
&gt;&gt;&gt; f.close()                  # close file</pre></div><br>
<p class="docText"><a name="iddle1428"></a><a name="iddle2002"></a><a name="iddle2062"></a><a name="iddle2549"></a><a name="iddle2865"></a><a name="iddle3093"></a><a name="iddle3551"></a><a name="iddle3553"></a><a name="iddle3556"></a><a name="iddle3707"></a><a name="iddle4552"></a><a class="docLink" href="#ch09table03">Table 9.3</a> lists all the built-in methods for file objects.</p>
<a name="ch09table03"></a><p><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 9.3. Methods for File Objects</h5></caption><colgroup align="left" span="2"><col width="200"><col width="300"></colgroup><thead><tr><th class="thead" scope="col" align="left" valign="bottom"><p class="docText"><span class="docEmphasis">File Object Method</span></p></th><th class="thead" scope="col" align="left" valign="bottom"><p class="docText"><span class="docEmphasis">Operation</span></P></th></tr></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>file</tt></span><tt>.close()</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Closes <span class="docEmphasis"><tt>file</tt></span></p></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>file</tt></span><tt>.fileno()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns integer file descriptor (FD) for <span class="docEmphasis"><tt>file</tt></span></P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>file</tt></span><tt>.flush()</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Flushes internal buffer for <span class="docEmphasis"><tt>file</tt></span></p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>file</tt></span><tt>.isatty()</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Returns <tt>true</tt> if <span class="docEmphasis"><tt>file</tt></span> is a tty-like device and <tt>False</tt> otherwise</p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>file</tt></span><tt>.next</tt><sup class="docFootnote"><a class="docLink" href="#ch09tna2">[a]</a></sup><tt>( )</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns the next line in the file [similar to <span class="docEmphasis"><tt>file.readline()</tt></span>] or raises <tt>StopIteration</tt> if no more lines are available</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>file</tt></span><tt>.read(</tt><span class="docEmphasis"><tt>size</tt></span><tt>=-1)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Reads <span class="docEmphasis"><tt>size</tt></span> bytes of file, or all remaining bytes if <span class="docEmphasis"><tt>size</tt></span> not given or is negative, as a string and return it</P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>file</tt></span>.<tt>readinto</tt><sup class="docFootnote"><a class="docLink" href="#ch09tnb1">[b]</a></sup><tt>(</tt><span class="docEmphasis"><tt>buf, size</tt></span><tt>)</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Reads <span class="docEmphasis"><tt>size</tt></span> bytes from <span class="docEmphasis"><tt>file</tt></span> into buffer <span class="docEmphasis"><tt>buf</tt></span> (unsupported)</P></TD></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>file</tt></span><tt>.readline</tt><tt>(</tt><span class="docEmphasis"><tt>size</tt></span><tt>=-1)</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Reads and returns one line from <span class="docEmphasis"><tt>file</tt></span>(includes line-ending characters), either one full line or a maximum of <span class="docEmphasis"><tt>size</tt></span> characters</p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>file</tt></span><tt>.readlines</tt><tt>(</tt><span class="docEmphasis"><tt>sizhint</tt></span><tt>=0)</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Reads and returns all lines from <span class="docEmphasis"><tt>file</tt></span> as a list (includes all line termination characters); if <span class="docEmphasis"><tt>sizhint</tt></span> given and &gt; 0, whole lines are returned consisting of approximately <span class="docEmphasis"><tt>sizhint</tt></span> bytes (could be rounded up to next buffer's worth)</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>file</tt></span><tt>.xreadlines</tt><sup class="docFootnote"><a class="docLink" href="#ch09tnc1">[c]</a></sup><tt>( )</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Meant for iteration, returns lines in <span class="docEmphasis"><tt>file</tt></span> read as chunks in a more efficient way than <tt>readlines()</tt></p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>file</tt></span><tt>.seek</tt><tt>(</tt><span class="docEmphasis"><tt>off, whence</tt></span><tt>=0)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Moves to a location within <span class="docEmphasis"><tt>file</tt></span>, <span class="docEmphasis"><tt>off</tt></span> bytes offset from <span class="docEmphasis"><tt>whence</tt></span> (0 == beginning of file, 1 == current location, or 2 == end of file)</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>file</tt></span><tt>.tell()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns current location within <span class="docEmphasis"><tt>file</tt></span></P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>file</tt></span><tt>.truncate</tt><tt>(</tt><span class="docEmphasis"><tt>size</tt></span><tt>=</tt><span class="docEmphasis"><tt>file</tt></span><tt>.tell())</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Truncates <span class="docEmphasis"><tt>file</tt></span> to at most <span class="docEmphasis"><tt>size</tt></span> bytes, the default being the current file location</P></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>file</tt></span><tt>.write</tt><tt>(</tt><span class="docEmphasis"><tt>str</tt></span><tt>)</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Writes string <span class="docEmphasis"><tt>str</tt></span> to <span class="docEmphasis"><tt>file</tt></span></P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>file</tt></span><tt>.writelines</tt><tt>(</tt><span class="docEmphasis"><tt>seq</tt></span><tt>)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Writes <span class="docEmphasis"><tt>seq</tt></span> of strings to <span class="docEmphasis"><tt>file; seq</tt></span> should be an iterable producing strings; prior to 2.2, it was just a list of strings</p></td></TR></table></p><br><blockquote><p class="docFootnote"><sup><a name="ch09tna2">[a]</a></sup> New in <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec2">Python 2.2</a>.</P></blockquote><blockquote><p class="docFootnote"><sup><a name="ch09tnb1">[b]</a></sup> New in Python 1.5.2 but unsupported.</p></blockquote><blockquote><p class="docFootnote"><sup><a name="ch09tnc1">[c]</a></sup> New in <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec1">Python 2.1</a> but deprecated in <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec3">Python 2.3</a>.</p></blockquote>


</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch09lev1sec2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch09lev1sec4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>