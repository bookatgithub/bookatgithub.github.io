<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 10.3.&nbsp; Detecting and Handling Exceptions</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch10lev1sec2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch10lev1sec4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a href="14051536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a><a name="ch10lev1sec3"></a>
<h3 id="title-IDAPUGZF" class="docSection1Title">10.3. Detecting and Handling Exceptions</H3>
<p class="docText">Exceptions can be detected by incorporating them as part of a <span class="docEmphStrong"><tt>try</tt></span> statement. Any code suite of a <span class="docEmphStrong"><tt>TRy</tt></span> statement will be monitored for exceptions.</P>
<p class="docText">There are two main forms of the <span class="docEmphStrong"><tt>TRy</tt></span> statement: <span class="docEmphStrong"><tt>TRy-except</tt></span> and <span class="docEmphStrong"><tt>try-finally</tt></span>. These statements are mutually exclusive, meaning that you pick only one of them. A <span class="docEmphStrong"><tt>try</tt></span> statement can be accompanied by one or more <span class="docEmphStrong"><tt>except</tt></span> clauses, exactly one <span class="docEmphStrong"><tt>finally</tt></span> clause, or a hybrid <span class="docEmphStrong"><tt>try-except-finally</tt></span> combination.</P>
<p class="docText"><span class="docEmphStrong"><tt>try-except</tt></span> statements allow one to detect and handle exceptions. There is even an optional <span class="docEmphStrong"><tt>else</tt></span> clause for situations where code needs to run only when no exceptions are detected. Meanwhile, <span class="docEmphStrong"><tt>TRy-finally</tt></span> statements allow only for detection and processing of any obligatory cleanup (whether or not exceptions occur), but otherwise have no facility in dealing with exceptions. The combination, as you might imagine, does both.</p>
<a name="ch10lev2sec3"></a>
<H4 id="title-IDAQWGZF" class="docSection2Title">10.3.1. <tt>try-except</tt> Statement</H4>
<p class="docText">The <span class="docEmphStrong"><tt>TRy-except</tt></span> statement (and more complicated versions of this statement) allows you to define a section of code to monitor for exceptions and also provides the mechanism to execute handlers for exceptions.</p>
<p class="docText">The syntax for the most general <span class="docEmphStrong"><tt>try-except</tt></span> statement is given below. It consists of the keywords along with the <span class="docEmphStrong"><tt>try</tt></span> and <span class="docEmphStrong"><tt>except</tt></span> blocks (<tt>try_suite</tt> and <tt>except_suite</tt>) as well as optionally saving the <span class="docEmphStrong"><tt>reason</tt></span> of failure:</P>
<div class="docText"><pre><span class="docEmphStrong">try:</span>
    <span class="docEmphasis">try_suite</span>       # watch for exceptions here
<span class="docEmphStrong">except</span> <span class="docEmphasis">Exception[, reason]</span>:
    <span class="docEmphasis">except_suite</span>    # exception-handling code</pre></div><br>
<p class="docText">Let us give one example, then explain how things work. We will use our <tt>IOError</tt> example from above. We can make our code more robust by adding a <span class="docEmphStrong"><tt>try-except</tt></span> &quot;wrapper&quot; around the code:</P>
<div class="docText"><pre>&gt;&gt;&gt; <span class="docEmphStrong">try:</span>

...     f = open('blah', 'r')

... <span class="docEmphStrong">except</span> IOError, e:

...     <span class="docEmphStrong">print</span> 'could not open file:', e

...

could not open file: [Errno 2] No such file or directory</pre></div><br>
<p class="docText"><a name="iddle1448"></a><a name="iddle1868"></a><a name="iddle1879"></a><a name="iddle1881"></a><a name="iddle1884"></a><a name="iddle2225"></a><a name="iddle2538"></a><a name="iddle3366"></a><a name="iddle4327"></a><a name="iddle4383"></a><a name="iddle4529"></a>As you can see, our code now runs seemingly without errors. In actuality, the same <tt>IOError</tt> still occurred when we attempted to open the nonexistent file. The difference? We added code to both detect and handle the error. When the <tt>IOError</tt> exception was raised, all we told the interpreter to do was to output a diagnostic message. The program continues and does not &quot;bomb out&quot; as our earlier examplea minor illustration of the power of exception handling. So what is really happening codewise?</p>
<p class="docText">During runtime, the interpreter attempts to execute all the code within the <span class="docEmphStrong"><tt>try</tt></span> statement. If an exception does not occur when the code block has completed, execution resumes past the <span class="docEmphStrong"><tt>except</tt></span> statement. When the specified exception named on the <span class="docEmphStrong"><tt>except</tt></span> statement does occur, we save the reason, and control flow immediately continues in the handler (all remaining code in the <span class="docEmphStrong"><tt>TRy</tt></span> clause is skipped) where we display our error message along with the cause of the error.</P>
<p class="docText">In our example above, we are catching only <tt>IOError</tt> exceptions. Any other exception will not be caught with the handler we specified. If, for example, you want to catch an <tt>OSError</tt>, you have to add a handler for that particular exception. We will elaborate on the <span class="docEmphStrong"><tt>try-except</tt></span> syntax more as we progress further in this chapter.</p>
<a name="ch10note01"></a><div class="docNote"><p class="docNoteTitle">Core Note: Skipping code, continuation, and upward propagation</p><p><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top">
<img border="0" alt="" align="LEFT" width="50" height="50" SRC="images/core_note.jpg">


</td><td valign="top"><p class="docText"><span class="docEmphasis">The remaining code in the <span class="docEmphStrong"><tt>try</tt></span> suite from the point of the exception is never reached (hence never executed). Once an exception is raised, the race is on to decide on the continuing flow of control. The remaining code is skipped, and the search for a handler begins. If one is found, the program continues in the handler</span>.</p><p class="docText"><span class="docEmphasis">If the search is exhausted without finding an appropriate handler, the exception is then propagated to the caller's level for handling, meaning the stack frame immediately preceding the current one. If there is no handler at the next higher level, the exception is yet again propagated to its caller. If the top level is reached without an appropriate handler, the exception is considered <tt>unhandled</tt>, and the Python interpreter will display the traceback and exit</span>.</p></td></TR></table></p></div><BR>

<a name="ch10lev2sec4"></a>
<h4 id="title-IDA53GZF" class="docSection2Title">10.3.2. Wrapping a Built-in Function</H4>
<p class="docText">We will now present an interactive examplestarting with the bare necessity of detecting an error, then building continuously on what we have to further improve the robustness of our code. The premise is in detecting errors while <a name="iddle2046"></a>trying to convert a numeric string to a proper (numeric object) representation of its value.</p>
<p class="docText">The <tt>float()</tt> built-in function has a primary purpose of converting any numeric type to a float. In Python 1.5, <tt>float()</tt> was given the added feature of being able to convert a number given in string representation to an actual float value, obsoleting the use of the <tt>atof()</tt> function of the <tt>string</tt> module. Readers with older versions of Python may still use <tt>string.atof(),</tt> replacing <tt>float()</tt>, in the examples we use here.</P>
<div class="docText"><pre>&gt;&gt;&gt; float(12345)
12345.0
&gt;&gt;&gt; float('12345')
12345.0
&gt;&gt;&gt; float('123.45e67')
1.2345e+069</pre></div><br>
<p class="docText">Unfortunately, <tt>float()</tt> is not very forgiving when it comes to bad input:</P>
<div class="docText"><pre>&gt;&gt;&gt; float('foo')
Traceback (innermost last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
    float('foo')
ValueError: invalid literal for float(): foo
&gt;&gt;&gt;
&gt;&gt;&gt; float(['this is', 1, 'list'])
Traceback (innermost last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
    float(['this is', 1, 'list'])
TypeError: float() argument must be a string or a number</pre></div><BR>
<p class="docText">Notice in the errors above that <tt>float()</tt> does not take too kindly to strings that do not represent numbers or non-strings. Specifically, if the correct argument type was given (string type) but that type contained an invalid value, the exception raised would be <tt>ValueError</tt> because it was the value that was improper, not the type. In contrast, a list is a bad argument altogether, not even being of the correct type; hence, <tt>TypeError</tt>was thrown.</P>
<p class="docText">Our exercise is to call <tt>float()</tt>&quot;safely,&quot; or in a more &quot;safe manner,&quot; meaning that we want to ignore error situations because they do not apply to our task of converting numeric string values to floating point numbers, yet are not severe enough errors that we feel the interpreter should abandon execution. To accomplish this, we will create a &quot;wrapper&quot; function, and, with the help of <span class="docEmphStrong"><tt>TRy-except</tt></span>, create the environment that we envisioned. We shall call it <tt>safe_float()</tt>. In our first iteration, we will scan and ignore only <tt>ValueError</tt>s, because they are the more likely culprit. <tt>TypeError</tt>s rarely happen since somehow a non-string must be given to <tt>float()</tt>.</p>
<div class="docText"><pre><span class="docEmphStrong">def</span> safe_float(obj):
   <span class="docEmphStrong">try:
       return</span> float(obj)
   <span class="docEmphStrong">except</span> ValueError:
       pass</pre></div><br>
<p class="docText">The first step we take is to just &quot;stop the bleeding.&quot; In this case, we make the error go away by just &quot;swallowing it.&quot; In other words, the error will be detected, but since we have nothing in the <span class="docEmphStrong"><tt>except</tt></span> suite (except the <span class="docEmphStrong"><tt>pass</tt></span> statement, which does nothing but serve as a syntactical placeholder for where code is supposed to go), no handling takes place. We just ignore the error.</p>
<p class="docText">One obvious problem with this solution is that we did not explicitly return anything to the function caller in the error situation. Even though <tt>None</tt> is returned (when a function does not return any value explicitly, i.e., completing execution without encountering a <span class="docEmphStrong"><tt>return</tt></span> <tt>object</tt> statement), we give little or no hint that anything wrong took place. The very least we should do is to explicitly return <tt>None</tt> so that our function returns a value in both cases and makes our code somewhat easier to understand:</P>
<div class="docText"><pre><span class="docEmphStrong">def</span> safe_float(obj):
    <span class="docEmphStrong">try:</span>
         retval = float(obj)
    <span class="docEmphStrong">except</span> ValueError:
        retval = None
    <span class="docEmphStrong">return</span> retval</pre></div><br>
<p class="docText">Bear in mind that with our change above, nothing about our code changed except that we used one more local variable. In designing a well-written application programmer interface (API), you may have kept the return value more flexible. Perhaps you documented that if a proper argument was passed to <span class="docEmphasis"><tt>safe_float()</tt></span>, then indeed, a floating point number would be returned, but in the case of an error, you chose to return a string indicating the problem with the input value. We modify our code one more time to reflect this change:</P>
<div class="docText"><pre><span class="docEmphStrong">def</span> safe_float(obj):
     <span class="docEmphStrong">try:</span>
         retval = float(obj)
     <span class="docEmphStrong">except</span> ValueError:
          retval = 'could not convert non-number to float'
     <span class="docEmphStrong">return</span> retval</pre></div><br>
<p class="docText"><a name="iddle1834"></a><a name="iddle1873"></a><a name="iddle4230"></a>The only thing we changed in the example was to return an error string as opposed to just <tt>None</tt>. We should take our function out for a test drive to see how well it works so far:</P>
<div class="docText"><pre>&gt;&gt;&gt; safe_float('12.34')
12.34
&gt;&gt;&gt; safe_float('bad input')
'could not convert non-number to float'</pre></div><br>
<p class="docText">We made a good startnow we can detect invalid string input, but we are still vulnerable to invalid <span class="docEmphasis">objects</span> being passed in:</P>
<div class="docText"><pre>&gt;&gt;&gt; safe_float({'a': 'Dict'})
Traceback (innermost last):
  File &quot;&lt;stdin&gt;&quot;, line 3, in ?
    retval = float(obj)
TypeError: float() argument must be a string or a number</pre></div><BR>
<p class="docText">We will address this final shortcoming momentarily, but before we further modify our example, we would like to highlight the flexibility of the <span class="docEmphStrong"><tt>try-except</tt></span> syntax, especially the <span class="docEmphStrong"><tt>except</tt></span> statement, which comes in a few more flavors.</p>

<a name="ch10lev2sec5"></a>
<h4 id="title-IDAZFHZF" class="docSection2Title">10.3.3. <tt>try</tt> Statement with Multiple <tt>excepts</tt></H4>
<p class="docText">Earlier in this chapter, we introduced the following general syntax for <span class="docEmphStrong"><tt>except</tt></span>:</p>
<div class="docText"><pre><span class="docEmphStrong">except</span> Exception[, reason]:
     suite_for_exception_Exception</pre></div><br>
<p class="docText">The <span class="docEmphStrong"><tt>except</tt></span> statement in such formats specifically detects exceptions named <tt>Exception</tt>. You can chain multiple <span class="docEmphStrong"><tt>except</tt></span> statements together to handle different types of exceptions with the same <span class="docEmphStrong"><tt>TRy</tt></span>:</p>
<div class="docText"><pre><span class="docEmphStrong">except</span> Exception1[, reason1]:
     suite_for_exception_Exception1
<span class="docEmphStrong">except</span> Exception2[, reason2]:
     suite_for_exception_Exception2
                 :</pre></div><br>
<p class="docText">This same <span class="docEmphStrong"><tt>try</tt></span> clause is attempted, and if there is no error, execution continues, passing all the <span class="docEmphStrong"><tt>except</tt></span> clauses. However, if an exception <span class="docEmphasis">does</span> occur, the interpreter will look through your list of handlers attempting to match the exception with one of your handlers (<span class="docEmphStrong"><tt>except</tt></span> clauses). If one is found, execution proceeds to <span class="docEmphasis">that</span> <span class="docEmphStrong"><tt>except</tt></span> suite.</P>
<p class="docText">Our <tt>safe_float()</tt>function has some brains now to detect specific exceptions. Even smarter code would handle each appropriately. To do that, we have to have separate <span class="docEmphStrong"><tt>except</tt></span> statements, one for each exception type. That is no problem as Python allows <tt>except</tt>statements can be chained <a name="iddle1859"></a>together. We will now create separate messages for each error type, providing even more detail to the user as to the cause of his or her problem:</P>
<div class="docText"><pre><span class="docEmphStrong">def</span> safe_float(obj):
    <span class="docEmphStrong">try:</span>
         retval = float(obj)
    <span class="docEmphStrong">except</span> ValueError:
        retval = 'could not convert non-number to float'
    <span class="docEmphStrong">except</span> TypeError:
        retval = 'object type cannot be converted to float'
    <span class="docEmphStrong">return</span> retval</pre></div><br>
<p class="docText">Running the code above with erroneous input, we get the following:</p>
<div class="docText"><pre>&gt;&gt;&gt; safe_float('xyz')
'could not convert non-number to float'
&gt;&gt;&gt; safe_float(())
'argument must be a string'
&gt;&gt;&gt; safe_float(200L)
200.0
&gt;&gt;&gt; safe_float(45.67000)
45.67</pre></div><br>

<a name="ch10lev2sec6"></a>
<h4 id="title-IDAOKHZF" class="docSection2Title">10.3.4. <tt>except</tt> Statement with Multiple Exceptions</h4>
<p class="docText">We can also use the same <span class="docEmphStrong"><tt>except</tt></span> clause to handle multiple exceptions. <span class="docEmphStrong"><tt>except</tt></span> statements that process more than one exception require that the set of exceptions be contained in a tuple:</p>
<div class="docText"><pre><span class="docEmphStrong">except</span> (Exception1, Exception2)[, reason]:
   suite_for_Exception1_and_Exception2</pre></div><br>
<p class="docText">The above syntax example illustrates how two exceptions can be handled by the same code. In general, any number of exceptions can follow an <span class="docEmphStrong"><tt>except</tt></span> statement as long as they are all properly enclosed in a tuple:</p>
<div class="docText"><pre><span class="docEmphStrong">except</span> (Exc1[, Exc2[, ... ExcN]])[, reason]:
   suite_for_exceptions_Exc1_to_ExcN</pre></div><br>
<p class="docText">If for some reason, perhaps due to memory constraints or dictated as part of the design that all exceptions for our <tt>safe_float()</tt>function must be handled by the same code, we can now accommodate that requirement:</p>
<div class="docText"><pre><span class="docEmphStrong">def</span> safe_float(obj):
    <span class="docEmphStrong">try:</span>
        retval = float(obj)
    <span class="docEmphStrong">except</span> (ValueError, TypeError):
        retval = 'argument must be a number or numeric string'
    <span class="docEmphStrong">return</span> retval</pre></div><br>
<p class="docText"><a name="iddle1835"></a><a name="iddle1849"></a>Now there is only the single error string returned on erroneous input:</p>
<div class="docText"><pre>&gt;&gt;&gt; safe_float('Spanish Inquisition')
'argument must be a number or numeric string'
&gt;&gt;&gt; safe_float([])
'argument must be a number or numeric string'
&gt;&gt;&gt; safe_float('1.6')
1.6
&gt;&gt;&gt; safe_float(1.6)
1.6
&gt;&gt;&gt; safe_float(932)
932.0</pre></div><BR>

<a name="ch10lev2sec7"></a>
<h4 id="title-IDAVNHZF" class="docSection2Title">10.3.5. Catching All Exceptions</H4>
<p class="docText">Using the code we saw in the previous section, we are able to catch any number of specific exceptions and handle them. What about cases where we want to catch <span class="docEmphasis">all</span> exceptions? The short answer is yes, we can definitely do it. The code for doing it was significantly improved in 1.5 when exceptions became classes. Because of this, we now have an exception hierarchy to follow.</p>
<p class="docText">If we go all the way up the exception tree, we find <tt>Exception</tt> at the top, so our code will look like this:</P>
<div class="docText"><pre><span class="docEmphStrong">try:</span>
    :
<span class="docEmphStrong">except</span> Exception, e:
     # error occurred, log 'e', etc.</pre></div><br>
<p class="docText">Less preferred is the bare <span class="docEmphStrong">except</span> clause:</P>
<div class="docText"><pre><span class="docEmphStrong">try:</span>
    :
<span class="docEmphStrong">except:</span>
     # error occurred, etc.</pre></div><br>
<p class="docText">This syntax is not as &quot;Pythonic&quot; as the other. Although this code catches the most exceptions, it does not promote good Python coding style. One of the chief reasons is that it does not take into account the potential root causes of problems that may generate exceptions. Rather than investigating and discovering what types of errors may occur and how they may be prevented from happening, we have a catch-all that may not do the right thing.</P>
<p class="docText">We are not naming any specific exceptions to catchit does not give us any information about the possible errors that could happen in our <tt>TRy</tt> block. Another thing is that by catching all errors, you may be silently dropping important errors that really should be sent to the caller to properly take care of them. Finally, we do not have the opportunity to save the reason for <a name="iddle1195"></a><a name="iddle1836"></a><a name="iddle2597"></a><a name="iddle4119"></a>the exception. Yes, you can get it through <tt>sys.exc_ info()</tt>, but then you would have to import <tt>sys</tt> and execute that functionboth of which can be avoided, especially if all we wanted was the instance telling us why the exception occurred. It is a distinct possibility that the bare exception clause will be deprecated in a future release of Python. (See also <a class="docLink" href="#ch10note02">Core Style</a> note).</P>
<p class="docText">One aspect of catching all exceptions that you need to be aware of is that there are several exceptions that are not due to an error condition. These two exceptions are <tt>SystemExit</tt> and <tt>KeyboardInterrupt</tt>. <tt>SystemExit</tt> is for when the current Python application wants to quit, and <tt>KeyboardInterrupt</tt> is when a user presses CTRL-C (^C) to terminate Python. These will be caught by both code snippets above when we really want to pass them upward. A typical workaround code pattern will look like this:</P>
<div class="docText"><pre><span class="docEmphStrong">try:</span>
    :
<span class="docEmphStrong">except</span> (KeyboardInterupt, SystemExit):
    # user wants to quit
    <span class="docEmphStrong">raise</span>                 # reraise back to caller
<span class="docEmphStrong">except</span> Exception:
    # handle real errors</pre></div><br>
<p class="docText">A few things regarding exceptions did change in Python 2.5. Exceptions were moved to new-style classes, a new &quot;mother of all exception&quot; classes named <tt>BaseException</tt> was installed, and the exception hierarchy was switched around (very slightly) to get rid of that idiom of having to create two handlers. Both <tt>KeyboardInterrupt</tt> and <tt>SystemExit</tt> have been pulled out from being children of <tt>Exception</tt> to being its peers:</p>

<p class="docText">
<img border="0" alt="" width="50" height="47" SRC="images/2_5.jpg"></p>


<div class="docText"><pre>- BaseException
  |- KeyboardInterrupt
  |- SystemExit
  |- Exception
     |- (all other current built-in exceptions)</pre></div><BR>
<p class="docText">You can find the entire exception hierarchy (before and after these changes) in <a class="docLink" href="ch10lev1sec8.html#ch10table02">Table 10.2</a>.</p>
<p class="docText">The end result is that now you do not have to write the extra handler for those two exceptions if you have a handler for just <tt>Exception</tt>. This code will suffice:</P>
<div class="docText"><pre><span class="docEmphStrong">try:</span>
    :
<span class="docEmphStrong">except</span> Exception, e:
     # handle real errors</pre></div><br>
<p class="docText"><a name="iddle1096"></a><a name="iddle1196"></a><a name="iddle1823"></a><a name="iddle1827"></a><a name="iddle1845"></a><a name="iddle1875"></a><a name="iddle4234"></a>If you really want to catch all errors, you can still do that too, but use <tt>BaseException</tt> instead:</P>
<div class="docText"><pre><span class="docEmphStrong">try:</span>
    :
<span class="docEmphStrong">except</span> BaseException, e:
     # handle all errors</pre></div><br>
<p class="docText">And of course, there is the less preferred bare <span class="docEmphStrong"><tt>except</tt></span>.</P>
<a name="ch10note02"></a><div class="docNote"><p class="docNoteTitle">Core Style: Do not handle and ignore all errors</P><p><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top">
<img border="0" alt="" align="LEFT" width="50" height="46" SRC="images/core_style.jpg">


</td><TD valign="top"><p class="docText"><span class="docEmphasis">The <span class="docEmphStrong"><tt>try-except</tt></span> statement has been included in Python to provide a powerful mechanism for programmers to track down potential errors and perhaps to provide logic within the code to handle situations where it may not otherwise be possible, for example, in C. The main idea is to minimize the number of errors and still maintain program correctness. As with all tools, they must be used properly.</span></p><p class="docText"><span class="docEmphasis">One incorrect use of <span class="docEmphStrong"><tt>TRy-except</tt></span> is to serve as a giant bandage over large pieces of code. By that we mean putting large blocks, if not your entire source code, within a <span class="docEmphStrong"><tt>try</tt></span> <span class="docEmphasis">and/or have a large generic</span> <span class="docEmphStrong"><tt>except</tt></span> to &quot;filter&quot; any fatal errors by ignoring them:</span></p><div class="docText"><pre># this is really bad code
<span class="docEmphStrong">try:</span>
    large_block_of_code  # bandage of large piece of code
<span class="docEmphStrong">except</span> Exception:     # same as except:
    <span class="docEmphStrong">pass</span>              # blind eye ignoring all errors</pre></div><br><p class="docText"><span class="docEmphasis">Obviously, errors cannot be avoided, and the job of <span class="docEmphStrong"><tt>TRy-except</tt></span> is to provide a mechanism whereby an acceptable problem can be remedied or properly dealt with, and not be used as a filter. The construct above will hide many errors, but this type of usage promotes a poor engineering practice that we certainly cannot endorse.</span></P><p class="docText"><span class="docEmphasis">Bottom line: Avoid using <span class="docEmphStrong"><tt>try-except</tt></span> around a large block of code with a <span class="docEmphStrong"><tt>pass</tt></span> just to hide errors. Instead, either handle specific exceptions and ignore them (<span class="docEmphStrong"><tt>pass</tt></span>), or handle all errors and take a specific action. Do not do both (handle all errors, ignore all errors).</span></p></td></tr></table></p></div><br>

<a name="ch10lev2sec8"></a>
<h4 id="title-IDAHZI3D" class="docSection2Title">10.3.6. &quot;Exceptional Arguments&quot;</h4>
<p class="docText">No, the title of this section has nothing to do with having a major fight. Instead, we are referring to the fact that an exception may have an <span class="docEmphasis">argument</span> <a name="iddle1837"></a><a name="iddle2539"></a><a name="iddle3560"></a><a name="iddle3945"></a>or <span class="docEmphasis">reason</span> passed along to the exception handler when they are raised. When an exception is raised, parameters are generally provided as an additional aid for the exception handler. Although reasons for exceptions are optional, the standard built-in exceptions do provide at least one argument, an error string indicating the cause of the exception.</p>
<p class="docText">Exception parameters can be ignored in the handler, but the Python provides syntax for saving this value. We have already seen it in the syntax above: to access any provided exception reason, you must reserve a variable to hold the argument. This argument is given on the <span class="docEmphStrong"><tt>except</tt></span> header line and follows the exception type you are handling. The different syntaxes for the <span class="docEmphStrong"><tt>except</tt></span> statement can be extended to the following:</p>
<div class="docText"><pre># single exception
<span class="docEmphStrong">except</span> <span class="docEmphasis">Exception</span>[, <span class="docEmphasis">reason</span>]:
     <span class="docEmphasis">suite_for_Exception_with_Argument</span>

# multiple exceptions
<span class="docEmphStrong">except</span> (<span class="docEmphasis">Exception1, Exception2, ..., ExceptionN</span>)[, <span class="docEmphasis">reason</span>]:
     <span class="docEmphasis">suite_for_Exception1_to_ExceptionN_with_Argument</span></pre></div><br>
<p class="docText"><span class="docEmphasis">reason</span> is a class instance containing diagnostic information from the code raising the exception. The exception arguments themselves go into a tuple that is stored as an attribute of the class instance, an instance of the exception class from which it was instantiated. In the first alternate syntax above, <span class="docEmphasis"><tt>reason</tt></span> is an instance of the <tt>Exception</tt> class.</p>
<p class="docText">For most standard built-in exceptions, that is, exceptions derived from <tt>StandardError</tt>, the tuple consists of a single string indicating the cause of the error. The actual exception name serves as a satisfactory clue, but the error string enhances the meaning even more. Operating system or other environment type errors, i.e., <tt>IOError</tt>, will also include an operating system error number that precedes the error string in the tuple.</P>
<p class="docText">Whether a <span class="docEmphasis"><tt>reason</tt></span> contains just a string or a combination of an error number and a string, calling <tt>str</tt>(<span class="docEmphasis"><tt>reason</tt></span>) should present a human-readable cause of an error. However, do not lose sight that <span class="docEmphasis"><tt>reason</tt></span> is really a class instanceyou are only getting the error information via that class's special method <tt>__str__()</tt>. We have a complete treatment of special methods as we explore object-oriented programming in <a class="docLink" href="ch13.html#ch13">Chapter 13</a>.</p>
<p class="docText">The only caveat is that not all exceptions raised in third-party or otherwise external modules adhere to this standard protocol of error string or error number and error string. We recommend you follow such a standard when raising your own exceptions (see <a class="docLink" href="#ch10note03">Core Style</a> note).</P>
<a name="ch10note03"></a><div class="docNote"><p class="docNoteTitle">Core Style: Follow exception argument protocol</p><P><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top">
<img border="0" alt="" align="LEFT" width="50" height="46" SRC="images/core_style.jpg">


</td><TD valign="top"><p class="docText"><a name="iddle2047"></a><a name="iddle4308"></a><a name="iddle4421"></a><span class="docEmphasis">When you raise built-in exceptions in your own code, try to follow the protocol established by the existing Python code as far as the error information that is part of the tuple passed as the exception argument. In other words, if you raise a <tt>ValueError</tt>, provide the same argument information as when the interpreter raises a <tt>ValueError</tt> exception, and so on. This helps keep the code consistent and will prevent other applications that use your module from breaking.</span></P></TD></TR></table></p></div><br>
<p class="docText">The example below is when an invalid object is passed to the <tt>float()</tt> built-in function, resulting in a <tt>TypeError</tt> exception:</p>
<div class="docText"><pre>&gt;&gt;&gt; <span class="docEmphStrong">try:</span>
...    float(['float() does not', 'like lists', 2])
... <span class="docEmphStrong">except</span> TypeError, diag:# capture diagnostic info
...    <span class="docEmphStrong">pass</span>
...
&gt;&gt;&gt; type(diag)
&lt;class 'exceptions.TypeError'&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; <span class="docEmphStrong">print</span> diag
float() argument must be a string or a number</pre></div><BR>
<p class="docText">The first thing we did was cause an exception to be raised from within the <span class="docEmphStrong"><tt>try</tt></span> statement. Then we passed cleanly through by ignoring but saving the error information. Calling the <tt>type()</tt> built-in function, we were able to confirm that our exception was indeed an instance of the <tt>TypeError</tt> exception class. Finally, we displayed the error by calling <tt>print</tt> with our diagnostic exception argument.</P>
<p class="docText">To obtain more information regarding the exception, we can use the special <tt>__class__</tt> instance attribute, which identifies which class an instance was instantiated from. Class objects also have attributes, such as a documentation string and a string name that further illuminate the error type:</p>
<div class="docText"><pre>&gt;&gt;&gt; diag                     # exception instance object
&lt;exceptions.TypeError instance at 8121378&gt;
&gt;&gt;&gt; diag.__class__           # exception class object
&lt;class exceptions.TypeError at 80f6d50&gt;
&gt;&gt;&gt; diag.__class__.__doc__   # exception class documentation string
'Inappropriate argument type.'
&gt;&gt;&gt; diag.__class__.__name__  # exception class name
'TypeError'</pre></div><BR>
<p class="docText">As we will discover in <a class="docLink" href="ch13.html#ch13">Chapter 13</a>Classes and OOP the special instance attribute <tt>__class__</tt> exists for all class instances, and the <tt>__doc__</tt> class attribute is available for all classes that define their documentation strings.</p>
<p class="docText">We will now update our <tt>safe_float()</tt> one more time to include the exception argument, which is passed from the interpreter from within <tt>float()</tt>when exceptions are generated. In our last modification to <tt>safe_float()</tt>, we merged <a name="iddle1551"></a><a name="iddle1857"></a><a name="iddle1885"></a><a name="iddle4309"></a><a name="iddle4422"></a>both the handlers for the <tt>ValueError</tt> and <tt>TypeError</tt> exceptions into one because we had to satisfy some requirement. The problem, if any, with this solution is that no clue is given as to which exception was raised or what caused the error. The only thing returned is an error string that indicated some form of invalid argument. Now that we have the exception argument, this no longer has to be the case.</P>
<p class="docText">Because each exception will generate its own exception argument, if we chose to return this string rather than a generic one we made up, it would provide a better clue as to the source of the problem. In the following code snippet, we replace our single error string with the string representation of the exception argument.</P>
<div class="docText"><pre><span class="docEmphStrong">def</span> safe_float(object):
  <span class="docEmphStrong">try:</span>
      retval = float(object)
  <span class="docEmphStrong">except</span> (ValueError, TypeError), diag:
      retval = str(diag)
  <span class="docEmphStrong">return</span> retval</pre></div><br>
<p class="docText">Upon running our new code, we obtain the following (different) messages when providing improper input to <tt>safe_float()</tt>, even if both exceptions are managed by the same handler:</p>
<div class="docText"><pre>&gt;&gt;&gt; safe_float('xyz')
'invalid literal for float(): xyz'
&gt;&gt;&gt; safe_float({})
'object can't be converted to float'</pre></div><br>

<a name="ch10lev2sec9"></a>
<h4 id="title-IDA0DJ3D" class="docSection2Title">10.3.7. Using Our Wrapped Function in an Application</H4>
<p class="docText">We will now feature <tt>safe_float()</tt> in a mini application that takes a credit card transaction data file (<tt>carddata.txt</tt>) and reads in all transactions, including explanatory strings. Here are the contents of our example <tt>carddata.txt</tt> file:</p>
<div class="docText"><pre>% cat carddata.txt
# carddata.txt
previous balance
25
debits
21.64
541.24
25
credits
-25
-541.24
finance charge/late fees
7.30
5</pre></div><br>
<p class="docText">Our program, <tt>cardrun.py</tt>, is given in <a class="docLink" href="#ch10list01">Example 10.1</a>.</P>
<a name="ch10list01"></a><h5 id="title-IDACFJ3D" class="docExampleTitle">Example 10.1. Credit Card Transactions (<tt>cardrun.py</tt>)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>


<p class="docText"><span class="docEmphasis">We use safe_float() to process a set of credit card transactions given in a file and read in as strings. A log file tracks the processing.</span></p>

<pre>1  #!/usr/bin/env python
2
3  <span class="docEmphStrong">def</span> safe_float(obj):
4    'safe version of float()'
5    <span class="docEmphStrong">try:</span>
6        retval = float(obj)
7    <span class="docEmphStrong">except</span> (ValueError, TypeError), diag:
8        retval = str(diag)
9    <span class="docEmphStrong">return</span> retval
10
11 <span class="docEmphStrong">def</span> main():
12   'handles all the data processing'
13   log = open('cardlog.txt', 'w')
14   <span class="docEmphStrong">try:</span>
15       ccfile = open('carddata.txt', 'r')
16   <span class="docEmphStrong">except</span> IOError, e:
17       log.write('no txns this month\n')
18       log.close()
19       <span class="docEmphStrong">return</span>
20
21   txns = ccfile.readlines()
22   ccfile.close()
23   total = 0.00
24   log.write('account log:\n')
25
26   <span class="docEmphStrong">for</span> eachTxn <span class="docEmphStrong">in</span> txns:
27       result = safe_float(eachTxn)
28       <span class="docEmphStrong">if</span> isinstance(result, float):
29           total += result
30           log.write('data... processed\n')
31       <span class="docEmphStrong">else:</span>
32           log.write('ignored: %s' % result)
33   <span class="docEmphStrong">print</span> '$%.2f (new balance)' % (total)
34   log.close()
35
36   <span class="docEmphStrong">if</span> __name__ == '__main__':
37    main()</pre><br>

</td></tr></table></p>
<a name="ch10lev3sec1"></a>

<h5 id="title-IDAQHJ3D" class="docSection3Title">Line-by-Line Explanation</h5>
<a name="ch10lev4sec1"></a>
<h5 id="title-IDAZHJ3D" class="docSection4Title">Lines 39</h5>
<p class="docText">This chunk of code contains the body of our <tt>safe_float()</tt> function.</p>

<a name="ch10lev4sec2"></a>
<h5 id="title-IDALIJ3D" class="docSection4Title">Lines 1134</h5>
<p class="docText">The core part of our application performs three major tasks: (1) read the credit card data file, (2) process the input, and (3) display the result. Lines 14-22 perform the extraction of data from the file. You will notice that there is a <span class="docEmphStrong"><tt>TRy-except</tt></span> statement surrounding the file open.</p>
<p class="docText">A log file of the processing is also kept. In our example, we are assuming the log file can be opened for write without any problems. You will find that our progress is kept by the log. If the credit card data file cannot be accessed, we will assume there are no transactions for the month (lines 16-19).</P>
<p class="docText">The data are then read into the <tt>txns</tt> (transactions) list where it is iterated over in lines 26-32. After every call to <tt>safe_float()</tt>, we check the result type using the <tt>isinstance()</tt> built-in function. In our example, we check to see if <tt>safe_float()</tt> returns a string or float. Any string indicates an error situation with a string that could not be converted to a number, while all other values are floats that can be added to the running subtotal. The final new balance is then displayed as the final line of the <tt>main()</tt> function.</P>

<a name="ch10lev4sec3"></a>
<h5 id="title-IDALJJ3D" class="docSection4Title">Lines 3637</H5>
<p class="docText">These lines represent the general &quot;start only if not imported&quot; functionality.Upon running our program, we get the following output:</p>
<div class="docText"><pre>$ cardrun.py
$58.94 (new balance)</pre></div><BR>
<p class="docText">Taking a peek at the resulting log file (<tt>cardlog.txt</tt>), we see that it contains the following log entries after <tt>cardrun.py</tt> processed the transactions found in <tt>carddata.txt:</tt></P>
<div class="docText"><pre>$ cat cardl og.txt
account log:
ignored: invalid literal for float(): # carddata.txt
ignored: invalid literal for float(): previous balance
data... processed
ignored: invalid literal for float(): debits
data... processed
data... processed
data... processed
ignored: invalid literal for float(): credits
data... processed

data... processed
ignored: invalid literal for float(): finance charge/
late fees
data... processed
data... processed</pre></div><BR>



<a name="ch10lev2sec11"></a>
<H4 id="title-IDATKJ3D" class="docSection2Title">10.3.8. <tt>else</tt> Clause</h4>
<p class="docText"><a name="iddle1507"></a><a name="iddle1783"></a><a name="iddle1784"></a><a name="iddle1856"></a><a name="iddle1860"></a><a name="iddle1876"></a><a name="iddle2041"></a><a name="iddle4231"></a><a name="iddle4235"></a>We have seen the <span class="docEmphStrong"><tt>else</tt></span> statement with other Python constructs such as conditionals and loops. With respect to <span class="docEmphStrong"><tt>try-except</tt></span> statements, its functionality is not that much different from anything else you have seen: The <span class="docEmphStrong"><tt>else</tt></span> clause executes if no exceptions were detected in the preceding <span class="docEmphStrong"><tt>try</tt></span> suite.</P>
<p class="docText">All code within the <span class="docEmphStrong"><tt>try</tt></span> suite must have completed successfully (i.e., concluded with no exceptions raised) before any code in the <span class="docEmphStrong"><tt>else</tt></span> suite begins execution. Here is a short example in Python pseudocode:</P>
<div class="docText"><pre><span class="docEmphStrong">import</span> <span class="docEmphasis">3rd_party_module</span>

log = open('logfile.txt', 'w')

<span class="docEmphStrong">try:</span>
    <span class="docEmphasis">3rd_party_module.function()</span>
<span class="docEmphStrong">except:</span>
    log.write(&quot;*** caught exception in module\n&quot;)
<span class="docEmphStrong">else:</span>
    log.write(&quot;*** no exceptions caught\n&quot;)

log.close()</pre></div><br>
<p class="docText">In the preceding example, we import an external module and test it for errors. A log file is used to determine whether there were defects in the third-party module code. Depending on whether an exception occurred during execution of the external function, we write differing messages to the log.</P>

<a name="ch10lev2sec12"></a>
<h4 id="title-IDAGPJ3D" class="docSection2Title">10.3.9. <tt>finally</tt> Clause</H4>
<p class="docText">A <span class="docEmphStrong"><tt>finally</tt></span> clause is one where its suite or block of code is executed regardless of whether an exception occurred or whether it was caught (or not). You may use a <span class="docEmphStrong"><tt>finally</tt></span> clause with <span class="docEmphStrong"><tt>TRy</tt></span> by itself or with <span class="docEmphStrong"><tt>try-except</tt></span> (with or without an <span class="docEmphStrong"><tt>else</tt></span> clause). The standalone <span class="docEmphStrong"><tt>try-finally</tt></span> is covered in the next section, so we will just focus on the latter here.</p>

<p class="docText">
<img border="0" alt="" width="50" height="47" SRC="images/2_5.jpg"></p>


<p class="docText">Starting in Python 2.5, you can use the <span class="docEmphStrong"><tt>finally</tt></span> clause (again) with <span class="docEmphStrong"><tt>TRy-except</tt></span> or <span class="docEmphStrong"><tt>try-except-else</tt></span>. We say &quot;again&quot; because believe it or not, it is not a new feature. This was a feature available in Python back in the early days but was removed in Python 0.9.6 (April 1992). At the time, it helped simplify <a name="iddle1878"></a><a name="iddle4239"></a>the bytecode generation process and was easier to explain, and van Rossum believed that a unified <span class="docEmphStrong"><tt>try-except</tt></span> (<span class="docEmphStrong"><tt>-else</tt></span>)<span class="docEmphStrong"><tt>-finally</tt></span> would not be very popular anyway. How things change well over a decade later!</P>
<p class="docText">Here is what the syntax would look like with <span class="docEmphStrong"><tt>try-except-else-finally</tt></span>:</p>
<div class="docText"><pre><span class="docEmphStrong">try:</span>
    A
<span class="docEmphStrong">except</span> MyException:
    B
<span class="docEmphStrong">else:</span>
    C
<span class="docEmphStrong">finally:</span>
    D</pre></div><br>
<p class="docText">The equivalent in Python 0.9.6 through 2.4.x. is the longer:</P>
<div class="docText"><pre><span class="docEmphStrong">try:</span>
    <span class="docEmphStrong">try:</span>
         A
    <span class="docEmphStrong">except</span> MyException:
         B
    <span class="docEmphStrong">else:</span>
         C
<span class="docEmphStrong">finally:</span>
     D</pre></div><BR>
<p class="docText">Of course, in either case, you can have more than one <span class="docEmphStrong"><tt>except</tt></span> clause, however the syntax requires at least one <tt>except</tt> clause and both the <span class="docEmphStrong"><tt>else</tt></span> and <span class="docEmphStrong"><tt>finally</tt></span> clauses are optional. <span class="docEmphasis"><tt>A,B,C</tt></span>, and <span class="docEmphasis"><tt>D</tt></span> are suites (code blocks). The suites will execute in that order as necessary. (Note the only flows possible are <span class="docEmphasis">A-C-D</span> [normal] and <span class="docEmphasis">A-B-D</span> [exception].) The <span class="docEmphStrong"><tt>finally</tt></span> block will be executed whether exceptions occur in <span class="docEmphasis">A,B</span>, and/or <span class="docEmphasis">C</span>. Code written with the older idiom will continue to run, so there are no backward-compatibility problems.</p>

<a name="ch10lev2sec13"></a>
<h4 id="title-IDAKVJ3D" class="docSection2Title">10.3.10. <tt>try-finally</tt> Statement</h4>
<p class="docText">An alternative is to use <span class="docEmphStrong"><tt>finally</tt></span> alone with <span class="docEmphStrong"><tt>try</tt></span>. The <span class="docEmphStrong"><tt>try-finally</tt></span> statement differs from its <span class="docEmphStrong"><tt>try-except</tt></span> brethren in that it is not used to handle exceptions. Instead it is used to maintain consistent behavior regardless of whether or not exceptions occur. We know that the <span class="docEmphStrong"><tt>finally</tt></span> suite executes regardless of an exception being triggered within the <span class="docEmphStrong"><tt>try</tt></span> suite.</p>
<div class="docText"><pre><span class="docEmphStrong">try:</span>
    <span class="docEmphasis">try_suite</span>
<span class="docEmphStrong">finally:</span>
    <span class="docEmphasis">finally_suite</span>  # executes regardless</pre></div><br>
<p class="docText"><a name="iddle1552"></a>When an exception does occur within the <span class="docEmphStrong"><tt>try</tt></span> suite, execution jumps immediately to the <span class="docEmphStrong"><tt>finally</tt></span> suite. When all the code in the <span class="docEmphStrong"><tt>finally</tt></span> suite completes, the exception is reraised for handling at the next higher layer. Thus it is common to see a <span class="docEmphStrong"><tt>try-finally</tt></span> nested as part of a <span class="docEmphStrong"><tt>TRy-except</tt></span> suite.</p>
<p class="docText">One place where we can add a <span class="docEmphStrong"><tt>TRy-finally</tt></span> statement is by improving our code in <tt>cardrun.py</tt> so that we catch any problems that may arise from reading the data from the <tt>carddata.txt</tt> file. In the current code in <a class="docLink" href="#ch10list01">Example 10.1</a>, we do not detect errors during the read phase (using <tt>readlines()</tt>):</p>
<div class="docText"><pre><span class="docEmphStrong">try:</span>
   ccfile = open('carddata.txt')
<span class="docEmphStrong">except</span> IOError:
   log.write('no txns this month\n')

txns = ccfile.readlines()
ccfile.close()</pre></div><BR>
<p class="docText">It is possible for <tt>readlines()</tt> to fail for any number of reasons, one of which is if <tt>carddata.txt</tt> was a file on the network (or a floppy) that became inaccessible. Regardless, we should improve this piece of code so that the entire input of data is enclosed in the <span class="docEmphStrong"><tt>try</tt></span> clause:</P>
<div class="docText"><pre><span class="docEmphStrong">try:</span>
    ccfile = open('carddata.txt', 'r')
    txns = ccfile.readlines()
    ccfile.close()
<span class="docEmphStrong">except</span> IOError:
    log.write('no txns this month\n')</pre></div><br>
<p class="docText">All we did was to move the <tt>readlines()</tt> and <tt>close()</tt> method calls to the <tt>TRy</tt> suite. Although our code is more robust now, there is still room for improvement. Notice what happens if there was an error of some sort. If the open succeeds, but for some reason th <tt>readlines()</tt> call does not, the exception will continue with the <span class="docEmphStrong"><tt>except</tt></span> clause. No attempt is made to close the file. Wouldn't it be nice if we closed the file regardless of whether an error occurred or not? We can make it a reality using <span class="docEmphStrong"><tt>TRy-finally</tt></span>:</P>
<div class="docText"><pre><span class="docEmphStrong">try:
    try:</span>
         ccfile = open('carddata.txt', 'r')
         txns = ccfile.readlines()
    <span class="docEmphStrong">except</span> IOError:
        log.write('no txns this month\n')
<span class="docEmphStrong">finally:</span>
        ccfile.close()</pre></div><BR>
<p class="docText"><a name="iddle1877"></a><a name="iddle4238"></a>This code snippet will attempt to open the file and read in the data. If an error occurs during this step, it is logged, and then the file is properly closed. If no errors occur, the file is still closed. (The same functionality can be achieved using the unified <span class="docEmphStrong"><tt>try-except-finally</tt></span> statement above.) An alternative implementation involves switching the <span class="docEmphStrong"><tt>try-except</tt></span> and <span class="docEmphStrong"><tt>try-finally</tt></span> clauses:</P>
<div class="docText"><pre><span class="docEmphStrong">try:
    try:</span>
        ccfile = open('carddata.txt', 'r')
        txns = ccfile.readlines()
    <span class="docEmphStrong">finally:</span>
        ccfile.close()
<span class="docEmphStrong">except</span> IOError:
     log.write('no txns this month\n')</pre></div><br>
<p class="docText">The code works virtually the same with some differences. The most obvious one is that the closing of the file happens before the exception handler writes out the error to the log. This is because <span class="docEmphStrong"><tt>finally</tt></span> automatically reraises the exception.</P>
<p class="docText">One argument for doing it this way is that if an exception happens within the <span class="docEmphStrong"><tt>finally</tt></span> block, you are able to create another handler at the same outer level as the one we have, so in essence, be able to handle errors in both the original <span class="docEmphStrong"><tt>try</tt></span> block as well as the <span class="docEmphStrong"><tt>finally</tt></span> block. The only thing you lose when you do this is that if the <span class="docEmphStrong"><tt>finally</tt></span> block does raise an exception, you have lost context of the original exception unless you have saved it somewhere.</P>
<p class="docText">An argument against having the <span class="docEmphStrong"><tt>finally</tt></span> inside the <span class="docEmphStrong"><tt>except</tt></span> is that in many cases, the exception handler needs to perform some cleanup tasks as well, and if you release those resources with a <span class="docEmphStrong"><tt>finally</tt></span> block that comes before the exception handler, you have lost the ability to do so. In other words, the <span class="docEmphStrong"><tt>finally</tt></span> block is not as &quot;final&quot; as one would think.</p>
<p class="docText">One final note: If the code in the <span class="docEmphStrong"><tt>finally</tt></span> suite raises another exception, or is aborted due to a <span class="docEmphStrong"><tt>return</tt></span>, <span class="docEmphStrong"><tt>break</tt></span>, or <span class="docEmphStrong"><tt>continue</tt></span> statement, the original exception is lost and cannot be reraised.</P>

<a name="ch10lev2sec14"></a>
<H4 id="title-IDA24J3D" class="docSection2Title">10.3.11. <tt>try-except-else-finally:</tt> aka the Kitchen Sink</h4>
<p class="docText">We can combine all the varying syntaxes that we have seen so far in this chapter to highlight all the different ways you can handle exceptions:</p>
<div class="docText"><pre><span class="docEmphStrong">try:</span>
   <span class="docEmphasis">try_suite</span>
<span class="docEmphStrong">except</span> <span class="docEmphasis">Exception1:</span>
   suite_for_Exception1

<span class="docEmphStrong">except</span> <span class="docEmphasis">(Exception2, Exception3, Exception4)</span>:
   suite_for_Exceptions_2_3_and_4

<span class="docEmphStrong">except</span> <span class="docEmphasis">Exception5, Argument5</span>:
   suite_for_Exception5_plus_argument

<span class="docEmphStrong">except</span> <span class="docEmphasis">(Exception6, Exception7), Argument67</span>:
   suite_for_Exceptions6_and_7_plus_argument

<span class="docEmphStrong">except:</span>
   suite_for_all_other_exceptions

<span class="docEmphStrong">else:</span>
   no_exceptions_detected_suite
<span class="docEmphStrong">finally:</span>
   <span class="docEmphasis">always_execute_suite</span></pre></div><br>
<p class="docText"><a name="iddle1048"></a><a name="iddle1525"></a><a name="iddle1850"></a><a name="iddle1870"></a><a name="iddle4236"></a><a name="iddle4519"></a>Recall from above that using a <span class="docEmphStrong"><tt>finally</tt></span> clause combined with <span class="docEmphStrong"><tt>TRy-except</tt></span> or <span class="docEmphStrong"><tt>try-except-else</tt></span> is &quot;new&quot; as of Python 2.5. The most important thing to take away from this section regarding the syntax is that you must have at least one <span class="docEmphStrong"><tt>except</tt></span> clause; both the <span class="docEmphStrong"><tt>else</tt></span> and <span class="docEmphStrong"><tt>finally</tt></span> clauses are optional.</p>


<a href="14051536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch10lev1sec2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch10lev1sec4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>