<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 10.9.&nbsp; *Creating Exceptions</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch10lev1sec8.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch10lev1sec10.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a name="ch10lev1sec9"></a>
<h3 id="700181-833" class="docSection1Title">10.9. *Creating Exceptions</H3>
<p class="docText">Although the set of standard exceptions is fairly wide-ranging, it may be advantageous to create your own exceptions. One situation is where you would like additional information from what a standard or module-specific exception provides. We will present two examples, both related to <tt>IOError.</tt></p>
<p class="docText"><tt>IOError</tt> is a generic exception used for input/output problems, which may arise from invalid file access or other forms of communication. Suppose we wanted to be more specific in terms of identifying the source of the problem. For example, for file errors, we want to have a <tt>FileError</tt> exception that behaves like <tt>IOError</tt>, but with a name that has more meaning when performing file operations.</P>
<p class="docText">Another exception we will look at is related to network programming with sockets. The exception generated by the <tt>socket</tt> module is called <tt>socket.error</tt> and is not a built-in exception. It is subclassed from the generic <tt>Exception</tt> exception. However, the exception arguments from <tt>socket.error</tt> closely resemble those of <tt>IOError</tt> exceptions, so we are going to define a new exception called <tt>NetworkError</tt>, which subclasses from <tt>IOError</tt> but contains at least the information provided by <tt>socket.error</tt>.</P>
<p class="docText"><a name="iddle1858"></a>Like classes and object-oriented programming, we have not formally covered network programming at this stage, but skip ahead to <a class="docLink" href="ch16.html#ch16">Chapter 16</a> if you need to.</P>
<p class="docText">We now present a module called <tt>myexc.py</tt> with our newly customized exceptions <tt>FileError</tt> and <tt>NetworkError</tt>. The code is in <a class="docLink" href="#ch10list02">Example 10.2</a>.</P>
<a name="ch10list02"></a><h5 id="title-IDARZL0D" class="docExampleTitle">Example 10.2. Creating Exceptions <tt>(myexc.py)</tt></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>


<p class="docText"><span class="docEmphasis">This module defines two new exceptions,FileError and NetworkError, as well as reimplements more diagnostic versions of open() [myopen()] and socket.connect() [myconnect()]. Also included is a test function [test()] that is run if this module is executed directly.</span></P>

<pre>1   #!/usr/bin/env python
2
3   <span class="docEmphStrong">import</span> os, socket, errno, types, tempfile
4
5   <span class="docEmphStrong">class</span> NetworkError(IOError):
6       <span class="docEmphStrong">pass</span>
7
8   <span class="docEmphStrong">class</span> FileError(IOError):
9       <span class="docEmphStrong">pass</span>
10
11  <span class="docEmphStrong">def</span> updArgs(args, newarg=None):
12      <span class="docEmphStrong">if</span> isinstance(args, IOError):
13          myargs = []
14          myargs.extend([arg <span class="docEmphStrong">for</span> arg <span class="docEmphStrong">in</span> args])
15      <span class="docEmphStrong">else:</span>
16          myargs = list(args)
17
18      <span class="docEmphStrong">if</span> newarg:
19          myargs.append(newarg)
20
21      <span class="docEmphStrong">return</span> tuple(myargs)
22
23  <span class="docEmphStrong">def</span> fileArgs(file, mode, args):
24      <span class="docEmphStrong">if</span> args[0] == errno.EACCES <span class="docEmphStrong">and</span> \
25              'access' <span class="docEmphStrong">in</span> dir(os):
26          perms = ''
27          permd = { 'r': os.R_OK, 'w': os.W_OK,
28              'x': os.X_OK}
29          pkeys = permd.keys()
30          pkeys.sort()
31          pkeys.reverse()
32

33          <span class="docEmphStrong">for</span> eachPerm <span class="docEmphStrong">in</span> 'rwx':
34              <span class="docEmphStrong">if</span> os.access(file, permd[eachPerm]):
35                  perms += eachPerm
36              <span class="docEmphStrong">else:</span>
37                  perms += '-'
38
39          <span class="docEmphStrong">if</span> isinstance(args, IOError):
40              myargs = []
41              myargs.extend([arg <span class="docEmphStrong">for</span> arg <span class="docEmphStrong">in</span> args])
42         <span class="docEmphStrong">else:</span>
43              myargs = list(args)
44
45          myargs[1] = &quot;'%s' %s (perms: '%s')&quot; % \
46              (mode, myargs[1], perms)
47
48          myargs.append(args.filename)
49
50       <span class="docEmphStrong">else:</span>
51           myargs = args
52
53      <span class="docEmphStrong">return</span> tuple(myargs)
54
55  <span class="docEmphStrong">def</span> myconnect(sock, host, port):
56      <span class="docEmphStrong">try:</span>
57          sock.connect((host, port))
58
59      <span class="docEmphStrong">except</span> socket.error, args:
60          myargs = updArgs(args)    # conv inst2tuple
61          <span class="docEmphStrong">if</span> len(myargs) == 1:       # no #s on some errs
62              myargs = (errno.ENXIO, myargs[0])
63
64          <span class="docEmphStrong">raise</span> NetworkError, \
65              updArgs(myargs, host + ':' + str(port))
66
67  <span class="docEmphStrong">def</span> myopen(file, mode='r'):
68      <span class="docEmphStrong">try:</span>
69          fo = open(file, mode)
70      <span class="docEmphStrong">except</span> IOError, args:
71          <span class="docEmphStrong">raise</span> FileError, fileArgs(file, mode, args)
72
73      <span class="docEmphStrong">return</span> fo
74
75  <span class="docEmphStrong">def</span> testfile():
76
77      file = mktemp()
78      f = open(file, 'w')
79      f.close()
80

81      <span class="docEmphStrong">for</span> eachTest <span class="docEmphStrong">in</span> ((0, 'r'), (0100, 'r'),
82              (0400, 'w'), (0500, 'w')):
83          <span class="docEmphStrong">try:</span>
84              os.chmod(file, eachTest[0])
85             f = myopen(file, eachTest[1])
86
87          <span class="docEmphStrong">except</span> FileError, args:
88              <span class="docEmphStrong">print</span> &quot;%s: %s&quot; % \
89                  (args.__class__.__name__, args)
90         <span class="docEmphStrong">else:</span>
91              <span class="docEmphStrong">print</span> file, &quot;opened ok... perm ignored&quot;
92              f.close()
93
94      os.chmod(file, 0777)    # enable all perms
95      os.unlink(file)
96
97  <span class="docEmphStrong">def</span> testnet():
98      s = socket.socket(socket.AF_INET,
99          socket.SOCK_STREAM)
100
101     <span class="docEmphStrong">for</span> eachHost in ('deli', 'www'):
102       <span class="docEmphStrong">try:</span>
103          myconnect(s, 'deli', 8080)
104       <span class="docEmphStrong">except</span> NetworkError, args:
105          <span class="docEmphStrong">print</span> &quot;%s: %s&quot; % \
106              (args.__class__.__name__, args)
107
108 <span class="docEmphStrong">if</span> __name__ == '__main__':
109     testfile()
110     testnet()</pre><br>

</TD></tr></table></P>
<a name="ch10lev2sec19"></a>
<H4 id="title-IDATQ55H" class="docSection2Title">Lines 13</h4>
<p class="docText">The Unix startup script and importation of the <tt>socket</tt>, <tt>os</tt>, <tt>errno</tt>, <tt>types</tt>, and <tt>tempfile</tt> modules help us start this module.</p>

<a name="ch10lev2sec20"></a>
<h4 id="title-IDAKR55H" class="docSection2Title">Lines 59</h4>
<p class="docText">Believe it or not, these five lines make up our new exceptions. Not just one, but both of them. Unless new functionality is going to be introduced, creating a new exception is just a matter of subclassing from an already existing exception. In our case, that would be <tt>IOError</tt>. <tt>EnvironmentError</tt>, from which <tt>IOError</tt> is derived, would also work, but we wanted to convey that our exceptions were definitely I/O-related.</P>
<p class="docText">We chose <tt>IOError</tt> because it provides two arguments, an error number and an error string. File-related [uses <tt>open()</tt>] <tt>IOError</tt> exceptions even support a third argument that is not part of the main set of exception arguments, and that would be the filename. Special handling is done for this third argument, which lives outside the main tuple pair and has the name <tt>filename</tt>.</p>

<a name="ch10lev2sec21"></a>
<h4 id="title-IDAJS55H" class="docSection2Title">Lines 1121</H4>
<p class="docText">The entire purpose of the <tt>updArgs()</tt> function is to &quot;update&quot; the exception arguments. What we mean here is that the original exception is going to provide us a set of arguments. We want to take these arguments and make them part of our new exception, perhaps embellishing or adding a third argument (which is not added if nothing is given<tt>None</tt> is a default argument, which we will study in the next chapter). Our goal is to provide the more informative details to the user so that if and when errors occur, the problems can be tracked down as quickly as possible.</p>

<a name="ch10lev2sec22"></a>
<h4 id="title-IDA0S55H" class="docSection2Title">Lines 2353</h4>
<p class="docText">The <tt>fileArgs()</tt> function is used only by <tt>myopen()</tt> (see below). In particular, we are seeking error <tt>EACCES</tt>, which represents &quot;permission denied.&quot; We pass all other <tt>IOError</tt> exceptions along without modification (lines 54 - 55). If you are curious about <tt>ENXIO</tt>, <tt>EACCES</tt>, and other system error numbers, you can hunt them down by starting at file <tt>/usr/include/sys/errno.h</tt> on a Unix system, or <tt>C:\Msdev\include\Errno.h</tt> if you are using Visual C++ on Windows.</P>
<p class="docText">In line 27, we are also checking to make sure that the machine we are using supports the <tt>os.access()</tt> function, which helps you check what kind of file permissions you have for any particular file. We do not proceed unless we receive both a permission error as well as the ability to check what kind of permissions we have. If all checks out, we set up a dictionary to help us build a string indicating the permissions we have on our file.</P>
<p class="docText">The Unix file system uses explicit file permissions for the user, group (more than one user can belong to a group), and other (any user other than the owner or someone in the same group as the owner) in read, write, and execute (`<tt>r</tt>', `<tt>w</tt>', `<tt>x</tt>') order. Windows supports some of these permissions.</p>
<p class="docText">Now it is time to build the permission string. If the file has a permission, its corresponding letter shows up in the string, otherwise a dash ( - ) appears. For example, a string of &quot;<tt>rw-</tt>&quot; means that you have read and write access to it. If the string reads &quot;<tt>r-x</tt>&quot;, you have only read and execute access; &quot;<tt>---</tt>&quot; means no permission at all.</p>
<p class="docText"><a name="iddle2542"></a>After the permission string has been constructed, we create a temporary argument list. We then alter the error string to contain the permission string, something that standard <tt>IOError</tt> exception does not provide. &quot;Permission denied&quot; sometimes seems silly if the system does not tell you what permissions you have to correct the problem. The reason, of course, is security. When intruders do not have permission to access something, the last thing you want them to see is what the file permissions are, hence the dilemma. However, our example here is merely an exercise, so we allow for the temporary &quot;breach of security.&quot; The point is to verify whether or not the <tt>os.chmod()</tt>functions call affected file permissions the way they are supposed to.</p>
<p class="docText">The final thing we do is to add the filename to our argument list and return the set of arguments as a tuple.</p>

<a name="ch10lev2sec23"></a>
<h4 id="title-IDA5U55H" class="docSection2Title">Lines 5565</h4>
<p class="docText">Our new <tt>myconnect()</tt> function simply wraps the standard socket method <tt>connect()</tt>to provide an <tt>IOError</tt> -type exception if the network connection fails. Unlike the general <tt>socket.error</tt> exception, we also provide the hostname and port number as an added value to the programmer.</p>
<p class="docText">For those new to network programming, a hostname and port number pair are analogous to an area code and telephone number when you are trying to contact someone. In this case, we are trying to contact a program running on the remote host, presumably a server of some sort; therefore, we require the host's name and the port number that the server is listening on.</p>
<p class="docText">When a failure occurs, the error number and error string are quite helpful, but it would be even more helpful to have the exact host-port combination as well, since this pair may be dynamically generated or retrieved from some database or name service. That is the value-add we are bestowing on our version of <tt>connect()</tt>. Another issue arises when a host cannot be found. There is no direct error number given to us by the <tt>socket.error</tt> exception, so to make it conform to the <tt>IOError</tt> protocol of providing an error number-error string pair, we find the closest error number that matches. We choose <tt>ENXIO.</tt></p>

<a name="ch10lev2sec24"></a>
<h4 id="title-IDAAW55H" class="docSection2Title">Lines 6773</h4>
<p class="docText">Like its sibling <tt>myconnect()</tt>, <tt>myopen()</tt>also wraps around an existing piece of code. Here, we have the <tt>open()</tt> function. Our handler catches only <tt>IOError</tt>exceptions. All others will pass through and on up to the next level (when no handler is found for them). Once an <tt>IOError</tt> is caught, we raise our own error and customized arguments as returned from <tt>fileArgs()</tt>.</p>

<a name="ch10lev2sec25"></a>

<H4 id="title-IDA2W55H" class="docSection2Title">Lines 7595</h4>
<p class="docText">We shall perform the file testing first, here using the <tt>testfile()</tt> function. In order to begin, we need to create a test file that we can manipulate by changing its permissions to generate permission errors. The <tt>tempfile</tt> module contains code to create temporary file names or temporary files themselves. We just need the name for now and use our new <tt>myopen()</tt> function to create an empty file. Note that if an error occurred here, there would be no handler, and our program would terminate fatallythe test program should not continue if we cannot even <span class="docEmphasis">create</span> a test file.</P>
<p class="docText">Our test uses four different permission configurations. A zero means no permissions at all, 0100 means execute-only, 0400 indicates read-only, and 0500 means read- and execute-only (0400 + 0100). In all cases, we will attempt to open a file with an invalid mode. The <tt>os.chmod()</tt>function is responsible for updating a file's permission modes. (Note: These permissions all have a leading zero in front, indicating that they are octal [base 8] numbers.)</p>
<p class="docText">If an error occurs, we want to display diagnostic information similar to the way the Python interpreter performs the same task when uncaught exceptions occur, and that is giving the exception name followed by its arguments. The <tt>__class__</tt> special variable represents the class object from which an instance was created. Rather than displaying the entire class name here (<tt>myexc.FileError</tt>), we use the class object's <tt>__name__</tt> variable to just display the class name (<tt>FileError</tt>), which is also what you see from the interpreter in an unhandled error situation. Then the arguments that we arduously put together in our wrapper functions follow.</P>
<p class="docText">If the file opened successfully, that means the permissions were ignored for some reason. We indicate this with a diagnostic message and close the file. Once all tests have been completed, we enable all permissions for the file and remove it with the <tt>os.unlink()</tt> function. (<tt>os.remove()</tt> is equivalent to <tt>os.unlink()</tt>.)</p>

<a name="ch10lev2sec26"></a>
<H4 id="title-IDANY55H" class="docSection2Title">Lines 97106</h4>
<p class="docText">The next section of code (<tt>testnet()</tt>) tests our <tt>NetworkError</tt> exception. A socket is a communication endpoint with which to establish contact with another host. We create such an object, then use it in an attempt to connect to a host with no server to accept our connect request and a host not on our network.</P>

<a name="ch10lev2sec27"></a>
<H4 id="title-IDA4Y55H" class="docSection2Title">Lines 108110</H4>
<p class="docText">We want to execute our <tt>test*()</tt> functions only when invoking this script directly, and that is what the code here does. Most of the scripts given in this text utilize the same format.</P>
<p class="docText"><a name="iddle1855"></a><a name="iddle1883"></a><a name="iddle3759"></a><a name="iddle4400"></a><a name="iddle4486"></a>Running this script on a Unix-flavored box, we get the following output:</p>
<div class="docText"><pre>$myexc.py
FileError: [Errno 13] 'r' Permission denied (perms: '---'):
 '/usr/tmp/@18908.1'
FileError: [Errno 13] 'r' Permission denied (perms: '--x'):
 '/usr/tmp/@18908.1'
FileError: [Errno 13] 'w' Permission denied (perms: 'r--'):
 '/usr/tmp/@18908.1'
FileError: [Errno 13] 'w' Permission denied (perms: 'r-x'):
 '/usr/tmp/@18908.1'
NetworkError: [Errno 146] Connection refused: 'deli:8080'
NetworkError: [Errno 6] host not found: 'www:8080'</pre></div><br>
<p class="docText">The results are slightly different on a Win32 machine:</p>
<div class="docText"><pre>D:\python&gt; python myexc.py
C:\WINDOWS\TEMP\~-195619-1 opened ok... perms ignored
C:\WINDOWS\TEMP\~-195619-1 opened ok... perms ignored
FileError: [Errno 13] 'w' Permission denied (perms: 'r-x'):
 'C:\\WINDOWS\\TEMP\\~-195619-1'
FileError: [Errno 13] 'w' Permission denied (perms: 'r-x'):
 'C:\\WINDOWS\\TEMP\\~-195619-1'
NetworkError: [Errno 10061] winsock error: 'deli:8080'
NetworkError: [Errno 6] host not found: 'www:8080'</pre></div><BR>
<p class="docText">You will notice that Windows does not support read permissions on files, which is the reason why the first two file open attempts succeeded. Your mileage may vary (YMMV) on your own machine and operating system.</p>


</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch10lev1sec8.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch10lev1sec10.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>