<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 11.1.&nbsp; What Are Functions?</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch11.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch11lev1sec2.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a name="ch11lev1sec1"></a>
<h3 id="700181-876" class="docSection1Title">11.1. What Are Functions?</H3>
<p class="docText">Functions are the structured or procedural programming way of organizing the logic in your programs. Large blocks of code can be neatly segregated into manageable chunks, and space is saved by putting oft-repeated code in functions as opposed to multiple copies everywherethis also helps with consistency because changing the single copy means you do not have to hunt for and make changes to multiple copies of duplicated code. The basics of functions in Python are not much different from those of other languages with which you may be familiar. After a bit of review here in the early part of this chapter, we will focus on what else Python brings to the table.</p>
<p class="docText"><a name="iddle2175"></a><a name="iddle2177"></a><a name="iddle3106"></a><a name="iddle3459"></a><a name="iddle3649"></a><a name="iddle4292"></a>Functions can appear in different ways ... here is a sampling profile of how you will see functions created, used, or otherwise referenced:</P>
<p class="docText"><span class="docEmphBoldItalic">declaration/definition</span> <span class="docEmphStrong"><tt>def</tt></span> <tt>foo():</tt> <span class="docEmphStrong"><tt>print</tt></span> <tt>'bar'</tt></P>
<p class="docText"><span class="docEmphBoldItalic">function object/reference</span> <tt>foo</tt></P>
<p class="docText"><span class="docEmphBoldItalic">function call/invocation</span> <tt>foo()</tt></P>
<a name="ch11lev2sec1"></a>
<h4 id="title-IDAKR3KN" class="docSection2Title">11.1.1. Functions versus Procedures</h4>
<p class="docText">Functions are often compared to procedures. Both are entities that can be invoked, but the traditional function or &quot;black box,&quot; perhaps taking some or no input parameters, performs some amount of processing, and concludes by sending back a return value to the caller. Some functions are Boolean in nature, returning a &quot;yes&quot; or &quot;no&quot; answer, or, more appropriately, a non-zero or zero value, respectively. Procedures are simply special cases, functions that do not return a value. As you will see below, Python procedures are implied functions because the interpreter implicitly returns a default value of <tt>None</tt>.</p>

<a name="ch11lev2sec2"></a>
<H4 id="title-IDAZR3KN" class="docSection2Title">11.1.2. Return Values and Function Types</h4>
<p class="docText">Functions may return a value back to their callers and those that are more procedural in nature do not explicitly return anything at all. Languages that treat procedures as functions usually have a special type or value name for functions that &quot;return nothing.&quot; These functions default to a return type of <tt>&quot;void&quot;</tt> in C, meaning no value returned. In Python, the equivalent return object type is <tt>None</tt>.</P>
<p class="docText">The <tt>hello()</tt> function acts as a procedure in the code below, returning no value. If the return value is saved, you will see that its value is <tt>None</tt>:</p>
<div class="docText"><pre>&gt;&gt;&gt; <span class="docEmphStrong">def</span> hello():
...     <span class="docEmphStrong">print</span> 'hello world'
&gt;&gt;&gt;
&gt;&gt;&gt; res = hello()
hello world
&gt;&gt;&gt; res
&gt;&gt;&gt; <span class="docEmphStrong">print</span> res
None
&gt;&gt;&gt; type(res)
&lt;type 'None'&gt;</pre></div><BR>
<p class="docText">Also, like most other languages, you may return only one value/object from a function in Python. One difference is that in returning a container type, it will seem as if you can actually return more than a single object. In other words, you cannot leave the grocery store with multiple items, but you can throw them all in a single shopping bag, which you walk out of the store with, perfectly legal.</p>
<div class="docText"><pre><span class="docEmphStrong">def</span> foo():
    <span class="docEmphStrong">return</span> ['xyz', 1000000, -98.6]

<span class="docEmphStrong">def</span> bar():
    <span class="docEmphStrong">return</span> 'abc', [42, 'python'], &quot;Guido&quot;</pre></div><BR>
<p class="docText">The <tt>foo()</tt> function returns a list, and the <tt>bar()</tt> function returns a tuple. Because of the tuple's syntax of not requiring the enclosing parentheses, it creates the perfect illusion of returning multiple items. If we were to properly enclose the tuple items, the definition of <tt>bar()</tt> would look like this:</P>
<div class="docText"><pre><span class="docEmphStrong">def</span> bar():
    <span class="docEmphStrong">return</span> ('abc', [4-2j, 'python'], &quot;Guido&quot;)</pre></div><br>
<p class="docText">As far as return values are concerned, tuples can be saved in a number of ways. The following three ways of saving the return values are equivalent:</p>
<div class="docText"><pre>&gt;&gt;&gt; aTuple = bar()
&gt;&gt;&gt; x, y, z = bar()
&gt;&gt;&gt; (a, b, c) = bar()
&gt;&gt;&gt;
&gt;&gt;&gt; aTuple
('abc', [(4-2j), 'python'], 'Guido')
&gt;&gt;&gt; x, y, z
('abc', [(4-2j), 'python'], 'Guido')
&gt;&gt;&gt; (a, b, c)
('abc', [(4-2j), 'python'], 'Guido')</pre></div><br>
<p class="docText">In the assignments for <tt>x</tt>, <tt>y</tt>, <tt>z</tt>, and <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, each variable will receive its corresponding return value in the order the values are returned. The <tt>aTuple</tt> assignment takes the entire implied tuple returned from the function. Recall that a tuple can be &quot;unpacked&quot; into individual variables or not at all and its reference assigned directly to a single variable. (Refer back to <a class="docLink" href="ch06lev1sec18.html#ch06lev2sec38">Section 6.18.3</a> for a review.)</p>
<p class="docText">In short, when no items are explicitly returned or if <tt>None</tt> is returned, then Python returns <tt>None</tt>. If the function returns exactly one object, then that is the object that Python returns and the type of that object stays the same. If the function returns multiple objects, Python gathers them all together and returns them in a tuple. Yes, we claim that Python is more flexible than languages like C where only one return value is allowed, but in all honesty, Python follows the same tradition. The programmer is just given the impression that he or she can return more than one object. <a name="iddle1110"></a><a name="iddle1280"></a><a name="iddle1281"></a><a name="iddle1286"></a><a name="iddle1288"></a><a name="iddle2132"></a><a name="iddle2138"></a><a name="iddle2167"></a><a name="iddle2172"></a><a name="iddle2618"></a><a name="iddle3260"></a><a class="docLink" href="#ch11table01">Table 11.1</a> summarizes the number of items &quot;returned&quot; from a function, and the object that Python actually returns.</P>
<a name="ch11table01"></a><p><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 11.1. Return Values and Types</H5></caption><colgroup align="left" span="2"><col width="150"><col width="150"></colgroup><thead><tr><th class="thead" scope="col" align="left" valign="bottom"><p class="docText">Stated Number of Objects to Return</p></th><th class="thead" scope="col" align="left" valign="bottom"><p class="docText">Type of Object That Python Returns</p></th></TR></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText">0</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>None</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>object</tt></span></P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText">&gt;1</p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>tuple</tt></P></TD></TR></table></P><br>
<p class="docText">Many languages that support functions maintain the notion that a function's type is the type of its return value. In Python, no direct type correlation can be made since Python is dynamically typed and functions can return values of different types. Because overloading is not a feature, the programmer can use the <tt>type()</tt> built-in function as a proxy for multiple declarations with different <span class="docEmphasis">signatures</span> (multiple prototypes of the same overloaded function that differ based on its arguments).</p>


</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch11.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch11lev1sec2.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>