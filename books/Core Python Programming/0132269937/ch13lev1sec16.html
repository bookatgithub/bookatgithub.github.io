<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 13.16.&nbsp; Advanced Features of New-Style Classes (Python 2.2+)</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch13lev1sec15.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch13lev1sec17.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a href="14051536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a><a name="ch13lev1sec16"></a>
<h3 id="title-IDAW2HZF" class="docSection1Title">13.16. Advanced Features of New-Style Classes (<a class="docLink" href="ch05lev1sec2.html#ch05lev3sec2">Python 2.2+</a>)</H3>
<a name="ch13lev2sec50"></a>
<h4 id="title-IDAG3HZF" class="docSection2Title">13.16.1. General Features of New-Style Classes</H4>
<p class="docText">We have already discussed some of the features tied to new-style classes. With the unification of types and classes, the most significant of these features is the ability to subclass Python data types. One side effect of this is that all of the Python &quot;casting&quot; or conversion built-in functions are now factory functions. When you call them, you are really instantiating an instance of the corresponding type.</P>

<p class="docText">
<img border="0" alt="" width="50" height="48" SRC="images/2_2.jpg"></P>


<p class="docText">The following built-in function, which have been around Python for a while, have been quietly (or perhaps not) converted to factory functions:</P>
<ul><li><p class="docList"><tt>int(), long(), float(), complex()</tt></p></LI><li><p class="docList"><tt>str(), unicode()</tt></P></li><LI><p class="docList"><tt>list(), tuple()</tt></p></LI><LI><p class="docList"><tt>type()</tt></p></li></ul>
<p class="docText"><a name="iddle2552"></a>In addition, several new ones have been added to round out the posse:</p>
<UL><li><p class="docList"><tt>basestring()</tt><sup class="docFootnote"><a class="docLink" href="#ch13fn10">[1]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="ch13fn10">[1]</a></sup> New in <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec3">Python 2.3</a>.</P></blockquote></li><li><p class="docList"><tt>dict()</tt></p></LI><LI><p class="docList"><tt>bool()</tt></p></li><li><p class="docList"><tt>set()</tt>,<sup class="docFootnote"><a class="docLink" href="#ch13fn11">[2]</a></sup> <tt>frozenset()</tt><sup class="docFootnote"><a class="docLink" href="#ch13fn11">[2]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="ch13fn11">[2]</a></sup> New in <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec4">Python 2.4</a>.</p></blockquote></li><li><p class="docList"><tt>object()</tt></p></li><li><p class="docList"><tt>classmethod()</tt></p></li><LI><p class="docList"><tt>staticmethod()</tt></p></LI><li><p class="docList"><tt>super()</tt></P></li><LI><p class="docList"><tt>property()</tt></p></LI><LI><p class="docList"><tt>file()</tt></P></LI></ul>
<p class="docText">These class names and factory functions have flexible usage. In addition to creating new objects of those types, they can be used as base classes when subclassing types, and they can now be used with the <tt>isinstance()</tt> built-in function. Using <tt>isinstance()</tt> can help replace tired old idioms with one that requires fewer functions calls resulting in cleaner code. For example, to test if an object is an integer, we had to call <tt>type()</tt> twice or import the <tt>types</tt> module and use its attributes; but now we can just use <tt>isinstance()</tt> and even gain in performance:</p>
<blockquote><p><p class="docList">OLD (not as good):</P><ul><LI><p class="docList"><span class="docEmphStrong"><tt>if </tt></span><tt>type(</tt><span class="docEmphasis"><tt>obj</tt></span><tt>) == type(0)...</tt></p></LI><li><p class="docList"><span class="docEmphStrong"><tt>if</tt></span> <tt>type(</tt><span class="docEmphasis"><tt>obj</tt></span><tt>) == types.IntType...</tt></P></LI></ul></p><p><p class="docList">BETTER:</p><UL><li><p class="docList"><span class="docEmphStrong"><tt>if</tt></span> <tt>type(</tt><span class="docEmphasis"><tt>obj</tt></span>) <span class="docEmphStrong"><tt>is</tt></span> <tt>type(0)...</tt></p></LI></ul></p><p><p class="docList">EVEN BETTER:</P><UL><li><p class="docList"><span class="docEmphStrong"><tt>if</tt></span> <tt>isinstance(</tt><span class="docEmphasis"><tt>obj</tt></span><tt>, int)...</tt></p></li><li><p class="docList"><span class="docEmphStrong"><tt>if</tt></span> <tt>isinstance(</tt><span class="docEmphasis"><tt>obj</tt></span><tt>, (int, long))...</tt></p></li><li><p class="docList"><span class="docEmphStrong"><tt>if</tt></span> <tt>type(</tt><span class="docEmphasis"><tt>obj</tt></span>) <span class="docEmphStrong"><tt>is</tt></span> <tt>int...</tt></p></li></ul></p></blockquote>
<p class="docText">Keep in mind that although <tt>isinstance()</tt> is flexible, it does not perform an &quot;exact match&quot; comparisonit will also return <tt>true</tt> if <span class="docEmphasis"><tt>obj</tt></span> is an instance of the given type <span class="docEmphasis">or an instance of a subclass of the given type.</span> You will still need to use the <span class="docEmphStrong"><tt>is</tt></span> operator if you want an exact class match.</P>
<p class="docText"><a name="iddle1368"></a><a name="iddle1652"></a><a name="iddle2249"></a><a name="iddle2254"></a><a name="iddle2871"></a><a name="iddle2907"></a><a name="iddle3086"></a><a name="iddle3091"></a><a name="iddle3847"></a>Please review <a class="docLink" href="ch13lev1sec12.html#ch13lev2sec37">Section 13.12.2</a> above for a deeper explanation of <tt>isinstance()</tt> as well as its introduction in <a class="docLink" href="ch04.html#ch04">Chapter 4</a> and how these calls evolved along with Python.</p>

<a name="ch13lev2sec51"></a>
<H4 id="title-IDATY0KN" class="docSection2Title">13.16.2. <tt>__slots__</tt> Class Attribute</h4>
<p class="docText">A dictionary is at the heart of all instances. The <tt>__dict__</tt> attribute keeps track of all instance attributes. For example, when you have an instance <tt>inst</tt> with an attribute <tt>foo</tt>, recognize that accessing it with <tt>inst.foo</tt> is the same as doing it with <tt>inst.__dict__['foo']</tt>.</P>
<p class="docText">This dictionary takes up a good amount of memory, and if you have a class with very few attributes but a significant number of instances of this object, then you are taking a substantial hit. To combat this, users are now able to use the <tt>__slots__</tt> attribute to substitute for <tt>__dict__</tt>.</p>
<p class="docText">Basically, <tt>__slots__</tt> is a class variable consisting of a sequence-like object representing the set of valid identifiers that make up all of an instance's attributes. This can be a list, tuple, or iterable. It can also be a single string identifying the single attribute that an instance can have. Any attempt to create an instance attribute with a name not in <tt>__slots__</tt> will result in an <tt>AttributeError</tt> exception:</P>
<div class="docText"><pre><span class="docEmphStrong">class</span> SlottedClass(object):
    __slots__ = ('foo', 'bar')
&gt;&gt;&gt; c = SlottedClass()
&gt;&gt;&gt;
&gt;&gt;&gt; c.foo = 42
&gt;&gt;&gt; c.xxx = "don't think so"
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
AttributeError: 'SlottedClass' object has no attribute
'xxx'</pre></div><br>
<p class="docText">The primary reason for this feature is the conservation of memory. A side effect is a type of security preventing users from adding instances attributes dynamically in an ad hoc manner. A class defined with a <tt>__slots__</tt> attribute will not have a <tt>__dict__</tt> (unless you add <tt>'__dict__'</tt> as an element of <tt>__slots__</tt>). For more information on <tt>__slots__</tt>, see the Data Model chapter of the Python (Language) Reference Manual.</P>

<a name="ch13lev2sec52"></a>
<H4 id="title-IDAT00KN" class="docSection2Title">13.16.3. <tt>__getattribute__()</tt> Special Method</H4>
<p class="docText">Python classes have a special method named <tt>__getattr__()</tt>, which is called only when an attribute cannot be found in an instance's <tt>__dict__</tt> or its <a name="iddle1640"></a><a name="iddle1644"></a><a name="iddle2242"></a><a name="iddle3083"></a><a name="iddle3767"></a>class (class's <tt>__dict__</tt>), or ancestor class (its <tt>__dict__</tt>). One place where we saw <tt>__getattr__()</tt> used was for implementing delegation.</P>
<p class="docText">The problem that many users encountered was that they wanted a certain function to execute for every attribute access, not just when one cannot be found. This is where <tt>__getattribute__()</tt> comes in. It works just like <tt>__getattr__()</tt> except that it is <span class="docEmphasis">always</span> called when an attribute is accessed, not just when it cannot be found.</p>
<p class="docText">If a class has both <tt>__getattribute__()</tt> and <tt>__getattr__()</tt> defined, the latter will not be called unless explicitly called from <tt>__getattribute__()</tt> or if <tt>__getattribute__()</tt> raises <tt>AttributeError</tt>.</p>
<p class="docText">Be very careful if you are going to access attributes in here... attributes of this class or an ancestor. If you cause <tt>__getattribute__()</tt> to somehow call <tt>__getattribute__()</tt>again, you will have infinite recursion. To avoid infinite recursion using this method, you should always call an ancestor class method that shares the same name in order to access any attributes it needs safely; for example, <tt>super</tt>(<span class="docEmphasis"><tt>obj</tt></span>, <tt>self)</tt>.<tt>__getattribute__(</tt><span class="docEmphasis"><tt>attr</tt></span><tt>)</tt>. This special method is only valid with new-style classes. As with <tt>__slots__</tt>, you can get more information on <tt>__getattribute__()</tt> by referring to the Data Model chapter of the Python (Language) Reference Manual.</p>

<a name="ch13lev2sec53"></a>
<H4 id="title-IDA330KN" class="docSection2Title">13.16.4. Descriptors</h4>
<p class="docText">Descriptors are one of the keys behind Python's new-style classes. They provide a powerful API to object attributes. You can think of a descriptor as an agent that presents object attributes. Depending on which situation you encounter when you need an attribute, you can get to it via its descriptor (if there is one for it) or in the normal way (dotted attribute notation).</P>
<p class="docText">If there is an agent for your object and it has a &quot;get&quot; attribute (really spelled <tt>__get__</tt>), it is invoked, and you get back all you need to access the object in question. The same thing applies if you are attempting to assign a value to an object with a descriptor (set) or removing an attribute (delete).</p>
<a name="ch13lev3sec38"></a>
<H5 id="title-IDAN40KN" class="docSection3Title"><tt>__get__()</tt>, <tt>__set__()</tt>, <tt>__delete__()</tt> Special Methods</h5>
<p class="docText">Strictly speaking, a descriptor is really any (new-style) class that implements at least one of three special methods that serve as the <span class="docEmphasis">descriptor protocol</span>: <tt>__get__()</tt>, <tt>__set__()</tt>, and <tt>__delete__()</tt>. As mentioned just above, <tt>__get__()</tt> is used to get the value of an attribute, <tt>__set__()</tt> is used to assign a value to an attribute, and <tt>__delete__()</tt> is called when an attribute is explicitly removed using the <span class="docEmphStrong"><tt>del</tt></span> statement (or rather, its reference count decremented). Of the three, the latter is rarely implemented.</P>
<p class="docText"><a name="iddle1565"></a><a name="iddle1641"></a><a name="iddle2853"></a><a name="iddle3105"></a><a name="iddle3768"></a>Also, not all descriptors implement the <tt>__set__()</tt> method either. These are referred to as <span class="docEmphasis">method descriptors</span>, or more accurately, <span class="docEmphasis">non-data descriptors</span>. Those that override both <tt>__get__()</tt> and <tt>__set__()</tt> are called <span class="docEmphasis">data descriptors</span>, and they are more powerful than non-data descriptors.</P>
<p class="docText">The signatures for <tt>__get__()</tt>, <tt>__set__()</tt>, and <tt>__delete__()</tt> look like this:</p>
<ul><li><p class="docList"><span class="docEmphStrong"><tt>def</tt></span> <tt>__get__(self, obj, typ=None) <img src=images/U21D2.jpg border=0> value</tt></p></LI><li><p class="docList"><span class="docEmphStrong"><tt>def</tt></span> <tt>__set__(self, obj, val) <img src=images/U21D2.jpg border=0> None</tt></p></LI><li><p class="docList"><span class="docEmphStrong"><tt>def</tt></span> <tt>__delete__(self, obj) <img src=images/U21D2.jpg border=0> None</tt></p></li></UL>
<p class="docText">When you want to use an agent for an attribute, you install it as a class attribute, and let the agent handle all the dirty work. Anytime you try to do something to an attribute with that name, you will get the descriptor that proxies all functionality. We covered wrapping in the previous section. This is just more wrapping going on. Instead of just delegating everything to objects in your class, we are delegating slightly more complex attribute access here.</P>

<a name="ch13lev3sec39"></a>
<h5 id="title-IDAKC1KN" class="docSection3Title"><tt>__getattribute__()</tt> Special Method (again)</h5>
<p class="docText">Ordering matters when using descriptors, and certain aspects have precedence over others. The heart of the entire system is <tt>__getattribute__()</tt> since that special method is called for every attribute instance. It is the one that finds a class attribute or an agent to call on your behalf to access an attribute, etc.</p>
<p class="docText">Reviewing the signatures just above, if <tt>__get__()</tt> is called for an instance, the object is passed in and perhaps a type or class. For example, given a class <tt>X</tt> and an instance <tt>x</tt>, <tt>x.foo</tt> is translated by <tt>__getattribute__()</tt> to:</p>
<div class="docText"><pre>    type(x).__dict__['foo'].__get__(x, type(x))</pre></div><br>
<p class="docText">If <tt>__get__()</tt> is called for a class, then <tt>None</tt> is passed in as the object (which would be <tt>self</tt> for an instance):</p>
<div class="docText"><pre>    X.__dict__['foo'].__get__(None, X)</pre></div><br>
<p class="docText">Finally, if <tt>super()</tt> is called, for example given <tt>Y</tt> as a subclass of <tt>X</tt>, then <tt>super(Y</tt>, <tt>obj).foo</tt> looks in <tt>obj.__class__.__mro__</tt> for the class right next to <tt>Y</tt> going up the tree to find class <tt>X</tt>, and then calls:</p>
<div class="docText"><pre>    X.__dict__['foo'].__get__(obj, X)</pre></div><br>
<p class="docText">Then it is up to <span class="docEmphasis">that</span> descriptor to return the desired object.</p>

<a name="ch13lev3sec40"></a>

<h5 id="title-IDACF1KN" class="docSection3Title">Precedence</h5>
<p class="docText"><a name="iddle1182"></a><a name="iddle2250"></a><a name="iddle3452"></a>The way <tt>__getattribute__()</tt> works needs to be covered, as it was implemented to behave in a very specific way. Thus it is very important to recognize this ordering:</P>
<ul><LI><p class="docList">Class attributes</p></LI><li><p class="docList">Data descriptors</P></li><LI><p class="docList">Instance attributes</P></LI><LI><p class="docList">Non-data descriptors</p></li><li><p class="docList">Defaulting to <tt>__getattr__()</tt></P></li></UL>
<p class="docText">A descriptor is a class attribute, so all class attributes have the highest priority. You can even replace a descriptor by simply reassigning its original reference to other objects. They are followed closely behind by descriptors with <tt>__get__()</tt> and <tt>__set__()</tt> implemented. If you have an agent, it will do all your work for you!</p>
<p class="docText">Otherwise, it should just default to the local object's <tt>__dict__</tt>, meaning that it will be an instance attribute. The non-data descriptors come next. This may sound surprising because on first glance, one would think that these should be higher up in the food chain than instance attributes, but that is not the case. The purpose of non-data descriptors is only to provide a value if one is not already part of an instance, sort of how <tt>__getattr__()</tt> is only called if an attribute cannot be found in an instance's <tt>__dict__</tt>!</P>
<p class="docText">Speaking of <tt>__getattr__()</tt>, if no non-data descriptor is found, then <tt>__getattribute__()</tt> raises an <tt>AttributeError</tt>, and that in turn causes <tt>__getattr__()</tt> to be invoked as the last stand before <tt>AttributeError</tt> is raised to the user.</p>

<a name="ch13lev3sec41"></a>
<H5 id="title-IDAYH1KN" class="docSection3Title">Descriptor Examples</H5>
<p class="docText">Let us start with a very boring example... a descriptor that just discards any attempt to retrieve or set a value from and to an attribute, respectively. Actually, all of the examples here just ignore all requests, but they are incremental, and we hope that you can figure out a little more about descriptors for each one:</p>
<div class="docText"><pre><span class="docEmphStrong">class</span> DevNull1(object):
    <span class="docEmphStrong">def</span> __get__(self, obj, typ=None):
        <span class="docEmphStrong">pass
    def</span> __set__(self, obj, val):
        <span class="docEmphStrong">pass</span></pre></div><br>
<p class="docText">We create a class that uses this descriptor and try to assign something to it as well as display its value:</p>
<div class="docText"><pre>    &gt;&gt;&gt; <span class="docEmphStrong">class</span> C1(object):
    ...     foo = DevNull1()
    ...
    &gt;&gt;&gt; c1 = C1()
    &gt;&gt;&gt; c1.foo = 'bar'
    &gt;&gt;&gt; <span class="docEmphStrong">print</span> 'c1.foo contains:', c1.foo
    c1.foo contains: None</pre></div><br>
<p class="docText">That was not too terribly exciting... how about one where the descriptor methods at least give some output to show what is going on?</P>
<div class="docText"><pre><span class="docEmphStrong">class</span> DevNull2(object):
    <span class="docEmphStrong">def</span> __get__(self, obj, typ=None):
        <span class="docEmphStrong">print</span> 'Accessing attribute... ignoring'
    <span class="docEmphStrong">def</span> __set__(self, obj, val):
        <span class="docEmphStrong">print</span> 'Attempt to assign %r... ignoring' % (val)</pre></div><br>
<p class="docText">Now let us see this one in action:</p>
<div class="docText"><pre>    &gt;&gt;&gt; <span class="docEmphStrong">class</span> C2(object):
    ...  foo = DevNull2()
    ...
    &gt;&gt;&gt; c2 = C2()
    &gt;&gt;&gt; c2.foo = 'bar'
    Attempt to assign 'bar'... ignoring
    &gt;&gt;&gt; x = c2.foo
    Accessing attribute... ignoring
    &gt;&gt;&gt; <span class="docEmphStrong">print</span> 'c2.foo contains:', x
    c2.foo contains: None</pre></div><BR>
<p class="docText">For our final example, let us add a placeholder in our descriptor class that holds some useful information about the descriptor:</p>
<div class="docText"><pre><span class="docEmphStrong">class</span> DevNull3(object):
    <span class="docEmphStrong">def</span> __init__(self, name=None):
        self.name = name
    <span class="docEmphStrong">def</span> __get__(self, obj, typ=None):
        <span class="docEmphStrong">print</span> 'Accessing [%s]... ignoring' %
            self.name)
    <span class="docEmphStrong">def</span> __set__(self, obj, val):
        <span class="docEmphStrong">print</span> 'Assigning %r to [%s]... ignoring' %
            val, self.name)</pre></div><br>
<p class="docText"><a name="iddle2243"></a><a name="iddle3453"></a>In the output below, we show you the importance of the hierarchy mentioned above, especially where we state that a full data descriptor has precedence over an instance attribute:</p>
<div class="docText"><pre>    &gt;&gt;&gt; <span class="docEmphStrong">class</span> C3(object):
    ...     foo = DevNull3('foo')
    ...
    &gt;&gt;&gt; c3 = C3()
    &gt;&gt;&gt; c3.foo = 'bar'
    Assigning 'bar' to [foo]... ignoring
    &gt;&gt;&gt; x = c3.foo
    Accessing [foo]... ignoring
    &gt;&gt;&gt; <span class="docEmphStrong">print</span> 'c3.foo contains:', x
    c3.foo contains: None
    &gt;&gt;&gt; <span class="docEmphStrong">print</span> 'Let us try to sneak it into c3 instance...'
    Let us try to sneak it into c3 instance...
    &gt;&gt;&gt; c3.__dict__['foo'] = 'bar'
    &gt;&gt;&gt; x = c3.foo
    Accessing [foo]... ignoring
    &gt;&gt;&gt; <span class="docEmphStrong">print</span> 'c3.foo contains:', x
    c3.foo contains: None
    &gt;&gt;&gt; <span class="docEmphStrong">print</span> "c3.__dict__['foo'] contains: %r" % \
          c3.__dict__['foo'], "... why?!?"
    c3.__dict__['foo'] contains: 'bar' ... why?!?</pre></div><BR>
<p class="docText">Notice how we were able to sneak in an attribute to our instance. We were able to assign the string &quot;<tt>bar</tt>&quot; to <tt>c3.foo</tt>, but because the data descriptor is more important, it overrides or effectively hides our assignment.</P>
<p class="docText">Likewise, because instance attributes have a higher precedence than non-data attributes, you can also hide such a descriptor, just as you can hide a class attribute, by assigning an instance attribute with the same name:</p>
<div class="docText"><pre>    &gt;&gt;&gt; <span class="docEmphStrong">class</span> FooFoo(object):
    ...     <span class="docEmphStrong">def</span> foo(self):
    ...         <span class="docEmphStrong">print</span> 'Very important foo() method.'
    ...
    &gt;&gt;&gt;
    &gt;&gt;&gt; bar = FooFoo()
    &gt;&gt;&gt; bar.foo()
    Very important foo() method.
    &gt;&gt;&gt;
    &gt;&gt;&gt; bar.foo = 'It is no longer here.'
    &gt;&gt;&gt; bar.foo
    'It is no longer here.'
    &gt;&gt;&gt;
    &gt;&gt;&gt; <span class="docEmphStrong">del</span> bar.foo
    &gt;&gt;&gt; bar.foo()
    Very important foo() method.</pre></div><br>
<p class="docText">This was a pretty transparent example because we called it as a function, then accessed it as a string, but we could have used another function and kept the same calling mechanism, too:</p>
<div class="docText"><pre>   &gt;&gt;&gt; <span class="docEmphStrong">def</span> barBar():
   ...     <span class="docEmphStrong">print</span> 'foo() hidden by barBar()'
   ...
   &gt;&gt;&gt; bar.foo = barBar
   &gt;&gt;&gt; bar.foo()
   foo() hidden by barBar()
   &gt;&gt;&gt;
   &gt;&gt;&gt; <span class="docEmphStrong">del</span> bar.foo
   &gt;&gt;&gt; bar.foo()
   Very important foo() method.</pre></div><br>
<p class="docText">The point was to emphasize that because functions are non-data descriptors, instance attributes are ranked higher, and we can shadow any non-data descriptor simply by assigning an object to the instance (of the same name).</p>
<p class="docText">Our final example does a little bit more. It is a crude attempt at using the filesystem as a means of storing the contents of an attribute.</p>
<a name="ch13lev4sec10"></a>
<h5 id="title-IDAKP1KN" class="docSection4Title">Lines 110</h5>
<p class="docText">After the usual setup, we create our descriptor class with a class attribute (<tt>saved</tt>) that keeps track of all attributes with descriptor access. When a descriptor is created, it registers and saves the name of the attribute (passed in from the user).</p>

<a name="ch13lev4sec11"></a>
<h5 id="title-IDAZP1KN" class="docSection4Title">Lines 1226</h5>
<p class="docText">When fetching an attribute, we need to ensure that users do not use it before they have even assigned a value to it. If it passes that test, then we attempt to open the pickle file to read in the saved value. An exception is raised if somehow the file cannot be opened, either because it was erased (or never created), or if it was corrupted or somehow cannot be unserialized by the <tt>pickle</tt> module.</p>

<a name="ch13lev4sec12"></a>
<H5 id="title-IDALQ1KN" class="docSection4Title">Lines 2838</h5>
<p class="docText">Saving the attribute takes several steps: open the pickle file for write (either creating it for the first time or wiping out one that was already there), serializing the object to disk, and registering the name so users can retrieve the value. An exception is thrown if the object cannot be pickled. Note that if you are using Python 2.5 you can never merge the <span class="docEmphStrong"><tt>TRy-except</tt></span> and <span class="docEmphStrong"><tt>try finally</tt></span> statements (lines 30-38) together.</P>

<p class="docText"></p><a name="ch13list09"></a><H5 id="title-IDADR1KN" class="docExampleTitle">Example 13.9. Using a File to Store an Attribute (<tt>descr.py</tt>)</h5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>


<p class="docText"><a name="iddle1177"></a><a name="iddle2017"></a><a name="iddle2036"></a><a name="iddle3972"></a><span class="docEmphasis">This class is crude but represents an interesting use of descriptorsbeing able to store the contents of an attribute on the filesystem.</span></P>

<pre>1  #!/usr/bin/env python
2
3  <span class="docEmphStrong">import</span> os
4  <span class="docEmphStrong">import</span> pickle
5
6  <span class="docEmphStrong">class</span> FileDescr(object):
7     saved = []
8
9     <span class="docEmphStrong">def</span> __init__(self, name=None):
10        self.name = name
11
12    <span class="docEmphStrong">def</span> __get__(self, obj, typ=None):
13        <span class="docEmphStrong">if</span> self.name  <span class="docEmphStrong">not in</span> FileDescr.saved:
14           <span class="docEmphStrong">raise</span> AttributeError, \
15               "%r used before assignment" % self.name
16
17        <span class="docEmphStrong">try</span>:
18           f = open(self.name, 'r')
19           val = pickle.load(f)
20           f.close()
21           <span class="docEmphStrong">return</span> val
22        <span class="docEmphStrong">except</span> (pickle.UnpicklingError, IOError,
23              EOFError, AttributeError,
24              ImportError, IndexError), e:
25          <span class="docEmphStrong">raise</span> AttributeError, \
26              "could not read %r: %s" % self.name
27
28    <span class="docEmphStrong">def</span> __set__(self, obj, val):
29        f = open(self.name, 'w')
30        <span class="docEmphStrong">try</span>:
31           <span class="docEmphStrong">try</span>:
32              pickle.dump(val, f)
33              FileDescr.saved.append(self.name)
34        <span class="docEmphStrong">except</span> (TypeError, pickle.PicklingError), e:
35               <span class="docEmphStrong">raise</span> AttributeError, \
36                   "could not pickle %r" % self.name
37        <span class="docEmphStrong">finally</span>:
38           f.close()
39
40    <span class="docEmphStrong">def</span> __delete__(self, obj):
41        <span class="docEmphStrong">try</span>:
42           os.unlink(self.name)
43           FileDescr.saved.remove(self.name)
44        <span class="docEmphStrong">except</span> (OSError, ValueError), e:
45           <span class="docEmphStrong">pass</span></pre><br>

</td></tr></table></P>

<a name="ch13lev4sec13"></a>

<h5 id="title-IDALV1KN" class="docSection4Title">Lines 4045</H5>
<p class="docText">Finally, if the attribute is explicitly deleted, the file is removed, and the name unregistered.</p>
<p class="docText">Here is some sample usage of this class:</P>
<div class="docText"><pre>    &gt;&gt;&gt; <span class="docEmphStrong">class</span> MyFileVarClass(object):
    ...     foo = FileDescr('foo')
    ...     bar = FileDescr('bar')
    ...
    &gt;&gt;&gt; fvc = MyFileVarClass()
    &gt;&gt;&gt; <span class="docEmphStrong">print</span> fvc.foo
    Traceback (most recent call last):
      File "&lt;stdin&gt;", line 1, in ?
      File "descr.py", line 14, in __get__
        raise AttributeError, \
    AttributeError: 'foo' used before assignment
    &gt;&gt;&gt;
    &gt;&gt;&gt; fvc.foo = 42
    &gt;&gt;&gt; fvc.bar = 'leanna'
    &gt;&gt;&gt;
    &gt;&gt;&gt; <span class="docEmphStrong">print</span> fvc.foo, fvc.bar
    42 leanna
    &gt;&gt;&gt;
    &gt;&gt;&gt; <span class="docEmphStrong">del</span> fvc.foo
    &gt;&gt;&gt; <span class="docEmphStrong">print</span> fvc.foo, fvc.bar
    Traceback (most recent call last):
      File "&lt;stdin&gt;", line 1, in ?
      File "descr.py", line 14, in __get__
        raise AttributeError, \
    AttributeError: 'foo' used before assignment
    &gt;&gt;&gt;
    &gt;&gt;&gt; fvc.foo = __builtins__
    Traceback (most recent call last):
      File "&lt;stdin&gt;", line 1, in ?
      File "descr.py", line 35, in __set__
        raise AttributeError, \
    AttributeError: could not pickle 'foo'</pre></div><br>
<p class="docText">Attribute access appears normal, and the programmer cannot really tell that an object is pickled and stored to the filesystem (except in the last example where we tried to pickle a module, a no-no). We also put in a handler for cases when the pickle file gets corrupted. This is also the first descriptor where we have implemented <tt>__delete__()</tt>.</P>
<p class="docText">One thing to keep in mind with all of our examples is that we did not use the instance <tt>obj</tt> at all. Do not confuse <tt>obj</tt> with <tt>self</tt> as the latter is the instance of the descriptor, not the instance of the original class.</P>



<a name="ch13lev3sec42"></a>

<h5 id="title-IDAGX1KN" class="docSection3Title">Descriptor Summary</h5>
<p class="docText"><a name="iddle2153"></a><a name="iddle3470"></a>Believe it or not, you have already seen descriptors at work. Static methods, class methods, properties (see next section below), and even functions themselves are all descriptors. Think about this: functions are very generic objects in Python. There are built-in ones, user-defined ones, methods defined in classes, static methods, and class methods. Those are all examples of functions. The only difference between them is how they are called.</p>
<p class="docText">Functions are normally unbound. So are static methods, even though they are defined in classes. But methods need to be bound to an instance, and class methods need to be bound to a class, right? The descriptor for a function object knows all this, so depending on what type of function it is, a descriptor can &quot;wrap up&quot; a function object along with whatever it needs to be bound to, if applicable, and then returns that back to the caller. The way it works is that the function itself is a descriptor, and its <tt>__get__()</tt> method is what puts together the callable that it returns for you. It is quite an amazing generality, which does not break the way Python has been working all this time!</p>

<a name="ch13lev3sec43"></a>
<H5 id="title-IDAJY1KN" class="docSection3Title">Properties and <tt>property()</tt> Built-in Function</h5>
<p class="docText">Properties are a very useful and specific type of descriptor. They were meant to handle all accesses to instance attributes in a similar manner that we described for descriptors, above. When you access an instance attribute &quot;normally,&quot; you use the dotted-attribute notation. You were updating an instance's __dict__ attribute.</p>
<p class="docText">With properties, although your <span class="docEmphasis">usage</span> resembles normal attribute access, the actual <span class="docEmphasis">implementation</span> of such access uses function (or method) calls. In earlier versions of Python, as seen earlier this chapter, you could use <tt>__getattr__()</tt> and <tt>__setattr__()</tt> to play with attributes in general. The problem is that all attribute access goes through those special methods (and <tt>__getattribute__()</tt>), but with properties, you can give a property specific functions to execute for getting, setting, and deleting instance attributes, so you no longer have to use those other special methods (which became quite large actually if you had many instance attributes you were trying to manage).</P>
<p class="docText">The <tt>property()</tt> built-in function can take up to four arguments. Its signature is:</p>
<div class="docText"><pre>    property(fget=None, fset=None, fdel=None, doc=None)</pre></div><br>
<p class="docText">Keep in mind that although normal usage of <tt>property()</tt> is within a class definition where the functions passed in are actually methods, <tt>property()</tt> can accept functions. In fact, at the time that <tt>property()</tt> is called when a class is declared, those methods are unbound and thus really are functions!</p>
<p class="docText">Here is a simple example that creates a read-only integer attribute but hides it within the class by barely encrypting it using the bitwise XOR operator:</P>
<div class="docText"><pre><span class="docEmphStrong">class</span> ProtectAndHideX(object):
    <span class="docEmphStrong">def</span> __init__(self, x):
        <span class="docEmphStrong">assert</span> isinstance(x, int), \
            '"x" must be an integer!'
        self.__x = ~x

    <span class="docEmphStrong">def</span> get_x(self):
        <span class="docEmphStrong">return</span> ~self.__x

    x = property(get_x)</pre></div><BR>
<p class="docText">If we try it out, we see that it saves the first value we give it but does not allow us to set it again:</p>
<div class="docText"><pre>    &gt;&gt;&gt; inst = ProtectAndHideX('foo')
    Traceback (most recent call last):
      File "&lt;stdin&gt;", line 1, in ?
      File "prop.py", line 5, in __init__
        assert isinstance(x, int), \
    AssertionError: "x" must be an integer!
    &gt;&gt;&gt; inst = ProtectAndHideX(10)
    &gt;&gt;&gt; <span class="docEmphStrong">print</span> 'inst.x =', inst.x
    inst.x = 10
    &gt;&gt;&gt; inst.x = 20
    Traceback (most recent call last):
      File "&lt;stdin&gt;", line 1, in ?
    AttributeError: can't set attribute</pre></div><br>
<p class="docText">Here is another example, but with a setter:</p>
<div class="docText"><pre><span class="docEmphStrong">class</span> HideX(object):
    <span class="docEmphStrong">def</span> __init__(self, x):
        self.x = x

    <span class="docEmphStrong">def</span> get_x(self):
        <span class="docEmphStrong">return</span> ~self.__x

    <span class="docEmphStrong">def</span> set_x(self, x):
        <span class="docEmphStrong">assert</span> isinstance(x, int), \
            '"x" must be an integer!'
        self.__x = ~x

    x = property(get_x, set_x)</pre></div><br>
<p class="docText">Here is the output of this example:</p>
<div class="docText"><pre>    &gt;&gt;&gt; inst = HideX(20)
    &gt;&gt;&gt; <span class="docEmphStrong">print</span> inst.x
    20
    &gt;&gt;&gt; inst.x = 30
    &gt;&gt;&gt; <span class="docEmphStrong">print</span> inst.x
    30</pre></div><br>
<p class="docText">This property works because by the time the constructor is called to set the initial value of <tt>x</tt>, the getter already saves it as <tt>~x</tt> to <tt>self.__x</tt>.</p>
<p class="docText">You can even stick in a documentation string for your attribute, as shown here in this next example:</p>
<div class="docText"><pre><span class="docEmphStrong">from</span> math <span class="docEmphStrong">import</span> pi

<span class="docEmphStrong">def</span> get_pi(dummy):
    <span class="docEmphStrong">return</span> pi

<span class="docEmphStrong">class</span> PI(object):
    pi = property(get_pi, doc='Constant "pi"')</pre></div><br>
<p class="docText">Here we are using a function instead of a method for our property, just to show it can be done. When it is called, however, we have to keep in mind that <tt>self</tt> is going to be passed in as the first (and only) argument, so we still need to have a <tt>dummy</tt> variable to discard it. Here is the corresponding output:</p>
<div class="docText"><pre>    &gt;&gt;&gt; inst = PI()
    &gt;&gt;&gt; inst.pi
    3.1415926535897931
    &gt;&gt;&gt; <span class="docEmphStrong">print</span> PI.pi.__doc__
    Constant "pi"</pre></div><br>
<p class="docText">Can you see how properties take your functions (<tt>fget</tt>, <tt>fset</tt>, and <tt>fdel</tt>) and map them as descriptor methods <tt>__get__()</tt>, <tt>__set__()</tt>, and <tt>__delete__()</tt>? You did not have to create a descriptor class and define these callables as methods of your descriptor class. You just created functions (or methods) and gave them all to <tt>property()</tt>.</p>
<p class="docText">One drawback to creating your descriptor methods inside your class definition is that it clutters up the class namespace. Not only that, but isn't the point of having a property to control access to an attribute? But this control does not exist if they are not forced to use the property. Our second example does not enforce this because it allows access to our property methods (since they are part of the class definition):</P>
<div class="docText"><pre>    &gt;&gt;&gt; inst.set_x(40)      # can we require inst.x = 40?
    &gt;&gt;&gt; <span class="docEmphStrong">print</span> inst.x
    40</pre></div><br>
<p class="docText">A clever idiom in a recipe in the ActiveState Programmer Network Python Cookbook (<a class="docLink" target="_blank" href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/205183">http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/205183</a>) solves both of these problems by:</P>
<ul><LI><p class="docList">&quot;Borrowing&quot; a function's namespace,</p></LI><li><p class="docList">Creating the methods as inner functions intentionally named as (keyword) arguments to <tt>property()</tt>,</P></LI><LI><p class="docList">Returning all the (function/method) names and corresponding objects in a dictionary (via <tt>locals()</tt>),</P></li><li><p class="docList">Feeding it directly to <tt>property()</tt>, and</p></LI><li><p class="docList">Blowing away that temporary namespace</P></li></UL>
<p class="docText">There is no method clutter in the class's namespace because the methods were defined as inner functions in someone else's namespace. The user has no access to the methods because the namespace in which they were defined was destroyed (by going out-of-scope), thus they are compelled to use the property as that is now the one and only way for them to access the attribute. Here is our modified class inspired by the recipe:</p>
<div class="docText"><pre><span class="docEmphStrong">class</span> HideX(object):
    <span class="docEmphStrong">def</span> __init__(self, x):
        self.x = x

    @property
    <span class="docEmphStrong">def</span> x():
        <span class="docEmphStrong">def</span> fget(self):
            <span class="docEmphStrong">return</span> ~self.__x

        <span class="docEmphStrong">def</span> fset(self, x):
            <span class="docEmphStrong">assert</span> isinstance(x, int), \
                '"x" must be an integer!'
            self.__x = ~x

        <span class="docEmphStrong">return</span> locals()</pre></div><BR>
<p class="docText">Our code works exactly as before, but there two big differences: (1) the namespace for the class is much smaller and consists (only) of <tt>['__doc__'</tt>, <tt>'__init__'</tt>, <tt>'__module__'</tt>, <tt>'x']</tt>, and (2), the user can no longer use <tt>inst.set_x(40)</tt> to set the attribute ... they have to use <tt>init.x = 40</tt>. We also use a function decorator (<tt>@property</tt>) to reassign <tt>x</tt> from a function to a property object. Since decorators were introduced in <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec4">Python 2.4</a>, those of you using 2.2.x or 2.3.x need to replace the decorator with the following assignment after the <tt>x()</tt> function declaration with <tt>x = property(**x()</tt>).</P>



<a name="ch13lev2sec54"></a>

<h4 id="title-IDAHD2KN" class="docSection2Title">13.16.5. Metaclasses and <tt>__metaclass__</tt></h4>
<a name="ch13lev3sec44"></a>
<h5 id="title-IDARD2KN" class="docSection3Title">What Are Metaclasses?</h5>
<p class="docText"><a name="iddle1161"></a><a name="iddle2851"></a><a name="iddle2852"></a><a name="iddle3087"></a>Metaclasses are probably the most mind-bending feature that was added with new-style classes. Metaclasses are classes that let you define how certain classes can be constructed, basically giving you a level of control over how classes are created. (You do not even need to think at the instance level.) They have been talked about since before the days of Python 1.5 (when many minds were bent), but they are finally a reality.</P>
<p class="docText">Basically, you can think of a metaclass as the class of a class, or rather, a class whose instances are other classes. Believe it or not, whenever you create a class now, you are actually employing the default metaclass, which is a (or rather, <span class="docEmphasis">the</span>) <tt>type</tt> object. (If classic classes are used, the metaclasses for those are <tt>types.ClassType</tt>.) Take any class and call <tt>type()</tt> on it, and you will see what it is an instance of:</p>
<div class="docText"><pre><span class="docEmphStrong">class</span> C(object):
    <span class="docEmphStrong">pass

class</span> CC:
    <span class="docEmphStrong">pass</span>

&gt;&gt;&gt; type(C)
&lt;type 'type'&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; type(CC)
&lt;type 'classobj'&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; <span class="docEmphStrong">import</span> types
&gt;&gt;&gt; type(CC) <span class="docEmphStrong">is</span> types.ClassType
True</pre></div><br>

<a name="ch13lev3sec45"></a>
<H5 id="title-IDA4F2KN" class="docSection3Title">When Are Metaclasses Used?</h5>
<p class="docText">Metaclasses are always used when creating classes. When executing a class definition, the interpreter has to know the correct metaclass to use. It will look for a class attribute named <tt>__metaclass__</tt> first, and if it is there, it will use the class that is assigned to that attribute as the metaclass.</p>
<p class="docText">If that attribute has not been defined, it will go up and search an ancestor class for <tt>__metaclass__</tt>. All new-style classes must inherit from <tt>object</tt> or <tt>type</tt> if there are no other base classes (type (object) <span class="docEmphStrong"><tt>is</tt></span> <tt>type</tt> anyway). If that is not found, it checks for a global variable named <tt>__metaclass__</tt> and uses it if it exists. Otherwise, the class is a classic class, and <tt>types.ClassType</tt> is used as the metaclass. (Note you can do some trickery here... if you define a classic class and set <tt>__metaclass__ = type</tt>, you have parlayed it into a new-style class!)</p>
<p class="docText">Any time a class declaration is executed, the correct (and usually default) metaclass is determined, and that metaclass (always) passes three arguments (to its constructor): the class name, the tuple of base classes to inherit from, and the (class) attribute dictionary.</P>

<a name="ch13lev3sec46"></a>
<H5 id="title-IDAGH2KN" class="docSection3Title">Who Are Metaclass Users?</h5>
<p class="docText">To many, the subject of metaclasses belongs in the realm of the theoretical or pure object-oriented thinking and has no place in everyday programming. To some extent that is true; however, the most important thing to keep in mind is that the end consumers of metaclasses are programmers themselves, not application users. You can define metaclasses that &quot;force&quot; programmers to implement solution classes in specific ways, which can either simplify their work or make them program to a target specification.</p>

<a name="ch13lev3sec47"></a>
<h5 id="title-IDASH2KN" class="docSection3Title">When Are Metaclasses Created?</h5>
<p class="docText">Metaclasses are created for the situations described just above, when you want to change the default behavior of how classes can and are created. Most Python users will not be creating or explicitly using metaclasses. The standard behavior in creating new-style or classic classes is to just take the default behavior by using the system-supplied metaclasses.</p>
<p class="docText">In most cases, users will not even be aware that metaclasses are providing the templated default behavior of class creation (or metaclass instantiation). Although metaclasses will not be created on a regular basis, let us take a look at a simple example below. (More examples can be found in the documents listed at the end of this subsection.)</p>

<a name="ch13lev3sec48"></a>
<h5 id="title-IDADI2KN" class="docSection3Title">Metaclass Example 1</h5>
<p class="docText">The first example of metaclasses we are presenting here is (hopefully) very simple. It does not do anything at all except timestamp when a class is created using the metaclass. (As you know now, it happens when the class is created.)</p>
<p class="docText">Take a look at the following script. It contains print statements scattered throughout so that you can track the events as they occur:</p>
<div class="docText"><pre>#!/usr/bin/env python

<span class="docEmphStrong">from</span> time  <span class="docEmphStrong">import</span> ctime

<span class="docEmphStrong">print</span> '*** Welcome to Metaclasses!'
<span class="docEmphStrong">print</span> '\tMetaclass declaration first.'

<span class="docEmphStrong">class</span> MetaC(type):
      <span class="docEmphStrong">def</span> __init__(cls, name, bases, attrd):
          super(MetaC, cls).__init__(name, bases, attrd)
          <span class="docEmphStrong">print</span> '*** Created class %r at: %s' % (
                 name, ctime())

<span class="docEmphStrong">print</span> '\tClass "Foo" declaration next.'

<span class="docEmphStrong">class</span> Foo(object):
      __metaclass__ = MetaC
      <span class="docEmphStrong">def</span> __init__(self):
          <span class="docEmphStrong">print</span> '*** Instantiated class %r at: %s' % (
                 self.__class__.__name__, ctime())

<span class="docEmphStrong">print</span> '\tClass "Foo" instantiation next.'
f = Foo()
<span class="docEmphStrong">print</span> '\tDONE'</pre></div><br>
<p class="docText">If we run this script, we get the following output:</p>
<div class="docText"><pre>    *** Welcome to Metaclasses!
        Metaclass declaration first.
        Class "Foo" declaration next.
    *** Created class 'Foo' at: Tue May 16 14:25:53 2006
        Class "Foo" instantiation next.
    *** Instantiated class 'Foo' at: Tue May 16 14:25:53 2006
        DONE</pre></div><BR>
<p class="docText">Once you are comfortable with the fact that a class declaration actually causes some work to be done, then you are well under way.</p>

<a name="ch13lev3sec49"></a>
<H5 id="title-IDA1K2KN" class="docSection3Title">Metaclass Example 2</h5>
<p class="docText">In this second example, we are going to create a metaclass that forces programmers to supply a <tt>__str__()</tt> method in their classes so that their users can see something more useful than the generic Python object string (<tt>&lt;</tt> <span class="docEmphasis"><tt>object</tt></span> object at <span class="docEmphasis"><tt>id</tt></span><tt>&gt;</tt>) we saw earlier in this chapter.</P>
<p class="docText">Our metaclass will also (strongly) suggest users override <tt>__repr__()</tt> if they have not done that either, but it is only a warning. Not implementing <tt>__str__()</tt> will result in a <tt>TypeError</tt> exception being thrown, forcing users to create a special method with that name. Here is the code for the metaclass:</p>
<div class="docText"><pre><span class="docEmphStrong">from</span> warnings  <span class="docEmphStrong">import</span> warn

<span class="docEmphStrong">class</span> ReqStrSugRepr(type):

    <span class="docEmphStrong">def</span> __init__(cls, name, bases, attrd):
        super(ReqStrSugRepr, cls).__init__(
            name, bases, attrd)

        <span class="docEmphStrong">if</span> '__str__'  <span class="docEmphStrong">not in</span> attrd:
           <span class="docEmphStrong">raise</span> TypeError(
"Class requires overriding of __str__()")

        <span class="docEmphStrong">if</span> '__repr__'  <span class="docEmphStrong">not in</span> attrd:
            warn(
'Class suggests overriding of __repr__()\n',
             stacklevel=3)</pre></div><BR>
<p class="docText">We will create three example classes that use our metaclass, one that overrides both <tt>__str__()</tt> and <tt>__repr__()</tt> special methods (<tt>Foo</tt>), one that only implements the <tt>__str__()</tt> special method (<tt>Bar</tt>), and one that implements neither (<tt>Foo</tt>Bar), an error situation. The full application is presented here as <a class="docLink" href="#ch13list10">Example 13.10</a>.</p>
<a name="ch13list10"></a><H5 id="title-IDAAO2KN" class="docExampleTitle">Example 13.10. Metaclass Example (<tt>meta.py</tt>)</H5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>


<p class="docText"><span class="docEmphasis">This module features a metaclass and three classes under the jurisdiction of the metaclass. After each class is created, you will see a </span><span class="docEmphStrong"><tt>print </tt></span><span class="docEmphasis">statement.</span></p>

<pre>1  #!/usr/bin/env python
2
3  <span class="docEmphStrong">from</span> warnings  <span class="docEmphStrong">import</span> warn
4
5  <span class="docEmphStrong">class</span> ReqStrSugRepr(type):
6
7      <span class="docEmphStrong">def</span> __init__(cls, name, bases, attrd):
8          super(ReqStrSugRepr, cls).__init__(
9             name, bases, attrd)
10
11         <span class="docEmphStrong">if</span> '__str__'  <span class="docEmphStrong">not in</span> attrd:
12            <span class="docEmphStrong">raise</span> TypeError(
13            "Class requires overriding of __str__()")
14
15         <span class="docEmphStrong">if</span> '__repr__'  <span class="docEmphStrong">not in</span> attrd:
16            warn(
17            'Class suggests overriding of __repr__()\n',
18                 stacklevel=3)
19
20 <span class="docEmphStrong">print</span> '*** Defined ReqStrSugRepr (meta)class\n'
21
22 <span class="docEmphStrong">class</span> Foo(object):
23     __metaclass__ = ReqStrSugRepr
24
25     <span class="docEmphStrong">def</span> __str__(self):
26         <span class="docEmphStrong">return</span> 'Instance of class:', \
27            self.__class__.__name__
28
29     <span class="docEmphStrong">def</span> __repr__(self):
30         <span class="docEmphStrong">return</span> self.__class__.__name__
31
32 <span class="docEmphStrong">print</span> '*** Defined Foo class\n'
33
34 <span class="docEmphStrong">class</span> Bar(object):
35     __metaclass__ = ReqStrSugRepr
36
37     <span class="docEmphStrong">def</span> __str__(self):
38         <span class="docEmphStrong">return</span> 'Instance of class:', \
39            self.__class__.__name__
40
41 <span class="docEmphStrong">print</span> '*** Defined Bar class\n'
42
43 <span class="docEmphStrong">class</span> FooBar(object):
44     __metaclass__ = ReqStrSugRepr
45
46 <span class="docEmphStrong">print</span> '*** Defined FooBar class\n'</pre><br>

</TD></tr></table></P>
<p class="docText">Running this script, we get the following output:</p>
<div class="docText"><pre>    $ python meta.py
    *** Defined ReqStrSugRepr (meta)class

    *** Defined Foo class

    sys:1: UserWarning: Class suggests overriding of
    __repr__()

    *** Defined Bar class

    Traceback (most recent call last):
      File "meta.py", line 43, in ?
        class FooBar(object):
      File "meta.py", line 12, in __init__
        raise TypeError(
    TypeError: Class requires overriding of __str__()</pre></div><BR>
<p class="docText"><a name="iddle1393"></a><a name="iddle4289"></a><a name="iddle4396"></a><a name="iddle4398"></a><a name="iddle4401"></a>Note how we got past declaring <tt>Foo</tt> without incident. With <tt>Bar</tt>, we received the warning for not implementing <tt>__repr__()</tt>, and <tt>FooBar</tt> did not pass the security check, hence the reason why the application failed to make it to the (final) <span class="docEmphStrong"><tt>print</tt></span> statement. Another important thing to note is that we did not even create any instances of the test classes... they are not even part of our picture. However, keep in mind that those classes themselves are instances of our metaclass. This is but one example of the power of metaclasses.</p>
<p class="docText">There are many more examples online and in the Python documentation, PEPs 252 and 253, the What's New in <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec2">Python 2.2</a> document, and Guido van Rossum's essay entitled, &quot;Unifying Types and Classes in <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec2">Python 2.2</a>.&quot; You can find a link to that document from the main Python release page for 2.2.3.</P>





<a href="14051536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch13lev1sec15.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch13lev1sec17.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>