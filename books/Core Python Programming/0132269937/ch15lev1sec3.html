<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 15.3.&nbsp; REs and Python</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch15lev1sec2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch15lev1sec4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a href="14051536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a><a name="ch15lev1sec3"></a>
<h3 id="title-IDAF4RJ" class="docSection1Title">15.3. REs and Python</H3>
<p class="docText">Now that we know all about regular expressions, we can examine how Python currently supports regular expressions through the <tt>re</tt> module. The <tt>re</tt> module was introduced to Python in version 1.5. If you are using an older version of Python, you will have to use the now-obsolete <tt>regex</tt> and <tt>regsub</tt> modulesthese older modules are more Emacs-flavored, are not as full-featured, and are in many ways incompatible with the current <tt>re</tt> module. Both modules were removed from Python in 2.5, and import either of the modules from 2.5 and above triggers <tt>Import Error</tt> exception.</p>
<p class="docText">
<img border="0" alt="" width="50" height="47" SRC="images/2_5.jpg"></P>


<p class="docText">However, regular expressions are still regular expressions, so most of the basic concepts from this section can be used with the old <tt>regex</tt> and <tt>regsub</tt> software. In contrast, the new <tt>re</tt> module supports the more powerful <a name="iddle1477"></a><a name="iddle2042"></a><a name="iddle2176"></a><a name="iddle2815"></a><a name="iddle2874"></a><a name="iddle3549"></a><a name="iddle3593"></a><a name="iddle3607"></a><a name="iddle3702"></a>and regular Perl-style (Perl5) REs, allows multiple threads to share the same compiled RE objects, and supports named subgroups. In addition, there is a transition module called <tt>reconvert</tt> to help developers move from <tt>regex/regsub</tt> to <tt>re</tt>. However, be aware that although there are different flavors of regular expressions, we will primarily focus on the current incarnation for Python.</P>
<p class="docText">The <tt>re</tt> engine was rewritten in 1.6 for performance enhancements as well as adding Unicode support. The interface was not changed, hence the reason the module name was left alone. The new <tt>re</tt> engineknown internally as <tt>sre</tt> thus replaces the existing 1.5 engineinternally called <tt>pcre</tt>.</P>
<a name="ch15lev2sec10"></a>
<H4 id="title-IDAPC0SF" class="docSection2Title">15.3.1. <tt>re</tt> Module: Core Functions and Methods</h4>
<p class="docText">The chart in <a class="docLink" href="#ch15table02">Table 15.2</a> lists the more popular functions and methods from the <tt>re</tt> module. Many of these functions are also available as methods of compiled regular expression objects &quot;regex objects&quot; and RE &quot;match objects.&quot; In this subsection, we will look at the two main functions/methods, <tt>match()</tt> and <tt>search()</tt>, as well as the <tt>compile()</tt> function. We will introduce several more in the next section, but for more information on all these and the others that we do not cover, we refer you to the Python documentation.</p>
<a name="ch15table02"></a><p><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 15.2. Common Regular Expression Functions and Methods</h5></caption><colgroup align="left" span="2"><col width="150"><col width="350"></colgroup><thead><TR><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Function/Method</span></p></th><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Description</span></P></th></tr></thead><TR><TD class="docTableCell" align="left" valign="top" colspan="2" style="background-color:#DDDDDD"><p class="docText"><tt>re</tt> <span class="docEmphBoldItalic">Module Function Only</span></p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>compile(</tt><span class="docEmphasis"><tt>pattern, flags</tt></span><tt>=0)</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Compile RE <span class="docEmphasis"><tt>pattern</tt></span> with any optional <span class="docEmphasis"><tt>flags</tt></span> and return a regex object</p></td></tr><TR><TD class="docTableCell" align="left" valign="top" colspan="2" style="background-color:#DDDDDD"><p class="docText"><tt>re</tt> <span class="docEmphBoldItalic">Module Functions and regex Object Methods</span></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>match(</tt><span class="docEmphasis"><tt>pattern, string, flags</tt></span><tt>=0)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Attempt to match RE <span class="docEmphasis"><tt>pattern</tt></span> to <span class="docEmphasis"><tt>string</tt></span> with optional <span class="docEmphasis"><tt>flags</tt></span>; return match object on success, <tt>None</tt> on failure</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>search(</tt><span class="docEmphasis"><tt>pattern, string, flags</tt></span><tt>=0)</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Search for first occurrence of RE <span class="docEmphasis"><tt>pattern</tt></span> within <span class="docEmphasis"><tt>string</tt></span> with optional <span class="docEmphasis"><tt>flags</tt></span>; return match object on success, <tt>None</tt> on failure</P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>findall(</tt><span class="docEmphasis"><tt>pattern, string[,flags]</tt></span><tt>)</tt><sup class="docFootnote"><a class="docLink" href="#ch15tna">[a]</a></sup></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Look for all (non-overlapping) occurrences of <span class="docEmphasis"><tt>pattern</tt></span> in <span class="docEmphasis"><tt>string</tt></span>; return a list of matches</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>finditer(</tt><span class="docEmphasis"><tt>pattern, string[, flags]</tt></span><tt>)</tt><sup class="docFootnote"><a class="docLink" href="#ch15tnb">[b]</a></sup></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Same as <tt>findall()</tt> except returns an iterator instead of a list; for each match, the iterator returns a match object</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><a name="iddle1479"></a><a name="iddle2273"></a><a name="iddle3587"></a><a name="iddle3894"></a><a name="iddle4068"></a><tt>split(</tt><span class="docEmphasis"><tt>pattern, string, max</tt></span><tt>=0)</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Split <span class="docEmphasis"><tt>string</tt></span> into a list according to RE <span class="docEmphasis"><tt>pattern</tt></span> delimiter and return list of successful matches, splitting at most <span class="docEmphasis"><tt>max</tt></span> times (split all occurrences is the default)</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sub(</tt><span class="docEmphasis"><tt>pattern, repl, string, max</tt></span><tt>=0)</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Replace all occurrences of the RE <span class="docEmphasis"><tt>pattern</tt></span> in <span class="docEmphasis"><tt>string</tt></span> with <span class="docEmphasis"><tt>repl</tt></span>, substituting all occurrences unless <span class="docEmphasis"><tt>max</tt></span> provided (also see <tt>subn()</tt> which, in addition, returns the number of substitutions made)</p></td></tr><tr><td class="docTableCell" align="left" valign="top" colspan="2" style="background-color:#DDDDDD"><p class="docText"><span class="docEmphBoldItalic">Match Object Methods</span></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>group(</tt><span class="docEmphasis"><tt>num</tt></span><tt>=0)</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Return entire match (or specific subgroup <span class="docEmphasis"><tt>num</tt></span>)</p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>groups()</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Return all matching subgroups in a tuple (empty if there weren't any)</P></TD></TR></table></p><br><blockquote><p class="docFootnote"><sup><a name="ch15tna">[a]</a></sup> New in Python 1.5.2; <span class="docEmphasis"><tt>flags</tt></span> parameter added in 2.4.</p></blockquote><blockquote><p class="docFootnote"><sup><a name="ch15tnb">[b]</a></sup> New in <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec2">Python 2.2</a>; <span class="docEmphasis"><tt>flags</tt></span> parameter added in 2.4.</P></blockquote>
<a name="ch15note02"></a><div class="docNote"><p class="docNoteTitle">Core Note: RE compilation (to compile or not to compile?)</p><P><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="50" SRC="images/core_note.jpg">


</td><TD valign="top"><p class="docText"><span class="docEmphasis">In <a class="docLink" href="ch14.html#ch14">Chapter 14</a>, we described how Python code is eventually compiled into bytecode, which is then executed by the interpreter. In particular, we mentioned that calling <tt>eval()</tt> or <span class="docEmphStrong"><tt>exec</tt></span> with a code object rather than a string provides a significant performance improvement due to the fact that the compilation process does not have to be performed. In other words, using precompiled code objects is faster than using strings because the interpreter will have to compile it into a code object (anyway) before execution.</span></P><p class="docText"><span class="docEmphasis">The same concept applies to REsregular expression patterns must be compiled into regex objects before any pattern matching can occur. For REs, which are compared many times during the course of execution, we highly recommend using precompilation first because, again, REs have to be compiled anyway, so doing it ahead of time is prudent for performance reasons. <tt>re.compile()</tt> provides this functionality.</span></p><p class="docText"><span class="docEmphasis">The module functions do cache the compiled objects, though, so it's not as if every <tt>search()</tt> and <tt>match()</tt> with the same RE pattern requires compilation. Still, you save the cache lookups and do not have to make function calls with the same string over and over. In Python 1.5.2, this cache held up to 20 compiled RE objects, but in 1.6, due to the additional overhead of Unicode awareness, the compilation engine is a bit slower, so the cache has been extended to 100 compiled regex objects.</span></p></td></tr></table></P></div><br>

<a name="ch15lev2sec11"></a>

<h4 id="title-IDALQ2SF" class="docSection2Title">15.3.2. Compiling REs with <tt>compile()</tt></H4>
<p class="docText"><a name="iddle2274"></a><a name="iddle2278"></a><a name="iddle2785"></a><a name="iddle2867"></a><a name="iddle3595"></a>Almost all of the <tt>re</tt> module functions we will be describing shortly are available as methods for regex objects. Remember, even with our recommendation, precompilation is not required. If you compile, you will use methods; if you don't, you will just use functions. The good news is that either way, the names are the same whether a function or a method. (This is the reason why there are module functions and methods that are identical, e.g., <tt>search()</tt>, <tt>match()</tt>, etc., in case you were wondering.) Since it saves one small step for most of our examples, we will use strings instead. We will throw in a few with compilation, though, just so you know how it is done.</p>
<p class="docText">Optional flags may be given as arguments for specialized compilation. These flags allow for case-insensitive matching, using system locale settings for matching alphanumeric characters, etc. Please refer to the documentation for more details. These flags, some of which have been briefly mentioned (i.e., <tt>DOTALL</tt>, <tt>LOCALE</tt>), may also be given to the module versions of <tt>match()</tt> and <tt>search()</tt> for a specific pattern match attemptthese flags are mostly for compilation reasons, hence the reason why they can be passed to the module versions of <tt>match()</tt> and <tt>search(),</tt> which do compile an RE pattern once. If you want to use these flags with the methods, they must already be integrated into the compiled regex objects.</p>
<p class="docText">In addition to the methods below, regex objects also have some data attributes, two of which include any compilation flags given as well as the regular expression pattern compiled.</p>

<a name="ch15lev2sec12"></a>
<H4 id="title-IDARS2SF" class="docSection2Title">15.3.3. Match Objects and the <tt>group()</tt> and <tt>groups ()</tt> Methods</H4>
<p class="docText">There is another object type in addition to the regex object when dealing with regular expressions, the <span class="docEmphasis">match object</span>. These are the objects returned on successful calls to <tt>match()</tt> or <tt>search()</tt>. Match objects have two primary methods, <tt>group()</tt> and <tt>groups()</tt>.</p>
<p class="docText"><tt>group()</tt> will either return the entire match, or a specific subgroup, if requested. <tt>groups()</tt> will simply return a tuple consisting of only/all the subgroups. If there are no subgroups requested, then <tt>groups()</tt> returns an empty tuple while <tt>group()</tt> still returns the entire match.</p>
<p class="docText">Python REs also allow for named matches, which are beyond the scope of this introductory section on REs. We refer you to the complete <tt>re</tt> module documentation regarding all the more advanced details we have omitted here.</p>

<a name="ch15lev2sec13"></a>

<h4 id="title-IDA4T2SF" class="docSection2Title">15.3.4. Matching Strings with <tt>match()</tt></h4>
<p class="docText"><a name="iddle2811"></a><a name="iddle2816"></a><a name="iddle3594"></a><tt>match()</tt> is the first <tt>re</tt> module function and RE object (regex object) method we will look at. The <tt>match()</tt> function attempts to match the pattern to the string, starting at the beginning. If the match is successful, a match object is returned, but on failure, <tt>None</tt> is returned. The <tt>group()</tt> method of a match object can be used to show the successful match. Here is an example of how to use <tt>match()</tt> [and <tt>group()</tt>]:</p>
<div class="docText"><pre>&gt;&gt;&gt; m = re.match('foo', 'foo')    <span class="docEmphStrong">#</span> pattern matches string
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None:         <span class="docEmphStrong">#</span> show match if successful
...      m.group()
...
'foo'</pre></div><br>
<p class="docText">The pattern &quot;foo&quot; matches exactly the string &quot;foo.&quot; We can also confirm that <tt>m</tt> is an example of a match object from within the interactive interpreter:</p>
<div class="docText"><pre>&gt;&gt;&gt; m                  # confirm match object returned
&lt;re.MatchObject instance at 80ebf48&gt;</pre></div><br>
<p class="docText">Here is an example of a failed match where <tt>None</tt> is returned:</p>
<div class="docText"><pre>&gt;&gt;&gt; m = re.match('foo', 'bar')# pattern does not match string
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()# (1-line version of <span class="docEmphStrong">if</span>
clause)
...
&gt;&gt;&gt;</pre></div><br>
<p class="docText">The match above fails, thus <tt>None</tt> is assigned to <tt>m</tt>, and no action is taken due to the way we constructed our <span class="docEmphStrong"><tt>if</tt></span> statement. For the remaining examples, we will try to leave out the <span class="docEmphStrong"><tt>if</tt></span> check for brevity, if possible, but in practice it is a good idea to have it there to prevent <tt>AttributeError</tt> exceptions (<tt>None</tt> is returned on failures, which does not have a <tt>group()</tt> attribute [method].)</p>
<p class="docText">A match will still succeed even if the string is longer than the pattern as long as the pattern matches from the beginning of the string. For example, the pattern &quot;foo&quot; will find a match in the string &quot;food on the table&quot; because it matches the pattern from the beginning:</P>
<div class="docText"><pre>&gt;&gt;&gt; m = re.match('foo', 'food on the table') # match succeeds
&gt;&gt;&gt; m.group()
'foo'</pre></div><br>
<p class="docText">As you can see, although the string is longer than the pattern, a successful match was made from the beginning of the string. The substring &quot;foo&quot; represents the match, which was extracted from the larger string.</P>
<p class="docText"><a name="iddle2805"></a><a name="iddle3611"></a><a name="iddle3614"></a><a name="iddle3700"></a><a name="iddle3703"></a><a name="iddle4015"></a><a name="iddle4035"></a>We can even sometimes bypass saving the result altogether, taking advantage of Python's object-oriented nature:</p>
<div class="docText"><pre>&gt;&gt;&gt; re.match('foo', 'food on the table').group()
'foo'</pre></div><BR>
<p class="docText">Note from a few paragraphs above that an <tt>AttributeError</tt> will be generated on a non-match.</p>

<a name="ch15lev2sec14"></a>
<H4 id="title-IDAT02SF" class="docSection2Title">15.3.5. Looking for a Pattern within a String with <tt>search()</tt> (Searching versus Matching)</h4>
<p class="docText">The chances are greater that the pattern you seek is somewhere in the middle of a string, rather than at the beginning. This is where <tt>search()</tt> comes in handy. It works exactly in the same way as match except that it searches for the first occurrence of the given RE pattern anywhere with its string argument. Again, a match object is returned on success and <tt>None</tt> otherwise.</P>
<p class="docText">We will now illustrate the difference between <tt>match()</tt> and <tt>search()</tt>. Let us try a longer string match attempt. This time, we will try to match our string &quot;foo&quot; to &quot;seafood&quot;:</P>
<div class="docText"><pre>&gt;&gt;&gt; m = re.match('foo', 'seafood')     # no match
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
&gt;&gt;&gt;</pre></div><BR>
<p class="docText">As you can see, there is no match here. <tt>match()</tt> attempts to match the pattern to the string from the beginning, i.e., the &quot;f&quot; in the pattern is matched against the &quot;s&quot; in the string, which fails immediately. However, the string &quot;foo&quot; <span class="docEmphasis">does</span> appear (elsewhere) in &quot;seafood,&quot; so how do we get Python to say &quot;yes&quot;? The answer is by using the <tt>search()</tt> function. Rather than attempting a <span class="docEmphasis">match</span>, <tt>search()</tt> looks for the first occurrence of the pattern within the string. <tt>search()</tt> searches strictly from left to right.</P>
<div class="docText"><pre>&gt;&gt;&gt; m = re.search('foo', 'seafood')   # use search() instead
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
'foo'                   # search succeeds where match failed
&gt;&gt;&gt;</pre></div><br>
<p class="docText">We will be using the <tt>match()</tt> and <tt>search()</tt> regex object methods and the <tt>group()</tt> and <tt>groups()</tt> match object methods for the remainder of this subsection, exhibiting a broad range of examples of how to use regular expressions with Python. We will be using almost all of the special characters and symbols that are part of the regular expression syntax.</p>

<a name="ch15lev2sec15"></a>

<h4 id="title-IDAK32SF" class="docSection2Title">15.3.6. Matching More than One String ( <tt>|</tt> )</H4>
<p class="docText"><a name="iddle1013"></a><a name="iddle1021"></a><a name="iddle1025"></a><a name="iddle1326"></a><a name="iddle1758"></a><a name="iddle2788"></a><a name="iddle2795"></a><a name="iddle3413"></a><a name="iddle3425"></a><a name="iddle3582"></a><a name="iddle3597"></a><a name="iddle3828"></a><a name="iddle4014"></a><a name="iddle4036"></a>In <a class="docLink" href="ch15lev1sec2.html#ch15lev1sec2">Section 15.2</a>, we used the pipe in the RE &quot;<tt>bat|bet|bit</tt>.&quot; Here is how we would use that RE with Python:</p>
<div class="docText"><pre>&gt;&gt;&gt; bt = 'bat|bet|bit'       # RE pattern: bat, bet, bit
&gt;&gt;&gt; m = re.match(bt, 'bat')       # 'bat' is a match
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
'bat'
&gt;&gt;&gt; m = re.match(bt, 'blt')       # no match for 'blt'
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
&gt;&gt;&gt; m = re.match(bt, 'He bit me!') # does not match string
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
&gt;&gt;&gt; m = re.search(bt, 'He bit me!') # found 'bit' via search
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
'bit'</pre></div><BR>

<a name="ch15lev2sec16"></a>
<h4 id="title-IDAQC3SF" class="docSection2Title">15.3.7. Matching Any Single Character  ( <tt>.</tt> )</H4>
<p class="docText">In the examples below, we show that a dot cannot match a NEWLINE or a non-character, i.e., the empty string:</p>
<div class="docText"><pre>&gt;&gt;&gt; anyend = '.end'
&gt;&gt;&gt; m = re.match(anyend, 'bend')     # dot matches 'b'
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
'bend'
&gt;&gt;&gt; m = re.match(anyend, 'end')      # no char to match
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
&gt;&gt;&gt; m = re.match(anyend, '\nend')    # any char except \n
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
&gt;&gt;&gt; m = re.search('.end', 'The end.') # matches ' ' in search
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
' end'</pre></div><BR>
<p class="docText">The following is an example of searching for a real dot (decimal point) in a regular expression where we escape its functionality with a backslash:</P>
<div class="docText"><pre> &gt;&gt;&gt; patt314 = '3.14'         # RE dot
 &gt;&gt;&gt; pi_patt = '3\.14'        # literal dot (dec. point)
&gt;&gt;&gt; m = re.match(pi_patt, '3.14') # exact match
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
'3.14'
&gt;&gt;&gt; m = re.match(patt314, '3014') # dot matches '0'
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
'3014'
&gt;&gt;&gt; m = re.match(patt314, '3.14') # dot matches '.'
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
'3.14'</pre></div><br>

<a name="ch15lev2sec17"></a>
<h4 id="title-IDAKF3SF" class="docSection2Title">15.3.8. Creating Character Classes ( <tt>[ ]</tt> )</h4>
<p class="docText"><a name="iddle1040"></a><a name="iddle1227"></a><a name="iddle1329"></a><a name="iddle1336"></a><a name="iddle1337"></a><a name="iddle2793"></a><a name="iddle2803"></a><a name="iddle2809"></a><a name="iddle3586"></a><a name="iddle3592"></a><a name="iddle3609"></a><a name="iddle3617"></a><a name="iddle3639"></a><a name="iddle3640"></a>Earlier, we had a long discussion about &quot;<tt>[cr][23][dp][o2]</tt>&quot; and how it differs from &quot;<tt>r2d2|c3po.</tt>&quot; With the examples below, we will show that &quot;<tt>r2d2|c3po</tt>&quot; is more restrictive than &quot;<tt>[cr][23][dp][o2]</tt>&quot;:</p>
<div class="docText"><pre>&gt;&gt;&gt; m = re.match('[cr][23][dp][o2]', 'c3po') # matches 'c3po'
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
'c3po'
&gt;&gt;&gt; m = re.match('[cr][23][dp][o2]', 'c2do') # matches 'c2do'
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
'c2do'
&gt;&gt;&gt; m = re.match('r2d2|c3po', 'c2do') # does not match 'c2do'
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
&gt;&gt;&gt; m = re.match('r2d2|c3po', 'r2d2') # matches 'r2d2'
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
'r2d2'</pre></div><BR>

<a name="ch15lev2sec18"></a>
<h4 id="title-IDANK3SF" class="docSection2Title">15.3.9. Repetition, Special Characters, and Grouping</h4>
<p class="docText">The most common aspects of REs involve the use of special characters, multiple occurrences of RE patterns, and using parentheses to group and extract submatch patterns. One particular RE we looked at related to simple e-mail addresses (&quot;<tt>\w+@\w+\.com</tt>&quot;). Perhaps we want to match more e-mail addresses than this RE allows. In order to support an additional hostname in front of the domain, i.e., &quot;<tt>www.xxx.com</tt>&quot; as opposed to accepting only &quot;<tt>xxx.com</tt>&quot; as the entire domain, we have to modify our existing RE. To indicate that the hostname is optional, we create a pattern that matches the hostname (followed by a dot), use the <tt>?</tt> operator indicating zero or one copy of this pattern, and insert the optional RE into our previous RE as follows: &quot;<tt>\w+@(\w+\.)?\w+\.com.</tt>&quot; As you can see from the examples below, either one or two names are now accepted in front of the &quot;<tt>.com</tt>&quot;:</P>
<div class="docText"><pre>&gt;&gt;&gt; patt = '\w+@(\w+\.)?\w+\.com'
&gt;&gt;&gt; re.match(patt, 'nobody@xxx.com').group()
'nobody@xxx.com'
&gt;&gt;&gt; re.match(patt, 'nobody@www.xxx.com').group()
'nobody@www.xxx.com'</pre></div><br>
<p class="docText">Furthermore, we can even extend our example to allow any number of intermediate subdomain names with the pattern below. Take special note of our slight change from using <tt>?</tt> to <tt>*.</tt>: &quot;<tt>\w+@(\w+\.)*\w+\.com</tt>&quot;:</p>
<div class="docText"><pre>&gt;&gt;&gt; patt = '\w+@(\w+\.)*\w+\.com'
&gt;&gt;&gt; re.match(patt, 'nobody@www.xxx.yyy.zzz.com').group()
'nobody@www.xxx.yyy.zzz.com'</pre></div><br>
<p class="docText">However, we must add the disclaimer that using solely alphanumeric characters does not match all the possible characters that may make up e-mail addresses. The above RE patterns would not match a domain such as &quot;<tt>xxx-yyy.com</tt>&quot; or other domains with &quot;<tt>\W</tt>&quot; characters.</P>
<p class="docText">Earlier, we discussed the merits of using parentheses to match and save subgroups for further processing rather than coding a separate routine to manually parse a string after an RE match had been determined. In particular, we discussed a simple RE pattern of an alphanumeric string and a number separated by a hyphen, &quot;<tt>\w+-\d+,</tt>&quot; and how adding subgrouping to form a new RE, &quot;<tt>(\w+)-(\d+),</tt>&quot; would do the job. Here is how the original RE works:</P>
<div class="docText"><pre>&gt;&gt;&gt; m = re.match('\w\w\w-\d\d\d', 'abc-123')
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
'abc-123'

&gt;&gt;&gt; m = re.match('\w\w\w-\d\d\d', 'abc-xyz')
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
&gt;&gt;&gt;</pre></div><br>
<p class="docText"><a name="iddle2277"></a>In the above code, we created an RE to recognize three alphanumeric characters followed by three digits. Testing this RE on &quot;<tt>abc-123,</tt>&quot; we obtained positive results while &quot;<tt>abc-xyz</tt>&quot; fails. We will now modify our RE as discussed before to be able to extract the alphanumeric string and number. Note how we can now use the <tt>group()</tt> method to access individual subgroups or the <tt>groups()</tt> method to obtain a tuple of all the subgroups matched:</p>
<div class="docText"><pre>&gt;&gt;&gt; m = re.match('(\w\w\w)-(\d\d\d)', 'abc-123')
&gt;&gt;&gt; m.group()                      # entire match
'abc-123'
&gt;&gt;&gt; m.group(1)                     # subgroup 1
'abc'
&gt;&gt;&gt; m.group(2)                     # subgroup 2
'123'
&gt;&gt;&gt; m.groups()                     # all subgroups
('abc', '123')</pre></div><br>
<p class="docText">As you can see, <tt>group()</tt> is used in the normal way to show the entire match, but can also be used to grab individual subgroup matches. We can also use the <tt>groups()</tt> method to obtain a tuple of all the substring matches.</p>
<p class="docText">Here is a simpler example showing different group permutations, which will hopefully make things even more clear:</p>
<div class="docText"><pre>&gt;&gt;&gt; m = re.match('ab', 'ab')       # no subgroups
&gt;&gt;&gt; m.group()                      # entire match
'ab'
&gt;&gt;&gt; m.groups()                     # all subgroups
()
&gt;&gt;&gt;
&gt;&gt;&gt; m = re.match('(ab)', 'ab')     # one subgroup
&gt;&gt;&gt; m.group()                      # entire match
'ab'
&gt;&gt;&gt; m.group(1)                     # subgroup 1
'ab'
&gt;&gt;&gt; m.groups()                     # all subgroups
('ab',)
&gt;&gt;&gt;
&gt;&gt;&gt; m = re.match('(a)(b)', 'ab')        # two subgroups
&gt;&gt;&gt; m.group()                      # entire match
'ab'
&gt;&gt;&gt; m.group(1)                     # subgroup 1
'a'
&gt;&gt;&gt; m.group(2)                     # subgroup 2
'b'
&gt;&gt;&gt; m.groups()                     # all subgroups

('a', 'b')
&gt;&gt;&gt;
&gt;&gt;&gt; m = re.match('(a(b))', 'ab')         # two subgroups
&gt;&gt;&gt; m.group()                      # entire match
'ab'
&gt;&gt;&gt; m.group(1)                     # subgroup 1
'ab'
&gt;&gt;&gt; m.group(2)                     # subgroup 2
'b'
&gt;&gt;&gt; m.groups()                     # all subgroups
('ab', 'b')</pre></div><br>

<a name="ch15lev2sec19"></a>
<h4 id="title-IDATO3SF" class="docSection2Title">15.3.10. Matching from the Beginning and End of Strings and on Word Boundaries</h4>
<p class="docText"><a name="iddle2812"></a><a name="iddle2814"></a><a name="iddle3599"></a><a name="iddle3621"></a><a name="iddle4013"></a><a name="iddle4037"></a><a name="iddle4524"></a>The following examples highlight the positional RE operators. These apply more for searching than matching because <tt>match()</tt> always starts at the beginning of a string.</p>
<div class="docText"><pre>&gt;&gt;&gt; m = re.search('^The', 'The end.')      # match
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
'The'
&gt;&gt;&gt; m = re.search('^The', 'end. The')         # not at beginning
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
&gt;&gt;&gt; m = re.search(r'\bthe', 'bite the dog') # at a boundary
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
'the'
&gt;&gt;&gt; m = re.search(r'\bthe', 'bitethe dog')  # no boundary
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
&gt;&gt;&gt; m = re.search(r'\Bthe', 'bitethe dog')  # no boundary

&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
'the'</pre></div><br>
<p class="docText">You will notice the appearance of raw strings here. You may want to take a look at the Core Note toward the end of the chapter for clarification on why they are here. In general, it is a good idea to use raw strings with regular expressions.</p>
<p class="docText">There are four other <tt>re</tt> module functions and regex object methods we think you should be aware of: <tt>findall(), sub(), subn(),</tt> and <tt>split()</tt>.</p>

<a name="ch15lev2sec20"></a>

<H4 id="title-IDASS3SF" class="docSection2Title">15.3.11. Finding Every Occurrence with <tt>findall()</tt></h4>
<p class="docText"><a name="iddle2043"></a><a name="iddle3589"></a><a name="iddle3613"></a><a name="iddle3620"></a><a name="iddle4069"></a><a name="iddle4077"></a><tt>findall()</tt> is new to Python as of version 1.5.2. It looks for all non-overlapping occurrences of an RE pattern in a string. It is similar to <tt>search()</tt> in that it performs a string search, but it differs from <tt>match()</tt> and <tt>search()</tt> in that <tt>findall()</tt> always returns a list. The list will be empty if no occurrences are found but if successful, the list will consist of all matches found (grouped in left-to-right order of occurrence).</P>
<div class="docText"><pre>&gt;&gt;&gt; re.findall('car', 'car')
['car']
&gt;&gt;&gt; re.findall('car', 'scary')
['car']
&gt;&gt;&gt; re.findall('car', 'carry the barcardi to the car')
['car', 'car', 'car']</pre></div><br>
<p class="docText"><span class="docEmphasis">Subgroup</span> searches result in a more complex list returned, and that makes sense, because subgroups are a mechanism that allow you to extract specific patterns from within your single regular expression, such as matching an area code that is part of a complete telephone number, or a login name that is part of an entire e-mail address.</P>
<p class="docText">For a single successful match, each subgroup match is a single element of the resulting list returned by <tt>findall()</tt>; for multiple successful matches, each subgroup match is a single element in a tuple, and such tuples (one for each successful match) are the elements of the resulting list. This part may sound confusing at first, but if you try different examples, it will help clarify things.</p>

<a name="ch15lev2sec21"></a>
<H4 id="title-IDAHV3SF" class="docSection2Title">15.3.12. Searching and Replacing with <tt>sub()</tt> [and <tt>subn()</tt>]</h4>
<p class="docText">There are two functions/methods for search-and-replace functionality: <tt>sub()</tt> and <tt>subn()</tt>. They are almost identical and replace all matched occurrences of the RE pattern in a string with some sort of replacement. The replacement is usually a string, but it can also be a function that returns a replacement string. <tt>subn()</tt> is exactly the same as <tt>sub()</tt>, but it also returns the total number of substitutions madeboth the newly substituted string and the substitution count are returned as a 2-tuple.</P>
<div class="docText"><pre>&gt;&gt;&gt; re.sub('X', 'Mr. Smith', 'attn: X\n\nDear X,\n')
'attn: Mr. Smith\012\012Dear Mr. Smith,\012'
&gt;&gt;&gt;
&gt;&gt;&gt; re.subn('X', 'Mr. Smith', 'attn: X\n\nDear X,\n')

('attn: Mr. Smith\012\012Dear Mr. Smith,\012', 2)
&gt;&gt;&gt;
&gt;&gt;&gt; print re.sub('X', 'Mr. Smith', 'attn: X\n\nDear X,\n')
attn: Mr. Smith

Dear Mr. Smith,

&gt;&gt;&gt; re.sub('[ae]', 'X', 'abcdef')
'XbcdXf'
&gt;&gt;&gt; re.subn('[ae]', 'X', 'abcdef')
('XbcdXf', 2)</pre></div><BR>

<a name="ch15lev2sec22"></a>
<H4 id="title-IDAKW3SF" class="docSection2Title">15.3.13. Splitting (on Delimiting Pattern) with <tt>split()</tt></H4>
<p class="docText"><a name="iddle3618"></a><a name="iddle3895"></a>The <tt>re</tt> module and RE object method <tt>split()</tt> work similarly to its string counterpart, but rather than splitting on a fixed string, they split a string based on an RE pattern, adding some significant power to string splitting capabilities. If you do not want the string split for every occurrence of the pattern, you can specify the maximum number of splits by setting a value (other than zero) to the <tt>max</tt> argument.</p>
<p class="docText">If the delimiter given is not a regular expression that uses special symbols to match multiple patterns, then <tt>re.split()</tt> works in exactly the same manner as <tt>string.split()</tt>, as illustrated in the example below (which splits on a single colon):</p>
<div class="docText"><pre>&gt;&gt;&gt; re.split(':', 'str1:str2:str3')
['str1', 'str2', 'str3']</pre></div><br>
<p class="docText">But with regular expressions involved, we have an even more powerful tool. Take, for example, the output from the Unix <tt>who</tt> command, which lists all the users logged into a system:</P>
<div class="docText"><pre>% who
wesc      console      Jun 20 20:33
wesc      pts/9        Jun 22 01:38    (192.168.0.6)
wesc      pts/1        Jun 20 20:33    (:0.0)
wesc      pts/2        Jun 20 20:33    (:0.0)
wesc      pts/4        Jun 20 20:33    (:0.0)
wesc      pts/3        Jun 20 20:33    (:0.0)
wesc      pts/5        Jun 20 20:33    (:0.0)
wesc      pts/6        Jun 20 20:33    (:0.0)
wesc      pts/7        Jun 20 20:33    (:0.0)
wesc      pts/8        Jun 20 20:33    (:0.0)</pre></div><br>
<p class="docText">Perhaps we want to save some user login information such as login name, teletype they logged in at, when they logged in, and from where. Using <tt>string.split()</tt> on the above would not be effective, since the spacing is erratic and inconsistent. The other problem is that there is a space between the month, day, and time for the login timestamps. We would probably want to keep these fields together.</P>
<p class="docText">You need some way to describe a pattern such as, &quot;split on two or more spaces.&quot; This is easily done with regular expressions. In no time, we whip up the RE pattern &quot;<tt>\s\s+,</tt>&quot; which does mean at least two whitespace characters. Let's create a program called <tt>rewho.py</tt> that reads the output of the <tt>who</tt> command, presumably saved into a file called <tt>whodata.txt</tt>. Our <tt>rewho.py</tt> script initially looks something like this:</p>
<div class="docText"><pre><span class="docEmphStrong">import</span> re
f = open('whodata.txt', 'r')
<span class="docEmphStrong">for</span> eachLine <span class="docEmphStrong">in</span> f.readlines():
         <span class="docEmphStrong">print</span> re.split('\s\s+', eachLine)
f.close()</pre></div><BR>
<p class="docText">We will now execute the <tt>who</tt> command, saving the output into <tt>whodata.txt</tt>, and then call <tt>rewho.py</tt> and take a look at the results:</p>
<div class="docText"><pre>% who &gt; whodata.txt
% rewho.py
['wesc', 'console', 'Jun 20 20:33\012']
['wesc', 'pts/9', 'Jun 22 01:38\011(192.168.0.6)\012']
['wesc', 'pts/1', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/2', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/4', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/3', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/5', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/6', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/7', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/8', 'Jun 20 20:33\011(:0.0)\012']</pre></div><BR>
<p class="docText">It was a good first try, but not quite correct. For one thing, we did not anticipate a single TAB (ASCII <tt>\011</tt>) as part of the output (which looked like at least two spaces, right?), and perhaps we aren't really keen on saving the NEWLINE (ASCII <tt>\012</tt>), which terminates each line. We are now going to fix those problems as well as improve the overall quality of our application by making a few more changes.</P>
<p class="docText">First, we would rather run the <tt>who</tt> command from within the script, instead of doing it externally and saving the output to a <tt>whodata.txt</tt> filedoing this repeatedly gets tiring rather quickly. To accomplish invoking another program from within ours, we call upon the <tt>os.popen()</tt> command, discussed briefly in <a class="docLink" href="ch14lev1sec5.html#ch14lev2sec15">Section 14.5.2</a>. Although <tt>os.popen()</tt> is available only <a name="iddle4359"></a><a name="iddle4506"></a>on Unix systems, the point is to illustrate the functionality of <tt>re.split()</tt>, which is available on all platforms.</p>
<p class="docText">We get rid of the trailing NEWLINEs and add the detection of a single TAB as an additional, alternative <tt>re.split()</tt> delimiter. Presented in <a class="docLink" href="#ch15list01">Example 15.1</a> is the final version of our <tt>rewho.py</tt> script:</p>
<a name="ch15list01"></a><h5 id="title-IDA113SF" class="docExampleTitle">Example 15.1. Split Output of Unix <tt>who</tt> Command (<tt>rewho.py</tt>)</h5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>


<p class="docText"><span class="docEmphasis">This script calls the <span class="docEmphRoman">who</span> command and parses the input by splitting up its data along various types of whitespace characters.</span></P>

<pre>1  #!/usr/bin/env python
2
3  <span class="docEmphStrong">from</span> os <span class="docEmphStrong">import</span> popen
4  <span class="docEmphStrong">from</span> re <span class="docEmphStrong">import</span> split
5
6  f = popen('who', 'r')
7  <span class="docEmphStrong">for</span> eachLine <span class="docEmphStrong">in</span> f.readlines():
8    <span class="docEmphStrong">print</span> split('\s\s+|\t', eachLine.strip())
9  f.close()</pre><br>

</td></tr></table></P>
<p class="docText">Running this script, we now get the following (correct) output:</P>
<div class="docText"><pre>% rewho.py
['wesc', 'console', 'Jun 20 20:33']
['wesc', 'pts/9', 'Jun 22 01:38', '(192.168.0.6)']
['wesc', 'pts/1', 'Jun 20 20:33', '(:0.0)']
['wesc', 'pts/2', 'Jun 20 20:33', '(:0.0)']
['wesc', 'pts/4', 'Jun 20 20:33', '(:0.0)']
['wesc', 'pts/3', 'Jun 20 20:33', '(:0.0)']
['wesc', 'pts/5', 'Jun 20 20:33', '(:0.0)']
['wesc', 'pts/6', 'Jun 20 20:33', '(:0.0)']
['wesc', 'pts/7', 'Jun 20 20:33', '(:0.0)']
['wesc', 'pts/8', 'Jun 20 20:33', '(:0.0)']</pre></div><br>
<p class="docText">A similar exercise can be achieved in a DOS/Windows environment using the <tt>dir</tt> command in place of <tt>who</tt>.</p>
<p class="docText">While the subject of ASCII characters is still warm, we would like to note that there can be confusion between regular expression special characters and special ASCII symbols. We may use <tt>\n</tt> to represent an ASCII NEWLINE character, but we may use <tt>\d</tt> meaning a regular expression match of a single numeric digit. Problems may occur if there is a symbol used by both ASCII and regular expressions, so in the Core Note on the following page, we recommend the use of Python raw strings to prevent any problems. One more caution: the &quot;<tt>\w</tt>&quot; and &quot;<tt>\W</tt>&quot; alphanumeric character sets are affected by <a name="iddle1123"></a><a name="iddle1331"></a><a name="iddle3540"></a><a name="iddle3583"></a><a name="iddle3588"></a><a name="iddle3605"></a><a name="iddle4031"></a>the <tt>L</tt> or <tt>LOCALE</tt> compilation flag and in Python 1.6 and newer, by Unicode flags starting in 2.0 (<tt>U</tt> or <tt>UNICODE</tt>).</p>
<a name="ch15note03"></a><div class="docNote"><p class="docNoteTitle">Core Note: Use of Python raw strings</p><p><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="50" SRC="images/core_note.jpg">


</td><td valign="top"><p class="docText"><span class="docEmphasis">You may have seen the use of raw strings in some of the examples above. Regular expressions were a strong motivation for the advent of raw strings. The reason is because of conflicts between ASCII characters and regular expression special characters. As a special symbol, &quot;<tt>\b</tt>&quot; represents the ASCII character for backspace, but &quot;<tt>\b</tt>&quot; is also a regular expression special symbol, meaning &quot;match&quot; on a word boundary. In order for the RE compiler to see the two characters &quot;<tt>\b</tt>&quot; as your string and not a (single) backspace, you need to escape the backslash in the string by using another backslash, resulting in &quot;<tt>\\b.</tt>&quot;</span></p><p class="docText"><span class="docEmphasis">This can get messy, especially if you have a lot of special characters in your string, adding to the confusion. We were introduced to raw strings back in <a class="docLink" href="ch06.html#ch06">Chapter 6</a>, and they can be (and are often) used to help keep REs looking somewhat manageable. In fact, many Python programmers swear by these and only use raw strings when defining regular expressions.</span></p><p class="docText"><span class="docEmphasis">Here are some examples of differentiating between the backspace &quot;<tt>\b</tt>&quot; and the regular expression &quot;<tt>\b,</tt>&quot; with and without raw strings:</span></p><div class="docText"><pre>&gt;&gt;&gt; m = re.match('\bblow', 'blow')  # backspace, no match
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
&gt;&gt;&gt; m = re.match('\\bblow', 'blow')  # escaped \, now it works
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
'blow'
&gt;&gt;&gt; m = re.match(r'\bblow', 'blow')  # use raw string instead
&gt;&gt;&gt; <span class="docEmphStrong">if</span> m <span class="docEmphStrong">is not</span> None: m.group()
...
'blow'</pre></div><BR><p class="docText"><span class="docEmphasis">You may have recalled that we had no trouble using &quot;<tt>\d</tt>&quot; in our regular expressions without using raw strings. That is because there is no ASCII equivalent special character, so the regular expression compiler already knew you meant a decimal digit.</span></p></TD></tr></table></P></div><br>


<a href="14051536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch15lev1sec2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch15lev1sec4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>