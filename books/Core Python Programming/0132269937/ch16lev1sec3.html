<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 16.3.&nbsp; Network Programming in Python</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch16lev1sec2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch16lev1sec4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a href="14051536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a><a name="ch16lev1sec3"></a>
<h3 id="title-IDAJK0QF" class="docSection1Title">16.3. Network Programming in Python</H3>
<p class="docText">Now that you know all about client/server architecture, sockets, and networking, let us try to bring this concept to Python. The primary module we will be using in this section is the <tt>socket</tt> module. Found within this module is the <tt>socket()</tt> function, which is used to create socket objects. Sockets also have their own set of methods, which enable socket-based network communication.</p>
<a name="ch16lev2sec6"></a>
<H4 id="title-IDAZK0QF" class="docSection2Title">16.3.1. <tt>socket()</tt> Module Function</H4>
<p class="docText">To create a socket, you must use the <tt>socket.socket()</tt> function, which has the general syntax:</P>
<div class="docText"><pre>socket(<span class="docEmphasis">socket_family</span>, <span class="docEmphasis">socket_type</span>, <span class="docEmphasis">protocol</span>=0)</pre></div><BR>
<p class="docText">The <span class="docEmphasis"><tt>socket_family</tt></span> is either AF_UNIX or AF_INET, as explained earlier, and the <span class="docEmphasis"><tt>socket_type</tt></span> is either SOCK_STREAM or SOCK_ DGRAM, also explained earlier. The <span class="docEmphasis"><tt>protocol</tt></span> is usually left out, defaulting to 0.</p>
<p class="docText">So to create a TCP/IP socket, you call <tt>socket.socket()</tt> like this:</p>
<div class="docText"><pre>tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</pre></div><br>
<p class="docText">Likewise, to create a UDP/IP socket you perform:</P>
<div class="docText"><pre>udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</pre></div><br>
<p class="docText">Since there are numerous <tt>socket</tt> module attributes, this is one of the exceptions where using &quot;<span class="docEmphStrong"><tt>from</tt></span> <span class="docEmphasis"><tt>module</tt></span> <span class="docEmphStrong"><tt>import</tt></span> <tt>*</tt>&quot; is somewhat acceptable because of the number of module attributes. If we applied &quot;<span class="docEmphStrong"><tt>from</tt></span> <tt>socket</tt> <span class="docEmphStrong"><tt>import</tt></span> <tt>*</tt>&quot;, we bring the socket attributes into our namespace, but our code is shortened considerably, i.e.,</P>
<div class="docText"><pre>tcpSock = socket(AF_INET, SOCK_STREAM)</pre></div><br>
<p class="docText">Once we have a socket object, all further interaction will occur using that socket object's methods.</P>

<a name="ch16lev2sec7"></a>

<h4 id="title-IDAFO0QF" class="docSection2Title">16.3.2. Socket Object (Built-in) Methods</H4>
<p class="docText"><a name="iddle3864"></a>In <a class="docLink" href="#ch16table01">Table 16.1</a>, we present a list of the most common socket methods. In the next subsection, we will create both TCP and UDP clients and servers, all of which use these methods. Although we are focusing on Internet sockets, these methods have similar meanings when using Unix sockets.</P>
<a name="ch16table01"></a><p><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 16.1. Common Socket Object Methods</h5></caption><colgroup align="left" span="2"><col width="150"><col width="350"></colgroup><thead><tr><th class="thead" scope="col" align="left" valign="top"><p class="docText"><tt>Method</tt></P></th><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphBoldItalic">Description</span></p></th></tr></thead><TR><td class="docTableCell" align="left" valign="top" colspan="2" style="background-color:#DDDDDD"><p class="docText"><span class="docEmphBoldItalic">Server Socket Methods</span></p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>s</tt></span><tt>.bind()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Bind address (hostname, port number pair) to socket</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>s</tt></span><tt>.listen()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Set up and start TCP listener</P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>s</tt></span><tt>.accept()</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Passively accept TCP client connection, waiting until connection arrives (blocking)</P></TD></TR><TR><td class="docTableCell" align="left" valign="top" colspan="2" style="background-color:#DDDDDD"><p class="docText"><span class="docEmphBoldItalic">Client Socket Methods</span></p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>s</tt></span><tt>.connect()</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Actively initiate TCP server connection</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>s</tt></span><tt>.connect_ex()</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Extended version of <tt>connect()</tt> where problems are returned as error codes rather than an exception being thrown</p></TD></tr><tr><td class="docTableCell" align="left" valign="top" colspan="2" style="background-color:#DDDDDD"><p class="docText"><span class="docEmphBoldItalic">General Socket Methods</span></P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>s</tt></span><tt>.recv()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Receive TCP message</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>s</tt></span><tt>.send()</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Transmit TCP message</P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>s</tt></span><tt>.sendall()</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Transmit TCP message completely</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>s</tt></span><tt>.recvfrom()</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Receive UDP message</p></TD></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>s</tt></span><tt>.sendto()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Transmit UDP message</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>s</tt></span><tt>.getpeername()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Remote address connected to socket (TCP)</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>s</tt></span><tt>.getsockname()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Address of current socket</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>s</tt></span><tt>.getsockopt()</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Return value of given socket option</P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>s</tt></span><tt>.setsockopt()</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Set value for given socket option</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>s</tt></span><tt>.close()</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Close socket</p></TD></tr><TR><TD class="docTableCell" align="left" valign="top" colspan="2" style="background-color:#DDDDDD"><p class="docText"><a name="iddle2728"></a><a name="iddle3064"></a><a name="iddle3753"></a><a name="iddle4133"></a><span class="docEmphBoldItalic">Blocking-Oriented Socket Methods</span></p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>s</tt></span><tt>.setblocking()</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Set blocking or non-blocking mode of socket</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>s</tt></span><tt>.settimeout()</tt><sup class="docFootnote"><a class="docLink" href="#ch16tna1">[a]</a></sup></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Set timeout for blocking socket operations</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>s</tt></span><tt>.gettimeout()</tt><sup class="docFootnote"><a class="docLink" href="#ch16tna1">[a]</a></sup></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Get timeout for blocking socket operations</p></TD></tr><TR><td class="docTableCell" align="left" valign="top" colspan="2" style="background-color:#DDDDDD"><p class="docText"><span class="docEmphBoldItalic">File-Oriented Socket Methods</span></P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>s</tt></span><tt>.fileno()</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">File descriptor of socket</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>s</tt></span><tt>.makefile()</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Create a file object associated with socket</p></TD></TR></table></p><br><blockquote><p class="docFootnote"><sup><a name="ch16tna1">[a]</a></sup> New in <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec3">Python 2.3</a>.</p></blockquote>
<a name="ch16note01"></a><div class="docNote"><p class="docNoteTitle">Core Tip: Install clients and servers on different computers to run networked applications</p><P><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="47" SRC="images/core_tip.jpg">


</TD><td valign="top"><p class="docText"><span class="docEmphasis">In our multitude of examples in this chapter, you will often see code and output referring to host &quot;localhost&quot; or see an IP address of 127.0.0.1. Our examples are running the client(s) and server(s) on the same machine. We encourage the reader to change the hostnames and copy the code to different computers as it is much more fun developing and playing around with code that lets machines talk to one another across the network, and to see network programs that really do work!</span></p></td></TR></table></P></div><br>

<a name="ch16lev2sec8"></a>
<h4 id="title-IDAW30QF" class="docSection2Title">16.3.3. Creating a TCP Server</h4>
<p class="docText">We will first present some general pseudocode involved with creating a generic TCP server, then describe in general what is going on. Keep in mind that this is only one way of designing your server. Once you become comfortable with server design, you will be able to modify the pseudocode to operate the way you want it to:</p>
<div class="docText"><pre>      ss = socket()          # create server socket
      ss.bind()              # bind socket to address
      ss.listen()            # listen for connections
      <span class="docEmphasis">inf_loop</span>:              # server infinite loop
           cs = ss.accept()  # accept client connection
    <span class="docEmphasis">comm_loop</span>:               # communication loop
        cs.recv()/cs.send()  # dialog (receive/send)
    cs.close()               # close client socket
ss.close()                   # close server socket # (opt)</pre></div><br>
<p class="docText"><a name="iddle3005"></a><a name="iddle3866"></a><a name="iddle3871"></a><a name="iddle3889"></a><a name="iddle4183"></a>All sockets are created using the <tt>socket.socket()</tt> function. Servers need to &quot;sit on a port&quot; and wait for requests, so they all must &quot;bind&quot; to a local address. Because TCP is a connection-oriented communication system, some infrastructure must be set up before a TCP server can begin operation. In particular, TCP servers must &quot;listen&quot; for (incoming) connections. Once this setup process is complete, a server can start its infinite loop.</p>
<p class="docText">A simple (single-threaded) server will then sit on an <tt>accept()</tt> call waiting for a connection. By default, <tt>accept()</tt> is blocking, meaning that execution is suspended until a connection arrives. Sockets do support a non-blocking mode; refer to the documentation or operating systems textbooks for more details on why and how you would use non-blocking sockets.</p>
<p class="docText">Once a connection is accepted, a separate client socket is returned [by <tt>accept()</tt>] for the upcoming message interchange. Using the new client socket is similar to handing off a customer call to a service representative. When a client eventually does come in, the main switchboard operator takes the incoming call and patches it through, using another line to the right person to handle their needs.</p>
<p class="docText">This frees up the main line, i.e., the original server socket, so that the operator can resume waiting for new calls (client requests) while the customer and the service representative he or she was connected to carry on their own conversation. Likewise, when an incoming request arrives, a new communication port is created to converse directly with that client while the main one is free to accept new client connections.</p>
<a name="ch16note02"></a><div class="docNote"><p class="docNoteTitle">Core Tip: Spawning threads to handle client requests</p><p><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="47" SRC="images/core_tip.jpg">


</td><TD valign="top"><p class="docText"><span class="docEmphasis">We do not implement this in our examples, but it is also fairly common to hand a client request off to a new thread or process to complete the client processing. The</span> <tt>SocketServer</tt> <span class="docEmphasis">module, a high-level socket communication module written on top of</span> <tt>socket</tt>, <span class="docEmphasis">supports both threaded and spawned process handling of client requests. We refer the reader to the documentation to obtain more information about the</span> <tt>SocketServer</tt> <span class="docEmphasis">module as well as the exercises in <a class="docLink" href="ch17.html#ch17">Chapter 17</a>, Multithreaded Programming.</span></p></TD></tr></table></P></div><br>
<p class="docText">Once the temporary socket is created, communication can commence, and both client and server proceed to engage in a dialog of sending and receiving using this new socket until the connection is terminated. This usually happens when one of the parties either closes its connection or sends an empty string to its partner.</P>
<p class="docText">In our code, after a client connection is closed, the server goes back to wait for another client connection. The final line of code, where we close the server socket, is optional. It is never encountered since the server is supposed to run in an infinite loop. We leave this code in our example as a reminder to the reader that calling the <tt>close()</tt> method is recommended when implementing an intelligent exit scheme for the server, for example, a handler that detects some external condition whereby the server should be shut down. In those cases, a <tt>close()</tt> method call is warranted.</P>
<p class="docText">In <a class="docLink" href="#ch16list01">Example 16.1</a>, we present <tt>tsTserv.py</tt>, a TCP server program that takes the data string sent from a client and returns it timestamped (format: &quot;<tt>[timestamp]data</tt>&quot;) back to the client. (&quot;tsTserv&quot; stands for <span class="docEmphasis">t</span>ime<span class="docEmphasis">s</span>tamp <span class="docEmphasis">T</span>CP <span class="docEmphasis">serv</span>er. The other files are named in a similar manner.)</P>
<a name="ch16list01"></a><H5 id="title-IDATC1QF" class="docExampleTitle">Example 16.1. TCP Timestamp Server (<tt>tsTserv.py</tt>)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>


<p class="docText"><span class="docEmphasis">Creates a TCP server that accepts messages from clients and returns them with a timestamp prefix.</span></p>


<pre>        1   #!/usr/bin/env python
        2
        3   <span class="docEmphStrong">from</span> socket <span class="docEmphStrong">import</span> *
        4   <span class="docEmphStrong">from</span> time <span class="docEmphStrong">import</span> ctime
        5
        6   HOST = ''
        7   PORT = 21567
        8   BUFSIZ = 1024
        9   ADDR = (HOST, PORT)
        10
        11  tcpSerSock = socket(AF_INET, SOCK_STREAM)
        12  tcpSerSock.bind(ADDR)
        13  tcpSerSock.listen(5)
        14
        15  <span class="docEmphStrong">while</span> True:
        16      <span class="docEmphStrong">print</span> 'waiting for connection...'
        17      tcpCliSock, addr = tcpSerSock.accept()
        18      <span class="docEmphStrong">print</span> '...connected from:', addr
        19
        20      <span class="docEmphStrong">while</span> True:
        21          data = tcpCliSock.recv(BUFSIZ)
        22          <span class="docEmphStrong">if not</span> data:
        23              <span class="docEmphStrong">break</span>
        24          tcpCliSock.send('[%s] %s' % (
        25              ctime(), data))
        26
        27      tcpCliSock.close()
        28  tcpSerSock.close()</pre><BR>

</td></TR></table></p>
<a name="ch16lev3sec6"></a>

<H5 id="title-IDARE1QF" class="docSection3Title">Line-by-Line Explanation</H5>
<a name="ch16lev4sec1"></a>
<h5 id="title-IDA0E1QF" class="docSection4Title">Lines 14</h5>
<p class="docText"><a name="iddle1415"></a><a name="iddle4130"></a>After the Unix start-up line, we import <tt>time.ctime()</tt> and all the attributes from the <tt>socket</tt> module.</p>

<a name="ch16lev4sec2"></a>
<h5 id="title-IDAZF1QF" class="docSection4Title">Lines 613</H5>
<p class="docText">The <tt>HOST</tt> variable is blank, an indication to the <tt>bind()</tt> method that it can use any address that is available. We also choose an arbitrarily random port number, which does not appear to be used or reserved by the system. For our application, we set the buffer size to 1K. You may vary this size based on your networking capability and application needs. The argument for the <tt>listen()</tt> method is simply a maximum number of incoming connection requests to accept before connections are turned away or refused.</p>
<p class="docText">The TCP server socket (<tt>tcpSerSock</tt>) is allocated on line 11, followed by the calls to bind the socket to the server's address and to start the TCP listener.</p>

<a name="ch16lev4sec3"></a>
<H5 id="title-IDARG1QF" class="docSection4Title">Lines 1528</h5>
<p class="docText">Once we are inside the server's infinite loop, we (passively) wait for a connection. When one comes in, we enter the dialog loop where we wait for the client to send its message. If the message is blank, that means that the client has quit, so we would break from the dialog loop, close the client connection, and go back to wait for another client. If we did get a message from the client, then we format and return the same data but prepended with the current timestamp. The final line is never executed, but is there as a reminder to the reader that a <tt>close()</tt> call should be made if a handler is written to allow for a more graceful exit, as we discussed before.</p>



<a name="ch16lev2sec9"></a>
<h4 id="title-IDACH1QF" class="docSection2Title">16.3.4. Creating a TCP Client</H4>
<p class="docText">Creating a client is much simpler than a server. Similar to our description of the TCP server, we will present the pseudocode with explanations first, then show you the real thing.</P>
<div class="docText"><pre>cs = socket()               # create client socket
cs.connect()                # attempt server connection
<span class="docEmphasis">comm_loop</span>:                  # communication loop
    cs.send()/cs.recv()     # dialog (send/receive)
cs.close()                  # close client socket</pre></div><br>
<p class="docText"><a name="iddle3867"></a>As we noted before, all sockets are created using <tt>socket.socket()</tt>. Once a client has a socket, however, it can immediately make a connection to a server by using the socket's <tt>connect()</tt> method. When the connection has been established, then it can participate in a dialog with the server. Once the client has completed its transaction, it may close its socket, terminating the connection.</p>
<p class="docText">We present the code for <tt>tsTclnt.py</tt> in <a class="docLink" href="#ch16list02">Example 16.2</a>; it connects to the server and prompts the user for line after line of data. The server returns this data timestamped, which is presented to the user by the client code.</p>
<a name="ch16list02"></a><h5 id="title-IDAWI1QF" class="docExampleTitle">Example 16.2. TCP Timestamp Client (<tt>tsTclnt.py</tt>)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>


<p class="docText"><span class="docEmphasis">Creates a TCP client that prompts the user for messages to send to the server, gets them back with a timestamp prefix, and displays the results to the user.</span></p>


<pre>        1   #!/usr/bin/env python
        2
        3   <span class="docEmphStrong">from</span> socket <span class="docEmphStrong">import</span> *
        4
        5   HOST = 'localhost'
        6   PORT = 21567
        7   BUFSIZ = 1024
        8   ADDR = (HOST, PORT)
        9
        10  tcpCliSock = socket(AF_INET, SOCK_STREAM)
        11  tcpCliSock.connect(ADDR)
        12
        13  <span class="docEmphStrong">while</span> True:
        14      data = raw_input('&gt; ')
        15      <span class="docEmphStrong">if not</span> data:
        16          <span class="docEmphStrong">break</span>
        17      tcpCliSock.send(data)
        18      data = tcpCliSock.recv(BUFSIZ)
        19      <span class="docEmphStrong">if not</span> data:
        20          <span class="docEmphStrong">break</span>
        21      <span class="docEmphStrong">print</span> data
        22
        23  tcpCliSock.close()</pre><br>

</td></tr></table></P>
<a name="ch16lev3sec7"></a>
<h5 id="title-IDAKK1QF" class="docSection3Title">Line-by-Line Explanation</H5>
<a name="ch16lev4sec4"></a>
<h5 id="title-IDATK1QF" class="docSection4Title">Lines 13</H5>
<p class="docText">After the Unix startup line, we import all the attributes from the <tt>socket</tt> module.</p>

<a name="ch16lev4sec5"></a>

<H5 id="title-IDAEL1QF" class="docSection4Title">Lines 511</h5>
<p class="docText"><a name="iddle1913"></a><a name="iddle3754"></a><a name="iddle4134"></a>The <tt>HOST</tt> and <tt>PORT</tt> variables refer to the server's hostname and port number. Since we are running our test (in this case) on the same machine, <tt>HOST</tt> contains the local hostname (change it accordingly if you are running your server on a different host). The port number <tt>PORT</tt> should be exactly the same as what you set for your server (otherwise there won't be much communication[!]). We also choose the same buffer size, 1K.</P>
<p class="docText">The TCP client socket (<tt>tcpCliSock</tt>) is allocated on line 10, followed by (an active) call to connect to the server.</P>

<a name="ch16lev4sec6"></a>
<H5 id="title-IDATM1QF" class="docSection4Title">Lines 1323</H5>
<p class="docText">The client also has an infinite loop, but it is not meant to run forever like the server's loop. The client loop will exit on either of two conditions: the user enters no input (lines 14-16), or the server somehow quit and our call to the <tt>recv()</tt> method fails (lines 18-20). Otherwise, in a normal situation, the user enters in some string data, which is sent to the server for processing. The newly timestamped input string is then received and displayed to the screen.</p>



<a name="ch16lev2sec10"></a>
<h4 id="title-IDAEN1QF" class="docSection2Title">16.3.5. Executing Our TCP Server and Client(s)</h4>
<p class="docText">Now let us run the server and client programs to see how they work. Should we run the server first or the client first? Naturally, if we ran the client first, no connection would be possible because there is no server waiting to accept the request. The server is considered a passive partner because it has to establish itself first and passively wait for a connection. A client, on the other hand, is an active partner because it actively initiates a connection. In other words:</P>
<a name="ch16lev3sec8"></a>
<h5 id="title-IDAPN1QF" class="docSection3Title">Start the Server First (Before Any Clients Try to Connect).</H5>
<p class="docText">In our example running of the client and server, we use the same machine, but there is nothing to stop us from using another host for the server. If this is the case, then just change the hostname. (It is rather exciting when you get your first networked application running the server and client from different machines!)</p>
<p class="docText">We now present the corresponding (input and) output from the client program, which exits with a simple RETURN (or Enter key) keystroke with no data entered:</P>
<div class="docText"><pre>    $ tsTclnt.py
    &gt; hi
    [Sat Jun 17 17:27:21 2006] hi
    &gt; spanish inquisition
    [Sat Jun 17 17:27:37 2006] spanish inquisition
    &gt;
    $</pre></div><br>
<p class="docText"><a name="iddle3067"></a><a name="iddle3758"></a><a name="iddle4320"></a>The server's output is mainly diagnostic:</P>
<div class="docText"><pre>    $ tsTserv.py
    waiting for connection...
    ...connected from: ('127.0.0.1', 1040)
    waiting for connection...</pre></div><BR>
<p class="docText">The &quot;... connected from ...&quot; message was received when our client made its connection. The server went back to wait for new clients while we continued receiving &quot;service.&quot; When we exited from the server, we had to break out of it, resulting in an exception. The best way to avoid such an error is to create a more graceful exit, as we have been discussing.</p>
<a name="ch16note03"></a><div class="docNote"><p class="docNoteTitle">Core Tip: Exit gracefully and call server <tt>close()</tt> method</p><p><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="47" SRC="images/core_tip.jpg">


</td><td valign="top"><p class="docText"><span class="docEmphasis">One way to create this &quot;friendly&quot; exit is to put the server's</span> <span class="docEmphStrong"><tt>while</tt></span> <span class="docEmphasis">loop inside the</span> <span class="docEmphStrong"><tt>except</tt></span> <span class="docEmphasis">clause of a</span> <span class="docEmphStrong"><tt>TRy-except</tt></span> <span class="docEmphasis">statement and monitor for</span> <tt>EOFError</tt> <span class="docEmphasis">or</span> <tt>KeyboardInterrupt</tt> <span class="docEmphasis">exceptions. Then in the</span> <span class="docEmphStrong"><tt>except</tt></span> <span class="docEmphasis">clause, you can make a call to close the server's socket.</span></p></td></tr></table></P></div><BR>
<p class="docText">The interesting thing about this simple networked application is that we are not only showing how our data take a round trip from the client to the server and back to the client, but we also use the server as a sort of &quot;time server,&quot; because the timestamp we receive is purely from the server.</p>


<a name="ch16lev2sec11"></a>
<h4 id="title-IDAFR1QF" class="docSection2Title">16.3.6. Creating a UDP Server</h4>
<p class="docText">UDP servers do not require as much setup as TCP servers because they are not connection-oriented. There is virtually no work that needs to be done other than just waiting for incoming connections.</p>
<div class="docText"><pre>ss = socket()                     # create server socket
ss.bind()                         # bind server socket
inf_loop:                         # server infinite loop
    cs = ss.recvfrom()/ss.sendto()# dialog (receive/send)
ss.close()                        # close server socket</pre></div><br>
<p class="docText">As you can see from the pseudocode, there is nothing extra other than the usual create-the-socket and bind it to the local address (host/port pair). The infinite loop consists of receiving a message from a client, returning a timestamped one, then going back to wait for another message. Again, the <tt>close()</tt> call is optional and will not be reached due to the infinite loop, but it serves as a reminder that it should be part of the graceful or intelligent exit scheme we've been mentioning.</p>
<p class="docText"><a name="iddle1598"></a>One other significant different between UDP and TCP servers is that because datagram sockets are connectionless, there is no &quot;handing off&quot; of a client connection to a separate socket for succeeding communication. These servers just accept messages and perhaps reply.</p>
<p class="docText">You will find the code to <tt>tsUserv.py</tt> in <a class="docLink" href="#ch16list03">Example 16.3</a>, a UDP version of the TCP server seen earlier. It accepts a client message and returns it to the client timestamped.</p>
<a name="ch16list03"></a><h5 id="title-IDATS1QF" class="docExampleTitle">Example 16.3. UDP Timestamp Server (<tt>tsUserv.py</tt>)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>


<p class="docText"><span class="docEmphasis">Creates a UDP server that accepts messages from clients and returns them with a timestamp prefix.</span></p>


<pre>        1   #!/usr/bin/env python
        2
        3   <span class="docEmphStrong">from</span> socket <span class="docEmphStrong">import</span> *
        4   <span class="docEmphStrong">from</span> time <span class="docEmphStrong">import</span> ctime
        5
        6   HOST = ''
        7   PORT = 21567
        8   BUFSIZ = 1024
        9   ADDR = (HOST, PORT)
        10
        11  udpSerSock = socket(AF_INET, SOCK_DGRAM)
        12  udpSerSock.bind(ADDR)
        13
        14  <span class="docEmphStrong">while</span> True:
        15      <span class="docEmphStrong">print</span> 'waiting for message...'
        16      data, addr = udpSerSock.recvfrom(BUFSIZ)
        17      udpSerSock.sendto('[%s] %s' % (
        18          ctime(), data), addr)
        19      <span class="docEmphStrong">print</span> '...received from and returned to:', addr
        20
        21  udpSerSock.close()</pre><BR>

</td></TR></table></p>
<a name="ch16lev3sec9"></a>
<H5 id="title-IDADU1QF" class="docSection3Title">Line-by-Line Explanation</h5>
<a name="ch16lev4sec7"></a>
<H5 id="title-IDAMU1QF" class="docSection4Title">Lines 14</H5>
<p class="docText">After the Unix startup line, we import <tt>time.ctime()</tt> and all the attributes from the <tt>socket</tt> module, just like the TCP server setup.</P>

<a name="ch16lev4sec8"></a>
<H5 id="title-IDA3U1QF" class="docSection4Title">Lines 612</h5>
<p class="docText">The <tt>HOST</tt> and <tt>PORT</tt> variables are the same as before, and for all the same reasons. The call <tt>socket()</tt> differs only in that we are now requesting a datagram/UDP socket type, but <tt>bind()</tt> is invoked in the same way as in the <a name="iddle1419"></a><a name="iddle4319"></a><a name="iddle4390"></a>TCP server version. Again, because UDP is connectionless, no call to &quot;<tt>listen()</tt> for incoming connections&quot; is made here.</p>

<a name="ch16lev4sec9"></a>
<h5 id="title-IDARW1QF" class="docSection4Title">Lines 1421</H5>
<p class="docText">Once we are inside the server's infinite loop, we (passively) wait for a message (a datagram). When one comes in, we process it (by adding a timestamp to it), then send it right back and go back to wait for another message. The socket <tt>close()</tt> method is there for show only, as indicated before.</p>



<a name="ch16lev2sec12"></a>
<H4 id="title-IDACX1QF" class="docSection2Title">16.3.7. Creating a UDP Client</h4>
<p class="docText">Of the four highlighted here in this section, the UDP client is the shortest bit of code that we will look at. The pseudocode looks like this:</P>
<div class="docText"><pre>cs = socket()                  # create client socket
<span class="docEmphasis">comm_loop</span>:                # communication loop
    cs.sendto()/cs.recvfrom()    # dialog (send/receive)
cs.close()                     # close client socket</pre></div><br>
<p class="docText">Once a socket object is created, we enter the dialog loop of exchanging messages with the server. When communication is complete, the socket is closed.</P>
<p class="docText">The real client code, <tt>tsUclnt.py</tt>, is presented in <a class="docLink" href="#ch16list04">Example 16.4</a>.</P>
<a name="ch16list04"></a><h5 id="title-IDALY1QF" class="docExampleTitle">Example 16.4. UDP Timestamp Client (<tt>tsUclnt.py</tt>)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>


<p class="docText"><span class="docEmphasis">Creates a UDP client that prompts the user for messages to send to the server, gets them back with a timestamp prefix, and displays them back to the user.</span></p>


<pre>        1   #!/usr/bin/env python
        2
        3   <span class="docEmphStrong">from</span> socket <span class="docEmphStrong">import</span> *
        4
        5   HOST = 'localhost'
        6   PORT = 21567
        7   BUFSIZ = 1024
        8   ADDR = (HOST, PORT)
        9
        10  udpCliSock = socket(AF_INET, SOCK_DGRAM)
        11
        12  <span class="docEmphStrong">while</span> True:
        13      data = raw_input('&gt; ')
        14      <span class="docEmphStrong">if not</span> data:
        15          <span class="docEmphStrong">break</span>
        16      udpCliSock.sendto(data, ADDR)
        17      data, ADDR = udpCliSock.recvfrom(BUFSIZ)
        18      <span class="docEmphStrong">if not</span> data:
        19          <span class="docEmphStrong">break</span>
        20      <span class="docEmphStrong">print</span> dataudpCliSock.close()
        21
        22  udpCliSock.close()</pre><br>

</TD></tr></table></p>
<a name="ch16lev3sec10"></a>
<h5 id="title-IDA5Z1QF" class="docSection3Title">Line-by-Line Explanation</H5>
<a name="ch16lev4sec10"></a>
<H5 id="title-IDAI01QF" class="docSection4Title">Lines 13</h5>
<p class="docText">After the Unix startup line, we import all the attributes from the <tt>socket</tt> module, again, just like in the TCP version of the client.</p>

<a name="ch16lev4sec11"></a>
<h5 id="title-IDAX01QF" class="docSection4Title">Lines 510</h5>
<p class="docText">Because we are running the server on our local machine again, we use &quot;localhost&quot; and the same port number on the client side, not to mention the same 1K buffer. We allocate our socket object in the same way as the UDP server.</p>

<a name="ch16lev4sec12"></a>
<h5 id="title-IDAD11QF" class="docSection4Title">Lines 1222</h5>
<p class="docText">Our UDP client loop works in almost the exact manner as the TCP client. The only difference is that we do not have to establish a connection to the UDP server first; we simply send a message to it and await the reply. After the timestamped string is returned, we display it to the screen and go back for more. When the input is complete, we break out of the loop and close the socket.</p>



<a name="ch16lev2sec13"></a>

<h4 id="title-IDAU11QF" class="docSection2Title">16.3.8. Executing Our UDP Server and Client(s)</h4>
<p class="docText"><a name="iddle1917"></a>The UDP client behaves the same as the TCP client:</p>
<div class="docText"><pre>    $ tsUclnt.py
    &gt; hi
    [Sat Jun 17 19:55:36 2006] hi
    &gt; spam! spam! spam!
    [Sat Jun 17 19:55:40 2006] spam! spam! spam!
    &gt;
    $</pre></div><br>
<p class="docText">Likewise for the server:</P>
<div class="docText"><pre>    $ tsUserv.py
    waiting for message...
    ...received from and returned to: ('127.0.0.1', 1025)
    waiting for message...</pre></div><br>
<p class="docText">In fact, we output the client's information because we can be receiving messages from multiple clients and sending replies, and such output helps by telling us where messages came from. With the TCP server, we know where <a name="iddle1070"></a><a name="iddle1073"></a><a name="iddle1172"></a><a name="iddle3062"></a><a name="iddle3869"></a>messages come from because each client makes a connection. Note how the messages says, &quot;waiting for message&quot; as opposed to &quot;waiting for connection.&quot;</P>

<a name="ch16lev2sec14"></a>
<h4 id="title-IDAA41QF" class="docSection2Title">16.3.9. <tt>socket</tt> Module Attributes</H4>
<p class="docText">In addition to the <tt>socket.socket()</tt> function which we are now familiar with, the <tt>socket</tt> module features many more attributes that are used in network application development. Some of the most popular ones are shown in <a class="docLink" href="#ch16table02">Table 16.2</a>.</p>
<p class="docText">For more information, we refer you to the <tt>socket</tt> Module documentation in the Python Library Reference.</P>
<a name="ch16table02"></a><p><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 16.2. <tt>socket</tt> Module Attributes</H5></caption><colgroup align="left" span="2"><col width="175"><col width="350"></colgroup><thead><TR><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphBoldItalic">Attribute Name</span></P></th><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphBoldItalic">Description</span></p></th></tr></thead><tr><TD class="docTableCell" align="left" valign="top" colspan="2" style="background-color:#DDDDDD"><p class="docText"><span class="docEmphBoldItalic">Data Attributes</span></p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>AF_UNIX, AF_INET, AF_INET6</tt><sup class="docFootnote"><a class="docLink" href="#ch16tna2">[a]</a></sup></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Socket address families supported by Python</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>SO_STREAM, SO_DGRAM</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Socket types (TCP = stream, UDP = datagram)</p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>has_ipv6</tt><sup class="docFootnote"><a class="docLink" href="#ch16tnb1">[b]</a></sup></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Boolean flag indicating whether IPv6 is supported</p></td></tr><tr><td class="docTableCell" align="left" valign="top" colspan="2" style="background-color:#DDDDDD"><p class="docText"><span class="docEmphBoldItalic">Exceptions</span></p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>error</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Socket-related error</p></TD></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>herror</tt><sup class="docFootnote"><a class="docLink" href="#ch16tna2">[a]</a></sup></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Host and address-related error</p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>gaierror</tt><sup class="docFootnote"><a class="docLink" href="#ch16tna2">[a]</a></sup></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Address-related error</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>timeout</tt><sup class="docFootnote"><a class="docLink" href="#ch16tnb1">[b]</a></sup></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Timeout expiration</p></TD></tr><tr><td class="docTableCell" align="left" valign="top" colspan="2" style="background-color:#DDDDDD"><p class="docText"><span class="docEmphBoldItalic">Functions</span></P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>socket()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Create a socket object from the given address family, socket type, and protocol type (optional)</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>socketpair()</tt><sup class="docFootnote"><a class="docLink" href="#ch16tnc1">[c]</a></sup></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Create a pair of socket objects from the given address family, socket type, and protocol type (optional)</P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>fromfd()</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Create a socket object from an open file descriptor</P></TD></tr><tr><td class="docTableCell" align="left" valign="top" colspan="2" style="background-color:#DDDDDD"><p class="docText"><span class="docEmphBoldItalic">Data Attributes</span></P></td><TD class="docTableCell" align="left" valign="top">&nbsp;</td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>ssl()</tt><sup class="docFootnote"><a class="docLink" href="#ch16tnd1">[d]</a></sup></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Initiates a Secure Socket Layer connection over socket; does <span class="docEmphasis">not</span> perform certificate validation</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>getaddrinfo()</tt><sup class="docFootnote"><a class="docLink" href="#ch16tna2">[a]</a></sup></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Gets address information</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>getfqdn()</tt><sup class="docFootnote"><a class="docLink" href="#ch16tne1">[e]</a></sup></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns fully qualified domain name</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>gethostname()</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Returns current hostname</p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>gethostbyname()</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Maps a hostname to its IP address</P></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>gethostbyname_ex()</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Extended version of <tt>gethostbyname()</tt> returning hostname, set of alias hostnames, and list of IP addresses</P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>gethostbyaddr()</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Maps an IP address to DNS info; returns same 3-tuple as <tt>gethostbyname_ex()</tt></p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>getprotobyname()</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Maps a protocol name (e.g. <tt>'tcp'</tt>) to a number</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>getservbyname()/getservbyport()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Maps a service name to a port number or vice-versa; a protocol name is optional for either function</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>ntohl()/ntohs()</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Converts integers from network to host byte order</p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>htonl()/htons()</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Converts integers from host to network byte order</P></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>inet_aton()/inet_ntoa()</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Convert IP address octet string to 32-bit packed format or vice versa (for IPv4 addresses only)</P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>inet_pton()/inet_ntop()</tt><sup class="docFootnote"><a class="docLink" href="#ch16tnb1">[b]</a></sup></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Convert IP address string to packed binary format or vice versa (for both IPv4 and IPv6 addresses)</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>geTDefaulttimeout()/setdefaulttimeout()</tt><sup class="docFootnote"><a class="docLink" href="#ch16tnb1">[b]</a></sup></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Return default socket timeout in seconds (float); set default socket timeout in seconds (float)</P></TD></tr></table></p><br><blockquote><p class="docFootnote"><sup><a name="ch16tna2">[a]</a></sup> New in <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec2">Python 2.2</a>.</p></blockquote><blockquote><p class="docFootnote"><sup><a name="ch16tnb1">[b]</a></sup> New in <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec3">Python 2.3</a>.</p></blockquote><blockquote><p class="docFootnote"><sup><a name="ch16tnc1">[c]</a></sup> New in <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec4">Python 2.4</a>.</p></blockquote><blockquote><p class="docFootnote"><sup><a name="ch16tnd1">[d]</a></sup> New in Python 1.6.</p></blockquote><blockquote><p class="docFootnote"><sup><a name="ch16tne1">[e]</a></sup> New in Python 2.0.</p></blockquote>


<a href="14051536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch16lev1sec2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch16lev1sec4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>