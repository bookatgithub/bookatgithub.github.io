<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 18.5.&nbsp; threading Module</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch18lev1sec4.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch18lev1sec6.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a href="14051536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a><a name="ch18lev1sec5"></a>

<h3 id="title-IDABWD1D" class="docSection1Title">18.5. <tt>tHReading</tt> Module</h3>
<p class="docText"><a name="iddle3004"></a><a name="iddle4161"></a><a name="iddle4166"></a>We will now introduce the higher-level <tt>tHReading</tt> module, which gives you not only a <tt>THRead</tt> class but also a wide variety of synchronization mechanisms to use to your heart's content. <a class="docLink" href="#ch18table02">Table 18.2</a> represents a list of all the objects available in the <tt>tHReading</tt> module.</P>
<a name="ch18table02"></a><p><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 18.2. <tt>threading</tt> Module Objects</H5></caption><colgroup align="left" span="2"><col width="250"><col width="300"></colgroup><thead><tr><th class="thead" scope="col" align="left" valign="top"><p class="docText"><tt>tHReading</tt> <span class="docEmphasis">Module Objects</span></p></th><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Description</span></P></th></tr></thead><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>Thread</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Object that represents a single thread of execution</P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>Lock</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Primitive lock object (same lock object as in the <tt>tHRead</tt> module)</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>RLock</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Re-entrant lock object provides ability for a single thread to (re)acquire an already-held lock (recursive locking)</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>Condition</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Condition variable object causes one thread to wait until a certain &quot;condition&quot; has been satisfied by another thread, such as changing of state or of some data value <tt>Event</tt>General version of condition variables whereby any number of threads are waiting for some event to occur and all will awaken when the event happens</P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>Semaphore</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Provides a &quot;waiting area&quot;-like structure for threads waiting on a lock</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>BoundedSemaphore</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Similar to a <tt>Semaphore</tt> but ensures it never exceeds its initial value</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>Timer</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Similar to <tt>Thread</tt> except that it waits for an allotted period of time before running</p></TD></tr></table></p><br>
<p class="docText">In this section, we will examine how to use the <tt>THRead</tt> class to implement threading. Since we have already covered the basics of locking, we will not cover the locking primitives here. The <tt>THRead()</tt> class also contains a form of synchronization, so explicit use of locking primitives is not necessary.</p>
<a name="ch18note02"></a><div class="docNote"><p class="docNoteTitle">Core Tip: Daemon threads</p><p><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="47" SRC="images/core_tip.jpg">


</td><td valign="top"><p class="docText"><a name="iddle1561"></a><a name="iddle4163"></a><a name="iddle4170"></a><a name="iddle4172"></a><span class="docEmphasis">Another reason to avoid using the <tt>thread</tt> module is that it does not support the concept of daemon (or daemonic) threads. When the main thread exits, all child threads will be killed regardless of whether they are doing work. The concept of daemon threads comes into play here if you do not want this behavior.</span></p><p class="docText"><span class="docEmphasis">Support for daemon threads is available in the <tt>threading</tt> module, and here is how they work: a daemon is typically a server that waits for client requests to service. If there is no client work to be done, the daemon just sits around idle. If you set the daemon flag for a thread, you are basically saying that it is non-critical, and it is okay for the process to exit without waiting for it to &quot;finish.&quot; As you have seen in <a class="docLink" href="ch16.html#ch16">Chapter 16</a>, &quot;<a class="docLink" href="ch16.html#ch16">Network Programming</a>&quot; server threads run in an infinite loop and do not exit in normal situations.</span></p><p class="docText"><span class="docEmphasis">If your main thread is ready to exit and you do not care to wait for the child threads to finish, then set their daemon flag. Think of setting this flag as denoting a thread to be &quot;not important.&quot; You do this by calling each thread's <tt>setDaemon()</tt> method, e.g., <tt>thread.setDae-mon(True)</tt>, before it begins running (<tt>tHRead.start()</tt>.)</span></p><p class="docText"><span class="docEmphasis">If you want to wait for child threads to finish, just leave them as-is, or ensure that their daemon flags are off by explicitly calling <tt>tHRead.setDaemon (False)</tt> before starting them. You can check a thread's daemonic status with <tt>thread.isDaemon()</tt>. A new child thread inherits its daemonic flag from its parent. The entire Python program will stay alive until all non-daemonic threads have exited, in other words, when no active non-daemonic threads are left).</span></P></td></TR></table></p></div><BR>
<a name="ch18lev2sec9"></a>
<H4 id="title-IDAM5D1D" class="docSection2Title">18.5.1. Thread Class</H4>
<p class="docText">The <tt>THRead</tt> class of the <tt>threading</tt> is your primary executive object. It has a variety of functions not available to the <tt>thread</tt> module, and are outlined in <a class="docLink" href="#ch18table03">Table 18.3</a>.</p>
<a name="ch18table03"></a><P><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 18.3. Thread Object Methods</H5></caption><colgroup align="left" span="2"><col width="150"><col width="325"></colgroup><thead><tr><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Method</span></P></th><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Description</span></p></th></TR></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>start()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Begin thread execution</P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>run()</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Method defining thread functionality (usually overridden by application writer in a subclass)</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>join(</tt><span class="docEmphasis"><tt>timeout</tt></span> <tt>= None)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Suspend until the started thread terminates; blocks unless <span class="docEmphasis"><tt>timeout</tt></span> (in seconds) is given</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>getName()</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Return name of thread</p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>setName</tt><span class="docEmphasis"><tt>(name)</tt></span></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Set name of thread</P></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>isAlive()</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Boolean flag indicating whether thread is still running</P></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>isDaemon()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Return daemon flag of thread</P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>setDaemon</tt><span class="docEmphasis"><tt>(daemonic)</tt></span></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Set the daemon flag of thread as per the Boolean <span class="docEmphasis"><tt>daemonic</tt></span> (must be called before thread <tt>start()</tt>ed)</P></td></tr></table></p><br>
<p class="docText">There are a variety of ways you can create threads using the <tt>Thread</tt> class. We cover three of them here, all quite similar. Pick the one you feel most comfortable with, not to mention the most appropriate for your application and future scalability (we like the final choice the best):</p>
<ul><li><p class="docList">Create <tt>Thread</tt> instance, passing in function</p></li><li><p class="docList">Create <tt>THRead</tt> instance, passing in callable class instance</p></LI><li><p class="docList">Subclass <tt>THRead</tt> and create subclass instance</p></LI></ul>
<a name="ch18lev3sec4"></a>

<H5 id="title-IDAKGE1D" class="docSection3Title">Create <tt>THRead</tt> Instance, Passing in Function</H5>
<p class="docText"><a name="iddle2481"></a><a name="iddle4164"></a><a name="iddle4174"></a><a name="iddle4181"></a>In our first example, we will just instantiate <tt>THRead</tt>, passing in our function (and its arguments) in a manner similar to our previous examples. This function is what will be executed when we direct the thread to begin execution. Taking our <tt>mtsleep2.py</tt> script and tweaking it, adding the use of <tt>Thread</tt> objects, we have <tt>mtsleep3.py</tt>, shown in <a class="docLink" href="#ch18list04">Example 18.4</a>.</p>
<a name="ch18list04"></a><h5 id="title-IDALIE1D" class="docExampleTitle">Example 18.4. Using the <tt>tHReading</tt> Module (<tt>mtsleep3.py</tt>)</h5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>


<p class="docText"><span class="docEmphasis">The Thread class from the threading module has a join() method that lets the main thread wait for thread completion.</span></p>

<pre>1     #!/usr/bin/env python
2
3     <span class="docEmphStrong">import</span> threading
4     <span class="docEmphStrong">from</span> time <span class="docEmphStrong">import</span> sleep, ctime
5
6     loops = [4,2]
7
8     <span class="docEmphStrong">def</span> loop(nloop, nsec):
9         <span class="docEmphStrong">print</span> 'start loop', nloop, 'at:', ctime()
10        sleep(nsec)
11        <span class="docEmphStrong">print</span> 'loop', nloop, 'done at:', ctime()
12
13    <span class="docEmphStrong">def</span> main():
14        <span class="docEmphStrong">print</span> 'starting at:', ctime()
15        threads = []
16        nloops = range(len(loops))
17
18       <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span> nloops:
19           t = threading.Thread(target=loop,
20               args=(i, loops[i]))
21           threads.append(t)
22
23       <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span> nloops:           # start threads
24           threads[i].start()
25
26       <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span> nloops:           # wait for all
27           threads[i].join()      # threads to finish
28
29       <span class="docEmphStrong">print</span> 'all DONE at:', ctime()
30
31    <span class="docEmphStrong">if</span> __name__ == '__main__':
32        main()</pre><BR>

</TD></tr></table></p>
<p class="docText">When we run it, we see output similar to its predecessors' output:</p>
<div class="docText"><pre>$ mtsleep3.py
starting at: Sun Aug 13 18:16:38 2006
start loop 0 at: Sun Aug 13 18:16:38 2006
start loop 1 at: Sun Aug 13 18:16:38 2006
loop 1 done at: Sun Aug 13 18:16:40 2006
loop 0 done at: Sun Aug 13 18:16:42 2006
all DONE at: Sun Aug 13 18:16:42 2006</pre></div><br>
<p class="docText">So what <span class="docEmphasis">did</span> change? Gone are the locks that we had to implement when using the <tt>tHRead</tt> module. Instead, we create a set of <tt>Thread</tt> objects. When each <tt>Thread</tt> is instantiated, we dutifully pass in the function (<tt>target</tt>) and arguments (<tt>args</tt>) and receive a <tt>THRead</tt> instance in return. The biggest <a name="iddle1276"></a><a name="iddle3837"></a><a name="iddle4180"></a>difference between instantiating <tt>Thread</tt> [calling <tt>Thread()</tt>] and invoking <tt>thread.start_new_thread()</tt> is that the new thread does not begin execution right away. This is a useful synchronization feature, especially when you don't want the threads to start immediately.</P>
<p class="docText">Once all the threads have been allocated, we let them go off to the races by invoking each thread's <tt>start()</tt> method, but not a moment before that. And rather than having to manage a set of locks (allocating, acquiring, releasing, checking lock state, etc.), we simply call the <tt>join()</tt> method for each thread. <tt>join()</tt> will wait until a thread terminates, or, if provided, a timeout occurs. Use of <tt>join()</tt> appears much cleaner than an infinite loop waiting for locks to be released (causing these locks to sometimes be known as &quot;spin locks&quot;).</P>
<p class="docText">One other important aspect of <tt>join()</tt> is that it does not need to be called at all. Once threads are started, they will execute until their given function completes, whereby they will exit. If your main thread has things to do other than wait for threads to complete (such as other processing or waiting for new client requests), it should by all means do so. <tt>join()</tt> is useful only when you <span class="docEmphasis">want</span> to wait for thread completion.</p>

<a name="ch18lev3sec5"></a>
<h5 id="title-IDALNE1D" class="docSection3Title">Create <tt>Thread</tt> Instance, Passing in Callable Class Instance</h5>
<p class="docText">A similar offshoot to passing in a function when creating a thread is to have a callable class and passing in an instance for executionthis is the more OO approach to MT programming. Such a callable class embodies an execution environment that is much more flexible than a function or choosing from a set of functions. You now have the power of a class object behind you, as opposed to a single function or a list/tuple of functions.</p>
<p class="docText">Adding our new class <tt>ThreadFunc</tt> to the code and making other slight modifications to <tt>mtsleep3.py</tt>, we get <tt>mtsleep4.py</tt>, given in <a class="docLink" href="#ch18list05">Example 18.5</a>.</p>
<a name="ch18list05"></a><h5 id="title-IDALOE1D" class="docExampleTitle">Example 18.5. <a name="iddle4072"></a>Using Callable classes (<tt>mtsleep4.py</tt>)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>


<p class="docText"><span class="docEmphasis">In this example we pass in a callable class (instance) as opposed to just a function. It presents more of an OO approach than mtsleep3.py.</span></P>

<pre>1     #!/usr/bin/env python
2
3     <span class="docEmphStrong">import</span> threading
4     <span class="docEmphStrong">from</span> time <span class="docEmphStrong">import</span> sleep, ctime
5
6     loops = [4,2]
7
8     <span class="docEmphStrong">class</span> ThreadFunc(object):
9
10        <span class="docEmphStrong">def</span> __init__(self, func, args, name=''):
11            self.name = name
12            self.func = func
13            self.args = args
14
15        <span class="docEmphStrong">def</span> __call__(self):
16            apply(self.func, self.args)
17
18    <span class="docEmphStrong">def</span> loop(nloop, nsec):
19        <span class="docEmphStrong">print</span> 'start loop', nloop, 'at:', ctime()
20        sleep(nsec)
21        <span class="docEmphStrong">print</span> 'loop', nloop, 'done at:', ctime()
22
23    <span class="docEmphStrong">def</span> main():
24        <span class="docEmphStrong">print</span> 'starting at:', ctime()
25        threads = []
26        nloops = range(len(loops))
27
28        <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span> nloops: # create all threads
29            t = threading.Thread(
30                target=ThreadFunc(loop, (i, loops[i]),
31                loop.__name__))
32            threads.append(t)
33
34        <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span> nloops: # start all threads
35            threads[i].start()
36
37        <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span> nloops: # wait for completion
38            threads[i].join()
39
40        <span class="docEmphStrong">print</span> 'all DONE at:', ctime()
41
42    <span class="docEmphStrong">if</span> __name__ == '__main__':
43        main()</pre><br>

</TD></tr></table></P>
<p class="docText">If we run <tt>mtsleep4.py</tt>, we get the expected output:</p>
<div class="docText"><pre>$ mtsleep4.py
starting at: Sun Aug 13 18:49:17 2006
start loop 0 at: Sun Aug 13 18:49:17 2006
start loop 1 at: Sun Aug 13 18:49:17 2006
loop 1 done at: Sun Aug 13 18:49:19 2006
loop 0 done at: Sun Aug 13 18:49:21 2006
all DONE at: Sun Aug 13 18:49:21 2006</pre></div><BR>
<p class="docText">So what are the changes this time? The addition of the <tt>ThreadFunc</tt> class and a minor change to instantiate the <tt>THRead</tt> object, which also instantiates <tt>THReadFunc</tt>, our callable class. In effect, we have a double instantiation going on here. Let's take a closer look at our <tt>THReadFunc</tt> class.</P>
<p class="docText">We want to make this class general enough to use with functions other than our <tt>loop()</tt> function, so we added some new infrastructure, such as having this class hold the arguments for the function, the function itself, and also a function name string. The constructor <tt>__init__()</tt> just sets all the values.</p>
<p class="docText">When the <tt>Thread</tt> code calls our <tt>ThreadFunc</tt>object when a new thread is created, it will invoke the <tt>__call__()</tt> special method. Because we already have our set of arguments, we do not need to pass it to the <tt>THRead()</tt> constructor, but do have to use <tt>apply()</tt> in our code now because we have an argument tuple. Those of you who have Python 1.6 and higher can use the new function invocation syntax described in <a class="docLink" href="ch11lev1sec6.html#ch11lev2sec17">Section 11.6.3</a> instead of using <tt>apply()</tt> on line 16:</p>
<div class="docText"><pre>self.res = self.func(*self.args)</pre></div><BR>

<a name="ch18lev3sec6"></a>
<h5 id="title-IDAVTE1D" class="docSection3Title">Subclass <tt>THRead</tt> and Create Subclass Instance</h5>
<p class="docText">The final introductory example involves subclassing <tt>THRead()</tt>, which turns out to be extremely similar to creating a callable class as in the previous example. Subclassing is a bit easier to read when you are creating your threads (lines 29-30). We will present the code for <tt>mtsleep5.py</tt> in <a class="docLink" href="#ch18list06">Example 18.6</a> as well as the output obtained from its execution, and leave it as an exercise for the reader to compare <tt>mtsleep5.py</tt> to <tt>mtsleep4.py</tt>.</P>
<a name="ch18list06"></a><h5 id="title-IDAVUE1D" class="docExampleTitle">Example 18.6. <a name="iddle1951"></a><a name="iddle1970"></a><a name="iddle4088"></a><a name="iddle4165"></a>Subclassing <tt>Thread</tt> (<tt>mtsleep5.py</tt>)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>


<p class="docText"><span class="docEmphasis">Rather than instantiating the Thread class, we subclass it. This gives us more flexibility in customizing our threading objects and simplifies the thread creation call.</span></p>

<pre>1     #!/usr/bin/env python
2
3     <span class="docEmphStrong">import</span> threading
4     <span class="docEmphStrong">from</span> time <span class="docEmphStrong">import</span> sleep, ctime
5
6     loops = (4, 2)
7
8     <span class="docEmphStrong">class</span> MyThread(threading.Thread):
9         <span class="docEmphStrong">def</span> __init__(self, func, args, name=''):
10            threading.Thread.__init__(self)
11            self.name = name
12            self.func = func
13            self.args = args
14
15        <span class="docEmphStrong">def</span> run(self):
16            apply(self.func, self.args)
17
18    <span class="docEmphStrong">def</span> loop(nloop, nsec):
19        <span class="docEmphStrong">print</span> 'start loop', nloop, 'at:', ctime()
20        sleep(nsec)
21        <span class="docEmphStrong">print</span> 'loop', nloop, 'done at:', ctime()
22
23    <span class="docEmphStrong">def</span> main():
24        <span class="docEmphStrong">print</span> 'starting at:', ctime()
25        threads = []
26        nloops = range(len(loops))
27
28        <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span> nloops:
29            t = MyThread(loop, (i, loops[i]),
30                loop.__name__)
31            threads.append(t)
32
33        <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span> nloops:
34            threads[i].start()
35
36        <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span> nloops:
37            threads[i].join()
38
39        <span class="docEmphStrong">print</span> 'all DONE at:', ctime()'
40
41    <span class="docEmphStrong">if</span> __name__ == '__main__':
42        main()</pre><BR>

</td></tr></table></p>
<p class="docText">Here is the output for <tt>mtsleep5.py</tt>, again, just what we expected:</P>
<div class="docText"><pre>$ mtsleep5.py
starting at: Sun Aug 13 19:14:26 2006
start loop 0 at: Sun Aug 13 19:14:26 2006
start loop 1 at: Sun Aug 13 19:14:26 2006
loop 1 done at: Sun Aug 13 19:14:28 2006
loop 0 done at: Sun Aug 13 19:14:30 2006
all DONE at: Sun Aug 13 19:14:30 2006</pre></div><BR>
<p class="docText">While the reader compares the source between the <tt>mtsleep4</tt> and <tt>mtsleep5</tt> modules, we want to point out the most significant changes: (1) our <tt>MyThread</tt> subclass constructor must first invoke the base class constructor (line 9), and (2) the former special method <tt>__call__()</tt> must be called <tt>run()</tt> in the subclass.</p>
<p class="docText">We now modify our <tt>MyThread</tt> class with some diagnostic output and store it in a separate module called <tt>myThread</tt> (see <a class="docLink" href="#ch18list07">Example 18.7</a>) and import this class for the upcoming examples. Rather than simply calling <tt>apply()</tt> to run our functions, we also save the result to instance attribute <tt>self.res</tt>, and create a new method to retrieve that value, <tt>getresult()</tt>.</p>
<a name="ch18list07"></a><h5 id="title-IDAC0E1D" class="docExampleTitle">Example 18.7. <tt>MyThread</tt> Subclass of Thread (<tt>myThread.py</tt>)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>


<p class="docText"><span class="docEmphasis">To generalize our subclass of <span class="docEmphRoman">Thread</span> from <span class="docEmphRoman">mtsleep5.py</span>, we move the subclass to a separate module and add a <span class="docEmphRoman">getResult()</span> method for callables that produce return values.</span></p>

<pre>1   #!/usr/bin/env python
2
3   <span class="docEmphStrong">import</span> threading
4   <span class="docEmphStrong">from</span> time <span class="docEmphStrong">import</span> ctime
5
6   <span class="docEmphStrong">class</span> MyThread(threading.Thread):
7       <span class="docEmphStrong">def</span> __init__(self, func, args, name=''):
8             threading.Thread.__init__(self)
9             self.name = name
10            self.func = func
11            self.args = args
12
13       <span class="docEmphStrong">def</span> getResult(self):
14           <span class="docEmphStrong">return</span> self.res
15
16       <span class="docEmphStrong">def</span> run(self):
17           <span class="docEmphStrong">print</span> 'starting', self.name, 'at:', \
18               ctime()
19            self.res = apply(self.func, self.args)
20           <span class="docEmphStrong">print</span> self.name, 'finished at:', \
21               ctime()</pre><BR>

</td></TR></table></p>


<a name="ch18lev2sec10"></a>
<H4 id="title-IDAO2E1D" class="docSection2Title">18.5.4. Fibonacci and Factorial ... Take Two, Plus Summation</h4>
<p class="docText">The <tt>mtfacfib.py</tt> script, given in <a class="docLink" href="#ch18list08">Example 18.8</a>, compares execution of the recursive Fibonacci, factorial, and summation functions. This script runs all three functions in a single-threaded manner, then performs the same task using threads to illustrate one of the advantages of having a threading environment.</P>
<a name="ch18list08"></a><H5 id="title-IDAG3E1D" class="docExampleTitle">Example 18.8. <a name="iddle4167"></a>Fibonacci, Factorial, Summation (<tt>mtfacfib.py</tt>)</H5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>


<p class="docText"><span class="docEmphasis">In this MT application, we execute three separate recursive functionsfirst in a single-threaded fashion, followed by the alternative with multiple threads.</span></p>

<pre>1      #!/usr/bin/env python
2
3      <span class="docEmphStrong">from</span> myThread <span class="docEmphStrong">import</span> MyThread
4      <span class="docEmphStrong">from</span> time <span class="docEmphStrong">import</span> ctime, sleep
5
6      <span class="docEmphStrong">def</span> fib(x):
7          sleep(0.005)
8          <span class="docEmphStrong">if</span> x &lt; 2: <span class="docEmphStrong">return</span> 1
9          <span class="docEmphStrong">return</span> (fib(x-2) + fib(x-1))
10
11     <span class="docEmphStrong">def</span> fac(x):
12         sleep(0.1)
13         <span class="docEmphStrong">if</span> x &lt; 2: <span class="docEmphStrong">return</span> 1
14         <span class="docEmphStrong">return</span> (x * fac(x-1))
15
16     <span class="docEmphStrong">def</span> sum(x):
17         sleep(0.1)
18         <span class="docEmphStrong">if</span> x &lt; 2: <span class="docEmphStrong">return</span> 1
19         <span class="docEmphStrong">return</span> (x + sum(x-1))
20
21     funcs = [fib, fac, sum]
22     n = 12
23
24     <span class="docEmphStrong">def</span> main():
25         nfuncs = range(len(funcs))
26
27         <span class="docEmphStrong">print</span> '*** SINGLE THREAD'
28         <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span>   nfuncs:
29             <span class="docEmphStrong">print</span> 'starting', funcs[i].__name__, 'at:', \
30                 ctime()
31             <span class="docEmphStrong">print</span> funcs[i](n)
32             <span class="docEmphStrong">print</span> funcs[i].__name__, 'finished at:', \
33                 ctime()
34
35         <span class="docEmphStrong">print</span> '\n*** MULTIPLE THREADS'
36         threads = []
37         <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span> nfuncs:
38             t = MyThread(funcs[i], (n,),
39                 funcs[i].__name__)
40             threads.append(t)
41
42         <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span> nfuncs:
43             threads[i].start()
44
45         <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span> nfuncs:
46             threads[i].join()
47             <span class="docEmphStrong">print</span> threads[i].getResult()
48
49         <span class="docEmphStrong">print</span> 'all DONE'
50
51     <span class="docEmphStrong">if</span> __name__ == '__main__':
52         main()</pre><BR>

</td></TR></table></p>
<p class="docText">Running in single-threaded mode simply involves calling the functions one at a time and displaying the corresponding results right after the function call.</P>
<p class="docText">When running in multithreaded mode, we do not display the result right away. Because we want to keep our <tt>MyThread</tt> class as general as possible (being able to execute callables that do and do not produce output), we wait until the end to call the <tt>geTResult()</tt> method to finally show you the return values of each function call.</P>
<p class="docText">Because these functions execute so quickly (well, maybe except for the Fibonacci function), you will notice that we had to add calls to <tt>sleep()</tt> to each function to slow things down so that we can see how threading may improve performance, if indeed the actual work had varying execution times you certainly wouldn't pad your work with calls to <tt>sleep()</tt>. Anyway, here is the output:</p>
<div class="docText"><pre>$ mtfacfib.py
*** SINGLE THREAD
starting fib at: Sun Jun 18 19:52:20 2006
233
fib finished at: Sun Jun 18 19:52:24 2006
starting fac at: Sun Jun 18 19:52:24 2006
479001600
fac finished at: Sun Jun 18 19:52:26 2006
starting sum at: Sun Jun 18 19:52:26 2006
78
sum finished at: Sun Jun 18 19:52:27 2006

*** MULTIPLE THREADS
starting fib at: Sun Jun 18 19:52:27 2006
starting fac at: Sun Jun 18 19:52:27 2006
starting sum at: Sun Jun 18 19:52:27 2006
fac finished at: Sun Jun 18 19:52:28 2006
sum finished at: Sun Jun 18 19:52:28 2006
fib finished at: Sun Jun 18 19:52:31 2006
233
479001600
78
all DONE</pre></div><br>

<a name="ch18lev2sec11"></a>
<h4 id="title-IDAHDF1D" class="docSection2Title">18.5.5. Other <tt>Threading</tt> Module Functions</H4>
<p class="docText"><a name="iddle3461"></a><a name="iddle3516"></a><a name="iddle4168"></a><a name="iddle4169"></a>In addition to the various synchronization and threading objects, the <tt>Threading</tt> module also has some supporting functions, detailed in <a class="docLink" href="#ch18table04">Table 18.4</a>.</p>
<a name="ch18table04"></a><P><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 18.4. <tt>threading</tt> Module Functions</h5></caption><colgroup align="left" span="2"><col width="200"><col width="250"></colgroup><thead><TR><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Function</span></P></th><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Description</span></p></th></tr></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>activeCount()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Number of currently active <tt>Thread</tt> objects</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>currentThread()</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Returns the current <tt>THRead</tt> object</p></TD></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>enumerate()</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Returns list of all currently active <tt>Threads</tt></p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>settrace</tt><span class="docEmphasis"><tt>(func)</tt></span><sup class="docFootnote"><a class="docLink" href="#ch07fna1">[a]</a></sup></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Sets a trace <span class="docEmphasis">function</span> for all threads</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>setprofile</tt><span class="docEmphasis"><tt>(func)</tt></span><sup class="docFootnote"><a class="docLink" href="#ch07fna1">[a]</a></sup></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Sets a profile <span class="docEmphasis">function</span> for all threads</P></td></tr></table></p><BR><blockquote><p class="docFootnote"><sup><a name="ch07fna1">[a]</a></sup> New in <a class="docLink" href="ch05lev1sec2.html#ch05lev3sec3">Python 2.3</a>.</P></blockquote>

<a name="ch18lev2sec12"></a>
<h4 id="title-IDASJF1D" class="docSection2Title">18.5.6. Producer-Consumer Problem and the <tt>Queue</tt> Module</h4>
<p class="docText">The final example illustrates the producer-consumer scenario where a producer of goods or services creates goods and places it in a data structure such as a queue. The amount of time between producing goods is non-deterministic, as is the consumer consuming the goods produced by the producer.</p>
<p class="docText"><a name="iddle1170"></a>We use the <tt>Queue</tt> module to provide an interthread communication mechanism that allows threads to share data with each other. In particular, we create a queue into which the producer (thread) places new goods and the consumer (thread) consumes them. To do this, we will use the following attributes from the <tt>Queue</tt> module (see <a class="docLink" href="#ch18table05">Table 18.5</a>).</p>
<a name="ch18table05"></a><p><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 18.5. Common <tt>Queue</tt> Module Attributes</h5></caption><colgroup align="left" span="2"><col width="225"><col width="300"></colgroup><thead><tr><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Function/Method</span></p></th><th class="thead" scope="col" align="left" valign="top"><p class="docText"><span class="docEmphasis">Description</span></p></th></tr></thead><tr><TD class="docTableCell" align="left" valign="top" colspan="2" style="background-color:#DDDDDD"><p class="docText"><tt>Queue</tt> <span class="docEmphBoldItalic">Module Function</span></p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>queue</tt><span class="docEmphasis"><tt>(size)</tt></span></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Creates a <tt>Queue</tt> object of given <tt>size</tt></P></TD></TR><tr><td class="docTableCell" align="left" valign="top" colspan="2" style="background-color:#DDDDDD"><p class="docText"><tt>Queue</tt> <span class="docEmphBoldItalic">Object Methods</span></p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>qsize()</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Returns queue size (approximate, since queue may be getting updated by other threads)</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>empty()</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns <tt>TRue</tt> if queue empty, <tt>False</tt> otherwise</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>full()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns <tt>true</tt> if queue full, <tt>False</tt> otherwise</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>put(</tt><span class="docEmphasis"><tt>item, block</tt></span><tt>=0)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Puts <span class="docEmphasis"><tt>item</tt></span> in queue, if <span class="docEmphasis"><tt>block</tt></span> given (not 0), block until room is available</P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>get(</tt><span class="docEmphasis"><tt>block</tt></span><tt>=0)</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Gets <span class="docEmphasis"><tt>item</tt></span> from queue, if <span class="docEmphasis"><tt>block</tt></span> given (not 0), block until an item is available</P></TD></TR></table></P><br>
<p class="docText">Without further ado, we present the code for <tt>prodcons.py</tt>, shown in <a class="docLink" href="#ch18list09">Example 18.9</a>.</p>
<a name="ch18list09"></a><h5 id="title-IDAIRF1D" class="docExampleTitle">Example 18.9. <a name="iddle2999"></a>Producer-Consumer Problem (<tt>prodcons.py</tt>)</H5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>


<p class="docText"><span class="docEmphasis">We feature an implementation of the Producer-Consumer problem using Queue objects and a random number of goods produced (and consumed). The producer and consumer are individuallyand concurrentlyexecuting threads.</span></P>

<pre>1      #!/usr/bin/env python
2
3      <span class="docEmphStrong">from</span> random <span class="docEmphStrong">import</span> randint
4      <span class="docEmphStrong">from</span> time <span class="docEmphStrong">import</span>  sleep
5      <span class="docEmphStrong">from</span> Queue <span class="docEmphStrong">import</span>  Queue
6      <span class="docEmphStrong">from</span> myThread <span class="docEmphStrong">import</span> MyThread
7
8      <span class="docEmphStrong">def</span> writeQ(queue):
9          <span class="docEmphStrong">print</span> 'producing object for Q...',
10         queue.put('xxx', 1)
11         <span class="docEmphStrong">print</span> "size now", queue.qsize()
12
13     <span class="docEmphStrong">def</span> readQ(queue):
14         val = queue.get(1)
15         <span class="docEmphStrong">print</span> 'consumed object from Q... size now', \
16                 queue.qsize()
17
18     <span class="docEmphStrong">def</span> writer(queue, loops):
19         <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span> range(loops):
20             writeQ(queue)
21             sleep(randint(1, 3))
22
23     <span class="docEmphStrong">def</span> reader(queue, loops):
24         <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span> range(loops):
25             readQ(queue)
26             sleep(randint(2, 5))
27
28     funcs = [writer, reader]
29     nfuncs = range(len(funcs))
30
31     <span class="docEmphStrong">def</span> main():
32         nloops = randint(2, 5)
33         q = Queue(32)
34
35         threads = []
36         <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span> nfuncs:
37             t = MyThread(funcs[i], (q, nloops),
38                 funcs[i].__name__)
39             threads.append(t)
40
41         <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span> nfuncs:
42             threads[i].start()
43
44         <span class="docEmphStrong">for</span> i <span class="docEmphStrong">in</span> nfuncs:
45             threads[i].join()
46
47         <span class="docEmphStrong">print</span> 'all DONE'
48
49    <span class="docEmphStrong">if</span> __name__ == '__main__':
50        main()</pre><br>

</TD></TR></table></p>
<p class="docText">Here is the output from one execution of this script:</p>
<div class="docText"><pre>$ prodcons.py
starting writer at: Sun Jun 18 20:27:07 2006
producing object for Q... size now 1
starting reader at: Sun Jun 18 20:27:07 2006
consumed object from Q... size now 0
producing object for Q... size now 1
consumed object from Q... size now 0
producing object for Q... size now 1
producing object for Q... size now 2
producing object for Q... size now 3
consumed object from Q... size now 2
consumed object from Q... size now 1
writer finished at: Sun Jun 18 20:27:17 2006
consumed object from Q... size now 0
reader finished at: Sun Jun 18 20:27:25 2006
all DONE</pre></div><br>
<p class="docText">As you can see, the producer and consumer do not necessarily alternate in execution. (Thank goodness for random numbers!) Seriously, though, real life is generally random and non-deterministic.</p>
<a name="ch18lev3sec7"></a>
<H5 id="title-IDAAWF1D" class="docSection3Title">Line-by-Line Explanation</h5>
<a name="ch18lev4sec1"></a>
<h5 id="title-IDAJWF1D" class="docSection4Title">Lines 16</H5>
<p class="docText">In this module, we will use the <tt>Queue.Queue</tt> object as well as our thread class <tt>myThread.MyThread</tt>, which we gave in <a class="docLink" href="#ch18list07">Example 18.7</a>. We will use <tt>random.randint()</tt> to make production and consumption somewhat varied, and also grab the usual suspects from the time module.</p>

<a name="ch18lev4sec2"></a>
<h5 id="title-IDACXF1D" class="docSection4Title">Lines 816</H5>
<p class="docText">The <tt>writeQ()</tt> and <tt>readQ()</tt> functions each have a specific purpose, to place an object in the queuewe are using the string <tt>'xxx'</tt>, for exampleand to consume a queued object, respectively. Notice that we are producing one object and reading one object each time.</P>

<a name="ch18lev4sec3"></a>
<h5 id="title-IDAVXF1D" class="docSection4Title">Lines 1826</h5>
<p class="docText">The <tt>writer()</tt> is going to run as a single thread whose sole purpose is to produce an item for the queue, wait for a bit, then do it again, up to the specified number of times, chosen randomly per script execution. The <tt>reader()</tt> will do likewise, with the exception of consuming an item, of course.</p>
<p class="docText">You will notice that the random number of seconds that the writer sleeps is in general shorter than the amount of time the reader sleeps. This is to discourage the reader from trying to take items from an empty queue. By giving the writer a shorter time period of waiting, it is more likely that there will already be an object for the reader to consume by the time their turn rolls around again.</p>

<a name="ch18lev4sec4"></a>
<h5 id="title-IDALYF1D" class="docSection4Title">Lines 2829</h5>
<p class="docText">These are just setup lines to set the total number of threads that are to be spawned and executed.</p>

<a name="ch18lev4sec5"></a>

<h5 id="title-IDAZYF1D" class="docSection4Title">Lines 3147</h5>
<p class="docText"><a name="iddle3001"></a><a name="iddle3021"></a><a name="iddle3874"></a><a name="iddle4159"></a><a name="iddle4162"></a>Finally, we have our <tt>main()</tt> function, which should look quite similar to the <tt>main()</tt> in all of the other scripts in this chapter. We create the appropriate threads and send them on their way, finishing up when both threads have concluded execution.</p>
<p class="docText">We infer from this example that a program that has multiple tasks to perform can be organized to use separate threads for each of the tasks. This can result in a much cleaner program design than a single threaded program that attempts to do all of the tasks.</p>
<p class="docText">In this chapter, we illustrated how a single-threaded process may limit an application's performance. In particular, programs with independent, non-deterministic, and non-causal tasks that execute sequentially can be improved by division into separate tasks executed by individual threads. Not all applications may benefit from multithreading due to overhead and the fact that the Python interpreter is a single-threaded application, but now you are more cognizant of Python's threading capabilities and can use this tool to your advantage when appropriate.</p>




<a href="14051536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch18lev1sec4.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch18lev1sec6.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>