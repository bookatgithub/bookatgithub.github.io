<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 20.2.&nbsp; Web Surfing with Python: Creating Simple Web Clients</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch20lev1sec1.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch20lev1sec3.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a name="ch20lev1sec2"></a>
<h3 id="title-IDA2HDCD" class="docSection1Title">20.2. Web Surfing with Python: Creating Simple Web Clients</H3>
<p class="docText">One thing to keep in mind is that a browser is only one type of Web client. Any application that makes a request for data from a Web server is considered a &quot;client.&quot; Yes, it is possible to create other clients that retrieve documents or data off the Internet. One important reason to do this is that a browser provides only limited capacity, i.e., it is used primarily for viewing and interacting with Web sites. A client program, on the other hand, has the ability to do moreit can not only download data, but it can also store it, manipulate it, or perhaps even transmit it to another location or application.</p>
<p class="docText">Applications that use the <tt>urllib</tt> module to download or access information on the Web [using either <tt>urllib.urlopen()</tt> or <tt>urllib.urlretrieve()</tt>] can be considered a simple Web client. All you need to do is provide a valid Web address.</P>
<a name="ch20lev2sec3"></a>
<H4 id="title-IDATIDCD" class="docSection2Title">20.2.1. Uniform Resource Locators</H4>
<p class="docText">Simple Web surfing involves using Web addresses called <span class="docEmphasis">URLs</span> (Uniform Resource Locators). Such addresses are used to locate a document on the Web or to call a CGI program to generate a document for your client. URLs are part of a larger set of identifiers known as <span class="docEmphasis">URIs</span> (Uniform Resource Identifiers). This superset was created in anticipation of other naming conventions that have yet to be developed. A URL is simply a URI which uses an existing protocol or scheme (i.e., http, ftp, etc.) as part of its addressing. To complete this picture, we'll add that non-URL URIs are sometimes known as <span class="docEmphasis">URNs</span> (Uniform Resource Names), but because URLs are the only URIs in use today, you really don't hear much about URIs or URNs, save perhaps as XML identifiers.</P>
<p class="docText">Like street addresses, Web addresses have some structure. An American street address usually is of the form &quot;number street designation,&quot; i.e., 123 Main Street. It differs from other countries, which have their own rules. A URL uses the format:</p>
<div class="docText"><pre>        <span class="docEmphasis">prot_sch</span>://<span class="docEmphasis">net_loc</span>/<span class="docEmphasis">path</span>;<span class="docEmphasis">params</span>?<span class="docEmphasis">query</span>#<span class="docEmphasis">frag</span></pre></div><br>
<p class="docText"><a name="iddle3055"></a><a name="iddle4453"></a><a name="iddle4460"></a><a name="iddle4467"></a><a class="docLink" href="#ch20table01">Table 20.1</a> describes each of the components.</p>
<a name="ch20table01"></a><P><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 20.1. Web Address Components</H5></caption><colgroup align="left" span="2"><col width="150"><col width="300"></colgroup><thead><tr><th class="thead" scope="col" align="left" valign="top"><p class="docText">URL Component</P></th><th class="thead" scope="col" align="left" valign="top"><p class="docText">Description</p></th></TR></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>prot_sch</tt></span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Network protocol or download scheme</P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>net_loc</tt></span></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Location of server (and perhaps user information)</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>path</tt></span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Slash ( / ) delimited path to file or CGI application</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>params</tt></span></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Optional parameters</p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>query</tt></span></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Ampersand ( &amp; ) delimited set of &quot;key=value&quot; pairs</P></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>frag</tt></span></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Fragment to a specific anchor within document</P></td></TR></table></P><br>
<p class="docText"><span class="docEmphasis"><tt>net_loc</tt></span> can be broken down into several more components, some required, others optional. The <span class="docEmphasis"><tt>net_loc</tt></span> string looks like this:</p>
<div class="docText"><pre>        <span class="docEmphasis">user</span>:<span class="docEmphasis">passwd</span>@<span class="docEmphasis">host</span>:<span class="docEmphasis">port</span></pre></div><br>
<p class="docText">These individual components are described in <a class="docLink" href="#ch20table02">Table 20.2</a>.</p>
<a name="ch20table02"></a><P><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 20.2. Network Location Components</h5></caption><colgroup align="left" span="2"><col width="100"><col width="300"></colgroup><thead><TR><th class="thead" scope="col" align="left" valign="top"><p class="docText"><tt>net_loc</tt> Component</p></th><th class="thead" scope="col" align="left" valign="top"><p class="docText">Description</p></th></tr></thead><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>user</tt></span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">User name or login</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>passwd</tt></span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">User password</p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>host</tt></span></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Name or address of machine running Web server [required]</p></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>port</tt></span></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Port number (if not 80, the default)</P></td></TR></table></p><BR>
<p class="docText">Of the four, the <tt>host</tt> name is the most important. The <tt>port</tt> number is necessary only if the Web server is running on a different port number from the default. (If you aren't sure what a port number is, go back to <a class="docLink" href="ch16.html#ch16">Chapter 16</a>.)</p>
<p class="docText">User names and perhaps passwords are used only when making FTP connections, and even then they usually aren't necessary because the majority of such connections are &quot;anonymous.&quot;</P>
<p class="docText"><a name="iddle4386"></a><a name="iddle4478"></a>Python supplies two different modules, each dealing with URLs in completely different functionality and capacities. One is <tt>urlparse</tt>, and the other is <tt>urllib</tt>. We will briefly introduce some of their functions here.</P>

<a name="ch20lev2sec4"></a>
<h4 id="title-IDAHUDCD" class="docSection2Title">20.2.2. <tt>urlparse</tt> Module</h4>
<p class="docText">The <tt>urlparse</tt> module provides basic functionality with which to manipulate URL strings. These functions include <tt>urlparse()</tt>, <tt>urlunparse()</tt>, and <tt>urljoin()</tt>.</p>
<a name="ch20lev3sec1"></a>
<h5 id="title-IDA2UDCD" class="docSection3Title"><tt>urlparse.urlparse()</tt></H5>
<p class="docText"><tt>urlparse()</tt> breaks up a URL string into some of the major components described above. It has the following syntax:</p>
<div class="docText"><pre>        urlparse(<span class="docEmphasis">urlstr</span>, <span class="docEmphasis">defProtSch</span>=None, <span class="docEmphasis">allowFrag</span>=None)</pre></div><br>
<p class="docText"><tt>urlparse()</tt> parses <span class="docEmphasis"><tt>urlstr</tt></span> into a 6-tuple (<tt>prot_sch</tt>, <tt>net_loc</tt>, <tt>path</tt>, <tt>params</tt>, <tt>query</tt>, <tt>frag</tt>). Each of these components has been described above. <span class="docEmphasis"><tt>defProtSch</tt></span> indicates a default network protocol or download scheme in case one is not provided in <tt>urlstr.</tt><span class="docEmphasis"><tt>allowFrag</tt></span> is a flag that signals whether or not a fragment part of a URL is allowed. Here is what <tt>urlparse()</tt> outputs when given a URL:</P>
<div class="docText"><pre>        &gt;&gt;&gt; urlparse.urlparse('http://www.python.org/doc/FAQ.html')
        ('http', 'www.python.org', '/doc/FAQ.html', '', '', '')</pre></div><br>

<a name="ch20lev3sec2"></a>
<h5 id="title-IDA1WDCD" class="docSection3Title"><tt>urlparse.urlunparse()</tt></h5>
<p class="docText"><tt>urlunparse()</tt> does the exact opposite of <tt>urlparse()</tt>it merges a 6-tuple (<tt>prot_sch</tt>, <tt>net_loc</tt>, <tt>path</tt>, <tt>params</tt>, <tt>query</tt>, <tt>frag</tt>)<span class="docEmphasis"><tt>urltup</tt></span>, which could be the output of <tt>urlparse()</tt>, into a single URL string and returns it. Accordingly, we state the following equivalence:</P>
<div class="docText"><pre>        urlunparse(urlparse(<span class="docEmphasis">urlstr</span>)) <img src=images/U2261.jpg border=0> <span class="docEmphasis">urlstr</span></pre></div><BR>
<p class="docText">You may have already surmised that the syntax of <tt>urlunparse()</tt> is as follows:</p>
<div class="docText"><pre>        urlunparse(<span class="docEmphasis">urltup</span>)</pre></div><br>

<a name="ch20lev3sec3"></a>
<h5 id="title-IDAZYDCD" class="docSection3Title"><tt>urlparse.urljoin()</tt></h5>
<p class="docText">The <tt>urljoin()</tt> function is useful in cases where many related URLs are needed, for example, the URLs for a set of pages to be generated for a Web site. The syntax for <tt>urljoin()</tt> is:</p>
<div class="docText"><pre>        urljoin(<span class="docEmphasis">baseurl</span>, <span class="docEmphasis">newurl</span>, <span class="docEmphasis">allowFrag</span>=None)</pre></div><br>
<p class="docText"><a name="iddle4384"></a><a name="iddle4476"></a><tt>urljoin()</tt> takes <span class="docEmphasis"><tt>baseurl</tt></span> and joins its base path (<span class="docEmphasis"><tt>net_loc</tt></span> plus the full path up to, but not including, a file at the end) with <span class="docEmphasis"><tt>newurl</tt></span>. For example:</p>
<div class="docText"><pre>        &gt;&gt;&gt; urlparse.urljoin('http://www.python.org/doc/FAQ.html', \
        ... 'current/lib/lib.htm')
        'http://www.python.org/doc/current/lib/lib.html'</pre></div><br>
<p class="docText">A summary of the functions in <tt>urlparse</tt> can be found in <a class="docLink" href="#ch20table03">Table 20.3</a>.</p>
<a name="ch20table03"></a><p><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 20.3. Core <tt>urlparse</tt> Module Functions</h5></caption><colgroup align="left" span="2"><col width="200"><col width="350"></colgroup><thead><TR><th class="thead" scope="col" align="left" valign="top"><p class="docText"><tt>urlparse</tt> Functions</p></th><th class="thead" scope="col" align="left" valign="top"><p class="docText">Description</P></th></tr></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>urlparse(</tt><span class="docEmphasis"><tt>urlstr</tt></span><tt>,</tt> <span class="docEmphasis"><tt>defProtSch</tt></span><tt>=None,</tt> <span class="docEmphasis"><tt>allowFrag</tt></span><tt>=None)</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Parses <span class="docEmphasis"><tt>urlstr</tt></span> into separate components, using <span class="docEmphasis"><tt>defProtSch</tt></span> if the protocol or scheme is not given in <span class="docEmphasis"><tt>urlstr</tt></span>; <span class="docEmphasis"><tt>allowFrag</tt></span> determines whether a URL fragment is allowed</P></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>urlunparse(</tt><span class="docEmphasis"><tt>urltup</tt></span><tt>)</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Unparses a tuple of URL data (<span class="docEmphasis"><tt>urltup</tt></span>) into a single URL string</P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>urljoin(</tt><span class="docEmphasis"><tt>baseurl</tt></span><tt>,</tt><span class="docEmphasis"><tt>newurl</tt></span>,<span class="docEmphasis"><tt>allowFrag</tt></span><tt>=None)</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Merges the base part of the <span class="docEmphasis"><tt>baseurl</tt></span> URL with <span class="docEmphasis"><tt>newurl</tt></span> to form a complete URL; <span class="docEmphasis"><tt>allowFrag</tt></span> is the same as for <tt>urlparse()</tt>
</p></td></TR></table></p><br>


<a name="ch20lev2sec5"></a>
<H4 id="title-IDAU5DCD" class="docSection2Title">20.2.3. <tt>urllib</tt> Module</h4>
<a name="ch20note01"></a><div class="docNote"><p class="docNoteTitle">Core Module: <tt>urllib</tt></p><p><table width="90%" border="0" cellspacing="0" cellpadding="1"><TR><TD width="60" valign="top">
<img border="0" alt="" align="LEFT" width="50" height="46" SRC="images/core_module.jpg">


</td><td valign="top"><p class="docText"><span class="docEmphasis">Unless you are planning on writing a more lower-level network client, the <tt>urllib</tt> module provides all the functionality you need. <tt>urllib</tt> provides a high-level Web communication library, supporting the basic Web protocols, HTTP, FTP, and Gopher, as well as providing access to local files. Specifically, the functions of the <tt>urllib</tt> module are designed to download data (from the Internet, local network, or local host) using the aforementioned protocols. Use of this module generally obviates the need for using the <tt>httplib</tt>, <tt>ftplib</tt>, and <tt>gopherlib</tt> modules unless you desire their lower-level functionality. In those cases, such modules can be considered as alternatives. (Note: Most modules named <tt>*lib</tt> are generally for developing clients of the corresponding protocols. This is not always the case, however, as perhaps <tt>urllib</tt> should then be renamed &quot;internetlib&quot; or something similar!)</span></p></td></tr></table></p></div><br>
<p class="docText"><a name="iddle2915"></a><a name="iddle2989"></a>The <tt>urllib</tt> module provides functions to download data from given URLs as well as encoding and decoding strings to make them suitable for including as part of valid URL strings. The functions we will be looking at in this upcoming section include: <tt>urlopen()</tt>, <tt>urlretrieve()</tt>, <tt>quote()</tt>, <tt>unquote()</tt>, <tt>quote_plus()</tt>, <tt>unquote_plus()</tt>, and <tt>urlencode()</tt>. We will also look at some of the methods available to the file-like object returned by <tt>urlopen()</tt>. They will be familiar to you because you have already learned to work with files back in <a class="docLink" href="ch09.html#ch09">Chapter 9</a>.</p>
<a name="ch20lev3sec4"></a>
<h5 id="title-IDAXCECD" class="docSection3Title"><tt>urllib.urlopen()</tt></h5>
<p class="docText"><tt>urlopen()</tt> opens a Web connection to the given URL string and returns a file-like object. It has the following syntax:</p>
<div class="docText"><pre>        urlopen(<span class="docEmphasis">urlstr</span>, <span class="docEmphasis">postQueryData</span>=None)</pre></div><br>
<p class="docText"><tt>urlopen()</tt> opens the URL pointed to by <span class="docEmphasis"><tt>urlstr</tt></span>. If no protocol or download scheme is given, or if a &quot;file&quot; scheme is passed in, <tt>urlopen()</tt> will open a local file.</P>
<p class="docText">For all HTTP requests, the normal request type is &quot;GET.&quot; In these cases, the query string provided to the Web server (key-value pairs encoded or &quot;quoted,&quot; such as the string output of the <tt>urlencode()</tt> function [see below]), should be given as part of <span class="docEmphasis"><tt>urlstr</tt></span>.</p>
<p class="docText">If the &quot;POST&quot; request method is desired, then the query string (again encoded) should be placed in the <span class="docEmphasis"><tt>postQueryData</tt></span> variable. (For more information regarding the GET and POST request methods, refer to any general documentation or texts on programming CGI applicationswhich we will also discuss below. GET and POST requests are the two ways to &quot;upload&quot; data to a Web server.</P>
<p class="docText">When a successful connection is made, <tt>urlopen()</tt> returns a file-like object as if the destination was a file opened in read mode. If our file object is <tt>f</tt>, for example, then our &quot;handle&quot; would support the expected read methods such as <tt>f.read()</tt>, <tt>f.readline()</tt>, <tt>f.readlines()</tt>, <tt>f.close()</tt>, and <tt>f.fileno()</tt>.</p>
<p class="docText">In addition, a <tt>f.info()</tt> method is available which returns the <span class="docEmphasis">MIME</span> (Multipurpose Internet Mail Extension) headers. Such headers give the browser information regarding which application can view returned file types. For example, the browser itself can view <span class="docEmphasis">HTML</span> (HyperText Markup Language), plain text files, and render <span class="docEmphasis">PNG</span> (Portable Network Graphics) and <span class="docEmphasis">JPEG</span> (Joint Photographic Experts Group) or the old <span class="docEmphasis">GIF</span> (Graphics Interchange Format) graphics files. Other files such as multimedia or specific document types require external applications in order to view.</P>
<p class="docText">Finally, a <tt>geturl()</tt> method exists to obtain the true URL of the final opened destination, taking into consideration any redirection that may have occurred. A summary of these file-like object methods is given in <a class="docLink" href="#ch20table04">Table 20.4</a>.</p>
<a name="ch20table04"></a><P><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 20.4. <tt>urllib.urlopen()</tt> <span class="docEmphasis">File-like Object Methods</span></H5></caption><colgroup align="left" span="2"><col width="200"><col width="250"></colgroup><thead><TR><th class="thead" scope="col" align="left" valign="top"><p class="docText"><tt>urlopen()</tt> Object Methods</P></th><th class="thead" scope="col" align="left" valign="top"><p class="docText">Description</P></th></tr></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>f</tt></span><tt>.read(</tt><tt>[</tt><span class="docEmphasis"><tt>bytes</tt></span><tt>])</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Reads all or <tt>bytes</tt> bytes from <tt>f</tt>
</p></TD></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>f</tt></span><tt>.readline()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Reads a single line from <tt>f</tt>
</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>f</tt></span><tt>.readlines()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Reads a all lines from <tt>f</tt> into a list</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>f</tt></span><tt>.close()</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Closes URL connection for <tt>f</tt>
</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>f</tt></span><tt>.fileno()</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Returns file number of <tt>f</tt>
</P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>f</tt></span><tt>.info()</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Gets MIME headers of <tt>f</tt>
</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis"><tt>f</tt></span><tt>.geturl()</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Returns true URL opened for <tt>f</tt>
</p></TD></tr></table></P><BR>
<p class="docText">If you expect to be accessing more complex URLs or want to be able to handle more complex situations such as basic and digest authentication, redirections, cookies, etc., then we suggest using the <tt>urllib2</tt> module, introduced back in the 1.6 days (mostly as an experimental module). It too, has a <tt>urlopen()</tt> function, but also provides other functions and classes for opening a variety of URLs. For more on <tt>urllib2</tt>, see the next section of this chapter.</p>

<a name="ch20lev3sec5"></a>
<h5 id="title-IDAQLECD" class="docSection3Title"><tt>urllib.urlretrieve()</tt></h5>
<p class="docText"><tt>urlretrieve()</tt> will do some quick and dirty work for you if you are interested in working with a URL document as a whole. Here is the syntax for <tt>urlretrieve()</tt>:</p>
<div class="docText"><pre>        urlretrieve(<span class="docEmphasis">urlstr</span>, <span class="docEmphasis">localfile</span>=None, <span class="docEmphasis">downloadSta-
        tusHook</span>=None)</pre></div><BR>
<p class="docText">Rather than reading from the URL like <tt>urlopen()</tt> does, <tt>urlretrieve()</tt> will simply download the entire HTML file located at <span class="docEmphasis"><tt>urlstr</tt></span> to your local disk. It will store the downloaded data into <span class="docEmphasis"><tt>localfile</tt></span> if given or a temporary file if not. If the file has already been copied from the Internet or if the file is local, no subsequent downloading will occur.</p>
<p class="docText">The <span class="docEmphasis"><tt>downloadStatusHook</tt></span>, if provided, is a function that is called after each block of data has been downloaded and delivered. It is called with the following three arguments: number of blocks read so far, the block size in bytes, <a name="iddle3519"></a>and the total (byte) size of the file. This is very useful if you are implementing &quot;download status&quot; information to the user in a text-based or graphical display.</p>
<p class="docText"><tt>urlretrieve()</tt> returns a 2-tuple, (<span class="docEmphasis"><tt>filename</tt></span>, <span class="docEmphasis"><tt>mime_hdrs</tt></span>). <span class="docEmphasis"><tt>filename</tt></span> is the name of the local file containing the downloaded data. <span class="docEmphasis"><tt>mime_hdrs</tt></span> is the set of MIME headers returned by the responding Web server. For more information, see the <tt>Message</tt> class of the <tt>mimetools</tt> module. <span class="docEmphasis"><tt>mime_hdrs</tt></span> is <tt>None</tt> for local files.</P>
<p class="docText">For a simple example using <tt>urlretrieve()</tt>, take a look at <a class="docLink" href="ch11lev1sec5.html#ch11list04">Example 11.4</a> (<tt>grabweb.py</tt>). A larger piece of code using <tt>urlretrieve()</tt> can be found later in this chapter in <a class="docLink" href="#ch20list02">Example 20.2</a>.</p>
<a name="ch20list02"></a><h5 id="title-IDA3OECD" class="docExampleTitle">Example 20.2. Advanced Web Client: a Web Crawler (<tt>crawl.py</tt>)</h5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>


<p class="docText"><span class="docEmphasis">The crawler consists of two classes, one to manage the entire crawling process (</span><tt>Crawler</tt><span class="docEmphasis">), and one to retrieve and parse each downloaded Web page (<tt>Retriever</tt>).</span></p>

<pre>   1      #!/usr/bin/env python
   2
   3      <span class="docEmphStrong">from</span> sys <span class="docEmphStrong">import</span> argv
   4      <span class="docEmphStrong">from</span> os <span class="docEmphStrong">import</span> makedirs, unlink, sep
   5      <span class="docEmphStrong">from</span> os.path <span class="docEmphStrong">import</span> dirname, exists, isdir, splitext
   6      <span class="docEmphStrong">from</span> string <span class="docEmphStrong">import</span> replace, find, lower
   7      <span class="docEmphStrong">from</span> htmllib <span class="docEmphStrong">import</span> HTMLParser
   8      <span class="docEmphStrong">from</span> urllib <span class="docEmphStrong">import</span> urlretrieve
   9      <span class="docEmphStrong">from</span> urlparse <span class="docEmphStrong">import</span> urlparse, urljoin
   10     <span class="docEmphStrong">from</span> formatter <span class="docEmphStrong">import</span> DumbWriter, AbstractFormatter
   11     <span class="docEmphStrong">from</span> cStringIO <span class="docEmphStrong">import</span> StringIO
   12
   13     <span class="docEmphStrong">class</span> Retriever(object):# download Web pages
   14
   15          <span class="docEmphStrong">def</span> __init__(self, url):
   16           self.url = url
   17           self.file = self.filename(url)
   18
   19          <span class="docEmphStrong">def</span> filename(self, url, deffile='index.htm'):
   20           parsedurl = urlparse(url, 'http:', 0) ## parse path
   21           path = parsedurl[1] + parsedurl[2]
   22           ext = splitext(path)
   23           <span class="docEmphStrong">if</span> ext[1] == '':           # no file, use default
   24               <span class="docEmphStrong">if</span> path[-1] == '/':
   25                   path += deffile
   26               <span class="docEmphStrong">else:</span>
   27                   path += '/' + deffile
   28           ldir = dirname(path)   # local directory
   29           <span class="docEmphStrong">if</span> sep != '/':         # os-indep. path separator
   30               ldir = replace(ldir, '/', sep)
   31           <span class="docEmphStrong">if not</span> isdir(ldir):    # create archive dir if nec
   32               <span class="docEmphStrong">if</span> exists(ldir): unlink(ldir)
   33               makedirs(ldir)
   34           <span class="docEmphStrong">return</span> path
   35
   36          <span class="docEmphStrong">def</span> download(self):     # download Web page
   37              <span class="docEmphStrong">try:</span>
   38                  retval = urlretrieve(self.url, self.file)
   39              <span class="docEmphStrong">except</span> IOError:
   40                  retval = ('*** ERROR: invalid URL "%s"' %\
   41                       self.url,)
   42              <span class="docEmphStrong">return</span> retval
   43
   44           <span class="docEmphStrong">def</span> parseAndGetLinks(self):# parse HTML, save links
   45               self.parser = HTMLParser(AbstractFormatter(\
   46                    DumbWriter(StringIO())))
   47               self.parser.feed(open(self.file).read())
   48               self.parser.close()
   49               <span class="docEmphStrong">return</span> self.parser.anchorlist
   50
   51    <span class="docEmphStrong">class</span> Crawler(object):# manage entire crawling process
   52
   53      count = 0         # static downloaded page counter
   54
   55      <span class="docEmphStrong">def</span> __init__(self, url):
   56          self.q = [url]
   57          self.seen = []
   58          self.dom = urlparse(url)[1]
   59
   60      <span class="docEmphStrong">def</span> getPage(self, url):
   61          r = Retriever(url)
   62          retval = r.download()
   63          <span class="docEmphStrong">if</span> retval[0] == '*': # error situation, do not parse
   64              <span class="docEmphStrong">print</span> retval, '... skipping parse'
   65              <span class="docEmphStrong">return</span>
   66          Crawler.count += 1
   67          <span class="docEmphStrong">print</span> '\n(', Crawler.count, ')'
   68          <span class="docEmphStrong">print</span> 'URL:', url
   69          <span class="docEmphStrong">print</span> 'FILE:', retval[0]
   70          self.seen.append(url)
   71
   72          links = r.parseAndGetLinks() # get and process links
   73          <span class="docEmphStrong">for</span> eachLink <span class="docEmphStrong">in</span> links:
   74              <span class="docEmphStrong">if</span> eachLink[:4] != 'http' <span class="docEmphStrong">and</span> \
   75                      find(eachLink, '://') == -1:
   76                  eachLink = urljoin(url, eachLink)
   77              <span class="docEmphStrong">print</span> '* ', eachLink,
   78
   79              <span class="docEmphStrong">if</span> find(lower(eachLink), 'mailto:') != -1:
   80                  <span class="docEmphStrong">print</span> '... discarded, mailto link'
   81                  <span class="docEmphStrong">continue</span>
   82
   83              <span class="docEmphStrong">if</span> eachLink not in self.seen:
   84                  <span class="docEmphStrong">if</span> find(eachLink, self.dom) == -1:
   85                      <span class="docEmphStrong">print</span> '... discarded, not in domain'
   86                  <span class="docEmphStrong">else:</span>
   87                      <span class="docEmphStrong">if</span> eachLink not in self.q:
   88                          self.q.append(eachLink)
   89                          <span class="docEmphStrong">print</span> '... new, added to Q'
   90                      <span class="docEmphStrong">else:</span>
   91                          <span class="docEmphStrong">print</span> '... discarded, already in Q'
   92              <span class="docEmphStrong">else:</span>
   93                  <span class="docEmphStrong">print</span> '... discarded, already processed'
   94
   95      <span class="docEmphStrong">def</span> go(self):# process links in queue
   96          <span class="docEmphStrong">while</span> self.q:
   97              url = self.q.pop()
   98              self.getPage(url)
   99
   100     <span class="docEmphStrong">def</span> main():
   101         if len(argv) &gt; 1:
   102             url = argv[1]
   103          <span class="docEmphStrong">else:</span>
   104              <span class="docEmphStrong">try:</span>
   105              url = raw_input('Enter starting URL: ')
   106          <span class="docEmphStrong">except</span> (KeyboardInterrupt, EOFError):
   107              url = ''
   108
   109          <span class="docEmphStrong">if not</span> url: return
   110          robot = Crawler(url)
   111          robot.go()
   112
   113      <span class="docEmphStrong">if</span> __name__ == '__main__':
   114          main()</pre><br>
</td></tr></table></p>

<a name="ch20lev3sec6"></a>
<h5 id="title-IDAUYECD" class="docSection3Title"><tt>urllib.quote()</tt> and <tt>urllib.quote_plus()</tt></h5>
<p class="docText">The <tt>quote*()</tt> functions take URL data and &quot;encodes&quot; them so that they are &quot;fit&quot; for inclusion as part of a URL string. In particular, certain special characters that are unprintable or cannot be part of valid URLs acceptable to a Web server must be converted. This is what the <tt>quote*()</tt> functions do for you. Both <tt>quote*()</tt> functions have the following syntax:</p>
<div class="docText"><pre>        quote(<span class="docEmphasis">urldata</span>, <span class="docEmphasis">safe</span>='/')</pre></div><br>
<p class="docText">Characters that are never converted include commas, underscores, periods, and dashes, as well as alphanumerics. All others are subject to conversion. In particular, the disallowed characters are changed to their hexadecimal ordinal equivalents prepended with a percent sign (<tt>%</tt>), i.e., &quot;<tt>%xx</tt>&quot; where &quot;<tt>xx</tt>&quot; is the hexadecimal representation of a character's ASCII value. When calling <tt>quote*()</tt>, the <span class="docEmphasis"><tt>urldata</tt></span> string is converted to an equivalent string that can be part of a URL string. The <span class="docEmphasis"><tt>safe</tt></span> string should contain a set of characters which should also <span class="docEmphasis">not</span> be converted. The default is the slash ( <tt>/</tt> ).</p>
<p class="docText"><tt>quote_plus()</tt> is similar to <tt>quote()</tt> except that it also encodes spaces to plus signs ( <tt>+</tt> ). Here is an example using <tt>quote() vs</tt>. <tt>quote_plus()</tt>:</p>
<div class="docText"><pre>        &gt;&gt;&gt; name = 'joe mama'
        &gt;&gt;&gt; number = 6
        &gt;&gt;&gt; base = 'http://www/~foo/cgi-bin/s.py'
        &gt;&gt;&gt; final = '%s?name=%s&amp;num=%d' % (base, name, number)
        &gt;&gt;&gt; final
        'http://www/~foo/cgi-bin/s.py?name=joe mama&amp;num=6'
        &gt;&gt;&gt;
        &gt;&gt;&gt; urllib.quote(final)
        'http:%3a//www/%7efoo/cgi-bin/s.py%3fname%3djoe%20mama%26num%3d6'
        &gt;&gt;&gt;
        &gt;&gt;&gt; urllib.quote_plus(final)
        'http%3a//www/%7efoo/cgi-bin/s.py%3fname%3dj    oe+mama%26num%3d6'</pre></div><BR>

<a name="ch20lev3sec7"></a>

<h5 id="title-IDAA1ECD" class="docSection3Title"><tt>urllib.unquote()</tt> and <tt>urllib.unquote_plus()</tt></H5>
<p class="docText"><a name="iddle3704"></a><a name="iddle3905"></a><a name="iddle4385"></a><a name="iddle4477"></a>As you have probably guessed, the <tt>unquote*()</tt> functions do the exact opposite of the <tt>quote*()</tt> functionsthey convert all characters encoded in the &quot;<tt>%xx</tt>&quot; fashion to their ASCII equivalents. The syntax of <tt>unquote*()</tt> is as follows:</p>
<div class="docText"><pre>        unquote*(<span class="docEmphasis">urldata</span>)</pre></div><BR>
<p class="docText">Calling <tt>unquote()</tt> will decode all URL-encoded characters in <tt>urldata</tt> and return the resulting string. <tt>unquote_plus()</tt> will also convert plus signs back to space characters.</p>

<a name="ch20lev3sec8"></a>
<H5 id="title-IDAE3ECD" class="docSection3Title"><tt>urllib.urlencode()</tt></h5>
<p class="docText"><tt>urlencode()</tt>, added to Python back in 1.5.2, takes a dictionary of key-value pairs and encodes them to be included as part of a query in a CGI request URL string. The pairs are in &quot;<tt>key=value</tt>&quot; format and are delimited by ampersands ( <tt>&amp;</tt> ). Furthermore, the keys and their values are sent to <tt>quote_plus()</tt> for proper encoding. Here is an example output from <tt>urlencode()</tt>:</P>
<div class="docText"><pre>        &gt;&gt;&gt; aDict = { 'name': 'Georgina Garcia', 'hmdir': '~ggarcia' }
        &gt;&gt;&gt; urllib.urlencode(aDict)
        'name=Georgina+Garcia&amp;hmdir=%7eggarcia'</pre></div><BR>
<p class="docText">There are other functions in <tt>urllib</tt> and <tt>urlparse</tt> which we did not have the opportunity to cover here. Refer to the documentation for more information.</P>

<a name="ch20lev3sec9"></a>
<H5 id="title-IDAJ4ECD" class="docSection3Title">Secure Socket Layer support</h5>
<p class="docText">The <tt>urllib</tt> module was given support for opening HTTP connections using the Secure Socket Layer (SSL) in 1.6. The core change to add SSL is implemented in the <tt>socket</tt> module. Consequently, the <tt>urllib</tt> and <tt>httplib</tt> modules were updated to support URLs using the &quot;https&quot; connection scheme. In addition to those two modules, other protocol client modules with SSL support include: <tt>imaplib, poplib</tt>, and <tt>smtplib</tt>.</p>
<p class="docText">A summary of the <tt>urllib</tt> functions discussed in this section can be found in <a class="docLink" href="#ch20table05">Table 20.5</a>.</p>
<a name="ch20table05"></a><P><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 20.5. Core <tt>urllib</tt> Module Functions</H5></caption><colgroup align="left" span="2"><col width="275"><col width="275"></colgroup><thead><tr><th class="thead" scope="col" align="left" valign="top"><p class="docText"><tt>urllib</tt> Functions</P></th><th class="thead" scope="col" align="left" valign="top"><p class="docText">Description</p></th></TR></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>urlopen(</tt><span class="docEmphasis"><tt>urlstr, postQueryData</tt></span><tt>=None)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Opens the URL <span class="docEmphasis"><tt>urlstr</tt></span>, sending the query data in <span class="docEmphasis"><tt>postQueryData</tt></span> if a POST request</P></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>urlretrieve(</tt><span class="docEmphasis"><tt>urlstr, localfile</tt></span><tt>=None,</tt> <span class="docEmphasis"><tt>downloadStatusHook</tt></span><tt>=None)</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Downloads the file located at the <span class="docEmphasis"><tt>urlstr</tt></span> URL to <span class="docEmphasis"><tt>localfile</tt></span> or a temporary file if <span class="docEmphasis"><tt>localfile</tt></span> not given; if present, <span class="docEmphasis"><tt>downloaStatusHook</tt></span> is a function that can receive download statistics</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>quote(</tt><span class="docEmphasis"><tt>urldata, safe</tt></span><tt>='/')</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Encodes invalid URL characters of <span class="docEmphasis"><tt>urldata</tt></span>; characters in <span class="docEmphasis"><tt>safe</tt></span> string are <span class="docEmphasis">not</span> encoded</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>quote_plus(</tt><span class="docEmphasis"><tt>urldata, safe</tt></span><tt>='/')</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Same as <tt>quote()</tt> except encodes spaces as plus (<tt>+</tt>) signs (rather than as <tt>%20</tt>)</p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>unquote(</tt><span class="docEmphasis"><tt>urldata</tt></span><tt>)</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Decodes encoded characters of <span class="docEmphasis"><tt>urldata</tt></span>
</P></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>unquote_plus(</tt><span class="docEmphasis"><tt>urldata</tt></span><tt>)</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Same as <tt>unquote()</tt> but converts plus signs to spaces</P></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>urlencode(</tt><span class="docEmphasis"><tt>dict</tt></span><tt>)</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Encodes the key-value pairs of <span class="docEmphasis"><tt>dict</tt></span> into a valid string for CGI queries and encodes the key and value strings with <tt>quote_plus()</tt>
</P></td></tr></table></P><br>


<a name="ch20lev2sec6"></a>
<h4 id="title-IDAEOIIE" class="docSection2Title">20.2.4. <tt>urllib2</tt> Module</h4>
<p class="docText">As mentioned in the previous section, <tt>urllib2</tt> can handle more complex URL opening. One example is for Web sites with basic authentication (login and password) requirements. The most straightforward solution to &quot;getting <a name="iddle1187"></a><a name="iddle2332"></a><a name="iddle3559"></a>past security&quot; is to use the extended <tt>net_loc</tt> URL component as described earlier in this chapter, i.e., <tt>http://user:passwd@www.python.org</tt>. The problem with this solution is that it is not programmatic. Using <tt>urllib2</tt>, however, we can tackle this problem in two different ways.</P>
<p class="docText">We can create a basic authentication handler (<tt>urllib2.HTTPBasicAuthHandler</tt>) and &quot;register&quot; a login password given the base URL and perhaps a <span class="docEmphasis">realm</span>, meaning a string defining the secure area of the Web site. (For more on realms, see RFC 2617 [HTTP Authentication: Basic and Digest Access Authentication]). Once this is done, you can &quot;install&quot; a URL-opener with this handler so that all URLs opened will use our handler.</P>
<p class="docText">The other alternative is to simulate typing the username and password when prompted by a browser and that is to send an HTTP client request with the appropriate authorization headers. In <a class="docLink" href="#ch20list01">Example 20.1</a> we can easily identify each of these two methods.</p>
<a name="ch20list01"></a><h5 id="title-IDA3PIIE" class="docExampleTitle">Example 20.1. HTTP Auth Client (<tt>urlopen-auth.py</tt>)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>


<p class="docText"><span class="docEmphasis">This script uses both techniques described above for basic authentication.</span></p>

<pre>   1     #!/usr/bin/env python
   2
   3     <span class="docEmphStrong">import</span> urllib2
   4
   5     LOGIN = 'wesc'
   6     PASSWD = "you'llNeverGuess"
   7     URL = 'http://localhost'
   8
   9     <span class="docEmphStrong">def</span> handler_version(url):
   10        <span class="docEmphStrong">from</span> urlparse <span class="docEmphStrong">import</span> urlparse <span class="docEmphStrong">as</span> up
   11        hdlr = urllib2.HTTPBasicAuthHandler()
   12        hdlr.add_password('Archives', up(url)[1], LOGIN, PASSWD)
   13        opener = urllib2.build_opener(hdlr)
   14        urllib2.install_opener(opener)
   15        <span class="docEmphStrong">return</span> url
   16
   17   <span class="docEmphStrong">def</span> request_version(url):
   18        <span class="docEmphStrong">from</span> base64 <span class="docEmphStrong">import</span> encodestring
   19        req = urllib2.Request(url)
   20        b64str = encodestring('%s:%s' % (LOGIN, PASSWD))[:-1]
   21        req.add_header("Authorization", "Basic %s" % b64str)
   22        <span class="docEmphStrong">return</span> req
   23
   24   <span class="docEmphStrong">for</span> funcType <span class="docEmphStrong">in</span>  ('handler', 'request'):
   25        <span class="docEmphStrong">print</span> '*** Using %s:' % funcType.upper()
   26        url = eval('%s_version')(URL)
   27        f = urllib2.urlopen(url)
   28        <span class="docEmphStrong">print</span> f.readline()
   29        f.close()</pre><br>

</td></tr></table></p>
<a name="ch20lev3sec10"></a>
<h5 id="title-IDAMSIIE" class="docSection3Title">Line-by-Line Explanation</H5>
<a name="ch20lev4sec1"></a>
<h5 id="title-IDAVSIIE" class="docSection4Title">Lines 17</H5>
<p class="docText">The usual setup plus some constants for the rest of the script to use.</p>

<a name="ch20lev4sec2"></a>
<H5 id="title-IDABTIIE" class="docSection4Title">Lines 915</h5>
<p class="docText">The &quot;handler&quot; version of the code allocates a basic handler class as described earlier, then adds the authentication information. The handler is then used to <a name="iddle4464"></a>create a URL-opener that is then installed so that all URLs opened will use the given authentication. This code was adapted from the official Python documentation for the <tt>urllib2</tt> module.</P>

<a name="ch20lev4sec3"></a>
<h5 id="title-IDAZTIIE" class="docSection4Title">Lines 1722</H5>
<p class="docText">The &quot;request&quot; version of our code just builds a <tt>Request</tt> object and adds the simple base64-encoded authentication header into our HTTP request. This request is then used to substitute the URL string when calling <tt>urlopen()</tt> upon returning back to &quot;main.&quot; Note that the original URL was built into the Request object, hence the reason why it was not a problem to replace it in the subsequent call to <tt>urllib2.urlopen()</tt>. This code was inspired by Mike Foord's and Lee Harr's recipes in the Python Cookbook located at:</P>
<blockquote>
<p class="docText"><a class="docLink" target="_blank" href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/305288">http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/305288</a></P>
<p class="docText"><a class="docLink" target="_blank" href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/267197">http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/267197</a></P>
</blockquote>
<p class="docText">It would have been great to have been able to use Harr's <tt>HTTPRealmFinder</tt> class so that we do not need to hardcode it in our example.</p>

<a name="ch20lev4sec4"></a>
<h5 id="title-IDA4UIIE" class="docSection4Title">Lines 2429</h5>
<p class="docText">The rest of this script just opens the given URL using both techniques and displays the first line (dumping the others) of the resulting HTML page returned by the server once authentication has been validated. Note that an HTTP error (and no HTML) would be returned if the authentication information is invalid.</P>
<p class="docText">The output should look something like this:</p>
<div class="docText"><pre>        $ python urlopen-auth.py
        Using handler:
        &lt;html&gt;

        Using request:
        &lt;html&gt;</pre></div><BR>
<p class="docText">In addition to the official Python documentation for <tt>urllib2</tt>, you may find this companion piece useful: <a class="docLink" target="_blank" href="http://www.voidspace.org.uk/python/articles/urllib2.shtml">http://www.voidspace.org.uk/python/articles/urllib2.shtml</a>.</p>




</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch20lev1sec1.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch20lev1sec3.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>