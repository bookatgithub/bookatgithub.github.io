<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>A Closer Look at the SELECT Statement and Its Clauses</title>
<link rel="STYLESHEET" type="text/css" href="images/css1.css">
<link rel="STYLESHEET" type="text/css" href="images/css2.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=BBL0032.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=BBL0034.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><div class="chapter">
<a name=""></a>
<div class="section">
<h2 class="first-section-title">
<a name="525"></a><a name="ch05le"></a>A Closer Look at the SELECT Statement and Its Clauses</h2>
<a name="526"></a><a name=""></a>
<p class="para">We just saw that you can retrieve every value stored in a base table by executing a simple query that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT * FROM [TableName]
</pre>
</div>
<p class="para">But what if you wanted to see only the values stored in two columns of a table? Or what if you wanted the data retrieved to be ordered alphabetically in ascending order? (Data is stored in a table in no particular order, and unless otherwise specified, a query only returns data in the order in which it is found.) How do you construct a query that retrieves only certain data values and returns those values in a very specific format? You do so by using a more advanced form of the <span class="fixed">SELECT</span> SQL statement to construct your query. The syntax for the form of the <span class="fixed">SELECT</span> statement that is used to construct more advanced queries is:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT &lt;DISTINCT&gt;
[*|[<i class="emphasis">Expression</i>] &lt;&lt;AS&gt; [<i class="emphasis">NewColumnName</i>]&gt;, ...]
FROM [[<i class="emphasis">TableName</i>]|[<i class="emphasis">ViewName</i>]
 &lt;&lt;AS&gt; [<i class="emphasis">CorrelationName</i>]&gt;, ...]
&lt;<i class="emphasis">WhereClause</i>&gt;
&lt;<i class="emphasis">GroupByClause</i>&gt;
&lt;<i class="emphasis">HavingClause</i>&gt;
&lt;<i class="emphasis">OrderByClause</i>&gt;
&lt;<i class="emphasis">FetchFirstClause</i>&gt;
</pre>
</div>
<p class="para">where:</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">Expression</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies one or more columns values that are to be returned when the <span class="fixed">SELECT</span> statement is executed. The value specified for this option can be any valid SQL language element; however, corresponding table or view column names are the most common elements used.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">NewColumnName</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Specifies a new column name to be used in place of the table or view column name specified in the result data set returned by the query.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">TableName</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies the name(s) assigned to one or more tables from which data is to be retrieved.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">ViewName</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies the name(s) assigned to one or more views from which data is to be retrieved.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">CorrelationName</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies a shorthand name that can be used when referencing the table or view the correlation name is associated with in any of the <span class="fixed">SELECT</span> statement clauses.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">WhereClause</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies a <span class="fixed">WHERE</span> clause that is to be used with the <span class="fixed">SELECT</span> statement.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">GroupByClause</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies a <span class="fixed">GROUP BY</span> clause that is to be used with the <span class="fixed">SELECT</span> statement.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">HavingClause</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies a <span class="fixed">HAVING</span> clause that is to be used with the <span class="fixed">SELECT</span> statement.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">OrderByClause</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies an <span class="fixed">ORDER BY</span> clause that is to be used with the <span class="fixed">SELECT</span> statement.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">FetchFirstClause</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies a <span class="fixed">FETCH FIRST</span> clause that is to be used with the <span class="fixed">SELECT</span> statement.</p>
</td>
</tr>
</tbody>
</table>
</div>
<a name="527"></a><a name=""></a>
<p class="para">Thus, if you wanted to retrieve all values for the columns named <span class="fixed">WORKDEPT</span> and <span class="fixed">JOB</span> from a table named <span class="fixed">EMPLOYEE</span>, you could do so by executing a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT workdept, job FROM employee
</pre>
</div>
<p class="para">And if you executed this query against the <span class="fixed">SAMPLE</span> database provided with DB2, you would get a result data set that looks something like this:</p>
<a name="528"></a><a name=""></a>
<div class="informalexample">
<pre class="literallayout">
WORKDEPT   JOB
--------   -----
A00        PRES
B01        MANAGER
C01        MANAGER
E01        MANAGER
D11        MANAGER
D21        MANAGER
E11        MANAGER
E21        MANAGER
A00        SALESREP
A00        CLERK
C01        ANALYST
C01        ANALYST
D11        DESIGNER
D11        DESIGNER
D11        DESIGNER
D11        DESIGNER
D11        DESIGNER
D11        DESIGNER
D11        DESIGNER
D11        DESIGNER
D21        CLERK
D21        CLERK
D21        CLERK
D21        CLERK
D21        CLERK
E11        OPERATOR
E11        OPERATOR
E11        OPERATOR
E11        OPERATOR
E21        FIELDREP
E21        FIELDREPE
21         FIELDREP
A00        SALESREP
A00        CLERK
C01        ANALYST
D11        DESIGNER
D11        DESIGNER
D21        CLERK
E11        OPERATOR
E11        OPERATOR
E21        FIELDREP
E21        FIELDREP
42 record(s) selected.
</pre>
</div>
<p class="para">If the <span class="fixed">DISTINCT</span> clause is specified with a <span class="fixed">SELECT</span> statement, duplicate rows are removed from the final result data set returned. Two rows are considered to be duplicates of one another if the value of every column of the first row is identical to the value of the corresponding column of the second row. For the purpose of <a name="529"></a><a name=""></a>determining whether or not two rows are identical, null values are considered equal. However, the <span class="fixed">DISTINCT</span> clause cannot be used if the result data set produced contains <span class="fixed">LONG VARCHAR, LONG VARGRAPHIC, BLOB, CLOB, DBCLOB,</span> or <span class="fixed">XML</span> data.</p>
<p class="para">Thus, if you were to execute the same <span class="fixed">SELECT</span> statement that was executed earlier with the <span class="fixed">DISTINCT</span> clause specified, the resulting statement would look something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT DISTINCT workdept, job FROM employee
</pre>
</div>
<p class="para">This time, when the query is executed, you should see a result data set that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
WORKDEPT   JOB
---        -------
C01        ANALYST
A00        CLERK
D21        CLERK
D11        DESIGNER
E21        FIELDREP
B01        MANAGER
C01        MANAGER
D11        MANAGER
D21        MANAGER
E01        MANAGER
E11        MANAGER
E21        MANAGER
E11        OPERATOR
A00        PRES
A00        SALESREP
15 record(s) selected.
</pre>
</div>
<p class="para">Now suppose you wanted to retrieve every unique value (no duplicates) for a column named <span class="fixed">JOB</span> in a table named <span class="fixed">EMPLOYEE</span>, and you wanted to change the name of the <span class="fixed">JOB</span> column in the result data set produced to <span class="fixed">TITLE</span>. You could do so by executing a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT DISTINCT job AS title FROM employee
</pre>
</div>
<p class="para">This time, when the query is executed, you should see a result data set that looks something like this:.</p>
<a name="530"></a><a name=""></a>
<div class="informalexample">
<pre class="literallayout">
TITLE
------
ANALYST
CLERK
DESIGNER
FIELDREP
MANAGER
OPERATOR
PRES
SALESREP
 8 record(s) selected.
</pre>
</div>
<p class="para">You could also produce this result data set by executing the same query and using the correlation name E for the table named <span class="fixed">EMPLOYEE</span>. The only difference is that, this time, the <span class="fixed">SELECT</span> statement would look like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT DISTINCT e.job AS title FROM employee AS e
</pre>
</div>
<p class="para">Notice that the column named <span class="fixed">JOB</span> is qualified with the correlation name E that was assigned to the table named <span class="fixed">EMPLOYEE</span>. In this example, the use of a correlation name is not really necessary, because data is being retrieved from only one table and no two columns in a table can have the same name. However, if data was being retrieved from two or more tables and if some of the columns in those tables had the same name, a qualifier would be needed to tell the DB2 Database Manager which table to retrieve data from for a particular column.</p>
<p class="para">If you were counting when we examined the syntax for the <span class="fixed">SELECT</span> statement earlier, you may have noticed that a single <span class="fixed">SELECT</span> statement can contain up to seven different clauses. These clauses are:</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">The <span class="fixed">DISTINCT</span> clause</p>
</li>
<li class="listitem">
<p class="first-para">The <span class="fixed">FROM</span> clause</p>
</li>
<li class="listitem">
<p class="first-para">The <span class="fixed">WHERE</span> clause</p>
</li>
<li class="listitem">
<p class="first-para">The <span class="fixed">GROUP BY</span> clause</p>
</li>
<li class="listitem">
<p class="first-para">The <span class="fixed">HAVING</span> clause</p>
</li>
<li class="listitem">
<p class="first-para">The <span class="fixed">ORDER BY</span> clause</p>
</li>
<li class="listitem">
<p class="first-para">The <span class="fixed">FETCH FIRST</span> clause</p>
</li>
</ul>
<p class="para">(Incidentally, these clauses are processed in the order shown.) We just saw how the <span class="fixed">DISTINCT</span> clause and the <span class="fixed">FROM</span> clause are used. Now let's turn our attention to the other clauses the <span class="fixed">SELECT</span> statement recognizes.</p>
<a name="531"></a><a name=""></a>
<div class="section">
<h3 class="sect3-title">
<a name="532"></a><a name="ch05le"></a>The WHERE Clause</h3>
<p class="first-para">The <span class="fixed">WHERE</span> clause is used to tell the DB2 Database Manager how to select the rows that are to be returned in the result data set produced in response to a query. When specified, the <span class="fixed">WHERE</span> clause is followed by a <i class="emphasis">search condition</i>, which is nothing more than a simple test that, when applied to a row of data, will evaluate to <span class="fixed">TRUE, FALSE</span>, or <span class="fixed">Unknown</span>. If this test evaluates to <span class="fixed">TRUE</span>, the row is returned in the result data set produced; if the test evaluates to <span class="fixed">FALSE</span> or <span class="fixed">Unknown</span>, the row is ignored.</p>
<p class="para">The search condition of a <span class="fixed">WHERE</span> clause is made up of one or more predicates that are used to make comparisons. Six common types of <span class="fixed">WHERE</span> clause predicates are recognized by DB2. They are:</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">Relational predicates</p>
</li>
<li class="listitem">
<p class="first-para">
<span class="fixed">BETWEEN</span>
</p>
</li>
<li class="listitem">
<p class="first-para">
<span class="fixed">LIKE</span>
</p>
</li>
<li class="listitem">
<p class="first-para">
<span class="fixed">IN</span>
</p>
</li>
<li class="listitem">
<p class="first-para">
<span class="fixed">EXISTS</span>
</p>
</li>
<li class="listitem">
<p class="first-para">
<span class="fixed">IS NULL</span>
</p>
</li>
</ul>
<p class="para">Each of these predicates can be used alone, or they can be combined using parentheses or Boolean operators such as <span class="fixed">AND</span> and <span class="fixed">OR</span>.</p>
<div class="section">
<h4 class="sect4-title">
<a name="533"></a><a name="ch05le"></a>Relational Predicates</h4>
<p class="first-para">The <i class="emphasis">relational predicates</i> (or <i class="emphasis">comparison operators</i>) consist of a set of special operators that are used to define a comparison relationship between the contents of a column and a constant value, the contents of two columns from the same table, or the contents of a column in one table with the contents of a column in another table. The following comparison operators are available:</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">&lt; (Less than)</p>
</li>
<li class="listitem">
<p class="first-para">&gt; (Greater than)</p>
</li>
<li class="listitem">
<p class="first-para">&lt;= (Less than or equal to)</p>
</li>
<li class="listitem">
<p class="first-para">&gt;= (Greater than or equal to)</p>
</li>
<li class="listitem">
<p class="first-para">= (Equal to)</p>
</li>
<li class="listitem">
<p class="first-para">&lt;&gt; (Not equal to)</p>
</li>
</ul>
<p class="para">Typically, relational predicates are used to include or exclude specific rows from the final result data set produced in response to a query. Thus, if you wanted to <a name="534"></a><a name="IDX-"></a>retrieve values from columns named <span class="fixed">EMPNO</span> and <span class="fixed">SALARY</span> in a table named <span class="fixed">EMPLOYEE </span>where the value for the <span class="fixed">SALARY</span> column is greater than or equal to $70,000.00, you could do so by executing a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT empno, salary
FROM employee
WHERE salary &gt;= 70000.00
</pre>
</div>
<p class="para">And if you executed this query against the <span class="fixed">SAMPLE</span> database provided with DB2, you would get a result data set that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
EMPNO   SALARY
----    -------
000010  152750.00
000020  94250.00
000030  98250.00
000050  80175.00
000060  72250.00
000070  96170.00
000090  89750.00
000100  86150.00
000130  73800.00
 9 record(s) selected.
</pre>
</div>
<p class="para">It is important to note that the data types of all items involved in a relational predicate comparison must be compatible, or the comparison will fail. If necessary, the built-in functions provided with DB2 can be used to make any conversions required. For example, if you wanted to retrieve values from columns named <span class="fixed">LASTNAME</span> and <span class="fixed">HIREDATE</span> in a table named <span class="fixed">EMPLOYEE</span> for every employee who was hired in December, you could do so by executing a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT lastname, hiredate
FROM employee
WHERE MONTHNAME(hiredate) = 'December'
</pre>
</div>
<p class="para">In this example, the built-in function <span class="fixed">MONTHNAME()</span> is used to produce a mixed-case character string containing the name of the month for the month portion of the date value stored in the <span class="fixed">HIREDATE</span> column. This string value is then compared with the string <span class="fixed">'December'</span> to determine which rows are to be returned in a result data set. If you executed this query against the <span class="fixed">SAMPLE</span> database provided with DB2, you should get a result data set that looks something like this:</p>
<a name="535"></a><a name=""></a>
<div class="informalexample">
<pre class="literallayout">
LASTNAME         HIREDATE
---------        ---------
O'CONNELL        12/05/1993
NICHOLLS         12/15/2006
MARINO           12/05/2004
NATZ             12/15/2006
MONTEVERDE       12/05/2004
 5 record(s) selected.
</pre>
</div>
</div>
</div>
<div class="section">
<h3 class="sect3-title">
<a name="536"></a><a name="ch05le"></a>The BETWEEN Predicate</h3>
<p class="first-para">The <span class="fixed">BETWEEN</span> predicate is used to define a comparison relationship in which the contents of a column are checked to see whether they fall within a specified range of values. As with relational predicates, the <span class="fixed">BETWEEN</span> predicate is used to include or exclude specific rows from the result data set produced in response to a query.</p>
<p class="para">Therefore, if you wanted to retrieve values for columns named <span class="fixed">EMPNO</span> and <span class="fixed">SALARY</span> in a table named <span class="fixed">EMPLOYEE</span> where the value for the <span class="fixed">SALARY</span> column is greater than or equal to $60,000.00 and less than or equal to $70,000.00, you could do so by executing a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT empno, salary
FROM employee
WHERE salary BETWEEN 60000.00 AND 70000.00
</pre>
</div>
<p class="para">And if you executed this query against the <span class="fixed">SAMPLE</span> database provided with DB2, you would get a result data set that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
EMPNO      SALARY
------     --------
000110     66500.00
000140     68420.00
000160     62250.00
000210     68270.00
200140     68420.00
200170     64680.00
200220     69840.00
 7 record(s) selected.
</pre>
</div>
<p class="para">If the <span class="fixed">NOT</span> (negation) operator is used in conjunction with the <span class="fixed">BETWEEN</span> predicate (or with any other predicate, for that matter), the meaning of the predicate is reversed. In this case, contents of a column are checked, and only values that fall outside the range of values specified are returned to the final result data set produced. Thus, if you wanted to retrieve values for columns named <span class="fixed">EMPNO</span> and <a name="537"></a><a name=""></a><span class="fixed">SALARY</span> in a table named <span class="fixed">EMPLOYEE</span> where the value for the <span class="fixed">SALARY</span> column is less than $20,000.00 or more than $90,000.00, you could do so by executing a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT empno, salary
FROM employee
WHERE salary NOT BETWEEN 20000.00 AND 90000.00
</pre>
</div>
<p class="para">When this query is executed, you should see a result data set that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
EMPNO    SALARY
-------  ---------
000010  152750.00
000020   94250.00
000030   98250.00
000070   96170.00
 4 record(s) selected.
</pre>
</div>
</div>
<div class="section">
<h3 class="sect3-title">
<a name="538"></a><a name="ch05le"></a>The LIKE Predicate</h3>
<p class="first-para">The <span class="fixed">LIKE</span> predicate is used to define a comparison relationship in which a character string value is checked to see whether it contains a specific pattern of characters. The pattern of characters specified can consist of regular alphanumeric characters and/or special metacharacters that are interpreted as follows:</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">The underscore character (<span class="fixed">_</span>) is treated as a wildcard character that stands for any single alphanumeric character.</p>
</li>
<li class="listitem">
<p class="first-para">The percent character (<span class="fixed">%</span>) is treated as a wildcard character that stands for any sequence of alphanumeric characters.</p>
</li>
</ul>
<p class="para">Thus, if you wanted to retrieve values for columns named <span class="fixed">EMPNO</span> and <span class="fixed">LASTNAME</span> in a table named <span class="fixed">EMPLOYEE</span> where the value for the <span class="fixed">LASTNAME</span> column begins with the letter S, you could do so by executing a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT empno, lastname
FROM employee
WHERE lastname LIKE 'S%'
<a name="539"></a><a name=""></a>
</pre>
</div>
<p class="para">If you executed this query against the <span class="fixed">SAMPLE</span> database provided with DB2, you should get a result data set that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
EMPNO    LASTNAME
------   --------
000060   STERN
000100   SPENSER
000180   SCOUTTEN
000250   SMITH
000280   SCHNEIDER
000300   SMITH
000310   SETRIGHT
200280   SCHWARTZ
200310   SPRINGER
 9 record(s) selected.
</pre>
</div>
<p class="para">When using wildcard characters, you must take care to ensure that they are placed in the appropriate location in the pattern string specified. Note that in the previous example, when the character string pattern <span class="fixed">'S%'</span> was specified, only records for employees whose last name begins with the letter S were returned. If the character string pattern used had been <span class="fixed">'%S%'</span>, records for employees whose last name <i class="emphasis">contains</i> the character S (anywhere in the name) would have been returned, and the result data set produced would have looked like this instead:</p>
<div class="informalexample">
<pre class="literallayout">
EMPNO    LASTNAME
------   -------
000010   HAAS
000020   THOMPSON
000060   STERN
000070   PULASKI
000090   HENDERSON
000100   SPENSER
000110   LUCCHESSI
000140   NICHOLLS
000150   ADAMSON
000170   YOSHIMURA
000180   SCOUTTEN
000210   JONES
000230   JEFFERSON
000250   SMITH
000260   JOHNSON
000280   SCHNEIDER
000300   SMITH
000310   SETRIGHT
200280   SCHWARTZ
200310   SPRINGER
  20 record(s) selected.
<a name="540"></a><a name=""></a>
</pre>
</div>
<p class="para">Likewise, you must also be careful about using uppercase and lowercase characters in pattern strings; if the data being examined is stored in a case-sensitive manner, the characters used in a pattern string must match the case that was used to store the value in the column being searched, or no matching records will be found.</p>
<table border="0" cellspacing="0" cellpadding="0" class="tip">
<tr>
<td valign="top" class="admon-check"></td><td valign="top" class="admon-title">Tip&nbsp;</td><td valign="top" class="admon-body">
<p class="first-para">Although the LIKE predicate provides a relatively easy way to search for data values, it should be used with caution; the overhead involved in processing a LIKE predicate is very high and can be extremely resource-intensive.</p>
</td>
</tr>
</table>
</div>
<div class="section">
<h3 class="sect3-title">
<a name="541"></a><a name="ch05le"></a>The IN Predicate</h3>
<p class="first-para">The <span class="fixed">IN</span> predicate is used to define a comparison relationship in which a value is checked to see whether it matches a value in a finite set of values. This finite set of values can consist of one or more literal values that are coded directly in the <span class="fixed">IN</span> predicate, or it can be composed of the non-null values found in a result data set produced by a subquery.</p>
<table border="0" cellspacing="0" cellpadding="0" class="tip">
<tr>
<td valign="top" class="admon-check"></td><td valign="top" class="admon-title">Tip&nbsp;</td><td valign="top" class="admon-body">
<p class="first-para">A subquery may include search conditions of its own, and these search conditions may in turn include their own subqueries. When such "nested" subqueries are processed, the DB2 Database Manager executes the innermost query first and uses the results to execute the next outer query, and so on until all nested queries have been processed.</p>
</td>
</tr>
</table>
<p class="para">Thus, if you wanted to retrieve values for columns named <span class="fixed">EMPNO</span> and <span class="fixed">WORKDEPT</span> in a table named <span class="fixed">EMPLOYEE</span> where the value for the <span class="fixed">WORKDEPT</span> column matches a value in a list of predefined department code values, you could do so by executing a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT lastname, workdept
FROM employee
WHERE workdept IN ('E11', 'E21')
<a name="542"></a><a name="IDX-"></a>
</pre>
</div>
<p class="para">And if you executed this query against the <span class="fixed">SAMPLE</span> database provided with DB2, you would get a result data set that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
LASTNAME      WORKDEPT
---------     --------
HENDERSON     E11
SCHNEIDER     E11
PARKER        E11
SMITH         E11
SETRIGHT      E11
SCHWARTZ      E11
SPRINGER      E11
SPENSER       E21
MEHTA         E21
LEE           E21
GOUNOT        E21
WONG          E21
ALONZO        E21
 13 record(s) selected.
</pre>
</div>
<p class="para">On the other hand, if you wanted to retrieve values for columns named <span class="fixed">LASTNAME</span> and <span class="fixed">WORKDEPT</span> in a table named <span class="fixed">EMPLOYEE</span> where the value for the <span class="fixed">WORKDEPT</span> column matches a value in a list of department codes for departments that are managed by department <span class="fixed">A00</span>, you could do so by executing a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT lastname, workdept
FROM employee
WHERE workdept IN
 (SELECT deptno FROM department WHERE admrdept = 'A00')
</pre>
</div>
<p class="para">When this query is executed, you should see a result data set that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
LASTNAME        WORKDEPT
--------        --------
HAAS            A00
THOMPSON        B01
KWAN            C01
GEYER           E01
LUCCHESSI       A00
O'CONNELL       A00
QUINTANA        C01
NICHOLLS        C01
HEMMINGER       A00
ORLANDO         A00
NATZ            C01
 11 record(s) selected.
<a name="543"></a><a name=""></a>
</pre>
</div>
<p class="last-para">In this case, the subquery <span class="fixed">SELECT deptno FROM department WHERE admrdept = 'A00'</span> produces a result data set containing the values A00, B01, C01, D01, and E01, and the main query evaluates each value found in the <span class="fixed">WORKDEPT</span> column of the <span class="fixed">EMPLOYEE</span> table to determine whether it matches one of the values in the result data set produced by the subquery. If there is a match, the record is returned.</p>
</div>
<div class="section">
<h3 class="sect3-title">
<a name="544"></a><a name="ch05le"></a>The EXISTS Predicate</h3>
<p class="first-para">The <span class="fixed">EXISTS</span> predicate is used to determine whether a particular value exists in a given result data set. The <span class="fixed">EXISTS</span> predicate is always followed by a subquery, and it returns either <span class="fixed">TRUE</span> or <span class="fixed">FALSE</span> to indicate whether a specific value is found in the result data set produced by the subquery. Thus, if you wanted to find out which values found in the column named <span class="fixed">DEPTNO</span> in a table named <span class="fixed">DEPARTMENT</span> are used in the column named <span class="fixed">WORKDEPT</span> in a table named <span class="fixed">EMPLOYEE</span>, you could do so by executing a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT deptno, deptname
FROM department
WHERE EXISTS
 (SELECT workdept FROM employee WHERE workdept = deptno)
</pre>
</div>
<p class="para">And if you executed this query against the <span class="fixed">SAMPLE</span> database provided with DB2, you should get a result data set that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
DEPTNO   DEPTNAME
----     ---------------------------
A00      SPIFFY COMPUTER SERVICE DIV.
B01      PLANNING
C01      INFORMATION CENTER
D11      MANUFACTURING SYSTEMS
D21      ADMINISTRATION SYSTEMS
E01      SUPPORT SERVICES
E11      OPERATIONS
E21      SOFTWARE SUPPORT
 8 record(s) selected.
</pre>
</div>
<p class="last-para">In most situations, the <span class="fixed">EXISTS</span> predicate is <span class="fixed">AND</span>ed with other predicates to determine final row selection.</p>
</div>
<div class="section">
<h3 class="sect3-title">
<a name="545"></a><a name="ch05lev"></a>The NULL Predicate</h3>
<p class="first-para">The <span class="fixed">NULL</span> predicate is used to determine whether or not a particular value is a <span class="fixed">NULL </span>value. So, if you wanted to retrieve values for columns named <span class="fixed">DEPTNO</span> and <span class="fixed">DEPTNAME </span><a name="546"></a><a name=""></a>in a table named <span class="fixed">DEPARTMENT</span> where the value for the <span class="fixed">MGRNO</span> column is a <span class="fixed">NULL</span> value, you could do so by executing a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT deptno, deptname
FROM department
WHERE mgrno IS NULL
</pre>
</div>
<p class="para">If you executed this query against the <span class="fixed">SAMPLE</span> database provided with DB2, you would get a result data set that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
DEPTNO   DEPTNAME
-----    ------------
D01      DEVELOPMENT CENTER
F22      BRANCH OFFICE F2
G22      BRANCH OFFICE G2
H22      BRANCH OFFICE H2
I22      BRANCH OFFICE I2
J22      BRANCH OFFICE J2
 6 record(s) selected.
</pre>
</div>
<p class="last-para">When using the <span class="fixed">NULL</span> predicate, it is important to keep in mind that <span class="fixed">NULL</span>, zero (0), and blank (<span class="fixed">""</span>) are three different values. <span class="fixed">NULL</span> is a special marker that is used to represent missing information, while zero and blank (empty string) are actual values that may be stored in a column to indicate a specific value or lack thereof. Moreover, some columns accept <span class="fixed">NULL</span> values, while other columns do not, depending upon their definition. So, before writing <span class="fixed">WHERE</span> clauses that check for <span class="fixed">NULL</span> values, make sure that the <span class="fixed">NULL</span> value is supported by the column(s) being queried.</p>
</div>
<div class="section">
<h3 class="sect3-title">
<a name="547"></a><a name="ch05lev"></a>The GROUP BY Clause</h3>
<p class="first-para">The <span class="fixed">GROUP BY</span> clause is used to tell the DB2 Database Manager how to organize rows of data returned in the result data set produced in response to a query. In its simplest form, the <span class="fixed">GROUP BY</span> clause is followed by a grouping expression that is usually one or more column names that identify columns found in the result data set to be organized. The <span class="fixed">GROUP BY</span> clause can also be used to specify what columns are to be grouped together to provide input to aggregate functions such as <span class="fixed">SUM()</span> and <span class="fixed">AVG()</span>.</p>
<p class="para">Thus, if you wanted to obtain the average salary for all departments found in a column named <span class="fixed">WORKDEPT</span>, using salary information stored in a column named <span class="fixed">SALARY</span> in a table named <span class="fixed">EMPLOYEE</span>, and you wanted to round the salary information <a name="548"></a><a name=""></a>retrieved to two decimal points and organize it by department, you could do so by executing a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT workdept, DECIMAL(AVG(salary), 9, 2) AS avg_salary
FROM
employee
GROUP BY workdept
</pre>
</div>
<p class="para">If you executed this query against the <span class="fixed">SAMPLE</span> database provided with DB2, you would get a result data set that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
WORKDEPT    AVG_SALARY
----        ----------
A00         70850.00
B01         94250.00
C01         77222.50
D11         58783.63
D21         51240.00
E01         80175.00
E11         45305.71
E21         47086.66
 8 record(s) selected.
</pre>
</div>
<p class="para">In this example, each row returned in the result data set produced contains the department code, along with the average salary for individuals who work in that department.</p>
<table border="0" cellspacing="0" cellpadding="0" class="tip">
<tr>
<td valign="top" class="admon-check"></td><td valign="top" class="admon-title">Tip&nbsp;</td><td valign="top" class="admon-body">
<p class="first-para">A common mistake that is often made when using the GROUP BY clause is the addition of nonaggregate columns to the list of columns that follow the GROUP BY clause. Since grouping is performed by combining all of the nonaggregate columns together into a single concatenated key and breaking whenever that key value changes, extraneous columns can cause unexpected breaks to occur.</p>
</td>
</tr>
</table>
</div>
<div class="section">
<h3 class="sect3-title">
<a name="549"></a><a name="ch05lev"></a>The GROUP BY ROLLUP Clause</h3>
<p class="first-para">The <span class="fixed">GROUP BY ROLLUP</span> clause is used to analyze a collection of data in a single dimension but at more than one level of detail. For example, you could group data by successively larger organizational units, such as team, department, and division, or by successively larger geographical units, such as city, county, state or province, country, and continent. Thus, if you were to change the <span class="fixed">GROUP BY</span> clause in the <a name="550"></a><a name=""></a>previous <span class="fixed">SELECT</span> statement to a <span class="fixed">GROUP BY ROLLUP</span> clause, you would end up with a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT workdept, DECIMAL(AVG(salary), 9, 2) AS avg_salary
FROM employee
GROUP BY ROLLUP (workdept)
</pre>
</div>
<p class="para">And if you executed this query against the <span class="fixed">SAMPLE</span> database provided with DB2, you should get a result data set that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
WORKDEPT    AVG_SALARY
--------    ---------
-           58155.35
A00         70850.00
B01         94250.00
C01         77222.50
D11         58783.63
D21         51240.00
E01         80175.00
E11         45305.71
E21         47086.66
 9 record(s) selected.
</pre>
</div>
<p class="para">This result data set contains average salary information for all employees found in the table named <span class="fixed">EMPLOYEES</span> regardless of which department they work in (the line in the result data set returned that has a null value assigned to the <span class="fixed">WORKDEPT</span> column), as well as average salary information for each department available (the remaining lines in the result data set returned).</p>
<p class="para">In this example, only one expression (known as the <i class="emphasis">grouping expression</i>) is specified in the <span class="fixed">GROUP BY ROLLUP</span> clause (in this case, the grouping expression is <span class="fixed">WORKDEPT)</span>. However, one or more grouping expressions can be specified in a single <span class="fixed">GROUP BY ROLLUP</span> clause (for example, <span class="fixed">GROUP BY ROLLUP</span> (<span class="fixed">workdept, division</span>)). When multiple grouping expressions are specified, the DB2 Database Manager groups the data by all grouping expressions used, then by all but the last grouping expression used, and so on. Then, it makes one final grouping that consists of the entire contents of the specified table. Therefore, when specifying multiple grouping expressions, it is important to ensure that they are listed in the appropriate order-if one kind of group is logically contained inside another (for example departments within a division), then that group should be listed after the group it is contained in (i.e., <span class="fixed">GROUP BY ROLLUP (department, division)</span>), never before.</p>
<a name="551"></a><a name=""></a>
</div>
<div class="section">
<h3 class="sect3-title">
<a name="552"></a><a name="ch05lev"></a>The GROUP BY CUBE Clause</h3>
<p class="first-para">The <span class="fixed">GROUP BY CUBE</span> clause is used to analyze a collection of data by organizing it into groups in multiple dimensions. Thus, if you were to execute a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT workdept, sex, DECIMAL(AVG(salary), 9, 2) AS avg_salary
FROM employee
GROUP BY CUBE (workdept, sex)
</pre>
</div>
<p class="para">You might see a result data set that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
WORKDEPT         SEX           AVG_SALARY
-----            ----          ----------
-                F             63243.68
-                M             53951.95
-                -             58155.35
A00              -             70850.00
B01              -             94250.00
C01              -             77222.50
D11              -             58783.63
D21              -             51240.00
E01              -             80175.00
E11              -             45305.71
E21              -             47086.66
A00              F             99625.00
A00              M             51666.66
B01              M             94250.00
C01              F             77222.50
D11              F             58317.50
D11              M             59050.00
D21              F             60266.66
D21              M             44470.00
E01              M             80175.00
E11              F             48810.00
E11              M             36545.00
E21              F             35370.00
E21              M             49430.00
 24 record(s) selected.
</pre>
</div>
<p class="para">This result set contains average salary information for each department found in the table named <span class="fixed">EMPLOYEE</span> (the lines that contain a null value in the <span class="fixed">SEX</span> column and a value in the <span class="fixed">WORKDEPT</span> column of the result data set returned), average salary information for all employees found in the table named <span class="fixed">EMPLOYEE</span> regardless of which department they work in (the line that contains a null value for both the <span class="fixed">SEX</span> and the <span class="fixed">WORKDEPT</span> column of the result data set returned), average salary information for each genter (the lines that contain values in the <span class="fixed">SEX</span> column and a <a name="553"></a><a name=""></a>null value in the <span class="fixed">WORKDEPT</span> column of the result data set returned), and average salary information for each genter in each department available (the remaining lines in the result data set returned).</p>
<p class="para">In other words, the data in the result data set produced is grouped:</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">By department only</p>
</li>
<li class="listitem">
<p class="first-para">By gender only</p>
</li>
<li class="listitem">
<p class="first-para">By gender and department</p>
</li>
<li class="listitem">
<p class="first-para">As a single group that contains all genders and all departments.</p>
</li>
</ul>
<p class="para">The term <span class="fixed">CUBE</span> is intended to suggest that data is being analyzed in more than one dimension, and as you can see in the previous example, data analysis was actually performed in two dimensions, which resulted in four types of groupings. Suppose the following <span class="fixed">SELECT</span> statement had been used instead:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT workdept, sex, job,
 DECIMAL(AVG(salary), 9, 2) AS avg_salary
FROM employee
GROUP BY CUBE (workdept, sex, job)
</pre>
</div>
<p class="last-para">Data analysis would have been performed in three dimensions, and the data would have been broken into eight types of groupings. Thus, the number of types of groups produced by a <span class="fixed">GROUP BY CUBE</span> operation can be determined by the formula: 2<i class="emphasis"><sup>n</sup></i> where <i class="emphasis">n</i> is the number of expressions used in the <span class="fixed">GROUP BY CUBE</span> clause.</p>
</div>
<div class="section">
<h3 class="sect3-title">
<a name="554"></a><a name="ch05lev"></a>The HAVING Clause</h3>
<p class="first-para">The <span class="fixed">HAVING</span> clause is used to apply further selection criteria to columns referenced in a <span class="fixed">GROUP BY</span> clause. This clause behaves like the <span class="fixed">WHERE</span> clause, except that it refers to data that has already been grouped (the <span class="fixed">HAVING</span> clause is used to tell the DB2 Database Manager how to select the rows to be returned in a result data set from rows that have already been grouped). And, like the <span class="fixed">WHERE</span> clause, the <span class="fixed">HAVING</span> clause is followed by a search condition that acts as a simple test that, when applied to a row of data, will evaluate to <span class="fixed">TRUE, FALSE,</span> or <span class="fixed">Unknown</span> . If this test evaluates to <span class="fixed">TRUE</span>, the row is returned in the result data set produced; if the test evaluates to <span class="fixed">FALSE</span> or <span class="fixed">Unknown</span>, the row is skipped. Because it behaves like a <span class="fixed">WHERE</span> clause, the search condition of a <span class="fixed">HAVING</span> clause can consist of the same predicates that are recognized by the <span class="fixed">WHERE</span> clause.</p>
<a name="555"></a><a name=""></a>
<p class="para">Thus, if you wanted to obtain the average salary for all departments found in a column named <span class="fixed">WORKDEPT</span>, using salary information stored in a column named <span class="fixed">SALARY</span> in a table named <span class="fixed">EMPLOYEE</span>, and you wanted to organize the data retrieved by department, but you are interested only in departments whose average salary is greater than $60,000.00, you could obtain this information by executing a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT workdept, DECIMAL(AVG(salary), 9, 2)
AS avg_salary FROM employee GROUP BY work
dept HAVING AVG(salary) &gt; 60000
</pre>
</div>
<p class="para">And if you executed this query against the <span class="fixed">SAMPLE</span> database provided with DB2, you would get a result data set that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
WORKDEPT      AVG_SALARY
--------      ----------
A00           70850.00
B01           94250.00
C01           77222.50
E01           80175.00
 4 record(s) selected.
</pre>
</div>
<p class="last-para">As you can see from the output provided, each row in the result data set produced contains the department ID for every department whose average salary for individuals working in that department is greater than $60,000.00, along with the average salary found for each department.</p>
</div>
<div class="section">
<h3 class="sect3-title">
<a name="556"></a><a name="ch05lev"></a>The ORDER BY Clause</h3>
<p class="first-para">The <span class="fixed">ORDER BY</span> clause is used to tell the DB2 Database Manager how to sort and order the rows that are to be returned in a result data set produced in response to a query. When specified, the <span class="fixed">ORDER BY</span> clause is followed by the name of one or more column(s) whose data values are to be sorted and a keyword that indicates the desired sort order. If the keyword <span class="fixed">ASC</span> follows the column's name, ascending order is used, and if the keyword <span class="fixed">DESC</span> follows the column name, descending order is used. Multiple columns can be used for sorting, and each column used can be ordered in either ascending or descending order. Furthermore, when more than one column is identified in an <span class="fixed">ORDER BY</span> clause, the corresponding result data set is sorted by the first column specified (the primary sort), then the sorted data is sorted again by the next column specified, and so on until the data has been sorted by each column specified.</p>
<a name="557"></a><a name="IDX-"></a>
<p class="para">Thus, if you wanted to retrieve values for columns named <span class="fixed">EMPNO, LASTNAME</span>, and <span class="fixed">WORKDEPT</span> in a table named <span class="fixed">EMPLOYEE</span> and you wanted the information sorted by <span class="fixed">WORKDEPT</span> in ascending order, followed by <span class="fixed">LASTNAME</span> in descending order, you could do so by executing a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT empno, lastname, workdept
FROM employee
ORDER BY workdept ASC, lastname DESC
</pre>
</div>
<p class="para">And if you executed this query against the <span class="fixed">SAMPLE</span> database provided with DB2, you would get a result data set that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
EMPNO     LASTNAME     WORKDEPT
------    --------     --------
200120    ORLANDO      A00
000120    O'CONNELL    A00
000110    LUCCHESSI    A00
200010    HEMMINGER    A00
000010    HAAS         A00
000020    THOMPSON     B01
000130    QUINTANA     C01
000140    NICHOLLS     C01
200140    NATZ         C01
000030    KWAN         C01
000170    YOSHIMURA    D11
200170    YAMAMOTO     D11
000190    WALKER       D11
000060    STERN        D11
000180    SCOUTTEN     D11
000160    PIANKA       D11
000220    LUTZ         D11
000210    JONES        D11
200220    JOHN         D11
000200    BROWN        D11
000150    ADAMSON      D11
000250    SMITH        D21
000070    PULASKI      D21
000270    PEREZ        D21
200240    MONTEVERDE   D21
000240    MARINO       D21
000260    JOHNSON      D21
000230    JEFFERSON    D21
000050    GEYER        E01
200310    SPRINGER     E11
000300    SMITH        E11
000310    SETRIGHT     E11
200280    SCHWARTZ     E11
000280    SCHNEIDER    E11
000290    PARKER       E11
000090    HENDERSON    E11
<a name="558"></a><a name=""></a>
EMPNO     LASTNAME      WORKDEPT
------    --------      --------
200330    WONG          E21
000100    SPENSER       E21
000320    MEHTA         E21
000330    LEE           E21
000340    GOUNOT        E21
200340    ALONZO        E21
  42 record(s) selected.
</pre>
</div>
<p class="para">Using the <span class="fixed">ORDER BY</span> clause is easy if the result data set consists only of named columns. But what happens if the result data set produced needs to be ordered by a summary column or a result column that cannot be specified by name? Because these situations can exist, the <span class="fixed">ORDER BY</span> clause allows an integer value that corresponds to a particular column's number to be used in place of the column name. When integer values are used, the first or leftmost column in the result data set produced is treated as column 1, the next is column 2, and so on. Therefore, the result data set produced by the previous query could have also been produced by executing a <span class="fixed">SELECT</span> statement that looks like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT empno, lastname, workdept
FROM employee
ORDER BY 1 ASC, 2 DESC
</pre>
</div>
<p class="last-para">It is important to note that even though integer values are primarily used in the <span class="fixed">ORDER BY</span> clause to specify columns that cannot be specified by name, they can be used in place of any column name.</p>
</div>
<div class="section">
<h3 class="sect3-title">
<a name="559"></a><a name="ch05lev"></a>The FETCH FIRST Clause</h3>
<p class="first-para">The <span class="fixed">FETCH FIRST</span> clause is used to limit the number of rows returned to the result data set produced in response to a query. When used, the <span class="fixed">FETCH FIRST</span> clause is followed by a positive integer value and the words <span class="fixed">ROWS ONLY</span>. This tells the DB2 Database Manager that the user/application executing the query does not want to see more than <i class="emphasis">n</i> number of rows, regardless of how many rows might exist in the result data set produced were the <span class="fixed">FETCH FIRST</span> clause not specified.</p>
<p class="para">Thus, if you wanted to retrieve just the first 10 values for columns named <span class="fixed">EMPNO, LASTNAME</span>, and <span class="fixed">WORKDEPT</span> from a table named <span class="fixed">EMPLOYEE</span>, you could do so by executing a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<a name="560"></a><a name="IDX-"></a>
<div class="informalexample">
<pre class="literallayout">
SELECT empno, lastname, workdept
FROM employee
FETCH FIRST 10 ROWS ONLY
</pre>
</div>
<p class="para">If you executed this query against the <span class="fixed">SAMPLE</span> database provided with DB2, you would get a result data set that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
EMPNO      LASTNAME      WORKDEPT
------     --------      --------
000010     HAAS          A00
000020     THOMPSON      B01
000030     KWAN          C01
000050     GEYER         E01
000060     STERN         D11
000070     PULASKI       D21
000090     HENDERSON     E11
000100     SPENSER       E21
000110     LUCCHESSI     A00
000120     O'CONNELL     A00
 10 record(s) selected.
</pre>
</div>
<p class="para">It is important to note that if you use other clauses to format the data before returning a specified number of rows, the actual values returned can be different. For example, suppose the previous <span class="fixed">SELECT</span> statement was modified to include an <span class="fixed">ORDER BY</span> clause like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT empno, lastname, workdept FROM employee
ORDER BY lastname FETCH FIRST 10 ROWS ONLY
</pre>
</div>
<p class="para">The result data set produced when the query is executed might look something like this:</p>
<div class="informalexample">
<pre class="literallayout">
EMPNO       LASTNAME       WORKDEPT
--------    --------       --------
000150      ADAMSON        D11
200340      ALONZO         E21
000200      BROWN          D11
000050      GEYER          E01
000340      GOUNOT         E21
000010      HAAS           A00
200010      HEMMINGER      A00
000090      HENDERSON      E11
000230      JEFFERSON      D21
200220      JOHN           D11
 10 record(s) selected.
<a name="561"></a><a name=""></a>
</pre>
</div>
</div>
<div class="section">
<h3 class="sect3-title">
<a name="562"></a><a name="ch05lev"></a>A Word About Common Table Expressions</h3>
<p class="first-para">
<i class="emphasis">Common table expressions</i> are mechanisms that are used to construct local temporary tables that reside in memory and exist only for the life of the SQL statement that defines them. (In fact, the table that is created in response to a common table expression can only be referenced by the SQL statement that created it.) Common table expressions are typically used:</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">In place of a view (when the creation of a view is undesirable, when general use of a view is not required, and when positioned update or delete operations are not used)</p>
</li>
<li class="listitem">
<p class="first-para">To enable grouping by a column that is derived from a subquery or a scalar function that performs some external action</p>
</li>
<li class="listitem">
<p class="first-para">When the desired result table is based on host variables</p>
</li>
<li class="listitem">
<p class="first-para">When the same result table needs to be used by several different queries</p>
</li>
<li class="listitem">
<p class="first-para">When the results of a query need to be derived using recursion</p>
</li>
</ul>
<p class="para">The syntax used to construct a common table expression is:</p>
<div class="informalexample">
<pre class="literallayout">
WITH [<i class="emphasis">TableName</i>]&lt;([<i class="emphasis">ColumnName</i>], ...])&gt;
AS([<i class="emphasis">SELECTStatement</i>])
</pre>
</div>
<p class="para">where:</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">TableName</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Specifies the name that is to be assigned to the temporary table to be created.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">ColumnName</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Specifies the name(s) to be assigned to one or more columns that are to be included in the temporary table to be created. Each column name specified must be unique and unqualified; if no column names are specified, the names derived from the result data set produced by the <i class="emphasis">SELECTStatement</i> specified will be used. If a list of column names is specified, the number of column names provided must match the number of columns that will be returned by the <span class="fixed">SELECT</span> statement used to create the temporary table. If a common table expression is recursive, or if the result data set produced by the <span class="fixed">SELECT</span> statement specified contains duplicate column names, column names must be specified.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">SELECTStatement</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies a <span class="fixed">SELECT</span> SQL statement that, when executed, will produce the data values to be added to the column(s) in the temporary table to be created.</p>
</td>
</tr>
</tbody>
</table>
</div>
<a name="563"></a><a name="IDX-"></a>
<p class="para">Thus, if you wanted to retrieve all values for the columns named <span class="fixed">EMPNO,LASTNAME, HIREDATE</span>, and <span class="fixed">SEX</span> from a table named <span class="fixed">EMPLOYEE</span> and store them in a common table that is then referenced in a query that is designed to obtain employee number and hire date information for all female employees working for the company, you could do so by executing an SQL statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
WITH
 emp_info (empno, lastname, hiredate, sex) AS
  (SELECT empno, lastname, hiredate, sex FROM employee)
SELECT empno, hiredate FROM emp_info WHERE sex = 'F'
</pre>
</div>
<p class="para">And if you executed this statement against the <span class="fixed">SAMPLE</span> database provided with DB2, you would get a result data set that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
EMPNO     HIREDATE
------    ----------
000010    01/01/1995
000030    04/05/2005
000070    09/30/2005
000090    08/15/2000
000130    07/28/2001
000140    12/15/2006
000160    10/11/2006
000180    07/07/2003
000220    08/29/1998
000260    09/11/2005
000270    09/30/2006
000280    03/24/1997
000310    09/12/1994
200010    01/01/1995
200140    12/15/2006
200220    08/29/2005
200280    03/24/1997
200310    09/12/1994
200330    02/23/2006
 19 record(s) selected.
<a name="564"></a><a name=""></a>
</pre>
</div>
<p class="last-para">Multiple common table expressions can be specified following a single <span class="fixed">WITH</span> keyword, and each common table expression specified can be referenced, by name, in the <span class="fixed">FROM</span> clause of subsequent common table expressions. However, if multiple common table expressions are defined within the same <span class="fixed">WITH</span> keyword, the table name assigned to each temporary table created must be unique from all other table names used in the <span class="fixed">SELECT</span> statement that creates them. It is also important to note that the table name assigned to the temporary table created by a common table expression will take precedence over any existing table, view, or alias (in the system catalog) that has the same qualified name; if the <span class="fixed">SELECT</span> SQL statement -references the original table, view, or alias, it will actually be working with the temporary table created. (Existing tables, views, and aliases whose names match that of the temporary table are not altered but are simply no longer accessible.)</p>
</div>
<div class="section">
<h3 class="sect3-title">
<a name="565"></a><a name="ch05lev"></a>A Word About CASE Expressions</h3>
<p class="first-para">One efficient and concise way to display compared values in a readable format is to use one or more <span class="fixed">CASE</span> expressions in the selection list of a query. Each <span class="fixed">CASE</span> operation evaluates a specified expression and supplies a different value, depending on whether a certain condition is met. A <span class="fixed">CASE</span> expression can take one of two forms: <i class="emphasis">simple</i> or <i class="emphasis">searched</i>. The basic syntax used to create a simple <span class="fixed">CASE</span> expression is:</p>
<div class="informalexample">
<pre class="literallayout">
CASE [<i class="emphasis">Expression1</i>]
  [WHEN [<i class="emphasis">Expression2</i>] THEN [<i class="emphasis">Result1</i>], ...]
ELSE [<i class="emphasis">Result2</i>]
&lt;END&gt;
</pre>
</div>
<p class="para">where:</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">Expression1</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies an expression or value that is to be compared to one or more <i class="emphasis">Expression2</i> expressions or values.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">Expression2</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies one or more expressions or values that, when compared to <i class="emphasis">Expression1</i>, evaluate to <span class="fixed">TRUE</span> or <span class="fixed">FALSE</span>.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">Result1</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies a value to be used when a search condition evaluates to <span class="fixed">TRUE</span>.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">Result2</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies a value to be used when a search condition evaluates to <span class="fixed">FALSE</span>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<a name="566"></a><a name="IDX-"></a>
<p class="para">Thus, if you wanted to retrieve values for columns named <span class="fixed">EMPNO, LASTNAME,</span> and <span class="fixed">DIVISION</span> from a table named <span class="fixed">EMPLOYEE</span>, and you knew that the first character of the work department code associated with an employee represents a division within the company, you could use a simple <span class="fixed">CASE</span> expression to translate the codes and provide a complete division name to which each employee belongs by executing an SQL statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT empno, lastname,
  CASE SUBSTR(workdept, 1, 1)
   WHEN 'A' THEN 'ADMINISTRATION'
   WHEN 'B' THEN 'HUMAN RESOURCES'
   WHEN 'C' THEN 'DESIGN'
   WHEN 'D' THEN 'OPERATIONS'
   ELSE 'UNKNOWN DEPARTMENT'
  END AS division
FROM employee
</pre>
</div>
<p class="para">If you executed this statement against the <span class="fixed">SAMPLE</span> database provided with DB2, you would get a result data set that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
EMPNO     LASTNAME    DIVISION
------    ----------  ------------------
000010    HAAS        DMINISTRATION
000020    THOMPSON    HUMAN RESOURCES
000030    KWAN        DESIGN
000050    GEYER       UNKNOWN DEPARTMENT
000060    STERN       OPERATIONS
000070    PULASKI     OPERATIONS
000090    HENDERSON   UNKNOWN DEPARTMENT
000100    SPENSER     UNKNOWN DEPARTMENT
000110    LUCCHESSI   ADMINISTRATION
000120    O'CONNELL   ADMINISTRATION
000130    QUINTANA    DESIGN
000140    NICHOLLS    DESIGN
000150    ADAMSON     OPERATIONS
000160    PIANKA      OPERATIONS
000170    YOSHIMURA   OPERATIONS
000180    SCOUTTEN    OPERATIONS
000190    WALKER      OPERATIONS
000200    BROWN       OPERATIONS
000210    JONES       OPERATIONS
000220    LUTZ        OPERATIONS
000230    JEFFERSON   OPERATIONS
000240    MARINO      OPERATIONS
000250    SMITH       OPERATIONS
000260    JOHNSON     OPERATIONS
000270    PEREZ       OPERATIONS
000280    SCHNEIDER   UNKNOWN DEPARTMENT
<a name="567"></a><a name=""></a>
EMPNO     LASTNAME     DIVISION
------    ---------    -------------------
000290    PARKER       UNKNOWN DEPARTMENT
000300    SMITH        UNKNOWN DEPARTMENT
000310    SETRIGHT     UNKNOWN DEPARTMENT
000320    MEHTA        UNKNOWN DEPARTMENT
000330    LEE          UNKNOWN DEPARTMENT
000340    GOUNOT       UNKNOWN DEPARTMENT
200010    HEMMINGER    ADMINISTRATION
200120    ORLANDO      ADMINISTRATION
200140    NATZ         DESIGN
200170    YAMAMOTO     OPERATIONS
200220    JOHN         OPERATIONS
200240    MONTEVERDE   OPERATIONS
200280    SCHWARTZ     UNKNOWN DEPARTMENT
200310    SPRINGER     UNKNOWN DEPARTMENT
200330    WONG         UNKNOWN DEPARTMENT
200340    ALONZO       UNKNOWN DEPARTMENT
  42 record(s) selected.
</pre>
</div>
<p class="para">The syntax used to create a searched <span class="fixed">CASE</span> expression is:</p>
<div class="informalexample">
<pre class="literallayout">
CASE
  [WHEN [<i class="emphasis">SearchCondition</i>] THEN [<i class="emphasis">Result1</i>], ...]
   ELSE [<i class="emphasis">Result2</i>]
&lt;END&gt;
</pre>
</div>
<p class="para">where:</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">SearchCondition</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies one or more logical conditions that evaluate to <span class="fixed">TRUE</span> or <span class="fixed">FALSE</span>.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">Result1</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies a value to be used when a search condition evaluates to <span class="fixed">TRUE</span>.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">Result2</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies a value to be used when a search condition evaluates to <span class="fixed">FALSE</span>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">Thus, if you wanted to retrieve values for columns named <span class="fixed">EMPNO, LASTNAME,JOB</span>, and <span class="fixed">SALARY</span> from a table named <span class="fixed">EMPLOYEE</span>, and you wanted to calculate salary increases based on the job each employee performs, you could use a searched <span class="fixed">CASE</span> expression to provide new salary values based on the job held by executing an SQL statement that looks something like this:</p>
<a name="568"></a><a name="IDX-"></a>
<div class="informalexample">
<pre class="literallayout">
SELECT empno, lastname, job, salary,
  CASE
   WHEN job IN ('MANAGER', 'SUPRVSR') THEN salary * 1.10
   WHEN job IN ('DBA', 'SYS PROG') THEN salary * 1.08
   WHEN job = 'PRGRMR' THEN salary * 1.05
   ELSE salary * 1.035
  END as new_salary
FROM employee
</pre>
</div>
<p class="para">And if you executed this statement, you should get a result data set that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
EMPNO    LASTNAME    JOB         SALARY       NEW_SALARY
------   --------    --------    ------       ----------
000010   HAAS        PRES        152750.00    158096.25000
000020   THOMPSON    MANAGER     94250.00     103675.00000
000030   KWAN        MANAGER     98250.00     108075.00000
000050   GEYER       MANAGER     80175.00     88192.50000
000060   STERN       MANAGER     72250.00     79475.00000
000070   PULASKI     MANAGER     96170.00     105787.00000
000090   HENDERSON   MANAGER     89750.00     98725.00000
000100   SPENSER     MANAGER     86150.00     94765.00000
000110   LUCCHESSI   SALESREP    66500.00     68827.50000
000120   O'CONNELL   CLERK       49250.00     50973.75000
000130   QUINTANA    ANALYST     73800.00     76383.00000
000140   NICHOLLS    ANALYST     68420.00     70814.70000
000150   ADAMSON     DESIGNER    55280.00     57214.80000
000160   PIANKA      DESIGNER    62250.00     64428.75000
000170   YOSHIMURA   DESIGNER    44680.00     46243.80000
000180   SCOUTTEN    DESIGNER    51340.00     53136.90000
000190   WALKER      DESIGNER    50450.00     52215.75000
000200   BROWN       DESIGNER    57740.00     59760.90000
000210   JONES       DESIGNER    68270.00     70659.45000
000220   LUTZ        DESIGNER    49840.00     51584.40000
000230   JEFFERSON   CLERK       42180.00     43656.30000
000240   MARINO      CLERK       48760.00     50466.60000
000250   SMITH       CLERK       49180.00     50901.30000
000260   JOHNSON     CLERK       47250.00     48903.75000
000270   PEREZ       CLERK       37380.00     38688.30000
000280   SCHNEIDER   OPERATOR    36250.00     37518.75000
000290   PARKER      OPERATOR    35340.00     36576.90000
000300   SMITH       OPERATOR    37750.00     39071.25000
000310   SETRIGHT    OPERATOR    35900.00     37156.50000
000320   MEHTA       FIELDREP    39950.00     41348.25000
000330   LEE         FIELDREP    45370.00     46957.95000
000340   GOUNOT      FIELDREP    43840.00     45374.40000
200010   HEMMINGER   SALESREP    46500.00     48127.50000
200120   ORLANDO     CLERK       39250.00     40623.75000
200140   NATZ        ANALYST     68420.00     70814.70000
200170   YAMAMOTO    DESIGNER    64680.00     66943.80000
<a name="569"></a><a name=""></a>
EMPNO    LASTNAME    JOB          SALARY       NEW_SALARY
------   --------    -------- -   -----        ----------
200220   JOHN        DESIGNER     69840.00     72284.40000
200240   MONTEVERDE  CLERK        37760.00     39081.60000
200280   SCHWARTZ    OPERATOR     46250.00     47868.75000
200310   SPRINGER    OPERATOR     35900.00     37156.50000
200330   WONG        FIELDREP     35370.00     36607.95000
200340   ALONZO      FIELDREP     31840.00     32954.40000
 42 record(s) selected.
</pre>
</div>
<p class="last-para">As you can see from these examples, the value provided by a <span class="fixed">CASE</span> expression is the value of the result-expression (<i class="emphasis">Result1</i>) that follows the first (leftmost) case that evaluates to <span class="fixed">TRUE</span>. If no case evaluates to <span class="fixed">TRUE</span> and the <span class="fixed">ELSE</span> keyword is present, then the result is the value of the second result-expression (<i class="emphasis">Result2</i>). If no case evaluates to <span class="fixed">TRUE</span> and the <span class="fixed">ELSE</span> keyword is not present, then the result is null. It is important to note that when a case evaluates to <span class="fixed">Unknown</span> (because of null values), the case is not true and is treated the same as a case that evaluates to <span class="fixed">FALSE</span>. And it goes without saying that the data type of the search condition specified must be comparable to the data type of each result-expression used.</p>
</div>
<div class="section">
<h3 class="sect3-title">
<a name="570"></a><a name="ch05lev"></a>Joining Tables</h3>
<p class="first-para">So far, all the examples we have looked at have involved only one table. However, one of the more powerful features of the <span class="fixed">SELECT</span> statement (and the element that makes data normalization possible) is the ability to retrieve data from two or more tables by performing what is known as a <i class="emphasis">join operation</i>. In its simplest form, the syntax for a <span class="fixed">SELECT</span> statement that performs a join operation is:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT * FROM [ [<i class="emphasis">TableName</i>]|[<i class="emphasis">ViewName</i>], ...]
</pre>
</div>
<p class="para">where:</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">TableName</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies the name assigned to each of two or more tables from which data is to be retrieved.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">ViewName</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies the name assigned to each of two or more views from which data is to be retrieved.</p>
</td>
</tr>
</tbody>
</table>
</div>
<a name="571"></a><a name=""></a>
<p class="para">Consequently, if you wanted to retrieve all values stored in two base tables named <span class="fixed">CL_SCHED</span> and <span class="fixed">ORG</span>, you could do so by executing a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT * FROM cl_sched, org
</pre>
</div>
<p class="para">When such a <span class="fixed">SELECT</span> statement is executed, the result data set produced will contain all possible combinations of the rows found in each table specified (otherwise known as a <i class="emphasis">Cartesian product</i>). Every row in the result data set produced is a row from the first table referenced concatenated with a row from the second table referenced, concatenated in turn with a row from the third table referenced, and so on. The total number of rows found in the result data set produced is the product of the number of rows in all the individual table references. Thus, if the table named <span class="fixed">CL_SCHED</span> in our previous example contains five rows and the table named <span class="fixed">ORG</span> contains eight rows, the result data set produced by the statement "<span class="fixed">SELECT * FROM cl_sched, org"</span> will consist of 40 rows (5 &times; 8 = 40).</p>
<table border="0" cellspacing="0" cellpadding="0" class="tip">
<tr>
<td valign="top" class="admon-check"></td><td valign="top" class="admon-title">Tip&nbsp;</td><td valign="top" class="admon-body">
<p class="first-para">A Cartesian product join operation should be used with extreme caution when working with large tables; the amount of resources required to perform such a join operation can have a serious negative impact on performance.</p>
</td>
</tr>
</table>
<p class="para">A more common join operation involves collecting data from two or more tables that have one specific column in common and combining the results to create a result data set. The syntax for a <span class="fixed">SELECT</span> statement that performs this type of join operation is:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT
[*|[<i class="emphasis">Expression</i>] &lt;&lt;AS&gt; [<i class="emphasis">NewColumnName</i>]&gt;, ...]
FROM [[<i class="emphasis">TableName</i>] &lt;&lt;AS&gt; [<i class="emphasis">CorrelationName</i>]&gt;, ...]
[<i class="emphasis">JoinCondition</i>]
</pre>
</div>
<p class="para">where:</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">Expression</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies one or more columns whose values are to be returned when the <span class="fixed">SELECT</span> statement is executed. The value specified for this option can be any valid SQL language element; however, corresponding table or view column names are commonly used.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">NewColumnName</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies a new column name that is to be used in place of the corresponding table or view column name specified in the result data set returned by the <span class="fixed">SELECT</span> statement.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">TableName</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies the name(s) assigned to one or more tables from which data is to be retrieved.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">CorrelationName</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies a shorthand name that can be used when referencing the table name specified in the <i class="emphasis">TableName</i> parameter.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">JoinCondition</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies the condition to be used to join the tables specified. Typically, this is a <span class="fixed">WHERE</span> clause in which the values of a column in one table are compared with the values of a similar column in another table.</p>
</td>
</tr>
</tbody>
</table>
</div>
<a name="572"></a><a name="IDX-"></a>
<p class="para">Thus, a simple join operation could be conducted by executing a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT lastname, deptname
FROM employee e, department d
WHERE e.workdept = d.deptno
</pre>
</div>
<p class="para">If you executed this query against the <span class="fixed">SAMPLE</span> database provided with DB2, you would get a result data set that looks like this:</p>
<div class="informalexample">
<pre class="literallayout">
LASTNAME       DEPTNAME
--------       ---------------------------
HAAS           SPIFFY COMPUTER SERVICE DIV.
THOMPSON       PLANNING
KWAN           INFORMATION CENTER
GEYER          SUPPORT SERVICES
STERN          MANUFACTURING SYSTEMS
PULASKI        ADMINISTRATION SYSTEMS
HENDERSON      OPERATIONS
SPENSER        SOFTWARE SUPPORT
LUCCHESSI      SPIFFY COMPUTER SERVICE DIV.
O'CONNELL      SPIFFY COMPUTER SERVICE DIV.
<a name="573"></a><a name=""></a>
LASTNAME       DEPTNAME
--------       ---------------------------
QUINTANA       INFORMATION CENTER
NICHOLLS       INFORMATION CENTER
ADAMSON        MANUFACTURING SYSTEMS
PIANKA         MANUFACTURING SYSTEMS
YOSHIMURA      MANUFACTURING SYSTEMS
SCOUTTEN       MANUFACTURING SYSTEMS
WALKER         MANUFACTURING SYSTEMS
BROWN          MANUFACTURING SYSTEMS
JONES          MANUFACTURING SYSTEMS
LUTZ           MANUFACTURING SYSTEMS
EFFERSON       ADMINISTRATION SYSTEMS
MARINO         ADMINISTRATION SYSTEMS
SMITH          ADMINISTRATION SYSTEMS
JOHNSON        ADMINISTRATION SYSTEMS
PEREZ          ADMINISTRATION SYSTEMS
SCHNEIDER      OPERATIONS
PARKER         OPERATIONS
SMITH          OPERATIONS
SETRIGHT       OPERATIONS
MEHTA          SOFTWARE SUPPORT
LEE            SOFTWARE SUPPORT
GOUNOT         SOFTWARE SUPPORT
HEMMINGER      SPIFFY COMPUTER SERVICE DIV.
ORLANDO        SPIFFY COMPUTER SERVICE DIV.
NATZ           INFORMATION CENTER
YAMAMOTO       MANUFACTURING SYSTEMS
JOHN           MANUFACTURING SYSTEMS
MONTEVERDE     ADMINISTRATION SYSTEMS
SCHWARTZ       OPERATIONS
SPRINGER       OPERATIONS
WONG           SOFTWARE SUPPORT
ALONZO         SOFTWARE SUPPORT
 42 record(s) selected.
</pre>
</div>
<p class="para">This type of join is referred to as an <i class="emphasis">inner join</i>. Aside from a Cartesian product, only two types of joins can exist: inner joins and <i class="emphasis">outer joins</i>. And as you might imagine, there is a significant difference between the two.</p>
<div class="section">
<h4 class="sect4-title">
<a name="574"></a><a name="ch05le"></a>Inner joins</h4>
<p class="first-para">After a Cartesian product, an inner join is the simplest type of join operation that can be performed. An inner join can be thought of as the cross product of two tables, in which every row in one table that has a corresponding row in another table is combined with that row to produce a new record. This type of join works well as long as every row in the first table has a corresponding row in the second <a name="575"></a><a name="IDX-"></a>table. However, if this is not the case, the result table produced may be missing rows found in either or both of the tables that were joined. In the last example, we saw the <span class="fixed">SELECT</span> statement syntax that is commonly used to perform inner join operations. However, the following syntax can also be used to create a <span class="fixed">SELECT</span> statement that performs an inner join operation:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT
[*|[<i class="emphasis">Expression</i>] &lt;&lt;AS&gt; [<i class="emphasis">NewColumnName</i>]&gt; ,...]
FROM [[<i class="emphasis">TableName1</i>] &lt;&lt;AS&gt; [<i class="emphasis">CorrelationName1</i>]&gt;]
&lt;INNER&gt; JOIN [[<i class="emphasis">TableName2</i>] &lt;&lt;AS&gt; [<i class="emphasis">CorrelationName2</i>]&gt;]
ON [<i class="emphasis">JoinCondition</i>]
</pre>
</div>
<p class="para">where:</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">Expression</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies one or more columns whose values are to be returned when the <span class="fixed">SELECT</span> statement is executed. The value specified for this option can be any valid SQL language element; however, corresponding table or view column names are commonly used.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">NewColumnName</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies a new column name to be used in place of the corresponding table or view column name specified in the result data set returned by the <span class="fixed">SELECT</span> statement.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">TableName1</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies the name assigned to the first table from which data is to be retrieved.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">CorrelationName1</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies a shorthand name that can be used when referencing the leftmost table of the join operation.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">TableName2</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies the name assigned to the second table from which data is to be retrieved.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">CorrelationName2</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies a shorthand name that can be used when referencing the rightmost table of the join operation.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">JoinCondition</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies the condition to be used to join the two tables specified.</p>
</td>
</tr>
</tbody>
</table>
</div>
<a name="576"></a><a name=""></a>
<p class="para">Consequently, the same inner join operation we looked at earlier could be conducted by executing a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT lastname, deptname
FROM employee e INNER JOIN department d
ON e.workdept = d.deptno
</pre>
</div>
<p class="para">
<a class="internaljump" href="#ch0">Figure 5-1</a> illustrates how such an inner join operation would work.</p>
<div class="figure">
<a name="577"></a><a name="ch0"></a><span class="figuremediaobject"><a href="images/fig319_01_0.jpg" NAME="IMG_83" target="_parent"><img alt="Image from book" id="IMG_83" src="images/fig319_01.jpg" height="374" width="350" title="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 5-1: </span>A simple inner join operation.</span>
</div>
<a name="578"></a><a name=""></a>
</div>
<div class="section">
<h4 class="sect4-title">
<a name="579"></a><a name="ch05le"></a>Outer joins</h4>
<p class="first-para">Outer join operations are used when a join operation is required and any rows that would normally be eliminated by an inner join operation need to be preserved. With DB2, three types of outer joins are available:</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="para">
<b>Left outer join.</b> When a left outer join operation is performed, rows that would have been returned by an inner join operation, together with all rows stored in the leftmost table of the join operation (i.e., the table listed first in the <span class="fixed">OUTER JOIN</span> clause) that would have been eliminated by the inner join operation, are returned in the result data set produced.</p>
</li>
<li class="listitem">
<p class="para">
<b>Right outer join.</b> When a right outer join operation is performed, rows that would have been returned by an inner join operation, together with all rows stored in the rightmost table of the join operation (i.e., the table listed last in the <span class="fixed">OUTER JOIN</span> clause) that would have been eliminated by the inner join operation, are returned in the result data set produced.</p>
</li>
<li class="listitem">
<p class="para">
<b>Full outer join.</b> When a full outer join operation is performed, rows that would have been returned by an inner join operation, together with all rows stored in both tables of the join operation that would have been eliminated by the inner join operation, are returned in the result data set produced.</p>
</li>
</ul>
<p class="para">To understand the basic principles behind an outer join operation, it helps to look at an example. Suppose Table A and Table B are joined by an ordinary inner join operation. Any row in either Table A or Table B that does not have a matching row in the other table (according to the rules of the join condition) is eliminated from the final result data set produced. By contrast, if Table A and Table B are joined by an outer join, any row in either Table A or Table B that does not contain a matching row in the other table is included in the result data set (exactly once), and columns in that row that would have contained matching values from the other table are empty. Thus, an outer join operation adds nonmatching rows to the final result data set produced whereas an inner join operation excludes them. A left outer join of Table A with Table B preserves all nonmatching rows found in Table A, a right outer join of Table A with Table B preserves all nonmatching rows found in Table B, and a full outer join preserves nonmatching rows found in both Table A and Table B.</p>
<a name="580"></a><a name=""></a>
<p class="para">
<a class="internaljump" href="#ch0">Figure 5-2</a> illustrates how a left outer join operation works; <a class="internaljump" href="#ch0">Figure 5-3</a> illustrates how a right outer join operation works; and <a class="internaljump" href="#ch0">Figure 5-4</a> illustrates how a full join operation works.</p>
<div class="figure">
<a name="581"></a><a name="ch0"></a><span class="figuremediaobject"><a href="images/fig321_01_0.jpg" NAME="IMG_84" target="_parent"><img alt="Image from book" id="IMG_84" src="images/fig321_01.jpg" height="375" width="350" title="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 5-2: </span>A simple left outer join operation.</span>
</div>
<div class="figure">
<a name="582"></a><a name="ch0"></a><span class="figuremediaobject"><a href="images/fig322_01_0.jpg" NAME="IMG_85" target="_parent"><img alt="Image from book" id="IMG_85" src="images/fig322_01.jpg" height="379" width="350" title="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 5-3: </span>A simple right outer join operation.</span>
</div>
<div class="figure">
<a name="583"></a><a name="ch0"></a><span class="figuremediaobject"><a href="images/fig322_02_0.jpg" NAME="IMG_86" target="_parent"><img alt="Image from book" id="IMG_86" src="images/fig322_02.jpg" height="329" width="299" title="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 5-4: </span>A simple full outer join operation.</span>
</div>
<a name="584"></a><a name=""></a><a name="585"></a><a name=""></a>
<p class="para">The basic syntax used to create a <span class="fixed">SELECT</span> statement that performs an outer join operation is:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT
[*|[<i class="emphasis">Expression</i>] &lt;&lt;AS&gt; [<i class="emphasis">NewColumnName</i>]&gt;, ...]
FROM [[<i class="emphasis">TableName1</i>] &lt;&lt;AS&gt; [<i class="emphasis">CorrelationName1</i>]&gt;]
[LEFT | RIGHT | FULL] OUTER JOIN
[[<i class="emphasis">TableName2</i>] &lt;&lt;AS&gt; [<i class="emphasis">CorrelationName2</i>]&gt;]
ON [<i class="emphasis">JoinCondition</i>]
</pre>
</div>
<p class="para">where:</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">Expression</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies one or more columns whose values are to be returned when the <span class="fixed">SELECT</span> statement is executed. The value specified for this option can be any valid SQL language element; however, corresponding table or view column names are commonly used.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">NewColumnName</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies a new column name that is to be used in place of the corresponding table or view column name specified in the result data set returned by the <span class="fixed">SELECT</span> statement.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">TableName1</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies the name assigned to the first table from which data is to be retrieved. This table is considered the "left" table in an outer join.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">CorrelationName1</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies a shorthand name that can be used when referencing the leftmost table of the join operation.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">TableName2</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies the name assigned to the second table from which data is to be retrieved. This table is considered the "right" table in an outer join.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">CorrelationName2</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies a shorthand name that can be used when referencing the rightmost table of the join operation.</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">JoinCondition</i>
</p>
</td><td class="td" align="left">
<p class="table-para">Identifies the condition to be used to join the two tables specified.</p>
</td>
</tr>
</tbody>
</table>
</div>
<a name="586"></a><a name=""></a>
<p class="para">Thus, a simple left outer join operation could be conducted by executing a <span class="fixed">SELECT </span>statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT lastname, deptname
FROM employee e LEFT OUTER JOIN department d
ON e.workdept = d.deptno
</pre>
</div>
<p class="para">A simple right outer join operation could be conducted by executing a <span class="fixed">SELECT </span>statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT lastname, deptname
FROM employee e RIGHT OUTER JOIN department d
ON e.workdept = d.deptno
</pre>
</div>
<p class="para">And finally, a simple full outer join operation could be conducted by executing a <span class="fixed">SELECT</span> statement that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT lastname, deptname
FROM employee e FULL OUTER JOIN department d
ON e.workdept = d.deptno
</pre>
</div>
<p class="para">If you executed this query against the <span class="fixed">SAMPLE</span> database provided with DB2, you would get a result data set that looks something like this:</p>
<div class="informalexample">
<pre class="literallayout">
LASTNAME         DEPTNAME
--------         ---------------------------
HAAS             SPIFFY COMPUTER SERVICE DIV.
THOMPSON         PLANNING
KWAN             INFORMATION CENTER
GEYER            SUPPORT SERVICES
STERN            MANUFACTURING SYSTEMS
PULASKI          ADMINISTRATION SYSTEMS
HENDERSON        OPERATIONS
SPENSER          SOFTWARE SUPPORT
LUCCHESSI        SPIFFY COMPUTER SERVICE DIV.
O'CONNELL        SPIFFY COMPUTER SERVICE DIV.
QUINTANA         INFORMATION CENTER
NICHOLLS         INFORMATION CENTER
ADAMSON          MANUFACTURING SYSTEMS
PIANKA           MANUFACTURING SYSTEMS
YOSHIMURA        MANUFACTURING SYSTEMS
SCOUTTEN         MANUFACTURING SYSTEMS
WALKER           MANUFACTURING SYSTEMS
BROWN            MANUFACTURING SYSTEMS
JONES            MANUFACTURING SYSTEMS
LUTZ             MANUFACTURING SYSTEMS
JEFFERSON        ADMINISTRATION SYSTEMS
<a name="587"></a><a name=""></a>
LASTNAME         DEPTNAME
--------         -------------------------
MARINO           ADMINISTRATION SYSTEMS
SMITH            ADMINISTRATION SYSTEMS
JOHNSON          ADMINISTRATION SYSTEMS
PEREZ            ADMINISTRATION SYSTEMS
SCHNEIDER        OPERATIONS
PARKER           OPERATIONS
SMITH            OPERATIONS
SETRIGHT         OPERATIONS
MEHTA            SOFTWARE SUPPORT
LEE              SOFTWARE SUPPORT
GOUNOT           SOFTWARE SUPPORT
HEMMINGER        SPIFFY COMPUTER SERVICE DIV.
ORLANDO          SPIFFY COMPUTER SERVICE DIV.
NATZ             INFORMATION CENTER
YAMAMOTO         MANUFACTURING SYSTEMS
JOHN             MANUFACTURING SYSTEMS
MONTEVERDE       ADMINISTRATION SYSTEMS
SCHWARTZ         OPERATIONS
SPRINGER         OPERATIONS
WONG             SOFTWARE SUPPORT
ALONZO           SOFTWARE SUPPORT
-                BRANCH OFFICE H2
-                RANCH OFFICE I2
-                BRANCH OFFICE G2
-                DEVELOPMENT CENTER
-                BRANCH OFFICE F2
-                BRANCH OFFICE J2
48 record(s) selected.
</pre>
</div>
<p class="last-para">Records that have a null value assigned to one of the columns are records that did not have a matching value in the two tables.</p>
</div>
</div>
<div class="section">
<h3 class="sect3-title">
<a name="588"></a><a name="ch05lev"></a>Combining the Results of Two or More Queries Using a Set Operator</h3>
<p class="first-para">With DB2, it is possible to combine two or more queries into a single query by using a special operator known as a <i class="emphasis">set operator</i>. When a set operator is used, the results of each query executed are combined in a specific manner to produce a single result data set. The following set operators are available:</p>
<a name="589"></a><a name=""></a>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">
<b class="bold">UNION.</b> When the <span class="fixed">UNION</span> set operator is used, the result data sets produced by each individual query are combined and all duplicate rows are eliminated. <a class="internaljump" href="#ch0">Figure 5-5</a> illustrates how a simple <span class="fixed">UNION</span> operation works.</p>
<a name="590"></a><a name=""></a>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">UNION ALL.</b> When the <span class="fixed">UNION ALL</span> set operator is used, the result data sets produced by each individual query are combined; all duplicate rows found are retained. <a class="internaljump" href="#ch0">Figure 5-6</a> illustrates how a simple <span class="fixed">UNION ALL</span> operation would work.</p>
<a name="591"></a><a name=""></a>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">INTERSECT.</b> When the <span class="fixed">INTERSECT</span> set operator is used, the result data sets produced by each individual query are combined, all duplicate rows found are eliminated, and all records found in the first result data set that do not have a corresponding record in the second result data set are eliminated, leaving just the records that are found in both result data sets. <a class="internaljump" href="#ch0">Figure 5-7</a> illustrates how a simple <span class="fixed">INTERSECT</span> operation would work.</p>
<a name="592"></a><a name=""></a>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">INTERSECT ALL</b>: When the <span class="fixed">INTERSECT ALL</span> set operator is used, the result data sets produced by each individual query are combined and all records found in the first result data set that do not have a corresponding record in the second result data set are eliminated, leaving just the records that are found in both result data sets; all duplicate rows found are retained. <a class="internaljump" href="#ch0">Figure 5-8</a> illustrates how a simple <span class="fixed">INTERSECT ALL</span> operation would work.</p>
<a name="593"></a><a name=""></a>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">EXCEPT</b>: When the <span class="fixed">EXCEPT</span> set operator is used, the result data sets produced by each individual query are combined, all duplicate rows found are eliminated, and all records found in the first result data set that have a corresponding record in the second result data set are eliminated, leaving just the records that are not found in both result data sets. <a class="internaljump" href="#ch0">Figure 5-9</a> illustrates how a simple <span class="fixed">EXCEPT</span> operation would work.</p>
<a name="594"></a><a name=""></a>
<p class="para">It is important to note that, in contrast to the <span class="fixed">UNION</span>, <span class="fixed">UNION ALL</span>, <span class="fixed">INTERSECT</span>, and <span class="fixed">INTERSECT ALL</span> set operators, if the queries used with the <span class="fixed">EXCEPT</span> and <span class="fixed">EXCEPT ALL</span> set operators are reversed, a different result data set will be produced. <a class="internaljump" href="#ch0">Figure 5-10</a> illustrates how the same <span class="fixed">EXCEPT</span> operation would work if the order of the queries specified were reversed.</p>
<a name="595"></a><a name=""></a>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">EXCEPT ALL</b>: When the <span class="fixed">EXCEPT ALL</span> set operator is used, the result data sets produced by each individual query are combined and all records found in the first result data set that have a corresponding record in the second result data set are eliminated, leaving just the records that are not found in both result data sets; all duplicate rows found are retained. <a class="internaljump" href="#ch0">Figure 5-11</a> illustrates how a simple <span class="fixed">EXCEPT ALL</span> operation would work.</p>
</li>
</ul>
<div class="figure">
<a name="596"></a><a name="ch0"></a><span class="figuremediaobject"><a href="images/fig326_01_0.jpg" NAME="IMG_87" target="_parent"><img alt="Image from book" id="IMG_87" src="images/fig326_01.jpg" height="347" width="350" title="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 5-5: </span>A simple UNION set operation.</span>
</div>
<div class="figure">
<a name="597"></a><a name="ch0"></a><span class="figuremediaobject"><a href="images/fig327_01_0.jpg" NAME="IMG_88" target="_parent"><img alt="Image from book" id="IMG_88" src="images/fig327_01.jpg" height="360" width="350" title="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 5-6: </span>A simple UNION ALL set operation.</span>
</div>
<div class="figure">
<a name="598"></a><a name="ch0"></a><span class="figuremediaobject"><a href="images/fig328_01_0.jpg" NAME="IMG_89" target="_parent"><img alt="Image from book" id="IMG_89" src="images/fig328_01.jpg" height="319" width="350" title="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 5-7: </span>A simple INTERSECT set operation.</span>
</div>
<div class="figure">
<a name="599"></a><a name="ch0"></a><span class="figuremediaobject"><a href="images/fig329_01_0.jpg" NAME="IMG_90" target="_parent"><img alt="Image from book" id="IMG_90" src="images/fig329_01.jpg" height="318" width="350" title="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 5-8: </span>A simple INTERSECT ALL set operation.</span>
</div>
<div class="figure">
<a name="600"></a><a name="ch0"></a><span class="figuremediaobject"><a href="images/fig330_01_0.jpg" NAME="IMG_91" target="_parent"><img alt="Image from book" id="IMG_91" src="images/fig330_01.jpg" height="311" width="350" title="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 5-9: </span>A simple EXCEPT set operation.</span>
</div>
<div class="figure">
<a name="601"></a><a name="ch0"></a><span class="figuremediaobject"><a href="images/fig331_01_0.jpg" NAME="IMG_92" target="_parent"><img alt="Image from book" id="IMG_92" src="images/fig331_01.jpg" height="310" width="350" title="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 5-10: </span>A simple EXCEPT set operation with the queries reversed.</span>
</div>
<div class="figure">
<a name="602"></a><a name="ch0"></a><span class="figuremediaobject"><a href="images/fig332_01_0.jpg" NAME="IMG_93" target="_parent"><img alt="Image from book" id="IMG_93" src="images/fig332_01.jpg" height="328" width="350" title="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 5-11: </span>A simple EXCEPT ALL set operation.</span>
</div>
<a name="603"></a><a name=""></a>
<p class="para">In order for two result data sets to be combined with a set operator, both must have the same number of columns, and each of those columns must have the same data types assigned to it. So when would you want to combine the results of two queries using a set operator? Suppose your company keeps individual employee expense account information in a table whose contents are archived at the end of each fiscal year. When a new fiscal year begins, expenditures for that year are essentially recorded in a new table. Now suppose, for tax purposes, you need a record of all employees' expenses for the last two years. To obtain this information, each archived table must be queried, and the results must then be combined. Rather than do this by running individual queries against the archived tables and storing the results in some kind of temporary table, this operation could be performed simply by using the <span class="fixed">UNION</span> set operator, along with two <span class="fixed">SELECT</span> SQL statements. Such a set of <span class="fixed">SELECT</span> statements might look something like this:</p>
<div class="informalexample">
<pre class="literallayout">
SELECT * FROM emp_exp_02
UNION
SELECT * FROM emp_exp_01
</pre>
</div>
</div>
</div>
</div>
</div>
</DIV>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=BBL0032.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=BBL0034.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>