<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Application Development Enhancements</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="app06lev1sec1.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="app06lev1sec3.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="app06lev1sec2"></A><H3 class="docSection1Title">Application Development Enhancements</H3>
<P class="docText">The second category of enhancements pertains to application development and programming. DB2 V7 offers many new features to simplify the process of programming DB2 applications, thereby helping developers become more productive.<A NAME="app06index07"></A><A NAME="app06index08"></A><A NAME="app06index09"></A><A NAME="app06index10"></A></P>
<A NAME="app06lev2sec1"></A><H4 class="docSection2Title">Stored Procedure Enhancements</H4>
<P class="docText">Stored Procedure Builder (SPB) is a new feature that provides a point-and-click environment for building stored procedures. The SPB can be used to develop stored procedures for both the distributed and mainframe DB2 environments. The SPB can be used either standalone or in conjunction with a development tool (such as IBM VisualAge, Microsoft Visual Basic, and Microsoft Visual Studio). SPB supports SQL Procedure Language and Java as stored procedure host languages.<A NAME="app06index11"></A><A NAME="app06index12"></A><A NAME="app06index13"></A><A NAME="app06index14"></A><A NAME="app06index15"></A><A NAME="app06index16"></A><A NAME="app06index17"></A></P>
<P class="docText">The second big application enhancement is SQL Procedure Language support. SQL Procedure Language enables stored procedures to be written in an extended, procedural SQL language. IBM's SQL Procedure Language is compatible with the ANSI SQL/PSM specification. It extends the SQL language to support additional functionality, effectively making SQL a more computationally complete language. Examples of the extended programming capabilities added to SQL for SQL Procedure Language include</P>
<UL><LI><P class="docList">Assignment statements</P></LI><LI><P class="docList"><TT>CASE</TT> - <TT>LEAVE</TT></P></LI><LI><P class="docList">Cursors</P></LI><LI><P class="docList"><TT>IF</TT> - <TT>THEN</TT> - <TT>ELSE</TT></P></LI><LI><P class="docList">Local variables</P></LI><LI><P class="docList"><TT>LOOP</TT>, <TT>REPEAT</TT>, and <TT>WHILE</TT></P></LI><LI><P class="docList"><TT>FOR</TT>, <TT>CALL</TT>, and <TT>RETURN</TT></P></LI><LI><P class="docList"><TT>GET DIAGNOSTICS</TT></P></LI><LI><P class="docList"><TT>SIGNAL</TT> and <TT>RESIGNAL</TT></P></LI></UL>
<P class="docText">Before SQL Procedure Language programs can be executed, first the code needs to be converted into C by the Stored Procedure Builder. Once converted, the code goes through the program preparation process. So, you get the benefit of writing code using the simple SQL Procedure Language dialect and the performance benefit of optimized C code. However, you will need to own a C compiler to take advantage of SQL Procedure Language.</P>
<P class="docText">Finally, for stored procedures, as of V7 DB2 provides the capability to issue <TT>COMMIT</TT> and <TT>ROLLBACK</TT> statements inside a stored procedure. The <TT>COMMIT</TT> or <TT>ROLLBACK</TT> will affect the entire unit of work, including any work done by the calling program, not just the work done within the stored procedure itself. So, you will need to use caution when issuing a <TT>COMMIT</TT> or <TT>ROLLBACK</TT> within a stored procedure.<A NAME="app06index18"></A><A NAME="app06index19"></A><A NAME="app06index20"></A><A NAME="app06index21"></A><A NAME="app06index22"></A></P>
<A NAME="app06lev2sec2"></A><H4 class="docSection2Title">Scrollable Cursors</H4>
<P class="docText">Probably the most significant new application development enhancement made to DB2 for V7 is scrollable cursors. A scrollable cursor provides the ability to scroll forward and backward through the data once the cursor is open. This can be achieved using nothing but SQL—no host language code (COBOL, C, and so on) is required to facilitate a scrollable cursor in DB2 V7. A scrollable cursor makes navigating through SQL result sets much easier. There are two types of DB2 scrollable cursors: <TT>SENSITIVE</TT> and <TT>INSENSITIVE</TT>.<A NAME="app06index23"></A><A NAME="app06index24"></A><A NAME="app06index25"></A><A NAME="app06index26"></A><A NAME="app06index27"></A><A NAME="app06index28"></A></P>
<P class="docText">A <TT>SENSITIVE</TT> scrollable cursors is updateable, meaning it can access data changed by the user or other users. An <TT>INSENSITIVE</TT> scrollable cursor, however, is not updateable, so it will not show any changes made.</P>
<P class="docText">To use scrollable cursors, you must use declared temporary tables, another new feature of DB2 Version 7. Declared temporary tables are discussed later in this appendix in the section "<A class="docLink" HREF="app06lev1sec3.html#app06lev1sec3">Data Management Enhancements</A>." DB2 uses a declared temporary table to hold and maintain the data returned by a scrollable cursor.</P>
<P class="docText">Scrollable cursors allow developers to move through the results of a query in multiple ways. The following keywords are supported when fetching data from a scrollable cursor:</P>
<UL><LI><p class="docText">
<TT>NEXT</TT>— 
Will <TT>FETCH</TT> the next row, the same way that the pre-V7 <TT>FETCH</TT> statement functioned</p></LI><LI><p class="docText">
<TT>PRIOR</TT>— 
Will <TT>FETCH</TT> the previous row</p></LI><LI><p class="docText">
<TT>FIRST</TT>— 
Will <TT>FETCH</TT> the first row in the results set</p></LI><LI><p class="docText">
<TT>LAST</TT>— 
Will <TT>FETCH</TT> the last row in the results set</p></LI><LI><p class="docText">
<TT>CURRENT</TT>— 
Will re-<TT>FETCH</TT> the current row from the result set</p></LI><LI><p class="docText">
<TT>BEFORE</TT>— 
Positions the cursor before the first row of the results set</p></LI><LI><p class="docText">
<TT>AFTER</TT>— 
Positions the cursor after the last row of the results set</p></LI><LI><p class="docText">
<TT>ABSOLUTE </TT><span class="docEmphasis"><TT>n</TT></span>— 
Will <TT>FETCH</TT> the row that is <span class="docEmphasis"><TT>n</TT></span> rows away from the first row in the results set</p></LI><LI><p class="docText">
<TT>RELATIVE </TT><span class="docEmphasis"><TT>n</TT></span>— 
Will <TT>FETCH</TT> the row that is <span class="docEmphasis"><TT>n</TT></span> rows away from the last row fetched</p></LI></UL>
<P class="docText">For both <TT>ABSOLUTE</TT> and <TT>RELATIVE</TT>, the number <span class="docEmphasis"><TT>n</TT></span> must be an integer. It can be either a positive or a negative number, and it can be represented as a numeric constant or as a host variable.</P>
<P class="docText">All of the <TT>FETCH</TT> options for scrollable cursors also reposition the cursor before fetching the data. For example, consider the following cursor logic:</P>
<pre>

</pre><BR><pre>
DECLARE csr1 SENSITIVE STATIC SCROLL CURSOR
FOR SELECT   FIRSTNAME, LASTNME
   FROM     DSN8710.EMP
   ORDER BY LASTNME;

OPEN csr1;

FETCH LAST csr1 INTO :FN, :LN;
</pre><BR>
<P class="docText">Issuing this SQL will declare a scrollable cursor named <TT>csr1</TT>, open that cursor, and then <TT>FETCH</TT> the last row from the cursor's results set. The <TT>FETCH LAST</TT> statement will reposition the cursor to the last row of the results set, and then <TT>FETCH</TT> the results into the host variables as specified. Scrollable cursors reduce the amount of time and effort required to move backward and forward through the results of SQL queries.</P>
<P class="docText">But as helpful as scrollable cursors are, do not make every cursor a scrollable cursor. Scrollable cursors require substantially more overhead than a traditional, non-scrollable cursor. Analyze the requirements of your applications and deploy scrollable cursors only where it makes sense to do so.<A NAME="app06index29"></A><A NAME="app06index30"></A><A NAME="app06index31"></A><A NAME="app06index32"></A><A NAME="app06index33"></A><A NAME="app06index34"></A></P>
<A NAME="app06lev2sec3"></A><H4 class="docSection2Title">Limiting the Number of Rows Fetched</H4>
<P class="docText">Application developers frequently need to retrieve a limited number of qualifying rows from a table. For example, maybe you need to list the top ten best selling items from inventory. There are several ways to accomplish this prior to DB2 V7 using SQL, but they are not necessarily efficient.<A NAME="app06index35"></A><A NAME="app06index36"></A><A NAME="app06index37"></A><A NAME="app06index38"></A><A NAME="app06index39"></A></P>
<P class="docText">The first reaction is to simply use the <TT>WHERE</TT> clause to eliminate non-qualifying rows. But this is simplistic, and often is not sufficient to produce the results desired in an optimal manner. What if the program only requires that the top ten results be returned? This can be a somewhat difficult request to formulate using SQL alone. Consider, for example, an application that needs to retrieve only the ten most highly paid employees from the <TT>EMP</TT> sample table. You could simply issue a SQL request that retrieves all of the employees in order by salary, but only use the first ten retrieved. That is easy, for example</P>
<pre>

</pre><BR><pre>
SELECT   EMPNO, FIRSTNME, LASTNAME, SALARY
FROM     DSN8710.EMP
ORDER BY SALARY DESC;
</pre><BR>
<P class="docText">You must specify the <TT>ORDER BY</TT> clause with the <TT>DESC</TT> keyword. This sorts the results into descending order, instead of the default, which is ascending. Without the <TT>DESC</TT> keyword, the "top ten" would be at the very end of the results set, not at the beginning.</P>
<P class="docText">But that does not really satisfy the requirement—retrieving only the top ten. It merely sorts the results into descending sequence. So, the results would still be all employees in the table, but in the correct order so you can view the "top ten" salaries very easily. The ideal solution should return only the ten employees with the highest salary and not merely a sorted list of all employees.</P>
<P class="docText">You can code some "tricky" SQL to support this request for all versions of DB2, such as the following:</P>
<pre>

</pre><BR><pre>
SELECT   EMPNO, FIRSTNME, LASTNAME, SALARY
FROM     DSN8710.EMP A
WHERE 10 &gt; (SELECT COUNT(*)
            FROM   DSN8710.EMP B
            WHERE A.SALARY &lt; B.SALARY
            AND   B.SALARY IS NOT NULL)
ORDER BY SALARY DESC;
<span class="docEmphStrong">SELECT   EMPNO, FIRSTNME, LASTNAME, SALARY</span>
<span class="docEmphStrong">FROM     DSN8710.EMP A</span>
<span class="docEmphStrong">WHERE 10 &gt; (SELECT COUNT(*)</span>
            <span class="docEmphStrong">FROM   DSN8710.EMP A</span>
            <span class="docEmphStrong">WHERE A.SALARY &lt; B.SALARY)</span>
<span class="docEmphStrong">AND SALARY IS NOT NULL</span>
<span class="docEmphStrong">ORDER BY SALARY DESC;</span>
<span class="docEmphStrong">---------+---------+---------+---------+---------+---------+---------+-</span>
<span class="docEmphStrong">DSNT408I SQLCODE = -206, ERROR:  B.SALARY IS NOT A COLUMN OF AN INSERTE</span>
         UPDATED TABLE, OR ANY TABLE IDENTIFIED IN A FROM CLAUSE, OR IS
         <span class="docEmphStrong">COLUMN OF THE TRIGGERING TABLE OF A TRIGGER</span>
</pre><BR>
<P class="docText">This SQL is portable from version to version of DB2 (as well as to another DBMS, such as Oracle or SQL Server). And, of course, you can change the constant 10 to any number you wish, thereby retrieving the top 20, or top 5, as deemed necessary by the needs of your application. Because the <TT>SALARY</TT> column is nullable in the <TT>EMP</TT> table, you must remove the nulls from the results set. The <TT>ORDER BY</TT> is required to sort the results in the right order. If it is removed from the query, the results will still contain the top ten, but they will be in no particular order.</P>
<P class="docText">DB2 V7 provides an easier and less complicated way to limit the results of a <TT>SELECT</TT> statement—the <TT>FIRST</TT> keyword. You can code <TT>FETCH FIRST </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS</TT>, which will limit the number of rows that are fetched and returned by a <TT>SELECT</TT> statement. Additionally, you can specify a new clause—<TT>FETCH FIRST 1 ROW ONLY</TT>—on <TT>SELECT INTO</TT> statements when the query can return more than one row in the answer set. Doing so informs DB2 to ignore any other rows.</P>
<P class="docText">There is one difference between the new V7 formulation and the other <TT>SELECT</TT> statement we reviewed, and that is the way "ties" are handled. A tie occurs when more than one row contains the same value. The previous query we examined might return more than 10 rows if there are multiple rows with the same value for price within the top ten. Using the <TT>FIRST</TT> keyword, DB2 will limit the number of rows returned to ten, even if there are other rows with the same value for price as the number ten row in the results set. The needs of your application will dictate whether ties are to be ignored or included in the result set. If all "ties" need to be included in the results set, the new V7 feature might not prove to be helpful.<A NAME="app06index40"></A><A NAME="app06index41"></A><A NAME="app06index42"></A><A NAME="app06index43"></A><A NAME="app06index44"></A></P>
<A NAME="app06lev2sec4"></A><H4 class="docSection2Title">External <TT>SAVEPOINTS</TT></H4>
<P class="docText">DB2 V7 allows you to set a <TT>SAVEPOINT</TT> within a transaction. You can think of a <TT>SAVEPOINT</TT> as a sub-UOW (unit of work) "stability" point. You can code application logic to undo any data modifications and database schema changes that were made since the application set the <TT>SAVEPOINT</TT>. Application development should be more efficient using <TT>SAVEPOINT</TT>s because you will not need to include contingency and what-if logic in your application code.<A NAME="app06index45"></A><A NAME="app06index46"></A><A NAME="app06index47"></A><A NAME="app06index48"></A><A NAME="app06index49"></A></P>
<P class="docText">Issuing a <TT>SAVEPOINT</TT> does not <TT>COMMIT</TT> work to DB2. It is simply a mechanism for registering milestones within a transaction or program. Let's learn by example. Consider the following pseudo-code:</P>
<pre>

</pre><BR><pre>
SAVEPOINT POINTX ON ROLLBACK RETAIN CURSORS;

Subsequent processing. . .

ROLLBACK TO SAVEPOINT POINTX;
</pre><BR>
<P class="docText">The <TT>ROLLBACK</TT> will cause any data or schema changes made in the "subsequent processing" to be undone.</P>
<P class="docText">It is permissible to code multiple <TT>SAVEPOINT</TT>s within a UOW, and you can <TT>ROLLBACK</TT> to any <TT>SAVEPOINT</TT> (as long as you do not reuse the <TT>SAVEPOINT</TT> name). The <TT>UNIQUE</TT> keyword can be specified to ensure that the <TT>SAVEPOINT</TT> name is not reused within the unit of recovery.</P>
<P class="docText">There are two clauses that can be specified to further define the nature of the <TT>SAVEPOINT</TT> when a <TT>ROLLBACK</TT> is issued:</P>
<UL><LI><p class="docText">
<TT>RETAIN CURSORS</TT>— 
Specifies that any cursors opened after the <TT>SAVEPOINT</TT> is set are not tracked and will not be closed when rolling back to that <TT>SAVEPOINT</TT>.</p></LI><LI><p class="docText">
<TT>RETAIN LOCKS</TT>— 
Specifies that any locks acquired after the <TT>SAVEPOINT</TT> is set are not tracked and will not be released when rolling back to the <TT>SAVEPOINT</TT>.</p></LI></UL>
<P class="docText">Even if <TT>RETAIN CURSORS</TT> is specified, some of the cursors might not be useable. For example, if the <TT>ROLLBACK</TT> removes a row (that is, rolls back an <TT>INSERT</TT>) upon which the cursor was positioned, an error will arise.<A NAME="app06index50"></A><A NAME="app06index51"></A><A NAME="app06index52"></A><A NAME="app06index53"></A><A NAME="app06index54"></A></P>
<A NAME="app06lev2sec5"></A><H4 class="docSection2Title">Row Expressions</H4>
<P class="docText">SQL becomes even more flexible under DB2 V7 with row expressions. Row expressions allow SQL statements to be coded using more than one set of comparisons in a single predicate using a subquery. The net result is that multiple columns can be compared within the scope of a single SQL predicate—possibly against multiple rows on the right side of the predicate. Once again, the best way to understand this feature is by viewing an example:<A NAME="app06index55"></A><A NAME="app06index56"></A><A NAME="app06index57"></A><A NAME="app06index58"></A><A NAME="app06index59"></A><A NAME="app06index60"></A></P>
<pre>

</pre><BR><pre>
SELECT *
FROM   SAMPLE_TABLE
WHERE  (COL1, COL2) IN (SELECT COLX, COLY
                        FROM   OTHER_TABLE);
</pre><BR>
<P class="docText">You can readily see the difference: Two columns are coded on the left side of the predicate, thereby enabling two columns to be selected in the <TT>SELECT</TT> statement on the right side of the predicate. Of course, a row expression need not be limited to only two columns; multiple columns can be specified, so long as the number of columns on the left matches the number of columns on the right side of the predicate. Row expressions bring more flexibility and can greatly simplify certain types of SQL statements.</P>
<A NAME="app06lev2sec6"></A><H4 class="docSection2Title">SQL Assist</H4>
<P class="docText">Another feature that will aid application developers is SQL Assist. The SQL Assist feature is a GUI-driven tool to help you build SQL statements such as <TT>SELECT</TT>, <TT>INSERT</TT>, <TT>UPDATE</TT>, and <TT>DELETE</TT>. It is accessible from the following "products":<A NAME="app06index61"></A><A NAME="app06index62"></A><A NAME="app06index63"></A><A NAME="app06index64"></A><A NAME="app06index65"></A></P>
<UL><LI><P class="docList">Control Center</P></LI><LI><P class="docList">Stored Procedure Builder</P></LI><LI><P class="docList">Data Warehouse Center</P></LI></UL>
<A NAME="app06lev2sec7"></A><H4 class="docSection2Title">Precompiler Services</H4>
<P class="docText">DB2 V7 supports more robust Precompiler Services. An API is provided that can be called by a host language compiler or preprocessor. Precompiler Services enable developers to precompile and compile programs in a single step, instead of multiple steps. This makes the development environment more flexible, easier to use, and able to offer better portability between members of the DB2 Family. Initial support for Precompiler Services is provided for COBOL only, but support for other languages is planned for later DB2 releases.<A NAME="app06index66"></A><A NAME="app06index67"></A><A NAME="app06index68"></A><A NAME="app06index69"></A><A NAME="app06index70"></A></P>
<A NAME="app06lev2sec8"></A><H4 class="docSection2Title">Additional Application Development Improvements</H4>
<P class="docText">IBM has made numerous additional improvements to application development aspects of DB2 in Version 7. Some of the more interesting enhancements include<A NAME="app06index71"></A><A NAME="app06index72"></A><A NAME="app06index73"></A></P>
<UL><LI><P class="docList">Improving DB2's support of JDBC and ODBC, including support for JDBC 2.0 and ODBC 3.0.</P></LI><LI><P class="docList">Improvements in SQL optimization and better parallel query support.</P></LI><LI><P class="docList">The ability to run ODBC/CLI programs as a static application (instead of only as dynamic).</P></LI><LI><P class="docList">Support for encouraging or discouraging index access for small tables. A <TT>DSNZPARM</TT> value is provided that can be set to give the DB2 optimizer guidance on the threshold for what constitutes a small table in your shop.</P></LI><LI><P class="docList">The ability to code a self-referencing sub-<TT>SELECT</TT> on searched <TT>UPDATE</TT> and <TT>DELETE</TT> statements. In previous releases of DB2, the <TT>WHERE</TT> clause cannot refer to the table (or view) being modified by the statement. For example, the following SQL is legitimate as of DB2 V7 and can be used to implement a 10% raise for employees who earn less than their department's average salary:</P><pre>

</pre><BR><pre>
UPDATE DSN8710.EMP E1
SET SALARY = SALARY * 1.10
WHERE SALARY &lt; (SELECT AVG(SALARY)
                FROM   DSN8710.EMP E2
                WHERE  E1.WORKDEPT = E2.WORKDEPT);
</pre><BR><P class="docList">DB2 will evaluate the complete subquery before performing the requested <TT>UPDATE</TT>.<A NAME="app06index74"></A><A NAME="app06index75"></A><A NAME="app06index76"></A></P></LI></UL>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="app06lev1sec1.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="app06lev1sec3.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
