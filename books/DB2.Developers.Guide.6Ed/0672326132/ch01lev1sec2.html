<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>SQL Tools of the Trade</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch01lev1sec1.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch01lev1sec3.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch01lev1sec2"></A><H3 class="docSection1Title">SQL Tools of the Trade</H3>
<P class="docText">SQL, as a "relational" data sublanguage, must support certain basic functions. These functions, or tools of the trade, implement the basic features of set-theory functions. You must have a basic understanding of the capabilities of SQL before you can explore the deeper issues of efficiency, development environments, performance, and tuning.</P>
<P class="docText">The basic functions of SQL are described in the following sections. Use these sections as a refresher course; they are not meant to teach SQL syntax or provide in-depth coverage of its use.</P>
<A NAME="ch01lev2sec4"></A><H4 class="docSection2Title">Selection and Projection</H4>
<P class="docText">The <span class="docEmphasis">selection</span> operation retrieves a specified subset of rows from a DB2 table. You use predicates in a <TT>WHERE</TT> clause to specify the search criteria. The SQL implementation for selection is shown in the following example:<A NAME="ch01index65"></A><A NAME="ch01index66"></A></P>
<pre>

</pre><BR><pre>
SELECT    *
FROM      DSN8810.PROJ
WHERE     DEPTNO = 'D01';
</pre><BR>
<P class="docText">To retrieve all rows from the <TT>PROJ</TT> table, simply eliminate the <TT>WHERE</TT> clause from the statement.</P>
<P class="docText">The <span class="docEmphasis">projection</span> operation retrieves a specified subset of columns from a given DB2 table. A DB2 query can provide a list of column names to limit the columns that are retrieved. Projection retrieves all of the rows but only the specified columns. The following statement illustrates the SQL implementation for projection:<A NAME="ch01index67"></A><A NAME="ch01index68"></A></P>
<pre>

</pre><BR><pre>
SELECT    DEPTNO, PROJNO, PROJNAME
FROM      DSN8810.PROJ;
</pre><BR>
<P class="docText">Simply, the selection operation determines which rows are retrieved, and the projection operation determines which columns are retrieved. This is clearly depicted in <A class="docLink" HREF="#ch01fig04">Figure 1.4</A>.</P>
<A NAME="ch01fig04"></A><p><CENTER><H5 class="docFigureTitle">Figure 1.4. Selection and projection.</H5>
<p class="docText"><IMG BORDER="0" width="500" height="464" SRC="images/0672326132/graphics/01fig04.gif" ALT="graphics/01fig04.gif"></p></CENTER></p><br>
<P class="docText">The SQL <TT>SELECT</TT> statement is used to implement both the selection and projection operations. In most cases, queries combine selection and projection to retrieve data. The following SQL statement combines the selection and projection operations of the preceding two examples:<A NAME="ch01index69"></A><A NAME="ch01index70"></A><A NAME="ch01index71"></A></P>
<pre>

</pre><BR><pre>
SELECT  DEPTNO, PROJNO, PROJNAME
FROM    DSN8810.PROJ
WHERE   DEPTNO = 'D01';
</pre><BR>
<A NAME="ch01lev2sec5"></A><H4 class="docSection2Title">Joins and Subqueries</H4>
<P class="docText">The capability to query data from multiple tables using a single SQL statement is one of the nicer features of DB2. The more tables involved in a <TT>SELECT</TT> statement, however, the more complex the SQL. Complex SQL statements sometimes cause confusion. Therefore, a basic understanding of the multiple table capabilities of SQL is essential for all users.</P>
<A NAME="ch01lev3sec1"></A><H5 class="docSection3Title">Joining Tables</H5>
<P class="docText">The capability of DB2 to combine data from multiple tables is called <span class="docEmphasis">joining</span>. A standard join, also referred to as an inner join, matches the data from two or more tables, based on the values of one or more columns in each table. All matches are combined, creating a resulting row that is the concatenation of the columns from each table where the specified columns match.<A NAME="ch01index72"></A><A NAME="ch01index73"></A><A NAME="ch01index74"></A></P>
<P class="docText">The most common method of joining DB2 tables requires SQL <TT>SELECT</TT> statements having the following:</P>
<UL><LI><P class="docList">A string of table names separated by commas in the <TT>FROM</TT> clause</P></LI><LI><P class="docList">A <TT>WHERE</TT> clause comparing the value of a column in one of the joined tables to the value of a column in the other joined table (this is usually an equality comparison)</P></LI></UL>
<P class="docText">For example, to query employees and their department names, the EMP table is joined to the DEPT table as follows:</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, LASTNAME, DEPTNO, DEPTNAME
FROM    DSN8810.EMP,
        DSN8810.DEPT
WHERE   WORKDEPT = DEPTNO;
</pre><BR>
<P class="docText">This method of coding joins, however, has confused many novice SQL programmers. No join verb need be coded explicitly in the SQL <TT>SELECT</TT> statement to implement table joining. A join can be specified by the presence of more than one table in the <TT>FROM</TT> clause of the <TT>SELECT</TT> statement. It is sometimes difficult to grasp the concept of joining tables without a specific <TT>JOIN</TT> keyword being used in the SQL join statement.</P>
<P class="docText">DB2 V4 introduced the <TT>JOIN</TT> keyword and an alternate method of coding joins. The following two join statements are equivalent to the previous join statement:<A NAME="ch01index75"></A><A NAME="ch01index76"></A><A NAME="ch01index77"></A><A NAME="ch01index78"></A><A NAME="ch01index79"></A><A NAME="ch01index80"></A></P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, LASTNAME, DEPTNO, DEPTNAME
FROM    DSN8810.EMP JOIN DSN8810.DEPT
ON      WORKDEPT = DEPTNO;
</pre><BR>
<P class="docText">or:</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, LASTNAME, DEPTNO, DEPTNAME
FROM    DSN8810.EMP INNER JOIN DSN8810.DEPT
ON      WORKDEPT = DEPTNO;
</pre><BR>
<P class="docText">Note that the comma-delimited list of tables is replaced with the keyword <TT>JOIN</TT> or <TT>INNER JOIN</TT>. The <TT>INNER</TT> keyword is used to differentiate a standard, or inner, join from an outer join. Outer joins will be discussed in a moment. The <TT>INNER</TT> keyword is implicit and will be assumed if not explicitly coded.<A NAME="ch01index81"></A><A NAME="ch01index82"></A><A NAME="ch01index83"></A><A NAME="ch01index84"></A><A NAME="ch01index85"></A></P>
<P class="docText">Likewise, note that when you use the <TT>JOIN</TT> keyword you must use <TT>ON</TT> (instead of <TT>WHERE</TT>) to specify the join condition. Additional local predicates can be applied with an additional <TT>WHERE</TT> clause if so desired.<A NAME="ch01index86"></A><A NAME="ch01index87"></A><A NAME="ch01index88"></A></P>
<A NAME="ch01note05"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Although both types of joins are supported by DB2, consider adopting an SQL coding standard using the explicit <TT>[INNER] JOIN</TT> keyword. Using the <TT>JOIN</TT> keyword makes it more difficult to forget to code the join columns (because it requires the special <TT>ON</TT> clause). Furthermore, when using the <TT>JOIN</TT> keyword it is easier for novices to learn and effectively code join statements.</P></div><br>
<P class="docText">When coding joins, remember to keep in mind that SQL is a set-level language. If the value of the data in the columns being matched is not unique, multiple matches might be found for each row in each table. Even if the data is unique, many rows could still match if the operation specified in the join criteria is not an equality operation. For example<A NAME="ch01index89"></A><A NAME="ch01index90"></A><A NAME="ch01index91"></A></P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, LASTNAME
FROM    DSN8810.EMP INNER JOIN
        DSN8810.DEPT
ON      WORKDEPT &gt; DEPTNO;
</pre><BR>
<P class="docText">(Admittedly, this example is contrived.) Many rows will match, and could result in the join returning more rows than either table originally contained.</P>
<P class="docText">You do not have to join tables based only on equal values. Matching can be achieved with any of the following operations:</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5"><COLGROUP><COL width="82.5"><COL width="467.5"></COLGROUP><THEAD></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>=</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Equal to</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>&gt;</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Greater than</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>&gt;=</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Greater than or equal to</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>&lt;&gt;</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Not equal to</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>&lt;</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Less than</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>&lt;=</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Less than or equal to</P></TD></TR></TABLE></P><br>
<P class="docText">Take care to ensure that the proper join criteria are specified for the columns you are joining. Base the predicates of a join on columns drawn from the same logical domain. For example, consider the following join:</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, LASTNAME, DEPTNO, DEPTNAME
FROM    DSN8810.EMP JOIN
        DSN8810.DEPT
ON      WORKDEPT = DEPTNO;
</pre><BR>
<P class="docText">This is a good example of a join. The employee table is joined to the department table using a logical department code that exists physically as a column in both tables (<TT>WORKDEPT</TT> in the employee table and <TT>DEPTNO</TT> in the department table). Both these columns are pooled from the same domain: the set of valid departments for the organization. Remember, there are two ways of coding join statements and this join statement could alternately be coded as follows:</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, LASTNAME, DEPTNO, DEPTNAME
FROM    DSN8810.EMP,
        DSN8810.DEPT
WHERE   WORKDEPT = DEPTNO;
</pre><BR>
<P class="docText">You must consider the possible size of the results table before deciding to join tables. Generally, the more data that must be <span class="docEmphBoldItalic">accessed</span> to accomplish the join, the less efficient the join will be. Note that this does not necessarily mean that joining larger tables will result in poorer performance than joining smaller tables. It all depends on the formulation of the query, the design of the database, the amount of data that must be accessed, the organization of the data, and the amount of data that will be returned as the result set for the query. Guidelines for the efficient coding of SQL joins are presented in <A class="docLink" HREF="ch02.html#ch02">Chapter 2</A>, "Data Manipulation Guidelines."<A NAME="ch01index92"></A><A NAME="ch01index93"></A><A NAME="ch01index94"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> More than two tables can be joined in a single SQL statement. As of Version 8, up to 225 DB2 tables can be joined in one SQL statement, but it is not usually practical to code such a large number of tables into a single statement. From both a performance and a maintainability standpoint, the practical limit is probably about a dozen or so tables, but it is <span class="docEmphBoldItalic">possible</span> to code very large SQL statements that access hundreds of tables. It is even possible to get acceptable performance when joining large numbers of tables.<A NAME="ch01index95"></A><A NAME="ch01index96"></A><A NAME="ch01index97"></A></P></td></tr></table><br>
<P class="docText">The order of magnitude for the join is determined by the number of tables specified in the <TT>FROM</TT> clause; or by counting the number of <TT>JOIN</TT> keywords and adding 1. For example, the following join is a three-table join because three tables—<TT>EMP</TT>, <TT>DEPT</TT>, and <TT>PROJ</TT>—are specified:<A NAME="ch01index98"></A><A NAME="ch01index99"></A><A NAME="ch01index100"></A></P>
<pre>

</pre><BR><pre>
SELECT  PROJNO, EMPNO, LASTNAME, DEPTNAME
FROM    DSN8810.EMP   E,
        DSN8810.DEPT  D,
        DSN8810.PROJ  P
WHERE   EMPNO = RESPEMP
AND     D.DEPTNO = E.WORKDEPT;
</pre><BR>
<P class="docText">This example of an equijoin involves three tables. DB2 matches rows in the <TT>EMP</TT> table with rows in the <TT>PROJ</TT> table where the two rows match on employee number. Likewise, rows in the <TT>EMP</TT> table are matched with rows in the <TT>DEPT</TT> table where the department number is the same. This example produces a results table listing each project number along with information about the employee responsible for the project including his or her department name.</P>
<P class="docText">The following is an equivalent formulation of the prior statement using the <TT>[INNER] JOIN</TT> keyword (and it should perform similarly):</P>
<pre>

</pre><BR><pre>
SELECT  PROJNO, EMPNO, LASTNAME, DEPTNAME
FROM    (DSN8810.EMP E JOIN
        DSN8810.DEPT D
ON      D.DEPTNO = E.WORKDEPT) JOIN
        DSN8810.PROJ P
ON      EMPNO = RESPEMP;
</pre><BR>
<P class="docText">The join criteria are specified in the <TT>ON</TT> clause immediately following the table join specification. Contrast this with the looser, comma-delimited formulation. It is much easier to determine which predicate applies to which join specification when the <TT>INNER JOIN</TT> syntax is used. To determine the magnitude of the join in this example, count the <TT>JOIN</TT> keywords and add 1. There are two <TT>JOIN</TT> keywords specified, so the magnitude of the join is 2+1, or 3.</P>
<P class="docText">Tables can be joined to themselves also. Consider the following query:<A NAME="ch01index101"></A><A NAME="ch01index102"></A><A NAME="ch01index103"></A></P>
<pre>

</pre><BR><pre>
SELECT  A.DEPTNO, A.DEPTNAME, A.ADMRDEPT, B.DEPTNAME
FROM    DSN8810.DEPT   A,
        DSN8810.DEPT   B
WHERE   A.ADMRDEPT = B.DEPTNO;
</pre><BR>
<P class="docText">This join returns a listing of all department numbers and names, along with the associated department number and name to which the department reports. Self-referencing lists such as this one would not be possible without the capability to join a table to itself.</P>
<P class="docText">Joins are possible because all data relationships in DB2 are defined by values in columns instead of by other methods (such as pointers). DB2 can check for matches based solely on the data in the columns specified in the predicates of the <TT>WHERE</TT> clause in the SQL join statement. When coding a join, you must take extra care to code a proper matching predicate for each table being joined. Failure to do so can result in a <span class="docEmphasis">Cartesian product</span>, the subject of the next section.<A NAME="ch01index104"></A><A NAME="ch01index105"></A><A NAME="ch01index106"></A></P>
<A NAME="ch01lev3sec2"></A><H5 class="docSection3Title">Cartesian Products</H5>
<P class="docText">A Cartesian product is the result of a join that does not specify matching columns. Consider the following query:<A NAME="ch01index107"></A><A NAME="ch01index108"></A></P>
<pre>

</pre><BR><pre>
SELECT  *
FROM    DSN8810.DEPT,
        DSN8810.EMP;
</pre><BR>
<P class="docText">This query lacks a <TT>WHERE</TT> clause. To satisfy the query DB2 combines every row from the <TT>DEPT</TT> table with every row in the <TT>EMP</TT> table. An example of the output from this statement follows:</P>
<pre>

</pre><BR><pre>
DEPTNO DEPTNAME      MGRNO  ADMRDEPT EMPNO  FIRSTNAME MIDINIT LASTNAME WORKDEPT ...
A00    SPIFFY CO.    000010 A00      000010 CHRISTINE I       HAAS     A00      ...
A00    SPIFFY CO.    000010 A00      000020 MICHAEL   L       THOMPSON B01      ...
A00    SPIFFY CO.    000010 A00      000030 SALLY     A       KWAN     C01      ...
A00    SPIFFY CO.    000010 A00      000040 JOHN      B       GEYER    E01      ...
A00    SPIFFY CO.    000010 A00      000340 JASON     R       GOUNOT   E21      ...
B01    PLANNING      000020 A00      000010 CHRISTINE I       HAAS     A00      ...
B01    PLANNING      000020 A00      000020 MICHAEL   L       THOMPSON B01      ...
B01    PLANNING      000020 A00      000030 SALLY     A       KWAN     C01      ...
B01    PLANNING      000020 A00      000040 JOHN      B       GEYER    E01      ...
E21    SOFTWARE SUP. 000100 E01      000340 JASON     R       GOUNOT   E21      ...
</pre><BR>
<P class="docText">All the columns of the <TT>DEPT</TT> table and all the columns of the <TT>EMP</TT> table are included in the Cartesian product. For brevity, the example output does not show all of the columns of the <TT>EMP</TT> table. The output shows the first four rows of the output followed by a break and then additional rows and breaks. A break indicates data that is missing but irrelevant for this discussion.</P>
<P class="docText">By analyzing this output, you can see some basic concepts about the Cartesian product. For example, the first row looks okay. Christine I. Haas works in department <TT>A00</TT>, and the information for department <TT>A00</TT> is reported along with her employee information. This is a coincidence. Notice the other rows of the output. In each instance, the <TT>DEPTNO</TT> does not match the <TT>WORKDEPT</TT> because we did not specify this in the join statement.</P>
<P class="docText">When a table with 1,000 rows is joined as a Cartesian product with a table having 100 rows, the result is 1,000 * 100 rows, or 100,000 rows. These 100,000 rows, however, contain no more information than the original two tables because no criteria were specified for combining the table. In addition to containing no new information, the result of a Cartesian product is more difficult to understand because the information is now jumbled, whereas before it existed in two separate tables. In general, avoid Cartesian products.<A NAME="ch01index109"></A><A NAME="ch01index110"></A></P>
<A NAME="ch01note06"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Although Cartesian products should be avoided in practice, there are certain circumstances where DB2 can use Cartesian products "behind the scenes" to practical benefit. These circumstances occur when the DB2 optimizer determines that better performance can be achieved using a Cartesian product. You, as a user, should not attempt to create and execute a Cartesian product because the performance is usually atrocious and no additional information is gained by running such a query.</P>
<P class="docText">The DB2 optimizer may determine that a Cartesian product should be performed for a portion of a join. Such a situation usually happens in data warehousing queries where a star join is used to build a Cartesian product for dimension tables. (For details on star joins consult <A class="docLink" HREF="ch45.html#ch45">Chapter 45</A>, "Data Warehousing with DB2.") The result of the dimension table Cartesian join is then joined with the fact table. Because the fact table is usually many times larger than the dimension table, processing the fact table only once can significantly improve performance by reducing the size of intermediate results sets.<A NAME="ch01index111"></A><A NAME="ch01index112"></A></P></div><br>
<A NAME="ch01lev3sec3"></A><H5 class="docSection3Title">Subqueries</H5>
<P class="docText">SQL provides the capability to nest <TT>SELECT</TT> statements. When one or more <TT>SELECT</TT> statements are nested in another <TT>SELECT</TT> statement, the query is referred to as a <span class="docEmphasis">subquery</span>. (Many SQL and DB2 users refer to subqueries as nested <TT>SELECT</TT>s.) A subquery enables a user to base the search criteria of one <TT>SELECT</TT> statement on the results of another <TT>SELECT</TT> statement.<A NAME="ch01index113"></A><A NAME="ch01index114"></A><A NAME="ch01index115"></A><A NAME="ch01index116"></A><A NAME="ch01index117"></A></P>
<A NAME="ch01note07"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Do not confuse a subquery with a subselect. The term subquery is used when one query is embedded in the <TT>WHERE</TT> clause of another query.</P>
<P class="docText">The term subselect is used by IBM to define a particular component of a fullselect statement.</P></div><br>
<P class="docText">Although you can formulate subqueries in different fashions, they typically are expressed as one <TT>SELECT</TT> statement connected to another in one of four ways:</P>
<UL><LI><P class="docList">Using the <TT>IN</TT> (or <TT>NOT IN</TT>) predicate</P></LI><LI><P class="docList">Using the <TT>EXISTS</TT> (or <TT>NOT EXISTS</TT>) predicate</P></LI><LI><P class="docList">Specifying the equality predicate (<TT>=</TT>) or the inequality predicate (<TT>&lt;&gt;</TT>)</P></LI><LI><P class="docList">Specifying a predicate using a comparative operator (<TT>&lt;</TT>, <TT>&lt;=</TT>, <TT>&gt;</TT>, or <TT>&gt;=</TT>)</P></LI></UL>
<P class="docText">The following <TT>SELECT</TT> statement is an example of a subquery:</P>
<pre>

</pre><BR><pre>
SELECT  DEPTNAME
FROM    DSN8810.DEPT
WHERE   DEPTNO IN
        (SELECT  WORKDEPT
         FROM    DSN8810.EMP
         WHERE   SALARY &gt; 50000);
</pre><BR>
<P class="docText">DB2 processes this SQL statement by first evaluating the nested <TT>SELECT</TT> statement to retrieve all <TT>WORKDEPT</TT>s where the <TT>SALARY</TT> is over $50,000. It then matches rows in the <TT>DEPT</TT> table that correspond to the <TT>WORKDEPT</TT> values retrieved by the nested <TT>SELECT</TT>. This match produces a results table that lists the name of all departments where any employee earns more than $50,000. Of course, if more than one employee earns over $50,000 per department, the same <TT>DEPTNAME</TT> may be listed multiple times in the results set. To eliminate duplicates, the <TT>DISTINCT</TT> clause must be used. For example:</P>
<pre>

</pre><BR><pre>
SELECT  <span class="docEmphStrong">DISTINCT</span> DEPTNAME
FROM    DSN8810.DEPT
WHERE   DEPTNO IN
        (SELECT  WORKDEPT
         FROM    DSN8810.EMP
         WHERE   SALARY &gt; 50000);
</pre><BR>
<P class="docText">The preceding statements use the <TT>IN</TT> operator to connect <TT>SELECT</TT> statements. The following example shows an alternative way of nesting <TT>SELECT</TT> statements, by means of an equality predicate:</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, LASTNAME
FROM    DSN8810.EMP
WHERE   WORKDEPT =
        (SELECT  DEPTNO
         FROM    DSN8810.DEPT
         WHERE   DEPTNAME = 'PLANNING');
</pre><BR>
<P class="docText">DB2 processes this SQL statement by retrieving the proper <TT>DEPTNO</TT> with the nested <TT>SELECT</TT> statement that is coded to search for the <TT>PLANNING</TT> department. It then matches rows in the <TT>EMP</TT> table that correspond to the <TT>DEPTNO</TT> of the <TT>PLANNING</TT> department. This match produces a results table that lists all employees in the <TT>PLANNING</TT> department. Of course, it also assumes that there is only one <TT>PLANNING</TT> department. If there were more, the SQL statement would fail because the nested <TT>SELECT</TT> statement can only return a single row when the <TT>=</TT> predicate is used. This type of failure can be avoided by using <TT>IN</TT> instead of the <TT>=</TT> predicate.</P>
<P class="docText">The capability to express retrieval criteria on nested <TT>SELECT</TT> statements gives the user of SQL additional flexibility for querying multiple tables. A specialized form of subquery, called a <span class="docEmphasis">correlated subquery</span>, provides a further level of flexibility by permitting the nested <TT>SELECT</TT> statement to refer back to columns in previous <TT>SELECT</TT> statements. As an example:</P>
<pre>

</pre><BR><pre>
SELECT  A.WORKDEPT, A.EMPNO, A.FIRSTNME, A.MIDINIT,
        A.LASTNAME, A.SALARY
FROM    DSN8810.EMP  A
WHERE   A.SALARY &gt;
        (SELECT  AVG(B.SALARY)
         FROM    DSN8810.EMP  B
         WHERE   A.WORKDEPT = B.WORKDEPT)
ORDER BY A.WORKDEPT, A.EMPNO;
</pre><BR>
<P class="docText">Look closely at this correlated subquery. It differs from a normal subquery in that the nested <TT>SELECT</TT> statement refers back to the table in the first <TT>SELECT</TT> statement. The preceding query returns information for all employees who earn a <TT>SALARY</TT> greater than the average salary for that employee's given department. This is accomplished by the correlation of the <TT>WORKDEPT</TT> column in the nested <TT>SELECT</TT> statement to the <TT>WORKDEPT</TT> column in the first <TT>SELECT</TT> statement.<A NAME="ch01index118"></A><A NAME="ch01index119"></A><A NAME="ch01index120"></A><A NAME="ch01index121"></A><A NAME="ch01index122"></A><A NAME="ch01index123"></A><A NAME="ch01index124"></A><A NAME="ch01index125"></A></P>
<P class="docText">The following example illustrates an alternative form of correlated subquery using the <TT>EXISTS</TT> predicate:</P>
<pre>

</pre><BR><pre>
SELECT  A.EMPNO, A.LASTNAME, A.FIRSTNME
FROM    DSN8810.EMP  A
WHERE   EXISTS
        (SELECT '1'
         FROM   DSN8810.DEPT  B
         WHERE  B.DEPTNO = A.WORKDEPT
         AND    B.DEPTNAME = 'OPERATIONS');
</pre><BR>
<P class="docText">This query returns the names of all employees who work in the <TT>OPERATIONS</TT> department.</P>
<P class="docText">A <span class="docEmphasis">non-correlated subquery</span> is processed in bottom-to-top fashion. The bottom-most query is executed and, based on the results, the top-most query is resolved. A correlated subquery works in a top-bottom-top fashion. The top-most query is analyzed, and based on the analysis, the bottom-most query is initiated. The bottom-most query, however, relies on the top-most query to evaluate its predicate. After processing for the first instance of the top-most query, therefore, DB2 must return to that query for another value and repeat the process until the results table is complete.<A NAME="ch01index126"></A><A NAME="ch01index127"></A><A NAME="ch01index128"></A></P>
<P class="docText">Both forms of subqueries enable you to base the qualifications of one retrieval on the results of another.<A NAME="ch01index129"></A><A NAME="ch01index130"></A><A NAME="ch01index131"></A><A NAME="ch01index132"></A><A NAME="ch01index133"></A></P>
<A NAME="ch01lev3sec4"></A><H5 class="docSection3Title">Joins Versus Subqueries</H5>
<P class="docText">A subquery can be converted to an equivalent join. The concept behind both types of queries is to retrieve data by accessing multiple tables based on search criteria matching data in the tables.<A NAME="ch01index134"></A><A NAME="ch01index135"></A><A NAME="ch01index136"></A><A NAME="ch01index137"></A></P>
<P class="docText">Consider the following two <TT>SELECT</TT> statements. The first is a subquery:</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, LASTNAME
FROM    DSN8810.EMP
WHERE   WORKDEPT IN
        (SELECT  DEPTNO
         FROM    DSN8810.DEPT
         WHERE   DEPTNAME = 'PLANNING');
</pre><BR>
<P class="docText">The second <TT>SELECT</TT> statement is a join:</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, LASTNAME
FROM    DSN8810.EMP,
        DSN8810.DEPT
WHERE   WORKDEPT = DEPTNO
AND     DEPTNAME = 'PLANNING';
</pre><BR>
<P class="docText">Both of these queries return the employee numbers and last names of all employees who work in the <TT>PLANNING</TT> department.</P>
<P class="docText">Let's first discuss the subquery formulation of this request. The list of valid <TT>DEPTNO</TT>s is retrieved from the <TT>DEPT</TT> table for the <TT>DEPTNAME</TT> of <TT>'PLANNING'</TT>. This <TT>DEPTNO</TT> list then is compared against the <TT>WORKDEPT</TT> column of the <TT>EMP</TT> table. Employees with a <TT>WORKDEPT</TT> that matches any <TT>DEPTNO</TT> are retrieved.</P>
<P class="docText">The join operates in a similar manner. In fact, the DB2 optimizer can be intelligent enough to transform a subquery into its corresponding join format before <span class="docEmphasis">optimization</span>; optimization is covered in depth in <A class="docLink" HREF="ch21.html#ch21">Chapter 21</A>, "The Optimizer."</P>
<P class="docText">The decision to use a subquery, a correlated subquery, or a join usually is based on performance. In early releases of DB2, the performance of logically equivalent queries could vary greatly depending upon whether they were coded as a subquery or a join. With the performance changes made to DB2 in recent years, worrying about the performance of joins and subqueries is usually not worth the effort.</P>
<P class="docText">As a general rule of thumb, I suggest using joins over the other two types of multi-table data retrieval. This provides a consistent base from which to operate. By promoting joins over subqueries, you can meet the needs of most users and diminish confusion. If you need to squeeze the most performance from a system, however, try rewriting multi-table data retrieval SQL <TT>SELECT</TT> statements as both a join and a subquery. Test the performance of each SQL formulation and use the one that performs best.<A NAME="ch01index138"></A><A NAME="ch01index139"></A><A NAME="ch01index140"></A><A NAME="ch01index141"></A></P>
<A NAME="ch01lev2sec6"></A><H4 class="docSection2Title">Union</H4>
<P class="docText">The <span class="docEmphasis">union</span> operation combines two sets of rows into a single result set composed of all the rows in both of the two original sets. The two original sets must be <span class="docEmphasis">union-compatible</span>. For union compatibility<A NAME="ch01index142"></A><A NAME="ch01index143"></A></P>
<UL><LI><P class="docList">The two sets must contain the same number of columns.</P></LI><LI><P class="docList">Each column of the first set must be either the same data type as the corresponding column of the second set <span class="docEmphasis">or</span> convertible to the same data type as the corresponding column of the second set.</P></LI></UL>
<P class="docText">In purest set-theory form, the union of two sets contains no duplicates, but DB2 provides the option of retaining or eliminating duplicates. The <TT>UNION</TT> verb eliminates duplicates; <TT>UNION ALL</TT> retains them.<A NAME="ch01index144"></A><A NAME="ch01index145"></A></P>
<P class="docText">An example SQL statement using <TT>UNION</TT> follows:</P>
<pre>

</pre><BR><pre>
SELECT  CREATOR, NAME, 'TABLE  '
FROM    SYSIBM.SYSTABLES
WHERE   TYPE = 'T'
UNION
SELECT  CREATOR, NAME, 'VIEW   '
FROM    SYSIBM.SYSTABLES
WHERE   TYPE = 'V'
UNION
SELECT  CREATOR, NAME, 'ALIAS  '
FROM    SYSIBM.SYSTABLES
WHERE   TYPE = 'A'
UNION
SELECT  CREATOR, NAME, 'SYNONYM'
FROM    SYSIBM.SYSSYNONYMS;
</pre><BR>
<P class="docText">This SQL <TT>UNION</TT> retrieves all the tables, views, aliases, and synonyms in the DB2 Catalog. Notice that each <TT>SELECT</TT> statement tied together using the <TT>UNION</TT> verb has the same number of columns, and each column has the same data type and length. This statement could be changed to use <TT>UNION ALL</TT> instead of <TT>UNION</TT> because you know that none of the <TT>SELECT</TT>s will return duplicate rows. (A table cannot be a view, a view cannot be an alias, and so on.)</P>
<P class="docText">The ability to use <TT>UNION</TT> to construct results data is essential to formulating some of the more complex forms of SQL. This is demonstrated in the next section.</P>
<P class="docText">When results from two <TT>SELECT</TT> statements accessing the <span class="docEmphStrong">same table</span> are combined using <TT>UNION</TT>, remember that the same result can be achieved using the <TT>OR</TT> clause and <TT>CASE</TT> expressions. Moreover, the use of <TT>OR</TT> is preferable to the use of <TT>UNION</TT> because the <TT>OR</TT> formulation</P>
<UL><LI><P class="docList">Is generally easier for most users to understand</P></LI><LI><P class="docList">Tends to outperform <TT>UNION</TT></P></LI></UL>
<P class="docText">Consider the following two queries:</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO
FROM    DSN8810.EMP
WHERE   LASTNAME = 'HAAS'
UNION
SELECT  EMPNO
FROM    DSN8810.EMP
WHERE   JOB = 'PRES';
</pre><BR>
<P class="docText">and</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO
FROM    DSN8810.EMP
WHERE   LASTNAME = 'HAAS'
OR      JOB = 'PRES';
</pre><BR>
<P class="docText">After scrutinizing these queries, you can see that the two statements are equivalent. If the two <TT>SELECT</TT> statements were accessing different tables, however, the <TT>UNION</TT> could not be changed to an equivalent form using <TT>OR</TT>.</P>
<A NAME="ch01note08"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">A literal can be used in the <TT>UNION</TT> query to indicate which predicate was satisfied for each particular row—for example:</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, 'NAME=HAAS'
FROM    DSN8810.EMP
WHERE   LASTNAME = 'HAAS'
UNION ALL
SELECT  EMPNO, 'JOB =PRES'
FROM    DSN8810.EMP
WHERE   JOB = 'PRES';
</pre><BR>
<P class="docText">The result set from the query using <TT>OR</TT> cannot include a literal. However, if rows exists that satisfy both predicates, the results of the <TT>UNION</TT> query will not match the results of the <TT>OR</TT> query because the literal will cause the duplicates to remain (when the literal is added, the row is no longer a duplicate).</P>
<P class="docText">A better-performing alternative is to use the following query with a <TT>CASE</TT> expression:</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, (CASE WHEN LASTNAME = 'HAAS' THEN 'NAME=HAAS'
                     WHEN JOB = 'PRES' THEN 'NAME=PRES' END) AS NAMETAG
FROM    DSN8810.EMP
WHERE   LASTNAME = 'HAAS'
OR      JOB = 'PRES';
</pre><BR></div><br>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><P class="docText"> In older versions of DB2, <TT>UNION</TT> was not permitted in views. As of DB2 Version 7, views can contain the <TT>UNION</TT> and <TT>UNION ALL</TT> clauses. This brings much more flexibility to views—and makes <TT>UNION</TT> more useful, too.<A NAME="ch01index146"></A><A NAME="ch01index147"></A></P></td></tr></table><br>
<A NAME="ch01lev2sec7"></A><H4 class="docSection2Title">Outer Join</H4>
<P class="docText">As discussed previously, when tables are joined, the rows that are returned contain matching values for the columns specified in the join predicates. Sometimes, however, it is desirable to return both matching and non-matching rows for one or more of the tables being joined. This is known as an <span class="docEmphasis">outer join</span>. Prior to V4, DB2 did not explicitly support outer joins. Instead, users were forced to accommodate outer join processing by combining a join and a correlated subquery with the <TT>UNION</TT> verb.<A NAME="ch01index148"></A><A NAME="ch01index149"></A><A NAME="ch01index150"></A></P>
<P class="docText">Before we progress to discussing how to code an outer join, let's first clarify the concept of an outer join. Suppose that you want a report on the departments in your organization, presented in department number (<TT>DEPTNO</TT>) order. This information is in the <TT>DEPT</TT> sample table. You also want the last name of the manager of each department. Your first attempt at this request might look like this:</P>
<pre>

</pre><BR><pre>
SELECT  DISTINCT
        D.DEPTNO, D.DEPTNAME, D.MGRNO, E.LASTNAME
FROM    DSN8810.DEPT   D,
        DSN8810.EMP    E
WHERE   D.MGRNO = E.EMPNO;
</pre><BR>
<P class="docText">This example, using an inner join, appears to satisfy your objective. However, if a department does not have a manager or if a department has been assigned a manager who is not recorded in the <TT>EMP</TT> table, your report would not list every department. The predicate <TT>D.MGRNO = E.EMPNO</TT> is not met for these types of rows. In addition, a <TT>MGRNO</TT> is not assigned to the <TT>DEVELOPMENT CENTER</TT> department in the <TT>DEPT</TT> sample table. That department therefore is not listed in the result set for the preceding query.</P>
<P class="docText">The following query corrects the problem by using <TT>UNION</TT> to concatenate the non-matching rows:</P>
<pre>

</pre><BR><pre>
SELECT  DISTINCT
        D.DEPTNO, D.DEPTNAME, D.MGRNO, E.LASTNAME
FROM    DSN8810.DEPT  D,
        DSN8810.EMP   E
WHERE   D.MGRNO = E.EMPNO
UNION ALL
SELECT  DISTINCT
        D.DEPTNO, D.DEPTNAME, D.MGRNO, '* No Mgr Name *'
FROM    DSN8810.DEPT  D
WHERE   NOT EXISTS
        (SELECT  EMPNO
         FROM    DSN8810.EMP  E
         WHERE   D.MGRNO = E.EMPNO)
ORDER BY 1;
</pre><BR>
<P class="docText">By providing the constant '<TT>* No Mgr Name *</TT>' in place of the nonexistent data, and by coding a correlated subquery with the <TT>NOT EXISTS</TT> operator, the rows that do not match are returned. <TT>UNION</TT> appends the two sets of data, returning a complete report of departments regardless of whether the department has a valid manager.</P>
<P class="docText">Using the <TT>OUTER JOIN</TT> syntax simplifies this query significantly:</P>
<pre>

</pre><BR><pre>
SELECT  DEPTNO, DEPTNAME, MGRNO, LASTNAME
FROM    DSN8810.EMP LEFT OUTER JOIN DSN8810.DEPT
          ON EMPNO = MGRNO;
</pre><BR>
<P class="docText">The keywords <TT>LEFT OUTER JOIN</TT> cause DB2 to invoke an outer join, returning rows that have matching values in the predicate columns, but also returning unmatched rows from the table on the left side of the join. In the case of the left outer join example shown, this would be the <TT>EMP</TT> table because it is on the left side of the join clause.</P>
<P class="docText">Note that the <TT>WHERE</TT> keyword is replaced with the <TT>ON</TT> keyword for the outer join statement. Additionally, the missing values in the result set are filled with nulls (not a sample default as shown in the previous example). Use the <TT>VALUE</TT> (or <TT>COALESCE</TT>) function to fill in the missing values with a default, as shown in the following SQL query:<A NAME="ch01index151"></A><A NAME="ch01index152"></A></P>
<pre>

</pre><BR><pre>
SELECT  DEPTNO, DEPTNAME, MGRNO, VALUE(LASTNAME, '* No Mgr Name *')
FROM    DSN8810.EMP LEFT OUTER JOIN DSN8810.DEPT
          ON EMPNO = MGRNO;
</pre><BR>
<A NAME="ch01lev3sec5"></A><H5 class="docSection3Title">Types of Outer Joins</H5>
<P class="docText">There are three types of outer joins supported by DB2 for OS/390:<A NAME="ch01index153"></A><A NAME="ch01index154"></A></P>
<UL><LI><P class="docList"><TT>LEFT OUTER JOIN</TT></P></LI><LI><P class="docList"><TT>RIGHT OUTER JOIN</TT></P></LI><LI><P class="docList"><TT>FULL OUTER JOIN</TT></P></LI></UL>
<P class="docText">The keywords <TT>LEFT OUTER JOIN</TT>, <TT>RIGHT OUTER JOIN</TT> and <TT>FULL OUTER JOIN</TT> can be used in place of the <TT>INNER JOIN</TT> keyword to indicate an outer join.</P>
<P class="docText">As you might guess, the keywords <TT>RIGHT OUTER JOIN</TT> cause DB2 to return rows that have matching values in the predicate columns but also return unmatched rows from the table on the right side of the join. So the following outer join is 100% equivalent to the previous query:<A NAME="ch01index155"></A><A NAME="ch01index156"></A><A NAME="ch01index157"></A></P>
<pre>

</pre><BR><pre>
SELECT  DEPTNO, DEPTNAME, MGRNO, LASTNAME
FROM    DSN8810.DEPT RIGHT OUTER JOIN DSN8810.EMP
          ON EMPNO = MGRNO;
</pre><BR>
<P class="docText">The only code change was swapping the position of the <TT>DEPT</TT> and <TT>EMP</TT> table in the <TT>FROM</TT> clause and changing from a <TT>LEFT OUTER JOIN</TT> to a <TT>RIGHT OUTER JOIN</TT>. In general practice, consider limiting your usage of <TT>RIGHT OUTER JOIN</TT> statements, instead converting them to <TT>LEFT OUTER JOIN</TT> statements.<A NAME="ch01index158"></A><A NAME="ch01index159"></A><A NAME="ch01index160"></A></P>
<P class="docText">The remaining outer join option is the <TT>FULL OUTER JOIN</TT>. It, like all previous outer joins, returns matching rows from both tables, but it also returns non-matching rows from both tables; left and right. A <TT>FULL OUTER JOIN</TT> can use only the equal (<TT>=</TT>) comparison operator.<A NAME="ch01index161"></A><A NAME="ch01index162"></A><A NAME="ch01index163"></A></P>
<P class="docText">Left and right outer joins are able to use all the comparison operators. An example of the <TT>FULL OUTER JOIN</TT> follows:</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, WORKDEPT, DEPTNAME
FROM    DSN8810.EMP FULL OUTER JOIN DSN8810.DEPT
          ON WORKDEPT = DEPTNO;
</pre><BR>
<P class="docText">In this example, all of the following will be returned in the results set:</P>
<UL><LI><P class="docList">Rows where there are matches indicating that the employee works in a specific department (for example, where <TT>WORKDEPT</TT> in <TT>EMP</TT> matches <TT>DEPTNO</TT> in <TT>DEPT</TT>).</P></LI><LI><P class="docList">Employee rows where there is no matching department in the DEPT table (for example, where a <TT>WORKDEPT</TT> in <TT>EMP</TT> has no matching <TT>DEPTNO</TT> in <TT>DEPT</TT>). This could occur when an employee is temporarily unassigned to a department or the employee is assigned to an invalid department (or if there are data integrity problems).</P></LI><LI><P class="docList">Department rows where there is no matching work department in the <TT>EMP</TT> table (for example, where a <TT>DEPTNO</TT> in <TT>DEPT</TT> has no matching <TT>WORKDEPT</TT> in <TT>EMP</TT>). This could occur when a department has no employees assigned to it.</P></LI></UL>
<P class="docText">Coding appropriate outer join statements can be tricky. Outer joins become even more confusing when local predicates need to be applied. Consider, for example, our previous left outer join:</P>
<pre>

</pre><BR><pre>
SELECT  DEPTNO, DEPTNAME, MGRNO, VALUE(LASTNAME, '* No Mgr Name *')
FROM    DSN8810.EMP LEFT OUTER JOIN DSN8810.DEPT
          ON EMPNO = MGRNO;
</pre><BR>
<P class="docText">Now what happens if you need to apply a local predicate to this join? For example, perhaps we only want to concern ourselves with department number <TT>"A00"</TT>. The first reaction is just to add <TT>AND DEPTNO = "A00"</TT>, but this might not be correct. It all depends on what you are truly requesting. Adding this clause directly to the <TT>ON</TT> clause will cause DB2 to apply the predicate during the join. So, DB2 will retrieve all rows but only join the <TT>"A00"</TT> rows. So, you will see other <TT>DEPTNO</TT> values in your result set. This is probably not the result you intended.</P>
<P class="docText">Instead you would need to code a <TT>WHERE</TT> clause for this predicate, so it does not become part of the join criteria in the <TT>ON</TT> clause. So, our right outer join SQL statement becomes<A NAME="ch01index164"></A><A NAME="ch01index165"></A></P>
<pre>

</pre><BR><pre>
SELECT  DEPTNO, DEPTNAME, MGRNO, VALUE(LASTNAME, '* No Mgr Name *')
FROM    DSN8810.EMP LEFT OUTER JOIN DSN8810.DEPT
        ON EMPNO = MGRNO;
WHERE   DEPTNO = 'A00';
</pre><BR>
<P class="docText">This section outlines the basics of the outer join. For suggestions on coding efficient outer joins, refer to <A class="docLink" HREF="ch02.html#ch02">Chapter 2</A>.</P>
<A NAME="ch01lev2sec8"></A><H4 class="docSection2Title">Sorting and Grouping</H4>
<P class="docText">SQL also can sort and group retrieved data. The <TT>ORDER BY</TT> clause sorts the results of a query in the specified order (ascending or descending) for each column. The <TT>GROUP BY</TT> clause collates the resultant rows to apply functions that consolidate the data. By grouping data, users can use statistical functions on a column (discussed later) and eliminate non-pertinent groups of data with the <TT>HAVING</TT> clause.<A NAME="ch01index166"></A><A NAME="ch01index167"></A><A NAME="ch01index168"></A></P>
<P class="docText">For example, the following query groups employee data by department, returning the aggregate salary for each department:<A NAME="ch01index169"></A><A NAME="ch01index170"></A><A NAME="ch01index171"></A></P>
<pre>

</pre><BR><pre>
SELECT   WORKDEPT, SUM(SALARY)
FROM     DSN8810.EMP
GROUP BY WORKDEPT;
</pre><BR>
<P class="docText">By adding a <TT>HAVING</TT> clause to this query, you can eliminate aggregated data that is not required. For example, if you're interested in departments with an average salary of less than $19,500, you can code the following query:<A NAME="ch01index172"></A><A NAME="ch01index173"></A><A NAME="ch01index174"></A></P>
<pre>

</pre><BR><pre>
SELECT   WORKDEPT, SUM(SALARY)
FROM     DSN8810.EMP
GROUP BY WORKDEPT
HAVING   AVG(SALARY) &lt; 19500 ;
</pre><BR>
<P class="docText">Note that the report is not necessarily returned in any specific order. The <TT>GROUP BY</TT> clause does not sort the data for the result set; it only consolidates the data values for grouping. To return the results of this query in a particular order, you must use the <TT>ORDER BY</TT> clause. For example, to order the resultant data into descending department number order, code the following:<A NAME="ch01index175"></A><A NAME="ch01index176"></A><A NAME="ch01index177"></A><A NAME="ch01index178"></A><A NAME="ch01index179"></A><A NAME="ch01index180"></A></P>
<pre>

</pre><BR><pre>
SELECT   WORKDEPT, SUM(SALARY)
FROM     DSN8810.EMP
GROUP BY WORKDEPT
HAVING   AVG(SALARY) &lt; 17500
ORDER BY WORKDEPT;
</pre><BR>
<P class="docText">The <TT>ORDER BY</TT>, <TT>GROUP BY</TT>, and <TT>HAVING</TT> clauses are important SQL features that can increase productivity. They are the means by which you can sort and group data using SQL.<A NAME="ch01index181"></A><A NAME="ch01index182"></A><A NAME="ch01index183"></A><A NAME="ch01index184"></A><A NAME="ch01index185"></A><A NAME="ch01index186"></A></P>
<A NAME="ch01note09"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">The only way to ensure the data is returned in a specific order is to use the <TT>ORDER BY</TT> clause. When DB2 uses an index to satisfy a query, your data might be returned in the specific order you desire. However, without an <TT>ORDER BY</TT> clause, there is no guarantee that the data will always be sorted in that particular order. Changes to the access path used to satisfy the query can change the order of your results.</P>
<P class="docText">Therefore, when the order of your results set is important, <span class="docEmphStrong">always</span> specify an <TT>ORDER BY</TT> clause.</P></div><br>
<A NAME="ch01lev2sec9"></A><H4 class="docSection2Title">The Difference Between <TT>HAVING</TT> and <TT>WHERE</TT></H4>
<P class="docText">The <TT>WHERE</TT> and <TT>HAVING</TT> clauses are similar in terms of functionality. However, they operate on different types of data.</P>
<P class="docText">Any SQL statement can use a <TT>WHERE</TT> clause to indicate which rows of data are to be returned. The <TT>WHERE</TT> clause operates on "detail" data rows from tables, views, synonyms, and aliases.<A NAME="ch01index187"></A><A NAME="ch01index188"></A><A NAME="ch01index189"></A><A NAME="ch01index190"></A><A NAME="ch01index191"></A><A NAME="ch01index192"></A></P>
<P class="docText">The <TT>HAVING</TT> clause, on the other hand, operates on "aggregated" groups of information. Only SQL statements that specify the <TT>GROUP BY</TT> clause can use the <TT>HAVING</TT> clause. The predicates in the <TT>HAVING</TT> clause are applied after the <TT>GROUP BY</TT> has been applied.</P>
<P class="docText">If both a <TT>WHERE</TT> clause and a <TT>HAVING</TT> clause are coded on the same SQL statement, the following occurs:</P>
<UL><LI><P class="docList">The <TT>WHERE</TT> clause is applied to the "detail" rows</P></LI><LI><P class="docList">The <TT>GROUP BY</TT> is applied to aggregate the data</P></LI><LI><P class="docList">The <TT>HAVING</TT> clause is applied to the "aggregate" rows</P></LI></UL>
<P class="docText">Consider the following SQL:</P>
<pre>

</pre><BR><pre>
SELECT   WORKDEPT, AVG(BONUS), MAX(BONUS), MIN(BONUS)
FROM     DSN8810.EMP
WHERE    WORKDEPT NOT IN ('D11', 'D21')
GROUP BY WORKDEPT
HAVING   COUNT(*) &gt; 1;
</pre><BR>
<P class="docText">This query will return the average, maximum, and minimum bonus for each department except <TT>'D11'</TT> and <TT>'D12'</TT> as long as the department has more than 1 employee. The steps DB2 takes to satisfy this query are:</P>
<UL><LI><P class="docList">Apply the <TT>WHERE</TT> clause to eliminate departments <TT>'D11'</TT> and <TT>'D12'</TT>.</P></LI><LI><P class="docList">Apply the <TT>GROUP BY</TT> clause to aggregate the data by department.</P></LI><LI><P class="docList">Apply the <TT>HAVING</TT> clause to eliminate any department groups consisting of only one employee.<A NAME="ch01index193"></A><A NAME="ch01index194"></A><A NAME="ch01index195"></A><A NAME="ch01index196"></A><A NAME="ch01index197"></A><A NAME="ch01index198"></A></P></LI></UL>
<A NAME="ch01lev2sec10"></A><H4 class="docSection2Title">Relational Division</H4>
<P class="docText">A very useful, though somewhat complex SQL statement is relational division. Because of its complexity, developers often avoid relational division, but it is wise to understand relational division because of its power and usefulness. The <span class="docEmphasis">relational division</span> of two tables is the operation of returning rows whereby column values in one table match column values for <span class="docEmphasis">every</span> corresponding row in the other table.<A NAME="ch01index199"></A><A NAME="ch01index200"></A></P>
<P class="docText">For example, look at the following query:</P>
<pre>

</pre><BR><pre>
SELECT  DISTINCT PROJNO
FROM    DSN8810.PROJACT  P1
WHERE   NOT EXISTS
        (SELECT ACTNO
         FROM   DSN8810.ACT  A
         WHERE  NOT EXISTS
                (SELECT PROJNO
                 FROM   DSN8810.PROJACT  P2
                 WHERE  P1.PROJNO = P2.PROJNO
                 AND    A.ACTNO = P2.ACTNO));
</pre><BR>
<P class="docText">Division is implemented in SQL using a combination of correlated subqueries. This query is accomplished by coding three correlated subqueries that match projects and activities. It retrieves all projects that require every activity listed in the activity table.</P>
<A NAME="ch01note10"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">If you execute this query, no rows are returned because no projects in the sample data require all activities.</P></div><br>
<P class="docText">Relational division is a powerful operation and should be utilized whenever practical. Implementing relational division using a complex query such as the one depicted above will <span class="docEmphasis">almost</span> always out-perform an equivalent application program using separate cursors processing three individual <TT>SELECT</TT> statements. However, this query is complicated and may be difficult for novice programmers to understand and maintain as your application changes.<A NAME="ch01index201"></A><A NAME="ch01index202"></A></P>
<A NAME="ch01lev2sec11"></A><H4 class="docSection2Title"><TT>CASE</TT> Expressions</H4>
<P class="docText">The <TT>CASE</TT> expression, introduced to DB2 in V5, is similar to <TT>CASE</TT> statements used by many popular programming languages. A <TT>CASE</TT> statement uses the value of a specified expression to select one statement among several for execution. A common application of the <TT>CASE</TT> statement will be to eliminate a multi-table <TT>UNION</TT> statement; for example<A NAME="ch01index203"></A><A NAME="ch01index204"></A><A NAME="ch01index205"></A></P>
<pre>

</pre><BR><pre>
SELECT  CREATOR, NAME, 'TABLE'
FROM    SYSIBM.SYSTABLES
WHERE   TYPE = 'T'
UNION ALL
SELECT  CREATOR, NAME, 'VIEW '
FROM    SYSIBM.SYSTABLES
WHERE   TYPE = 'V'
UNION ALL
SELECT  CREATOR, NAME, 'ALIAS'
FROM    SYSIBM.SYSTABLES
WHERE   TYPE = 'A';
</pre><BR>
<P class="docText">it can be coded more simply as</P>
<pre>

</pre><BR><pre>
SELECT CREATOR, NAME,
CASE TYPE
  WHEN 'T' THEN 'TABLE'
  WHEN 'V' THEN 'VIEW '
  WHEN 'A' THEN 'ALIAS'
END
FROM SYSIBM.SYSTABLES;
</pre><BR>
<P class="docText">The <TT>WHEN</TT> clause of the <TT>CASE</TT> expression replaces the predicates from each of the <TT>SELECT</TT> statements in the <TT>UNION</TT>. When <TT>CASE</TT> is used in place of multiple <TT>UNION</TT>s, performance most likely will be improved because DB2 will make fewer passes against the data to return a result set. In the preceding example, one pass is required instead of three.</P>
<P class="docText">There are two types of <TT>CASE</TT> expressions: those with a simple <TT>WHEN</TT> clause and those with a searched <TT>WHEN</TT> clause. The previous example depicts a simple <TT>WHEN</TT> clause. Simple <TT>WHEN </TT>clauses only test for equality of an expression. Searched <TT>WHEN</TT> clauses provide more complex expression testing. An example follows:<A NAME="ch01index206"></A><A NAME="ch01index207"></A><A NAME="ch01index208"></A><A NAME="ch01index209"></A><A NAME="ch01index210"></A><A NAME="ch01index211"></A></P>
<pre>

</pre><BR><pre>
SELECT EMPNO, LASTNAME,
  CASE  WHEN SALARY &lt; 0. THEN 'ERROR'
    WHEN SALARY = 0. THEN 'NONE '
    WHEN SALARY BETWEEN 1. AND 20000. THEN 'LOW  '
    WHEN SALARY BETWEEN 20001. AND 50000. THEN 'MID  '
    WHEN SALARY BETWEEN 50001. AND 99999. THEN 'HIGH '
    ELSE '100+ '
  END
FROM DSN8810.EMP;
</pre><BR>
<P class="docText">In this case, the <TT>SALARY</TT> column is examined by the <TT>CASE</TT> expression to place it into a specific, predefined category. <TT>CASE</TT> expressions also can be specified in a <TT>WHERE</TT> clause, for example:</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, PROJNO, ACTNO, EMPTIME
FROM    DSN8810.EMPPROJACT
WHERE   (CASE WHEN
           EMPTIME=0. THEN 0.
         ELSE
           40./EMPTIME
         END) &gt; 25;
</pre><BR>
<P class="docText">This query returns data for employees who are allocated to spend more than 25 hours (of a typical 40-hour work week) on a specific activity. The <TT>CASE</TT> expression is used to avoid division by zero. Values for the <TT>EMPTIME</TT> column range from 0.0 to 1.0 and indicate the ratio of time to be spent on an activity. When <TT>EMPTIME</TT> is zero, the <TT>CASE</TT> expression substitutes zero and avoids the calculation.<A NAME="ch01index212"></A><A NAME="ch01index213"></A><A NAME="ch01index214"></A></P>
<P class="docText">Another valuable usage of the <TT>CASE</TT> expression is to perform table pivoting. A common requirement is to take a normalized table and produce denormalized query results. For example, consider the following table containing monthly sales numbers:<A NAME="ch01index215"></A><A NAME="ch01index216"></A></P>
<pre>

</pre><BR><pre>
CREATE TABLE SALES
  (SALES_MGR    INTEGER       NOT NULL,
   MONTH        INTEGER       NOT NULL,
   YEAR         CHAR(4)       NOT NULL,
   SALES_AMT    DECIMAL(11,2) NOT NULL WITH DEFAULT);
</pre><BR>
<P class="docText">The table contains 12 rows, one for each month, detailing the amount of product sold by the specified sales manager. A standard query can be produced using a simple <TT>SELECT</TT> statement. However, many users prefer to see the months strung out as columns showing one row per sales manager with a bucket for each month. This is known as table pivoting and can be produced using the following SQL statement using the <TT>CASE</TT> expression in the <TT>SELECT</TT>-list:</P>
<pre>

</pre><BR><pre>
SELECT SALES_MGR,
  MAX(CASE MONTH WHEN 1 THEN SALES_AMT ELSE NULL END) AS JAN,
  MAX(CASE MONTH WHEN 2 THEN SALES_AMT ELSE NULL END) AS FEB,
  MAX(CASE MONTH WHEN 3 THEN SALES_AMT ELSE NULL END) AS MAR,
  MAX(CASE MONTH WHEN 4 THEN SALES_AMT ELSE NULL END) AS APR,
  MAX(CASE MONTH WHEN 5 THEN SALES_AMT ELSE NULL END) AS MAY,
  MAX(CASE MONTH WHEN 6 THEN SALES_AMT ELSE NULL END) AS JUN,
  MAX(CASE MONTH WHEN 7 THEN SALES_AMT ELSE NULL END) AS JUL,
  MAX(CASE MONTH WHEN 8 THEN SALES_AMT ELSE NULL END) AS AUG,
  MAX(CASE MONTH WHEN 9 THEN SALES_AMT ELSE NULL END) AS SEP,
  MAX(CASE MONTH WHEN 10 THEN SALES_AMT ELSE NULL END) AS OCT,
  MAX(CASE MONTH WHEN 11 THEN SALES_AMT ELSE NULL END) AS NOV,
  MAX(CASE MONTH WHEN 12 THEN SALES_AMT ELSE NULL END) AS DEC
FROM  SALES
WHERE YEAR = ?
GROUP BY SALES_MGR;
</pre><BR>
<P class="docText">The results will be spread out across a single row for the year specified. Other uses for <TT>CASE</TT> include rounding numeric data (containing positive and negative numbers), performing different calculations based on type indicators, and converting two-digit dates.</P>
<P class="docText"><TT>CASE</TT> expressions can be used in an <TT>ORDER BY</TT> clause.<A NAME="ch01index217"></A><A NAME="ch01index218"></A><A NAME="ch01index219"></A></P>
<A NAME="ch01lev2sec12"></A><H4 class="docSection2Title">SQL Functions</H4>
<P class="docText">Functions can be specified in SQL statements to transform data from one state to another. Two types of functions can be applied to data in a DB2 table using SQL: <span class="docEmphasis">column functions</span> and <span class="docEmphasis">scalar functions. Column functions</span> compute, from a group of rows, a single value for a designated column or expression. For example, the <TT>SUM</TT> function can be used to add, returning the sum of the values instead of each individual value. By contrast, <span class="docEmphasis">scalar functions</span> are applied to a column or expression and operate on a single value. For example, the <TT>CHAR</TT> function converts a single date or time value into its character representation.<A NAME="ch01index220"></A><A NAME="ch01index221"></A><A NAME="ch01index222"></A><A NAME="ch01index223"></A><A NAME="ch01index224"></A><A NAME="ch01index225"></A><A NAME="ch01index226"></A><A NAME="ch01index227"></A></P>
<P class="docText">As of Version 6, DB2 added support for user-defined functions in addition to the base, system-defined functions (referred to as built-in functions, or BIFs). With user-defined functions the user can develop customized functions that can then be specified in SQL. A user-defined function can be specified anywhere a system-defined function can be specified.<A NAME="ch01index228"></A><A NAME="ch01index229"></A><A NAME="ch01index230"></A><A NAME="ch01index231"></A><A NAME="ch01index232"></A><A NAME="ch01index233"></A></P>
<P class="docText">There are two categories of user-defined functions that can be created:</P>
<UL><LI><P class="docList">User-defined scalar functions</P></LI><LI><P class="docList">User-defined table functions</P></LI></UL>
<P class="docText">Similar to system-defined scalar functions, user-defined scalar functions return a single-value answer each time it is invoked. A user-defined table function returns a complete table to the SQL statement that references it. A user-defined table function can be referenced in SQL statements in place of a DB2 table.</P>
<P class="docText">Using SQL functions can simplify the requirements of complex data access. For more details on using functions in DB2, both user-defined and system-defined, column and scalar, refer to <A class="docLink" HREF="ch03.html#ch03">Chapter 3</A>, "Using DB2 Functions" and <A class="docLink" HREF="ch04.html#ch04">Chapter 4</A>, "Using DB2 User-Defined Functions and Data Types."</P>
<A NAME="ch01lev2sec13"></A><H4 class="docSection2Title">Definition of DB2 Data Structures</H4>
<P class="docText">You can use SQL also to define DB2 data structures. DB2 data structures are referred to as <span class="docEmphasis">objects</span>. Each DB2 object is used to support the structure of the data being stored. There are DB2 objects to support groups of DASD volumes, VSAM data sets, table representations, and data order, among others. A description of each type of DB2 object follows:<A NAME="ch01index234"></A><A NAME="ch01index235"></A><A NAME="ch01index236"></A></P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5"><COLGROUP><COL width="148.5"><COL width="401.5"></COLGROUP><THEAD></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>ALIAS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">A locally defined name for a table or view in the same local DB2 subsystem or in a remote DB2 subsystem. Aliases give DB2 location independence because an alias can be created for a table at a remote site, thereby freeing the user from specifying the site that contains the data. Aliases can be used also as a type of global synonym. This is so because they can be accessed by anyone, not only by their creator (as is the case with synonyms).<A NAME="ch01index237"></A><A NAME="ch01index238"></A><A NAME="ch01index239"></A><A NAME="ch01index240"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COLUMN</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">A single, non-decomposable data element in a DB2 table.<A NAME="ch01index241"></A><A NAME="ch01index242"></A><A NAME="ch01index243"></A><A NAME="ch01index244"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DATABASE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">A logical grouping of DB2 objects related by common characteristics, such as logical functionality, relation to an application system or subsystem, or type of data. A database holds no data of its own, but exists to group DB2 objects. A database can function also as a unit of start and stop for the DB2 objects defined to it or as a unit of control for the administration of DB2 security.<A NAME="ch01index245"></A><A NAME="ch01index246"></A><A NAME="ch01index247"></A><A NAME="ch01index248"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INDEX</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">A DB2 object that consists of one or more VSAM data sets. To achieve more efficient access to DB2 tables, these data sets contain pointers ordered based on the value of data in specified columns of that table.<A NAME="ch01index249"></A><A NAME="ch01index250"></A><A NAME="ch01index251"></A><A NAME="ch01index252"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>STOGROUP</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">A series of DASD volumes assigned a unique name and used to allocate VSAM data sets for DB2 objects.<A NAME="ch01index253"></A><A NAME="ch01index254"></A><A NAME="ch01index255"></A><A NAME="ch01index256"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SYNONYM</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">An alternative, private name for a table or view. A synonym can be used only by the individual who creates it.<A NAME="ch01index257"></A><A NAME="ch01index258"></A><A NAME="ch01index259"></A><A NAME="ch01index260"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>TABLE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">A DB2 object that consists of columns and rows that define the physical characteristics of the data to be stored.<A NAME="ch01index261"></A><A NAME="ch01index262"></A><A NAME="ch01index263"></A><A NAME="ch01index264"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>TABLESPACE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">A DB2 object that defines the physical structure of the data sets used to house the DB2 table data.<A NAME="ch01index265"></A><A NAME="ch01index266"></A><A NAME="ch01index267"></A><A NAME="ch01index268"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>VIEW</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">A virtual table consisting of an SQL <TT>SELECT</TT> statement that accesses data from one or more tables or views. A view never stores data. When you access a view, the SQL statement that defines it is executed to derive the requested data.<A NAME="ch01index269"></A><A NAME="ch01index270"></A><A NAME="ch01index271"></A><A NAME="ch01index272"></A></P></TD></TR></TABLE></P><br>
<P class="docText">These objects are created with the DDL verbs of SQL, and must be created in a specific order. See <A class="docLink" HREF="#ch01fig05">Figure 1.5</A> for the hierarchy of DB2 objects.</P>
<A NAME="ch01fig05"></A><p><CENTER><H5 class="docFigureTitle">Figure 1.5. The DB2 object hierarchy.</H5><A NAME="ch01index273"></A><A NAME="ch01index274"></A><A NAME="ch01index275"></A><A NAME="ch01index276"></A>
<p class="docText"><IMG BORDER="0" width="450" height="397" SRC="images/0672326132/graphics/01fig05.gif" ALT="graphics/01fig05.gif"></p></CENTER></p><br>
<P class="docText">Also, DB2 supports the ability to create user-defined data types. Each column of a DB2 table must be assigned to a data type. Appropriately enough, the data type defines the type of data that can be stored in the column. DB2 supports the following native data types:<A NAME="ch01index277"></A><A NAME="ch01index278"></A><A NAME="ch01index279"></A><A NAME="ch01index280"></A><A NAME="ch01index281"></A></P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5"><COLGROUP><COL width="192.5"><COL width="357.5"></COLGROUP><THEAD></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CHAR</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Fixed length alphanumeric data<A NAME="ch01index282"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>VARCHAR</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Variable length alphanumeric data<A NAME="ch01index283"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>GRAPHIC</TT> <A NAME="ch01index284"></A></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Fixed length graphical data</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>VARGRAPHIC</TT><A NAME="ch01index285"></A></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Variable length graphical data</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SMALLINT</TT><A NAME="ch01index286"></A></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Small integer numbers</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INTEGER</TT> <A NAME="ch01index287"></A></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Larger integer numbers</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DECIMAL(p,s)</TT> <A NAME="ch01index288"></A></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Numeric data</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>FLOAT(n)</TT> or <TT>FLOAT</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Single precision floating point (if n&gt;21)<A NAME="ch01index289"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>FLOAT(n)</TT> or <TT>REAL</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Double precision floating point (if n&lt;21)<A NAME="ch01index290"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DATE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Calendar date data<A NAME="ch01index291"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>TIME</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Time data<A NAME="ch01index292"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>TIMESTAMP</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Combination date and time data<A NAME="ch01index293"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>ROWID</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Unique row identifier (internally generated by DB2)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BLOB</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Binary large object<A NAME="ch01index294"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CLOB</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Character large object<A NAME="ch01index295"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DBCLOB</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Double byte character large object<A NAME="ch01index296"></A></P></TD></TR></TABLE></P><br>
<P class="docText">The last three data types, <TT>BLOB</TT>, <TT>CLOB</TT>, and <TT>DBCLOB</TT>, are used to store object/relational data. Using DB2 Extenders, rich data types such as audio, video, image, and character can be supported. Although there are many native DB2 data types, DB2 also supports user-defined <TT>DISTINCT</TT> data types. User-defined <TT>DISTINCT</TT> types are covered in detail in <A class="docLink" HREF="ch04.html#ch04">Chapter 4</A>.<A NAME="ch01index297"></A><A NAME="ch01index298"></A><A NAME="ch01index299"></A><A NAME="ch01index300"></A><A NAME="ch01index301"></A><A NAME="ch01index302"></A><A NAME="ch01index303"></A><A NAME="ch01index304"></A></P>
<A NAME="ch01lev2sec14"></A><H4 class="docSection2Title">Security Control over DB2 Data Structures</H4>
<P class="docText">The data-control feature of SQL provides security for DB2 objects, data, and resources with the <TT>GRANT</TT> and <TT>REVOKE</TT> verbs. The hierarchy of DB2 security types and levels is complicated, and can be confusing at first glance (see <A class="docLink" HREF="#ch01fig06">Figure 1.6</A>).<A NAME="ch01index305"></A><A NAME="ch01index306"></A><A NAME="ch01index307"></A><A NAME="ch01index308"></A></P>
<A NAME="ch01fig06"></A><p><CENTER><H5 class="docFigureTitle">Figure 1.6. DB2 security levels.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/01fig06_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="729" SRC="images/0672326132/graphics/01fig06.gif" ALT="graphics/01fig06.gif"></p></CENTER></p><br>
<P class="docText">You can administer group and individual levels of DB2 security. A group-level security specification is composed of other group-level and individual security specifications. Individual security is a single authorization for a single object or resource.</P>
<P class="docText">The group-level authorizations are enclosed in boxes in <A class="docLink" HREF="#ch01fig06">Figure 1.6</A>. This list shows these authorizations:<A NAME="ch01index309"></A><A NAME="ch01index310"></A></P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5"><COLGROUP><COL width="192.5"><COL width="357.5"></COLGROUP><THEAD></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INSTALL SYSADM</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Authority for the entire system at installation time<A NAME="ch01index311"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SYSADM</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Authority for the entire system<A NAME="ch01index312"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INSTALL SYSOPR</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Authority for the entire system at installation time<A NAME="ch01index313"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SYSOPR</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Authority for the entire system<A NAME="ch01index314"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SYSCTRL</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Authority for the entire system, but with less access to end user data<A NAME="ch01index315"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BINDAGENT</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Authority for the entire system<A NAME="ch01index316"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PACKADM</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Authority for all packages in a specific collection or collections<A NAME="ch01index317"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DBADM</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Authority for a specific database<A NAME="ch01index318"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DBCTRL</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Authority for a specific database<A NAME="ch01index319"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DBMAINT</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Authority for a specific database<A NAME="ch01index320"></A></P></TD></TR></TABLE></P><br>
<P class="docText">Each group-level authorization is composed of the group and individual security levels connected by arrows in <A class="docLink" HREF="#ch01fig06">Figure 1.6</A>. For example, <TT>INSTALL SYSOPR</TT> is composed of <TT>IMAGCOPY</TT> authority for the DB2 Catalog and <TT>SYSOPR</TT> authority, which in turn is composed of the <TT>DISPLAY</TT>, <TT>RECOVER</TT>, <TT>STOPALL</TT>, and <TT>TRACE</TT> authorities.</P>
<P class="docText">The effective administration of these levels of security often is a job in itself. Most organizations simplify authorization to DB2 objects using secondary authids. With secondary authids, sets of similar users can be assigned to an authorization group, and security can be granted to the group. In this way, fewer <TT>GRANT</TT> and <TT>REVOKE</TT> statements are required to administer DB2 security.<A NAME="ch01index321"></A><A NAME="ch01index322"></A><A NAME="ch01index323"></A><A NAME="ch01index324"></A></P>
<P class="docText">Guidelines for the efficient utilization and administration of DB2 security are covered in <A class="docLink" HREF="ch10.html#ch10">Chapter 10</A>, "DB2 Security and Authorization."</P>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch01lev1sec1.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch01lev1sec3.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
