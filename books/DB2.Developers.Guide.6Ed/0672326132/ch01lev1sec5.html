<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>SQL Performance Factors</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch01lev1sec4.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch02.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch01lev1sec5"></A><H3 class="docSection1Title">SQL Performance Factors</H3>
<P class="docText">This first chapter discusses SQL basics, but little has been covered pertaining to SQL performance. You need at least a rudimentary knowledge of the factors affecting SQL performance before reading a discussion of the best ways to achieve optimum performance. This section is an introduction to DB2 optimization and some DB2 performance features. These topics are discussed in depth in <A class="docLink" HREF="part05.html#part05">Part V</A>, "DB2 Performance Tuning."</P>
<A NAME="ch01lev2sec15"></A><H4 class="docSection2Title">Introduction to the Optimizer</H4>
<P class="docText">The DB2 optimizer is integral to the operation of SQL statements. The optimizer, as its name implies, determines the optimal method of satisfying an SQL request. For example, consider the following statement:<A NAME="ch01index338"></A><A NAME="ch01index339"></A><A NAME="ch01index340"></A><A NAME="ch01index341"></A></P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, WORKDEPT, DEPTNAME
FROM    DSN8810.EMP,
        DSN8810.DEPT
WHERE   DEPTNO = WORKDEPT;
</pre><BR>
<P class="docText">This statement, whether embedded statically in an application program or executed dynamically, must be passed through the DB2 optimizer before execution. The optimizer parses the statement and determines the following:</P>
<UL><LI><P class="docList">Which tables must be accessed</P></LI><LI><P class="docList">Whether the tables are in partitioned table spaces or not (to determine whether or not query I/O, CPU, and Sysplex parallelism is feasible)</P></LI><LI><P class="docList">Which columns from those tables need to be returned</P></LI><LI><P class="docList">Which columns participate in the SQL statement's predicates</P></LI><LI><P class="docList">Whether there are any indexes for this combination of tables and columns</P></LI><LI><P class="docList">The order in which to evaluate the query's predicates</P></LI><LI><P class="docList">What statistics are available in the DB2 Catalog</P></LI></UL>
<P class="docText">Based on this information (and system information), the optimizer analyzes the possible access paths and chooses the best one for the given query. An access path is the navigation logic used by DB2 to access the requisite data. A "table space scan using sequential prefetch" is an example of a DB2 access path. Access paths are discussed in greater detail in <A class="docLink" HREF="part05.html#part05">Part V</A>.</P>
<P class="docText">The optimizer acts like a complex expert system. Based on models developed by IBM for estimating the cost of CPU and I/O time, the impact of uniform and non-uniform data distribution, evaluation DB2 object statistics, and the state of table spaces and indexes, the optimizer usually arrives at a good estimate of the optimal access path. Remember, though, that it is only a "best guess." Several factors can cause the DB2 optimizer to choose the wrong access path, such as incorrect or outdated statistics in the DB2 Catalog, an improper physical or logical database design, an improper use of SQL (for example, record-at-a-time processing), or bugs in the logic of the optimizer (although this occurs infrequently).</P>
<P class="docText">The optimizer usually produces a better access path than a programmer or analyst could develop manually. Sometimes, the user knows more than DB2 about the nature of the data being accessed. If this is the case, there are ways to influence DB2's choice of access path. The best policy is to allow DB2 initially to choose all access paths automatically, then challenge its decision only when performance suffers. Although the DB2 optimizer does a good job for most queries, you might need to periodically examine, modify, or influence the access paths for some SQL statements.<A NAME="ch01index342"></A><A NAME="ch01index343"></A></P>
<A NAME="ch01note11"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">As a general rule of thumb, be sure to review and tune all SQL statements prior to migrating the SQL to the production environment.</P></div><br>
<A NAME="ch01lev2sec16"></A><H4 class="docSection2Title">Influencing the Access Path</H4>
<P class="docText">DB2's optimizer determines the best access method based on the information discussed previously. However, users can influence the DB2 optimizer to choose a different access path if they know a few tricks.<A NAME="ch01index344"></A><A NAME="ch01index345"></A><A NAME="ch01index346"></A><A NAME="ch01index347"></A><A NAME="ch01index348"></A><A NAME="ch01index349"></A><A NAME="ch01index350"></A></P>
<P class="docText">To influence access path selection, users can tweak the SQL statement being optimized or update the statistics in the DB2 Catalog. Both of these methods are problematic and not recommended, but can be used as a last resort. If an SQL statement is causing severe performance degradation, you could consider using these options.</P>
<A NAME="ch01note12"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">As of DB2 V6, though, there is another option for bypassing the DB2 optimizer's access path choices. IBM calls the feature optimizer "hints." Optimizer hints are covered briefly in the next section, and in more depth in <A class="docLink" HREF="ch28.html#ch28">Chapter 28</A>, "Tuning DB2's Components."</P>
<P class="docText">Using "hints" to modify access paths usually is preferable to manually updating DB2 Catalog statistics.</P></div><br>
<P class="docText">One option is to change the SQL statement. Some SQL statements function more efficiently than others based on the version of DB2. As you learned previously, SQL is flexible; you can write functionally equivalent SQL in many ways. Sometimes, by altering the way in which an SQL statement is written, you can influence DB2 to choose a different access path.</P>
<P class="docText">The danger in coding SQL to take advantage of release-dependent features lies in the fact that DB2 continues to be enhanced and upgraded. If a future DB2 release changes the performance feature you took advantage of, your SQL statement may degrade. It usually is unwise to take advantage of a product's undocumented features, unless it is as a last resort. If this is done, be sure to document and retain information about the workaround. At a minimum, keep the following data:</P>
<UL><LI><P class="docList">The reason for the workaround (for example, for performance or functionality).</P></LI><LI><P class="docList">A description of the workaround (what exactly was changed and why).</P></LI><LI><P class="docList">If SQL is modified, keep a copy of the old SQL statement and a copy of the new SQL statement.</P></LI><LI><P class="docList">The version and release of DB2 at the time of the workaround.</P></LI></UL>
<P class="docText">The second method of influencing DB2's choice of access path is to update the statistics in the DB2 Catalog on which the optimizer relies. DB2 calculates a filter factor for each possible access path based on the values stored in the DB2 Catalog and the type of predicates in the SQL statement to be optimized. <span class="docEmphasis">Filter factors</span> estimate the number of accesses required to return the desired results. The lower the filter factor, the more rows filtered out by the access path and the more efficient the access path.<A NAME="ch01index351"></A></P>
<P class="docText">There are two methods of modifying DB2 Catalog statistics. The first is with the <TT>RUNSTATS</TT> utility. <TT>RUNSTATS</TT> can be executed for each table space that requires updated statistics. This approach is recommended because it populates the DB2 Catalog with accurate statistics based on a sampling of the data currently stored in the table spaces. Sometimes, however, accurate statistics produce an undesirable access path. To get around this, DB2 allows <TT>SYSADM</TT> users to modify the statistics stored in the DB2 Catalog. Most, but not all, of these statistical columns can be changed using SQL update statements. By changing the statistical information used by the optimization process, you can influence the access path chosen by DB2. This method can be used to<A NAME="ch01index352"></A><A NAME="ch01index353"></A><A NAME="ch01index354"></A><A NAME="ch01index355"></A><A NAME="ch01index356"></A><A NAME="ch01index357"></A><A NAME="ch01index358"></A></P>
<UL><LI><P class="docList">Mimic production volumes in a test system to determine production access paths before migrating a system to production</P></LI><LI><P class="docList">Favor certain access paths over others by specifying either lower or higher cardinality for specific tables or columns</P></LI><LI><P class="docList">Favor indexed access by changing index statistics</P></LI></UL>
<P class="docText">Examples of this are shown in <A class="docLink" HREF="ch21.html#ch21">Chapter 21</A>, along with additional information on access paths and influencing DB2.</P>
<P class="docText">Directly updating the DB2 Catalog, however, generally is not recommended. You may get unpredictable results because the values being changed will not accurately reflect the actual table space data. Additionally, if <TT>RUNSTATS</TT> is executed any time after the DB2 Catalog statistics are updated, the values placed in the DB2 Catalog by SQL update statements are overwritten. It usually is very difficult to maintain accurate statistics for some columns and inaccurate, tweaked values for other columns. To do so, you must reapply the SQL updates to the DB2 Catalog immediately after you run the <TT>RUNSTATS</TT> utility and before you run any binds or rebinds.<A NAME="ch01index359"></A><A NAME="ch01index360"></A><A NAME="ch01index361"></A><A NAME="ch01index362"></A><A NAME="ch01index363"></A><A NAME="ch01index364"></A><A NAME="ch01index365"></A></P>
<P class="docText">In order to update DB2 Catalog statistics, you must have been granted the authority to update the specific DB2 Catalog tables (or columns) or have <TT>SYSADM</TT> authority.</P>
<P class="docText">As a general rule, updating the DB2 Catalog outside the jurisdiction of <TT>RUNSTATS</TT> should be considered only as a last resort. If SQL is used to update DB2 Catalog statistics, be sure to record and maintain the following information:</P>
<UL><LI><P class="docList">The reason for the DB2 Catalog updates</P></LI><LI><P class="docList">A description of the updates applied:</P><P class="docList">Applied once; <TT>RUNSTATS</TT> never runs again</P><P class="docList">Applied initially; <TT>RUNSTATS</TT> runs without reapplying updates</P><P class="docList">Applied initially; <TT>RUNSTATS</TT> runs and updates are immediately reapplied</P></LI><LI><P class="docList">The version and release of DB2 when the updates were first applied</P></LI><LI><P class="docList">The SQL <TT>UPDATE</TT> and <TT>INSERT</TT> statements used to modify the DB2 Catalog</P></LI><LI><P class="docList">A report of the DB2 Catalog statistics overlaid by the <TT>UPDATE</TT> statements (must be produced before the initial updates)<A NAME="ch01index366"></A><A NAME="ch01index367"></A><A NAME="ch01index368"></A><A NAME="ch01index369"></A><A NAME="ch01index370"></A><A NAME="ch01index371"></A><A NAME="ch01index372"></A></P></LI></UL>
<A NAME="ch01lev2sec17"></A><H4 class="docSection2Title">DB2 Optimizer "Hints"</H4>
<P class="docText">It is possible also to use optimizer "hints" to achieve more control over the access paths chosen by DB2. Similar to the techniques just discussed for influencing access paths, optimizer "hints" should be used only as a final approach when more traditional methods do not create optimal access paths. Optimizer "hints" are also useful when you need to temporarily choose an alternate access path, and later revert back to the access path chosen by DB2.<A NAME="ch01index373"></A><A NAME="ch01index374"></A><A NAME="ch01index375"></A><A NAME="ch01index376"></A><A NAME="ch01index377"></A></P>
<A NAME="ch01note13"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">IBM uses the term "hints," but I choose to place it in quotes because the technique is not literally a hint; instead it is a directive for DB2 to use a pre-determined specified access path. IBM probably chose the term "hints" because Oracle provides optimizer hints and IBM is competing quite heavily with Oracle these days. In Oracle, a hint is implemented by coding specific comments into SQL statements—such as <TT>USE NLJ</TT> to force use of a nested-loop join.<A NAME="ch01index378"></A><A NAME="ch01index379"></A></P></div><br>
<P class="docText">The typical scenario for using an optimizer "hint" follows. Over time, a query that was previously performing well begins to experience severe performance degradation. The performance problem occurs even though the DB2 Catalog statistics are kept up-to-date using <TT>RUNSTATS</TT>, and the package and/or plan containing the SQL is rebound using the new and accurate statistics. Upon further examination, the performance analyst determines that DB2 has chosen a new access path that does not perform as well as the old access path.</P>
<P class="docText">Faced with a choice between poor performance, modifying DB2 Catalogs statistics manually, and optimizer "hints," the performance analyst chooses to use "hints." Querying the <TT>PLAN_TABLE</TT> that contains the access path information for the offending statement, the analyst finds the older access path that performed well. The analyst then uses BIND to use the "hint" in the <TT>PLAN_TABLE</TT>, redirecting DB2 to use the old access path instead of calculating a new one. More details on access path "hints" are provided in <A class="docLink" HREF="ch21.html#ch21">Chapters 21</A> and <A class="docLink" HREF="ch28.html#ch28">28</A>.<A NAME="ch01index380"></A><A NAME="ch01index381"></A><A NAME="ch01index382"></A></P>
<A NAME="ch01note14"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Be sure to thoroughly test and analyze the results of any query using optimizer "hints." If the environment has changed since the optimizer "hint" access path was chosen, the "hint" may be ignored by DB2, or only partially implemented.</P></div><br>
<A NAME="ch01lev2sec18"></A><H4 class="docSection2Title">DB2 Performance Features</H4>
<P class="docText">Finally, it is important to understand the performance features that IBM has engineered into DB2. Performance features have been added with each successive release of DB2. This section is a short synopsis of some of the DB2 performance features discussed in depth throughout this book.</P>
<A NAME="ch01lev3sec6"></A><H5 class="docSection3Title">Sequential Prefetch</H5>
<P class="docText"><span class="docEmphasis">Sequential prefetch</span> is a look-ahead <span class="docEmphasis">read engine</span> that enables DB2 to read many data pages in large chunks of pages, instead of one page at a time. It usually is invoked when a sequential scan of pages is needed. The overhead associated with I/O can be reduced with sequential prefetch because many pages are read before they must be used. When the pages are needed, they then are available without additional I/O.<A NAME="ch01index383"></A><A NAME="ch01index384"></A></P>
<P class="docText">Sequential prefetch can be invoked for both table space scans and index scans.</P>
<A NAME="ch01lev3sec7"></A><H5 class="docSection3Title">Sequential Detection</H5>
<P class="docText">DB2 can dynamically detect sequential processing and invoke sequential prefetch even if the optimizer did not specify its use. DB2 can trigger sequential detection for a query that appears at first to be random, but instead begins to process data sequentially.<A NAME="ch01index385"></A><A NAME="ch01index386"></A></P>
<A NAME="ch01lev3sec8"></A><H5 class="docSection3Title">List Prefetch</H5>
<P class="docText">When the DB2 optimizer determines that an index will increase the efficiency of access to data in a DB2 table, it may decide also to invoke <span class="docEmphasis">list prefetch</span>. List prefetch sorts the index entries into order by <span class="docEmphasis">record identifier</span> (<span class="docEmphasis">RID</span>). This sorting ensures that two index entries that must access the same page will require no more than one I/O because they now are accessed contiguously by record identifier. This reduction in I/O can increase performance.<A NAME="ch01index387"></A><A NAME="ch01index388"></A><A NAME="ch01index389"></A><A NAME="ch01index390"></A></P>
<A NAME="ch01lev3sec9"></A><H5 class="docSection3Title">Index Lookaside</H5>
<P class="docText">The <span class="docEmphasis">index lookaside</span> feature is a method employed by DB2 to traverse indexes in an optimal manner. When using an index, DB2 normally traverses the b-tree structure of the index. This can involve significant overhead in checking root and nonleaf index pages when DB2 is looking for the appropriate leaf page for the given data. When using index lookaside, DB2 checks for the RID of the desired row on the current leaf page and the immediately higher nonleaf page. For repetitive index lookups, it is usually more efficient to check recently accessed pages (that are probably still in the bufferpool), than to traverse the b-tree from the root. Index lookaside, therefore, generally reduces the path length of locating rows.<A NAME="ch01index391"></A><A NAME="ch01index392"></A></P>
<A NAME="ch01lev3sec10"></A><H5 class="docSection3Title">Index Only Access</H5>
<P class="docText">If all the data being retrieved is located in an index, DB2 can satisfy the query by accessing the index without accessing the table. Because additional reads of table pages are not required, I/O is reduced and performance is increased.<A NAME="ch01index393"></A><A NAME="ch01index394"></A></P>
<A NAME="ch01lev3sec11"></A><H5 class="docSection3Title">RDS Sorting</H5>
<P class="docText">DB2 sorting occurs in the Relational Data Services (RDS) component of DB2. (See <A class="docLink" HREF="part03.html#part03">Part III</A> for in-depth descriptions of DB2's components.) DB2's efficient sort algorithm uses a <span class="docEmphasis">tournament sort</span> technique. Additionally, with the proper hardware, DB2 can funnel sort requests to routines in microcode that significantly enhance the sort performance.<A NAME="ch01index395"></A><A NAME="ch01index396"></A><A NAME="ch01index397"></A><A NAME="ch01index398"></A></P>
<A NAME="ch01lev3sec12"></A><H5 class="docSection3Title">Operating System Exploitation</H5>
<P class="docText">DB2 exploits many features of z/OS and OS/390, including cross memory services, efficient virtual storage use, data space usage with DB2 virtual pools, hiperspace usage with DB2 hiperpools, and effective use of expanded storage, enabling the use of very large buffer pool and EDM pool specifications. The dynamic statement cache also can be stored in a data space as of DB2 Version 6.<A NAME="ch01index399"></A><A NAME="ch01index400"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> One of the biggest impacts of DB2 Version 8 is the requirement that you first must be running a zSeries machine and z/OS v1.3. DB2 V8 does not support old hardware, nor will it support OS/390. Owing to these architectural requirements, DB2 will have the ability to support large virtual memory. DB2 V8 surmounts the limitation of 2GB real storage that was imposed due to S/390's 31-bit addressing. Theoretically, with 64-bit addressing DB2 could have up to 16 exabytes of virtual storage addressability to be used by a single DB2 address space. Now there is some room for growth!</P></td></tr></table><br>
<A NAME="ch01note15"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Although z/OS V1.3 is the minimal requirement for DB2 V8, some features require z/OS V1.4 and even V1.5.</P></div><br>
<A NAME="ch01lev3sec13"></A><H5 class="docSection3Title">Stage 1 and Stage 2 Processing</H5>
<P class="docText">Sometimes referred to as <span class="docEmphasis">sargable</span> and <span class="docEmphasis">nonsargable</span> processing, Stage 1 and Stage 2 processing effectively splits the processing of SQL into separate components of DB2. Stage 1 processing is more efficient than Stage 2 processing.<A NAME="ch01index401"></A><A NAME="ch01index402"></A><A NAME="ch01index403"></A><A NAME="ch01index404"></A><A NAME="ch01index405"></A><A NAME="ch01index406"></A></P>
<P class="docText">There is no magic regarding which SQL predicates are Stage 1 and which are Stage 2. Indeed, the stage in which a predicate is evaluated can change from version to version of DB2. Usually, IBM pushes predicates from Stage 2 to Stage 1 to make them more efficient. Consult <A class="docLink" HREF="ch02.html#ch02">Chapter 2</A> for more details on Stage 1 and Stage 2 predicates.</P>
<A NAME="ch01lev3sec14"></A><H5 class="docSection3Title">Join Methods</H5>
<P class="docText">When tables must be joined, the DB2 optimizer chooses one of three methods based on many factors, including all the information referred to in the discussion on optimization. The join methods are a merge scan, a nested loop join, and a hybrid join. A <span class="docEmphasis">merge scan</span> requires reading sorted rows and merging them based on the join criteria. A <span class="docEmphasis">nested loop join</span> repeatedly reads from one table, matching rows from the other table based on the join criteria. A <span class="docEmphasis">hybrid join</span> uses list prefetch to create partial rows from one table with RIDs from an index on the other table. The partial rows are sorted, with list prefetch used to complete the partial rows.<A NAME="ch01index407"></A><A NAME="ch01index408"></A><A NAME="ch01index409"></A><A NAME="ch01index410"></A><A NAME="ch01index411"></A><A NAME="ch01index412"></A></P>
<A NAME="ch01lev3sec15"></A><H5 class="docSection3Title">Lock Escalation</H5>
<P class="docText">During application processing, if DB2 determines that performance is suffering because an inordinate number of locks have been taken, the granularity of the lock taken by the application might be escalated. Simply stated, if a program is accessing DB2 tables using page locking, and too many page locks are being used, DB2 might change the locking strategy to table space locking. This reduces the concurrency of access to the tables being manipulated, but significantly reduces overhead and increases performance for the application that was the beneficiary of the lock escalation.<A NAME="ch01index413"></A><A NAME="ch01index414"></A></P>
<A NAME="ch01lev3sec16"></A><H5 class="docSection3Title">Lock Avoidance</H5>
<P class="docText">With lock avoidance, DB2 can avoid taking locks under certain circumstances, while still maintaining data integrity. DB2 can test to see if a row or page has committed data on it. If it does then DB2 may not have to obtain a lock on the data at all. Lock avoidance reduces overhead and improves application performance for those programs that can take advantage of it.<A NAME="ch01index415"></A><A NAME="ch01index416"></A></P>
<A NAME="ch01lev3sec17"></A><H5 class="docSection3Title">Data Compression</H5>
<P class="docText">DB2 provides Lempel Ziv data compression employing hardware-assist for specific high-end CPU models or software compression for other models. Additionally, data compression can be directly specified in the <TT>CREATE TABLESPACE</TT> and <TT>ALTER TABLESPACE</TT> DDL, thereby avoiding the overhead and restrictions of an <TT>EDITPROC</TT>.<A NAME="ch01index417"></A><A NAME="ch01index418"></A><A NAME="ch01index419"></A></P>
<A NAME="ch01lev3sec18"></A><H5 class="docSection3Title">Data Sharing</H5>
<P class="docText">DB2 provides the ability to couple DB2 subsystems together enabling data to be shared between multiple DB2s. This allows applications running on more than one DB2 subsystem to read from and write to the same DB2 tables simultaneously. This was not possible in prior releases without using DB2's distributed data capabilities. Additionally, data sharing enables nonstop DB2 processing. If one subsystem becomes unavailable, workload can be shifted to other subsystems participating in the data sharing group. Refer to <A class="docLink" HREF="ch19.html#ch19">Chapter 19</A>, "Data Sharing," for an in-depth discussion of data sharing.<A NAME="ch01index420"></A><A NAME="ch01index421"></A><A NAME="ch01index422"></A></P>
<A NAME="ch01lev3sec19"></A><H5 class="docSection3Title">Query Parallelism</H5>
<P class="docText">DB2 can utilize multiple read tasks to satisfy a single SQL <TT>SELECT</TT> statement. By running multiple, simultaneous read engines the overall elapsed time for an individual query can be substantially reduced. This will aid I/O-bound queries.<A NAME="ch01index423"></A><A NAME="ch01index424"></A></P>
<P class="docText">DB2 V4 improved on query I/O parallelism by enabling queries to utilize CPU in parallel. When CPU parallelism is engaged, each concurrent read engine will utilize its own portion of the central processor. This will aid processor-bound queries.</P>
<P class="docText">DB2 V5 improved parallelism even further with Sysplex query parallelism. With Sysplex query parallelism DB2 can spread the work for a single query across multiple DB2 subsystems in a data sharing group. This will further aid intensive, processor-bound queries.</P>
<P class="docText">DB2 V6 further improved parallelism by enabling data accessed in a non-partitioned table space to use query parallelism.</P>
<A NAME="ch01lev3sec20"></A><H5 class="docSection3Title">Partition Independence</H5>
<P class="docText">Using resource serialization, DB2 has the ability to process a single partition while permitting concurrent access to independent partitions of the same table space by utilities and SQL. This partition independence enhances overall data availability by enabling users concurrent access to data in separate partitions.<A NAME="ch01index425"></A><A NAME="ch01index426"></A></P>
<A NAME="ch01lev3sec21"></A><H5 class="docSection3Title">Limited Partition Scanning</H5>
<P class="docText">When processing against a partitioned table space, DB2 can enhance the performance of table space scans by limiting the partitions that are read. A limited partition table space scan will only read the specific range of partitions required based on the specified predicates in the <TT>WHERE</TT> clause.<A NAME="ch01index427"></A><A NAME="ch01index428"></A></P>
<P class="docText">DB2 V5 further modified partition scanning to enable skipping partitions in the middle of a range.</P>
<A NAME="ch01lev3sec22"></A><H5 class="docSection3Title">Uncommitted Read, a.k.a. "Dirty" Read</H5>
<P class="docText">When data integrity is not an issue, DB2 can bypass locking and enable readers to access data regardless of its state. The "UR" isolation level provides a dirty read by allowing a <TT>SELECT</TT> statement to access data that is locked, in the process of being deleted, inserted but not yet committed, or, indeed in <span class="docEmphasis">any</span> state. This can greatly enhance performance in certain situations.<A NAME="ch01index429"></A><A NAME="ch01index430"></A></P>
<A NAME="ch01note16"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Never use DB2's dirty read capability without a complete understanding of its ramifications on data integrity. For more information on uncommitted read processing refer to <A class="docLink" HREF="ch02.html#ch02">Chapter 2</A> for statement level usage; and <A class="docLink" HREF="ch13.html#ch13">Chapter 13</A>, "<A class="docLink" HREF="ch13.html#ch13">Program Preparation</A>," for plan and package level usage.</P></div><br>
<A NAME="ch01lev3sec23"></A><H5 class="docSection3Title">Run Time Reoptimization</H5>
<P class="docText">DB2 can reoptimize static and dynamic SQL statements that rely on input variables in the <TT>WHERE</TT> clause during processing. This feature enables DB2 to optimize SQL statements after the host variable, parameter marker, and special register values are known. Run time reoptimization can result in better access paths (albeit at a cost).<A NAME="ch01index431"></A><A NAME="ch01index432"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> DB2 V8 adds the capability to reoptimize variables once—the first time the statement is executed, instead of every time.</P></td></tr></table><br>
<A NAME="ch01lev3sec24"></A><H5 class="docSection3Title">Instrumentation Facility Interface (IFI)</H5>
<P class="docText">DB2 provides the Instrumentation Facility Interface, better known to DB2 professionals as IFI. The IFI is a facility for gathering trace data enabling users to better monitor and tune the DB2 environment. Using the DB2 IFI users can submit DB2 commands, obtain trace information, and pass data to DB2.<A NAME="ch01index433"></A><A NAME="ch01index434"></A><A NAME="ch01index435"></A></P>
<A NAME="ch01lev3sec25"></A><H5 class="docSection3Title">Dynamic System Parameters</H5>

<P class="docText">Changing DB2 system parameters, commonly referred to as <TT>DSNZPARM</TT>s or simply ZPARMs, required DB2 to be stopped and restarted prior to Version 7. Due to rising availability requirements, in large part spurred by the Internet, many (but not all) ZPARMs can be changed on the fly—without requiring DB2 to be recycled. This capability offers DBAs and system administrators greater flexibility and adaptability to respond to system and performance problems.<A NAME="ch01index436"></A><A NAME="ch01index437"></A><A NAME="ch01index438"></A><A NAME="ch01index439"></A></P>
<A NAME="ch01lev3sec26"></A><H5 class="docSection3Title">Historical and Real-Time Statistics</H5>

<P class="docText">AS of V7 DB2 now stores historical statistical details in the DB2 Catalog. Previous DB2 versions simply overlaid old statistics with new whenever <TT>RUNSTATS</TT> was run. By keeping historical statistics DBAs can now compare current DB2 object characteristics with past statistics. Such comparisons can be helpful to tune queries and to predict performance results based on history.<A NAME="ch01index440"></A><A NAME="ch01index441"></A><A NAME="ch01index442"></A><A NAME="ch01index443"></A></P>
<P class="docText">IBM also added support for real-time statistics as a feature upgrade in between Version 7 and 8. Real-time stats are collected by DB2 during normal operations—without requiring a separate utility (such as <TT>RUNSTATS</TT>) to be run. The additional real-time statistics provide growth and performance information to help DBAs determine when maintenance tasks, such as reorganization, should be scheduled.</P>
<A NAME="ch01lev3sec27"></A><H5 class="docSection3Title">Materialized Query Tables</H5>

<P class="docText">Data warehousing queries regularly involve complex operations on large amounts of data. To reduce the amount of time required to respond to such queries, DB2 Version 8 introduced materialized query tables (or MQTs). Using an MQT, DB2 stores data derived from one or more source tables. This materialized data can be summarized, joined, and combined using SQL operations, but the data is stored so the data warehousing queries operate more efficiently. Consult <A class="docLink" HREF="ch45.html#ch45">Chapter 45</A> for more details on materialized query tables.<A NAME="ch01index444"></A><A NAME="ch01index445"></A><A NAME="ch01index446"></A><A NAME="ch01index447"></A></P>
<A NAME="ch01lev3sec28"></A><H5 class="docSection3Title">Data Partitioned Secondary Indexes</H5>

<P class="docText">One of the biggest problems faced by DBAs when they are managing large partitioned DB2 table spaces is contending with non-partitioned indexes. DB2 Version 8 helps to alleviate this problem with data partitioned secondary indexes (or DPSIs). A DPSI is basically a partitioned NPI. So, DPSIs are partitioned based on the data rows—similar to a partitioning index. The number of parts in the index will be equal to the number of parts in the table space—even though the DPSI is created based on columns different from those used to define the partitioning scheme for the table space. Therefore, partition 1 of the DPSI will be for the same rows as partition 1 of the table space and partition 1 of the partitioning index, and so on.<A NAME="ch01index448"></A><A NAME="ch01index449"></A><A NAME="ch01index450"></A><A NAME="ch01index451"></A></P>
<P class="docText">These changes to DB2 V8 provide many benefits, including</P>
<UL><LI><P class="docList">The ability to cluster by a secondary index</P></LI><LI><P class="docList">The ability to drop and rotate partitions easily</P></LI><LI><P class="docList">Less data sharing overhead</P></LI></UL>
<P class="docText">Be careful though, because converting to a DPSI can require that your queries be rewritten in order to use the DPSI instead of a table space scan.</P>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch01lev1sec4.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch02.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
