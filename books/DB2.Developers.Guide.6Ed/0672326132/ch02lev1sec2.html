<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>SQL Access Guidelines</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch02lev1sec1.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch02lev1sec3.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch02lev1sec2"></A><H3 class="docSection1Title">SQL Access Guidelines</H3>
<P class="docText">The SQL access guidelines will help you develop efficient data retrieval SQL for DB2 applications. Test them to determine their usefulness and effectiveness in your environment.<A NAME="ch02index10"></A><A NAME="ch02index11"></A><A NAME="ch02index12"></A><A NAME="ch02index13"></A></P>
<A NAME="ch02lev4sec1"></A><H4 class="docSection2Title">Pretest All Embedded SQL</H4>
<P class="docText">Before embedding SQL in an application program, you should test it using <TT>SPUFI</TT>, <TT>QMF</TT>, or whatever ad hoc query tool you have available. This way, you can reduce the amount of program testing by ensuring that all SQL code is syntactically correct and efficient. Only after the SQL statements have been thoroughly tested and debugged should they be placed in an application program.<A NAME="ch02index14"></A><A NAME="ch02index15"></A><A NAME="ch02index16"></A><A NAME="ch02index17"></A><A NAME="ch02index18"></A></P>
<A NAME="ch02lev4sec2"></A><H4 class="docSection2Title">Use <TT>EXPLAIN</TT></H4>
<P class="docText">Use the <TT>EXPLAIN</TT> command to gain further insight into the performance potential for each SQL statement in an application. When <TT>EXPLAIN</TT> is executed on an SQL statement or application plan, information about the access path chosen by the optimizer is provided. This information is inserted into a DB2 table called the <TT>PLAN_TABLE</TT>. By querying the <TT>PLAN_TABLE</TT>, an analyst can determine the potential efficiency of SQL queries. <A class="docLink" HREF="part05.html#part05">Part V</A>, "DB2 Performance Tuning," provides a complete description of the <TT>EXPLAIN</TT> command and guidelines for interpreting its output. <TT>EXPLAIN</TT> also populates the <TT>DSN_STATEMNT_TABLE</TT> with statement cost information and the <TT>DSN_FUNCTION_TABLE</TT> table with information about user-defined function usage.<A NAME="ch02index19"></A><A NAME="ch02index20"></A><A NAME="ch02index21"></A><A NAME="ch02index22"></A><A NAME="ch02index23"></A></P>
<P class="docText">Use <TT>EXPLAIN</TT> and analyze the results for each SQL statement before it is migrated to the production application. Following this procedure is important not only for SQL statements in application programs, but also for canned QMF queries, and any other, predictable, dynamic SQL queries. For application programs, <TT>EXPLAIN</TT> can be used with the <TT>EXPLAIN</TT> option of the <TT>BIND</TT> command. Specifying <TT>EXPLAIN(YES)</TT> when you use <TT>BIND</TT> on an application plan or package provides the access path information necessary to determine the efficiency of the statements in the program. For a QMF (or ad hoc) query, use <TT>EXPLAIN</TT> on it before allowing the statement to be used in production procedures.</P>
<P class="docText">The following is an example of running <TT>EXPLAIN</TT> for a <TT>SELECT</TT> statement:</P>
<pre>

</pre><BR><pre>
EXPLAIN PLAN SET QUERYNO = 1 FOR
     SELECT  *
     FROM    DSN8810.DEPT
     WHERE   DEPTNO = 'D21';
</pre><BR>
<P class="docText"><TT>EXPLAIN</TT> enables a programmer or DBA to analyze the chosen access path by studying the <TT>PLAN_TABLE</TT>.</P>
<P class="docText">Because <TT>EXPLAIN</TT> provides access path information based on the statistics stored in the DB2 Catalog, you should keep these statistics current and accurate. Sometimes you must "fudge" the DB2 Catalog statistics to produce production access paths in a test environment. (See the section, "<A class="docLink" HREF="ch01lev1sec5.html#ch01lev2sec16">Influencing the Access Path</A>," in <A class="docLink" HREF="ch01.html#ch01">Chapter 1</A> for more information.)<A NAME="ch02index24"></A><A NAME="ch02index25"></A><A NAME="ch02index26"></A><A NAME="ch02index27"></A><A NAME="ch02index28"></A></P>
<A NAME="ch02lev4sec3"></A><H4 class="docSection2Title">Use All <TT>PLAN_TABLE</TT> Columns Available</H4>
<P class="docText">Each new release or version of DB2 adds new columns to the <TT>PLAN_TABLE</TT>. These new columns are used to report on new access paths and features. Sometimes shops fail to add the new <TT>PLAN_TABLE</TT> columns after a new release is installed. Be sure to verify that the <TT>PLAN_TABLE</TT> actually contains every column that is available for the current DB2 release being run. For more information on the <TT>PLAN_TABLE</TT> and the columns available for each DB2 release, refer to <A class="docLink" HREF="ch25.html#ch25">Chapter 25</A>, "Using EXPLAIN."<A NAME="ch02index29"></A><A NAME="ch02index30"></A><A NAME="ch02index31"></A><A NAME="ch02index32"></A><A NAME="ch02index33"></A><A NAME="ch02index34"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><P class="docText"> For DB2 V7, the following columns were added to the <TT>PLAN_TABLE</TT> to offer additional information on table functions, temporary intermediate result tables, and work files:</P></td></tr></table><br>
<UL><LI><p class="docText">
<TT>PARENT_QBLOCK</TT>— 
<TT>SMALLINT</TT></p></LI><LI><p class="docText">
<TT>TABLE_TYPE</TT>— 
<TT>CHAR(1)</TT></p></LI></UL>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> For DB2 V8, the following columns were added to the <TT>PLAN_TABLE</TT>:</P></td></tr></table><br>
<UL><LI><p class="docText">
<TT>TABLE_ENCODE</TT>— 
<TT>CHAR(1)</TT></p></LI><LI><p class="docText">
<TT>TABLE_SCCSID</TT>— 
<TT>SMALLINT</TT></p></LI><LI><p class="docText">
<TT>TABLE_MCCSID</TT>— 
<TT>SMALLINT</TT></p></LI><LI><p class="docText">
<TT>TABLE_DCCSID</TT>— 
<TT>SMALLINT</TT></p></LI><LI><p class="docText">
<TT>ROUTINE_ID</TT>— 
<TT>INTEGER</TT><A NAME="ch02index35"></A><A NAME="ch02index36"></A><A NAME="ch02index37"></A><A NAME="ch02index38"></A><A NAME="ch02index39"></A><A NAME="ch02index40"></A></p></LI></UL>
<A NAME="ch02lev4sec4"></A><H4 class="docSection2Title">Use the <TT>DSN_STATEMNT_TABLE</TT></H4>
<P class="docText">As of DB2 V6, <TT>EXPLAIN</TT> also can determine an estimated cost of executing SQL <TT>SELECT</TT>, <TT>INSERT</TT>, <TT>UPDATE</TT>, or <TT>DELETE</TT> statements. <TT>EXPLAIN</TT> will populate <TT>DSN_STATEMNT_TABLE</TT>, also known as the statement table, at the same time it populates the <TT>PLAN_TABLE</TT>. After running <TT>EXPLAIN</TT>, the statement table will contain cost estimates, in service units and in milliseconds, for the SQL statements being bound or prepared (both static and dynamic SQL).<A NAME="ch02index41"></A><A NAME="ch02index42"></A><A NAME="ch02index43"></A><A NAME="ch02index44"></A><A NAME="ch02index45"></A><A NAME="ch02index46"></A></P>
<P class="docText">The estimates can be used to help determine the cost of running SQL statements. However, keep in mind that the cost numbers are just estimates. Factors that can cause the estimates to be inaccurate include cost adjustments caused by parallel processing, the use of triggers and user-defined functions, and inaccurate statistics.</P>
<P class="docText">For more information on statement tables and cost estimates, see <A class="docLink" HREF="ch25.html#ch25">Chapter 25</A>.</P>
<A NAME="ch02lev4sec5"></A><H4 class="docSection2Title">Use <TT>DSN_FUNCTION_TABLE</TT> to Explain User-Defined Function Usage</H4>
<P class="docText">If you have implemented user-defined functions (UDFs), be sure to create <TT>DSN_FUNCTION_TABLE</TT>, also known as the function table. DB2 inserts data into <TT>DSN_FUNCTION_TABLE</TT> for each function referenced in an SQL statement when <TT>EXPLAIN</TT> is executed on an SQL statement containing a UDF or when a program bound with <TT>EXPLAIN(YES)</TT> executes an SQL statement containing a UDF.<A NAME="ch02index47"></A><A NAME="ch02index48"></A><A NAME="ch02index49"></A><A NAME="ch02index50"></A><A NAME="ch02index51"></A><A NAME="ch02index52"></A></P>
<P class="docText">The data DB2 inserts to the function table contains information on how DB2 resolves the user-defined function references. This information can be quite useful when tuning or debugging SQL that specifies a UDF.</P>
<P class="docText">For more information on using <TT>EXPLAIN</TT> with the function table, see <A class="docLink" HREF="ch04.html#ch04">Chapter 4</A>, "Using DB2 User-Defined Functions and Data Types."</P>
<A NAME="ch02lev4sec6"></A><H4 class="docSection2Title">Enable <TT>EXPLAIN</TT> for <TT>Auto Rebind</TT></H4>
<P class="docText"><TT>EXPLAIN</TT> during <TT>auto rebind</TT> can be enabled if you set an appropriate <TT>DSNZPARM</TT>. An <TT>auto rebind</TT> occurs when an authorized user attempts to execute an invalid plan or package. To revalidate the plan or package, DB2 will automatically rebind it. If <TT>EXPLAIN</TT> during <TT>auto rebind</TT> is not turned on, then you will not have a record of the new access paths that were created. The <TT>DSNZPARM</TT> for auto rebind is <TT>ABIND</TT> (the default is <TT>YES</TT>); the <TT>DSNZPARM</TT> for binding during auto rebind is <TT>ABEXP</TT> (the default is <TT>YES</TT>).<A NAME="ch02index53"></A><A NAME="ch02index54"></A><A NAME="ch02index55"></A><A NAME="ch02index56"></A><A NAME="ch02index57"></A><A NAME="ch02index58"></A><A NAME="ch02index59"></A></P>
<P class="docText">Plans and packages are invalidated when an object that an access path in the plan or package is using is dropped. Be sure that a proper <TT>PLAN_TABLE</TT> exists before enabling the <TT>EXPLAIN</TT> during <TT>auto rebind</TT> option.</P>
<A NAME="ch02lev4sec7"></A><H4 class="docSection2Title">When Data Sharing Specify <TT>COEXIST</TT> for <TT>Auto Rebind</TT></H4>
<P class="docText">If you are running in a data sharing environment, consider specifying <TT>COEXIST</TT> for <TT>ABIND</TT>. Doing so allows automatic rebind operations to be performed in a DB2 data sharing coexistence environment only when the plan or package is invalid, or when it was last bound on a new subsystem other than the one on which it is running. In this way, DB2 can keep the new access path even when a query is run in an older subsystem. Of course, DB2 will not magically use V7 features on a V6 subsystem (for example).<A NAME="ch02index60"></A><A NAME="ch02index61"></A><A NAME="ch02index62"></A><A NAME="ch02index63"></A></P>
<A NAME="ch02note03"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">When all members of a data sharing group have been migrated to the same DB2 version, <TT>ABIND COEXIST</TT> will be interpreted the same as <TT>ABIND YES</TT>.</P></div><br>
<A NAME="ch02lev4sec8"></A><H4 class="docSection2Title">Utilize Visual Explain and Query Analysis Tools</H4>
<P class="docText">Visual Explain is a tool provided by IBM as a free feature of DB2 for z/OS. Visual Explain will display graphical representations of the DB2 access paths and advice on how to improve SQL performance. The display can be for access paths stored in a <TT>PLAN_TABLE</TT> or for <TT>EXPLAIN</TT> output from dynamic SQL statements.<A NAME="ch02index64"></A><A NAME="ch02index65"></A><A NAME="ch02index66"></A><A NAME="ch02index67"></A></P>
<P class="docText">One of the nice features of Visual Explain is its ability to display pertinent DB2 Catalog statistics for objects referenced in an access path. It is much easier to understand access paths from the visual representations of Visual Explain, than it is to interpret <TT>PLAN_TABLE</TT> output. Refer to <A class="docLink" HREF="#ch02fig01">Figure 2.1</A> for a sample Visual Explain screen shot.</P>
<A NAME="ch02fig01"></A><p><CENTER><H5 class="docFigureTitle">Figure 2.1. Visual Explain graphically depicts an <TT>EXPLAIN</TT>.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/02fig01_alt.jpg">[View full size image]</a></div><IMG BORDER="0"  width="500" height="375" SRC="images/0672326132/graphics/02fig01.gif" ALT="graphics/02fig01.gif"></p></CENTER></p><br>
<P class="docText">You must run Visual Explain from a client workstation (there is no TSO or ISPF interface).</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> Significant improvements were made to the Visual Explain tool for DB2 Version 8. More detailed information is provided about access paths and more statistical details are available for each node in the query access graph. Furthermore, Visual Explain works with XML to document query access paths.<A NAME="ch02index68"></A><A NAME="ch02index69"></A><A NAME="ch02index70"></A><A NAME="ch02index71"></A></P></td></tr></table><br>
<P class="docText">Even with all of the new functionality of Visual Explain, you may need to augment this tool with more in-depth SQL tuning options. To isolate potential performance problems in application plans or single SQL statements, utilize all available analysis tools, such as BMC Software's SQL Explorer or Computer Associates' Plan Analyzer. These products analyze the SQL code, provide a clear, textual description of the access path selected by the DB2 optimizer, and recommend alternative methods of coding your queries. They are similar in function to Visual Explain, but provide an ISPF interface and more in-depth tuning recommendations.<A NAME="ch02index72"></A><A NAME="ch02index73"></A><A NAME="ch02index74"></A><A NAME="ch02index75"></A><A NAME="ch02index76"></A></P>
<A NAME="ch02lev4sec9"></A><H4 class="docSection2Title">Avoid <TT>SELECT *</TT></H4>
<P class="docText">As a general rule, a query should <span class="docEmphasis">never</span> ask DB2 for anything more than is required to satisfy the desired task. Each query should access only the columns needed for the function to be performed. Following this dictum results in maximum flexibility and efficiency.<A NAME="ch02index77"></A><A NAME="ch02index78"></A><A NAME="ch02index79"></A><A NAME="ch02index80"></A></P>
<A NAME="ch02note04"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Another cardinal rule of database performance is "never say <span class="docEmphasis">always</span> or <span class="docEmphasis">never</span>." Well, perhaps this rule is better stated as "<span class="docEmphasis">almost</span> never say always or never." There are very few times in this text where I will say "always" or "never," but there are a few, such as <span class="docEmphasis">never</span> asking DB2 for anything more than is required.</P></div><br>
<P class="docText">The gain in flexibility is the result of decreased maintenance on application programs. Consider a table in which columns are modified, deleted, or added. Only programs that access the affected columns need to be changed. When a program uses <TT>SELECT *</TT>, however, every column in the table is accessed. The program must be modified when any of the columns change, even if the program doesn't use the changed columns. This use complicates the maintenance process.</P>
<P class="docText">For example, consider a program that contains the following statement:</P>
<pre>

</pre><BR><pre>
EXEC SQL
     SELECT  *
     INTO    :DEPTREC
     FROM    DSN8810.DEPT
     WHERE   DEPTNO = :HV-DEPT
END-EXEC.
</pre><BR>
<P class="docText">Suppose that the program is developed, tested, and migrated to the production environment. You then add a column to the <TT>DEPT</TT> table. The program then fails to execute the preceding statement because the <TT>DEPTREC</TT> layout does not contain the new column. (This program was compiled with the old <TT>DCLGEN</TT>.) The program must be recompiled with the new <TT>DCLGEN</TT>, a step that is not required when the program asks for only the columns it needs.</P>
<P class="docText">Additionally, by limiting your query to only those columns necessary</P>
<UL><LI><P class="docList">The programmer does not need extra time to code for the extraneous columns.</P></LI><LI><P class="docList">You avoid the DB2 overhead required to retrieve the extraneous columns. Overhead will be incurred because there is work required to move each column.</P></LI><LI><P class="docList">DB2 might be able to use an index-only access path that is unavailable for <TT>SELECT *</TT>.<A NAME="ch02index81"></A><A NAME="ch02index82"></A><A NAME="ch02index83"></A><A NAME="ch02index84"></A></P></LI></UL>
<A NAME="ch02lev4sec10"></A><H4 class="docSection2Title">Limit the Data Selected</H4>
<P class="docText">Return the minimum number of columns and rows needed by your application program. Do not code generic queries (such as <TT>SELECT</TT> statements without a <TT>WHERE</TT> clause) that return more rows than necessary, and then filter the unnecessary rows with the application program. Doing so wastes disk I/O by retrieving useless data and wastes CPU and elapsed time returning the additional, unneeded rows to your program.<A NAME="ch02index85"></A><A NAME="ch02index86"></A><A NAME="ch02index87"></A><A NAME="ch02index88"></A></P>
<P class="docText">Allowing DB2 to use <TT>WHERE</TT> clauses to limit the data to be returned is more efficient than filtering data programmatically after it has been returned.</P>
<A NAME="ch02lev4sec11"></A><H4 class="docSection2Title">Do Not Ask for What You Already Know</H4>
<P class="docText">This might sound obvious, but most programmers violate this rule at one time or another. For a typical example, consider what's wrong with this SQL statement:<A NAME="ch02index89"></A><A NAME="ch02index90"></A><A NAME="ch02index91"></A><A NAME="ch02index92"></A></P>
<pre>

</pre><BR><pre>
SELECT   EMPNO, LASTNAME, SALARY
FROM     DSN8810.EMP
WHERE    EMPNO = '000010';
</pre><BR>
<P class="docText">Give up? The problem is that <TT>EMPNO</TT> is included in the <TT>SELECT</TT>-list. You already know that <TT>EMPNO</TT> will be equal to the value <TT>'000010'</TT> because that is what the <TT>WHERE</TT> clause tells DB2 to do. But with <TT>EMPNO</TT> listed in the <TT>WHERE</TT> clause, DB2 will dutifully retrieve that column, too. This incurs additional overhead for each qualifying row, thereby degrading performance. So, this statement would be better coded this way:</P>
<pre>

</pre><BR><pre>
SELECT   LASTNAME, SALARY
FROM     DSN8810.EMP
WHERE    EMPNO = '000010';
</pre><BR>
<A NAME="ch02lev4sec12"></A><H4 class="docSection2Title">Singleton <TT>SELECT</TT> Versus the Cursor</H4>
<P class="docText">To return a single row, an application program can use a cursor or a singleton <TT>SELECT</TT>. A cursor requires an <TT>OPEN</TT>, <TT>FETCH</TT>, and <TT>CLOSE</TT> to retrieve one row, whereas a singleton <TT>SELECT</TT> requires only <TT>SELECT...INTO</TT>. Usually, the singleton <TT>SELECT</TT> outperforms the cursor.<A NAME="ch02index93"></A><A NAME="ch02index94"></A><A NAME="ch02index95"></A><A NAME="ch02index96"></A><A NAME="ch02index97"></A><A NAME="ch02index98"></A><A NAME="ch02index99"></A><A NAME="ch02index100"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><P class="docText"> This is especially true for DB2 V7 and later releases because the <TT>FETCH FIRST 1 ROW ONLY</TT> clause can be added to any <TT>SELECT</TT> statement (both singleton <TT>SELECT</TT>s and cursors) to ensure that only one row is ever returned. Historically, the biggest problem associated with using a singleton <TT>SELECT</TT> is managing what happens when more than one row can be returned. DB2 will return a <TT>SQLCODE</TT> of <TT>–811</TT> if more than one row results from a singleton <TT>SELECT</TT>. By adding <TT>FETCH FIRST 1 ROW ONLY</TT> to the singleton <TT>SELECT</TT>, though, DB2 will never return more than one row.</P></td></tr></table><br>
<A NAME="ch02lev4sec13"></A><H4 class="docSection2Title">Avoid Singleton <TT>SELECT</TT> When Modifying Data</H4>
<P class="docText">When developing a program to retrieve data that must be subsequently modified, avoid using a singleton <TT>SELECT</TT>. When the selected row must be updated after it is retrieved, using a cursor with the <TT>FOR UPDATE OF</TT> clause is recommended over a singleton <TT>SELECT</TT>. The <TT>FOR UPDATE OF</TT> clause ensures the integrity of the data in the row because it causes DB2 to hold an X lock on the page containing the row to be updated. If you use a singleton <TT>SELECT</TT>, the row can be updated by someone else after the singleton <TT>SELECT</TT> but before the subsequent <TT>UPDATE</TT>, thereby causing the intermediate modification to be lost.<A NAME="ch02index101"></A><A NAME="ch02index102"></A><A NAME="ch02index103"></A><A NAME="ch02index104"></A><A NAME="ch02index105"></A><A NAME="ch02index106"></A><A NAME="ch02index107"></A><A NAME="ch02index108"></A></P>
<A NAME="ch02lev4sec14"></A><H4 class="docSection2Title">Use <TT>FOR READ ONLY</TT></H4>
<P class="docText">When a <TT>SELECT</TT> statement is used only for retrieval, code the <TT>FOR READ ONLY</TT> clause. This clause enables DB2 to use <span class="docEmphasis">block fetch</span>, which returns fetched rows more efficiently for distributed DB2 requests. Efficient row fetches are important for dynamic SQL in an application program or <TT>SPUFI</TT>. Furthermore, the <TT>FOR READ ONLY</TT> clause can be used to encourage DB2 to use lock avoidance techniques and parallelism.<A NAME="ch02index109"></A><A NAME="ch02index110"></A><A NAME="ch02index111"></A><A NAME="ch02index112"></A><A NAME="ch02index113"></A><A NAME="ch02index114"></A><A NAME="ch02index115"></A></P>
<P class="docText">QMF automatically appends <TT>FOR READ ONLY</TT> to <TT>SELECT</TT> statements. Static SQL embedded in an application program automatically uses block fetch if the <TT>BIND</TT> process determines it to be feasible.</P>
<P class="docText">Allowing block fetch is important in a distributed DB2 environment. If data is blocked, less overhead is required as data is sent over the communication lines.</P>
<A NAME="ch02note05"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">The <TT>FOR FETCH ONLY</TT> clause provides the same function as <TT>FOR READ ONLY</TT>, but <TT>FOR READ ONLY</TT> is preferable because it is ODBC-compliant.</P></div><br>
<A NAME="ch02lev4sec15"></A><p><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><H4 class="docSection2Title">Control Distributed Query Blocks Using <TT>OPTIMIZE FOR </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS</TT></H4></td></tr></table></p>

<P class="docText">Additionally, consider using the <TT>OPTIMIZE FOR </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS</TT> clause to optimize network traffic. If your application opens a cursor and downloads a great amount of data, specifying a large value for <span class="docEmphasis"><TT>n</TT></span> increases the number of DRDA query blocks that a DB2 server returns in each network transmission for a non-scrollable cursor. If <span class="docEmphasis"><TT>n</TT></span> is greater than the number of rows that fit in a DRDA query block, <TT>OPTIMIZE FOR </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS</TT> lets the DRDA client request multiple blocks of query data on each network transmission instead of requesting a new block when the first block is full.<A NAME="ch02index116"></A><A NAME="ch02index117"></A><A NAME="ch02index118"></A><A NAME="ch02index119"></A><A NAME="ch02index120"></A><A NAME="ch02index121"></A><A NAME="ch02index122"></A></P>
<A NAME="ch02lev4sec16"></A><H4 class="docSection2Title">Use <TT>DISTINCT</TT> with Care</H4>
<P class="docText">The <TT>DISTINCT</TT> verb removes duplicate rows from an answer set. If duplicates will not cause a problem, do not code <TT>DISTINCT</TT> because it might add to overhead if it must invoke a sort to remove the duplicates.<A NAME="ch02index123"></A><A NAME="ch02index124"></A><A NAME="ch02index125"></A><A NAME="ch02index126"></A><A NAME="ch02index127"></A><A NAME="ch02index128"></A><A NAME="ch02index129"></A><A NAME="ch02index130"></A><A NAME="ch02index131"></A></P>
<P class="docText">However, do not avoid <TT>DISTINCT</TT> for performance reasons if you must remove duplicates from your result set. It is better for DB2 to remove the duplicates than for the results to be passed to the program and then having the duplicates removed by application logic. One major benefit is that DB2 will not make any mistakes, but the application logic could contain bugs.</P>
<P class="docText">For example, the following SQL will return a list of all departments to which an employee has been assigned with no duplicate <TT>WORKDEPT</TT> values returned:</P>
<pre>

</pre><BR><pre>
SELECT  DISTINCT WORKDEPT
FROM    DSN8810.EMP;
</pre><BR>
<A NAME="ch02lev4sec17"></A><H4 class="docSection2Title">Consider Using Multiple <TT>DISTINCT</TT> Clauses</H4>
<P class="docText">The <TT>DISTINCT</TT> keyword can be used at the statement level or at the column level. When used at the statement level, for example<A NAME="ch02index132"></A><A NAME="ch02index133"></A><A NAME="ch02index134"></A></P>
<pre>

</pre><BR><pre>
SELECT  DISTINCT LASTNAME, WORKDEPT
FROM    DSN8810.EMP;
</pre><BR>
<P class="docText">duplicate rows are removed from the result set. So, only one <TT>LASTNAME</TT> – <TT>WORKDEPT</TT> combination will be returned even if multiple employees with the same last name work in the same department. When <TT>DISTINCT</TT> is used at the column level, for example</P>
<pre>

</pre><BR><pre>
SELECT  AVG(SALARY), COUNT(DISTINCT EMPNO)
FROM    DSN8810.EMP;
</pre><BR>
<P class="docText">duplicate values are removed for the column on which the <TT>DISTINCT</TT> keyword is used. Prior to DB2 V7 only one <TT>DISTINCT</TT> clause can be specified in a <TT>SELECT</TT> list.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><P class="docText"> With DB2 V7 you can specify multiple <TT>DISTINCT</TT> clauses, but on the same column only. For example</P></td></tr></table><br>
<pre>

</pre><BR><pre>
SELECT  SUM(DISTINCT SALARY), COUNT(DISTINCT SALARY)
FROM    DSN8810.EMP;
</pre><BR>
<P class="docText">However, for DB2 V7 and earlier releases, you cannot specify multiple <TT>DISTINCT</TT> clauses on different columns, or you get <TT>SQLCODE –127</TT>.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> DB2 Version 8 extends the functionality of the <TT>DISTINCT</TT> clause by enabling you to code multiple <TT>DISTINCT</TT>s in the <TT>SELECT</TT> or <TT>HAVING</TT> clause of SQL statements. The retriction limiting multiple <TT>DISTINCT</TT>s to the same column is lifted with DB2 V8. This enhancement is accomplished by performing multiple sorts on multiple distinct columns. For example, the following SQL statement uses two <TT>DISTINCT</TT> clauses on two different columns and is legal as of Version 8:</P></td></tr></table><br>
<pre>

</pre><BR><pre>
SELECT  COUNT(DISTINCT(ACTNO)),
        SUM(DISTINCT(ACSTAFF))
FROM    DSN8810.PROJACT
GROUP BY PROJNO;
</pre><BR>
<P class="docText">You could even add a <TT>HAVING</TT> clause with a <TT>DISTINCT</TT> to this query as of V8, for example<A NAME="ch02index135"></A><A NAME="ch02index136"></A><A NAME="ch02index137"></A><A NAME="ch02index138"></A><A NAME="ch02index139"></A><A NAME="ch02index140"></A><A NAME="ch02index141"></A><A NAME="ch02index142"></A><A NAME="ch02index143"></A></P>
<pre>

</pre><BR><pre>
HAVING AVG(DISTINCT ACSTAFF) &lt; 2.0;
</pre><BR>
<A NAME="ch02lev4sec18"></A><H4 class="docSection2Title">Code Predicates on Indexed Columns</H4>
<P class="docText">DB2 usually performs more efficiently when it can satisfy a request using an existing index rather than no index. However, indexed access is not always the most efficient access method. For example, when you request most of the rows in a table or access by a non-clustered index, indexed access can result in a poorer performing query than non-indexed access. This is so because the number of I/Os is increased to access index pages. As a general rule of thumb, keep in mind that an index enhances performance when the total I/O required to access the index pages and the specific table space pages is less than simply accessing all of the table space pages.<A NAME="ch02index144"></A><A NAME="ch02index145"></A><A NAME="ch02index146"></A><A NAME="ch02index147"></A><A NAME="ch02index148"></A></P>
<P class="docText">You can find comprehensive guidelines for the efficient creation of DB2 indexes in <A class="docLink" HREF="ch06.html#ch06">Chapter 6</A>, "DB2 Indexes."</P>
<A NAME="ch02lev4sec19"></A><H4 class="docSection2Title">Use <TT>ORDER BY</TT> When the Sequence Is Important</H4>
<P class="docText">You cannot guarantee the order of the rows returned from a <TT>SELECT</TT> statement without an <TT>ORDER BY</TT> clause. At times SQL developers get confused when DB2 uses an index to satisfy a query and the results are returned in the desired order even without the <TT>ORDER BY</TT> clause. But, due to the nature of the DB2 optimizer, the access path by which the data is retrieved might change from execution to execution of an application program. If the access path changes (or parallelism kicks in), and <TT>ORDER BY</TT> is not specified, the results can be returned in a different (non-desired) order. For this reason, <span class="docEmphStrong">always</span> code the <TT>ORDER BY</TT> clause when the sequence of rows being returned is important.<A NAME="ch02index149"></A><A NAME="ch02index150"></A><A NAME="ch02index151"></A><A NAME="ch02index152"></A><A NAME="ch02index153"></A><A NAME="ch02index154"></A><A NAME="ch02index155"></A><A NAME="ch02index156"></A></P>
<A NAME="ch02lev4sec20"></A><H4 class="docSection2Title">Limit the Columns Specified in <TT>ORDER BY</TT></H4>
<P class="docText">When you use <TT>ORDER BY</TT> to sequence retrieved data, DB2 ensures that the data is sorted in order by the specified columns. Doing so usually involves the invocation of a sort (unless an appropriate index is available). The more columns that are sorted, the less efficient the query will be. Therefore, use <TT>ORDER BY</TT> on only those columns that are absolutely necessary.<A NAME="ch02index157"></A><A NAME="ch02index158"></A><A NAME="ch02index159"></A><A NAME="ch02index160"></A><A NAME="ch02index161"></A><A NAME="ch02index162"></A><A NAME="ch02index163"></A><A NAME="ch02index164"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><P class="docText"> Also, keep in mind that as of DB2 V6 you can <TT>ORDER BY</TT> columns that are not included in the <TT>SELECT</TT> list. And, as of Version 7, this feature is extended even if the item is an expression. So, be sure to prune the <TT>SELECT</TT> list to only the data required for the display.</P></td></tr></table><br>
<A NAME="ch02lev4sec21"></A><H4 class="docSection2Title">Favor Stage 1 and Indexable Predicate</H4>
<P class="docText">For SQL statements, you must consider at which stage the predicate is applied: Stage 1 or Stage 2.<A NAME="ch02index165"></A><A NAME="ch02index166"></A><A NAME="ch02index167"></A><A NAME="ch02index168"></A><A NAME="ch02index169"></A><A NAME="ch02index170"></A></P>
<A NAME="ch02note06"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Stage 1 predicates were previously known as sargable predicates. <span class="docEmphasis">Sargable</span> is an IBM-defined term that stands for <span class="docEmphBoldItalic">s</span>earch <span class="docEmphBoldItalic">arg</span>u<span class="docEmphBoldItalic">able</span>. The term simply defines in which portion of DB2 a predicate can be satisfied. The term <span class="docEmphasis">sargable</span> is ostensibly obsolete and has been replaced in the IBM literature by the term <span class="docEmphasis">Stage 1 processing</span>.</P></div><br>
<P class="docText">A predicate that can be satisfied by Stage 1 processing can be evaluated by the Data Manager portion of DB2, not the Relational Data System. The Data Manager component of DB2 is at a level closer to the data than the Relational Data System. You can find a more complete description of the components of DB2 in <A class="docLink" HREF="ch20.html#ch20">Chapter 20</A>, "DB2 Behind the Scenes."</P>
<P class="docText">Because a Stage 1 predicate can be evaluated at an earlier Stage of data retrieval, you avoid the overhead of passing data from component to component of DB2. Try to use Stage 1 predicates rather than Stage 2 predicates because Stage 1 predicates are more efficient.</P>
<P class="docText">Additionally, a query that can use an index has more access path options, so it can be more efficient than a query that cannot use an index. The DB2 optimizer can use an index or indexes in a variety of ways to speed the retrieval of data from DB2 tables. For this reason, try to use indexable predicates rather than those that are not.</P>
<P class="docText">Of course, this raises the questions: "Which predicates are Stage 1 and which are Stage 2?" and "How do I know if a predicate is indexable or not?" This information is consolidated for you in <A class="docLink" HREF="#ch02table01">Table 2.1</A>.</P>
<A NAME="ch02table01"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 2.1. Predicate Stage and Indexability</h5></CAPTION><COLGROUP><COL width="363"><COL width="82.5"><COL width="104.5"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Predicate Type</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Stage</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Indexable</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL = value</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL = noncol expr</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL IS NULL</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL IS NOT NULL</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL op value</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL op noncol expr</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL BETWEEN value1 AND value 2</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL BETWEEN noncol expr1 AND noncol expr2</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL BETWEEN expr1 and expr2</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL LIKE 'pattern'</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL IN (list)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL LIKE :HV</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>T1.COL = T2.COL</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>T1.COL op T2.COL</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL = (non subq)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL op (non subq)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL op ANY (non subq)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL op ALL (non subq)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL IN (non subq)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL = expression</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>(COL1,&#8230;COLn) IN (non subq)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>(COL1,&#8230;COLn) = (val1,3&#8230;valn)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>T1.COL = T2.col expr</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">YES</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL &lt;&gt; value</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">NO</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL &lt;&gt; noncol expr</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">NO</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL NOT BETWEEN value1 AND value2</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">NO</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL NOT BETWEEN noncol expr1 AND noncol expr2</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">NO</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL NOT IN (list)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">NO</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL NOT LIKE ' char'</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">NO</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL NOT LIKE '%char'</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">NO</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL NOT LIKE '_char'</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">NO</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>T1.COL &lt;&gt; T2.COL</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">NO</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>T1.COL1 = T1.COL2</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">NO</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COL &lt;&gt; (non subq)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">NO<A NAME="ch02index173"></A><A NAME="ch02index174"></A></P></TD></TR></TABLE></P><br>
<P class="docText">If the predicate type is not listed in <A class="docLink" HREF="#ch02table01">Table 2.1</A>, then it is Stage 2 and non-indexable. Note that you can replace <span class="docEmphasis"><TT>op</TT></span> with <TT>&lt;=</TT>, <TT>&gt;=</TT>, <TT>&lt;</TT>, <TT>&gt;</TT>, or <TT>&lt;&gt;</TT>. A <TT>noncol expr</TT> is a noncolumn expression; it refers to any expression in which a column of a table is not specified. Examples of such expressions include<A NAME="ch02index175"></A><A NAME="ch02index176"></A><A NAME="ch02index177"></A><A NAME="ch02index178"></A><A NAME="ch02index179"></A><A NAME="ch02index180"></A></P>
<pre>

</pre><BR><pre>
CURRENT TIMESTAMP - 10 DAYS

:HOST-VARIABLE + 20

FLOAT(8.5)
</pre><BR>
<P class="docText">Stage 1 predicates combined with <TT>AND</TT>, combined with <TT>OR</TT>, or preceded by <TT>NOT</TT> are also Stage 1. All others are Stage 2. Additionally, please note that a <TT>LIKE</TT> predicate ceases to be Stage 1 if the column is defined using a field procedure. Indexable predicates combined with <TT>AND</TT> or <TT>OR</TT> are also indexable. However, note that predicates preceded by <TT>NOT</TT> are not indexable.</P>
<A NAME="ch02note07"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">All indexable predicates are also Stage 1. The reverse, however, is not true: All Stage 1 predicates are not necessarily indexable.</P></div><br>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> Keep in mind, too, that a predicate defined such that it conforms to the syntax specified for Stage 1 might in fact be changed to Stage 2 by DB2. Prior to V8, this can occur because the predicate contains constants whose data type or length does not match. As of Version 8, though, many Stage 1 predicates will remain Stage 1 even if the data types are not perfect.</P></td></tr></table><br>
<P class="docText">Additionally, Stage 1 processing and indexability are only two aspects of efficient query writing and, as such, do not guarantee the most effective way to code your query. Follow the rest of the advice in this chapter to formulate efficient SQL code.</P>
<P class="docText">Finally, do not read more into this guideline than is intended. I am not saying you should never use Stage 2 predicates. Feel free to code Stage 2 predicates when necessary based on your application requirements. Using Stage 2 predicates is much preferable to returning the data to the program and filtering it there.<A NAME="ch02index181"></A><A NAME="ch02index182"></A><A NAME="ch02index183"></A><A NAME="ch02index184"></A><A NAME="ch02index185"></A><A NAME="ch02index186"></A></P>
<A NAME="ch02note08"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">This information is accurate as of DB2 Version 8. Determine which predicates are Stage 1 and indexable with care because IBM tends to change certain predicates' stage and indexability with each release of DB2.</P></div><br>
<A NAME="ch02lev4sec22"></A><H4 class="docSection2Title">Reformulate SQL to Achieve Indexability</H4>
<P class="docText">Remember that SQL is flexible and often the same results can be achieved using different SQL formulations. Sometimes one SQL statement will dramatically outperform a functionally equivalent SQL statement just because it is indexable and the other is not. For example, consider this SQL statement:<A NAME="ch02index187"></A><A NAME="ch02index188"></A><A NAME="ch02index189"></A><A NAME="ch02index190"></A></P>
<pre>

</pre><BR><pre>
SELECT EMPNO, FIRSTNME, MIDINIT, LASTNAME
FROM   DSN8810.EMP
WHERE  MIDINIT NOT BETWEEN 'A' AND 'G';
</pre><BR>
<P class="docText">It is not indexable because it uses the <TT>NOT BETWEEN</TT> predicate. However, if we understand the data in the table and the desired results, perhaps we can reformulate the SQL to use indexable predicates, such as</P>
<pre>

</pre><BR><pre>
SELECT EMPNO, FIRSTNME, MIDINIT, LASTNAME
FROM   DSN8810.EMP
WHERE  MIDINIT &gt;= 'H';
</pre><BR>
<P class="docText">Or we could code <TT>MIDINIT BETWEEN 'H' AND 'Z'</TT> in place of <TT>MIDINIT &gt;= 'H'</TT>. Of course, for either of these solutions to work correctly we would need to know that <TT>MIDINIT</TT> never contained values that collate lower than the value <TT>'A'</TT>.</P>
<A NAME="ch02lev4sec23"></A><H4 class="docSection2Title">Try to Avoid Using <TT>NOT</TT> (Except with <TT>EXISTS</TT>)</H4>
<P class="docText">In older versions of DB2, predicates using <TT>NOT</TT> were non-indexable and Stage 2. As of DB2 V4, predicates formed using <TT>NOT</TT> are evaluated at Stage 1, but they are still non-indexable. Therefore, whenever possible, you should recode queries to avoid the use of <TT>NOT</TT> (<TT>&lt;&gt;</TT>). Take advantage of your understanding of the data being accessed. For example, if you know that no values are less than the value that you are testing for inequality, you could recode<A NAME="ch02index191"></A><A NAME="ch02index192"></A><A NAME="ch02index193"></A><A NAME="ch02index194"></A><A NAME="ch02index195"></A></P>
<pre>

</pre><BR><pre>
COLUMN1  &lt;&gt;  value
</pre><BR>
<P class="docText">as</P>
<pre>

</pre><BR><pre>
COLUMN1  &gt;=  value
</pre><BR>
<P class="docText">See the section on <A class="docLink" HREF="ch02lev1sec3.html#ch02lev1sec3">complex SQL guidelines</A> for guidance in the use of the <TT>EXISTS</TT> predicate.</P>
<A NAME="ch02lev4sec24"></A><H4 class="docSection2Title">Use Equivalent Data Types</H4>
<P class="docText">Use the same data types and lengths when comparing column values to host variables or literals. This way, you can eliminate the need for data conversion. Because the data type or length does not match, DB2 evaluates the predicate as Stage 2 (even if the predicate could be Stage 1 if the data type and length matched).<A NAME="ch02index196"></A><A NAME="ch02index197"></A><A NAME="ch02index198"></A><A NAME="ch02index199"></A><A NAME="ch02index200"></A></P>
<P class="docText">For example, comparing a column defined as <TT>INTEGER</TT> to another column defined as <TT>INTEGER</TT> is more efficient than comparing an <TT>INTEGER</TT> column to a column defined as <TT>DECIMAL(5,2)</TT>. When DB2 must convert data, available indexes are not used.</P>
<P class="docText">DB2 also does not use an index if the host variable or literal is longer than the column being compared, or if the host variable has a greater precision or a different data type than the column being compared. This situation adversely affects performance and should be avoided.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><P class="docText"> As of Version 7, you are allowed to <TT>CAST</TT> numeric equi-join columns to match in order to preserve Stage 1. But, if you can wait for Version 8, all you will have to do is <TT>REBIND</TT> because V8 resolves many of the data type mismatch problems. Until then, though, use <TT>CAST</TT>.</P></td></tr></table><br>
<P class="docText">Use a <TT>CAST</TT> function to resolve data type mismatches for date and numeric values to avoid demotion to Stage 2. For example, if you need to compare a <TT>DECIMAL(9,2)</TT> column to a <TT>SMALLINT</TT>, cast the integer value to a decimal value as follows:<A NAME="ch02index201"></A><A NAME="ch02index202"></A></P>
<pre>

</pre><BR><pre>
WHERE  DECIMAL(SMALLINTCOL, 9, 2) = DECIMALCOL
</pre><BR>
<P class="docText">Be sure to <TT>CAST</TT> the column belonging to the larger result set if both columns are indexed. That is, the column that can take on more distinct values should be the one cast. However, if only one column is indexed, <TT>CAST</TT> the one that is not indexed. You will need to rebind in order to receive the promotion to Stage 1.</P>
<P class="docText">As of DB2 V6, and via a retrofit APAR to V5, DB2 partially alleviated the data type and length mismatch performance problem, but only for character data. When two character columns are specified in an equi-join predicate, they no longer need to be of the same length to be considered Stage 1 and indexable. Please note that this applies only to columns, not host variables or string literals. Also, note that the two columns being compared must be of <TT>CHAR</TT> or <TT>VARCHAR</TT> data type. For example, you cannot join an <TT>INTEGER</TT> column to a <TT>SMALLINT</TT> column and expect it to be Stage 1 or indexable (for DB2 V7 or earlier).</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> DB2 V8 provides even more relief for this problem, but only within the data type family. This means that numbers can match numbers, characters match characters, and so on, without having to be an exact type and length match. In other words, as long as you are close to matching DB2 will evaluate the predicate in Stage 1 (if you are running DB2 Version 8 or greater). Even though this is now the case, it is still wise to exactly match up the data type and length of all column values, host variables, and literals within your predicates.<A NAME="ch02index203"></A><A NAME="ch02index204"></A><A NAME="ch02index205"></A><A NAME="ch02index206"></A><A NAME="ch02index207"></A></P></td></tr></table><br>
<A NAME="ch02lev4sec25"></A><H4 class="docSection2Title">Consider <TT>BETWEEN</TT> Instead of <TT>&lt;=</TT> and <TT>&gt;=</TT></H4>
<P class="docText">The <TT>BETWEEN</TT> predicate is easier to understand and code than the equivalent combination of the <span class="docEmphasis">less than or equal to</span> predicate (<TT>&lt;=</TT>) and the <span class="docEmphasis">greater than or equal to</span> predicate (<TT>&gt;=</TT>). In past releases it was also more efficient, but now the optimizer recognizes the two formulations as equivalent and there usually is no performance benefit one way or the other. Performance reasons aside, one <TT>BETWEEN</TT> predicate is much easier to understand and maintain than multiple <TT>&lt;=</TT> and <TT>&gt;=</TT> predicates. For this reason, favor using <TT>BETWEEN</TT>.<A NAME="ch02index208"></A><A NAME="ch02index209"></A><A NAME="ch02index210"></A><A NAME="ch02index211"></A><A NAME="ch02index212"></A><A NAME="ch02index213"></A></P>
<P class="docText">However, there is one particular instance where this guidelines does not apply—when comparing a host variable to two columns. Usually <TT>BETWEEN</TT> is used to compare one column to two values, here shown using host variables:</P>
<pre>

</pre><BR><pre>
WHERE COLUMN1 BETWEEN :HOST-VAR1 AND :HOST-VAR2
</pre><BR>
<P class="docText">However, it is possible to use <TT>BETWEEN</TT> to compare one value to two columns, as shown:</P>
<pre>

</pre><BR><pre>
WHERE :HOST-VAR BETWEEN COLUMN1 AND COLUMN2
</pre><BR>
<P class="docText">This statement should be changed to</P>
<pre>

</pre><BR><pre>
WHERE :HOST_VAR &gt;= COLUMN1 and :HOST-VAR &lt;= COLUMN2
</pre><BR>
<P class="docText">The reason for this exception is that a <TT>BETWEEN</TT> formulation comparing a host variable to two columns is a Stage 2 predicate, whereas the preferred formulation is Stage 1.</P>
<A NAME="ch02lev4sec26"></A><H4 class="docSection2Title">Consider <TT>IN</TT> Instead of <TT>LIKE</TT></H4>
<P class="docText">Whenever feasible, use <TT>IN</TT> or <TT>BETWEEN</TT> instead of <TT>LIKE</TT> in the <TT>WHERE</TT> clause of a <TT>SELECT</TT>. If you know that only a certain number of occurrences exist, using <TT>IN</TT> with the specific list usually is more efficient than using <TT>LIKE</TT>. For example, use<A NAME="ch02index214"></A><A NAME="ch02index215"></A><A NAME="ch02index216"></A><A NAME="ch02index217"></A><A NAME="ch02index218"></A><A NAME="ch02index219"></A></P>
<pre>

</pre><BR><pre>
IN ('VALUE1', 'VALUE2', 'VALUE3')
</pre><BR>
<P class="docText">instead of</P>
<pre>

</pre><BR><pre>
LIKE 'VALUE_'
</pre><BR>
<P class="docText">The functionality of <TT>LIKE</TT> can be imitated using a range of values. For example, if you want a query to retrieve all employees with a last name beginning with <span class="docEmphasis">K</span>, you know that last names between <span class="docEmphasis">KAAAAAAAAAAA</span> and <span class="docEmphasis">KZZZZZZZZZZZZ</span> also satisfy the request. To optimize performance, favor using</P>
<pre>

</pre><BR><pre>
BETWEEN :VALUE_LO AND :VALUE_HI
</pre><BR>
<P class="docText">instead of</P>
<pre>

</pre><BR><pre>
LIKE 'VALUE%'
</pre><BR>
<A NAME="ch02lev4sec27"></A><H4 class="docSection2Title">Formulate <TT>LIKE</TT> Predicates with Care</H4>
<P class="docText">Avoid using the <TT>LIKE</TT> predicate when the percentage sign (<TT>%</TT>) or the underscore (<TT>_</TT>) appears at the beginning of the comparison string because they prevent DB2 from using a matching index. The <TT>LIKE</TT> predicate can produce efficient results, however, when you use the percentage sign or underscore at the end or in the middle of the comparison string.<A NAME="ch02index220"></A><A NAME="ch02index221"></A><A NAME="ch02index222"></A><A NAME="ch02index223"></A><A NAME="ch02index224"></A><A NAME="ch02index225"></A></P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="groups" CELLPADDING="5"><COLGROUP><COL width="220"><COL width="330"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Not Okay</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Okay</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>LIKE %NAME</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>LIKE NAME%</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>LIKE _NAME</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>LIKE NA_ME</TT></P></TD></TR></TABLE></P><br>
<P class="docText">DB2 does not use direct index lookup when a wildcard character is supplied as the first character of a <TT>LIKE</TT> predicate. DB2 can determine when a host variable contains a wildcard character as the first character of a <TT>LIKE</TT> predicate. The optimizer therefore does not assume that an index cannot be used; rather, it indicates that an index might be used. At runtime, DB2 determines whether the index will be used based on the value supplied to the host variable. When a wildcard character is specified for the first character of a <TT>LIKE</TT> predicate, DB2 uses a non-matching index scan or a table space scan to satisfy the search.</P>
<A NAME="ch02lev4sec28"></A><H4 class="docSection2Title">Specify Appropriate Host Variable Values with <TT>LIKE</TT></H4>
<P class="docText">The <TT>LIKE</TT> predicate offers a great deal of flexibility and power to your SQL statements. Using <TT>LIKE</TT> you can quickly retrieve data based on patterns and wildcards. However, some uses of <TT>LIKE</TT> can be confusing to implement appropriately—especially when <TT>LIKE</TT> is used with host variables.<A NAME="ch02index226"></A><A NAME="ch02index227"></A><A NAME="ch02index228"></A><A NAME="ch02index229"></A><A NAME="ch02index230"></A><A NAME="ch02index231"></A></P>
<P class="docText">Let's assume that you need to create an application that retrieves employees by last name, but the supplied value for the last name can be either the entire name or just the first few bytes of that name. In that case, the following query can suffice:</P>
<pre>

</pre><BR><pre>
SELECT EMPNO, FIRSTNME, LASTNAME
FROM   DSN8810.EMP
WHERE  LASTNAME LIKE :host_variable;
</pre><BR>
<P class="docText">In order for this to work, when you enter the value for <TT>host_variable</TT> always append percent signs (<TT>%</TT>) to the end of the value. The percent sign specifies that DB2 should accept as a match any number of characters (including 0). This must be done programmatically. So, if the value entered is <TT>SM</TT>, the <TT>host_variable</TT> should contain <TT>SM%%%%%%%%</TT> and if the value entered is <TT>SMITH</TT>, the <TT>host_variable</TT> should contain <TT>SMITH%%%%%</TT>. Append as many percent signs as required to fill up the entire length of the host variable. Failure to do this will result in DB2 searching for blank spaces. Think about it—if you assign <TT>SMITH%</TT> to a 10-byte host variable, that host variable will think it should search for <TT>SMITH%</TT>, that is <TT>SMITH</TT> at the beginning, four blanks at the end, and anything in the middle.</P>
<P class="docText">So, for <TT>SMITH%%%%%</TT>, <TT>SMITH</TT> will be returned, but so will <TT>SMITHLY</TT> (or any name beginning with <TT>SMITH</TT>). There is no way to magically determine if what was entered is a complete name or just a portion thereof. If this is not acceptable, then a single query will not likely be feasible. Instead, you would have to ask the user to enter whether a full name or just a portion is being entered.<A NAME="ch02index232"></A><A NAME="ch02index233"></A><A NAME="ch02index234"></A><A NAME="ch02index235"></A><A NAME="ch02index236"></A><A NAME="ch02index237"></A></P>
<A NAME="ch02lev4sec29"></A><H4 class="docSection2Title">Code Most Restrictive Predicate First (Within Predicate Type)</H4>
<P class="docText">DB2 uses a predefined method for evaluating SQL predicates. The sequence in which predicates are evaluated is dependent upon four different factors:<A NAME="ch02index238"></A><A NAME="ch02index239"></A><A NAME="ch02index240"></A><A NAME="ch02index241"></A></P>
<UL><LI><P class="docList">The indexes being used</P></LI><LI><P class="docList">Whether the predicate is Stage 1 or Stage 2</P></LI><LI><P class="docList">The type of predicate (for example, <TT>=</TT>, <TT>&gt;</TT>, <TT>&lt;</TT>, <TT>BETWEEN</TT>, and so on)</P></LI><LI><P class="docList">The sequence in which the predicates are physically coded in the SQL statement</P></LI></UL>
<P class="docText">First, DB2 will apply the predicates that match the indexes selected in the access path. The sequence in which these predicates are applied is based on the order of the column in the index. So, you must design efficient indexes to impact performance (see <A class="docLink" HREF="ch05.html#ch05">Chapter 5</A>, "Data Definition Guidelines," for more information on efficient index design).</P>
<P class="docText">After applying matching index predicates, DB2 then applies</P>
<div style="font-weight:bold"><OL class="docList" TYPE="1"><LI><div style="font-weight:normal"><P class="docList">Stage 1 predicates that were not chosen as matching predicates but still refer to index columns, followed by</P></div></LI><LI><div style="font-weight:normal"><P class="docList">Stage 1 predicates in columns that were not in the indexes being used, and then</P></div></LI><LI><div style="font-weight:normal"><P class="docList">any Stage 2 predicates</P></div></LI></OL></div>
<P class="docText">Within each of these three groups, the sequence in which predicates are evaluated is based on the predicate type and the sequence in which the predicate appears in the SQL statement.</P>
<P class="docText">Predicate types are applied in the following sequence:</P>
<div style="font-weight:bold"><OL class="docList" TYPE="1"><LI><div style="font-weight:normal"><P class="docList">All equality predicates (including column <TT>IN</TT>-list, where list has only one element)</P></div></LI><LI><div style="font-weight:normal"><P class="docList">All range predicates and predicates specifying <span class="docEmphasis"><TT>column</TT></span> <TT>IS NOT NULL</TT></P></div></LI><LI><div style="font-weight:normal"><P class="docList">All other predicate types, but non-correlated subqueries are processed before correlated subqueries</P></div></LI></OL></div>
<P class="docText">Due to the preceding set of rules, when you code predicates in your <TT>SELECT</TT> statement, place the predicate that will eliminate the greatest number of rows first (within predicate type). For example, consider the following statement:</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, FIRSTNME, LASTNAME
FROM    DSN8810.EMP
WHERE   WORKDEPT = 'D21'
AND     SEX = 'F';
</pre><BR>
<P class="docText">Suppose that the <TT>WORKDEPT</TT> has 10 distinct values. The <TT>SEX</TT> column obviously has only 2 distinct values. Because both are equality predicates, the predicate for the <TT>WORKDEPT</TT> column should be coded first (as shown) because it eliminates more rows than the predicate for the <TT>SEX</TT> column. The performance gain from predicate placement is usually minimal, but sometimes every little performance gain is significant.<A NAME="ch02index242"></A><A NAME="ch02index243"></A><A NAME="ch02index244"></A><A NAME="ch02index245"></A></P>
<A NAME="ch02note09"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Remember, this guideline is true only for like predicate types. If the predicates are not of the same type, the guideline is not applicable.</P></div><br>
<A NAME="ch02lev4sec30"></A><H4 class="docSection2Title">Use Predicates Wisely</H4>
<P class="docText">By reducing the number of predicates on your SQL statements, you might be able to achieve better performance in two ways:<A NAME="ch02index246"></A><A NAME="ch02index247"></A><A NAME="ch02index248"></A><A NAME="ch02index249"></A></P>
<div style="font-weight:bold"><OL class="docList" TYPE="1"><LI><div style="font-weight:normal"><P class="docList">Reduced <TT>BIND</TT> time due to fewer options that must be examined by the DB2 optimizer.</P></div></LI><LI><div style="font-weight:normal"><P class="docList">Reduced execution time due to a smaller path length caused by the removal of redundant search criteria from the optimized access path. DB2 processes each predicate coded for the SQL statement. Removing predicates removes work, and less work equals less time to process the SQL.</P></div></LI></OL></div>
<P class="docText">However, if you remove predicates from SQL statements, you run the risk of changing the data access logic. So, remove predicates only when you're sure that their removal will not have an impact on the query results. For example, consider the following query:</P>
<pre>

</pre><BR><pre>
SELECT  FIRSTNME, LASTNAME
FROM    DSN8810.EMP
WHERE   JOB = 'DESIGNER'
AND     EDLEVEL &gt;= 16;
</pre><BR>
<P class="docText">This statement retrieves all rows for designers who are at an education level of 16 or above. But what if you know that the starting education level for all designers in an organization is 16? No one with a lower education level can be hired as a designer. In this case, the second predicate is redundant. Removing this predicate does not logically change the results, but it might enhance performance.</P>
<P class="docText">On the other hand, performance possibly can degrade when you remove predicates. The DB2 optimizer analyzes correlation statistics when calculating filter factors. Examples of correlated columns include <TT>CITY</TT> and <TT>STATE</TT> (<TT>Chicago</TT> and <TT>Illinois</TT> are likely to occur together); <TT>FIRST_NAME</TT> and <TT>GENDER</TT> (<TT>Robert</TT> and <TT>male</TT> are likely to occur together).</P>
<P class="docText">Because the filter factor might change when a predicate is changed or removed, a different access path can be chosen. That access path might be more (or less) efficient than the one it replaces. The basic rule is to test the SQL both ways to determine which will perform better for each specific statement.</P>
<P class="docText">Truly "knowing your data," however, is imperative. For example, it is not sufficient to merely note that for current rows in the <TT>EMP</TT> table no designers are at an <TT>EDLEVEL</TT> below 16. This may just be a data coincidence. Do not base your knowledge of your data on the current state of the data, but on business requirements. You must truly <span class="docEmphasis">know</span> that a correlation between two columns (such as between <TT>JOB</TT> and <TT>EDLEVEL</TT>) actually exists before you modify your SQL to take advantage of this fact.</P>
<P class="docText">In any case, whenever you make changes to SQL statements based on your knowledge of the data, be sure to document the reason for the change in the actual SQL statement using SQL comments. Good documentation practices make future tuning, maintenance, and debugging easier.<A NAME="ch02index250"></A><A NAME="ch02index251"></A><A NAME="ch02index252"></A><A NAME="ch02index253"></A></P>
<A NAME="ch02lev4sec31"></A><H4 class="docSection2Title">Be Careful with Arithmetic Precision</H4>
<P class="docText">When you select columns using arithmetic expressions, be careful to ensure that the result of the expression has the correct precision. When an arithmetic expression operates on a column, DB2 determines the data type of the numbers in the expression and decides the correct data type for the result. Remember the following rules for performing arithmetic with DB2 columns:<A NAME="ch02index254"></A><A NAME="ch02index255"></A><A NAME="ch02index256"></A><A NAME="ch02index257"></A><A NAME="ch02index258"></A></P>
<UL><LI><P class="docList">DB2 supports addition, subtraction, multiplication, and division.</P></LI><LI><P class="docList"><TT>DATE</TT>, <TT>TIME</TT>, and <TT>TIMESTAMP</TT> columns can be operated on only by means of addition and subtraction. (See the section "<A class="docLink" HREF="#ch02lev4sec36">Use Date and Time Arithmetic with Care</A>" later in this chapter.)</P></LI><LI><P class="docList">Floating-point numbers are displayed in scientific notation. Avoid using floating-point numbers because scientific notation is difficult for some users to comprehend. <TT>DECIMAL</TT> columns can contain as many as 31 bytes of precision, which is adequate for most users.</P></LI><LI><P class="docList">When an arithmetic expression operates on two numbers of different data types, DB2 returns the result using the data type with the highest precision. The only exception to this rule is that an expression involving two <TT>SMALLINT</TT> columns is returned as an <TT>INTEGER</TT> result.</P></LI></UL>
<P class="docText">The last rule may require additional clarification. When DB2 operates on two numbers, the result of the operation must be returned as a valid DB2 data type. Consult the following chart to determine the result data type for operations on any two numbers in DB2:<A NAME="ch02index259"></A><A NAME="ch02index260"></A></P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="groups" CELLPADDING="5"><COLGROUP><COL width="275"><COL width="275"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Statement</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Yields</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SMALLINT </TT><span class="docEmphasis"><TT>operator</TT></span> <TT>SMALLINT</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">INTEGER</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SMALLINT </TT><span class="docEmphasis"><TT>operator</TT></span> <TT>INTEGER</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">INTEGER</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SMALLINT </TT><span class="docEmphasis"><TT>operator</TT></span> <TT>DECIMAL</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">DECIMAL</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SMALLINT </TT><span class="docEmphasis"><TT>operator</TT></span> <TT>FLOAT</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">FLOAT</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INTEGER </TT><span class="docEmphasis"><TT>operator</TT></span> <TT>SMALLINT</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">INTEGER</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INTEGER </TT><span class="docEmphasis"><TT>operator</TT></span> <TT>INTEGER</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">INTEGER</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INTEGER </TT><span class="docEmphasis"><TT>operator</TT></span> <TT>DECIMAL</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">DECIMAL</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INTEGER </TT><span class="docEmphasis"><TT>operator</TT></span> <TT>FLOAT</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">FLOAT</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DECIMAL </TT><span class="docEmphasis"><TT>operator</TT></span> <TT>SMALLINT</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">DECIMAL</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DECIMAL </TT><span class="docEmphasis"><TT>operator</TT></span> <TT>INTEGER</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">DECIMAL</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DECIMAL </TT><span class="docEmphasis"><TT>operator</TT></span> <TT>DECIMAL</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">DECIMAL</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DECIMAL </TT><span class="docEmphasis"><TT>operator</TT></span> <TT>FLOAT</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">FLOAT</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>FLOAT </TT><span class="docEmphasis"><TT>operator</TT></span> <TT>ANY DATA TYPE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>FLOAT</TT><A NAME="ch02index261"></A><A NAME="ch02index262"></A><A NAME="ch02index263"></A><A NAME="ch02index264"></A><A NAME="ch02index265"></A></P></TD></TR></TABLE></P><br>
<P class="docText">For example, consider the following <TT>SELECT</TT>:</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, EDLEVEL/2, SALARY/2
FROM    DSN8810.EMP
WHERE   EMPNO BETWEEN '000250' AND '000290';
</pre><BR>
<P class="docText">This statement returns the following results:</P>
<pre>

</pre><BR><pre>
<span class="docEmphStrong">EMPNO             COL1             COL2</span>
000250             7              9590.00000000
000260             8              8625.00000000
000270             7             13690.00000000
000280             8             13125.00000000
000290             6              7670.00000000

DSNE610I NUMBER OF ROWS DISPLAYED IS 5
</pre><BR>
<P class="docText">Because <TT>EDLEVEL</TT> is an <TT>INTEGER</TT> and <TT>2</TT> is specified as an <TT>INTEGER</TT>, the result in <TT>COL1</TT> is truncated and specified as an <TT>INTEGER</TT>. Because <TT>SALARY</TT> is a <TT>DECIMAL</TT> column and <TT>2</TT> is specified as an <TT>INTEGER</TT>, the result is a <TT>DECIMAL</TT>. If you must return a more precise number for COL1, consider specifying <TT>EDLEVEL/2.0</TT>. The result is a <TT>DECIMAL</TT> because <TT>2.0</TT> is specified as a <TT>DECIMAL</TT>.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><P class="docText"> As of DB2 V7, you can use the <TT>MULTIPLY_ALT</TT> function to assure precision. <TT>MULTIPLY_ALT</TT> is preferable to the multiplication operator when performing decimal arithmetic where a scale of at least 3 is desired and the sum of the precisions exceeds 31. With <TT>MULTIPLY_ALT</TT>, DB2 performs the internal computation avoiding overflows. For example, the result of the following expression is the value of <TT>COL1</TT> multiplied by the value of <TT>:HV2</TT>:<A NAME="ch02index266"></A><A NAME="ch02index267"></A><A NAME="ch02index268"></A><A NAME="ch02index269"></A></P></td></tr></table><br>
<pre>

</pre><BR><pre>
MULTIPLY_ALT(COL1, :HV2)
</pre><BR>
<P class="docText">The precision of the result will be the precision of each argument added together (unless that is greater than 31, in which case, the precision will be 31). The scale of the result is determined as follows:</P>
<UL><LI><P class="docList">If the scale of both arguments is 0, the scale of the result will be 0.</P></LI><LI><P class="docList">If the sum of the two precisions added together is less than or equal to 31, the scale of the result will be either the two scales added together or 31, whichever is smaller.</P></LI><LI><P class="docList">If the sum of the two precisions added together is greater than 31, the scale of the result will be determined using the following formula:</P><pre>

</pre><BR><pre>
MAX( MIN(3, s1+s2), 31-(p1-s1+p2-s2) )
</pre><BR><P class="docList">where <TT>s1</TT> is the scale of the first argument, and so on.<A NAME="ch02index270"></A><A NAME="ch02index271"></A><A NAME="ch02index272"></A><A NAME="ch02index273"></A><A NAME="ch02index274"></A></P></LI></UL>
<A NAME="ch02lev4sec32"></A><H4 class="docSection2Title">Use Column Renaming with Arithmetic Expressions and Functions</H4>
<P class="docText">You can use the <TT>AS</TT> clause to give arithmetic expressions a column name, as follows:<A NAME="ch02index275"></A><A NAME="ch02index276"></A><A NAME="ch02index277"></A><A NAME="ch02index278"></A><A NAME="ch02index279"></A><A NAME="ch02index280"></A><A NAME="ch02index281"></A></P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, EDLEVEL/2 AS HALF_EDLEVEL, SALARY/2 AS HALF_SALARY
FROM    DSN8810.EMP
WHERE   EMPNO BETWEEN '000250' AND '000290';
</pre><BR>
<P class="docText">If you give expressions a descriptive name, SQL becomes easier to understand and maintain. Likewise, when specifying functions in the <TT>SELECT</TT> list, use the <TT>AS</TT> clause to give the new column a name.</P>
<A NAME="ch02lev4sec33"></A><H4 class="docSection2Title">Decimal Precision and Scale</H4>
<P class="docText">The precision of a decimal number is the total number of digits in the number (do not count the decimal point). For example, the number 983.201 has a precision of 6. The scale of a decimal number is equal to the number of digits to the right of the decimal point. In the previous example, the scale is 3.<A NAME="ch02index282"></A><A NAME="ch02index283"></A><A NAME="ch02index284"></A><A NAME="ch02index285"></A><A NAME="ch02index286"></A><A NAME="ch02index287"></A></P>
<A NAME="ch02lev4sec34"></A><H4 class="docSection2Title">Avoid Arithmetic in Column Expressions</H4>
<P class="docText">An index is not used for a column when the column participates in an arithmetic expression. For example, the predicate in the following statement is non-indexable:<A NAME="ch02index288"></A><A NAME="ch02index289"></A><A NAME="ch02index290"></A><A NAME="ch02index291"></A><A NAME="ch02index292"></A><A NAME="ch02index293"></A></P>
<pre>

</pre><BR><pre>
SELECT  PROJNO
FROM    DSN8810.PROJ
WHERE   PRSTDATE - 10 DAYS = :HV-DATE;
</pre><BR>
<P class="docText">You have two options to make the predicate indexable. You can switch the arithmetic to the non-column side of the predicate. For example</P>
<pre>

</pre><BR><pre>
SELECT  PROJNO
FROM    DSN8810.PROJ
WHERE   PRSTDATE = DATE(:HV-DATE) + 10 DAYS;
</pre><BR>
<P class="docText">It makes no logical difference whether you subtract 10 from the column on the left side of the predicate, or add 10 to the host variable on the right side of the predicate. However, it makes a big performance difference because DB2 can use an index to evaluate non-column arithmetic expressions.</P>
<P class="docText">Alternatively, you can perform calculations before the SQL statement and then use the result in the query. For example, you could recode the previous SQL statement as this sequence of COBOL and SQL:</P>
<pre>

</pre><BR><pre>
ADD +10 TO HV-DATE.                <span class="docEmphasis">COBOL</span>

SELECT  PROJNO                     <span class="docEmphasis">SQL</span>
FROM    DSN8810.PROJ
WHERE   PRSTDATE = :HV-DATE;
</pre><BR>
<P class="docText">In general, though, it is wise to avoid arithmetic in predicates altogether, if possible. In this case, however, we are dealing with date arithmetic, which can be difficult to emulate in a program.</P>
<P class="docText">The fewer arithmetic expressions in the SQL statement, the easier it is to understand the SQL. Furthermore, if arithmetic is avoided in SQL, you do not need to remember the exact formulations which are indexable and Stage 1. For these reasons, favor performing arithmetic outside of the SQL when possible.<A NAME="ch02index294"></A><A NAME="ch02index295"></A><A NAME="ch02index296"></A><A NAME="ch02index297"></A><A NAME="ch02index298"></A><A NAME="ch02index299"></A></P>
<A NAME="ch02lev4sec35"></A><H4 class="docSection2Title">Use the Dummy Table to Select Data not in a DB2 Table</H4>
<P class="docText">Sometimes you will need to use DB2 facilities to retrieve data that is not stored in a DB2 table. This can be a challenge until you learn about the dummy table, <TT>SYSIBM.SYSDUMMY1</TT>.</P>
<P class="docText">Why would you want to <TT>SELECT</TT> data that is not stored in a DB2 table? Well, perhaps you need to use a function that does not require DB2 table data. One such function is RAND, which is used to return a random number. To use this function, you can select it from the dummy table as follows:<A NAME="ch02index300"></A><A NAME="ch02index301"></A><A NAME="ch02index302"></A><A NAME="ch02index303"></A><A NAME="ch02index304"></A></P>
<pre>

</pre><BR><pre>
SELECT RAND(:HOSTVAR)
FROM   SYSIBM.SYSDUMMY1;
</pre><BR>
<P class="docText">The dummy table is part of the DB2 Catalog and is available to all DB2 installations.</P>
<A NAME="ch02note10"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Take care when using the <TT>RAND</TT> function to generate a random value. To get a random value every time, use <TT>RAND()</TT>, without the host variable. If using a host variable, supplying it with the same value will cause <TT>RAND</TT> always to return the same random value. Of course, this can be useful if you want consistent random values to be generated.</P></div><br>
<A NAME="ch02lev4sec36"></A><H4 class="docSection2Title">Use Date and Time Arithmetic with Care</H4>
<P class="docText">DB2 enables you to add and subtract <TT>DATE</TT>, <TT>TIME</TT>, and <TT>TIMESTAMP</TT> columns. In addition, you can add date and time durations to or subtract them from these columns.<A NAME="ch02index305"></A><A NAME="ch02index306"></A><A NAME="ch02index307"></A><A NAME="ch02index308"></A><A NAME="ch02index309"></A></P>
<P class="docText">Use date and time arithmetic with care. If users understand the capabilities and features of date and time arithmetic, they should have few problems implementing it. Keep the following rules in mind:</P>
<UL><LI><P class="docList">When you issue date arithmetic statements using durations, do not try to establish a common conversion factor between durations of different types. For example, the date arithmetic statement</P><pre>

</pre><BR><pre>
DATE('2004/04/03') - 1 MONTH
</pre><BR><P class="docList">is <span class="docEmphasis">not</span> equivalent to the statement</P><pre>

</pre><BR><pre>
DATE('2004/04/03') - 30 DAYS
</pre><BR><P class="docList">April has 30 days, so the normal response would be to subtract 30 days to subtract one month. The result of the first statement is 2004/03/03, but the result of the second statement is 2004/03/04. In general, use like durations (for example, use months or use days, but not both) when you issue date arithmetic.</P></LI><LI><P class="docList">If one operand is a date, the other operand must be a date or a date duration. If one operand is a time, the other operand must be a time or a time duration. You cannot mix durations and data types with date and time arithmetic.</P></LI><LI><P class="docList">If one operand is a timestamp, the other operand can be a time, a date, a time duration, or a date duration. The second operand cannot be a timestamp. You can mix date and time durations with timestamp data types.</P></LI><LI><P class="docList">Date durations are expressed as a <TT>DECIMAL(8,0)</TT> number. The valid date durations are</P><P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5"><COLGROUP><COL width="242"><COL width="308"></COLGROUP><THEAD></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DAY</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DAYS</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>MONTH</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>MONTHS</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>YEAR</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>YEARS</TT></P></TD></TR></TABLE></P><br></LI><LI><P class="docList">Time durations are expressed as a <TT>DECIMAL(6,0)</TT> number. The valid time durations are</P><P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5"><COLGROUP><COL width="242"><COL width="308"></COLGROUP><THEAD></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>HOUR</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>HOURS</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>MINUTE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>MINUTES</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SECOND</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SECONDS</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>MICROSECOND</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>MICROSECONDS</TT></P></TD></TR></TABLE></P><br></LI></UL>
<P class="docText">Additional guidelines on handling date and time data in DB2 are provided in the "<A class="docLink" HREF="ch02lev1sec6.html#ch02lev1sec6">Date and Time Guidelines</A>" section later in this chapter.<A NAME="ch02index310"></A><A NAME="ch02index311"></A><A NAME="ch02index312"></A><A NAME="ch02index313"></A><A NAME="ch02index314"></A></P>
<A NAME="ch02lev4sec37"></A><H4 class="docSection2Title">Use Built-in Functions Where Available</H4>
<P class="docText">DB2 comes with more than 120 built-in functions that can be used in SQL statements to transform data from one state to another. Use the built-in functions instead of performing similar functionality in your application programs.<A NAME="ch02index315"></A><A NAME="ch02index316"></A><A NAME="ch02index317"></A><A NAME="ch02index318"></A><A NAME="ch02index319"></A></P>
<P class="docText">Prior to Version 6, DB2 provided only a minimal set of built-in functions. As such, developers needed to write their own work-arounds to achieve certain functionality. For example, previous editions of this book recommended using the following logic to return a day of the week</P>
<pre>

</pre><BR><pre>
DAYS(CURRENT DATE) - (DAYS(CURRENT DATE)/7) * 7
</pre><BR>
<P class="docText">However, DB2 now provides a <TT>DAYOFWEEK</TT> function that is easier to use and understand than this expression. I do not recommend going back to your old programs and retrofitting them to use the new functions because the manpower required would be excessive and the return would be marginal. However, for all new and future SQL, use the built-in functions. For more information on the built-in functions available to DB2 consult <A class="docLink" HREF="ch03.html#ch03">Chapter 3</A>, "Using DB2 Functions."</P>
<A NAME="ch02note11"></A><div class="docNote"><p class="docNoteTitle">NOTE</p><p><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  ALIGN="LEFT" width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><P class="docText">As of V7, DB2 also provides the <TT>DAYOFWEEK_ISO</TT> function. This function is similar to the <TT>DAYOFWEEK</TT> function, but results in different numbers to represent the days of the week. For <TT>DAYOFWEEK_ISO</TT>, the result is a number where <TT>1</TT> represents Monday, <TT>2</TT> Tuesday, <TT>3</TT> Wednesday, <TT>4</TT> Thursday, <TT>5</TT> Friday, <TT>6</TT> Saturday, and <TT>7</TT> Sunday. For <TT>DAYOFWEEK</TT>, the resulting value is a number where <TT>1</TT> represents Sunday, <TT>2</TT> Monday, <TT>3</TT> Tuesday, <TT>4</TT> Wednesday, <TT>5</TT> Thursday, <TT>6</TT> Friday, and <TT>7</TT> Saturday.</P><P class="docText">Unfortunately, neither of the results matches the results of the old formula (<TT>0</TT> for Sunday, <TT>1</TT> for Monday and so on), as returned by<A NAME="ch02index320"></A><A NAME="ch02index321"></A><A NAME="ch02index322"></A><A NAME="ch02index323"></A><A NAME="ch02index324"></A></P><pre>

</pre><BR><pre>
DAYS(CURRENT DATE) - (DAYS(CURRENT DATE)/7) * 7)
</pre><BR></td></tr></table></p></div><br>
<A NAME="ch02lev4sec38"></A><H4 class="docSection2Title">Limit the Use of Scalar Functions in <TT>WHERE</TT> Clauses</H4>
<P class="docText">For performance reasons, you can try to avoid using scalar functions referencing columns in <TT>WHERE</TT> clauses, but do not read too much into this recommendation. It is still wise to use scalar functions to offload work from the application to DB2. But remember that an index is not used for columns to which scalar functions are applied. Scalar functions typically can be used in the <TT>SELECT</TT> list of SQL statements with no performance degradation.<A NAME="ch02index325"></A><A NAME="ch02index326"></A><A NAME="ch02index327"></A><A NAME="ch02index328"></A><A NAME="ch02index329"></A><A NAME="ch02index330"></A><A NAME="ch02index331"></A></P>
<A NAME="ch02lev4sec39"></A><H4 class="docSection2Title">Specify the Number of Rows to Be Returned</H4>
<P class="docText">When you code a cursor to fetch a predictable number of rows, consider specifying the number of rows to be retrieved in the <TT>OPTIMIZE FOR </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS</TT> clause of the <TT>CURSOR</TT>. This way, DB2 can select the optimal access path for the statement based on actual use.<A NAME="ch02index332"></A><A NAME="ch02index333"></A><A NAME="ch02index334"></A><A NAME="ch02index335"></A></P>
<P class="docText">Coding the <TT>OPTIMIZE FOR </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS</TT> clause of the <TT>CURSOR</TT> does not limit your program from fetching more than the specified number of rows.</P>
<P class="docText">This statement can cause your program to be inefficient, however, when many more rows or many fewer rows than specified are retrieved. So be sure you specify a reasonable estimate for the number of rows to be returned if you code this clause.</P>
<A NAME="ch02lev4sec40"></A><H4 class="docSection2Title">Disable List Prefetch Using <TT>OPTIMIZE FOR 1 ROW</TT></H4>
<P class="docText">If a particular query experiences sub-optimal performance due to list prefetch, consider specifying <TT>OPTIMIZE FOR 1 ROW</TT>. Doing so makes it less likely that DB2 will choose an access path that uses list prefetch. This capability might be of particular use in an online environment in which data is displayed to the end user a screen at a time.<A NAME="ch02index336"></A><A NAME="ch02index337"></A><A NAME="ch02index338"></A><A NAME="ch02index339"></A><A NAME="ch02index340"></A></P>
<A NAME="ch02note12"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Keep in mind that there is a difference between <TT>OPTIMIZE FOR 1 ROW</TT> and <TT>OPTIMIZE FOR </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS</TT> (were <span class="docEmphasis"><TT>n</TT></span> is greater than 1). <TT>OPTIMIZE FOR 1 ROW</TT> tries to avoid sorts; <TT>OPTIMIZE FOR </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS</TT> will try to use the least cost access path for <span class="docEmphasis"><TT>n</TT></span>.</P></div><br>
<A NAME="ch02lev4sec41"></A><H4 class="docSection2Title">Disable Index Access</H4>
<P class="docText">During the tuning process, you can append <TT>OR 0 = 1</TT> to a predicate to eliminate index access. For example, consider a query against the <TT>EMP</TT> table on which two indexes exist: one on <TT>EMPNO</TT> and one on <TT>WORKDEPT</TT>.<A NAME="ch02index341"></A><A NAME="ch02index342"></A><A NAME="ch02index343"></A><A NAME="ch02index344"></A><A NAME="ch02index345"></A><A NAME="ch02index346"></A></P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, WORKDEPT, EDLEVEL, SALARY
FROM    DSN8810.EMP
WHERE   EMPNO BETWEEN '000020' AND '000350'
AND     (WORKDEPT &gt; 'A01' OR 0 = 1);
</pre><BR>
<P class="docText">In this case, the <TT>0 = 1</TT> prohibits DB2 from choosing the <TT>WORKDEPT</TT> index by making the predicate Stage 2. This forces DB2 to use either the index on <TT>EMPNO</TT> or a table space scan. Similar techniques include adding 0 to a numeric column or appending a null string to a character column to avoid indexed access. The latter is preferred because it disables matching index access but leaves the predicate Stage 1. For example:</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, WORKDEPT, EDLEVEL, SALARY
FROM    DSN8810.EMP
WHERE   EMPNO BETWEEN '000020' AND '000350'
AND     WORKDEPT &gt; 'A01' CONCAT '';
</pre><BR>
<A NAME="ch02lev4sec42"></A><H4 class="docSection2Title">Consider Other Forms of Query Tweaking</H4>
<P class="docText">Both <TT>OPTIMIZE FOR 1 ROW</TT> and using <TT>OR 0=1</TT> are valid query tweaks for specific types of tuning. The following techniques can be used to tweak queries to try to encourage DB2 to use different access paths:<A NAME="ch02index347"></A><A NAME="ch02index348"></A><A NAME="ch02index349"></A><A NAME="ch02index350"></A></P>
<BLOCKQUOTE><P><p class="docText"><TT>OPTIMIZE FOR </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS</TT>: 
Note that the <span class="docEmphasis"><TT>n</TT></span> can be any value.</p></P><P><p class="docText"><TT>FETCH FIRST </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS ONLY</TT>: 
Again, where <span class="docEmphasis"><TT>n</TT></span> can be any value.</p></P><P><p class="docText"><span class="docEmphRoman">No Operation (</span><TT>+0</TT>, <TT>-0</TT>, <TT>/1</TT>, <TT>*1</TT>, <TT>CONCAT ''</TT><span class="docEmphRoman">)</span>: 
Adding or subtracting zero, dividing or multiplying by 1, or concatenating an empty string will not change the results of a query but might change the optimizer's decision.</p></P></BLOCKQUOTE>
<P class="docText">These techniques can cause DB2 to choose a different access path. Consider using them when you are in a jam and need to try different types of access. Compare and contrast the results and costs of each scenario to determine which might be most useful to your particular situation.</P>
<P class="docText">Although non-column expressions are indexable (at least as of DB2 V5), IBM has made an exception for the "no operation" expressions because they are used as tricks to fool the optimizer. IBM did not include these expressions because these tricks were deployed by DB2 developers to avoid indexed access for more than a decade. An example SQL statement using one of these tricks follows:</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, WORKDEPT, EDLEVEL, SALARY
FROM    DSN8810.EMP
WHERE   EMPNO &lt; :HOST-VAR CONCAT '';
</pre><BR>
<P class="docText">In this case, a table space scan is used because an empty string is concatenated to the host variable in the predicate and no other predicates are available for indexed access. However, the predicate remains Stage 1.</P>
<A NAME="ch02lev4sec43"></A><H4 class="docSection2Title">Consider Using <TT>REOPT</TT> to Change Access Paths</H4>
<P class="docText">When SQL is bound into a plan or package you can specify whether to have DB2 determine an access path at runtime using values for host variables, parameter markers, and special registers. This is achieved using the <TT>REOPT</TT> (or <TT>NOREOPT</TT>) parameter.<A NAME="ch02index351"></A><A NAME="ch02index352"></A><A NAME="ch02index353"></A><A NAME="ch02index354"></A><A NAME="ch02index355"></A><A NAME="ch02index356"></A><A NAME="ch02index357"></A><A NAME="ch02index358"></A></P>
<P class="docText">Specifying <TT>NOREOPT(VARS)</TT> will cause DB2 to determine access paths at <TT>BIND</TT> time, and not at runtime. Instead, specifying <TT>REOPT(VARS)</TT> will cause DB2 to redetermine the access path at runtime. Consider choosing this option if performance fluctuates based on the values supplied to host variables and parameter markers when your program is run.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> DB2 V8 introduces another useful <TT>REOPT</TT> option, <TT>REOPT(ONCE)</TT>. Consider choosing <TT>REOPT(ONCE)</TT> instead of <TT>REOPT(VARS)</TT> when you wish to avoid constantly recalculating access paths at a <TT>PREPARE</TT>. With <TT>REOPT(ONCE)</TT>, access path selection will be deferred until the cursor is opened. The host variable and parameter marker values at cursor <TT>OPEN</TT> time will be used to determine the access path. The resultant access path will be cached in the global prepare cache.</P></td></tr></table><br>
<A NAME="ch02lev4sec44"></A><H4 class="docSection2Title">Be Aware of Table Space Partitioning Key Ranges</H4>
<P class="docText">When you access data in partitioned table spaces, be aware of the values used for the partitioning scheme. Prior to V4, DB2 scanned the entire table in a table space scan of a partitioned table. As of DB2 V4, you can limit a table space scan to accessing a subset of the partitions if the predicates of the <TT>WHERE</TT> clause can be used to limit the key ranges that need to be scanned. As of DB2 V5, the key ranges do not have to be contiguous.<A NAME="ch02index359"></A><A NAME="ch02index360"></A><A NAME="ch02index361"></A><A NAME="ch02index362"></A><A NAME="ch02index363"></A><A NAME="ch02index364"></A></P>
<P class="docText">For this technique to work with host variables you must <TT>BIND</TT> using the <TT>REOPT(VARS)</TT> parameter.</P>
<A NAME="ch02lev4sec45"></A><H4 class="docSection2Title">Specify Isolation Level for Individual SQL Statements</H4>
<P class="docText">You can use the <TT>WITH</TT> clause to specify an explicit isolation level at the SQL statement level. Four options are available:<A NAME="ch02index365"></A><A NAME="ch02index366"></A><A NAME="ch02index367"></A><A NAME="ch02index368"></A><A NAME="ch02index369"></A><A NAME="ch02index370"></A></P>
<BLOCKQUOTE><P><p class="docText"><TT>WITH RR</TT>: 
Repeatable Read</p></P><P><p class="docText"><TT>WITH RS</TT>: 
Read Stability</p></P><P><p class="docText"><TT>WITH CS</TT>: 
Cursor Stability</p></P><P><p class="docText"><TT>WITH UR</TT>: 
Uncommitted Read (can be specified only if the result table is read-only)</p></P></BLOCKQUOTE>
<P class="docText">Sometimes it makes sense to change the isolation level of an SQL statement within a program, without changing the isolation level of the other SQL statements in the program. For example, one query might be able to tolerate a dirty read because the data is being aggregated and only an estimated result is required. In this case, that query can be specified as <TT>WITH UR</TT>, even though the package for the program is bound as <TT>ISOLATION(CS)</TT>.</P>
<P class="docText">Use the <TT>WITH</TT> clause when you need to change the isolation level for specific SQL statements within a package or plan. More information on isolation levels is provided in <A class="docLink" HREF="ch13.html#ch13">Chapter 13</A>, "Program Preparation."</P>
<A NAME="ch02note13"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p><p><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  ALIGN="LEFT" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText">Do not confuse the use of <TT>WITH</TT> to specify isolation levels with the use of <TT>WITH</TT> to specify common table expressions. Common table expressions were introduced with DB2 Version 8 and are placed at the beginning of SQL statements. SQL statement isolation levels are placed at the end of SQL statements.</P><P class="docText">An example of a common table expression is given later in this chapter in the section titled "<A class="docLink" HREF="ch02lev1sec4.html#ch02lev1sec4">Common Table Expressions and Recursion</A>."</P></td></tr></table></p></div><br>
<A NAME="ch02lev4sec46"></A><H4 class="docSection2Title">Consider <TT>KEEP UPDATE LOCKS</TT> to Serialize Updates</H4>
<P class="docText">The <TT>KEEP UPDATE LOCKS</TT> clause can be specified for <TT>RR</TT> and <TT>RS</TT> isolation levels. With <TT>KEEP UPDATE LOCKS</TT>, DB2 acquires X locks instead of U or S locks on all qualified rows or pages. Use this option to serialize updates when concurrency is not an issue.<A NAME="ch02index371"></A><A NAME="ch02index372"></A><A NAME="ch02index373"></A><A NAME="ch02index374"></A><A NAME="ch02index375"></A><A NAME="ch02index376"></A></P>
<A NAME="ch02lev4sec47"></A><p><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><H4 class="docSection2Title">Use SQL Assist to Help Build SQL Statements</H4></td></tr></table></p>

<P class="docText">SQL Assist is a new feature of DB2 Version 7 that can greatly assist SQL developers. The SQL Assist feature is a GUI-driven tool to help you build SQL statements like <TT>SELECT</TT>, <TT>INSERT</TT>, <TT>UPDATE</TT>, and <TT>DELETE</TT>. Simply by picking and clicking SQL Assist will build syntactically correct SQL statements. Refer to <A class="docLink" HREF="#ch02fig02">Figure 2.2</A> for an example of SQL Assist. It is accessible from the following "products":<A NAME="ch02index377"></A><A NAME="ch02index378"></A><A NAME="ch02index379"></A><A NAME="ch02index380"></A><A NAME="ch02index381"></A></P>
<UL><LI><P class="docList">Control Center</P></LI><LI><P class="docList">DB2 Development Center (a.k.a Stored Procedure Builder)</P></LI><LI><P class="docList">Data Warehouse Center</P></LI></UL>
<A NAME="ch02fig02"></A><p><CENTER><H5 class="docFigureTitle">Figure 2.2. SQL Assist graphically guides SQL creation.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/02fig02_alt.jpg">[View full size image]</a></div><IMG BORDER="0"  width="500" height="438" SRC="images/0672326132/graphics/02fig02.jpg" ALT="graphics/02fig02.jpg"></p></CENTER></p><br>
<P class="docText">SQL Assist can be used to help developers build correct SQL statements, but it does not provide SQL performance advice. Using SQL Assist, however, can help to promote using a standard format for SQL statements within your organization.</P>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch02lev1sec1.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch02lev1sec3.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
