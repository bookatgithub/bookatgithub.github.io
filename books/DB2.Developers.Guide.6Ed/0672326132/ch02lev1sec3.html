<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Complex SQL Guidelines</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch02lev1sec2.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch02lev1sec4.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch02lev1sec3"></A><H3 class="docSection1Title">Complex SQL Guidelines</H3>
<P class="docText">The preceding section provided guidelines for simple SQL <TT>SELECT</TT> statements. These statements retrieve rows from a single table only. Complex SQL can use a single SQL <TT>SELECT</TT> statement to retrieve rows from different tables. There are five <span class="docEmphasis">basic</span> categories of complex SQL statements, namely<A NAME="ch02index382"></A><A NAME="ch02index383"></A><A NAME="ch02index384"></A></P>
<UL><LI><P class="docList">Joins</P></LI><LI><P class="docList">Subqueries</P></LI><LI><P class="docList">Table Expressions (also known as in-line views)</P></LI><LI><P class="docList">Unions</P></LI><LI><P class="docList">Grouping</P></LI></UL>
<P class="docText">Other forms of complex SQL, such as common table expressions and recursion, are covered later in this chapter.</P>
<P class="docText">Before delving into each of the five basic categories let's first discuss a general approach to writing complex SQL. It is a good practice to build complex SQL in steps. Start with simple SQL, test it for accuracy, and slowly add any additional elements required to return the proper results. For example, if you need to access three tables do not start by trying to build a single SQL statement that references all three tables. Start with one table and code the local predicates for that table. Test it for accuracy. When that works, add any grouping, sorting, and functions that might be needed. Test again. Only when you are retrieving the proper data from the first table should you add an additional table and its join predicates to the statement. Repeating this process for each table allows you to slowly build complex SQL instead of just jumping in and starting off complex—which can be confusing and error-prone.</P>
<A NAME="ch02lev2sec1"></A><H4 class="docSection2Title">Retrieving Data From Multiple Tables</H4>
<P class="docText">There are three basic ways to retrieve data from multiple tables in a single DB2 query: joins, subqueries, and table expressions.</P>
<P class="docText">A <span class="docEmphStrong">join</span> references multiple tables in the <TT>FROM</TT> clause of a <TT>SELECT</TT> (or uses the <TT>JOIN</TT> keyword to combine tables). When joining tables, columns from any table in the join can be returned in the result set (simply by specifying the column names in the <TT>SELECT</TT>-list of the query).<A NAME="ch02index385"></A><A NAME="ch02index386"></A><A NAME="ch02index387"></A><A NAME="ch02index388"></A></P>
<P class="docText">A <span class="docEmphStrong">subquery</span> is when one query references the results of another query. With subqueries, only those columns in the outermost table in the statement can be returned in the result set.<A NAME="ch02index389"></A><A NAME="ch02index390"></A><A NAME="ch02index391"></A><A NAME="ch02index392"></A></P>
<P class="docText"><span class="docEmphStrong">Table expressions</span> are SQL statements that are used in place of a table in another SQL statement. As with joins, columns from any table in the statement can be returned in the result set.<A NAME="ch02index393"></A><A NAME="ch02index394"></A><A NAME="ch02index395"></A><A NAME="ch02index396"></A><A NAME="ch02index397"></A></P>
<P class="docText">Truthfully, there are four ways to access data from multiple tables in a single query if you include <span class="docEmphStrong">unions</span>. A <TT>UNION</TT>, however, is fundamentally different from a join, subquery, or table expression because each SQL statement that is unioned returns a portion of the results set.<A NAME="ch02index398"></A><A NAME="ch02index399"></A><A NAME="ch02index400"></A><A NAME="ch02index401"></A></P>
<P class="docText">The following guidelines offer advice for complex SQL using joins, subqueries, table expressions, and unions.</P>
<A NAME="ch02lev4sec48"></A><H5 class="docSection3Title"><TT>UNION</TT> Versus <TT>UNION ALL</TT></H5>
<P class="docText">The <TT>UNION</TT> operator always results in a sort. When the <TT>UNION</TT> operator connects two <TT>SELECT</TT> statements, both <TT>SELECT</TT> statements are issued, the rows are sorted, and all duplicates are eliminated. If you want to avoid duplicates, use the <TT>UNION</TT> operator.<A NAME="ch02index402"></A><A NAME="ch02index403"></A><A NAME="ch02index404"></A><A NAME="ch02index405"></A><A NAME="ch02index406"></A><A NAME="ch02index407"></A><A NAME="ch02index408"></A><A NAME="ch02index409"></A></P>
<P class="docText">The <TT>UNION ALL</TT> operator, by contrast, does not invoke a sort. The <TT>SELECT</TT> statements connected by <TT>UNION ALL</TT> are executed, and all rows from the first <TT>SELECT</TT> statement are appended to all rows from the second <TT>SELECT</TT> statement. Duplicate rows might exist. Use <TT>UNION ALL</TT> when duplicate rows are required or, at least, are not a problem. Also use <TT>UNION ALL</TT> when you know that the <TT>SELECT</TT> statements will not return duplicates.</P>
<A NAME="ch02lev4sec49"></A><H5 class="docSection3Title">Use <TT>NOT EXISTS</TT> Instead of <TT>NOT IN</TT></H5>
<P class="docText">When you code a subquery using negation logic, try to use <TT>NOT EXISTS</TT> instead of <TT>NOT IN</TT> to increase the efficiency of your SQL statement. When you use <TT>NOT EXISTS</TT>, DB2 must verify only nonexistence. Doing so can reduce processing time significantly. With the <TT>NOT IN</TT> predicate, DB2 must materialize and sort the complete subquery results set.<A NAME="ch02index410"></A><A NAME="ch02index411"></A><A NAME="ch02index412"></A><A NAME="ch02index413"></A><A NAME="ch02index414"></A><A NAME="ch02index415"></A><A NAME="ch02index416"></A><A NAME="ch02index417"></A><A NAME="ch02index418"></A><A NAME="ch02index419"></A></P>
<A NAME="ch02lev4sec50"></A><H5 class="docSection3Title">Order the Elements in Your <TT>IN</TT> Lists</H5>
<P class="docText">The order of elements in a SQL <TT>IN</TT> list can impact performance when an index is not used to process the IN list. DB2 will search the list of elements from left to right until a match is found or the end of the list is reached. For this reason, code the most commonly occurring values first in your <TT>IN</TT> lists. Doing so will cause DB2 to match as early as possible most of the time—thereby improving performance. For example, consider the following SQL statement:<A NAME="ch02index420"></A><A NAME="ch02index421"></A><A NAME="ch02index422"></A><A NAME="ch02index423"></A><A NAME="ch02index424"></A></P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, WORKDEPT, EDLEVEL, SALARY
FROM    DSN8810.EMP
WHERE   WORKDEPT IN ('A00', 'A01', 'E21');
</pre><BR>
<P class="docText">This SQL statement demonstrates the natural tendency to order lists alphabetically or numerically. The statement is correctly coded only if <TT>A00</TT> occurs more often than <TT>A01</TT>, which occurs more often than <TT>E21</TT>. But if <TT>A01</TT> was most common, followed by <TT>E21</TT> and then <TT>A00</TT>, the statement would be better coded (performance-wise) as</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, WORKDEPT, EDLEVEL, SALARY
FROM    DSN8810.EMP
WHERE   WORKDEPT IN ('A01', 'E21', 'A00');
</pre><BR>
<A NAME="ch02lev4sec51"></A><H5 class="docSection3Title">Remove Duplicates from Your <TT>IN</TT> Lists</H5>
<P class="docText">When using the <TT>IN</TT> predicate with a list of values, DB2 sorts the <TT>IN</TT>-list into ascending sequence and removes duplicates if the column specified is indexed. The <TT>IN</TT>-list values are then used to probe the index to find the matching rows. However, if there is no index for the column, DB2 will not sort the <TT>IN</TT>-list and any duplicates will remain. Upon retrieval of a row, the column value is used to search the <TT>IN</TT>-list (duplicates and all).<A NAME="ch02index425"></A><A NAME="ch02index426"></A><A NAME="ch02index427"></A><A NAME="ch02index428"></A><A NAME="ch02index429"></A><A NAME="ch02index430"></A></P>
<P class="docText">Therefore, it makes sense to order the elements of the <TT>IN</TT>-list, code your most restrictive predicates first, and never code duplicates in the <TT>IN</TT>-list.</P>
<A NAME="ch02lev4sec52"></A><H5 class="docSection3Title">Be Aware of Predicate Transitive Closure Rules</H5>
<P class="docText"><span class="docEmphasis">Predicate transitive closure</span> refers to the capability of the DB2 optimizer to use the rule of transitivity (if A=B and B=C, then A=C) to determine the most efficient access path for queries. The optimizer did not always have the capability to use the rule of transitivity.<A NAME="ch02index431"></A><A NAME="ch02index432"></A><A NAME="ch02index433"></A><A NAME="ch02index434"></A><A NAME="ch02index435"></A><A NAME="ch02index436"></A></P>
<P class="docText">In older releases of DB2, you produced a more efficient query by providing redundant information in the <TT>WHERE</TT> clause of a join statement, as in this example</P>
<pre>

</pre><BR><pre>
SELECT  A.COL1, A.COL2, B.COL1
FROM    TABLEA A, TABLEB B
WHERE   A.COL1 = B.COL1
AND     A.COL1 = :HOSTVAR;
</pre><BR>
<P class="docText">This query could process more efficiently in pre-V2.1 releases of DB2 by coding a redundant predicate, as follows:</P>
<pre>

</pre><BR><pre>
SELECT  A.COL1, A.COL2, B.COL1
FROM    TABLEA A,
        TABLEB B
WHERE   A.COL1 = B.COL1
AND     A.COL1 = :HOSTVAR
AND     B.COL1 = :HOSTVAR;
</pre><BR>
<P class="docText">The need to code redundant predicates for performance no longer exists for equality and range predicates. However, predicate transitive closure is not applied with <TT>LIKE</TT> or <TT>IN</TT> predicates. Consider this example:</P>
<pre>

</pre><BR><pre>
SELECT  A.COL1, A.COL2, B.COL1
FROM    TABLEA  A,
        TABLEB  B
WHERE   A.COL1 = B.COL1
AND     A.COL1 LIKE 'ABC%';
</pre><BR>
<P class="docText">The preceding can be more efficiently coded as follows:</P>
<pre>

</pre><BR><pre>
SELECT  A.COL1, A.COL2, B.COL1
FROM    TABLEA  A,
        TABLEB  B
WHERE   A.COL1 = B.COL1
AND     A.COL1 LIKE 'ABC%'
AND     B.COL1 LIKE 'ABC%';
</pre><BR>
<P class="docText">Unless you're using an <TT>IN</TT> or <TT>LIKE</TT> clause, or you are running on an ancient version of DB2 (pre V2.3) do not code redundant predicates; doing so is unnecessary and might cause the query to be less efficient.<A NAME="ch02index437"></A><A NAME="ch02index438"></A><A NAME="ch02index439"></A><A NAME="ch02index440"></A><A NAME="ch02index441"></A><A NAME="ch02index442"></A></P>
<A NAME="ch02lev4sec53"></A><H5 class="docSection3Title">Use SQL to Determine "Top Ten"</H5>
<P class="docText">Application developers frequently wish to retrieve a limited number of qualifying rows from a table. For example, maybe you need to list the ten highest selling items from inventory or the top ten most expensive products (that is, the products with the highest price tags). There are several ways to accomplish this prior to DB2 V7 using SQL, but they are not necessarily efficient.<A NAME="ch02index443"></A><A NAME="ch02index444"></A><A NAME="ch02index445"></A><A NAME="ch02index446"></A><A NAME="ch02index447"></A><A NAME="ch02index448"></A></P>
<P class="docText">The basic question that arises frequently is how best to return only a portion of the actual result set for a query. This situation most frequently manifests itself in the "Top Ten" problem (for example, returning the top-ten highest salaries in the company).</P>
<P class="docText">The first reaction is to simply use the <TT>WHERE</TT> clause to eliminate non-qualifying rows. But this is simplistic, and often is not sufficient to produce the results desired in an optimal manner. What if the program only requires that the top ten results be returned? This can be a somewhat difficult request to formulate using SQL alone. Consider, for example, an application that needs to retrieve only the ten highest-paid employees from the EMP sample table. You could simply issue a SQL request that retrieves all of the employees in order by salary, but only use the first ten retrieved. That is easy, for example</P>
<pre>

</pre><BR><pre>
SELECT   SALARY, EMPNO, LASTNAME
FROM     DSN8810.EMP
ORDER BY SALARY DESC;
</pre><BR>
<P class="docText">It is imperative that you specify the <TT>ORDER BY</TT> clause with the <TT>DESC</TT> keyword. This sorts the results into descending order, instead of the default, which is ascending. Without the <TT>DESC</TT> key word, the "top ten" would be at the very end of the results set, not at the beginning.<A NAME="ch02index449"></A><A NAME="ch02index450"></A><A NAME="ch02index451"></A><A NAME="ch02index452"></A></P>
<P class="docText">But this "solution" does not really satisfy the requirement—retrieving only the top ten. It merely sorts the results into descending sequence. So the results would still be all employees in the table, but in the correct order so you can view the "top ten" salaries very easily.</P>
<P class="docText">The ideal solution should return <span class="docEmphStrong">only</span> the ten employees with the highest salaries and not merely a sorted list of all employees. Consider the following SQL:</P>
<pre>

</pre><BR><pre>
SELECT SALARY, EMPNO, LASTNAME
FROM   DSN8810.EMP  E1
WHERE  10 &gt; (SELECT COUNT(*)
             FROM   DSN8810.EMP E2
             WHERE  E1.SALARY &lt; E2.SALARY);
</pre><BR>
<P class="docText">The ten highest salaries are returned. You can alter the actual number by changing the literal value <TT>10</TT> to whatever number you want. This particular SQL does not perform very well, but it will work with all versions of DB2.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><P class="docText"> As of DB2 Version 7, the best way to perform this function is to use a query with the <TT>FETCH FIRST </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS ONLY</TT> clause. So, the query becomes:<A NAME="ch02index453"></A><A NAME="ch02index454"></A></P></td></tr></table><br>
<pre>

</pre><BR><pre>
SELECT SALARY, EMPNO, LASTNAME
FROM   DSN8810.EMP
ORDER BY SALARY DESC
FETCH FIRST 10 ROWS ONLY;
</pre><BR>
<P class="docText">The <TT>ORDER BY</TT> clause will sort the data into descending order by <TT>SALARY</TT> values. The <TT>FETCH FIRST 10 ROWS ONLY</TT> clause will limit your output to 10 rows only. If duplicates are possible you can eliminate them by adding a <TT>DISTINCT</TT> clause after the <TT>SELECT</TT> and before the columns being selected.<A NAME="ch02index455"></A><A NAME="ch02index456"></A><A NAME="ch02index457"></A><A NAME="ch02index458"></A><A NAME="ch02index459"></A><A NAME="ch02index460"></A></P>
<A NAME="ch02lev4sec54"></A><H5 class="docSection3Title">Use <TT>FETCH FIRST </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS ONLY</TT> to Limit the Size of SQL Result Sets</H5>

<P class="docText">The <TT>FETCH FIRST </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS ONLY</TT> clause can limit the number of qualifying rows for any <TT>SELECT</TT> statement. You can code <TT>FETCH FIRST </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS</TT>, which will limit the number of rows fetched and returned by a <TT>SELECT</TT> statement. So, for example, to limit your results to 371 rows, you could code<A NAME="ch02index461"></A><A NAME="ch02index462"></A><A NAME="ch02index463"></A><A NAME="ch02index464"></A></P>
<pre>

</pre><BR><pre>
SELECT SALARY, EMPNO, LASTNAME
FROM   DSN8810.EMP
FETCH FIRST 371 ROWS ONLY;
</pre><BR>
<P class="docText">The <TT>SQLCODE</TT> will be set to <TT>+100</TT> when you try to <TT>FETCH</TT> row number 372, or at the end of the result set if there are fewer than 371 rows.</P>
<A NAME="ch02note14"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">The <TT>FETCH FIRST </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS ONLY</TT> clause is not the same as the <TT>OPTIMIZE FOR </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS</TT> clause. The <TT>FETCH FIRST</TT> clause will cause your cursor to stop returning rows after <span class="docEmphasis"><TT>n</TT></span> rows have been returned; the <TT>OPTIMIZE FOR</TT> clause will not (it just gives guidance to the DB2 optimizer for access path formulation).</P>
<P class="docText">However, specifying <TT>FETCH FIRST</TT> causes DB2 to use an implicit <TT>OPTIMIZE FOR</TT> clause with the same number for <span class="docEmphasis"><TT>n</TT></span>. So, specifying <TT>FETCH FIRST 12 ROWS ONLY</TT> causes DB2 to use an implicit <TT>OPTIMIZE FOR 12 ROWS</TT>; you do not need to code the <TT>OPTIMIZE FOR</TT> clause.</P></div><br>
<P class="docText">Keep in mind that this discussion differs from the previous guideline because we do not care about order (or the "top" so many rows), just limiting the number of rows to some preset number. That is why an <TT>ORDER BY</TT> is not required.<A NAME="ch02index465"></A><A NAME="ch02index466"></A><A NAME="ch02index467"></A><A NAME="ch02index468"></A></P>
<A NAME="ch02note15"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">If you do not provide an <TT>ORDER BY</TT> clause on a query that uses the <TT>FETCH FIRST </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS ONLY</TT> clause, your results will be unpredictable. Remember, there is no inherent order to a DB2 table, so the order in which rows are returned is based on the access path chosen by the DB2 optimizer. So, although the <TT>FETCH FIRST </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS ONLY</TT> clause will limit your result set to <span class="docEmphasis"><TT>n</TT></span>, you are <span class="docEmphStrong">not</span> guaranteed to retrieve the same <span class="docEmphasis"><TT>n</TT></span> rows every time.</P></div><br>
<A NAME="ch02lev4sec55"></A><H5 class="docSection3Title">Code Appropriate Existence Checking SQL</H5>
<P class="docText">There are times when a program just needs to know that some given data exists and does not need to actually retrieve and use that data. For these situations you will need to develop the most efficient SQL possible that just checks if the specific data exists. But what is the best way to accomplish an existence check?<A NAME="ch02index469"></A><A NAME="ch02index470"></A><A NAME="ch02index471"></A><A NAME="ch02index472"></A><A NAME="ch02index473"></A></P>
<P class="docText">Prior to DB2 V7, the best way to check for existence is to use a correlated query against the <TT>SYSDUMMY1</TT> table. For example, to check for the existence of an employee with the last name of Jones in the <TT>EMP</TT> table, the SQL would look like this:</P>
<pre>

</pre><BR><pre>
SELECT 1
FROM   SYSIBM.SYSDUMMY1 A
WHERE  EXISTS (SELECT 1
               FROM   DSN8810.EMP B
               WHERE  LASTNAME = 'JONES'
               AND A.IBMREQD = A.IBMREQD);
</pre><BR>
<P class="docText">Sometimes, though, we need more information. Perhaps we need to list all employees who are responsible for at least one project. That can be coded as follows:</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO
FROM    DSN8810.EMP   E
WHERE   EXISTS
        (SELECT  1
         FROM    DSN8810.PROJ   P
         WHERE   P.RESPEMP = E.EMPNO);
</pre><BR>
<P class="docText">First, notice that we just <TT>SELECT</TT> the constant <TT>1</TT>. Because the data does not need to be returned to the program, the SQL statement need not specify any columns in the <TT>SELECT</TT>-list. We simply check the <TT>SQLCODE</TT>. If the <TT>SQLCODE</TT> is zero, data exists; if not, the data does not exist.</P>
<P class="docText">If you do not use a correlated query with <TT>EXISTS</TT>, but instead simply issue the <TT>SELECT</TT> statement, performance can suffer as DB2 scans to find subsequent occurrences of the data—which might be many, especially for a common name such as Jones. Of course, if a unique index exists on the column(s) in question, then you can get by with the simple query.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><P class="docText"> Which brings us to DB2 V7. In this version IBM added a new clause called <TT>FETCH FIRST </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS ONLY</TT>. This solves our problem for existence checking and should be the new standard after you move to DB2 V7. Going back to our example, the SQL for existence checking now becomes:</P></td></tr></table><br>
<pre>

</pre><BR><pre>
SELECT 1
FROM   DSN8810.EMP
WHERE  LASTNAME = 'JONES'
FETCH FIRST 1 ROW ONLY;
</pre><BR>
<P class="docText">We still do not specify columns in the <TT>SELECT</TT>-list, but we no longer need the correlated query. DB2 will stop after 1 row has been checked—which is the desired result.<A NAME="ch02index474"></A><A NAME="ch02index475"></A><A NAME="ch02index476"></A><A NAME="ch02index477"></A><A NAME="ch02index478"></A></P>
<A NAME="ch02lev4sec56"></A><H5 class="docSection3Title">Minimize the Number of Tables in a Join</H5>
<P class="docText">Joining many tables in one query can adversely affect performance. Although the maximum number of tables that can be joined in a single SQL statement is 225, the practical limit is usually fewer.<A NAME="ch02index479"></A><A NAME="ch02index480"></A><A NAME="ch02index481"></A><A NAME="ch02index482"></A><A NAME="ch02index483"></A></P>
<A NAME="ch02note16"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p><p><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" ALIGN="LEFT" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText">Prior to DB2 V6, the limit for tables in a SQL statement was 15. DB2 V6 actually increased the limit for tables in a SQL statement from 15 to 225, but in a restricted manner: Each SQL statement can consist of up to 15 Query Blocks, each directly or indirectly identifying 15 base table references. The grand total number of tables for a single SQL statement is 225; however, no query block can exceed 15 base table references, whether direct or indirect.<A NAME="ch02index484"></A><A NAME="ch02index485"></A><A NAME="ch02index486"></A><A NAME="ch02index487"></A><A NAME="ch02index488"></A></P><P class="docText">DB2 V8 removes this restriction; each SQL statement can reference up to 225 tables in total. The limit has been raised to such a high number to accommodate ERP vendors such as Peoplesoft and SAP, whose applications were designed originally for other RDBMS packages, such as Oracle, that have higher limits than DB2. Just because the limit has been increased does not mean you should write queries that access such a large number of tables. The performance of such queries will likely be poor and difficult to manage.</P></td></tr></table></p></div><br>
<P class="docText">However, setting an artificial limit on the standard number of tables per join is not a wise course of action. In some situations, avoiding large, complex joins in an online environment may be necessary. But the same statement might be completely acceptable in a batch job or as an ad hoc request.</P>
<P class="docText">The number of tables to be joined in any application should be based on the following:</P>
<UL><LI><P class="docList">The total number of rows participating in the join</P></LI><LI><P class="docList">The results you want to obtain from the query</P></LI><LI><P class="docList">The level of performance you want</P></LI><LI><P class="docList">The anticipated throughput of the application</P></LI><LI><P class="docList">The type of application (OLTP versus OLAP or DSS)</P></LI><LI><P class="docList">The environment in which the application will operate (online versus batch)</P></LI><LI><P class="docList">The availability you want (for example, 24x7)</P></LI></UL>
<P class="docText">In general, however, always eliminate unnecessary tables from your join statement.<A NAME="ch02index489"></A><A NAME="ch02index490"></A><A NAME="ch02index491"></A><A NAME="ch02index492"></A><A NAME="ch02index493"></A></P>
<A NAME="ch02lev4sec57"></A><H5 class="docSection3Title">Consider <TT>CASE</TT> Expressions to Optimize Counting</H5>
<P class="docText">When you need to produce counts of rows in DB2 tables, consider using a <TT>CASE</TT> expression instead of using multiple SQL <TT>SELECT</TT> statements. For example, if you need to count the number of employees who earn different salary ranges, consider the following statement<A NAME="ch02index494"></A><A NAME="ch02index495"></A><A NAME="ch02index496"></A><A NAME="ch02index497"></A><A NAME="ch02index498"></A><A NAME="ch02index499"></A></P>
<pre>

</pre><BR><pre>
SELECT SUM(CASE WHEN SALARY BETWEEN 0 AND 20000
                THEN 1 <span class="docEmphasis">ELSE 0</span> END) AS UPTO20
      ,SUM(CASE WHEN SALARY BETWEEN 20001 AND 50000
                THEN 1 <span class="docEmphasis">ELSE 0</span> END) AS FROM20TO50
      ,SUM(CASE WHEN SALARY BETWEEN 50001 AND 80000
                THEN 1 <span class="docEmphasis">ELSE 0</span> END) AS FROM50TO80
      ,SUM(CASE WHEN SALARY &gt; 80000
                THEN 1 <span class="docEmphasis">ELSE 0</span> END) AS OVER80
      ,SUM(CASE WHEN SALARY &lt; 0
                THEN 1 <span class="docEmphasis">ELSE 0</span> END) AS NEGATIVESAL
FROM DSN8810.EMP;
</pre><BR>
<P class="docText">This <TT>SELECT</TT> statement efficiently scans through the data and produces a sum for each range that is defined. The multiple <TT>CASE</TT> expressions return either a <TT>0</TT> or a <TT>1</TT>. The <TT>SUM</TT> function just adds up the values and you get totals for employees within each range.</P>
<P class="docText">This outperforms multiple <TT>SELECT</TT> statements using <TT>COUNT(*)</TT> because DB2 can keep running totals as it passes once through the data using the <TT>CASE</TT> expressions.</P>
<A NAME="ch02note17"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">The previous example shows the <TT>CASE</TT> expression returning either a <TT>0</TT> or a <TT>1</TT>. If you did not include the <TT>ELSE</TT> portion of each <TT>CASE</TT> expression, DB2 would return either a <TT>1</TT> or a <TT>NULL</TT>. This can be more efficient than returning <TT>1</TT> or <TT>0</TT> for very large sets of data. This is so because DB2 will actually add the zeroes, but it can ignore the <TT>NULL</TT>s.</P>
<P class="docText">However, be careful, because if there are any categories where no rows apply, then DB2 will <TT>SUM</TT> up a bunch of <TT>NULL</TT>s—which returns <TT>NULL</TT>, not <TT>0</TT> as the result.</P></div><br>
<A NAME="ch02lev4sec58"></A><H5 class="docSection3Title">Consider Denormalizing to Reduce Joins</H5>
<P class="docText">To minimize the need for joins, consider denormalization. Remember, however, that denormalization usually implies redundant data, dual updating, and extra DASD usage. Normalization optimizes data modification at the expense of data access; denormalization optimizes data access at the expense of data modification.<A NAME="ch02index500"></A><A NAME="ch02index501"></A><A NAME="ch02index502"></A><A NAME="ch02index503"></A></P>
<P class="docText">Whenever you denormalize be sure to document the specific reasons for the denormalization, as well as listing each specific change made to the database structure. Denormalization should be undertaken only as a last resort. You can find additional denormalization assistance in <A class="docLink" HREF="ch05.html#ch05">Chapter 5</A>.</P>
<A NAME="ch02lev4sec59"></A><H5 class="docSection3Title">Reduce the Number of Rows to Be Joined</H5>
<P class="docText">The number of rows participating in a join is the single most important determinant in predicting the response time of a join. To reduce join response time, reduce the number of rows to be joined in the join's predicates.<A NAME="ch02index504"></A><A NAME="ch02index505"></A><A NAME="ch02index506"></A><A NAME="ch02index507"></A><A NAME="ch02index508"></A></P>
<P class="docText">For example, when you try to determine which males in all departments reporting to department <TT>D01</TT> make a salary of $40,000 or more, you can code the predicates for both <TT>SEX</TT> and <TT>SALARY</TT> as follows:</P>
<pre>

</pre><BR><pre>
SELECT  E.LASTNAME, E.FIRSTNME
FROM    DSN8810.DEPT  D,
        DSN8810.EMP   E
WHERE   D.ADMRDEPT = 'D01'
AND     D.DEPTNO = E.WORKDEPT
AND     E.SEX = 'M'
AND     E.SALARY &gt;= 40000.00;
</pre><BR>
<P class="docText">The predicates on the <TT>SEX</TT> and <TT>SALARY</TT> columns can be used to reduce the amount of data that needs to be joined. If you fail to code either of the last two predicates, deciding instead to scan the results and pull out the information you need, more rows qualify for the join and the join is less efficient.</P>
<A NAME="ch02lev4sec60"></A><H5 class="docSection3Title">Join Using SQL Instead of Program Logic</H5>
<P class="docText">Coding a join using SQL instead of COBOL or another high-level language is almost always more efficient. The DB2 optimizer has a vast array of tools in its arsenal to optimize the performance of SQL queries. Usually, a programmer will fail to consider the same number of possibilities as DB2.<A NAME="ch02index509"></A><A NAME="ch02index510"></A><A NAME="ch02index511"></A><A NAME="ch02index512"></A></P>
<P class="docText">If a specific SQL join is causing high overhead, consider the tuning options outlined in this chapter before deciding to implement the join using a program. To further emphasize the point, consider the results of a recent test. A three table join using <TT>GROUP BY</TT> and the <TT>COUNT(*)</TT> function similar to the one below was run:</P>
<pre>

</pre><BR><pre>
SELECT   A.EMPNO, LASTNAME, COUNT(*)
FROM     DSN8810.EMP         E,
         DSN8810.EMPPROJACT  A,
         DSN8810.PROJ        P
WHERE    E.EMPNO = A.EMPNO
AND      P.PROJNAME IN ('PROJECT1', 'PROJECT7', 'PROJECT9')
AND      A.PROJNO = P.PROJNO
AND      A.EMPTIME &gt; 40.0
GROUP BY A.EMPNO, LASTNAME;
</pre><BR>
<P class="docText">Additionally, an equivalent program was coded using three cursors (one for each join), internal sorting (using Syncsort, <TT>DFSORT</TT>, or a similar utility), and programmatic counting. Performance reports were run on both, and the SQL statement outperformed the equivalent application program by several orders of magnitude in terms of both elapsed time and CPU time.</P>
<P class="docText">Programming your own application joins should <span class="docEmphBoldItalic">always</span> be a very last resort and should not be considered unless you have exhausted all other tuning techniques. In practice, application joins are almost never needed for performance reasons.</P>
<A NAME="ch02lev4sec61"></A><H5 class="docSection3Title">Use Joins Instead of Subqueries</H5>
<P class="docText">A join can be more efficient than a correlated subquery or a subquery using <TT>IN</TT>. For example, this query joins two tables:<A NAME="ch02index513"></A><A NAME="ch02index514"></A><A NAME="ch02index515"></A><A NAME="ch02index516"></A><A NAME="ch02index517"></A></P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, LASTNAME
FROM    DSN8810.EMP,
        DSN8810.PROJ
WHERE   WORKDEPT = DEPTNO
AND     EMPNO = RESPEMP;
</pre><BR>
<P class="docText">The preceding example is usually more efficient than the following query, which is formulated as a correlated subquery accessing the same two tables:</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, LASTNAME
FROM    DSN8810.EMP X
WHERE   WORKDEPT IN
        (SELECT  DEPTNO
         FROM    DSN8810.PROJ
         WHERE   RESPEMP = X.EMPNO);
</pre><BR>
<P class="docText">The preceding two queries demonstrate how to turn a correlated subquery into a join. You can translate non-correlated subqueries into joins in the same manner. For example, the join</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, LASTNAME
FROM    DSN8810.EMP,
        DSN8810.DEPT
WHERE   WORKDEPT = DEPTNO
AND     DEPTNAME = 'PLANNING';
</pre><BR>
<P class="docText">is usually more efficient than the subquery</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, LASTNAME
FROM    DSN8810.EMP
WHERE   WORKDEPT IN
        (SELECT  DEPTNO
         FROM    DSN8810.DEPT
         WHERE   DEPTNAME = 'PLANNING');
</pre><BR>
<P class="docText">Note that these two queries do not necessarily return the same results. If <TT>DEPTNO</TT> is not unique, the first <TT>SELECT</TT> statement could return more rows than the second <TT>SELECT</TT> statement, and some of the values for <TT>EMPNO</TT> could appear more than once in the results table.</P>
<P class="docText">Be aware, however, that with each new release of DB2, subqueries (both correlated and non-correlated) are becoming more and more efficient. Yet, performance concerns aside, standardizing on joins instead of subqueries (when possible) can make development and maintenance easier because fewer query formulations need to be considered during implementation, or modified during maintenance cycles. Additionally, in certain cases DB2 may transform subqueries into joins during optimization.<A NAME="ch02index518"></A><A NAME="ch02index519"></A><A NAME="ch02index520"></A><A NAME="ch02index521"></A><A NAME="ch02index522"></A></P>
<A NAME="ch02lev4sec62"></A><H5 class="docSection3Title">Join on Clustered Columns</H5>
<P class="docText">When you join large tables, use clustered columns in the join criteria when possible. This way, you can reduce the need for intermediate sorts. Note that doing so might require clustering of the parent table by primary key and the child table by foreign key.<A NAME="ch02index523"></A><A NAME="ch02index524"></A><A NAME="ch02index525"></A><A NAME="ch02index526"></A><A NAME="ch02index527"></A><A NAME="ch02index528"></A></P>
<A NAME="ch02lev4sec63"></A><H5 class="docSection3Title">Join on Indexed Columns</H5>
<P class="docText">The efficiency of your program improves when tables are joined based on indexed columns rather than on non-indexed ones. To increase the performance of joins, consider creating indexes specifically for the predicates being joined.<A NAME="ch02index529"></A><A NAME="ch02index530"></A><A NAME="ch02index531"></A><A NAME="ch02index532"></A><A NAME="ch02index533"></A><A NAME="ch02index534"></A></P>
<A NAME="ch02lev4sec64"></A><H5 class="docSection3Title">Use Caution When Specifying <TT>ORDER BY</TT> with a Join</H5>
<P class="docText">When the results of a join must be sorted, limiting the <TT>ORDER BY</TT> to columns of a single table can cause DB2 to avoid a sort. Whenever you specify columns from multiple tables in the <TT>ORDER BY</TT> clause of a join statement, DB2 invokes a sort.<A NAME="ch02index535"></A><A NAME="ch02index536"></A><A NAME="ch02index537"></A><A NAME="ch02index538"></A><A NAME="ch02index539"></A><A NAME="ch02index540"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> In DB2 V8, you can alleviate the pain of the multi-table <TT>ORDER BY</TT> by using a Materialized Query Table, which is covered in detail in <A class="docLink" HREF="ch45.html#ch45">Chapter 45</A>, "Data Warehousing with DB2."</P></td></tr></table><br>
<A NAME="ch02lev4sec65"></A><H5 class="docSection3Title">Avoid Cartesian Products</H5>
<P class="docText">Never use a join statement without a predicate. A join without a predicate generates a results table in which every row from the first table is joined with every row from the other table: a Cartesian product. For example, joining—without a predicate—a 1,000 row table with another 1,000 row table results in a table with 1,000,000 rows. No additional information is provided by this join, so a lot of machine resources are wasted.<SUP><A class="docLink" HREF="ch02endnotes.html#ch02en01">[1]</A></SUP><A NAME="ch02index541"></A><A NAME="ch02index542"></A><A NAME="ch02index543"></A><A NAME="ch02index544"></A><A NAME="ch02index545"></A></P>
<A NAME="ch02note18"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Although you should never specify a Cartesian product in your SQL queries, the DB2 optimizer may decide to use a Cartesian product for a portion, or portions of a join. For example, when a star join is being used, the DB2 optimizer will choose to implement Cartesian products for portions of the join. This may happen in data warehousing queries and other ad hoc queries where multiple dimension tables are joined to a very large fact table. Because the fact table is usually many times larger than the dimension tables, processing the fact table only once against the Cartesian product of the fact tables can enhance query performance. As many as six dimension tables (five prior to DB2 V6) can be joined as a Cartesian product for a star join in DB2.</P>
<P class="docText">For more information on star joins consult <A class="docLink" HREF="ch45.html#ch45">Chapter 45</A>.</P></div><br>
<A NAME="ch02lev4sec66"></A><H5 class="docSection3Title">Provide Adequate Search Criteria</H5>
<P class="docText">When possible, provide additional search criteria in the <TT>WHERE</TT> clause for every table in a join. These criteria are in addition to the join criteria, which are mandatory to avoid Cartesian products. This information provides DB2 with the best opportunity for ranking the tables to be joined in the most efficient manner (that is, for reducing the size of intermediate results tables). In general, the more information you provide to DB2 for a query, the better the chances that the query will perform adequately.<A NAME="ch02index546"></A><A NAME="ch02index547"></A><A NAME="ch02index548"></A><A NAME="ch02index549"></A><A NAME="ch02index550"></A><A NAME="ch02index551"></A><A NAME="ch02index552"></A></P>
<A NAME="ch02lev4sec67"></A><H5 class="docSection3Title">Consider Using Explicit INNER JOINs</H5>
<P class="docText">Instead of specifying joins by using a comma-delimited list of tables in the <TT>FROM</TT> clause, use <TT>INNER JOIN</TT> with the <TT>ON</TT> clause. Explicit <TT>INNER JOIN</TT> syntax might help when you're training new programmers in SQL because it provides a join keyword. Likewise, the join predicates must be isolated in the <TT>ON</TT> clause when you're using an explicit <TT>INNER JOIN</TT>. This way, reading, tuning, and maintaining the SQL code are easier.<A NAME="ch02index553"></A><A NAME="ch02index554"></A><A NAME="ch02index555"></A><A NAME="ch02index556"></A><A NAME="ch02index557"></A><A NAME="ch02index558"></A></P>
<A NAME="ch02lev4sec68"></A><H5 class="docSection3Title">Use Explicit OUTER JOINs</H5>
<P class="docText">Avoid coding an outer join in the old style, which required a simple <TT>SELECT</TT>, a <TT>UNION</TT>, and a correlated subselect.<A NAME="ch02index559"></A><A NAME="ch02index560"></A><A NAME="ch02index561"></A><A NAME="ch02index562"></A><A NAME="ch02index563"></A><A NAME="ch02index564"></A></P>
<A NAME="ch02note19"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Prior to DB2 V4, this was the only way to code an outer join.</P></div><br>
<P class="docText">Instead use the SQL outer join syntax which is easier to code, easier to maintain, and more efficient to execute. An explicit <TT>OUTER JOIN</TT> uses one pass against the tables and as such usually outperforms an outer join using <TT>UNION</TT> or <TT>UNION ALL</TT>. Using explicit <TT>OUTER JOIN</TT> statements reduces the number of bugs and speeds application development time due solely to the significant reduction in lines of code required. Furthermore, as IBM improves the optimizer over time, techniques designed to make outer joins more efficient will most likely focus only on the new, explicit outer join syntax and not on the old, complex SQL formulation.</P>
<A NAME="ch02lev4sec69"></A><H5 class="docSection3Title">Exception Reporting</H5>
<P class="docText">You can use the bottom half of the old style of outer join to report just the exceptions when you don't need a full-blown outer join. Consider this example:<A NAME="ch02index565"></A><A NAME="ch02index566"></A><A NAME="ch02index567"></A><A NAME="ch02index568"></A><A NAME="ch02index569"></A></P>
<pre>

</pre><BR><pre>
SELECT  D.DEPTNO, D.DEPTNAME, D.MGRNO, '* No Mgr Name *'
FROM    DSN8810.DEPT  D
WHERE   NOT EXISTS
        (SELECT  1
         FROM    DSN8810.EMP  E
         WHERE   D.MGRNO = E.EMPNO)
ORDER BY 1;
</pre><BR>
<P class="docText">This SQL returns only the departments without a manager name.</P>
<A NAME="ch02lev4sec70"></A><H5 class="docSection3Title">Favor <TT>LEFT</TT> Over <TT>RIGHT OUTER JOIN</TT>s</H5>
<P class="docText">Favor coding <TT>LEFT OUTER JOIN</TT> over <TT>RIGHT OUTER JOIN</TT>. The choice is truly arbitrary, but the manner in which DB2 shows <TT>EXPLAIN</TT> information makes left outer joins easier to tune. <TT>EXPLAIN</TT> populates the <TT>JOIN_TYPE</TT> column to describe the outer join method (<TT>FULL</TT>, <TT>RIGHT</TT>, or <TT>LEFT</TT>). The column contains the value <TT>F</TT> for a <TT>FULL OUTER JOIN</TT>, <TT>L</TT> for a <TT>LEFT OUTER JOIN</TT> or <TT>RIGHT OUTER JOIN</TT>, or a blank for an <TT>INNER JOIN</TT> or no join. DB2 always converts right outer joins to left outer joins, so there is no <TT>R</TT> value for <TT>JOIN_TYPE</TT>.<A NAME="ch02index570"></A><A NAME="ch02index571"></A><A NAME="ch02index572"></A><A NAME="ch02index573"></A><A NAME="ch02index574"></A><A NAME="ch02index575"></A></P>
<P class="docText">The right outer join syntax is only available to make the query easier to read and understand. Because deciphering the <TT>PLAN_TABLE</TT> data is more difficult for a <TT>RIGHT OUTER JOIN</TT> than for a <TT>LEFT OUTER JOIN</TT>, favor coding left outer joins whenever possible.</P>
<A NAME="ch02lev4sec71"></A><H5 class="docSection3Title">Use <TT>COALESCE</TT> with <TT>FULL OUTER JOIN</TT>s</H5>
<P class="docText">At times, you might need the <TT>COALESCE</TT> function to avoid nulls in the result columns of <TT>OUTER JOIN</TT> statements. To understand how <TT>COALESCE</TT> can be useful in an outer join, consider the following query:<A NAME="ch02index576"></A><A NAME="ch02index577"></A><A NAME="ch02index578"></A><A NAME="ch02index579"></A><A NAME="ch02index580"></A><A NAME="ch02index581"></A><A NAME="ch02index582"></A></P>
<pre>

</pre><BR><pre>
SELECT  EMP.EMPNO, EMP.WORKDEPT, DEPT.DEPTNAME
FROM    DSN8810.EMP EMP FULL OUTER JOIN DSN8810.DEPT DEPT
ON      EMP.WORKDEPT = DEPT.DEPTNO;
</pre><BR>
<P class="docText">A portion of the results for this query looks like the following:</P>
<P><TABLE CELLSPACING="0" FRAME="below" RULES="groups" CELLPADDING="5"><COLGROUP><COL width="121"><COL width="132"><COL width="297"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><TT>EMPNO</TT></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><TT>WORKDEPT</TT></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><TT>DEPTNAME</TT></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>200330</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>E21</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SOFTWARE SUPPORT</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>200340</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>E21</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SOFTWARE SUPPORT</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>------</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>---</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DEVELOPMENT CENTER</TT></P></TD></TR></TABLE></P><br>
<P class="docText">Note that the department code for <TT>DEVELOPMENT CENTER</TT> is not displayed, even though you know by simple browsing of the <TT>DEPT</TT> table that the code is <TT>D01</TT>. The value is not returned because the query selects the <TT>WORKDEPT</TT> column from <TT>EMP</TT>, not the <TT>DEPTNO</TT> column from <TT>DEPT</TT>. You can rectify this situation by using the <TT>COALESCE</TT> function. The <TT>COALESCE</TT> function notifies DB2 to look for a value in both of the listed columns, one from each table in the outer join (in this case, <TT>EMP</TT> and <TT>DEPT</TT>). If a value is found in either table, it can be returned in the result set. Consider the following example:</P>
<pre>

</pre><BR><pre>
SELECT  EMP.EMPNO,
        COALESCE(EMP.WORKDEPT, DEPT.DEPTNO) AS DEPTNUM,
        DEPT.DEPTNAME
FROM    DSN8810.EMP EMP FULL OUTER JOIN DSN8810.DEPT DEPT
ON      EMP.WORKDEPT = DEPT.DEPTNO;
</pre><BR>
<P class="docText">The results are changed as follows:</P>
<P><TABLE CELLSPACING="0" FRAME="below" RULES="groups" CELLPADDING="5"><COLGROUP><COL width="130.6930693069307"><COL width="125.24752475247526"><COL width="294.0594059405941"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><TT>EMPNO</TT></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><TT>DEPTNUM</TT></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><TT>DEPTNAME</TT></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>200330</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>E21</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SOFTWARE SUPPORT</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>200340</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>E21</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SOFTWARE SUPPORT</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>------</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>D01</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DEVELOPMENT CENTER</TT></P></TD></TR></TABLE></P><br>
<P class="docText">In this case, the last row of the result set contains the correct department code. The <TT>COALESCE</TT> function determines that the department code is stored in the <TT>DEPT.DEPTNO</TT> column and returns that value instead of the null because there is no corresponding <TT>WORKDEPT</TT> number.<A NAME="ch02index583"></A><A NAME="ch02index584"></A><A NAME="ch02index585"></A><A NAME="ch02index586"></A><A NAME="ch02index587"></A><A NAME="ch02index588"></A><A NAME="ch02index589"></A></P>
<A NAME="ch02note20"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">The <TT>VALUE</TT> function is a synonym for the <TT>COALESCE</TT> function. Favor using <TT>COALESCE</TT> though as it adheres to the ANSI standard.</P></div><br>
<A NAME="ch02lev4sec72"></A><H5 class="docSection3Title"><TT>OUTER JOIN</TT>s and Inline Views</H5>
<P class="docText">Be aware that you might need to combine inline views (also known as nested table expressions) with the <TT>COALESCE</TT> function to return the appropriate results. Consider adding a local predicate to the preceding example:<A NAME="ch02index590"></A><A NAME="ch02index591"></A><A NAME="ch02index592"></A><A NAME="ch02index593"></A><A NAME="ch02index594"></A></P>
<pre>

</pre><BR><pre>
SELECT  EMP.EMPNO,
        COALESCE(EMP.WORKDEPT, DEPT.DEPTNO) AS DEPTNUM,
        DEPT.DEPTNAME
FROM    DSN8810.EMP EMP FULL OUTER JOIN DSN8810.DEPT DEPT
ON      EMP.WORKDEPT = DEPT.DEPTNO
WHERE   EMP.WORKDEPT = 'D01';
</pre><BR>
<P class="docText">In this case, no rows are returned. The <TT>'D01'</TT> department number is aligned with the <TT>"DEVELOPMENT CENTER"</TT> in the <TT>DEPT</TT> table as <TT>DEPTNO</TT>, not in the <TT>EMP</TT> table as <TT>WORKDEPT</TT>. The solution is to use an inline view as follows:</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, DEPTNUM, DEPTNAME
FROM    (SELECT EMPNO,
                COALESCE(EMP.WORKDEPT, DEPT.DEPTNO) AS DEPTNUM,
                DEPT.DEPTNAME
         FROM   DSN8810.EMP EMP FULL OUTER JOIN DSN8810.DEPT DEPT
         ON     EMP.WORKDEPT = DEPT.DEPTNO) AS OJ_EMP_DEPT
WHERE   DEPTNUM = 'D01';
</pre><BR>
<P class="docText">This example finds the row for <TT>'D01'</TT> because <TT>COALESCE</TT> is applied to the inline view before the local predicate is applied.</P>
<A NAME="ch02lev4sec73"></A><H5 class="docSection3Title"><TT>OUTER JOIN</TT>s and Predicate Placement</H5>
<P class="docText">Prior to DB2 V6 inline views were required to achieve optimal outer join performance. This restriction no longer exists. Consider the following <TT>OUTER JOIN</TT> with a local predicate:<A NAME="ch02index595"></A><A NAME="ch02index596"></A><A NAME="ch02index597"></A><A NAME="ch02index598"></A><A NAME="ch02index599"></A><A NAME="ch02index600"></A></P>
<pre>

</pre><BR><pre>
SELECT  EMP.EMPNO, EMP.LASTNAME, DEPT.DEPTNAME
FROM    DSN8810.EMP EMP LEFT OUTER JOIN DSN8810.DEPT DEPT
ON      EMP.WORKDEPT = DEPT.DEPTNO
WHERE   EMP.SALARY &gt; 50000.00;
</pre><BR>
<P class="docText">Running under DB2 V6 or later, this query will execute quite efficiently. However, in past releases, if thousands or millions of rows were filtered out by additional predicates, this method of coding outer joins performed quite poorly because the outer join was performed first, before any rows were filtered out. To resolve this problem in V5 and earlier DB2 subsystems, ensure that the local predicate is applied before the outer join takes place, using an inline view as follows:</P>
<pre>

</pre><BR><pre>
SELECT  E.EMPNO, E.LASTNAME, DEPT.DEPTNAME
FROM    (SELECT EMPNO, LASTNAME
         FROM DSN8810.EMP
         WHERE SALARY &gt; 50000.00) AS E
        LEFT OUTER JOIN DSN8810.DEPT DEPT
        ON E.WORKDEPT = DEPT.DEPTNO;
</pre><BR>
<P class="docText">By moving the local predicate into the <TT>FROM</TT> clause as an inline view, the local predicate is evaluated before the outer join, thereby reducing the number of rows to be joined and enhancing performance.</P>
<P class="docText">If additional local predicates are required, you can specify additional inline views. If you want to return rows only for which a domestic resource has responsibility, you can change the sample query as shown:</P>
<pre>

</pre><BR><pre>
SELECT  E.EMPNO, E.LASTNAME, DEPT.DEPTNAME
FROM     (SELECT EMPNO, LASTNAME, WORKDEPT
          FROM EMP
          WHERE SALARY &gt; 50000.00) AS E
        LEFT OUTER JOIN
         (SELECT DEPTNO, DEPTNAME
          FROM DEPT
          WHERE MGRNO IS NOT NULL) AS D
        ON E.WORKDEPT = DEPT.DEPTNO;<A NAME="ch02index601"></A><A NAME="ch02index602"></A><A NAME="ch02index603"></A><A NAME="ch02index604"></A><A NAME="ch02index605"></A><A NAME="ch02index606"></A>
</pre><BR>
<A NAME="ch02note21"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">To reiterate, this tuning technique is applicable only to DB2 V4 and V5. Do not code outer joins with inline views in the manner described for DB2 V6 and later because the query will be more difficult to code, explain, and maintain.</P></div><br>
<A NAME="ch02lev4sec74"></A><H5 class="docSection3Title">Limit the Columns Grouped</H5>
<P class="docText">When you use a <TT>GROUP BY</TT> clause to achieve data aggregation, specify only the columns that need to be grouped. Do not provide extraneous columns in the <TT>SELECT</TT> list and <TT>GROUP BY</TT> list. To accomplish data grouping, DB2 must sort the retrieved data before displaying it. The more columns that need to be sorted, the more work DB2 must do, and the poorer the performance of the SQL statement.<A NAME="ch02index607"></A><A NAME="ch02index608"></A><A NAME="ch02index609"></A><A NAME="ch02index610"></A><A NAME="ch02index611"></A><A NAME="ch02index612"></A><A NAME="ch02index613"></A></P>
<A NAME="ch02lev4sec75"></A><H5 class="docSection3Title"><TT>GROUP BY</TT> and <TT>ORDER BY</TT> Are Not Equivalent</H5>
<P class="docText">Although the <TT>GROUP BY</TT> clause typically sorts data to aggregate, the results are not necessarily ordered by the <TT>GROUP BY</TT>. If you want to ensure that the results are displayed in a specific order, you must use the <TT>ORDER BY</TT> clause.<A NAME="ch02index614"></A><A NAME="ch02index615"></A><A NAME="ch02index616"></A><A NAME="ch02index617"></A><A NAME="ch02index618"></A><A NAME="ch02index619"></A><A NAME="ch02index620"></A><A NAME="ch02index621"></A></P>
<P class="docText">When you specify both <TT>GROUP BY</TT> and <TT>ORDER BY</TT>, and the ordering requirements are compatible, DB2 can avoid the redundant sort.</P>
<A NAME="ch02lev4sec76"></A><H5 class="docSection3Title"><TT>ORDER BY</TT> and Columns Selected</H5>
<P class="docText">As of DB2 V6, and via a retrofit APAR to V5, it became possible to <TT>ORDER BY</TT> columns not specified in the <TT>SELECT</TT>-list. However, you cannot eliminate columns from the <TT>SELECT</TT>-list if they are specified in an <TT>ORDER BY</TT> if you also are using a column function, <TT>UNION</TT>, <TT>UNION ALL</TT>, <TT>GROUP BY</TT>, or <TT>DISTINCT</TT>.<A NAME="ch02index622"></A><A NAME="ch02index623"></A><A NAME="ch02index624"></A><A NAME="ch02index625"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><P class="docText"> Keep in mind that as of DB2 V7, you no longer need to <TT>SELECT</TT> what you <TT>GROUP BY</TT>.</P></td></tr></table><br>
<A NAME="ch02lev4sec77"></A><H5 class="docSection3Title">Use Table Expressions to Your Advantage</H5>
<P class="docText">Table Expressions, sometimes called <span class="docEmphasis">inline views</span>, allow the <TT>FROM</TT> clause of a <TT>SELECT</TT> statement to contain another <TT>SELECT</TT> statement. You can write any table expression in the <TT>FROM</TT> clause.<A NAME="ch02index626"></A><A NAME="ch02index627"></A><A NAME="ch02index628"></A><A NAME="ch02index629"></A></P>
<P class="docText">Why would you want to use an inline view instead of simply creating an actual view prior to issuing the <TT>SELECT</TT> statement? The first potential benefit is that an inline view expression can be easier to understand. Instead of attempting to query the DB2 Catalog to extract the SQL definition of a view, the SQL is clearly displayed in the body of the <TT>SELECT</TT> statement. Second, inline views do not require object management because no DB2 object is created. Finally, inline views provide direct SQL support for certain complex queries that required a view prior to DB2 V4.</P>
<P class="docText">Inline views are useful, for example, when detail and aggregated information from a single table must be returned by a single query. A prime example is reporting on column length information from the DB2 Catalog. Consider a request to provide column details for each table, and on each row also report the maximum, minimum, and average column lengths for that table. One solution is to create a view. Consider the <TT>COL_LENGTH</TT> view based on <TT>SYSIBM.SYSCOLUMNS</TT>, as shown here:</P>
<pre>

</pre><BR><pre>
CREATE VIEW COL_LENGTH
   (TABLE_NAME, MAX_LENGTH,
    MIN_LENGTH, AVG_LENGTH)
AS SELECT   TBNAME, MAX(LENGTH),
            MIN(LENGTH), AVG(LENGTH)
   FROM     SYSIBM.SYSCOLUMNS
   GROUP BY TBNAME;
</pre><BR>
<P class="docText">After the view is created, you can issue the following <TT>SELECT</TT> statement joining the view to the base table, thereby providing both detail and aggregate information on each report row:</P>
<pre>

</pre><BR><pre>
SELECT   TBNAME, NAME, COLNO, LENGTH,
         MAX_LENGTH, MIN_LENGTH, AVG_LENGTH
FROM     SYSIBM.SYSCOLUMNS C,
         authid.COL_LENGTH V
WHERE    C.TBNAME = V.TABLE_NAME
ORDER BY 1, 3;
</pre><BR>
<P class="docText">The solution using inline views is to skip the view-creation step and simply execute the following SQL statement:</P>
<pre>

</pre><BR><pre>
SELECT TBNAME, NAME, COLNO, LENGTH,
       MAX_LENGTH, MIN_LENGTH, AVG_LENGTH
FROM   SYSIBM.SYSCOLUMNS C,
       (SELECT TBNAME AS TABLE_NAME,
               MAX(LENGTH) AS MAX_LENGTH,
               MIN(LENGTH) AS MIN_LENGTH,
               AVG(LENGTH) AS AVG_LENGTH
        FROM   SYSIBM.SYSCOLUMNS
        GROUP BY TBNAME) AS V
WHERE  C.TBNAME = V.TABLE_NAME
ORDER BY 1,3;
</pre><BR>
<P class="docText">The same result is returned in a single SQL statement, but without using a view. You must enclose inline view expressions in parentheses and must use a correlation name. You cannot refer to the correlation name for the inline view expression elsewhere in the same <TT>FROM</TT> clause, but you can use it outside the <TT>FROM</TT> clause (just like any other table or view name) as the qualifier of a column name.<A NAME="ch02index630"></A><A NAME="ch02index631"></A><A NAME="ch02index632"></A><A NAME="ch02index633"></A></P>
<A NAME="ch02lev4sec78"></A><H5 class="docSection3Title">Consider Table Expressions to Improve Performance</H5>
<P class="docText">Table expressions are frequently overlooked as a potential solution for resolving problems using only SQL.</P>
<P class="docText">One practical use for table expressions is to force the optimizer to choose a specific processing order. For example, consider the following query:<A NAME="ch02index634"></A><A NAME="ch02index635"></A><A NAME="ch02index636"></A><A NAME="ch02index637"></A><A NAME="ch02index638"></A></P>
<pre>

</pre><BR><pre>
SELECT    D.DEPTNO, MIN(D.DEPTNAME) AS DEPT_NAME, MIN(D.LOCATION) AS DEPT_LOCATION,
          SUM(E.SALARY) AS TOTAL_SALARY
FROM      DSN8810.DEPT D,
          DSN8810.EMP  E
WHERE     D.DEPTNO = E.WORKDEPT
AND       E.BONUS BETWEEN 0.00 AND 1000.00
GROUP BY  D.DEPTNO;
</pre><BR>
<P class="docText">In this query, the detail rows that qualify from each table are joined prior to the <TT>GROUP BY</TT> processing. In general, there will be more <TT>EMP</TT> rows than <TT>DEPT</TT> rows because a department comprises multiple employees. Suppose there were 200 <TT>DEPT</TT> rows joined to 75,000 <TT>EMP</TT> rows—then the <TT>GROUP BY</TT> is processed. Instead, you can use table expressions to force the optimizer to process the aggregations on a table-by-table basis:</P>
<pre>

</pre><BR><pre>
SELECT  D.DEPTNO, D.DEPTNAME, D.LOCATION, TOTAL_SALARY
FROM    DSN8810.DEPT D,
        (SELECT WORKDEPT, SUM(SALARY) AS TOTAL_SALARY
         FROM   DSN8810.EMP  E
         WHERE  E.BONUS BETWEEN 0.00 and 1000.00
         GROUP BY  E.WORKDEPT) AS E
WHERE   D.DEPTNO = E.WORKDEPT;
</pre><BR>
<P class="docText">This will produce the same results with better performance. Use table expressions to pre-filter <TT>FULL JOIN</TT> tables, to pre-filter null supplying tables of <TT>LEFT</TT>/<TT>RIGHT</TT> joins, to separate <TT>GROUP BY</TT> work, and to generate or derive data.<A NAME="ch02index639"></A><A NAME="ch02index640"></A><A NAME="ch02index641"></A><A NAME="ch02index642"></A><A NAME="ch02index643"></A></P>
<A NAME="ch02lev4sec79"></A><H5 class="docSection3Title">Consider Table Expressions Instead of Views</H5>
<P class="docText">Instead of creating views and using them in your application programs, consider using table expressions. By moving the SQL from the view into a table expression the full intent of the SQL becomes more apparent. Additionally, it is easier to debug SQL problems when the SQL is completely visible in the program.<A NAME="ch02index644"></A><A NAME="ch02index645"></A><A NAME="ch02index646"></A><A NAME="ch02index647"></A><A NAME="ch02index648"></A><A NAME="ch02index649"></A></P>
<P class="docText">When confronted with a problem in SQL that uses a view, you will have to query the DB2 Catalog to find the SQL that makes up the view. This information is in <TT>SYSIBM.SYSVIEWS</TT>. The SQL in this table can be difficult to read because it is not formatted. However, if the SQL were changed to include the view SQL too, it would be much easier to understand and debug or tune the query.</P>
<A NAME="ch02lev4sec80"></A><H5 class="docSection3Title">Consider Row Expressions</H5>

<P class="docText">SQL becomes even more flexible under DB2 V7 with row expressions. Row expressions allow SQL statements to be coded using more than one set of comparisons in a single predicate using a subquery. The net result is that multiple columns can be compared within the scope of a single SQL predicate—possibly against multiple rows on the right side of the predicate. Perhaps the best way to understand this feature is by viewing an example:<A NAME="ch02index650"></A><A NAME="ch02index651"></A><A NAME="ch02index652"></A><A NAME="ch02index653"></A><A NAME="ch02index654"></A></P>
<pre>

</pre><BR><pre>
SELECT *
FROM   SAMPLE_TABLE
WHERE  (COL1, COL2) IN (SELECT COLX, COLY
                        FROM   OTHER_TABLE);
</pre><BR>
<P class="docText">The difference between this statement and a typical SQL statement is quite obvious: Two columns are coded on the left side of the predicate, thereby enabling two columns to be selected in the <TT>SELECT</TT> statement on the right side of the predicate. Of course, a row expression need not be limited to only two columns; any number of columns can be specified, so long as the number of columns on the left matches the number of columns on the right side of the predicate.</P>
<P class="docText">Row expressions bring more flexibility and can greatly simplify certain types of SQL statements. Additionally, they can be more efficient than an equivalent SQL statement using multiple subqueries. Consider</P>
<pre>

</pre><BR><pre>
SELECT *
FROM   SAMPLE_TABLE
WHERE  COL1 IN (SELECT COLX
                FROM   OTHER_TABLE)
AND    COL2 IN (SELECT COLY
                FROM   OTHER_TABLE);
</pre><BR>
<P class="docText">Although this SQL statement is functionally equivalent to the previous SQL statement, it contains two subquery predicates and requires two scans of <TT>OTHER_TABLE</TT>. The previous SQL statement can scan <TT>OTHER_TABLE</TT> once to achieve the same results.<A NAME="ch02index655"></A><A NAME="ch02index656"></A><A NAME="ch02index657"></A><A NAME="ch02index658"></A><A NAME="ch02index659"></A></P>
<A NAME="ch02lev4sec81"></A><H5 class="docSection3Title">Use Scalar Fullselect to Your Advantage</H5>

<P class="docText">DB2 Version 8 extends the functionality of SQL to allow a scalar fullselect to be used almost anywhere an expression can be used. The term <span class="docEmphStrong">scalar fullselect</span> basically means a <TT>SELECT</TT> statement that returns a single value (or a <TT>NULL</TT>). An example will help to clarify:<A NAME="ch02index660"></A><A NAME="ch02index661"></A><A NAME="ch02index662"></A><A NAME="ch02index663"></A></P>
<pre>

</pre><BR><pre>
SELECT PROJNO, PROJNAME,
       (SELECT MIN(ACSTDATE)) FROM PROJACT),
       DEPTNO
FROM   DSN8810.PROJ;
</pre><BR>
<P class="docText">The <TT>SELECT</TT>-list of this statement contains three columns and a scalar fullselect. For this SQL to work, it is important that only one value is returned to the fullselect embedded in the <TT>SELECT</TT> statement; this is what makes it a <span class="docEmphasis">scalar</span> fullselect.</P>
<A NAME="ch02lev4sec82"></A><H5 class="docSection3Title">Consider Using Multi-Row Fetches</H5>

<P class="docText">When you need to retrieve multiple rows, consider deploying a multi-row fetch to transfer more than one row using a single <TT>FETCH</TT> statement. This capability is new as of DB2 Version 8—basically, it allows you to <TT>FETCH</TT> multiple rows at one time into an array in your program. By fetching multiple rows at once your request can become more efficient, especially for distributed requests. More information on multi-row fetching is provided in <A class="docLink" HREF="ch11.html#ch11">Chapter 11</A>, "Using DB2 in an Application Program."<A NAME="ch02index664"></A><A NAME="ch02index665"></A><A NAME="ch02index666"></A><A NAME="ch02index667"></A><A NAME="ch02index668"></A></P>
<A NAME="ch02lev4sec83"></A><H5 class="docSection3Title">Be Flexible and Adapt to Your Circumstances</H5>
<P class="docText">When coding SQL, there are no rules that <span class="docEmphStrong">always</span> apply. Adopt the basic tenet of almost never saying "always" or "never" and you will have grasped the zen of SQL coding.<A NAME="ch02index669"></A><A NAME="ch02index670"></A><A NAME="ch02index671"></A></P>
<P class="docText">Remember the cardinal rule of DBMS development that we discussed earlier—"It depends." To be successful with complex SQL, be sure to understand what can be done using SQL and have a good grasp on the fundamentals. Also, be sure to have the IBM DB2 SQL Reference manual readily available, too. With patience, willingness to experiment, and a sound understanding of your available options, you will be able to code efficient SQL statements—regardless of the complexity required.</P>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch02lev1sec2.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch02lev1sec4.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
