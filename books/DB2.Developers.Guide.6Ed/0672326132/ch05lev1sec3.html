<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Creating and Using DB2 Table Spaces</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch05lev1sec2.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch05lev1sec4.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch05lev1sec3"></A><H3 class="docSection1Title">Creating and Using DB2 Table Spaces</H3>
<P class="docText">Although DB2 data is accessed at the table level, the data itself is actually stored in a structure known as a table space. Each table space correlates to one or more individual physical VSAM linear data sets that are used to house the actual DB2 data.</P>
<P class="docText">Before any data can be physically stored in a DB2 database, a table space must first be created. If you attempt to create a table without specifying a table space, DB2 will create a default table space (unless you do not have authority to use the default database).</P>
<A NAME="ch05lev2sec2"></A><H4 class="docSection2Title">Types of Table Spaces</H4>
<P class="docText">When designing DB2 databases, DBAs can choose from four types of table spaces, each one useful in different circumstances. The four types of table spaces are:<A NAME="ch05index43"></A><A NAME="ch05index44"></A></P>
<UL><LI><P class="docList">Simple table spaces</P></LI><LI><P class="docList">Segmented table spaces</P></LI><LI><P class="docList">Partitioned table spaces</P></LI><LI><P class="docList">LOB table spaces</P></LI></UL>
<A NAME="ch05lev3sec1"></A><H5 class="docSection3Title">Simple Table Spaces</H5>
<P class="docText">Simple table spaces are found mostly in older DB2 applications. A simple table space can contain one or more tables. When multiple tables are defined to a simple table space, a single page can contain rows from all the tables defined to the table space.<A NAME="ch05index45"></A><A NAME="ch05index46"></A><A NAME="ch05index47"></A></P>
<P class="docText">Prior to DB2 V2.1, most DB2 table spaces were defined as simple table spaces because the only other option was a partitioned table space. However, most subsequent applications use segmented table spaces because of their enhanced performance and improved methods of handling multiple tables.</P>
<P class="docText">If an application must read rows from multiple tables in a predefined sequence, however, mixing the rows of these tables together in a single simple table space can prove to be beneficial. The rows should be mixed together on the page in a way that clusters the keys by which the rows will be accessed. This can be done by inserting the rows using a "round robin" approach, switching from table to table, as follows:</P>
<A NAME="ch05pr02"></A>





<div style="font-weight:bold"><OL class="docList" START="1"><LI value="1"><div style="font-weight:normal">Create a simple table space; this is accomplished by issuing the <TT>CREATE TABLESPACE</TT> statement without specifying either the <TT>SEGSIZE</TT> or <TT>NUMPARTS</TT> clause.<BR><BR></div></LI><LI value="2"><div style="font-weight:normal">Create the two tables (for example, Table1 and Table2), assigning them both to the simple table space you just created.<BR><BR></div></LI><LI value="3"><div style="font-weight:normal">Sort the input data set of values to be inserted into Table1 into key sequence order.<BR><BR></div></LI><LI value="4"><div style="font-weight:normal">Sort the input data set of values to be inserted into Table2 into sequence by the foreign key that refers to the primary key of Table1.<BR><BR></div></LI><LI value="5"><div style="font-weight:normal">Code a program that inserts a row into Table1 and then immediately inserts all corresponding foreign key rows into Table2.<BR><BR></div></LI><LI value="6"><div style="font-weight:normal">Continue this pattern until all of the primary keys have been inserted.<BR><BR></div></LI></OL></div>
<P class="docText">When the application reads the data in this predefined sequence, the data from these two tables will be clustered on the same (or a neighboring) page. Great care must be taken to ensure that the data is inserted in the proper sequence. Keep in mind that any subsequent data modification (<TT>INSERT</TT>s, <TT>UPDATE</TT>s that increase row size, and <TT>DELETE</TT>s) will cause the data to get out of sequence—and then performance will suffer. For this reason, this approach is more useful for static data than it is for dynamic, changing data.</P>
<P class="docText">Also, remember that mixing data rows from multiple tables on the same table space page adversely affects the performance of all queries, utilities, and applications that do not access the data in this manner. Be sure that the primary type of access to the data is by the predefined mixing sequence before implementing a simple table space in this manner.<A NAME="ch05index48"></A><A NAME="ch05index49"></A><A NAME="ch05index50"></A></P>
<P class="docText">Unless data-row mixing is being implemented, define no more than one table to each simple table space. Also, consider defining all your non-partitioned table spaces as segmented instead of simple.</P>
<A NAME="ch05lev3sec2"></A><H5 class="docSection3Title">Segmented Table Spaces</H5>
<P class="docText">A segmented table space is the most common type of table space for most DB2 development efforts. A segmented table space provides most of the benefits of a simple table space, except multiple tables can be defined to one segmented table space without the problems encountered when using simple table spaces. Tables are stored in separate segments. Because data rows never are mixed on the same page, concurrent access to tables in the same segmented table space is not a problem.<A NAME="ch05index51"></A><A NAME="ch05index52"></A><A NAME="ch05index53"></A></P>
<P class="docText">For the segmented table space depicted in <A class="docLink" HREF="#ch05fig01">Figure 5.1</A>, each box represents a segment. Notice how each segment is represented by a single pattern, signifying that only one table's data can be contained in the segment. Now look at the simple table space in the same figure. Each box represents a page. Notice how multiple patterns inter-mix on the same page.</P>
<A NAME="ch05fig01"></A><p><CENTER><H5 class="docFigureTitle">Figure 5.1. Simple versus segmented table spaces.</H5>
<p class="docText"><IMG BORDER="0" width="500" height="226" SRC="images/0672326132/graphics/05fig01.gif" ALT="graphics/05fig01.gif"></p></CENTER></p><br>
<P class="docText">Segmented table spaces have other benefits as well. For example,</P>
<UL><LI><P class="docList">Segmented table spaces handle free space more efficiently, which results in less overhead for inserts and for variable-length row updates.</P></LI><LI><P class="docList">Mass delete processing is more efficient because only the space map—not the data itself—is updated. A mass delete of rows from a table in a simple table space causes every row to be physically read and deleted. The following is an example of a mass delete:</P><pre>

</pre><BR><pre>
DELETE
FROM DSN8810.DEPT;
</pre><BR><P class="docList">If <TT>DSN8810.DEPT</TT> is defined in a simple table space, all of its rows are read, deleted, and logged. If it is defined in a segmented table space, however, only the space map is updated to indicate that all rows have been deleted.</P></LI><LI><P class="docList">Space can be reclaimed from dropped tables immediately. This reduces the need for reorganization.</P></LI></UL>
<P class="docText">Most of your application table spaces should be segmented. All table spaces that contain multiple tables (and do not need to mix data from multiple tables on a page) should be segmented. Even when you're defining one table for each table space, the performance advantage of the more efficient space utilization should compel you to use segmented table spaces.</P>
<P class="docText">Choose the segment size carefully. Consider each of the following when selecting the segment size:</P>
<UL><LI><P class="docList"><TT>SEGSIZE</TT> is defined as an integer representing the number of pages to be assigned to a segment. The size of a segment can be any multiple of 4, from 4 to 64, inclusive.</P></LI><LI><P class="docList">DASD space is allocated based either on the <TT>PRIQTY</TT> and <TT>SECQTY</TT> specifications for <TT>STOGROUP</TT>-defined table spaces, or on the VSAM IDCAMS definition for user-defined VSAM table spaces. However, this space can never be smaller than a full segment. The primary extent and all secondary extents are rounded to the next full segment before being allocated.</P></LI><LI><P class="docList">Space cannot be allocated at less than a full track. Consult the "<A class="docLink" HREF="#ch05lev3sec11">PRIQTY and SECQTY and <TT>SECQTY</TT></A>" section later in this chapter for additional information.</P></LI><LI><P class="docList">When defining multiple tables in a segmented table space, keep tables of like size in the same table space. Do not combine large tables with small tables in a single segmented table space. Defining small tables in a table space with a large segment size could result in wasted DASD space.</P></LI><LI><P class="docList">When a segmented table space contains multiple tables large enough to be processed using sequential prefetch, be sure to define the <TT>SEGSIZE</TT> according to the following chart. The segment size should be at least as large as the maximum number of pages that can be read by sequential prefetch. Otherwise, sequential prefetch could read pages that do not apply to the table being accessed, causing inefficient sequential prefetch processing:<A NAME="ch05index54"></A><A NAME="ch05index55"></A><A NAME="ch05index56"></A></P><P><TABLE CELLSPACING="0" FRAME="void" RULES="groups" CELLPADDING="5"><COLGROUP><COL width="302.5"><COL width="247.5"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Bufferpool Range</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Segment Size</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">1 through 500</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">16</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">501 through 999</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">32</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">1000 and over</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">64</P></TD></TR></TABLE></P><br></LI></UL>
<A NAME="ch05lev3sec3"></A><H5 class="docSection3Title">Partitioned Table Spaces</H5>
<P class="docText">A partitioned table space is divided into components called <span class="docEmphasis">partitions</span>. Each partition resides in a separate physical data set. Partitioned table spaces are designed to increase the availability of data in large tables by spreading the data across multiple physical disk devices.<A NAME="ch05index57"></A><A NAME="ch05index58"></A><A NAME="ch05index59"></A></P>
<P class="docText">Furthermore, data is assigned to a partition based on a partitioning limit key (see <A class="docLink" HREF="#ch05fig02">Figure 5.2</A>). Each partition holds data only for the valid range of keys specified for the partition.</P>
<A NAME="ch05fig02"></A><p><CENTER><H5 class="docFigureTitle">Figure 5.2. Partitioned table space.</H5>
<p class="docText"><IMG BORDER="0" width="500" height="317" SRC="images/0672326132/graphics/05fig02.gif" ALT="graphics/05fig02.gif"></p></CENTER></p><br>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> Prior to V8, the limit key was defined by a partitioning index. With DB2 V8, though, an index is not required to specify the partitioning limit key; instead, the partitioning limit key is specified in the table creation DDL.</P></td></tr></table><br>
<P class="docText">In general, your larger table spaces should be partitioned in order to better control and manage your DB2 objects and data sets. As of DB2 V8, up to 4,096 partitions can be defined for a partitioned table space. For DB2 V6 and V7, the limit is 254 partitions for a <TT>LARGE</TT> table space. For a non-<TT>LARGE</TT> table space the limit is 64 partitions.</P>
<A NAME="ch05note03"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">As of DB2 V8, it is possible to create very large databases and table spaces. With up to 4,096 partitions, the maximum size of a partitioned table space is 128 terabytes. For example, a table space with a 4K page size and 4,096 partitions having a <TT>DSSIZE</TT> of 32GB would max out at 128TB. That is a lot of data! In fact, if you use one per partition for a single day's worth of data, then 4,096 partitions will provide for more than 11 years worth of data.<A NAME="ch05index60"></A><A NAME="ch05index61"></A><A NAME="ch05index62"></A><A NAME="ch05index63"></A></P>
<P class="docText">For V6 and V7, a partitioned table space can hold up to 1TB of data (254 partitions each containing 4GB of data is approximately equal to 1TB). A <TT>LARGE</TT> partitioned table space can contain up to 16TB of data. (254 partitions, each containing 64GB of data, is approximately equal to 16TB.)</P>
<P class="docText">So, even before V8 a partitioned table space could be used to store quite a bit of data.</P></div><br>
<P class="docText">There are two types of partitioned table space: <TT>LARGE</TT> and non-<TT>LARGE</TT>. Whether or not a partitioned table space is a <TT>LARGE</TT> table space is controlled using the <TT>DSSIZE</TT> parameter. The <TT>DSSIZE</TT> parameter specifies the maximum size, in gigabytes, for each partition of the table space. DB2 V8 continues to support the <TT>LARGE</TT> parameter for compatibility, but using <TT>DSSIZE</TT> is recommended over using <TT>LARGE</TT>.<A NAME="ch05index64"></A><A NAME="ch05index65"></A><A NAME="ch05index66"></A><A NAME="ch05index67"></A><A NAME="ch05index68"></A></P>
<P class="docText">When using the <TT>DSSIZE</TT> parameter, you will explicitly specify the maximum size of each partition. The following are valid <TT>DSSIZE</TT> values:</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5"><COLGROUP><COL width="297"><COL width="253"></COLGROUP><THEAD></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>1GB</TT> (1 gigabyte)</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>2GB</TT> (2 gigabytes)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>4GB</TT> (4 gigabytes)</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>8GB</TT> (8 gigabytes)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>16GB</TT> (16 gigabytes)</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>32GB</TT> (32 gigabytes)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>64GB</TT> (64 gigabytes)</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR></TABLE></P><br>
<A NAME="ch05note04"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">To specify a value greater than <TT>4GB</TT>, you must be running DB2 with DFSMS V1.5 or greater, and the data sets for the table space must be associated with a DFSMS data class defined with extended format and extended addressability. DFSMS's extended addressability function is necessary to create data sets larger than 4GB in size. The term used by IBM to define data sets that are enabled for extended addressability is <span class="docEmphasis">EA-enabled</span>.</P></div><br>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> When the total table space size is 4TB or greater, DB2 will use a 5-byte RID instead of a 4-byte RID for record identifiers. Prior to DB2 V8, this restriction was more simply stated as whenever the <TT>DSSIZE</TT> is greater than 4GB, a 5-byte RID is used. But with the greater number of partitions supported as of DB2 V8, this restriction needs to be stated as a combination of <TT>NUMPARTS</TT>, page size, and <TT>DSSIZE</TT>. <A class="docLink" HREF="#ch05table01">Table 5.1</A> outlines the table space parameter combinations and sizes requiring 5-byte RIDs.<A NAME="ch05index69"></A><A NAME="ch05index70"></A><A NAME="ch05index71"></A><A NAME="ch05index72"></A><A NAME="ch05index73"></A><A NAME="ch05index74"></A></P></td></tr></table><br>
<A NAME="ch05table01"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 5.1. Large Table Space Combinations</h5></CAPTION><COLGROUP><COL width="115.5"><COL width="99"><COL width="121"><COL width="214.5"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><TT>NUMPARTS</TT></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Page Size</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><TT>DSSIZE</TT></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Table Space Size</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4096</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4096</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">8TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4096</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">16TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">2048</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">8GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">16TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">1024</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">16GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">16TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">512</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">32GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">16TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">256</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">64GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">16TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4096</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4096</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">8TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4096</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">16TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4096</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">8GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">32TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">2048</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">16GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">32TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">1024</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">32GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">32TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">512</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">64GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">32TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4096</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4096</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">8TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4096</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">16TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4096</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">8GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">32TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4096</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">16GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">64TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">2048</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">32GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">64TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">1024</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">64GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">64TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4096</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4096</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">8TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4096</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">16TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4096</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">8GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">32TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4096</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">16GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">64TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4096</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">32GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">128TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">2048</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">64GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">128TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4096</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>LARGE</TT> (4GB)</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">16TB<A NAME="ch05index75"></A><A NAME="ch05index76"></A><A NAME="ch05index77"></A></P></TD></TR></TABLE></P><br>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> As mentioned earlier, DB2 V8 partitioning is no longer dependent on indexing. For all previous releases, a partitioned table space required a partitioning index. It was the index that set up the specific limit keys that determined which data rows were placed in which partition. With DB2 V8, it is possible to specify the limit keys in the table DDL.<A NAME="ch05index78"></A><A NAME="ch05index79"></A><A NAME="ch05index80"></A></P></td></tr></table><br>
<P class="docText">Keep the following terminology in mind:</P>
<UL><LI><p class="docText">
<span class="docEmphBoldItalic">Partitioned Table Space</span>— 
Any table space with multiple physical partitions.</p></LI><LI><p class="docText">
<span class="docEmphBoldItalic">Partitioned Index</span>— 
Any index with multiple physical partitions.<A NAME="ch05index81"></A><A NAME="ch05index82"></A></p></LI><LI><p class="docText">
<span class="docEmphBoldItalic">Partitioning Index</span>— 
Any index where the left-most columns match the partitioning limit key of the table space; the index might or might not be partitioned itself.<A NAME="ch05index83"></A><A NAME="ch05index84"></A></p></LI></UL>
<P class="docText">Furthermore, as of V8, the data in a partitioned table space need not be clustered by the partitioning limit key. So, it is now possible to create a partitioned table space without any indexes (but it is still not generally advisable to do so).<A NAME="ch05index85"></A><A NAME="ch05index86"></A><A NAME="ch05index87"></A></P>
<P class="docText">Another V8 partitioned table space improvement is the ability to modify partitions. With the online schema change capabilities of DB2 V8, you can add, remove, and rotate partitions easily using the facilities of DB2. Prior to V8, such changes required dropping and re-creating the table space—a difficult proposition for many large partitioned table spaces. For more information on the schema change capabilities of DB2 Version 8, refer to <A class="docLink" HREF="ch07.html#ch07">Chapter 7</A>, "Database Change Management and Schema Evolution."<A NAME="ch05index88"></A><A NAME="ch05index89"></A><A NAME="ch05index90"></A></P>
<A NAME="ch05lev4sec4"></A><H5 class="docSection4Title">Partitioning, Size, and Data Distribution</H5>
<P class="docText">Deciding to use a partitioned table space is not as simple as merely determining the size of the table. In the early days of DB2 (that is, pre-V4), size typically was the primary consideration for choosing a partitioned table space. However, as DB2 has matured and the applications written using DB2 have become modernized, additional considerations impact your partitioning decisions. Application-level details, such as data contention, performance requirements, degree of parallelism, and data access patterns, must factor into the decision to use partitioned table spaces.<A NAME="ch05index91"></A><A NAME="ch05index92"></A><A NAME="ch05index93"></A></P>
<P class="docText">A commonly held belief among DB2 DBAs is that partitioned table spaces should be defined with evenly distributed data across partitions. However, maintaining evenly distributed partitions might not be desirable when partitions are used to isolate data "hot spots." Indeed, it is better to design table space partitions with the needs of the application in mind. Therefore, the best approach is to define table space partitions based on the access requirements of the applications accessing the data. Keep in mind that parallel processing can benefit from properly partitioned table spaces placed on separate volumes.<A NAME="ch05index94"></A><A NAME="ch05index95"></A><A NAME="ch05index96"></A><A NAME="ch05index97"></A></P>
<A NAME="ch05lev4sec5"></A><H5 class="docSection4Title">Partitioning Versus Multiple Tables</H5>
<P class="docText">Sometimes designers try to avoid partitioned table spaces by dividing a table into multiple tables, each with its own table space. Unless you have specific reasons for doing so, this approach is not wise. When proceeding in this manner, the designer usually places separate tables into each of the smaller table spaces. This can be problematic because it introduces an uncontrolled and unneeded denormalization. (See the "<A class="docLink" HREF="ch05lev1sec6.html#ch05lev2sec14">Denormalization</A>" section later in this chapter for more information.)<A NAME="ch05index98"></A><A NAME="ch05index99"></A><A NAME="ch05index100"></A></P>
<P class="docText">Furthermore, when data that logically belongs in one table is separated into multiple tables, SQL operations to access the data as a logical whole are made needlessly complex. One example of this complexity is the difficulty in enforcing unique keys across multiple tables. Although partitioned table spaces can introduce additional complexities into your environment, these complexities rarely outweigh those introduced by mimicking partitioning with several smaller, identical table spaces. To clarify why this idea is usually not a good approach, consider these two different ways of implementing a three-"partition" solution:</P>
<P class="docText">The first, generally recommended way is to create the table in a single partitioned table space with three partitions. For example:<A NAME="ch05index101"></A><A NAME="ch05index102"></A><A NAME="ch05index103"></A></P>
<pre>

</pre><BR><pre>
CREATE DATABASE DB_SAMP;

CREATE TABLESPACE TS_SAMPP
       IN DB_SAMP
       ERASE NO NUMPARTS 3
       (PART 1
        USING STOGROUP SG_SAMP1
        PRIQTY 2000 SECQTY 50
        COMPRESS NO,

        PART 2
        USING STOGROUP SG_SAMP2
        PRIQTY 4000 SECQTY 150
        COMPRESS YES,

        PART 3
        USING STOGROUP SG_SAMP3
        PRIQTY 1000 SECQTY 50
        COMPRESS YES)

       LOCKSIZE PAGE   BUFFERPOOL BP1   CLOSE NO;

CREATE TABLE TB_SAMP . . . IN DB_SAMP.TS_SAMPP;
</pre><BR>
<P class="docText">The second, alternative approach is to create three table spaces, each with its own table, as follows:</P>
<pre>

</pre><BR><pre>
CREATE DATABASE DB_SAMP2;

CREATE TABLESPACE TS_SAMP1 IN DB_SAMP2
       USING STOGROUP SG_SAMP1
       PRIQTY 2000   SECQTY 50
       ERASE NO COMPRESS NO
       LOCKSIZE PAGE   BUFFERPOOL BP1  CLOSE NO;

CREATE TABLESPACE TS_SAMP2 IN DB_SAMP2
       USING STOGROUP SG_SAMP2
       PRIQTY 4000   SECQTY 150
       ERASE NO COMPRESS YES
       LOCKSIZE PAGE   BUFFERPOOL BP1  CLOSE NO;

CREATE TABLESPACE TS_SAMP3 IN DB_SAMP2
       USING STOGROUP SG_SAMP3
       PRIQTY 1000   SECQTY 50
       ERASE NO COMPRESS YES
       LOCKSIZE PAGE   BUFFERPOOL BP1  CLOSE NO;

CREATE TABLE TB_SAMP1 . . . IN DB_SAMP2.TS_SAMP1;
CREATE TABLE TB_SAMP2 . . . IN DB_SAMP2.TS_SAMP2;
CREATE TABLE TB_SAMP3 . . . IN DB_SAMP2.TS_SAMP3;<A NAME="ch05index104"></A><A NAME="ch05index105"></A><A NAME="ch05index106"></A><A NAME="ch05index107"></A><A NAME="ch05index108"></A><A NAME="ch05index109"></A>
</pre><BR>
<P class="docText">Now consider how difficult it would be to retrieve data in the second implementation if you did not know which "partition" (table) the data resides in, or if the data could reside in multiple partitions. Using the first example, a simple <TT>SELECT</TT> will work:</P>
<pre>

</pre><BR><pre>
SELECT  *
FROM    TB_SAMP
WHERE   COL1 = :HOST-VARIABLE;
</pre><BR>
<P class="docText">In the second example, a <TT>UNION</TT> is required:</P>
<pre>

</pre><BR><pre>
SELECT  *
FROM    TB_SAMP1
WHERE   COL1 = :HOST-VARIABLE
UNION ALL
SELECT  *
FROM    TB_SAMP2
WHERE   COL1 = :HOST-VARIABLE
UNION ALL
SELECT  *
FROM    TB_SAMP3
WHERE   COL1 = :HOST-VARIABLE;<A NAME="ch05index110"></A><A NAME="ch05index111"></A><A NAME="ch05index112"></A>
</pre><BR>
<P class="docText">If other tables need to be joined, the "solution" becomes even more complex. Likewise, if data must be updated, inserted, or deleted and you do not know which "partition" contains the affected data, it is difficult to code an efficient method to change the data.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><P class="docText"> As of DB2 V7, it is possible to implement <TT>UNION</TT> in views, so the multi-table approach becomes a little easier. A view could be created so that all users and programs could access the view as if it were a table. The view would look something like this:<A NAME="ch05index113"></A><A NAME="ch05index114"></A><A NAME="ch05index115"></A></P></td></tr></table><br>
<pre>

</pre><BR><pre>
CREATE VIEW ALL_DATA
AS SELECT * FROM TB_SAMP1
   UNION ALL
   SELECT * FROM TB_SAMP2
   UNION ALL
   SELECT * FROM TB_SAMP3;
</pre><BR>
<A NAME="ch05note05"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Of course, the <TT>SELECT</TT> statements in the view should not use <TT>SELECT *</TT> but instead should list out all of the columns in the table. The example used the shorthand notation for simplicity.</P></div><br>
<P class="docText">Data integrity and modification poses an additional problem. Every <TT>UPDATE</TT> will need to "know" which table contains which ranges of values. Without this knowledge, valid data may be entered into the wrong table.</P>
<P class="docText">The bottom line is that you should avoid bypassing DB2 partitioning using your own pseudo-partitions unless the table is inordinately large and you are not running DB2 V7 or earlier. Using the multi-table approach can be viable for very, very large tables to get around non-partitioning index problems prior to V8.<A NAME="ch05index116"></A><A NAME="ch05index117"></A><A NAME="ch05index118"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> Prior to V8 only the partitioning index is partitioned like the underlying data.<sup class="docFootnote"><A class="docLink" HREF="#ch05fn01">[*]</A></sup> Every other index will be a single, non-partitioned index (NPI), also known as a non-partitioned secondary index (NPSI). With DB2 V8 you can create data partitioned secondary indexes to alleviate NPI problems. NPSIs are unwieldy and difficult to manage, administer, backup, recover, and reorganize. These administration issues are somewhat alleviated by the multi-table approach—but keep in mind, additional administration issues are created. Such as:<A NAME="ch05index119"></A><A NAME="ch05index120"></A><A NAME="ch05index121"></A></P><blockquote><p class="docFootnote"><sup><A NAME="ch05fn01">[*]</A></sup> <span class="docEmphasis">As of DB2 V8 a partitioned index can have a superset of the partitioning key columns. For example, a table space partitioned on columns <TT>C1</TT> and <TT>C2</TT> can have a partitioned index on columns <TT>C1</TT>, <TT>C2</TT>, and <TT>C3</TT></span>.</p></blockquote></td></tr></table><br>
<UL><LI><P class="docList">Assuring data integrity (as discussed above), including avoiding duplicate keys, ensuring key ranges are put in the proper table, and so on, is extremely difficult.</P></LI><LI><P class="docList">Managing multiple indexes can be an administrative burden. Multiple indexes are required because each table will generally have to have the same indexes placed on them. That is, if you index on <TT>ACCT_TYPE</TT>, you will need to build that index on each of the individual tables; with partitioning, it is built once on the partitioned table.</P></LI><LI><P class="docList">Creating and maintaining additional backup and recovery jobs for each of the table spaces is required when using the multi-table approach. Of course, you may have a similar number of backup jobs under the partitioned approach if you <TT>COPY</TT> by partition.<A NAME="ch05index122"></A><A NAME="ch05index123"></A><A NAME="ch05index124"></A></P></LI></UL>
<A NAME="ch05lev4sec6"></A><H5 class="docSection4Title">Partitioning Pros and Cons</H5>
<P class="docText">Before deciding to partition a table space, weigh the pros and cons. Consult the following list of advantages and disadvantages before implementation:</P>
<P class="docText">Advantages of a partitioned table space are the following:<A NAME="ch05index125"></A><A NAME="ch05index126"></A></P>
<UL><LI><P class="docList">Each partition can be placed on a different DASD volume to increase access efficiency.</P></LI><LI><P class="docList">Partitioned table spaces can be used to store large amounts of data. They are the only type of table space that can hold more than 64GB of data (the maximum size of simple and segmented table spaces).</P></LI><LI><P class="docList"><TT>START</TT> and <TT>STOP</TT> commands can be issued at the partition level. By stopping only specific partitions, the remaining partitions are available to be accessed thereby promoting higher availability.</P></LI><LI><P class="docList">Free space (<TT>PCTFREE</TT> and <TT>FREEPAGE</TT>) can be specified at the partition level enabling the DBA to isolate data "hot spots" to a specific partition and tune accordingly.</P></LI><LI><P class="docList">Query I/O, CPU, and Sysplex parallelism enable multiple engines to access different partitions in parallel, usually resulting in reduced elapsed time. DB2 can access non-partitioned table spaces in parallel, too, but partitioning can optimize parallelism by removing disk contention.</P></LI><LI><P class="docList">Table space scans on partitioned table spaces can skip partitions that are excluded based on the query predicates. Skipping entire partitions can improve overall query performance for table space scans.</P></LI><LI><P class="docList">By mixing clustering and partitioning you can design to decrease data contention. For example, if the table space will be partitioned by <TT>DEPTNO</TT>, each department (or range of compatible departments) could be placed in separate partitions. Each department is in a discrete physical data set, thereby reducing inter-departmental contention due to multiple departments coexisting on the same data page.<A NAME="ch05index127"></A><A NAME="ch05index128"></A></P><p class="docText"><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docList"> As of DB2 V8 you can further reduce contention by creating data partitioned secondary indexes (DPSIs). Prior to V8, some contention will remain for data in non-partitioned indexes. Defining an NPSI on a table in a partitioned table space causes you to lose some of the benefits of partition-level independence for utility operations because access to an NPSI is sequential.</P></td></tr></table></p></LI><LI><P class="docList">DB2 creates a separate compression dictionary for each table space partition. Multiple dictionaries tend to cause better overall compression ratios. In addition, it is more likely that the partition-level compression dictionaries can be rebuilt more frequently than non-partitioned dictionaries. Frequent rebuilding of the compression dictionary can lead to a better overall compression ratio.</P></LI><LI><P class="docList">The <TT>REORG</TT>, <TT>COPY</TT>, and <TT>RECOVER</TT> utilities can execute on table spaces at the partition level. If these utilities are set to execute on partitions instead of on the entire table space, valuable time can be saved by processing only the partitions that need to be reorganized, copied, or recovered. Partition independence and resource serialization further increase the availability of partitions during utility processing.<A NAME="ch05index129"></A><A NAME="ch05index130"></A></P></LI></UL>
<P class="docText">Disadvantages of a partitioned table space are as follows:</P>
<UL><LI><P class="docList">Only one table can be defined in a partitioned table space. This is not really a disadvantage, merely a limitation.<A NAME="ch05index131"></A><A NAME="ch05index132"></A></P></LI><LI><P class="docList">Prior to DB2 V8, updating the partitioning columns can be problematic. Although it is possible to <TT>UPDATE</TT> the columns of the partitioning index, it is not very efficient. First, the <TT>PARTKEYU</TT> DSNZPARM parameter must be set to enable portioning key modification. If this parameter is set to <TT>NO</TT>, then updates are not permitted. If updates are allowed, the actual <TT>UPDATE</TT> will in all likelihood run quite slowly. If the <TT>PARTKEYU</TT> previous ZPARM is not set, you must delete the row and then reinsert it with the new values in order change a value in a column of a partitioning index key. (As of V8, a partitioning index is no longer required.)</P></LI><LI><P class="docList">The range of key values for which data will be inserted into the table should be known and stable before you create the partitioning index. To define a partition, a range of values must be hard coded either into the partitioning index definition or the table definition. These ranges should distribute the data throughout the partitions according to the access needs of the applications using the data. If you provide a stop-gap partition to catch all the values lower (or higher) than the defined range, monitor that partition to ensure that it does not grow dramatically or cause performance problems if it is smaller or larger than most other partitions.<A NAME="ch05index133"></A><A NAME="ch05index134"></A></P></LI></UL>
<A NAME="ch05note06"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">For table spaces created with a large <TT>DSSIZE</TT> (or with the <TT>LARGE</TT> parameter), the values specified after the <TT>VALUES</TT> clause are strictly enforced. The highest value specified is the highest value that can be placed in the table. Any values greater than the value specified for the last partition are out of range and cannot be inserted.</P></div><br>
<A NAME="ch05note07"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">As of DB2 V6, you can change partition key ranges using <TT>ALTER INDEX</TT> without having to drop and redefine the partitioned table space and index. This capability greatly increases data availability when partition key ranges need to be changed.<A NAME="ch05index135"></A><A NAME="ch05index136"></A><A NAME="ch05index137"></A><A NAME="ch05index138"></A></P>
<P class="docText">Of course, as of DB2 V8, partitioning becomes more flexible and modifying partitioning details becomes much easier with online schema changes.</P></div><br>
<A NAME="ch05lev4sec7"></A><H5 class="docSection4Title">Updating Partitioning Keys</H5>
<P class="docText">Your organization must decide whether or not to allow updates to partitioning keys. This is controlled using the <TT>PARTKEYU</TT> DSNZPARM (which is set on the <TT>DSNTIP4</TT> installation panel).<A NAME="ch05index139"></A><A NAME="ch05index140"></A><A NAME="ch05index141"></A><A NAME="ch05index142"></A><A NAME="ch05index143"></A><A NAME="ch05index144"></A><A NAME="ch05index145"></A></P>
<P class="docText">There are three valid settings for <TT>PARTKEYU</TT>:</P>
<UL><LI><p class="docText">
<TT>YES</TT>— 
The partitioning key columns may be updated. This is the default.</p></LI><LI><p class="docText">
<TT>NO</TT>— 
The partitioning key columns are not permitted to be updated.</p></LI><LI><p class="docText">
<TT>SAME</TT>— 
The partitioning key columns can be updated but only if the <TT>UPDATE</TT> results in the row staying in its current partition.</p></LI></UL>
<A NAME="ch05lev4sec8"></A><H5 class="docSection4Title">Partitioning and Data Set Sizes</H5>
<P class="docText">For partitioned table spaces not specified as <TT>LARGE</TT> (or without the <TT>DSSIZE</TT> parameter), the number of partitions affects the maximum size of the data set partition as follows:<A NAME="ch05index146"></A><A NAME="ch05index147"></A><A NAME="ch05index148"></A><A NAME="ch05index149"></A></P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="groups" CELLPADDING="5"><COLGROUP><COL width="225.5"><COL width="324.5"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Number of Partitions</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Maximum Data Set Size</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">1 to 16</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4GB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">17 to 32</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2GB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">33 to 64</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1GB</P></TD></TR></TABLE></P><br>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><P class="docText"> Prior to V7, table spaces that are defined with the <TT>LARGE</TT> parameter can have a maximum data set size of 4GB for 1 to 256 partitions.</P></td></tr></table><br>
<P class="docText">For V7, table spaces that are defined with a <TT>DSSIZE</TT> of 4GB or greater can have a maximum data set size of 64GB; partitions can range from 1 to 256.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> For V8, table spaces that are defined with a <TT>DSSIZE</TT> of 4GB or greater can have a maximum data set size of 64GB; partitions can range from 1 to 4,096.</P></td></tr></table><br>
<P class="docText">The preceding discussion of table space size is somewhat unclear, so let's clarify it. The maximum number of partitions a table space can have is dependent on the <TT>DSSIZE</TT>, the page size, and the total tablespace size. Page size affects table size because it affects the number of partitions allowed. <A class="docLink" HREF="#ch05table02">Table 5.2</A> consolidates this information accurately as of DB2 V8.</P>
<A NAME="ch05table02"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 5.2. Table Space Size</h5></CAPTION><COLGROUP><COL width="93.5"><COL width="104.5"><COL width="121"><COL width="231"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Max Part</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Page Size</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><TT>DSSIZE</TT></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Max TS Size</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4096</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">16TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">256</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">64GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">16TB<A NAME="ch05index150"></A><A NAME="ch05index151"></A><A NAME="ch05index152"></A><A NAME="ch05index153"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch05note08"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Use caution when creating very large table spaces with LOBs. You can only specify up to 5 LOBs per table if 4096 partitions are to be supported. This is so because one LOB table space is required for each LOB per partition. So one LOB on a table with 4,096 partitions would require 12,288 objects. The maximum number of objects per DB2 database is 65,535, hence the 5 LOB limit.<A NAME="ch05index154"></A><A NAME="ch05index155"></A><A NAME="ch05index156"></A></P></div><br>
<A NAME="ch05lev4sec9"></A><H5 class="docSection4Title">Table-Controlled Partitioning</H5>

<P class="docText">Consider favoring table-controlled partitioning over index-controlled partitioning. This option is available as of DB2 V8. By specifying the partitioning limit keys in the table DDL, DB2 will not have to rely on a partitioning index to keep the correct data in the proper partition.<A NAME="ch05index157"></A><A NAME="ch05index158"></A><A NAME="ch05index159"></A></P>
<P class="docText">The ability to <TT>ALTER</TT> a table-controlled partitioned scheme is made much simpler with the advent of online schema evolution. Online schema evolution is addressed in detail in <A class="docLink" HREF="ch07.html#ch07">Chapter 7</A>.</P>
<P class="docText">In order to determine whether a given partitioned table space is index-controlled or table-controlled you will have to query the DB2 Catalog. The <TT>PARTKEYCOLUMN</TT> in <TT>SYSIBM.SYSTABLES</TT> will be set to zero if it is index-controlled, or to a particular value if it is table-controlled.</P>
<P class="docText">Index-controlled partitioning will be converted to table-controlled partitioning whenever a new DB2 V8 table-controlled partitioning feature is exploited. This includes</P>
<UL><LI><P class="docList">Creating a data partitioned secondary index (DPSI)</P></LI><LI><P class="docList">Creating a partitioning index without the <TT>CLUSTER</TT> keyword or altering the existing partitioning index to specify <TT>CLUSTER NO</TT></P></LI><LI><P class="docList">Dropping the partitioning index on an index-controlled partitioning table space</P></LI><LI><P class="docList">Altering the table in a partitioned table space to add a partition, rotate a partition, or modify a partition parameter<A NAME="ch05index160"></A><A NAME="ch05index161"></A><A NAME="ch05index162"></A></P></LI></UL>
<A NAME="ch05lev3sec4"></A><H5 class="docSection3Title">LOB Table Spaces</H5>
<P class="docText">LOB table spaces are to be used only in conjunction with LOB columns. One LOB table space is required per LOB column in a table. If the table space containing the LOB column is partitioned, one LOB table space per partition per column is required. The LOB table space is used to store the large object data.<A NAME="ch05index163"></A><A NAME="ch05index164"></A></P>
<P class="docText">Comprehensive coverage of LOB table spaces is provided in <A class="docLink" HREF="ch09.html#ch09">Chapter 9</A>, "Large Objects and Object/Relational Databases."</P>
<A NAME="ch05lev2sec3"></A><H4 class="docSection2Title">Table Space Parameters</H4>
<P class="docText">Many parameters must be considered when creating a table space. Each of these parameters is discussed in this section.<A NAME="ch05index165"></A><A NAME="ch05index166"></A></P>
<A NAME="ch05lev3sec5"></A><H5 class="docSection3Title"><TT>LARGE</TT></H5>
<P class="docText">The <TT>LARGE</TT> parameter is available for partitioned table spaces only. When <TT>LARGE</TT> is specified more than 64GB of data can be stored in the table space. A large table space can have up to 254 partitions, each containing up to 4GB; if EA-enabled, each containing up to 64GB. Refer to <A class="docLink" HREF="#ch05table03">Table 5.3</A> for definitions of storage abbreviations such as GB and TB.<A NAME="ch05index167"></A><A NAME="ch05index168"></A><A NAME="ch05index169"></A><A NAME="ch05index170"></A></P>
<A NAME="ch05table03"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 5.3. Storage Abbreviations</h5></CAPTION><COLGROUP><COL width="126.5"><COL width="99"><COL width="324.5"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Abbreviation</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Term</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Amount</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Kilobyte</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1,024 bytes</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">GB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Gigabyte</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1,024 KB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">TB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Terabyte</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1,024 GB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">PB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Petabyte</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1,024 TB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">EB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Exabyte</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1,024 PB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">ZB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Zettabyte</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1,024 EB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">YB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Yottabyte</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1,024 ZB</P></TD></TR></TABLE></P><br>
<P class="docText">When <TT>LARGE</TT> (or <TT>DSSIZE</TT>) is not specified, the maximum storage amount is limited to 64GB; the maximum number of partitions to 64.<A NAME="ch05index171"></A><A NAME="ch05index172"></A><A NAME="ch05index173"></A><A NAME="ch05index174"></A></P>
<A NAME="ch05note09"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">If the <TT>NUMPARTS</TT> parameter is defined to be greater than 64, the table space will automatically be defined as a large table space even if the <TT>LARGE</TT> parameter is omitted.</P></div><br>
<A NAME="ch05lev3sec6"></A><H5 class="docSection3Title">Create <TT>LARGE</TT> Table Spaces Sparingly</H5>
<P class="docText">Although it may be tempting to define every table space as <TT>LARGE</TT>, space considerations and resource requirements need to be taken into account. RIDs in a large table space are 5 bytes instead of 4 bytes. As such, index space usage will increase. Additionally, large table spaces can use more data sets and increase resource consumption of utility processing. Therefore, a large table space should be used only under the following conditions:<A NAME="ch05index175"></A><A NAME="ch05index176"></A><A NAME="ch05index177"></A><A NAME="ch05index178"></A></P>
<UL><LI><P class="docList">When more than 16 partitions are required and more than 1GB must be stored per partition; or</P></LI><LI><P class="docList">More than 64 partitions are required; or</P></LI><LI><P class="docList">More than 64GB of data must be stored in a single table space</P></LI></UL>
<A NAME="ch05note10"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Use the <TT>DSSIZE</TT> clause instead of <TT>LARGE</TT> to specify a maximum partition size of 4GB and larger. The <TT>LARGE</TT> clause is retained for compatibility with releases of DB2 prior to Version 6.</P></div><br>
<A NAME="ch05lev3sec7"></A><H5 class="docSection3Title"><TT>DSSIZE</TT></H5>
<P class="docText">The <TT>DSSIZE</TT> parameter is used to specify the maximum size for each partition or, for LOB table spaces, each data set. If you specify <TT>DSSIZE</TT>, you must also specify <TT>NUMPARTS</TT> or <TT>LOB</TT>. Remember that to specify a value greater than 4GB, the table space must be EA-enabled.<A NAME="ch05index179"></A><A NAME="ch05index180"></A><A NAME="ch05index181"></A><A NAME="ch05index182"></A></P>
<P class="docText">One way of determining whether a data set is EA-enabled is to view it using ISPF option 3.4. The <TT>DSORG</TT> column will show VS-E for a VSAM EA-enabled data set.</P>
<P class="docText">The same cautions regarding the use of <TT>LARGE</TT> should be adhered to regarding specifying a <TT>DSSIZE</TT> greater than 4GB.</P>
<A NAME="ch05lev3sec8"></A><H5 class="docSection3Title"><TT>LOCKSIZE</TT></H5>
<P class="docText">The <TT>LOCKSIZE</TT> parameter indicates the type of locking DB2 performs for the given table space. The choices are<A NAME="ch05index183"></A><A NAME="ch05index184"></A><A NAME="ch05index185"></A><A NAME="ch05index186"></A><A NAME="ch05index187"></A></P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5"><COLGROUP><COL width="170.5"><COL width="379.5"></COLGROUP><THEAD></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>ROW</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Row-level locking</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PAGE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Page-level locking</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>TABLE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Table-level locking (for segmented table spaces only)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>TABLESPACE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Table space-level locking</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>LOB</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">LOB locking; valid only for LOB table spaces</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>ANY</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Lets DB2 decide, starting with <TT>PAGE</TT></P></TD></TR></TABLE></P><br>
<P class="docText">In general, it is fine to let DB2 handle the level of locking required. DB2 will usually use <TT>LOCKSIZE PAGE</TT> and <TT>LOCKMAX SYSTEM</TT> unless it is a LOB table space, in which case DB2 will usually choose <TT>LOCKSIZE LOB</TT> and <TT>LOCKMAX SYSTEM</TT>. When the number of locks acquired for the table space exceeds the maximum number of locks allowed for a table space, locking escalates to the next higher level. If the table space is segmented, the next higher level is the table. If the table space is nonsegmented, the next higher level is the table space. Any page or LOB locks held are not released when lock escalation occurs.</P>
<P class="docText">A good general locking strategy would be to implement <TT>LOCKSIZE ANY</TT>, except in the following circumstances:</P>
<UL><LI><P class="docList">A read-only table defined in a single table space should be specified as <TT>LOCKSIZE TABLESPACE</TT>. There rarely is a reason to update the table, so page locks should be avoided.</P></LI><LI><P class="docList">A table that does not require shared access should be placed in a single table space specified as <TT>LOCKSIZE TABLESPACE</TT>. Shared access refers to multiple users (or jobs) accessing the table simultaneously.</P></LI><LI><P class="docList">A grouping of tables in a segmented table space used by a single user (for example, a QMF user) should be specified as <TT>LOCKSIZE TABLE</TT>. If only one user can access the tables, there is no reason to take page-level locks.</P></LI><LI><P class="docList">Specify <TT>LOCKSIZE PAGE</TT> for production systems that cannot tolerate a lock escalation, but for which row locking would be overkill. When many accesses are made consistently to the same data, you must maximize concurrency. If lock escalation can occur (that is, a change from page locks to table space locks), concurrency is eliminated. If a particular production system always must support concurrent access, use <TT>LOCKSIZE PAGE</TT> and set the <TT>LOCKMAX</TT> parameter for the table space to <TT>0</TT>.</P></LI><LI><P class="docList">For LOB table spaces, always specify <TT>LOCKSIZE LOB</TT>.</P></LI><LI><P class="docList">Consider specifying <TT>LOCKSIZE ROW</TT> only when concurrency is of paramount importance. When multiple updates must occur to the same page at absolutely the same time, <TT>LOCKSIZE ROW</TT> might prove to be beneficial. But row locking can cause performance problems, because a row lock requires about the same amount of resources as a page lock. And, because there are usually multiple rows on a page, row locking will typically consume more resources. Do not implement <TT>LOCKSIZE ROW</TT>, though, unless you are experiencing a locking problem with page locking. Often, at design time, developers believe multiple transactions will be updating the same page simultaneously, but it is not very commonplace in practice. An alternative to <TT>LOCKSIZE ROW</TT> is <TT>LOCKSIZE PAGE</TT> with <TT>MAXROWS 1</TT>, which will achieve the same purpose by forcing one row per page.</P></LI></UL>
<P class="docText">Consider using <TT>LOCKSIZE ANY</TT> in situations other than those just outlined because it allows DB2 to determine the optimal locking strategy based on actual access patterns. Locking begins with <TT>PAGE</TT> locks and escalates to <TT>TABLE</TT> or <TT>TABLESPACE</TT> locks when too many page locks are being held. The <TT>LOCKMAX</TT> parameter controls the number of locks that can be taken before escalation occurs. <TT>LOCKSIZE ANY</TT> generally provides an efficient locking pattern because it allows the DBMS to actively monitor and manage the locking strategy.<A NAME="ch05index188"></A><A NAME="ch05index189"></A><A NAME="ch05index190"></A><A NAME="ch05index191"></A><A NAME="ch05index192"></A></P>
<A NAME="ch05lev4sec10"></A><H5 class="docSection4Title">Use <TT>LOCKSIZE ROW</TT> with Caution</H5>
<P class="docText">The resources required to acquire, maintain, and release a lock at the row level are about the same as required for locking at the page level lock. When row locking is used and a table or table space scan is required, DB2 will lock every row on every page accessed. The number of locks required to successfully accomplish a scan can have a detrimental impact on performance. If a table has 100 rows per page, a table space scan could possibly require nearly 100 times as many resources for row locks as it would for page locks.<A NAME="ch05index193"></A><A NAME="ch05index194"></A><A NAME="ch05index195"></A><A NAME="ch05index196"></A><A NAME="ch05index197"></A><A NAME="ch05index198"></A></P>
<A NAME="ch05lev4sec11"></A><H5 class="docSection4Title">Switch Locking Strategies Based on Processing</H5>
<P class="docText">Some tables have different access patterns based upon the time of day. For example, many applications are predominantly OLTP during work hours and predominantly batch during off hours. OLTP is usually characterized by short, indexed access to tables. Batch processing typically requires more intensive data access and table scans.<A NAME="ch05index199"></A><A NAME="ch05index200"></A><A NAME="ch05index201"></A><A NAME="ch05index202"></A><A NAME="ch05index203"></A></P>
<P class="docText">To take advantage of these situations, use the <TT>ALTER TABLESPACE</TT> statement to change the <TT>LOCKSIZE</TT> parameter to <TT>ROW</TT> for daylight processing. Before the nightly batch jobs and after online processing diminishes, alter the <TT>LOCKSIZE</TT> parameter back to <TT>ANY</TT> or <TT>PAGE</TT>.</P>
<P class="docText">By changing the locking strategy to conform to the type of processing, contention can be reduced thereby enhancing application performance.</P>
<P class="docText">Of course, in order to change each program's locking strategy you will need to rebind your static plans and packages after altering <TT>LOCKSIZE</TT>. For this approach to be successful you should consider assigning different plans and packages to online and batch, if you do not already do so.</P>
<A NAME="ch05lev3sec9"></A><H5 class="docSection3Title"><TT>LOCKMAX</TT></H5>
<P class="docText">The <TT>LOCKMAX</TT> parameter specifies the maximum number of page or row locks that any one process can hold at any one time for the table space. When the threshold is reached, the page or row locks are escalated to a table or table space lock.<A NAME="ch05index204"></A><A NAME="ch05index205"></A><A NAME="ch05index206"></A><A NAME="ch05index207"></A><A NAME="ch05index208"></A></P>
<P class="docText">Three options are available for setting the <TT>LOCKMAX</TT> parameter:</P>
<UL><LI><P class="docList">The literal <TT>SYSTEM</TT> can be specified, indicating that <TT>LOCKMAX</TT> should default to the systemwide value as specified in <TT>DSNZPARM</TT>s.</P></LI><LI><P class="docList">The value <TT>0</TT> can be specified, indicating that lock escalation should never occur for this table space.</P></LI><LI><P class="docList">An integer value ranging from <TT>1</TT> to <TT>2,147,483,647</TT> can be specified, indicating the actual number of row or page locks to tolerate before lock escalation.</P></LI></UL>
<A NAME="ch05lev4sec12"></A><H5 class="docSection4Title">Use Caution Before Disabling Lock Escalation</H5>
<P class="docText">Specify <TT>LOCKMAX 0</TT> only when you are absolutely sure of the impact it will have on your processing mix. A very high value for <TT>LOCKMAX</TT> can have a similar effect to <TT>LOCKMAX 0</TT>, with the added benefit of an escape if the number of locks becomes intolerable. Large batch jobs running against a table space specified as <TT>LOCKMAX 0</TT> can severely constrain concurrent access if a large number of locks are held without an intelligent commit strategy. When volumes fluctuate (for example, monthly processing cycles), lock patterns can deviate from the norm, potentially causing concurrency problems.<A NAME="ch05index209"></A><A NAME="ch05index210"></A><A NAME="ch05index211"></A><A NAME="ch05index212"></A><A NAME="ch05index213"></A></P>
<A NAME="ch05lev3sec10"></A><H5 class="docSection3Title"><TT>USING</TT></H5>
<P class="docText">The method of storage allocation for the table space is defined with the <TT>USING</TT> parameter. You can specify either a <TT>STOGROUP</TT> name combined with a primary and secondary quantity for space allocation or a VCAT indicating the high-level ICF catalog identifier for user-defined VSAM data sets.<A NAME="ch05index214"></A><A NAME="ch05index215"></A><A NAME="ch05index216"></A><A NAME="ch05index217"></A><A NAME="ch05index218"></A><A NAME="ch05index219"></A></P>
<P class="docText">In most cases, you should create the majority of your table spaces and indexes as <TT>STOGROUP</TT>-defined. This allows DB2 to do most of the work of creating and maintaining the underlying VSAM data sets, which contain the actual data. Another approach that reduces maintenance even more is to let SMS manage your page set allocations.</P>
<P class="docText">Table spaces and indexes defined using <TT>STOGROUP</TT>s provide the additional advantage of automatic data set creation as new data sets are needed. This is more beneficial than simply having DB2 create the initial data sets when the objects are defined. When a table space exceeds the maximum VSAM data set size, DB2 will automatically create additional data sets as needed to store the additional data. If you were using user-defined VSAM data sets instead, you would have to manually add new data sets when new VSAM data sets were needed. It is very difficult to predict when new data sets are needed, and even if you can predict this need, it is difficult to manage and create the data sets when they are needed.</P>
<P class="docText">Some DBAs believe that explicitly creating user-defined VSAM data sets for VCAT-defined table spaces gives them more control over the physical allocation, placement, and movement of the VSAM data sets. Similar allocation, placement, and movement techniques, however, can be achieved using <TT>STOGROUP</TT>s if the <TT>STOGROUP</TT>s are properly created and maintained and the table spaces are assigned to the <TT>STOGROUP</TT>s in a planned and orderly manner.</P>
<P class="docText">Another perceived advantage of user-defined VSAM data sets is the capability of recovering them if they inadvertently are dropped. The underlying, user-defined VSAM data sets for VCAT-defined objects are not deleted automatically when the corresponding object is dropped. You can recover the data for the table space using the <TT>DSN1COPY</TT> utility with the translate option. When you intentionally drop table spaces, however, additional work is required to manually delete the data sets.</P>
<P class="docText">There is one large exception to this scenario: If a segmented table space is dropped erroneously, the data cannot be recovered regardless of whether it was VCAT- or <TT>STOGROUP</TT>-defined. When a table is dropped from a segmented table space, DB2 updates the space map for the table space to indicate that the data previously in the table has been deleted, and the corresponding space is available immediately for use by other tables. When a table space is dropped, DB2 implicitly drops all tables in that table space.<A NAME="ch05index220"></A><A NAME="ch05index221"></A><A NAME="ch05index222"></A><A NAME="ch05index223"></A><A NAME="ch05index224"></A><A NAME="ch05index225"></A></P>
<P class="docText">A DBA can attempt to recover from an inadvertent drop of a segmented table space, and will appear to be successful with one glaring problem: DB2 will indicate that there is no data in the table space after the recovery. As you can see, the so-called advantage of easy <TT>DSN1COPY</TT> recovery of dropped tables disappears for user-defined VSAM data sets when you use segmented table spaces. This is crucial because more users are using segmented table spaces instead of simple table spaces to take advantage of their enhanced features.</P>
<P class="docText">Another perceived advantage of user-defined VSAM data sets was avoiding deleting and redefining the underlying data sets during utility processing. With <TT>STOGROUP</TT>-defined data sets, certain utilities, such as <TT>REORG</TT>, will delete and define the underlying data sets as part of the <TT>REORG</TT> process. As of DB2 V6, the <TT>REUSE</TT> option can be specified indicating that <TT>STOGROUP</TT>-defined data sets should be reused instead of being deleted and redefined. The utilities impacted are <TT>LOAD</TT>, <TT>REBUILD</TT>, <TT>RECOVER</TT>, and <TT>REORG</TT>.</P>
<P class="docText">See <A class="docLink" HREF="#ch05table04">Table 5.4</A> for a comparison of VCAT- and <TT>STOGROUP</TT>-defined data sets.</P>
<A NAME="ch05table04"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 5.4. User-Defined VSAM Data Sets Versus <TT>STOGROUP</TT>s</h5></CAPTION><COLGROUP><COL width="324.5"><COL width="88"><COL width="137.5"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top">&nbsp;</TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">VCAT</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><TT>STOGROUP</TT></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Need to know VSAM</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Yes</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">No</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">User physically must create the underlying data sets</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Yes</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">No</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Can ALTER storage requirements using SQL</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">No</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Yes</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Can use AMS</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Yes</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">No<sup class="docFootnote"><A class="docLink" HREF="#ch05tn01">[*]</A></sup></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Confusing when data sets are defined on more than one DASD volume</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">No</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Yes</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">After dropping the table or the table space, the underlying data set is not deleted</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Yes</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">No<sup class="docFootnote"><A class="docLink" HREF="#ch05tn02">[**]</A></sup><A NAME="ch05index226"></A><A NAME="ch05index227"></A><A NAME="ch05index228"></A><A NAME="ch05index229"></A><A NAME="ch05index230"></A><A NAME="ch05index231"></A></P></TD></TR></TABLE></P><br><blockquote><p class="docFootnote"><sup><A NAME="ch05tn01">[*]</A></sup> <span class="docEmphasis">A table space initially created as a user-defined VSAM later can be altered to use <TT>STOGROUP</TT>s. A <TT>STOGROUP</TT>-defined table space can be altered to user-defined VSAM as well.</span></p></blockquote><blockquote><p class="docFootnote"><sup><A NAME="ch05tn02">[**]</A></sup> <span class="docEmphasis">Data in a segmented table space is unavailable after dropping the table space because the space map p</span>ages are modified to indicate that the table space is empty after a <span class="docEmphasis"><TT>DROP</TT></span>.</p></blockquote>
<A NAME="ch05note11"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">If you are using RAID storage devices do not try to explicitly place data sets. RAID storage devices will "mix" up the data anyway, so your placement efforts will be for naught.</P></div><br>
<A NAME="ch05lev3sec11"></A><H5 class="docSection3Title"><TT>PRIQTY</TT> and <TT>SECQTY</TT></H5>
<P class="docText">If you are defining your table spaces using the <TT>STOGROUP</TT> method, you must specify primary and secondary space allocations. The primary allocation is the amount of physical storage allocated when the table space is created. As the amount of data in the table space grows, secondary allocations of storage are taken. To accurately calculate the DASD space requirements, you must know the following:<A NAME="ch05index232"></A><A NAME="ch05index233"></A><A NAME="ch05index234"></A><A NAME="ch05index235"></A><A NAME="ch05index236"></A><A NAME="ch05index237"></A><A NAME="ch05index238"></A><A NAME="ch05index239"></A><A NAME="ch05index240"></A><A NAME="ch05index241"></A><A NAME="ch05index242"></A><A NAME="ch05index243"></A><A NAME="ch05index244"></A><A NAME="ch05index245"></A></P>
<BLOCKQUOTE><P><P class="docList">Number of columns in each row</P></P><P><P class="docList">Data type for each column</P></P><P><P class="docList">Nullability of each column</P></P><P><P class="docList">Average size of variable columns</P></P><P><P class="docList">Number of rows in the table</P></P><P><P class="docList">Row overhead, such as RID size</P></P><P><P class="docList">Growth statistics</P></P><P><P class="docList">Growth horizon</P></P><P><P class="docList">Row compression statistics (if compression is used)</P></P></BLOCKQUOTE>
<P class="docText">The values specified for <TT>PRIQTY</TT> and <TT>SECQTY</TT> are in kilobytes. Most DB2 pages are 4K in size, so you usually should specify <TT>PRIQTY</TT> and <TT>SECQTY</TT> in multiples of four. DB2 also supports page sizes of 8KB, 16KB, and 32KB. For table spaces with these page sizes, always specify the <TT>PRIQTY</TT> and <TT>SECQTY</TT> amounts in multiples of the page size: 8, 16, or 32, respectively.</P>
<P class="docText">Additionally, you should specify <TT>PRIQTY</TT> and <TT>SECQTY</TT> amounts in terms of the type of DASD defined to the <TT>STOGROUP</TT> being used. For example, a table space with 4KB pages defined on an IBM 3390 DASD device uses 48KB for each physical track of storage. This corresponds to 12 pages. A data set cannot be allocated at less than a track, so it is wise to specify the primary and secondary allocations to at least a track boundary. For an IBM 3390 DASD device, specify the primary and secondary quantities in multiples of 48. Here are the physical characteristics of the two most popular IBM DASD devices:</P>
<P><TABLE CELLSPACING="0" FRAME="below" RULES="groups" CELLPADDING="5"><COLGROUP><COL width="100"><COL width="88.88888888888889"><COL width="94.44444444444444"><COL width="133.33333333333331"><COL width="133.33333333333331"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top">&nbsp;</TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Track</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Cylinder</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Cylinders/Device</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Bytes/Track</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">3380 Device</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">40KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">600KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">885</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">47,476</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">3390 Device</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">48KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">720KB</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1113</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">56,664</P></TD></TR></TABLE></P><br>
<P class="docText">For segmented table spaces, be sure to specify these quantities such that neither the primary nor the secondary allocation is less than a full segment. If you indicate a <TT>SEGSIZE</TT> of 12, for instance, do not specify less than four times the <TT>SEGSIZE</TT>, or 48K, for <TT>PRIQTY</TT> or <TT>SECQTY</TT>. It is worth noting that a table space with a <TT>SEGSIZE</TT> of 12 will require 13 total pages, and thus two tracks to store: 1 page for the space map and 12 pages for the first segment.<A NAME="ch05index246"></A><A NAME="ch05index247"></A><A NAME="ch05index248"></A><A NAME="ch05index249"></A><A NAME="ch05index250"></A><A NAME="ch05index251"></A></P>
<P class="docText">If you are allocating multiple tables to a single table space, calculate the <TT>PRIQTY</TT> and <TT>SECQTY</TT> separately for each table using the formulas in <A class="docLink" HREF="#ch05table05">Table 5.5</A>. When the calculations have been completed, add the totals for <TT>PRIQTY</TT> to get one large <TT>PRIQTY</TT> for the table space. Do the same for the <TT>SECQTY</TT> numbers. You might want to add approximately 10% to both <TT>PRIQTY</TT> and <TT>SECQTY</TT> when defining multiple tables to a simple table space. This additional space offsets the space wasted when rows of different lengths from different tables are combined on the same table space page. (See the section in this chapter called "<A class="docLink" HREF="ch05lev1sec5.html#ch05lev4sec50">Avoid Wasted Space</A>" for more information.) Remember, however, that the practice of defining multiple tables to a single, simple table space is not encouraged.<A NAME="ch05index252"></A><A NAME="ch05index253"></A><A NAME="ch05index254"></A><A NAME="ch05index255"></A><A NAME="ch05index256"></A><A NAME="ch05index257"></A><A NAME="ch05index258"></A><A NAME="ch05index259"></A><A NAME="ch05index260"></A><A NAME="ch05index261"></A><A NAME="ch05index262"></A><A NAME="ch05index263"></A><A NAME="ch05index264"></A><A NAME="ch05index265"></A><A NAME="ch05index266"></A><A NAME="ch05index267"></A><A NAME="ch05index268"></A><A NAME="ch05index269"></A><A NAME="ch05index270"></A><A NAME="ch05index271"></A></P>
<A NAME="ch05table05"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 5.5. Lengths for DB2 Data Types</h5></CAPTION><COLGROUP><COL width="126.5"><COL width="143"><COL width="16.5"><COL width="77"><COL width="187"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Data Type</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Internal Length</span></P></TH><TH class="bottomBorder thead" align="left" valign="top" colspan="3"><P class="docText"><span class="docEmphStrong">COBOL WORKING STORAGE</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CHAR(n)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">n</P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">01 identifier</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PIC X(n)</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top" rowspan="3"><P class="docText"><TT>VARCHAR(n)</TT></P></TD><TD class="docTableCell" align="left" valign="top" rowspan="3"><P class="docText">max=n+2</P></TD><TD class="docTableCell" align="left" valign="top" colspan="3"><P class="docText">01 identifier</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText">49 identifier</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PIC S9(4) COMP</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText">49 identifier</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PIC X(n)</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top" rowspan="3"><P class="docText"><TT>LONG VARCHAR</TT></P></TD><TD class="docTableCell" align="left" valign="top" rowspan="3"><P class="docText"><sup class="docFootnote"><A class="docLink" HREF="#ch05tn03">[*]</A></sup></P></TD><TD class="docTableCell" align="left" valign="top" colspan="3"><P class="docText">01 identifier</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText">49 identifier</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PIC S9(4) COMP</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText">49 identifier</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PIC X(n)</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>GRAPHIC(n)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2<SUP><A class="docLink" HREF="#ch05tn03">[*]</A></SUP>n</P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">01 identifier</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PIC G(n) DISPLAY-1</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top" rowspan="3"><P class="docText"><TT>VARGRAPHIC(n)</TT></P></TD><TD class="docTableCell" align="left" valign="top" rowspan="3"><P class="docText">(2<SUP><A class="docLink" HREF="#ch05tn03">[*]</A></SUP>n)+2</P></TD><TD class="docTableCell" align="left" valign="top" colspan="3"><P class="docText">01 identifier</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText">49 identifier</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PIC S9(4) COMP</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText">49 identifier</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PIC G(n) DISPLAY-1</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>LONG</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><SUP><A class="docLink" HREF="#ch05tn03">[*]</A></SUP></P></TD><TD class="docTableCell" align="left" valign="top" colspan="3"><P class="docText">01 identifier</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top" rowspan="2"><P class="docText"><TT>VARGRAPHIC</TT></P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText">49 identifier</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PIC S9(4) COMP</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText">49 identifier</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PIC G(n) DISPLAY-1</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SMALLINT</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2</P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">01 identifier</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PIC S9(4) COMP</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INTEGER</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4</P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">01 identifier</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PIC S9(9) COMP</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DECIMAL(p,s)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INTEGER </TT>(p/2)+1</P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">01 identifier</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PIC S9(p)V9(s) COMP-3</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>FLOAT(n)</TT> or <TT>REAL</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">8 (<TT>SINGLE</TT> <TT>PRECISION </TT>if n&gt;21)</P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">01 identifier</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COMP-2</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>FLOAT(n)</TT> or <TT>FLOAT</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4 (<TT>DOUBLE PRECISION </TT>if n&lt;21)</P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">01 identifier</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COMP-1</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DATE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4</P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">01 identifier</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PIC X(10)</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>TIME</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">3</P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">01 identifier</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PIC X(8)</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>TIMESTAMP</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">10</P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">01 identifier</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PIC X(26)</TT><A NAME="ch05index272"></A><A NAME="ch05index273"></A><A NAME="ch05index274"></A><A NAME="ch05index275"></A><A NAME="ch05index276"></A><A NAME="ch05index277"></A><A NAME="ch05index278"></A><A NAME="ch05index279"></A><A NAME="ch05index280"></A><A NAME="ch05index281"></A><A NAME="ch05index282"></A><A NAME="ch05index283"></A><A NAME="ch05index284"></A><A NAME="ch05index285"></A><A NAME="ch05index286"></A><A NAME="ch05index287"></A><A NAME="ch05index288"></A><A NAME="ch05index289"></A><A NAME="ch05index290"></A><A NAME="ch05index291"></A></P></TD></TR></TABLE></P><br><blockquote><p class="docFootnote"><sup><A NAME="ch05tn03">[*]</A></sup> <span class="docEmphasis">See text following this table to calculate this length.</span></p></blockquote>
<P class="docText">To calculate the internal length of a long character column, use these formulas:</P>
<BLOCKQUOTE><P><P class="docList">Modified row size = (max row size)–(size of all other cols)–(nullable long char cols)</P></P><P><P class="docList">Internal length = 2 * <TT>INTEGER</TT>((<TT>INTEGER</TT>((modified row size)/(long cols in table))/2))</P></P></BLOCKQUOTE>
<P class="docText">Next, calculate the number of rows per page and the total number of pages necessary. To do this, use the following formula:</P>
<BLOCKQUOTE><P><P class="docList">Rows per page = (((page size)–22) * ((100* <TT>PCTFREE</TT>)/100)/row length)</P></P><P><P class="docList">Total pages = (number of rows) / (rows per page)</P></P></BLOCKQUOTE>
<P class="docText">Finally, the <TT>PRIQTY</TT> is calculated as follows:</P>
<BLOCKQUOTE><P><P class="docList"><TT>PRIQTY</TT> = total pages * 4</P></P></BLOCKQUOTE>
<P class="docText">To accurately calculate the primary quantity for a table, you must make a series of calculations.<A NAME="ch05index292"></A><A NAME="ch05index293"></A></P>
<P class="docText">First, calculate the row length. To do this, add the length of each column, using <A class="docLink" HREF="#ch05table05">Table 5.5</A> to determine each column's internal stored length. Remember to add one byte for each nullable column and two bytes for each variable column.<A NAME="ch05index294"></A><A NAME="ch05index295"></A><A NAME="ch05index296"></A><A NAME="ch05index297"></A><A NAME="ch05index298"></A><A NAME="ch05index299"></A><A NAME="ch05index300"></A><A NAME="ch05index301"></A><A NAME="ch05index302"></A><A NAME="ch05index303"></A><A NAME="ch05index304"></A><A NAME="ch05index305"></A><A NAME="ch05index306"></A><A NAME="ch05index307"></A></P>
<P class="docText">If the rows are compressed, determine the average compressed row size and use this for the row length in the previous formulas.</P>
<P class="docText">To calculate <TT>SECQTY</TT>, you must estimate the growth statistics for the table space and the horizon over which this growth will occur.<A NAME="ch05index308"></A><A NAME="ch05index309"></A></P>
<P class="docText">For example, assume that you need to define the <TT>SECQTY</TT> for a table space that grows by 100 rows (growth statistics) over two months (growth horizon). If free space has been defined in the table space for 1,000 rows and you will reorganize this table space yearly (changing <TT>PRIQTY</TT> and <TT>SECQTY</TT>), you must provide for 200 rows in your <TT>SECQTY</TT>.</P>
<P class="docText">Divide the number of rows you want to provide for (in this case 200) by the number of rows per page. Round this number up to the next whole number divisible by 4 (to the track or cylinder boundary). Then specify this number as your <TT>SECQTY</TT>.</P>
<P class="docText">You might want to provide for secondary allocation in smaller chunks, not specifying the total number of rows in the initial <TT>SECQTY</TT> allocation. In the preceding example, you provided for 200 rows. By defining <TT>SECQTY</TT> large enough for 100 rows, you allocate three secondary extents before your yearly reorganization.</P>
<P class="docText">You may ask: why three? If each <TT>SECQTY</TT> can contain 100 rows and you must provide for 200 rows, shouldn't only two extents be allocated? No, there will be three. A secondary allocation is made when the amount of available space in the current extent reaches 50% of the next extent to be taken. So there are three allocations, but the third one is empty, or nearly empty.</P>
<P class="docText">As a general rule, avoid a large number of secondary extents. They decrease the efficiency of I/O, and I/O is the most critical bottleneck in most DB2 application systems.</P>
<P class="docText">Consider using DB2 Estimator to calculate space requirements for DB2 table space and index data sets. DB2 Estimator is a standalone tool provided by IBM at no cost with DB2 for OS/390. DB2 Estimator can be used to estimate the cost of running DB2 applications. DB2 Estimator also provides a space calculation feature. To calculate space for a table, highlight the table and choose the Space Requirements option in the Tables menu, as shown in <A class="docLink" HREF="#ch05fig03">Figure 5.3</A>. This will take you to the screen shown in <A class="docLink" HREF="#ch05fig04">Figure 5.4</A>, which can be used to determine the space requirements for the selected table. This allows the DBA to save time by avoiding the manual space calculations we just covered.<A NAME="ch05index310"></A><A NAME="ch05index311"></A><A NAME="ch05index312"></A><A NAME="ch05index313"></A><A NAME="ch05index314"></A><A NAME="ch05index315"></A><A NAME="ch05index316"></A><A NAME="ch05index317"></A><A NAME="ch05index318"></A><A NAME="ch05index319"></A><A NAME="ch05index320"></A><A NAME="ch05index321"></A><A NAME="ch05index322"></A><A NAME="ch05index323"></A><A NAME="ch05index324"></A><A NAME="ch05index325"></A></P>
<A NAME="ch05fig03"></A><p><CENTER><H5 class="docFigureTitle">Figure 5.3. DB2 Estimator and space requirements.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/05fig03_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="375" SRC="images/0672326132/graphics/05fig03.jpg" ALT="graphics/05fig03.jpg"></p></CENTER></p><br>
<A NAME="ch05fig04"></A><p><CENTER><H5 class="docFigureTitle">Figure 5.4. Using DB2 Estimator to calculate space.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/05fig04_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="375" SRC="images/0672326132/graphics/05fig04.jpg" ALT="graphics/05fig04.jpg"></p></CENTER></p><br>
<A NAME="ch05lev4sec13"></A><H5 class="docSection4Title">Allocate Space on Cylinder Boundaries</H5>
<P class="docText">Performance can be significantly affected based upon the choice of allocation unit. As an application inserts data into a table, DB2 will preformat space within the index and/or table space page set as necessary. This process will be more efficient if DB2 can preformat cylinders instead of tracks, because more space will be preformatted at once using cylinder allocation.<A NAME="ch05index326"></A><A NAME="ch05index327"></A><A NAME="ch05index328"></A><A NAME="ch05index329"></A><A NAME="ch05index330"></A></P>
<P class="docText">DB2 determines whether to use allocation units of tracks or cylinders based upon the value of <TT>PRIQTY</TT> and <TT>SECQTY</TT>. If either of these quantities is less than one cylinder, space for both primary and secondary will be allocated in tracks. For this reason, it is wise to specify both <TT>PRIQTY</TT> and <TT>SECQTY</TT> values of at least one cylinder for most table spaces and indexes.</P>
<P class="docText">Allocating space in tracks is a valid option, however, under any of the following conditions:</P>
<UL><LI><P class="docList">For small table spaces and indexes that consume less than one cylinder of DASD</P></LI><LI><P class="docList">For stable objects that are never updated <TT>SECQTY</TT> can be set to 0 causing DB2 to consider only <TT>PRIQTY</TT> when determining the allocation unit</P></LI></UL>
<A NAME="ch05lev4sec14"></A><H5 class="docSection4Title">Default Values for <TT>PRIQTY</TT> and <TT>SECQTY</TT></H5>
<P class="docText">If the <TT>PRIQTY</TT> parameter is not specified, and the data set is <TT>STOGROUP</TT>-defined, a default primary quantity value will be chosen by DB2. DB2 will base both the primary and secondary space allocation on the value of the <TT>TSQTY</TT> DSNZPARM parameter. If <TT>TSQTY</TT> is 0, then DB2 will default the size as follows, based on the page size of the data set:<A NAME="ch05index331"></A><A NAME="ch05index332"></A><A NAME="ch05index333"></A><A NAME="ch05index334"></A></P>
<UL><LI><P class="docList">For 4KB page sizes: 12</P></LI><LI><P class="docList">For 8KB page sizes: 24</P></LI><LI><P class="docList">For 16KB page sizes: 48</P></LI><LI><P class="docList">For 32KB page sizes: 96</P></LI></UL>
<P class="docText">If the <TT>SECQTY</TT> parameter is not specified, but the <TT>PRIQTY</TT> parameter is specified, the default value for <TT>SECQTY</TT> is 10% of the <TT>PRIQTY</TT> value or 3 times the page size of the table space, whichever value is greater.</P>
<P class="docText">If both the <TT>SECQTY</TT> and <TT>PRIQTY</TT> parameters are not specified, the default value for <TT>SECQTY</TT> follows the same pattern as for <TT>PRIQTY</TT> as indicated earlier.</P>
<P class="docText">Once again, avoid relying on default values. They are rarely, if ever, the correct choice. And even if the default happens to be the best choice, it is always better to explicitly specify the value to ensure that you are choosing the correct option.</P>
<A NAME="ch05lev4sec15"></A><H5 class="docSection4Title"><TT>SECQTY 0</TT> Versus No <TT>SECQTY</TT> Specified</H5>
<P class="docText">Specifying <TT>SECQTY 0</TT> means that no secondary extents will be taken. This is not the same as failing to specify the <TT>SECQTY</TT> option (which causes DB2 to use the default value). Be sure you understand the difference and only specify <TT>SECQTY 0</TT> if you want to avoid extents. If you try to <TT>INSERT</TT> data and no room is found in the table space and the table space is defined with <TT>SECQTY 0</TT>, the <TT>INSERT</TT> will fail. This is rarely desirable.<A NAME="ch05index335"></A><A NAME="ch05index336"></A><A NAME="ch05index337"></A><A NAME="ch05index338"></A><A NAME="ch05index339"></A><A NAME="ch05index340"></A></P>
<A NAME="ch05lev3sec12"></A><H5 class="docSection3Title">Free Space (<TT>PCTFREE</TT> and <TT>FREEPAGE</TT>)</H5>
<P class="docText">The specification of free space in a table space or index can reduce the frequency of reorganization, reduce contention, and increase the efficiency of insertion. The <TT>PCTFREE</TT> parameter specifies what percentage of each page should remain available for future inserts. The <TT>FREEPAGE</TT> parameter indicates the specified number of pages after which a completely empty page is available.<A NAME="ch05index341"></A><A NAME="ch05index342"></A><A NAME="ch05index343"></A><A NAME="ch05index344"></A><A NAME="ch05index345"></A><A NAME="ch05index346"></A><A NAME="ch05index347"></A><A NAME="ch05index348"></A><A NAME="ch05index349"></A><A NAME="ch05index350"></A></P>
<A NAME="ch05note12"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Keep in mind that <TT>PCTFREE</TT> and <TT>FREEPAGE</TT> represent the accurate free space only immediately after the object is created or reorganized. As soon as data starts to be inserted or updated, the space set aside using these parameters will start to be used by DB2.</P></div><br>
<P class="docText">Increasing free space decreases the number of rows per page and therefore decreases the efficiency of the buffer pool because fewer rows are retrieved per I/O. Increasing free space can improve concurrent processing, however, by reducing the number of rows on the same page. For example, consider a table space that contains a table clustered on the <TT>DEPARTMENT</TT> column. Each department must access and modify its data independent of other departments. By increasing free space, you decrease the occurrences of departments coexisting on table space pages because fewer rows exist per page.</P>
<P class="docText">Space can be used to keep areas of the table space available for the rows to be inserted. This results in a more efficient insert process, as well as more efficient access—with less unclustered data—after the rows have been inserted.</P>
<P class="docText">Understanding how insert activity affects DB2 data pages will aid in understanding how optimal free space specification can aid performance. When a row is inserted, DB2 will perform a space search algorithm to determine the optimal placement of the new row in the table space. This algorithm is different for segmented and non-segmented (simple and partitioned) table spaces. For segmented table spaces DB2 will<A NAME="ch05index351"></A><A NAME="ch05index352"></A><A NAME="ch05index353"></A><A NAME="ch05index354"></A><A NAME="ch05index355"></A></P>
<UL><LI><P class="docList">Identify the page in which the row should be inserted using the clustering index. (If no clustering index exists, DB2 will search all segments for available space to insert the row.)</P></LI><LI><P class="docList">If space is available on that page, the row will be inserted; if space is not available, DB2 will search within the segment containing the target page for available space.<A NAME="ch05index356"></A><A NAME="ch05index357"></A></P></LI><LI><P class="docList">If space is available in the segment, the row will be inserted; if space is not available, DB2 will search the last segment allocated in the table space for that specific table.</P></LI><LI><P class="docList">If space is available, insert the row; otherwise DB2 will allocate a new segment.</P></LI></UL>
<P class="docText">For non-segmented table space DB2 searches for space as follows:</P>
<UL><LI><P class="docList">Identify the page in which the row should be inserted using the clustering index.<A NAME="ch05index358"></A><A NAME="ch05index359"></A><A NAME="ch05index360"></A><A NAME="ch05index361"></A><A NAME="ch05index362"></A></P></LI><LI><P class="docList">If space is available on that page, the row will be inserted; if space is not available, DB2 will search 16 contiguous pages before and after the target page.</P></LI><LI><P class="docList">If space is available on any of those 32 pages, the row will be inserted; if space is not available, DB2 will scan from the beginning of the table space (or partition).</P></LI><LI><P class="docList">If space is available, insert the row; otherwise DB2 will request a secondary extent.</P></LI></UL>
<P class="docText">For both segmented and non-segmented table spaces, DB2 will bypass locked pages even if they contain sufficient free space to hold the row to be inserted.<A NAME="ch05index363"></A><A NAME="ch05index364"></A><A NAME="ch05index365"></A><A NAME="ch05index366"></A><A NAME="ch05index367"></A><A NAME="ch05index368"></A><A NAME="ch05index369"></A><A NAME="ch05index370"></A><A NAME="ch05index371"></A><A NAME="ch05index372"></A></P>
<P class="docText">If insert activity is skewed, with inserts clustered at certain locations in the table space, you might want to increase the free space to offset the space used for the heavily updated portions of the table spaces. This increases the overall DASD usage but can provide better performance by decreasing the amount of unclustered data. Additionally, you could partition the table space such that the data area having the highest insert activity is isolated in its own partition. Free space could then be assigned by partition such that the insert "hot spot"has a higher <TT>PCTFREE</TT> and/or <TT>FREEPAGE</TT> specified. The other partitions could be assigned a lower free space.<A NAME="ch05index373"></A><A NAME="ch05index374"></A></P>
<P class="docText">If more than one table is assigned to a table space, calculate the free space for the table with the highest insert activity. This provides for more free space for tables with lower insert activity, but results in the best performance. Also, if the rows are compressed, calculate free space based on the average compressed row size.</P>
<P class="docText">When calculating free space, you must take into account that a certain amount of each page is wasted. DB2 uses 4K page sizes (of which 4,074 bytes are useable for data), and a maximum of 255 rows can be placed on one page. Consider a table space containing a single table with 122-byte rows. A single page can contain 33 rows. This leaves 48 bytes wasted per page, as follows:<A NAME="ch05index375"></A><A NAME="ch05index376"></A></P>
<BLOCKQUOTE><P><P class="docList">4074 / 122 = 33.39</P></P><P><P class="docList">4074 – (122 * 33) = 48</P></P></BLOCKQUOTE>
<P class="docText">Suppose that you want 10% free space in this table space. To specify that 10% of each page will be free space, you must factor the wasted space into the calculation. By specifying <TT>PCTFREE</TT> 10, 407 bytes are set aside as free space. However, 48 of those bytes can never be used, leaving 359 bytes free. Only two rows can fit in this space, whereas three would fit into 407 bytes. Factor the wasted space into your free-space calculations.</P>
<P class="docText">As a general rule, free space allocation depends on knowing the growth rate for the table, the frequency and impact of reorganization, and the concurrency needs of the application. Remember, <TT>PCTFREE</TT> is not the same as growth rate. Consider a table space that is allocated with a primary quantity of 7200K. If <TT>PCTFREE</TT> was set to 10, 720K is left free, with 6480K remaining for data storage. However, this provides a growth rate of 720/6480, or just over 11%, which is clearly a larger number than the <TT>PCTFREE</TT> specified. The general formula for converting growth rate to <TT>PCTFREE</TT> is:<A NAME="ch05index377"></A><A NAME="ch05index378"></A><A NAME="ch05index379"></A><A NAME="ch05index380"></A></P>
<BLOCKQUOTE><P><P class="docList"><TT>PCTFREE</TT> = (growth rate) / (1 + growth rate)</P></P></BLOCKQUOTE>
<P class="docText">To accommodate a 15% growth rate, only 13% (.15/1.15) of free space is necessary.</P>
<P class="docText">The other free space parameter is <TT>FREEPAGE</TT>. Specifying <TT>PCTFREE</TT> is sufficient for the free space needs of most table spaces. If the table space is heavily updated, however, consider specifying <TT>FREEPAGE</TT> in conjunction with <TT>PCTFREE</TT>. See <A class="docLink" HREF="#ch05table06">Table 5.6</A> for free space suggestions based on update frequency. Modify these numbers to include wasted space, as described previously. These numbers should be used as rough guidelines only. You should always consider the growth rate for data used in your applications when specifying DB2 free space.</P>
<A NAME="ch05table06"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 5.6. Free Space Allocation Chart</h5></CAPTION><COLGROUP><COL width="225.5"><COL width="137.5"><COL width="187"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Type of Table Processing</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><TT>FREEPAGE</TT></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><TT>PCTFREE</TT></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Read only</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">0</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">0</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Less than 20% of table volume inserted between <TT>REORG</TT>s</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">0</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">10 to 20</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">20 to 60% of table volumes inserted between <TT>REORG</TT>s</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">0</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">20 to 30</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Greater than 60% of table volumes inserted between <TT>REORG</TT>s</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">0 or (<TT>SEGSIZE–</TT>1)</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">20 to 30</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Most inserts done in sequence by the clustering index</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">0</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">0 to 10</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Table space with variable length rows being updated</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">0</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">10 to 20<A NAME="ch05index381"></A><A NAME="ch05index382"></A><A NAME="ch05index383"></A><A NAME="ch05index384"></A><A NAME="ch05index385"></A><A NAME="ch05index386"></A><A NAME="ch05index387"></A><A NAME="ch05index388"></A><A NAME="ch05index389"></A><A NAME="ch05index390"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch05lev3sec13"></A><H5 class="docSection3Title"><TT>BUFFERPOOL</TT></H5>
<P class="docText">DB2 provides eighty buffer pool options for table space and index objects:<A NAME="ch05index391"></A><A NAME="ch05index392"></A><A NAME="ch05index393"></A><A NAME="ch05index394"></A><A NAME="ch05index395"></A></P>
<UL><LI><P class="docList">50 4KB buffer pools—BP0 through BP49</P></LI><LI><P class="docList">10 8KB buffer pools—BP8K0 through BP8K9</P></LI><LI><P class="docList">10 16KB buffer pools—BP16K0 through BP16K9</P></LI><LI><P class="docList">10 32KB buffer pools—BP32K through BP32K9</P></LI></UL>
<P class="docText">Data accessed from a DB2 table is first read from DASD, and then moved into a buffer pool, and then returned to the requester. Data in the buffer pool can remain resident in memory, avoiding the expense of I/O for future queries that access the same data. There are many strategies for specifying buffer pools, and each is discussed fully in <A class="docLink" HREF="part05.html#part05">Part V</A>, "DB2 Performance Tuning." For now, it's sufficient to mention the following rules:</P>
<UL><LI><P class="docList">Some small to medium DB2 shops use a single buffer pool, namely <TT>BP0</TT>. For these types of shops, DB2 does an adequate job of managing I/O using a single, large <TT>BP0</TT> containing most (or all) of a shop's table spaces and indexes.</P></LI><LI><P class="docList">As usage of DB2 grows, you should specify additional buffer pools tuned for specific applications, table spaces, indexes, or activities. The majority of mature DB2 shops fall into this category. Several buffer pool allocation and usage approaches are discussed in <A class="docLink" HREF="part05.html#part05">Part V</A>.</P></LI><LI><P class="docList">Avoid using <TT>BP32K</TT> for application table spaces. DB2 arranges a table space assigned to a 32K buffer pool as eight single 4K pages per 32K page. Therefore, every logical I/O to a 32K table space requires eight physical I/Os. To avoid using <TT>BP32K</TT>, consider denormalizing your tables, if necessary. (See the "<A class="docLink" HREF="ch05lev1sec6.html#ch05lev2sec14">Denormalization</A>" section later in this chapter for more information.) With the addition of 8KB and 16KB buffer pools in DB2 V6, it is easier to manage DB2 table spaces having a page size greater than 4KB.</P></LI></UL>
<P class="docText">The number of buffer pools in use at your shop depends on the DB2 workload and the amount of real and extended memory that can be assigned to the DB2 buffer pools. These topics are covered in greater detail in <A class="docLink" HREF="part05.html#part05">Part V</A>.<A NAME="ch05index396"></A><A NAME="ch05index397"></A><A NAME="ch05index398"></A><A NAME="ch05index399"></A><A NAME="ch05index400"></A></P>
<A NAME="ch05lev4sec16"></A><H5 class="docSection4Title">Always Specify a Buffer Pool</H5>
<P class="docText">If you do not specify the <TT>BUFFERPOOL</TT> clause, the default buffer pools for the database are used (one for table spaces and one for indexes). Do not allow the <TT>BUFFERPOOL</TT> to default to the buffer pool of the database. It is better to explicitly specify the <TT>BUFFERPOOL</TT> clause on all table spaces and index <TT>CREATE</TT> statements.<A NAME="ch05index401"></A><A NAME="ch05index402"></A><A NAME="ch05index403"></A><A NAME="ch05index404"></A><A NAME="ch05index405"></A></P>
<A NAME="ch05lev4sec17"></A><H5 class="docSection4Title">BP32 and BP32K</H5>
<P class="docText">Remember that <TT>BP32</TT> and <TT>BP32K</TT> are two different sizes. <TT>BP32</TT> is one of the fifty 4K buffer pools. <TT>BP32K</TT> is one of the ten 32K buffer pools. If you miss, or add, an erroneous "K" you may be using or allocating the wrong buffer pool.<A NAME="ch05index406"></A><A NAME="ch05index407"></A><A NAME="ch05index408"></A><A NAME="ch05index409"></A><A NAME="ch05index410"></A><A NAME="ch05index411"></A></P>
<A NAME="ch05note13"></A><div class="docNote"><p class="docNoteTitle">TIP</p>

<P class="docText">Any buffer pool that contains a "K" in it is not a 4KB buffer pool; instead it is an 8KB, 16KB, or 32KB buffer pool. If the buffer pool does not contain a "K," it is a 4KB buffer pool.</P></div><br>
<A NAME="ch05lev3sec14"></A><H5 class="docSection3Title"><TT>CLOSE YES</TT> or <TT>NO</TT></H5>
<P class="docText">Prior to DB2 V2.3, the <TT>CLOSE</TT> option specified whether the underlying VSAM data sets for the table space (or index space) should be closed each time the table was used. <TT>CLOSE YES</TT> indicated that the underlying data set was to be closed after use; <TT>CLOSE NO</TT> indicated the opposite. A performance gain was usually realized when you specified <TT>CLOSE NO</TT>. For table spaces accessed infrequently (only once or twice daily), <TT>CLOSE YES</TT> might have been appropriate.<A NAME="ch05index412"></A><A NAME="ch05index413"></A><A NAME="ch05index414"></A><A NAME="ch05index415"></A><A NAME="ch05index416"></A><A NAME="ch05index417"></A><A NAME="ch05index418"></A><A NAME="ch05index419"></A></P>
<P class="docText">DB2 V2.3 introduced deferred close processing, sometimes referred to as <span class="docEmphasis">slow close</span>. Deferred close provided relief from the overhead associated with opening and closing data sets by closing the data sets only when the maximum number of open data sets was reached, regardless of whether <TT>CLOSE YES</TT> or <TT>CLOSE NO</TT> was specified. However, DB2 V2.3 will also update <TT>SYSLGRNX</TT> every time the data set is not in use. This speeds the recovery, because DB2 has a record of when updates could have occurred. However, the constant <TT>SYSLGRNX</TT> updating can be a performance detriment during normal processing. Also, deferred close is a mixed blessing, because DB2 V2.3 table spaces that need to be closed after each access will remain open regardless of the <TT>CLOSE</TT> parameter specified.</P>
<P class="docText">DB2 V3 introduced a new open/close scenario referred to as <span class="docEmphasis">pseudo close</span>. Pseudo close offers the following features:<A NAME="ch05index420"></A></P>
<UL><LI><P class="docList">A page set is not physically opened until it is first accessed, such as when an SQL statement or utility is executed against it.</P></LI><LI><P class="docList">The VSAM open-for-update timestamp is not modified until data in the page set is updated. Previously, it was modified when the page set was first opened. This timestamp can be used by some types of software to determine when an updated page set needs to be backed-up. If an updated page set has not been modified for a specified number of DB2 checkpoints (DSNZPARM <TT>PCLOSEN</TT>) or a specified amount of time (DSNZPARM <TT>PCLOSET</TT>), then it is switched to a read-only state.</P></LI><LI><P class="docList">Page sets specified as <TT>CLOSE NO</TT> are candidates for physical close when either the <TT>DDLIMIT</TT> or <TT>DSMAX</TT> limit has been reached.</P></LI><LI><P class="docList"><TT>SYSLGRNX</TT> records are updated for <TT>CLOSE YES</TT> data sets and are maintained by partition instead of at the data set level.</P></LI><LI><P class="docList">The performance problems associated with updating <TT>SYSLGRNX</TT> are eliminated; <TT>SYSLGRNX</TT> entries will be written only when a data set (or partition) is converted to read-only state, not every time the data set is not in use.<A NAME="ch05index421"></A><A NAME="ch05index422"></A><A NAME="ch05index423"></A><A NAME="ch05index424"></A><A NAME="ch05index425"></A><A NAME="ch05index426"></A><A NAME="ch05index427"></A><A NAME="ch05index428"></A></P></LI></UL>
<A NAME="ch05note14"></A><div class="docNote"><p class="docNoteTitle">TIP</p>

<P class="docText">Favor the use of <TT>CLOSE YES</TT> when operating with DB2 V3 and greater, because the <TT>SYSLGRNX</TT> modification performance problems have been eliminated.</P></div><br>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> The maximum number of data sets that could be open in MVS at one time was 10,000. For V8, the number of open data sets can be up to 32,000 for z/OS V1.4 or 100,000 for z/OS V1.5.<A NAME="ch05index429"></A><A NAME="ch05index430"></A><A NAME="ch05index431"></A><A NAME="ch05index432"></A><A NAME="ch05index433"></A><A NAME="ch05index434"></A><A NAME="ch05index435"></A><A NAME="ch05index436"></A></P></td></tr></table><br>
<A NAME="ch05lev3sec15"></A><H5 class="docSection3Title"><TT>ERASE YES</TT> or <TT>NO</TT></H5>
<P class="docText">The <TT>ERASE</TT> option specifies whether the physical DASD where the table space data set resides should be written over with binary zeroes when the table-space is dropped. Sensitive data that should never be accessed without proper authority should be set to <TT>ERASE YES</TT>. This ensures that the data in the table is erased when the table is dropped. Most table spaces, however, should be specified as <TT>ERASE NO</TT>.<A NAME="ch05index437"></A><A NAME="ch05index438"></A><A NAME="ch05index439"></A><A NAME="ch05index440"></A><A NAME="ch05index441"></A></P>
<A NAME="ch05lev3sec16"></A><H5 class="docSection3Title"><TT>NUMPARTS</TT> and <TT>SEGSIZE</TT></H5>
<P class="docText">See the "<A class="docLink" HREF="#ch05lev4sec25">Use Proper Table space Definitions</A>" section earlier in this chapter for <TT>NUMPARTS</TT> and <TT>SEGSIZE</TT> recommendations. The <TT>NUMPARTS</TT> option is used only for partitioned table spaces, <TT>SEGSIZE</TT> only for segmented table spaces.<A NAME="ch05index442"></A><A NAME="ch05index443"></A><A NAME="ch05index444"></A><A NAME="ch05index445"></A><A NAME="ch05index446"></A><A NAME="ch05index447"></A><A NAME="ch05index448"></A><A NAME="ch05index449"></A></P>
<A NAME="ch05lev3sec17"></A><H5 class="docSection3Title">Compression</H5>
<P class="docText">Data compression can be specified directly in a DB2 table space. Compression is indicated in the DDL by specifying <TT>COMPRESS YES</TT> for the table space. Likewise, it can be turned off in the DDL by specifying <TT>COMPRESS NO</TT>. When compression is specified, DB2 builds a static dictionary to control compression. It saves from 2 to 17 dictionary pages in the table space. These pages are stored after the header and first space map page.<A NAME="ch05index450"></A><A NAME="ch05index451"></A><A NAME="ch05index452"></A><A NAME="ch05index453"></A><A NAME="ch05index454"></A><A NAME="ch05index455"></A></P>
<P class="docText">DB2 compression provides two very clear benefits:</P>
<UL><LI><P class="docList">Hardware-assisted compression.</P></LI><LI><P class="docList">It is provided free of charge with the base DB2 product.</P></LI></UL>
<P class="docText">Hardware-assisted compression is available only to those users owning IBM's high-end CPU models. This does not mean that DB2 compression features are only available to those with high-end CPUs. Hardware-assisted compression simply speeds up the compression and decompression of data—it is not a requirement for the inherent data compression features of DB2.</P>
<P class="docText">Of course, there are also potential disadvantages to using DB2 compression. Each compressed table space requires a compression dictionary that must be created, stored, and managed. It takes up DBM1 storage and can complicate recovery situations.</P>
<P class="docText">Overall, though, DB2 compression generally is efficient and effective. Users who never looked at compression before it was provided by DB2 because of the cost of third-party products should reevaluate their compression needs.</P>
<A NAME="ch05lev4sec18"></A><H5 class="docSection4Title">DDL Data Compression Versus Edit Procedures</H5>
<P class="docText">DB2 data compression definitely should be used instead of the <TT>DSN8HUFF</TT> routine that is also supplied with DB2. But how does it compare to third-party tools? Most third-party vendors provide compression using <TT>EDITPROC</TT>s. However, these products are waning in popularity because of the excellent compression available to DB2 and the hardware-assist. Most users will find that DB2 can handle most of their compression requirements without needing a third-party compression tool.<A NAME="ch05index456"></A><A NAME="ch05index457"></A><A NAME="ch05index458"></A><A NAME="ch05index459"></A><A NAME="ch05index460"></A><A NAME="ch05index461"></A><A NAME="ch05index462"></A></P>
<P class="docText">However, before completely refusing to evaluate third-party solutions, consider the following:</P>
<UL><LI><P class="docList">IBM compression supplies only a single compression routine (based on the Ziv-Lempel algorithm), whereas several third-party tools provide many different compression routines. This enables the user to better fit the algorithm to the composition of the data—using different compression algorithms for different types of data.</P></LI><LI><P class="docList">The cost in time and effort to convert from prior compression methods to internal DB2 compression may not be cost-justifiable when compared to other tasks facing your enterprise.</P></LI><LI><P class="docList">Third-party tool vendors are constantly enhancing their products to take better advantage of the operating system and the hardware environment. To ensure that you are getting the best "bang for your buck" in terms of data compression, it is wise to evaluate all of your options before settling on any given one. However, most of the third parties have fallen behind in updating their compression routines because of DB2's "out of the box" compression functionality.<A NAME="ch05index463"></A><A NAME="ch05index464"></A><A NAME="ch05index465"></A><A NAME="ch05index466"></A><A NAME="ch05index467"></A><A NAME="ch05index468"></A><A NAME="ch05index469"></A></P></LI></UL>
<A NAME="ch05note15"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">For smaller table spaces, it is possible that the dictionary used by DB2 for compression could use more space than compression saves. For this reason, avoid compressing smaller table spaces.</P></div><br>
<A NAME="ch05lev4sec19"></A><H5 class="docSection4Title">General Data Compression Considerations</H5>
<P class="docText">Why compress data? Consider an uncompressed table with a very large row size of 800 bytes. Therefore, five of this table's rows fit on a 4K page. If the compression routine achieves 30% compression, on average, the 800-byte row uses only 560 bytes, because 800–(800*.3) = 560. Now seven rows fit on a 4K page. Because I/O occurs at the page level, the cost of I/O is reduced because fewer pages must be read for table space scans, and the data is more likely to be in the buffer pool because more rows fit on a physical page.<A NAME="ch05index470"></A><A NAME="ch05index471"></A><A NAME="ch05index472"></A><A NAME="ch05index473"></A><A NAME="ch05index474"></A><A NAME="ch05index475"></A></P>
<P class="docText">This can be a significant reduction. Consider the following scenarios. A 10,000-row table with 800-byte rows requires 2,000 pages. Using a compression routine as outlined previously, the table would require only 1,429 pages. Another table also with 800-byte rows but now having 1 million rows would require 200,000 pages without a compression routine. Using the compression routine, you would reduce the pages to 142,858—a reduction of more than 50,000 pages.</P>
<P class="docText">Of course, there is always a trade-off: DASD savings for CPU cost of compressing and decompressing data. However, the cost should be minimal with hardware-assisted compression. Indeed, overall elapsed time for certain I/O heavy processes may decrease when data is compressed. Furthermore, DB2 may require fewer buffer pages to process compressed data versus fully expanded data. Additionally, the compression dictionary is loaded into memory when the page set is opened. Loading lots of compression dictionaries into memory could eventually cause problems.<A NAME="ch05index476"></A><A NAME="ch05index477"></A></P>
<A NAME="ch05lev3sec18"></A><H5 class="docSection3Title">Encoding Scheme</H5>
<P class="docText">The <TT>CCSID</TT> parameter is used to specify the data encoding scheme to use for the table space: ASCII or EBCDIC. All data stored within a table space must use the same encoding scheme.<A NAME="ch05index478"></A><A NAME="ch05index479"></A><A NAME="ch05index480"></A><A NAME="ch05index481"></A><A NAME="ch05index482"></A><A NAME="ch05index483"></A><A NAME="ch05index484"></A></P>
<A NAME="ch05note16"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Do not specify an encoding scheme using <TT>CCSID</TT> for LOB table spaces or table spaces in a temporary database. The encoding scheme for a LOB table space will be inherited from its base table space. The LOB table space must have the same encoding scheme as its base table space—it cannot be different.<A NAME="ch05index485"></A><A NAME="ch05index486"></A></P>
<P class="docText">A table space in a <TT>TEMP</TT> database will not have an encoding scheme, because it can contain temporary tables having a variety of different encoding schemes.</P></div><br>
<P class="docText">The default encoding scheme for a table space is the encoding scheme of the database in which the table space is being created. So, obviously, the <TT>CCSID</TT> parameter can be coded for databases as well as table spaces. When <TT>CCSID</TT> is specified on a <TT>CREATE DATABASE</TT> statement, it specifies the default encoding scheme for data stored in the database. If no <TT>CCSID</TT> is specified for the database, the default will be the value specified to the <TT>DEF ENCODING SCHEME</TT> field on the <TT>DSNTIPF</TT> installation panel.<A NAME="ch05index487"></A><A NAME="ch05index488"></A><A NAME="ch05index489"></A><A NAME="ch05index490"></A><A NAME="ch05index491"></A><A NAME="ch05index492"></A><A NAME="ch05index493"></A></P>
<A NAME="ch05lev3sec19"></A><H5 class="docSection3Title"><TT>LOCKPART</TT></H5>
<P class="docText">Specifying <TT>LOCKPART YES</TT> enables selective partition locking (SPL). With SPL, individual partitions of a partitioned table space are locked only when accessed. SPL provides the following benefits:<A NAME="ch05index494"></A><A NAME="ch05index495"></A><A NAME="ch05index496"></A><A NAME="ch05index497"></A><A NAME="ch05index498"></A><A NAME="ch05index499"></A></P>
<UL><LI><P class="docList">When SPL is enabled, applications accessing different partitions of a partitioned table space can enjoy greater concurrency.</P></LI><LI><P class="docList">In a data sharing environment, DB2 and the IRLM can detect and optimize locking for situations in which no inter-subsystem activity exists by partition.</P></LI></UL>
<P class="docText">The default is <TT>LOCKPART NO</TT>, which indicates that locks are taken on the entire partitioned table space, not partition by partition.</P>
<A NAME="ch05lev3sec20"></A><H5 class="docSection3Title"><TT>MAXROWS</TT></H5>
<P class="docText">The <TT>MAXROWS</TT> parameter indicates the maximum number of rows that can be stored on a table space page. The default is 255. Specify <TT>MAXROWS 255</TT> unless there is a compelling reason to limit the number of rows per page, such as to limit contention for page locking.<A NAME="ch05index500"></A><A NAME="ch05index501"></A><A NAME="ch05index502"></A><A NAME="ch05index503"></A><A NAME="ch05index504"></A><A NAME="ch05index505"></A></P>
<A NAME="ch05note17"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Do not use <TT>MAXROWS</TT> for a LOB table space or a table space in a work file database.</P></div><br>
<A NAME="ch05lev4sec20"></A><H5 class="docSection4Title">Use <TT>MAXROWS 1</TT> Instead of Using Dummy Columns</H5>
<P class="docText">A common design technique for older DB2 systems was to append dummy columns to DB2 tables to arbitrarily extend the row length. This was done to coerce DB2 into storing one row per page, effectively forcing a kludged type of row locking. However, this technique is invasive and undesirable because dummy columns will show up in <TT>DCLGEN</TT>s and might not always be recognized as "dummies." The same effect can be accomplished by specifying <TT>MAXROWS 1</TT>.<A NAME="ch05index506"></A><A NAME="ch05index507"></A><A NAME="ch05index508"></A><A NAME="ch05index509"></A><A NAME="ch05index510"></A><A NAME="ch05index511"></A></P>
<P class="docText"><TT>MAXROWS 1</TT> also can be a viable alternative to <TT>LOCKSIZE ROW</TT>.</P>
<A NAME="ch05lev3sec21"></A><H5 class="docSection3Title"><TT>MEMBER CLUSTER</TT></H5>
<P class="docText">The <TT>MEMBER CLUSTER</TT> parameter is used to indicate that inserted data is to ignore the clustering index (whether implicit or explicit). Instead, DB2 will choose where to put the data based on the space available in the table space.<A NAME="ch05index512"></A><A NAME="ch05index513"></A><A NAME="ch05index514"></A><A NAME="ch05index515"></A><A NAME="ch05index516"></A><A NAME="ch05index517"></A><A NAME="ch05index518"></A></P>
<P class="docText">Use this option with great care and only in certain specific situations. For example, if <TT>INSERT</TT>s are applied during batch processing and then the table space is always immediately reorganized, inserting the data by clustering index just slows down the <TT>INSERT</TT> processing. In this scenario, specifying <TT>MEMBER CLUSTER</TT> will speed up the batch jobstream and the subsequent <TT>REORG</TT> will recluster the data.</P>
<A NAME="ch05note18"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Do not use <TT>MEMBER CLUSTER</TT> for a <TT>LOB</TT> table space or a table space in a work file database.</P></div><br>
<A NAME="ch05lev3sec22"></A><H5 class="docSection3Title"><TT>TRACKMOD</TT></H5>
<P class="docText">The <TT>TRACKMOD</TT> parameter indicates whether DB2 should track modified pages in the space map pages of the table space or table space partition. If you specify <TT>TRACKMOD YES</TT>, DB2 tracks changed pages in the space map pages to improve the performance of incremental image copy. The default value is <TT>YES</TT>.<A NAME="ch05index519"></A><A NAME="ch05index520"></A><A NAME="ch05index521"></A><A NAME="ch05index522"></A><A NAME="ch05index523"></A><A NAME="ch05index524"></A><A NAME="ch05index525"></A></P>
<P class="docText">You can specify <TT>TRACKMOD NO</TT> to turn off the tracking of changed pages in the space map pages. Consider specifying <TT>TRACKMOD NO</TT> if you never take incremental image copies. Making an incremental copy can be significantly faster than making a full copy if the table space is defined with the <TT>TRACKMOD YES</TT> option.</P>
<P class="docText">Also, you cannot use the <TT>CHANGELIMIT</TT> option of the <TT>COPY</TT> utility for a table space or partition that is defined with <TT>TRACKMOD NO</TT>.</P>
<A NAME="ch05note19"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Do not use the <TT>TRACKMOD</TT> clause for a <TT>LOB</TT> table space.</P></div><br>
<A NAME="ch05lev3sec23"></A><H5 class="docSection3Title">Page Size</H5>
<P class="docText">Each DB2 table space requires an underlying VSAM linear data set in which to store its data. The majority of DB2 table spaces will have 4KB page sizes. However, if the row size is so large that it will not fit onto a 4KB page, the table space can be created with a page size of 8KB, 16KB, or 32KB.<A NAME="ch05index526"></A><A NAME="ch05index527"></A><A NAME="ch05index528"></A><A NAME="ch05index529"></A><A NAME="ch05index530"></A><A NAME="ch05index531"></A><A NAME="ch05index532"></A></P>
<P class="docText">A VSAM CI, or control interval, is basically equivalent to DB2 page size. Prior to DB2 V8, the CI size of every underlying VSAM file was 4KB. DB2 would use multiple 4KB CIs to build up to 8KB, 16KB, or 32KB. For example, DB2 chains together eight separate 4KB CIs to build a 32KB page.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> However, as of DB2 V8 you can direct DB2 to use CI sizes of 8, 16, and 32KB to support table spaces with these large page sizes. To use this feature you need to set a new DSNZPARM. This parameter is set on the <TT>DSNTIP7</TT> panel (<TT>VARY DS CONTROL INTERVAL</TT>).</P></td></tr></table><br>
<A NAME="ch05note20"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">DB2 index spaces are still restricted to using 4KB page sizes.</P></div><br>
<P class="docText">After setting the DSNZPARM, all new 8KB, 16KB, and 32KB table spaces will use the same CI size instead of chaining 4KB CIs. Existing table spaces will be converted when they are reorganized or reloaded from scratch.</P>
<P class="docText">Consider using this new feature to synchronize CI size with table space page size to improve the performance of table space scans.<A NAME="ch05index533"></A><A NAME="ch05index534"></A><A NAME="ch05index535"></A><A NAME="ch05index536"></A><A NAME="ch05index537"></A><A NAME="ch05index538"></A><A NAME="ch05index539"></A></P>
<A NAME="ch05lev2sec4"></A><H4 class="docSection2Title">Multi-Table Table Spaces</H4>
<P class="docText">Most DBAs follow a loose rule of placing only a single table in each table space. In general, this is a wise course of action for simple and segmented table spaces. Of course, it is mandatory for partitioned table spaces because only one table can be defined per partitioned table space. The one table per table space rule eases the administration process and helps to protect data integrity.<A NAME="ch05index540"></A><A NAME="ch05index541"></A></P>
<P class="docText">In a simple table space, data from more than one table can exist on the same page. Having multiple tables in a simple table space adversely affects concurrent data access, data availability, space management, and <TT>LOAD</TT> utility processing. For segmented table spaces, each page will contain data for only one table, so the concurrency issues are not relevant.</P>
<P class="docText">Another problem for multi-table table spaces is utility processing. DB2 utilities operate at the table space level, even when the code looks like it is for a single table. For example, consider the following <TT>LOAD</TT> statement:</P>
<pre>

</pre><BR><pre>
LOAD DATA
REPLACE LOG NO
INDDN INPUT
INTO TABLE DSN8810.DEPT;
</pre><BR>
<P class="docText">Most folks would read this statement to say that DB2 will read the data in the data set referenced by the <TT>INPUT DDNAME</TT> and use it to replace the data in the <TT>DEPT</TT> table only. That is mostly but not 100% accurate. DB2 will actually replace all of the data in the table space where the <TT>DEPT</TT> table resides. So, if the <TT>EMP</TT> table was defined in the same table space, then this <TT>LOAD</TT> statement would replace all of the <TT>DEPT</TT> data and completely eliminate all of the <TT>EMP</TT> data. That is probably not the intent of this <TT>LOAD</TT> operation. Obliterating data in this manner usually is unacceptable for most applications. This caveat applies to both segmented and simple table spaces.</P>
<P class="docText">Additionally, compression can be problematic for multi-table table spaces. The compression ratio can be adversely affected by storing multiple tables in a single table space.<A NAME="ch05index542"></A><A NAME="ch05index543"></A></P>
<A NAME="ch05lev4sec21"></A><H5 class="docSection3Title">Define One Table per Table Space</H5>
<P class="docText">For the reasons outlined in the previous section, it is a good idea to follow the rule of placing only a single table into each table space. This is so regardless of the type of table space (simple, segmented, or partitioned). If you are going to put more than one table into the same table space, do so only for small, static tables that will not be loaded using the <TT>REPLACE</TT> option.<A NAME="ch05index544"></A><A NAME="ch05index545"></A></P>
<A NAME="ch05lev3sec24"></A><H5 class="docSection3Title">Defining Multiple Tables per Segmented Table Space</H5>
<P class="docText">However, at times it is advisable to assign multiple tables to a single segmented table space. Although doing so in the wrong situation can be disastrous, there are advantages to multi-table table spaces, too, if they are implemented properly and with discretion. Consider the following advantages and disadvantages before proceeding with more than one table assigned to a segmented table space.<A NAME="ch05index546"></A><A NAME="ch05index547"></A><A NAME="ch05index548"></A><A NAME="ch05index549"></A></P>
<P class="docText">Advantages to defining multiple tables to a segmented table space are as follows:</P>
<UL><LI><P class="docList">There are fewer open data sets, causing less system overhead.</P></LI><LI><P class="docList">There are fewer executions of the <TT>COPY</TT>, <TT>REORG</TT>, and <TT>RECOVER</TT> utilities per application system because these utilities are executed at the table space level.</P></LI><LI><P class="docList">It is easier to group like tables for administrative tasks because the tables reside in the same physical table space.</P></LI></UL>
<P class="docText">Disadvantages to defining multiple tables to a segmented table space are as follows:</P>
<UL><LI><P class="docList">When only one table needs to be reorganized, all must be <TT>REORG</TT>ed because they coexist in a single data set or group of data sets.</P></LI><LI><P class="docList">If compression is used the compression ratio will be impacted by multiple tables instead of being optimized for the data patterns of a single table.</P></LI><LI><P class="docList">The <TT>LOAD REPLACE</TT> utility will replace all data for all tables defined to the table space.</P></LI><LI><P class="docList">There may be confusion about which tables are in which table spaces, making monitoring and administration difficult.</P></LI></UL>
<P class="docText">As a very rough general guideline, define small- to medium-size tables (less than 1 million pages) to a single, segmented table space. Create a partitioned table space for each large table (more than 1 million pages). If you decide to group tables in a segmented table space, group only small tables (less than 32 pages). Provide a series of segmented table spaces per application such that tables in the ranges defined in the following chart are grouped together. This will save space. Avoid grouping larger tables (more than 32 pages) with other tables.</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="groups" CELLPADDING="5"><COLGROUP><COL width="214.5"><COL width="335.5"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Number of Pages</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Table Space Segment Size</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">1 to 4</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">5 to 8</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">8</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">9 to 12</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">12</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">12 to 16</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">16</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">17 to 20</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">20</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">21 to 24</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">24</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">25 to 28</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">28</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">29 to 32</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">32</P></TD></TR></TABLE></P><br>
<P class="docText">When the table space contains tables with the number of pages in the range on the left, assign the <TT>SEGSIZE</TT> indicated on the right to the table space.</P>
<P class="docText">When considering whether to place more than one table in a segmented table space, keep in mind that such a strategy is more preferable for static data than for rapidly changing data. This is so because there will be fewer requirements for running utilities against static data—and remember, DB2 utilities are run against table spaces.<A NAME="ch05index550"></A><A NAME="ch05index551"></A><A NAME="ch05index552"></A><A NAME="ch05index553"></A></P>
<A NAME="ch05lev4sec22"></A><H5 class="docSection4Title">Multi-Table Code and Reference Table Spaces</H5>
<P class="docText">Consider placing your code and reference tables into multi-table segmented table spaces. Code and reference tables are likely to be static and frequently used by many programs. It is also plausible that a single application could have numerous code and reference tables. Placing multiple code and references tables into a single tablespace will reduce the number of open data sets required.<A NAME="ch05index554"></A><A NAME="ch05index555"></A><A NAME="ch05index556"></A><A NAME="ch05index557"></A><A NAME="ch05index558"></A><A NAME="ch05index559"></A></P>
<A NAME="ch05lev4sec23"></A><H5 class="docSection4Title">Multi-Table Table Spaces and RI</H5>
<P class="docText">Consider grouping tables related by referential integrity into a single, segmented table space. This is not always feasible, because the size and access criteria of the tables might not lend themselves to multi-table segmented table spaces. Grouping referentially related tables, however, simplifies your <TT>QUIESCE</TT> processing.<A NAME="ch05index560"></A><A NAME="ch05index561"></A><A NAME="ch05index562"></A></P>
<P class="docText">Actually, RI can be a good reason to avoid multi-table table spaces entirely. If unrelated tables are assigned to the same table space you can wind up having to recover data unnecessarily because of a referential constraint.</P>
<A NAME="ch05lev4sec24"></A><H5 class="docSection4Title">Multi-Table Table Spaces and DBD Growth</H5>
<P class="docText">Use caution when dropping and creating large numbers of tables in a single segmented table space, because over time, the DBD for the database containing the segmented table space will grow. There might be a high volume of tables being created and dropped in test environments, ad hoc environments, and any environment where end users have control over the creation and removal of DB2 tables.<A NAME="ch05index563"></A><A NAME="ch05index564"></A><A NAME="ch05index565"></A></P>
<P class="docText">Remember that a large DBD can affect storage and processing by consuming a large amount of EDM pool space.</P>
<A NAME="ch05lev2sec5"></A><H4 class="docSection2Title">General Table Space Guidelines</H4>
<P class="docText">As you create DB2 table spaces, refer to the following list of guidelines for proper table space creation and usage.</P>
<A NAME="ch05lev4sec25"></A><H5 class="docSection3Title">Use Proper Table Space Definitions</H5>
<P class="docText">Explicitly define table spaces. If a table space is not specified in the table creation statement, DB2 creates an implicit table space for new tables and sets all table space parameters to the default values. These values are unacceptable for most applications.<A NAME="ch05index566"></A></P>
<A NAME="ch05lev4sec26"></A><H5 class="docSection3Title">Favor Segmented Table Spaces</H5>
<P class="docText">In general, use segmented table spaces except as follows:<A NAME="ch05index567"></A><A NAME="ch05index568"></A></P>
<UL><LI><P class="docList">Use partitioned table spaces when you want to encourage parallelism. (Non-partitioned table spaces can be accessed in parallel, but partitioned table spaces are preferred for performance and data set placement reasons.)</P></LI><LI><P class="docList">Use partitioned table spaces when the amount of data to be stored is very large (more than several million pages).</P></LI><LI><P class="docList">Use partitioned table spaces to reduce utility processing time and decrease contention</P></LI><LI><P class="docList">Use partitioned table spaces to isolate specific data areas in dedicated data sets.</P></LI><LI><P class="docList">Use partitioned table spaces to improve data availability. If the data is partitioned by region, the partitions for the eastern, southern, and northern regions can be made available while the western region partition is being reorganized.</P></LI><LI><P class="docList">Use partitioned table spaces to improve recoverability. If the data is partitioned by region and an error impacts data for the eastern region only, only the eastern partition needs to be recovered.</P></LI><LI><P class="docList">Use a simple table space <span class="docEmphasis">only</span> when you need to mix data from different tables on one page.</P></LI></UL>
<A NAME="ch05lev4sec27"></A><H5 class="docSection3Title">Consider More Frequent Partitioning</H5>
<P class="docText">To optimize query parallelism, it is wise to reevaluate your basic notions regarding partitioning. The common "rule of thumb" regarding whether to create a partitioned table space instead of a segmented table space was to use partitioning only for larger table spaces. This strategy is outdated.<A NAME="ch05index569"></A><A NAME="ch05index570"></A></P>
<P class="docText">Consider partitioning table spaces that are accessed in a read-only manner by long-running batch programs. Of course, very small table spaces are rarely viable candidates for partitioning, even with DB2's advanced I/O, CPU, and Sysplex parallelism features. This is true because the smaller the amount of data to access, the more difficult it is to break it into pieces large enough such that concurrent, parallel processing will be helpful.</P>
<A NAME="ch05lev4sec28"></A><H5 class="docSection3Title">Place Partitions on Separate DASD Devices</H5>
<P class="docText">Move each partition of the same partitioned table space to separate DASD volumes. Failure to do so will negatively affect the performance of query parallelism performed against those partitions. Disk drive head contention will occur because concurrent access is being performed on separate partitions that coexist on the same device.<A NAME="ch05index571"></A><A NAME="ch05index572"></A><A NAME="ch05index573"></A><A NAME="ch05index574"></A></P>
<A NAME="ch05lev4sec29"></A><H5 class="docSection3Title">Consider Single Table Space Databases</H5>
<P class="docText">For larger table spaces (100K pages and more) that are very active, consider defining a single table space per database. This can reduce contention. To increase efficiency, assign very active table spaces to volumes with low activity.<A NAME="ch05index575"></A><A NAME="ch05index576"></A></P>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch05lev1sec2.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch05lev1sec4.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
