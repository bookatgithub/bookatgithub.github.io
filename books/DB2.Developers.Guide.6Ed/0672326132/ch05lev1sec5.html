<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Table Guidelines</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch05lev1sec4.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch05lev1sec6.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch05lev1sec5"></A><H3 class="docSection1Title">Table Guidelines</H3>
<P class="docText">The table is the basic unit of data that is accessible when using SQL. Data is inserted to, deleted from, and updated within DB2 tables. Once populated, data can be selected from a DB2 table. Basically, the table is the means by which end users gain access to DB2 data.</P>
<P class="docText">In general, you will define one table for each entity for which you will be storing data. A table can be thought of as a grouping of attributes that identify a physical entity. The table name should conform to the entity name. For example, consider the sample table for employees, <TT>DSN8810.EMP</TT>. <TT>EMP</TT> is the name of the table that represents an entity known as "employee." An employee has many attributes, some of which are <TT>EMPNO</TT>, <TT>FIRSTNME</TT>, and <TT>LASTNME</TT>. These attributes are columns of the table.</P>
<P class="docText">When you create one table for each entity, the tables are easy to identify and use because they represent real-world "things."</P>
<P class="docText">Of course, at times, the simple rule of one "physical" table per "logical" entity will need to be broken. This usually occurs when you need to denormalize for performance reasons. More details on are provided later in this chapter in the section "<A class="docLink" HREF="ch05lev1sec6.html#ch05lev2sec14">Denormalization</A>."</P>
<A NAME="ch05lev2sec9"></A><H4 class="docSection2Title">DB2 Table Parameters</H4>
<P class="docText">The preceding section concentrated on the rows and columns of a DB2 table. Other parameters also must be considered when creating DB2 tables. This section provides guidelines to assist you in your table creation endeavors.<A NAME="ch05index628"></A><A NAME="ch05index629"></A></P>
<A NAME="ch05lev3sec26"></A><H5 class="docSection3Title">Encoding Scheme</H5>
<P class="docText">The <TT>CCSID</TT> parameter can be used to specify <TT>ASCII</TT>, <TT>EBCDIC</TT>, or <TT>UNICODE</TT> encoding at the table level as well as at the table space level. All data stored within a table space must use the same encoding scheme. Any indexes defined for tables in the table space will have the same encoding scheme as the table space.<A NAME="ch05index630"></A><A NAME="ch05index631"></A><A NAME="ch05index632"></A><A NAME="ch05index633"></A><A NAME="ch05index634"></A><A NAME="ch05index635"></A><A NAME="ch05index636"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><P class="docText"> Support for Unicode is new as of DB2 Version 7.</P></td></tr></table><br>
<A NAME="ch05lev3sec27"></A><H5 class="docSection3Title"><TT>DROP</TT> Restriction</H5>
<P class="docText">To prohibit inadvertent table drops, use the <TT>WITH RESTRICT ON DROP</TT> clause of the <TT>CREATE TABLE</TT> statement. When <TT>WITH RESTRICT ON DROP</TT> is specified, drops cannot be issued for the table, its table space, and its database. To subsequently drop the table, it must first be altered to remove the <TT>RESTRICT ON DROP</TT> specification.<A NAME="ch05index637"></A><A NAME="ch05index638"></A><A NAME="ch05index639"></A><A NAME="ch05index640"></A><A NAME="ch05index641"></A></P>
<A NAME="ch05lev3sec28"></A><H5 class="docSection3Title">DB2-Enforced Table Auditing</H5>
<P class="docText">If you must audit user access to DB2 tables, you can specify an audit rule for your tables. Although the auditing features of DB2 are rudimentary, sometimes they are useful. DB2 has three table audit options: <TT>NONE</TT>, <TT>CHANGES</TT>, and <TT>ALL</TT>.<A NAME="ch05index642"></A><A NAME="ch05index643"></A></P>
<P class="docText">DB2 table auditing is done on a unit-of-work basis only. DB2 audits only the first table access of any particular type for each unit of work, not every table access. <TT>AUDIT CHANGES</TT> writes an audit trace record for the first insert, update, and delete made by each unit of work. <TT>AUDIT ALL</TT> writes an audit trace record for the first select, insert, update, and delete made by each unit of work. By specifying <TT>AUDIT NONE</TT> or by failing to code an audit parameter, table auditing is inactivated.<A NAME="ch05index644"></A><A NAME="ch05index645"></A><A NAME="ch05index646"></A><A NAME="ch05index647"></A><A NAME="ch05index648"></A><A NAME="ch05index649"></A><A NAME="ch05index650"></A><A NAME="ch05index651"></A><A NAME="ch05index652"></A><A NAME="ch05index653"></A><A NAME="ch05index654"></A><A NAME="ch05index655"></A></P>
<P class="docText">Before deciding to audit DB2 table access, consider that table auditing incurs overhead—each time a table is accessed in a new unit of work, an audit trace record is written. Additionally, even if auditing has been specified for a given table, no audit trace records are written unless the appropriate DB2 audit trace classes are activated. For <TT>AUDIT CHANGES</TT>, activate audit trace classes 1, 2, 3, 4, 7, and 8. For <TT>AUDIT ALL</TT>, activate audit trace classes 1 through 8.</P>
<A NAME="ch05note25"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Keep in mind that the <TT>ALTER TABLE</TT> statement itself is audited only if <TT>AUDIT CHANGES</TT> or <TT>AUDIT ALL</TT> is specified and the appropriate audit trace class has been activated.</P></div><br>
<P class="docText">In general, to alleviate overhead, do not audit table access unless your application absolutely requires it.</P>
<A NAME="ch05lev3sec29"></A><H5 class="docSection3Title">Specifying Your Own <TT>OBID</TT></H5>
<P class="docText">You can use the <TT>OBID</TT> parameter to explicitly specify a particular <TT>OBID</TT> (object identifier) for DB2 to use for the table being created. An <TT>OBID</TT> is an identifier assigned by DB2 for its own internal use and identification purposes.<A NAME="ch05index656"></A><A NAME="ch05index657"></A><A NAME="ch05index658"></A><A NAME="ch05index659"></A><A NAME="ch05index660"></A><A NAME="ch05index661"></A></P>
<P class="docText">You might choose to specify an <TT>OBID</TT> if you are re-creating a table that used to exist and you wish to keep the previous <TT>OBID</TT> that was assigned to the table. For example, if you are dropping a table but will be re-creating it with changes you may wish to keep the previous <TT>OBID</TT> for that table.</P>
<P class="docText">To obtain the current <TT>OBID</TT> of any table you can query the DB2 Catalog as follows (supplying the <TT>CREATOR</TT> and <TT>NAME</TT> of the table for the question marks in the query):</P>
<pre>

</pre><BR><pre>
SELECT  OBID
FROM    SYSIBM.SYSTABLES
WHERE   CREATOR = ?
AND     NAME = ?;
</pre><BR>
<P class="docText">You cannot use the <TT>OBID</TT> parameter to assign an <TT>OBID</TT> to a table that is already assigned to an existing DB2 table.</P>
<A NAME="ch05lev3sec30"></A><H5 class="docSection3Title">Augmenting the Log with Changed Information</H5>
<P class="docText">If you are using a data propagation technology such as IBM's DataPropagator product, you may have to use the <TT>DATA CAPTURE</TT> parameter to augment the information captured on the DB2 log.<A NAME="ch05index662"></A><A NAME="ch05index663"></A><A NAME="ch05index664"></A><A NAME="ch05index665"></A><A NAME="ch05index666"></A><A NAME="ch05index667"></A><A NAME="ch05index668"></A></P>
<P class="docText">There are two options for <TT>DATA CAPTURE</TT>, <TT>NONE</TT>, and <TT>CHANGES</TT>. <TT>DATA CAPTURE NONE</TT>, which is the default, specifies that no additional information is to be recorded on the DB2 log. <TT>DATA</TT> <TT>CAPTURE CHANGES</TT>, however, will cause DB2 to write additional information about inserted, updated, and deleted data. When a data propagation tool uses the DB2 log to capture changed information this additional data may be required to ensure the validity of the propagated data.</P>
<A NAME="ch05note26"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText"><TT>DATA CAPTURE CHANGES</TT> will not capture additional information for LOB columns.</P></div><br>
<A NAME="ch05lev2sec10"></A><H4 class="docSection2Title">Temporary Tables</H4>
<P class="docText">Most DB2 tables are permanent, meaning that once created, they exist until an authorized user drops them. At times, though, you may need to create DB2 tables that exist only for the duration of a program run. Such a table is known as a temporary table.<A NAME="ch05index669"></A><A NAME="ch05index670"></A></P>
<P class="docText">DB2 has provided the capability to create temporary tables since Version 5. But the initial functionality was practical only in certain circumstances due to some inherent limitations. This first type of temporary table is known as a created (or global) temporary table.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><P class="docText"> IBM's support of temporary tables was expanded as of Version 7. Now DB2 offers two different types of temporary tables: created and declared.</P></td></tr></table><br>
<A NAME="ch05lev3sec31"></A><H5 class="docSection3Title">Why Use Temporary Tables?</H5>
<P class="docText">Before we investigate these two types of temporary tables, let's first address why anyone would want or need to use a temporary table in the first place.</P>
<P class="docText">One potential use of temporary tables is to store intermediate SQL results during a program run. Consider, for example, if the results of a first query need to be used in a subsequent query. Instead of rerunning the first query (or combining it with the subsequent query), the results of the first query can be stored in a temporary table. Then the temporary table can be joined into the second query without incurring the overhead of rerunning the first query. This is particularly useful if the first query is particularly complex or inefficient.<A NAME="ch05index671"></A><A NAME="ch05index672"></A></P>
<P class="docText">Or what about result sets that need to be returned more than once by the same program? Consider this scenario: A complex multi-table join is coded that consumes a lot of resources to run. Furthermore, that join statement needs to be run three times during the course of the program. Instead of running the join three times you can run it once and populate a temporary table with the results. The next two times you can simply read the temporary table which might be more efficient than re-executing the complex, resource-consuming multi-table join.</P>
<P class="docText">Temporary tables also are useful for enabling non-relational data to be processed using SQL. For example, you can create a global temporary table that is populated with IMS data (or any other non-relational data source) by a program. Then during the course of that program, the temporary table containing the IMS data can be accessed by SQL statements and even joined to other DB2 tables. The same could be done for data from a flat file, VSAM, IDMS, or any other non-relational data.</P>
<P class="docText">Another reason for IBM's inclusion of temporary table support in DB2 is to make conversion from other relational products easier. Microsoft SQL Server and Oracle both have supported temporary tables for quite some time now. Without such support in DB2 it was very difficult for developers to convert or port their Oracle or SQL Server applications to DB2. IBM alleviated this problem by enabling temporary table support in DB2.</P>
<P class="docText">Now let's examine the two types of temporary tables supported by DB2.<A NAME="ch05index673"></A><A NAME="ch05index674"></A></P>
<A NAME="ch05lev3sec32"></A><H5 class="docSection3Title">Created Temporary Tables</H5>
<P class="docText">A created temporary table exists only as long as the process that uses it. Temporary tables are created using the <TT>CREATE GLOBAL TEMPORARY TABLE</TT> statement. When created, the schema for the table is stored in the DB2 system catalog (<TT>SYSIBM.SYSTABLES</TT>) just like any other table, but the <TT>TYPE</TT> column is set to <TT>'G'</TT> to indicate a global temporary table. Created temporary tables are sometimes referred to as global temporary tables, but this is confusing since declared temporary tables are also referred to as global when they are created.<A NAME="ch05index675"></A><A NAME="ch05index676"></A><A NAME="ch05index677"></A><A NAME="ch05index678"></A><A NAME="ch05index679"></A></P>
<P class="docText">It is important to remember that a created global temporary table must be created using a DDL <TT>CREATE</TT> statement before it can be used in any program.</P>
<P class="docText">A created temporary table is instantiated when it is referenced in an <TT>OPEN</TT>, <TT>SELECT INTO</TT>, <TT>INSERT</TT>, or <TT>DELETE</TT> statement, not when it is created. Each application process that uses the temporary table creates a new instance of the table for its use. When using a temporary table, keep the following in mind:</P>
<UL><LI><P class="docList">Because they are not persistent, locking, logging, and recovery do not apply to temporary tables.</P></LI><LI><P class="docList">Indexes cannot be created on temporary tables, so all access is by a complete table scan.</P></LI><LI><P class="docList">Constraints cannot be created on temporary tables.</P></LI><LI><P class="docList">A null is the only default value permitted for columns of a temporary table.</P></LI><LI><P class="docList">Temporary tables cannot be referenced by DB2 utilities.</P></LI><LI><P class="docList">Temporary tables cannot be specified as the object of an <TT>UPDATE</TT> statement.</P></LI><LI><P class="docList">When deleting from a temporary table, all rows must be deleted.</P></LI><LI><P class="docList">Although views can be created on temporary tables, the <TT>WITH CHECK OPTION</TT> cannot be specified.</P></LI></UL>
<P class="docText">Work file data sets are used to manage the data of created temporary tables. The work database (<TT>DSNDB07</TT>) is used as storage for processing SQL statements that require working storage—not just for created temporary tables. If you are using created temporary tables, be sure to examine the DB2 Installation Guide for tactics to estimate the disk storage required for temporary work files.</P>
<P class="docText">When a temporary work file result table is populated using an <TT>INSERT</TT> statement, it uses work file space. No other process can use the same work file space as that temporary work file table until the table goes away. The space is reclaimed when the application process commits or rolls back, or when it is deallocated, depending on which <TT>RELEASE</TT> option was used when the plan or package was bound. It is a good idea to keep the work files in a separate buffer pool to make it easier to monitor. <TT>IFCID 0311</TT> in performance trace class 8 can be used to distinguish these tables from other uses of the work file.<A NAME="ch05index680"></A><A NAME="ch05index681"></A><A NAME="ch05index682"></A></P>
<A NAME="ch05lev3sec33"></A><H5 class="docSection3Title">Declared Temporary Tables</H5>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><P class="docText"> DB2 Version 7 introduces declared temporary tables. Actually, to be more accurate, declared temporary tables were made available in the intermediate DB2 Version 6 refresh.<A NAME="ch05index683"></A><A NAME="ch05index684"></A><A NAME="ch05index685"></A></P></td></tr></table><br>
<P class="docText">This new type of temporary table is different from a created temporary table and overcomes many of their limitations. The first significant difference between declared and created temporary tables is that declared temporary tables are specified using a <TT>DECLARE</TT> statement in an application program—and not using a DDL <TT>CREATE</TT> statement. Because they are not persistent they do not have descriptions in the DB2 Catalog.</P>
<P class="docText">Additionally, declared temporary tables offer significant features and functionality not provided by created temporary tables. Consider<A NAME="ch05index686"></A><A NAME="ch05index687"></A></P>
<UL><LI><P class="docList">Declared temporary tables can have indexes and <TT>CHECK</TT> constraints defined on them.</P></LI><LI><P class="docList">You can issue <TT>UPDATE</TT> statements and positioned <TT>DELETE</TT> statements against a declared temporary table.</P></LI><LI><P class="docList">You can implicitly define the columns of a declared temporary table and use the result table from a <TT>SELECT</TT>.</P></LI></UL>
<P class="docText">So, declared temporary tables offer much more flexibility and functionality than created temporary tables. To "create" an instance of a declared temporary table, you must issue the <TT>DECLARE GLOBAL TEMPORARY TABLE</TT> statement inside of an application program. That instance of the declared temporary table is known only to the process that issues the <TT>DECLARE</TT> statement. Multiple concurrent programs can be executed using the same declared temporary table name because each program will have its own copy of the temporary table.<A NAME="ch05index688"></A><A NAME="ch05index689"></A></P>
<P class="docText">But there is more work required to use a declared temporary table than there is to use a created temporary table. Before you can declare temporary tables you must create a temporary database and table spaces for them to use. This is accomplished by specifying the <TT>AS TEMP</TT> clause on a <TT>CREATE DATABASE</TT> statement. Then, you must create segmented table spaces in the temporary database. Only one temporary database for declared temporary tables is permitted per DB2 subsystem.</P>
<A NAME="ch05note27"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Everyone has the <TT>CREATETAB</TT> privilege in the temporary database by default—and you cannot <TT>REVOKE</TT> this privilege. It is implicitly granted when the temporary database is created.</P></div><br>
<P class="docText">When a <TT>DECLARE GLOBAL TEMPORARY TABLE</TT> statement is issued, DB2 will create an empty instance of the temporary table in the temporary table space. <TT>INSERT</TT> statements are used to populate the temporary table. Once inserted, the data can be accessed, modified, or deleted. When the program completes, DB2 will drop the instance of the temporary table. Also, be aware that users of temporary tables must have been granted <TT>USE</TT> authority on the temporary table space.<A NAME="ch05index690"></A><A NAME="ch05index691"></A><A NAME="ch05index692"></A></P>
<P class="docText">The following example shows a <TT>DECLARE</TT> statement that can be issued from an application program (assuming the temporary database and table spaces already have been defined):</P>
<pre>

</pre><BR><pre>
DECLARE GLOBAL TEMPORARY TABLE TEMP_EMP
  (EMPNO      CHAR(6)     NOT NULL,
   FIRSTNME   VARCHAR(12) NOT NULL,
   MIDINIT    CHAR(1)     NOT NULL,
   LASTNAME   VARCHAR(15) NOT NULL,
   WORKDEPT   CHAR(3),
   PHONENO    CHAR(4)
  );
</pre><BR>
<P class="docText">This creates a declared temporary table named <TT>TEMP_EMP</TT>. Additionally, you can use the <TT>LIKE</TT> clause to <TT>DECLARE</TT> a temporary table that uses the same schema definition as another currently existing table. You can use the <TT>INCLUDING IDENTITY COLUMN ATTRIBUTES</TT> clause to copy the <TT>IDENTITY</TT> columns as well. For example:</P>
<pre>

</pre><BR><pre>
DECLARE GLOBAL TEMPORARY TABLE TEMP_PROJ
 LIKE DSN8810.PROJ
 INCLUDING IDENTITY
 ON COMMIT PRESERVE ROWS;
</pre><BR>
<P class="docText">This example shows how to use the <TT>INCLUDING IDENTITY</TT> clause. However, the sample table <TT>DSN8810.PROJ</TT> does not use an <TT>IDENTITY</TT> column, so this statement would not work—it is shown as an example only. Identity columns are covered later in this chapter in the section titled "<A class="docLink" HREF="#ch05lev3sec36">Sequence Objects and Identity Columns</A>."</P>
<P class="docText">Notice also the <TT>ON COMMIT PRESERVE ROWS</TT> clause in the previous example. The <TT>ON COMMIT</TT> clause specifies what action DB2 is to take with the data in the declared temporary table when the program issues a <TT>COMMIT</TT> statement. There are two options: <TT>PRESERVE</TT> or <TT>DELETE</TT> rows. Specifying <TT>PRESERVE ROWS</TT> indicates that the rows of the table are to be kept. Beware, though, that the <TT>PRESERVE ROWS</TT> option impacts thread reuse. You will not be able to reuse threads for any application process that contains, at its most recent <TT>COMMIT</TT>, an active declared temporary table defined using the <TT>PRESERVE ROWS</TT> option of the <TT>ON COMMIT</TT> clause. The other option, which is the default, is <TT>ON COMMIT DELETE ROWS</TT>. In that case all of the rows of the table are deleted as long as there are no cursors defined using <TT>WITH HOLD</TT>.<A NAME="ch05index693"></A><A NAME="ch05index694"></A><A NAME="ch05index695"></A><A NAME="ch05index696"></A><A NAME="ch05index697"></A></P>
<A NAME="ch05note28"></A><div class="docNote"><p class="docNoteTitle">NOTE</p><p><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" ALIGN="LEFT" width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><P class="docText">Scrollable cursors, another new feature of DB2 V7, require declared temporary tables. A scrollable cursor provides the ability to scroll forward and backward through the data once the cursor is open.<A NAME="ch05index698"></A><A NAME="ch05index699"></A><A NAME="ch05index700"></A><A NAME="ch05index701"></A><A NAME="ch05index702"></A></P><P class="docText">The data from a scrollable cursor is maintained in a declared temporary table. DB2 uses this mechanism to facilitate scrolling through data in multiple ways—forward, backward, or to a specific position.</P><P class="docText">So, keep in mind, even if you do not choose to use temporary tables in your application programs, you may need to implement them to support scrollable cursors.</P></td></tr></table></p></div><br>
<A NAME="ch05lev4sec34"></A><H5 class="docSection4Title">Declared Temporary Table Storage</H5>
<P class="docText">Before using declared temporary tables, the temporary database and temporary table spaces must be defined to store the temporary data. For example,<A NAME="ch05index703"></A><A NAME="ch05index704"></A><A NAME="ch05index705"></A><A NAME="ch05index706"></A></P>
<pre>

</pre><BR><pre>
CREATE DATABASE TEMPDB AS TEMP;

CREATE TABLESPACE TEMPTS
 IN TEMPDB
 SEGSIZE 4
 BUFFERPOOL BP7;
</pre><BR>
<P class="docText">The table space is created as a temporary table space by virtue of it being in the temporary database.</P>
<P class="docText">The page size of the temporary table space must be large enough to hold the longest row in the declared temporary table. The size of a row in the declared temporary table might be considerably larger than the size of the row in the table for which the scrollable cursor is used. As with a regular table, the size of the row depends on the number of columns that are stored in the declared temporary table and the size of each column.</P>
<P class="docText">Consider creating a temporary table space for every page size. The buffer pool assignment determines the page size.</P>
<P class="docText">An in-depth discussion of calculating the storage requirements for a temporary table space for a declared temporary table is provided in the <span class="docEmphasis">DB2 Installation Guide</span>. Be sure to refer to that manual before implementing declared temporary tables or any features that rely on declared temporary tables (for example, scrollable cursors).<A NAME="ch05index707"></A><A NAME="ch05index708"></A><A NAME="ch05index709"></A><A NAME="ch05index710"></A></P>
<A NAME="ch05note29"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Keep in mind that when there is more than one temporary table space defined to the DB2 subsystem, DB2 will select which temporary table spaces it will use for scrollable cursor processing. More information on scrollable cursors is provided in <A class="docLink" HREF="ch11.html#ch11">Chapter 11</A>, "Using DB2 in an Application Program."</P></div><br>
<A NAME="ch05lev3sec34"></A><H5 class="docSection3Title">Temporary Table Guidelines</H5>
<P class="docText">The following guidelines are provided for your assistance as you implement temporary tables for your DB2 applications.</P>
<A NAME="ch05lev4sec35"></A><H5 class="docSection4Title">Favor Declared Temporary Tables</H5>
<P class="docText">For applications that require temporary tables, favor declared temporary tables over created temporary tables. Declared temporary tables are more flexible and functional than created temporary tables.<A NAME="ch05index711"></A><A NAME="ch05index712"></A><A NAME="ch05index713"></A></P>
<P class="docText">When using declared temporary tables you can index them, define <TT>CHECK</TT> constraints for them, and issue <TT>UPDATE</TT> statements and positioned <TT>DELETE</TT> statements against them, none of which can be done using created temporary tables.</P>
<A NAME="ch05lev4sec36"></A><H5 class="docSection4Title">When to Consider Created Temporary Tables</H5>
<P class="docText">With all of the limitations of created temporary tables why would anyone still want to use them instead of declared temporary tables?<A NAME="ch05index714"></A><A NAME="ch05index715"></A><A NAME="ch05index716"></A></P>
<P class="docText">Well, there are a few potential problems with declared temporary tables, too. First of all, the DB2 Catalog (<TT>SYSIBM.SYSPACKDEP</TT>) will not show dependencies for declared temporary tables, but it will for created temporary tables. Second, some DBAs are leery of allowing database structures to be created by application programmers inside of an application programmer. With limited DDL and database design knowledge it may not be wise to trust programmers to get the table structure correct. Furthermore, the additional management of the temporary database and table spaces can become an administrative burden.</P>
<P class="docText">So, created temporary tables are still useful—in the right situations. They should be considered primarily when no updating of temporary data is needed and access to the temporary data is purely sequential.</P>
<A NAME="ch05lev4sec37"></A><H5 class="docSection4Title">Use Temporary Tables with Stored Procedures</H5>
<P class="docText">Temporary tables are most useful when a large result set must be returned from a stored procedure. Refer to <A class="docLink" HREF="ch15.html#ch15">Chapter 15</A>, "Using DB2 Stored Procedures," for in-depth guidelines on using stored procedures.<A NAME="ch05index717"></A><A NAME="ch05index718"></A><A NAME="ch05index719"></A><A NAME="ch05index720"></A></P>
<A NAME="ch05lev4sec38"></A><H5 class="docSection4Title">Use SQL to Access Non-Relational Data</H5>
<P class="docText">Temporary tables are useful for enabling non-relational data to be processed using SQL. For example, you can create a temporary table (global or created) and then populate it with IMS data in your application program. Then, during the course of that program, the temporary table containing the IMS data can be accessed by SQL statements and even joined to other DB2 tables.<A NAME="ch05index721"></A><A NAME="ch05index722"></A></P>
<A NAME="ch05lev2sec11"></A><H4 class="docSection2Title">General Table Guidelines</H4>
<P class="docText">The following guidelines provide helpful hints for you to follow as you implement and manage tables within your DB2 applications and systems.</P>
<A NAME="ch05lev4sec39"></A><H5 class="docSection3Title">Use <TT>LIKE</TT> to Duplicate a Table's Schema</H5>
<P class="docText">Use the <TT>LIKE</TT> clause to create a table with the same columns as another table. The following SQL creates a new table <TT>OLD_PROJ</TT> using the <TT>PROJ</TT> table as a template:<A NAME="ch05index723"></A><A NAME="ch05index724"></A><A NAME="ch05index725"></A><A NAME="ch05index726"></A></P>
<pre>

</pre><BR><pre>
CREATE TABLE DSN8810.OLD_PROJ
LIKE DSN8810.PROJ
IN <span class="docEmphasis">db.ts</span>;
</pre><BR>
<P class="docText">The <TT>LIKE</TT> clause is particularly useful in the following instances:</P>
<UL><LI><P class="docList">When creating exception tables required by the <TT>CHECK</TT> utility</P></LI><LI><P class="docList">When multiple instances of a similar table must be created</P></LI><LI><P class="docList">When creating a <TT>PLAN_TABLE</TT></P></LI><LI><P class="docList">When creating the same table for multiple users</P></LI></UL>
<A NAME="ch05lev4sec40"></A><H5 class="docSection3Title">Consider Using Comments</H5>
<P class="docText">Consider using the <TT>COMMENT ON</TT> statement to document the entities you create. For V7 and previous releases, as many as 254 characters of descriptive text can be applied to each column, table, alias, index, distinct type, procedure, sequence, trigger, and UDF known to DB2. The maximum size of a comment is increased to 762 characters as of DB2 V8. The comment text is stored in a column named <TT>REMARKS</TT> in the appropriate DB2 Catalog table as follows:<A NAME="ch05index727"></A><A NAME="ch05index728"></A><A NAME="ch05index729"></A><A NAME="ch05index730"></A></P>
<UL><LI><P class="docList"><TT>SYSIBM.SYSTABLES</TT> for aliases and tables</P></LI><LI><P class="docList"><TT>SYSIBM.SYSCOLUMNS</TT> for columns</P></LI><LI><P class="docList"><TT>SYSIBM.SYSINDEXES</TT> for indexes</P></LI><LI><P class="docList"><TT>SYSIBM.SYSSEQUENCES</TT> for sequences</P></LI><LI><P class="docList"><TT>SYSIBM.SYSTRIGGERS</TT> for triggers</P></LI><LI><P class="docList"><TT>SYSIBM.SYSDATATYPES</TT> for distinct types</P></LI><LI><P class="docList"><TT>SYSIBM.SYSROUTINES</TT> for stored procedures and UDFs</P></LI></UL>
<P class="docText">If useful descriptions are maintained for all columns and tables, the DB2 Catalog can function as a crude data dictionary for DB2 objects. However, be aware that comments are stored in a <TT>VARCHAR</TT> column in each of the preceding catalog tables.</P>
<A NAME="ch05note30"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">When comments are specified, the overall size of the DB2 Catalog will expand and might grow to be larger than expected. Weigh the benefits of added documentation against the impact on the DB2 Catalog before adding comments on all columns and tables.</P></div><br>
<A NAME="ch05lev4sec41"></A><H5 class="docSection3Title">Avoid Specifying Labels for Columns</H5>

<P class="docText">DB2 provides the capability to label columns of DB2 tables using the <TT>LABEL ON</TT> statement. This was useful at times prior to DB2 Version 8 because the maximum length for a column name was 18 characters; the maximum length of a column label was 30 characters.<A NAME="ch05index731"></A><A NAME="ch05index732"></A><A NAME="ch05index733"></A></P>
<P class="docText">The label is stored in the DB2 Catalog in the <TT>SYSIBM.SYSCOLUMNS</TT> tables. QMF users can specify that they want to use labels rather than column names, thereby providing better report headings.</P>
<P class="docText">However, as of DB2 V8 the maximum length of a column name is 128 characters and the maximum length of the label is 90 characters, negating the benefit of a "descriptive" column label.</P>
<A NAME="ch05note31"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Be aware that specifying column labels will add to the overall size of the DB2 Catalog, specifically to the <TT>SYSIBM.SYSCOLUMNS</TT> table. However, labels will not cause the same amount of growth as comments because labels have a maximum size of 30 characters as opposed to 254 for comments; or, as of DB2 V8, 90 characters as opposed to 762 for comments.</P></div><br>
<A NAME="ch05lev4sec42"></A><H5 class="docSection3Title">Changing the Name of a Table</H5>
<P class="docText">The <TT>RENAME</TT> statement enables DBAs to change the name of a DB2 table without dropping and re-creating the table. All table characteristics, data, and authorization is maintained. This feature is not available prior to DB2 Version 5.<A NAME="ch05index734"></A><A NAME="ch05index735"></A></P>
<A NAME="ch05lev4sec43"></A><H5 class="docSection3Title">Avoid Using the IN <TT>DATABASE</TT> Clause</H5>
<P class="docText">When creating tables do not use the <TT>IN DATABASE</TT> clause. When <TT>IN DATABASE</TT> is used, a simple table space is implicitly created in the specified database. This simple table space will use all of the default parameters—which, as we have already learned, are usually not optimal. Additionally, no other tables can be assigned to this table space.<A NAME="ch05index736"></A><A NAME="ch05index737"></A><A NAME="ch05index738"></A></P>
<P class="docText">Instead, explicitly create a table space (of the proper type for the data), and then create the table in that table space.</P>
<A NAME="ch05lev2sec12"></A><H4 class="docSection2Title">Rows and Columns</H4>
<P class="docText">When defining DB2 columns to a table you will need to choose a data type and perhaps a length for each column. Recall from <A class="docLink" HREF="ch01.html#ch01">Chapter 1</A>, "The Magic Words," that DB2 supports the following data types:<A NAME="ch05index739"></A><A NAME="ch05index740"></A><A NAME="ch05index741"></A><A NAME="ch05index742"></A></P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5"><COLGROUP><COL width="264"><COL width="209"><COL width="77"></COLGROUP><THEAD></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CHAR</TT></P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">fixed length alphanumeric data</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>VARCHAR</TT></P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">variable length alphanumeric data</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>GRAPHIC</TT></P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">fixed length graphical data</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>VARGRAPHIC</TT></P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">variable length graphical data</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SMALLINT</TT></P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">small integer numbers</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INTEGER</TT></P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">larger integer numbers</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DECIMAL(p,s)</TT></P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">numeric data</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>FLOAT(n)</TT> or <TT>FLOAT</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">single precision floating point</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">(if n&gt;21)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>FLOAT(n)</TT> or <TT>REAL</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">double precision floating point</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">(if n&lt;21)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DATE</TT></P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">calendar date data</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>TIME</TT></P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">time data</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>TIMESTAMP</TT></P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">combination date and time data</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>ROWID</TT></P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">unique row identifier (internally generated by DB2)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BLOB</TT></P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">binary large object</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CLOB</TT></P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">character large object</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DBCLOB</TT></P></TD><TD class="docTableCell" align="left" valign="top" colspan="2"><P class="docText">double byte character large object</P></TD></TR></TABLE></P><br>
<P class="docText">As you define your DB2 tables you also will have to worry about other factors and assign other characteristics to each column. For example,</P>
<UL><LI><P class="docList">When creating a table you will need to define each column and therefore will be required to specify the columns in an effective sequence.</P></LI><LI><P class="docList">Each column must be named.</P></LI><LI><P class="docList">Each column must be defined as nullable or unable to be assigned null.</P></LI><LI><P class="docList">Each column may be assigned a default value to use when data is inserted to a row but no value is provided for that particular column.</P></LI></UL>
<P class="docText">As you create DB2 tables, you should be mindful of their composition (rows and columns) and how this affects performance. This section outlines several guidelines that ensure efficient row and column specification.<A NAME="ch05index743"></A><A NAME="ch05index744"></A><A NAME="ch05index745"></A><A NAME="ch05index746"></A></P>
<A NAME="ch05lev3sec35"></A><H5 class="docSection3Title"><TT>ROWID</TT></H5>
<P class="docText">The <TT>ROWID</TT> data type is used to generate a unique value for every row in a table. The value is internally generated by DB2. A table can have only one <TT>ROWID</TT> column. The values in a <TT>ROWID</TT> column cannot be null.<A NAME="ch05index747"></A><A NAME="ch05index748"></A><A NAME="ch05index749"></A><A NAME="ch05index750"></A><A NAME="ch05index751"></A><A NAME="ch05index752"></A></P>
<P class="docText">An additional parameter, <TT>GENERATED</TT>, must be specified for a column defined as a <TT>ROWID</TT>. The <TT>GENERATED</TT> parameter is reserved for <TT>ROWID</TT> columns only (as of DB2 Version 6). It indicates that the values for the column are to be generated by DB2. There are two options for <TT>GENERATED</TT>, one of which must be supplied:<A NAME="ch05index753"></A><A NAME="ch05index754"></A></P>
<UL><LI><P class="docList">The <TT>ALWAYS</TT> parameter indicates that DB2 will always generate a value for the column when a row is inserted into the table. Most <TT>ROWID</TT> columns should be defined with this option.<A NAME="ch05index755"></A><A NAME="ch05index756"></A></P></LI><LI><P class="docList">The <TT>BY DEFAULT</TT> parameter indicates that DB2 will generate a value for the column when a row is inserted into the table unless a value is specified. The <TT>BY DEFAULT</TT> option can be useful if you are using data propagation to move <TT>ROWID</TT> values from one table to another. If you specify <TT>BY DEFAULT</TT>, the <TT>ROWID</TT> column must have a unique, single-column index. Until this index is created, you cannot add rows to the table regardless of whether you are using <TT>INSERT</TT> or <TT>LOAD</TT>.<A NAME="ch05index757"></A><A NAME="ch05index758"></A></P></LI></UL>
<A NAME="ch05note32"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">DB2 will use an explicitly specified value for a <TT>ROWID</TT> only if it is a valid <TT>ROWID</TT> value that was previously generated by DB2.</P></div><br>
<A NAME="ch05lev3sec36"></A><H5 class="docSection3Title">Sequence Objects and Identity Columns</H5>
<P class="docText">When designing database a frequent request is for a column to contain sequentially generated numbers. For example, each row has a counter associated with it. When a new row is inserted, the counter should be incremented by one for the new row. Until recently such a design was difficult to deliver.<A NAME="ch05index759"></A><A NAME="ch05index760"></A><A NAME="ch05index761"></A><A NAME="ch05index762"></A><A NAME="ch05index763"></A></P>
<P class="docText">Without sequence objects or identity columns an application program can implement similar functionality, but usually not in a manner that will perform adequately as a usage scale. One common technique is to maintain a one-row table that contains the sequence number. Each transaction locks that table, increments the number, and then commits to unlock the table. In this scenario only one transaction at a time can increment the sequence number. A variation uses something like this:</P>
<pre>

</pre><BR><pre>
SELECT MAX()+ 1
FROM   ONEROW_TABLE
WITH RR;
</pre><BR>
<P class="docText">The result is the next highest number to be used. This value is used by the application and <TT>ONEROW_TABLE</TT> must be updated with the incremented value. Performance bottlenecks will occur with this method when a lot of concurrent usage is required.</P>
<P class="docText">But now DB2 offers two methods of automatically generating sequential numbers for a column:</P>
<UL><LI><P class="docList">
<IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"> Identity columns.</P></LI><LI><P class="docList">
<IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"> <TT>SEQUENCE</TT> objects.</P></LI></UL>
<A NAME="ch05lev4sec44"></A><H5 class="docSection4Title">Identity Columns</H5>
<P class="docText">Identity columns were formally added to DB2 as of Version 7, but were also made available to DB2 Version 6 as a refresh. An identity column is defined to a DB2 column using the <TT>IDENTITY</TT> parameter. A column thusly defined will cause DB2 to automatically generate a unique, sequential value for that column when a row is added to the table. For example, identity columns might be used to generate unique primary key values or a value that somewhat mimics Oracle's row number capability. Using identity columns helps to avoid some of the concurrency and performance problems that can occur when application programs are used to populate sequential values for a "counter" column.<A NAME="ch05index764"></A><A NAME="ch05index765"></A><A NAME="ch05index766"></A></P>
<P class="docText">When inserting data into a table that uses an identity column, the program or user will not provide a value for the identity column. Instead, DB2 automatically generates the appropriate value to be inserted.</P>
<P class="docText">Only one identity column can be defined per DB2 table. Additionally, the data type of the column must be <TT>SMALLINT</TT>, <TT>INTEGER</TT>, or <TT>DECIMAL</TT> with a zero scale, that is <TT>DECIMAL(</TT><span class="docEmphasis"><TT>n</TT></span><TT>,0)</TT>. The data type also can be a user-defined <TT>DISTINCT</TT> type based on one of these numeric data types. The designer has control over the starting point for the generated sequential values, and the number by which the count is incremented.</P>
<P class="docText">An example of creating a table with an identity column follows:</P>
<pre>

</pre><BR><pre>
CREATE TABLE EXAMPLE
   (ID_COL INTEGER NOT NULL
           GENERATED ALWAYS AS IDENTITY
           START WITH 100
           INCREMENT BY 10
    ...);
</pre><BR>
<P class="docText">In this example, the identity column is named <TT>ID_COL</TT>. The first value stored in the column will be 100 and subsequent <TT>INSERT</TT>s will add 10 to the last value. So the identity column values generated will be 100, 110, 120, 130, and so on.</P>
<P class="docText">Note, too, that each identity column has a property associated with it assigned using the <TT>GENERATED</TT> parameter. This parameter indicates how DB2 generates values for the column. You must specify <TT>GENERATED</TT> if the column is to be considered an identity column or the data type of the column is a <TT>ROWID</TT>. This means that DB2 must be permitted to generate values for all identity columns. There are two options for the <TT>GENERATED</TT> parameter, <TT>ALWAYS</TT> and <TT>BY DEFAULT</TT>:<A NAME="ch05index767"></A><A NAME="ch05index768"></A></P>
<UL><LI><P class="docList"><TT>GENERATED ALWAYS</TT> indicates that DB2 will always generate a value for the column when a row is inserted into the table. You will usually specify <TT>ALWAYS</TT> for your identity columns unless you are using data propagation.</P></LI><LI><P class="docList"><TT>GENERATED BY DEFAULT</TT> indicates that DB2 will generate a value for the column when a row is inserted into the table unless a value is specified. So, if you want to be able to insert an explicit value into an identity column you must specify <TT>GENERATED BY DEFAULT</TT>.</P></LI></UL>
<P class="docText">Additionally, you can specify what to do when the maximum value is hit. Specifying the <TT>CYCLE</TT> keyword will cause DB2 to begin generating values from the minimum value all over again. Of course, this can cause duplicate values to be generated and should only be used when uniqueness is not a requirement.</P>
<P class="docText">Sometimes it is necessary to retrieve the value of an identity column immediately after it is inserted. For example, if you are using identity columns for primary key generation you may need to retrieve the value to provide the foreign key of a child table row that is to be inserted after the primary key is generated. The <TT>IDENTITY_VAL_LOCAL()</TT> function can be used to retrieve the value of an identity column after insertion. For example, run the following statement immediately after the <TT>INSERT</TT> statement that sets the identity value:<A NAME="ch05index769"></A><A NAME="ch05index770"></A><A NAME="ch05index771"></A><A NAME="ch05index772"></A></P>
<pre>

</pre><BR><pre>
VALUES IDENTITY_VAL_LOCAL() INTO :IVAR;
</pre><BR>
<P class="docText">The host variable <TT>IVAR</TT> will contain the value of the identity column.<A NAME="ch05index773"></A><A NAME="ch05index774"></A><A NAME="ch05index775"></A></P>
<A NAME="ch05lev4sec45"></A><H5 class="docSection4Title">Problems with Identity Columns</H5>
<P class="docText">Identity columns can be useful, depending on your specific needs, but the problems that accompany identity column are numerous. Some of these problems include<A NAME="ch05index776"></A><A NAME="ch05index777"></A><A NAME="ch05index778"></A></P>
<UL><LI><P class="docList">Handling the loading of data into a table with an identity column defined as <TT>GENERATED BY DEFAULT</TT>. The next identity value stored by DB2 to be assigned may not be the correct value that should be generated. This can be especially troublesome in a testing environment.</P></LI><LI><P class="docList"><TT>LOAD INTO PART x</TT> is not allowed if an identity column is part of the partitioning index.</P></LI><LI><P class="docList">What about environments that require regular loading and reloading (<TT>REPLACE</TT>) for testing? The identity column will not necessarily hold the same values for the same rows from test to test.</P></LI><LI><P class="docList">
<IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"> Prior to V8, it was not possible to change the <TT>GENERATED</TT> parameter (such as from <TT>GENERATED BY DEFAULT</TT> to <TT>GENERATED ALWAYS</TT>).</P></LI><LI><P class="docList">The <TT>IDENTITY_VAL_LOCAL()</TT> function returns the value used for the last insert to the identity column. But it only works after a singleton <TT>INSERT</TT>. This means you cannot use <TT>INSERT INTO SELECT FROM</TT> or <TT>LOAD</TT>, if you need to rely on this function.</P></LI><LI><P class="docList">When the maximum value is reached for the identity column, DB2 will cycle back to the beginning to begin reassigning values—which might not be the desired approach.</P></LI></UL>
<P class="docText">If you can live with these caveats, then identity columns might be useful to your applications. However, in general, these "problems" make identity columns a very niche solution. IBM has intentions to rectify some of these problems over time in upcoming versions of DB2.<A NAME="ch05index779"></A><A NAME="ch05index780"></A><A NAME="ch05index781"></A></P>
<A NAME="ch05lev4sec46"></A><H5 class="docSection4Title"><TT>SEQUENCE</TT> Objects</H5>
<P class="docText">Recall that DB2 has two methods of automatically generating sequential numbers. The first method is to define an identity column for the table; the second is to create a <TT>SEQUENCE</TT> object. A <TT>SEQUENCE</TT> object is a separate structure that generates sequential numbers.<A NAME="ch05index782"></A><A NAME="ch05index783"></A><A NAME="ch05index784"></A><A NAME="ch05index785"></A><A NAME="ch05index786"></A><A NAME="ch05index787"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> New to DB2 V8, a <TT>SEQUENCE</TT> is a database object specifically created to generate sequential values. So, using a <TT>SEQUENCE</TT> object requires the creation of a database object; using an identity column does not.</P></td></tr></table><br>
<P class="docText">A <TT>SEQUENCE</TT> objects is created using the <TT>CREATE SEQUENCE</TT> statement.</P>
<P class="docText">When the <TT>SEQUENCE</TT> object is created it can be used by applications to "grab" a next sequential value for use in a table. <TT>SEQUENCE</TT> objects are ideal for generating sequential, unique numeric key values. A sequence can be accessed and incremented by many applications concurrently without the hot spots and performance degradation associated with other methods of generating sequential values. <TT>SEQUENCE</TT> objects also can be used by more than one column in the same table.<A NAME="ch05index788"></A><A NAME="ch05index789"></A><A NAME="ch05index790"></A><A NAME="ch05index791"></A></P>
<P class="docText">Sequences are efficient and can be used by many users at the same time without causing performance problems. Multiple users can concurrently and efficiently access <TT>SEQUENCE</TT> objects because DB2 does not wait for a transaction to <TT>COMMIT</TT> before allowing the sequence to be incremented again by another transaction.<A NAME="ch05index792"></A><A NAME="ch05index793"></A><A NAME="ch05index794"></A><A NAME="ch05index795"></A><A NAME="ch05index796"></A></P>
<P class="docText">An example of creating a <TT>SEQUENCE</TT> object follows:</P>
<pre>

</pre><BR><pre>
CREATE SEQUENCE ACTNO_SEQ
   AS SMALLINT
   START WITH 1
   INCREMENT BY 1
   NOMAXVALUE
   NOCYCLE
   CACHE 10;
</pre><BR>
<P class="docText">This creates the <TT>SEQUENCE</TT> object named <TT>ACTNO_SEQ</TT>. Now it can be used to generate a new sequential value, for example</P>
<pre>

</pre><BR><pre>
INSERT INTO DSN8810.ACT
     (ACTNO, ACTKWD, ACTDESC)
   VALUES
     (NEXT VALUE FOR ACTNO_SEQ, 'TEST', 'Test activity');
</pre><BR>
<P class="docText">The <TT>NEXT VALUE FOR</TT> clause is known as a sequence expression. Coding the sequence expression causes DB2 to use the named <TT>SEQUENCE</TT> object to automatically generate the next value. You can use a sequence expression to request the previous value that was generated. For example,<A NAME="ch05index797"></A><A NAME="ch05index798"></A></P>
<pre>

</pre><BR><pre>
SELECT PREVIOUS VALUE FOR ACTNO_SEQ
INTO   :IVAR
FROM   DSN8810.ACT;
</pre><BR>
<P class="docText">As you can see, sequence expressions are not limited to <TT>INSERT</TT> statements, but can be used in <TT>UPDATE</TT> and <TT>SELECT</TT> statements, too.<A NAME="ch05index799"></A><A NAME="ch05index800"></A><A NAME="ch05index801"></A><A NAME="ch05index802"></A><A NAME="ch05index803"></A><A NAME="ch05index804"></A></P>
<A NAME="ch05note33"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">If you specify the <TT>NEXT VALUE FOR</TT> clause more than once in the same SQL statement, DB2 will return the same value for each <TT>NEXT VALUE FOR</TT> specification.</P></div><br>
<A NAME="ch05lev4sec47"></A><H5 class="docSection4Title"><TT>SEQUENCE</TT> Object Parameters</H5>
<P class="docText">Similar to identity columns, a <TT>SEQUENCE</TT> object has parameters to control the starting point for the generated sequential values, and the number by which the count is incremented. You can also specify the data type to be generated (the default is <TT>INTEGER</TT>). You can also specify a minimum value (<TT>MINVALUE</TT>) and a maximum value (<TT>MAXVALUE</TT>) if you wish to have further control over the values than is provided by the data type chosen.<A NAME="ch05index805"></A><A NAME="ch05index806"></A><A NAME="ch05index807"></A><A NAME="ch05index808"></A><A NAME="ch05index809"></A><A NAME="ch05index810"></A><A NAME="ch05index811"></A></P>
<P class="docText">Again, as with identity columns, you can specify how the <TT>SEQUENCE</TT> should handle running out of values when the maximum value is hit. Specifying the <TT>CYCLE</TT> keyword will cause the <TT>SEQUENCE</TT> object to wrap around and begin generating values from the minimum value all over again.</P>
<P class="docText">A final consideration for <TT>SEQUENCE</TT> objects is caching. Sequence values can be cached in memory to facilitate better performance. The size of the cache specifies the number of sequence values that DB2 will pre-allocate in memory. In the previous example <TT>CACHE 10</TT> indicates that ten sequence values will be generated and stored in memory for subsequent use. Of course, you can turn off caching by specifying <TT>NO CACHE</TT>. With caching turned off each new request for a sequence number will cause I/O to the DB2 Catalog (<TT>SYSIBM.SYSSEQUENCES</TT>) to generate the next sequential value.</P>
<A NAME="ch05lev4sec48"></A><H5 class="docSection4Title"><TT>SEQUENCE</TT> Object Guidelines</H5>
<P class="docText">DB2 does not wait for an application that has incremented a sequence to commit before allowing the sequence to be incremented again by another application. Applications can use one sequence for many tables, or create multiple sequences for use of each table requiring generated key values. In either case, the applications control the relationship between the sequences and the tables.</P>
<P class="docText">The name of the <TT>SEQUENCE</TT> object indicates that we are going to use it to generate activity numbers (<TT>ACTNO</TT>), but its usage is not limited to that. Of course, failure to control the use of a <TT>SEQUENCE</TT> object can result in gaps in the sequential values. For example, if we use the <TT>ACTNO_SEQ</TT> object to generate a number for a different column, the next time we use it for <TT>ACTNO</TT> there will be a gap where we generated that number.<A NAME="ch05index812"></A><A NAME="ch05index813"></A><A NAME="ch05index814"></A><A NAME="ch05index815"></A></P>
<P class="docText">Other scenarios can cause gaps in a <TT>SEQUENCE</TT>, too. For example, issuing a <TT>ROLLBACK</TT> after acquiring a sequence number will not roll back the value of the sequence generator—so that value is lost. A DB2 failure can also cause gaps because cached sequence values will be lost.</P>
<A NAME="ch05note34"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">When sequences were introduced in non-mainframe DB2, syntax was supported that did not conform to the SQL standard. This non-standard syntax is supported on the mainframe as well:</P>
<UL><LI><P class="docList"><TT>NEXTVAL</TT> can be used in place of <TT>NEXT VALUE</TT></P></LI><LI><P class="docList"><TT>PREVVAL</TT> can be used in place of <TT>PREVIOUS VALUE</TT></P></LI></UL></div><br>
<A NAME="ch05lev4sec49"></A><H5 class="docSection4Title">Choosing Between <TT>IDENTITY</TT> and <TT>SEQUENCE</TT></H5>
<P class="docText">Although both <TT>IDENTITY</TT> columns and <TT>SEQUENCE</TT> objects are useful for generating incremental numeric values, you will need to choose between the two. Consider the following criteria when choosing one over the other. <TT>IDENTITY</TT> columns are useful when<A NAME="ch05index816"></A><A NAME="ch05index817"></A><A NAME="ch05index818"></A><A NAME="ch05index819"></A><A NAME="ch05index820"></A><A NAME="ch05index821"></A></P>
<UL><LI><P class="docList">Only one column in a table requires automatically generated values.</P></LI><LI><P class="docList">Each row requires a separate value.</P></LI><LI><P class="docList">An automatic generator is desired for a primary key of a table.</P></LI><LI><P class="docList">The process of generating a new value is tied closely to inserting into a table, regardless of how the insert happens.</P></LI></UL>
<P class="docText"><TT>SEQUENCE</TT> objects are useful when</P>
<UL><LI><P class="docList">Values generated from one sequence are to be stored in more than one table.</P></LI><LI><P class="docList">More than one column per table requires automatically generated values (multiple values may be generated for each row using the same sequence or more than one sequence).</P></LI><LI><P class="docList">The process of generating a new value is independent of any reference to a table.</P></LI></UL>
<P class="docText">Unlike <TT>SEQUENCE</TT> objects, which are more flexible, <TT>IDENTITY</TT> columns must adhere to several rigid requirements. For example, an <TT>IDENTITY</TT> column is always defined on a single table, and each table can have at most one <TT>IDENTITY</TT> column. Furthermore, when you create an <TT>IDENTITY</TT> column, the data type for that column must be numeric—not so for sequences. If you used a <TT>SEQUENCE</TT> object to generate a value, you could put that generated value into a <TT>CHAR</TT> column, for example. Finally, when defining an <TT>IDENTITY</TT> column you cannot specify the <TT>DEFAULT</TT> clause, and the column is implicitly defined as <TT>NOT NULL</TT>. Remember, DB2 automatically generates the <TT>IDENTITY</TT> column's value, so default values and nulls are not useful concepts.<A NAME="ch05index822"></A><A NAME="ch05index823"></A><A NAME="ch05index824"></A><A NAME="ch05index825"></A><A NAME="ch05index826"></A><A NAME="ch05index827"></A></P>
<P class="docText">Consult <A class="docLink" HREF="#ch05table07">Table 5.7</A> for a summary comparison of <TT>SEQUENCE</TT> objects and <TT>IDENTITY</TT> column characteristics.</P>
<A NAME="ch05table07"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 5.7. <TT>IDENTITY</TT> Columns Versus <TT>SEQUENCE</TT> Objects</h5></CAPTION><COLGROUP><COL width="236.5"><COL width="313.5"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><TT>IDENTITY</TT> <span class="docEmphStrong">Columns</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><TT>SEQUENCE</TT> <span class="docEmphStrong">Objects</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Internal objects generated and maintained by DB2</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Standalone database objects created by a DBA</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Associated with a single table</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Not associated with a specific table; useable across tables</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Use <TT>IDENTITY_VAL_LOCAL()</TT> to get last value assigned</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Use <TT>PREVIOUS VALUE FOR </TT><span class="docEmphasis"><TT>seq-expr</TT></span> to get last value assigned</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">N/A</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Use <TT>NEXT VALUE FOR </TT><span class="docEmphasis"><TT>seq-expr</TT></span> to get next value to be assigned</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Add/change using <TT>ALTER TABLE ...ALTER COLUMN</TT> (<span class="docEmphasis">DB2 V8 only</span>)</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Administer using <TT>ALTER SEQUENCE</TT>, <TT>DROP</TT>, <TT>COMMENT</TT>, <TT>GRANT</TT>, and <TT>REVOKE</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Version 6 refresh; Version 7</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Version 8</P></TD></TR></TABLE></P><br>
<A NAME="ch05lev3sec37"></A><H5 class="docSection3Title">Row and Column Guidelines</H5>
<P class="docText">The following guidelines can be used to assist you as you design the row and column specifications of your DB2 tables.</P>
<A NAME="ch05lev4sec50"></A><H5 class="docSection4Title">Avoid Wasted Space</H5>
<P class="docText">If you do not use very large and very small row sizes, you can reduce the amount of space wasted by unuseable bytes on the pages of a table space. Keep these rules in mind:<A NAME="ch05index828"></A><A NAME="ch05index829"></A><A NAME="ch05index830"></A><A NAME="ch05index831"></A></P>
<UL><LI><P class="docList">A maximum of 255 rows can be stored on one table space page.</P></LI><LI><P class="docList">A row length larger than 4,056 will not fit on a 4KB page. You will need to choose one of the other allowable page sizes. Page sizes supported by DB2 include 4KB, 8KB, 16KB, and 32KB.</P></LI><LI><P class="docList">A row length less than 15 wastes space because no more than 255 rows can be stored on a DB2 page, regardless of the size of the row. For pre-V3 subsystems, a row length less than 31 bytes wastes space because the limit at that time was 127 rows per page.</P></LI><LI><P class="docList">A row length of 2,029 results in only one row per (4K) page because the second row will be too large to exist on the same page.</P></LI></UL>
<P class="docText">Determine row size carefully to avoid wasting space. If you can combine small tables or split large tables to avoid wasting a large amount of space, do so. It usually is impossible to avoid wasting some space, however.</P>
<A NAME="ch05lev4sec51"></A><H5 class="docSection4Title">Define All Appropriate Columns</H5>
<P class="docText">Be sure to apply normalization to your database design to arrive at the appropriate columns for each DB2 table. An introduction to normalization is forthcoming in a later section of this chapter.<A NAME="ch05index832"></A><A NAME="ch05index833"></A><A NAME="ch05index834"></A></P>
<P class="docText">Keep in mind, however, that the maximum number of columns that can be defined for a DB2 table is 750. If the table participates as a dependent to another table (referential integrity), then the maximum number of columns is reduced to 749.</P>
<P class="docText">For a table with more than 749 or 750 columns, you might need to break it into two tables, each with the same primary key, but with a different subset of the total number of columns.</P>
<A NAME="ch05lev4sec52"></A><H5 class="docSection4Title">Choose Meaningful Column Names</H5>
<P class="docText">In many data processing shops, common names for data elements have been used for years. Sometimes these names seem arcane because they comply with physical constraints that have long since been overcome.<A NAME="ch05index835"></A><A NAME="ch05index836"></A><A NAME="ch05index837"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> With DB2 V8 a column name can comprise up to 128 bytes. For V7 and prior releases the maximum size of a column name is 18 bytes. You can enhance the useability of your applications if you use as many characters as necessary to achieve easy-to-understand column names. For example, use <TT>CUSTOMER_NAME</TT> instead of <TT>CNA0</TT> for a customer name column. Do not use column names simply because people are accustomed to them.</P></td></tr></table><br>
<P class="docText">This might be a tough sell in your organization, but it's well worth the effort. If you must support the older, non-descriptive names, consider creating tables with the fully descriptive names and then creating views of these tables with the old names. Eventually, people will convert to use the tables instead of the views.</P>
<A NAME="ch05lev4sec53"></A><H5 class="docSection4Title">Standardize Abbreviations</H5>
<P class="docText">Every shop uses abbreviated data names. This isn't a bad practice—unless the specification of abbreviations is random, uncontrolled, or unplanned. Document and enforce strict abbreviation standards for data names in conjunction with your data-naming standards. For example, the <TT>CUSTOMER_NAME</TT> column mentioned in the previous guideline can be abbreviated in many ways (<TT>CST_NME</TT>, <TT>CUST_NM</TT>, <TT>CUST_NAME</TT>, and so on). Choose one standard abbreviation and stick to it.<A NAME="ch05index838"></A><A NAME="ch05index839"></A><A NAME="ch05index840"></A><A NAME="ch05index841"></A><A NAME="ch05index842"></A></P>
<P class="docText">Many shops use a list of tokens to create data abbreviation standards. This is fine as long as each token represents only one entity and each entity has only one abbreviation. For example:</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="groups" CELLPADDING="5"><COLGROUP><COL width="198"><COL width="352"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Entity</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Standard Abbreviation</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CUSTOMER</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CUST</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>NAME</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>NME</TT></P></TD></TR></TABLE></P><br>
<A NAME="ch05lev4sec54"></A><H5 class="docSection4Title">Sequence Columns to Achieve Optimal Performance</H5>
<P class="docText">The sequencing of columns in a table is not important from a functionality perspective because the relational model states that columns must be non-positional. Columns and rows do not need to be sequenced for the retrieval commands to work on tables.<A NAME="ch05index843"></A><A NAME="ch05index844"></A><A NAME="ch05index845"></A><A NAME="ch05index846"></A><A NAME="ch05index847"></A></P>
<P class="docText">When you create a table, however, you must supply the columns in a particular order, and that becomes the order in which they physically are stored. The columns then can be retrieved in any order using the appropriate SQL <TT>SELECT</TT> statement.</P>
<P class="docText">When creating your tables, you will get better performance if you sequence the columns with an understanding of how DB2 logs. When data is modified in your database, DB2 will log every change made (in most circumstances). At a high level, this is how DB2 logs:</P>
<UL><LI><P class="docList">For fixed-length rows, DB2 logs from the first byte changed to the last byte changed.</P></LI><LI><P class="docList">For variable-length rows in which the size of the row changes due to the modification, DB2 logs from the first byte changed to the end of the row.</P></LI><LI><P class="docList">For variable-length rows in which the size of the row does not change, DB2 logs from the first byte changed to the last byte changed.</P></LI></UL>
<P class="docText">"So what?" you may be asking. Logging can cause a significant performance bottleneck. You can optimize performance by sequencing your columns such that you minimize the amount of data logged. The less data DB2 needs to log, the better the performance of your data modification operations will be. So, follow these rules for column sequencing:</P>
<UL><LI><P class="docList">Place the primary key columns first to ease identification.</P></LI><LI><P class="docList">Place infrequently updated non-variable columns next.</P></LI><LI><P class="docList">Place infrequently updated variable columns after the infrequently updated non- variable columns.</P></LI><LI><P class="docList">Consider placing columns that are frequently modified at the same time next to one another in sequence in the table. This can help to reduce the amount of data that is logged. Do so even if it does not "appear" to be an elegant design; for example, if the <TT>MIDDLE_INITIAL</TT> column is often updated at the same time as the <TT>PHONE_NUMBER</TT> column, place the two columns contiguously next to each other. Even though it might "look nicer" to put the <TT>LAST_NAME</TT> column after <TT>MIDDLE_INITIAL</TT>, performance can be improved in this scenario by putting <TT>PHONE_NUMBER</TT> after <TT>MIDDLE_INITIAL</TT>.</P></LI><LI><P class="docList">Only then, and given the preceding constraints, try to sequence the columns in an order that makes sense to the users of the table.<A NAME="ch05index848"></A><A NAME="ch05index849"></A><A NAME="ch05index850"></A><A NAME="ch05index851"></A><A NAME="ch05index852"></A></P></LI></UL>
<A NAME="ch05note35"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">A varying length row is any row that contains a <TT>VARCHAR</TT> or <TT>VARGRAPHIC</TT> column or any row that is compressed. Using <TT>ALTER TABLE</TT> to add a column to an existing table also makes the rows varying length (until the table space for the table is reorganized).</P></div><br>
<A NAME="ch05lev4sec55"></A><H5 class="docSection4Title">Avoid Special Sequencing for Nullable Columns</H5>
<P class="docText">Treat nullable columns the same as you would any other column. Some DBAs advise you to place nullable columns of the same data type after non-nullable columns. This is supposed to assist in administering the null columns, but in my opinion it does not. Sequencing nullable columns in this manner provides no clear benefit and should be avoided.<A NAME="ch05index853"></A><A NAME="ch05index854"></A><A NAME="ch05index855"></A></P>
<P class="docText">See the "<A class="docLink" HREF="#ch05lev2sec9">DB2 Table Parameters</A>" section in this chapter for additional advice on nullable columns and <A class="docLink" HREF="ch02.html#ch02">Chapter 2</A>, "Data Manipulation Guidelines," for advice on accessing nullable columns.</P>
<A NAME="ch05lev4sec56"></A><H5 class="docSection4Title">Use Nulls with Care</H5>
<P class="docText">A null is DB2's attempt to record missing or unknown information. When you assign a null to a column instance, it means that a value currently does not exist for the column. It's important to understand that a column assigned to null logically means one of two things: The column does not apply to this row, or the column applies to this row, but the information is not known at present.<A NAME="ch05index856"></A><A NAME="ch05index857"></A><A NAME="ch05index858"></A><A NAME="ch05index859"></A><A NAME="ch05index860"></A></P>
<P class="docText">For example, suppose that a table contains information on the hair color of employees. The <TT>HAIR_COLOR</TT> column is defined in the table as being capable of accepting nulls. Three new employees are added today: a man with black hair, a woman with unknown hair color, and a bald man. The woman with the unknown hair color and the bald man both could be assigned null <TT>HAIR_COLOR</TT>, but for different reasons. The hair column color for the woman would be null because she has hair but the color presently is unknown. The hair color column for the bald man would be null also, but this is because he has no hair and so hair color does not apply.</P>
<P class="docText">DB2 does not differentiate between nulls that signify unknown data and those that signify inapplicable data. This distinction must be made by the program logic of each application.</P>
<P class="docText">DB2 represents null in a special hidden column known as an <span class="docEmphasis">indicator variable</span>. An indicator variable is defined to DB2 for each column that can accept nulls. The indicator variable is transparent to an end user, but must be provided for when programming in a host language (such as COBOL or PL/I). Every column defined to a DB2 table must be designated as either allowing or disallowing nulls.<A NAME="ch05index861"></A><A NAME="ch05index862"></A></P>
<P class="docText">The default definition for columns in a DB2 table is to allow nulls. Nulls can be prohibited for a column by specifying the <TT>NOT NULL</TT> or <TT>NOT NULL WITH DEFAULT</TT> option in the <TT>CREATE TABLE</TT> statement.</P>
<P class="docText">Avoid nulls in columns that must participate in arithmetic logic (for example, <TT>DECIMAL</TT> money values). The <TT>AVG</TT>, <TT>COUNT DISTINCT</TT>, <TT>SUM</TT>, <TT>MAX</TT>, and <TT>MIN</TT> functions omit column occurrences set to null. The <TT>COUNT(*)</TT> function, however, does not omit columns set to null because it operates on rows. Thus, <TT>AVG</TT> is not equal to <TT>SUM/COUNT(*)</TT> when the average is being computed for a column that can contain nulls. If the <TT>COMM</TT> column is nullable, the result of the following queries are not the same</P>
<pre>

</pre><BR><pre>
SELECT  AVG(COMM)                            SELECT  SUM(COMM)/COUNT(*)
FROM    DSN8810.EMP;                         FROM    DSN8810.EMP;
</pre><BR>
<P class="docText">For this reason, avoid nulls in columns involved in math functions.</P>
<P class="docText">When <TT>DATE</TT>, <TT>TIME</TT>, and <TT>TIMESTAMP</TT> columns can be unknown, assign them as nullable. DB2 checks to ensure that only valid dates, times, and timestamps are placed in columns defined as such. If the column can be unknown, it must be defined to be nullable because the default for these columns is the current date, current time, and current timestamp (unless explicitly defined otherwise using the <TT>DEFAULT</TT> clause). Null, therefore, is the only available option for the recording of missing dates, times, and timestamps.</P>
<P class="docText">For every other column, determine whether nullability can be of benefit before allowing nulls. Consider these rules:<A NAME="ch05index863"></A><A NAME="ch05index864"></A><A NAME="ch05index865"></A><A NAME="ch05index866"></A><A NAME="ch05index867"></A></P>
<UL><LI><P class="docList">When a nullable column participates in an <TT>ORDER BY</TT> or <TT>GROUP BY</TT> clause, the returned nulls are grouped at the high end of the sort order.</P></LI><LI><P class="docList">Nulls are considered to be equal when duplicates are eliminated by <TT>SELECT DISTINCT</TT> or <TT>COUNT (DISTINCT </TT><span class="docEmphasis"><TT>column</TT></span><TT>)</TT>.</P></LI><LI><P class="docList">A unique index considers nulls to be equivalent and disallows duplicate entries because of the existence of nulls, unless the <TT>WHERE NOT NULL</TT> clause is specified in the index.</P></LI><LI><P class="docList">For comparison in a <TT>SELECT</TT> statement, two null columns are not considered equal. When a nullable column participates in a predicate in the <TT>WHERE</TT> or <TT>HAVING</TT> clause, the nulls encountered cause the comparison to evaluate to <TT>UNKNOWN</TT>.</P></LI><LI><P class="docList">When a nullable column participates in a calculation, the result is null.</P></LI><LI><P class="docList">Columns that participate in a primary key cannot be null.</P></LI><LI><P class="docList">To test for the existence of nulls, use the special predicate <TT>IS NULL</TT> in the <TT>WHERE</TT> clause of the <TT>SELECT</TT> statement.</P></LI><LI><P class="docList">You cannot simply state <TT>WHERE </TT><span class="docEmphasis"><TT>column</TT></span> <TT>= NULL</TT>. You must state <TT>WHERE </TT><span class="docEmphasis"><TT>column</TT></span> <TT>IS NULL</TT>.</P></LI><LI><P class="docList">It is invalid to test if a column is <TT>&lt; NULL</TT>, <TT>&lt;= NULL</TT>, <TT>&gt; NULL</TT>, or <TT>&gt;= NULL</TT>. These are all meaningless because null is the absence of a value.</P></LI><LI><P class="docList">You can assign a column to null using the <TT>=</TT> predicate in the <TT>SET</TT> clause of the <TT>UPDATE</TT> statement.</P></LI></UL>
<P class="docText">Examine these rules closely. <TT>ORDER BY</TT>, <TT>GROUP BY</TT>, <TT>DISTINCT</TT>, and unique indexes consider nulls to be equal and handle them accordingly. The <TT>SELECT</TT> statement, however, deems that the comparison of null columns is not equivalence, but unknown. This inconsistent handling of nulls is an anomaly that you must remember when using nulls. The following are several sample SQL queries and the effect nulls have on them.</P>
<pre>

</pre><BR><pre>
SELECT   JOB, SUM(SALARY)
FROM     DSN8810.EMP
GROUP BY JOB;
</pre><BR>
<P class="docText">This query returns the average salary for each type of job. All instances in which <TT>JOB</TT> is null will group at the bottom of the output.</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, PROJNO, ACTNO, EMPTIME,
        EMSTDATE, EMENDATE
FROM    DSN8810.EMPPROJACT
WHERE   EMSTDATE = EMENDATE;
</pre><BR>
<P class="docText">This query retrieves all occurrences in which the project start date is equal to the project end date. This information is clearly erroneous, as anyone who has ever worked on a software development project can attest. The query does not return any rows in which either date or both dates are null for two reasons:</P>
<UL><LI><P class="docList">Two null columns are never equal for purposes of comparison.</P></LI><LI><P class="docList">When either column of a comparison operator is null, the result is unknown.</P></LI></UL>
<pre>

</pre><BR><pre>
UPDATE  DSN8810.DEPT
  SET   MGRNO = NULL
WHERE   MGRNO = '000010';
</pre><BR>
<P class="docText">This query sets the <TT>MGRNO</TT> column to null wherever <TT>MGRNO</TT> is currently equal to <TT>'000010'</TT> in the <TT>DEPT</TT> table.<A NAME="ch05index868"></A><A NAME="ch05index869"></A><A NAME="ch05index870"></A><A NAME="ch05index871"></A><A NAME="ch05index872"></A></P>
<A NAME="ch05note36"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Nulls sometimes are inappropriately referred to as null values. Using the term <span class="docEmphasis">value</span> to describe a null column is incorrect because the term <span class="docEmphasis">null</span> implies the lack of a value. The relational model has abandoned the idea of nulls in favor of a similar concept called <span class="docEmphasis">marks</span>. The two types of marks are an <span class="docEmphasis">A-mark</span> and an <span class="docEmphasis">I-mark</span>. An A-mark refers to information that is applicable but presently unknown, whereas an I-mark refers to inapplicable information (information that does not apply). If DB2 would implement marks rather than nulls, the problem of differentiating between inapplicable and unknown data would disappear.<A NAME="ch05index873"></A><A NAME="ch05index874"></A><A NAME="ch05index875"></A><A NAME="ch05index876"></A><A NAME="ch05index877"></A><A NAME="ch05index878"></A><A NAME="ch05index879"></A><A NAME="ch05index880"></A><A NAME="ch05index881"></A><A NAME="ch05index882"></A></P>
<P class="docText">No commercial DBMS products support A-marks and I-marks.</P></div><br>
<A NAME="ch05lev4sec57"></A><H5 class="docSection4Title">Define Columns Across Tables in the Same Way</H5>
<P class="docText">When a column that defines the same attribute as another column is given a different column name, data administrators refer it to as a <span class="docEmphasis">column synonym</span>. In general, column synonyms should be avoided except in the situations detailed in this guideline.<A NAME="ch05index883"></A><A NAME="ch05index884"></A><A NAME="ch05index885"></A></P>
<P class="docText">Every attribute should be defined in one way, that is, with one distinct name and one distinct data type and length. The name should be different only if the same attribute needs to be represented as a column in one table more than once, or if the practical meaning of the attribute differs as a column from table to table. For example, suppose that a database contains a table that holds the colors of items. This column is called Color. The same database has a table with a Preferred Color column for customers. This is the same logical attribute, but its meaning changes based on the context. It is not wise to simply call the column Color in the Customer table, because it would imply that the customer is that color!</P>
<P class="docText">An attribute must be defined twice in self-referencing tables and in tables requiring multiple foreign key references to a single table. In these situations, create a standard prefixing or suffixing mechanism for the multiple columns. After you define the mechanism, stick to it. For example, the <TT>DSN8810.DEPT</TT> table in <A class="docLink" HREF="app01.html#app01">Appendix A</A>, "DB2 Sample Tables," is a self-referencing table that does not follow these recommendations. The <TT>ADMRDEPT</TT> column represents the same attribute as the <TT>DEPTNO</TT> column, but the name is not consistent. A better name for the column would have been <TT>ADMR_DEPTNO</TT>. This adds the <TT>ADMR</TT> prefix to the attribute name, <TT>DEPTNO</TT>.</P>
<P class="docText">The practical meaning of columns that represent the same attribute can differ from table to table as well. In the sample tables, for example, the <TT>MGRNO</TT> column in the <TT>DSN8810.DEPT</TT> table represents the same attribute as the <TT>EMPNO</TT> column in the <TT>DSN8810.EMP</TT> table. The two columns can be named differently in this situation because the employee number in the <TT>DEPT</TT> table represents a manager, whereas the employee number in the <TT>EMP</TT> table represents any employee. (Perhaps the <TT>MGRNO</TT> column should have been named <TT>MGR_EMPNO</TT>.)</P>
<P class="docText">The sample tables provide another example of when this guideline should have been followed, but wasn't. Consider the same two tables: <TT>DSN8810.DEPT</TT> and <TT>DSN8810.EMP</TT>. Both contain the department number attribute. In the <TT>DEPT</TT> table, the column representing this attribute is <TT>DEPTNO</TT>, but in the <TT>EMP</TT> table, the column is <TT>WORKDEPT</TT>. This is confusing and should be avoided. In this instance, both should have been named <TT>DEPTNO</TT>.</P>
<P class="docText">Never use homonyms. A <span class="docEmphasis">homonym</span>, in DB2-column terminology, is a column that is spelled and pronounced the same as another column, but represents a different attribute.<A NAME="ch05index886"></A><A NAME="ch05index887"></A><A NAME="ch05index888"></A></P>
<A NAME="ch05lev4sec58"></A><H5 class="docSection4Title">Avoid Duplicate Rows</H5>
<P class="docText">To conform to the relational model, every DB2 table should prohibit duplicate rows. Duplicate rows cause ambiguity and add no value.<A NAME="ch05index889"></A><A NAME="ch05index890"></A><A NAME="ch05index891"></A></P>
<P class="docText">If duplicates exist for an entity, either the entity has not been rigorously defined and normalized or a simple counter column can be added to the table. The counter column would contain a number indicating the number of duplicates for the given row.</P>
<A NAME="ch05lev4sec59"></A><H5 class="docSection4Title">Define a Primary Key</H5>
<P class="docText">To assist in the unique identification of rows, define a primary (or unique) key for every DB2 table. The preferred way to define a primary key is with the <TT>PRIMARY KEY</TT> clause of the <TT>CREATE TABLE</TT> statement.<A NAME="ch05index892"></A><A NAME="ch05index893"></A><A NAME="ch05index894"></A><A NAME="ch05index895"></A></P>
<A NAME="ch05lev4sec60"></A><H5 class="docSection4Title">Consider Using a Surrogate Key</H5>
<P class="docText">When the primary key for a table is very large it can be unwieldy to implement. For example, an eight-column key of 250 bytes could pose problems if there are numerous foreign keys that refer to it. If the primary key is defined using eight columns and 250 bytes, then every foreign key also will consume 250 bytes and use eight columns.<A NAME="ch05index896"></A><A NAME="ch05index897"></A><A NAME="ch05index898"></A><A NAME="ch05index899"></A><A NAME="ch05index900"></A><A NAME="ch05index901"></A></P>
<P class="docText">If the length of the primary key is impractical to implement, consider defining a surrogate key. You might be able to use a DB2 <TT>TIMESTAMP</TT> or a <TT>SEQUENCE</TT> object to generate unique surrogate key values.</P>
<A NAME="ch05lev4sec61"></A><H5 class="docSection4Title">Use Appropriate DB2 Data Types</H5>
<P class="docText">Use the appropriate DB2 data type when defining table columns. Recall the list of valid DB2 data types presented earlier in this section. Some people may advise you to avoid certain DB2 data types—this is unwise. Follow these rules:<A NAME="ch05index902"></A><A NAME="ch05index903"></A><A NAME="ch05index904"></A><A NAME="ch05index905"></A><A NAME="ch05index906"></A></P>
<UL><LI><P class="docList">Use the DB2 <TT>DATE</TT> data type to represent all dates. Do not use a character or numeric representation of the date.</P></LI><LI><P class="docList">Use the DB2 <TT>TIME</TT> data type to represent all times. Do not use a character or numeric representation of the time.</P></LI><LI><P class="docList">Favor the use of the DB2 <TT>TIMESTAMP</TT> data type when the date and time are always needed together, but rarely needed alone. Do not use a character or numeric representation of the timestamp. For additional insight, see the tradeoffs listed in the upcoming "<A class="docLink" HREF="#ch05lev4sec62">Analyze DATE and TIME Columns Versus TIMESTAMP Columns</A>" section.</P></LI><LI><P class="docList">Using <TT>INTEGER</TT> and <TT>SMALLINT</TT> data types is interchangeable with using the <TT>DECIMAL</TT> data type without scale. Specifying <TT>DECIMAL</TT> without scale sometimes is preferable to <TT>INTEGER</TT> and <TT>SMALLINT</TT> because it provides more control over the domain of the column. However, <TT>DECIMAL</TT> without scale might use additional DASD. For additional insight, see the tradeoffs listed in the upcoming "<A class="docLink" HREF="#ch05lev4sec72">Consider All Options When Defining Columns As INTEGER</A>" section.</P></LI><LI><P class="docList">When the data item is always numeric (and numeric only), use a numeric data type. Even if leading zeroes must be stored or reported, using the character data type is rarely acceptable. You can use program logic and reporting software to display any numeric data with leading blanks. Storing the data as a numeric data type has the benefit of providing automatic DB2 data integrity checking (non-numeric data can never be stored in a column defined with a numeric data type).</P></LI><LI><P class="docList">Remember, DB2 uses the cardinality of a column to determine its filter factors used during access path selection. The specification of column data types can influence this access path selection.</P></LI></UL>
<P class="docText">There are more possible character (alphanumeric) values than there are numeric values for columns of equal length. For example, consider the following two columns:</P>
<pre>

</pre><BR><pre>
COLUMN1   SMALLINT  NOT NULL
COLUMN2   CHAR(5)   NOT NULL
</pre><BR>
<P class="docText"><TT>COLUMN1</TT> can contain values only in the range –32,768 to 32,767, for a total of 65,536 possible values. <TT>COLUMN2</TT>, however, can contain all the permutations and combinations of legal alphabetic characters, special characters, and numerals. So you can see how defining numeric data as a numeric data type usually results in a more accurate access path selection by the DB2 optimizer; the specified domain is more accurate for filter factor calculations.<A NAME="ch05index907"></A><A NAME="ch05index908"></A><A NAME="ch05index909"></A><A NAME="ch05index910"></A><A NAME="ch05index911"></A></P>
<A NAME="ch05lev4sec62"></A><H5 class="docSection4Title">Analyze <TT>DATE</TT> and <TT>TIME</TT> Columns Versus <TT>TIMESTAMP</TT> Columns</H5>
<P class="docText">When defining tables that require a date and time stamp, two solutions are available:<A NAME="ch05index912"></A><A NAME="ch05index913"></A><A NAME="ch05index914"></A><A NAME="ch05index915"></A><A NAME="ch05index916"></A><A NAME="ch05index917"></A></P>
<UL><LI><P class="docList">Coding two columns, one as a <TT>DATE</TT> data type and the other as a <TT>TIME</TT> data type</P></LI><LI><P class="docList">Coding one column specifying the <TT>TIMESTAMP</TT> data type</P></LI></UL>
<P class="docText">Each option has its benefits and drawbacks. Before choosing an approach, consider the following issues:</P>
<UL><LI><P class="docList">With <TT>DATE</TT> and <TT>TIME</TT> you must use two columns. <TT>TIMESTAMP</TT> uses one column, thereby simplifying data access and modification.</P></LI><LI><P class="docList">The combination of <TT>DATE</TT> and <TT>TIME</TT> columns requires 7 bytes of storage, while a <TT>TIMESTAMP</TT> column always requires 10 bytes of storage. Using the combination of <TT>DATE</TT> and <TT>TIME</TT> columns can save space.</P></LI><LI><P class="docList"><TT>TIMESTAMP</TT> provides greater time accuracy, down to the microsecond level. <TT>TIME</TT> provides accuracy only to the second level. If precision is important, use <TT>TIMESTAMP</TT>; otherwise consider the combination of <TT>DATE</TT> and <TT>TIME</TT>.</P></LI><LI><P class="docList">Date and time arithmetic can be easier to implement using <TT>TIMESTAMP</TT> data instead of a combination of <TT>DATE</TT> and <TT>TIME</TT>. Subtracting one <TT>TIMESTAMP</TT> from another results in a <TT>TIMESTAMP</TT> duration. To calculate a duration using <TT>DATE</TT> and <TT>TIME</TT> columns, two subtraction operations must occur: one for the <TT>DATE</TT> column and one for the <TT>TIME</TT> column.</P></LI><LI><P class="docList">DB2 provides for the formatting of <TT>DATE</TT> and <TT>TIME</TT> columns via local <TT>DATE</TT> and <TT>TIME</TT> exits, the <TT>CHAR</TT> function, and the <TT>DATE</TT> and <TT>TIME</TT> precompiler options. These facilities are not available for <TT>TIMESTAMP</TT> columns. If the date and time information is to be extracted and displayed on a report or by an online application, the availability of these DB2-provided facilities for <TT>DATE</TT> and <TT>TIME</TT> columns should be considered when making your decision.<A NAME="ch05index918"></A><A NAME="ch05index919"></A><A NAME="ch05index920"></A><A NAME="ch05index921"></A><A NAME="ch05index922"></A><A NAME="ch05index923"></A></P></LI></UL>
<A NAME="ch05lev4sec63"></A><H5 class="docSection4Title">Consider the Display Format for <TT>DATE</TT> and <TT>TIME</TT> Data</H5>
<P class="docText">DB2 provides four options for displaying <TT>DATE</TT> and <TT>TIME</TT> data, as shown in <A class="docLink" HREF="#ch05table08">Table 5.8</A>. Each format conforms to a standard means of displaying date and time data: <TT>EUR</TT> is European Standard, <TT>ISO</TT> is the International Standards Organization format, <TT>JIS</TT> is Japanese Industrial Standard, and <TT>USA</TT> is IBM United States of America Standard.<A NAME="ch05index924"></A><A NAME="ch05index925"></A><A NAME="ch05index926"></A><A NAME="ch05index927"></A><A NAME="ch05index928"></A><A NAME="ch05index929"></A><A NAME="ch05index930"></A></P>
<A NAME="ch05table08"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 5.8. DB2 Date and Time Formats</h5></CAPTION><COLGROUP><COL width="94.44444444444444"><COL width="150"><COL width="305.55555555555554"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Format</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Date</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Time</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>EUR</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DD.MM.YYYY</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>HH.MM.SS</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>ISO</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>YYYY-MM-DD</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>HH.MM.SS</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>JIS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>YYYY-MM-DD</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>HH:MM:SS</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>USA</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>MM/DD/YYYY</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>HH:MM AM</TT> or <TT>PM</TT></P></TD></TR></TABLE></P><br>
<P class="docText">DB2 also allows for the creation of an installation-defined date format. One of these formats is chosen as the default standard for your DB2 subsystem at installation time. The default is <TT>ISO</TT>. Any format can be displayed using the <TT>CHAR()</TT> function (previously described in <A class="docLink" HREF="ch03.html#ch03">Chapter 3</A>, "Using DB2 Functions").</P>
<A NAME="ch05note37"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Avoid choosing the <TT>USA</TT> format as the default. The <TT>USA</TT> format causes <TT>TIME</TT> data to be displayed without the seconds component, instead appending an <TT>AM</TT> or <TT>PM</TT>. <TT>EUR</TT>, <TT>ISO</TT>, and <TT>JIS</TT> all display <TT>TIME</TT> in military format, specifying 1 through 24 for the hour. The <TT>USA</TT> format does not, instead specifying 1 through 12 for the hour, and using <TT>AM</TT> and <TT>PM</TT> to designate morning and evening times.</P>
<P class="docText">If the default format is <TT>USA</TT>, <TT>TIME</TT> columns will be displayed without seconds and with the <TT>AM</TT> or <TT>PM</TT> extension. When data is unloaded using <TT>DSNTIAUL</TT>, the seconds information is lost. This can result in data integrity problems if the unloaded data is subsequently loaded to another table or used as input for other processes.</P></div><br>
<A NAME="ch05lev4sec64"></A><H5 class="docSection4Title">Consider Optimization When Choosing Data Type</H5>
<P class="docText">The impact on optimization is another consideration when deciding whether to use a character or a numeric data type for a numeric column.<A NAME="ch05index931"></A><A NAME="ch05index932"></A><A NAME="ch05index933"></A><A NAME="ch05index934"></A><A NAME="ch05index935"></A></P>
<P class="docText">Consider, for example, a column that must store four byte integers. This can be supported using a <TT>CHAR(4)</TT> data type or a <TT>SMALLINT</TT> data type. Often times, the desire to use <TT>CHAR(4)</TT> is driven by the need to display leading zeroes on reports.</P>
<P class="docText">Data integrity will not be an issue assuming that all data is edit checked prior to insertion to the column (a big assumption). But even if edit checks are coded, DB2 is not aware of these and assumes that all combinations of characters are permitted. For access path determination on character columns, DB2 uses base 37 math. This assumes that usually one of the 26 alphabetic letters or the 10 numeric digits or a space will be used. This adds up to 37 possible characters. For a four-byte character column there are 37<SUP>4</SUP> or 1,874,161 possible values.</P>
<P class="docText">A <TT>SMALLINT</TT> column can range from –32,768 to 32,767 producing 65,536 possible small integer values. The drawback here is that negative or 5 digit product codes could be entered. However, if we adhere to our proper edit check assumption, the data integrity problems will be avoided here, as well.<A NAME="ch05index936"></A><A NAME="ch05index937"></A></P>
<P class="docText">DB2 will use the <TT>HIGH2KEY</TT> and <TT>LOW2KEY</TT> values to calculate filter factors. For character columns, the range between <TT>HIGH2KEY</TT> and <TT>LOW2KEY</TT> is larger than numeric columns because there are more total values. The filter factor will be larger for the numeric data type than for the character data type, which might influence DB2 to choose a different access path. For this reason, favor the <TT>SMALLINT</TT> over the <TT>CHAR(4)</TT> definition.<A NAME="ch05index938"></A><A NAME="ch05index939"></A><A NAME="ch05index940"></A><A NAME="ch05index941"></A><A NAME="ch05index942"></A></P>
<A NAME="ch05lev4sec65"></A><H5 class="docSection4Title">Choose a Data Type Closest to the Desired Domain</H5>
<P class="docText">It is always best to choose the data type for each column to be the one that is closest to its domain. By doing so, DB2 will perform data integrity checking that otherwise would need to be coded into application programs or <TT>CHECK</TT> constraints. For example, if you are storing numeric data in the column, do not choose a character data type. In general, adhere to the following rules:<A NAME="ch05index943"></A><A NAME="ch05index944"></A><A NAME="ch05index945"></A><A NAME="ch05index946"></A><A NAME="ch05index947"></A></P>
<UL><LI><P class="docList">If the data is numeric, favor <TT>SMALLINT</TT>, <TT>INTEGER</TT>, or <TT>DECIMAL</TT> data types. <TT>FLOAT</TT> is also an option.</P></LI><LI><P class="docList">If the data is character, use <TT>CHAR</TT> or <TT>VARCHAR</TT> data types.</P></LI><LI><P class="docList">If the data is date and time, use <TT>DATE</TT>, <TT>TIME</TT>, and <TT>TIMESTAMP</TT> data types.</P></LI><LI><P class="docList">If the data is multimedia, use <TT>GRAPHIC</TT>, <TT>VARGRAPHIC</TT>, <TT>BLOB</TT>, <TT>CLOB</TT>, or <TT>DBCLOB</TT> data types.</P></LI></UL>
<A NAME="ch05lev4sec66"></A><H5 class="docSection4Title">Specify Appropriate Defaults</H5>
<P class="docText">When a row is inserted or loaded into a table and no value is specified for a column but the column has a default specified, the column will be set to the value that has been identified in the column default specification. Two types of defaults are available: system-defined and user-defined.<A NAME="ch05index948"></A><A NAME="ch05index949"></A><A NAME="ch05index950"></A><A NAME="ch05index951"></A></P>
<P class="docText">Each column can have a default value specifically tailored to it. These are known as user-defined defaults. DB2 also provides specific system-defined defaults for each data type, which are used if an explicit default value is not specified. The system-defined defaults are outlined in <A class="docLink" HREF="#ch05table09">Table 5.9</A>.</P>
<A NAME="ch05table09"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 5.9. System-Defined Column Default Values</h5></CAPTION><COLGROUP><COL width="159.5"><COL width="390.5"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Data Type</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Default Value</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Numeric</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Zero</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Fixed-length String</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Blanks</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Varying-length String</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">String of length zero</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Row identifier</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Actual <TT>ROWID</TT> for the row</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Date</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Current date</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Time</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Current time</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Timestamp</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Current timestamp</P></TD></TR></TABLE></P><br>
<P class="docText">For existing rows, when a non-nullable column is added to a table, <TT>DATE</TT>, <TT>TIME</TT>, and <TT>TIMESTAMP</TT> data types default to the lowest possible value instead of the current value. <TT>DATE</TT> types will default to <TT>January 1, 0001</TT>; <TT>TIME</TT> types will default to <TT>0:00:00</TT>; and timestamp types will default to a date of <TT>January 1, 0001</TT> and a time of <TT>0:00:00:00</TT>.</P>
<P class="docText">Four options are available for user-defined defaults: a constant value, <TT>USER</TT>, <TT>CURRENT SQLID</TT>, and <TT>NULL</TT>. When specifying a constant, the value must conform to the column on which it is defined. Specifying <TT>USER</TT> causes the column to default to the contents of the <TT>USER</TT> special register. When <TT>CURRENT SQLID</TT> is specified, the default value will be the SQL authid of the process performing the <TT>INSERT</TT>. <TT>NULL</TT> is self-explanatory.</P>
<P class="docText">In general, it is best to explicitly define the default value to be used for each column. If the system-defined default values are adequate for your application, it is fine to use them by not providing a value following the <TT>DEFAULT</TT> clause. Consider the following column definitions:</P>
<pre>

</pre><BR><pre>
BONUS       DECIMAL(9,2)  DEFAULT 500.00,
COMM        DECIMAL(9,2)  NOT NULL WITH DEFAULT,
</pre><BR>
<P class="docText">If a row is inserted without specifying <TT>BONUS</TT> and <TT>COMM</TT>, <TT>BONUS</TT> will default to 500.00 and <TT>COMM</TT> will default to zero.<A NAME="ch05index952"></A><A NAME="ch05index953"></A><A NAME="ch05index954"></A><A NAME="ch05index955"></A></P>
<A NAME="ch05lev4sec67"></A><H5 class="docSection4Title">Choose <TT>VARCHAR</TT> Columns Carefully</H5>
<P class="docText">You can save DASD storage space by using variable columns instead of placing small amounts of data in a large fixed space. Each variable column carries a 2-byte overhead, however, for storing the length of the data. Additionally, variable columns tend to increase CPU usage and can cause the update process to become inefficient. When a variable column is updated with a larger value, the row becomes larger; if not enough space is available to store the row, it must be moved to another page. This makes the update and any subsequent retrieval slower.<A NAME="ch05index956"></A><A NAME="ch05index957"></A><A NAME="ch05index958"></A></P>
<P class="docText">Follow these rules when defining variable character columns:</P>
<UL><LI><P class="docList">Avoid variable columns if a sufficient amount of DASD is available to store the data using fixed columns.</P></LI><LI><P class="docList">Do not define a variable column if its maximum length is less than 30 bytes. Instead, simply define the column as a fixed length <TT>CHAR</TT> (or <TT>GRAPHIC</TT>) column.</P></LI><LI><P class="docList">Do not define a variable column if its maximum length is within 10 bytes of the average length of the column.</P></LI><LI><P class="docList">Do not define a variable column when the data does not vary from row to row.</P></LI><LI><P class="docList">Place variable columns at the end of the row, but before columns that are frequently updated. Refer back to the "<A class="docLink" HREF="#ch05lev4sec54">Sequence Columns to Achieve Optimal Performance</A>" section for more details.</P></LI><LI><P class="docList">Consider redefining variable columns by placing multiple rows of fixed-length columns in another table or by shortening the columns and placing the overflow in another table.<A NAME="ch05index959"></A><A NAME="ch05index960"></A><A NAME="ch05index961"></A></P></LI></UL>
<A NAME="ch05lev4sec68"></A><H5 class="docSection4Title">Compression Versus <TT>VARCHAR</TT> Columns</H5>
<P class="docText">Using DB2 compression, you can achieve similar results as with <TT>VARCHAR</TT> columns. However, DB2 compression avoids the two bytes of overhead and requires no programmatic intervention for handling the two-byte column length information.<A NAME="ch05index962"></A><A NAME="ch05index963"></A><A NAME="ch05index964"></A><A NAME="ch05index965"></A><A NAME="ch05index966"></A><A NAME="ch05index967"></A></P>
<P class="docText">On the other hand, <TT>VARCHAR</TT> columns affect data for the column only. With compression, the entire row is affected. Therefore, there is a greater chance that an <TT>UPDATE</TT> of a compressed row will need to be relocated to another page if its size has increased.</P>
<A NAME="ch05lev4sec69"></A><H5 class="docSection4Title">Altering <TT>VARCHAR</TT> Columns</H5>
<P class="docText">As of DB2 V6, you can <TT>ALTER</TT> the length of a <TT>VARCHAR</TT> column to a greater length. However, you cannot <TT>ALTER</TT> the length of a <TT>VARCHAR</TT> column to a smaller length.<A NAME="ch05index968"></A><A NAME="ch05index969"></A><A NAME="ch05index970"></A><A NAME="ch05index971"></A></P>
<A NAME="ch05lev4sec70"></A><H5 class="docSection4Title">Monitor the Effectiveness of Variable Columns</H5>
<P class="docText">Using views and SQL, it is possible to query the DB2 Catalog to determine the effectiveness of using <TT>VARCHAR</TT> for a column instead of <TT>CHAR</TT>. Consider, for example, the <TT>PROJNAME</TT> column of the <TT>DSN8810.PROJ</TT> table. It is defined as <TT>VARCHAR(24)</TT>.<A NAME="ch05index972"></A><A NAME="ch05index973"></A><A NAME="ch05index974"></A><A NAME="ch05index975"></A></P>
<P class="docText">To gauge whether <TT>VARCHAR</TT> is appropriate follow these steps:</P>
<A NAME="ch05pr03"></A>

<div style="font-weight:bold"><OL class="docList" START="1"><LI value="1"><div style="font-weight:normal">Create a view that returns the length of the <TT>NAME</TT> column for every row, for example:<BR><BR>
<pre>

</pre><BR><pre>
CREATE VIEW PROJNAME_LENGTH
     (COL_LGTH)
AS   SELECT LENGTH(PROJNAME)
     FROM   DSN8810.PROJ;
</pre><BR></div></LI><LI value="2"><div style="font-weight:normal">Issue the following query using <TT>SPUFI</TT> to produce a report detailing the <TT>LENGTH</TT> and number of occurrences for that length:<BR><BR>
<pre>

</pre><BR><pre>
SELECT   COL_LGTH, COUNT(*)
FROM     PROJNAME_LENGTH
GROUP BY COL_LGTH
ORDER BY COL_LGTH;
</pre><BR></div></LI></OL></div>
<P class="docText">This query will produce a report listing the lengths (in this case, from 1 to 24, excluding those lengths which do not occur) and the number of times that each length occurs in the table. These results can be analyzed to determine the range of lengths stored within the variable column.</P>
<P class="docText">If you are not concerned about this level of detail, the following query can be used instead to summarize the space characteristics of the variable column in question:</P>
<pre>

</pre><BR><pre>
SELECT  24*COUNT(*),
        24,
        SUM(2+LENGTH(PROJNAME)),
        AVG(2+LENGTH(PROJNAME)),
        24*COUNT(*)-SUM(2+LENGTH(PROJNAME)),
        24-AVG(2+LENGTH(PROJNAME))
FROM    DSN8810.PROJ;
</pre><BR>
<P class="docText">The constant 24 will need to be changed in the query to indicate the maximum length of the variable column as defined in the DDL. The individual columns returned by this report are defined in the following list:</P>
<P><TABLE CELLSPACING="0" FRAME="below" RULES="groups" CELLPADDING="5"><COLGROUP><COL width="275"><COL width="275"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Definition</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Calculation</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Space used as <TT>CHAR(24)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>24*COUNT(*)</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Average space used as <TT>CHAR(24)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>24</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Space used as <TT>VARCHAR(24)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SUM(2+LENGTH(PROJNAME))</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Average space used as <TT>VARCHAR(24)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>AVG(2+LENGTH(PROJNAME))</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Total space saved</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>24*COUNT(*)-SUM(2+LENGTH(PROJNAME))</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Average space saved</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>24-AVG(2+LENGTH(PROJNAME))</TT><A NAME="ch05index976"></A><A NAME="ch05index977"></A><A NAME="ch05index978"></A><A NAME="ch05index979"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch05lev4sec71"></A><H5 class="docSection4Title">Consider Using Odd <TT>DECIMAL</TT> Precision</H5>
<P class="docText">Think about making the precision of all <TT>DECIMAL</TT> columns odd. This can provide an extra digit for the column being defined without using additional storage. For example, consider a column that must have a precision of 6 with a scale of 2. This would be defined as <TT>DECIMAL(6,2)</TT>. By defining the column as <TT>DECIMAL(7,2)</TT> instead, numbers up to 99999.99 can be stored instead of numbers up to 9999.99. This can save future expansion efforts.<A NAME="ch05index980"></A><A NAME="ch05index981"></A><A NAME="ch05index982"></A></P>
<P class="docText">However, if you must ensure that the data in the column conforms to the specified domain (that is, even precision), specify even precision.</P>
<A NAME="ch05lev4sec72"></A><H5 class="docSection4Title">Consider All Options When Defining Columns As <TT>INTEGER</TT></H5>
<P class="docText">Use <TT>SMALLINT</TT> instead of <TT>INTEGER</TT> when the –32,768 to 32,767 range of values is appropriate. This data type usually is a good choice for sequencing type columns. The range of allowable values for the <TT>INTEGER</TT> data type is –2,147,483,648 to 2,147,483,647. These ranges might seem arbitrary, but are designed to store the maximum amount of information in the minimum amount of space. A <TT>SMALLINT</TT> column occupies 2 bytes, and an <TT>INTEGER</TT> column occupies only 4 bytes.<A NAME="ch05index983"></A><A NAME="ch05index984"></A><A NAME="ch05index985"></A></P>
<P class="docText">The alternative to <TT>SMALLINT</TT> and <TT>INTEGER</TT> data types is <TT>DECIMAL</TT> with a 0 scale. <TT>DECIMAL(5,0)</TT> supports the same range as <TT>SMALLINT</TT>, and <TT>DECIMAL(10,0)</TT> supports the same range as <TT>INTEGER</TT>. The <TT>DECIMAL</TT> equivalent of <TT>SMALLINT</TT> occupies 3 bytes of storage but permits values as large as 99,999 instead of only 32,767. The <TT>DECIMAL</TT> equivalent of <TT>INTEGER</TT> occupies 6 bytes but permits values as large as 9,999,999,999 instead of 2,147,483,647.</P>
<P class="docText">When deciding whether to use <TT>DECIMAL</TT> without scale to represent integer columns, another factor is control over the domain of acceptable values. The domain of <TT>SMALLINT</TT> and <TT>INTEGER</TT> columns is indicated by the range of allowable values for their respective data types. If you must ensure conformance to a domain, <TT>DECIMAL</TT> without scale provides the better control.</P>
<P class="docText">Suppose that you code a column called <TT>DAYS_ABSENT</TT> that indicates the number of days absent for employees in the <TT>DSN8810.EMP</TT> table. Suppose too that an employee cannot miss more than five days per year without being disciplined and that no one misses ten or more days. In this case, a single digit integer column could support the requirements for <TT>DAYS_ABSENT</TT>. A <TT>DECIMAL(1,0)</TT> column would occupy 2 bytes of physical storage and provide for values ranging from –9 to 9. By contrast, a <TT>SMALLINT</TT> column would occupy two bytes of physical storage and provide for values ranging from –32768 to 32,767. The <TT>DECIMAL(1,0)</TT> column, however, more closely matches the domain for the <TT>DAYS_ABSENT</TT> columns.</P>
<p class="docText"><span class="docEmphRoman">One final consideration</span>: 
A decimal point is required with <TT>DECIMAL</TT> data, even when the data has no scale. For example, the integer 5 is 5, when expressed as a decimal. This can be confusing to programmers and users who are accustomed to dealing with integer data without a decimal point.</p>
<P class="docText">Consider all these factors when deciding whether to implement <TT>SMALLINT</TT>, <TT>INTEGER</TT>, or <TT>DECIMAL</TT> data types for integer columns.<A NAME="ch05index986"></A><A NAME="ch05index987"></A><A NAME="ch05index988"></A></P>
<A NAME="ch05lev4sec73"></A><H5 class="docSection4Title">Use LOBs for Large Multimedia Objects</H5>
<P class="docText">As of V6, DB2 provides support for large multimedia data types. Using <TT>BLOB</TT>, <TT>CLOB</TT>, and <TT>DBCLOB</TT> data types, DB2 can be used to store complex, unstructured data, such as images, audio, text, and video. Such data types can be used to store much larger multimedia data than can be stored in <TT>VARGRAPHIC</TT> or <TT>VARCHAR</TT> columns. Of course, these data types need to be treated differently by application programs and there are management considerations (the larger they become the more difficult it is to administer the data). For more details on the object/relational capabilities of DB2, consult <A class="docLink" HREF="ch09.html#ch09">Chapter 9</A>, "Large Objects and Object/Relational Databases."<A NAME="ch05index989"></A><A NAME="ch05index990"></A></P>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch05lev1sec4.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch05lev1sec6.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
