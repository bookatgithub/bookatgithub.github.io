<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Normalization and Denormalization</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch05lev1sec5.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch05lev1sec7.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch05lev1sec6"></A><H3 class="docSection1Title">Normalization and Denormalization</H3>
<P class="docText">One of the biggest challenges of DB2 database design and implementation can be handling normalization. This section will help you by defining normalization and denormalization and providing tips and guidelines on when and how to denormalize.</P>
<A NAME="ch05lev2sec13"></A><H4 class="docSection2Title">Normalization</H4>
<P class="docText"><span class="docEmphasis">Normalization</span> is a database design approach that minimizes data redundancy and optimizes data structures by systematically and properly placing data elements into appropriate groupings. A normalized data model can be translated into a physical database that is organized correctly.<A NAME="ch05index991"></A><A NAME="ch05index992"></A></P>
<P class="docText">Another way of putting it is that normalization is the process of putting one fact in one appropriate place. E.F. Codd, the father of the relational model, also created normalization. Like the relational model, normalization is based on the mathematical principles of set theory.<A NAME="ch05index993"></A></P>
<P class="docText">It is important to remember that normalization is a logical process and does not necessarily dictate physical database design. A normalized data model will ensure that each entity is well-formed and that each attribute is assigned to the proper entity.</P>
<P class="docText">Of course, the best situation is when a normalized logical data model can be physically implemented without major modifications. But keep in mind that normalization optimizes updates at the expense of retrievals. When a fact is stored in only one place, retrieving many different but related facts usually requires going to many different places. This tends to slow the retrieval process. Updating is quicker, however, because the fact you're updating exists in only one place.</P>
<P class="docText">Your DB2 tables should be based on a normalized logical data model. With a normalized data model, one fact is stored in one place, related facts about a single entity are stored together, and every column of each entity refers non-transitively to only the unique identifier for that entity.<A NAME="ch05index994"></A><A NAME="ch05index995"></A></P>
<P class="docText">Although an in-depth discussion of normalization is beyond the scope of this book, brief definitions of the first three normal forms follow.</P>
<UL><LI><P class="docList">In <span class="docEmphasis">first normal form</span>, all entities must have a unique identifier, or key, that can be composed of one or more attributes. In addition, all attributes must be atomic and non-repeating. (<span class="docEmphasis">Atomic</span> means that the attribute must not be composed of multiple attributes. For example, <TT>EMPNO</TT> should not be composed of <TT>SSN</TT> and <TT>FIRSTNAME</TT> because these are separate attributes.)<A NAME="ch05index996"></A><A NAME="ch05index997"></A><A NAME="ch05index998"></A></P></LI><LI><P class="docList">In <span class="docEmphasis">second normal form</span>, all attributes that are not part of the key must depend on the entire key for that entity.<A NAME="ch05index999"></A><A NAME="ch05index1000"></A><A NAME="ch05index1001"></A></P></LI><LI><P class="docList">In <span class="docEmphasis">third normal form</span>, all attributes that are not part of the key must not depend on any other non-key attributes.<A NAME="ch05index1002"></A><A NAME="ch05index1003"></A><A NAME="ch05index1004"></A></P></LI></UL>
<P class="docText">So, normalization can be summed up as "every attribute must depend upon the key, the whole key, and nothing but the key, so help me Codd."<A NAME="ch05index1005"></A><A NAME="ch05index1006"></A></P>
<A NAME="ch05lev2sec14"></A><H4 class="docSection2Title">Denormalization</H4>
<P class="docText">Speeding the retrieval of data from DB2 tables is a frequent requirement for DBAs and performance analysts. One way to accomplish this is to denormalize DB2 tables for physical implementation. The opposite of normalization, <span class="docEmphasis">denormalization</span> is the process of putting one fact in many places. This speeds data retrieval at the expense of data modification. This is not necessarily a bad decision, but should be undertaken only when a completely normalized design will not perform optimally.<A NAME="ch05index1007"></A><A NAME="ch05index1008"></A></P>
<P class="docText">All that is really required to physically implement a DB2 database is first normal form—that is, the data must be in rows and columns. But that is the bare minimum and anything less than fully normalized can cause data integrity problems and needlessly complex <TT>INSERT</TT>, <TT>UPDATE</TT>, and <TT>DELETE</TT> operations.</P>
<P class="docText">Denormalization should be done based on the processing needs of applications accessing the data. Any denormalization decision must be based on how much the resulting design will optimize the most important queries. On the other hand, you must consider how difficult it will become to modify the data once it is implemented as a denormalized design. Consider these issues before denormalizing:</P>
<UL><LI><P class="docList">Can the system achieve acceptable performance without denormalization?</P></LI><LI><P class="docList">Will denormalization render the database design unuseable for ad hoc queries? (Is specialized expertise required to code queries against the denormalized design?)</P></LI><LI><P class="docList">Will the performance of the system still be unacceptable after denormalization?</P></LI><LI><P class="docList">Will the system be less reliable due to denormalization?</P></LI></UL>
<P class="docText">If the answer to any of these questions is "yes," you should not denormalize your tables because the benefit will not exceed the cost. If, after considering these issues, you decide to denormalize, there are rules you should follow.</P>
<UL><LI><P class="docList">If enough DASD is available, create the fully normalized tables and populate denormalized versions using the normalized tables. Access the denormalized tables in a read-only fashion. Create a controlled and scheduled population function to keep denormalized and normalized tables synchronized.</P></LI><LI><P class="docList">If sufficient DASD does not exist, maintain denormalized tables programmatically. Be sure to update each denormalized table representing the same entity at the same time; alternatively, provide a rigorous schedule whereby table updates are synchronized. If you cannot avoid inconsistent data, inform all users of the implications.</P></LI><LI><P class="docList">When updating any column that is replicated in many tables, update all copies simultaneously, or as close to simultaneously as possible given the physical constraints of your environment.</P></LI><LI><P class="docList">If denormalized tables are ever out of sync with the normalized tables, be sure to inform users that batch reports and online queries may not show up-to-date information.</P></LI><LI><P class="docList">Design the application so that it can be easily converted from denormalized tables to normalized tables.<A NAME="ch05index1009"></A><A NAME="ch05index1010"></A></P></LI></UL>
<P class="docText">There is only one reason to denormalize a relational design: performance. Several indicators help identify systems and tables that are candidates for denormalization. These indicators follow:</P>
<UL><LI><P class="docList">Many critical queries and reports rely on data from more than one table. Often these requests must be processed in an online environment.</P></LI><LI><P class="docList">Repeating groups must be processed in a group instead of individually.</P></LI><LI><P class="docList">Many calculations must be applied to one or many columns before queries can be answered successfully.</P></LI><LI><P class="docList">Tables must be accessed in different ways by different users during the same timeframe.</P></LI><LI><P class="docList">Many large primary keys are clumsy to query and use a large amount of DASD when carried as foreign key columns in related tables.</P></LI><LI><P class="docList">Certain columns are queried a large percentage of the time. (Consider 60% or greater as a cautionary number flagging denormalization as an option.)</P></LI></UL>
<P class="docText">Many types of denormalized tables work around the problems caused by these indicators. <A class="docLink" HREF="#ch05table10">Table 5.10</A> summarizes the types of denormalization, with a short description of when each type is useful. The sections that follow describe these denormalization types in greater detail.<A NAME="ch05index1011"></A><A NAME="ch05index1012"></A></P>
<A NAME="ch05table10"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 5.10. Types of Denormalization</h5></CAPTION><COLGROUP><COL width="154"><COL width="396"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Denormalization</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Use</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Pre-joined Tables</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">When the cost of joining is prohibitive</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Report Tables</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">When specialized critical reports are needed</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Mirror Tables</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">When tables are required concurrently by two types of environments</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Split Tables</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">When distinct groups use different parts of a table</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Combined Tables</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">When one-to-one relationships exist</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Redundant Data</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">To reduce the number of table joins required</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Repeating Groups</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">To reduce I/O and (possibly) DASD</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Derivable Data</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">To eliminate calculations and algorithms</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Speed Tables</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">To support hierarchies<A NAME="ch05index1016"></A><A NAME="ch05index1017"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch05lev3sec38"></A><H5 class="docSection3Title">Denormalization: Pre-joined Tables</H5>
<P class="docText">If two or more tables need to be joined on a regular basis by an application, but the cost of the join is too prohibitive to support, consider creating tables of pre-joined data. The pre-joined tables should<A NAME="ch05index1018"></A><A NAME="ch05index1019"></A><A NAME="ch05index1020"></A><A NAME="ch05index1021"></A><A NAME="ch05index1022"></A></P>
<UL><LI><P class="docList">Contain no redundant columns.</P></LI><LI><P class="docList">Contain only the columns necessary for the application to meet its processing needs.</P></LI><LI><P class="docList">Be created periodically using SQL to join the normalized tables.</P></LI></UL>
<P class="docText">The cost of the join is incurred only once, when the pre-joined tables are created. A pre-joined table can be queried efficiently because every new query does not incur the overhead of the table join process.</P>
<A NAME="ch05lev3sec39"></A><H5 class="docSection3Title">Denormalization: Report Tables</H5>
<P class="docText">Reports requiring special formatting or manipulation often are impossible to develop using SQL or QMF alone. If critical or highly visible reports of this nature must be viewed in an online environment, consider creating a table that represents the report. The table then can be queried using SQL or QMF.<A NAME="ch05index1023"></A><A NAME="ch05index1024"></A><A NAME="ch05index1025"></A><A NAME="ch05index1026"></A><A NAME="ch05index1027"></A></P>
<P class="docText">Create the report using the appropriate mechanism in a batch environment. The report data then can be loaded into the report table in the appropriate sequence. The report table should</P>
<UL><LI><P class="docList">Contain one column for every column of the report.</P></LI><LI><P class="docList">Have a clustering index on the columns that provide the reporting sequence.</P></LI><LI><P class="docList">Not subvert relational tenets (for example, atomic data elements).</P></LI></UL>
<P class="docText">Report tables are ideal for storing the results of outer joins or other complex SQL statements. If an outer join is coded and then loaded into a table, you can retrieve the results of the outer join using a simple <TT>SELECT</TT> statement instead of using the <TT>UNION</TT> technique discussed in <A class="docLink" HREF="ch01.html#ch01">Chapter 1</A>.</P>
<A NAME="ch05lev3sec40"></A><H5 class="docSection3Title">Denormalization: Mirror Tables</H5>
<P class="docText">If an application system is very active, you might need to split processing into two (or more) distinct components. This requires the creation of duplicate, or <span class="docEmphasis">mirror</span>, tables.<A NAME="ch05index1028"></A><A NAME="ch05index1029"></A><A NAME="ch05index1030"></A><A NAME="ch05index1031"></A><A NAME="ch05index1032"></A></P>
<P class="docText">Consider an application system that has heavy online traffic during the morning and early afternoon. The traffic consists of querying and updating data. Decision-support processing also is performed on the same application tables during the afternoon. The production work in the afternoon disrupts the decision-support processing, resulting in frequent timeouts and deadlocks.</P>
<P class="docText">These disruptions could be corrected by creating mirror tables: a foreground set of tables for the production traffic and a background set of tables for the decision-support reporting. To keep the application data-synchronized, you must establish a mechanism to migrate the foreground data periodically to the background tables. (One such mechanism is a batch job executing the <TT>UNLOAD</TT> utility on the data followed by running the <TT>LOAD</TT> utility to the target.) Migrate the information as often as necessary to ensure efficient and accurate decision-support processing.</P>
<P class="docText">Because the access needs of decision support and the production environment often are considerably different, different data definition decisions such as indexing and clustering may be chosen.</P>
<A NAME="ch05lev3sec41"></A><H5 class="docSection3Title">Denormalization: Split Tables</H5>
<P class="docText">If separate pieces of one normalized table are accessed by different and distinct groups of users or applications, consider splitting the table into one denormalized table for each distinct processing group. Retain the original table if other applications access the entire table; in this scenario, the split tables should be handled as a special case of mirror table.<A NAME="ch05index1033"></A><A NAME="ch05index1034"></A><A NAME="ch05index1035"></A><A NAME="ch05index1036"></A><A NAME="ch05index1037"></A></P>
<P class="docText">Tables can be split in two ways: vertically or horizontally. Refer to <A class="docLink" HREF="#ch05fig05">Figure 5.5</A>. A vertical split cuts a table column-wise, such that one group of columns is placed into a new table and the remaining columns are placed in another new table. Both of the split tables should retain the primary key columns. A horizontally split table is a row-wise split. To split a table horizontally, rows are classified into groups by key ranges. The rows from one key range are placed in one table, those from another key range are placed in a different table, and so on.</P>
<A NAME="ch05fig05"></A><p><CENTER><H5 class="docFigureTitle">Figure 5.5. Two methods of splitting tables.</H5>
<p class="docText"><IMG BORDER="0" width="450" height="256" SRC="images/0672326132/graphics/05fig05.gif" ALT="graphics/05fig05.gif"></p></CENTER></p><br>
<P class="docText">When splitting tables, designate one of the two tables as the parent table for referential integrity. If the original table still exists, it should be the parent table in all referential constraints. In this case, do not set up referential integrity for the split tables; they are derived from a referentially intact source.</P>
<P class="docText">When you split a table vertically, include one row per primary key in both tables to ease retrieval across tables. Do not eliminate rows from either of the two tables. Otherwise, updating and retrieving data from both tables is unnecessarily complicated.</P>
<P class="docText">When you split a table horizontally, try to split the rows between the new tables to avoid duplicating any one row in each new table. Simply stated, the operation of <TT>UNION ALL</TT>, when applied to the horizontally split tables, should not add more rows than those in the original, unsplit tables.<A NAME="ch05index1038"></A><A NAME="ch05index1039"></A><A NAME="ch05index1040"></A><A NAME="ch05index1041"></A><A NAME="ch05index1042"></A></P>
<A NAME="ch05lev3sec42"></A><H5 class="docSection3Title">Denormalization: Combined Tables</H5>
<P class="docText">If tables have a one-to-one relationship, consider combining them into a single table. Sometimes, one-to-many relationships can be combined into a single table, but the data update process is significantly complicated because of the increase in redundant data.<A NAME="ch05index1043"></A><A NAME="ch05index1044"></A><A NAME="ch05index1045"></A><A NAME="ch05index1046"></A><A NAME="ch05index1047"></A></P>
<P class="docText">For example, consider combining the sample tables <TT>DSN8810.DEPT</TT> and <TT>DSN8810.EMP</TT> into a large table called <TT>DSN8810.EMP_WITH_DEPT</TT>. (Refer to <A class="docLink" HREF="app01.html#app01">Appendix A</A> for a definition of the sample tables.) This new table would contain all the columns of both tables, except the <TT>DEPTNO</TT> column of <TT>DSN8810.DEPT</TT>. This column is excluded because it contains the same data as the <TT>ADMRDEPT</TT> column.</P>
<P class="docText">Each employee row therefore contains all the employee information, in addition to all the department information, for each employee. The department data is duplicated throughout the combined table because a department can employ many people. Tables of this sort should be considered pre-joined tables, not combined tables, and treated accordingly. Only tables with one-to-one relationships should be considered combined tables.</P>
<A NAME="ch05lev3sec43"></A><H5 class="docSection3Title">Denormalization: Redundant Data</H5>
<P class="docText">Sometimes one or more columns from one table are accessed whenever data from another table is accessed. If these columns are accessed frequently with tables other than those in which they were initially defined, consider carrying them in the other tables as redundant data. By carrying the additional columns, you can eliminate joins and increase the speed of data retrieval. Because this technique violates a tenet of database design, it should be attempted only if the normal access cannot efficiently support your business.<A NAME="ch05index1048"></A><A NAME="ch05index1049"></A><A NAME="ch05index1050"></A><A NAME="ch05index1051"></A><A NAME="ch05index1052"></A></P>
<P class="docText">Consider, once again, the <TT>DSN8810.DEPT</TT> and <TT>DSN8810.EMP</TT> tables. If most employee queries require the name of the employee's department, this column could be carried as redundant data in the <TT>DSN8810.EMP</TT> table. (Do not remove the column from the <TT>DSN8810.DEPT</TT> table, though.)</P>
<P class="docText">Columns you want to carry as redundant data should have the following attributes:</P>
<UL><LI><P class="docList">Only a few columns are necessary to support the redundancy.</P></LI><LI><P class="docList">The columns are stable, that is, updated infrequently.</P></LI><LI><P class="docList">The columns are used by many users or a few important users.</P></LI></UL>
<A NAME="ch05lev3sec44"></A><H5 class="docSection3Title">Denormalization: Repeating Groups</H5>
<P class="docText">When repeating groups are normalized, they are implemented as distinct rows instead of distinct columns. This usually results in higher disk storage requirements and less efficient retrieval, because there are more rows in the table and more rows must be read to satisfy queries that access the entire repeating group (or a subset of the repeating group).<A NAME="ch05index1053"></A><A NAME="ch05index1054"></A><A NAME="ch05index1055"></A><A NAME="ch05index1056"></A><A NAME="ch05index1057"></A></P>
<P class="docText">Sometimes you can achieve significant performance gains when you denormalize the data by storing it in distinct columns. These gains, however, come at the expense of flexibility.</P>
<P class="docText">For example, consider an application that stores repeating group information in the following normalized table:</P>
<pre>

</pre><BR><pre>
CREATE TABLE <span class="docEmphasis">user</span>.PERIODIC_BALANCES
   (CUSTOMER_NO        CHAR(11)        NOT NULL,
    BALANCE_PERIOD     SMALLINT        NOT NULL,
    BALANCE            DECIMAL(15,2),
    PRIMARY KEY (CUSTOMER_NO, BALANCE_PERIOD)
   )
</pre><BR>
<P class="docText">Available storage and DB2 requirements are the only limits to the number of balances per customer that you can store in this table. If you decide to string out the repeating group, <TT>BALANCE</TT>, into columns instead of rows, you must limit the number of balances to be carried in each row. The following is an example of stringing out repeating groups into columns after denormalization:</P>
<pre>

</pre><BR><pre>
CREATE TABLE <span class="docEmphasis">user</span>.PERIODIC_BALANCES
   (CUSTOMER_NO        CHAR(11)        NOT NULL,
    PERIOD1_BALANCE    DECIMAL(15,2),
    PERIOD2_BALANCE    DECIMAL(15,2),
    PERIOD3_BALANCE    DECIMAL(15,2),
    PERIOD4_BALANCE    DECIMAL(15,2),
    PERIOD5_BALANCE    DECIMAL(15,2),
    PERIOD6_BALANCE    DECIMAL(15,2),
    PRIMARY KEY (CUSTOMER_NO)
   )
IN SAMPLE.BALANCE;
</pre><BR>
<P class="docText">In this example, only six balances can be stored for each customer. The number six is not important, but the limit on the number of values is important; it reduces the flexibility of data storage and should be avoided unless performance needs dictate otherwise.</P>
<P class="docText">Before you decide to implement repeating groups as columns instead of rows, be sure that the data:</P>
<UL><LI><P class="docList">Rarely—preferably never—is aggregated, averaged, or compared in the row</P></LI><LI><P class="docList">Occurs in a statistically well-behaved pattern</P></LI><LI><P class="docList">Has a stable number of occurrences</P></LI><LI><P class="docList">Usually is accessed collectively</P></LI><LI><P class="docList">Has a predictable pattern of insertion and deletion</P></LI></UL>
<P class="docText">If any of the preceding criteria is not met, some SQL statements could be difficult to code—making the data less available due to inherently unsound data-modeling practices. This should be avoided, because you usually denormalize data to make it more readily available.<A NAME="ch05index1058"></A><A NAME="ch05index1059"></A><A NAME="ch05index1060"></A><A NAME="ch05index1061"></A><A NAME="ch05index1062"></A></P>
<A NAME="ch05lev3sec45"></A><H5 class="docSection3Title">Denormalization: Derivable Data</H5>
<P class="docText">If the cost of deriving data with complicated formulas is prohibitive, consider storing the derived data instead of calculating it. When the underlying values that compose the calculated value change, the stored derived data must be changed also; otherwise, inconsistent information could be reported.<A NAME="ch05index1063"></A><A NAME="ch05index1064"></A><A NAME="ch05index1065"></A><A NAME="ch05index1066"></A><A NAME="ch05index1067"></A></P>
<P class="docText">Sometimes you cannot immediately update derived data elements when the columns on which they rely change. This can occur when the tables containing the derived elements are offline or are being operated on by a utility. In this situation, time the update of the derived data so that it occurs immediately after the table is available for update. Outdated derived data should never be made available for reporting and queries.</P>
<A NAME="ch05lev3sec46"></A><H5 class="docSection3Title">Denormalization: Hierarchies</H5>
<P class="docText">A hierarchy is easy to support using a relational database such as DB2, but difficult to retrieve information from efficiently. For this reason, applications that rely on hierarchies often contain denormalized tables to speed data retrieval. Two examples of these types of systems are a Bill of Materials application and a Departmental Reporting system. A Bill of Materials application typically records information about parts assemblies, in which one part is composed of other parts. A Department Reporting system typically records the departmental structure of an organization, indicating which departments report to which other departments.<A NAME="ch05index1068"></A><A NAME="ch05index1069"></A><A NAME="ch05index1070"></A><A NAME="ch05index1071"></A></P>
<P class="docText">An effective way to denormalize a hierarchy is to create <span class="docEmphasis">speed tables</span>. <A class="docLink" HREF="#ch05fig06">Figure 5.6</A> depicts a department hierarchy for a given organization. The hierarchic tree is built so that the top node is the entire corporation. The other nodes represent departments at various levels in the corporation.</P>
<A NAME="ch05fig06"></A><p><CENTER><H5 class="docFigureTitle">Figure 5.6. A department hierarchy.</H5><A NAME="ch05index1072"></A><A NAME="ch05index1073"></A><A NAME="ch05index1074"></A>
<p class="docText"><IMG BORDER="0" width="250" height="263" SRC="images/0672326132/graphics/05fig06.gif" ALT="graphics/05fig06.gif"></p></CENTER></p><br>
<P class="docText">Department 123456 is the entire corporation. Departments 1234 and 56 report directly to 123456. Departments 12, 3, and 4 report directly to 1234 and indirectly to department 123456, and so on. This can be represented in a DB2 table as follows:</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="groups" CELLPADDING="5"><COLGROUP><COL width="170.5"><COL width="192.5"><COL width="187"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><TT>DEPTNO</TT></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphasis"><TT>PARENT_DEPTNO</TT></span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText">&#8230;other columns</P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Department Table</span></P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">123456</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">------</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">1234</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">123456</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">56</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">123456</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">12</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1234</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">3</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1234</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1234</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">12</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">2</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">12</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">5</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">56</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">6</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">56</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR></TABLE></P><br>
<P class="docText">This DB2 table is a classic relational implementation of a hierarchy. There are two department columns: one for the parent and one for the child. The table's data is an accurately normalized version of this hierarchy, containing everything represented in <A class="docLink" HREF="#ch05fig06">Figure 5.6</A>. The complete hierarchy can be rebuilt with the proper data retrieval instructions.<A NAME="ch05index1075"></A><A NAME="ch05index1076"></A><A NAME="ch05index1077"></A><A NAME="ch05index1078"></A></P>
<P class="docText">Even though the implementation effectively records the entire hierarchy, a query to report all the departments under any other department is time consuming to code and inefficient to process. A sample query that returns all the departments reporting to the corporate node, 123456, is illustrated by this rather complex SQL statement:<A NAME="ch05index1079"></A><A NAME="ch05index1080"></A><A NAME="ch05index1081"></A></P>
<pre>

</pre><BR><pre>
SELECT  DEPTNO
FROM    DEPARTMENT
WHERE   PARENT_DEPTNO = '123456'
UNION
SELECT  DEPTNO
FROM    DEPARTMENT
WHERE   PARENT_DEPTNO IN
        (SELECT  DEPTNO
         FROM    DEPARTMENT
         WHERE   PARENT_DEPTNO = '123456')
UNION
SELECT  DEPTNO
FROM    DEPARTMENT
WHERE   PARENT_DEPTNO IN
        (SELECT  DEPTNO
         FROM    DEPARTMENT
         WHERE   PARENT_DEPTNO IN
                 (SELECT  DEPTNO
                  FROM    DEPARTMENT
                  WHERE   PARENT_DEPTNO = '123456'));
</pre><BR>
<P class="docText">This query can be built only if you know in advance the total number of possible levels the hierarchy can achieve. If there are <span class="docEmphasis">n</span> levels in the hierarchy, you need <span class="docEmphasis">n-1</span> <TT>UNION</TT>s. The previous SQL statement assumes that only three levels are between the top and bottom of the department hierarchy. For every possible level of the hierarchy, you must add a more complex <TT>SELECT</TT> statement to the query in the form of a <TT>UNION</TT>. This implementation works, but is difficult to use and inefficient.</P>
<P class="docText">A faster way to query a hierarchy is to use a speed table. A speed table contains a row for every combination of the parent department and all its dependent departments, regardless of the level. Data is replicated in a speed table to increase the speed of data retrieval. The speed table for the hierarchy presented in <A class="docLink" HREF="#ch05fig06">Figure 5.6</A> is:<A NAME="ch05index1082"></A><A NAME="ch05index1083"></A><A NAME="ch05index1084"></A><A NAME="ch05index1085"></A><A NAME="ch05index1086"></A><A NAME="ch05index1087"></A><A NAME="ch05index1088"></A><A NAME="ch05index1089"></A></P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="groups" CELLPADDING="5"><COLGROUP><COL width="104.5"><COL width="99"><COL width="88"><COL width="93.5"><COL width="165"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><TT>PARENT DEPTNO</TT></P></TH><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><TT>CHILD DEPTNO</TT></P></TH><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><TT>LEVEL</TT></P></TH><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><TT>DETAIL</TT></P></TH><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><span class="docEmphStrong">...other columns</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">123456</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1234</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">123456</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">56</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">123456</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">12</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">123456</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">3</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">123456</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">3</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">123456</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">3</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">123456</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">123456</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">5</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">123456</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">6</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">1234</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">12</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">1234</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">1234</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">1234</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">3</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">1234</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">3</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">3</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">4</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">12</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">12</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">2</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">56</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">5</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">56</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">6</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">5</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">5</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">6</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">6</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR></TABLE></P><br>
<P class="docText">Contrast this to the previous table, which recorded only the immediate children for each parent. The <TT>PARENT_DEPTNO</TT> column is the top of the hierarchy. The <TT>CHILD_DEPTNO</TT> column represents all the dependent nodes of the parent. The <TT>LEVEL</TT> column records the level in the hierarchy. The <TT>DETAIL</TT> column contains Y if the row represents a node at the bottom of the hierarchy, or N if the row represents a node that is not at the bottom. A speed table commonly contains other information needed by the application. Typical information includes the level in the hierarchy for the given node and, if the order within a level is important, the sequence of the nodes at the given level.</P>
<P class="docText">After the speed table has been built, you can write speed queries. The following are several informative queries. They would be inefficient if executed against the classical relational hierarchy, but are efficient when run against a speed table.</P>
<P class="docText">To retrieve all dependent departments for department 123456,</P>
<pre>

</pre><BR><pre>
SELECT   CHILD_DEPTNO
FROM     DEPARTMENT_SPEED
WHERE    PARENT_DEPTNO = '123456';
</pre><BR>
<P class="docText">To retrieve only the bottom-most, detail departments that report to department 123456,</P>
<pre>

</pre><BR><pre>
SELECT   CHILD_DEPTNO
FROM     DEPARTMENT_SPEED
WHERE    PARENT_DEPTNO = '123456'
AND      DETAIL = 'Y';
</pre><BR>
<P class="docText">To return the complete department hierarchy for department 123456,</P>
<pre>

</pre><BR><pre>
SELECT   PARENT_DEPTNO, CHILD_DEPTNO, LEVEL
FROM     DEPARTMENT_SPEED
WHERE    PARENT_DEPTNO = '123456'
ORDER BY LEVEL;
</pre><BR>
<P class="docText">A speed table commonly is built using a program written in COBOL or another high-level language. SQL alone usually is too inefficient to handle the creation of a speed table.<A NAME="ch05index1090"></A><A NAME="ch05index1091"></A><A NAME="ch05index1092"></A><A NAME="ch05index1093"></A><A NAME="ch05index1094"></A><A NAME="ch05index1095"></A><A NAME="ch05index1096"></A><A NAME="ch05index1097"></A></P>
<A NAME="ch05note38"></A><div class="docNote"><p class="docNoteTitle">NOTE</p><p><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" ALIGN="LEFT" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText">With the advent of recursive SQL support in DB2 V8, the need to denormalize for hierarchies is greatly diminished. The nature of recursive SQL makes it ideal for traversing hierarchical data stored in normalized, DB2 tables. Refer back to <A class="docLink" HREF="ch02.html#ch02">Chapter 2</A> for more information on recursion.</P></td></tr></table></p></div><br>
<A NAME="ch05lev3sec47"></A><H5 class="docSection3Title">Denormalization to Avoid Large Page Sizes</H5>
<P class="docText">You can denormalize your tables to avoid using page sizes greater than 4KB. If a table space is so large as to have pages that require more than 4KB, DB2 will force the use of a larger page size (and buffer pool). DB2 supports 8KB, 16KB, and 32KB pages in addition to the standard 4KB page size.<A NAME="ch05index1098"></A><A NAME="ch05index1099"></A><A NAME="ch05index1100"></A><A NAME="ch05index1101"></A><A NAME="ch05index1102"></A></P>
<P class="docText">A larger page size can increase overhead. For example, DB2 arranges a table space assigned to the <TT>BP32K</TT> buffer pool as 8 single 4KB pages per 32KB page. Every logical I/O to a 32KB table space requires 8 physical I/Os. You can use the vertical split technique to denormalize tables that would otherwise require pages greater than 4KB.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> With DB2 V8 you have the ability to specify the actual CI size of the VSAM file to synchronize it with the DB2 page size. Using this approach is generally preferable, and easier, than vertically splitting the table.</P></td></tr></table><br>
<A NAME="ch05lev2sec15"></A><H4 class="docSection2Title">Denormalization Guidelines</H4>
<P class="docText">Be sure to follow these tips and techniques when making your denormalization decision—and afterward to manage your databases effectively.</P>
<A NAME="ch05lev4sec74"></A><H5 class="docSection3Title">Look for Ways to Avoid Denormalization</H5>
<P class="docText">Whenever possible, you should avoid denormalizing your DB2 databases. Look for DB2 features and functionality that can be used in place of a denormalized implementation.<A NAME="ch05index1103"></A><A NAME="ch05index1104"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> For example, DB2 V8 introduces recursive SQL. Therefore, as of DB2 V8, you should try to implement fully normalized hierarchies and query them using recursive queries instead of using a denormalization technique like speed tables. More information on recursion is provided in <A class="docLink" HREF="ch02.html#ch02">Chapter 2</A>.</P></td></tr></table><br>
<A NAME="ch05lev4sec75"></A><H5 class="docSection3Title">Periodically Test the Validity of Denormalization</H5>
<P class="docText">The decision to denormalize <span class="docEmphBoldItalic">never</span> should be made lightly: Denormalization involves a lot of administrative dedication. This dedication takes the form of documenting denormalization decisions, ensuring valid data, scheduling migration, and keeping end users informed about the state of the tables. An additional category of administrative overhead is periodic analysis.<A NAME="ch05index1105"></A><A NAME="ch05index1106"></A><A NAME="ch05index1107"></A><A NAME="ch05index1108"></A></P>
<P class="docText">When an application has denormalized data, you should review the data and the environment periodically. Changes in hardware, software, and application requirements can alter the need for denormalization. To verify whether denormalization still is a valid decision, ask the following questions:</P>
<UL><LI><P class="docList">Have the application-processing requirements changed such that the join criteria, the timing of reports, or the transaction throughput no longer require denormalized data?</P></LI><LI><P class="docList">Did a new software release change performance considerations? For example, does the introduction of 8KB and 16KB page sizes in DB2 Version 6 alleviate the need for denormalization to avoid 32K page sizes? Or, did the introduction of a new join method or faster join processing undo the need for pre-joined tables?</P></LI><LI><P class="docList">Did a new hardware release change performance considerations? For example, does a CPU upgrade reduce the amount of CPU consumption such that denormalization no longer is necessary?</P></LI></UL>
<P class="docText">In general, periodically test whether the extra cost related to processing with normalized tables justifies the benefit of denormalization. Monitor and reevaluate all denormalized applications by measuring the following criteria:</P>
<UL><LI><P class="docList">I/O saved</P></LI><LI><P class="docList">CPU saved</P></LI><LI><P class="docList">Complexity of update programming</P></LI><LI><P class="docList">Cost of returning to a normalized design</P></LI></UL>
<A NAME="ch05note39"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">To summarize, remember these basic rules:</P>
<UL><LI><P class="docList">All things being equal, always favor a normalized design over a denormalized design.</P></LI><LI><P class="docList">Normalization optimizes data modification at the expense of data access.</P></LI><LI><P class="docList">Denormalization optimizes data access at the expense of data modification.</P></LI></UL></div><br>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch05lev1sec5.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch05lev1sec7.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
