<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Creating Indexes</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch06.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch06lev1sec2.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch06lev1sec1"></A><H3 class="docSection1Title">Creating Indexes</H3>
<P class="docText">A proper indexing strategy can be the most important factor to ensure optimal performance of DB2 applications. However, indexing is most likely improperly implemented at most DB2 sites. This is due to the nature of database development. Database objects typically are created near the beginning of a project—after the logical data model has been transformed into a physical database design, but before any application code or SQL has been written. So the DBA takes an initial best guess at creating some indexes on each table. Of course, indexes are best designed based on how the data will be accessed. Without the SQL, proper indexes cannot be created. Therefore, as the development process progresses an iterative approach is taken to index creation. New indexes are created to support new queries; old indexes are removed if they are not being used. Such an approach is fraught with potential problems, but such is life.<A NAME="ch06index07"></A></P>
<P class="docText">Indexes should be created to match the predicates of your most important and frequently executed SQL statements. When DB2 accesses data using an index, it can be much more efficient than scanning an entire table for the row(s) that apply. For example, consider the following SQL statement:</P>
<pre>

</pre><BR><pre>
SELECT FIRSTNME, MIDINIT, LASTNAME, WORKDEPT,
       PHONENO, SALARY
FROM   DSN8810.EMP
WHERE  EDLEVEL = 2
AND    BONUS &gt; 100.00;
</pre><BR>
<P class="docText">If there are no indexes defined on the EMP table, DB2 will have to search every row of the table, looking for employees with an education level of 2 and a bonus greater than $100.00. But if we define an index on the table—on either or both of the two columns in the predicates—then DB2 can use the index to find the qualifying rows. This should reduce I/O and improve performance.</P>
<P class="docText">An index on <TT>EDLEVEL</TT>, <TT>BONUS</TT> would be the most beneficial for this query. DB2 can match on the equality predicate and scan on the range (<TT>&gt;</TT>) predicate. So, DB2 can use the index to match the value of <TT>EDLEVEL</TT> and scan for <TT>BONUS</TT> values.</P>
<P class="docText">An index is created using the <TT>CREATE INDEX</TT> statement, which is similar in several ways to the <TT>CREATE TABLESPACE</TT> statement. Both require the user to specify storage (<TT>USING</TT>, <TT>PRIQTY</TT>, and <TT>SECQTY</TT>), free space (<TT>PCTFREE</TT> and <TT>FREEPAGE</TT>), a buffer pool (<TT>BUFFERPOOL</TT>), and how to close the underlying data sets (<TT>CLOSE</TT>). However, there are also many differences.<A NAME="ch06index08"></A><A NAME="ch06index09"></A></P>
<P class="docText">One big difference is that separate <TT>CREATE</TT> statements are not used to create an index and an index space. An index space is the underlying storage structure for index data and it is automatically created by DB2 whenever an index is created. There can only be one index in an index space.</P>
<P class="docText">Of course, there are many other differences because indexes are different from table spaces, and serve different data processing needs.</P>
<P class="docText">In DB2, uniqueness is enforced using an index. You can create a unique index that forces the columns specified for the index to be unique within the table. If you try to <TT>INSERT</TT> or <TT>UPDATE</TT> these columns with non-unique values, an error code is returned and the request fails. Creating a unique index is the only way to ensure uniqueness for a column (or columns) in DB2.</P>
<P class="docText">You can use an index to guide DB2 to control how table space data is physically stored on disk. This is called <span class="docEmphBoldItalic">clustering</span>. A DB2 index is a clustering index if the <TT>CLUSTER</TT> keyword is specified when the index is created. Clustering causes inserted rows to be stored contiguously in sequence whenever possible. Additionally, when the table space is reorganized the data will be sequenced according to the clustering index. Since there can only be one physical sequence for data on disk, there can only be one clustering index per table. If you do not specify a clustering index DB2 will choose to cluster the data using the oldest existing index. It is wise to explicitly specify a clustering index instead of letting DB2 decide because you will almost always choose better than the (basically random) choice DB2 makes.<A NAME="ch06index10"></A><A NAME="ch06index11"></A><A NAME="ch06index12"></A><A NAME="ch06index13"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> Indexes also can be used to control partitioning. Prior to DB2 V8, a partitioning index was the only way to partition data. As of V8, though, partitioning can be specified and controlled in the table DDL. Notwithstanding this separation of partitioning from indexing, an index can be partitioned itself into separate data sets.<A NAME="ch06index14"></A><A NAME="ch06index15"></A></P></td></tr></table><br>
<P class="docText">Indexed columns can be specified as ascending or descending. This is accomplished by specifying either <TT>ASC</TT> or <TT>DESC</TT> after each column in the index. Specifying <TT>ASC</TT> causes index entries to be in ascending order by the column (this is the default). <TT>DESC</TT> puts the index entries in descending order by the column.<A NAME="ch06index16"></A><A NAME="ch06index17"></A></P>
<P class="docText">Finally, through the use of the <TT>DEFINE</TT> and <TT>DEFER</TT> parameters DB2 can delay the creation of the index and its data sets until a later time.<A NAME="ch06index18"></A></P>
<A NAME="ch06lev2sec1"></A><H4 class="docSection2Title">Index Considerations</H4>
<P class="docText">Before creating any indexes, you should analyze your data and consider the following factors:<A NAME="ch06index19"></A></P>
<P class="docText"><sup class="docFootnote"><A class="docLink" HREF="#ch06fn01">[1]</A></sup></P><blockquote><p class="docFootnote"><sup><A NAME="ch06fn01">[1]</A></sup> <span class="docEmphasis">Actually, if no clustering index is explicitly defined, DB2 uses the index with the lowest OBID to cluster the data. This usually results in the oldest index being used for clustering, but not necessarily because OBIDs can be reused.</span></p></blockquote>
<UL><LI><P class="docList">Percentage of table access versus table update</P></LI><LI><P class="docList">Data access patterns, both ad hoc and planned</P></LI><LI><P class="docList">Amount of data accessed by each query against the table</P></LI><LI><P class="docList">Impact on recovery</P></LI><LI><P class="docList">Performance requirements of accessing the table</P></LI><LI><P class="docList">Performance requirements of modifying the table</P></LI><LI><P class="docList">Frequency of <TT>INSERT</TT>, <TT>UPDATE</TT>, and <TT>DELETE</TT> operations</P></LI><LI><P class="docList">Storage requirements</P></LI><LI><P class="docList">Impact of reorganization</P></LI><LI><P class="docList">Impact on the <TT>LOAD</TT> utility</P></LI></UL>
<P class="docText">Remember that indexes are created to enhance performance. Although an index may speed up the performance of a query, each new index will degrade data modification. Keep the following in mind as you create indexes:</P>
<UL><LI><P class="docList">Consider indexing on columns used in <TT>WHERE</TT>, <TT>GROUP BY</TT>, <TT>ORDER BY</TT>, and <TT>UNION ALL</TT> clauses.</P></LI><LI><P class="docList">Limit the indexing of frequently updated columns.</P></LI><LI><P class="docList">If indexing a table, explicitly create a clustering index. Failure to do so will result in DB2 clustering data by the first index created. If indexes are subsequently dropped and re-created, this can change the clustering sequence if the indexes are created in a different order.<A NAME="ch06index20"></A><A NAME="ch06index21"></A></P></LI><LI><P class="docList">Consider clustering on columns in <TT>GROUP BY</TT> and <TT>ORDER BY</TT> specifications to improve sequential access.</P></LI><LI><P class="docList">If no sorting or grouping is required, analyze your <TT>WHERE</TT> clauses and cluster on the columns most frequently referenced, or better yet, most frequently run.</P></LI><LI><P class="docList">Choose the first column of multi-column indexes wisely, based on the following hierarchy. First, choose columns that will be specified most frequently in SQL <TT>WHERE</TT> clauses (unless cardinality is very low). Second, choose columns that will be referenced most often in <TT>ORDER BY</TT> and <TT>GROUP BY</TT> clauses (once again, unless cardinality is very low). Third, choose columns with the highest cardinality.</P><A NAME="ch06note01"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Low cardinality of the first column is not an issue if a filtering value will always be provided in each query using equality, for example, a predicate like <TT>WHERE COL = :HOSTVAR</TT> or <TT>WHERE COL IN (</TT><span class="docEmphasis"><TT>list</TT></span><TT>)</TT>.</P></div><br></LI><LI><P class="docList">The biggest payback from an index comes from DB2's capability to locate and retrieve referenced data quickly. DB2's capability to do this is reduced when cardinality is low because multiple RIDs satisfy a given reference. Balance the cardinality of a column against the amount of time it is accessed, giving preference to data access over cardinality.</P></LI><LI><P class="docList">There are no hard and fast rules for index creation. Experiment with different index combinations and gauge the efficiency of the results.</P></LI><LI><P class="docList">Keep the number of columns in an index to a minimum. If only three columns are needed, index only those three columns. As more columns are added to the index, data modification degrades.</P></LI><LI><P class="docList">Sometimes, however, it can be advantageous to include additional columns in an index to increase the chances of index-only access. (Index-only access is discussed further in <A class="docLink" HREF="ch21.html#ch21">Chapter 21</A>, "The Optimizer.") For example, suppose that there is an index on the <TT>DEPTNO</TT> column of the <TT>DSN8810.DEPT</TT> table. The following query may use this index:</P><pre>

</pre><BR><pre>
SELECT  DEPTNAME
FROM    DSN8810.DEPT
WHERE   DEPTNO &gt; 'D00';
</pre><BR><P class="docList">DB2 could use the index to access only those columns with a <TT>DEPTNO</TT> greater than <TT>D00</TT>, and then access the data to return the <TT>DEPT</TT>.<A NAME="ch06index22"></A></P></LI></UL>
<A NAME="ch06note02"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">A good rule of thumb for index creation is to keep creating indexes to enhance the performance of your queries until the performance of data modification becomes unacceptable. Then, delete the last index you created. This general approach is best described as creating indexes until it hurts.<A NAME="ch06index23"></A></P></div><br>
<A NAME="ch06lev2sec2"></A><H4 class="docSection2Title">Indexing Variable Columns</H4>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> Prior to Version 8, when indexing on a variable column, DB2 automatically pads the variable column out to its maximum size. So, for example, creating an index on a column defined as <TT>VARCHAR(50)</TT> will cause the index key to be padded out to the full 50 bytes. Padding poses several problems. You cannot get index-only access with a padded index because DB2 will always have to access the table space data to retrieve the actual size of each column. Remember, the size of a variable-length column is stored in a two-byte prefix and this information is not in a padded index. Also, padding very large variable columns can create a very large index with a lot of wasted space.<A NAME="ch06index24"></A><A NAME="ch06index25"></A><A NAME="ch06index26"></A></P></td></tr></table><br>
<P class="docText">DB2 V8 offers the capability to direct DB2 as to whether variable columns in an index should be padded. Appropriately enough, a new option, <TT>PADDED</TT> (or <TT>NOT PADDED</TT>) can be specified when creating indexes. The specification is made at the index level, so every variable column in the index will be either padded or not padded.<A NAME="ch06index27"></A><A NAME="ch06index28"></A><A NAME="ch06index29"></A><A NAME="ch06index30"></A><A NAME="ch06index31"></A><A NAME="ch06index32"></A><A NAME="ch06index33"></A></P>
<P class="docText">When <TT>PADDED</TT> is specified, DB2 will create the index just as it did prior to V8—by padding all variable columns to their maximum size. When <TT>NOT PADDED</TT> is specified, DB2 will treat the columns as variable and you will be able to obtain index-only access. The length information will be stored in the index key.</P>
<A NAME="ch06note03"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Keep in mind that DB2 cannot perform index-only access using a padded index—even if every required column exists in the index. This is so because the actual length of the <TT>VARCHAR</TT> column(s) is not stored in a padded index. So, DB2 will have to access the table to retrieve the length from the two-byte column prefix.</P></div><br>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> A new DSNZPARM, named <TT>PADIX</TT>, is provided to control whether the default is <TT>PADDED</TT> or <TT>NOT PADDED</TT> when an index is created and neither is specified. By default, DB2 will create <TT>PADDED</TT> indexes if you migrate from V7 to V8 but will create <TT>NOT PADDED</TT> indexes if you install V8 from scratch.<A NAME="ch06index34"></A><A NAME="ch06index35"></A><A NAME="ch06index36"></A><A NAME="ch06index37"></A><A NAME="ch06index38"></A></P></td></tr></table><br>
<A NAME="ch06note04"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Remember the precaution from <A class="docLink" HREF="ch05.html#ch05">Chapter 5</A>, "Data Definition Guidelines," to avoid defaults. Set up the <TT>PADIX</TT> parameter to create the type of indexes you prefer by default, but when creating indexes be sure to explicitly specify either <TT>PADDED</TT> or <TT>NOT PADDED</TT> so that you are assured of creating the type of index you want to create every time. Relying on defaults is lazy and potentially fraught with problems.</P></div><br>
<A NAME="ch06lev2sec3"></A><H4 class="docSection2Title">Indexing and Partitioning</H4>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> The indexing requirements for partitioning change significantly in DB2 Version 8. For all releases of DB2 up through and including Version 7, a partitioning index is required to specify the limit keys for each partition; this means that a partitioning index was required and was used to determine which data goes into which partition.<A NAME="ch06index39"></A><A NAME="ch06index40"></A></P></td></tr></table><br>
<P class="docText">This all changes with DB2 Version 8. To understand partitioning in DB2 V8, first we need to define some terminology: namely, partitioned versus partitioning.</P>
<BLOCKQUOTE><P><p class="docText"><span class="docEmphStrong">Partitioned and non-partitioned</span>— 
A partitioned index means that the index itself is physically partitioned into separate data sets; a non-partitioned index, though, might still be a partitioning index.<A NAME="ch06index41"></A><A NAME="ch06index42"></A><A NAME="ch06index43"></A><A NAME="ch06index44"></A></p></P><P><p class="docText"><span class="docEmphStrong">Partitioning and secondary index</span>— 
A partitioning index means that the index keys correlate to the columns used to partition the data. The index might or might not also be partitioned.<A NAME="ch06index45"></A><A NAME="ch06index46"></A><A NAME="ch06index47"></A><A NAME="ch06index48"></A></p></P></BLOCKQUOTE>
<P class="docText">Control of partitioning changes from index-controlled to table-controlled as of DB2 V8. Actually, DB2 V8 supports both types of partitioning, but table-controlled partitioning enables new features not supported under index-controlled partitioning. For example, the ability to easily add or rotate partitions is only supported with table-controlled partitioning.</P>
<A NAME="ch06note05"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">DB2 will automatically switch from index-based to table-based partitioning if any of the following operations are performed:</P>
<UL><LI><P class="docList">Dropping the partitioning index</P></LI><LI><P class="docList">Altering the partitioning index to be not clustered</P></LI><LI><P class="docList">Adding a partition using <TT>ALTER TABLE ADD PART</TT></P></LI><LI><P class="docList">Rotating partitions using <TT>ALTER TABLE ALTER PART ROTATE</TT></P></LI><LI><P class="docList">Altering a partition using <TT>ALTER TABLE ALTER PART </TT><span class="docEmphasis"><TT>n</TT></span></P></LI><LI><P class="docList">Creating a data-partitioned secondary index (DPSI)</P></LI><LI><P class="docList">Creating an index with the <TT>VALUES</TT> clause, but without the <TT>CLUSTER</TT> keyword</P></LI></UL></div><br>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> When creating partitioned table spaces using DB2 Version 8 or greater, use table-controlled partitioning instead of index-controlled partitioning. Also, you should seriously consider switching your current index-controlled partitioning structures to be table-controlled because of the additional flexibility and functionality it provides.<A NAME="ch06index49"></A><A NAME="ch06index50"></A></P></td></tr></table><br>
<A NAME="ch06lev3sec1"></A><H5 class="docSection3Title">Clustering and Partitioning</H5>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> Prior to DB2 V8, the partitioning index for a partitioned table space had to be a clustering index. This means that the data in the table space had to be clustered by the partitioning columns. As of DB2 V8, though, data in a partitioned table space no longer needs to be clustered by the partitioning key. That is, clustering and partitioning are completely independent from each other as of V8.<A NAME="ch06index51"></A><A NAME="ch06index52"></A></P></td></tr></table><br>
<A NAME="ch06lev3sec2"></A><H5 class="docSection3Title">Data Partitioned Secondary Indexes</H5>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> One of the biggest problems DBAs face when they are managing large partitioned DB2 table spaces is contending with non-partitioned indexes. DB2 Version 8 helps to remedy these problems with a new type of index—the data partitioned secondary index, or DPSI (pronounced dipsy). However, before we examine the solution, let's first investigate the problem in a little more detail.<A NAME="ch06index53"></A><A NAME="ch06index54"></A><A NAME="ch06index55"></A><A NAME="ch06index56"></A></P></td></tr></table><br>
<A NAME="ch06lev4sec1"></A><H5 class="docSection4Title">Problems With Non-Partitioning Indexes</H5>
<P class="docText">Prior to V8, a partitioning index was required to define a partitioned table space. The <TT>CREATE INDEX</TT> statement specifies the range of values that DB2 will store in each specific partition. The partitioning index will have individual <TT>PART</TT> clauses, each of which specifies the highest value that can be stored in the partition. To illustrate, consider the following SQL to create a partitioning index:<A NAME="ch06index57"></A><A NAME="ch06index58"></A><A NAME="ch06index59"></A><A NAME="ch06index60"></A></P>
<pre>

</pre><BR><pre>
CREATE INDEX XEMP2
  ON DSN8710.EMP (EMPNO ASC)
    USING STOGROUP DSN8G710
    PRIQTY 36 ERASE NO CLUSTER
      (PART 1 VALUES('H99'),
       PART 2 VALUES('P99'),
       PART 3 VALUES('Z99'),
       PART 4 VALUES('999'))
    BUFFERPOOL BP1
    CLOSE YES
    COPY YES;
</pre><BR>
<P class="docText">This creates four partitions. Behind the scenes, DB2 will create four separate data sets—both for the table space data and for the index data. However, all other indexes defined on the table will be regular, non-clustering DB2 indexes—that is, non-partitioning indexes (NPIs). An NPI resides in a single data set unless the <TT>PIECESIZE</TT> clause is used to break it apart—and even then the data will not be broken apart by partition. (The <TT>PIECESIZE</TT> clause is covered in more detail later in this chapter.)</P>
<A NAME="ch06note06"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" ALIGN="LEFT" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> As of DB2 V8, NPIs are also referred to as NPSIs (where the S stands for secondary). In this book, the terms NPI and NPSI are used synonymously.</P></td></tr></table><br></div><br>
<P class="docText">NPIs can cause contention, particularly with DB2 utilities. You can run a utility against a single table space or index partition, but you do not have that luxury with NPIs because they are not partitioned. You can minimize and manage downtime by running utilities a partition at a time. However, running utilities against NPIs can impact the availability of an entire table space. Because an NPI contains data for an entire table space, not just for a single partition, utility operations on an NPI can cause downtime across an entire table space. Additionally, contention on NPIs can cause performance bottlenecks during parallel update, insert, and delete operations.<A NAME="ch06index61"></A><A NAME="ch06index62"></A></P>
<A NAME="ch06lev4sec2"></A><H5 class="docSection4Title">Solving Problems with DPSIs?</H5>

<P class="docText">DB2 V8 introduces the Data Partitioned Secondary Index, or DPSI. DPSIs are significant because they help to resolve the problems involved with NPIs discussed in the preceding section. A DPSI is basically a partitioned NPI.<A NAME="ch06index63"></A><A NAME="ch06index64"></A><A NAME="ch06index65"></A></P>
<P class="docText">Consult <A class="docLink" HREF="#ch06fig02">Figure 6.2</A> for a graphical depiction of the difference between a DPSI and an NPI. This diagram shows a table space partitioned by month. We need to build an index on the CUSTNO for access requirements, but we have a choice as to whether we create an NPI or a DPSI. You can see the different results in the diagram: The DPSI will be partitioned by the same key ranges as the table, but the NPI will not be partitioned at all.</P>
<A NAME="ch06fig02"></A><p><CENTER><H5 class="docFigureTitle">Figure 6.2. DPSI versus NPI.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/06fig02_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="491" SRC="images/0672326132/graphics/06fig02.gif" ALT="graphics/06fig02.gif"></p></CENTER></p><br>
<P class="docText">So, with a DPSI the index will be partitioned based on the data rows. The number of parts in the index will be equal to the number of parts in the table space—even though the DPSI is created based on columns that are different from those used to define the partitioning scheme for the table space. Therefore, partition 1 of the DPSI will be for the same rows as partition 1 of the table space, and so on. These changes provide many benefits, including</P>
<UL><LI><P class="docList">The ability to cluster by a secondary index</P></LI><LI><P class="docList">The ability to drop and rotate partitions easily</P></LI><LI><P class="docList">Potentially less overhead in data sharing</P></LI></UL>
<P class="docText">NPIs historically have caused DB2 performance and availability problems, especially with utilities. DPSIs solve many of these problems. With DPSIs there is an independent index tree structure for every partition. This means that utilities do not have to share pages or index structures. In addition, logical drains on indexes are now physically at the partition level. This helps utility processing in several useful ways. For example, you can run a <TT>LOAD</TT> by partition with no contention because the DPSI is partitioned the same way as the data and the partitioning index. Additionally, when reorganizing with DPSIs, the <TT>BUILD2</TT> phase is not needed. Even your recovery procedures might be aided because you can copy and recover a single partition of a DPSI.</P>
<P class="docText">However, DPSIs are not magical objects that solve all problems. Indeed, changing an NPI to a DPSI will likely cause some queries to perform worse than before. Some queries will need to examine multiple partitions of the DPSI as opposed to the single NPI it previously used. On the other hand, if the query has predicates that reference columns in a single partition only, then performance might improve because only one DPSI partition needs to be probed.</P>
<P class="docText">Keep in mind that each DPSI partition has its own index structure. So, a query could potentially have to probe each of these individual index structures to use the DPSI. This type of operation, obviously, will not perform as well as a single probe that would be required against the NPI. So, of course, not every index on a partitioned table should be a DPSI. An additional drawback is that a DPSI cannot be defined as a unique index.</P>
<P class="docText">The bottom line on whether to create DPSIs or NPIs is that you will need to analyze your data access and utility processing requirements. DPSIs are easier to manage and can be processed more efficiently by utilities, but can require special query formulation to be efficient. NPIs are typically most efficient for general-purpose queries but come with a lot of administration baggage.</P>
<P class="docText">Before using DPSIs, you will have to examine your queries to determine predicate usage and the potential performance impact.<A NAME="ch06index66"></A><A NAME="ch06index67"></A><A NAME="ch06index68"></A></P>
<A NAME="ch06lev2sec4"></A><H4 class="docSection2Title">Indexes and Column Cardinality</H4>
<P class="docText">Column cardinality (that is, the number of distinct values for a column) is an important consideration when building composite indexes. You should analyze column cardinality for columns in a multi-column index.<A NAME="ch06index69"></A><A NAME="ch06index70"></A><A NAME="ch06index71"></A></P>
<P class="docText">DB2 records and stores column cardinality in the DB2 Catalog and then uses this information when optimizing SQL to determine access paths. The following cardinality columns are used by the DB2 optimizer:</P>
<BLOCKQUOTE><P><p class="docText"><span class="docEmphStrong"><TT>COLCARDF</TT></span>— 
Contains the number of distinct values for this column. The optimizer uses this column to calculate the filter factor for a composite index when equals predicates are not specified for each column. Found in <TT>SYSIBM.SYSCOLUMNS</TT> for non-partitioned indexes or <TT>SYSIBM.SYSCOLSTATS</TT> for partitioned indexes.<A NAME="ch06index72"></A><A NAME="ch06index73"></A></p></P><P><p class="docText"><span class="docEmphStrong"><TT>FIRSTKEYCARDF</TT></span>— 
Contains the number of distinct values of the first column in an index. This information is captured only for the first column in a multi-column index. It will be used by the DB2 optimizer when calculating the filter factor for a predicate on a single-column index. Found in <TT>SYSIBM.SYSINDEXES</TT> for non-partitioned indexes or <TT>SYSIBM.SYSINDEXSTATS</TT> for partitioned indexes.<A NAME="ch06index74"></A><A NAME="ch06index75"></A></p></P><P><p class="docText"><span class="docEmphStrong"><TT>FULLKEYCARDF</TT></span> <span class="docEmphRoman">(</span><TT>SYSIBM.SYSINDEXES</TT><span class="docEmphRoman">)</span>— 
Contains the number of distinct values for the combined, entire key (all columns) of an index. The optimizer uses this column to calculate the filter factor for a composite index when an equality predicate is specified for each column of a multi-column index. Found in <TT>SYSIBM.SYSINDEXES</TT> for non-partitioned indexes or <TT>SYSIBM.SYSINDEXSTATS</TT> for partitioned indexes.<A NAME="ch06index76"></A><A NAME="ch06index77"></A><A NAME="ch06index78"></A><A NAME="ch06index79"></A><A NAME="ch06index80"></A></p></P></BLOCKQUOTE>
<A NAME="ch06lev2sec5"></A><H4 class="docSection2Title">Modifying Indexes</H4>
<P class="docText">As data is added to the table, it is also added to every index defined on the table. For <TT>INSERT</TT> operations, new keys are placed in the proper sequence in the index. Existing keys are moved to the right to make room for the new entry. If there is not enough room on the page for the new entry, DB2 will try to find space on <span class="docEmphasis">neighboring</span> pages or on the next free page. When a neighboring page is used, DB2 attempts to redistribute entries in the pages to accommodate the <TT>INSERT</TT> operation.<A NAME="ch06index81"></A><A NAME="ch06index82"></A><A NAME="ch06index83"></A></P>
<P class="docText">As data is deleted from the table, it must also be removed from every index defined on the table. The more indexes defined to a table, the more time it will take for DB2 to perform <TT>DELETE</TT> operations.</P>
<P class="docText">For <TT>UPDATE</TT> operations, indexes are impacted only if the columns being modified participate in an index. The more indexes containing the columns being modified, the longer the <TT>UPDATE</TT> will take.</P>
<A NAME="ch06lev3sec3"></A><H5 class="docSection3Title">Forming Index Levels</H5>
<P class="docText">As data is added to the index it will grow and change. For very small indexes, the root page can also act as a leaf page. As data is added, the root page will fill up. When the index becomes too large to accommodate both root and leaf page data, DB2 creates two new leaf pages. Each of these leaf pages will contain half the entries that were in the original root page. The root page will contain pointers to the leaf pages. You have just witnessed the birth of a new index.<A NAME="ch06index84"></A><A NAME="ch06index85"></A></P>
<P class="docText">Over time, as more data is added, more index entries are added. Eventually, the root page grows too large, causing DB2 to create two more new pages. These will be nonleaf pages, each containing half of the entries that were in the root page. The root page now contains pointers to nonleaf pages—and thus, another new level is born.</P>
<P class="docText">The greater the number of levels in an index, the less efficient it becomes. This is so because DB2 needs to perform an additional I/O operation for an index lookup for each new level in the index.<A NAME="ch06index86"></A><A NAME="ch06index87"></A></P>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch06.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch06lev1sec2.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
