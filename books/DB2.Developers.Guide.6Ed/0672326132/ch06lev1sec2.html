<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Index Guidelines</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch06lev1sec1.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch07.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch06lev1sec2"></A><H3 class="docSection1Title" >Index Guidelines</H3>
<P class="docText">Consider the following guidelines when planning the index strategy for your DB2 databases and applications.</P>
<A NAME="ch06lev4sec3"></A><H4 class="docSection2Title">Use Workload As a Basis for Indexing</H4>
<P class="docText">The basic trick to creating the appropriate indexes is to analyze your workload and build indexes to match. Indexing one table at a time is unlikely to produce a batch of indexes that will match your actual workload. The trick is to choose a workload to optimize. Choose an important workload, such as month-end processing or another peak processing time. You might also choose a workload for a specific application or group of applications.<A NAME="ch06index88"></A><A NAME="ch06index89"></A></P>
<P class="docText">After you choose the workload, you will need to examine the queries in the workload, documenting each table that is accessed and the frequency of each query run during the workload. Favor building indexes to optimize the queries that run the most often. For example, it is more beneficial to create an index to optimize a query that runs 1,000 times a day, than for a query that runs 3 times a day.</P>
<P class="docText">Then, factor in the relative priority of each query. You might favor building indexes to optimize very important queries over other queries that might run more frequently. For example, a query (<TT>Q1</TT>) that is only run 10 times a day might be more important than another query (<TT>Q2</TT>) that runs 120 times a day. Why? Reasons might include the following:</P>
<UL><LI><P class="docList"><TT>Q1</TT> is more important to the business than <TT>Q2</TT> because it brings in more revenue, satisfies more customers, or reduces spending.</P></LI><LI><P class="docList"><TT>Q1</TT> is used by an important business user, such as the CEO or perhaps your most important customers.</P></LI><LI><P class="docList"><TT>Q1</TT> is required for regulatory or legal reasons.</P></LI><LI><P class="docList">The users of <TT>Q1</TT> are willing to spend more to optimize their query than the users of <TT>Q2</TT>; of course, approach this scenario with caution, because financial clout should not be the only consideration for DB2 query optimization.</P></LI></UL>
<P class="docText">When you have sufficiently ranked each query in a particular workload you can begin to build indexes for the most important queries in the workload. At least the top 30% most critical processes should have optimal indexes built for them, taking into consideration the predicate filtering and sequencing required.</P>
<P class="docText">Be sure to consider each workload profile and its performance requirements as you embark on an index creation strategy.<A NAME="ch06index90"></A><A NAME="ch06index91"></A></P>
<A NAME="ch06lev4sec4"></A><H4 class="docSection2Title">Be Aware of Data Modification</H4>
<P class="docText">Remember, indexing optimizes the performance of data access but degrades the performance of data modification. Every <TT>INSERT</TT> or <TT>DELETE</TT> performed on a table will also insert or delete the data from every index defined on the table. Additionally, an <TT>UPDATE</TT> to a column in a table will cause DB2 to update any index that references that column.<A NAME="ch06index92"></A><A NAME="ch06index93"></A></P>
<P class="docText">In general, keep adding indexes until the impact on data modification causes your applications to be able to meet the necessary performance and service levels. When modification performance becomes unacceptable, remove the last index (or indexes) created until the performance of modification becomes tolerable.</P>
<A NAME="ch06lev4sec5"></A><H4 class="docSection2Title">Uniqueness Recommendations</H4>
<P class="docText">You can enforce the uniqueness of a column or a group of columns by creating a unique index on those columns. You can have more than one unique index per table.<A NAME="ch06index94"></A><A NAME="ch06index95"></A></P>
<P class="docText">It usually is preferable to enforce the uniqueness of columns by creating unique indexes, thereby allowing the DBMS to do the work. The alternative is to code uniqueness logic in an application program to do the same work that DB2 does automatically.</P>
<A NAME="ch06note07"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Remember: If security is liberal for application tables, ad hoc SQL users can modify table data without the application program, and thereby insert or update columns that should be unique to non-unique values. However, this cannot happen if a unique index is defined on the columns.</P></div><br>
<A NAME="ch06lev4sec6"></A><H4 class="docSection2Title">Create a Unique Index for Each Primary Key</H4>
<P class="docText">Every primary key explicitly defined for a table must be associated with a corresponding unique index. If you do not create a unique index for a primary key, an incomplete key is defined for the table, making the table inaccessible.<A NAME="ch06index96"></A><A NAME="ch06index97"></A><A NAME="ch06index98"></A></P>
<A NAME="ch06lev4sec7"></A><H4 class="docSection2Title">Use <TT>WHERE NOT NULL</TT> to Allow Multiple Nulls in a <TT>UNIQUE</TT> Index</H4>
<P class="docText">Specify the <TT>UNIQUE WHERE NOT NULL</TT> clause to enable multiple nulls to exist in a unique index. This is useful when an index contains at least one nullable column, but all non-null entries must be unique.<A NAME="ch06index99"></A><A NAME="ch06index100"></A><A NAME="ch06index101"></A><A NAME="ch06index102"></A></P>
<A NAME="ch06lev4sec8"></A><H4 class="docSection2Title">Create Indexes for Foreign Keys</H4>
<P class="docText">Unless an index already exists for access reasons or the table is too small to be indexed, create an index for each foreign key defined for a table. Because DB2's referential integrity feature accesses data defined as a foreign key behind the scenes, it's a good idea to enhance the efficiency of this access by creating indexes.<A NAME="ch06index103"></A><A NAME="ch06index104"></A><A NAME="ch06index105"></A></P>
<A NAME="ch06lev4sec9"></A><H4 class="docSection2Title">When to Avoid Indexing</H4>
<P class="docText">There are only a few situations when you should consider not defining indexes for a table. Consider avoiding indexing when the table is very small, that is, less than 100 or so pages. However, there are scenarios where even a small table can benefit from being indexed (for example, for uniqueness or for specific, high-performance access requirements).<A NAME="ch06index106"></A></P>
<P class="docText">Another scenario where indexing might not be advantageous is when the table has heavy insert and delete activity but is relatively small, that is, less than 200 or so pages.</P>
<P class="docText">A table also should not be indexed if it <span class="docEmphasis">always</span> is accessed with a scan—in other words, if there is no conditional predicate access to the table.</P>
<A NAME="ch06lev4sec10"></A><H4 class="docSection2Title">When to Avoid Placing Columns in an Index</H4>
<P class="docText">Sometimes you should not define indexes for columns. If the column is updated frequently and the table is less than 200 or so pages, consider avoiding placing the column in an index.<A NAME="ch06index107"></A><A NAME="ch06index108"></A></P>
<P class="docText">Avoid defining an index for a column if an index on the column exists that would make the new index redundant. For example, if an index exists on <TT>COL1</TT>, <TT>COL2</TT> in <TT>TABLE1</TT>, a second index on <TT>COL1</TT> only is redundant. An index on <TT>COL2</TT> alone is not redundant because it is not the first column in the index.</P>
<A NAME="ch06lev4sec11"></A><H4 class="docSection2Title">When to Specify Extra Index Columns</H4>
<P class="docText">When the column or columns to be indexed contain non-unique data, consider adding an extra column to increase the cardinality of the index. This reduces the index RID list and avoids chaining—an inefficient method of processing index entries. Uniqueness can be gauged by determining the cardinality for the columns in the index. The cardinality for the columns is nothing more than the number of distinct values stored in the columns. If this number is small (for example, less than 10% of the total number of rows for the table), consider adding extra columns to the index. (A column's cardinality can be found in the DB2 Catalog using queries presented in <A class="docLink" HREF="part04.html#part04">Part IV</A>, "DB2 Performance Monitoring.")<A NAME="ch06index109"></A><A NAME="ch06index110"></A></P>
<A NAME="ch06lev4sec12"></A><p><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><H4 class="docSection2Title">Control the Length of Index Keys</H4></td></tr></table></p>

<P class="docText">DB2 V8 permits indexes to be defined with keys of up to 2,000 bytes. The previous limit for index key length was 255.<A NAME="ch06index111"></A><A NAME="ch06index112"></A><A NAME="ch06index113"></A></P>
<A NAME="ch06note08"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">The maximum size of a partitioning key is still 255 whether partitioning is index-controlled or table-controlled.</P></div><br>
<P class="docText">Of course, just because DB2 permits greater key lengths does not mean that you should pad more columns into your indexes. For example, just blindly adding every column to every index to support more index-only access is generally not a wise idea. Be sure that there is a reasoned, practical need for each column defined to an index.</P>
<A NAME="ch06note09"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">To calculate the actual physical limit for index key length you must take nullable columns into account. Subtract 1 from the maximum length for every column that is nullable. So, if an index contains 5 columns, 3 of which can be set to null, the total length of the 5 columns can be no greater than 1997 (2000–3 = 1997).<A NAME="ch06index114"></A><A NAME="ch06index115"></A><A NAME="ch06index116"></A></P></div><br>
<A NAME="ch06lev4sec13"></A><H4 class="docSection2Title">Indexing Large and Small Tables</H4>
<P class="docText">For tables over 100 (or so) pages, it is best to define at least one index. If the table is very large (over 10,000 pages), try to limit the indexes to those that are absolutely necessary for adequate performance. When a large table has multiple indexes, data modification performance can suffer. When large tables lack indexes, however, access efficiency will suffer. This fragile balance must be monitored closely. In most situations, more indexes are better than fewer indexes because most applications are query-intensive rather than update-intensive.<A NAME="ch06index117"></A><A NAME="ch06index118"></A></P>
<P class="docText">For tables containing a small number of pages (up to 100 or so pages) consider limiting indexes to those required for uniqueness and perhaps to support common join criterion. Add indexes also when the performance of queries that access the table suffers. Test the performance of the query after the index is created, though, to ensure that the index helps. When you index a small table, increased I/O (due to index accesses) may cause performance to suffer when compared to a complete scan of all the data in the table.<A NAME="ch06index119"></A><A NAME="ch06index120"></A></P>
<A NAME="ch06lev4sec14"></A><H4 class="docSection2Title">Promote Index-Only Access</H4>
<P class="docText">When an index contains all of the columns being selected in a query, DB2 can choose to use index-only access. With index-only access, DB2 will read all of the data required from the index without having to access the table space. Index-only access can reduce the number of I/Os required to satisfy a query. For example, consider the following query:<A NAME="ch06index121"></A><A NAME="ch06index122"></A><A NAME="ch06index123"></A><A NAME="ch06index124"></A></P>
<pre>

</pre><BR><pre>
SELECT  DEPTNAME, MGRNO
FROM    DSN8810.DEPT
WHERE   DEPTNO &gt; 'D00';
</pre><BR>
<P class="docText">Now, also consider that there is only one index on this table—a two-column index on <TT>DEPTNO</TT> and <TT>MGRNO</TT>. DB2 will most likely choose to use this index to satisfy the <TT>DEPTNO &gt; 'D00'</TT> predicate. But, if we add the <TT>DEPTNAME</TT> column to this index, DB2 can conceivably use this index for index-only access because all of the required columns are stored in the index.</P>
<P class="docText">So, it can be worthwhile to extend an index with an additional column or two to encourage index-only access. However, this practice should be deployed with care; you do not want to overload every index, because it will become unwieldy to manage.</P>
<P class="docText">When deciding whether to extend an index to encourage index-only access, be sure to consider the following factors:</P>
<UL><LI><P class="docList">Adding extra columns to an index will increase the size of the index requiring additional storage.</P></LI><LI><P class="docList">Adding extra columns to an index might increase the number of levels in the index, especially if the table is very large. Additional levels can degrade performance.</P></LI><LI><P class="docList">The sequencing of columns in a multi-column index is important and can significantly impact performance if chosen improperly.</P></LI><LI><P class="docList">Use caution when choosing the indexes to be overloaded; consider overloading indexes for index-only access only for the most important or performance-critical queries in your applications.<A NAME="ch06index125"></A><A NAME="ch06index126"></A><A NAME="ch06index127"></A><A NAME="ch06index128"></A></P></LI></UL>
<A NAME="ch06lev4sec15"></A><H4 class="docSection2Title">Multi-column Indexes</H4>
<P class="docText">If a table has only multi-column indexes, try to specify the high-level column in the <TT>WHERE</TT> clause of your query. This action results in an index scan with at least one matching column.<A NAME="ch06index129"></A><A NAME="ch06index130"></A><A NAME="ch06index131"></A></P>
<P class="docText">A multi-column index <span class="docEmphasis">can</span> be used to scan data to satisfy a query in which the high-level column is not specified (but another column in the index is specified). However, a non-matching index scan of this sort is not as efficient as a matching index scan.</P>
<A NAME="ch06lev4sec16"></A><H4 class="docSection2Title">Consider Several Indexes Instead of a Multi-column Index</H4>
<P class="docText">Because DB2 can utilize multiple indexes in an access path for a single SQL statement, multiple indexes might be more efficient (from a global perspective) than a single multi-column index. If access to the columns varies from query to query, multiple indexes might provide better overall performance for all your queries, at the expense of an individual query.<A NAME="ch06index132"></A></P>
<P class="docText">If you feel that multiple indexes might be of benefit for your specific situation, test their effectiveness first in a test environment by</P>
<UL><LI><P class="docList">Dropping the multi-column index</P></LI><LI><P class="docList">Creating a single index for each of the columns in the multi-column index</P></LI><LI><P class="docList">Updating DB2 Catalog statistics to indicate production volume</P></LI><LI><P class="docList">Running <TT>EXPLAIN</TT> on all the affected queries and analyzing the results</P></LI></UL>
<A NAME="ch06note10"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">It is not common for the DB2 optimizer to choose multiple-index access in practice. Use caution before dropping a multi-column index in favor of multiple indexes because, after optimization, DB2 might choose to use only one of the indexes instead of a multiple index strategy.</P></div><br>
<A NAME="ch06lev4sec17"></A><H4 class="docSection2Title">Multi-Index Access</H4>
<P class="docText">DB2 can use more than one index to satisfy a data retrieval request. For example, consider two indexes on the <TT>DSN8810.DEPT</TT> table: one index for <TT>DEPTNO</TT> and another index for <TT>ADMRDEPT</TT>. If you executed the following query, DB2 could use both of these indexes to satisfy the request:<A NAME="ch06index133"></A><A NAME="ch06index134"></A><A NAME="ch06index135"></A><A NAME="ch06index136"></A></P>
<pre>

</pre><BR><pre>
SELECT   DEPTNO, DEPTNAME, MGRNO
FROM     DSN8810.DEPT
WHERE    DEPTNO &gt; 'D00'
AND      ADMRDEPT = 'D01';
</pre><BR>
<P class="docText">If multi-index access is used, the index on <TT>DEPTNO</TT> is used to retrieve all departments with a <TT>DEPTNO</TT> greater than <TT>'D00'</TT>, and the index on <TT>ADMRDEPT</TT> is used to retrieve only rows containing <TT>'D01'</TT>. Then these rows are intersected and the correct result is returned.</P>
<P class="docText">An alternative to the multi-index access just described is a single multi-column index. If you create one index for the combination of columns <TT>ADMRDEPT</TT> and <TT>DEPTNO</TT>, DB2 could use this index, as well. When deciding whether to use multiple indexes or multi-column indexes, consider the following guidelines:</P>
<UL><LI><P class="docList">Multi-index access is usually less efficient than access by a single multi-column index.</P></LI><LI><P class="docList">Many multi-column indexes require more DASD than multiple single-column indexes.</P></LI><LI><P class="docList">Consider the access criteria for all applications that will be querying the table that must be indexed. If the indexing needs are light, a series of multi-column indexes is usually the best solution. If the indexing needs are heavy and many combinations and permutations of columns are necessary to support the access criteria, multiple single-column indexes could be a better solution.</P></LI><LI><P class="docList">Sometimes one multi-column index can fit the needs of many different access criteria. For example, suppose that the <TT>DSN8810.EMP</TT> table (see <A class="docLink" HREF="app01.html#app01">Appendix A</A>, "DB2 Sample Tables") has three access needs, as follows:</P><P class="docList"><TT>LASTNAME</TT> only</P><P class="docList"><TT>LASTNAME</TT> and <TT>FIRSTNME</TT></P><P class="docList"><TT>LASTNAME</TT>, <TT>FIRSTNME</TT>, and <TT>BONUS</TT></P><P class="docList">One index on the concatenation of the <TT>LASTNAME</TT>, <TT>FIRSTNME</TT>, and <TT>BONUS</TT> columns would efficiently handle the access needs for this table. When only <TT>LASTNAME</TT> is required, only the first column of the index is used. When both <TT>LASTNAME</TT> and <TT>FIRSTNME</TT> are specified in a query, only the first two columns are used. Finally, if all three columns are specified in a query, the index uses all three columns.</P><P class="docList">With index screening, DB2 also could use the same three column index to satisfy a query specifying only <TT>LASTNAME</TT> and <TT>BONUS</TT>. A matching index scan would be performed on <TT>LASTNAME</TT>, and then DB2 could screen the index for the <TT>BONUS</TT> values.</P><P class="docList">Of course, you might need to create indexes for one (or both) of the other two indexes if they are needed to maintain uniqueness.</P></LI><LI><P class="docList">Consider the tradeoff of DASD versus performance, and weigh the access criteria to determine the best indexing scenario for your implementation.<A NAME="ch06index137"></A><A NAME="ch06index138"></A><A NAME="ch06index139"></A><A NAME="ch06index140"></A></P></LI></UL>
<A NAME="ch06lev4sec18"></A><H4 class="docSection2Title">Specify Appropriate Index Parameters</H4>
<P class="docText">The first design decision to be made when defining an indexing strategy for a table is to choose a useful clustering strategy. Clustering reduces I/O. The DB2 optimizer usually tries to use an index on a clustered column before using other indexes. Choose your clustering index wisely; in general, use the index accessed for scanning most often, because clustering improves sequential access more than random access.<A NAME="ch06index141"></A><A NAME="ch06index142"></A></P>
<P class="docText">Specify index-free space the same as the table space free space. The same reason for the free space in the table space applies to the free space in the index. Remember that index row sizes are smaller than table row sizes, so plan accordingly when calculating free space. Also, as <TT>PCTFREE</TT> increases, the frequency of page splitting decreases and the efficiency of index updates increases.<A NAME="ch06index143"></A><A NAME="ch06index144"></A></P>
<P class="docText">When an index page is completely filled and a new entry must be inserted, DB2 splits the index leaf page involved in two, moving half the data to a new page. Splits can cause DB2 to lock at many levels of the index, possibly causing splits all the way back to the root page. This splitting activity is inefficient and should be avoided by prudent use of free space and frequent index reorganizations. DB2 also uses a free page for splits if one is available within 64 pages of the original page being split. Use the suggestions in <A class="docLink" HREF="#ch06table01">Table 6.1</A> as a rough guideline for specifying <TT>PCTFREE</TT> and <TT>FREEPAGE</TT> based on insert and update frequency. Of course, these are very rough guidelines and your free space allocations will vary according to the volatility of your data and the frequency of reorganization.</P>
<A NAME="ch06table01"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 6.1. Index Free Space Allocation Chart</h5></CAPTION><COLGROUP><COL width="183.33333333333331"><COL width="183.33333333333331"><COL width="183.33333333333331"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Type of Index Processing</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><TT>FREEPAGE</TT></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><TT>PCTFREE</TT></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Read only</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">0</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">0</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Less than 20% of volume inserted or updated between <TT>REORG</TT>s</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">0</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">10 to 20</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Twenty to 60% of volume inserted or updated between <TT>REORG</TT>s</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">63</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">20 to 30</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Greater than 60% of volume inserted or updated between <TT>REORG</TT>s</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">15</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">20 to 30</P></TD></TR></TABLE></P><br>
<P class="docText">Additionally, refer to the VCAT versus <TT>STOGROUP</TT> considerations presented in <A class="docLink" HREF="ch05.html#ch05">Chapter 5</A>. The same considerations that apply to table space allocation also apply to index allocation.<A NAME="ch06index145"></A><A NAME="ch06index146"></A></P>
<A NAME="ch06lev4sec19"></A><H4 class="docSection2Title">Create Indexes Before Loading Tables</H4>
<P class="docText">The <TT>LOAD</TT> utility updates indexes efficiently. Usually, the <TT>LOAD</TT> utility is more efficient than building indexes for tables that already contain data. The data being loaded should be sorted into the order of the clustering index before execution.<A NAME="ch06index147"></A><A NAME="ch06index148"></A><A NAME="ch06index149"></A><A NAME="ch06index150"></A><A NAME="ch06index151"></A></P>
<A NAME="ch06lev4sec20"></A><H4 class="docSection2Title">Consider Deferring Index Creation</H4>
<P class="docText">The <TT>DEFER</TT> option on the <TT>CREATE INDEX</TT> statement allows the index to be created but not populated. The <TT>RECOVER INDEX</TT> utility can then be executed to populate the index. This will speed the index creation process because <TT>REBUILD INDEX</TT> usually populates index entries faster than <TT>CREATE INDEX</TT>.<A NAME="ch06index152"></A><A NAME="ch06index153"></A><A NAME="ch06index154"></A></P>
<P class="docText">Creating a <TT>STOGROUP</TT>-defined index with <TT>DEFER YES</TT> causes the underlying VSAM data set for the index to be allocated.</P>
<P class="docText">Additionally, the DB2 catalog is updated to record that the index exists. But, if the table being indexed currently contains data, DB2 will turn on the recover pending flag for the index space and issue a <TT>+610 SQLCODE</TT>. Subsequent execution of <TT>RECOVER INDEX</TT> will turn off the recover pending flag and populate the index.</P>
<A NAME="ch06lev4sec21"></A><H4 class="docSection2Title">Consider Deferring Index Data Set Definition</H4>
<P class="docText">The <TT>DEFINE</TT> parameter can be used to control when the underlying data set(s) for the index space are created. <TT>DEFINE YES</TT>, which is the default, indicates that the data sets are created when the index is created. <TT>DEFINE NO</TT> indicates that data set creation will not occur until data is inserted in to the index. The <TT>DEFINE</TT> parameter should be used only with <TT>STORGROUP</TT>-defined indexes; it will be ignored if specified for <TT>VCAT</TT>-defined indexes.<A NAME="ch06index155"></A><A NAME="ch06index156"></A><A NAME="ch06index157"></A><A NAME="ch06index158"></A><A NAME="ch06index159"></A><A NAME="ch06index160"></A></P>
<P class="docText">Specifying <TT>DEFINE NO</TT> can be useful to minimize the number of data sets where indexes are being created on empty tables that will remain empty for some time.</P>
<A NAME="ch06lev4sec22"></A><H4 class="docSection2Title">Let DB2 Tell You What Indexes to Create</H4>
<P class="docText">Consider using <TT>CREATE INDEX</TT> with the <TT>DEFER YES</TT> option to create many different indexes for new applications. The indexes will be recorded in the DB2 catalog, but will not be populated. Then, update the statistics in the DB2 catalog to indicate anticipated production volumes and run <TT>EXPLAIN</TT> on yourperformance-sensitive queries.<A NAME="ch06index161"></A></P>
<P class="docText">Use <TT>REBUILD INDEX</TT> to populate the indexes that were used and drop the indexes that were not used. In this way DB2 can help you choose which indexes will be useful.</P>
<A NAME="ch06lev4sec23"></A><H4 class="docSection2Title">Store Index and Table Space Data Sets Separately</H4>
<P class="docText">You should assign indexes to different <TT>STOGROUP</TT>s or different volumes than the table spaces containing the tables to which the indexes apply. This reduces head contention and increases I/O efficiency. This is especially important for tables and indexes involved in parallel queries.<A NAME="ch06index162"></A><A NAME="ch06index163"></A><A NAME="ch06index164"></A><A NAME="ch06index165"></A></P>
<A NAME="ch06lev4sec24"></A><H4 class="docSection2Title">Consider Separate Index Buffer Pools</H4>
<P class="docText">Consider placing critical indexes in a different buffer pool from your table spaces. For more in-depth buffer pool consideration, see <A class="docLink" HREF="ch28.html#ch28">Chapter 28</A>, "Tuning DB2's Components."<A NAME="ch06index166"></A><A NAME="ch06index167"></A></P>
<A NAME="ch06lev4sec25"></A><H4 class="docSection2Title"><TT>PRIQTY</TT> and <TT>SECQTY</TT></H4>
<P class="docText">If you are defining indexes using the <TT>STOGROUP</TT> method, you must specify primary and secondary space allocations. The primary allocation is the amount of physical storage allocated when the index is created. As the amount of data in the index grows, secondary allocations of storage are taken. Use the guidelines specified for table space space allocations to guide your index space allocation efforts.<A NAME="ch06index168"></A><A NAME="ch06index169"></A><A NAME="ch06index170"></A></P>
<P class="docText">The default values for index <TT>PRIQTY</TT> and <TT>SECQTY</TT> are the same as the 4KB page size defaults for table space <TT>PRIQTY</TT> and <TT>SECQTY</TT>.</P>
<A NAME="ch06lev4sec26"></A><H4 class="docSection2Title">Use <TT>PIECESIZE</TT> to Explicitly Define Index Data Set Size</H4>
<P class="docText">Consider using the <TT>PIECESIZE</TT> clause to specify the largest data set size for a non-partitioned index.<A NAME="ch06index171"></A><A NAME="ch06index172"></A><A NAME="ch06index173"></A><A NAME="ch06index174"></A><A NAME="ch06index175"></A></P>
<P class="docText">The creation of non-partitioning indexes (NPIs) on tables in a partitioned table space has been one of the most vexing problems facing DBAs. Partitioned table spaces tend to be large and by their very design will span multiple underlying data sets. The partitioning index that defines the partitioning key and key ranges also spans multiple data sets. There can be only one partitioning index per partitioned table space. What happens when you need to define more than one index on a table in a partitioned table space?</P>
<P class="docText">Well, in the old days (pre-V5), the DBA could not control the creation of the underlying data set(s) used for NPIs. As of V5, the <TT>PIECESIZE</TT> clause of the <TT>CREATE INDEX</TT> statement can be used during index creation to break an NPI into several data sets (or <span class="docEmphasis">pieces</span>). More accurately, the <TT>PIECESIZE</TT> clause specifies the largest data set size for a non-partitioned index. <TT>PIECESIZE</TT> can be specified in kilobytes, megabytes, or gigabytes. For example, the following statement will limit the size of individual data sets for the <TT>XACT2</TT> index to 256 megabytes:</P>
<pre>

</pre><BR><pre>
CREATE TYPE 2 UNIQUE INDEX DSN8710.XACT2
  ON DSN8710.ACT (ACTKWD ASC)
  USING STOGROUP DSN8G710
        PRIQTY 65536K
        SECQTY 8192K
        ERASE NO
  BUFFERPOOL BP0
  CLOSE NO
  PIECESIZE 256M;
</pre><BR>
<P class="docText">Basically, <TT>PIECESIZE</TT> is used to enable NPIs to be created on very large partitioned table spaces. It breaks apart the NPI into separate pieces that can be somewhat managed individually. Without <TT>PIECESIZE</TT>, NPIs would be quite difficult to manage and administer. Keep in mind, though, that <TT>PIECESIZE</TT> does not magically partition an NPI based on the partitioning scheme of the table space. This is a common misperception of the <TT>PIECESIZE</TT> clause. So, if you have a partitioned table space with four partitions and then create an NPI with four pieces, the data in the NPI pieces will not match up with the data in the four partitions.</P>
<P class="docText">When using <TT>PIECESIZE</TT>, more data sets will be created, and therefore you can obtain greater control over data set placement. Placing the pieces on separate disk devices can help to reduce I/O contention for SQL operations that access NPIs during read or update processing. The elapsed time improvement might be even greater when multiple tasks are accessing the NPI.</P>
<P class="docText">Separating the NPI into pieces allows for better performance of <TT>INSERT</TT>, <TT>UPDATE</TT>, and <TT>DELETE</TT> processes by eliminating bottlenecks that can be caused by using only one data set for the index. The use of pieces also improves concurrency and performance of heavy <TT>INSERT</TT>, <TT>UPDATE</TT>, and <TT>DELETE</TT> processing against any size partitioned table space with NPIs.</P>
<P class="docText">Keep in mind that <TT>PIECESIZE</TT> is only a specification of the maximum amount of data that a piece (that is, a data set) can hold and not the actual allocation of storage, so <TT>PIECESIZE</TT> has no effect on primary and secondary space allocation. Each data set will max out at the <TT>PIECESIZE</TT> value, so specifying <TT>PRIQTY</TT> greater than <TT>PIECESIZE</TT> will waste space.<A NAME="ch06index176"></A><A NAME="ch06index177"></A><A NAME="ch06index178"></A><A NAME="ch06index179"></A><A NAME="ch06index180"></A></P>
<A NAME="ch06note11"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Avoid setting the <TT>PIECESIZE</TT> too small. A new data set is allocated each time the <TT>PIECESIZE</TT> threshold is reached. DB2 increments the <TT>A001</TT> component of the data set name each time. This makes the <span class="docEmphasis">physical</span> limit 999 data sets (<TT>A001</TT> through <TT>A999</TT>). If <TT>PIECESIZE</TT> is set too small, the data set name can limit the overall size of the table space. Ideally, the value of your primary quantity and secondary quantities should be evenly divisible into <TT>PIECESIZE</TT> to avoid wasting space.</P></div><br>
<P class="docText">To choose a <TT>PIECESIZE</TT> value, divide the overall size of the entire NPI by the number of data sets that you want to have. For example, for an NPI that is 8 megabytes, you can arrive at four data sets for the NPI by specifying <TT>PIECESIZE 2M</TT>. Of course, if your NPI grows over eight megabytes in total you will get additional data sets. Keep in mind that 32 pieces is the limit if the underlying table space is not defined with <TT>DSSIZE 4G</TT> or greater. The limit is 254 pieces if the table space is defined as <TT>DSSIZE 4G</TT> or greater.<A NAME="ch06index181"></A><A NAME="ch06index182"></A><A NAME="ch06index183"></A><A NAME="ch06index184"></A><A NAME="ch06index185"></A></P>
<A NAME="ch06lev4sec27"></A><H4 class="docSection2Title">Index Image Copies</H4>
<P class="docText">As of DB2 V6 and later, it is possible to use the <TT>COPY</TT> utility to make backup image copies of index data sets. You also can use the <TT>RECOVER</TT> utility on index image copies to recover indexes. To use <TT>COPY</TT> on indexes, the <TT>COPY</TT> parameter must be set to <TT>YES</TT>. The default value for the <TT>COPY</TT> parameter is <TT>NO</TT>.<A NAME="ch06index186"></A><A NAME="ch06index187"></A><A NAME="ch06index188"></A><A NAME="ch06index189"></A></P>
<A NAME="ch06note12"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">The <TT>REBUILD</TT> utility can be used to rebuild indexes from the underlying data in the table. <TT>REBUILD</TT> can be executed on any index regardless of the value of the <TT>COPY</TT> parameter.<A NAME="ch06index190"></A><A NAME="ch06index191"></A><A NAME="ch06index192"></A><A NAME="ch06index193"></A></P></div><br>
<A NAME="ch06lev4sec28"></A><H4 class="docSection2Title">Indexing Auxiliary Tables</H4>
<P class="docText">Only one index can be specified on an auxiliary table. The index cannot specify any columns. The default key for an index on an auxiliary table is implicitly defined as a <TT>ROWID</TT>, which is a unique 19-byte, DB2-generated value. For more information on auxiliary tables consult <A class="docLink" HREF="ch09.html#ch09">Chapter 9</A>, "Large Objects and Object/Relational Databases."<A NAME="ch06index194"></A><A NAME="ch06index195"></A><A NAME="ch06index196"></A></P>
<A NAME="ch06lev4sec29"></A><H4 class="docSection2Title">Type 2 Indexes Are Required</H4>
<P class="docText">Prior to DB2 V6, there were two types of indexes available to DB2: Type 1 and Type 2. Type 2 indexes were introduced with DB2 Version 4; Type 1 indexes had been available since Version 1 of DB2. However, as of DB2 V6, Type 1 indexes are obsolete and no longer supported. Type 2 indexes are the only type of index that can be defined. Type 2 indexes provide the following benefits over Type 1 indexes:<A NAME="ch06index197"></A><A NAME="ch06index198"></A><A NAME="ch06index199"></A><A NAME="ch06index200"></A></P>
<UL><LI><P class="docList">Eliminate index locking (the predominant cause of contention in most pre-V4 DB2 applications).</P></LI><LI><P class="docList">Do not use index subpages.</P></LI><LI><P class="docList">Are the only type supported for ASCII encoded tables.</P></LI><LI><P class="docList">Many newer DB2 features cannot be used unless Type 2 indexes are used; these features include row level locking, data sharing, full partition independence, uncommitted reads, <TT>UNIQUE WHERE NOT NULL</TT>, and CPU and Sysplex parallelism.</P></LI></UL>
<A NAME="ch06note13"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">The <TT>TYPE 2</TT> clause can be explicitly specified in the <TT>CREATE INDEX</TT> statement. However, if it is not specified, DB2 will create a Type 2 index anyway. As of DB2 V6, it does not matter whether <TT>TYPE 2</TT> is explicitly specified in the <TT>CREATE INDEX</TT> statement; Type 2 indexes are the only indexes that will be created by DB2. Furthermore, as of DB2 V8, DB2 will not work with Type 1 indexes, only Type 2 indexes.</P></div><br>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch06lev1sec1.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch07.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
