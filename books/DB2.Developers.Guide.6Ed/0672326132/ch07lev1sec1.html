<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Online Schema Changes</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch07.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch08.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch07lev1sec1"></A><H3 class="docSection1Title">Online Schema Changes</H3>
<P class="docText">DB2 database changes are more flexible with DB2 V8 due to online schema evolution. IBM also refers to this feature as simple schema evolution, online schema changes, or just schema changes.<A NAME="ch07index01"></A><A NAME="ch07index02"></A><A NAME="ch07index03"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> IBM introduced online schema evolution with DB2 V8 with the intention of allowing DB2 databases to be altered over time without causing an outage. Of course, this is the long-term goal of online schema evolution. We are in the first phases of this evolution with DB2 V8—and remember, evolution is a very lengthy process. It took many millions of years for life to evolve on Earth. The point is, it will take a long time for online schema evolution to enable every type of database change to be carried out without downtime.</P></td></tr></table><br>
<A NAME="ch07note02"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">For literal-minded readers, it most likely will not take millions of years for online schema evolution to support most types of database changes. I am simply using biological evolution as a metaphor for schema evolution.</P></div><br>
<A NAME="ch07lev2sec1"></A><H4 class="docSection2Title">Online Change Management Prior to V8</H4>
<P class="docText">Of course, DB2 has offered some degree of online change management even prior to V8. For example, DB2 has provided the following capabilities for quite some time now:<A NAME="ch07index04"></A><A NAME="ch07index05"></A></P>
<UL><LI><P class="docList">You can add a column to the end of a table without having to <TT>STOP</TT> access to the table or perhaps even modify any programs that access that table.</P></LI><LI><P class="docList">A table can be renamed without dropping and re-creating the table.</P></LI><LI><P class="docList">You can use <TT>ALTER</TT> to extend the length of a <TT>VARCHAR</TT> column to a greater size (but not to a smaller length).</P></LI><LI><P class="docList">Application changes can be introduced and managed using package versioning.</P></LI><LI><P class="docList">For DB2 data sharing, complex changes can be made to the DB2 engine code of a single member via PTFs while other members remain active.</P></LI><LI><P class="docList">The <TT>REORG</TT> and <TT>LOAD RESUME</TT> utilities can be run online while concurrent workloads are being run against the data being reorganized or loaded.</P></LI></UL>
<P class="docText">These are just a few of the capabilities of DB2 change management, but some changes are not quite so easy.</P>
<A NAME="ch07lev2sec2"></A><H4 class="docSection2Title">Online Schema Changes for V8</H4>
<P class="docText">Online schema evolution for DB2 V8 introduces some nice, new capabilities for managing database changes. What exactly can be changed today, as of DB2 Version 8?<A NAME="ch07index06"></A><A NAME="ch07index07"></A></P>
<BLOCKQUOTE><P><P class="docList">You can extend the length of a <TT>CHAR</TT> column to a greater size (but not to a smaller length).</P></P><P><P class="docList">You can switch the data type of a column within character data types (<TT>CHAR</TT>, <TT>VARCHAR</TT>); within numeric data types (<TT>SMALLINT</TT>, <TT>INTEGER</TT>, <TT>FLOAT</TT>, <TT>REAL</TT>, <TT>FLOAT</TT>, <TT>DOUBLE</TT>, <TT>DECIMAL</TT>); and within graphic data types (<TT>GRAPHIC</TT>, <TT>VARGRAPHIC</TT>).</P></P><P><P class="docList">You cannot change character to numeric or graphic, numeric to character or graphic, or graphic to numeric or character.</P></P><P><P class="docList">The previous data type changes are permitted even for columns that are part of an index or referenced within a view.</P></P><P><P class="docList"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"> You can alter identity columns.</P></P><P><P class="docList">You can add a column to an index.</P></P><P><P class="docList">You can change the clustering index for a table.</P></P><P><P class="docList">You can make many changes to partitioned and partitioning table spaces and indexes that were previously not allowed. For example, you can drop the partitioning index, create a table without a partitioning index, add a partition to the end of a table to extend the limit key value, rotate partitions, and re-balance partitions during a <TT>REORG</TT>.</P></P><P><P class="docList">You can better create and support indexes on variable length columns. Prior to V8 all indexes on variable columns were padded to their maximum size in the index. Now you can <TT>CREATE</TT> or <TT>ALTER</TT> an index to specify non-padded variable keys.</P></P><P><P class="docList">You can better support utility processing for database objects in utility-pending states (<TT>REORG</TT> pending, <TT>RECOVER</TT> pending, <TT>REBUILD</TT> pending).<A NAME="ch07index08"></A><A NAME="ch07index09"></A></P></P></BLOCKQUOTE>
<A NAME="ch07lev2sec3"></A><H4 class="docSection2Title">Changing the Data Type of a Column</H4>
<P class="docText">Sometimes it becomes necessary to change the data type of a column for an existing DB2 table. Prior to V8 this required dropping and re-creating the table, but as of V8 a column data type may be changed if the data can be converted from the old type to the new without losing significance. Essentially, this means that the new column definition has to allow for "larger" values than the current column definition.<A NAME="ch07index10"></A><A NAME="ch07index11"></A><A NAME="ch07index12"></A><A NAME="ch07index13"></A><A NAME="ch07index14"></A></P>
<P class="docText">The <TT>ALTER TABLE</TT> statement can be used to change the data type of a column as indicated in <A class="docLink" HREF="#ch07table01">Table 7.1</A>. If the combination is not shown in this table, it is not supported—that is, you cannot use <TT>ALTER</TT> to make such a change.</P>
<A NAME="ch07table01"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 7.1. Data Type Changes Supported By <TT>ALTER</TT></h5></CAPTION><COLGROUP><COL width="253"><COL width="297"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Current Date Type</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Supported New Data Type(s)</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SMALLINT</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INTEGER</TT></P>
<P class="docText"><TT>REAL</TT></P>
<P class="docText"><TT>DOUBLE</TT>,</P>
<P class="docText"><TT>&gt;=DECIMAL(5,0)</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INTEGER</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DOUBLE</TT>,</P>
<P class="docText"><TT>&gt;=DECIMAL(10,0)</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>REAL</TT> [or <TT>FLOAT(4)</TT>]</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DOUBLE</TT> [or <TT>FLOAT(8)</TT>]</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>&lt;=DECIMAL(15,m)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DOUBLE</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DECIMAL(n,m)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DECIMAL(n+x,m+y)</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CHAR(n)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CHAR(n+x)</TT></P>
<P class="docText"><TT>VARCHAR(n+x)</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>VARCHAR(n)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CHAR(n+x)</TT></P>
<P class="docText"><TT>VARCHAR(n+x)</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>GRAPHIC(n)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>GRAPHIC(n+x)</TT></P>
<P class="docText"><TT>VARGRAPHIC(n+x)</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>VARGRAPHIC(n)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>GRAPHIC(n+x)</TT></P>
<P class="docText"><TT>VARGRAPHIC(n+x)</TT></P></TD></TR></TABLE></P><br>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> To change a data type under DB2 V8 you will use the <TT>SET DATATYPE</TT> clause of the <TT>ALTER TABLE</TT> statement. For example</P></td></tr></table><br>
<pre>

</pre><BR><pre>
ALTER TABLE DSN8810.EMP
  ALTER COLUMN EDLEVEL
  SET DATATYPE DECIMAL(7,0);
</pre><BR>
<P class="docText">This is possible because the current data type of <TT>EDLEVEL</TT> was <TT>SMALLINT</TT>, so it can be changed to a <TT>DECIMAL</TT> with a scale of 5 or greater.</P>
<P class="docText">After the <TT>ALTER</TT> runs successfully, DB2 creates a new "version" of the table space. The definition of the data type is stored in the DB2 Catalog and immediately applies to the data. Up to 256 concurrent versions of a table space and up to 16 concurrent versions of an index can be maintained by DB2. See the section "<A class="docLink" HREF="#ch07lev2sec6">Versioning for Online Schema Changes</A>" later in this chapter for more details on versioning.</P>
<P class="docText">Keep in mind, though, that the existing data is not changed or reformatted on disk. Instead, when data is retrieved, the changed column(s) will be materialized in the new format.</P>
<P class="docText">Updating or inserting data will cause the row to be saved using the format of the new data type. When the object is reorganized or rebuilt, the data is converted to the format of the latest version specified in the DB2 Catalog. This technique allows DB2 to offer the greatest availability to users with minimal performance degradation.<A NAME="ch07index17"></A><A NAME="ch07index18"></A><A NAME="ch07index19"></A><A NAME="ch07index20"></A><A NAME="ch07index21"></A></P>
<A NAME="ch07lev3sec1"></A><H5 class="docSection3Title">Limitations on Changing a Data Type</H5>
<P class="docText">Keep in mind that the data type can be changed only for character and numeric data types. You cannot change the data type of <TT>ROWID</TT>, <TT>DATE</TT>, <TT>TIME</TT>, <TT>TIMESTAMP</TT>, or <TT>FOR BIT DATA</TT> columns, nor can you change the length of an LOB column.<A NAME="ch07index22"></A><A NAME="ch07index23"></A></P>
<P class="docText">Additionally, you cannot change the data type or length of a column under the following circumstances:</P>
<UL><LI><P class="docList">The column is part of a materialized query table.</P></LI><LI><P class="docList">The column is part of a referential constraint.</P></LI><LI><P class="docList">The column is defined as an <TT>IDENTITY</TT> column.</P></LI><LI><P class="docList">The column has a <TT>FIELDPROC</TT> defined on it.</P></LI><LI><P class="docList">There is an <TT>EDITPROC</TT> or <TT>VALIDPROC</TT> defined on the table in which the column resides.</P></LI></UL>
<P class="docText">For each of these items you will need to <TT>DROP</TT> and re-<TT>CREATE</TT> the table to modify the data type or change its length.</P>
<A NAME="ch07lev3sec2"></A><H5 class="docSection3Title">Impact of Changing a Data Type</H5>
<P class="docText">When changing the data type for a column you need to be aware of the effect the change will have on other DB2 facilities and database objects. For example, when any column in a table has its data type changed, the <span class="docEmphBoldItalic">plans, packages, and cached dynamic statements</span> that reference the changed table are invalidated.<A NAME="ch07index24"></A><A NAME="ch07index25"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> After changing a data type or length using <TT>ALTER</TT>, be sure to analyze all of the application programs that reference the column—using either static or dynamic SQL. You can query <TT>SYSIBM.SYSPLANDEP</TT> and <TT>SYSIBM.SYSPACKDEP</TT> to find which plans and packages reference the changed column's table using static SQL, but you will have to use other means such as your data dictionary or a SQL performance monitor to find dynamic SQL dependencies. As you examine the programs that are potentially impacted, pay particular attention to the <span class="docEmphBoldItalic">host variables</span> that are used in conjunction with the column. You will probably have to change the definition of the host variable to conform to the new definition of the column. Failure to do so can cause data to be truncated. For example, if a column is changed from <TT>CHAR(x)</TT> to <TT>CHAR(x+y)</TT>, the processing application truncates the last <span class="docEmphasis">y</span> bytes unless the application is changed to accommodate the longer column.<A NAME="ch07index26"></A><A NAME="ch07index27"></A></P></td></tr></table><br>
<P class="docText"><span class="docEmphBoldItalic">Statistics</span> in the DB2 Catalog are also an issue. Any distribution statistics for the column in <TT>SYSIBM.SYSCOLDIST</TT> and <TT>SYSIBM.SYSCOLDISTSTATS</TT> will be invalidated when its data type changes. Additionally, the <TT>STATSTIME</TT> column in <TT>SYSIBM.SYSCOLUMNS</TT> will be set to January 1, 0001. This tells the optimizer to ignore the distribution frequency statistics. Be sure to run the <TT>RUNSTATS</TT> utility to repopulate the catalog with accurate column and index statistics as soon as possible after changing a column data type or length.<A NAME="ch07index28"></A><A NAME="ch07index29"></A><A NAME="ch07index30"></A><A NAME="ch07index31"></A><A NAME="ch07index32"></A><A NAME="ch07index33"></A></P>
<P class="docText">Table spaces, indexes, and views are the obvious database objects that will need to be modified when a data type is changed. Check constraints are affected, as well.</P>
<P class="docText">Every data type change requires the column's table space to be modified. Upon completion of a data type change, the <span class="docEmphBoldItalic">table space</span> will be placed in an <TT>AREO*</TT> exception state, which stands for Advisory <TT>REORG</TT> Pending. Users can continue to access the data while the table space is in the <TT>AREO*</TT> state, but performance will suffer because the columns will need to be converted from the old format to the format of the new data type. Additionally, when the data is modified, the entire row will be logged. Performance will continue to suffer until the table space is reorganized.<A NAME="ch07index34"></A></P>
<P class="docText"><span class="docEmphBoldItalic">Indexes</span> need to be changed if the column whose data type has changed participates in an index. The availability of the index depends upon the data type of the column being changed.<A NAME="ch07index35"></A></P>
<P class="docText">The index will be immediately available for use if a <TT>CHAR</TT>, <TT>VARCHAR</TT>, <TT>GRAPHIC</TT>, or <TT>VARGRAPHIC</TT> column is altered to increase its length. Altering a numeric data type to increase its length will result in delayed availability for the index. This includes columns defined as <TT>SMALLINT</TT>, <TT>INTEGER</TT>, <TT>DECIMAL</TT>, <TT>NUMERIC</TT>, <TT>FLOAT</TT>, <TT>REAL</TT>, or <TT>DOUBLE</TT>. The index is not immediately available because changes to numeric data would create severe performance problems. Instead, the index is placed into <TT>RBPD</TT> exception state, which stands for <TT>REBUILD</TT> Pending. If an entire index is rebuilt from the data, all the keys are converted to the latest format. The utilities that can be used to rebuild an index include <TT>REBUILD INDEX</TT>, <TT>REORG TABLESPACE</TT>, and <TT>LOAD REPLACE</TT>.</P>
<A NAME="ch07note03"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">DB2 will not choose any index in an <TT>RBDP</TT> exception state for an access path. To resolve this problem run the <TT>REBUILD INDEX</TT> utility to remove the <TT>RBDP</TT> exception.</P></div><br>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> If the data type changes (for example, from <TT>SMALLINT</TT> to <TT>DECIMAL</TT>), reorganizing the index will reformat the index keys to the latest version unless the index is in <TT>ARBDP</TT> (Advisory Rebuild Pending). An index in the <TT>ARBDP</TT> exception state requires access to the data to determine the length of the index key.</P></td></tr></table><br>
<P class="docText"><span class="docEmphBoldItalic">Views</span> that reference an impacted column will be immediately regenerated. DB2 will examine the DB2 Catalog to perform this regeneration. Affected views are retrieved from the <TT>SYSIBM.SYSVIEWDEP</TT> table and then <TT>SYSIBM.SYSVTREE</TT> and <TT>SYSIBM.SYSVLTREE</TT> are used to review and modify the parse tree for the views. Keep in mind that a view can be created on another view, so this process might be recursive. Also, as with tables, a change to any column within a view invalidates all plans, packages, and dynamic cached statements that are dependent on that view.<A NAME="ch07index36"></A><A NAME="ch07index37"></A><A NAME="ch07index38"></A></P>
<A NAME="ch07note04"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">The regeneration of a view can fail if the precision for decimal arithmetic does not work with the application. In this case, you must <TT>DROP</TT> and re-<TT>CREATE</TT> the view in order to correct the problem.</P></div><br>
<P class="docText">Finally, when <span class="docEmphBoldItalic">check constraints</span> exist on a column whose data type or length has changed, the constraints will bea regenerated.<A NAME="ch07index39"></A><A NAME="ch07index40"></A><A NAME="ch07index41"></A><A NAME="ch07index42"></A><A NAME="ch07index43"></A><A NAME="ch07index44"></A><A NAME="ch07index45"></A><A NAME="ch07index46"></A></P>
<A NAME="ch07note05"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">The regeneration of a check constraint can fail if the decimal point indicator or quote delimiter has changed since the check constraint was first defined.</P></div><br>
<A NAME="ch07lev2sec4"></A><H4 class="docSection2Title">Changing an Index</H4>
<P class="docText">Prior to DB2 V8, the aspects of an index that could be altered were limited to mostly storage characteristics. With V8 and online schema evolution, additional index attributes can be changed; you can use <TT>ALTER</TT> to add columns to an index, change the clustering specification, and modify the manner in which varying length index keys are treated.<A NAME="ch07index47"></A><A NAME="ch07index48"></A><A NAME="ch07index49"></A></P>
<A NAME="ch07lev3sec3"></A><H5 class="docSection3Title">Adding Columns to an Index</H5>
<P class="docText">To add a column to an index under DB2 V8 you will use the <TT>ADD COLUMN</TT> clause of the <TT>ALTER INDEX</TT> statement. For example, to add a column to the <TT>XDEPT2</TT> index (currently defined on the <TT>MGRNO</TT> column only)<A NAME="ch07index50"></A><A NAME="ch07index51"></A><A NAME="ch07index52"></A><A NAME="ch07index53"></A><A NAME="ch07index54"></A><A NAME="ch07index55"></A><A NAME="ch07index56"></A></P>
<pre>

</pre><BR><pre>
ALTER INDEX DSN8810.XDEPT2
  ADD COLUMN (ADMRDEPT);
</pre><BR>
<P class="docText">Running this <TT>ALTER</TT> statement adds the <TT>ADMRDEPT</TT> column to the existing <TT>XDEPT2</TT> index on the <TT>DSN8810.DEPT</TT> table. The new column will be appended to the end of the existing index key; you cannot change the existing order of a key or append a column to the beginning of the index key.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> What is the impact of adding a column to an index? Well, if the column is added to both the table and the index in the same unit of work, then the index is immediately available for use and it is put in the <TT>AREO*</TT> exception state. If the column was not added to the table in the same unit of work, the index is put into the <TT>RBDP</TT> exception state. This would be the state of the example we just reviewed. Finally, if the index was created specifying <TT>DEFINE NO</TT>, then no exception state is set and a new version of the index is not created; the index is simply changed in the DB2 Catalog awaiting eventual definition.<A NAME="ch07index57"></A><A NAME="ch07index58"></A><A NAME="ch07index59"></A><A NAME="ch07index60"></A><A NAME="ch07index61"></A><A NAME="ch07index62"></A><A NAME="ch07index63"></A></P></td></tr></table><br>
<A NAME="ch07lev3sec4"></A><H5 class="docSection3Title">Changing Clustering</H5>
<P class="docText">Sometimes it becomes necessary to adjust the manner in which DB2 attempts to store data physically on disk. Recall from <A class="docLink" HREF="ch05.html#ch05">Chapter 5</A>, "Data Definition Guidelines," that this is referred to as clustering. You might wish to change how data is clustered for several different reasons, such as<A NAME="ch07index64"></A><A NAME="ch07index65"></A><A NAME="ch07index66"></A><A NAME="ch07index67"></A><A NAME="ch07index68"></A><A NAME="ch07index69"></A></P>
<UL><LI><P class="docList">Data that used to be accessed mostly randomly is now being accessed mostly sequentially.</P></LI><LI><P class="docList">The initial clustering specification was chosen improperly.</P></LI><LI><P class="docList">The sort order changed for large batch reporting jobs.</P></LI><LI><P class="docList">The order in which data is being requested by applications has changed.</P></LI></UL>
<P class="docText">Prior to V8, changing clustering required dropping the clustering index and re-creating it without the <TT>CLUSTER</TT> keyword. To change clustering in DB2 V8, you can use the <TT>ALTER INDEX</TT> statement to specify either <TT>CLUSTER</TT> or <TT>NO CLUSTER</TT>. For example</P>
<pre>

</pre><BR><pre>
ALTER INDEX DSN8810.XPROJAC1
  NO CLUSTER;
</pre><BR>
<P class="docText">Running this <TT>ALTER</TT> statement will change the <TT>XPROJAC1</TT> index such that it no longer controls clustering. Keep in mind, though, that simply removing explicit clustering might not change the clustering specification for the table space. Until another clustering index is specified for the table, DB2 will continue to use the index that was just changed as the implicit clustering index.</P>
<A NAME="ch07note06"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">If no explicit clustering index is specified for a table, the first index created on each table will be used as the implicit clustering index.</P></div><br>
<P class="docText">When the clustering index is changed, new <TT>INSERT</TT> statements will cause data to be placed using the new clustering order. However, existing data is not immediately reclustered. Existing data will not be affected until the next time the table space is reorganized.</P>
<P class="docText">Of course, you are still restricted to having only one clustering index at any one point in time. So, you will need to order and time the execution of your <TT>ALTER INDEX</TT> statements so that there is never a state when two clustering indexes exist at the same time. For example, to change the clustering index from <TT>IX2</TT> to <TT>IX5</TT>, you would issue the following sequence of <TT>ALTER</TT> statements:<A NAME="ch07index70"></A><A NAME="ch07index71"></A><A NAME="ch07index72"></A><A NAME="ch07index73"></A><A NAME="ch07index74"></A><A NAME="ch07index75"></A></P>
<pre>

</pre><BR><pre>
ALTER INDEX IX2
  NO CLUSTER;

COMMIT;
</pre><BR><pre>
</pre><BR><pre><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></pre><BR><pre>

</pre><BR><pre>
 ALTER INDEX IX5
  CLUSTER;

COMMIT;
</pre><BR>
<A NAME="ch07note07"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">You can use the <TT>ALTER</TT> statement to respecify the clustering of your existing partitioned table spaces if you so desire. Prior to DB2 V8, the partitioning index for partitioned tables also had to be the clustering index. This is no longer the case. You can now specify a partitioning key that is not also the clustering key for a table.</P></div><br>
<A NAME="ch07lev3sec5"></A><H5 class="docSection3Title">Changing the Treatment of Variable Index Keys</H5>
<P class="docText">Prior to DB2 V8, specifying a variable length column in an index caused DB2 to pad the data to its maximum length in the index key. This is no longer a requirement, because DB2 V8 allows you to specify <TT>PADDED</TT> or <TT>NOT PADDED</TT> to control whether the index key should be padded to its maximum length. This specification can be made when the index is defined using <TT>CREATE INDEX</TT> or changed using <TT>ALTER INDEX</TT>.<A NAME="ch07index76"></A><A NAME="ch07index77"></A><A NAME="ch07index78"></A><A NAME="ch07index79"></A><A NAME="ch07index80"></A><A NAME="ch07index81"></A><A NAME="ch07index82"></A></P>
<A NAME="ch07note08"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">The default is <TT>PADDED</TT> when you migrate from V7 to V8 in order to maintain compatibility with past implementations. However, for new V8 installations the default is <TT>NOT PADDED</TT>.</P>
<P class="docText">A new DB2 V8 DSNZPARM named <TT>PADIX</TT> can be used to change the default.</P></div><br>
<P class="docText">When changing an index from <TT>PADDED</TT> to <TT>NOT PADDED</TT>, the index is placed in the <TT>ARBDP</TT> exception state and a value of <TT>'N'</TT> is placed in the <TT>PADDED</TT> column of <TT>SYSIBM.SYSINDEXES</TT>. The index must be rebuilt, because DB2 cannot determine the accurate length of the index key without accessing the table space. The index is not available for use until it has been rebuilt, thereby setting all of the keys to varying lengths and resetting the pending state.</P>
<A NAME="ch07note09"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Be aware that recovery to a point in time may cause the <TT>ARBDP</TT> exception state to be set (if that point in time was before the index was rebuilt).</P></div><br>
<P class="docText">You can also change an index from <TT>NOT PADDED</TT> to <TT>PADDED</TT> using <TT>ALTER INDEX</TT>. If the index has varying length columns, it is placed in the <TT>AREO*</TT> exception state and a value of <TT>'Y'</TT> is placed in the <TT>PADDED</TT> column of <TT>SYSIBM.SYSINDEXES</TT>. The index is available for use but performance will suffer. The index can be rebuilt or reorganized to pad the keys to the maximum length and reset the pending state.</P>
<P class="docText">Whenever the padding attribute of the index is changed, DB2 creates a new version of the index in the DB2 Catalog.<A NAME="ch07index83"></A><A NAME="ch07index84"></A><A NAME="ch07index85"></A><A NAME="ch07index86"></A><A NAME="ch07index87"></A><A NAME="ch07index88"></A><A NAME="ch07index89"></A></P>
<A NAME="ch07lev2sec5"></A><H4 class="docSection2Title">Changing Table Space Partitioning Specifications</H4>
<P class="docText">Historically, one of the biggest impediments to managing DB2 database systems has been administering partitioned table spaces. Prior to DB2 V8, it was either difficult or impossible to modify the structure and many of the parameters of a partitioned table space.<A NAME="ch07index90"></A><A NAME="ch07index91"></A><A NAME="ch07index92"></A><A NAME="ch07index93"></A><A NAME="ch07index94"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> Exacerbating this problem is the fact that most partitioned table spaces are the largest, most critical table spaces in the system with the highest availability requirements. Fortunately, DB2 V8 removes many of the barriers to managing partitioned table spaces.</P></td></tr></table><br>
<P class="docText">With DB2 V8 you gain the ability to immediately add partitions, rotate partitions, and change the partitioning key values. In order to gain this flexibility, though, you will need to change from index-controlled partitioning to table-controlled partitioned tables. Then, you can use the <TT>ALTER TABLE</TT> statement to modify most of the partitioning specifications.</P>
<A NAME="ch07lev3sec6"></A><H5 class="docSection3Title">Adding Partitions</H5>
<P class="docText">To add a partition to an existing table space the <TT>ALTER TABLE</TT> statement has been augmented with the <TT>ADD PART</TT> parameter. For example, consider a table space that is partitioned having one fiscal quarter worth of data per partition. Eventually, you might run out of partitions and need to add one. Assume that the last partition holds data up to the third quarter of 2004, but now you need to add data past this date. The following SQL shows how to use <TT>ALTER</TT> to add a new partition to a table:<A NAME="ch07index95"></A><A NAME="ch07index96"></A><A NAME="ch07index97"></A><A NAME="ch07index98"></A><A NAME="ch07index99"></A><A NAME="ch07index100"></A><A NAME="ch07index101"></A><A NAME="ch07index102"></A><A NAME="ch07index103"></A></P>
<pre>

</pre><BR><pre>
ALTER TABLE CREATOR.TBNAME
  ADD PART VALUES('12-31-2004');
</pre><BR>
<P class="docText">Of course, this assumes that your fourth quarter ends in December.</P>
<A NAME="ch07note10"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">You do not specify a partition number when you add a partition. DB2 will determine the next partition number to be used by examining information in the DB2 Catalog.</P></div><br>
<P class="docText">Along with adding a new data partition, a new partition is added for each partitioning index. This can include both the partitioning index and data-partitioned secondary indexes (DPSIs), as well.</P>
<P class="docText">You can add partitions up to the maximum limit; the maximum number of partitions depends on the <TT>DSSIZE</TT> parameter and page size of the table space (as defined in <A class="docLink" HREF="ch05.html#ch05">Chapter 5</A>).</P>
<P class="docText">You cannot specify attributes such as <TT>PRIQTY</TT> and <TT>SECQTY</TT>; instead, DB2 uses the values in use for the previous logical partition. Before you begin to use the new partition, you should execute an <TT>ALTER TABLESPACE</TT> statement to provide accurate space parameters for the new partition.</P>
<P class="docText">If you are using <TT>STOGROUP</TT>s the next data set is automatically allocated for the table space and each partitioned index. When your DB2 objects are user managed (<TT>VCAT</TT>), you must pre-define the data sets using VSAM <TT>IDCAMS</TT>.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> Each newly added partition will be immediately available for use, but you must stop the table space and partitioned index before adding the partition. When adding a partition, the table will be quiesced and all related plans, packages, and cached statements will be invalidated. This is required because certain access paths might be optimized to read only certain partitions. Automatic rebinds will occur if <TT>AUTO REBIND</TT> is enabled, but rebinding manually is usually a better approach to avoid performance problems, as applications wait to rebind before execution.<A NAME="ch07index104"></A><A NAME="ch07index105"></A><A NAME="ch07index106"></A><A NAME="ch07index107"></A><A NAME="ch07index108"></A><A NAME="ch07index109"></A><A NAME="ch07index110"></A><A NAME="ch07index111"></A><A NAME="ch07index112"></A><A NAME="ch07index113"></A></P></td></tr></table><br>
<A NAME="ch07lev3sec7"></A><H5 class="docSection3Title">Rotating Partitions</H5>
<P class="docText">If the requirement to add a partition can be satisfied by allowing an existing partition to be reused, you might be able to rotate the partition. Rotating partitions allows old data to "roll off," but the partition is kept for new data. This is a good option in the following situations:<A NAME="ch07index114"></A><A NAME="ch07index115"></A><A NAME="ch07index116"></A><A NAME="ch07index117"></A><A NAME="ch07index118"></A></P>
<UL><LI><P class="docList">A year of data is kept in 13 partitions.</P></LI><LI><P class="docList">Data is stored with a quarter in each partition but only the last 20 quarters (5 years) are needed online; <span class="docEmphasis">this might be any number of quarter or years</span>.</P></LI><LI><P class="docList">Any time old data is periodically archived and only a limited number of partitions need to be active.</P></LI></UL>
<P class="docText">Partition rotation is implemented using the <TT>ALTER TABLE ALTER PART ROTATE FIRST TO LAST</TT> statement. When rotating, if you specify the <TT>RESET</TT> parameter, the data rows in the oldest (or logically first) partition are deleted, and a new table space high boundary is set so that partition becomes the last logical partition in sequence. This partition will then be ready to hold the new data as it is added. The partition that was rolled off is immediately available after the <TT>ALTER</TT> succeeds; a <TT>REORG</TT> is not required.<A NAME="ch07index119"></A><A NAME="ch07index120"></A></P>
<A NAME="ch07note11"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">When specifying <TT>RESET</TT>, the existing data in the oldest partition is deleted and <TT>SYSIBM.SYSCOPY</TT> and <TT>SYSLGRNX</TT> rows associated with the partition being reset are deleted, too.</P></div><br>
<P class="docText">The aftermath of rotating a partition can be confusing. This is especially the case if you are trying to match partitions to physical data sets. The <TT>.A001</TT> data set is now the last logical partition, not the first. You will need to use the new <TT>LOGICAL_PART</TT> column in the <TT>SYSIBM.SYSTABLEPART</TT> table to match partitions to data sets. The <TT>DISPLAY</TT> command will list the status of table space partitions by logical partition.</P>
<P class="docText">Also, steps need to be taken if you need to keep the rolled off data for archival purposes. Be sure to unload the data immediately before rotating the partition using either the <TT>UNLOAD</TT> utility or a user-written program.</P>
<P class="docText">If this <TT>REUSE</TT> option is specified, a logical reset of the partition is done instead of deleting and redefining data sets. Existing extents for the partition will be kept.<A NAME="ch07index121"></A><A NAME="ch07index122"></A><A NAME="ch07index123"></A><A NAME="ch07index124"></A><A NAME="ch07index125"></A></P>
<A NAME="ch07lev3sec8"></A><H5 class="docSection3Title">Changing Partition Boundaries</H5>
<P class="docText">DB2 V6 introduced the ability to modify limit keys for partitions. DB2 V8 adds the same capability for table-based partitioning with the <TT>ALTER TABLE ALTER PART VALUES</TT> statement. The affected data partitions are placed into the <TT>REORG</TT> pending state until they have been reorganized.<A NAME="ch07index126"></A><A NAME="ch07index127"></A><A NAME="ch07index128"></A><A NAME="ch07index129"></A><A NAME="ch07index130"></A><A NAME="ch07index131"></A><A NAME="ch07index132"></A></P>
<A NAME="ch07lev3sec9"></A><H5 class="docSection3Title">Rebalancing Partitions</H5>

<P class="docText">You can rebalance partitions when running DB2 V8, too. Unlike the schema changes previously discussed in this chapter, partition rebalancing is accomplished using the <TT>REORG</TT> utility instead of the <TT>ALTER</TT> statement. When reorganizing a table space you can specify a new parameter, <TT>REBALANCE</TT>, indicating that new partition boundaries should be set for the range of partitions being reorganized. DB2 will rebalance the data such that it is evenly distributed across the partitions. Rebalancing is most practical when the data is not skewed greatly.<A NAME="ch07index133"></A><A NAME="ch07index134"></A><A NAME="ch07index135"></A><A NAME="ch07index136"></A><A NAME="ch07index137"></A><A NAME="ch07index138"></A><A NAME="ch07index139"></A></P>
<A NAME="ch07note12"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">When many duplicate values occur in the columns that define the partition boundaries, DB2 might not be able to evenly balance the data effectively.</P></div><br>
<P class="docText">Yes, you are reading this right. Running a <TT>REORG</TT> with the <TT>REBALANCE</TT> option can change the limit key for partition boundaries. The <TT>REORG</TT> will set new partition boundaries so that all the rows participating in the reorganization are evenly distributed across the partitions being reorganized. DB2 will update the <TT>SYSIBM.SYSTABLEPART</TT> and <TT>SYSIBM.SYSINDEXPART</TT> tables to record the new limit key values.</P>
<P class="docText">Using <TT>REORG</TT> to rebalance partitions has its advantages. Using this approach, your partitions will not be placed in the <TT>REORG</TT> exception state, as would be the case if you changed the partition boundaries using <TT>ALTER TABLE</TT>.<A NAME="ch07index140"></A><A NAME="ch07index141"></A><A NAME="ch07index142"></A><A NAME="ch07index143"></A><A NAME="ch07index144"></A></P>
<P class="docText">Keep the following restrictions in mind when considering whether to rebalance your partitions using <TT>REORG</TT>:</P>
<UL><LI><P class="docList">You cannot specify the <TT>REBALANCE</TT> keyword if you are reorganizing a table space using the <TT>SHRLEVEL CHANGE</TT> option.</P></LI><LI><P class="docList">You cannot specify the <TT>REBALANCE</TT> keyword with any of the following keywords: <TT>SCOPE PENDING</TT>, <TT>OFFPOSLIMIT</TT>, <TT>INDREFLIMIT</TT>, <TT>REPORTONLY</TT>, <TT>UNLOAD ONLY</TT>, and <TT>UNLOAD EXTERNAL</TT>.</P></LI><LI><P class="docList">You cannot rebalance a partitioned table space that also has LOB columns.</P></LI><LI><P class="docList">When the clustering sequence does not match the partitioning sequence, <TT>REORG</TT> must be run twice. The first <TT>REORG</TT> moves the rows to the right partition; the second <TT>REORG</TT> sorts the data into clustering sequence. After the first <TT>REORG</TT>, DB2 places the table space in the <TT>AREO*</TT> exception state—meaning that DB2 recommends running another <TT>REORG</TT> (to cluster the data).<A NAME="ch07index145"></A><A NAME="ch07index146"></A><A NAME="ch07index147"></A><A NAME="ch07index148"></A><A NAME="ch07index149"></A><A NAME="ch07index150"></A><A NAME="ch07index151"></A><A NAME="ch07index152"></A><A NAME="ch07index153"></A><A NAME="ch07index154"></A></P></LI></UL>
<A NAME="ch07note13"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">After rebalancing is complete, plans, packages, and the dynamic statement cache records that reference the reorganized object are invalidated.</P></div><br>
<A NAME="ch07lev2sec6"></A><p><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><H4 class="docSection2Title">Versioning for Online Schema Changes</H4></td></tr></table></p>

<P class="docText">To support online schema changes, DB2 has been enhanced to support multiple versions of DB2 objects. As certain schema changes are made, DB2 creates a new version to refer to the new structure. Multiple versions can exist at one time, each version referring to the object at a different stage of its life.<A NAME="ch07index155"></A><A NAME="ch07index156"></A><A NAME="ch07index157"></A></P>
<P class="docText">Issuing an <TT>ALTER</TT> for an existing DB2 object or column can cause a new format to be needed for tables, table spaces, and/or indexes. DB2 needs to know about the old format and the new format because all of the underlying data for an object (as well as its image copies) cannot be changed immediately to match the format of the latest version. By supporting multiple versions with different formats over time for tables and indexes, maximum data availability is achieved.</P>
<P class="docText">DB2 references the version information to appropriately store and use the data in its correct format. Versioning is tracked and recorded in the <TT>OLDEST_VERSION</TT> and <TT>CURRENT_VERSION</TT> columns in the following DB2 Catalog tables:</P>
<BLOCKQUOTE><P><P class="docList"><TT>SYSIBM.SYSTABLESPACE</TT></P></P><P><P class="docList"><TT>SYSIBM.SYSTABLEPART</TT></P></P><P><P class="docList"><TT>SYSIBM.SYSTABLES</TT></P></P><P><P class="docList"><TT>SYSIBM.SYSINDEXES</TT></P></P><P><P class="docList"><TT>SYSIBM.SYSINDEXPART</TT></P></P><P><P class="docList"><TT>SYSIBM.SYSOBDS</TT></P></P><P><P class="docList"><TT>SYSIBM.SYSCOPY</TT></P></P></BLOCKQUOTE>
<P class="docText"><TT>SYSIBM.SYSOBDS</TT> is a new V8 DB2 Catalog table that contains one row for each table space and index that can be recovered to an image copy that was made before the first version was generated.</P>
<P class="docText">However, the version information relevant to the data also is stored in system pages embedded in the table space or index page set. The system pages are stored along with the data so that the data can be properly interpreted. Doing so makes table spaces and indexes self-defining. Additionally, with the version information embedded in the page set, data can be accessed or unloaded from an image copy without DB2 being up.</P>
<A NAME="ch07note14"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">DB2 supported versioning prior to V8. When an indexed <TT>VARCHAR</TT> column in a table is enlarged, a new index version is created and tracked using the <TT>IOFACTOR</TT> column of <TT>SYSIBM.SYSINDEXES</TT>.</P>
<P class="docText">In DB2 V8, the first <TT>ALTER</TT> that creates a new index version switches to DB2 V8 versioning by setting the <TT>OLDEST_VERSION</TT> and <TT>CURRENT_VERSION</TT> columns to the existing versions in the index.</P></div><br>
<P class="docText">The <TT>OLDEST_VERSION</TT> is the oldest format of the data in the object itself or any image copy still registered in <TT>SYSIBM.SYSCOPY</TT>. There is an upper bound for version numbers. A table space can have up to 256 different active versions; an index can have up to 16 different active versions. A version is active if it is used on any page within a page set (table space or index) or is in use in an existing image copy still registered in the DB2 Catalog.</P>
<A NAME="ch07note15"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">When the upper bound is hit for a version and a new version must be created, the version number will wrap back to the beginning—starting again at version 1 (not zero). So, it is possible that the <TT>CURRENT_VERSION</TT> is a lower number than the <TT>OLDEST_VERSION</TT>.</P>
<P class="docText">Of course, DB2 will not wrap if version number 1 is still an active version. If the maximum number of active versions is reached, a <TT>–4702 SQLCODE</TT> will be returned and the <TT>ALTER</TT> will fail.</P></div><br>
<P class="docText">An object that is never altered remains at version zero.<A NAME="ch07index158"></A><A NAME="ch07index159"></A><A NAME="ch07index160"></A></P>
<A NAME="ch07lev3sec10"></A><H5 class="docSection3Title">When Is a New Version Generated?</H5>
<P class="docText">A new version is created for the table or index that is affected whenever the following types of changes are made:<A NAME="ch07index161"></A><A NAME="ch07index162"></A><A NAME="ch07index163"></A></P>
<UL><LI><P class="docList"><TT>ALTER TABLE</TT> table-name <TT>ALTER COLUMN</TT> column-name <TT>SET DATA TYPE</TT> altered-data-type.</P></LI><LI><P class="docList"><TT>ALTER INDEX</TT> index-name <TT>NOT PADDED</TT>.</P></LI><LI><P class="docList"><TT>ALTER INDEX</TT> index-name <TT>PADDED</TT>.</P></LI><LI><P class="docList"><TT>ALTER INDEX</TT> index-name <TT>ADD COLUMN</TT> column-name.</P></LI><LI><P class="docList">Multiple <TT>ALTER COLUMN SET DATA TYPE</TT> statements in the same unit of work are included in one new schema version.</P></LI></UL>
<A NAME="ch07lev3sec11"></A><H5 class="docSection3Title">Deactivating Versions</H5>
<P class="docText">For table spaces, and indexes defined as <TT>COPY YES</TT>, the <TT>MODIFY</TT> utility needs to be run to update the <TT>LOW_VERSION</TT> in the DB2 Catalog and reclaim the version by making it inactive. If there are entries for <TT>COPY</TT>, <TT>REORG</TT>, or <TT>REPAIR VERSIONS</TT> remaining in <TT>SYSIBM.SYSCOPY</TT> for the table space, <TT>MODIFY</TT> updates <TT>LOW_VERSION</TT> to be the lowest value of <TT>LOW_VERSION</TT> found from matching <TT>SYSCOPY</TT> rows. If no <TT>SYSCOPY</TT> rows remain for the object, <TT>MODIFY</TT> sets <TT>LOW_VERSION</TT> to the lowest version data row or key that exists in the active page set.<A NAME="ch07index164"></A><A NAME="ch07index165"></A><A NAME="ch07index166"></A><A NAME="ch07index167"></A></P>
<P class="docText">For indexes defined as <TT>COPY NO</TT>, running a <TT>REORG</TT>, <TT>REBUILD</TT>, or <TT>LOAD</TT> utility that resets the entire index updates the <TT>LOW_VERSION</TT> in <TT>SYSIBM.SYSINDEXES</TT> to be the same as <TT>HIGH_VERSION</TT>.</P>
<A NAME="ch07lev2sec7"></A><H4 class="docSection2Title">Database Exception States for Online Schema Changes</H4>
<P class="docText">Exception states are used by DB2 to alert administrators and users to a database condition that needs to be managed or improved. Exception states have been used in all past releases of DB2, but two new states have been created to support online schema changes. Throughout this chapter, we have discussed these new database exception states, but we will review them here for easy reference:<A NAME="ch07index168"></A><A NAME="ch07index169"></A><A NAME="ch07index170"></A><A NAME="ch07index171"></A></P>
<BLOCKQUOTE><P><p class="docText"><span class="docEmphStrong">Advisory Reorg</span> <span class="docEmphRoman">(</span><TT>AREO*</TT><span class="docEmphRoman">)</span>— 
<IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"> Indicates that the specified table space, index, or partition needs to be reorganized for performance to improve.<A NAME="ch07index172"></A></p></P><P><p class="docText"><span class="docEmphStrong">Advisory Rebuild Pending</span> <span class="docEmphRoman">(</span><TT>ARBDP</TT><span class="docEmphRoman">)</span>— 
Indicates that the specified index needs to be rebuilt to improve performance and to allow DB2 to choose the index for index-only access.<A NAME="ch07index173"></A></p></P></BLOCKQUOTE>
<P class="docText">As with any DB2 database exception state, these states will appear when you issue the <TT>DISPLAY</TT> command to monitor the status of your database objects. Consult <A class="docLink" HREF="ch37.html#ch37">Chapter 37</A>, "DB2 Utility and Command Guidelines," for a complete discussion of the database exception states.</P>
<A NAME="ch07lev2sec8"></A><H4 class="docSection2Title">Online Schema Change Implementation Considerations</H4>
<P class="docText">Keep in mind that existing access paths can become inefficient when a new version of an object is created. Therefore, making an online schema change might cause performance to degrade. Just because IBM has made it easier to implement changes to database objects does not mean that changes can be made indiscriminately and without planning.<A NAME="ch07index174"></A><A NAME="ch07index175"></A><A NAME="ch07index176"></A></P>
<P class="docText">Be sure to treat every database change as a potential impact to performance and availability. Whenever possible, schedule schema changes as close to a scheduled reorganization as possible. This will minimize the potential performance impact.</P>
<P class="docText">Certain types of online schema changes are more invasive than others. For example, rotating partitions can be very time-consuming. When rotating partitions of a partitioned table, the reset operation requires that the keys for deleted rows also be deleted from all NPIs. Because each NPI must be scanned to delete the keys this activity can consume an inordinate amount of elapsed time to complete.</P>
<P class="docText">Individual delete row processing is required for referential integrity relationships when <TT>DATA CAPTURE</TT> is enabled, or when there are delete triggers. In such scenarios, be sure to factor in additional time to delete data a row at a time.</P>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch07.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch08.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
