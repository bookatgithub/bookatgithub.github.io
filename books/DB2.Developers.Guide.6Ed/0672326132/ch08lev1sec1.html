<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>What Is a Trigger?</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch08.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch08lev1sec2.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch08lev1sec1"></A><H3 class="docSection1Title">What Is a Trigger?</H3>
<P class="docText">Simply stated, a <span class="docEmphasis">trigger</span> is a piece of code that is executed in response to an SQL data modification statement; that is, an <TT>INSERT</TT>, <TT>UPDATE</TT>, or <TT>DELETE</TT>. To be a bit more precise: Triggers are event-driven specialized procedures that are stored in and managed by the RDBMS. Each trigger is attached to a single, specified table. A trigger can be thought of as an advanced form of "rule" or "constraint" written using an extended form of SQL. A trigger cannot be directly called or executed; it is automatically executed (or "fired") by DB2 as the result of an action—a data modification to the associated table.<A NAME="ch08index01"></A></P>
<P class="docText">After a trigger is created, it is always executed when its "firing" event occurs (<TT>INSERT</TT>, <TT>UPDATE</TT>, or <TT>DELETE</TT>). Therefore, triggers are automatic, implicit, and non-bypassable.</P>
<A NAME="ch08lev2sec1"></A><H4 class="docSection2Title">The Schema</H4>
<P class="docText">Recall from <A class="docLink" HREF="ch04.html#ch04">Chapter 4</A>, "Using DB2 User-Defined Functions and Data Types," that user-defined functions, user-defined distinct types, stored procedures, and triggers are all associated with a schema. By default, the schema name is the authid of the process that issues the <TT>CREATE FUNCTION</TT>, <TT>CREATE DISTINCT TYPE</TT>, <TT>CREATE PROCEDURE</TT>, or <TT>CREATE TRIGGER</TT> statement.<A NAME="ch08index02"></A></P>
<P class="docText">A schema, therefore, is simply a logical grouping of procedural database objects (user-defined functions, user-defined distinct types, stored procedures, and triggers).</P>
<P class="docText">You can specify a schema name when you create a user-defined function, type, or trigger. If the schema name is not the same as the SQL authorization ID, the issuer of the statement must have either <TT>SYSADM</TT> or <TT>SYSCTRL</TT> authority, or the authid of the issuing process has the <TT>CREATEIN</TT> privilege on the schema.</P>
<A NAME="ch08note01"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">A DB2 schema is not really a DB2 object. You cannot explicitly <TT>CREATE</TT> or <TT>DROP</TT> a schema. The schema is implicitly <span class="docEmphasis">created</span> when the first DB2 object is created using that schema name.</P></div><br>
<A NAME="ch08lev2sec2"></A><H4 class="docSection2Title">Triggers Are Hybrid DB2 Objects</H4>
<P class="docText">Triggers are like other database objects, such as tables and indexes, in that they are created using DDL, stored in the database, and documented as entries in the DB2 Catalog.</P>
<P class="docText">Triggers also are like stored procedures and check constraints in that they contain code, or logic, and can be used to control data integrity.</P>
<A NAME="ch08lev3sec1"></A><H5 class="docSection3Title">Triggers Versus Stored Procedures</H5>
<P class="docText">Triggers are similar in functionality to stored procedures. Both consist of procedural logic that is stored at the database level. However, stored procedures are not event-driven and are not attached to a specific table. A stored procedure is explicitly executed by invoking a <TT>CALL</TT> to the procedure (instead of implicitly being executed like triggers). Additionally, a stored procedure can access many tables without being specifically associated to any of them.<A NAME="ch08index03"></A><A NAME="ch08index04"></A></P>
<A NAME="ch08lev3sec2"></A><H5 class="docSection3Title">Triggers Versus Check Constraints</H5>
<P class="docText">Triggers are similar to table check constraints because triggers can be used to control integrity when data is changed in a DB2 table. However, triggers are much more powerful than simple check constraints because they can be coded to accomplish more types of actions. A check constraint is used to specify what data is allowable in a column, but a trigger can do that, plus make changes to data. Furthermore, a trigger can act on data in other tables, whereas a check constraint cannot.<A NAME="ch08index05"></A><A NAME="ch08index06"></A></P>
<P class="docText">Furthermore, triggers have more knowledge of the database change. A trigger can view both the old value and the new value of a changed column and take action based on that information.</P>
<A NAME="ch08note02"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">When deciding whether to use a constraint or a trigger, keep in mind that triggers are more expensive than an equivalent constraint. You should always consider the relative cost of executing each. If the task at hand can be completed with either a trigger or a constraint, favor constraints because they are cheaper than triggers and it is always better to use the cheaper alternative.</P></div><br>
<A NAME="ch08lev2sec3"></A><H4 class="docSection2Title">Why Use Triggers?</H4>
<P class="docText">Triggers are useful for implementing code that must be executed on a regular basis due to a predefined event. By utilizing triggers, scheduling and data integrity problems can be eliminated because the trigger will be fired whenever the triggering event occurs. You need not remember to schedule or code an activity to perform the logic in the trigger. It happens automatically by virtue of it being in the trigger. This is true of both static and dynamic SQL; planned and ad hoc. Simply stated: Whenever the triggering event occurs, the trigger is fired.<A NAME="ch08index07"></A></P>
<P class="docText">Triggers can be implemented for many practical uses. Quite often, it is impossible to code business rules into the database using only DDL. For example, DB2 does not support complex constraints (only value-based <TT>CHECK</TT> constraints) or various types of referential constraints (such as pendant <TT>DELETE</TT> processing or <TT>ON UPDATE CASCADE</TT>). Using triggers, a very flexible environment is established for implementing business rules and constraints in the DBMS. This is important because having the business rules in the database ensures that everyone uses the same logic to accomplish the same process.<A NAME="ch08index08"></A><A NAME="ch08index09"></A></P>
<P class="docText">Triggers can be coded to access and/or modify other tables, print informational messages, and specify complex restrictions. For example, consider the standard suppliers and parts application used in most introductory database texts. A part can be supplied by many suppliers and a supplier can supply many parts. Triggers can be used to support the following scenarios:</P>
<UL><LI><P class="docList">What if a business rule exists specifying that no more than three suppliers are permitted to supply any single part? A trigger can be coded to check that rows cannot be inserted if the data violates this requirement.</P></LI><LI><P class="docList">A trigger can be created to allow only orders for parts that are already in stock, or maybe for parts that are already in stock or are on order and planned for availability within the next week.</P></LI><LI><P class="docList">Triggers can be used to perform calculations, such as ensuring that the order amount for the parts is calculated appropriately, given the suppliers chosen to provide the parts. This is especially useful if the order purchase amount is stored in the database as redundant data.</P></LI><LI><P class="docList">Triggers can be used to automatically generate values for newly inserted rows. For example, you could generate customer profile information whenever a new row is inserted into a customer table.</P></LI><LI><P class="docList">To curb costs, a business decision may be made that the low cost supplier will always be used. A trigger can be implemented to disallow any order that is not the current "low cost" order.</P></LI></UL>
<P class="docText">The number of business rules that can be implemented using triggers is truly limited only by your imagination (or, more appropriately, your business needs).<A NAME="ch08index10"></A></P>
<P class="docText">After you define a trigger on a table, it is stored in the database, and any application or ad hoc SQL that modifies that table uses it. Triggers can help ease application development and maintenance tasks. For example, if a business rule changes, you only have to update the trigger, not the application code. Furthermore, if ad hoc updates are allowed, triggers will enforce integrity rules that otherwise would have been bypassed because the update was ad hoc. Therefore, you should code business rules into triggers instead of application program logic whenever possible.<A NAME="ch08index11"></A><A NAME="ch08index12"></A></P>
<P class="docText">Additionally, triggers can access non-DB2 resources. This can be accomplished by invoking a stored procedure or a user-defined function that takes advantage of the OS/390 resource recovery services (RRS). Data stored in the non-DB2 resource can be accessed or modified in the stored procedure or user-defined function that is called from the trigger.<A NAME="ch08index13"></A><A NAME="ch08index14"></A><A NAME="ch08index15"></A><A NAME="ch08index16"></A><A NAME="ch08index17"></A></P>
<A NAME="ch08lev2sec4"></A><H4 class="docSection2Title">When Does a Trigger Fire?</H4>
<P class="docText">At the basic level, we have already discussed when a trigger fires: that is, whenever its triggering activity occurs. For example, an <TT>UPDATE</TT> trigger will fire whenever an <TT>UPDATE</TT> is issued on the table on which the trigger is defined. But there is another, more subtle, question. Does the logic in the trigger get executed before the firing <TT>UPDATE</TT> or after?<A NAME="ch08index18"></A><A NAME="ch08index19"></A></P>
<P class="docText">Two options exist for when a trigger can fire: before the firing activity occurs or after the firing activity occurs. DB2 supports both "before" and "after" triggers. A "before" trigger executes before the firing activity occurs; an "after" trigger executes after the firing activity occurs. In DB2, "before" triggers are restricted because they cannot perform updates.<A NAME="ch08index20"></A><A NAME="ch08index21"></A><A NAME="ch08index22"></A><A NAME="ch08index23"></A></P>
<P class="docText">Knowing how the triggers in your databases function is imperative. Without this knowledge, properly functioning triggers cannot be coded, supported, or maintained effectively. Why is this?</P>
<P class="docText">Consider, for example, if the firing activity occurs before the trigger is fired. In other words, the <TT>INSERT</TT>, <TT>UPDATE</TT>, or <TT>DELETE</TT> occurs first; then, as a result of this action, the trigger logic is executed. If necessary, the trigger code can change transition variables. What if the trigger is fired before the actual firing event occurs? In this situation, DB2 disallows modification of transition variables.<A NAME="ch08index24"></A><A NAME="ch08index25"></A></P>
<P class="docText">Another interesting feature of DB2 triggers is the order in which they are fired. If multiple triggers are coded on the same table, which trigger is fired first? It can make a difference as to how the triggers should be coded, tested, and maintained. The rule for order of execution is basically simple to understand, but can be difficult to maintain. For triggers of the same type, they are executed in the order in which they were created. For example, if two <TT>DELETE</TT> triggers are coded on the same table, the one that physically was created first is executed first. Keep this in mind as you make changes to your database objects and triggers. If you need to <TT>DROP</TT> the table and re-create it to implement a database change, make sure you create the triggers in the same order as they originally were created to keep the functionality the same.<A NAME="ch08index26"></A><A NAME="ch08index27"></A></P>
<P class="docText">To understand why this is important, consider this simple example. Two <TT>INSERT</TT> triggers are created on <TT>TABLE1</TT>, as follows:</P>
<UL><LI><P class="docList"><TT>TRIGGER1</TT> adds +5 to <TT>COL1</TT> of <TT>TABLE2</TT></P></LI><LI><P class="docList"><TT>TRIGGER2</TT> multiplies <TT>COL1</TT> of <TT>TABLE2</TT> by 2</P></LI></UL>
<P class="docText">The triggers are of the same type, so because <TT>TRIGGER1</TT> was created first, it will fire first whenever an <TT>INSERT</TT> occurs to <TT>TABLE1</TT>. If <TT>COL1</TT> of <TT>TABLE2</TT> is initially set to 1, after the triggers fire, the value will be</P>
<pre>

</pre><BR><pre>
(1 + 5) * 2 = 12
</pre><BR>
<P class="docText">However, if you later make changes requiring the triggers to be dropped and re-created, but inadvertently created them in reverse order, <TT>TRIGGER2</TT> then <TT>TRIGGER1</TT>, the actions would change causing the following to occur:</P>
<pre>

</pre><BR><pre>
(1 * 2) + 5 = 7
</pre><BR>
<P class="docText">You can see that this can cause drastically different results. Determining the procedural activity that is required when triggers are present can be a complicated task. It is of paramount importance that all developers are schooled in the firing methods utilized for triggers in DB2.<A NAME="ch08index28"></A><A NAME="ch08index29"></A></P>
<P class="docText">To determine the order in which the triggers were created for a table, issue the following query substituting the table owner and table name in place of the question marks</P>
<pre>

</pre><BR><pre>
SELECT   DISTINCT SCHEMA, NAME, CREATEDTS
FROM     SYSIBM.SYSTRIGGERS
WHERE    TBOWNER = ?
AND      TBNAME = ?
ORDER BY CREATEDTS;
</pre><BR>
<P class="docText">The results will be returned in the order the triggers were created, earliest to latest. The <TT>DISTINCT</TT> is required because trigger definitions may require multiple rows in <TT>SYSIBM.SYSTRIGGERS</TT>.<A NAME="ch08index30"></A><A NAME="ch08index31"></A></P>
<A NAME="ch08lev2sec5"></A><H4 class="docSection2Title">Creating Triggers</H4>
<P class="docText">Triggers are created using the <TT>CREATE TRIGGER</TT> DDL statement. Before creating any triggers, be sure you know<A NAME="ch08index32"></A><A NAME="ch08index33"></A><A NAME="ch08index34"></A></P>
<UL><LI><P class="docList">The business rule you are trying to enforce with the trigger</P></LI><LI><P class="docList">Whether or not the trigger will modify data in other tables</P></LI><LI><P class="docList">What other triggers exist on the table</P></LI><LI><P class="docList">What actions those triggers perform</P></LI><LI><P class="docList">The order in which those triggers were created</P></LI><LI><P class="docList">The referential integrity implemented on any impacted tables</P></LI><LI><P class="docList">The RI rules for those referential constraints</P></LI><LI><P class="docList">The firing activity (<TT>UPDATE</TT>, <TT>DELETE</TT>, or <TT>INSERT</TT>) for the new trigger</P></LI><LI><P class="docList">Whether the trigger fires "before" or "after" the firing event</P></LI></UL>
<P class="docText">The DDL statement issued to <TT>CREATE</TT> a trigger requires the following details:</P>
<BLOCKQUOTE><P><p class="docText"><span class="docEmphRoman">Trigger Name</span>— 
The name of the trigger</p></P><P><p class="docText"><span class="docEmphRoman">Triggering Table</span>— 
The table for which the trigger exists</p></P><P><p class="docText"><span class="docEmphRoman">Activation</span>— 
Whether the trigger fires <TT>BEFORE</TT> or <TT>AFTER</TT> the data modification</p></P><P><p class="docText"><span class="docEmphRoman">Triggering Event</span>— 
The statement that causes the trigger to fire, that is <TT>INSERT</TT>, <TT>UPDATE</TT>, or <TT>DELETE</TT></p></P><P><p class="docText"><span class="docEmphRoman">Granularity</span>— 
Whether the trigger fires <TT>FOR EACH ROW</TT> or <TT>FOR EACH STATEMENT</TT></p></P><P><p class="docText"><span class="docEmphRoman">Transition Variables or Table</span>— 
The names to be used to reference the information prior to, and after the data modification.</p></P><P><p class="docText"><span class="docEmphRoman">Trigger Condition</span>— 
An optional condition can be specified whereby the triggered action that follows is only executed when the condition evaluates to true.</p></P><P><p class="docText"><span class="docEmphRoman">Triggered Action</span>— 
The actual code that runs when the trigger is fired.</p></P></BLOCKQUOTE>
<P class="docText">Furthermore, like any program you write, you should have the basic logic and flow of the trigger code mapped out before you sit down to write it.<A NAME="ch08index35"></A><A NAME="ch08index36"></A><A NAME="ch08index37"></A></P>
<P class="docText">So, let's examine the basic things that you must know before coding a trigger. The first consideration, of course, is for which table the trigger should be defined. The trigger must be defined for the table that you want to monitor for inserts, updates, or deletes. Next, you must decide what the triggering event should be: <TT>INSERT</TT>, <TT>UPDATE</TT>, or <TT>DELETE</TT>.<A NAME="ch08index38"></A><A NAME="ch08index39"></A><A NAME="ch08index40"></A><A NAME="ch08index41"></A><A NAME="ch08index42"></A><A NAME="ch08index43"></A><A NAME="ch08index44"></A></P>
<P class="docText">The next decision is to determine when the trigger is to be activated—before or after the triggering activity occurs. Keep in mind that <TT>BEFORE</TT> triggers are activated before DB2 makes any changes to the triggering table and cannot activate other triggers. <TT>AFTER</TT> triggers are activated after DB2 makes changes to the triggering table and can potentially activate other triggers.<A NAME="ch08index45"></A><A NAME="ch08index46"></A><A NAME="ch08index47"></A><A NAME="ch08index48"></A></P>
<P class="docText">The granularity of the trigger must be determined. Because SQL is a set-level language, any single SQL statement can impact multiple rows of data. For example, one <TT>DELETE</TT> statement can actually cause zero, one, or many rows to be removed. You must take this into account as you build triggers.<A NAME="ch08index49"></A><A NAME="ch08index50"></A><A NAME="ch08index51"></A><A NAME="ch08index52"></A></P>
<P class="docText">Therefore, there are two levels of granularity that a trigger can have: statement-level or row-level. A statement-level trigger is executed once on firing, regardless of the actual number of rows inserted, deleted, or updated. A statement-level trigger is coded by specifying the <TT>FOR EACH STATEMENT</TT> clause. A row-level trigger, once fired, is executed once for each and every row that is inserted, deleted, or updated. A row-level trigger is coded by specifying the <TT>FOR EACH ROW</TT> clause. Different business requirements will drive what type of trigger granularity should be chosen.<A NAME="ch08index53"></A><A NAME="ch08index54"></A><A NAME="ch08index55"></A><A NAME="ch08index56"></A><A NAME="ch08index57"></A><A NAME="ch08index58"></A><A NAME="ch08index59"></A></P>
<A NAME="ch08note03"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Only <TT>AFTER</TT> triggers can be defined with the <TT>FOR EACH STATEMENT</TT> clause; both <TT>BEFORE</TT> and <TT>AFTER</TT> triggers can be defined with the <TT>FOR EACH ROW</TT> clause.</P></div><br>
<A NAME="ch08note04"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Performance problems can ensue when triggers are defined with the <TT>FOR EACH ROW</TT> clause. Consider the impact of issuing a mass delete against a table with a <TT>FOR EACH ROW</TT> trigger defined on it. A delete trigger would fire once for every row that is deleted.<A NAME="ch08index60"></A><A NAME="ch08index61"></A></P></div><br>
<P class="docText">For row-level triggers, you might need to refer to the values of columns in each updated row of the triggering table. To do this, you can use specialized transition variables that provide, in essence, before and after views of the changed data. Each trigger can have one <TT>NEW</TT> view of the table and one <TT>OLD</TT> view of the table available. These "views" are accessible only from triggers. They provide access to the modified data by viewing information in the transaction log.<A NAME="ch08index62"></A><A NAME="ch08index63"></A><A NAME="ch08index64"></A><A NAME="ch08index65"></A><A NAME="ch08index66"></A></P>
<P class="docText">The <TT>OLD</TT> transition variables contain the values of columns before the triggering SQL statement updates them. This information is particularly useful if you need to access the prior value of a column before a triggering <TT>UPDATE</TT> or <TT>DELETE</TT> statement. The <TT>NEW</TT> transition variables contain the values of columns after the triggering SQL statement updates them. You can define <TT>NEW</TT> transition variables for <TT>UPDATE</TT> and <TT>INSERT</TT> triggers.</P>
<P class="docText">Refer to <A class="docLink" HREF="#ch08fig01">Figure 8.1</A> for a graphic representation of the <TT>OLD</TT> and <TT>NEW</TT> transition variables. When an <TT>INSERT</TT> occurs, the <TT>NEW</TT> table contains the rows that were just inserted into the table to which the trigger is attached. When a <TT>DELETE</TT> occurs, the <TT>OLD</TT> table contains the rows that were just deleted from the table to which the trigger is attached. An <TT>UPDATE</TT> statement logically functions as a <TT>DELETE</TT> followed by an <TT>INSERT</TT>. Therefore, after an <TT>UPDATE</TT>, the <TT>NEW</TT> table contains the new values for the rows that were just updated in the table to which the trigger is attached; the <TT>OLD</TT> table contains the old values for the updated rows.<A NAME="ch08index67"></A><A NAME="ch08index68"></A><A NAME="ch08index69"></A></P>
<A NAME="ch08fig01"></A><p><CENTER><H5 class="docFigureTitle">Figure 8.1. Trigger transition variables: <TT>NEW</TT> and <TT>OLD</TT>.</H5>
<p class="docText"><IMG BORDER="0"  width="400" height="470" SRC="images/0672326132/graphics/08fig01.gif" ALT="graphics/08fig01.gif"></p></CENTER></p><br>
<P class="docText">You can also use transition tables to refer to the entire set of rows that a triggering SQL statement modifies, rather than individual rows.</P>
<P class="docText">Transition variables and transition tables are specified in the <TT>REFERENCING</TT> clause of the <TT>CREATE TRIGGER</TT> statement. Transition variables are defined using the <TT>OLD AS</TT> and <TT>NEW AS</TT> clauses; transition tables are defined using the <TT>OLD_TABLE AS</TT> and <TT>NEW_TABLE AS</TT> clauses.</P>
<P class="docText">Each trigger can include two correlation names, one for <TT>OLD</TT> and one for <TT>NEW</TT>, and two table names, one for the <TT>OLD_TABLE</TT> and one for the <TT>NEW_TABLE</TT>. Each of the correlation names must be unique from the others. <A class="docLink" HREF="#ch08table01">Table 8.1</A> outlines the transition variables that are permitted for each type of trigger. In the table N/A indicates not allowed.</P>
<A NAME="ch08table01"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 8.1. Permitted Trigger Transition Variables</h5></CAPTION><COLGROUP><COL width="110"><COL width="110"><COL width="110"><COL width="110"><COL width="110"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><span class="docEmphStrong">Activation Time</span></P></TH><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><span class="docEmphStrong">Triggering SQL</span></P></TH><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><span class="docEmphStrong">Granularity</span></P></TH><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><span class="docEmphStrong">Transition Variables</span></P></TH><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><span class="docEmphStrong">Transition Tables</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BEFORE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INSERT</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Row</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>NEW</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N/A</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>UPDATE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Row</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>OLD</TT>, <TT>NEW</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N/A</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DELETE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Row</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>OLD</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N/A</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>AFTER</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INSERT</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Row</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>NEW</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>NEW_TABLE</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Statement</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N/A</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>NEW_TABLE</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>UPDATE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Row</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>OLD</TT>, <TT>NEW</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>OLD_TABLE</TT>, <TT>NEW_TABLE</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Statement</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N/A</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>OLD_TABLE</TT>, <TT>NEW_TABLE</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DELETE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Row</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>OLD</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>OLD_TABLE</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Statement</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N/A</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>OLD_TABLE</TT>, <TT>NEW_TABLE</TT></P></TD></TR></TABLE></P><br>
<P class="docText">So, transition tables can be specified only for <TT>AFTER</TT> triggers. Similarly, transition variables are allowable only for triggers with row granularity (that is, triggers specifying <TT>FOR EACH ROW</TT>).<A NAME="ch08index70"></A><A NAME="ch08index71"></A><A NAME="ch08index72"></A><A NAME="ch08index73"></A><A NAME="ch08index74"></A><A NAME="ch08index75"></A><A NAME="ch08index76"></A><A NAME="ch08index77"></A></P>
<A NAME="ch08note05"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Keep in mind that the scope of the transition variables and transition tables is the triggered action. Do not refer to transition variables or transition tables outside of the trigger.</P></div><br>
<P class="docText">The final consideration is how to code the actual logic that is to be performed when the trigger fires. This logic is placed inside of a <TT>BEGIN</TT> and <TT>END</TT> grouping as follows:<A NAME="ch08index78"></A><A NAME="ch08index79"></A><A NAME="ch08index80"></A><A NAME="ch08index81"></A></P>
<pre>

</pre><BR><pre>
BEGIN ATOMIC
    <span class="docEmphasis">triggered-SQL-statements</span>
END
</pre><BR>
<P class="docText">Like any "program," the SQL statements are executed in the order they are specified. You must code the keywords <TT>BEGIN ATOMIC</TT> and <TT>END</TT> only if you code more than one SQL statement. Each SQL statement must end with a semicolon (<TT>;</TT>).</P>
<P class="docText">Only certain types of SQL can be issued from certain types of triggers. <A class="docLink" HREF="#ch08table02">Table 8.2</A> outlines the types of SQL statements that can be coded inside DB2 triggers.<A NAME="ch08index82"></A><A NAME="ch08index83"></A><A NAME="ch08index84"></A></P>
<A NAME="ch08table02"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 8.2. Allowable SQL Statements by Trigger Type</h5></CAPTION><COLGROUP><COL width="183.33333333333331"><COL width="183.33333333333331"><COL width="183.33333333333331"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><span class="docEmphStrong">Trigger Type SQL Statement</span></P></TH><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><TT>BEFORE</TT></P></TH><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><TT>AFTER</TT></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><span class="docEmphasis">fullselect</span></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Yes</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Yes</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CALL</TT> <span class="docEmphasis">stored procedure</span></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Yes</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Yes</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SIGNAL SQLSTATE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Yes</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Yes</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>VALUES</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Yes</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Yes</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SET</TT> <span class="docEmphasis">transition variable</span></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Yes</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">No</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INSERT</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">No</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Yes</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DELETE</TT> <span class="docEmphasis">(searched)</span></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">No</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Yes</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>UPDATE</TT> <span class="docEmphasis">(searched)</span></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">No</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Yes</P></TD></TR></TABLE></P><br>
<A NAME="ch08note06"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">SQL statements in triggers cannot refer to host variables, parameter markers, or undefined transition variables. The statements can refer only to tables and views at the current server.</P></div><br>
<A NAME="ch08lev3sec3"></A><H5 class="docSection3Title">The <TT>WHEN</TT> Clause</H5>
<P class="docText">The <TT>WHEN</TT> clause is used to control the conditions under which the trigger will fire. A search condition consists of one or more predicates. Search conditions for the <TT>WHEN</TT> clause are formulated just like search conditions in an SQL <TT>WHERE</TT> clause. A search condition always evaluates to true, false, or unknown. If a condition is coded into the <TT>WHEN</TT> clause the triggered SQL statements are executed only if the search condition evaluates to true.<A NAME="ch08index89"></A><A NAME="ch08index90"></A><A NAME="ch08index91"></A><A NAME="ch08index92"></A><A NAME="ch08index93"></A></P>
<P class="docText">The <TT>WHEN</TT> clause is optional. If the <TT>WHEN</TT> clause is omitted, the triggered action always is executed. However, if a trigger search condition is coded, the trigger will stop executing and return control to the <TT>INSERT</TT>, <TT>UPDATE</TT>, or <TT>DELETE</TT> that triggered it as soon as the condition is determined to be false. Of course, when the condition is true, the trigger body is executed. Consider specifying a trigger condition when the trigger must fire only for a subset of rows that apply. The more specific the condition, the higher the chances of improving trigger performance.</P>
<P class="docText">Now let's take a look at some sample triggers to see how these clauses can be used in <TT>CREATE TRIGGER</TT> statements.</P>
<A NAME="ch08lev3sec4"></A><H5 class="docSection3Title">Trigger Examples</H5>
<P class="docText">The following is an example of using the <TT>CREATE TRIGGER</TT> statement to create a very simple trigger:<A NAME="ch08index94"></A><A NAME="ch08index95"></A><A NAME="ch08index96"></A></P>
<pre>

</pre><BR><pre>
CREATE TRIGGER SALARY_UPDATE
   BEFORE UPDATE OF SALARY
   ON DSN8810.EMP
   FOR EACH ROW MODE DB2SQL
 WHEN (NEW.SALARY &gt; (OLD.SALARY * 1.5))
 BEGIN ATOMIC
   SIGNAL SQLSTATE '75001' ('Raise exceeds 50%');
 END;
</pre><BR>
<P class="docText">This statement creates an <TT>UPDATE</TT> trigger named <TT>SALARY_UPDATE</TT>. The trigger will fire before the actual <TT>UPDATE</TT> that fires it occurs. The trigger will execute for every row impacted by the <TT>UPDATE</TT>. If the new value for the <TT>SALARY</TT> column exceeds 50% of the old value, an error is raised giving an <TT>SQLSTATE</TT> code and message.</P>
<A NAME="ch08note07"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">This is a very simple trigger to impose a business rule on the database. It does not impact data in any other tables.</P></div><br>
<P class="docText">After the trigger has been created, it will automatically be fired any time the firing event (an <TT>UPDATE</TT> to the <TT>SALARY</TT> column in the <TT>EMP</TT> table) occurs.</P>
<P class="docText">When creating triggers, you can call stored procedures to deliver more trigger functionality. Consider the following trigger, for example:</P>
<pre>

</pre><BR><pre>
CREATE TRIGGER ORDER_STOCK
   AFTER UPDATE OF PRENDATE ON DSN8810.PROJ
   REFERENCING NEW AS NEW
   FOR EACH ROW MODE DB2SQL
WHEN (NEW.PRENDATE &lt; CURRENT DATE + 14 DAYS)
BEGIN ATOMIC
   CALL PROJCRIT(NEW.PROJNO);
END
</pre><BR>
<P class="docText">In this case, if the date the project is to end is modified to be within the next two weeks (14 days), call the <TT>PROJCRIT</TT> stored procedure to perform functionality required for critical projects. This can be as simple as creating a report for management, or as complex as modifying project status information in multiple tables (or, really, whatever you can do within a stored procedure).<A NAME="ch08index97"></A><A NAME="ch08index98"></A><A NAME="ch08index99"></A></P>
<P class="docText">The following is another example of creating a trigger, this time an <TT>INSERT</TT> trigger:</P>
<pre>

</pre><BR><pre>
CREATE TRIGGER TOT_COMP
   AFTER UPDATE OF SALARY, BONUS, COMM ON DSN8810.EMP
   REFERENCING NEW AS INSERTED, OLD AS DELETED
   FOR EACH ROW MODE DB2SQL
WHEN (INSERTED.SALARY &lt;&gt; DELETED.SALARY OR
      INSERTED.BONUS &lt;&gt; DELETED.BONUS OR
      INSERTED.COMM &lt;&gt; DELETED.COMM)
  BEGIN ATOMIC
    UPDATE EMP_SALARY
      SET TOT_COMP = INSERTED.SALARY + INSERTED.BONUS + INSERTED.COMM
    WHERE EMP_SALARY.EMPNO = INSERTED.EMPNO;
  END
</pre><BR>
<P class="docText">This trigger is used to check for changes to the components of an employee's total compensation. The trigger keeps derived data in synch with its components. In this case, whenever <TT>SALARY</TT>, <TT>BONUS</TT>, or <TT>COMM</TT> are changed in the <TT>EMP</TT> table, a table named <TT>EMP_SALARY</TT> has its <TT>TOT_COMP</TT> column modified to be the new sum of salary, bonus, and commission information. Triggers can be used in this manner to maintain data integrity across tables when derived data is stored physically. Whenever any value in the three components of total compensation changes, the trigger automatically calculates a new <TT>TOT_COMP</TT> and updates it in the table.<A NAME="ch08index100"></A><A NAME="ch08index101"></A><A NAME="ch08index102"></A></P>
<A NAME="ch08lev2sec6"></A><H4 class="docSection2Title">Trigger Packages</H4>
<P class="docText">When a trigger is created, DB2 creates a trigger package for the statements in the triggered action. The trigger package is recorded in <TT>SYSIBM.SYSPACKAGE</TT> and has the same name as the trigger. The trigger package is always accessible and can be executed only when a trigger is activated by a triggering operation.<A NAME="ch08index103"></A><A NAME="ch08index104"></A></P>
<P class="docText">Trigger packages do not follow the same rules as regular DB2 packages. For example, it is not possible to maintain multiple versions of a trigger package. Additionally, the user executing the triggering SQL operation does not need to have the authority to execute the trigger package. Furthermore, the trigger package does not need to be in the package list for the plan that is associated with the program that contains the SQL statement.</P>
<P class="docText">The only way to delete the trigger package is to use the <TT>DROP TRIGGER</TT> statement. Of course, if you issue a <TT>DROP TABLE</TT> and the table has a trigger, the trigger will be dropped, too.<A NAME="ch08index105"></A></P>
<P class="docText">The trigger package is implicitly bound when the trigger is created. When the trigger package is implicitly bound by DB2, it will use the following <TT>BIND</TT> attributes:</P>
<BLOCKQUOTE><P><P class="docList"><TT>ACTION(ADD)</TT></P></P><P><P class="docList"><TT>CURRENTDATA(YES)</TT></P></P><P><P class="docList"><TT>DBPROTOCOL(DRDA)</TT></P></P><P><P class="docList"><TT>DEGREE(1)</TT></P></P><P><P class="docList"><TT>DYNAMICRULES(BIND)</TT></P></P><P><P class="docList"><TT>ENABLE(*)</TT></P></P><P><P class="docList"><TT>EXPLAIN(NO)</TT></P></P><P><P class="docList"><TT>FLAG(I)</TT></P></P><P><P class="docList"><TT>ISOLATION(CS)</TT></P></P><P><P class="docList"><TT>NOREOPT(VARS)</TT></P></P><P><P class="docList"><TT>NODEFER(PREPARE)</TT></P></P><P><P class="docList"><TT>OWNER(</TT><span class="docEmphasis"><TT>authid</TT></span><TT>)</TT></P></P><P><P class="docList"><TT>QUERYOPT(1)</TT></P></P><P><P class="docList"><TT>PATH(</TT><span class="docEmphasis"><TT>path</TT></span><TT>)</TT></P></P><P><P class="docList"><TT>RELEASE(COMMIT)</TT></P></P><P><P class="docList"><TT>SQLERROR(NOPACKAGE)</TT></P></P><P><P class="docList"><TT>QUALIFIER(</TT><span class="docEmphasis"><TT>authid</TT></span><TT>)</TT></P></P><P><P class="docList"><TT>VALIDATE(BIND)</TT></P></P></BLOCKQUOTE>
<P class="docText">Of course, you can <TT>REBIND</TT> the trigger package once it is created. In many instances you will want to do this to change the default options. By rebinding the trigger package right after it is created you can specify <TT>EXPLAIN(YES)</TT> or <TT>CURRENTDATA(NO)</TT>, for example. Be sure to use <TT>REBIND</TT> to ensure you are using the <TT>BIND</TT> options that you choose—instead of the default options foisted on you by DB2.<A NAME="ch08index106"></A><A NAME="ch08index107"></A></P>
<A NAME="ch08lev2sec7"></A><H4 class="docSection2Title">Triggers Can Fire Other Triggers</H4>
<P class="docText">As we've already learned, a trigger is fired by an <TT>INSERT</TT>, <TT>UPDATE</TT>, or <TT>DELETE</TT> statement. However, a trigger can also contain <TT>INSERT</TT>, <TT>UPDATE</TT>, or <TT>DELETE</TT> logic within itself. Therefore, a trigger is fired by a data modification, but can also cause another data modification, thereby firing yet another trigger. When a trigger contains <TT>INSERT</TT>, <TT>UPDATE</TT>, and/or <TT>DELETE</TT> logic, the trigger is said to be a <span class="docEmphasis">nested trigger</span>.<A NAME="ch08index108"></A><A NAME="ch08index109"></A></P>
<P class="docText">DB2 places a limit on the number of nested triggers that can be executed within a single firing event. If this were not done, it could be quite possible to have triggers firing triggers ad infinitum until all of the data was removed from an entire database.</P>
<P class="docText">If referential integrity is combined with triggers, additional cascading updates and/or deletes can occur. If a <TT>DELETE</TT> or <TT>UPDATE</TT> results in a series of additional <TT>UPDATE</TT>s or <TT>DELETE</TT>s that need to be propagated to other tables, the <TT>UPDATE</TT> or <TT>DELETE</TT> triggers for the second table also will be activated.</P>
<P class="docText">This combination of multiple triggers and referential integrity constraints are capable of setting a cascading effect into motion, which can result in multiple data changes. DB2 limits this cascading effect to 16 levels to prevent endless looping. If more than 16 levels of nesting occur, the transaction is aborted.</P>
<P class="docText">The ability to nest triggers provides an efficient method for implementing automatic data integrity. Because triggers generally cannot be bypassed, they provide an elegant solution to the enforced application of business rules and data integrity.<A NAME="ch08index110"></A><A NAME="ch08index111"></A></P>
<A NAME="ch08note08"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Use caution to ensure that the maximum trigger nesting level is not reached. Failure to heed this advice can cause an environment where certain types of data modification cannot occur because the number of nested calls will always be exceeded.</P></div><br>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch08.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch08lev1sec2.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
