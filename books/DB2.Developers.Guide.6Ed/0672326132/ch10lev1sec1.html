<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Granting and Revoking Privileges</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch10.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="part02.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch10lev1sec1"></A><H3 class="docSection1Title" >Granting and Revoking Privileges</H3>
<P class="docText">The capability to access and modify DB2 objects and resources is authorized with SQL <TT>GRANT</TT> statements and removed with SQL <TT>REVOKE</TT> statements. The complete security picture, however, is not this simple.</P>
<P class="docText">Many features of DB2 security can complicate security administration, such as<A NAME="ch10index01"></A><A NAME="ch10index02"></A></P>
<UL><LI><P class="docList">The cascading effect of the DB2 <TT>REVOKE</TT> statement</P></LI><LI><P class="docList">Secondary authorization IDs</P></LI><LI><P class="docList"><TT>PUBLIC</TT> access</P></LI><LI><P class="docList">Use of dynamic SQL</P></LI></UL>
<P class="docText">To enable authorization, the <TT>GRANT</TT> statement is used to bestow privileges on authids. There are ten different classes of privileges that can be granted:<A NAME="ch10index03"></A><A NAME="ch10index04"></A><A NAME="ch10index05"></A><A NAME="ch10index06"></A><A NAME="ch10index07"></A></P>
<UL><LI><p class="docText">
<TT>COLLECTION</TT>— 
To <TT>GRANT</TT> the ability to <TT>BIND</TT> packages into specified collections or to <TT>GRANT PACKADM</TT> authority for specified collections<A NAME="ch10index08"></A><A NAME="ch10index09"></A></p></LI><LI><p class="docText">
<TT>DATABASE</TT>— 
To <TT>GRANT</TT> database-related privileges such as <TT>DBADM</TT>, <TT>DBCTRL</TT>, <TT>DBMAINT</TT>, or the ability to <TT>CREATE</TT> or <TT>DROP</TT> objects, display, start and stop objects, or execute utilities for specified databases<A NAME="ch10index10"></A><A NAME="ch10index11"></A></p></LI><LI><p class="docText">
<TT>DISTINCT TYPE</TT> <span class="docEmphRoman">or</span> <TT>JAR</TT>— 
To <TT>GRANT</TT> the ability to use user-defined distinct types (UDTs) or a Java Archive File (JAR)<A NAME="ch10index12"></A><A NAME="ch10index13"></A></p></LI><LI><p class="docText">
<TT>FUNCTION</TT> <span class="docEmphRoman">or</span> <TT>STORED PROCEDURE</TT>— 
To <TT>GRANT</TT> the ability to execute specified functions and stored procedures<A NAME="ch10index14"></A><A NAME="ch10index15"></A></p></LI><LI><p class="docText">
<TT>PACKAGE</TT>— 
To <TT>GRANT</TT> the ability to <TT>BIND</TT> and <TT>REBIND</TT> specified packages, to use the <TT>COPY</TT> option of <TT>BIND</TT> for specified packages, or to run application programs that use specified packages<A NAME="ch10index16"></A><A NAME="ch10index17"></A></p></LI><LI><p class="docText">
<TT>PLAN</TT>— 
To <TT>GRANT</TT> the ability to <TT>BIND</TT>, <TT>REBIND</TT>, <TT>FREE</TT>, or <TT>EXECUTE</TT> specified plans<A NAME="ch10index18"></A><A NAME="ch10index19"></A></p></LI><LI><p class="docText">
<TT>SCHEMA</TT>— 
To <TT>GRANT</TT> the ability to <TT>ALTER</TT>, <TT>CREATE</TT>, or <TT>DROP</TT> user-defined distinct types, user-defined functions, stored procedures, and triggers in the specified schema or schemata<A NAME="ch10index20"></A><A NAME="ch10index21"></A></p></LI><LI><p class="docText">
<TT>SYSTEM</TT>— 
To <TT>GRANT</TT> system management-related abilities including <TT>ARCHIVE</TT>, <TT>BINDADD</TT>, <TT>BINDAGENT</TT>, <TT>BSDS</TT>, <TT>CREATEALIAS</TT>, <TT>CREATEDBA</TT>, <TT>CREATEDBC</TT>, <TT>CREATESG</TT>, <TT>CREATETMTAB</TT>, <TT>DISPLAY</TT>, <TT>MONITOR1</TT>, <TT>MONITOR2</TT>, <TT>RECOVER</TT>, <TT>STOPALL</TT>, <TT>STOSPACE</TT>, <TT>SYSADM</TT>, <TT>SYSCTRL</TT>, <TT>SYSOPR</TT>, and <TT>TRACE</TT><A NAME="ch10index22"></A><A NAME="ch10index23"></A></p></LI><LI><p class="docText">
<TT>TABLE</TT> <span class="docEmphRoman">or</span> <TT>VIEW</TT>— 
To <TT>GRANT</TT> the ability to <TT>ALTER</TT>, <TT>CREATE</TT> or <TT>DROP</TT> triggers, indexes, and referential constraints, or to <TT>SELECT</TT>, <TT>INSERT</TT>, <TT>UPDATE</TT>, and <TT>DELETE</TT> data from the specified views or tables<A NAME="ch10index24"></A><A NAME="ch10index25"></A><A NAME="ch10index26"></A><A NAME="ch10index27"></A></p></LI><LI><p class="docText">
<TT>USE</TT>— 
To <TT>GRANT</TT> the ability to use and create objects in specific bufferpools, storage groups, table spaces, and sequences<A NAME="ch10index28"></A><A NAME="ch10index29"></A><A NAME="ch10index30"></A><A NAME="ch10index31"></A><A NAME="ch10index32"></A><A NAME="ch10index33"></A><A NAME="ch10index34"></A></p></LI></UL>
<P class="docText">Likewise, there are ten different classes of <TT>REVOKE</TT> statements that can be issued—one for each class of <TT>GRANT</TT> that can be issued. As might be expected, the <TT>REVOKE</TT> statement removes authority from authids.<A NAME="ch10index35"></A><A NAME="ch10index36"></A><A NAME="ch10index37"></A><A NAME="ch10index38"></A><A NAME="ch10index39"></A></P>
<A NAME="ch10lev2sec1"></A><H4 class="docSection2Title">Authorization Guidelines</H4>
<P class="docText">Guidelines for using <TT>GRANT</TT> and <TT>REVOKE</TT> to properly implement DB2 security are addressed in this section on <A class="docLink" HREF="#ch10lev2sec1">authorization guidelines</A>.</P>
<A NAME="ch10lev4sec1"></A><H5 class="docSection3Title">Use Care When Granting <TT>PUBLIC</TT> Access</H5>
<P class="docText">Administering security can be a complex duty. Simply allowing blanket access to certain DB2 objects and resources often appears easier. The <TT>PUBLIC</TT> authority of DB2 gives the security administrator this option, but it is usually an unwise choice.<A NAME="ch10index40"></A><A NAME="ch10index41"></A><A NAME="ch10index42"></A><A NAME="ch10index43"></A><A NAME="ch10index44"></A></P>
<P class="docText">For example, when many shops install DB2, they grant <TT>PUBLIC</TT> access to the default database, <TT>DSNDB04</TT>. Inevitably, users assign table spaces to this database. Because the table spaces are in a default area, they are difficult to monitor and control. The area quickly becomes overused. The DBA unit is unaware of some tables that exist. If an error occurs, recovery might be impossible. Additionally, the only way to move a table space to a different database is by dropping the table space and redefining it, specifying another database name.</P>
<P class="docText">The only valid uses for <TT>PUBLIC</TT> access are for objects and resources that should be available to everyone who has access to the DB2 subsystem or if another security mechanism is in place. An example of the first use is granting the <TT>BINDADD</TT> privilege to <TT>PUBLIC</TT> in a test environment to allow all DB2 programmers to create DB2 application plans and packages. An example of the second use is granting <TT>EXECUTE</TT> authority for CICS transactions to <TT>PUBLIC</TT> and using CICS transaction security to control access. Other exceptions to avoiding <TT>PUBLIC</TT> access follow.</P>
<P class="docText">In some installations, the security is thought to be adequately provided by application programs, so <TT>PUBLIC</TT> access is implemented for objects. Implementing this access is unwise unless ad hoc access to these objects is forbidden. If ad hoc use is allowed, users have access to the data through <TT>SPUFI</TT> or QMF, and could corrupt the data. In general, you should grant <TT>PUBLIC</TT> access only as a last resort. Even when ad hoc access is forbidden, objects granted <TT>PUBLIC</TT> access can be accessed by hackers or other folks who "bend the rules."<A NAME="ch10index45"></A><A NAME="ch10index46"></A><A NAME="ch10index47"></A><A NAME="ch10index48"></A><A NAME="ch10index49"></A></P>
<A NAME="ch10lev4sec2"></A><H5 class="docSection3Title">Grant <TT>SELECT</TT> Authority on <TT>SYSIBM.SYSDUMMY1</TT> to <TT>PUBLIC</TT></H5>
<P class="docText">Be sure to grant <TT>SELECT</TT> authority to <TT>PUBLIC</TT> for the <TT>SYSIBM.SYSDUMMY1</TT> table. <TT>SYSIBM.SYSDUMMY1</TT> contains a single row. It is designed to be used with SQL statements in which a table reference is needed but the table contents are unimportant.<A NAME="ch10index50"></A><A NAME="ch10index51"></A><A NAME="ch10index52"></A><A NAME="ch10index53"></A><A NAME="ch10index54"></A><A NAME="ch10index55"></A><A NAME="ch10index56"></A><A NAME="ch10index57"></A></P>
<A NAME="ch10lev4sec3"></A><H5 class="docSection3Title">Grant <TT>DISPLAY</TT> Authority to <TT>PUBLIC</TT></H5>
<P class="docText">Consider granting <TT>DISPLAY</TT> authority for each DB2 subsystem to <TT>PUBLIC</TT>. <TT>PUBLIC DISPLAY</TT> authority will not pose a security threat, but can improve productivity. Application developers can use <TT>DISPLAY</TT> to identify active programs and utilities affecting performance without requiring DBA assistance.<A NAME="ch10index58"></A><A NAME="ch10index59"></A><A NAME="ch10index60"></A><A NAME="ch10index61"></A><A NAME="ch10index62"></A></P>
<A NAME="ch10lev4sec4"></A><H5 class="docSection3Title">Do Not Repeat Security Grants</H5>
<P class="docText">DB2 allows authorization to be granted multiple times to the same grantee for the same object or resource. As of DB2 V3, duplicate grants from the same grantor are not recorded in the DB2 Catalog. However, if the grants are from different grantors, duplicate authorizations still can occur. You should avoid duplicate authorizations because they cause confusion and clutter the DB2 Catalog with useless entries.<A NAME="ch10index63"></A><A NAME="ch10index64"></A><A NAME="ch10index65"></A></P>
<P class="docText">Duplicate authority is recorded in the DB2 Catalog most commonly when SQL <TT>GRANT</TT> statements have been coded in a common <TT>CLIST</TT>, <TT>REXX EXEC</TT>, or standard job. An example is a <TT>CLIST</TT> used by application programmers to <TT>BIND</TT> a plan and then <TT>GRANT EXECUTE</TT> authority to a list of users automatically. You should not use this method because it can lead to duplicate authorization entries in the DB2 Catalog.</P>
<A NAME="ch10lev4sec5"></A><H5 class="docSection3Title">Consolidate Security Grants</H5>
<P class="docText"><TT>SELECT</TT>, <TT>INSERT</TT>, <TT>UPDATE</TT>, and <TT>DELETE</TT> authority should be granted using a single <TT>GRANT</TT> statement, instead of two to four separate statements. If one statement is used, one catalog row is created, instead of multiple rows (one for each <TT>GRANT</TT> statement that is issued).<A NAME="ch10index66"></A><A NAME="ch10index67"></A><A NAME="ch10index68"></A></P>
<A NAME="ch10lev4sec6"></A><H5 class="docSection3Title">Do Not <TT>GRANT</TT> More Security Than Necessary</H5>
<P class="docText">Secure your DB2 application environment. Using group-level authority (for example, <TT>SYSADM</TT> or <TT>SYSOPR</TT>) is tempting because coding and maintaining it is easier. Group authorities, however, often provide more security than is required. <TT>SYSADM</TT> authority is the most powerful level of authorization provided by DB2 and should be reserved only for those DBAs and system programmers who need the authority and know how to use it wisely.<A NAME="ch10index69"></A><A NAME="ch10index70"></A><A NAME="ch10index71"></A><A NAME="ch10index72"></A></P>
<P class="docText">If system-development staff members are allowed to access and modify table data but are not allowed to create indexes and tables, do not grant them <TT>DBADM</TT> authority. Simply grant them the appropriate authority for the appropriate tables—in this case, <TT>SELECT</TT>, <TT>UPDATE</TT>, <TT>INSERT</TT>, and <TT>DELETE</TT>.</P>
<A NAME="ch10lev4sec7"></A><H5 class="docSection3Title">Plan DCL When Issuing DDL</H5>
<P class="docText">Remember that when DB2 objects are dropped, the security for the objects is dropped as well. If you plan to drop and re-create a database, for example, be prepared to re-create the security for the database and all subordinate objects (such as table spaces, tables, views, and indexes).<A NAME="ch10index73"></A><A NAME="ch10index74"></A></P>
<P class="docText">Remember also that when plans are freed, all security is removed for the freed plans. Take this fact into account before freeing plans that you might need later.</P>
<A NAME="ch10lev4sec8"></A><H5 class="docSection3Title">Be Aware of DB2's Built-in Security Groupings</H5>
<P class="docText">DB2 provides several built-in groupings of authorization that can be assigned to users. When a user is granted one of the group-level authorities, all of the security that applies to the group will then apply to the user. <A class="docLink" HREF="ch01lev1sec2.html#ch01fig05">Figure 1.5</A> in <A class="docLink" HREF="ch01.html#ch01">Chapter 1</A>, "The Magic Words," outlines the DB2 security levels; refer to it now if you need to refresh your memory.<A NAME="ch10index75"></A><A NAME="ch10index76"></A><A NAME="ch10index77"></A></P>
<P class="docText">In general, these group-level authorizations should be used for system users, such as DBAs, systems programmers, and operators. The authorization contained within these groups is useful for administrative users, but not for end users and developers.</P>
<A NAME="ch10lev4sec9"></A><H5 class="docSection3Title">Use Group-Level Security and Secondary Authids</H5>
<P class="docText">When possible, use group-level security (for example, <TT>DBADM</TT> and <TT>DBCTRL</TT>) and secondary authids to reduce administrative tasks. Do not use group-level security, however, if the group will provide unwanted authority to users.<A NAME="ch10index78"></A><A NAME="ch10index79"></A><A NAME="ch10index80"></A><A NAME="ch10index81"></A><A NAME="ch10index82"></A><A NAME="ch10index83"></A><A NAME="ch10index84"></A></P>
<P class="docText">An alternative authorization ID is provided when you use the secondary authid extension, a useful timesaving feature of DB2 security. Each primary authid can have secondary authids associated with it. You can create these associations by using an external security package such as RACF or a hard-coded table of IDs. You can then grant security to a secondary authid assigned to a functional group of users.</P>
<P class="docText">For example, if all users in the finance department have been assigned a secondary authid of <TT>FINANCE</TT>, you can provide them with blanket query access by granting the <TT>SELECT</TT> authority to <TT>FINANCE</TT> for all financial tables. No additional security at the primary authid level is necessary when personnel leave or are hired. This feature eases the administrative burden of security allocation.</P>
<P class="docText">Additionally, secondary authids can reduce the workload of the DBA staff by offloading authorization tasks to the corporate security group. Security administration groups typically can support adding and deleting authids from a RACF group, but are not usually capable of issuing appropriate DB2 DCL statements.</P>
<A NAME="ch10lev4sec10"></A><H5 class="docSection3Title">Create DB2 Objects Using a Secondary Authid</H5>
<P class="docText">When objects are created, implicit authority is automatically granted to the object owner. By using secondary authids when creating DB2 objects, administrative burden can be reduced. This is important when DBAs do not have <TT>SYSADM</TT> authority or when the DBA staff changes. If a secondary authid is not used as the object owner, it might be necessary to drop and re-create entire object structures to revoke implicit authorization.<A NAME="ch10index85"></A><A NAME="ch10index86"></A><A NAME="ch10index87"></A><A NAME="ch10index88"></A></P>
<A NAME="ch10lev4sec11"></A><H5 class="docSection3Title">Use External Security with Caution</H5>
<P class="docText">DB2 provides the ability to replace its internal security mechanism with an external security package, such as RACF. When doing this, all security to DB2 objects is handled outside of DB2 instead of inside of DB2. The advantage of this approach is the ability to offload DB2 security administration from the DBA staff to in-house security experts.<A NAME="ch10index89"></A><A NAME="ch10index90"></A><A NAME="ch10index91"></A></P>
<P class="docText">To determine who has the ability to access DB2 objects, DBAs will need to access the external security package instead of querying DB2 Catalog tables. Before replacing DB2 security with an external security package, be sure that your policies and procedures are changed to enable DB2 DBAs to, at least, review the authorizations as managed in the external security package.</P>
<P class="docText">Furthermore, be sure that any third-party DB2 products and applications used by your shop can operate without requiring DB2 authority to be stored in the DB2 Catalog.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> Of course, if you need to setup multilevel security (MLS) then you will need to use RACF with DB2. More information on MLS follows later in this chapter.<A NAME="ch10index92"></A><A NAME="ch10index93"></A><A NAME="ch10index94"></A></P></td></tr></table><br>
<A NAME="ch10lev4sec12"></A><H5 class="docSection3Title">Restrict <TT>SYSADM</TT> Authority</H5>
<P class="docText"><TT>SYSADM</TT> is a powerful group authority that you should use sparingly. You should restrict its use to the corporate DBA function and the appropriate system programming support staff. End users, managers, and application development personnel should never need <TT>SYSADM</TT> authority. In general, no more than a half dozen technical support personnel should have <TT>SYSADM</TT> authority.<A NAME="ch10index95"></A><A NAME="ch10index96"></A><A NAME="ch10index97"></A><A NAME="ch10index98"></A></P>
<A NAME="ch10lev4sec13"></A><H5 class="docSection3Title">Use <TT>SYSCTRL</TT> for Additional Control</H5>
<P class="docText">You can limit <TT>SYSADM</TT> authority even further by granting <TT>SYSCTRL</TT> instead of <TT>SYSADM</TT> to database administration and technical support personnel who play a backup role. <TT>SYSCTRL</TT> gives the same authority as <TT>SYSADM</TT> without access to data in application tables that were not created by the <TT>SYSCTRL</TT> user. End users, managers, and application development personnel should never be granted <TT>SYSCTRL</TT> authority.<A NAME="ch10index99"></A><A NAME="ch10index100"></A><A NAME="ch10index101"></A><A NAME="ch10index102"></A></P>
<P class="docText"><TT>SYSCTRL</TT> authority is one of the most misunderstood security features of DB2. It cannot be used to completely ensure that the <TT>SYSCTRL</TT> user will never have access to end-user data. A primary objective of the <TT>SYSCTRL</TT> authority is to enable a user—who has no general requirement to manipulate table data—to administer a DB2 environment. In essence, you can think of <TT>SYSCTRL</TT> as <TT>SYSADM</TT> without explicit DB2 data authority.</P>
<P class="docText">Basically, <TT>SYSCTRL</TT> authority implies that the user can exercise <TT>DBCTRL</TT> authority over tables in any database. However, <TT>CREATEDBA</TT> authority is also implicit under <TT>SYSCTRL</TT>. Therefore, the <TT>SYSCTRL</TT> user can create databases and obtain <TT>DBADM</TT> authority over them, which enables the <TT>SYSCTRL</TT> user to access and modify the data in any table within that database.</P>
<P class="docText">To get around this problem, you should implement procedures or standards to ensure that the <TT>SYSCTRL</TT> user never creates databases. You must do so manually because there is no systematic way of prohibiting <TT>SYSCTRL</TT> from creating databases. Assign the database creation function to a <TT>SYSADM</TT> user. After the database is created by another user, the <TT>SYSCTRL</TT> user can administer the database without accessing the data. As long as the <TT>SYSCTRL</TT> user has not created the database in question and has not been granted any other authority (that is, <TT>SELECT</TT>, <TT>DBADM</TT>, and so on), he or she cannot access the data in user tables.</P>
<A NAME="ch10lev4sec14"></A><H5 class="docSection3Title">Use <TT>BINDAGENT</TT> for Package and Plan Administration</H5>
<P class="docText">Use the <TT>BINDAGENT</TT> authority to permit the binding of plans and packages without the ability to execute them. <TT>BINDAGENT</TT> authority is sometimes called "assigning" authority. <TT>BINDAGENT</TT> authority enables one user to assign another user the capability of performing tasks (in this case, plan and package binding) on his or her behalf.<A NAME="ch10index103"></A><A NAME="ch10index104"></A><A NAME="ch10index105"></A><A NAME="ch10index106"></A></P>
<P class="docText">A centralized area in your organization should be responsible for binding production plans and packages. This area can be granted the <TT>BINDAGENT</TT> authority from all production plan and package owners. This approach is preferable to granting <TT>SYSADM</TT> or <TT>SYSCTRL</TT> because only bind operations are enabled when you grant <TT>BINDAGENT</TT>. <TT>BINDAGENT</TT> provides all the authority necessary to administer the bind function effectively.</P>
<A NAME="ch10lev4sec15"></A><H5 class="docSection3Title">Bind Plans from a Restricted Userid</H5>
<P class="docText">You can acquire a greater level of control over the bind function by using a restricted userid for all production binding. This userid should have no logon capability so that the only access to the userid is through a batch job, not online access. You can provide external security with RACF (or any other security tool) to prohibit the unauthorized use of this userid.<A NAME="ch10index107"></A><A NAME="ch10index108"></A><A NAME="ch10index109"></A><A NAME="ch10index110"></A></P>
<P class="docText">Batch jobs that bind the application plans and packages as necessary should be created. The restricted userid should have <TT>BINDAGENT</TT> authority to allow successful binding with the <TT>OWNER</TT> parameter. The batch jobs are then submitted with the restricted userid by the group in your organization responsible for binding. This solution permits multiple authorized individuals to submit batch binds from the same userid. This solution also can ease the administrative burden associated with plan and package ownership, the attrition of binding agent personnel, and plan monitoring.</P>
<P class="docText">This scenario might not be feasible if your data security standards prohibit restricted userids. Some data security shops think that restricted userids have a propensity to fall into unauthorized hands. If this situation cannot be prevented, restricted userids for binding might not be appropriate for your shop.</P>
<A NAME="ch10lev4sec16"></A><H5 class="docSection3Title">Do Not Issue DCL from Application Programs</H5>
<P class="docText">Avoid issuing <TT>GRANT</TT> and <TT>REVOKE</TT> statements from an application program. Security is granted ideally by an agent who understands the authorization needs of the organization.<A NAME="ch10index111"></A><A NAME="ch10index112"></A><A NAME="ch10index113"></A></P>
<P class="docText">Although you can set up a parameter-driven program to administer security, you generally cannot automate the task completely. Also, your program must avoid granting duplicate privileges, which is allowed by DB2. Otherwise, many duplicate privileges could be granted for your system, impeding overall system performance.</P>
<P class="docText">Additionally, an application program that grants security must be executed by a user who has the appropriate security to issue the grants and revokes coded in the application program. This could be a loophole in the security structure.</P>
<P class="docText">Finally, a program that issues <TT>REVOKE</TT> and <TT>GRANT</TT> statements can have a great impact on the overall scheme of your operating environment. Consider the following problems that can be caused by a program issuing DCL:</P>
<UL><LI><P class="docList">The program tries to <TT>REVOKE</TT> a privilege from a user who is currently executing a transaction that would no longer be valid after the <TT>REVOKE</TT>.</P></LI><LI><P class="docList">The program <TT>REVOKE</TT>s a privilege, causing numerous cascading <TT>REVOKE</TT>s that are difficult to trace after invocation. After the program is finished, the potential for many missing authorizations exists. This situation can wreak havoc on a production DB2 subsystem.</P></LI><LI><P class="docList">What should the <TT>COMMIT</TT> and <TT>ROLLBACK</TT> structure of the program be? If the program abends, should all security be committed or rolled back and reapplied? The answer to these questions may not be immediately obvious in the absence of in-depth system documentation. It is better to avoid these types of questions by mandating that all DCL be issued by skilled technicians that understand the ramifications of each <TT>GRANT</TT> and <TT>REVOKE</TT> statement.<A NAME="ch10index114"></A><A NAME="ch10index115"></A><A NAME="ch10index116"></A></P></LI></UL>
<A NAME="ch10lev4sec17"></A><H5 class="docSection3Title">Be Careful When Granting Access to a Synonym</H5>
<P class="docText">Avoid granting others access to a synonym. A synonym, by definition, can be used only by its creator. Granting access to a synonym grants access to the underlying base table for which the synonym was created.<A NAME="ch10index117"></A><A NAME="ch10index118"></A><A NAME="ch10index119"></A></P>
<P class="docText">For example, consider a synonym called <TT>USER1.DEPARTMENT</TT> for the <TT>DSN8810.DEPT</TT> table. If <TT>USER1</TT> wants to grant <TT>USER2</TT> the authority to query this synonym, <TT>USER1</TT> could code the following:</P>
<pre>

</pre><BR><pre>
GRANT SELECT
   ON TABLE USER1.DEPARTMENT
   TO USER2;
</pre><BR>
<P class="docText">In this case, <TT>USER2</TT> now has <TT>SELECT</TT> authority on the <TT>DSN8810.DEPT</TT> table, not on the synonym created by <TT>USER1</TT>. Because this situation can be confusing, you should avoid granting access to synonyms.</P>
<A NAME="ch10lev4sec18"></A><H5 class="docSection3Title">Be Aware of Automatic Security</H5>
<P class="docText">When you create a DB2 object, DB2 automatically grants you full security to<A NAME="ch10index120"></A><A NAME="ch10index121"></A><A NAME="ch10index122"></A></P>
<UL><LI><P class="docList">Use the object in any way.</P></LI><LI><P class="docList">Grant others the use of the object.</P></LI></UL>
<P class="docText">If users need access to an object they did not create, they must get the creator, a <TT>SYSADM</TT>, a <TT>SYSCTRL</TT>, or someone else with the proper authority to grant them access. Additionally, the only way to change implicit authority is to drop the object and re-create it (and all dependent objects).</P>
<A NAME="ch10lev4sec19"></A><H5 class="docSection3Title">Be Aware of Package and Plan Authorization Differences</H5>
<P class="docText">A user with the <TT>BIND</TT> privilege on a plan can free that plan, but a user with the <TT>BIND</TT> privilege on a package cannot free that package. To free a package, the user must meet one of the following conditions:<A NAME="ch10index123"></A><A NAME="ch10index124"></A><A NAME="ch10index125"></A><A NAME="ch10index126"></A><A NAME="ch10index127"></A><A NAME="ch10index128"></A></P>
<UL><LI><P class="docList">Be the owner of the package.</P></LI><LI><P class="docList">Have <TT>SYSADM</TT> or <TT>SYSCTRL</TT> authority.</P></LI><LI><P class="docList">Have <TT>BINDAGENT</TT> privilege granted by the package owner.</P></LI></UL>
<A NAME="ch10lev4sec20"></A><H5 class="docSection3Title">Avoid <TT>WITH GRANT OPTION</TT></H5>
<P class="docText">Be careful with the multilevel security of DB2. When a privilege is granted to a user using <TT>WITH GRANT OPTION</TT>, the user can also grant that privilege. This capability can create an administrative nightmare for DB2 security agents. Consider the following scenario:<A NAME="ch10index129"></A><A NAME="ch10index130"></A><A NAME="ch10index131"></A></P>
<div style="font-weight:bold"><OL class="docList" TYPE="1"><LI><div style="font-weight:normal"><P class="docList"><TT>SYSADM</TT> grants a privilege to <TT>USER1</TT> with the grant option.</P></div></LI><LI><div style="font-weight:normal"><P class="docList"><TT>USER1</TT> grants this privilege to <TT>USER2</TT> without the grant option.</P></div></LI><LI><div style="font-weight:normal"><P class="docList"><TT>USER1</TT> grants this privilege to <TT>USER3</TT> with the grant option.</P></div></LI><LI><div style="font-weight:normal"><P class="docList"><TT>SYSADM</TT> grants this privilege to <TT>USER5</TT> with the grant option.</P></div></LI><LI><div style="font-weight:normal"><P class="docList"><TT>USER5</TT> grants this privilege to <TT>PUBLIC</TT>.</P></div></LI><LI><div style="font-weight:normal"><P class="docList"><TT>USER3</TT> grants this privilege to <TT>USER9</TT>.</P></div></LI><LI><div style="font-weight:normal"><P class="docList"><TT>SYSADM</TT> revokes the privilege from <TT>USER1</TT>.</P></div></LI></OL></div>
<P class="docText">Who has this privilege now? When <TT>SYSADM</TT> revokes the privilege from <TT>USER1</TT>, DB2 cascades the revokes to all the users who were granted this privilege directly or indirectly by <TT>USER1</TT>. This effectively revokes the privilege from everybody except <TT>USER5</TT>. However, <TT>USER5</TT> granted this privilege to <TT>PUBLIC</TT>, so everybody—including <TT>USER1</TT>—still has this privilege. <TT>WITH GRANT OPTION</TT> is the only privilege removed by the <TT>SYSADM</TT> revoke.</P>
<P class="docText">As a general rule, never allow the <TT>WITH GRANT OPTION</TT> in a production environment, and control and limit the availability of the <TT>WITH GRANT OPTION</TT> in a test environment. Consider purchasing an add-on security maintenance tool to monitor and minimize the effects of DB2's cascading revoke. Security tools are described further in <A class="docLink" HREF="part07.html#part07">Part VII</A>, "The Ideal DB2 Environment."<A NAME="ch10index132"></A><A NAME="ch10index133"></A><A NAME="ch10index134"></A></P>
<A NAME="ch10lev4sec21"></A><H5 class="docSection3Title">Revoking a <TT>SYSADM</TT></H5>
<P class="docText">Use caution when revoking a <TT>SYSADM</TT> from the system. Simply revoking the <TT>SYSADM</TT> authority from a user can cause cascading revokes. To revoke a <TT>SYSADM</TT> without causing cascading revokes, follow this procedure:<A NAME="ch10index135"></A><A NAME="ch10index136"></A><A NAME="ch10index137"></A><A NAME="ch10index138"></A><A NAME="ch10index139"></A></P>
<A NAME="ch10pr01"></A>


<div style="font-weight:bold"><OL class="docList" START="1"><LI value="1"><div style="font-weight:normal">Create a DSNZPARM member specifying the <TT>SYSADM</TT> userid to be revoked as an Install <TT>SYSADM</TT>. If both Install <TT>SYSADM</TT> parameters are currently being used, simply remove one of them and place the <TT>SYSADM</TT> userid to be revoked in its place. Removing an Install <TT>SYSADM</TT> does not cause cascading revokes.<BR><BR></div></LI><LI value="2"><div style="font-weight:normal">Revoke the <TT>SYSADM</TT> authority from the user.<BR><BR></div></LI><LI value="3"><div style="font-weight:normal">Modify the <TT>DSNZPARM</TT> member to remove the userid as an Install <TT>SYSADM</TT>. Replace the old Install <TT>SYSADM</TT> userid (if one was removed).<BR><BR></div></LI></OL></div>
<A NAME="ch10note01"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">If, after you revoke <TT>SYSADM</TT>, the userid is still valid in the system, its associated user can revoke privileges that were previously granted when the user was a <TT>SYSADM</TT>. This user has this capability because the userid remains as the <TT>GRANTOR</TT> of the authority in the DB2 Catalog.</P></div><br>
<A NAME="ch10lev4sec22"></A><H5 class="docSection3Title">Avoid Explicit <TT>DELETE</TT>, <TT>UPDATE</TT>, and <TT>INSERT</TT> Authority</H5>
<P class="docText">Consider not permitting users to have <TT>DELETE</TT>, <TT>UPDATE</TT>, and <TT>INSERT</TT> authority on production tables. You can enable users to modify data through application programs by granting them execute authority on an application plan that performs the desired type of updates. This way, you can effectively limit data modification to a controlled environment.<A NAME="ch10index140"></A><A NAME="ch10index141"></A><A NAME="ch10index142"></A><A NAME="ch10index143"></A><A NAME="ch10index144"></A><A NAME="ch10index145"></A><A NAME="ch10index146"></A><A NAME="ch10index147"></A></P>
<P class="docText">You should strictly control data modification because DB2 set-level processing can cause entire tables to be destroyed with a single SQL statement. Consider this example:</P>
<pre>

</pre><BR><pre>
UPDATE DSN8810.DEPT
   SET DEPT = 'YYY';
</pre><BR>
<P class="docText">This statement sets every department in the <TT>DEPT</TT> table to <TT>'YYY'</TT>, which is probably not required. If uncontrolled deletion, insertion, and modification are permitted, data almost certainly will be lost because of careless SQL modification statements.</P>
<A NAME="ch10lev4sec23"></A><H5 class="docSection3Title">Limit Alter Authority with the <TT>REFERENCES</TT> Privilege</H5>
<P class="docText">The <TT>REFERENCES</TT> privilege grants a user authority to <TT>CREATE</TT> or <TT>DROP</TT> referential constraints in which the named table is the parent table. Grant the <TT>REFERENCES</TT> privilege to administrators needing to maintain RI but not needing general <TT>ALTER</TT> authority on DB2 objects.<A NAME="ch10index148"></A><A NAME="ch10index149"></A><A NAME="ch10index150"></A><A NAME="ch10index151"></A></P>
<A NAME="ch10lev4sec24"></A><H5 class="docSection3Title">Consider Dynamic Authority</H5>
<P class="docText">As of DB2 V4, authorization for dynamic SQL in application programs can be treated the same as static SQL. For more details, refer to <A class="docLink" HREF="ch12.html#ch12">Chapter 12</A>, "Dynamic SQL Programming."<A NAME="ch10index152"></A><A NAME="ch10index153"></A><A NAME="ch10index154"></A><A NAME="ch10index155"></A></P>
<A NAME="ch10lev4sec25"></A><H5 class="docSection3Title">Follow the Proliferation Avoidance Rule</H5>
<P class="docText">Do not needlessly proliferate DB2 security. Every DB2 authorization grant requires additional entries in the DB2 Catalog. Granting unneeded authority causes catalog clutter—extraneous entries strewn about the DB2 Catalog tables. The larger the DB2 Catalog tables become, the less efficient your entire DB2 system will be.<A NAME="ch10index156"></A><A NAME="ch10index157"></A><A NAME="ch10index158"></A></P>
<P class="docText">The proliferation avoidance rule is based on common sense. Why proliferate unneeded authorization?</P>
<A NAME="ch10lev2sec2"></A><H4 class="docSection2Title">Multilevel Security</H4>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> With <span class="docEmphasis">multilevel security (MLS)</span> in DB2 V8 it becomes possible to support applications that need a more granular security scheme. For example, you might want to set up an authorization scenario such that employees can see their own data but no one else's. Or your authorization needs might dictate that each employee's immediate manager is able to see his payroll information as well as all of his employee's data, and so on up through the org chart. Setting up such a security scheme is virtually impossible prior to DB2 V8.<A NAME="ch10index159"></A><A NAME="ch10index160"></A><A NAME="ch10index161"></A></P></td></tr></table><br>
<A NAME="ch10lev3sec1"></A><H5 class="docSection3Title">MLS with Row Level Granularity</H5>
<P class="docText">As database systems and applications become more sophisticated, the need for low-level access control to the business data becomes more critical. With the events of the past few years, issues such as security, privacy, and auditing are now more important than ever before. The need to ensure that each piece of data is secured such that only authorized users can perform authorized functions is growing. DB2 V8 adds support for row level granularity of access control with multilevel security.<A NAME="ch10index162"></A><A NAME="ch10index163"></A></P>
<P class="docText">DB2 V8 supports row-level security in conjunction with a security management product (like RACF). To activate this authorization mechanism, you will need to add a specially named column to act as the security label. The security label column is matched with the multilevel security hierarchy in the security manager. For example, you might want to set up a hierarchy representing the animal kingdom, as shown in <A class="docLink" HREF="#ch10fig01">Figure 10.1</A>. Of course, the hierarchy need not be so complex—you might simply choose to use something simpler, such as TOP SECRET, SECRET, and UNCLASSIFIED.<A NAME="ch10index164"></A><A NAME="ch10index165"></A></P>
<A NAME="ch10fig01"></A><p><CENTER><H5 class="docFigureTitle">Figure 10.1. A sample MLS hierarchy.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/10fig01_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="216" SRC="images/0672326132/graphics/10fig01.gif" ALT="graphics/10fig01.gif"></p></CENTER></p><br>
<A NAME="ch10note02"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">To support MLS hierarchies, DB2 V8 requires several new RACF access control functions that are not available prior to V1R5 of z/OS.</P>
<P class="docText">For other security server products, consult the vendor for guidance before attempting to use it with DB2 for multilevel security.</P></div><br>
<P class="docText">In the example shown in <A class="docLink" HREF="#ch10fig01">Figure 10.1</A>, an MLS hierarchy representing the animal kingdom is to be used. This hierarchy is established in RACF. At the top of the hierarchy, <TT>ANIMALS</TT>, is a security label that includes everything—for example, all mammals, reptiles, and insects. Middle levels of the hierarchy that represent additional security groupings can be created. In this case we have a second level of <TT>MAMMALS</TT>, <TT>REPTILES</TT>, and <TT>INSECTS</TT>. And under <TT>MAMMALS</TT> we have other levels/security labels: <TT>DOGS</TT> (<TT>SPANIEL</TT>, <TT>POODLE</TT>) and even <TT>SPANIEL</TT> breaks down to <TT>FIELD</TT>, <TT>SPRINGER</TT>, and <TT>COCKER</TT>. And so on throughout the hierarchy. Such a hierarchy provides great flexibility for assigning various levels of security to data in DB2 tables—and thereby appropriately securing the data from unauthorized user access.<A NAME="ch10index166"></A><A NAME="ch10index167"></A></P>
<P class="docText">Again, referring to the MLS hierarchy, let's discuss a few of the levels and what they imply. First of all, users designated with the <TT>ANIMALS</TT> authority can access anything. Users with authority to access <TT>MAMMALS</TT> data can access any row associated with <TT>MAMMALS</TT>, or any subordinate mammal (<TT>MONKEYS</TT>, <TT>PIGS</TT>, and <TT>DOGS</TT>), and so on down through the hierarchy (including <TT>SPANIELS</TT> and <TT>POODLES</TT>, as well as types of spaniels—<TT>FIELD</TT>, <TT>SPRINGER</TT>, and <TT>COCKER</TT> spaniels). This offers more powerful security than simple matching. To use this feature in DB2, you must define a special column for each table that is to have row-level security. This column, referred to as the <TT>SECLABEL</TT>, must be defined with the specification <TT>AS SECURITY LABEL</TT>. The <TT>SECLABEL</TT> column must be defined as <TT>CHAR(8) NOT NULL WITH DEFAULT</TT>. Furthermore, the <TT>SECLABEL</TT> column cannot have any field procedures, edit procedures or check constraints defined upon it. After a table has a <TT>SECLABEL</TT> defined, it cannot be disabled. Only one security label per table is permitted.<A NAME="ch10index168"></A><A NAME="ch10index169"></A></P>
<P class="docText">When row-level security is implemented, every user must be identified to RACF (or another security server with equivalent functionality) with a valid <TT>SECLABEL</TT>. If the user is not identified with a <TT>SECLABEL</TT>, an authorization error will occur. At a high level, then, row-level security works by matching the <TT>SECLABEL</TT> of the data to the <TT>SECLABEL</TT> of the user. One of the important features of multilevel security is that the person retrieving the row has no idea other rows even exist—and not that they simply cannot see them.</P>
<P class="docText">Of course, there are additional details that are needed to implement user row-level authorization properly in DB2. First of all, there is some new terminology that you will need to assimilate in order to understand how DB2 row-level security works. Controls put in place to prevent unauthorized users from accessing information at a higher classifications that their authorization level enforce <span class="docEmphasis">read up</span> security. But controls also must be put in place to prevent users from declassifying information—and this is known as <span class="docEmphasis">write down</span> security.<A NAME="ch10index170"></A><A NAME="ch10index171"></A><A NAME="ch10index172"></A><A NAME="ch10index173"></A><A NAME="ch10index174"></A><A NAME="ch10index175"></A></P>
<P class="docText">Additionally, you will need to understand the terms used when comparing <TT>SECLABEL</TT>s. To enforce read up and write down security, comparison is not just a simple equivalency match. There are four possible outcomes when a user's <TT>SECLABEL</TT> is compared to the data's <TT>SECLABEL</TT>:<A NAME="ch10index176"></A><A NAME="ch10index177"></A><A NAME="ch10index178"></A></P>
<UL><LI><p class="docText">
<span class="docEmphStrong">Dominate</span>— 
A <TT>SECLABEL</TT> dominates another if it is greater than or equal to it in the hierarchy.</p></LI><LI><p class="docText">
<span class="docEmphStrong">Reverse Dominate</span>— 
A <TT>SECLABEL</TT> reverse dominates another if it is less than or equal to it in the hierarchy.</p></LI><LI><p class="docText">
<span class="docEmphStrong">Equivalence</span>— 
Equivalence means that the <TT>SECLABEL</TT>s are the same or have the same level and set of categories. Two <TT>SECLABEL</TT>s are equivalent if both dominance and reverse dominance apply.</p></LI><LI><p class="docText">
<span class="docEmphStrong">Null</span>— 
If none of the above are true, the null condition applies.</p></LI></UL>
<P class="docText">The following bulleted items describe the manner in which row-level security authorization operates:</P>
<UL><LI><p class="docText">
<TT>SELECT</TT>— 
The value of the user's <TT>SECLABEL</TT> is compared to the <TT>SECLABEL</TT> of the row to be selected. If the user's <TT>SECLABEL</TT> dominates the data's <TT>SECLABEL</TT>, the row is returned. If the user's <TT>SECLABEL</TT> does not dominate the data's <TT>SECLABEL</TT>, then the row is not returned, and no error is reported.</p></LI><LI><p class="docText">
<TT>INSERT</TT>— 
If the user has a valid <TT>SECLABEL</TT>, then the user's <TT>SECLABEL</TT> value is used for the data's <TT>SECLABEL</TT> column for the row that is being inserted. If the user does not have the write-down privilege, then the <TT>SECLABEL</TT> of inserted rows will be exactly the current <TT>SECLABEL</TT>. Users with the write-down privilege can set the value of the <TT>SECLABEL</TT> column to any value.</p></LI><LI><p class="docText">
<TT>UPDATE</TT>— 
The user's <TT>SECLABEL</TT> is compared with the data's <TT>SECLABEL</TT> (for the row being updated), but only for users with a valid <TT>SECLABEL</TT>. If the <TT>SECLABEL</TT>s match, then the row is updated. If the <TT>SECLABEL</TT>s do not match, then both dominance and reverse dominance are checked. The <TT>UPDATE</TT> is allowed only if both are true. Also, the data's <TT>SECLABEL</TT> is set to the user's <TT>SECLABEL</TT> value.<A NAME="ch10index179"></A><A NAME="ch10index180"></A><A NAME="ch10index181"></A></p></LI><LI><p class="docText">
<TT>DELETE</TT>— 
The user's <TT>SECLABEL</TT> is compared with the data's <TT>SECLABEL</TT> (for the row being deleted), but only for users with a valid <TT>SECLABEL</TT>. If the <TT>SECLABEL</TT>s match, then the row is deleted. If the <TT>SECLABEL</TT>s do not match, then both dominance and reverse dominance are checked. The <TT>DELETE</TT> is allowed only if both are true. A user who has write down authority can access and delete down-level (dominance) rows, but not up-level (reverse dominance) rows.</p></LI></UL>
<P class="docText">Similar to normal data processing in DB2 tables, utility processing must be checked for authorization. As with normal processing, the user running the utility must be identified to RACF. The following outlines how the IBM DB2 utilities work with row-level MLS:<A NAME="ch10index182"></A><A NAME="ch10index183"></A><A NAME="ch10index184"></A><A NAME="ch10index185"></A></P>
<BLOCKQUOTE><P><p class="docText"><TT>LOAD RESUME</TT>— 
Loading with the <TT>RESUME</TT> option functions similarly to <TT>INSERT</TT> processing. Without write down permission, the <TT>SECLABEL</TT> is set to the current <TT>SECLABEL</TT>. With write down permission, the user is permitted to specify the <TT>SECLABEL</TT>.</p></P><P><p class="docText"><TT>LOAD REPLACE</TT>— 
Because loading with the <TT>REPLACE</TT> option will <TT>DELETE</TT> all existing rows, write down authority is required.</p></P><P><p class="docText"><TT>UNLOAD</TT>— 
Unloading data functions similarly to <TT>SELECT</TT> processing. The only rows that can be unloaded are those where the user's <TT>SECLABEL</TT> dominates the data's <TT>SECLABEL</TT>. If this is not the case, the row is not returned (and no error is returned).</p></P><P><p class="docText"><TT>REORG UNLOAD EXTERNAL</TT>— 
Functions the same as the <TT>UNLOAD</TT> utility (just discussed).</p></P><P><p class="docText"><TT>REORG DISCARD</TT>— 
Reorganizing data with the <TT>DISCARD</TT> option functions similarly to <TT>DELETE</TT> processing. For each row that is unloaded during the <TT>REORG</TT>, if the row qualifies to be discarded, the user's <TT>SECLABEL</TT> is compared to the data's <TT>SECLABEL</TT>. If both dominance and reverse dominance is true, then the row is discarded, otherwise it is kept.<A NAME="ch10index186"></A><A NAME="ch10index187"></A></p></P></BLOCKQUOTE>
<A NAME="ch10lev4sec26"></A><H5 class="docSection4Title">Be Aware of Row-Level MLS Restrictions</H5>
<P class="docText">Although row-level MLS provides great control over data access and modifications, there are several restrictions that apply. These restrictions are as follows:<A NAME="ch10index188"></A><A NAME="ch10index189"></A></P>
<UL><LI><P class="docList">Referential constraints cannot be defined on a security label column.</P></LI><LI><P class="docList">Sysplex parallelism will not be used for any query that accesses a table with a security label column.</P></LI><LI><P class="docList">Edit procedures and field procedures are not allowed on a security label column.</P></LI><LI><P class="docList">Trigger transition tables cannot have security labels.</P></LI></UL>
<P class="docText">Additionally, the access control authorization exit, which used to ship with RACF, now ships with DB2. So, the exit is no longer in the RACF <TT>SYS1.SAMPLIB</TT> library, but in the DB2 <TT>SDSNSAMP</TT> library.<A NAME="ch10index190"></A><A NAME="ch10index191"></A></P>
<A NAME="ch10note03"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Your old authorization exits will no longer work with DB2 Version 8. Migration to the new authorization exit is required in order to support new object types and certain new features, such as long names. Be sure to plan the conversion as part of your V8 migration effort.</P></div><br>
<A NAME="ch10lev3sec2"></A><H5 class="docSection3Title">MLS for Access Control</H5>
<P class="docText">Multilevel security access controls can be used in conjunction with native DB2 access controls (<TT>GRANT</TT>/<TT>REVOKE</TT>) or with RACF access controls. If you use RACF, then you can use security labels to define the access controls on most DB2 objects.<A NAME="ch10index192"></A><A NAME="ch10index193"></A><A NAME="ch10index194"></A><A NAME="ch10index195"></A></P>
<P class="docText">Access requires both the discretionary access control (<TT>PERMIT</TT>) and the mandatory access control (<TT>SECLABEL</TT> comparison). When implementing MLS on database objects be sure to define the <TT>SECLABEL</TT> of each object such that the higher object dominates all objects lower than it in the hierarchy. <A class="docLink" HREF="#ch10fig02">Figure 10.2</A> shows the DB2 object hierarchy for MLS security. This hierarchy is for security purposes, as opposed to the simple database object hierarchy shown in <A class="docLink" HREF="ch01.html#ch01">Chapter 1</A> (<A class="docLink" HREF="ch01lev1sec2.html#ch01fig04">Figure 1.4</A>), which is to be used to guide the order in which database objects should be created.</P>
<A NAME="ch10fig02"></A><p><CENTER><H5 class="docFigureTitle">Figure 10.2. The DB2 database object hierarchy.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/10fig02_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="258" SRC="images/0672326132/graphics/10fig02.gif" ALT="graphics/10fig02.gif"></p></CENTER></p><br>
<A NAME="ch10lev2sec3"></A><H4 class="docSection2Title">Session Variables</H4>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> Session variables, set by DB2 or by the user, provide another way to provide additional information to applications. The following session variables are set by DB2 (as of V8), and are therefore accessible to application programs and end users:<A NAME="ch10index196"></A><A NAME="ch10index197"></A><A NAME="ch10index198"></A></P></td></tr></table><br>
<UL><LI><p class="docText">
<TT>PLAN_NAME</TT>— 
Name of the plan that is currently being run<A NAME="ch10index199"></A><A NAME="ch10index200"></A><A NAME="ch10index201"></A></p></LI><LI><p class="docText">
<TT>PACKAGE_NAME</TT>— 
Name of the package currently in use<A NAME="ch10index202"></A><A NAME="ch10index203"></A><A NAME="ch10index204"></A></p></LI><LI><p class="docText">
<TT>PACKAGE_SCHEMA</TT>— 
Schema name of the current package<A NAME="ch10index205"></A><A NAME="ch10index206"></A><A NAME="ch10index207"></A></p></LI><LI><p class="docText">
<TT>PACKAGE_VERSION</TT>— 
Version of the current package<A NAME="ch10index208"></A><A NAME="ch10index209"></A><A NAME="ch10index210"></A></p></LI><LI><p class="docText">
<TT>SECLABEL</TT>— 
The user's security label<A NAME="ch10index211"></A><A NAME="ch10index212"></A><A NAME="ch10index213"></A></p></LI><LI><p class="docText">
<TT>SYSTEM_NAME</TT>— 
Name of the system<A NAME="ch10index214"></A><A NAME="ch10index215"></A><A NAME="ch10index216"></A></p></LI><LI><p class="docText">
<TT>VERSION</TT>— 
Version of the DB2 subsystem<A NAME="ch10index217"></A><A NAME="ch10index218"></A><A NAME="ch10index219"></A></p></LI><LI><p class="docText">
<TT>DATA_SHARING_GROUP_NAME</TT>— 
Name of the data sharing group<A NAME="ch10index220"></A><A NAME="ch10index221"></A><A NAME="ch10index222"></A></p></LI><LI><p class="docText">
<TT>SYSTEM_ASCII_CCSID</TT>— 
CCSID information in ASCII<A NAME="ch10index223"></A><A NAME="ch10index224"></A><A NAME="ch10index225"></A></p></LI><LI><p class="docText">
<TT>SYSTEM_EBCDIC_CCSID</TT>— 
CCSID information in EBCDIC<A NAME="ch10index226"></A><A NAME="ch10index227"></A><A NAME="ch10index228"></A></p></LI><LI><p class="docText">
<TT>SYSTEM_UNICODE_CCSID</TT>— 
CCSID information in Unicode<A NAME="ch10index229"></A><A NAME="ch10index230"></A><A NAME="ch10index231"></A></p></LI></UL>
<P class="docText">Each of these session variables is qualified by <TT>SYSIBM</TT>. A new (V8) built-in function named <TT>GETVARIABLE</TT> is used to retrieve session variable values. So, you could create a view based on a security label, for example:</P>
<pre>

</pre><BR><pre>
CREAT VIEW VSECLBL AS
  SELECT <span class="docEmphasis">column-list</span>
  FROM   <span class="docEmphasis">table-name</span>
  WHERE  SECLABEL_COL = GETVARIABLE(SYSIBM.SECLABEL);
</pre><BR>
<P class="docText">The built-in function can be used in views, triggers, stored procedures, and constraints to enforce a security policy.</P>
<P class="docText">Users can add up to ten session variables by setting the name and value in their connection or signon exits. User-created session variables are qualified by <TT>SESSION</TT>. For example, the customer might have a connection or signon exit that examines the SQL user's IP address, and maps the IP address to the user's site within the company. This is recorded in a session variable, named say, <TT>USER_SITE</TT>. This session variable is then accessible using the built-in function, for example:<A NAME="ch10index232"></A><A NAME="ch10index233"></A><A NAME="ch10index234"></A></P>
<pre>

</pre><BR><pre>
GETVARIABLE(SESSION.USER_SITE)
</pre><BR>
<P class="docText">Using session variables much more information is available to application programs as they execute, and more control and security is provided, as well. Additionally, session variables can be trusted. They are set by DB2 and an application cannot modify them.<A NAME="ch10index235"></A><A NAME="ch10index236"></A><A NAME="ch10index237"></A></P>
<A NAME="ch10lev2sec4"></A><H4 class="docSection2Title">Additional DB2 Security Guidelines</H4>
<P class="docText">As you adopt your security and authorization policies, consider the following guidelines and suggestions.</P>
<A NAME="ch10lev4sec27"></A><H5 class="docSection3Title">Consider DCE Security</H5>
<P class="docText">DB2 V5 and later releases can use the Distributed Computing Environment (DCE) security services to authenticate remote users. Users can access any DCE-based server (including DB2 on OS/390) using a single DCE userid and password. DCE and DCE security are complex systems management topics for distributed, interconnected networks, and in-depth coverage is beyond the scope of this book.<A NAME="ch10index238"></A><A NAME="ch10index239"></A><A NAME="ch10index240"></A></P>
<A NAME="ch10lev4sec28"></A><H5 class="docSection3Title">Consider Kerberos Security</H5>

<P class="docText">DB2 V7 and later releases can use Kerberos as a replacement standard for DCE. Kerberos is a standard industry authentication technique. Many vendors have implemented Kerberos solutions on a variety of different platforms. For example, Kerberos provides for better integration with Windows 2000 security as well as offering a single sign-on solution for your applications. One advantage of using Kerberos security is that when you sign on to a Windows 2000 workstation you will not need to provide a host userid and password to use applications that access DB2 for z/OS database servers.<A NAME="ch10index241"></A><A NAME="ch10index242"></A></P>
<P class="docText">In-depth coverage of Kerberos security, however, is beyond the scope of this book.</P>
<A NAME="ch10lev4sec29"></A><H5 class="docSection3Title">Consider Encrypting Userids and Passwords</H5>

<P class="docText">DB2 V7 (and DB2 V5 and V6 with APAR <TT>PQ21252</TT>) supports password encryption. You can direct DB2 Connect to encrypt the password when it is sent to DB2 for z/OS for authentication. Any compliant DRDA Version 2 requester can use password encryption.<A NAME="ch10index243"></A><A NAME="ch10index244"></A><A NAME="ch10index245"></A><A NAME="ch10index246"></A></P>
<A NAME="ch10note04"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">DB2 Connect V5.2 (Fixpack 7) and higher is required in order to support DRDA Version 2 password encryption.</P></div><br>
<P class="docText">To enable DB2 Connect to flow encrypted passwords, DCS authentication must be set to <TT>DCS_ENCRYPT</TT> in the DCS directory entry.</P>
<P class="docText">Userids, as well as passwords, can be encrypted with DB2 V7, but encrypted userids and passwords are supported when DB2 for z/OS (and OS/390) is acting as a server. DB2 for z/OS (and OS/390) cannot act as a requester and send encrypted userids and passwords to a DRDA server.</P>
<A NAME="ch10lev4sec30"></A><H5 class="docSection3Title">Consider Encrypting DB2 Data</H5>

<P class="docText">DB2 Version 8 adds several new built-in functions to facilitate the encryption and decryption of DB2 data. The functionality of these functions is described in <A class="docLink" HREF="ch03.html#ch03">Chapter 3</A>, "Using DB2 Functions." Basically, there are functions for encrypting and decrypting the data, as well as for generating unique values, and getting a hint for your encryption password.<A NAME="ch10index247"></A><A NAME="ch10index248"></A><A NAME="ch10index249"></A></P>
<P class="docText">The encryption password is set using the <TT>SET ENCRYPTION PASSWORD</TT> statement. The encryption password can be a <TT>CHAR</TT> or <TT>VARCHAR</TT> variable or constant. Its length must be between 6 and 127 bytes and cannot be null.<A NAME="ch10index250"></A><A NAME="ch10index251"></A></P>
<P class="docText">Consider encrypting data if the data is sensitive and there is a good chance of unauthorized access to the data. Be aware that encrypting and decrypting data consumes CPU cycles, so performance will be impacted by data encryption.</P>
<P class="docText">Whenever data is encrypted, be sure to set a hint to facilitate decryption in case you forget the encryption password; for example:</P>
<pre>

</pre><BR><pre>
SET ENCRYPTION PASSWORD = :hv1 WITH HINT :hv2;
</pre><BR>
<P class="docText">The <TT>WITH HINT</TT> clause allows you to set a value as a password hint to help you to remember a data encryption password. For example, you might set the hint to "Dog" as a hint to remember the password "Jerry" (my dog's name). If a password hint is specified, the hint is used for the encryption function. If a password hint is not specified, no hint is embedded in data that is encrypted with the encryption function. The hint can be a <TT>CHAR</TT> or <TT>VARCHAR</TT> variable or constant up to 32 bytes.<A NAME="ch10index252"></A><A NAME="ch10index253"></A></P>
<P class="docText">The <TT>GETHINT</TT> function is used to retrieve the hint for an encrypted value.<A NAME="ch10index254"></A><A NAME="ch10index255"></A><A NAME="ch10index256"></A></P>
<A NAME="ch10lev4sec31"></A><H5 class="docSection3Title">Consider Using Views to Implement Security</H5>
<P class="docText">Sometimes views can be used to implement row- and column-level security for DB2 applications. One approach is to create a view on a base table containing only those columns that you want a user to be able to access. Then you can <TT>GRANT</TT> the user the authority to use the view, not the base table. For example, suppose you want to allow users to access the <TT>DSN8810.EMP</TT> table, but not the sensitive salary-related columns <TT>SALARY</TT>, <TT>COMM</TT>, and <TT>BONUS</TT>. First you would create the following view:<A NAME="ch10index257"></A><A NAME="ch10index258"></A></P>
<pre>

</pre><BR><pre>
CREATE VIEW EMP_DETAILS
AS
  SELECT EMPNO, FIRSTNME, MIDINIT, LASTNAME, WORKDEPT,
         PHONENO, HIREDATE, JOB, EDLEVEL, SEX, BIRTHDATE
  FROM   DSN8810.EMP;
</pre><BR>
<P class="docText">This creates a view named <TT>EMP_DETAILS</TT> that can now be accessed using SQL statements. Then you would <TT>GRANT</TT> the appropriate authority to your users for this view, but not the <TT>EMP</TT> table. By granting users only the authority to use the view, access is given to only that data within the view, thereby securing the non-included data from unauthorized access. This effectively blocks access to the sensitive data.</P>
<P class="docText">But what about row-level security? You can implement crude row-level security using views, too. Of course, with DB2 V8, MLS security provides a much more efficient and effective means of securing data at the row-level. To use views for row-level security, simply code the appropriate <TT>WHERE</TT> clauses on the views to remove the rows you do not want your users to be able to access. For example, if we only wanted to allow access to male employees, we could code the view as follows:</P>
<pre>

</pre><BR><pre>
CREAT VIEW MALE_EMP
AS
  SELECT EMPNO, FIRSTNME, MIDINIT, LASTNAME, WORKDEPT,
         PHONENO, HIREDATE, JOB, EDLEVEL, BIRTHDATE
  FROM   DSN8810.EMP
  WHERE  SEX = 'M'
WITH CHECK OPTION;
</pre><BR>
<P class="docText">Notice that we chose to omit the <TT>SEX</TT> column because we know that all of these employees are <TT>MALE</TT>—this is optional, but probably a good idea. Be sure to specify the <TT>WITH CHECK OPTION</TT> clause on the view to assure that rows outside the scope of the <TT>WHERE</TT> clause cannot be modified.<A NAME="ch10index259"></A><A NAME="ch10index260"></A></P>
<A NAME="ch10lev4sec32"></A><H5 class="docSection3Title">Consider Using Stored Procedures to Implement Security</H5>
<P class="docText">You can create stored procedures to provide specific, tailored security. You can do so by coding specific SQL statements within a stored procedure and granting specific access to that procedure. The users need not have authorization to the underlying tables accessed by the stored procedure. This approach allows you to hide complex authorization rules in the details of a stored procedure.<A NAME="ch10index261"></A><A NAME="ch10index262"></A></P>
<A NAME="ch10lev4sec33"></A><H5 class="docSection3Title">Userid and Password</H5>

<P class="docText">As of V7, it is possible specify a userid and password when connecting to a server from an application running on z/OS. You can <TT>CONNECT</TT> to a remote server or a local server. The password is used to verify that you are authorized to connect to the DB2 subsystem.</P>
<P class="docText">This is important because DB2 for Linux, Unix, and Windows supports the <TT>USER</TT> parameter as an option of the <TT>CONNECT</TT> statement. So, you can now port applications to z/OS (or OS/390). Additionally, you can develop applications on workstation DB2 platforms, and then move the application to production on the mainframe without having to reprogram.</P>
<A NAME="ch10lev4sec34"></A><H5 class="docSection3Title">Take Advantage of Special Registers</H5>
<P class="docText">DB2 provides many special registers that store information for DB2 processes. When referencing a special register DB2 replaces the register name with its value at execution time. Several of these special registers are helpful for security and authorization purposes:<A NAME="ch10index263"></A><A NAME="ch10index264"></A><A NAME="ch10index265"></A></P>
<BLOCKQUOTE><P><P class="docList"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"> <TT>CLIENT ACCTNG</TT> contains the value of the accounting string from the client information that is specified for the connection. The data type is <TT>VARCHAR(255)</TT>.<A NAME="ch10index266"></A></P></P><P><P class="docList"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"> <TT>CLIENT APPLNAME</TT> contains the value of the application name from the client information specified for the connection. The data type is <TT>VARCHAR(255)</TT>.<A NAME="ch10index267"></A></P><P class="docList"><TT>CURRENT SQLID</TT> specifies the current SQL authid of the process. The data type is <TT>VARCHAR(8)</TT>.</P></P><P><P class="docList"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"> <TT>CLIENT USERID</TT> contains the value of the client userid from the client information that is specified for the connection. The data type is <TT>VARCHAR(255)</TT>.<A NAME="ch10index268"></A></P></P><P><P class="docList"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"> <TT>CLIENT WORKSTNNAME</TT> contains the value of the workstation name from the client information that is specified for the connection. The data type is <TT>VARCHAR(255)</TT>.<A NAME="ch10index269"></A></P></P><P><P class="docList"><TT>USER</TT> contains the primary authid of the process. The data type is <TT>VARCHAR(8)</TT>. If <TT>USER</TT> is referred to in an SQL statement that is executed at a remote DB2 and the primary authid has been translated to a different authid, <TT>USER</TT> returns the translated authid.<A NAME="ch10index270"></A><A NAME="ch10index271"></A><A NAME="ch10index272"></A></P></P></BLOCKQUOTE>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch10.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="part02.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
