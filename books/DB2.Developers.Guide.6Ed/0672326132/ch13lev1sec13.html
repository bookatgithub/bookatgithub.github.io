<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>BIND Guidelines</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch13lev1sec12.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch13lev1sec14.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch13lev1sec13"></A><H3 class="docSection1Title"><TT>BIND</TT> Guidelines</H3>
<P class="docText">Using the following tips and techniques will ensure effective execution of the <TT>BIND</TT> statement and the creation of efficiently bound DB2 application programs.</P>
<A NAME="ch13lev4sec20"></A><H4 class="docSection2Title">Administer Initial Binds Centrally</H4>
<P class="docText">A centralized administration group (DBA, bind agent, and so on) should be responsible for all initial binds of applications plans (<TT>BIND ADD</TT>). This provides a point of control for administering plan and package use and freeing old or unused plans and packages when they are no longer required. Centralized control also makes it easier to enforce your shop's DB2 naming standards.<A NAME="ch13index282"></A><A NAME="ch13index283"></A><A NAME="ch13index284"></A></P>
<A NAME="ch13lev4sec21"></A><H4 class="docSection2Title">Keep Statistics Current for Binding</H4>
<P class="docText">Before binding, ensure that the <TT>RUNSTATS</TT> utility has been executed recently for every table accessed by the plan or package to be bound. This allows the bind process to base access path selections on the most recent statistical information. Without up-to-date statistics, DB2 will create access paths based on inaccurate information—which can cause poor performance due to sub-optimal access paths.<A NAME="ch13index285"></A><A NAME="ch13index286"></A></P>
<A NAME="ch13lev4sec22"></A><H4 class="docSection2Title">Avoid Default Parameters</H4>
<P class="docText">Specify every bind parameter. Defaults are used for certain bind parameters when the <TT>BIND</TT> command is issued without specifying them. This could be dangerous because the default options are not always the best for performance and concurrency.<A NAME="ch13index287"></A><A NAME="ch13index288"></A><A NAME="ch13index289"></A></P>
<A NAME="ch13lev4sec23"></A><H4 class="docSection2Title">Group Like Programs into Collections</H4>
<P class="docText">You should group like programs by binding them to packages and specifying the same collection identifier. If a customer application is composed of 12 DB2 programs, for example, bind each into a separate package with a collection identifier of <TT>CUSTOMER</TT>. This makes the administration of packages belonging to the same application easy.<A NAME="ch13index290"></A><A NAME="ch13index291"></A><A NAME="ch13index292"></A><A NAME="ch13index293"></A></P>
<A NAME="ch13lev4sec24"></A><H4 class="docSection2Title">Use Wildcard Package Lists</H4>
<P class="docText">When multiple packages must exist in the same plan, favor using the wildcard capability of the <TT>PKLIST</TT> parameter of the <TT>BIND PLAN</TT> statement. To bind the 12-customer application packages (mentioned in the last guideline) to a single plan, for example, you could specify <TT>PKLIST(CUSTOMER.*)</TT>. Additionally, all new packages bound in the <TT>CUSTOMER</TT> collection are automatically added to that plan.<A NAME="ch13index294"></A><A NAME="ch13index295"></A><A NAME="ch13index296"></A><A NAME="ch13index297"></A></P>
<A NAME="ch13lev4sec25"></A><H4 class="docSection2Title">Specify Collections and Packages Carefully in the PKLIST</H4>
<P class="docText">Avoiding the following scenario will eliminate confusing which package is actually being used during program execution:<A NAME="ch13index298"></A><A NAME="ch13index299"></A><A NAME="ch13index300"></A><A NAME="ch13index301"></A><A NAME="ch13index302"></A><A NAME="ch13index303"></A></P>
<UL><LI><P class="docList">Binding the same DBRM into different collections (such as <TT>C1</TT> and <TT>C2</TT>)</P></LI><LI><P class="docList">Binding a plan with a package list specifying both collections (<TT>C1.*,C2.*</TT>), both packages (<TT>C1.PACKAGE</TT>, <TT>C2.PACKAGE</TT>), or a combination (<TT>C1.*,C2.PACKAGE</TT> or <TT>C1.PACKAGE,C2.*</TT>)</P></LI><LI><P class="docList">Failing to specify <TT>SET CURRENT PACKAGESET</TT> in the application program</P></LI></UL>
<P class="docText">If the current package set is blank, the package is in any collection in the EDM pool, and the consistency tokens match, DB2 will return the package. It does not matter whether the package is from <TT>C1</TT> or <TT>C2</TT>. For this reason, specifying <TT>SET CURRENT PACKAGESET</TT> is imperative if you have a package bound into more than one collection in the <TT>PKLIST</TT> of the same plan. Although many think that DB2 uses packages in the order specified in the package list, this is only true if none of the packages are in the EDM Pool when the plan executes. If a matching package is in the EDM pool and can be used, DB2 will use it and the program might execute an improper package.</P>
<A NAME="ch13lev4sec26"></A><H4 class="docSection2Title">Specify Explicit Consistency Tokens</H4>
<P class="docText">Favor the specification of an explicit consistency token for package versioning over allowing it to default to a timestamp. If a new version with a new timestamp is created every time a package is bound, the DB2 Catalog quickly becomes cluttered with unused versions. Explicitly specifying a consistency token to control versions that must be saved is better. You could, for example, specify a release number such as <TT>REL100</TT>, and then increment the number to <TT>REL101</TT>, <TT>REL102</TT>, <TT>REL200</TT>, and so on, to indicate different versions of the software. In this manner, only one version, rather than many versions of each release will exist.<A NAME="ch13index304"></A><A NAME="ch13index305"></A><A NAME="ch13index306"></A><A NAME="ch13index307"></A><A NAME="ch13index308"></A></P>
<A NAME="ch13lev4sec27"></A><H4 class="docSection2Title">Use the <TT>QUALIFIER</TT> Parameter</H4>
<P class="docText">When binding packages, use the <TT>QUALIFIER</TT> parameter to specify an identifier to be used by the bind process to qualify all tables referenced by SQL statements in the DBRM being bound. The <TT>DSN8510.DEPT</TT> table, for example, is accessed if the following statement is embedded in a program bound to a package specifying a<TT>QUALIFIER</TT> of <TT>DSN8510</TT>:<A NAME="ch13index309"></A><A NAME="ch13index310"></A><A NAME="ch13index311"></A><A NAME="ch13index312"></A></P>
<pre>

</pre><BR><pre>
EXEC SQL
    SELECT  DEPTNO, DEPTNAME
    INTO    :DEPTNO, :DEPTNAME
    FROM    DEPT
END-EXEC.
</pre><BR>
<P class="docText">Users can specify a qualifier different from their userid if they have the necessary authority to issue the <TT>BIND</TT> command for the plan or package. The users do not need to be <TT>SYSADM</TT> or have a secondary authid, as is required with the <TT>OWNER</TT> parameter.</P>
<P class="docText">Optionally, the <TT>OWNER</TT> parameter can be used to qualify tables at <TT>BIND</TT> time. When specifying an <TT>OWNER</TT>, however, the binding agent must be either a <TT>SYSADM</TT> or set up with a secondary authid equal to the owner being specified.</P>
<A NAME="ch13lev4sec28"></A><H4 class="docSection2Title">Strategically Implement Multiple Qualified Tables</H4>
<P class="docText">If a single plan needs to access tables with different qualifiers, consider one of the following two strategies. The first strategy is to create aliases or synonyms such that every table or view being accessed has the same qualifier. The second method is to separate the tables being accessed into logical processing groups by qualifier. Code a separate program to access each processing group. Then bind each program to a separate package, specifying the qualifier of the tables in that program. Finally, bind all the packages into a single plan.<A NAME="ch13index313"></A><A NAME="ch13index314"></A></P>
<A NAME="ch13lev4sec29"></A><H4 class="docSection2Title">Use One Program and Multiple Packages for Mirror Tables</H4>
<P class="docText">When you use mirror tables, one program can access different tables. Suppose that you need an employee table for every month of the year. Each employee table is modeled after <TT>DSN8810.EMP</TT> but contains only the active employees for the month it supports. The following tables, for example, are differentiated by their qualifier:<A NAME="ch13index315"></A><A NAME="ch13index316"></A><A NAME="ch13index317"></A><A NAME="ch13index318"></A></P>
<pre>

</pre><BR><pre>
JANUARY.EMP

FEBRUARY.EMP

MARCH.EMP

  .

  .

  .

NOVEMBER.EMP

DECEMBER.EMP
</pre><BR>
<P class="docText">Assume that you need 12 reports, each one providing a list of employees for a different month. One program can be coded to access a generic, unqualified <TT>EMP</TT> table. You then could bind the program to 12 separate packages (or plans), each specifying a different qualifier (<TT>JANUARY</TT> through <TT>DECEMBER</TT>). For more information on mirror tables, refer to <A class="docLink" HREF="ch05.html#ch05">Chapter 5</A>, "Data Definition Guidelines."</P>
<A NAME="ch13note11"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">This approach will likely increase EDM pool usage. This is so because the package will be allocated once for every collection.</P></div><br>
<A NAME="ch13lev4sec30"></A><H4 class="docSection2Title">Use the Correct <TT>ACTION</TT> Parameter</H4>
<P class="docText">Specify the proper <TT>ACTION</TT> parameter for your bind. You can specify two types of actions: <TT>ADD</TT> or <TT>REPLACE</TT>. <TT>ADD</TT> indicates that the plan is new. <TT>REPLACE</TT> indicates that an old plan by the same name will be replaced. Specifying <TT>ACTION</TT> (<TT>REPLACE</TT>) for a new plan does not cause the bind to fail—it merely causes confusion.<A NAME="ch13index319"></A><A NAME="ch13index320"></A><A NAME="ch13index321"></A><A NAME="ch13index322"></A></P>
<A NAME="ch13lev4sec31"></A><H4 class="docSection2Title">Establish <TT>BIND PLAN</TT> Parameter Guidelines</H4>
<P class="docText">Favor the use of the following parameters when binding application plans:<A NAME="ch13index323"></A><A NAME="ch13index324"></A><A NAME="ch13index325"></A><A NAME="ch13index326"></A></P>
<pre>

</pre><BR><pre>
ISOLATION (CS)

VALIDATE (BIND)

ACTION (REPLACE)

NODEFER (PREPARE)

FLAG (I)

ACQUIRE (USE)

RELEASE (COMMIT)

DEGREE (1)

CURRENTDATA (NO)

EXPLAIN (YES)
</pre><BR>
<P class="docText">These <TT>BIND PLAN</TT> parameters usually produce the most efficient and effective DB2 plan. However, one set of <TT>BIND</TT> parameters will <span class="docEmphStrong">not</span> be applicable for every DB2 application program. Reasons for choosing different options are discussed in other guidelines in this chapter.</P>
<A NAME="ch13lev4sec32"></A><H4 class="docSection2Title">Establish <TT>BIND PACKAGE</TT> Parameter Guidelines</H4>
<P class="docText">Favor the use of the following parameters when binding packages:<A NAME="ch13index327"></A><A NAME="ch13index328"></A><A NAME="ch13index329"></A><A NAME="ch13index330"></A></P>
<pre>

</pre><BR><pre>
ISOLATION (CS)

VALIDATE (BIND)

ACTION (REPLACE)

SQLERROR (NOPACKAGE)

FLAG (I)

RELEASE (COMMIT)

DEGREE (1)

CURRENTDATA (NO)

EXPLAIN (YES)
</pre><BR>
<P class="docText">These <TT>BIND PACKAGE</TT> parameters usually produce the most efficient and effective DB2 package. Once again, one set of <TT>BIND</TT> parameters will <span class="docEmphStrong">not</span> be applicable for every DB2 application program. Other guidelines in this chapter cover the occasions when you should choose different options.</P>
<A NAME="ch13lev4sec33"></A><H4 class="docSection2Title">Take Care When Specifying Isolation Level</H4>
<P class="docText">The <TT>ISOLATION</TT> parameter of the <TT>BIND</TT> command specifies the isolation level of the package or plan. The isolation level determines the mode of page locking implemented by the program as it runs.<A NAME="ch13index331"></A><A NAME="ch13index332"></A><A NAME="ch13index333"></A></P>
<P class="docText">DB2 implements page and row locking at the program execution level, which means that all page or row locks are acquired as needed during the program run. Page or row locks are released when the program issues a <TT>COMMIT</TT> or <TT>ROLLBACK</TT>.</P>
<P class="docText">You can specify the following four isolation levels:</P>
<UL><LI><P class="docList">Cursor stability (<TT>CS</TT>)</P></LI><LI><P class="docList">Repeatable read (<TT>RR</TT>)</P></LI><LI><P class="docList">Read stability (<TT>RS</TT>)</P></LI><LI><P class="docList">Uncommitted read (<TT>UR</TT>)</P></LI></UL>
<P class="docText">They significantly affect how the program processes page locks.</P>
<A NAME="ch13lev4sec34"></A><H4 class="docSection2Title">Use Uncommitted Read with Caution</H4>
<P class="docText">Anyone accustomed to application programming when access to a database is required understands the potential for concurrency problems. To ensure data integrity when one application program attempts to read data that is in the process of being changed by another, the DBMS must forbid access until the modification is complete. Most DBMS products, DB2 included, use a locking mechanism for all data items being changed. Therefore, when one task is updating data on a page, another task cannot access data (read or update) on that same page until the data modification is complete and committed.<A NAME="ch13index334"></A><A NAME="ch13index335"></A><A NAME="ch13index336"></A><A NAME="ch13index337"></A></P>
<P class="docText">Programs that read DB2 data typically access numerous rows during their execution and are thus quite susceptible to concurrency problems. DB2 provides read-through locks, also know as a <span class="docEmphasis">dirty read</span> or <span class="docEmphasis">uncommitted read</span>, to help overcome concurrency problems. When you're using an uncommitted read, an application program can read data that has been changed but is not yet committed.</P>
<P class="docText">Dirty read capability is implemented at <TT>BIND</TT> time by specifying <TT>ISOLATION(UR)</TT>. Application programs bound using the <TT>UR</TT> isolation level will read data without taking locks. This way, the application program can read data contained in the table as it is being manipulated. Consider the following sequence of events:</P>
<div style="font-weight:bold"><OL class="docList" TYPE="1"><LI><div style="font-weight:normal"><P class="docList">To change a specific value, at 9:00 a.m. a transaction containing the following SQL is executed:</P><pre>

</pre><BR><pre>
UPDATE    DSN8810.EMP
   SET FIRSTNME = '"MICHELLE'"
WHERE     EMPNO = '10020';
</pre><BR><P class="docList">The transaction is a long-running one and continues to execute without issuing a <TT>COMMIT</TT>.</P></div></LI><LI><div style="font-weight:normal"><P class="docList">At 9:01 a.m., a second transaction attempts to <TT>SELECT</TT> the data that was changed, but not committed.</P></div></LI></OL></div>
<P class="docText">If the <TT>UR</TT> isolation level was specified for the second transaction, it would read the changed data even though it had yet to be committed. Obviously, if the program doesn't need to wait to take a lock and merely reads the data in whatever state it happens to be at that moment, the program will execute faster than if it had to wait for locks to be taken and resources to be freed before processing.<A NAME="ch13index338"></A><A NAME="ch13index339"></A></P>
<P class="docText">The implications of reading uncommitted data, however, must be carefully examined before being implemented. Several types of problems can occur. Using the previous example, if the long-running transaction rolled back the <TT>UPDATE</TT> to <TT>EMPNO</TT> '<TT>10020'</TT>, the program using dirty reads may have picked up the wrong name ("<TT>'MICHELLE'</TT>") because it was never committed to the database.<A NAME="ch13index340"></A><A NAME="ch13index341"></A><A NAME="ch13index342"></A><A NAME="ch13index343"></A><A NAME="ch13index344"></A></P>
<P class="docText">Inaccurate column values are not the only problems that can be caused by using<TT>ISOLATION(UR)</TT>. A dirty read can cause duplicate rows to be returned where none exist. Alternatively, a dirty read can cause no rows to be returned when one (or more) actually exists. Additionally, an <TT>ORDER BY</TT> clause does not guarantee that rows will be returned in order if the <TT>UR</TT> isolation level is used. Obviously, these problems must be taken into consideration before using the <TT>UR</TT> isolation level. The following rules apply to <TT>ISOLATION(UR)</TT>:</P>
<UL><LI><P class="docList">The <TT>UR</TT> isolation level applies to read-only operations: <TT>SELECT</TT>, <TT>SELECT INTO</TT>, and <TT>FETCH</TT> from a read-only result table.</P></LI><LI><P class="docList">Any application plan or package bound with an isolation level of <TT>UR</TT> will use uncommitted read functionality for any read-only SQL. Operations contained in the same plan or package that are not read-only will use an isolation level of <TT>CS</TT>.</P></LI><LI><P class="docList">The isolation level defined at the plan or package level during <TT>BIND</TT> or <TT>REBIND</TT> can be overridden as desired for each SQL statement in the program. You can use the <TT>WITH</TT> clause to specify the isolation level for any individual SQL statement, as in the following example:</P><pre>

</pre><BR><pre>
SELECT EMPNO, LASTNAME
FROM   DSN8810.EMP
WITH UR;
</pre><BR><P class="docList">The <TT>WITH</TT> clause is used to allow an isolation level of <TT>RR</TT>, <TT>RS</TT>, <TT>CS</TT>, or <TT>UR</TT> to be used on a statement-by-statement basis. The <TT>UR</TT> isolation level can be used only with read-only SQL statements. This includes read-only cursors and <TT>SELECT INTO</TT> statements. The <TT>CS</TT>, <TT>RR</TT>, and <TT>RS</TT> isolation levels can be specified for <TT>SELECT</TT>, <TT>INSERT</TT>, <TT>UPDATE</TT>, and <TT>DELETE</TT> statements. The <TT>WITH</TT> clause, however, cannot be used with subselects.</P></LI><LI><P class="docList">DB2 will not choose <TT>UR</TT> isolation with an access path that uses a Type-1 index. If the plan or package is rebound to change to <TT>UR</TT> isolation, DB2 will not consider any access paths that use a Type-1 index. If an acceptable Type-2 index cannot be found, DB2 will choose a table scan. This applies only to DB2 V5 and older subsystems because Type 2 indexes are the only type of indexes supported as of DB2 V6.</P></LI></UL>
<P class="docText">When is it appropriate to use <TT>UR</TT> isolation? The general rule of thumb is to avoid <TT>UR</TT> whenever the results must be 100% accurate. Following are examples of when this would be true:<A NAME="ch13index345"></A><A NAME="ch13index346"></A><A NAME="ch13index347"></A><A NAME="ch13index348"></A></P>
<UL><LI><P class="docList">Calculations that must balance are being performed on the selected data</P></LI><LI><P class="docList">Data is being retrieved from one source to insert into or update another</P></LI><LI><P class="docList">Production, mission-critical work is being performed that cannot contain or cause data integrity problems<A NAME="ch13index349"></A><A NAME="ch13index350"></A><A NAME="ch13index351"></A></P></LI></UL>
<P class="docText">In general, most current DB2 applications will not be candidates for dirty reads. In a few specific situations, however, the dirty read capability will be of major benefit. Consider the following cases in which the <TT>UR</TT> isolation level could prove to be useful:<A NAME="ch13index352"></A><A NAME="ch13index353"></A></P>
<UL><LI><P class="docList">Access is required to a reference, code, or look-up table that basically is static in nature. Due to the non-volatile nature of the data, a dirty read would be no different from a normal read the majority of the time. In those cases when the code data is being modified, any application reading the data would incur minimum, if any, problems.</P></LI><LI><P class="docList">Statistical processing must be performed on a large amount of data. Your company, for example, might want to determine the average age of female employees within a certain pay range. The impact of an uncommitted read on an average of multiple rows will be minimal because a single value changed will not greatly impact the result.</P></LI><LI><P class="docList">Dirty reads can prove invaluable in a data warehousing environment that uses DB2 as the DBMS. A data warehouse is a time-sensitive, subject-oriented, store of business data that is used for online analytical processing. Other than periodic data propagation and/or replication, access to the data warehouse is read-only. Because the data is generally not changing, an uncommitted read is perfect in a read-only environment due to the fact that it can cause little damage. More data warehouse projects are being implemented in corporations worldwide and DB2 with dirty read capability is a very wise choice for data warehouse implementation.</P></LI><LI><P class="docList">In those rare cases when a table, or set of tables, is used by a single user only, <TT>UR</TT> can make a lot of sense. If only one individual can be modifying the data, the application programs can be coded such that all (or most) reads are done using <TT>UR</TT> isolation level, and the data will still be accurate.</P></LI><LI><P class="docList">Finally, if the data being accessed already is inconsistent, little harm can be done using a dirty read to access the information.<A NAME="ch13index354"></A><A NAME="ch13index355"></A><A NAME="ch13index356"></A><A NAME="ch13index357"></A><A NAME="ch13index358"></A><A NAME="ch13index359"></A><A NAME="ch13index360"></A></P></LI></UL>
<A NAME="ch13note12"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Although the dirty read capability can provide relief of concurrency problems and deliver faster performance in specific situations, it also can cause data integrity problems and inaccurate results. Be sure to understand the implications of the <TT>UR</TT> isolation level and the problems it can cause before diving headlong into implementing it in your production applications.</P></div><br>
<P class="docText">Sometimes, just ensuring that you are using lock avoidance can deliver better performance and can be a good alternative to dirty read processing. More information on lock avoidance follows later in this chapter.</P>
<A NAME="ch13lev4sec35"></A><H4 class="docSection2Title">Use Caution Before Binding with Repeatable Read <TT>ISOLATION</TT></H4>
<P class="docText">With repeatable read, or <TT>RR</TT>, all page locks are held until they are released by a <TT>COMMIT</TT>. Cursor stability, or <TT>CS</TT>, releases read-only page locks as soon as another page is accessed.<A NAME="ch13index361"></A><A NAME="ch13index362"></A><A NAME="ch13index363"></A></P>
<P class="docText">In most cases, you should specify <TT>CS</TT> to enable the greatest amount of application program concurrency. <TT>RR</TT>, however, is the default isolation level.</P>
<P class="docText">Use the <TT>RR</TT> page locking strategy only when an application program requires consistency in rows that may be accessed twice in one execution of the program, or when an application program requires data integrity that cannot be achieved with <TT>CS</TT>. Programs of this nature are rare.</P>
<P class="docText">For an example of the first reason to use RR page locking, consider a reporting program that scans a table to produce a detail report, and then scans it again to produce a summarized managerial report. If the program is bound using <TT>CS</TT>, the results of the first report might not match the results of the second.<A NAME="ch13index364"></A><A NAME="ch13index365"></A><A NAME="ch13index366"></A></P>
<P class="docText">Suppose that you are reporting the estimated completion dates for project activities. The first report lists every project and the estimated completion date. The second, managerial report lists only the projects with a completion date greater than one year.</P>
<P class="docText">The first report indicates that two activities are scheduled for more than one year. After the first report but before the second, however, an update occurs. A manager realizes that she underestimated the resources required for a project. She invokes a transaction (or uses QMF) to change the estimated completion date of one of her project's activities from 8 months to 14 months. The second report is produced by the same program, but reports 3 activities.</P>
<P class="docText">If the program has used an isolation level of <TT>RR</TT> rather than <TT>CS</TT>, an update between the production of the two reports would not have been allowed because the program would have maintained the locks it held from the generation of the first report.</P>
<P class="docText">For an example of the second reason to use <TT>RR</TT> page locking, consider a program that is looking for pertinent information about employees in the information center and software support departments who make more than $30,000 in base salary. The program opens a cursor based on the following <TT>SELECT</TT> statement:</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, FIRSTNME, LASTNAME,
        WORKDEPT, SALARY
FROM    DSN8810.EMP
WHERE   WORKDEPT IN ('C01', 'E21')
AND     SALARY &gt; 30000;
</pre><BR>
<P class="docText">The program then begins to fetch employee rows. Department <TT>'C01'</TT> is the information center and department <TT>'E21'</TT> is software support. Assume further, as would probably be the case, that the statement uses the <TT>DSN8810.XEMP2</TT> index on the <TT>WORKDEPT</TT> column. An update program that implements employee modifications is running concurrently. The program, for example, handles transfers by moving employees from one department to another, and implements raises by increasing the salary.</P>
<P class="docText">Assume that Sally Kwan, one of your employees, has just been transferred from the information center to software support. Assume further that another information center employee, Heather Nicholls, received a 10% raise. Both of these modifications will be implemented by the update program running concurrently with the report program.<A NAME="ch13index367"></A><A NAME="ch13index368"></A><A NAME="ch13index369"></A></P>
<P class="docText">If the report program were bound with an isolation level of <TT>CS</TT>, the second program could move Sally from <TT>C01</TT> to <TT>E21</TT> after she was reported to be in department <TT>C01</TT> but before the entire report was finished. Thus, she could be reported twice: once as an information center employee and again as a software support employee. Although this circumstance is rare, it can happen with programs that use cursor stability. If the program were bound instead with <TT>RR</TT>, this problem could not happen. The update program probably would not be allowed to run concurrently with a reporting program, however, because it would experience too many locking problems.</P>
<P class="docText">Now consider Heather's dilemma. The raise increases her salary 10%, from $28,420 to $31,262. Her salary now fits the parameters specified in the <TT>WHERE</TT> condition of the SQL statement. Will she be reported? It depends on whether the update occurs before or after the row has been retrieved by the index scan, which is clearly a tenuous situation. Once again, <TT>RR</TT> avoids this problem.</P>
<P class="docText">You might be wondering, "If <TT>CS</TT> has the potential to cause so many problems, why are you recommending its use? Why not trade the performance and concurrency gain of <TT>CS</TT> for the integrity of <TT>RR</TT>?" The answer is simple: The types of problems outlined are rare. The expense of using <TT>RR</TT>, however, is so great in terms of concurrency that the tradeoff between the concurrency expense of <TT>RR</TT> and the efficiency of <TT>CS</TT> usually is not a sound one.<A NAME="ch13index370"></A><A NAME="ch13index371"></A><A NAME="ch13index372"></A></P>
<A NAME="ch13lev4sec36"></A><H4 class="docSection2Title">Consider Read Stability (<TT>RS</TT>) Over Repeatable Read (<TT>RR</TT>)</H4>
<P class="docText">The <TT>RS</TT> isolation level is similar in functionality to the <TT>RR</TT> isolation level. It indicates that a retrieved row or page is locked until the end of the unit of work. No other program can modify the data until the unit of work is complete, but other processes can insert values that might be read by your application if it accesses the row a second time.<A NAME="ch13index373"></A><A NAME="ch13index374"></A><A NAME="ch13index375"></A></P>
<P class="docText">Use read stability only when your program can handle retrieving a different set of rows each time a cursor or singleton <TT>SELECT</TT> is issued. If using read stability, be sure your application is not dependent on having the same number of rows returned each time.</P>
<A NAME="ch13lev4sec37"></A><H4 class="docSection2Title">Favor Acquiring Table Space Locks When the Table Space Is Used</H4>
<P class="docText">In addition to a page locking strategy, every plan also has a table space locking strategy. This strategy is implemented by two bind parameters: <TT>ACQUIRE</TT> and <TT>RELEASE</TT>.<A NAME="ch13index376"></A><A NAME="ch13index377"></A><A NAME="ch13index378"></A><A NAME="ch13index379"></A></P>
<P class="docText">Remember that a page lock is acquired when the page is requested, and is released after a <TT>COMMIT</TT> or a <TT>ROLLBACK</TT>. Table space locking is different. DB2 uses a mixed table space locking strategy—the programmer specifies when to acquire and release table space locks by means of the <TT>ACQUIRE</TT> and <TT>RELEASE</TT> parameters. Table space locking is implemented only at the plan level; it is not implemented at the package level.</P>
<P class="docText">The options for the <TT>ACQUIRE</TT> parameter are <TT>USE</TT> and <TT>ALLOCATE</TT>. When you specify <TT>USE</TT>, table space locks are taken when the table space is accessed. With <TT>ALLOCATE</TT>, table space locks are taken when the plan is first allocated.</P>
<P class="docText">The options for <TT>RELEASE</TT> are <TT>COMMIT</TT> and <TT>DEALLOCATE</TT>. When you specify the <TT>COMMIT</TT> option, locks are released at commit or rollback time. When you specify <TT>DEALLOCATE</TT> all locks are held until the plan finishes and is deallocated.</P>
<P class="docText">In general, use the following table space locking allocation strategy:</P>
<pre>

</pre><BR><pre>
ACQUIRE(USE)
RELEASE(COMMIT)
</pre><BR>
<P class="docText">This provides your program with the highest degree of concurrency.</P>
<P class="docText">When you have conditional table access in your program, consider using the following lock and resource allocation strategy:</P>
<pre>

</pre><BR><pre>
ACQUIRE(USE)
RELEASE(DEALLOCATE)
</pre><BR>
<P class="docText">With conditional table access, every invocation of the program does not cause that section of code to be executed. By specifying that locks will be acquired only when used, and released only when deallocated, you can increase the efficiency of a program because locks, once acquired, are held during the entire course of the program. This does reduce concurrency, however.</P>
<P class="docText">For a batch update program in which you know that you will access every table coded in your program, use the following lock and resource allocation strategy:</P>
<pre>

</pre><BR><pre>
ACQUIRE(ALLOCATE)
RELEASE(DEALLOCATE)
</pre><BR>
<P class="docText">All locks are acquired as soon as possible and are not released until they are absolutely not needed. This strategy, too, will reduce concurrency.</P>
<P class="docText">For high-volume transactions (one or more transactions per second throughput), use a <TT>CICS</TT> protected entry thread (<TT>RCT TYPE=ENTRY</TT>) with the following strategy:</P>
<pre>

</pre><BR><pre>
ACQUIRE(ALLOCATE)
RELEASE(DEALLOCATE)
</pre><BR>
<P class="docText">A high-volume transaction generally executes much faster if it is not bogged down with the accumulation of table space locks.</P>
<P class="docText">In all cases, you should obtain database administration approval before binding with parameters other than <TT>ACQUIRE(USE)</TT> and <TT>RELEASE(COMMIT)</TT>.<A NAME="ch13index380"></A><A NAME="ch13index381"></A><A NAME="ch13index382"></A><A NAME="ch13index383"></A></P>
<A NAME="ch13lev4sec38"></A><H4 class="docSection2Title">Specify Validation at <TT>BIND</TT> Time</H4>
<P class="docText">A validation strategy refers to the method of checking for the existence and validity of DB2 tables and DB2 access authorization. You can use two types of validation strategies: <TT>VALIDATE(BIND)</TT> or <TT>VALIDATE(RUN)</TT>.<A NAME="ch13index384"></A><A NAME="ch13index385"></A><A NAME="ch13index386"></A></P>
<P class="docText"><TT>VALIDATE(BIND)</TT>, the preferred option, validates at bind time. If a table is invalid or proper access authority has not been granted, the bind fails.</P>
<P class="docText"><TT>VALIDATE(RUN)</TT> validates DB2 table and security each time the plan is executed. This capability is useful if a table is changed or authority is granted after the bind is issued. It does, however, impose a potentially severe performance degradation because each SQL statement is validated each time it is executed.</P>
<P class="docText">Always specify <TT>VALIDATE(BIND)</TT> for production plans. Use <TT>VALIDATE(RUN)</TT> only in a testing environment.</P>
<A NAME="ch13lev4sec39"></A><H4 class="docSection2Title">Request All Error Information</H4>
<P class="docText">Always specify <TT>FLAG(I)</TT>, which causes the <TT>BIND</TT> command to return all information, warning, error, and completion messages. This option provides the greatest amount of information pertaining to the success or failure of the bind.<A NAME="ch13index387"></A><A NAME="ch13index388"></A><A NAME="ch13index389"></A></P>
<A NAME="ch13lev4sec40"></A><H4 class="docSection2Title">Specify an Appropriate <TT>CACHESIZE</TT></H4>
<P class="docText">The <TT>CACHESIZE</TT> parameter specifies the size of the authorization cache for a plan. The authorization cache is a portion of memory set aside for a plan to store valid authids that can execute the plan. By storing the authids in memory, the cost of I/O can be saved.<A NAME="ch13index390"></A><A NAME="ch13index391"></A><A NAME="ch13index392"></A><A NAME="ch13index393"></A><A NAME="ch13index394"></A><A NAME="ch13index395"></A></P>
<P class="docText">The cache can vary in size from 0 to 4096 bytes in 256 byte increments. For a plan with a small number of users, specify the minimum size, 256. If the plan will have large number of users, calculate the appropriate size as follows:</P>
<pre>

</pre><BR><pre>
CACHESIZE = ( [number of concurrent users] * 8 ) + 32
</pre><BR>
<P class="docText">Take the number returned by the formula and round up to the next 256 byte increment making sure not to exceed 4096.</P>
<A NAME="ch13note13"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">The number 32 is added because the authid cache always uses 32 control bytes.</P></div><br>
<P class="docText">One final suggestion—if the plan is executed only infrequently, or has been granted to <TT>PUBLIC</TT>, do not cache authids. Specify a <TT>CACHESIZE</TT> of zero.</P>
<P class="docText">As of DB2 V5, authorization can be cached for packages as well as plans. However, no <TT>CACHESIZE BIND</TT> parameter is available for packages. Instead, package caching must be enabled by the system administrator at the subsystem level.</P>
<A NAME="ch13lev4sec41"></A><H4 class="docSection2Title">Consider Using <TT>CURRENTDATA(NO)</TT> for Lock Avoidance</H4>
<P class="docText">DB2 uses the lock avoidance technique to reduce the number of locks that need to be taken for read only processes. To enable lock avoidance for read only and ambiguous cursors, <TT>NO</TT> must be specified for the <TT>CURRENTDATA</TT> option. Unfortunately, <TT>YES</TT> is the default. By specifying <TT>CURRENTDATA(NO)</TT> you indicate that currency is not required for cursors that are read only or ambiguous.<A NAME="ch13index396"></A><A NAME="ch13index397"></A><A NAME="ch13index398"></A></P>
<P class="docText">Do not use <TT>CURRENTDATA(NO)</TT> if your program dynamically prepares and executes a <TT>DELETE WHERE CURRENT OF</TT> statement against an ambiguous cursor after that cursor is opened. DB2 returns a negative <TT>SQLCODE</TT> to the program if it attempts a <TT>DELETE WHERE CURRENT OF</TT> statement for any of the following cursors:</P>
<UL><LI><P class="docList">Cursor uses block fetching</P></LI><LI><P class="docList">Cursor uses query parallelism</P></LI><LI><P class="docList">Cursor that is positioned on a row that is modified by this or another application process</P></LI></UL>
<A NAME="ch13note14"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">For local access, <TT>CURRENTDATA(YES)</TT> means that the data cannot change while the cursor is positioned on it. <TT>CURRENTDATA(NO)</TT> is similar to <TT>CURRENTDATA(YES)</TT> except when a cursor is accessing a base table rather than a result table in a work file. With <TT>CURRENTDATA(YES)</TT>, DB2 can guarantee that the cursor and the base table are current, whereas <TT>CURRENTDATA(NO)</TT> does not.</P>
<P class="docText">For remote access, <TT>CURRENTDATA(YES)</TT> turns off block fetching for ambiguous cursors. The data returned with the cursor is current with the contents of the remote table or index for ambiguous cursors.</P></div><br>
<A NAME="ch13lev4sec42"></A><H4 class="docSection2Title">Consider Using <TT>DEGREE(ANY)</TT> for Parallelism</H4>
<P class="docText">When <TT>DEGREE(ANY)</TT> is specified, DB2 will attempt to execute queries using parallel engines whenever possible. Parallel queries are typically deployed against partitioned table spaces, and can be used to access non-partitioned table spaces when specified in a join with at least one partitioned table space.<A NAME="ch13index399"></A><A NAME="ch13index400"></A><A NAME="ch13index401"></A><A NAME="ch13index402"></A></P>
<P class="docText">At optimization time, DB2 can be directed to consider parallelism by specifying <TT>DEGREE(ANY)</TT> at <TT>BIND</TT> time for packages and plan. Following are the three types of parallelism:</P>
<UL><LI><p class="docText">
<span class="docEmphRoman">I/O</span>— 
multiple read engines</p></LI><LI><p class="docText">
<span class="docEmphRoman">CPU</span>— 
multiple processor and multiple read engines</p></LI><LI><p class="docText">
<span class="docEmphRoman">Sysplex</span>— 
multiple data sharing subsystems</p></LI></UL>
<P class="docText">Parallelism can significantly enhance the performance of queries against partitioned table spaces. By executing in parallel, elapsed time usually will decrease, even if CPU time does not. This results in an overall perceived performance gain because the same amount of work will be accomplished in less clock time.</P>
<P class="docText">Following are the types of queries that will benefit most from I/O parallelism:</P>
<UL><LI><P class="docList">Access large amount of data, but return only a few rows</P></LI><LI><P class="docList">Use column functions (<TT>AVG</TT>, <TT>COUNT</TT>, <TT>COUNT_BIG</TT>, <TT>MIN</TT>, <TT>MAX</TT>, <TT>STDDEV</TT>, <TT>SUM</TT>, <TT>VARIANCE</TT>)</P></LI><LI><P class="docList">Access long rows</P></LI></UL>
<P class="docText">CPU parallelism extends the capabilities of I/O parallelism. When CPU parallelism is invoked, it is always used in conjunction with I/O parallelism. The reverse of this is not necessarily true. Most of the queries that benefit from I/O parallelism also will benefit from CPU parallelism because as the I/O bottlenecks are reduced, the CPU bottlenecks become more apparent.<A NAME="ch13index403"></A><A NAME="ch13index404"></A><A NAME="ch13index405"></A><A NAME="ch13index406"></A></P>
<P class="docText">Sysplex parallelism extends the parallel capabilities of DB2 even further. When Sysplex parallelism is employed, DB2 can spread a single query across multiple central processor complexes within a data sharing group. For more information on data sharing and Sysplex parallelism, refer to <A class="docLink" HREF="ch19.html#ch19">Chapter 19</A>, "Data Sharing."<A NAME="ch13index407"></A><A NAME="ch13index408"></A></P>
<A NAME="ch13note15"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Before attempting to achieve parallel query operations using <TT>DEGREE(ANY)</TT>, be sure that your environment is suitable for parallelism. Do you have enough memory and the proper buffer pool configurations to take advantage of parallelism? Is the machine on which you are running your queries capable of parallelism? For example, a machine without multiple CPUs will not be able to run CPU parallelism.</P></div><br>
<P class="docText">You can use the <TT>PARAMDEG</TT> DSNZPARM to specify the maximum degree of parallelism for a parallel group. By specifying a maximum value DB2 is limited to the <TT>PARAMDEG</TT> value as the maximum degree of parallelism. This parameter can be used to throttle DB2 so that it does not create too many parallel tasks and therefore use too much virtual storage.<A NAME="ch13index409"></A><A NAME="ch13index410"></A><A NAME="ch13index411"></A><A NAME="ch13index412"></A></P>
<A NAME="ch13lev4sec43"></A><H4 class="docSection2Title">Specify <TT>NODEFER(PREPARE)</TT></H4>
<P class="docText">Specify <TT>NODEFER(PREPARE)</TT> rather than <TT>DEFER(PREPARE)</TT> unless your program contains SQL statements that access DB2 tables at a remote location and are executed more than once during the program's invocation. In this case, specifying <TT>DEFER(PREPARE)</TT> can reduce the amount of message traffic by preparing each SQL statement only once at the remote location, when it is first accessed. Subsequent execution of the same statement in the same unit of recovery does not require an additional <TT>PREPARE</TT>.</P>
<A NAME="ch13lev4sec44"></A><H4 class="docSection2Title">Use <TT>SQLERROR</TT> to Control Package Creation</H4>
<P class="docText">Two options for the <TT>SQLERROR</TT> parameter exist: <TT>NOPACKAGE</TT> and <TT>CONTINUE</TT>. <TT>NOPACKAGE</TT> is the recommended option when not operating in a distributed environment. By specifying <TT>NOPACKAGE</TT>, a package will not be created when an SQL error is encountered.<A NAME="ch13index413"></A><A NAME="ch13index414"></A><A NAME="ch13index415"></A><A NAME="ch13index416"></A><A NAME="ch13index417"></A></P>
<P class="docText">The other option is <TT>CONTINUE</TT>, which will create a package even if an error is encountered. Because SQL syntax varies from environment to environment, <TT>CONTINUE</TT> is a viable option when operating in a distributed environment. The package can be created, regardless of the error with the understanding that the SQL will function properly at the remote location.</P>
<A NAME="ch13lev4sec45"></A><H4 class="docSection2Title">Specify <TT>EXPLAIN(YES)</TT> for Production <TT>BIND</TT>s</H4>
<P class="docText">At a minimum, all production <TT>BIND</TT>s should be performed with the <TT>EXPLAIN(YES)</TT> option. This allows the proper monitoring of the production access path selection made by DB2. Binding without producing <TT>EXPLAIN</TT> output will hamper your performance tuning abilities, because you will not be able to determine the access paths chosen by DB2 without the <TT>EXPLAIN</TT> data.<A NAME="ch13index418"></A><A NAME="ch13index419"></A><A NAME="ch13index420"></A><A NAME="ch13index421"></A></P>
<P class="docText">Of course, in a testing environment you will not need to specify <TT>EXPLAIN(YES)</TT> for every single <TT>BIND</TT>. This is especially the case at the beginning of the development process. However, you should consider specifying <TT>EXPLAIN(YES)</TT> even in a test environment once your development efforts are significantly underway. By binding your test programs using <TT>EXPLAIN(YES)</TT>, you will have access path information at your disposal for your tuning efforts.</P>
<A NAME="ch13note16"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">You will not necessarily assure efficient production access paths just because you achieve desirable access paths in your test environment. The only way to assure that access paths are the same in both test and production is to be sure that <span class="docEmphStrong">everything</span> about the two environments are the same: statistics, system parameters, memory, and so on.</P></div><br>
<A NAME="ch13lev4sec46"></A><H4 class="docSection2Title">Use the <TT>ENABLE</TT> and <TT>DISABLE</TT> Parameters Effectively</H4>
<P class="docText">You can use the <TT>ENABLE</TT> and <TT>DISABLE</TT> bind options to control the environment in which the plan or package being bound can be executed. <TT>ENABLE</TT> ensures that the plan or package operates in only the enabled environments. <TT>DISABLE</TT> permits execution of the plan or package by all subsystems except those explicitly disabled. <TT>ENABLE</TT> and <TT>DISABLE</TT> are mutually exclusive parameters (only one can be used per package or plan).<A NAME="ch13index422"></A><A NAME="ch13index423"></A><A NAME="ch13index424"></A><A NAME="ch13index425"></A><A NAME="ch13index426"></A><A NAME="ch13index427"></A></P>
<P class="docText">If a plan is bound specifying <TT>ENABLE(IMS)</TT>, for example, only the IMS subsystem is permitted to execute the plan. If a plan is bound with the <TT>DISABLE(CICS)</TT> option, the CICS subsystem is not permitted to execute this plan.</P>
<P class="docText">Be careful when using <TT>ENABLE</TT> and <TT>DISABLE</TT> because they may function differently than one might originally think. <TT>ENABLE</TT> explicitly enables an environment for execution. The enabled environment, however, is the only environment that can execute the plan or package. So <TT>ENABLE</TT> limits the environments in which a package or plan can execute. By contrast, specifying <TT>DISABLE</TT> actually is more open because only one specific area is disabled, thereby implicitly enabling everything else. The bottom line is that <TT>ENABLE</TT> is more limiting than <TT>DISABLE</TT>.</P>
<P class="docText"><A class="docLink" HREF="#ch13table01">Table 13.1</A> shows valid <TT>ENABLE</TT> and <TT>DISABLE</TT> specifications.</P>
<A NAME="ch13table01"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 13.1. Environments that Can Be Enabled or Disabled</h5></CAPTION><COLGROUP><COL width="236.5"><COL width="313.5"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Specification</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Package or plan is executed only</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BATCH</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">As a batch job</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DLIBATCH</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">As an IMS batch job</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DB2CALL</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">With the Call Attach Facility</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CICS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Online through CICS</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>IMS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Under the control of IMS</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>IMSBMP</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">As an IMS BMP (batch message processor)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>IMSMPP</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">As an online IMS message processing program (that is, a transaction)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>RRSAF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">With the RRS Attachment Facility</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>REMOTE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">As a remote program</P></TD></TR></TABLE></P><br>
<P class="docText"><TT>ENABLE</TT> and <TT>DISABLE</TT> are great keywords to consider for plans granted to <TT>PUBLIC</TT> that rely on an external security mechanism (such as RACF) to control unauthorized access.<A NAME="ch13index431"></A><A NAME="ch13index432"></A><A NAME="ch13index433"></A><A NAME="ch13index434"></A><A NAME="ch13index435"></A><A NAME="ch13index436"></A></P>
<A NAME="ch13lev4sec47"></A><H4 class="docSection2Title">Retain Security When <TT>BIND</TT>ing Existing Plans</H4>
<P class="docText">Be sure to specify the <TT>RETAIN</TT> parameter for existing plans. <TT>RETAIN</TT> indicates that all <TT>BIND</TT> and <TT>EXECUTE</TT> authority granted for this plan will be retained. If you fail to specify the <TT>RETAIN</TT> parameter, all authority for the plan is revoked.<A NAME="ch13index437"></A><A NAME="ch13index438"></A><A NAME="ch13index439"></A><A NAME="ch13index440"></A></P>
<A NAME="ch13lev4sec48"></A><H4 class="docSection2Title">Retain DBRMs Bound in Plans</H4>
<P class="docText">Develop a consistent scheme for the maintenance and retention of DBRMs bound to application plans and packages. Ensure that DBRMs are copied to the appropriate library (test, education, production, and so on) before the binding of plans in the new environment. This applies to both new and modified programs.<A NAME="ch13index441"></A><A NAME="ch13index442"></A><A NAME="ch13index443"></A></P>
<A NAME="ch13lev4sec49"></A><H4 class="docSection2Title">Consider Dynamic Reoptimization</H4>
<P class="docText">When host variables or parameter markers are used in SQL statements in an application program, DB2 does not know the values that will be supplied at execution time. This lack of information causes DB2 to guess at the best access path using the information available at <TT>BIND</TT> time.<A NAME="ch13index444"></A><A NAME="ch13index445"></A><A NAME="ch13index446"></A><A NAME="ch13index447"></A></P>
<P class="docText">By specifying the <TT>BIND</TT> parameter <TT>REOPT(VARS)</TT>, DB2 will reevaluate the access path at runtime when the host variable and parameter marker values are known. This should result in a better-formulated access path. Reoptimization, however, is not a panacea. Because DB2 must reevaluate access paths at execution time, additional overhead will be consumed. This overhead can negate any performance gains achieved by the new access paths. Enabling reoptimization does not guarantee a different access path; it only allows DB2 to formulate the access path based on the runtime values used.</P>
<P class="docText">In general, reoptimization can be an easy-to-implement alternative to dynamic SQL. The overhead of reoptimization will be less than that associated with dynamic SQL because reoptimization does not require statement parsing, authorization checking, dependency checking, or table decomposition.</P>
<A NAME="ch13lev4sec50"></A><H4 class="docSection2Title">Do Not Blindly Enable Reoptimization for All Programs</H4>
<P class="docText">In general, consider specifying <TT>REOPT(VARS)</TT> in the following situations:<A NAME="ch13index448"></A><A NAME="ch13index449"></A><A NAME="ch13index450"></A></P>
<UL><LI><P class="docList">Application programs in which multiple SQL statements utilize host variables (or parameter markers)</P></LI><LI><P class="docList">SQL statements in which host variables (or parameter markers) are deployed against columns with very skewed distribution statistics</P></LI><LI><P class="docList">Application programs in which dynamic SQL was considered, but avoided because of its complexity or overhead</P></LI></UL>
<P class="docText">Before implementing reoptimization, conduct performance tests to determine its impact on transaction performance.</P>
<A NAME="ch13lev4sec51"></A><H4 class="docSection2Title">Consider Isolating Reoptimized Statements</H4>
<P class="docText">The <TT>REOPT</TT> and <TT>NOREOPT</TT> parameters must be specified for an entire program when it is bound into a plan or package. Most programs commonly contain multiple SQL statements, not all of which will benefit from reoptimization.<A NAME="ch13index451"></A><A NAME="ch13index452"></A><A NAME="ch13index453"></A></P>
<P class="docText">Consider isolating specific SQL statements into a separate program, and binding it into a package. In this manner, individual SQL statements can be set for reoptimization without impacting the rest of the SQL in a program.</P>
<A NAME="ch13lev4sec52"></A><H4 class="docSection2Title">Consider Keeping Prepared Statements Past <TT>COMMIT</TT></H4>
<P class="docText">By specifying <TT>KEEPDYNAMIC(YES)</TT>, dynamic SQL statements can be held past a <TT>COMMIT</TT> point. Specify <TT>KEEPDYNAMIC(YES)</TT> for dynamic SQL programs in DB2 subsystems in which the dynamic SQL prepare cache is enabled. This causes fewer dynamic binds and optimizes the performance of dynamic SQL programs.<A NAME="ch13index454"></A><A NAME="ch13index455"></A><A NAME="ch13index456"></A><A NAME="ch13index457"></A></P>
<P class="docText">Note that when <TT>KEEPDYNAMIC(YES)</TT> is specified, you also must use <TT>NOREOPT(VARS)</TT>.</P>
<A NAME="ch13lev4sec53"></A><H4 class="docSection2Title">Specify the <TT>PATH</TT> Parameter</H4>
<P class="docText">If UDTs, UDFs, or stored procedures are used in your program, be sure to specify the appropriate <TT>PATH</TT> parameter. The <TT>PATH</TT> identifies the schema names in the SQL path to be used for function resolution. Refer to <A class="docLink" HREF="ch04.html#ch04">Chapter 4</A> for more information on UDFs and UDTs and <A class="docLink" HREF="ch15.html#ch15">Chapter 15</A>, "Using DB2 Stored Procedures," for more information on stored procedures.<A NAME="ch13index458"></A><A NAME="ch13index459"></A><A NAME="ch13index460"></A><A NAME="ch13index461"></A></P>
<P class="docText">You can specify a SQL <TT>PATH</TT> of up to 254 bytes in length. To determine the length of the SQL path, use the following calculation:</P>
<pre>

</pre><BR><pre>
  length of each schema name
+ (2 * total number of names) <span class="docEmphasis">(for delimiters)</span>
+ (total number of names – 1) <span class="docEmphasis">(for commas)</span>
</pre><BR>
<P class="docText">For example, consider the following SQL path definition</P>
<pre>

</pre><BR><pre>
SQLPATH('SCHEMA21', 'SCHZ', 'SYSPROC')
</pre><BR>
<P class="docText">The length of this SQL path would be calculated as follows:</P>
<BLOCKQUOTE><P><P class="docList">The length of each schema name added together: (8 + 4 + 7) = 19</P></P><P><P class="docList">Total number of schema names times two: (3 * 2) = 6</P></P><P><P class="docList">Total number of schema names minus one: (3 – 1) = 2</P></P><P><P class="docList">Added together is 19 + 6 + 2 = 27</P></P></BLOCKQUOTE>
<A NAME="ch13note17"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Be sure to specify the schema names in uppercase in the <TT>PATH</TT> definition.</P></div><br>
<A NAME="ch13lev4sec54"></A><H4 class="docSection2Title">Specify the Appropriate <TT>DYNAMICRULES</TT> Option for Dynamic SQL</H4>
<P class="docText">The <TT>DYNAMICRULES</TT> parameter determines the characteristics of dynamic SQL. There are four types of behavior that dynamic SQL can exhibit:<A NAME="ch13index462"></A><A NAME="ch13index463"></A><A NAME="ch13index464"></A><A NAME="ch13index465"></A></P>
<UL><LI><P class="docList"><TT>BIND</TT> behavior</P></LI><LI><P class="docList"><TT>DEFINE</TT> behavior</P></LI><LI><P class="docList"><TT>INVOKE</TT> behavior</P></LI><LI><P class="docList"><TT>RUN</TT> behavior</P></LI></UL>
<P class="docText">The following are the six options for the <TT>DYNAMICRULES</TT> parameter:</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5"><COLGROUP><COL width="247.5"><COL width="302.5"></COLGROUP><THEAD></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DYNAMICRULES(RUN)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Dynamic SQL statements are processed using run behavior. Run behavior means that DB2 uses the authid of the running application and the SQL authid of the <TT>CURRENT SQLID</TT> special register for authorization checking for dynamic SQL statements. Furthermore, the <TT>CURRENT SQLID</TT> is used as the qualifier for unqualified table, view, and alias names. When bound with this option, the program can issue dynamic DCL (<TT>GRANT</TT> and <TT>REVOKE</TT>) or dynamic DDL (<TT>ALTER</TT>, <TT>CREATE</TT>, <TT>DROP</TT>, and <TT>RENAME</TT>). Run behavior is the only behavior that permits dynamic DCL and DDL.</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DYNAMICRULES(BIND)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Dynamic SQL statements are processed using bind behavior. Bind behavior means that DB2 uses the authid of the plan or package for dynamic SQL authorization checking. The<TT>QUALIFIER</TT> value of the <TT>BIND</TT> is used as the qualifier for unqualified table, view, and alias names. If <TT>QUALIFIER</TT> is not specified, the authid of the plan or package owner is used to qualify table objects.</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DYNAMICRULES(DEFINEBIND)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Dynamic SQL statements are processed using define or bind behavior. When the package is run as a standalone DB2 program, it uses bind behavior as described previously for <TT>DYNAMICRULES(BIND)</TT>. When the package is run as a stored procedure or UDF, DB2 processes dynamic SQL statements using define behavior. Define behavior means that DB2 uses the authid of the UDF or stored procedure owner for dynamic SQL authorization checking. The owner of the UDF or stored procedure is used as the qualifier for unqualified table, view, and alias names.<A NAME="ch13index466"></A><A NAME="ch13index467"></A><A NAME="ch13index468"></A><A NAME="ch13index469"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DYNAMICRULES(DEFINERUN)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Dynamic SQL statements are processed using define or run behavior. When the package is run as a standalone DB2 program, it uses run behavior as described previously for <TT>DYNAMICRULES(RUN)</TT>. When the package is run as a stored procedure or UDF, DB2 processes dynamic SQL statements using define behavior, as described under <TT>DYNAMICRULES(DEFINEBIND)</TT>.</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DYNAMICRULES(INVOKEBIND)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Dynamic SQL statements are processed using invoke or bind behavior. When the package is run as a standalone DB2 program, it uses bind behavior as described previously for <TT>DYNAMICRULES(BIND)</TT>. When the package is run as a stored procedure or UDF, DB2 processes dynamic SQL statements using invoke behavior. Invoke behavior means that DB2 uses the authid of the UDF or stored procedure invoker for dynamic SQL authorization checking. The invoker of the UDF or stored procedure is to qualify any unqualified table, view, and alias names.</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DYNAMICRULES(INVOKERUN)</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Dynamic SQL statements are processed using invoke or run behavior. When the package is run as a standalone DB2 program, it uses run behavior as described previously for <TT>DYNAMICRULES(RUN)</TT>. When the package is run as a stored procedure or UDF, DB2 processes dynamic SQL statements using invoke behavior, as described under <TT>DYNAMICRULES(INVOKEBIND)</TT>.<A NAME="ch13index470"></A><A NAME="ch13index471"></A><A NAME="ch13index472"></A><A NAME="ch13index473"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch13lev4sec55"></A><H4 class="docSection2Title">Use <TT>OPTHINT</TT> to Change Access Paths</H4>
<P class="docText">The <TT>OPTHINT</TT> parameter can be used "tell" DB2 what access paths to use for the plan or package. This information is conveyed to DB2 using rows in a <TT>PLAN_TABLE</TT>. For more information on optimizer hints, refer to <A class="docLink" HREF="ch21.html#ch21">Chapter 21</A>.<A NAME="ch13index474"></A><A NAME="ch13index475"></A><A NAME="ch13index476"></A><A NAME="ch13index477"></A><A NAME="ch13index478"></A><A NAME="ch13index479"></A></P>
<A NAME="ch13lev4sec56"></A><H4 class="docSection2Title">Consider the <TT>IMMEDWRITE</TT> Parameter for Data Sharing</H4>
<P class="docText">The <TT>IMMEDWRITE</TT> parameter indicates whether immediate writes will be done for updates made to group buffer pool dependent page sets or partitions. This option applies to data sharing environments only. <A NAME="ch13index480"></A><A NAME="ch13index481"></A><A NAME="ch13index482"></A><A NAME="ch13index483"></A><A NAME="ch13index484"></A><A NAME="ch13index485"></A></P>
<P class="docText">An immediate write means that the page is written to the group buffer pool (or to DASD for <TT>GBPCACHE NO</TT> group buffer pools or <TT>GBPCACHE NONE</TT> or <TT>SYSTEM</TT> page sets) as soon as the buffer update completes. To enable immediate write, specify <TT>IMMEDWRITE(YES)</TT>.</P>
<P class="docText">Consider specifying <TT>IMMEDWRITE(YES)</TT> when one transaction can spawn another transaction that can run on another DB2 member, and the spawned transaction depends on uncommitted updates made by the original transaction. With immediate writes, the original transaction can write the updated data immediately to the group bufferpool-dependent buffers to ensure that the spawned transaction retrieves the correct, updated data.</P>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch13lev1sec12.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch13lev1sec14.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
