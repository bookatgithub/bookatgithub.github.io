<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Using Java and DB2</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch14lev1sec6.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch14lev1sec8.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch14lev1sec7"></A><H3 class="docSection1Title" >Using Java and DB2</H3>
<P class="docText">Java is another alternative programming technique. It is an increasingly popular choice for DB2 application development. Just about everybody has at least heard of Java. But just because you've heard about it doesn't mean you understand it. Even if you know a bit about it, there is always more to discover. Let's face it, there's a lot of hype out there regarding anything that concerns the Internet. Now that DB2 for z/OS fully supports Java, Java usage will continue to increase. So, let's learn a bit about Java.<A NAME="ch14index209"></A><A NAME="ch14index210"></A></P>
<A NAME="ch14lev2sec8"></A><H4 class="docSection2Title">What Is Java?</H4>
<P class="docText">First and foremost, Java is an object-oriented programming language. Developed by Sun Microsystems in 1991, Java was modeled after, and most closely resembles C++. But Java requires a smaller footprint and eliminates some of the more complex and error-prone features of C and C++ (such as pointer management and the <TT>go to</TT> construct). Additionally, many tasks have been moved from the language itself to the JVM (Java Virtual Machine).<A NAME="ch14index211"></A><A NAME="ch14index212"></A></P>
<P class="docText">Java enables animation for and interaction with the World Wide Web. Although Web interaction is Java's most touted feature, it is a fully functional programming language that can be used for developing general-purpose programs independent from the Web.</P>
<P class="docText">Using HTML, developers can run Java programs, called applets, over the Web. But Java is a completely different language from HTML, and it does not replace HTML. Java applets are automatically downloaded and executed by users as they surf the Web. The Java applet is run by the Web browser.<A NAME="ch14index213"></A><A NAME="ch14index214"></A><A NAME="ch14index215"></A></P>
<P class="docText">What makes Java special is that it was designed to be multi-platform. In theory, regardless of the machine and operating system you are running, any Java program should be able to run. Many possible benefits accrue because Java enables developers to write an application once and then distribute it to be run on any platform. Benefits can include reduced development and maintenance costs, lower systems management costs, and more flexible hardware and software configurations.</P>
<P class="docText">So, to summarize, the major qualities of Java are</P>
<UL><LI><P class="docList">It is similar to other popular languages.</P></LI><LI><P class="docList">It can enable Web interaction.</P></LI><LI><P class="docList">It can enable executable Web content.</P></LI><LI><P class="docList">It can run on multiple platforms.</P></LI></UL>
<P class="docText">Now that DB2 for z/OS supports application development using Java, all of these qualities are available to DB2 applications.<A NAME="ch14index216"></A><A NAME="ch14index217"></A></P>
<A NAME="ch14lev3sec1"></A><H5 class="docSection3Title">Java Bytecodes and the Java Virtual Machine</H5>
<P class="docText">After a Java program is written, the source code is compiled into machine-independent constructs called <span class="docEmphasis">bytecodes</span> using the Java compiler. Bytecodes are the manner in which Java achieves its platform independence. Because the Java bytecode is in a machine-independent, architecture-neutral format, it can run on any system with a standard Java implementation.<A NAME="ch14index218"></A><A NAME="ch14index219"></A><A NAME="ch14index220"></A></P>
<P class="docText">The Java bytecodes are then processed by the Java Virtual Machine (JVM). The JVM interprets the bytecodes for the platform on which the Java program is to be run. The JVM loads and verifies the Java bytecode. It is then passed to the Java interpreter to be executed. Alternatively, the bytecodes can be passed to a just-in-time (JIT) compiler to be compiled into machine code to be executed.<A NAME="ch14index221"></A><A NAME="ch14index222"></A><A NAME="ch14index223"></A><A NAME="ch14index224"></A></P>
<A NAME="ch14note06"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Java has a reputation as a "slow" language. That is, the performance of Java is questionable. The major disadvantage is that Java is an interpretive language. Both the Java interpreter and the JIT compiler consume resources and take time to process the Java bytecodes before execution.</P>
<P class="docText">The performance of a Java program will pale in comparison to a program compiled and link-edited into object code (such as a COBOL program). As a developer, you must decide whether the platform independence and Web development capabilities offset the potential for performance degradation.</P></div><br>
<A NAME="ch14lev3sec2"></A><H5 class="docSection3Title">Java Applications, Applets, and Servlets</H5>
<P class="docText">There are three types of Java implementation methods that you can implement when accessing DB2 data from Java—Java applications, applets, and servlets.</P>
<P class="docText">A <span class="docEmphasis">Java application</span> program is basically the same as a program written in any other programming language. It can perform all of the tasks normally associated with programs, including many tasks that Java applets cannot perform. Furthermore, a Java application does not need a browser to be executed. It can be executed in a client or server machine.<A NAME="ch14index225"></A><A NAME="ch14index226"></A><A NAME="ch14index227"></A></P>
<P class="docText">A <span class="docEmphasis">Java applet</span> is a small application program that must be downloaded before it is run within a Java-enabled Web browser. Java applets reside on a Web server. When the Web server returns an HTML page that points to a Java applet, the Java-enabled Web browser requests the applet to be downloaded from the Web server. After the applet is received at the browser, either the browser starts the applet internally, or an external JVM executes it.<A NAME="ch14index228"></A><A NAME="ch14index229"></A><A NAME="ch14index230"></A></P>
<P class="docText">Applets typically perform simple operations, such as editing input data, control screen interaction, and other client functionality. Of course, Java applets can be written to perform more complex functionality, but to load and run non-Java code in the client requires signed applets, which have the authority needed to run code in the client machine.</P>
<A NAME="ch14note07"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">You should be aware of the performance implications of the requirement for Java applets to be downloaded before they can be run. In general, Java applets are small, so the performance impact should be negligible. Additionally, Java applets can be cached by the Web browser, further diminishing the performance impact.</P></div><br>
<P class="docText">A <span class="docEmphasis">Java servlet</span> is basically server-side Java. A Java servlet runs on the Web server, just like an applet runs in the Web browser. Java servlets can be used to extend the functionality of the Web server. The Web server hands requests to the servlet, which replies to them. Servlets can be used instead of CGI applications.<A NAME="ch14index231"></A><A NAME="ch14index232"></A><A NAME="ch14index233"></A></P>
<A NAME="ch14note08"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">To run Java servlets, your Web server must support the Java servlet API, developed by JavaSoft. This API defines how the servlet communicates with the server.</P></div><br>
<P class="docText">Java servlets have security advantages over client-side Java applets. A servlet that runs on a Web server inside a firewall can control access to sensitive data and business logic. Java applets do not inherently provide these security capabilities.</P>
<P class="docText">Before choosing which Java development style to use, you must know the basics of the environment in which the program must run. Ask the following questions when deciding what type of Java program is required for your development needs:</P>
<UL><LI><P class="docList">How will the program be executed? Must it run over the Internet, as an intranet or extranet application, or merely as a standalone application?</P></LI><LI><P class="docList">What is the business logic that this program must perform?</P></LI><LI><P class="docList">How complicated is the program?</P></LI><LI><P class="docList">How large (or small) is the program, and can it be downloaded quickly?</P></LI><LI><P class="docList">What are the security requirements?</P></LI><LI><P class="docList">Who are the target users and at what speed will they be connected to the Web?</P></LI></UL>
<P class="docText">Java applications, Java applets, and Java servlets are similar in nature. However, a different method is used to invoke each of them. Java applets and servlets are started from an HTML page. Java applications do not require a Web component but can be used as part of an intranet solution.</P>
<P class="docText">To implement any Java programs, you need to use the Java Developers Kit, or JDK for short. The JDK is a development environment for writing Java. The JDK includes the Java Virtual Machine (JVM), Java classes, source files to create the classes in the JVM, documentation, and the JDK tools required for building and testing Java bytecode. These tools include the Java compiler and interpreter, the Java applet viewer, and the Java debugger.<A NAME="ch14index234"></A><A NAME="ch14index235"></A><A NAME="ch14index236"></A><A NAME="ch14index237"></A></P>
<A NAME="ch14lev3sec3"></A><H5 class="docSection3Title">Enterprise Java Beans</H5>
<P class="docText">Enterprise Java Beans, or EJBs for short, are part of Java 2 Enterprise Edition (J2EE). EJBs are Java programs written as components that reside on the server. They are used to simplify the delivery of distributed applications and Web services by assembling components to achieve business functionality. Such an approach can greatly reduce the amount of time required to develop and deploy scalable enterprise Java applications.<A NAME="ch14index238"></A><A NAME="ch14index239"></A><A NAME="ch14index240"></A><A NAME="ch14index241"></A></P>
<P class="docText">A typical Java development environment for DB2 includes J2EE and WebSphere for building enterprise applications.</P>
<A NAME="ch14lev2sec9"></A><H4 class="docSection2Title">JDBC Versus SQLJ</H4>
<P class="docText">There are two options for accessing DB2 for z/OS data in Java application programs: JDBC and SQLJ. It is imperative that you understand the differences between these two methods in order to develop proper database access for your Java programs.</P>
<P class="docText"><span class="docEmphasis">Java Database Connectivity</span>, or <span class="docEmphasis">JDBC</span>, is an API that enables Java to access relational databases. Similar to ODBC, JDBC consists of a set of classes and interfaces that can be used to access relational data. Anyone familiar with application programming and ODBC (or any call-level interface) can get up and running with JDBC quickly. JDBC uses dynamic SQL to access DB2 data. The primary benefits of JDBC include the following:<A NAME="ch14index242"></A><A NAME="ch14index243"></A><A NAME="ch14index244"></A><A NAME="ch14index245"></A></P>
<UL><LI><P class="docList">Develop an application once and execute it anywhere.</P></LI><LI><P class="docList">Enable the user to change between drivers and access a variety of databases without recoding your Java program.</P></LI><LI><P class="docList">JDBC applications do not require precompiles or binds.</P></LI></UL>
<P class="docText">Potential drawbacks of JDBC include in the following:</P>
<UL><LI><P class="docList">JDBC uses dynamic SQL, which can add overhead when the SQL is bound.</P></LI><LI><P class="docList">Programs using JDBC can become quite large.</P></LI></UL>
<P class="docText">SQLJ enables developers to embed SQL statements in Java programs. SQLJ provides static SQL support to Java. Developers can embed SQL statements into Java, and a precompiler is used to translate SQL into Java code. Then the Java program can be compiled into bytecodes, and a bind can be run to create a package for the SQL. Simply stated, SQLJ enables Java programs to be developed the way most DB2 programs have been developed for years.<A NAME="ch14index246"></A><A NAME="ch14index247"></A><A NAME="ch14index248"></A></P>
<P class="docText">Of course, SQLJ does not allow dynamic SQL. But you can mix SQLJ and JDBC in a single Java program, which effectively enables you to choose static or dynamic SQL for your Java programs. The primary benefits of SQLJ include the following:</P>
<UL><LI><P class="docList">The ability to code static, embedded SQL in Java programs.</P></LI><LI><P class="docList">SQLJ source programs usually are smaller than equivalent JDBC programs.</P></LI><LI><P class="docList">SQLJ does data type checking during the program preparation process and enforces strong typing between table columns and Java host expressions. JDBC passes values without compile-time data type checking.</P></LI></UL>
<P class="docText">Potential drawbacks of the SQLJ approach include the following:</P>
<UL><LI><P class="docList">SQLJ programs must be precompiled and bound.</P></LI><LI><P class="docList">SQLJ is not yet a standard, but it has been proposed to ANSI for inclusion and has the widespread support of the major DBMS vendors.</P></LI></UL>
<P class="docText">To get a quick understanding of the differences between JDBC and SQLJ, review the code fragments in <A class="docLink" HREF="#ch14list02">Listings 14.2</A> and <A class="docLink" HREF="#ch14list03">14.3</A>. These listings do not show complete programs, but you can use them to understand the different means by which a SQL statement is issued with JDBC versus with SQLJ.<A NAME="ch14index249"></A><A NAME="ch14index250"></A><A NAME="ch14index251"></A><A NAME="ch14index252"></A></P>
<A NAME="ch14list02"></A><H5 class="docExampleTitle">Listing 14.2. JDBC Code Fragment</H5>

<PRE>
// Create the connection
// change the following URL to match the location name
// of your local DB2 for OS/390.
// The URL format is: "jdbc:db2os390:location_name"
String url = "jdbc:db2os390:st11db2g";
Connection con = DriverManager.getConnection (url);

// Create the Statement
Statement stmt = con.createStatement();
System.out.println("**** JDBC Statement Created");

// Execute the query and generate a ResultSet instance
ResultSet rs = stmt.executeQuery("SELECT LASTNAME, HIREDATE FROM EMP");
System.out.println("**** JDBC Result Set Created");

// Close the statement
stmt.close();

// Close the connection
con.close();
</PRE><BR>

<A NAME="ch14list03"></A><H5 class="docExampleTitle">Listing 14.3. SQLJ Code Fragment</H5><A NAME="ch14index253"></A><A NAME="ch14index254"></A><A NAME="ch14index255"></A><A NAME="ch14index256"></A>

<PRE>
{
#sql public iterator ByPos(String,Date);
                         // Declare positioned iterator class ByPos
ByPos positer; // Declare object of ByPos class
String name = null;
Date hrdate;
#sql positer = { SELECT LASTNAME, HIREDATE FROM EMP };
#sql { FETCH :positer INTO :name, :hrdate };
// Retrieve the first row from the result table
 while ( !positer.endFetch() )
 { System.out.println(name + " was hired in " + hrdate);
   #sql { FETCH :positer INTO :name, :hrdate };
// Retrieve the rest of the rows
  }
}
</PRE><BR>

<P class="docText">So, in general, JDBC programs are more portable and manage their own connections to DB2, but require dynamic SQL. SQLJ programs are easier to code because they require fewer lines of code and can be more efficient because they use static SQL, but require program preparation and are less portable.</P>
<A NAME="ch14note09"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Be sure to check out the Java sections of IBM's Web site for additional information regarding Java support and sample Java code. Two good URLs to bookmark are</P>
<P class="docText"><A class="docLink" target="_blank" HREF="http://www.ibm.com/developer/java/">http://www.ibm.com/developer/java/</A></P>
<P class="docText"><A class="docLink" target="_blank" HREF="http://www-4.ibm.com/software/data/db2/java/">http://www-4.ibm.com/software/data/db2/java/</A></P></div><br>
<A NAME="ch14lev3sec4"></A><H5 class="docSection3Title">Java Program Preparation</H5>
<P class="docText">Both JDBC and SQLJ programs need to be prepared before they can be run. But a SQLJ program requires precompilation and binding, whereas a JDBC program does not.<A NAME="ch14index257"></A><A NAME="ch14index258"></A><A NAME="ch14index259"></A></P>
<P class="docText">To prepare a JDBC-only Java program is the same as preparing any Java program with no database access. The only required step is to compile the program using the <TT>javac</TT> command.<A NAME="ch14index260"></A><A NAME="ch14index261"></A><A NAME="ch14index262"></A></P>
<P class="docText">To prepare a Java program that contains SQLJ calls, you will need to follow the program preparation steps as depicted in <A class="docLink" HREF="#ch14fig04">Figure 14.4</A>. In general, you will follow similar steps to what you would for preparing a COBOL program, but with some differences. The first step is to run the source code through the SQLJ Translator (<TT>sqlj</TT>). This produces a modified source file and a SQLJ "serialized profile." The modified source is compiled into a Java class to produce Java bytecodes. The SQLJ "serialized profile" is customized into standard DB2 DBRMs using <TT>db2profc</TT>. At this point you can <TT>BIND</TT> the DBRMs into packages and then the packages in to a plan; or you can simply <TT>BIND</TT> the DBRMs directly into a single plan.<A NAME="ch14index263"></A><A NAME="ch14index264"></A><A NAME="ch14index265"></A><A NAME="ch14index266"></A><A NAME="ch14index267"></A><A NAME="ch14index268"></A></P>
<A NAME="ch14fig04"></A><p><CENTER><H5 class="docFigureTitle">Figure 14.4. SQLJ program preparation.</H5>
<p class="docText"><IMG BORDER="0"  width="500" height="368" SRC="images/0672326132/graphics/14fig04.gif" ALT="graphics/14fig04.gif"></p></CENTER></p><br>
<A NAME="ch14lev2sec10"></A><H4 class="docSection2Title">Using Result Set Iterators to Retrieve Multiple Rows</H4>
<P class="docText">Traditional DB2 application programs written in host languages use a DB2 cursor to retrieve individual rows from a multi-row result set. The SQLJ equivalent of a cursor is a <span class="docEmphasis">result set iterator</span>. A result set iterator can be passed as a parameter to a method.<A NAME="ch14index269"></A><A NAME="ch14index270"></A><A NAME="ch14index271"></A></P>
<P class="docText">The result set iterator is defined using an iterator declaration clause specifying a list of Java data types. The Java data types represent columns of the table in the result set. The information in <A class="docLink" HREF="#ch14table02">Table 14.2</A> shows the SQL data types and their equivalent SQLJ data types that can be specified in result set iterator declarations. The SQLJ data type in the left column can be used for data retrieved that is of any of the SQL data types listed in the right column.</P>
<A NAME="ch14table02"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 14.2. SQLJ and SQL Data Type Equivalents</h5></CAPTION><COLGROUP><COL width="253"><COL width="297"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">SQLJ Data Type</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">SQL Data Type</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>java.lang.String</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CHAR</TT></P>
<P class="docText"><TT>VARCHAR</TT></P>
<P class="docText"><TT>LONG VARCHAR</TT></P>
<P class="docText"><TT>GRAPHIC</TT></P>
<P class="docText"><TT>VARGRAPHIC</TT></P>
<P class="docText"><TT>LONG VARGRAPHIC</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>java.math.BigDecimal</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>NUMERIC</TT></P>
<P class="docText"><TT>INTEGER</TT></P>
<P class="docText"><TT>DECIMAL</TT></P>
<P class="docText"><TT>SMALLINT</TT></P>
<P class="docText"><TT>FLOAT</TT></P>
<P class="docText"><TT>REAL</TT></P>
<P class="docText"><TT>DOUBLE</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>Boolean</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INTEGER</TT></P>
<P class="docText"><TT>SMALLINT</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>Integer</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INTEGER</TT></P>
<P class="docText"><TT>SMALLINT</TT></P>
<P class="docText"><TT>DECIMAL</TT></P>
<P class="docText"><TT>NUMERIC</TT></P>
<P class="docText"><TT>FLOAT</TT></P>
<P class="docText"><TT>DOUBLE</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>Float</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INTEGER</TT></P>
<P class="docText"><TT>SMALLINT</TT></P>
<P class="docText"><TT>DECIMAL</TT></P>
<P class="docText"><TT>NUMERIC</TT></P>
<P class="docText"><TT>FLOAT</TT></P>
<P class="docText"><TT>DOUBLE</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>Double</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INTEGER</TT></P>
<P class="docText"><TT>SMALLINT</TT></P>
<P class="docText"><TT>DECIMAL</TT></P>
<P class="docText"><TT>NUMERIC</TT></P>
<P class="docText"><TT>FLOAT</TT></P>
<P class="docText"><TT>DOUBLE</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>byte[]</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CHARACTER</TT></P>
<P class="docText"><TT>VARCHAR</TT></P>
<P class="docText"><TT>LONG VARCHAR</TT></P>
<P class="docText"><TT>GRAPHIC</TT></P>
<P class="docText"><TT>VARGRAPHIC</TT></P>
<P class="docText"><TT>LONG VARGRAPHIC</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>java.sql.Date</TT></P>
<P class="docText"><TT>java.sql.Time</TT></P>
<P class="docText"><TT>java.sql.Timestamp</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DATE</TT></P>
<P class="docText"><TT>TIME</TT></P>
<P class="docText"><TT>TIMESTAMP</TT><A NAME="ch14index272"></A><A NAME="ch14index273"></A><A NAME="ch14index274"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch14note10"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">The <TT>byte[]</TT> SQLJ data type is equivalent to the SQL data type with a subtype of <TT>FOR BIT DATA</TT>.</P>
<P class="docText">The <TT>java.sql.Date</TT>, <TT>java.sql.Time</TT>, and <TT>java.sql.Timestamp</TT> data types are part of the JDBC API.</P></div><br>
<A NAME="ch14lev2sec11"></A><H4 class="docSection2Title">Java Guidelines</H4>
<P class="docText">The following guidelines apply to Java application development against DB2 for z/OS data.</P>
<A NAME="ch14lev4sec37"></A><H5 class="docSection3Title">Beware of Java Performance</H5>
<P class="docText">As already noted, Java has a reputation for sluggish performance due to being interpreted instead of compiled. Java applications will tend to consume more CPU than COBOL applications. A good rule of thumb is to assume that Java will consume about 3 times more than COBOL in a DB2 V6 environment or about 2 times more in a DB2 V7 or V8 environment.<A NAME="ch14index275"></A><A NAME="ch14index276"></A><A NAME="ch14index277"></A></P>
<A NAME="ch14lev4sec38"></A><H5 class="docSection3Title">Beware of Character Data</H5>
<P class="docText">Java does not have a native fixed-length text data type. For this reason, many Java shops favor defining <TT>VARCHAR</TT> columns in their tables instead of <TT>CHAR</TT> columns—even for very small character columns. This allows the Java variables to match up with the DB2 columns without degrading from Stage 1 to Stage 2.<A NAME="ch14index278"></A><A NAME="ch14index279"></A><A NAME="ch14index280"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> Of course, DB2 V8 helps to remedy this problem by allowing mismatched data types to be compared at Stage 1 within data type families. So, for V8, a Java variable length variable can be compared to a DB2 <TT>CHAR</TT> column at Stage 1.</P></td></tr></table><br>
<A NAME="ch14note11"></A><div class="docNote"><p class="docNoteTitle">NOTE</p><p><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  ALIGN="LEFT" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText">Prior to DB2 V8, it was a somewhat common practice for designers to specify <TT>VARCHAR</TT> as the data type for <span class="docEmphasis">every</span> column in DB2 tables that were predominantly accessed by Java programs. This is no longer necessary and should be avoided once you have migrated to DB2 Version 8.</P></td></tr></table></p></div><br>
<A NAME="ch14lev4sec39"></A><H5 class="docSection3Title">Beware of <TT>SMALLINT</TT> Data</H5>
<P class="docText">There is no Java host variable equivalent for a <TT>SMALLINT</TT> data type. For this reason, it is a good idea to specify <TT>INTEGER</TT> columns in tables that are predominantly accessed by Java instead of <TT>SMALLINT</TT>—even for very small integers. This allows the Java program to match up <TT>Integer</TT> host variables with the DB2 <TT>INTEGER</TT> columns.<A NAME="ch14index281"></A><A NAME="ch14index282"></A><A NAME="ch14index283"></A><A NAME="ch14index284"></A></P>
<A NAME="ch14note12"></A><div class="docNote"><p class="docNoteTitle">NOTE</p><p><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  ALIGN="LEFT" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText">Once again, DB2 V8 provides relief for this situation because a Java <TT>Integer</TT> variable can be used with a DB2 <TT>SMALLINT</TT> column and still be processed at Stage 1 because the conversion is within the data type "family."</P></td></tr></table></p></div><br>
<A NAME="ch14lev4sec40"></A><H5 class="docSection3Title">Use Dynamic SQL Caching for JDBC</H5>
<P class="docText">If you are using JDBC programs then you are issuing dynamic SQL statements. Be sure to turn on dynamic SQL caching so that dynamic access paths can be reused when the same SQL statement is executed multiple times. This can greatly enhance the performance of all your dynamic SQL statements, because DB2 can reuse an access path instead of preparing a new one each time the statement is executed.<A NAME="ch14index285"></A><A NAME="ch14index286"></A><A NAME="ch14index287"></A><A NAME="ch14index288"></A></P>
<P class="docText">Of course, for dynamic SQL caching to work the SQL statement must be 100% the same—meaning that the statement must be exactly the same length and there can be no stray or trailing blanks.</P>
<A NAME="ch14lev4sec41"></A><H5 class="docSection3Title">Release Your Java Resources</H5>
<P class="docText">Be sure to release your Java resources as soon as your program no longer requires them. This means you should intelligently close result sets, prepared statements, and callable statements in your code.<A NAME="ch14index289"></A><A NAME="ch14index290"></A><A NAME="ch14index291"></A></P>
<A NAME="ch14lev4sec42"></A><H5 class="docSection3Title">Access Only the Columns Required</H5>
<P class="docText">Although this guideline applies to any DB2 program, it is even more important to follow in your Java programs. This is so because a Java object is created for each column that is retrieved. Therefore, be sure to <TT>SELECT</TT> only the columns you absolutely require—and never any extras. Each column accessed by your Java program adds overhead and therefore degrades the performance of your application.<A NAME="ch14index292"></A><A NAME="ch14index293"></A><A NAME="ch14index294"></A></P>
<A NAME="ch14lev4sec43"></A><H5 class="docSection3Title">Use Procedural Objects to Reduce SQL in Your Java Programs</H5>
<P class="docText">Consider using triggers, functions, and stored procedures to reduce the amount of SQL in your Java program. Triggers can be used to validate data, functions to transform data, and stored procedures to reduce network traffic.<A NAME="ch14index295"></A><A NAME="ch14index296"></A><A NAME="ch14index297"></A></P>
<A NAME="ch14lev4sec44"></A><H5 class="docSection3Title">Use the Appropriate JDBC Driver Type</H5>
<P class="docText">There are four types of JDBC drivers:<A NAME="ch14index298"></A><A NAME="ch14index299"></A><A NAME="ch14index300"></A><A NAME="ch14index301"></A></P>
<UL><LI><p class="docText">
<span class="docEmphRoman">Type 1</span>— 
Provided by Sun, this was the first JDBC driver type that was available. It is the slowest and should only be used if no other driver is available for the DBMS (this is not the case for DB2).</p></LI><LI><p class="docText">
<span class="docEmphRoman">Type 2</span>— 
Usually provided by the DBMS vendor, this type of driver is vendor-specific and sits on top of the database API.</p></LI><LI><p class="docText">
<span class="docEmphRoman">Type 3</span>— 
Similar to Type 2, but no database software is required on the local machine. Useful for Java applets.</p></LI><LI><p class="docText">
<span class="docEmphRoman">Type 4</span>— 
A native-protocol Java driver type that talks directly to the database server.</p></LI></UL>
<P class="docText">For applets, favor a Type 4 driver as it will give better performance than a Type 3 driver.</P>
<P class="docText">For most DB2 applications, favor a Type 2 driver.<A NAME="ch14index302"></A><A NAME="ch14index303"></A><A NAME="ch14index304"></A><A NAME="ch14index305"></A></P>
<A NAME="ch14lev4sec45"></A><H5 class="docSection3Title">Setting the Isolation Level in a Java Program</H5>
<P class="docText">You can use the <TT>SET TRANSACTION ISOLATION LEVEL</TT> clause to set the isolation level for a unit of work within an SQLJ program. For Java programs that contain both SQLJ and JDBC connections, setting the isolation level in this way will affect both the SQLJ connection and the JDBC connection. You can change the isolation level only at the beginning of a transaction. Refer to <A class="docLink" HREF="#ch14table03">Table 14.3</A> for a summary of the valid values that you can specify in the <TT>SET TRANSACTION ISOLATION LEVEL</TT> clause and their equivalent DB2 for z/OS <TT>ISOLATION</TT> parameter values.<A NAME="ch14index306"></A><A NAME="ch14index307"></A><A NAME="ch14index308"></A></P>
<P class="docText"><A class="docLink" HREF="#ch14table03">Table 14.3</A> shows the SQLJ isolation levels and their DB2 for OS/390 and z/OS equivalents.</P>
<A NAME="ch14table03"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="rows" CELLPADDING="4"><CAPTION><h5 class="docTableTitle">Table 14.3. SQLJ and DB2 Isolation Levels</h5></CAPTION><COLGROUP><COL width="275"><COL width="275"></COLGROUP><THEAD><TR><TH class="thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">SET TRANSACTION ISOLATION LEVEL</span></P></TH><TH class="thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">DB2 ISOLATION Parameter</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>READ COMMITTED</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CS</TT> (Cursor Stability)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>READ UNCOMMITTED</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>UR</TT> (Uncommitted Read)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>REPEATABLE READ</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>RS</TT> (Read Stability)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SERIALIZABLE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>RR</TT> (Repeatable Read)</P></TD></TR></TABLE></P><br>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch14lev1sec6.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch14lev1sec8.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
