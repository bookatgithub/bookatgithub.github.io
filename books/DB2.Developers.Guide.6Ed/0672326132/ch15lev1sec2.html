<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Implementing DB2 Stored Procedures</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch15lev1sec1.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch15lev1sec3.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch15lev1sec2"></A><H3 class="docSection1Title">Implementing DB2 Stored Procedures</H3>
<P class="docText">Now that you understand what stored procedures are and why you would want to use them, you're ready to investigate how to implement stored procedures in DB2.</P>
<A NAME="ch15lev2sec3"></A><H4 class="docSection2Title">Developing a Stored Procedure</H4>
<P class="docText">You can design and develop stored procedures in a similar manner to the way you develop any other application program. However, stored procedures have some special design requirements that you need to understand prior to developing them: using LE/370, coding parameters, returning result sets, and changing the program preparation procedure.<A NAME="ch15index62"></A><A NAME="ch15index63"></A><A NAME="ch15index64"></A></P>
<A NAME="ch15lev3sec1"></A><H5 class="docSection3Title">Using LE/370</H5>
<P class="docText">You must develop stored procedures using an LE/370 language. LE/370 is mandatory for the use of stored procedures. LE/370 provides a common runtime environment for multiple, disparate programming languages. The runtime services available to LE/370 include error handling, storage management, and debugging. The benefit to DB2 is that the runtime services are the same for every programming language used to deploy stored procedures.<A NAME="ch15index65"></A><A NAME="ch15index66"></A><A NAME="ch15index67"></A><A NAME="ch15index68"></A><A NAME="ch15index69"></A></P>
<A NAME="ch15lev3sec2"></A><H5 class="docSection3Title">Coding Parameters</H5>
<P class="docText">Parameters are essential to the effective use of stored procedures. Parameters allow data to be sent to and received from a stored procedure.<A NAME="ch15index70"></A><A NAME="ch15index71"></A><A NAME="ch15index72"></A><A NAME="ch15index73"></A></P>
<P class="docText">Each stored procedure has a parameter list associated with it. This list must be static and predefined. The parameter list defines the data type, size, and disposition (output, input, or both) of each parameter. The complete process of registering stored procedures, including parameter lists, is outlined in the upcoming section "<A class="docLink" HREF="art01lev1sec6.html#art01lev1sec6">Registering Stored Procedures</A>."</P>
<P class="docText">You must define the parameters to the stored procedure using the appropriate technique for the language you're using. For COBOL programs, you must define parameters in the <TT>LINKAGE SECTION</TT>. Refer to <A class="docLink" HREF="#ch15list01">Listing 15.1</A> for a sample stored procedure shell using COBOL.<A NAME="ch15index74"></A><A NAME="ch15index75"></A></P>
<A NAME="ch15list01"></A><H5 class="docExampleTitle">Listing 15.1. COBOL Stored Procedure Shell</H5>

<PRE>
<span class="docEmphasis">Must set up IDENTIFICATION and</span>
    <span class="docEmphasis">ENVIRONMENT DIVISIONS.</span>

DATA DIVISION.
LINKAGE SECTION.
********************************************************
**       PARAMETERS DEFINED IN LINKAGE SECTION        **
********************************************************
01  IN-PARM        PIC X(20).
01  OUT-PARM       PIC X(30).

********************************************************
** INDICATOR VARIABLES USED ONLY IF PARMS CAN BE NULL **
********************************************************
01  NULL-INDVARS.
    05  INDVAR-1   PIC S9(4) COMP.
    05  INDVAR-2   PIC S9(4) COMP.

WORKING-STORAGE SECTION.

    <span class="docEmphasis">Must declare all necessary variables.</span>

********************************************************
**   PARAMETERS SPECIFIED TO THE PROCEDURE DIVISION   **
********************************************************
PROCEDURE DIVISION USING PARM-A, PARM-B, NULL-INDVARS.

MAIN-PARAGRAPH.
       .
       .
       .
     IF INDVAR-1 &lt; 0
         if input parameter is null perform an error-routine
       .
       .
       .
     MOVE "SOME VALUE" TO OUT-PARM.
     MOVE ZERO TO INDVAR-2.
PROGRAM-END.
     GOBACK.<A NAME="ch15index76"></A><A NAME="ch15index77"></A>
</PRE><BR>

<P class="docText">Be sure to test all input parameters that can be null. If the input parameter is null, you must code the program to handle that situation. Likewise, for output parameters that can be null, be sure to set the null indicator variable to zero if not null or <TT>-1</TT> if null.</P>
<P class="docText">Additionally, be sure to set all input parameters to an appropriate value in the calling program prior to issuing the <TT>CALL</TT> to the stored procedure. The value of the stored procedure parameters is set at the time of the procedure <TT>CALL</TT>.<A NAME="ch15index78"></A><A NAME="ch15index79"></A><A NAME="ch15index80"></A><A NAME="ch15index81"></A></P>
<A NAME="ch15lev3sec3"></A><H5 class="docSection3Title">Nesting Stored Procedure Calls</H5>
<P class="docText">Prior to DB2 V6, a stored procedure could not issue the <TT>CALL</TT> statement, thereby forbidding one stored procedure to call another stored procedure. This limitation is removed for DB2 V6 and above.<A NAME="ch15index82"></A><A NAME="ch15index83"></A><A NAME="ch15index84"></A><A NAME="ch15index85"></A></P>
<P class="docText">When one stored procedure calls another stored procedure, it is referred to as a <span class="docEmphasis">nested procedure call</span>. DB2 supports 16 levels of nesting. When more than 16 levels of nesting are attempted a <TT>–746 SQLCODE</TT> is returned (<TT>SQLSTATE 57053</TT>).</P>
<P class="docText">The nesting level includes calls to stored procedure, as well as trigger and user-defined function invocations. Nesting can occur within a single DB2 subsystem or when a stored procedure or user-defined function is invoked at a remote server. If a stored procedure returns any query result sets, the result sets are returned to the caller of the stored procedure.</P>
<A NAME="ch15note06"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">DB2 restricts certain procedures from being called from another stored procedure, trigger, or UDF. A stored procedure, UDF, or trigger cannot call a stored procedure that is defined with the <TT>COMMIT ON RETURN</TT> attribute. Additionally, a stored procedure can <TT>CALL</TT> another stored procedure only if both stored procedures execute in the same type of address space. In other words, they must both execute in a DB2-established address space (SPAS) or both execute in a WLM-established address space.</P></div><br>
<P class="docText">If the <TT>CALL</TT> statement is nested, the result sets generated by the stored procedure are visible only to the program that is at the previous nesting level. <A class="docLink" HREF="#ch15fig02">Figure 15.2</A> depicts three levels of nested procedure calls. The results set returned from <TT>PROCZ</TT> is only available to <TT>PROCY</TT>. The calling program and <TT>PROCX</TT> have no access to the result sets returned from <TT>PROCX</TT>.</P>
<A NAME="ch15fig02"></A><p><CENTER><H5 class="docFigureTitle">Figure 15.2. Stored procedure nesting.</H5>
<p class="docText"><IMG BORDER="0" width="350" height="409" SRC="images/0672326132/graphics/15fig02.gif" ALT="graphics/15fig02.gif"></p></CENTER></p><br>
<P class="docText">Furthermore, the result sets from <TT>PROCY</TT> would be available only to <TT>PROCX</TT>, and the result sets from <TT>PROCX</TT> would be available to the calling program.<A NAME="ch15index86"></A><A NAME="ch15index87"></A><A NAME="ch15index88"></A><A NAME="ch15index89"></A></P>
<A NAME="ch15lev3sec4"></A><H5 class="docSection3Title">Returning Result Sets</H5>
<P class="docText">A stored procedure can return multiple row result sets back to the calling program. If you enable result sets to be returned, stored procedures become more efficient and effective. Benefits include the following:<A NAME="ch15index90"></A><A NAME="ch15index91"></A><A NAME="ch15index92"></A><A NAME="ch15index93"></A></P>
<UL><LI><P class="docList">Reduced network traffic, because an entire result set requires only a single network request</P></LI><LI><P class="docList">Better application design, because stored procedures do not need to loop artificially through cursors to return data one row at a time</P></LI><LI><P class="docList">Better flexibility, because more work can be done using stored procedures</P></LI></UL>
<P class="docText"><A class="docLink" HREF="#ch15fig03">Figure 15.3</A> shows the impact of result sets on stored procedure processing.</P>
<A NAME="ch15fig03"></A><p><CENTER><H5 class="docFigureTitle">Figure 15.3. A stored procedure returning result sets.</H5>
<p class="docText"><IMG BORDER="0" width="500" height="355" SRC="images/0672326132/graphics/15fig03.gif" ALT="graphics/15fig03.gif"></p></CENTER></p><br>
<A NAME="ch15note07"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Stored procedure result sets can only be returned to the program that called the stored procedure. For example, if PRG1 calls SP1 and SP1 calls SP2, SP2 cannot return a result set to PRG1.</P></div><br>
<P class="docText">To implement stored procedures that return result sets, you must perform several steps. The first step is to ensure that the <TT>RESULT_SETS</TT> parameter is specified correctly for the stored procedure. The <TT>RESULT_SETS</TT> parameter is specified on the <TT>CREATE</TT> or <TT>ALTER PROCEDURE</TT> statement and indicates the maximum number of result sets that can be returned by the stored procedure. To enable the stored procedure to return result sets, you must set the <TT>RESULTS SET</TT>s parameter to a value greater than <TT>0</TT>.<A NAME="ch15index94"></A><A NAME="ch15index95"></A></P>
<P class="docText">The second step is to specify the <TT>WITH RETURN</TT> clause on each <TT>OPEN</TT> cursor statement for which result sets are to be returned. The cursors must not be closed by the stored procedure. When the stored procedure ends, the result sets are returned to the calling program. This can cause trouble if you try to issue a <TT>COMMIT</TT> in the stored procedure and you are not using <TT>WITH HOLD</TT> or you try to issue a <TT>ROLLBACK</TT>.</P>
<P class="docText">The last step is coding the calling program to accept result sets from the stored procedure. Refer to <A class="docLink" HREF="#ch15fig04">Figure 15.4</A> to view the interaction of a stored procedure with a calling program that accepts result sets. The first step is to declare a result set locator variable. Next, the calling program issues the <TT>CALL</TT> to execute the stored procedure. The stored procedure executes, opening a cursor that specifies the <TT>WITH RETURN</TT> clause. The stored procedure ends without closing the cursor, causing DB2 to return the result set automatically to the calling program. The calling program issues the <TT>ASSOCIATE LOCATOR</TT> statement to assign a value to the result set locator that was previously defined. The calling program then issues the <TT>ALLOCATE CURSOR</TT> statement to associate the query with the result set. Finally, the program can execute a loop to <TT>FETCH</TT> the rows of the result set.<A NAME="ch15index96"></A><A NAME="ch15index97"></A><A NAME="ch15index98"></A><A NAME="ch15index99"></A></P>
<A NAME="ch15fig04"></A><p><CENTER><H5 class="docFigureTitle">Figure 15.4. Coding to return a result set.</H5>
<p class="docText"><IMG BORDER="0" width="500" height="351" SRC="images/0672326132/graphics/15fig04.gif" ALT="graphics/15fig04.gif"></p></CENTER></p><br>
<P class="docText">The preceding outlines the tasks necessary when the calling program knows what result sets can be returned by the stored procedure it is calling. However, special SQL statements—<TT>DESCRIBE PROCEDURE</TT> and <TT>DESCRIBE CURSOR</TT>—are available when the calling program does not know in advance the number of result sets that a stored procedure can return.</P>
<P class="docText">The <TT>DESCRIBE PROCEDURE</TT> statement returns the following information for a stored procedure that has already been called. The information, which is returned to the <TT>SQLDA</TT>, includes<A NAME="ch15index100"></A><A NAME="ch15index101"></A></P>
<UL><LI><P class="docList">The number of result sets to be returned</P></LI><LI><P class="docList">The result set locator value for each result set</P></LI><LI><P class="docList">The name of the SQL cursor used by the stored procedure for each result set</P></LI></UL>
<P class="docText">The <TT>DESCRIBE CURSOR</TT> statement also returns information to the <TT>SQLDA</TT>, but it describes the columns accessed by the cursor.<A NAME="ch15index102"></A><A NAME="ch15index103"></A><A NAME="ch15index104"></A><A NAME="ch15index105"></A></P>
<A NAME="ch15lev3sec5"></A><H5 class="docSection3Title">Preparing Stored Procedure Programs</H5>
<P class="docText">The program preparation process for stored procedures is essentially the same as for any program that accesses DB2. The program code must be precompiled, compiled, and then link-edited into an executable form. The DBRM must be bound into a package; no plan is required for the stored procedure.<A NAME="ch15index106"></A><A NAME="ch15index107"></A><A NAME="ch15index108"></A></P>
<P class="docText">When the program is link-edited, the LE/370 program library must be included. Likewise, the program for the stored procedure must link-edit either <TT>DSNALI</TT> (for CAF) or <TT>DSNRLI</TT> (for RRSAF), depending on which attachment facility is to be used. Of course, you also can link-edit the stored procedure program to run in multiple environments if you choose.</P>
<P class="docText">No impact to the program preparation process is required for the calling program; you should use normal DB2 program preparation steps.</P>
<A NAME="ch15note08"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">A plan is still required for the calling program. Only the stored procedure (<span class="docEmphasis">the called program</span>) does not require a plan.</P>
<P class="docText">The package for the stored procedure does not have to be bound in the package list of the calling program.</P></div><br>
<A NAME="ch15lev2sec4"></A><H4 class="docSection2Title">Creating Stored Procedures</H4>
<P class="docText">As of DB2 V6, stored procedures are registered and managed within DB2 like other DB2 objects, using standard DDL statements—<TT>ALTER</TT>, <TT>CREATE</TT>, and <TT>DROP</TT>. After a stored procedure has been developed and is ready to be tested, the stored procedure must be created in the DB2 subsystem.<A NAME="ch15index109"></A><A NAME="ch15index110"></A></P>
<pre>

</pre><BR><pre>
CREATE PROCEDURE SYSPROC.PROCNAME(INOUT CHAR(20))
   LANGUAGE COBOL
   EXTERNAL NAME LOADNAME
   PARAMETER STYLE GENERAL
   NOT DETERMINISTIC
   MODIFIES SQL DATA
   WLM ENVIRONMENT WLMNAME
   STAY RESIDENT YES
   RESULT SETS 1;
</pre><BR>
<P class="docText">This statement creates a stored procedure named <TT>PROCNAME</TT> in the <TT>SYSPROC</TT> schema using an external load module name of <TT>LOADNAME</TT>. The stored procedure is written in COBOL and runs under the control of WLM. It returns one result set.</P>
<P class="docText">The <TT>ALTER</TT> statement can be used to change most characteristics of the stored procedure (except the stored procedure name, its schema, and parameters). The stored procedure can be removed from the DB2 subsystem using the <TT>DROP</TT> statement.</P>
<P class="docText">Information about the stored procedures defined to DB2 is stored in the <TT>SYSIBM.SYSROUTINES</TT> table in the DB2 Catalog. This table is used to store information about stored procedures and user-defined functions. When <TT>ALTER</TT>, <TT>CREATE</TT>, and <TT>DROP </TT>statements are issued for those objects the structural definition of those objects is stored in <TT>SYSIBM.SYSROUTINES</TT>. When parameters are used, the parm lists are stored in <TT>SYSIBM.SYSPARMS</TT>.<A NAME="ch15index111"></A><A NAME="ch15index112"></A></P>
<A NAME="ch15note09"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Prior to DB2 V6, you had to manually register stored procedures in the DB2 Catalog using SQL. Because in past releases of DB2 stored procedures were not created within DB2, nor were they created using DDL, the DBA had to use SQL <TT>INSERT</TT> statements to populate a DB2 Catalog table, <TT>SYSIBM.SYSPROCEDURES</TT>, that contained the metadata for the stored procedure.</P>
<P class="docText">The following SQL provides an example of an <TT>INSERT</TT> to register a stored procedure named <TT>PROCNAME</TT>:</P>
<pre>

</pre><BR><pre>
INSERT INTO SYSIBM.SYSPROCEDURES
  (PROCEDURE, AUTHID, LUNAME, LOADMOD, LINKAGE,
  COLLID, LANGUAGE, ASUTIME, STAYRESIDENT,
  IBMREQD, RUNOPTS, PARMLIST, RESULT_SETS,
  WLM_ENV, PGM_TYPE, EXTERNAL_SECURITY,
  COMMIT_ON_RETURN)
VALUES
 ('PROCNAME', ' ', ' ', 'LOADNAME', ' ',
  'COLL0001', 'COBOL', 0, 'Y',
  'N', ' ', 'NAME CHAR(20) INOUT', 1,
  ' ', 'M', 'N', 'N');
</pre><BR></div><br>
<A NAME="ch15lev3sec6"></A><H5 class="docSection3Title">Configuring Parameter Lists</H5>
<P class="docText">The parameters to be used by DB2 stored procedures must be specified in parentheses after the procedure name in the <TT>CREATE PROCEDURE</TT> statement. You can define three types of parameters:<A NAME="ch15index113"></A><A NAME="ch15index114"></A><A NAME="ch15index115"></A></P>
<UL><LI><p class="docText">
<TT>IN</TT>— 
An input parameter<A NAME="ch15index116"></A><A NAME="ch15index117"></A></p></LI><LI><p class="docText">
<TT>OUT</TT>— 
An output parameter<A NAME="ch15index118"></A><A NAME="ch15index119"></A></p></LI><LI><p class="docText">
<TT>INOUT</TT>— 
A parameter that is used for both input and output<A NAME="ch15index120"></A><A NAME="ch15index121"></A></p></LI></UL>
<P class="docText">The type of parameter must be predetermined and cannot be changed without dropping and re-creating the stored procedure.</P>
<P class="docText">Consider, for example, a stored procedure with three parameters: an employee number, bonus, and total compensation. The stored procedure calculates the total compensation for a specified employee and returns it to the calling program. The bonus parameter is either set to <TT>0</TT> (in which case, no additional processing is performed) or to a percentage that the employee bonus is to be increased. If total compensation is greater than $100,000, the bonus percentage is cut in half. In this case, you could code the <TT>PARMLIST</TT> as follows:</P>
<pre>

</pre><BR><pre>
CREATE PROCEDURE PROCNAME(IN EMPNO CHAR(6), INOUT BONUS DEC(5,2), OUT COMPNSTN DEC(9,2)...
</pre><BR>
<P class="docText">This way, the stored procedure receives the employee number; receives, modifies, and then returns the bonus; and returns the total compensation.</P>
<P class="docText">Providing names for the parameters is optional.</P>
<P class="docText">An additional consideration when you're coding parameters for stored procedures is whether the parameters can be null. You use the <TT>PARAMETER STYLE</TT> parameter to specify nullability. You have three choices:<A NAME="ch15index122"></A><A NAME="ch15index123"></A></P>
<UL><LI><p class="docText">
<TT>DB2SQL</TT>— 
In addition to the parameters on the <TT>CALL</TT> statement, the following are also passed to the stored procedure: a null indicator for each parameter, the <TT>SQLSTATE</TT> to be returned to DB2, the qualified name of the stored procedure, the specific name of the stored procedure, and a SQL diagnostic string to be returned to DB2.</p></LI><LI><p class="docText">
<TT>GENERAL</TT>— 
Only the parameters on the <TT>CALL</TT> statement are passed to the stored procedure, and the parameters are not allowed to be null.</p></LI><LI><p class="docText">
<TT>GENERAL WITH NULLS</TT>— 
In addition to the parameters on the <TT>CALL</TT> statement, an array of null indicators is passed to the stored procedure for each of the parameters on the <TT>CALL</TT> statement that enables the stored procedure to accept or return null parameter values.</p></LI></UL>
<A NAME="ch15note10"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">The default <TT>PARAMETER STYLE</TT> is <TT>DB2SQL</TT>.</P></div><br>
<P class="docText">Refer to <A class="docLink" HREF="#ch15list01">Listing 15.1</A> for an example of the indicator variables being passed to the stored procedure as an array.<A NAME="ch15index124"></A><A NAME="ch15index125"></A><A NAME="ch15index126"></A></P>
<A NAME="ch15lev2sec5"></A><H4 class="docSection2Title">Managing Stored Procedures</H4>
<P class="docText">Whether or not programs can call a stored procedure is controlled using commands to start and stop the stored procedure. Of course, the program must have been granted the appropriate privileges to run the stored procedure even if it has been started.<A NAME="ch15index127"></A><A NAME="ch15index128"></A><A NAME="ch15index129"></A></P>
<P class="docText">The <TT>-START PROCEDURE</TT> command activates a stored procedure that is stopped or refreshes one that is cached. When a stored procedure is first created, you will not need to start the procedure before it can be called. DB2 will automatically activate the new procedure the first time it is referenced by a <TT>CALL</TT> statement. To issue <TT>-START PROCEDURE</TT> simply reference the procedure name to be started as follows:<A NAME="ch15index130"></A><A NAME="ch15index131"></A><A NAME="ch15index132"></A><A NAME="ch15index133"></A><A NAME="ch15index134"></A></P>
<pre>

</pre><BR><pre>
-START PROCEDURE(<span class="docEmphasis">procedure name</span>)
</pre><BR>
<P class="docText">Similarly, the <TT>-STOP PROCEDURE</TT> command prevents DB2 from accepting SQL <TT>CALL</TT> statements for stored procedures:<A NAME="ch15index135"></A><A NAME="ch15index136"></A><A NAME="ch15index137"></A><A NAME="ch15index138"></A><A NAME="ch15index139"></A></P>
<pre>

</pre><BR><pre>
-STOP PROCEDURE(<span class="docEmphasis">procedure name</span>) ACTION(REJECT | QUEUE)
</pre><BR>
<A NAME="ch15note11"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">The <TT>-STOP PROCEDURE</TT> command will not prevent <TT>CALL</TT> statements from running if they have already been queued or scheduled by DB2.</P></div><br>
<P class="docText">When stopping stored procedures you can specify how <TT>CALL</TT> statements that are issued while the procedure is stopped are to be treated. This is accomplished with the <TT>ACTION</TT> parameter of the <TT>-STOP PROCEDURE</TT> command. There are two options:</P>
<UL><LI><p class="docText">
<TT>QUEUE</TT>— 
Queues the requested stored procedure <TT>CALL</TT> until either the stored procedure is started again, or you exceed your installation timeout value</p></LI><LI><p class="docText">
<TT>REJECT</TT>— 
Rejects the requested stored procedure <TT>CALL</TT></p></LI></UL>
<P class="docText">To execute the <TT>-START</TT> and <TT>-STOP PROCEDURE</TT> commands, you must be authorized as either the owner of the stored procedure, or as <TT>SYSOPR</TT>, <TT>SYSCTRL</TT>, or <TT>SYSADM</TT>.</P>
<P class="docText">Another part of management is monitoring. You can use the <TT>DISPLAY</TT> command to monitor the status of stored procedures:<A NAME="ch15index140"></A><A NAME="ch15index141"></A><A NAME="ch15index142"></A></P>
<pre>

</pre><BR><pre>
-DISPLAY PROCEDURE(<span class="docEmphasis">procedure name</span>)
</pre><BR>
<P class="docText">This command shows</P>
<UL><LI><P class="docList">Whether the named procedure is currently started or stopped</P></LI><LI><P class="docList">How many requests are currently executing</P></LI><LI><P class="docList">The high water mark for concurrently running requests</P></LI><LI><P class="docList">How many requests are currently queued</P></LI><LI><P class="docList">How many times a request has timed out<A NAME="ch15index143"></A><A NAME="ch15index144"></A><A NAME="ch15index145"></A></P></LI></UL>
<A NAME="ch15lev3sec7"></A><H5 class="docSection3Title">Controlling Failures</H5>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><P class="docText"> Stored procedures can be difficult to manage when problems occur in production systems. It can be particularly problematic to manage stored procedure availability when problems cause stored procedures to abend. Do you really want a single program failure to make the stored procedure unavailable? As of DB2 V7, controlling stored procedure failures becomes somewhat easier.<A NAME="ch15index146"></A><A NAME="ch15index147"></A><A NAME="ch15index148"></A><A NAME="ch15index149"></A></P></td></tr></table><br>
<P class="docText">The DSNZPARM value <TT>STORMXAB</TT> (on installation panel <TT>DSNTIPX</TT>) can be set to specify a value for the maximum abend. You can use this value to indicate the number of times a stored procedure (or UDF) is allowed to terminate abnormally before it is stopped. This parameter is subsystem-wide—it applies to all stored procedures and UDFs the same across the entire DB2 subsystem.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> As of DB2 V8, you gain further control. The parameter allows you to specify a maximum number of failures value for each stored procedure or UDF. This brings the control to each individual object, instead of at the DB2 subsystem level.</P></td></tr></table><br>
<P class="docText">The options available include</P>
<BLOCKQUOTE><P><p class="docText"><TT>STOP AFTER </TT><span class="docEmphasis"><TT>n</TT></span> <TT>FAILURES</TT>— 
The stored procedure (or UDF) will be stopped only after <span class="docEmphasis"><TT>n</TT></span> failures have occurred. The value <span class="docEmphasis"><TT>n</TT></span> can range from 1 to 32,767.</p></P><P><p class="docText"><TT>STOP AFTER SYSTEM DEFAULT FAILURES</TT>— 
The stored procedure (or UDF) will be stopped when it reaches the number of abnormal terminations specified in the <TT>STORMXAB</TT> DSNZPARM. This is the default.</p></P><P><p class="docText"><TT>CONTINUE AFTER FAILURE</TT>— 
The stored procedure (or UDF) is never placed in a stopped state, unless you explicitly use the <TT>-STOP PROCEDURE</TT> command.<A NAME="ch15index150"></A><A NAME="ch15index151"></A><A NAME="ch15index152"></A><A NAME="ch15index153"></A></p></P></BLOCKQUOTE>
<A NAME="ch15note12"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">The preceding parameters cannot be used for sourced functions or SQL scalar functions.</P>
<P class="docText">Furthermore, after altering the stored procedure (or UDF) to specify one of these parameters, you must first <TT>STOP</TT> and then <TT>START</TT> the corresponding stored procedure or UDF to activate the new settings.</P></div><br>
<A NAME="ch15lev2sec6"></A><H4 class="docSection2Title">Executing a Stored Procedure</H4>
<P class="docText">To run a stored procedure, you must explicitly issue a <TT>CALL</TT> statement. For example, the following statement calls a stored procedure named <TT>SAMPLE</TT>, sending a literal string as a parameter:<A NAME="ch15index154"></A><A NAME="ch15index155"></A><A NAME="ch15index156"></A></P>
<pre>

</pre><BR><pre>
EXEC SQL
    CALL SAMPLE('ABC')
END-EXEC.
</pre><BR>
<P class="docText">To issue a <TT>CALL</TT> statement for a stored procedure requires the <TT>EXECUTE</TT> privilege on the stored procedure, as well as on the stored procedure package and packages (other than for UDFs and triggers) that run under the stored procedure.<A NAME="ch15index157"></A><A NAME="ch15index158"></A></P>
<P class="docText">DB2 runs stored procedure code isolated from the core DB2 code. This is done to ensure that a rogue or buggy stored procedure does not crash DB2. There are two ways that DB2 isolates stored procedures:</P>
<UL><LI><P class="docList">In a DB2-managed stored procedure address space (SPAS)</P></LI><LI><P class="docList">Using Work Load Manager (WLM)</P></LI></UL>
<P class="docText">Using a SPAS to run stored procedures was the first method used by DB2 and it continues to be completely supported through V7. However, there is only one SPAS and your management options are limited when choosing this method. Furthermore, the SPAS is destined for the scrap heap—as we will discuss in a moment.</P>
<P class="docText">As of DB2 V5 and subsequent releases, you can use multiple stored procedure address spaces. Doing so requires the use of the z/OS Workload Manager (WLM). Running stored procedures in the WLM allows you to isolate code in separate address spaces based on the type of processing being performed. For example, OLTP stored procedures can be separated from data warehousing stored procedures. In this manner you can create an environment with multiple physical address spaces for stored procedures executing at the same dispatching priority as the calling program.<A NAME="ch15index159"></A><A NAME="ch15index160"></A><A NAME="ch15index161"></A></P>
<A NAME="ch15lev3sec8"></A><H5 class="docSection3Title">What Is Workload Manager?</H5>
<P class="docText">The z/OS Workload Manager, or WLM, is used to implement workload management for your mainframe system. The purpose of workload management is to match the available system resources with the demands of z/OS components (such as CICS, batch, TSO, and so on). WLM will balance the work across available processors so as to most effectively utilize the resources of the machine.<A NAME="ch15index162"></A><A NAME="ch15index163"></A><A NAME="ch15index164"></A><A NAME="ch15index165"></A></P>
<P class="docText">The goal is for z/OS to distribute workload automatically to achieve the desired response time, such as described in Service Level Agreements (SLAs). WLM works to distribute work without over-committing resources while at the same time attempting to maximize system throughput.</P>
<P class="docText">WLM was introduced as a component of MVS/ESA V5. From this release onward, MVS can run in either "compatibility mode" or "goal mode," at the discretion of the installation. When in goal mode, WLM allows more effective use of a single system, because resource adjustment is automatic. WLM in goal mode is required for DB2 V8.</P>
<P class="docText">Using WLM to control stored procedures has the following benefits:</P>
<UL><LI><P class="docList">It allows the creation of multiple environments to segregate stored procedures by processing type.</P></LI><LI><P class="docList">It isolates stored procedures by address space. (If a stored procedure bug brings down one address space, others are still available.)</P></LI><LI><P class="docList">It provides two-phase commit for non-SQL resources using RRSAF.</P></LI><LI><P class="docList">It allows individual MVS dispatching priorities.</P></LI><LI><P class="docList">It enables RACF control over access to non-SQL resources.</P></LI></UL>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> Furthermore, as of DB2 V8, managing WLM-managed stored procedures is made easier because DB2 can exploit proactive WLM administration functionality. Work Load Manager and System Resource Manager can analyze resource utilization and recommend changes in the number of tasks operating inside a WLM-managed stored procedure address space. This helps to make the environment more self-managing.</P></td></tr></table><br>
<P class="docText">For DB2 V7 and before, whenever the number of TCBs running in a WLM-managed stored procedure address space exceeded the value of <TT>NUMTCB</TT> a new WLM address space will be started. But as of V8, the value specified in <TT>NUMTCB</TT> is regarded as a maximum limit. WLM will determine the actual number of TCBs to run inside the WLM-managed address space based on resource usage.</P>
<A NAME="ch15note13"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Consider specifying a higher number for <TT>NUMTCB</TT> after you move to V8 to allow WLM some flexibility in choosing the number of tasks.</P></div><br>
<A NAME="ch15note14"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Certain stored procedures require <TT>NUMTCB</TT> to be set to <TT>1</TT>. The utility stored procedure provided with DB2, <TT>DSNUTILS</TT>, is an example of such a stored procedure. REXX stored procedures have to have a <TT>NUMTCB</TT> of <TT>1</TT>.</P></div><br>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> With DB2 Version 8, IBM has begun to remove support for DB2-managed stored procedures. All new stored procedures must be WLM-managed. This means that once you move to V8, each SPAS must be established using the z/OS Workload Manager. No new stored procedures can be created without specifying a WLM environment.</P></td></tr></table><br>
<P class="docText">Stored procedures created prior to V8 without a WLM environment will still run correctly and they can be altered using <TT>ALTER PROCEDURE</TT>. However, if the stored procedure is dropped you cannot re-<TT>CREATE</TT> it without changing it to a WLM-managed stored procedure.<A NAME="ch15index166"></A><A NAME="ch15index167"></A><A NAME="ch15index168"></A><A NAME="ch15index169"></A><A NAME="ch15index170"></A><A NAME="ch15index171"></A><A NAME="ch15index172"></A></P>
<A NAME="ch15lev3sec9"></A><H5 class="docSection3Title">What Happens When a Stored Procedure Is Called?</H5>
<P class="docText">To execute a stored procedure, a program must issue the SQL <TT>CALL</TT> statement. When the <TT>CALL</TT> is issued, the name of the stored procedure, its schema name, and its list of parameters are sent to DB2. DB2 searches <TT>SYSIBM.SYSROUTINES</TT> for the appropriate row that defines the stored procedure to be executed. If the row is not found, the stored procedure does not run.<A NAME="ch15index173"></A><A NAME="ch15index174"></A><A NAME="ch15index175"></A><A NAME="ch15index176"></A></P>
<P class="docText">If the row is found, DB2 retrieves the pertinent information to allow the stored procedure to execute, including the actual load module. DB2 then finds a TCB to use for the stored procedure in the appropriate SPAS (either WLM- or DB2-managed) and indicates to the SPAS that the stored procedure is to be executed. The SPAS reuses the thread of the calling program to run the stored procedure. The stored procedure runs, assigns values to input/output and output parameters, and returns control to the calling program.</P>
<P class="docText">The calling program receives the input/output and output parameters and continues processing. The entire processing within the stored procedure is within the same unit of work as the <TT>CALL</TT> in the calling program. Locks acquired within the stored procedure continue to be held until released by the calling program (with a <TT>COMMIT</TT> or <TT>ROLLBACK</TT>).<A NAME="ch15index177"></A><A NAME="ch15index178"></A><A NAME="ch15index179"></A><A NAME="ch15index180"></A><A NAME="ch15index181"></A><A NAME="ch15index182"></A><A NAME="ch15index183"></A></P>
<A NAME="ch15lev2sec7"></A><H4 class="docSection2Title">Built-In Stored Procedures</H4>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><P class="docText"> DB2 V7 ships three built-in stored procedures to support Java. DB2 V7 also ships a new built-in schema, <TT>SQLJ</TT>, which contains these built-in procedures.<A NAME="ch15index184"></A><A NAME="ch15index185"></A><A NAME="ch15index186"></A></P></td></tr></table><br>
<P class="docText">The three built-in procs are used to install JAR files into DB2. They are:</P>
<UL><LI><p class="docText">
<TT>SQLJ.INSTALL_JAR</TT>— 
Installs a JAR file into DB2.</p></LI><LI><p class="docText">
<TT>SQLJ.REPLACE_JAR</TT>— 
Replaces a JAR file in DB2 with a new file.</p></LI><LI><p class="docText">
<TT>SQLJ.REMOVE_JAR</TT>— 
Removes a previously installed JAR file from DB2.<A NAME="ch15index187"></A><A NAME="ch15index188"></A><A NAME="ch15index189"></A></p></LI></UL>
<A NAME="ch15lev2sec8"></A><H4 class="docSection2Title">Stored Procedure Guidelines</H4>
<P class="docText">On the surface, stored procedures appear to be simple and highly effective new devices for enabling better application performance, enhancing database administration, and promoting code reuseability. However, as with every DB2 feature, you can find good and bad ways to proceed with implementing stored procedures. Keep the following guidelines in mind as you develop stored procedures at your shop.</P>
<A NAME="ch15lev4sec1"></A><H5 class="docSection3Title">Exercise Control Over Stored Procedure Stopping</H5>

<P class="docText">Use the <TT>FAILURE</TT> parameters when creating stored procedures to explicitly control how DB2 should treat each stored procedure when failures occur. By specifying the most appropriate value for an individual routine, you can let some routines continue to be invoked for development and debugging, and stop other routines for maintenance before they cause problems in a production environment.<A NAME="ch15index190"></A><A NAME="ch15index191"></A><A NAME="ch15index192"></A></P>
<P class="docText">Recall that the available options that can be specified using <TT>CREATE</TT> or <TT>ALTER PROCEDURE</TT> are: <TT>STOP AFTER FAILURE</TT>, <TT>STOP AFTER </TT><span class="docEmphasis"><TT>n</TT></span> <TT>FAILURES</TT>, and <TT>CONTINUE AFTER FAILURE</TT>.</P>
<A NAME="ch15lev4sec2"></A><H5 class="docSection3Title">Minimize Nested Procedure Calls</H5>
<P class="docText">When a procedure calls another procedure, the ensuing structure is called a <span class="docEmphasis">nested procedure</span>. Nested procedures are difficult to test and modify. Furthermore, when one procedure calls another, the likelihood of reuse decreases because the complexity increases.<A NAME="ch15index193"></A><A NAME="ch15index194"></A><A NAME="ch15index195"></A></P>
<P class="docText">However, in some cases, the benefits of nesting procedures can outweigh the problems. If you decide to nest procedure calls, be sure to analyze the number of nested stored procedures, triggers, and user-defined functions that can be executed for any given SQL statement and ensure that the limit of 16 levels of nesting is not exceeded.</P>
<A NAME="ch15lev4sec3"></A><H5 class="docSection3Title">Consider Using Subprograms</H5>
<P class="docText">A stored procedure can call another program using the facilities of the programming language. The program being called cannot be a stored procedure, though. The use of subprograms enables better program reuse.<A NAME="ch15index196"></A><A NAME="ch15index197"></A><A NAME="ch15index198"></A></P>
<P class="docText">If you use subprograms, be sure to document their use within the stored procedure that calls the subprogram. The call statements used to execute the subprogram might be confused with the SQL <TT>CALL</TT> statement used to execute a stored procedure unless the program makes liberal use of comments.</P>
<A NAME="ch15lev4sec4"></A><H5 class="docSection3Title">Plan Stored Procedure Implementation</H5>
<P class="docText">Design and implement only useful stored procedures. By <span class="docEmphasis">useful</span>, I mean only those stored procedures that support a business rule and are robust enough to perform a complete task without being too small to be trivial (a two-line procedure) or too large to be understood (a thousand-line procedure that performs every customer function known to the organization). To be useful, a stored procedure must<A NAME="ch15index199"></A><A NAME="ch15index200"></A><A NAME="ch15index201"></A></P>
<UL><LI><P class="docList">Perform one task and perform it very well</P></LI><LI><P class="docList">Correspond to a useful business function</P></LI><LI><P class="docList">Be documented (including a description of the input, output, and the process)</P></LI></UL>
<A NAME="ch15lev4sec5"></A><H5 class="docSection3Title">Specify Atomic Parameters</H5>
<P class="docText">Always specify parameters at an atomic level. In other words, every stored procedure parameter must be complete and non-divisible. For example, use<A NAME="ch15index202"></A><A NAME="ch15index203"></A><A NAME="ch15index204"></A></P>
<pre>

</pre><BR><pre>
(IN FNAME CHAR(20), IN LNAME CHAR(30))
</pre><BR>
<P class="docText">instead of</P>
<pre>

</pre><BR><pre>
(IN FULLNAME CHAR(50))
</pre><BR>
<P class="docText">When you code parameters as non-atomic variable blocks, the stored procedure logic must parse the block. If changes occur to the data causing lengths or data type to change, procedures using atomic parameters are easier to modify and test.</P>
<A NAME="ch15lev4sec6"></A><H5 class="docSection3Title">Learn LE/370</H5>
<P class="docText">You must write DB2 stored procedures using an LE/370 language. You therefore cannot use VS COBOL II to code stored procedures.<A NAME="ch15index205"></A><A NAME="ch15index206"></A><A NAME="ch15index207"></A><A NAME="ch15index208"></A></P>
<P class="docText">However, stored procedures can be called from any DB2-compatible programming language (even non-LE/370 languages).</P>
<A NAME="ch15lev4sec7"></A><H5 class="docSection3Title">Consider Using CODE/370</H5>
<P class="docText">IBM offers CODE/370, an integrated toolset consisting of editing, compilation, and debugging tools. Without a tool such as CODE/370, testing and debugging DB2 stored procedures can be difficult. Both mainframe and workstation interfaces are available for CODE/370.<A NAME="ch15index209"></A><A NAME="ch15index210"></A><A NAME="ch15index211"></A><A NAME="ch15index212"></A></P>
<A NAME="ch15lev4sec8"></A><H5 class="docSection3Title">Use Stored Procedures for Internal DBA Tools</H5>
<P class="docText">If your shop has technical DBAs who like to code their own administration tools performance monitoring applications, consider using stored procedures to issue DB2 commands and access trace records using IFI (Instrumentation Facility Interface). You can develop generalized procedures that are maintained by the DBA and accessed by multiple programs to start, stop, and display data base objects or analyze IFCIDs and display performance details.<A NAME="ch15index213"></A><A NAME="ch15index214"></A><A NAME="ch15index215"></A><A NAME="ch15index216"></A></P>
<A NAME="ch15lev4sec9"></A><H5 class="docSection3Title">Use Appropriate Data Types for Parameters</H5>
<P class="docText">Make sure that the calling program and the stored procedure use the same data type and length for each parameter. DB2 converts compatible data types, but by using the same data types and lengths, you can ensure efficient and effective execution.<A NAME="ch15index217"></A><A NAME="ch15index218"></A><A NAME="ch15index219"></A></P>
<P class="docText">You can use user-defined distinct types for stored procedure parameters.</P>
<A NAME="ch15lev4sec10"></A><H5 class="docSection3Title">Do Not Use <TT>LONG VARCHAR</TT> and <TT>LONG VARGRAPHIC</TT> Parameters</H5>
<P class="docText">When defining parameters to be used in your stored procedures, you can use the same built-in and user-defined data types as for the <TT>CREATE TABLE</TT> statement, except for <TT>LONG VARCHAR</TT> and <TT>LONG VARGRAPHIC</TT> data types. Instead, specify the parameter as a <TT>VARCHAR</TT> or <TT>VARGRAPHIC</TT> with an explicit length.<A NAME="ch15index220"></A><A NAME="ch15index221"></A><A NAME="ch15index222"></A><A NAME="ch15index223"></A><A NAME="ch15index224"></A><A NAME="ch15index225"></A></P>
<A NAME="ch15lev4sec11"></A><H5 class="docSection3Title">Consider Using Output Parameters for the <TT>SQLCA</TT></H5>
<P class="docText">The <TT>SQLCA</TT> information for SQL statements executed in stored procedures is not returned to the calling program. Consider using output parameters to send <TT>SQLCA</TT> information to the calling program. This way, you can enable the calling program to determine the success or failure of SQL, as well as possibly provide error resolution information.<A NAME="ch15index226"></A><A NAME="ch15index227"></A><A NAME="ch15index228"></A></P>
<P class="docText">A separate output parameter is required for each SQL statement in the stored procedure (because the <TT>SQLCA</TT> of the stored procedure changes for each SQL statement execution).</P>
<A NAME="ch15lev4sec12"></A><H5 class="docSection3Title">Use the Appropriate <TT>PARAMETER STYLE</TT></H5>
<P class="docText">When coding a stored procedure with parameters, use the <TT>PARAMETER STYLE</TT> option to identify the convention to be used to pass parameters to the stored procedure. The following options are available:<A NAME="ch15index229"></A><A NAME="ch15index230"></A><A NAME="ch15index231"></A></P>
<UL><LI><p class="docText">
<TT>DB2SQL</TT>— 
Indicates that the following arguments are passed to the stored procedure in addition to the parameters: a null indicator for each parameter, the <TT>SQLSTATE</TT>, the qualified and specific name of the stored procedure, and the SQL diagnostic string.</p></LI><LI><p class="docText">
<TT>GENERAL</TT>— 
Indicates that only the parameters are passed to the stored procedure, and the parameters cannot be null.</p></LI><LI><p class="docText">
<TT>GENERAL WITH NULLS</TT>— 
Indicates that in addition to the parameters being passed, an additional argument is passed that contains a vector of null indicators for each parameter.</p></LI><LI><p class="docText">
<TT>JAVA</TT>— 
Indicates that the stored procedure is a Java procedure and should follow Java conventions for parameter passing.</p></LI></UL>
<A NAME="ch15note15"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">You cannot specify <TT>PARAMETER STYLE DB2SQL</TT> with a REXX stored procedure.</P></div><br>
<A NAME="ch15lev4sec13"></A><H5 class="docSection3Title">Consider Using Temporary Tables</H5>
<P class="docText">Stored procedures can make excellent use of temporary tables to store intermediate results. Consider the following uses:<A NAME="ch15index232"></A><A NAME="ch15index233"></A><A NAME="ch15index234"></A><A NAME="ch15index235"></A></P>
<UL><LI><P class="docList">The stored procedure can <TT>INSERT</TT> data into a temporary table. A cursor can then be opened for the table with the results sent back to the calling program.</P></LI><LI><P class="docList">Because stored procedures can access non-DB2 resources, data from IMS or IDMS can be accessed and stored in a temporary table. That data can then be accessed by the stored procedure using SQL, effectively enabling DB2 to perform joins with non-DB2 data sources such as IMS or IDMS.</P></LI></UL>
<A NAME="ch15lev4sec14"></A><H5 class="docSection3Title">Promote Reuseability</H5>
<P class="docText">As I mentioned earlier, the predominant reason for using stored procedures is to increase reuseability. By reusing components—in this case, stored procedures—you can write applications more quickly using code that is already developed, tested, and working.<A NAME="ch15index236"></A><A NAME="ch15index237"></A><A NAME="ch15index238"></A></P>
<P class="docText">However noble the goal of reuseable components, though, simply mandating the use of stored procedures does not ensure that goal. Documentation and management support (perhaps coercion) are necessary to ensure successful reuse. The basic maxim applies: "How can I reuse it if I don't know it exists or don't know what it does?"</P>
<A NAME="ch15lev4sec15"></A><H5 class="docSection3Title">Make Stored Procedures Reentrant</H5>
<P class="docText">Stored procedures perform better if they are prepared to be reentrant. When a stored procedure is reentrant, a single copy of the stored procedure is used by many clients. A reentrant stored procedure does not have to be loaded into storage every time it is called. Compiling and link-editing your programs as reentrant reduces the amount of virtual storage required for the stored procedure address space. You can use the <TT>RENT</TT> compiler option to make a COBOL stored procedure reentrant. Link-edit the program as reentrant and reuseable.<A NAME="ch15index239"></A><A NAME="ch15index240"></A><A NAME="ch15index241"></A></P>
<P class="docText">Furthermore, to make a reentrant stored procedure remain resident in storage, specify the <TT>STAY RESIDENT YES</TT> option in your <TT>CREATE</TT> or <TT>ALTER PROCEDURE</TT> statement.</P>
<A NAME="ch15note16"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">For details on compiling programs coded in languages other than COBOL to be reentrant, refer to the appropriate manual for the programming language you are using.</P></div><br>
<A NAME="ch15lev4sec16"></A><H5 class="docSection3Title">Make Stored Procedures Resident</H5>
<P class="docText">Better use of system resources occurs if stored procedures are made reuseable and remain resident in the SPAS. Specify the <TT>STAY RESIDENT</TT> parameter when creating stored procedures, and avoid the <TT>NOREUS</TT> link-edit option. A program must be reentrant before it can be specified to stay resident. Therefore, the general recommendation is to make all stored procedures reentrant, reuseable, and resident.<A NAME="ch15index242"></A><A NAME="ch15index243"></A><A NAME="ch15index244"></A><A NAME="ch15index245"></A><A NAME="ch15index246"></A></P>
<A NAME="ch15lev4sec17"></A><H5 class="docSection3Title">Accurately Specify <TT>DETERMINISTIC</TT> or <TT>NOT DETERMINISTIC</TT></H5>
<P class="docText">Be sure to specify accurately whether the stored procedure will always return the same result for identical input arguments. If the stored procedure always returns the same result for identical input arguments, it is <TT>DETERMINISTIC</TT>. If not, the stored procedure should be identified as <TT>NOT DETERMINISTIC</TT>. Any stored procedure that relies on external data sources that can change should be specified as <TT>NOT DETERMINISTIC</TT>. Other examples of stored procedures that are <TT>NOT DETERMINISTIC</TT> include stored procedures that contain SQL <TT>SELECT</TT>, <TT>INSERT</TT>, <TT>UPDATE</TT>, or <TT>DELETE</TT> statements or a random number generator.<A NAME="ch15index247"></A><A NAME="ch15index248"></A><A NAME="ch15index249"></A><A NAME="ch15index250"></A></P>
<P class="docText">DB2 will not check to ensure that the <TT>[NOT] DETERMINISTIC</TT> parameter is specified appropriately. You must specify it accurately when you <TT>CREATE</TT> (or <TT>ALTER</TT>) the stored procedure.</P>
<A NAME="ch15lev4sec18"></A><H5 class="docSection3Title">Specifying Collection IDs</H5>
<P class="docText">A specific collection ID can be assigned to a stored procedure using the <TT>COLLID</TT> parameter of the <TT>CREATE PROCEDURE</TT> statement. If <TT>NO COLLID</TT> is specified, the collection ID defaults to that of the package of the calling program. This result can be confusing. Explicitly specifying the collection ID is usually the better alternative. The default is <TT>NO COLLID</TT>.<A NAME="ch15index251"></A><A NAME="ch15index252"></A><A NAME="ch15index253"></A><A NAME="ch15index254"></A><A NAME="ch15index255"></A><A NAME="ch15index256"></A><A NAME="ch15index257"></A></P>
<A NAME="ch15lev4sec19"></A><H5 class="docSection3Title">Returning Column Names from Stored Procedure Results Sets</H5>
<P class="docText">If the <TT>SELECT</TT> statements in your stored procedure are static, the <TT>DESCSTAT</TT> subsystem parameter must be turned on to retrieve column names from your stored procedure result sets. Set the subsystem parameter on the host DB2 where the procedure was compiled. After setting this parameter, you will have to <TT>REBIND</TT> your stored procedure packages.<A NAME="ch15index258"></A><A NAME="ch15index259"></A><A NAME="ch15index260"></A><A NAME="ch15index261"></A><A NAME="ch15index262"></A><A NAME="ch15index263"></A></P>
<P class="docText">If the <TT>SELECT</TT> statements inside of the stored procedure are dynamic, the result-set column names should be returned automatically.</P>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch15lev1sec1.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch15lev1sec3.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
