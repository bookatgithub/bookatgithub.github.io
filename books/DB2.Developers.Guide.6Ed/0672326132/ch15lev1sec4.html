<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Procedural SQL</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch15lev1sec3.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch15lev1sec5.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch15lev1sec4"></A><H3 class="docSection1Title">Procedural SQL</H3>
<P class="docText">The major difference between DB2's stored procedure support and the other RDBMS vendors is the manner in which the stored procedure is coded. As I mentioned at the beginning of this chapter, other popular RDBMS products require procedural dialects of SQL for stored procedure creation. Oracle uses PL/SQL and Sybase, and Microsoft SQL Server uses Transact SQL. Each of these languages is proprietary, and they cannot interoperate with one another.<A NAME="ch15index266"></A><A NAME="ch15index267"></A></P>
<P class="docText">As of DB2 V6, IBM supports a procedural dialect of SQL based on the ANSI standard. The IBM DB2 version of procedural SQL is called <span class="docEmphasis">SQL procedures language</span>, or SPL for short.</P>
<A NAME="ch15note17"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">SQL/PSM is the ANSI standard specification for developing stored procedures and routines using SQL. PSM is an acronym for Persistent Stored Modules. IBM's implementation of its SQL Stored Procedure Language is based on SQL/PSM, but is not a complete implementation of the ANSI SQL/PSM standard.</P></div><br>
<P class="docText">But what is procedural SQL? One of the biggest benefits derived from SQL (and relational technology in general) is the capability to operate on sets of data with a single line of code. By using a single SQL statement, you can retrieve, modify, or remove multiple rows. However, this capability also limits SQL's functionality. A procedural dialect of SQL eliminates this drawback through the addition of looping, branching, and flow of control statements. Procedural SQL has major implications on database design.</P>
<P class="docText">Procedural SQL will look familiar to anyone who has ever written any type of SQL or coded using any type of programming language. Typically, procedural SQL dialects contain constructs to support looping (<TT>WHILE</TT> or <TT>REPEAT</TT>), exiting (<TT>LEAVE</TT>), conditional processing (<TT>IF...THEN...ELSE</TT>), blocking (<TT>BEGIN...END</TT>), and variable definition and use.<A NAME="ch15index268"></A><A NAME="ch15index269"></A></P>
<A NAME="ch15lev2sec9"></A><H4 class="docSection2Title">IBM's SQL Procedure Language</H4>
<P class="docText">Stored procedure language for creating SQL stored procedures was added after the general availability of DB2 V6.<A NAME="ch15index270"></A><A NAME="ch15index271"></A><A NAME="ch15index272"></A><A NAME="ch15index273"></A></P>
<P class="docText">SQL stored procedures are like other stored procedures in that the SQL stored procedure must have a name and a schema, as well as the definition of the stored procedure characteristics and the actual code for the stored procedure. The code, however, is written in SQL alone—no 3GL program is required.</P>
<P class="docText">SQL stored procedures differ from external stored procedures in the way that the code is defined. SQL stored procedures include the actual SQL procedural source code in the <TT>CREATE PROCEDURE</TT> statement, whereas external stored procedures specify only the definition of the stored procedure in the <TT>CREATE PROCEDURE</TT> statement. The actual code of an external stored procedure is developed independently and is not included in the <TT>CREATE</TT> statement.<A NAME="ch15index274"></A><A NAME="ch15index275"></A><A NAME="ch15index276"></A><A NAME="ch15index277"></A></P>
<P class="docText">SQL stored procedures are developed entirely in IBM's SQL procedures language but must be converted to C before they can be executed. This process is described later in this chapter in the section titled "<A class="docLink" HREF="#ch15lev3sec11">Creating SQL Stored Procedures</A>."<A NAME="ch15index278"></A><A NAME="ch15index279"></A><A NAME="ch15index280"></A><A NAME="ch15index281"></A><A NAME="ch15index282"></A><A NAME="ch15index283"></A></P>
<P class="docText">The actual SQL code in the SQL stored procedure is referred to as the <span class="docEmphasis">body</span> of the SQL stored procedure. The body of an SQL stored procedure can include most valid SQL statements, but also extended, procedural SQL statements. The procedure body consists of a single simple or compound statement. The following statements can be included in an SQL stored procedure body.<A NAME="ch15index284"></A><A NAME="ch15index285"></A><A NAME="ch15index286"></A></P>
<UL><LI><P class="docList">Most regular SQL statements can be coded in an SQL stored procedure. Some SQL statements are valid in a compound statement, but they are not valid if the SQL is the only statement in the procedure body.</P></LI><LI><P class="docList">Assignment statements can be used to assign a value (or null) to an output parameter or an SQL variable. An SQL variable is defined and used only within the body of an SQL stored procedure.</P></LI><LI><P class="docList"><TT>CASE</TT> statements are used to select an execution path based on the evaluation of one or more conditions. The SQL procedures language <TT>CASE</TT> statement is similar to the SQL <TT>CASE</TT> expression previously described in <A class="docLink" HREF="ch01.html#ch01">Chapter 1</A>, "The Magic Words."</P></LI><LI><P class="docList"><TT>IF</TT> statements can be coded to select an execution path based on conditional logic.</P></LI><LI><P class="docList">The <TT>LEAVE</TT> statement transfers program control out of a loop or a block of code.</P></LI><LI><P class="docList">A <TT>LOOP</TT> statement is provided to execute a single statement or grouping of statements multiple times.</P></LI><LI><P class="docList">The <TT>REPEAT</TT> statement executes a single statement or group of statements until a specified condition evaluates to true.</P></LI><LI><P class="docList">The <TT>WHILE</TT> statement is similar to the <TT>REPEAT</TT> statement, but it executes a single statement or group of statements while a specified condition is true.</P></LI><LI><P class="docList">
<IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"> The <TT>RETURN</TT> statement can be used to return a status in the form of an integer value to the invoking application.</P></LI><LI><P class="docList">
<IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"> The <TT>SIGNAL</TT> statement works in conjunction with the <TT>RETURN</TT> statement. The <TT>SIGNAL</TT> statement can be used to set the <TT>SQLSTATE</TT> to a specific value. You can also use it to specify an optional <TT>MESSAGE_TEXT</TT>, the first 70 bytes of which will be stored in the <TT>SQLERRMC</TT> field of the SQLCA. The full message text can be obtained from the <TT>MESSAGE_TEXT</TT> and <TT>MESSAGE_LENGTH</TT> fields of <TT>GET DIAGNOSTICS</TT>.</P></LI><LI><P class="docList">
<IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"> The <TT>RESIGNAL</TT> statement enables a condition handler within an SQL procedure to raise a condition with a specific <TT>SQLSTATE</TT> and message text, or to return the same condition that activated the handler.<A NAME="ch15index287"></A><A NAME="ch15index288"></A></P></LI><LI><P class="docList">Compound statements can be coded that contain one or more of any of the other SQL procedures language statements. In addition, a compound statement can contain SQL variable declarations, condition handlers, and cursor declarations. Compound statements cannot be nested.<A NAME="ch15index289"></A><A NAME="ch15index290"></A><A NAME="ch15index291"></A></P></LI></UL>
<A NAME="ch15note18"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">When coding a compound statement, you must code the component statements in the following specific order:</P>
<div style="font-weight:bold"><OL class="docList" TYPE="1"><LI><div style="font-weight:normal"><P class="docList">SQL variable and condition declarations</P></div></LI><LI><div style="font-weight:normal"><P class="docList">Cursor declarations</P></div></LI><LI><div style="font-weight:normal"><P class="docList">Handler declarations</P></div></LI><LI><div style="font-weight:normal"><P class="docList">Procedure body statements (<TT>CASE</TT>, <TT>IF</TT>, <TT>LOOP</TT>, <TT>REPEAT</TT>, <TT>WHILE</TT>, and other SQL statements)<A NAME="ch15index292"></A><A NAME="ch15index293"></A></P></div></LI></OL></div></div><br>
<A NAME="ch15lev3sec10"></A><H5 class="docSection3Title">Sample SQL Stored Procedures</H5>
<P class="docText">The following SQL code implements an SQL stored procedure that accepts an employee number and a rate as input. The stored procedure raises the salary of the specified employee by the specified rate. However, using an <TT>IF</TT> statement, the stored procedure also checks to make sure that no raise exceeds 50%.<A NAME="ch15index294"></A><A NAME="ch15index295"></A></P>
<pre>

</pre><BR><pre>
CREATE PROCEDURE UPDATE_SALARY
  (IN EMPLOYEE_NUMBER CHAR(10),
   IN RATE DECIMAL(6,2))
LANGUAGE SQL
WLM ENVIRONMENT SAMP1
COMMIT ON RETURN YES
IF RATE &lt;= 0.50
THEN UPDATE EMP
     SET SALARY = SALARY * RATE
     WHERE EMPNO = EMPLOYEE_NUMBER;
ELSE UPDATE EMP
     SET SALARY = SALARY * 0.50
     WHERE EMPNO = EMPLOYEE_NUMBER;
END IF
</pre><BR>
<P class="docText">Another sample stored procedure follows:</P>
<pre>

</pre><BR><pre>
CREATE PROCEDURE PROC1(OUT NOROWS INT)
LANGUAGE SQL
BEGIN
  DECLARE var_firstnme VARCHAR(12);
  DECLARE var_midinit CHAR(1);
  DECLARE var_lastname VARCHAR(15);
  DECLARE at_end INT DEFAULT 0;
  DECLARE not_found CONDITION FOR '02000'
  DECLARE cempname CURSOR FOR
    SELECT   FIRSTNME, MIDINIT, LASTNAME
    FROM     EMP
    ORDER BY LASTNAME;
  DECLARE CONTINUE HANDLER FOR not_found SET NOROWS=1;
  OPEN cempname;
  FETCH cempname INTO var_firstnme, var_midinit, var_lastname;
  CLOSE cempname;
END
</pre><BR>
<P class="docText">This SQL stored procedure declares a cursor on the <TT>EMP</TT> table and fetches a row from the cursor. The condition handler is used to handle the row-not-found condition. You could code a loop construct to fetch all rows from a cursor until no more rows are found. For example,</P>
<pre>

</pre><BR><pre>
  .
  .
  .
fetch_loop:
REPEAT
  FETCH cempname INTO
        var_firstnme, var_midinit, var_lastname;
UNTIL SQLCODE &lt;&gt; 0
END REPEAT fetch_loop
  .
  .
  .
</pre><BR>
<P class="docText">Of course, a similar effect could be achieved using the <TT>LOOP</TT> construct with a <TT>LEAVE</TT> statement.<A NAME="ch15index296"></A><A NAME="ch15index297"></A></P>
<A NAME="ch15lev3sec11"></A><H5 class="docSection3Title">Creating SQL Stored Procedures</H5>
<P class="docText">There are three steps to creating SQL stored procedures:<A NAME="ch15index298"></A><A NAME="ch15index299"></A></P>
<A NAME="ch15pr01"></A>


<div style="font-weight:bold"><OL class="docList" START="1"><LI value="1"><div style="font-weight:normal">Write the procedural SQL source statements.<BR><BR></div></LI><LI value="2"><div style="font-weight:normal">Create the executable form of the SQL procedure.<BR><BR></div></LI><LI value="3"><div style="font-weight:normal">Define the SQL procedure to DB2.<BR><BR></div></LI></OL></div>
<P class="docText">There are two different ways for you to accomplish these three steps to create an SQL procedure:</P>
<UL><LI><P class="docList">Use the IBM DB2 Stored Procedure Builder to guide you through the steps of specifying the source statements for the SQL procedure, defining the SQL procedure to DB2, and preparing the SQL procedure for execution.</P></LI><LI><P class="docList">Code a <TT>CREATE PROCEDURE</TT> statement for the SQL procedure. Then use JCL or <TT>DSNTPSMP</TT> to define the SQL procedure to DB2 and create an executable procedure.<A NAME="ch15index300"></A><A NAME="ch15index301"></A></P></LI></UL>
<A NAME="ch15note19"></A><div class="docNote"><p class="docNoteTitle">NOTE</p><p><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  ALIGN="LEFT" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText">As of DB2 V8, Stored Procedure Builder is renamed to DB2 Development Center.</P></td></tr></table></p></div><br>
<A NAME="ch15lev4sec20"></A><H5 class="docSection4Title">Using JCL to Create SQL Stored Procedures</H5>
<P class="docText">Use the following steps to prepare an SQL procedure using JCL. This JCL is similar to the JCL used for program preparation presented in <A class="docLink" HREF="ch13.html#ch13">Chapter 13</A>, "Program Preparation," with an additional step to generate C source code.<A NAME="ch15index302"></A><A NAME="ch15index303"></A><A NAME="ch15index304"></A></P>
<P class="docText">First, preprocess the <TT>CREATE PROCEDURE</TT> statement using the <TT>DSNHPSM</TT> program. The output from this step is<A NAME="ch15index305"></A><A NAME="ch15index306"></A></P>
<UL><LI><P class="docList">A C language source program</P></LI><LI><P class="docList">A <TT>CREATE PROCEDURE</TT> statement (or for V5, an <TT>INSERT</TT> statement for defining the stored procedure in <TT>SYSIBM.SYSPROCEDURES</TT> for V5)</P></LI></UL>
<P class="docText">Next, precompile the generated C language program. This produces a DBRM and modified C language source statements. Ensure that the DBRM name is the same as the name of the load module for the SQL procedure.</P>
<P class="docText">The third step is to compile and link-edit the modified C source statements, producing an executable C language program. The default name for the C language program is the first eight bytes of the SQL procedure name. Finally, <TT>BIND</TT> the DBRM into a package and define the stored procedure to DB2.<A NAME="ch15index307"></A><A NAME="ch15index308"></A><A NAME="ch15index309"></A></P>
<A NAME="ch15lev4sec21"></A><H5 class="docSection4Title">Using <TT>DSNTPSMP</TT> to Create SQL Stored Procedures</H5>
<P class="docText"><TT>DSNTPSMP</TT>, also known as the SQL procedure processor, is a REXX stored procedure that you can use to prepare an SQL procedure for execution. You can also use <TT>DSNTPSMP</TT> to perform selected steps in the preparation process or delete an existing SQL procedure. The following sections contain information on invoking <TT>DSNTPSMP</TT>.<A NAME="ch15index310"></A><A NAME="ch15index311"></A><A NAME="ch15index312"></A><A NAME="ch15index313"></A><A NAME="ch15index314"></A></P>
<P class="docText"><TT>DSNTPSMP</TT> can be executed only by issuing a <TT>CALL</TT> statement inside an application program or through DB2 Stored Procedure Builder or DB2 Development Center. Before you can run <TT>DSNTPSMP</TT>, you need to ensure that the appropriate PTFs and APARs have been applied to DB2, install the REXX language support feature, and code a program that issues a <TT>CALL</TT> statement for <TT>DSNTPSMP</TT>.</P>
<A NAME="ch15lev4sec22"></A><H5 class="docSection4Title">Use the Sample Programs Provided by IBM</H5>
<P class="docText">IBM provides quite a few sample programs and jobs to assist you in developing SQL stored procedures. The samples can be found in the <TT>SDSNSAMP</TT> data set. Examine these for examples of how to implement effective DB2 SQL stored procedures. The SQL stored procedure samples that ship with DB2 are listed in <A class="docLink" HREF="#ch15table01">Table 15.1</A>.<A NAME="ch15index315"></A><A NAME="ch15index316"></A><A NAME="ch15index317"></A></P>
<A NAME="ch15table01"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 15.1. SQL Stored Procedure Samples</h5></CAPTION><COLGROUP><COL width="115.5"><COL width="434.5"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Name</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Description</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DSNHSQL</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Sample JCL to preprocess, precompile, compile, prelink-edit, and link-edit SQL stored procedures.<A NAME="ch15index318"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DSNTEJ63</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Sample JCL to prepare the <TT>DSN8ES1</TT> SQL stored procedure for execution.<A NAME="ch15index319"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DSN8ES1</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">An example of an SQL stored procedure that uses the DB2 sample tables. It accepts a department number as input and returns a result set that contains salary information for each employee in that department.<A NAME="ch15index320"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DSNTEJ64</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Sample JCL to prepare <TT>DSN8ED3</TT> for execution.<A NAME="ch15index321"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DSN8ED3</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">A sample C program that calls the <TT>DSN8ES1</TT> SQL stored procedure <A NAME="ch15index322"></A><A NAME="ch15index323"></A><A NAME="ch15index324"></A><A NAME="ch15index325"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch15lev4sec23"></A><H5 class="docSection4Title">The SQL Procedures Language "Catalog"</H5>
<P class="docText">SQL procedures language requires two additional supportive tables, similar to DB2 Catalog tables. These tables contain information such as the source code of the SQL stored procedure code and the options used to develop the SQL stored procedure. The two tables are <TT>SYSIBM.SYSPSM</TT> and <TT>SYSIBM.SYSPSMOPTS</TT>.<A NAME="ch15index326"></A><A NAME="ch15index327"></A></P>
<P class="docText"><TT>SYSIBM.SYSPSM</TT> holds the source code for SQL stored procedures. The table contains one or more rows for each SQL stored procedure prepared by <TT>DSNTPSMP</TT>, Stored Procedure Builder, or DB2 Development Center. If the SQL stored procedure consists of more than 3,800 bytes, more than one row is required to hold the source code for the SQL procedure. Refer to <A class="docLink" HREF="#ch15table02">Table 15.2</A> for a definition of <TT>SYSIBM.SYSPSM</TT>.</P>
<A NAME="ch15table02"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 15.2. <TT>SYSIBM.SYSPSM</TT> (SQL Procedure Source Table)</h5></CAPTION><COLGROUP><COL width="275"><COL width="275"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Column Name</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Column Definition</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SCHEMA</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Schema of the SQL procedure. Blank if the SQL procedure was created prior to DB2 V6.</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PROCEDURENAME</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Name of the SQL stored procedure.</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SEQNO</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Sequence number between 1 and <TT>CEILING(</TT><span class="docEmphasis"><TT>x</TT></span><TT>/3800)</TT>, where <span class="docEmphasis"><TT>x</TT></span> is the number of bytes in the SQL procedure source statement.</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PSMDATE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">The date on which the SQL procedure was created.</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PSMTIME</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">The time at which the SQL procedure was created.</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PROCCREATESTMT</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">A <TT>VARCHAR(3800)</TT> column containing all or part of an SQL procedure source. If the SQL procedure statement is more than 3,800 bytes, this column contains the portion of the source statement indicated by <TT>SEQNO</TT>.</P></TD></TR></TABLE></P><br>
<P class="docText">The <TT>SYSIBM.SYSPSM</TT> table has two indexes defined on it: <TT>DSNPSMX1</TT> (nonunique) and <TT>DSNPSMX2</TT> (unique).<A NAME="ch15index328"></A><A NAME="ch15index329"></A></P>
<P class="docText"><TT>SYSIBM.SYSPSMOPTS</TT> holds the program preparation options for SQL stored procedures. The table contains one row for each SQL stored procedure prepared by <TT>DSNTPSMP</TT>, Stored Procedure Builder, or DB2 Development Center. Refer to <A class="docLink" HREF="#ch15table03">Table 15.3</A> for a definition of <TT>SYSIBM.SYSPSMOPTS</TT>.<A NAME="ch15index330"></A><A NAME="ch15index331"></A></P>
<P class="docText">The <TT>SYSIBM.SYSPSMOPTS</TT> table has one unique index, <TT>DSNPSMOX1</TT> defined on it. This index must be defined before <TT>DSNTPSMP</TT> is executed.<A NAME="ch15index332"></A><A NAME="ch15index333"></A></P>
<A NAME="ch15table03"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 15.3. <TT>SYSIBM.SYSPSMOPTS</TT> (SQL Procedure Options Table)</h5></CAPTION><COLGROUP><COL width="275"><COL width="275"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Column Name</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Column Definition</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SCHEMA</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Schema of the SQL procedure. Blank if the SQL procedure was created prior to DB2 V6.<A NAME="ch15index334"></A><A NAME="ch15index335"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PROCEDURENAME</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Name of the SQL stored procedure.<A NAME="ch15index336"></A><A NAME="ch15index337"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BUILDSCHEMA</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">The schema name that qualifies the procedure name specified in the <TT>BUILDNAME</TT> column.<A NAME="ch15index338"></A><A NAME="ch15index339"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BUILDNAME</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">A procedure name associated with stored procedure <TT>DSNTPSMP</TT>. You can create multiple definitions for the <TT>DSNTPSMP</TT> stored procedure to run <TT>DSNTPSMP</TT> in different WLM environments.<A NAME="ch15index340"></A><A NAME="ch15index341"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BUILDOWNER</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">The authorization ID used to create the SQL stored procedure.<A NAME="ch15index342"></A><A NAME="ch15index343"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PRECOMPILE_OPTS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">The options that were specified in the precompiler-options parameter for the most recent invocation of <TT>DSNTPSMP</TT> for this SQL stored procedure.<A NAME="ch15index344"></A><A NAME="ch15index345"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COMPILE_OPTS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">The options that were specified in the compiler-options parameter for the most recent invocation of <TT>DSNTPSMP</TT> for this SQL stored procedure.<A NAME="ch15index346"></A><A NAME="ch15index347"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PRELINK_OPTS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">The options that were specified in the prelink-edit-options parameter for the most recent invocation of <TT>DSNTPSMP</TT> for this SQL stored procedure.<A NAME="ch15index348"></A><A NAME="ch15index349"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>LINK_OPTS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">The options that were specified in the link-edit-options parameter for the most recent invocation of <TT>DSNTPSMP</TT> for this SQL stored procedure.<A NAME="ch15index350"></A><A NAME="ch15index351"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BIND_OPTS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">The options that were specified in the bind-options parameter in the most recent invocation of <TT>DSNTPSMP</TT> for this SQL stored procedure.<A NAME="ch15index352"></A><A NAME="ch15index353"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SOURCEDSN</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">The name of the data set that contains the source code for the SQL stored procedure (if the SQL procedure source code was input to <TT>DSNTPSMP</TT> stored in an external data set).<A NAME="ch15index354"></A><A NAME="ch15index355"></A><A NAME="ch15index356"></A><A NAME="ch15index357"></A><A NAME="ch15index358"></A><A NAME="ch15index359"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch15lev2sec10"></A><H4 class="docSection2Title">The Benefits of Procedural SQL</H4>
<P class="docText">The most useful procedural extension to SQL is the addition of procedural flow control statements. Flow control within procedural SQL is handled by typical programming constructs that you can mix with standard SQL statements. These typical constructs enable programmers to<A NAME="ch15index360"></A><A NAME="ch15index361"></A></P>
<UL><LI><P class="docList">Embed SQL statements within a loop</P></LI><LI><P class="docList">Group SQL statements together into executable blocks</P></LI><LI><P class="docList">Test for specific conditions and perform one set of SQL statements when the condition is true, another set when the condition is false (<TT>IF...ELSE</TT>)</P></LI><LI><P class="docList">Perform branches to other areas of the procedural code</P></LI></UL>
<P class="docText">The addition of procedural commands to SQL provides a more flexible environment for application developers. Often, major components of an application can be delivered using nothing but SQL. You can code stored procedures and complex triggers using procedural SQL, thereby reducing the amount of host language (COBOL, C, Visual Basic, and so on) programming required.</P>
<P class="docText">Additionally, when stored procedures can be written using just SQL, more users will be inclined to use these features. DB2 requires stored procedures to be written in a host language. This requirement may scare off many potential developers. Most DBAs I know avoid programming (especially in COBOL) like the plague.</P>
<P class="docText">In addition to SQL stored procedures, procedural SQL extensions also enable more complicated business requirements to be coded using nothing but SQL. For example, an independent SQL statement cannot examine each row of a result set during processing. Procedural SQL can accomplish this task quite handily using cursors and looping.<A NAME="ch15index362"></A><A NAME="ch15index363"></A></P>
<A NAME="ch15lev2sec11"></A><H4 class="docSection2Title">The Drawbacks of Procedural SQL</H4>
<P class="docText">The biggest drawback to procedural SQL is that it is late getting into the ANSI standard. Although DB2's stored procedure support is based on the ANSI SQL3 standard, other DBMS vendors support different flavors of procedural SQL because they were developed before the ANSI standard. If your shop has standardized on one particular DBMS or does not need to scale applications across multiple platforms, you may not have this problem. But, then again, how many shops does this description actually describe? Probably not very many!<A NAME="ch15index364"></A><A NAME="ch15index365"></A></P>
<P class="docText">The bottom line is that scalability will suffer when applications are coded using non- standard extensions—such as procedural SQL. Recoding applications that were designed to use stored procedures and triggers written using procedural SQL constructs is a non-trivial task. If an application needs to be scaled to a platform which uses a DBMS that does not support procedural SQL, a complete rewrite is exactly what must be done.</P>
<P class="docText">Performance drawbacks can be realized when using procedural SQL if the developer is not careful. For example, improper cursor specification can cause severe performance problems. Of course, this problem can happen just as easily when cursors are used inside a host language. The problem is more inherent to application design than it is to procedural SQL.</P>
<P class="docText">One final drawback is that even procedural SQL dialects are not computationally complete. Most dialects of procedural SQL lack programming constructs to control the users' screens and mechanisms for data input/output (other than to relational tables).<A NAME="ch15index366"></A><A NAME="ch15index367"></A></P>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch15lev1sec3.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch15lev1sec5.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
