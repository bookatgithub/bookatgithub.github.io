<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>TSO (Time-Sharing Option)</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch18.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch18lev1sec2.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch18lev1sec1"></A><H3 class="docSection1Title" >TSO (Time-Sharing Option)</H3>
<P class="docText">TSO, or Time-Sharing Option, is one of the five basic environments from which DB2 data can be accessed. TSO enables users to interact with the system using an online interface that is either screen- or panel-driven. The Interactive System Productivity Facility, or ISPF, provides the mechanism for communicating by panels, which is the common method for interaction between TSO applications and users. The TSO Attachment Facility provides access to DB2 resources in two ways:<A NAME="ch18index12"></A><A NAME="ch18index13"></A><A NAME="ch18index14"></A><A NAME="ch18index15"></A></P>
<UL><LI><P class="docList">Online, in the TSO foreground, driven by application programs, CLISTs, or REXX <TT>EXEC</TT>s coded to communicate with DB2 and TSO, possibly using ISPF panels<A NAME="ch18index16"></A><A NAME="ch18index17"></A><A NAME="ch18index18"></A><A NAME="ch18index19"></A></P></LI><LI><P class="docList">In batch mode using the TSO Terminal Monitor Program, <TT>IKJEFT01</TT> (or <TT>IKJEFT1B</TT>), to invoke the <TT>DSN</TT> command and run a DB2 application program<A NAME="ch18index20"></A><A NAME="ch18index21"></A><A NAME="ch18index22"></A><A NAME="ch18index23"></A></P></LI></UL>
<P class="docText">TSO is one of the three online environments supported by DB2, but unlike the other two, TSO is not transaction-driven. The TSO Attachment Facility operates by means of a communication channel that uses a single thread to direct DB2 calls. Each user can be logged on, in the foreground, to a single TSO address space at any time.</P>
<P class="docText">Each batch TSO job, however, initiates a different invocation of the TMP, enabling numerous batch TSO jobs submitted by the same user to run simultaneously. The batch jobs are independent of any foreground TSO activity. Thus, a single user, at any given time, can have one online TSO session communicating with DB2 and multiple batch TSO jobs communicating with DB2.</P>
<P class="docText">The TSO Attachment Facility is available for use by simply installing DB2. Communication between DB2 and TSO is accomplished with the <TT>DSN</TT> command processor, which is bundled with DB2. The <TT>DSN</TT> command processor enables users to issue DB2 commands in the TSO environment. One of these commands, the <TT>RUN</TT> command, executes DB2 application programs. (IBM bundles an online TSO application that can be used to access DB2 data: DB2 Interactive, or DB2I. DB2I is discussed in greater depth later in this section.)<A NAME="ch18index24"></A><A NAME="ch18index25"></A></P>
<P class="docText">As you can see in <A class="docLink" HREF="#ch18fig02">Figure 18.2</A>, the <TT>DSN</TT> command processor establishes the thread that enables TSO to communicate with DB2. An alternative method is to use the Call Attach Facility in TSO to communicate with DB2. The Call Attach Facility is discussed later in the "<A class="docLink" HREF="ch18lev1sec4.html#ch18lev1sec4">CAF (Call Attach Facility)</A>" section of this chapter.<A NAME="ch18index26"></A><A NAME="ch18index27"></A></P>
<A NAME="ch18fig02"></A><p><CENTER><H5 class="docFigureTitle">Figure 18.2. Using the TSO Attach Facility.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/18fig02_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="410" SRC="images/0672326132/graphics/18fig02.gif" ALT="graphics/18fig02.gif"></p></CENTER></p><br>
<A NAME="ch18lev2sec1"></A><H4 class="docSection2Title">TSO/DB2 Parameters</H4>
<P class="docText">DB2 is a parameter-driven subsystem. A series of parameters known as DSNZPARMs, or simply ZPARMs, is passed to DB2 when it is started. A complete discussion of the DSNZPARMs is supplied in <A class="docLink" HREF="ch28.html#ch28">Chapter 28</A>, "Tuning DB2's Components." Because two of these parameters—<TT>IDFORE</TT> and <TT>IDBACK</TT>—apply directly to TSO, however, I will discuss them here.<A NAME="ch18index28"></A><A NAME="ch18index29"></A></P>
<P class="docText"><TT>IDFORE</TT> controls the number of users that can access DB2 simultaneously from the TSO foreground. The types of TSO foreground users include the following:<A NAME="ch18index30"></A><A NAME="ch18index31"></A></P>
<UL><LI><P class="docList">DB2I</P></LI><LI><P class="docList">QMF</P></LI><LI><P class="docList">Users running the <TT>DSN</TT> command (through ISPF, CLISTs, REXX, and so on)</P></LI><LI><P class="docList">Users running TSO/DB2 programs through the Call Attach Facility</P></LI><LI><P class="docList">Users running any DB2 tool online in foreground TSO</P></LI></UL>
<P class="docText">DB2 limits the number of TSO foreground tasks to the number specified in the <TT>IDFORE</TT> parameter. When the limit is reached, any subsequent request for additional foreground TSO tasks is rejected.</P>
<P class="docText"><TT>IDBACK</TT> controls the number of concurrent DB2 batch connections. These connections, however, are not limited to TSO batch connections. They include the following:<A NAME="ch18index32"></A><A NAME="ch18index33"></A></P>
<UL><LI><P class="docList">Batch DB2 jobs using the <TT>DSN</TT> command</P></LI><LI><P class="docList">Batch DB2 jobs using the Call Attach Facility</P></LI><LI><P class="docList">QMF batch jobs</P></LI><LI><P class="docList">DB2 utilities<A NAME="ch18index34"></A><A NAME="ch18index35"></A></P></LI></UL>
<A NAME="ch18lev2sec2"></A><H4 class="docSection2Title">DB2 Access Using Batch TSO</H4>
<P class="docText">DB2 batch programs are executed in the background under the control of the TSO terminal monitor program. A TSO session is thereby created in batch. The <TT>DSN</TT> command is invoked by this session through input specified in the <TT>SYSTSIN</TT> data set. See <A class="docLink" HREF="#ch18list01">Listing 18.1</A> for JCL to run a batch TSO/DB2 program.<A NAME="ch18index36"></A><A NAME="ch18index37"></A><A NAME="ch18index38"></A><A NAME="ch18index39"></A></P>
<A NAME="ch18list01"></A><H5 class="docExampleTitle">Listing 18.1. Batch JCL for a TSO/DB2 Program</H5><A NAME="ch18index40"></A>

<PRE>
//DB2JOBB JOB (BATCH),'DB2 BATCH',MSGCLASS=X,CLASS=X,
//         NOTIFY=USER
//*
//***************************************************************
//*
//*       JCL TO RUN A DB2 PROGRAM IN BATCH
//*       USING THE TSO TERMINAL MONITOR PROGRAM
//*
//***************************************************************
//*
//JOBLIB     DD DSN=SYS1.DB2V810.DSNLOAD,DISP=SHR
//BATCHPRG   EXEC PGM=IKJEFT01,DYNAMNBR=20
//SYSTSPRT   DD  SYSOUT=*
//SYSPRINT   DD  SYSOUT=*
//SYSUDUMP   DD  SYSOUT=*
//SYSTSIN    DD  *
  DSN SYSTEM(DB2P)
  RUN PROGRAM(PROG0001)  -
  PLAN(PLAN0001)  -
  LIB('APPL.LOAD.LIBRARY')
  END
/*
//
</PRE><BR>

<P class="docText">This JCL invokes TSO in batch, reads the <TT>SYSTSIN</TT> input, and invokes the <TT>DSN</TT> command processor for the DB2P subsystem. Next, it runs the program named <TT>PROG0001</TT> using the plan <TT>PLAN0001</TT>. When the program is complete, the <TT>DSN</TT> session ends.<A NAME="ch18index41"></A><A NAME="ch18index42"></A><A NAME="ch18index43"></A><A NAME="ch18index44"></A></P>
<A NAME="ch18lev2sec3"></A><H4 class="docSection2Title">DB2 Access Using Foreground TSO</H4>
<P class="docText">Another way to access DB2 data is through online, or foreground, TSO using the <TT>DSN</TT> command processor. You simply issue the following command from either ISPF option 6 or the TSO <TT>READY</TT> prompt:<A NAME="ch18index45"></A><A NAME="ch18index46"></A><A NAME="ch18index47"></A><A NAME="ch18index48"></A><A NAME="ch18index49"></A><A NAME="ch18index50"></A></P>
<pre>

</pre><BR><pre>
DSN SYSTEM(<span class="docEmphasis">xxxx</span>)
</pre><BR>
<P class="docText">Here, <span class="docEmphasis"><TT>xxxx</TT></span> represents the DB2 subsystem name. This command places you under the control of <TT>DSN</TT>. A prompt labeled <TT>DSN</TT> appears, indicating that you are in the middle of a <TT>DSN</TT> session. You can issue any <TT>DSN</TT> subcommand, including the <TT>RUN</TT> subcommand. The <TT>DSN</TT> command processor and its associated subcommands are discussed more fully in <A class="docLink" HREF="ch36.html#ch36">Chapter 36</A>, "DB2 Commands."</P>
<P class="docText">Suppose that you want to run a DB2 program called <TT>SAMPLE2</TT> using the plan <TT>SAM2PLAN</TT> in foreground TSO. To do so, you can issue the following commands:</P>
<pre>

</pre><BR><pre>
READY
  <span class="docEmphStrong">DSN SYSTEM(DB2T)</span>
DSN
  <span class="docEmphStrong">RUN PROGRAM(SAMPLE2) PLAN(SAM2PLAN)</span>
DSN
  <span class="docEmphStrong">END</span>
READY
</pre><BR>
<P class="docText">The boldface words are entered by the user. The other words are system prompts returned by TSO or the <TT>DSN</TT> command processor.</P>
<P class="docText">Rather than using the <TT>DSN</TT> command directly from a terminal, as just discussed, embedding the execution of a DB2 program in a <TT>CLIST</TT> or REXX <TT>EXEC</TT> is more common. A TSO user can invoke the <TT>CLIST</TT> or <TT>EXEC</TT> either directly by entering its name from ISPF option 6 or the TSO <TT>READY</TT> prompt, or as a selection from an ISPF panel. <A class="docLink" HREF="#ch18fig03">Figure 18.3</A> shows a common configuration for an online, TSO, ISPF-driven DB2 application.<A NAME="ch18index51"></A><A NAME="ch18index52"></A><A NAME="ch18index53"></A><A NAME="ch18index54"></A><A NAME="ch18index55"></A><A NAME="ch18index56"></A></P>
<A NAME="ch18fig03"></A><p><CENTER><H5 class="docFigureTitle">Figure 18.3. A typical ISPF online DB2 application.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/18fig03_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="499" SRC="images/0672326132/graphics/18fig03.gif" ALT="graphics/18fig03.gif"></p></CENTER></p><br>
<A NAME="ch18lev2sec4"></A><H4 class="docSection2Title">Online TSO/DB2 Design Techniques</H4>
<P class="docText">Programmers can follow two basic scenarios for developing online TSO programs that access DB2 data. Each scenario provides a different level of runtime efficiency and support for application development. These two scenarios provide either fast application development or efficient performance.<A NAME="ch18index57"></A><A NAME="ch18index58"></A><A NAME="ch18index59"></A><A NAME="ch18index60"></A><A NAME="ch18index61"></A></P>
<P class="docText">Using the fast application development scenario enables programmers to make full use of the development tools provided by TSO and ISPF. The normal processing flow for this scenario is a seven-step process<A NAME="ch18index62"></A><A NAME="ch18index63"></A></P>
<A NAME="ch18pr01"></A>






<div style="font-weight:bold"><OL class="docList" START="1"><LI value="1"><div style="font-weight:normal">An ISPF menu appears, containing options for one or more TSO/DB2 application programs.<BR><BR></div></LI><LI value="2"><div style="font-weight:normal">The user selects an option for the DB2 application he or she wants to execute.<BR><BR></div></LI><LI value="3"><div style="font-weight:normal">The option invokes a <TT>CLIST</TT> that issues the <TT>DSN</TT> command and the <TT>RUN</TT> subcommand for the selected option.<BR><BR></div></LI><LI value="4"><div style="font-weight:normal">The program displays a panel, engaging in a dialog with the user whereby data can be entered, validated, and processed. The user selects an option or function key on the panel to signal when he or she has finished.<BR><BR></div></LI><LI value="5"><div style="font-weight:normal">The user can process multiple panels but only for the selected program.<BR><BR></div></LI><LI value="6"><div style="font-weight:normal">When the user indicates that he or she has finished, the program ends and control is returned to the <TT>CLIST</TT>. The <TT>CLIST</TT> immediately issues the <TT>DSN END</TT> subcommand, which ends the connection to DB2.<BR><BR></div></LI><LI value="7"><div style="font-weight:normal">The original menu is then displayed so that the user can select another option.<A NAME="ch18index64"></A><A NAME="ch18index65"></A><A NAME="ch18index66"></A><A NAME="ch18index67"></A><A NAME="ch18index68"></A><BR><BR></div></LI></OL></div>
<P class="docText">This scenario provides maximum programming flexibility using minimum system resources. It has two drawbacks, however. Each time the user selects a menu option, a large amount of overhead is involved to load and run the CLIST, invoke <TT>DSN</TT>, issue the <TT>RUN</TT> command, load the program module, and create the thread. Also, each menu option consists of a single load module and plan. This scenario effectively eliminates the capability to switch from program to program using <TT>ISPLINK</TT> because one program and its associated plan accomplish one task.</P>
<P class="docText">The scenario to process a TSO application achieving efficient performance is a nine-step process:<A NAME="ch18index69"></A><A NAME="ch18index70"></A></P>
<A NAME="ch18pr02"></A>








<div style="font-weight:bold"><OL class="docList" START="1"><LI value="1"><div style="font-weight:normal">An ISPF menu appears, containing an option for one or more TSO/DB2 application programs.<BR><BR></div></LI><LI value="2"><div style="font-weight:normal">The user selects an option for the DB2 application he or she wants to execute.<BR><BR></div></LI><LI value="3"><div style="font-weight:normal">The option invokes a <TT>CLIST</TT> that issues the <TT>DSN</TT> command and the <TT>RUN</TT> subcommand for the selected option.<BR><BR></div></LI><LI value="4"><div style="font-weight:normal">The program displays a menu from which the user can select the programs that make up the TSO/DB2 application.<BR><BR></div></LI><LI value="5"><div style="font-weight:normal">When a menu option is chosen, the program calls another program. (All programs are linked into a single load module.)<BR><BR></div></LI><LI value="6"><div style="font-weight:normal">The called program displays a panel, engaging in a dialog with the users whereby data can be entered, validated, and processed. The user selects an option or function key on the panel to signal when he or she has finished.<BR><BR></div></LI><LI value="7"><div style="font-weight:normal">The user can process multiple panels in the program. You also can provide options to run other programs in the application based on user input or function keys.<BR><BR></div></LI><LI value="8"><div style="font-weight:normal">When the user indicates that he or she has finished, the control program redisplays the menu. The user can then back out of the menu that causes the <TT>CLIST</TT> to issue the <TT>DSN END</TT> subcommand, ending the connection to DB2.<BR><BR></div></LI><LI value="9"><div style="font-weight:normal">The original ISPF menu is then displayed so that the user can select another option.<A NAME="ch18index71"></A><A NAME="ch18index72"></A><A NAME="ch18index73"></A><A NAME="ch18index74"></A><A NAME="ch18index75"></A><BR><BR></div></LI></OL></div>
<P class="docText">When you develop applications using this scenario, overhead is reduced significantly. The <TT>CLIST</TT> is loaded and executed only once, <TT>DSN</TT> is invoked only once, the program modules are loaded only once, and a single thread is established once and used for the duration of the user's stay in the application.</P>
<P class="docText">This scenario has some drawbacks, however. The application can contain one potentially very large program load module. Each time a program is modified, the entire module must be link-edited again. This process uses a lot of CPU time. Also, application downtime is required because the application must wait for the link-edit process to complete. In addition, more virtual storage is required to store the program load module as it executes.</P>
<P class="docText">Additionally, you must take extra care when determining how to bind the application. For applications developed on older releases of DB2 (prior to V2.3), a single large plan may exist that consists of every DBRM in the application. This used to be required by DB2. This scenario causes the same types of problems as a large program load module:<A NAME="ch18index76"></A><A NAME="ch18index77"></A><A NAME="ch18index78"></A></P>
<UL><LI><P class="docList">Extra CPU time is used for a bind.</P></LI><LI><P class="docList">Application downtime is increased while waiting for the bind.</P></LI><LI><P class="docList">More virtual storage is required to hold the plan in the EDM Pool as the program runs.</P></LI></UL>
<P class="docText">The better application design option is for each program DBRM to be bound to a single package. All the packages are then included in the package list of a plan (either explicitly or using wildcards). This scenario reduces bind time, thereby decreasing CPU time and application downtime waiting for the bind to complete.</P>
<P class="docText">A final drawback to this scenario is that when the <TT>DSN</TT> command is used to run online TSO programs, the thread is created when the first SQL call is made. When the program is composed of many programs that call one another, a thread can be tied up for an inordinate amount of time.<A NAME="ch18index79"></A><A NAME="ch18index80"></A><A NAME="ch18index81"></A><A NAME="ch18index82"></A><A NAME="ch18index83"></A></P>
<P class="docText">When the application is invoked, the <TT>DSN</TT> command is issued, specifying the online application's load module and the composite plan. The thread created for this program's execution remains active until the program ends. One thread is used for each user of the TSO/DB2 application for the duration of its execution.</P>
<P class="docText">TSO is not a transaction-driven system. Users can enter a TSO application and leave a terminal inactive in the middle of the application, thus tying up a DB2 thread. That thread is not necessary when the user is thinking about what to do next or has walked away from the terminal.</P>
<P class="docText">An alternative solution is to use the Call Attach Facility to control the activation and deactivation of threads. This technique is addressed in the upcoming section on CAF.<A NAME="ch18index84"></A><A NAME="ch18index85"></A><A NAME="ch18index86"></A><A NAME="ch18index87"></A><A NAME="ch18index88"></A></P>
<A NAME="ch18lev2sec5"></A><H4 class="docSection2Title">DB2I and SPUFI</H4>
<P class="docText">DB2I is a TSO-based DB2 application. It consists of a series of ISPF panels, programs, and <TT>CLIST</TT>s enabling rapid access to DB2 services and data. Using DB2I can increase the TSO DB2 developer's productivity. DB2I provides many features that can be exploited by the TSO user to query and administer DB2 data. To access DB2I, follow this sequence:<A NAME="ch18index89"></A><A NAME="ch18index90"></A><A NAME="ch18index91"></A></P>
<A NAME="ch18pr03"></A>


<div style="font-weight:bold"><OL class="docList" START="1"><LI value="1"><div style="font-weight:normal">Log on to TSO as you normally would.<BR><BR></div></LI><LI value="2"><div style="font-weight:normal">If the logon procedure does not automatically place you into ISPF, enter ISPF. The ISPF main menu appears.<BR><BR></div></LI><LI value="3"><div style="font-weight:normal">Choose the DB2I option. This option most often is available directly from the main ISPF menu. However, DB2I could be on a different ISPF menu (for example, a System Services, Database Options, or User menu), or it could be accessible only through a <TT>CLIST</TT>. (Consult your shop standards, if necessary, to determine the correct method of accessing DB2I.)<BR><BR></div></LI></OL></div>
<P class="docText">After you select the DB2I option, the main menu appears, as shown in <A class="docLink" HREF="#ch18fig04">Figure 18.4</A>. This figure shows all DB2I features, including those used for program preparation and execution, as discussed in <A class="docLink" HREF="ch13.html#ch13">Chapter 13</A>, "Program Preparation." Each DB2I option is discussed in the following sections.<A NAME="ch18index92"></A><A NAME="ch18index93"></A><A NAME="ch18index94"></A></P>
<A NAME="ch18fig04"></A><p><CENTER><H5 class="docFigureTitle">Figure 18.4. The DB2I menu.</H5><A NAME="ch18index95"></A><A NAME="ch18index96"></A><A NAME="ch18index97"></A>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/18fig04_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="375" SRC="images/0672326132/graphics/18fig04.gif" ALT="graphics/18fig04.gif"></p></CENTER></p><br>
<A NAME="ch18lev3sec1"></A><H5 class="docSection3Title">SPUFI Option</H5>
<P class="docText">The first option in the DB2I main menu is SPUFI, or SQL Processor Using File Input. It reads SQL statements contained as text in a sequential file, processes those statements, and places you in an ISPF browse session to view the results. <A class="docLink" HREF="#ch18fig05">Figure 18.5</A> shows the SPUFI panel.<A NAME="ch18index98"></A><A NAME="ch18index99"></A><A NAME="ch18index100"></A><A NAME="ch18index101"></A><A NAME="ch18index102"></A><A NAME="ch18index103"></A><A NAME="ch18index104"></A><A NAME="ch18index105"></A><A NAME="ch18index106"></A><A NAME="ch18index107"></A></P>
<A NAME="ch18fig05"></A><p><CENTER><H5 class="docFigureTitle">Figure 18.5. The DB2I SPUFI panel.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/18fig05_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="358" SRC="images/0672326132/graphics/18fig05.gif" ALT="graphics/18fig05.gif"></p></CENTER></p><br>
<P class="docText">By specifying an input and output data set and selecting the appropriate options, you can execute SQL statements in an online mode. The SPUFI options follow:</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5"><COLGROUP><COL width="126.5"><COL width="423.5"></COLGROUP><THEAD></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Change Defaults</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">When <TT>Y</TT> is specified , the SPUFI defaults panel appears, as shown in <A class="docLink" HREF="#ch18fig06">Figure 18.6</A>.</P>
</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Edit Input</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">When <TT>Y</TT> is specified, SPUFI places you in an ISPF edit session for the input data set. This way, you can change the input SQL before its execution. Never specify <TT>N</TT> in this field. When you want to bypass editing your input file, place an asterisk (<TT>*</TT>) in this field; DB2I bypasses the edit step but resets the field to its previous value the next time SPUFI is invoked. If you use <TT>N</TT> and you forget to change the field back to <TT>Y</TT>, your next invocation of SPUFI executes SQL without allowing you to edit your SQL.</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Execute</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">When <TT>Y</TT> is specified, the SQL in the input file is read and executed.</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Autocommit</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">When <TT>Y</TT> is specified, a <TT>COMMIT</TT> is issued automatically after the successful execution of the SQL in the input file. When you specify <TT>N</TT>, SPUFI prompts you about whether a <TT>COMMIT</TT> should be issued. If the <TT>COMMIT</TT> is not issued, all changes are rolled back.</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Browse Output</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">When <TT>Y</TT> is specified, SPUFI places you in an ISPF browse session for the output data set. You can view the results of the SQL that was executed.</P></TD></TR></TABLE></P><br>
<P class="docText">Specifying <TT>Y</TT> for all these options except Change Defaults is common. Typically, defaults are changed only once—the first time someone uses SPUFI. ISPF saves the defaults entered from session to session. Use these options—as you see fit—to control your SPUFI executions. The defaults panel is shown in <A class="docLink" HREF="#ch18fig06">Figure 18.6</A>.</P>
<A NAME="ch18fig06"></A><p><CENTER>
<H5 class="docFigureTitle">Figure 18.6. The DB2I SPUFI Defaults panel.</H5><A NAME="ch18index108"></A><A NAME="ch18index109"></A><A NAME="ch18index110"></A><A NAME="ch18index111"></A>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/18fig06_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="358" SRC="images/0672326132/graphics/18fig06.gif" ALT="graphics/18fig06.gif"></p>
</CENTER></p><br>
<P class="docText">The SPUFI input data set can contain multiple SQL statements, as long as they are separated by semicolons. For example, you could successfully code the following statements in a SPUFI input data set:<A NAME="ch18index112"></A><A NAME="ch18index113"></A><A NAME="ch18index114"></A><A NAME="ch18index115"></A><A NAME="ch18index116"></A><A NAME="ch18index117"></A><A NAME="ch18index118"></A></P>
<pre>

</pre><BR><pre>
--
-- THIS SQL STATEMENT WILL SELECT ALL ROWS OF THE
-- SAMPLE TABLE, DSN8810.DEPT
  SELECT * FROM DSN8810.DEPT;
--
-- THIS SQL STATEMENT WILL SET THE SALARY FOR ALL EMPLOYEES
-- WITH THE LAST NAME OF 'KWAN' TO ZERO
  UPDATE DSN8810.EMP
  SET SALARY = 0
  WHERE LASTNAME = 'KWAN';
--
-- THIS SQL STATEMENT WILL ROLL BACK THE CHANGES MADE BY
-- THE PREVIOUS SQL STATEMENT
  ROLLBACK;
</pre><BR>
<P class="docText">This sample input for the SPUFI processor contains three SQL statements. Each SQL statement is separated from the others by the semicolon that terminates each statement. Comments are preceded by two hyphens. When the SQL is executed and browsed, an output data set like the following appears:<A NAME="ch18index119"></A><A NAME="ch18index120"></A><A NAME="ch18index121"></A><A NAME="ch18index122"></A></P>
<pre>

</pre><BR><pre>
--------+--------+--------+--------+--------+--------+-
-- THIS SQL STATEMENT WILL SELECT ALL ROWS OF THE
-- SAMPLE TABLE, DSN8810.DEPT
  SELECT * FROM DSN8810.DEPT;
--------+--------+--------+--------+--------+--------+-
DEPTNO  DEPTNAME                        MGRNO        ADMRDEPT
--------+--------+--------+--------+--------+--------+-
A00     SPIFFY COMPUTER SERVICE DIV.    000010       A00
B01     PLANNING                        000020       A00
C01     INFORMATION CENTER              000030       A00
D01     DEVELOPMENT CENTER              -------       A00
E01     SUPPORT SERVICES                000050       A00
D11     MANUFACTURING SYSTEMS           000060       D01
D21     ADMINISTRATION SYSTEMS          000070       D01
E11     OPERATIONS                      000090       E01
E21     SOFTWARE SUPPORT                000010       E01
DSNE610I NUMBER OF ROWS DISPLAYED IS 9
DSNE616I STATEMENT EXECUTION WAS SUCCESSFUL, SQLCODE IS 100
--------+--------+--------+--------+--------+--------+-
--
--THIS SQL STATEMENT WILL SET THE SALARY FOR ALL EMPLOYEES
--WITH THE LAST NAME OF 'KWAN' TO ZERO
  UPDATE DSN8810.EMP
  SET SALARY = 0
  WHERE LASTNAME = 'KWAN';
--------+--------+--------+--------+--------+--------+-
DSNE615I NUMBER OF ROWS AFFECTED IS 1
DSNE616I STATEMENT EXECUTION WAS SUCCESSFUL, SQLCODE IS 0
--------+--------+--------+--------+--------+--------+-
--
-- THIS SQL STATEMENT WILL ROLL BACK THE CHANGES MADE BY
-- THE PREVIOUS SQL STATEMENT
  ROLLBACK;
--------+--------+--------+--------+--------+--------+-
DSNE616I STATEMENT EXECUTION WAS SUCCESSFUL, SQLCODE IS 0
--------+--------+--------+--------+--------+--------+-
DSNE617I COMMIT PERFORMED, SQLCODE IS 0
DSNE616I STATEMENT EXECUTION WAS SUCCESSFUL, SQLCODE IS 0
--------+--------+--------+--------+--------+--------+-
DSNE601I SQL STATEMENTS ASSUMED TO BE BETWEEN COLUMNS 1 AND 72
DSNE620I NUMBER OF SQL STATEMENTS PROCESSED IS 3
DSNE621I NUMBER OF INPUT RECORDS READ IS 17
DSNE622I NUMBER OF OUTPUT RECORDS WRITTEN IS 48
</pre><BR>
<P class="docText">The data set used for input of SQL must be allocated before invoking SPUFI. The data set can be empty and can be edited as part of the SPUFI session. It is recommended that each SPUFI user maintain a partitioned data set containing his or her SPUFI input. This way, users can keep and reference frequently used SQL statements. The SPUFI input data set should be defined as a fixed, blocked data set with an LRECL of <TT>80</TT>. You can write SQL statements in all but the last 8 bytes of each input record; this area is reserved for sequence numbers.<A NAME="ch18index123"></A><A NAME="ch18index124"></A><A NAME="ch18index125"></A></P>
<P class="docText">You do not need to allocate the output data set before using SPUFI. If the output data set does not exist, SPUFI creates a virtual, blocked sequential data set with an LRECL of <TT>4092</TT>.<A NAME="ch18index126"></A><A NAME="ch18index127"></A><A NAME="ch18index128"></A><A NAME="ch18index129"></A></P>
<P class="docText">Set the proper SPUFI defaults (see <A class="docLink" HREF="#ch18fig06">Figure 18.6</A>). You can set these defaults the first time you use SPUFI and then bypass them on subsequent SPUFI runs. Be sure to specify the following defaults:<A NAME="ch18index130"></A><A NAME="ch18index131"></A></P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5"><COLGROUP><COL width="148.5"><COL width="401.5"></COLGROUP><THEAD></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Isolation Level</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Favor setting this option to <TT>CS</TT>. You might choose <TT>UR</TT> to improve performance, but at the expense of possible data integrity problems. If you require an Isolation Level of <TT>RR</TT>, you probably should be accessing the data programmatically rather than with SPUFI.</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Max Select Lines</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Set to an appropriate number. If you will be selecting from large tables that return more than 250 rows, the installation default value of <TT>250</TT> is insufficient. SPUFI stops returning rows after reaching the specified limit, and it issues a message indicating so.</P></TD></TR></TABLE></P><br>
<P class="docText">The other default values are appropriate for most situations.<A NAME="ch18index132"></A><A NAME="ch18index133"></A><A NAME="ch18index134"></A><A NAME="ch18index135"></A></P>
<A NAME="ch18lev3sec2"></A><H5 class="docSection3Title">DCLGEN Option</H5>
<P class="docText">The <TT>DCLGEN</TT> option in the DB2I main menu automatically produces a data set containing a <TT>DECLARE TABLE</TT> statement and valid <TT>WORKING-STORAGE</TT> host variables for a given DB2 table.<A NAME="ch18index136"></A><A NAME="ch18index137"></A><A NAME="ch18index138"></A><A NAME="ch18index139"></A></P>
<P class="docText">You can include the data set in a COBOL program to enable embedded SQL access. See <A class="docLink" HREF="ch13.html#ch13">Chapter 13</A> for more details on <TT>DCLGEN</TT>.</P>
<A NAME="ch18lev3sec3"></A><H5 class="docSection3Title">Program Preparation Option</H5>
<P class="docText">The Program Preparation option in the DB2I main menu prepares a program containing embedded SQL for execution. See <A class="docLink" HREF="ch13.html#ch13">Chapter 13</A> for more details on DB2 program preparation.<A NAME="ch18index140"></A><A NAME="ch18index141"></A><A NAME="ch18index142"></A><A NAME="ch18index143"></A></P>
<A NAME="ch18lev3sec4"></A><H5 class="docSection3Title">Precompile Option</H5>
<P class="docText">Precompile is the fourth option on the DB2I main menu. In precompilation, a program containing embedded SQL is parsed to retrieve all SQL and replace it with calls to a runtime interface to DB2. See <A class="docLink" HREF="ch13.html#ch13">Chapter 13</A> for more details on precompiling a DB2 program.<A NAME="ch18index144"></A><A NAME="ch18index145"></A><A NAME="ch18index146"></A><A NAME="ch18index147"></A></P>
<A NAME="ch18lev3sec5"></A><H5 class="docSection3Title">Bind/Rebind/Free Option</H5>
<P class="docText">When you select Option 5 of the DB2I menu, the Bind/Rebind/Free menu shown in <A class="docLink" HREF="#ch18fig07">Figure 18.7</A> appears.</P>
<A NAME="ch18fig07"></A><p><CENTER><H5 class="docFigureTitle">Figure 18.7. The DB2I Bind/Rebind/Free menu.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/18fig07_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="358" SRC="images/0672326132/graphics/18fig07.gif" ALT="graphics/18fig07.gif"></p></CENTER></p><br>
<P class="docText">Option 1 on this menu provides the capability to bind a DB2 plan, and option 4 binds a package. These options are discussed fully in <A class="docLink" HREF="ch13.html#ch13">Chapter 13</A>.<A NAME="ch18index148"></A><A NAME="ch18index149"></A><A NAME="ch18index150"></A><A NAME="ch18index151"></A><A NAME="ch18index152"></A><A NAME="ch18index153"></A><A NAME="ch18index154"></A><A NAME="ch18index155"></A></P>
<P class="docText">The second option is Rebind Plan. When you choose this option, the panel in <A class="docLink" HREF="#ch18fig08">Figure 18.8</A> appears. A plan can be rebound, thereby rechecking syntax, reestablishing access paths, and in general, redoing the bind. However, rebind does not enable you to add a DBRM to the plan. In addition, if any of the rebind parameters are not specified, they default to the options specified at bind time, not to the traditional bind defaults. Rebind is particularly useful for determining new access paths after running the <TT>RUNSTATS</TT> utility.<A NAME="ch18index156"></A><A NAME="ch18index157"></A><A NAME="ch18index158"></A><A NAME="ch18index159"></A></P>
<A NAME="ch18fig08"></A><p><CENTER><H5 class="docFigureTitle">Figure 18.8. The DB2I Rebind Plan panel.</H5><A NAME="ch18index160"></A><A NAME="ch18index161"></A>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/18fig08_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="358" SRC="images/0672326132/graphics/18fig08.gif" ALT="graphics/18fig08.gif"></p></CENTER></p><br>
<P class="docText">Option 5 provides the capability to rebind a package. You rebind packages in much the same way you rebind plans. <A class="docLink" HREF="#ch18fig09">Figure 18.9</A> shows the Rebind Package panel.<A NAME="ch18index162"></A><A NAME="ch18index163"></A><A NAME="ch18index164"></A><A NAME="ch18index165"></A><A NAME="ch18index166"></A><A NAME="ch18index167"></A></P>
<A NAME="ch18fig09"></A><p><CENTER><H5 class="docFigureTitle">Figure 18.9. The DB2I Rebind Package panel.</H5><A NAME="ch18index168"></A><A NAME="ch18index169"></A>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/18fig09_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="358" SRC="images/0672326132/graphics/18fig09.gif" ALT="graphics/18fig09.gif"></p></CENTER></p><br>
<P class="docText">There is a significant amount of confusion about the difference between the <TT>REBIND</TT> command and the <TT>BIND REPLACE</TT> command. A <TT>REBIND</TT> simply <span class="docEmphasis">reevaluates access paths</span> for the DBRMs currently in a plan (or the single DBRM in a package). <TT>BIND REPLACE</TT>, on the other hand, <span class="docEmphasis">replaces</span> all the DBRMs in the plan. So, if you must use a different DBRM, <TT>BIND REPLACE</TT> is your only option. If you must simply change access path selections based on current statistics, <TT>REBIND</TT> will do the trick.</P>
<P class="docText">On the Bind/Rebind/Free menu, Option 3, Free Plan, and Option 6, Free Package, enable you to remove plans and packages from the system. <A class="docLink" HREF="#ch18fig10">Figure 18.10</A> shows the Free Plan panel, and <A class="docLink" HREF="#ch18fig11">Figure 18.11</A> shows the Free Package panel. You simply specify the names of the plans or packages to remove from the system, and they are <span class="docEmphasis">freed</span>.<A NAME="ch18index170"></A><A NAME="ch18index171"></A><A NAME="ch18index172"></A><A NAME="ch18index173"></A><A NAME="ch18index174"></A><A NAME="ch18index175"></A><A NAME="ch18index176"></A><A NAME="ch18index177"></A></P>
<A NAME="ch18fig10"></A><p><CENTER><H5 class="docFigureTitle">Figure 18.10. The DB2I Free Plan panel.</H5><A NAME="ch18index178"></A><A NAME="ch18index179"></A>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/18fig10_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="358" SRC="images/0672326132/graphics/18fig10.gif" ALT="graphics/18fig10.gif"></p></CENTER></p><br>
<A NAME="ch18fig11"></A><p><CENTER><H5 class="docFigureTitle">Figure 18.11. The DB2I Free Package panel.</H5><A NAME="ch18index180"></A><A NAME="ch18index181"></A>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/18fig11_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="358" SRC="images/0672326132/graphics/18fig11.gif" ALT="graphics/18fig11.gif"></p></CENTER></p><br>
<P class="docText">Packages and plans you no longer use should be freed from the DB2 subsystem. Doing so frees DB2 Directory and DB2 Catalog pages for use by other packages and plans.</P>
<A NAME="ch18note01"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Avoid issuing the <TT>FREE (*)</TT> command. This command drops every plan in the DB2 subsystem, which is probably not your intention. Additionally, a large amount of resources is used to execute this command.</P></div><br>
<A NAME="ch18lev3sec6"></A><H5 class="docSection3Title">Run Option</H5>
<P class="docText">The sixth DB2I option enables you to run a DB2 application program. The Run option is rarely used. More often, foreground DB2 programs are invoked by <TT>CLIST</TT>s, REXX <TT>EXEC</TT>s, or ISPF panels, and background DB2 programs are invoked through preexisting batch JCL. When you select this option, the Run panel appears, as shown in <A class="docLink" HREF="#ch18fig12">Figure 18.12</A>. You simply specify the load library data set (including the member name) for the program to be run, along with any necessary parameters, the appropriate plan name, and a <TT>WHERE TO RUN</TT> option. The three <TT>WHERE TO RUN</TT> options follow:<A NAME="ch18index182"></A><A NAME="ch18index183"></A><A NAME="ch18index184"></A><A NAME="ch18index185"></A></P>
<A NAME="ch18fig12"></A><p><CENTER><H5 class="docFigureTitle">Figure 18.12. The DB2I Run panel.</H5><A NAME="ch18index186"></A><A NAME="ch18index187"></A>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/18fig12_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="358" SRC="images/0672326132/graphics/18fig12.gif" ALT="graphics/18fig12.gif"></p></CENTER></p><br>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5"><COLGROUP><COL width="143"><COL width="407"></COLGROUP><THEAD></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>FOREGROUND</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">The program is run to completion, tying up the terminal from which the run was submitted for the duration of the program's run.</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BACKGROUND</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">JCL is automatically built to run the program and is submitted in batch for processing.</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>EDITJCL</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">JCL is automatically built and displayed for you. You have the option of editing the JCL. You then can submit the JCL.</P></TD></TR></TABLE></P><br>
<A NAME="ch18lev3sec7"></A><H5 class="docSection3Title">DB2 Commands Option</H5>
<P class="docText">When you select DB2I option 7, DB2 Commands, the panel in <A class="docLink" HREF="#ch18fig13">Figure 18.13</A> appears, enabling you to submit DB2 commands using TSO. For example, the command shown in <A class="docLink" HREF="#ch18fig12">Figure 18.12</A> displays the status of adatabase. In-depth coverage of DB2 commands is included in <A class="docLink" HREF="part06.html#part06">Part VI</A>.<A NAME="ch18index188"></A><A NAME="ch18index189"></A><A NAME="ch18index190"></A><A NAME="ch18index191"></A></P>
<A NAME="ch18fig13"></A><p><CENTER><H5 class="docFigureTitle">Figure 18.13. The DB2I Commands panel.</H5><A NAME="ch18index192"></A><A NAME="ch18index193"></A>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/18fig13_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="358" SRC="images/0672326132/graphics/18fig13.gif" ALT="graphics/18fig13.gif"></p></CENTER></p><br>
<A NAME="ch18lev3sec8"></A><H5 class="docSection3Title">Utilities Option</H5>
<P class="docText">DB2I also provides panels that ease the administrative burdens of DB2 utility processing. Using option 8 of DB2I, the Utilities option, you can generate utility JCL, submit the utility JCL, display the status of utilities, and terminate utilities using a panel-driven interface. For a complete discussion of the DB2 utilities and the use of DB2I to control DB2 utility processing, consult <A class="docLink" HREF="part06.html#part06">Part VI</A>.<A NAME="ch18index194"></A><A NAME="ch18index195"></A><A NAME="ch18index196"></A><A NAME="ch18index197"></A></P>
<A NAME="ch18lev3sec9"></A><H5 class="docSection3Title">DB2I Defaults Option</H5>
<P class="docText">The defaults panel, DB2I option D, lets you modify parameters that control the operation of DB2I (see <A class="docLink" HREF="#ch18fig14">Figure 18.14</A>). Be sure that the proper DB2 subsystem is specified in the DB2 Name parameter. If your production DB2 subsystem runs on the same central electronic complex as your test DB2 subsystem, disaster can result if the name is not coded properly. Be sure also that you supply the proper language to be used for preparing DB2 programs in the Application Language parameter and a valid job card for your shop in the DB2I Job Statement parameter. A second default panel (such as the one shown in <A class="docLink" HREF="#ch18fig15">Figure 18.15</A>) can be displayed for language defaults based on the Application Language chosen.<A NAME="ch18index198"></A><A NAME="ch18index199"></A><A NAME="ch18index200"></A><A NAME="ch18index201"></A></P>
<A NAME="ch18fig14"></A><p><CENTER><H5 class="docFigureTitle">Figure 18.14. The DB2I Defaults panel.</H5><A NAME="ch18index202"></A><A NAME="ch18index203"></A>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/18fig14_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="358" SRC="images/0672326132/graphics/18fig14.gif" ALT="graphics/18fig14.gif"></p></CENTER></p><br>
<A NAME="ch18fig15"></A><p><CENTER><H5 class="docFigureTitle">Figure 18.15. The DB2I Defaults panel #2: COBOL Defaults.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/18fig15_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="358" SRC="images/0672326132/graphics/18fig15.gif" ALT="graphics/18fig15.gif"></p></CENTER></p><br>
<A NAME="ch18lev2sec6"></A><H4 class="docSection2Title">QMF</H4>
<P class="docText">IBM's Query Management Facility, or QMF, is an interactive query tool used to produce formatted query output. QMF enables you to submit SQL queries dynamically, much like DB2I's SPUFI facility. QMF goes much further, however. Using a mechanism called a <span class="docEmphasis">QMF</span> <span class="docEmphasis">form</span>, you can format the results of your SQL queries into professional-looking reports.<A NAME="ch18index204"></A><A NAME="ch18index205"></A><A NAME="ch18index206"></A><A NAME="ch18index207"></A></P>
<P class="docText">To depict the basics of QMF, assume that you must produce a formatted report of all employees in the company. You invoke QMF, generally by choosing an option from the ISPF main menu. The QMF Home panel then appears, as shown in <A class="docLink" HREF="#ch18fig16">Figure 18.16</A>. Notice the numbered options along the bottom portion of the screen. These numbers correspond to QMF functions that you can invoke by pressing the function key for the number indicated. For example, press F1 to request the first function, Help.<A NAME="ch18index208"></A><A NAME="ch18index209"></A><A NAME="ch18index210"></A></P>
<A NAME="ch18fig16"></A><p><CENTER><H5 class="docFigureTitle">Figure 18.16. The QMF Home panel.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/18fig16_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="358" SRC="images/0672326132/graphics/18fig16.gif" ALT="graphics/18fig16.gif"></p></CENTER></p><br>
<P class="docText">You can use three basic QMF objects to produce formatted reports of DB2 data: queries, forms, and procs. You begin by creating a query. Press F6 to navigate to the QMF Query panel, which is initially blank.</P>
<P class="docText">You will produce an employee report, so type the following statement at the <TT>COMMAND</TT> prompt:</P>
<pre>

</pre><BR><pre>
COMMAND ===&gt; <span class="docEmphStrong">DRAW SYSIBM.SYSPLAN</span>
</pre><BR>
<P class="docText">The panel shown in <A class="docLink" HREF="#ch18fig17">Figure 18.17</A> then appears.<A NAME="ch18index211"></A><A NAME="ch18index212"></A><A NAME="ch18index213"></A></P>
<A NAME="ch18fig17"></A><p><CENTER><H5 class="docFigureTitle">Figure 18.17. The QMF Query panel.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/18fig17_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="358" SRC="images/0672326132/graphics/18fig17.gif" ALT="graphics/18fig17.gif"></p></CENTER></p><br>
<P class="docText">To run this query, press F2. Doing so produces the report shown in <A class="docLink" HREF="#ch18fig18">Figure 18.18</A>. You can print this report using F4 or format it using F9. When you press F9, the report form appears, as shown in <A class="docLink" HREF="#ch18fig19">Figure 18.19</A>. A default form is generated for each query when it is run.<A NAME="ch18index214"></A><A NAME="ch18index215"></A><A NAME="ch18index216"></A></P>
<A NAME="ch18fig18"></A><p><CENTER><H5 class="docFigureTitle">Figure 18.18. The QMF Report panel.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/18fig18_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="375" SRC="images/0672326132/graphics/18fig18.gif" ALT="graphics/18fig18.gif"></p></CENTER></p><br>
<A NAME="ch18fig19"></A><p><CENTER><H5 class="docFigureTitle">Figure 18.19. The QMF Form panel.</H5><A NAME="ch18index217"></A><A NAME="ch18index218"></A><A NAME="ch18index219"></A>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/18fig19_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="358" SRC="images/0672326132/graphics/18fig19.gif" ALT="graphics/18fig19.gif"></p></CENTER></p><br>
<P class="docText">You can use a QMF Form to produce a formatted report for the query output. QMF Forms enable you to perform the following:</P>
<UL><LI><P class="docList">Code a different column heading</P></LI><LI><P class="docList">Specify control breaks</P></LI><LI><P class="docList">Code control-break heading and footing text</P></LI><LI><P class="docList">Specify edit codes to transform column data (for example, suppress leading zeroes or display a currency symbol)</P></LI><LI><P class="docList">Compute averages, percentages, standard deviations, and totals for specific columns</P></LI><LI><P class="docList">Display summary results across a row, suppressing the supporting detail rows</P></LI><LI><P class="docList">Omit columns in the query from the report</P></LI></UL>
<P class="docText">You can see how QMF gives you a great deal of power for creating quick, formatted reports from simple SQL queries.</P>
<P class="docText">The third QMF object, the QMF Proc, is another important feature of QMF. A QMF query can contain only one SQL statement. Contrast this capability with SPUFI, which can contain multiple SQL statements as long as they are separated by a semicolon.<A NAME="ch18index220"></A><A NAME="ch18index221"></A></P>
<P class="docText">To execute multiple SQL statements at one time, you use a QMF Proc. QMF Procs contain QMF commands that are tied together and executed serially. For an example, see <A class="docLink" HREF="#ch18fig20">Figure 18.20</A>. This QMF Proc runs one query, prints the results, and then runs another query and prints its results. You can string together as many run statements as necessary and store them as a QMF Proc.<A NAME="ch18index222"></A><A NAME="ch18index223"></A><A NAME="ch18index224"></A></P>
<A NAME="ch18fig20"></A><p><CENTER><H5 class="docFigureTitle">Figure 18.20. The QMF Proc panel.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/18fig20_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="358" SRC="images/0672326132/graphics/18fig20.gif" ALT="graphics/18fig20.gif"></p></CENTER></p><br>
<P class="docText">Using QMF is a quick way to produce high-quality professional reports. Following is a typical QMF user's session, shown also in <A class="docLink" HREF="#ch18fig21">Figure 18.21</A>. If you type a single SQL statement and press a few function keys, an end-user report is generated.</P>
<A NAME="ch18pr04"></A>




<div style="font-weight:bold"><OL class="docList" START="1"><LI value="1"><div style="font-weight:normal">Enter <TT>QMF</TT>, and the QMF Home panel appears.<BR><BR></div></LI><LI value="2"><div style="font-weight:normal">Press F6 to display the QMF Query panel. Code the SQL <TT>SELECT</TT> statement.<BR><BR></div></LI><LI value="3"><div style="font-weight:normal">Press F2 to display the QMF Report panel. Execute the SQL statement to produce the report.<BR><BR></div></LI><LI value="4"><div style="font-weight:normal">Press F9 to display the QMF Form panel. Modify the report parameters and headings as necessary.<BR><BR></div></LI><LI value="5"><div style="font-weight:normal">Press F12 to display the QMF Report panel. Print the final formatted report.<A NAME="ch18index225"></A><A NAME="ch18index226"></A><BR><BR></div></LI></OL></div>
<A NAME="ch18fig21"></A><p><CENTER><H5 class="docFigureTitle">Figure 18.21. A typical QMF session.</H5><A NAME="ch18index227"></A><A NAME="ch18index228"></A><A NAME="ch18index229"></A>
<p class="docText"><IMG BORDER="0"  width="500" height="424" SRC="images/0672326132/graphics/18fig21.gif" ALT="graphics/18fig21.gif"></p></CENTER></p><br>
<A NAME="ch18lev2sec7"></A><H4 class="docSection2Title">Other TSO-Based DB2 Tools</H4>
<P class="docText">A host of vendor-supplied tools use TSO as their execution environment. In addition to QMF, IBM provides other tools with a TSO interface such as DB2-PM. Additionally, most of the third-party tools for DB2 database administration, analysis, and development are TSO-based. A comprehensive list of DB2 tool vendors is provided in <A class="docLink" HREF="app02.html#app02">Appendix B</A>, "DB2 Tool Vendors," and coverage of the types of tools available is provided in <A class="docLink" HREF="ch39.html#ch39">Chapter 39</A>, "Components of a Total DB2 Solution."<A NAME="ch18index230"></A><A NAME="ch18index231"></A></P>
<A NAME="ch18lev2sec8"></A><H4 class="docSection2Title">TSO Guidelines</H4>
<P class="docText">When utilizing DB2 in conjunction with TSO, the following guidelines should be used to ensure effective usage of DB2 and TSO.</P>
<A NAME="ch18lev4sec1"></A><H5 class="docSection3Title">Create MVS Performance Groups for DB2 Users</H5>
<P class="docText">To ensure fast TSO response time, create separate MVS performance groups for TSO users who will access DB2 applications. TSO is generally associated with three periods, designated here as period1, period2, and period3. These periods dictate the amount of MVS resources assigned to a TSO user. Period1 provides more resources than period2, which in turn provides more resources than period3. As TSO users run DB2 applications, their address space is moved from an initial period to lower periods as resources are used. As the address space is moved lower, the TSO response time becomes slower.<A NAME="ch18index232"></A><A NAME="ch18index233"></A><A NAME="ch18index234"></A><A NAME="ch18index235"></A></P>
<P class="docText">For DB2 and QMF users, you can create TSO performance groups with higher levels of resources in period1 and period2. Also, you can prevent the lowering of their TSO sessions to period3. This way, you can provide an optimal environment for high-priority TSO/DB2 applications.</P>
<A NAME="ch18lev4sec2"></A><H5 class="docSection3Title">Integrate All Resources into the DB2 Unit of Work When Using TSO</H5>
<P class="docText">When <TT>COMMIT</TT> processing is performed in online, TSO-based applications, DB2 controls the committing of its resources. The commit and recovery of any other resources, such as sequential input and output files, must be controlled through a program. This is in contrast to the other online environments, which control commit processing by commands native to the environment.<A NAME="ch18index236"></A><A NAME="ch18index237"></A></P>
<P class="docText"><TT>COMMIT</TT> processing in batch TSO/DB2 programs should follow the guidelines presented in <A class="docLink" HREF="part02.html#part02">Part II</A>.</P>
<A NAME="ch18lev4sec3"></A><H5 class="docSection3Title">COMMIT Frequently in TSO/DB2 Applications</H5>
<P class="docText">Online TSO/DB2 applications are subject to more frequent deadlocks and timeouts than DB2 applications using other transaction-oriented online environments. For this reason, you should commit more frequently in an online TSO/DB2 application than in DB2 applications running in other environments. Consider committing updates every row or two, rather than after a full screen. Committing might affect the efficiency of the application and should be handled on a program-by-program basis. Failure to commit frequently, however, can result in an unusable application because of lock contention.<A NAME="ch18index238"></A><A NAME="ch18index239"></A></P>
<A NAME="ch18lev4sec4"></A><H5 class="docSection3Title">Use ISPF Panels to Validate Screen Input</H5>
<P class="docText">To perform validation checking, use the native functionality of ISPF rather than code validation routines. When ISPF performs the checking, the data is validated before it is processed by the application. This approach can reduce the overhead of loading the program and allocating the thread and other overhead related to program execution.<A NAME="ch18index240"></A><A NAME="ch18index241"></A><A NAME="ch18index242"></A></P>
<P class="docText">In addition, error checking is handled by the ISPF routines rather than by the application code. Code provided by the system is generally more error free than functionally equivalent application code. Finally, if you use the validation facilities of ISPF, you can greatly reduce the time it takes to develop TSO/DB2 applications.</P>
<A NAME="ch18lev4sec5"></A><H5 class="docSection3Title">Avoid TSO in Performance-Critical Applications</H5>
<P class="docText">As a development platform for DB2-based applications, TSO is limited in its functionality and efficiency. You should follow these basic rules when deciding whether to use TSO as your online monitor. Do not choose TSO as the development platform for an online DB2-based application if you need subsecond response time or if more than 10 users will be accessing the application concurrently. However, you should choose TSO if you need an environment that speeds up the application development cycle. TSO provides a rich set of tools for developing and testing programs and ISPF screens.<A NAME="ch18index243"></A><A NAME="ch18index244"></A><A NAME="ch18index245"></A></P>
<A NAME="ch18lev4sec6"></A><H5 class="docSection3Title">Use ISPF Tables</H5>
<P class="docText">Consider copying a DB2 table that must be browsed to an ISPF table at the beginning of the program and processing from the ISPF table instead of the DB2 table. This way, you can dramatically increase performance when an online TSO/DB2 program must continually reopen a cursor with an <TT>ORDER BY</TT> due to <TT>COMMIT</TT> processing. Instead, the ISPF table can be created from a cursor, sorted appropriately, and <TT>COMMIT</TT> processing will not cause the program to lose cursor positioning on the ISPF table.<A NAME="ch18index246"></A><A NAME="ch18index247"></A><A NAME="ch18index248"></A></P>
<P class="docText">However, you must consider the update implications of using an ISPF table when programming and executing programs using this technique. Updates made to the DB2 table by other users are not made to the ISPF table because it is a copy of the DB2 table for your program's use only. These updates can cause two problems.</P>
<P class="docText">One, updates made by other programs might be bypassed rather than processed by the program using the ISPF table. For example, if another program updates data and an ISPF table-driven program generates reports, the report might not contain the most current data.</P>
<P class="docText">Another potential problem is that the program using the ISPF table might make incorrect updates. For example, if the program reads the ISPF table and then updates the DB2 table, the following scenario could result:</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="groups" CELLPADDING="5"><COLGROUP><COL width="244.44444444444443"><COL width="105.55555555555556"><COL width="200"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Program 1</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Time</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Program 2</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Copy EMP table to ISPF table</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText">3</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Update Emp 000010</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Commit</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Read ISPF table</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">5</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Update Emp 000020</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Update Emp 000010</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">6</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Commit</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Read ISPF table</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">7</P></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Update Emp 000020</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">8</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">And so on</P></TD></TR></TABLE></P><br>
<P class="docText">At time 1, Program 1 begins executing. It copies the EMP table to the ISPF table before Program 2 begins. At time 3, Program 2 begins executing, serially processing employees and adding 100 to each employee's bonus. After Program 1 copies the entire EMP table, it begins giving all employees in department B01 a 10-percent raise in their bonus.</P>
<P class="docText">You can see how the employees in department B01 will be disappointed when their bonus paycheck arrives. Program 2 adds 100, but Program 1, unaware of the additional 100, adds 10 percent to the old bonus amount. Consider employee 000020, who works in department B01. He starts with a bonus of $800. Program 2 adds 100, making his bonus $900. Then Program 1 processes employee 000020, setting his bonus to 800 x 1.10, or $880. Instead of a $990 bonus, he receives only $880.<A NAME="ch18index249"></A><A NAME="ch18index250"></A><A NAME="ch18index251"></A></P>
<A NAME="ch18lev4sec7"></A><H5 class="docSection3Title">Avoid Running Batch Programs in TSO Foreground</H5>
<P class="docText">A DB2 program developed to run as a batch program (that is, with no user interaction while the program is running) can be run in the TSO foreground using the <TT>DSN</TT> command processor, but doing so is not recommended. Running a DB2 batch program in this manner needlessly ties up a user's TSO session and, more important, consumes a valuable foreground thread that could be used for true online processing. (Remember that the <TT>IDFORE DSNZPARM</TT> value limits the number of foreground threads available for use.)<A NAME="ch18index252"></A><A NAME="ch18index253"></A><A NAME="ch18index254"></A></P>
<A NAME="ch18lev4sec8"></A><H5 class="docSection3Title">Use IKJEFT1B</H5>
<P class="docText">You must use the TSO Terminal Monitor Program (TMP) to invoke the <TT>DSN</TT> command and run a DB2 application program in batch mode. The generic program name is <TT>IKJEFT01</TT>. However, system errors and user abends are not honored by <TT>IKJEFT01</TT>, making it difficult to perform error checking in subsequent JCL steps. To rectify this problem, you can use <TT>IKJEFT1B</TT> instead of <TT>IKJEFT01</TT>. <TT>IKJEFT1B</TT> is an alternate entry point to the TSO TMP.<A NAME="ch18index255"></A><A NAME="ch18index256"></A><A NAME="ch18index257"></A></P>
<P class="docText">If an ABEND occurs and you are using <TT>IKJEFT01</TT>, the result will be a dump of TSO and the <TT>ABEND</TT> code will not be passed to the next step of your job. This is probably not the results you are looking for. The use of <TT>IKJEFT1B</TT> will give the same results as a standard MVS batch job because <TT>IKJEFT1B</TT> passes non-zero return codes through to JES where they can be checked in the JCL job stream.</P>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch18.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch18lev1sec2.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
