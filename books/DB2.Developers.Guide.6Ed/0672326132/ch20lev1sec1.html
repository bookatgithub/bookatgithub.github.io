<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>The Physical Storage of Data</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch20.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch20lev1sec2.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch20lev1sec1"></A><H3 class="docSection1Title">The Physical Storage of Data</H3>
<P class="docText">The first segment of your journey behind the scenes of DB2 consists of learning the manner in which DB2 data is physically stored. Before you proceed, however, recall the types of DB2 objects: storage groups (or <TT>STOGROUP</TT>s), databases, table spaces, tables, and indexes. Refer to <A class="docLink" HREF="#ch20fig01">Figure 20.1</A>. A database can be composed of many table spaces, which in turn can contain one or more tables, which in turn can have indexes defined for them.<A NAME="ch20index01"></A><A NAME="ch20index02"></A><A NAME="ch20index03"></A></P>
<A NAME="ch20fig01"></A><p><CENTER><H5 class="docFigureTitle">Figure 20.1. DB2 database objects.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/20fig01_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="477" SRC="images/0672326132/graphics/20fig01.gif" ALT="graphics/20fig01.gif"></p></CENTER></p><br>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> Prior to DB2 V8, a partitioned table space required a partitioning index to set up the partition boundaries. As of DB2 V8, though, partition boundaries are set up in the table parameters, not the index. If an index exists on the partition keys, though, it is referred to as a partitioning index. Furthermore, DB2 V8 introduced DPSIs, or data partitioned secondary indexes. A DPSI is partitioned such that its data matches up with the table space partitions, even though the key of the index is not the partitioning key. Finally, a partitioned table space might have non-partitioned indexes, or NPIs. An NPI is neither partitioned, nor does its key match the partitioning key of the table space.<A NAME="ch20index04"></A><A NAME="ch20index05"></A></P></td></tr></table><br>
<P class="docText">When LOB data types are used, LOB table spaces are required. In addition, databases, table spaces, and indexes can all be assigned <TT>STOGROUP</TT>s.</P>
<P class="docText">Of these five objects, only three represent actual physical entities. <TT>STOGROUP</TT>s represent one or more physical DASD devices. Table spaces and indexes relate to physical data sets. But tables and databases have no actual physical representation. A table is assigned to a table space, and one table space can have one or multiple tables assigned to it. Table spaces are created within a database; one database can have multiple table spaces. Any tables created in a table space in the database, and the indexes on that table, are said to be in the database. But the mere act of creating a database or creating a table does not create a physical manifestation in the form of a data set or disk usage.</P>
<A NAME="ch20note01"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">A DBD is created by DB2 for databases. The DBD is a component that is managed in the EDM pool and contains the structure of the database objects in that database. It is used by DB2 to help access the objects assigned to the database.</P></div><br>
<A NAME="ch20lev2sec1"></A><H4 class="docSection2Title">DB2 Physical Characteristics</H4>
<P class="docText">There are a myriad of things that go on behind the scenes in DB2 as you create and access database structures. The following sections contain descriptions and guidelines regarding the physical implementation and control of DB2 objects.</P>
<A NAME="ch20lev4sec1"></A><H5 class="docSection3Title">The Identifiers: OBIDs, PSIDs, and DBIDs</H5>
<P class="docText">When an object is created, DB2 assigns it an identifier that is stored in the DB2 Catalog. These identifiers are known as OBIDs. Furthermore, table spaces and index spaces are assigned PSIDs, otherwise known as page set IDs, because these objects require a physical data set. Databases are assigned DBIDs.<A NAME="ch20index06"></A><A NAME="ch20index07"></A><A NAME="ch20index08"></A></P>
<P class="docText">DB2 uses these identifiers behind the scenes to distinguish one DB2 object from another.</P>
<A NAME="ch20lev4sec2"></A><H5 class="docSection3Title">Storage Groups</H5>
<P class="docText">You can assign up to 133 DASD volumes to a single <TT>STOGROUP</TT>. The practical limit, though, is far fewer. To ease administration and management, keep the number of volumes assigned to a <TT>STOGROUP</TT> to a dozen or so.<A NAME="ch20index09"></A><A NAME="ch20index10"></A><A NAME="ch20index11"></A></P>
<P class="docText">You can use a DB2 <TT>STOGROUP</TT> to turn over control to SMS. This is accomplished by specifying an asterisk as the volume when creating the DB2 storage group.</P>
<A NAME="ch20lev2sec2"></A><H4 class="docSection2Title">VSAM Data Sets</H4>
<P class="docText">Data sets used by DB2 can be either VSAM entry-sequenced data sets (ESDS) or VSAM linear data sets (LDS). Linear data sets are more efficient because they do not contain the VSAM control interval information that an ESDS does. Additionally, an LDS has control intervals with a fixed length of 4,096 bytes.<A NAME="ch20index12"></A><A NAME="ch20index13"></A><A NAME="ch20index14"></A><A NAME="ch20index15"></A><A NAME="ch20index16"></A><A NAME="ch20index17"></A><A NAME="ch20index18"></A><A NAME="ch20index19"></A></P>
<A NAME="ch20lev4sec3"></A><H5 class="docSection3Title">Data Sets for Non-Partitioned Objects</H5>
<P class="docText">Usually only one VSAM data set is used for each non-partitioning index, simple table space, and segmented table space defined to DB2. But, each data set can be no larger than 2 gigabytes. When the 2-gigabyte limit is reached, a new VSAM data set is allocated. DB2 can use as many as 32 VSAM data sets per object.<A NAME="ch20index20"></A><A NAME="ch20index21"></A><A NAME="ch20index22"></A><A NAME="ch20index23"></A></P>
<P class="docText">Recall from <A class="docLink" HREF="ch05.html#ch05">Chapter 5</A>, "Data Definition Guidelines," the data set naming standard that is used by DB2 for table space and index data sets:</P>
<pre>

</pre><BR><pre>
vcat.DSNDBx.dddddddd.ssssssss.y0001.znnn
</pre><BR>
<P class="docText">where:</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5"><COLGROUP><COL width="137.5"><COL width="412.5"></COLGROUP><THEAD></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><span class="docEmphasis"><TT>vcat</TT></span></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">High-level qualifier, indicating an ICF catalog</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><span class="docEmphasis"><TT>X</TT></span></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">C if VSAM cluster component</P>
<P class="docText">D if VSAM data component</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><span class="docEmphasis"><TT>dddddddd</TT></span></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Database name</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><span class="docEmphasis"><TT>ssssssss</TT></span></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Table space name or index space name</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><span class="docEmphasis"><TT>y</TT></span><TT>0001</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Instance qualifier</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><span class="docEmphasis"><TT>znnn</TT></span></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Partition number or the data set number</P></TD></TR></TABLE></P><br>
<P class="docText">The instance qualifier normally will be <TT>I0001</TT>. However, if you run <TT>REORG</TT> with the <TT>FASTSWITCH YES</TT> option, the instance qualifier will switch back and forth between <TT>I0001</TT> and <TT>J0001</TT> after reorganizing.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> The data set number is controlled by the last component of the data set name.</P></td></tr></table><br>
<P class="docText">For simple and segmented table spaces, the data set number is always preceded by <TT>A</TT>. The data set number for the first data set is always <TT>A001</TT>. When the size of the data set for a simple or a segmented table space approaches the maximum, another data set will be defined (for <TT>STOGROUP</TT>-controlled objects) with the data set number set to <TT>A002</TT>. For user-defined VSAM data sets, the DBA will have to allocate the data set using <TT>A002</TT> as the data set number. The next data set will be <TT>A003</TT>, and so on.<A NAME="ch20index24"></A><A NAME="ch20index25"></A><A NAME="ch20index26"></A><A NAME="ch20index27"></A></P>
<A NAME="ch20lev4sec4"></A><H5 class="docSection3Title">Data Sets for Partitioned Objects</H5>
<P class="docText">Multiple VSAM data sets are used for partitioned table spaces, partitioning indexes, and DPSIs. One data set is used per partition. For partitioned table spaces, the data set number is used to indicate the partition number.<A NAME="ch20index28"></A><A NAME="ch20index29"></A><A NAME="ch20index30"></A><A NAME="ch20index31"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> The first character of the data set number, represented by the <span class="docEmphasis">z</span>, will contain a letter from A through E. This letter corresponds to the value 0, 1, 2, 3, or 4 as the first digit of the partition number. Prior to DB2 V8, this character was the letter A. But now that Version 8 allows up to 4096 partitions, the letters A, B, C, D, and E must be used.</P></td></tr></table><br>
<P class="docText">If the partition number is less than 1000, the data set number is <TT>A</TT><span class="docEmphasis"><TT>nnn</TT></span>. For example, the data set number for partition 750 would be <TT>A750</TT>. For partitions 1000 to 1999, the data set number is <TT>B</TT><span class="docEmphasis"><TT>nnn</TT></span>. For example, the data set number for partition 1025 would be <TT>B025</TT>, and so on. The same rules apply to the naming of data sets for partitioned indexes.</P>
<P class="docText">The maximum size of each data set is based on the number of defined partitions. If the partitioned table space is not defined with the <TT>LARGE</TT> parameter, and the <TT>DSSIZE</TT> is not greater than 2GB, the maximum number of partitions is 64 and the maximum size per partition is as follows:</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="groups" CELLPADDING="5"><COLGROUP><COL width="192.5"><COL width="357.5"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Partitions</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Maximum Size of VSAM Data Set</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">1 through 16</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4GB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">17 through 32</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2GB</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">33 through 64</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1GB</P></TD></TR></TABLE></P><br>
<A NAME="ch20note02"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Recall from <A class="docLink" HREF="ch05.html#ch05">Chapter 5</A> that the <TT>DSSIZE</TT> parameter is used to specify the maximum size for each partition of partitioned and LOB table spaces. Valid <TT>DSSIZE</TT> values are 1GB, 2GB, 4GB, 8GB, 16GB, 32GB, or 64GB.</P>
<P class="docText">To specify a <TT>DSSIZE</TT> greater than <TT>4GB</TT>, you must be running DB2 with DFSMS V1.5, and the data sets for the table space must be associated with a DFSMS data class defined with extended format and extended addressability. DFSMS's extended addressability function is necessary to create data sets larger than 4GB in size.<A NAME="ch20index32"></A><A NAME="ch20index33"></A></P></div><br>
<P class="docText">If the partitioned table space is defined with the <TT>LARGE</TT> parameter, the maximum number of partitions is 4096 and the maximum size per partition is 4GB.</P>
<P class="docText">If the partitioned table space is defined with a <TT>DSSIZE</TT> greater than 2GB, the maximum size per partition is 64GB, but it depends on the page size, too. With a DSSIZE of 4GB and a page size of 4K, you can define up to 4096 partitions, but with a <TT>DSSIZE</TT> of 64GB the maximum number of partitions using 4K pages is 256.<A NAME="ch20index34"></A><A NAME="ch20index35"></A><A NAME="ch20index36"></A><A NAME="ch20index37"></A></P>
<A NAME="ch20lev4sec5"></A><H5 class="docSection3Title">Data Sets for LOB Table Spaces</H5>
<P class="docText">For LOB data, up to 127TB of data per LOB column can be stored (using 254 partitions). If <TT>DSSIZE</TT> is not specified for a LOB table space, the default for the maximum size of each data set is 4GB. The maximum number of data sets is 254.<A NAME="ch20index38"></A><A NAME="ch20index39"></A><A NAME="ch20index40"></A><A NAME="ch20index41"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> If 4096 partitions need to be supported, no more than 5 LOBs can be put in the table. This is so because each individual LOB would require 12,288 objects to support it, and DB2 has a limit of 65,535 objects allowed per database.<A NAME="ch20index42"></A><A NAME="ch20index43"></A><A NAME="ch20index44"></A><A NAME="ch20index45"></A></P></td></tr></table><br>
<P class="docText">For more information on LOBs, refer to <A class="docLink" HREF="ch09.html#ch09">Chapter 9</A>, "Large Objects and Object/Relational Databases."</P>
<A NAME="ch20lev2sec3"></A><H4 class="docSection2Title">The Structure of a Page</H4>
<P class="docText">Now that you know how data sets are used by DB2, the next question is likely to be "How are these data sets structured?"</P>
<P class="docText">Every VSAM data set used to represent a DB2 table space or index is composed of pages. Up through V7, DB2 is limited to using pages that consist of 4,096 bytes, or 4KB. Actually, even for DB2 V8, the vast majority of all DB2 table spaces and indexes will use 4K pages. You therefore can think of a data set used by DB2 table spaces or indexes as shown in <A class="docLink" HREF="#ch20fig02">Figure 20.2</A>.<A NAME="ch20index46"></A><A NAME="ch20index47"></A><A NAME="ch20index48"></A></P>
<A NAME="ch20fig02"></A><p><CENTER><H5 class="docFigureTitle">Figure 20.2. DB2 uses data sets with 4KB pages.</H5>
<p class="docText"><IMG BORDER="0" width="400" height="353" SRC="images/0672326132/graphics/20fig02.gif" ALT="graphics/20fig02.gif"></p></CENTER></p><br>
<P class="docText">But what about table spaces with larger page sizes? As you might recall, DB2 table spaces can have page sizes of 4KB, 8KB, 16KB, or 32KB. Up through V7, DB2 groups 4KB pages together to create virtual page sizes greater than 4KB. For example, a table space defined with 32KB pages uses a logical 32KB page composed of eight physical 4KB pages, as represented in <A class="docLink" HREF="#ch20fig03">Figure 20.3</A>. A table space with 32KB pages is physically structured like a table space with 4KB pages. It differs only in that rows of a 32KB page table space can span 4K pages, thereby creating a logical 32KB page.</P>
<A NAME="ch20fig03"></A><p><CENTER><H5 class="docFigureTitle">Figure 20.3. 32KB pages are composed of eight 4KB pages.</H5>
<p class="docText"><IMG BORDER="0" width="420" height="366" SRC="images/0672326132/graphics/20fig03.gif" ALT="graphics/20fig03.gif"></p></CENTER></p><br>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> As of DB2 V8, though, you can specify that DB2 use the correct CI size for DB2 page sizes greater than 4K. This is controlled system-wide using a parameter in the DSNZPARMs. Consult your DBA or system programmer to determine whether your organization uses grouped 4K pages for page sizes larger than 4K, or matches the page size to the VSAM CI size.<A NAME="ch20index49"></A><A NAME="ch20index50"></A><A NAME="ch20index51"></A></P></td></tr></table><br>
<A NAME="ch20lev2sec4"></A><H4 class="docSection2Title">DB2 Page Types</H4>
<P class="docText">DB2 uses different types of pages to manage data in data sets. Each type of page has its own purpose and format. The type of page used is based on the type of table space or index for which it exists and the location of the page in the data set defined for that object.<A NAME="ch20index52"></A><A NAME="ch20index53"></A><A NAME="ch20index54"></A><A NAME="ch20index55"></A></P>
<P class="docText">Before proceeding any further, I must introduce a new term, <span class="docEmphasis">page set,</span> which is a physical grouping of pages. Page sets come in two types: linear and partitioned. DB2 uses <span class="docEmphasis">linear page sets</span> for simple table spaces, segmented table spaces, and indexes. DB2 uses <span class="docEmphasis">partitioned page sets</span> when it implements partitioned table spaces.<A NAME="ch20index56"></A><A NAME="ch20index57"></A><A NAME="ch20index58"></A><A NAME="ch20index59"></A><A NAME="ch20index60"></A></P>
<P class="docText">Each page set is composed of several types of pages, as follows.</P>
<UL><LI><P class="docList">Header page</P></LI><LI><P class="docList">Space Map pages</P></LI><LI><P class="docList">Dictionary pages</P></LI><LI><P class="docList">
<IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"> System pages</P></LI><LI><P class="docList">Data pages</P></LI></UL>
<P class="docText"><A class="docLink" HREF="#ch20fig04">Figure 20.4</A> shows the basic layout of a DB2 table space.</P>
<A NAME="ch20fig04"></A><p><CENTER><H5 class="docFigureTitle">Figure 20.4. DB2 table space layout.</H5>
<p class="docText"><IMG BORDER="0" width="400" height="217" SRC="images/0672326132/graphics/20fig04.gif" ALT="graphics/20fig04.gif"></p></CENTER></p><br>
<P class="docText">The <span class="docEmphasis">header page</span> contains control information used by DB2 to manage and maintain the table space. For example, the <TT>OBID</TT> and <TT>DBID</TT> (internal object and database identifiers used by DB2) of the table space and database are maintained here, as well as information on logging. Each linear page set has one header page; every partition of a partitioned page set has its own header page. The header page is the first page of a VSAM data set and can occur only once per page set.<A NAME="ch20index61"></A><A NAME="ch20index62"></A></P>
<P class="docText"><span class="docEmphasis">Space map pages</span> contain information pertaining to the amount of free space available on pages in a page set. A space map page outlines the space available for a range of pages. Refer to <A class="docLink" HREF="#ch20fig05">Figure 20.5</A> for the number of pages covered by a space map page based on the type of table space. More than one space map can exist per page set.<A NAME="ch20index63"></A><A NAME="ch20index64"></A></P>
<A NAME="ch20fig05"></A><p><CENTER><H5 class="docFigureTitle">Figure 20.5. Number of pages per space map page.</H5>
<p class="docText"><IMG BORDER="0" width="500" height="542" SRC="images/0672326132/graphics/20fig05.gif" ALT="graphics/20fig05.gif"></p></CENTER></p><br>
<P class="docText"><span class="docEmphasis">Dictionary pages</span> are used for table spaces that specify <TT>COMPRESS YES</TT>. Information is stored in the dictionary pages to help DB2 control compression and decompression. The dictionary pages are stored after the header page and first space map page, but before any data pages.<A NAME="ch20index65"></A><A NAME="ch20index66"></A></P>
<A NAME="ch20note03"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Each table space or table space partition that contains compressed data has a compression dictionary that is used to control compression and decompression. The dictionary contains a fixed number of entries, up to a maximum of 4096. The dictionary content is based on the data at the time it was built, and it does not change unless the dictionary is rebuilt or recovered, or compression is disabled using <TT>ALTER</TT> with <TT>COMPRESS NO</TT>.<A NAME="ch20index67"></A><A NAME="ch20index68"></A></P></div><br>
<P class="docText"><span class="docEmphasis">System pages</span> are new as of DB2 V8 and contain information about the version of the object and hence the structure of its rows, as well as other system-related details.<A NAME="ch20index69"></A><A NAME="ch20index70"></A></P>
<P class="docText"><span class="docEmphasis">Data pages</span> contain the user data for the table space or index page set. The layout of a data page depends on whether it is an index data page or a table space data page.<A NAME="ch20index71"></A><A NAME="ch20index72"></A><A NAME="ch20index73"></A><A NAME="ch20index74"></A><A NAME="ch20index75"></A><A NAME="ch20index76"></A></P>
<A NAME="ch20lev2sec5"></A><H4 class="docSection2Title">Table Space Data Pages</H4>
<P class="docText">Each table space data page is formatted as shown in <A class="docLink" HREF="#ch20fig06">Figure 20.6</A>. Each page begins with a 20-byte header that records control information about the rest of the page. For example, the header contains the page set page number, pointers to free space in the page, and information pertaining to the validity and recoverability of the page.<A NAME="ch20index77"></A><A NAME="ch20index78"></A><A NAME="ch20index79"></A></P>
<A NAME="ch20fig06"></A><p><CENTER><H5 class="docFigureTitle">Figure 20.6. Table space data page layout.</H5>
<p class="docText"><IMG BORDER="0" width="500" height="456" SRC="images/0672326132/graphics/20fig06.gif" ALT="graphics/20fig06.gif"></p></CENTER></p><br>
<P class="docText">At the very end of the page is a 1-byte trailer used as a consistency check token. DB2 checks the value in the trailer byte against a single bit in the page header to ensure that the data page is sound. DB2 ensures that these two bits are the same when the page is read.</P>
<P class="docText">The next-to-last byte of each page contains a pointer to the next available ID map entry. The ID map is a series of contiguous 2-byte row pointers. One row pointer exists for every data row in the table. A maximum of 255 of these pointers can be defined per data page. The maximum number of rows per page can be specified for each table space using the <TT>MAXROWS</TT> clause. Each row pointer identifies the location of a data row in the data page.</P>
<P class="docText">Each data page can contain one or more data rows. One data row exists for each row pointer, thereby enforcing a maximum of 255 data rows per data page. Each data row contains a 6-byte row header used to administer the status of the data row.<A NAME="ch20index80"></A><A NAME="ch20index81"></A><A NAME="ch20index82"></A></P>
<A NAME="ch20lev2sec6"></A><H4 class="docSection2Title">LOB Pages</H4>
<P class="docText">LOB columns are stored in auxiliary tables, not with the primary data. An auxiliary table is stored in a LOB table space. For complete details on large object support, refer to <A class="docLink" HREF="ch09.html#ch09">Chapter 9</A>.<A NAME="ch20index83"></A><A NAME="ch20index84"></A><A NAME="ch20index85"></A></P>
<P class="docText">The layout of data pages in a LOB table space differs from a regular DB2 table space. There are two types of LOB pages:</P>
<UL><LI><P class="docList">LOB map pages</P></LI><LI><P class="docList">LOB data pages</P></LI></UL>
<P class="docText"><span class="docEmphasis">LOB map pages</span> contain information describing the LOB data. A LOB map page always precedes the LOB data. <A class="docLink" HREF="#ch20fig07">Figure 20.7</A> describes the LOB map page. There are potentially five components of the LOB map page.<A NAME="ch20index86"></A><A NAME="ch20index87"></A><A NAME="ch20index88"></A></P>
<A NAME="ch20fig07"></A><p><CENTER><H5 class="docFigureTitle">Figure 20.7. LOB map page layout.</H5>
<p class="docText"><IMG BORDER="0" width="450" height="349" SRC="images/0672326132/graphics/20fig07.gif" ALT="graphics/20fig07.gif"></p></CENTER></p><br>
<P class="docText">The LOB map page header connects the LOB page with the base table. The LOB map entries point to the page number where LOB data exists, as well as containing information about the length of the LOB data.</P>
<P class="docText">The final two components of the LOB map page exist only when the LOB map page also contains LOB data. The LOB map page data header, LOB data, and page trailer exist when the last LOB map page contains LOB data.</P>
<P class="docText">The LOB data page contains the actual LOB data. The layout of a LOB data page is depicted in <A class="docLink" HREF="#ch20fig08">Figure 20.8</A>.<A NAME="ch20index89"></A><A NAME="ch20index90"></A><A NAME="ch20index91"></A><A NAME="ch20index92"></A><A NAME="ch20index93"></A><A NAME="ch20index94"></A></P>
<A NAME="ch20fig08"></A><p><CENTER><H5 class="docFigureTitle">Figure 20.8. LOB data page layout.</H5>
<p class="docText"><IMG BORDER="0" width="450" height="250" SRC="images/0672326132/graphics/20fig08.gif" ALT="graphics/20fig08.gif"></p></CENTER></p><br>
<A NAME="ch20lev2sec7"></A><H4 class="docSection2Title">Index Pages</H4>
<P class="docText">The data pages for a DB2 index are somewhat more complex than those for a DB2 table space. Before you delve into the specifics of the layout of index data pages, you should examine the basic structure of DB2 indexes.<A NAME="ch20index95"></A><A NAME="ch20index96"></A></P>
<P class="docText">A DB2 index is a modified <span class="docEmphasis">b-tree</span> (balanced tree) structure that orders data values for rapid retrieval. The values being indexed are stored in an inverted tree structure, as shown in <A class="docLink" HREF="#ch20fig09">Figure 20.9</A>.<A NAME="ch20index97"></A><A NAME="ch20index98"></A></P>
<A NAME="ch20fig09"></A><p><CENTER><H5 class="docFigureTitle">Figure 20.9. DB2 index structure.</H5>
<p class="docText"><IMG BORDER="0" width="500" height="505" SRC="images/0672326132/graphics/20fig09.gif" ALT="graphics/20fig09.gif"></p></CENTER></p><br>
<P class="docText">As values are inserted and deleted from the index, the tree structure is automatically balanced, realigning the hierarchy so that the path from top to bottom is uniform. This realignment minimizes the time required to access any given value by keeping the search paths as short as possible.</P>
<P class="docText">Every DB2 index resides in an index space. When an index is created, the physical space to hold the index data is automatically created if <TT>STOGROUP</TT>s are used. This physical structure is called the index space. Refer to <A class="docLink" HREF="#ch20fig10">Figure 20.10</A> for a depiction of the layout of an index space.<A NAME="ch20index99"></A><A NAME="ch20index100"></A></P>
<A NAME="ch20fig10"></A><p><CENTER><H5 class="docFigureTitle">Figure 20.10. DB2 index space layout.</H5>
<p class="docText"><IMG BORDER="0" width="400" height="263" SRC="images/0672326132/graphics/20fig10.gif" ALT="graphics/20fig10.gif"></p></CENTER></p><br>
<P class="docText">Index data pages are always 4KB in size. To implement indexes, DB2 uses the following types of index data pages:<A NAME="ch20index101"></A><A NAME="ch20index102"></A><A NAME="ch20index103"></A></P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5"><COLGROUP><COL width="126.5"><COL width="423.5"></COLGROUP><THEAD></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Space map pages</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Space map pages determine what space is available in the index for DB2 to utilize. An index space map page is required every 32,632 index pages. <A class="docLink" HREF="#ch20fig11">Figure 20.11</A> shows the layout of an index space map page.<A NAME="ch20index104"></A><A NAME="ch20index105"></A><A NAME="ch20index106"></A></P>
</TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Root page</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Only one root page is available per index. The third page in the index space, after the header page and (first) space map page, is the root page. The root page must exist at the highest level of the hierarchy for every index structure. It is always structured as a non-leaf page.<A NAME="ch20index107"></A><A NAME="ch20index108"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Non-leaf pages</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Non-leaf pages are intermediate-level index pages in the b-tree hierarchy. Non-leaf pages need not exist. If they do exist, they contain pointers to other non-leaf pages or leaf pages. They never point to data rows.<A NAME="ch20index109"></A><A NAME="ch20index110"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Leaf pages</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Leaf pages contain the most important information within the index. Leaf pages contain pointers to the data rows of a table.<A NAME="ch20index111"></A><A NAME="ch20index112"></A></P></TD></TR></TABLE></P><br>
<P class="docText">The pointers in the leaf pages of an index are called a <span class="docEmphasis">record ID</span>, or <span class="docEmphasis">RID</span>. Each RID is a combination of the table space page number and the row pointer for the data value, which together indicate the location of the data value.</P>
<A NAME="ch20fig11"></A><p><CENTER>
<H5 class="docFigureTitle">Figure 20.11. Index space map page layout.</H5><p class="docText"><IMG BORDER="0" width="450" height="227" SRC="images/0672326132/graphics/20fig11.gif" ALT="graphics/20fig11.gif"></p></CENTER></p><br>
<A NAME="ch20note04"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">A RID is a <span class="docEmphStrong">record</span> ID, not a <span class="docEmphStrong">row</span> ID as is commonly assumed. A DB2 record is the combination of the record prefix and the row. Each record prefix is 6 bytes long. RIDs point to the record, not the row; therefore, a RID is a record ID. But don't let this information change the way you think. The data returned by your <TT>SELECT</TT> statements are still rows!<A NAME="ch20index113"></A><A NAME="ch20index114"></A></P></div><br>
<P class="docText">The level of a DB2 index indicates whether it contains non-leaf pages. The smallest DB2 index is a two-level index. A two-level index does not contain non-leaf pages. The root page points directly to leaf pages, which in turn point to the rows containing the indexed data values.<A NAME="ch20index115"></A><A NAME="ch20index116"></A></P>
<P class="docText">A three-level index, such as the one shown in <A class="docLink" HREF="#ch20fig09">Figure 20.9</A>, contains one level for the root page, another level for non-leaf pages, and a final level for leaf pages. The larger the number of levels for an index, the less efficient it will be. You can have any number of intermediate non-leaf page levels. The more levels that exist for the index, the less efficient the index becomes, because additional levels must be traversed to find the index key data on the leaf page. Try to minimize the number of levels in your DB2 indexes; when more than three levels exist, indexes generally start to become inefficient.<A NAME="ch20index117"></A><A NAME="ch20index118"></A><A NAME="ch20index119"></A><A NAME="ch20index120"></A></P>
<A NAME="ch20lev3sec1"></A><H5 class="docSection3Title">Type 1 Index Data Pages</H5>
<P class="docText">Type 1 indexes are DB2's legacy index type. These are the indexes that were available with DB2 since V1. They started to be called Type 1 indexes with the introduction of DB2 V4, which added a new type of index (Type 2 indexes).<A NAME="ch20index121"></A><A NAME="ch20index122"></A><A NAME="ch20index123"></A><A NAME="ch20index124"></A><A NAME="ch20index125"></A><A NAME="ch20index126"></A><A NAME="ch20index127"></A></P>
<P class="docText">As of V6, DB2 uses only Type 2 indexes. Type 1 indexes are no longer supported.</P>
<A NAME="ch20note05"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p><p><table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" ALIGN="LEFT" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText">You will not be able to migrate to DB2 V8 if any Type 1 indexes still exist.</P></td></tr></table></p></div><br>
<P class="docText">However, if you are using a past release of DB2 and want to read more about Type 1 indexes, refer to the CD accompanying this book, where you can find a file containing a section from a previous edition of this book covering Type 1 indexes.</P>
<A NAME="ch20lev3sec2"></A><H5 class="docSection3Title">Type 2 Index Data Pages</H5>
<P class="docText">Non-leaf pages are physically formatted as shown in <A class="docLink" HREF="#ch20fig12">Figure 20.12</A>. Each non-leaf page contains the following:<A NAME="ch20index128"></A><A NAME="ch20index129"></A><A NAME="ch20index130"></A><A NAME="ch20index131"></A></P>
<UL><LI><P class="docList">A 12-byte index page header that houses consistency and recoverability information for the index.</P></LI><LI><P class="docList">A 16-byte physical header that stores control information for the index page. For example, the physical header controls administrative housekeeping, such as the type of page (leaf or non-leaf), the location of the page in the index structure, and the ordering and size of the indexed values.</P></LI></UL>
<A NAME="ch20fig12"></A><p><CENTER><H5 class="docFigureTitle">Figure 20.12. Type 2 index non-leaf page layout.</H5>
<p class="docText"><IMG BORDER="0" width="500" height="320" SRC="images/0672326132/graphics/20fig12.gif" ALT="graphics/20fig12.gif"></p></CENTER></p><br>
<P class="docText">Each non-leaf page contains high keys with child page pointers. The last page pointer has no high key because it points to a child page that has entries greater than the highest high key in the parent.<A NAME="ch20index132"></A><A NAME="ch20index133"></A></P>
<P class="docText">Additionally, Type 2 index non-leaf pages deploy suffix truncation to reduce data storage needs and increase efficiency. Suffix truncation allows the non-leaf page to store only the most significant bytes of the key. For example, consider an index in which a new value is being inserted. The value, <TT>ABCE0481</TT>, is to be placed on a new index page. The last key value on the previous page was <TT>ABCD0398</TT>. Only the significant bytes needed to determine that this key is new need to be stored—in this case, <TT>ABCE</TT>.</P>
<A NAME="ch20note06"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">In the older, Type 1 indexes, the entire length of each key was stored. Truncation helps to reduce index size, thereby possibly reducing the number of index levels and incurring less I/O.</P></div><br>
<P class="docText">Entries on a Type 2 leaf page are not stored contiguously in order on the page. A collated key map exists at the end of the Type 2 leaf page to order the entries. Type 2 index leaf pages are formatted as shown in <A class="docLink" HREF="#ch20fig13">Figure 20.13</A>. When an entry is added to the index, the collated key map grows backward from the end of the page into the page. By traversing the key map within the page, DB2 can read entries in order by the index key. Additionally, Type 2 indexes have no subpages.<A NAME="ch20index134"></A><A NAME="ch20index135"></A></P>
<A NAME="ch20fig13"></A><p><CENTER><H5 class="docFigureTitle">Figure 20.13. Type 2 Index leaf page layout.</H5>
<p class="docText"><IMG BORDER="0" width="500" height="436" SRC="images/0672326132/graphics/20fig13.gif" ALT="graphics/20fig13.gif"></p></CENTER></p><br>
<P class="docText">Type 2 leaf page entries add a flag byte. The <span class="docEmphasis">flag byte</span> indicates the status of the RID. The first bit indicates whether the RID is pseudo-deleted. A <span class="docEmphasis">pseudo-delete</span> occurs when a RID has been marked for deletion. The second bit indicates that the RID is possibly uncommitted, and the third bit indicates that a RID hole follows. An array of RIDs is stored contiguously in ascending order to allow binary searching. For non-unique indexes, each index entry is preceded by a count of the number of RIDs.<A NAME="ch20index136"></A><A NAME="ch20index137"></A><A NAME="ch20index138"></A><A NAME="ch20index139"></A></P>
<A NAME="ch20note07"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Type 2 indexes will need to be reorganized periodically to physically delete the pseudo-deleted RIDS. Information about pseudo-deleted RIDs can be found in the DB2 Catalog in <TT>SYSIBM.SYSINDEXPART</TT> and in the Real Time Statistics tables. Consider tracking the historical size of indexes for those that are larger than normal and thus, candidates for reorganization.<A NAME="ch20index140"></A><A NAME="ch20index141"></A></P></div><br>
<P class="docText">The final physical index structure to explore is the index entry. You can create both unique and non-unique indexes for each DB2 table. When the index key is of varying length, DB2 pads the columns to their maximum length, making the index keys a fixed length. A unique index contains entries, and each entry has a single RID. In a unique index, no two index entries can have the same value because the values being indexed are unique (see <A class="docLink" HREF="#ch20fig14">Figure 20.14</A>).<A NAME="ch20index142"></A><A NAME="ch20index143"></A><A NAME="ch20index144"></A><A NAME="ch20index145"></A><A NAME="ch20index146"></A><A NAME="ch20index147"></A></P>
<A NAME="ch20fig14"></A><p><CENTER><H5 class="docFigureTitle">Figure 20.14. Index entries.</H5>
<p class="docText"><IMG BORDER="0" width="450" height="257" SRC="images/0672326132/graphics/20fig14.gif" ALT="graphics/20fig14.gif"></p></CENTER></p><br>
<P class="docText">You can add the <TT>WHERE NOT NULL</TT> clause to a unique index causing multiple nulls to be stored. Therefore, an index specified as unique <TT>WHERE NOT NULL</TT> has multiple unique entries and possibly one non-unique entry for the nulls.</P>
<P class="docText">If the index can point to multiple table rows containing the same values, however, the index entry must support a RID list. In addition, a header is necessary to maintain the length of the RID list. This type of index entry is shown in <A class="docLink" HREF="#ch20fig09">Figure 20.9</A>.<A NAME="ch20index148"></A><A NAME="ch20index149"></A><A NAME="ch20index150"></A><A NAME="ch20index151"></A></P>
<A NAME="ch20lev4sec6"></A><H5 class="docSection4Title">The Storage Impact of Type 2 Indexes</H5>
<P class="docText">Type 2 indexes provide numerous benefits to a DB2 subsystem. The primary benefit is the elimination of index locking. However, many newer DB2 features, such as row level locking and uncommitted reads, require Type 2 indexes. Type 1 indexes were no longer supported as of DB2 V6, but DB2 would continue to operate if Type 1 indexes still exist. You cannot migrate to DB2 V8 without dropping or converting all of your Type 1 indexes. So, you are now forced to move to Type 2 indexes.<A NAME="ch20index152"></A><A NAME="ch20index153"></A><A NAME="ch20index154"></A></P>
<P class="docText">If you have already migrated your Type 1 indexes to Type 2, you can ignore the rest of this short section. Otherwise, be sure you understand all of the storage ramifications of converting to Type 2 indexes.</P>
<P class="docText">What will the impact of Type 2 indexes be with regard to storage requirements? The answer, not surprisingly, is "it depends!" There are quite a few differences between Type 1 and Type 2 indexes that impact storage. The first difference is in the amount of useable space on an index page. A Type 2 leaf page has 4038 bytes of useable space; a Type 2 non-leaf page has 4046 bytes. Type 1 leaf and non-leaf pages have 4050 useable bytes per page. So, Type 2 indexes have less useable space per page.</P>
<P class="docText">Additionally, Type 2 indexes require an additional one-byte RID prefix in addition to the four-byte RID found in both Type 1 and Type 2 indexes. The new one-byte RID prefix found in a Type 2 index contains three flags: pseudo-deleted, possibly uncommitted, and RID hole follows.</P>
<P class="docText">Because Type 2 indexes have a different internal structure, two pieces of header information needed on Type 1 indexes are no longer required: the subpage header and the non-unique key header. Because Type 2 indexes do not use subpages, the 17-byte logical subpage header required of a Type 1 index is not in Type 2 indexes.</P>
<P class="docText">Non-unique Type 1 indexes have a six-byte header and will repeat an entry (header and key) if a key has more than 255 RIDs. Type 2 indexes have a two-byte header and can have more than 255 RIDs in each entry. The entry is only repeated if there is not enough room in a leaf page to hold all of the RIDs; the same is true for a Type 1 index. Type 2 indexes also have a two-byte <TT>MAPID</TT> for each key at the end of the page, so total savings per key is two bytes (six bytes for the Type 1 header, minus two bytes for the Type 2 header and two bytes for the <TT>MAPID</TT>).</P>
<P class="docText">Type 2 indexes store truncated keys instead of the complete key. Only the portion of the key required to make it uniquely identifiable is stored on non-leaf pages. However, if there are many duplicate keys so that the same key is on more than one leaf page, a Type 2 index will have RIDs stored in the non-leaf pages, causing more space to be used instead of less. This is due to Type 2 indexes keeping the RIDs in sequence.</P>
<P class="docText">Finally, Type 2 indexes are required for <TT>LARGE</TT> table spaces (that is, <TT>DSSIZE</TT> greater than 2GB). In this case, the RID is five bytes (plus the one-byte RID prefix, which is still required).</P>
<P class="docText">As you can see, there is no clear-cut answer as to whether a Type 1 or Type 2 index will utilize more storage.</P>
<P class="docText">Taking all these points into consideration, here are some general rules of thumb on index storage requirements that you can apply when developing DB2 databases:<A NAME="ch20index155"></A><A NAME="ch20index156"></A></P>
<UL><LI><P class="docList">A Type 1 index with a subpage count of 16 usually wastes a lot of space. A Type 2 index will almost always use less space than a Type 1 with 16 subpages (but so will a Type 1 index with a subpage of 1).</P></LI><LI><P class="docList">A Type 1 with a subpage of 1 usually will use slightly less space than a Type 2 index for both unique and non-unique keys. For the average user, the space difference is relatively small and usually should not be a factor.<A NAME="ch20index157"></A><A NAME="ch20index158"></A><A NAME="ch20index159"></A></P></LI><LI><P class="docList">Beware of Type 2 space usage if numerous row deletes occur. Type 1 indexes clean up after a delete, while DB2 pseudo-deletes index RID entries. A pseudo-delete is when DB2 marks the index entry for deletion, but does not physically delete it. When high levels of activity occur, you could encounter numerous pages of nothing but pseudo-deleted RIDs. DB2 should periodically cleanup the pseudo-deleted entries, but in some cases, users report seeing them staying around for weeks at a time wasting space. A reorganization or rebuild will clean up the pseudo-deleted RIDs and free the wasted space.</P></LI><LI><P class="docList">Beware of space usage when numerous inserts occur. Type 1 index entries move around in the page and finally, when a split occurs, one half of the index entries are moved to another page, usually causing the one half page to be wasted. This is known as the "half full" problem. Type 2 index pages will also split, but provision has been made at the end of a data set to avoid the "half full" problem. Also, Type 2 indexes with non-unique keys will chain RIDs within a page. Each chain entry requires a chain pointer and the normal RID. The additional overhead is two bytes plus the Type 2 RID. Reorganizing or rebuilding the index can solve all of these problems.</P></LI><LI><P class="docList">The DBA should monitor the disk space usage of indexes and reorganize the indexes when they grow too large or when performance problems arise.<A NAME="ch20index160"></A><A NAME="ch20index161"></A></P></LI></UL>
<P class="docText">Be sure to factor all of these issues into your index storage requirement exercises.<A NAME="ch20index162"></A><A NAME="ch20index163"></A><A NAME="ch20index164"></A></P>
<A NAME="ch20lev2sec8"></A><H4 class="docSection2Title">Record Identifiers</H4>
<P class="docText">A RID is a 4-byte record identifier that contains record location information. RIDs are used to locate any piece of DB2 data. For large partitioned table spaces, the RID is a 5-byte record identifier.<A NAME="ch20index165"></A></P>
<P class="docText">The RID stores the page number and offset within the page where the data can be found. For pages in a partitioned table space, the high-order bits are used to identify the partition number.</P>
<P class="docText">Now that you know the physical structure of DB2 objects, you can explore the layout of DB2 itself.</P>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch20.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch20lev1sec2.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
