<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Access Path Strategies</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch21lev1sec3.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch21lev1sec5.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch21lev1sec4"></A><H3 class="docSection1Title">Access Path Strategies</H3>
<P class="docText">The optimizer can choose from a wealth of solutions when selecting the optimal access path for each SQL statement. These solutions, called <span class="docEmphasis">strategies,</span> range from the simple method of using a series of sequential reads to the complex strategy of using multiple indexes to combine multiple tables. This section describes the features and functionality of these strategies.<A NAME="ch21index63"></A><A NAME="ch21index64"></A><A NAME="ch21index65"></A><A NAME="ch21index66"></A></P>
<A NAME="ch21lev2sec5"></A><H4 class="docSection2Title">Scans</H4>
<P class="docText">Of the many decisions that must be made by the optimizer, perhaps the most important decision is whether an index will be used to satisfy the query. To determine this, the optimizer must first discover whether an index exists. Remember that you can query any column of any table known to DB2. An index does not have to be defined before SQL can be written to access that column. Therefore, it is important that the optimizer provide the capability to access non-indexed data as efficiently as possible.<A NAME="ch21index67"></A><A NAME="ch21index68"></A><A NAME="ch21index69"></A><A NAME="ch21index70"></A></P>
<P class="docText">Basically, an index will be used unless no indexes exist for the table and columns being accessed, or the optimizer determines that the query can be executed more efficiently without using an index.<sup class="docFootnote"><A class="docLink" HREF="#ch21fn01">[*]</A></sup> When an index is not used, the query is satisfied by sequentially reading the tablespace pages for the table being accessed.</P><blockquote><p class="docFootnote"><sup><A NAME="ch21fn01">[*]</A></sup> <span class="docEmphasis">Additionally, DB2 may forgo indexed access when type 2 indexes are required for a specific feature (such as uncommitted read isolation) but only type 1 indexes exist. This is true only for pre-V6 subsystems because type 1 indexes are no longer supported as of DB2 V6.</span></p></blockquote>
<P class="docText">Why would the optimizer determine that an index should not be used? Aren't indexes designed to make querying tables more efficient? The optimizer decides that an index should not be used for one of two reasons. The first reason is when the table being accessed has only a small number of rows. Using an index to query a small table can degrade performance because additional I/O is required. For example, consider a tablespace consisting of one page. Accessing this page without the index would require a single I/O. But if you use an index, at least one additional I/O is required to read the index page. Even more I/O may be required if index root pages, index non-leaf pages, and additional index leaf pages must be accessed.</P>
<P class="docText">The second reason for not using an index is that, for larger tables, the organization of the index could require additional I/O to satisfy the query. Factors affecting this are the full and first key cardinality of the index and the cluster ratio of the index.</P>
<P class="docText">When an index is not used to satisfy a query, the resulting access path is called a tablespace scan (see <A class="docLink" HREF="#ch21fig02">Figure 21.2</A>). A tablespace scan performs page-by-page processing, reading every page of a tablespace (or table).<A NAME="ch21index71"></A><A NAME="ch21index72"></A></P>
<A NAME="ch21fig02"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.2. A tablespace scan.</H5>
<p class="docText"><IMG BORDER="0" width="450" height="363" SRC="images/0672326132/graphics/21fig02.gif" ALT="graphics/21fig02.gif"></p></CENTER></p><br>
<P class="docText">Following are the steps involved in a tablespace scan:</P>
<A NAME="ch21pr02"></A>




<div style="font-weight:bold"><OL class="docList" START="1"><LI value="1"><div style="font-weight:normal">The RDS passes the request for a tablespace scan to the DM.<BR><BR></div></LI><LI value="2"><div style="font-weight:normal">The DM asks the BM to read all the data pages of the accessed table, one by one. Tablespace scans usually invoke a fast type of bulk read known as <span class="docEmphasis">sequential prefetch.</span><BR><BR></div></LI><LI value="3"><div style="font-weight:normal">The BM determines whether the requested page is in the buffer and takes the appropriate action to retrieve the requested page and return it to the DM.<BR><BR></div></LI><LI value="4"><div style="font-weight:normal">The DM scans the page and returns the selected columns to the RDS row by row. Predicates are applied by either the DM or the RDS, depending on whether the predicate is a Stage 1 or Stage 2 predicate.<BR><BR></div></LI><LI value="5"><div style="font-weight:normal">The results are returned to the requesting agent.<A NAME="ch21index73"></A><A NAME="ch21index74"></A><BR><BR></div></LI></OL></div>
<P class="docText">The actual type of tablespace scan used by DB2 depends on the type of tablespace being scanned. A simple tablespace uses a tablespace scan as shown in <A class="docLink" HREF="#ch21fig02">Figure 21.2</A>. Every page of the tablespace being scanned is read. This is true even if multiple tables are defined to the simple tablespace (which is one of the reasons to avoid multi-table simple tablespaces).<A NAME="ch21index75"></A><A NAME="ch21index76"></A><A NAME="ch21index77"></A><A NAME="ch21index78"></A></P>
<P class="docText">When a segmented tablespace is scanned, a tablespace scan such as the one in <A class="docLink" HREF="#ch21fig03">Figure 21.3</A> is invoked. A segmented tablespace scan reads pages from only those segments used for the table being accessed. This could more appropriately be termed a <span class="docEmphasis">table scan.</span><A NAME="ch21index79"></A><A NAME="ch21index80"></A></P>
<A NAME="ch21fig03"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.3. A segmented tablespace scan.</H5>
<p class="docText"><IMG BORDER="0" width="450" height="514" SRC="images/0672326132/graphics/21fig03.gif" ALT="graphics/21fig03.gif"></p></CENTER></p><br>
<P class="docText">Partitioned tablespace scans differ from simple and segmented tablespace scans because whole partitions can be skipped. DB2 can limit the partitions scanned to only those partitions that contain data relevant to the query. To do so, however, the query must specify a predicate that matches columns in the partitioning index.</P>
<P class="docText">To understand how limited partition scans function, consider the following query in conjunction with <A class="docLink" HREF="#ch21fig04">Figure 21.4</A>:<A NAME="ch21index81"></A><A NAME="ch21index82"></A></P>
<pre>

</pre><BR><pre>
SELECT COL1, COLx
FROM   T1
WHERE  PART_KEY BETWEEN "H" AND "J"
AND    PART_KEY = "T";
</pre><BR>
<A NAME="ch21fig04"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.4. Partitioned tablespace scans.</H5>
<p class="docText"><IMG BORDER="0" width="500" height="306" SRC="images/0672326132/graphics/21fig04.gif" ALT="graphics/21fig04.gif"></p></CENTER></p><br>
<P class="docText">Table <TT>T1</TT> is partitioned on the <TT>PART_KEY</TT> column. Note that there are five partitions in this tablespace as depicted in <A class="docLink" HREF="#ch21fig04">Figure 21.4</A>, but DB2 understands that only partitions 2 through 4 contain data that will satisfy this request. (Data values containing <TT>H</TT> through <TT>J</TT> are in partition 2; <TT>T</TT> is in partition 4.) Therefore, DB2 can avoid scanning the data contained in partitions 1 and 5. But DB2 can also avoid scanning partition 3 because it does not contain any data needed to satisfy the query. This is called partition skipping within a tablespace scan. If DB2 determines that partitions can be skipped during a scan, it will do so. Otherwise it will revert back to scanning all of the tablespace partitions.</P>
<P class="docText">Limited partition scans can be combined with matching index scans when appropriate. A limited partition scan can also be used for each table accessed in a join, as long as the access is sequential.<A NAME="ch21index83"></A><A NAME="ch21index84"></A><A NAME="ch21index85"></A><A NAME="ch21index86"></A><A NAME="ch21index87"></A><A NAME="ch21index88"></A></P>
<A NAME="ch21note02"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">When host variables or parameter markers are used in the first column of a multi-column partitioning key, DB2 will not limit the partitions scanned. In these circumstances, DB2 doesn't know the qualified partition range at bind time. By binding with the <TT>REOPT(VARS)</TT> parameter though, you can direct DB2 to redetermine the access path at run time each time the statement is run.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" ALIGN="LEFT" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> As of DB2 V8, <TT>REOPT(ALWAYS)</TT> can be used as a synonym for <TT>REOPT(VARS)</TT>.</P></td></tr></table><br></div><br>
<A NAME="ch21lev2sec6"></A><H4 class="docSection2Title">Sequential Prefetch</H4>
<P class="docText">Before discussing the various types of indexed data access, a discussion of sequential prefetch is in order. <span class="docEmphasis">Sequential prefetch</span> is a read-ahead mechanism invoked to prefill DB2's buffers so that data is already in memory before it is requested. When sequential prefetch is requested, DB2 can be thought of as playing the role of a psychic, predicting that the extra pages being read will need to be accessed, because of the nature of the request.<A NAME="ch21index89"></A><A NAME="ch21index90"></A><A NAME="ch21index91"></A><A NAME="ch21index92"></A><A NAME="ch21index93"></A></P>
<P class="docText">The optimizer requests sequential prefetch when it determines that sequential processing is required. The sequential page processing of a tablespace scan is a good example of a process that can benefit from sequential prefetch. The optimizer requests sequential prefetch in one of three ways.</P>
<P class="docText">The first way is static. A static request is made when the optimizer deems the request to be sequential and causes the optimizer to choose sequential prefetch at bind time. The second way is when a dynamic request invokes sequential prefetch at execution time.<A NAME="ch21index94"></A><A NAME="ch21index95"></A><A NAME="ch21index96"></A><A NAME="ch21index97"></A><A NAME="ch21index98"></A><A NAME="ch21index99"></A></P>
<P class="docText">The third way in which sequential prefetch is requested is called sequential detection. <span class="docEmphasis">Sequential detection</span> dynamically invokes sequential prefetch during the middle of running a query. Sequential detection "turns on" sequential prefetch for static requests that were not thought to be sequential at bind time but resulted in sequential data access during execution.<A NAME="ch21index100"></A><A NAME="ch21index101"></A><A NAME="ch21index102"></A></P>
<P class="docText">Sequential detection uses groupings of pages based on the size of the buffer pool to determine whether sequential prefetch should be requested. The size of the buffer pool is called the sequential detection indicator and is determined using the Normal Processing column of <A class="docLink" HREF="#ch21table03">Table 21.3</A>. The values in <A class="docLink" HREF="#ch21table03">Table 21.3</A> apply to buffer pools with a 4KB page size (BP0 through BP49). Call the sequential detection indicator <span class="docEmphasis">D</span>. Sequential detection will request prefetch when ((D/4)+1) out of (D/2) pages are accessed sequentially within a grouping of D pages.<A NAME="ch21index103"></A><A NAME="ch21index104"></A><A NAME="ch21index105"></A></P>
<A NAME="ch21table03"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 21.3. Sequential Prefetch and Detection Values for 4KB Page Bufferpools</h5></CAPTION><COLGROUP><COL width="183.33333333333331"><COL width="183.33333333333331"><COL width="183.33333333333331"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><span class="docEmphStrong">Bufferpool Size</span></P></TH><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><span class="docEmphStrong">Number of Pages Read (Normal Processing)</span></P></TH><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><span class="docEmphStrong">Number of Pages Read (Utility Processing)</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">0-223</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">8</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">16</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">224-999</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">16</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">32</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">1000+</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">32</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">64</P></TD></TR></TABLE></P><br>
<P class="docText">For example, in an environment having 800 buffers, the sequential detection indicator would be 16. If 4 out of 8 pages accessed are sequential within a 16-page grouping, sequential detection invokes prefetch.</P>
<P class="docText">The sequential prefetch numbers are different for larger page sizes. DB2 will prefetch fewer pages because the buffer pools are larger (a 32KB pages is 8 times larger than a 4K page). <A class="docLink" HREF="#ch21table05">Tables 21.5</A> through <A class="docLink" HREF="ch21lev1sec5.html#ch21table07">21.7</A> shows the number of pages read by sequential prefetch for 8KB, 16KB, and 32KB page buffer pools. For utility processing, the number of pages read are double the amount specified in <A class="docLink" HREF="#ch21table04">Tables 21.4</A>, <A class="docLink" HREF="#ch21table05">21.5</A>, and <A NAME="ch21index106"></A><A class="docLink" HREF="#ch21table06">21.6</A>.</P>
<A NAME="ch21table04"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 21.4. Sequential Prefetch Values for 8KB Page Bufferpools</h5></CAPTION><COLGROUP><COL width="187"><COL width="363"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Bufferpool Size</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Number of Pages Read</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">0-112</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">112-499</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">8</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">500+</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">16</P></TD></TR></TABLE></P><br>
<A NAME="ch21table05"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 21.5. Sequential Prefetch Values for 16KB Page Bufferpools</h5></CAPTION><COLGROUP><COL width="187"><COL width="363"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Bufferpool Size</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Number of Pages Read</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">0-56</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">57-249</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">250+</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">8</P></TD></TR></TABLE></P><br>
<A NAME="ch21table06"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 21.6. Sequential Prefetch Values for 32KB Page Bufferpools</h5></CAPTION><COLGROUP><COL width="187"><COL width="363"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Bufferpool Size</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Number of Pages Read</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">0-16</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">0 (prefetch disabled)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">17-99</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">100+</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">4<A NAME="ch21index107"></A><A NAME="ch21index108"></A><A NAME="ch21index109"></A></P></TD></TR></TABLE></P><br>
<P class="docText"><A class="docLink" HREF="#ch21fig05">Figure 21.5</A> shows the potential effect of sequential prefetch on a request. A normal DB2 I/O reads one page of data at a time. By contrast, a sequential prefetch I/O can read up to 32 pages at a time, which can have a dramatic effect on performance because you skip the seek and rotational delay time. Everything else being constant, sequential prefetch I/O can enhance efficiency significantly over standard I/O.<A NAME="ch21index110"></A><A NAME="ch21index111"></A><A NAME="ch21index112"></A><A NAME="ch21index113"></A><A NAME="ch21index114"></A></P>
<A NAME="ch21fig05"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.5. Sequential prefetch.</H5>
<p class="docText"><IMG BORDER="0" width="450" height="561" SRC="images/0672326132/graphics/21fig05.gif" ALT="graphics/21fig05.gif"></p></CENTER></p><br>
<P class="docText">The number of pages that can be requested in a single I/O by sequential prefetch depends on the number of pages allocated to the DB2 buffer pool, as shown in <A class="docLink" HREF="#ch21table04">Tables 21.4</A> through <A class="docLink" HREF="ch21lev1sec5.html#ch21table07">21.7</A>.</P>
<P class="docText">As you plan your environment for the optimal use of sequential prefetch, keep these final notes in mind. When sequential prefetch is requested by the optimizer, it is invoked immediately after the first single page I/O is performed. After this first I/O, DB2 kicks off two sequential prefetch I/Os—one for the pages that must be processed almost immediately and another for the second set of prefetched pages. This is done to reduce I/O wait time. Thereafter, each successive prefetch I/O is requested before all the currently prefetched pages have been processed. This scenario is shown in <A class="docLink" HREF="#ch21fig06">Figure 21.6</A>.<A NAME="ch21index115"></A><A NAME="ch21index116"></A><A NAME="ch21index117"></A></P>
<A NAME="ch21fig06"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.6. Sequential prefetch processing.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/21fig06_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="362" SRC="images/0672326132/graphics/21fig06.gif" ALT="graphics/21fig06.gif"></p></CENTER></p><br>
<P class="docText">Sequential prefetch is not the sole dominion of tablespace scans. Any process that relies on the sequential access of data pages (either index pages or tablespace pages) can benefit from sequential prefetch. Sequential prefetch can be requested by DB2 under any of the following circumstances:</P>
<UL><LI><P class="docList">A tablespace scan of more than one page</P></LI><LI><P class="docList">An index scan in which the data is clustered and DB2 determines that eight or more pages must be accessed</P></LI><LI><P class="docList">An index-only scan in which DB2 estimates that eight or more leaf pages must be accessed<A NAME="ch21index118"></A><A NAME="ch21index119"></A><A NAME="ch21index120"></A><A NAME="ch21index121"></A><A NAME="ch21index122"></A></P></LI></UL>
<A NAME="ch21lev2sec7"></A><H4 class="docSection2Title">Indexed Access</H4>
<P class="docText">Generally, the fastest way to access DB2 data is with an index. Indexes are structured in such a way as to increase the efficiency of finding a particular piece of data. However, the manner in which DB2 uses an index varies from statement to statement. DB2 uses many different internal algorithms to traverse an index structure. These algorithms are designed to elicit optimum performance in a wide variety of data access scenarios.<A NAME="ch21index123"></A><A NAME="ch21index124"></A><A NAME="ch21index125"></A><A NAME="ch21index126"></A><A NAME="ch21index127"></A></P>
<P class="docText">Before DB2 will use an index to satisfy a data access request, the following criteria must be met:</P>
<UL><LI><P class="docList">At least one of the predicates for the SQL statement must be indexable. Refer to <A class="docLink" HREF="ch02.html#ch02">Chapter 2</A>, "Data Manipulation Guidelines," for a list of indexable predicates.</P></LI><LI><P class="docList">One of the columns (in any indexable predicate) must exist as a column in an available index.</P></LI></UL>
<P class="docText">This is all that is required for DB2 to consider indexed access as a possible solution for a given access path. As you progress further into the types of indexed access, you will see that more specific criteria might be required before certain types of indexed access are permitted.</P>
<P class="docText">The first, and most simple, type of indexed access is the <span class="docEmphasis">direct index lookup,</span> shown in <A class="docLink" HREF="#ch21fig07">Figure 21.7</A>. The arrows on this diagram outline the processing flow through the highlighted pages. The following sequence of steps is performed during a direct index lookup:<A NAME="ch21index128"></A><A NAME="ch21index129"></A><A NAME="ch21index130"></A></P>
<A NAME="ch21pr03"></A>



<div style="font-weight:bold"><OL class="docList" START="1"><LI value="1"><div style="font-weight:normal">The value requested in the predicate is compared to the values in the root page of the index.<BR><BR></div></LI><LI value="2"><div style="font-weight:normal">If intermediate non-leaf pages exist, the appropriate non-leaf page is read, and the value is compared to determine which leaf page to access.<BR><BR></div></LI><LI value="3"><div style="font-weight:normal">The appropriate leaf page is read, and the RIDs of the qualifying rows are determined.<BR><BR></div></LI><LI value="4"><div style="font-weight:normal">Based on the index entries, DB2 reads the appropriate data pages.<BR><BR></div></LI></OL></div>
<A NAME="ch21fig07"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.7. Direct index lookup.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/21fig07_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="405" SRC="images/0672326132/graphics/21fig07.gif" ALT="graphics/21fig07.gif"></p></CENTER></p><br>
<P class="docText">For DB2 to perform a direct index lookup, values must be provided for each column in the index. For example, consider an index on one of the sample tables, <TT>DSN8810.XPROJAC1</TT> on <TT>DSN8810.PROJACT</TT>. This index consists of three columns: <TT>PROJNO</TT>, <TT>ACTNO</TT>, and <TT>ACSTDATE</TT>. All three columns must appear in the SQL statement for a direct index lookup to occur. For example, consider the following:</P>
<pre>

</pre><BR><pre>
SELECT   ACSTAFF, ACENDATE
FROM     DSN8810.PROJACT
WHERE    PROJNO = '000100'
AND      ACTNO = 1
AND      ACSTDATE = '2001-12-31';
</pre><BR>
<P class="docText">If only one or two of these columns were specified as predicates, a direct index lookup could not occur because DB2 would not have a value for each column and could not match the full index key. Instead, an index scan could be chosen. There are two basic types of index scans: <span class="docEmphasis">matching index scans</span> and <span class="docEmphasis">non-matching index scans</span>. A matching index scan is sometimes called <span class="docEmphasis">absolute positioning</span>; a non-matching index scan is sometimes called <span class="docEmphasis">relative positioning</span>.<A NAME="ch21index131"></A><A NAME="ch21index132"></A><A NAME="ch21index133"></A><A NAME="ch21index134"></A><A NAME="ch21index135"></A><A NAME="ch21index136"></A></P>
<P class="docText">Remember the previous discussion of tablespace scans? Index scans are similar. When you invoke an index scan, the leaf pages of the index being used to facilitate access are read sequentially. Let's examine these two types of index scans more closely.</P>
<P class="docText">A matching index scan begins at the root page of an index and works down to a leaf page in much the same manner as a direct index lookup does. However, because the complete key of the index is unavailable, DB2 must scan the leaf pages using the values that it does have, until all matching values have been retrieved. This is shown in <A class="docLink" HREF="#ch21fig08">Figure 21.8</A>.<A NAME="ch21index137"></A><A NAME="ch21index138"></A><A NAME="ch21index139"></A><A NAME="ch21index140"></A><A NAME="ch21index141"></A><A NAME="ch21index142"></A><A NAME="ch21index143"></A><A NAME="ch21index144"></A><A NAME="ch21index145"></A><A NAME="ch21index146"></A></P>
<A NAME="ch21fig08"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.8. A matching index scan.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/21fig08_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="404" SRC="images/0672326132/graphics/21fig08.gif" ALT="graphics/21fig08.gif"></p></CENTER></p><br>
<P class="docText">To clarify, consider again a query of the <TT>DSN8810.PROJACT</TT> table. This time, the query is recoded without the predicate for the <TT>ACSTDATE</TT> column:</P>
<pre>

</pre><BR><pre>
SELECT   ACSTAFF, ACENDATE
FROM     DSN8810.PROJACT
WHERE    PROJNO = '000100'
AND      ACTNO = 1;
</pre><BR>
<P class="docText">The matching index scan locates the first leaf page with the appropriate value for <TT>PROJNO</TT> and <TT>ACTNO</TT> by traversing the index starting at the root. However, there can be multiple index entries with this combination of values and different <TT>ACSTDATE</TT> values. Therefore, leaf pages are sequentially scanned until no more valid <TT>PROJNO</TT>, <TT>ACTNO</TT>, and varying <TT>ACSTDATE</TT> combinations are encountered.</P>
<P class="docText">For a matching index scan to be requested, you must specify the high order column in the index key, which is <TT>PROJNO</TT> in the preceding example. This provides a starting point for DB2 to traverse the index structure from the root page to the appropriate leaf page. What would happen, though, if you did not specify this high order column? Suppose that you alter the sample query such that a predicate for <TT>PROJNO</TT> is not specified:<A NAME="ch21index147"></A><A NAME="ch21index148"></A><A NAME="ch21index149"></A><A NAME="ch21index150"></A><A NAME="ch21index151"></A></P>
<pre>

</pre><BR><pre>
SELECT   ACSTAFF, ACENDATE
FROM     DSN8810.PROJACT
WHERE    ACTNO = 1
AND      ACSTDATE = '2001-12-31';
</pre><BR>
<P class="docText">In this instance, a non-matching index scan can be chosen. When a starting point cannot be determined because the first column in the key is unavailable, DB2 cannot use the index tree structure, but it can use the index leaf pages, as shown in <A class="docLink" HREF="#ch21fig09">Figure 21.9</A>. A non-matching index scan begins with the first leaf page in the index and sequentially scans subsequent leaf pages, applying the available predicates.<A NAME="ch21index152"></A><A NAME="ch21index153"></A><A NAME="ch21index154"></A><A NAME="ch21index155"></A><A NAME="ch21index156"></A></P>
<A NAME="ch21fig09"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.9. A non-matching index scan.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/21fig09_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="356" SRC="images/0672326132/graphics/21fig09.gif" ALT="graphics/21fig09.gif"></p></CENTER></p><br>
<P class="docText">DB2 uses a non-matching index scan instead of a tablespace scan for many reasons. A non-matching index scan can be more efficient than a tablespace scan, especially if the data pages that must be accessed are in clustered order. As discussed in <A class="docLink" HREF="ch02.html#ch02">Chapter 2</A>, you can create clustering indexes that dictate the order in which DB2 should attempt to store data. When data is clustered by key columns, I/O can be reduced. Of course, a non-matching index scan be done on a non-clustered index, also.</P>
<P class="docText">Compare the clustered index access shown in <A class="docLink" HREF="#ch21fig10">Figure 21.10</A> with the non-clustered index access in <A class="docLink" HREF="#ch21fig11">Figure 21.11</A>. Clustered index access, as it proceeds from leaf page to leaf page, never requests a read for the same data page twice. It is evident from the figure that the same cannot be said for non-clustered index access.<A NAME="ch21index157"></A><A NAME="ch21index158"></A><A NAME="ch21index159"></A><A NAME="ch21index160"></A><A NAME="ch21index161"></A><A NAME="ch21index162"></A></P>
<A NAME="ch21fig10"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.10. Clustered index access.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/21fig10_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="356" SRC="images/0672326132/graphics/21fig10.gif" ALT="graphics/21fig10.gif"></p></CENTER></p><br>
<A NAME="ch21fig11"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.11. Non-clustered index access.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/21fig11_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="356" SRC="images/0672326132/graphics/21fig11.gif" ALT="graphics/21fig11.gif"></p></CENTER></p><br>
<P class="docText">Furthermore, scanning an index can be more efficient than scanning the table because index rows usually are smaller than table rows so more data can be stored on an index page than a data page.</P>
<P class="docText">Another time when a non-matching index might be chosen is to maintain data in a particular order to satisfy an <TT>ORDER BY</TT> or <TT>GROUP BY</TT><A NAME="ch21index163"></A><A NAME="ch21index164"></A><A NAME="ch21index165"></A><A NAME="ch21index166"></A><A NAME="ch21index167"></A><A NAME="ch21index168"></A><A NAME="ch21index169"></A><A NAME="ch21index170"></A><A NAME="ch21index171"></A><A NAME="ch21index172"></A></P>
<P class="docText">Another indexed access technique that DB2 can deploy is <span class="docEmphasis">index screening</span>. With index screening, a matching index scan is done on the leading columns of a composite index and then additional predicates are applied to the composite index. This technique is useful if columns of a multi-column index are not specified in the query. Consider our sample query revised once more<A NAME="ch21index173"></A><A NAME="ch21index174"></A><A NAME="ch21index175"></A><A NAME="ch21index176"></A></P>
<pre>

</pre><BR><pre>
SELECT   ACSTAFF, ACENDATE
FROM     DSN8810.PROJACT
WHERE    ACTNO = 1
AND      ACSTDATE &gt; '2001-12-31';
</pre><BR>
<P class="docText">Now, assume a composite index exists on the following—<TT>ACTNO</TT>, one or more other columns, and then <TT>ACSTDATE</TT>. The index can be screened by applying a matching index scan on <TT>ACTNO</TT>, and then a nonmatching scan for the specified <TT>ACSTDATE</TT> values greater than <TT>'2001-12-31'</TT>—but only for those rows that matched the <TT>ACTNO = 1</TT> predicate.</P>
<P class="docText">DB2 can avoid reading data pages completely if all the required data exists in the index. This feature is known as <span class="docEmphasis">index-only access</span> and is pictured in <A class="docLink" HREF="#ch21fig12">Figure 21.12</A>.<A NAME="ch21index177"></A><A NAME="ch21index178"></A><A NAME="ch21index179"></A></P>
<A NAME="ch21fig12"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.12. Index-only access.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/21fig12_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="501" SRC="images/0672326132/graphics/21fig12.gif" ALT="graphics/21fig12.gif"></p></CENTER></p><br>
<P class="docText">Consider again the sample query. This time, it is recoded so that the only columns that must be accessed are <TT>ACTNO</TT> and <TT>ACSTDATE</TT> for predicate evaluation and <TT>PROJNO</TT>, which is returned in the select list:</P>
<pre>

</pre><BR><pre>
SELECT   PROJNO
FROM     DSN8810.PROJACT
WHERE    ACTNO = 1
AND      ACSTDATE = '2001-12-31';
</pre><BR>
<P class="docText">DB2 can satisfy this query by simply scanning the leaf pages of the index. It never accesses the tablespace data pages. A non-matching index-only scan is usually much faster than a tablespace scan because index entries are generally smaller than the table rows that they point to.</P>
<A NAME="ch21note03"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" ALIGN="LEFT" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> Be careful with indexes having VARCHAR columns in the key. Prior to DB2 V8 there was no such thing as a non-padded index, so the data was expanded to its maximum length in the index. This eliminated the possibility of index-only access for such indexes because DB2 had to access the table data to get the length of the variable length data. Of course, DB2 V8 supports variable length keys in non-padded indexes, so this problem is not as troublesome any longer.<A NAME="ch21index180"></A><A NAME="ch21index181"></A><A NAME="ch21index182"></A></P></td></tr></table><br></div><br>
<P class="docText">DB2 can use three other methods to provide indexed access for optimized SQL. The first is <span class="docEmphasis">list prefetch</span>. As mentioned, accessing non-clustered data with an index can be inefficient. However, if DB2 determines beforehand that the degree of clustering is such that a high number of additional page I/Os might be requested, list prefetch can be requested to sort the access requests before requesting the data page I/Os (see <A class="docLink" HREF="#ch21fig13">Figure 21.13</A>).<A NAME="ch21index183"></A><A NAME="ch21index184"></A><A NAME="ch21index185"></A><A NAME="ch21index186"></A><A NAME="ch21index187"></A><A NAME="ch21index188"></A><A NAME="ch21index189"></A><A NAME="ch21index190"></A><A NAME="ch21index191"></A></P>
<A NAME="ch21fig13"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.13. List prefetch.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/21fig13_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="538" SRC="images/0672326132/graphics/21fig13.gif" ALT="graphics/21fig13.gif"></p></CENTER></p><br>
<P class="docText">List prefetch performs the following tasks:</P>
<div style="font-weight:bold"><OL class="docList" TYPE="1"><LI><div style="font-weight:normal"><P class="docList">The first leaf page is located using a matching index scan.</P></div></LI><LI><div style="font-weight:normal"><P class="docList">A list of RIDs for the matching index entries is acquired from the leaf pages as they are scanned.</P></div></LI><LI><div style="font-weight:normal"><P class="docList">These RIDs can be sorted into sequence by data page number to reduce the number of I/O requests. If the index is at least 80% clustered, the sort is bypassed.</P></div></LI><LI><div style="font-weight:normal"><P class="docList">Using the ordered RID list, data pages are accessed to satisfy the request.<A NAME="ch21index192"></A><A NAME="ch21index193"></A><A NAME="ch21index194"></A><A NAME="ch21index195"></A></P></div></LI></OL></div>
<P class="docText">When the RIDs are sorted by list prefetch, the order in which they were retrieved from the index is changed. Therefore, an additional sort of the results might be required if an <TT>ORDER BY</TT> clause was specified. If an <TT>ORDER BY</TT> clause was not specified, the use of list prefetch will probably cause the results to be unordered, even though an index was used.</P>
<P class="docText">The term <span class="docEmphasis">skip sequential prefetch</span> is used to categorize the type of access that list prefetch performs on data pages. When the sorted RID list is used to retrieve data pages, list prefetch effectively performs a type of sequential prefetch, whereby only the needed data pages are accessed. Those that are not needed are skipped.<A NAME="ch21index196"></A><A NAME="ch21index197"></A><A NAME="ch21index198"></A><A NAME="ch21index199"></A><A NAME="ch21index200"></A></P>
<P class="docText"><span class="docEmphasis">Multi-index access</span> is another type of indexed access used by DB2. The idea behind multi-index access is to use more than one index for a single access path. For example, consider the <TT>DSN8810.EMP</TT> table, which has two indexes: <TT>DSN8810.XEMP1</TT> on column <TT>EMPNO</TT> and <TT>DSN8810.XEMP2</TT> on column <TT>WORKDEPT</TT>.<A NAME="ch21index201"></A><A NAME="ch21index202"></A><A NAME="ch21index203"></A></P>
<P class="docText">Here is a query of three employees who work in a specific department:</P>
<pre>

</pre><BR><pre>
SELECT   LASTNAME, FIRSTNME, MIDINIT
FROM     DSN8810.EMP
WHERE    EMPNO IN ('000100', '000110', '000120')
AND      WORKDEPT = 'A00';
</pre><BR>
<P class="docText">This query specifies predicates for two columns that appear in two separate indexes. Doesn't it stand to reason that it might be more efficient to use both indexes than to estimate which of the two indexes will provide more efficient access? This is the essence of multi-index access.</P>
<P class="docText">There are two types of multi-index access, depending on whether the predicates are tied together using <TT>AND</TT> or <TT>OR</TT>. DB2 invokes the following sequence of tasks when multi-index access is requested:</P>
<A NAME="ch21pr04"></A>






<div style="font-weight:bold"><OL class="docList" START="1"><LI value="1"><div style="font-weight:normal">The first leaf page for the first indexed access is located using a matching index scan.<BR><BR></div></LI><LI value="2"><div style="font-weight:normal">A list of RIDs for the matching index entries is acquired from the leaf pages as they are scanned.<BR><BR></div></LI><LI value="3"><div style="font-weight:normal">These RIDs are sorted into sequence by data page number to reduce the number of I/O requests.<BR><BR></div></LI><LI value="4"><div style="font-weight:normal">Steps 1, 2, and 3 are repeated for each index used.<BR><BR></div></LI><LI value="5"><div style="font-weight:normal">If the SQL statement being processed concatenated its predicates using the <TT>AND</TT> connector (such as in the sample query), the RID lists are intersected as shown in <A class="docLink" HREF="#ch21fig14">Figure 21.14</A>. RID intersection is the process of combining multiple RID lists by keeping only the RIDs that exist in both RID lists.<A NAME="ch21index204"></A><A NAME="ch21index205"></A><A NAME="ch21index206"></A><A NAME="ch21index207"></A><A NAME="ch21index208"></A><BR><BR>
<A NAME="ch21fig14"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.14. Multi-index access (<TT>AND</TT>).</H5>
<p class="docText"><IMG BORDER="0" width="500" height="532" SRC="images/0672326132/graphics/21fig14.gif" ALT="graphics/21fig14.gif"></p></CENTER></p><br></div></LI><LI value="6"><div style="font-weight:normal">If the SQL statement being processed concatenated its predicates using the <TT>OR</TT> connector (such as the following query), the RID lists are combined using a <TT>UNION</TT>, as shown in <A class="docLink" HREF="#ch21fig15">Figure 21.15</A>.<BR><BR>
<pre>

</pre><BR><pre>
SELECT   LASTNAME, FIRSTNME, MIDINIT
FROM     DSN8810.EMP
WHERE    EMPNO IN ('000100', '000110', '000120')
OR       WORKDEPT = 'A00';
</pre><BR>
<A NAME="ch21fig15"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.15. Multi-index access (<TT>OR</TT>).</H5>
<p class="docText"><IMG BORDER="0" width="500" height="530" SRC="images/0672326132/graphics/21fig15.gif" ALT="graphics/21fig15.gif"></p></CENTER></p><br>
RID <TT>UNION</TT> is the process of combining multiple RID lists by appending all the RIDs into a single list and eliminating duplicates.<A NAME="ch21index209"></A><A NAME="ch21index210"></A><A NAME="ch21index211"></A><BR><BR></div></LI><LI value="7"><div style="font-weight:normal">Using the final, combined RID list, data pages are accessed to satisfy the request. As with list prefetch, skip sequential prefetch is used to access these pages.<BR><BR></div></LI></OL></div>
<P class="docText">A final indexed access technique is <span class="docEmphasis">index lookaside</span>. Although index lookaside is technically not an access path but a technique employed by DB2, it is still appropriate to discuss it in the context of indexed access. Index lookaside optimizes the manner in which index pages can be accessed (see <A class="docLink" HREF="#ch21fig16">Figure 21.16</A>). Of course, you have no control over whether DB2 uses index lookaside or not—it is a technique used by DB2 at the sole discretion of DB2.<A NAME="ch21index212"></A><A NAME="ch21index213"></A><A NAME="ch21index214"></A><A NAME="ch21index215"></A></P>
<A NAME="ch21fig16"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.16. Index lookaside.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/21fig16_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="356" SRC="images/0672326132/graphics/21fig16.gif" ALT="graphics/21fig16.gif"></p></CENTER></p><br>
<P class="docText">Normally, DB2 traverses the b-tree structure of the index to locate an index entry. This can involve significant overhead as DB2 checks the root and intermediate non-leaf index pages. When using index lookaside, the path length required to find a particular leaf page can be reduced. The index lookaside technique begins only after an initial index access has taken place. Using index lookaside, DB2 checks for the RID of the desired row first on the current leaf page and next on the immediately higher non-leaf page. If unsuccessful, DB2 then reverts to a standard index lookup.</P>
<P class="docText">By checking the current leaf page and the immediately higher non-leaf page, DB2 increases its chances of locating the desired RID sooner and adds only a minimal amount of overhead (because the ranges of values covered by the leaf and non-leaf pages are stored in cache memory upon first execution of the <TT>SELECT</TT>).<A NAME="ch21index216"></A><A NAME="ch21index217"></A><A NAME="ch21index218"></A><A NAME="ch21index219"></A><A NAME="ch21index220"></A></P>
<A NAME="ch21lev2sec8"></A><H4 class="docSection2Title">Join Methods</H4>
<P class="docText">When more than one DB2 table is referenced in the <TT>FROM</TT> clause of a single SQL <TT>SELECT</TT> statement, a request is being made to join tables. Based on the join criteria, a series of instructions must be carried out to combine the data from the tables. The optimizer has a series of methods to enable DB2 to join tables.<A NAME="ch21index221"></A><A NAME="ch21index222"></A><A NAME="ch21index223"></A><A NAME="ch21index224"></A></P>
<P class="docText">Multi-table queries are broken down into several access paths. The DB2 optimizer selects two of the tables and creates an optimized access path for accomplishing that join. When that join is satisfied, the results are joined to another table. This process continues until all specified tables have been joined.</P>
<P class="docText">When joining tables, the access path defines how each single table will be accessed and also how it will be joined with the next table. Thus, each access path chooses not only an access path strategy (for example, a tablespace scan versus indexed access) but also a join algorithm. The join algorithm, or <span class="docEmphasis">join method</span>, defines the basic procedure for combining the tables. DB2 has three basic methods for joining tables:</P>
<UL><LI><P class="docList">Nested loop join</P></LI><LI><P class="docList">Merge scan join</P></LI><LI><P class="docList">Hybrid join</P></LI></UL>
<P class="docText">Each method operates differently from the others but achieves the same basic results—accessing data from multiple tables. However, the choice of join method has an important effect on the performance of the join. Each join method used by DB2 is engineered such that, given a set of statistics, optimum performance can be achieved. Therefore, you should understand the different join methods and the factors that cause them to be chosen.</P>
<P class="docText">How do these join methods operate? A basic series of steps is common to each join method. In general, the first decision to be made is which table should be processed first. This table is referred to as the <span class="docEmphasis">outer table</span>. After this decision is made, a series of operations are performed on the outer table to prepare it for joining. Rows from that table are then combined to the second table, called the <span class="docEmphasis">inner table</span>. A series of operations are also performed on the inner table either before the join occurs, as the join occurs, or both. This general join procedure is depicted in <A class="docLink" HREF="#ch21fig17">Figure 21.17</A>.</P>
<A NAME="ch21fig17"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.17. Generalized join process.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/21fig17_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="577" SRC="images/0672326132/graphics/21fig17.gif" ALT="graphics/21fig17.gif"></p></CENTER></p><br>
<P class="docText">Although all joins are composed of similar steps, each of DB2's three join methods is strikingly dissimilar when you get beyond the generalities. The optimizer understands the advantages and disadvantages of each method and how the use of that method can affect performance. Based on the current statistics in the DB2 Catalog, the optimizer understands also which tables are best accessed as the inner table versus the outer table.<A NAME="ch21index225"></A><A NAME="ch21index226"></A><A NAME="ch21index227"></A><A NAME="ch21index228"></A></P>
<A NAME="ch21lev3sec1"></A><H5 class="docSection3Title">Nested Loop Join</H5>
<P class="docText">The most common type of join method is the <span class="docEmphasis">nested loop join,</span> which is shown in <A class="docLink" HREF="#ch21fig18">Figure 21.18</A>. A qualifying row is identified in the outer table, and then the inner table is scanned searching for a match. (A <span class="docEmphasis">qualifying row</span> is one in which the local predicates for columns in the table match.) When the inner table scan is complete, another qualifying row in the outer table is identified. The inner table is scanned for a match again, and so on. The repeated scanning of the inner table is usually accomplished with an index so as not to incur undue I/O costs. Filtering the outer table for qualifying rows also is likely to be accomplished using an index.<A NAME="ch21index229"></A><A NAME="ch21index230"></A><A NAME="ch21index231"></A><A NAME="ch21index232"></A><A NAME="ch21index233"></A><A NAME="ch21index234"></A><A NAME="ch21index235"></A></P>
<A NAME="ch21fig18"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.18. Nested loop join. (Diagram provided courtesy of Sheryl M. Larsen, Inc.)</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/21fig18_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="575" SRC="images/0672326132/graphics/21fig18.gif" ALT="graphics/21fig18.gif"></p></CENTER></p><br>
<P class="docText">Nested loop join is a viable access path when the whole answer set is not required.</P>
<A NAME="ch21lev3sec2"></A><H5 class="docSection3Title">Merge Scan Join</H5>
<P class="docText">The second type of join method that can be used by DB2 is the <span class="docEmphasis">merge scan join</span>. In a merge scan join, the tables to be joined are ordered by the keys. This ordering can be the result of either a sort or indexed access (see <A class="docLink" HREF="#ch21fig19">Figure 21.19</A>). After ensuring that both the outer and inner tables are properly sequenced, each table is read sequentially, and the join columns are matched. Neither table is read more than once during a merge scan join.<A NAME="ch21index236"></A><A NAME="ch21index237"></A><A NAME="ch21index238"></A><A NAME="ch21index239"></A><A NAME="ch21index240"></A></P>
<A NAME="ch21fig19"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.19. Merge scan join. (Diagram provided courtesy of Sheryl M. Larsen, Inc.)</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/21fig19_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="288" SRC="images/0672326132/graphics/21fig19.gif" ALT="graphics/21fig19.gif"></p></CENTER></p><br>
<A NAME="ch21lev3sec3"></A><H5 class="docSection3Title">Hybrid Join</H5>
<P class="docText">The third type of join is the hybrid join. In practice, relatively few joins turn out to be optimal as hybrid joins. The <span class="docEmphasis">hybrid join</span> can be thought of as a mixture of the other join methods coupled with list prefetch.<A NAME="ch21index241"></A><A NAME="ch21index242"></A><A NAME="ch21index243"></A><A NAME="ch21index244"></A><A NAME="ch21index245"></A></P>
<P class="docText"><A class="docLink" HREF="#ch21fig20">Figure 21.20</A> shows the processing flow used by the hybrid join.</P>
<A NAME="ch21fig20"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.20. Hybrid join. (Diagram provided courtesy of Sheryl M. Larsen, Inc.)</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/21fig20_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="573" SRC="images/0672326132/graphics/21fig20.gif" ALT="graphics/21fig20.gif"></p></CENTER></p><br>
<P class="docText">The hybrid join works as follows:</P>
<div style="font-weight:bold"><OL class="docList" TYPE="1"><LI><div style="font-weight:normal"><P class="docList">Using either indexed access or a sort, qualifying outer table rows are accessed in order by the join columns.</P></div></LI><LI><div style="font-weight:normal"><P class="docList">As the outer table rows are accessed in sequence, they are compared to an appropriate index on the inner table. In a hybrid join, there must be an index on the join columns of the inner table.</P></div></LI><LI><div style="font-weight:normal"><P class="docList">The index RIDs from the qualifying inner table are combined with the required columns of the outer table, forming an intermediate table. This intermediate table consists of the selected outer table columns and the RIDs of the matching rows from the index on the inner table. The RIDs are also placed in the RID pool, forming a RID list.</P></div></LI><LI><div style="font-weight:normal"><P class="docList">Both the RID list and the intermediate table are sorted. If the index on the inner table is a clustering index, DB2 can skip this sort.</P></div></LI><LI><div style="font-weight:normal"><P class="docList">The RID list in the intermediate table is resolved into a results table using list prefetch. The appropriate inner table rows are returned by following the RIDs.</P></div></LI><LI><div style="font-weight:normal"><P class="docList">Finally, if an <TT>ORDER BY</TT> is specified in the join SQL, a sort is usually required to order the final results table.</P></div></LI></OL></div>
<P class="docText">The hybrid join method can provide modest performance gains for some applications that process medium-sized table joins. However, most shops have few access paths that use this type of join.<A NAME="ch21index246"></A><A NAME="ch21index247"></A><A NAME="ch21index248"></A><A NAME="ch21index249"></A><A NAME="ch21index250"></A></P>
<A NAME="ch21note04"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Hybrid joins apply to inner joins only. Either of the other two join methods can be used for both inner and outer joins.</P></div><br>
<A NAME="ch21lev3sec4"></A><H5 class="docSection3Title">Star Join</H5>
<P class="docText">A final type of join provided by DB2 is the <span class="docEmphasis">star join</span>. The star join is a special join technique used most often by analytical and data warehousing queries where the tables being joined use a star schema. A star schema is when one large fact table is related to many separate and smaller dimension tables. This is referred to as a star schema because a data model diagram of the tables resembles a star. More details on star schema are provided in <A class="docLink" HREF="ch45.html#ch45">Chapter 45</A>, "Data Warehousing with DB2."<A NAME="ch21index251"></A><A NAME="ch21index252"></A><A NAME="ch21index253"></A><A NAME="ch21index254"></A><A NAME="ch21index255"></A></P>
<P class="docText">Unlike the other DB2 join methods where only two tables are joined in each step, the star join can involve three or more tables per step. The fact table is always the last table in the star join step. For a star join to operate effectively there must be a well-defined, multi-column index on the fact table for each of the dimension table keys involved in the join.</P>
<P class="docText"><A class="docLink" HREF="#ch21fig21">Figure 21.21</A> depicts the basic flow of a star join. The steps involved in the star join are as follows:</P>
<A NAME="ch21pr05"></A>





<div style="font-weight:bold"><OL class="docList" START="1"><LI value="1"><div style="font-weight:normal">Filter and sort (if needed) data from the dimension tables participating in the star join.<BR><BR></div></LI><LI value="2"><div style="font-weight:normal">Create a sparse index consisting of just the required data from each of the dimension tables.<BR><BR></div></LI><LI value="3"><div style="font-weight:normal">Emulate building a Cartesian product using entries from the smaller dimension tables pointed to by the sparse index.<BR><BR></div></LI><LI value="4"><div style="font-weight:normal">Probe the fact table index once for every calculated combination of dimension table join values.<BR><BR></div></LI><LI value="5"><div style="font-weight:normal">Join the qualify fact table values with the qualifying dimension table values and place the result.<BR><BR></div></LI><LI value="6"><div style="font-weight:normal">Use sophisticated feedback loop technology to omit unnecessary fact table index probes.<BR><BR></div></LI></OL></div>
<A NAME="ch21fig21"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.21. Merge scan join. (Diagram provided courtesy of Sheryl M. Larsen, Inc.)</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/21fig21_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="478" SRC="images/0672326132/graphics/21fig21.gif" ALT="graphics/21fig21.gif"></p></CENTER></p><br>
<P class="docText">The following conditions must be met before DB2 can use the star join technique:</P>
<UL><LI><P class="docList">The subsystem must have been enabled for star join processing. This means that the value of the <TT>STARJOIN</TT> DSNZPARM must not be set to <TT>DISABLE</TT> (which is the default).</P></LI><LI><P class="docList">The number of tables in the query block must be at least 10. However, this value can be changed using the <TT>SJTABLES</TT> DSNZPARM parameter.</P></LI><LI><P class="docList">All join predicates must be between the fact table and the dimension tables, or within tables of the same dimension.</P></LI><LI><P class="docList">All join predicates between the fact and dimension tables must be equijoins.</P></LI><LI><P class="docList">The join predicates between the fact and dimension tables cannot use <TT>OR</TT>.</P></LI><LI><P class="docList">A local predicate on a dimension table cannot be combined using <TT>OR</TT> with a local predicate of another dimension table.</P></LI><LI><P class="docList">A single fact table column cannot be joined to columns of different dimension tables.</P></LI><LI><P class="docList">No correlated subqueries can be coded across dimensions.</P></LI><LI><P class="docList">The data type and length of both sides of a join predicate must be the same between the fact and dimension tables.</P></LI><LI><P class="docList">A dimension table cannot be a table function.</P></LI><LI><P class="docList">No outer join operations can exist between the fact and dimension tables.</P></LI></UL>
<P class="docText">If all of the criteria are met, the query qualifies for star join.<A NAME="ch21index256"></A><A NAME="ch21index257"></A><A NAME="ch21index258"></A><A NAME="ch21index259"></A><A NAME="ch21index260"></A></P>
<A NAME="ch21lev3sec5"></A><H5 class="docSection3Title">Join Method Comparison</H5>
<P class="docText">You might be wondering which join method DB2 uses in a given circumstance. Although there is no foolproof method to determine which method will be used for every circumstance, there are some general guidelines:<A NAME="ch21index261"></A><A NAME="ch21index262"></A><A NAME="ch21index263"></A><A NAME="ch21index264"></A></P>
<UL><LI><P class="docList">Merge scan joins are usually chosen when an appropriate index is unavailable on one of the tables. This involves sorting and can use a high amount of overhead.</P></LI><LI><P class="docList">Nested loop joins are very effective when an index exists on the inner table, thereby reducing the overhead of the repeated table scan.</P></LI><LI><P class="docList">The smaller of the two tables being joined is usually chosen as the outer table in a nested loop join. Actually, the size of the table is not as relevant as the amount of data that needs to be accessed. The fewer rows accessed from the outer table the more efficient the repeated inner table scan will be.</P></LI><LI><P class="docList">The hybrid join can be chosen only if an index exists on the inner table.</P></LI><LI><P class="docList">A star join is a viable solution when a very large table is joined to many other smaller tables.</P></LI><LI><P class="docList">Query parallelism can be combined with any of the join methods, enabling joins to be processed in parallel. More information on parallelism follows in the next section of this chapter.</P></LI></UL>
<P class="docText">Many shops are biased toward the nested loop join, feeling that nested loop joins almost always outperform merge scan joins. However, the performance of the merge scan join has been significantly enhanced over the life of DB2. Merge scan joins are a viable, production-quality join method.</P>
<P class="docText">See <A class="docLink" HREF="#ch21fig22">Figure 21.22</A> for an estimate of the performance of the join methods as a function of the number of qualifying rows being joined.</P>
<A NAME="ch21fig22"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.22. Relative join performance.</H5>
<p class="docText"><IMG BORDER="0" width="500" height="515" SRC="images/0672326132/graphics/21fig22.gif" ALT="graphics/21fig22.gif"></p></CENTER></p><br>
<P class="docText">In general, the guidelines are as follows:</P>
<UL><LI><P class="docList">The nested loop join is preferred in terms of execution cost when a small number of rows qualify for the join.</P></LI><LI><P class="docList">The nested loop join is preferred whenever the <TT>OPTIMIZE FOR </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS</TT> clause is used, regardless of the number of qualifying rows.</P></LI><LI><P class="docList">As the number of qualifying rows increases, the merge scan join becomes the preferred method.</P></LI><LI><P class="docList">Finally, for a small number of cases with a medium number of rows, the hybrid join is the best performer.</P></LI></UL>
<P class="docText">These generalizations are purposefully vague. The exact number of qualifying rows for these cut-offs depends on many influencing factors. These factors include, but are not limited to, the following:</P>
<UL><LI><P class="docList">Database design</P></LI><LI><P class="docList">Type of CPU</P></LI><LI><P class="docList">Type of DASD device</P></LI><LI><P class="docList">Use of DASD cache</P></LI><LI><P class="docList">Version of DB2</P></LI><LI><P class="docList">Data Sharing environment</P></LI><LI><P class="docList">Amount of memory and size of the buffer pools</P></LI><LI><P class="docList">Buffer pool tuning specifications</P></LI><LI><P class="docList">Availability of hardware (microcode) sorting</P></LI><LI><P class="docList">Compression settings and hardware-assisted compression availability</P></LI><LI><P class="docList">Uniqueness of the join columns</P></LI><LI><P class="docList">Cluster ratio<A NAME="ch21index265"></A><A NAME="ch21index266"></A><A NAME="ch21index267"></A><A NAME="ch21index268"></A></P></LI></UL>
<A NAME="ch21lev2sec9"></A><H4 class="docSection2Title">Query Parallelism</H4>
<P class="docText">Another technique that can be applied by the optimizer is <span class="docEmphasis">query parallelism</span>. When query parallelism is invoked, DB2 activates multiple parallel tasks to access the data. A separate subtask MVS SRB is initiated for each parallel task. Both partitioned and non-partitioned tablespaces can take advantage of query parallelism.<A NAME="ch21index269"></A><A NAME="ch21index270"></A><A NAME="ch21index271"></A><A NAME="ch21index272"></A><A NAME="ch21index273"></A></P>
<P class="docText">After determining the initial access path, the optimizer can be directed to perform an additional step to determine whether parallelism is appropriate. This access path formulated during this step is referred to as a <span class="docEmphasis">parallel plan</span>. The initial access path (pre-parallelism) is referred to as the <span class="docEmphasis">sequential plan</span>.<A NAME="ch21index274"></A><A NAME="ch21index275"></A><A NAME="ch21index276"></A><A NAME="ch21index277"></A><A NAME="ch21index278"></A><A NAME="ch21index279"></A><A NAME="ch21index280"></A><A NAME="ch21index281"></A></P>
<P class="docText">When processing in parallel, the elapsed time required to access the data can decrease because more activity occurs at the same time (see <A class="docLink" HREF="#ch21fig23">Figure 21.23</A>). Although the serial task takes fewer resources, it requires more elapsed, sequential time to complete than breaking the request up into multiple components that can be processed in parallel.</P>
<A NAME="ch21fig23"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.23. Parallel tasks reduce elapsed time.</H5>
<p class="docText"><IMG BORDER="0" width="500" height="434" SRC="images/0672326132/graphics/21fig23.gif" ALT="graphics/21fig23.gif"></p></CENTER></p><br>
<P class="docText">The optimizer will consider parallelism when you set the <TT>DEGREE</TT> parameter to <TT>ANY</TT>. This is done at <TT>BIND</TT> time for static SQL with the <TT>DEGREE(ANY)</TT> specification and at execution time for dynamic SQL with the <TT>CURRENT DEGREE</TT> special register. The default for degree is set using the <TT>CDSSRDEF</TT> DSNZPARM parameter. Of course, as always, it is best not to rely on defaults.</P>
<P class="docText">There are three types of query parallelism that DB2 can perform:</P>
<UL><LI><P class="docList">Query I/O parallelism</P></LI><LI><P class="docList">Query CP parallelism</P></LI><LI><P class="docList">Query Sysplex parallelism</P></LI></UL>
<P class="docText"><span class="docEmphasis">Query I/O parallelism</span> enables concurrent I/O streams to be initiated for a single query, as shown in <A class="docLink" HREF="#ch21fig24">Figure 21.24</A>. This can significantly enhance the performance of I/O bound queries. Breaking the data access for the query into concurrent I/O streams executed in parallel should reduce the overall elapsed time for the query. With query I/O parallelism, DB2 is limited to operating on a single processor for each query.<A NAME="ch21index282"></A><A NAME="ch21index283"></A><A NAME="ch21index284"></A></P>
<A NAME="ch21fig24"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.24. Query I/O parallelism.</H5>
<p class="docText"><IMG BORDER="0" width="500" height="336" SRC="images/0672326132/graphics/21fig24.gif" ALT="graphics/21fig24.gif"></p></CENTER></p><br>
<P class="docText"><span class="docEmphasis">Query CP parallelism</span> enables multitasking of I/O streams and CPU processing within a query (see <A class="docLink" HREF="#ch21fig25">Figure 21.25</A>). CP parallelism always uses I/O parallelism; it cannot be invoked separately. In query CP parallelism, a large query is decomposed into multiple smaller queries that can be executed concurrently with one another on multiple processors. Query CP parallelism should further reduce the elapsed time for a query.<A NAME="ch21index285"></A><A NAME="ch21index286"></A><A NAME="ch21index287"></A></P>
<A NAME="ch21fig25"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.25. Query CP parallelism.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/21fig25_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="417" SRC="images/0672326132/graphics/21fig25.gif" ALT="graphics/21fig25.gif"></p></CENTER></p><br>
<P class="docText"><span class="docEmphasis">Query Sysplex parallelism</span> further enhances parallel operations by enabling a single query to be broken up and run across multiple DB2 members of a data-sharing group (see <A class="docLink" HREF="#ch21fig26">Figure 21.26</A>). By allowing a single query to take advantage of the processing power of multiple DB2 subsystems, the overall elapsed time for a complex query can be significantly decreased.<A NAME="ch21index288"></A><A NAME="ch21index289"></A><A NAME="ch21index290"></A></P>
<A NAME="ch21fig26"></A><p><CENTER><H5 class="docFigureTitle">Figure 21.26. Query Sysplex parallelism.</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/21fig26_alt.gif">[View full size image]</a></div><IMG BORDER="0" width="500" height="356" SRC="images/0672326132/graphics/21fig26.gif" ALT="graphics/21fig26.gif"></p></CENTER></p><br>
<P class="docText">Although not specifically depicted in the figure, multiple DB2 subsystems in a data-sharing group can access the same physical partition when participating in a query Sysplex parallelism operation.</P>
<P class="docText">When parallelism is invoked, an access path can be broken up into parallel groups. Each parallel group represents a series of concurrent operations with the same degree of parallelism. <span class="docEmphasis">Degree of parallelism</span> refers to the number of concurrent tasks used to satisfy the query.<A NAME="ch21index291"></A><A NAME="ch21index292"></A></P>
<P class="docText"><A class="docLink" HREF="#ch21fig24">Figures 21.24</A> thru 21.26 show a tablespace scan accessing a tablespace with a degree of parallelism of 4. The degree of parallelism is determined by the optimizer based upon the estimated CPU and I/O cost using partition-level statistics stored in the <TT>SYSIBM.SYSCOLSTATS</TT> table.<A NAME="ch21index293"></A><A NAME="ch21index294"></A><A NAME="ch21index295"></A><A NAME="ch21index296"></A><A NAME="ch21index297"></A></P>
<P class="docText">DB2 can downgrade the degree of parallelism at runtime if host variables indicate that only a portion of the data is to be accessed or if sufficient buffer pool space is not available.</P>
<P class="docText">It is particularly important to note that DB2 might choose not to issue one parallel task per partition for partitioned tablespace access. Determination of the degree of parallelism is based upon the information in the DB2 Catalog, the number of partitions for the accessed tablespaces, system resources, and the nature of the query. Each parallel task can access the following:</P>
<UL><LI><P class="docList">An entire partition</P></LI><LI><P class="docList">A portion of a single partition</P></LI><LI><P class="docList">Multiple partitions</P></LI><LI><P class="docList">Portions of multiple partitions</P></LI></UL>
<P class="docText">Likewise, DB2 can horizontally partition data in a non-partitioned tablespace to benefit from query parallelism. Horizontal data partitioning is the process of creating range predicates for non-partitioned tablespaces to mimic partitioning. For example, horizontal data partitioning is performed to enable query parallelism to be maintained when data in a partitioned tablespace is being joined to data in a non-partitioned tablespace. DB2 will not horizontally partition a non-partitioned tablespace for single table access.</P>
<P class="docText">By processing queries in parallel, overall elapsed time should decrease significantly, even if CPU time increases. This is usually a satisfactory trade-off, resulting in an overall performance gain because the same amount of work is accomplished using less clock time. Additionally, the CPU usage can be spread out across multiple CPUs within the same central processor complex (CPC) or even across CPCs with data sharing and query Sysplex parallelism.</P>
<P class="docText">The best types of queries for parallel processing are I/O bound queries. The types of queries that stand to benefit most from query I/O parallelism are those that perform the following functions:</P>
<UL><LI><P class="docList">Access large amounts of data but return only a few rows.</P></LI><LI><P class="docList">Use column functions (<TT>AVG</TT>, <TT>COUNT</TT>, <TT>MIN</TT>, <TT>MAX</TT>, <TT>SUM</TT>).</P></LI><LI><P class="docList">Access long rows.</P></LI></UL>
<P class="docText">Query CP parallelism is most beneficial for scans of large partitioned tablespaces, and query Sysplex parallelism is most beneficial for complex queries that require a lot of processing power.<A NAME="ch21index298"></A><A NAME="ch21index299"></A><A NAME="ch21index300"></A><A NAME="ch21index301"></A><A NAME="ch21index302"></A></P>
<A NAME="ch21lev3sec6"></A><H5 class="docSection3Title">Query Sysplex Parallelism Terms and Issues</H5>
<P class="docText">The DB2 subsystem that originates the SQL query is referred to as the <span class="docEmphasis">parallelism coordinator</span>. A member that assists in the processing of a parallel query is called a <span class="docEmphasis">parallelism assistant</span>. Data must be returned to the parallelism coordinator from each parallelism assistant. This is accomplished in one of two ways. When work files are required (for example, for sorting), the parallelism coordinator can access the data directly from the work files. Otherwise, the cross-system coupling facility is used to return the data to the parallelism coordinator.<A NAME="ch21index303"></A><A NAME="ch21index304"></A><A NAME="ch21index305"></A><A NAME="ch21index306"></A><A NAME="ch21index307"></A><A NAME="ch21index308"></A><A NAME="ch21index309"></A><A NAME="ch21index310"></A><A NAME="ch21index311"></A><A NAME="ch21index312"></A><A NAME="ch21index313"></A><A NAME="ch21index314"></A></P>
<A NAME="ch21lev3sec7"></A><H5 class="docSection3Title">Restrictions on Query Parallelism Usage</H5>
<P class="docText">Note the following query parallelism restrictions:</P>
<UL><LI><P class="docList">For all types of query parallelism, a limited partition scan can be invoked for queries against a single table only.<A NAME="ch21index315"></A><A NAME="ch21index316"></A></P></LI><LI><P class="docList">Query Sysplex parallelism cannot be used with multiple index access, list prefetch, or queries using <TT>RR</TT> and <TT>RS</TT> isolation levels.</P></LI><LI><P class="docList">For cursors defined using the <TT>WITH HOLD</TT> clause, the only type of parallelism that can be deployed is query I/O parallelism.</P></LI><LI><P class="docList">Parallelism is for queries only; as such, only <TT>SELECT</TT> statements can benefit from parallelism. Furthermore, the <TT>SELECT</TT> statement must not be in an updateable or ambiguous cursor.</P></LI><LI><P class="docList">The <TT>CURRENTDATA(NO)</TT> bind parameter must be specified for parallelism to be invoked.</P></LI><LI><P class="docList">Parallelism cannot be used with multicolumn merge scan joins, type-N hybrid joins, materialized views, or materialized nested table expressions, and it cannot be used across <TT>UNION</TT> query blocks, when accessing a temporary table, or when <TT>EXISTS</TT> is specified.</P></LI></UL>
<A NAME="ch21note05"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">A type-N hybrid join retrieves the inner table RIDs using a clustered index (when <TT>SORTN_JOIN="N"</TT> in the <TT>PLAN_TABLE</TT>).<A NAME="ch21index317"></A><A NAME="ch21index318"></A></P></div><br>
<A NAME="ch21lev3sec8"></A><H5 class="docSection3Title">Parallel Joins</H5>
<P class="docText">Parallel I/O processing during a join can occur for both the outer and the inner table of a join, for only the outer table, or for only the inner table.<A NAME="ch21index319"></A><A NAME="ch21index320"></A><A NAME="ch21index321"></A><A NAME="ch21index322"></A></P>
<P class="docText">For any join method, the outer table can be separated into logical partitions. As is true with any query executed in parallel, the optimizer determines the degree of parallelism, which can be adjusted at runtime. The logical partitions are processed using multiple parallel I/O streams applying the outer table predicates.<A NAME="ch21index323"></A><A NAME="ch21index324"></A><A NAME="ch21index325"></A><A NAME="ch21index326"></A><A NAME="ch21index327"></A></P>
<P class="docText">Subsequent inner table processing is based on the type of join being performed.</P>
<A NAME="ch21lev4sec1"></A><H5 class="docSection4Title">Nested Loop Join and Parallelism</H5>
<P class="docText">To perform a nested loop join in parallel, the key ranges for the inner table logical partitions might need to be adjusted to match the logical partitioning of the outer table. This ensures that the number of logical partitions is equivalent for the outer and inner tables. Likewise, if the outer table was not processed using parallelism, the filtered outer table rows will need to be logically partitioned to match the inner table partitioning. In both cases, the logical partitioning is accomplished using the ESA sort assist. It is possible, however, that the outer table rows need not be sorted. In this case, the ESA sort assist will simply adjust the outer table key range to match the partitioning key range of the inner table.<A NAME="ch21index328"></A><A NAME="ch21index329"></A><A NAME="ch21index330"></A><A NAME="ch21index331"></A></P>
<P class="docText">Additionally, if the inner table is not partitioned, it can be horizontally partitioned to enable parallelism to continue. Alternatively, the inner table can be passed to the ESA sort assist, causing sort output to be partitioned to match outer table sort output.</P>
<P class="docText">Multiple parallel I/O streams are then used to join the filtered outer table rows to the inner table using the nested loop procedure described previously. The rows are returned in random order unless an additional sort is required for <TT>ORDER BY</TT>, <TT>GROUP BY</TT>, or <TT>DISTINCT</TT>.</P>
<A NAME="ch21lev4sec2"></A><H5 class="docSection4Title">Merge Scan Join and Parallelism</H5>
<P class="docText">To enable parallel merge scan joining, outer table rows are passed into the ESA sort assist, causing the sort output to be repartitioned to match the logical partitioning of the inner table. The outer table access could have been either parallel or non-parallel. A single column merge scan join is then executed using multiple parallel I/O streams. (Query I/O parallelism cannot sort all of the join columns for merge scan join.)<A NAME="ch21index332"></A><A NAME="ch21index333"></A><A NAME="ch21index334"></A><A NAME="ch21index335"></A></P>
<P class="docText">If the inner table is not partitioned, it can be horizontally partitioned to enable parallelism to continue.</P>
<P class="docText">The rows are returned in random order unless an additional sort is required for <TT>ORDER BY</TT>, <TT>GROUP BY</TT>, or <TT>DISTINCT</TT>.</P>
<A NAME="ch21lev4sec3"></A><H5 class="docSection4Title">Hybrid Join and Parallelism</H5>
<P class="docText">Hybrid join processing with query I/O parallelism also passes outer table rows to the ESA sort assist to logically repartition the output to match the logical partitioning of the inner table.<A NAME="ch21index336"></A><A NAME="ch21index337"></A><A NAME="ch21index338"></A><A NAME="ch21index339"></A></P>
<P class="docText">After the outer table results are repartitioned to match the logical partitioning of the inner table, hybrid join processing is executed using parallel I/O streams. The rows are returned in page number order unless an additional sort is required for <TT>ORDER BY</TT>, <TT>GROUP BY</TT>, or <TT>DISTINCT</TT>.</P>
<P class="docText">For parallelism to be invoked on the inner table, a highly clustered index must exist on the join columns. If such an index does not exist, the sort of the RID list and intermediate table will prevent parallel access to the inner table.<A NAME="ch21index340"></A><A NAME="ch21index341"></A><A NAME="ch21index342"></A><A NAME="ch21index343"></A></P>
<A NAME="ch21lev3sec9"></A><H5 class="docSection3Title">Parallel Join Notes</H5>
<P class="docText">In any case, remember that during join processing, parallel access can occur as follows:<A NAME="ch21index344"></A><A NAME="ch21index345"></A><A NAME="ch21index346"></A><A NAME="ch21index347"></A></P>
<UL><LI><P class="docList">On just the inner table</P></LI><LI><P class="docList">On just the outer table</P></LI><LI><P class="docList">On both the inner and outer tables</P></LI><LI><P class="docList">On neither the inner nor outer tables<A NAME="ch21index348"></A><A NAME="ch21index349"></A><A NAME="ch21index350"></A><A NAME="ch21index351"></A><A NAME="ch21index352"></A></P></LI></UL>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch21lev1sec3.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch21lev1sec5.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
