<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Tuning the z/OS and OS/390 Environment</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch27.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch27lev1sec2.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch27lev1sec1"></A><H3 class="docSection1Title">Tuning the z/OS and OS/390 Environment</H3>
<P class="docText">Operating system tuning is a complex task best accomplished by extensively trained technicians. All DB2 users, however, should understand the basics of z/OS resource exploitation and the avenues for tuning it. Operating system tuning, as it affects DB2 performance, can be broken down into four areas:<A NAME="ch27index01"></A><A NAME="ch27index02"></A><A NAME="ch27index03"></A><A NAME="ch27index04"></A></P>
<UL><LI><P class="docList">Memory use</P></LI><LI><P class="docList">CPU use</P></LI><LI><P class="docList">I/O use</P></LI><LI><P class="docList">Operating system environment parameters</P></LI></UL>
<P class="docText">Now turn your attention to each of these four areas. The sections that follow offer various tuning guidelines and strategies along the way.</P>
<A NAME="ch27lev2sec1"></A><H4 class="docSection2Title">Tuning Memory Use</H4>
<P class="docText">How does DB2 utilize available memory? Before answering this question, you need a basic understanding of what memory is and how it is used by z/OS. <span class="docEmphasis">Memory</span> is the working storage available for programs and the data the programs use as they operate.<A NAME="ch27index05"></A><A NAME="ch27index06"></A><A NAME="ch27index07"></A></P>
<P class="docText"><span class="docEmphasis">Storage</span> is often used as a synonym for memory. MVS stands for Multiple Virtual Storage, which refers to MVS's capability to manage virtual memory. To manage virtual memory, the operating system uses a large pool of memory, known as <span class="docEmphasis">virtual storage</span>, to "back up" <span class="docEmphasis">real storage</span>. (Real storage is also called central storage. Virtual storage is also called expanded storage.)<A NAME="ch27index08"></A><A NAME="ch27index09"></A><A NAME="ch27index10"></A><A NAME="ch27index11"></A><A NAME="ch27index12"></A><A NAME="ch27index13"></A><A NAME="ch27index14"></A><A NAME="ch27index15"></A></P>
<P class="docText">Real storage is addressable. Programs and their data must be placed in real storage before they can run. Virtual memory management is the reason that multiple address spaces can execute concurrently, regardless of the physical memory they eventually use. This way, the system can process more jobs than can be held in real storage; information is swapped back and forth between virtual storage and real storage, a process known as <span class="docEmphasis">paging</span>.<A NAME="ch27index16"></A><A NAME="ch27index17"></A><A NAME="ch27index18"></A><A NAME="ch27index19"></A></P>
<P class="docText">You'll discover two types of paging. The first, moving data between virtual and real storage, is inexpensive in terms of resource consumption and occurs regularly. As more real storage is requested, a second type of paging can result. This type of paging consists of moving portions of memory to disk temporarily. This type is expensive and should be avoided.</P>
<A NAME="ch27sb01"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Consider using storage isolation to fence the DB2 address spaces. Doing so prevents DB2 from paging to disk. Storage isolation must be implemented by systems programmers.</P></TD></TR></TABLE></P><br>
<P class="docText">Virtual storage can be broken down further in two ways:</P>
<UL><LI><P class="docList">Common area versus private area</P></LI><LI><P class="docList">Above the line versus below the line</P></LI></UL>
<P class="docText">The <span class="docEmphasis">common area</span> is the portion of virtual storage addressable from any address space. The <span class="docEmphasis">private area</span> stores data that is addressable by only an individual address space. A common area and private area exist both above and below the line. But what does that mean?<A NAME="ch27index20"></A><A NAME="ch27index21"></A><A NAME="ch27index22"></A><A NAME="ch27index23"></A><A NAME="ch27index24"></A><A NAME="ch27index25"></A><A NAME="ch27index26"></A></P>
<P class="docText">Above and below the line refers to an imaginary line in virtual storage at the 16-megabyte level. Memory above the line is often called <span class="docEmphasis">extended storage</span>. In earlier versions of MVS, 16 megabytes was the upper limit for virtual and real storage addressability. New releases of MVS add addressability above the 16-megabyte line. And z/OS provides addressability up to 16-exabytes. The constraints imposed by the addressing schemes of older systems, however, can cause dense packing of applications into memory below the line. Systems that use memory above the line provide more efficient memory management, as well as relief for systems requiring memory use below the line.<A NAME="ch27index27"></A><A NAME="ch27index28"></A><A NAME="ch27index29"></A></P>
<P class="docText">How does DB2 fit into this memory structure? The answer differs quite a bit depending on whether you are running DB2 V8 or a previous release. Let's discuss releases prior to V8 first (see <A class="docLink" HREF="#ch27fig01">Figure 27.1</A>). DB2 manages memory efficiently, making use of extended storage when possible. A well-tuned DB2 subsystem requires less than 2 megabytes of virtual storage below the line. The things that affect below-the-line storage are the <TT>DSMAX</TT> and number of threads using functions (like AMS) that still run below the 16M line.<A NAME="ch27index30"></A><A NAME="ch27index31"></A><A NAME="ch27index32"></A></P>
<A NAME="ch27fig01"></A><p><CENTER><H5 class="docFigureTitle">Figure 27.1. DB2 memory use (pre-V8).</H5>
<p class="docText"><div class="v1"><a target="_blank" href="images/0672326132/graphics/27fig01_alt.gif">[View full size image]</a></div><IMG BORDER="0"  width="500" height="571" SRC="images/0672326132/graphics/27fig01.gif" ALT="graphics/27fig01.gif"></p></CENTER></p><br>
<A NAME="ch27lev3sec1"></A><H5 class="docSection3Title">z/Architecture, DB2 V8, and 64 Bits</H5>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> One of the biggest impacts of DB2 V8 is the requirement to be running a zSeries machine and z/OS v1.3 or greater. DB2 V8 does not support old hardware, nor does it support OS/390. Owing to these architectural requirements, DB2 will have the ability to support large virtual memory. This means DB2 can now surmount the limitation of 2GB real storage that was imposed due to S/390's 31-bit addressing.<A NAME="ch27index33"></A><A NAME="ch27index34"></A><A NAME="ch27index35"></A><A NAME="ch27index36"></A></P></td></tr></table><br>
<P class="docText">Moving from a 31-bit architecture of past operating systems to a 64-bit architecture allows DB2 to access much more virtual storage. Using z/OS, DB2 can deploy a single large address space of up to 16 exabytes (2<SUP>64</SUP> bytes). This architecture replaces both hiperspaces and data spaces. Virtual storage management is improved because it is all in one place and simpler—thereby improving the scalability, availability, and performance of your DB2 subsystems.<A NAME="ch27index37"></A><A NAME="ch27index38"></A><A NAME="ch27index39"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> Another by-product of this additional storage is that IBM has moved many of DB2's storage areas above the 2GB bar. Refer to <A class="docLink" HREF="#ch27fig02">Figure 27.2</A> for an updated look at memory usage by DB2 V8. As of V8, most of the DB2 code now runs above the 2-gigabyte bar. Most of the DSNDBM1 address space, the log manager, parts of DDF, buffer pools, data sharing castout buffers, IRLM locks, the RID pool, sort pools, compression dictionaries, and DBD and OBD objects in the EDM pool have all been moved above the bar.</P></td></tr></table><br>
<A NAME="ch27fig02"></A><p><CENTER><H5 class="docFigureTitle">Figure 27.2. DB2 V8 memory use.</H5>
<p class="docText"><IMG BORDER="0"  width="450" height="492" SRC="images/0672326132/graphics/27fig02.gif" ALT="graphics/27fig02.gif"></p></CENTER></p><br>
<A NAME="ch27lev3sec2"></A><H5 class="docSection3Title">A Rundown of DB2's Memory Structures</H5>
<P class="docText">Let's examine the primary consumers of memory in a DB2 subsystem and see how we might be able to tune them for better performance.</P>
<A NAME="ch27lev4sec1"></A><H5 class="docSection4Title">Buffer Pools</H5>
<P class="docText">DB2 provides 80 virtual buffer pools and optional hiperpools (pre-V8) for maintaining recently accessed table and index pages in virtual storage. The Buffer Manager component of DB2 manages I/O and the use of buffers to reduce the cost of I/O. If the Buffer Manager can satisfy a <TT>GETPAGE</TT> request from memory in the buffer pool rather than from disk, performance can increase significantly.<A NAME="ch27index40"></A><A NAME="ch27index41"></A><A NAME="ch27index42"></A></P>
<P class="docText">DB2 provides buffer pools as follows:</P>
<UL><LI><P class="docList">50 buffer pools for 4KB pages (named BP0 through BP49)</P></LI><LI><P class="docList">10 buffer pools for 8KB pages (named BP8K0 through BP8K9)</P></LI><LI><P class="docList">10 buffer pools for 16KB pages (named BP16K0 through BP16K9)</P></LI><LI><P class="docList">10 buffer pools for 32KB pages (named BP32K and BP32K1 through BP32K9)</P></LI></UL>
<P class="docText">The size of a buffer pool is specified to DB2 in pages. As of DB2 V8, the maximum total buffer pool size is 1 terabyte.</P>
<P class="docText">Tuning DB2 buffer pools is a critical piece of overall DB2 subsystem tuning. Strategies for effective buffer pool tuning are presented in <A class="docLink" HREF="ch28.html#ch28">Chapter 28</A>, "Tuning DB2's Components," in the section on DB2 subsystem tuning.</P>
<P class="docText">In addition to the buffer pools, DB2 creates a RID pool and a sort pool.<A NAME="ch27index43"></A><A NAME="ch27index44"></A><A NAME="ch27index45"></A></P>
<A NAME="ch27lev4sec2"></A><H5 class="docSection4Title">Sort Pool</H5>
<P class="docText">RIDs processed during the execution of list prefetch are stored in the RID pool. Remember that hybrid joins and multiple-index access paths use list prefetch. The RID pool should be increased as your application's use of list prefetch and multiple-index access paths increase.<A NAME="ch27index46"></A><A NAME="ch27index47"></A><A NAME="ch27index48"></A></P>
<P class="docText">The size of the RID pool can be explicitly specified using the <TT>MAXRBLK</TT> DSNZPARM parameter. The RID pool can range in size from 128K to 10 GB. The default is 8000K. Of course, you can set the RID pool to 0 too, which has the effect of disabling the RID pool, causing DB2 to avoid access paths and join methods that require RID pool storage.</P>
<A NAME="ch27note01"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Do not set the RID pool to 0. It is almost always better to allow DB2 to determine when it makes sense to use the RID pool for accessing data than to arbitrarily disable the RID pool.</P></div><br>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> As of DB2 V8, 25% of the RID pool is located below the 2-GB bar and 75% is located above the 2-GB bar.<A NAME="ch27index49"></A><A NAME="ch27index50"></A><A NAME="ch27index51"></A></P></td></tr></table><br>
<A NAME="ch27lev4sec3"></A><H5 class="docSection4Title">Sort Pool</H5>
<P class="docText">The sort pool, sometimes called a <span class="docEmphasis">sort work area,</span> is used when DB2 invokes a sort. Before I discuss the sort pool, examine the DB2 sorting process, which is shown in <A class="docLink" HREF="#ch27fig03">Figure 27.3</A>. The RDS (Relational Data Services) component of DB2 uses a tournament sort technique to perform internal DB2 sorting.<A NAME="ch27index52"></A><A NAME="ch27index53"></A><A NAME="ch27index54"></A></P>
<A NAME="ch27fig03"></A><p><CENTER><H5 class="docFigureTitle">Figure 27.3. How DB2 sorts.</H5>
<p class="docText"><IMG BORDER="0"  width="500" height="539" SRC="images/0672326132/graphics/27fig03.gif" ALT="graphics/27fig03.gif"></p></CENTER></p><br>
<P class="docText">The tournament sort works as follows:</P>
<UL><LI><P class="docList">Rows to be sorted are passed through a tree structure like the one in <A class="docLink" HREF="#ch27fig03">Figure 27.3</A>. A row enters the tree at the bottom. It is compared to rows already in the tree, and the lowest values (for ascending sequence) or the highest values (for descending sequence) are moved up the tree.</P></LI><LI><P class="docList">When a row emerges from the top of the tree, it is usually placed in an ordered set of rows in memory. Sometimes, however, a value emerges from the top of the tree but does not fit into the current ordered set because it is out of range.</P></LI><LI><P class="docList">When a row does not fit into the current ordered set, the complete ordered set of rows is written to a logical work file. This ordered set is then called a <span class="docEmphasis">run</span>.</P></LI><LI><P class="docList">Logical work files are located in the buffer pool. As logical work files grow, sometimes they are written to physical work files. DB2 uses the <TT>DSNDB07</TT> database to store physical work files.</P></LI><LI><P class="docList">After all the rows have passed through the tree, the accumulated runs are merged, forming a sorted results set. This set is returned to the requester, completely sorted.</P></LI></UL>
<P class="docText">How, then, does the sort pool affect RDS sorting? As the sort pool becomes larger, so does the tree used for the tournament sort. As the tree becomes larger, fewer runs are produced. As fewer runs are produced, less data must be merged and the likelihood of using <TT>DSNDB07</TT> diminishes. The result is a more efficient sort process.</P>
<P class="docText">You can use the following formula to estimate an efficient sort pool for each process:</P>
<pre>

</pre><BR><pre>
32000 * (12 + sort key length + sort data length + 4)
</pre><BR>
<P class="docText">Of course, each process will have a different optimal sort pool size because the length of the sort key and the length of the data to be sorted will vary.</P>
<P class="docText">Each concurrent sort operation is assigned a sort pool. The sort work area can range in size from a minimum of 240K to a maximum of 128 MB. The size of the sort pool can be explicitly specified using the <TT>SRTPOOL</TT> DSNZPARM parameter. If the sort pool is not explicitly specified, its default value is 2000K.<A NAME="ch27index55"></A><A NAME="ch27index56"></A><A NAME="ch27index57"></A></P>
<A NAME="ch27sb02"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">As with all DB2 parameters, it is better to explicitly specify RID and sort pool sizes to allow them to default.</P></TD></TR></TABLE></P><br>
<A NAME="ch27lev4sec4"></A><H5 class="docSection4Title">EDM Pool</H5>
<P class="docText">The EDM pool is used to maintain DBDs, cursor tables (for plans), package tables, the authorization cache, and the dynamic statement cache needed by executing SQL statements. The size of the EDM pool is specified in the DSNZPARMs and must be determined before starting DB2. To estimate the size of the EDM pool, you must have the following information:<A NAME="ch27index58"></A><A NAME="ch27index59"></A><A NAME="ch27index60"></A></P>
<UL><LI><P class="docList">The maximum number of concurrently executing plans and packages</P></LI><LI><P class="docList">The average plan and package size</P></LI><LI><P class="docList">The average cache size for plans</P></LI><LI><P class="docList">The number of concurrently accessed DBDs</P></LI><LI><P class="docList">The average DBD size</P></LI></UL>
<P class="docText">For new DB2 subsystems, letting the DB2 installation process use default values to calculate the size of the EDM pool is best. For existing DB2 subsystems, you can arrive at the average plan and package sizes by issuing the following SQL queries. For the average plan size, use this query:<A NAME="ch27index61"></A><A NAME="ch27index62"></A><A NAME="ch27index63"></A><A NAME="ch27index64"></A></P>
<pre>

</pre><BR><pre>
SELECT   AVG(PLSIZE)
FROM     SYSIBM.SYSPLAN
</pre><BR>
<P class="docText">For the average package size, use this query:<A NAME="ch27index65"></A><A NAME="ch27index66"></A><A NAME="ch27index67"></A><A NAME="ch27index68"></A></P>
<pre>

</pre><BR><pre>
SELECT   AVG(PKSIZE)
FROM     SYSIBM.SYSPACKAGE
</pre><BR>
<P class="docText">Add the two averages and divide by 2 to arrive at the total average plan and package size.</P>
<A NAME="ch27sb03"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Binding with the <TT>ACQUIRE(USE)</TT> option results in smaller plan sizes than binding with <TT>ACQUIRE(ALLOCATE)</TT>. Additional code is stored with the plan for <TT>ACQUIRE(ALLOCATE)</TT>. To reduce the amount of storage used by plans and packages in the EDM pool, specify <TT>ACQUIRE(USE)</TT> at bind time.</P>
<P class="docText">However, plan size usually should not be the determining factor for the specification of the <TT>ACQUIRE</TT> parameter. Instead, follow the guidelines presented in <A class="docLink" HREF="ch13.html#ch13">Chapter 13</A>, "Program Preparation."<A NAME="ch27index69"></A><A NAME="ch27index70"></A></P></TD></TR></TABLE></P><br>
<P class="docText">Another factor influencing the overall size of plans is the authorization cache. You can associate an authid cache for each plan by setting the size in the <TT>CACHESIZE</TT> parameter of the <TT>BIND</TT> command.<A NAME="ch27index71"></A><A NAME="ch27index72"></A><A NAME="ch27index73"></A><A NAME="ch27index74"></A><A NAME="ch27index75"></A><A NAME="ch27index76"></A></P>
<A NAME="ch27sb04"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Binding with the <TT>CACHESIZE(0)</TT> option also results in smaller plan sizes. However, the caching of authids enhances performance. So, once again, plan size should not be the determining factor in setting <TT>CACHESIZE</TT> either. The default cache size is 1024KB, which is probably overkill for many shops. Use the formula specified in <A class="docLink" HREF="ch13.html#ch13">Chapter 13</A> to calculate an appropriate <TT>CACHESIZE</TT> for each plan—instead of relying on the default.<A NAME="ch27index77"></A><A NAME="ch27index78"></A><A NAME="ch27index79"></A><A NAME="ch27index80"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch27note02"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Authids are not checked for plans that can be executed by <TT>PUBLIC</TT>. Avoid specifying a <TT>CACHESIZE</TT> for these plans.</P></div><br>
<P class="docText">For the average size of the plan authorization ID cache, use the following query:<A NAME="ch27index81"></A><A NAME="ch27index82"></A><A NAME="ch27index83"></A><A NAME="ch27index84"></A><A NAME="ch27index85"></A></P>
<pre>

</pre><BR><pre>
SELECT   AVG(CACHESIZE)
FROM     SYSIBM.SYSPLAN;
</pre><BR>
<P class="docText">Package authorization caching is a system-wide option. Caching is either enabled or disabled for the entire subsystem and a global cache is used. Therefore, package authorization caching does not have an impact on package size.<A NAME="ch27index86"></A><A NAME="ch27index87"></A><A NAME="ch27index88"></A><A NAME="ch27index89"></A><A NAME="ch27index90"></A></P>
<P class="docText">To arrive at the average DBD size, you must know the average number of columns per table and the average number of tables per database. A general formula for calculating the average DBD size follows:</P>
<pre>

</pre><BR><pre>
average DBD size = [(average # of tables per database) x 1K]
                 + [(average # of columns per table) x .5K]
</pre><BR>
<P class="docText">You can use the following queries to arrive at the average number of tables per database and the average number of columns per table. First, to determine the average number of tables per database, issue the following query:<A NAME="ch27index91"></A><A NAME="ch27index92"></A><A NAME="ch27index93"></A><A NAME="ch27index94"></A><A NAME="ch27index95"></A><A NAME="ch27index96"></A><A NAME="ch27index97"></A></P>
<pre>

</pre><BR><pre>
SELECT   COUNT(*) / COUNT(DISTINCT(DBNAME))
FROM     SYSIBM.SYSTABLES
WHERE    TYPE = 'T';
</pre><BR>
<P class="docText">You can use the following query to arrive at the average number of columns per table:<A NAME="ch27index98"></A><A NAME="ch27index99"></A><A NAME="ch27index100"></A><A NAME="ch27index101"></A></P>
<pre>

</pre><BR><pre>
SELECT   AVG(COLCOUNT)
FROM     SYSIBM.SYSTABLES
WHERE    TYPE = 'T';
</pre><BR>
<P class="docText">To arrive at the average number of concurrent plans, packages, and DBDs, you would be wise to accumulate a series of DB2 accounting statistics for your peak processing time. Use these figures to estimate the number of concurrent plans.<A NAME="ch27index102"></A><A NAME="ch27index103"></A><A NAME="ch27index104"></A><A NAME="ch27index105"></A></P>
<P class="docText">Determining the average number of concurrent packages is not easy. You must completely understand your particular DB2 implementation to be successful at determining this number. Asking the following questions can help:<A NAME="ch27index106"></A><A NAME="ch27index107"></A><A NAME="ch27index108"></A><A NAME="ch27index109"></A></P>
<UL><LI><P class="docList">How many plans use packages instead of simply DBRMs? Issue the following two queries to determine this information:</P><pre>

</pre><BR><pre>
SELECT   COUNT(DISTINCT PLANNAME)
FROM     SYSIBM.SYSPACKLIST;

SELECT   COUNT(*)
FROM     SYSIBM.SYSPLAN
WHERE    OPERATIVE = 'Y'
AND      VALID IN('Y','A');
</pre><BR></LI><LI><P class="docList">On average, how many versions of a package are permitted to remain in the DB2 Catalog? How many are used?</P></LI></UL>
<P class="docText">To determine the average number of concurrent DBDs, you must understand each application's database use. If an application that typically uses three databases is much more active than another that uses 12 databases, you must factor this information into your EDM pool sizing strategy. Obtaining this information can be difficult, so you might need to estimate. A general calculation for the EDM pool size follows:<A NAME="ch27index110"></A><A NAME="ch27index111"></A><A NAME="ch27index112"></A></P>
<pre>

</pre><BR><pre>
EDM Pool Size = [(((#CPP) + (#TPP/4)) x PP-AVG) +
                 (((#CPP) + (#TPP/4)) x C-AVG)  +
                 ((#DBD) x DBD-AVG) + 50K] x 1.25
</pre><BR>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="groups" CELLPADDING="5"><COLGROUP><COL width="165"><COL width="385"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Value</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Description</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>#CPP</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of concurrent plans and packages</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>#TPP</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Total number of plans and packages</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>#DBD</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Total number of concurrently used databases</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PP-AVG</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Average size of all plans and packages</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>C-AVG</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Average authorization cache size</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DBD-AVG</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Average authorization cache size</P></TD></TR></TABLE></P><br>
<P class="docText">The systems programmer calculates the size of the EDM pool during DB2 installation based on estimates of the values discussed in this section. The installation process for DB2 contains the preceding algorithm. The calculation used by the DB2 installation process is only as good as the information supplied to it. The default values (calculated by DB2 during the installation process) are adequate for most shops if correct estimates were input.</P>
<P class="docText">As DB2 use expands, however, the EDM pool should expand proportionally. The size of the EDM pool can be explicitly specified using the <TT>EDMPOOL</TT> DSNZPARM parameter.</P>
<P class="docText">As your DB2 usage patterns change, plan and package sizes can grow, necessitating EDM pool growth. For example, using <TT>DEGREE(ANY)</TT> instead of <TT>DEGREE(1)</TT> increases plan and package sizes.<A NAME="ch27index113"></A><A NAME="ch27index114"></A><A NAME="ch27index115"></A></P>
<A NAME="ch27sb05"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Overestimate the size of the EDM pool. Having EDM pool memory available as the number of DB2 plans, packages, and databases increases can be better than reacting to a problem after it occurs. Periodically monitor the number of plans, packages, and databases in conjunction with usage statistics, and increase the EDM pool as your DB2 use increases.<A NAME="ch27index116"></A><A NAME="ch27index117"></A><A NAME="ch27index118"></A></P></TD></TR></TABLE></P><br>
<P class="docText">Additionally, as more applications are made operational, or as more concurrent users start to access existing applications, EDM pool usage will increase.</P>
<A NAME="ch27sb06"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Prior to DB2 V8, if your <TT>DSNDBM1</TT> is storage-constrained you can move some of the EDM pool into a data space. This is particularly helpful if you use dynamic statement caching. You can move some EDM storage into a data space by specifying a non-zero value for <TT>EDMPOOL DATA SPACE SIZE</TT> on the DSNTIPC installation panel.<A NAME="ch27index119"></A><A NAME="ch27index120"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> As of DB2 V8, this option is not available because data spaces are no longer supported. Of course, more memory is available due to z/OS and the ability of the EDM pool to utilize space above the 2GB bar.</P></td></tr></table><br></TD></TR></TABLE></P><br>
<A NAME="ch27sb07"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> Because cached dynamic statements are stored in a separate pool in DB2 V8, re-evaluate your EDM pool storage needs. You might be able to decrease the size of the EDM pool after you move to DB2 V8.<A NAME="ch27index121"></A><A NAME="ch27index122"></A><A NAME="ch27index123"></A></P></td></tr></table><br></TD></TR></TABLE></P><br>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> DB2 V8 separates the EDM pool into separate storage areas as follows:<A NAME="ch27index124"></A><A NAME="ch27index125"></A></P></td></tr></table><br>
<BLOCKQUOTE><P><P class="docList">The main <span class="docEmphBoldItalic">EDM pool</span> for managing CTs and PTs in use, SKCTs and SKPTs for the most frequently used applications, and cache blocks for your plans that have caches.</P></P><P><P class="docList">The <span class="docEmphBoldItalic">EDM DBD cache</span> for the DBDs in use and DBDs referred to by the SKCTs and SKPTs for the most frequently used applications.</P></P><P><P class="docList">The <span class="docEmphBoldItalic">EDM statement cache</span> for the skeletons of the most frequently used dynamic SQL statements, if your system has enabled the dynamic statement cache.<A NAME="ch27index126"></A><A NAME="ch27index127"></A><A NAME="ch27index128"></A></P></P></BLOCKQUOTE>
<A NAME="ch27lev4sec5"></A><H5 class="docSection4Title">DB2 Working Storage</H5>
<P class="docText">DB2 working storage is memory used by DB2 as a temporary work area. The best way to estimate the working storage size for DB2 is to separate the number of concurrent DB2 users into users of dynamic SQL and users of static SQL. Dynamic SQL uses more working storage (but possibly less of the EDM pool) than static SQL. Estimate approximately 25KB per static SQL user and 75KB per dynamic SQL user. Additionally, DB2 itself uses about 600K. Therefore, you can estimate DB2 working storage usage by using the following:<A NAME="ch27index129"></A><A NAME="ch27index130"></A><A NAME="ch27index131"></A></P>
<pre>

</pre><BR><pre>
(concurrent static SQL users x 25K) +
(concurrent dynamic SQL users x 75K) + 600K
</pre><BR>
<A NAME="ch27sb08"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">You cannot explicitly tune the amount of memory used by concurrent static and dynamic SQL. Implicit control over the number of users can be established by the DSNZPARM values specified for <TT>IDFORE</TT>, <TT>IDBACK</TT>, and <TT>CTHREAD</TT>.</P></TD></TR></TABLE></P><br>
<A NAME="ch27lev4sec6"></A><H5 class="docSection4Title">DB2 Code</H5>
<P class="docText">The DB2 code itself requires approximately 4,300KB of storage. This value is inflexible.<A NAME="ch27index132"></A><A NAME="ch27index133"></A><A NAME="ch27index134"></A></P>
<A NAME="ch27lev4sec7"></A><H5 class="docSection4Title">IRLM</H5>
<P class="docText">Locks are maintained in memory by the IRLM. This capability enables DB2 to process a lock request quickly and efficiently without a physical read.<A NAME="ch27index135"></A><A NAME="ch27index136"></A><A NAME="ch27index137"></A></P>
<A NAME="ch27sb09"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">If the IRLM start-up parameters specify <TT>PC=Y</TT>, the locks are stored in the private address space for the IRLM. <TT>PC=N</TT> stores the locks in expanded memory, so this specification is more efficient than <TT>PC=Y</TT>.<A NAME="ch27index138"></A><A NAME="ch27index139"></A><A NAME="ch27index140"></A></P>
<P class="docText">As of DB2 V8 all locks are stored in the private address space for the IRLM. As such, this option is not available as of V8.</P></TD></TR></TABLE></P><br>
<P class="docText">The IRLM uses approximately 250 bytes per lock. This number is constant whether you are using row locks or page locks, so keep that in mind if you are considering row-level locking. You will likely consume much more storage with row locking because DB2 will probably have to lock more rows than it would pages (depending on the number of rows per page for the table space).<A NAME="ch27index141"></A><A NAME="ch27index142"></A><A NAME="ch27index143"></A></P>
<A NAME="ch27lev4sec8"></A><H5 class="docSection4Title">Open Data Sets</H5>
<P class="docText">Each open VSAM data set requires approximately 1.8KB for the VSAM control block that is created. Refer to <A class="docLink" HREF="ch05.html#ch05">Chapter 5</A>, "Data Definition Guidelines," for a discussion of the <TT>CLOSE</TT> parameter for DB2 table spaces and indexes and its effect on performance.<A NAME="ch27index144"></A><A NAME="ch27index145"></A><A NAME="ch27index146"></A><A NAME="ch27index147"></A></P>
<A NAME="ch27sb10"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Use segmented table spaces with multiple tables to reduce the amount of memory used by open data sets. When each table is assigned to a unique table space, DB2 must manage more open data sets—one for each table space and table combination. As the number of tables in a table space increases, DB2 must manage fewer open data sets. (All considerations for multi-table table spaces, as outlined in <A class="docLink" HREF="ch05.html#ch05">Chapter 5</A>, still apply.)<A NAME="ch27index148"></A><A NAME="ch27index149"></A><A NAME="ch27index150"></A><A NAME="ch27index151"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch27sb11"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">The memory cost per open data set, approximately 1.8K, is small in comparison to the performance gains associated with leaving the data sets open to avoid VSAM open and close operations. Favor using <TT>CLOSE YES</TT> for most of your table spaces and indexes. Doing so leaves data sets open until the maximum number of open data sets is reached. At this point, DB2 chooses the least recently used data sets to close. You might want to consider specifying <TT>CLOSE NO</TT> for your most critical objects so that other objects are closed before your most critical objects.<A NAME="ch27index152"></A><A NAME="ch27index153"></A><A NAME="ch27index154"></A><A NAME="ch27index155"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch27lev4sec9"></A><H5 class="docSection4Title">Total Memory Requirements</H5>
<P class="docText">By adding the memory requirements, as specified in the preceding sections, for the EDM pool, buffer pools, RID pool, sort pool, working storage, open data sets, and IRLM for each DB2 subsystem, you can estimate the memory resources required for DB2. If insufficient memory is available, consider limiting the availability of DB2 until more memory can be procured.<A NAME="ch27index156"></A><A NAME="ch27index157"></A><A NAME="ch27index158"></A></P>
<A NAME="ch27sb12"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">DB2 uses virtual and real storage. DB2's performance increases as you assign more memory. If you intend to have very large DB2 applications, do not be stingy with memory.</P></TD></TR></TABLE></P><br>
<A NAME="ch27lev2sec2"></A><H4 class="docSection2Title">Tuning CPU Use</H4>
<P class="docText">Tuning CPU use is a factor in reducing DB2 resource consumption and providing an efficient environment. The major factors affecting CPU cost are as follow:<A NAME="ch27index159"></A><A NAME="ch27index160"></A><A NAME="ch27index161"></A></P>
<UL><LI><P class="docList">Amount and type of I/O</P></LI><LI><P class="docList">Number of <TT>GETPAGE</TT> requests</P></LI><LI><P class="docList">Number of columns selected in the SQL statement</P></LI><LI><P class="docList">Number of predicates applied per SQL statement</P></LI></UL>
<P class="docText">The following paragraphs offer additional information about each of these factors, including suggested tuning strategies.</P>
<P class="docText">By reducing physical I/O requests, you decrease CPU consumption. Similarly, the use of sequential prefetch can decrease CPU cost because more data is returned per physical I/O.</P>
<A NAME="ch27sb13"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Encourage the use of sequential prefetch when every (or almost every) row in a table will be accessed. You can do so by coding <TT>SELECT</TT> statements without predicates, by coding <TT>SELECT</TT> statements with minimal predicates on columns that are not indexed, or sometimes, by specifying a large number in the <TT>OPTIMIZE</TT> clause (for example, <TT>OPTIMIZE FOR 1000000 ROWS</TT>). Because the <TT>OPTIMIZE FOR </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS</TT> clause was originally designed to reduce the estimated number of rows to be retrieved (not to increase that number), this trick does not always work.<A NAME="ch27index162"></A><A NAME="ch27index163"></A></P></TD></TR></TABLE></P><br>
<P class="docText">Each <TT>GETPAGE</TT> request causes the Data Manager to request a page from the Buffer Manager, which causes additional CPU use.<A NAME="ch27index164"></A><A NAME="ch27index165"></A><A NAME="ch27index166"></A></P>
<A NAME="ch27sb14"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">If possible, serialize data requests in static applications so that requests for the same piece of data are not duplicated. If a program requires the same data more than once, try to arrange the processes that act on that data to be contiguous, such that a single I/O is required instead of multiple I/Os. For example, if an employee's department number is required in three separate parts of a transaction, select the information once and save it for the other two times.<A NAME="ch27index167"></A><A NAME="ch27index168"></A></P></TD></TR></TABLE></P><br>
<P class="docText">As the number of selected columns increases, DB2 must do more work to manipulate these columns, thereby using excess CPU.<A NAME="ch27index169"></A><A NAME="ch27index170"></A><A NAME="ch27index171"></A></P>
<A NAME="ch27sb15"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Code each <TT>SELECT</TT> statement (even ad hoc SQL) to return only columns that are absolutely needed.</P></TD></TR></TABLE></P><br>
<P class="docText">As your number of predicates increases, DB2 must do more work to evaluate the predicates and ensure that the data returned satisfies the requirements of the predicates.<A NAME="ch27index172"></A><A NAME="ch27index173"></A><A NAME="ch27index174"></A></P>
<A NAME="ch27sb16"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Avoid coding redundant predicates. Use your knowledge of the application data in coding SQL. For example, if you know that employees must have an <TT>EDLEVEL</TT> of <TT>14</TT> or higher to hold the title of <TT>MANAGER</TT>, use this knowledge when you're writing SQL statements. The <TT>EDLEVEL</TT> predicate in the following query should not be coded because it is redundant, given the preceding qualification:<A NAME="ch27index175"></A><A NAME="ch27index176"></A></P>
<pre>

</pre><BR><pre>
SELECT   EMPNO, LASTNAME
FROM     DSN8610.EMP
WHERE    JOB = 'MANAGER'
AND      EDLEVEL &gt;= 14;
</pre><BR>
<P class="docText">Document the removal of redundant predicates in case policy changes. For example, if managers can have an education level of <TT>10</TT>, the <TT>EDLEVEL</TT> predicate is no longer redundant and must be added to the query again. Because tracking this information can be difficult, you should avoid removing predicates that are currently redundant but that might not always be so.<A NAME="ch27index177"></A><A NAME="ch27index178"></A><A NAME="ch27index179"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch27lev2sec3"></A><H4 class="docSection2Title">Tuning I/O</H4>
<P class="docText">I/O is probably the single most critical factor in the overall performance of your DB2 subsystem and applications. This factor is due to the physical nature of I/O: it is limited by hardware speed. The mechanical functionality of a storage device is slower and more prone to breakdown than the rapid, chip-based technologies of CPU and memory. For this reason, paying attention to the details of tuning the I/O characteristics of your environment is wise.<A NAME="ch27index180"></A><A NAME="ch27index181"></A><A NAME="ch27index182"></A></P>
<P class="docText">What is I/O? Simply stated, I/O is a transfer of data by the CPU from one medium to another. <span class="docEmphasis">I</span> stands for input, or the process of receiving data from a physical storage medium. <span class="docEmphasis">O</span> stands for output, which is the process of moving data to a physical storage device. In every case, an I/O involves moving data from one area to another.<A NAME="ch27index183"></A><A NAME="ch27index184"></A></P>
<P class="docText">In the strictest sense of the term, an I/O can be a movement of data from the buffer pool to a working storage area used by your program. This type, however, is a trivial I/O with a lower cost than an I/O requiring disk access, which is the type of I/O you must minimize and tune.</P>
<P class="docText">The best way to minimize the cost of I/O is to use very large buffer pools. This way, you can increase the possibility that any requested page is already in memory, thereby tuning I/O by sometimes eliminating it. In general, I/O decreases as the size of the buffer pools increases. This method, however, has drawbacks. Buffer pools should be backed up with real and virtual memory, but your shop might not have extra memory to give DB2. Also, DB2 basically takes whatever memory you give it and almost always can use more.<A NAME="ch27index185"></A><A NAME="ch27index186"></A></P>
<A NAME="ch27note03"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Of course, another way to minimize the cost of I/O is to utilize faster hardware. IBM's Enterprise Storage System (ESS), sometimes referred to as SHARK, can process data requests faster than older disk storage devices (such as 3380 or 3390 DASD units). The majority of improvements in ESS performance come from improvements to the bus architecture, higher parallelism, improved disk interconnection technology, and increased ESCON channel attachments.</P></div><br>
<P class="docText">Even with large buffer pools, data must be read from the disk storage device at some point to place it in the buffer pools. Tuning I/O, therefore, is wise.</P>
<P class="docText">The number of all reads and writes makes up the I/O workload incurred for any single resource. Therefore, the cost of I/O depends on the disk device, the number of pages retrieved per I/O, and the type of write operation.</P>
<P class="docText">The characteristics of the disk device that contains the data being read include the speed of the device, the number of data sets on the device, the proximity of the device to the device controller, and concurrent access to the device. You can improve performance by moving DB2 data sets to disk devices with faster retrieval rates. Consider the following estimates for retrieving a single page from different types of devices:<A NAME="ch27index187"></A><A NAME="ch27index188"></A><A NAME="ch27index189"></A></P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="groups" CELLPADDING="5"><COLGROUP><COL width="170.5"><COL width="379.5"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Device</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Retrieval Cost</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">3380</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">.020 to .028 seconds per page</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">3390</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">.015 to .020 seconds per page</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Solid State</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">.004 to .006 seconds per page</P></TD></TR></TABLE></P><br>
<P class="docText">Obviously, a solid-state device offers better performance because it lacks the mechanical aspects of 3380 and 3390 DASD units.</P>
<P class="docText">The second factor affecting I/O cost is the number of pages retrieved per I/O. As I indicated in the preceding section, sequential prefetch can increase the number of pages read per I/O. Sequential prefetch also functions as a read-ahead engine. Reads are performed in the background, before they are needed and while other useful work is being accomplished. This way, I/O wait time can be significantly reduced.</P>
<P class="docText">Refer to the following average response times. (Note that all times are approximate.) A single page being read by sequential prefetch can be two to four times more efficient than a single page read by synchronous I/O.<A NAME="ch27index190"></A><A NAME="ch27index191"></A><A NAME="ch27index192"></A></P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="groups" CELLPADDING="5"><COLGROUP><COL width="104.5"><COL width="154"><COL width="159.5"><COL width="132"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><span class="docEmphStrong">Device</span></P></TH><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><span class="docEmphStrong">Sequential Prefetch</span></P></TH><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><span class="docEmphStrong">Sequential Prefetch (per page)</span></P></TH><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><span class="docEmphStrong">Synchronous Read</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">3380</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">80ms</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">2.5ms</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">25ms</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">3390</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">40ms</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">1.5ms</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">10ms</P></TD></TR></TABLE></P><br>
<P class="docText">Better response times can be achieved with modern storage devices. In a document titled "DB2 for OS/390 Performance on IBM Enterprise Storage Server," IBM has published a prefetch rate of 11.8 MB/second with ESS and 5.8 MB/second with RAMAC-3.<A NAME="ch27index193"></A><A NAME="ch27index194"></A><A NAME="ch27index195"></A></P>
<P class="docText">The third factor in I/O cost is the type of write operation: asynchronous versus synchronous. DB2 can not only read data in the background but also write data in the background. In most cases, DB2 does not physically externalize a data modification to disk immediately following the successful completion of the SQL <TT>DELETE</TT>, <TT>INSERT</TT>, or <TT>UPDATE</TT> statement. Instead, the modification is externalized to the log. Only when the modified page is removed from DB2's buffers is it written to disk. This process is called an asynchronous, or deferred, write. Synchronous writes, on the other hand, are immediately written to disk. DB2 tries to avoid them, and it should. If you ensure that sufficient buffers are available, synchronous writes can be avoided almost entirely.<A NAME="ch27index196"></A><A NAME="ch27index197"></A><A NAME="ch27index198"></A></P>
<P class="docText">Several types of I/O must be tuned. They can be categorized into the following five groups:</P>
<BLOCKQUOTE><P><P class="docList">Application I/O</P></P><P><P class="docList">Internal I/O</P></P><P><P class="docList">Sort I/O</P></P><P><P class="docList">Log I/O</P></P><P><P class="docList">Paging I/O</P></P></BLOCKQUOTE>
<P class="docText">In the sections that follow, you will examine each of these types of I/O.<A NAME="ch27index199"></A><A NAME="ch27index200"></A><A NAME="ch27index201"></A></P>
<A NAME="ch27lev3sec3"></A><H5 class="docSection3Title">Application I/O</H5>
<P class="docText">Application I/O is incurred to retrieve and update application data. As DB2 applications execute, they read and modify data stored in DB2 tables. This process requires I/O.<A NAME="ch27index202"></A><A NAME="ch27index203"></A><A NAME="ch27index204"></A><A NAME="ch27index205"></A><A NAME="ch27index206"></A></P>
<P class="docText">You can apply the following strategies to tune all five types of I/O covered here, not just application I/O. They are of primary importance, however, for application I/O.</P>
<A NAME="ch27sb17"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Tune I/O by increasing the size of the buffer pools. With larger buffer pools, application data can remain in the buffer pool longer. When data is in the buffer pool, it can be accessed quickly by the application without issuing a physical I/O.</P></TD></TR></TABLE></P><br>
<A NAME="ch27sb18"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Tune I/O speed by using the fastest disk drives available. For example, replace older 3380 devices with newer, faster 3390 devices, RAMAC, or ESS. Most applications require multiple I/Os as they execute. For each I/O, you can save from 15ms to 40ms with 3390s instead of 3380s. The performance gains can be tremendous for applications requiring thousands (or even millions) of I/Os.</P></TD></TR></TABLE></P><br>
<A NAME="ch27sb19"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">For non-SMS users only: Use proper data set placement strategies to reduce disk head contention. To do so, follow these basic rules:</P>
<UL><LI><P class="docList">Avoid placing a table's indexes on the same disk device as the table space used for the table.<A NAME="ch27index207"></A><A NAME="ch27index208"></A><A NAME="ch27index209"></A><A NAME="ch27index210"></A><A NAME="ch27index211"></A></P></LI><LI><P class="docList">Analyze the access pattern for each application. When tables are frequently accessed together, consider placing them on separate devices to minimize contention.</P></LI><LI><P class="docList">Limit shared disk. Putting multiple, heavily accessed data sets from different applications on the same device is unwise. Cross-application contention can occur, causing head movement, undue contention, and I/O waits. Be cautious not only of high-use DB2 tables sharing a single volume, but also of mixing DB2 tables with highly accessed VSAM, QSAM, and other data sets.</P></LI><LI><P class="docList">Place the most heavily accessed table spaces and indexes closest to the disk controller unit. The closer a disk device is on the string to the actual controller, the higher its priority will be. The performance gain from this placement is minimal (especially for 3390 devices), but consider this option when you must squeeze out every last bit of performance.</P></LI><LI><P class="docList">Avoid having table space and index data sets in multiple extents. When the data set consists of more than a single extent, excess head movement can result, reducing the efficiency of I/O.</P></LI><LI><P class="docList">
<IMG BORDER="0"  width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"> Use the data-partitioned secondary indexes to explicitly partition secondary indexes to match partitioned table spaces and distribute the DPSI and table space partitions over multiple devices.</P></LI><LI><P class="docList">Use the <TT>PIECESIZE</TT> parameter to explicitly distribute non-partitioned table spaces and indexes over multiple devices.<A NAME="ch27index212"></A><A NAME="ch27index213"></A><A NAME="ch27index214"></A><A NAME="ch27index215"></A><A NAME="ch27index216"></A></P></LI><LI><P class="docList">Favor allocation of data sets in cylinders.</P></LI></UL></TD></TR></TABLE></P><br>
<P class="docText">Another factor impacting the efficiency of accessing DB2 application data is partitioning. When data is partitioned, it is more likely that DB2 can utilize query parallelism to read data.</P>
<A NAME="ch27sb20"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Consider partitioning simple and segmented table spaces to take advantage of DB2's parallel I/O capabilities. Although partitioning is not required, partitioning can help to encourage DB2 to use parallelism.</P></TD></TR></TABLE></P><br>
<A NAME="ch27lev3sec4"></A><H5 class="docSection3Title">Internal I/O</H5>
<P class="docText">DB2 requires internal I/Os as it operates. Different types of data must be read and updated by DB2 as applications, utilities, and commands execute. This type of I/O occurs during the following:<A NAME="ch27index217"></A><A NAME="ch27index218"></A><A NAME="ch27index219"></A><A NAME="ch27index220"></A><A NAME="ch27index221"></A></P>
<UL><LI><P class="docList">Recording utility execution information in the DB2 Directory</P></LI><LI><P class="docList">Updating the DB2 Catalog as a result of DCL, DDL, or utility executions</P></LI><LI><P class="docList">Reading the DB2 Catalog and DB2 Directory when certain DB2 commands (for example, <TT>-DISPLAY DATABASE</TT>) are issued</P></LI><LI><P class="docList">Retrieving skeleton cursor tables, skeleton plan tables, and DBDs from the DB2 Directory to enable programs to execute</P></LI><LI><P class="docList">Retrieving data from the DB2 Catalog during <TT>BIND</TT>, <TT>REBIND</TT>, and dynamic SQL use</P></LI><LI><P class="docList">Miscellaneous DB2 Catalog I/O for plans marked as <TT>VALIDATE(RUN)</TT> and for other runtime needs</P></LI><LI><P class="docList">Reading the Resource Limit Specification Table</P></LI></UL>
<A NAME="ch27sb21"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Limit activities that incur internal I/O during heavy DB2 application activity. This way, you can reduce the possibility of application timeouts due to the unavailability of internal DB2 resources resulting from contention.<A NAME="ch27index222"></A><A NAME="ch27index223"></A><A NAME="ch27index224"></A><A NAME="ch27index225"></A><A NAME="ch27index226"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch27sb22"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">To enhance the performance of I/O to the DB2 Catalog, consider placing the DB2 Catalog on a solid-state device that uses memory chips rather than mechanical disk. Although solid-state devices are often expensive, they can reduce I/O cost significantly. A power outage, however, can cause the DB2 Catalog to be unavailable or damaged. For many shops, this risk might be too great to take. You can find additional tuning strategies for the DB2 Catalog and DB2 Directory in <A class="docLink" HREF="ch28.html#ch28">Chapter 28</A>, "Tuning DB2's Components."<A NAME="ch27index227"></A><A NAME="ch27index228"></A><A NAME="ch27index229"></A><A NAME="ch27index230"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch27lev3sec5"></A><H5 class="docSection3Title">Sort I/O</H5>
<P class="docText">Sorting can cause an I/O burden on the DB2 subsystem. To sort very large sets of rows, DB2 sometimes uses physical work files in the <TT>DSNDB07</TT> database to store intermediate sort results. <TT>DSNDB07</TT> consists of table spaces stored on disk. The use of disk-based work files for sorting can dramatically affect performance.<A NAME="ch27index231"></A><A NAME="ch27index232"></A><A NAME="ch27index233"></A><A NAME="ch27index234"></A><A NAME="ch27index235"></A></P>
<A NAME="ch27sb23"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Consider placing <TT>DSNDB07</TT> on a solid-state device when applications in your DB2 subsystem require large sorts of many rows or the sorting of a moderate number of very large rows.</P></TD></TR></TABLE></P><br>
<A NAME="ch27sb24"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Tune <TT>DSNDB07</TT> because you will probably use it eventually. Be sure that multiple table spaces are defined for <TT>DSNDB07</TT> and that they are placed on separate disk devices. Furthermore, ensure that the underlying VSAM data sets for the <TT>DSNDB07</TT> table spaces are not using multiple extents.</P></TD></TR></TABLE></P><br>
<A NAME="ch27sb25"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">If the cost of sorting is causing a bottleneck at your shop, ensure that you are using the following sorting enhancements:</P>
<UL><LI><P class="docList">The microcode sort feature can improve the cost of sorting by as much as 50%. Microcode is very efficient software embedded in the architecture of the operating system. The microcode sort can be used only by DB2 V2.3 and higher and only when DB2 is run on one of the following CPU models: ES/9000 Model 190 and above, ES/3090-9000T, and ES/3090 Models 180J, 200J, 280J, and above.</P></LI><LI><P class="docList">Provide for unlimited logical work files based on the size of the buffer pool. This capability can significantly reduce I/O because more sort data can be contained in memory rather than written out to <TT>DSNDB07</TT>.</P></LI><LI><P class="docList">Define <TT>DSNDB07</TT> in a separate buffer pool and tune it accordingly for sorting. Keep in mind that although most sort operations are sequential, sorting also requires some random processing.<A NAME="ch27index236"></A><A NAME="ch27index237"></A><A NAME="ch27index238"></A><A NAME="ch27index239"></A><A NAME="ch27index240"></A></P></LI></UL></TD></TR></TABLE></P><br>
<A NAME="ch27sb26"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Be sure to create <TT>DSNDB07</TT> work files appropriately. Define multiple work files of equal size. You should consider allowing these files to go into extents, as well. Secondary extents allow runaway queries to complete. If you would rather have a runaway query fail than have it acquire the storage for sort work files using extents, define the work files without the ability to take extents. If you allow extents, define them on all work files, not just the last one.<A NAME="ch27index241"></A><A NAME="ch27index242"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch27lev3sec6"></A><H5 class="docSection3Title">Log I/O</H5>
<P class="docText">Log I/O occurs when changes are made to DB2 data. Log records are written to DB2's active log data sets for each row that is updated, deleted, or inserted. Every modification (with the exception of <TT>REORG LOG NO</TT> and <TT>LOAD LOG NO</TT>) is logged by DB2 to enable data recovery. In addition, when you run the <TT>RECOVER</TT> utility to restore or recover DB2 table spaces, an active log data set (and sometimes multiple archive log data sets) must be read.<A NAME="ch27index243"></A><A NAME="ch27index244"></A><A NAME="ch27index245"></A><A NAME="ch27index246"></A><A NAME="ch27index247"></A><A NAME="ch27index248"></A></P>
<P class="docText">For these reasons, optimal placement of DB2 log data sets on disk is critical.</P>
<A NAME="ch27sb27"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Put your log data sets on your fastest disk devices. For example, a shop using 3380 and 3390 devices should place log data sets on 3390 disk volumes with the DASD fast write feature. DASD fast write is a caching technique that significantly enhances the speed of I/O for DB2 log data sets.<A NAME="ch27index249"></A><A NAME="ch27index250"></A><A NAME="ch27index251"></A><A NAME="ch27index252"></A><A NAME="ch27index253"></A><A NAME="ch27index254"></A></P>
<P class="docText">The two types of DB2 log data sets are active logs and archive logs. As the active log data sets are filled, DB2 invokes a process called <span class="docEmphasis">log offloading</span> to move information from the active logs to the archive logs. Log offloading can have a severe impact on the throughput of a DB2 subsystem.</P></TD></TR></TABLE></P><br>
<A NAME="ch27sb28"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Ensure that your log data sets are on different volumes and on separate channels. Avoid placing more than one active log data set on the same disk volume. Otherwise, the whole reason for having dual active logs is negated and the overall performance of DB2 will be impaired significantly during the log offloading process.<A NAME="ch27index255"></A><A NAME="ch27index256"></A><A NAME="ch27index257"></A><A NAME="ch27index258"></A><A NAME="ch27index259"></A><A NAME="ch27index260"></A></P></TD></TR></TABLE></P><br>
<P class="docText">Optimal utilization of tapes and tape drives is critical for an efficient DB2 log offloading process. Recall from <A class="docLink" HREF="ch23.html#ch23">Chapter 23</A>, "Locking DB2 Data," that log offloading is the process of writing entries from the active log to the archive log.<A NAME="ch27index261"></A><A NAME="ch27index262"></A><A NAME="ch27index263"></A><A NAME="ch27index264"></A><A NAME="ch27index265"></A><A NAME="ch27index266"></A></P>
<A NAME="ch27sb29"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Consider making the active log the same size as a full cartridge. When the log is offloaded, the archive will utilize a full cartridge, resulting in fewer wasted tapes.<A NAME="ch27index267"></A><A NAME="ch27index268"></A></P>
<P class="docText">Of course, if you use disk archives then there is no reason to impose a size limit.</P></TD></TR></TABLE></P><br>
<A NAME="ch27lev3sec7"></A><H5 class="docSection3Title">Paging I/O</H5>
<P class="docText">Paging I/Os occur when memory is over-utilized and pages of storage are relocated temporarily to disk. When needed, they will be read from disk back into main storage. This process causes very high overhead.<A NAME="ch27index269"></A><A NAME="ch27index270"></A><A NAME="ch27index271"></A><A NAME="ch27index272"></A><A NAME="ch27index273"></A></P>
<A NAME="ch27sb30"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Avoid paging by fencing the DB2 address spaces as suggested in the section titled "<A class="docLink" HREF="#ch27lev2sec1">Tuning Memory Use</A>" at the beginning of this chapter.</P></TD></TR></TABLE></P><br>
<A NAME="ch27sb31"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Increase the amount of real and virtual storage for your CPU. When you increase the amount of memory at the system's disposal, paging is less frequent.<A NAME="ch27index274"></A><A NAME="ch27index275"></A><A NAME="ch27index276"></A><A NAME="ch27index277"></A><A NAME="ch27index278"></A></P>
<P class="docText">In addition to the tuning of I/O at the data set level, you must monitor and tune I/O at the disk device level. The overall performance of I/O depends on the efficiency of each disk volume to which DB2 data sets have been allocated.</P></TD></TR></TABLE></P><br>
<A NAME="ch27sb32"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Consistently monitor each disk volume to ensure that contention is minimal. You can do so with a third-party tool designed to report on the usage characteristics of disk devices. In general, if device contention for any disk volume is greater than 30%, an I/O problem exists. Each shop should analyze its disk usage patterns, reducing contention as much as possible given the shop's budgetary constraints. When contention is high, however, consider moving some data sets on the device to other, less active volumes.<A NAME="ch27index279"></A><A NAME="ch27index280"></A></P></TD></TR></TABLE></P><br>
<P class="docText">Some disk devices offer hardware caching as an option for all data sets stored on the device. In these cases, the actual disk drive can be used to cache data reads. These features are not usually effective for reading DB2 data.<A NAME="ch27index281"></A><A NAME="ch27index282"></A><A NAME="ch27index283"></A><A NAME="ch27index284"></A><A NAME="ch27index285"></A></P>
<A NAME="ch27sb33"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Avoid caching for disk volumes containing DB2 application table space and index data sets. The benefits of caching are greatly reduced for most DB2 application processing because of the efficient, asynchronous manner in which DB2 can read data (using sequential prefetch) and write data (using deferred write).<A NAME="ch27index286"></A><A NAME="ch27index287"></A><A NAME="ch27index288"></A><A NAME="ch27index289"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch27lev3sec8"></A><H5 class="docSection3Title">RAMAC Devices</H5>
<P class="docText">Some of the conventional wisdom regarding data set placement and I/O changes with RAMAC storage devices. A device is not a physical volume, it is a virtual volume that is spread across multiple physical volumes on the RAMAC. For this reason, arm movement is not a concern.<A NAME="ch27index290"></A><A NAME="ch27index291"></A><A NAME="ch27index292"></A><A NAME="ch27index293"></A><A NAME="ch27index294"></A></P>
<P class="docText">With RAMAC, it is possible that you could place data sets on separate volumes only to have RAMAC place them on the same physical volume. For this reason, consider using SMS to place the data, and use DFDSS to move data sets when contention occurs.</P>
<A NAME="ch27lev2sec4"></A><H4 class="docSection2Title">Tuning Various z/OS Parameters and Options</H4>
<P class="docText">Because z/OS is a complex operating system, it can be difficult to comprehend. In this section, I discuss—in easy-to-understand language—some environmental tuning options for z/OS.<A NAME="ch27index295"></A><A NAME="ch27index296"></A><A NAME="ch27index297"></A></P>
<P class="docText">The z/OS environment is driven by the Systems Resource Manager (SRM). The SRM functions are based on parameters coded by systems programmers in the <TT>SYS1.PARMLIB</TT> library. Three members of this data set are responsible for defining most performance-oriented parameters for MVS: <TT>OPT</TT>, <TT>IPS</TT>, and <TT>ICS</TT>. You can tune the items discussed in this chapter by modifying these members. However, I do not discuss how to set these parameters in this book.<A NAME="ch27index298"></A><A NAME="ch27index299"></A><A NAME="ch27index300"></A><A NAME="ch27index301"></A></P>
<P class="docText">You should not take this type of tuning lightly. z/OS tuning is complex, and a change made to benefit DB2 might affect another z/OS subsystem. All DB2 personnel in your shop (including management, database administration, and DB2, IMS, CICS, and z/OS systems programming) should discuss these types of tuning options before implementing them. Only a trained systems programmer should make these types of changes.</P>
<P class="docText">The first item to consider is whether a job is swappable. A <span class="docEmphasis">swappable</span> job can be temporarily swapped out of the system by MVS. When a job is swapped out, it is not processed. It therefore is not using CPU, cannot request I/O, and generally is dormant until it is swapped back into the system. Almost all of your jobs should be swappable so that MVS can perform as it was designed—maximizing the number of jobs that can be processed concurrently with a minimum of resources.<A NAME="ch27index302"></A><A NAME="ch27index303"></A></P>
<P class="docText">Because the DB2 address spaces, however, are non-swappable, DB2 itself is never swapped out. Therefore, a DB2 application program requesting DB2 functions never has to wait for DB2 because it has been swapped out. The following list outlines which components of your overall environment can be swappable:<A NAME="ch27index304"></A><A NAME="ch27index305"></A><A NAME="ch27index306"></A><A NAME="ch27index307"></A></P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5"><COLGROUP><COL width="187"><COL width="363"></COLGROUP><THEAD></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">DB2</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Non-swappable</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">CICS</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Swappable or non-swappable</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">IMS</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Non-swappable</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">TSO</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Swappable</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">QMF</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Swappable</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText">Application</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Swappable</P></TD></TR></TABLE></P><br>
<A NAME="ch27sb34"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">When a CICS subsystem is being used to access DB2, it should be defined as non-swappable to enhance response time (and thereby increase the performance) of the DB2/CICS transactions.</P></TD></TR></TABLE></P><br>
<P class="docText">Usually, an application address space is swapped out so that z/OS can maintain even control over the processing environment. z/OS might determine that a job should be swapped out for the following reasons:</P>
<UL><LI><P class="docList">Too many jobs are running concurrently for all of them to be swapped in simultaneously. The maximum number of address spaces that can be simultaneously swapped in is controlled by the SRM based on parameters and the workload.</P></LI><LI><P class="docList">Another job needs to execute.</P></LI><LI><P class="docList">A shortage of memory.</P></LI><LI><P class="docList">Terminal wait. A TSO user might be staring at the screen, thinking about what to do next. Online TSO application programs do not need to be swapped in until the user takes another action.<A NAME="ch27index308"></A><A NAME="ch27index309"></A><A NAME="ch27index310"></A></P></LI></UL>
<P class="docText">The <span class="docEmphasis">dispatching priority</span> of an address space is a means of controlling the rate at which the address space can consume resources. A higher dispatching priority for an address space translates into faster performance because resources are more readily available to jobs with higher dispatching priorities. Controlling the dispatching priorities of jobs is an important tuning technique.<A NAME="ch27index311"></A><A NAME="ch27index312"></A><A NAME="ch27index313"></A></P>
<P class="docText">Normally, SRM controls the dispatching priority. Your shop may be using the Workload Manager (WLM) to control priorities. Systems programmers assign the dispatching priority of different address spaces. To ensure optimal DB2 performance, arrange the dispatching priorities of your DB2-related address spaces as shown in <A class="docLink" HREF="#ch27fig04">Figure 27.4</A>. Batch application address spaces are generally dispatched below TSO (Long). Some critical batch jobs could be dispatched higher than TSO (Long).</P>
<A NAME="ch27fig04"></A><p><CENTER><H5 class="docFigureTitle">Figure 27.4. Dispatching priority hierarchy.</H5><A NAME="ch27index314"></A><A NAME="ch27index315"></A>
<p class="docText"><IMG BORDER="0"  width="500" height="581" SRC="images/0672326132/graphics/27fig04.gif" ALT="graphics/27fig04.gif"></p></CENTER></p><br>
<A NAME="ch27sb35"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Increasing the dispatching priority of batch DB2 application jobs that are critical or long-running increases their performance. However, this increase is at the expense of other jobs running with lower dispatching priorities. Tinkering with the dispatching priorities of application jobs is not a good practice unless it is an emergency. The dispatching priority of an address space can be changed "on–the-fly," but only by authorized personnel.<A NAME="ch27index316"></A><A NAME="ch27index317"></A><A NAME="ch27index318"></A></P></TD></TR></TABLE></P><br>
<P class="docText">When you're planning for a high amount of batch activity, ensure that an adequate number of <span class="docEmphasis">initiators</span> is available for the batch jobs. Initiators are essentially servers, under the control of JES, that process jobs as they are queued. In determining whether initiators are available, take the following into account:<A NAME="ch27index319"></A><A NAME="ch27index320"></A><A NAME="ch27index321"></A><A NAME="ch27index322"></A><A NAME="ch27index323"></A></P>
<UL><LI><P class="docList">An initiator is assigned to a job class or classes, specified on the job card of your batch JCL. If an initiator is not assigned to the job class that your DB2 jobs will be using, that initiator will not be used.</P></LI><LI><P class="docList">The number of initiators available for DB2 job classes dictates the number of DB2 batch jobs that can run concurrently from an MVS perspective. The <TT>IDBACK</TT>DSNZPARM parameter determines the number of background DB2 jobs that can be run concurrently from a DB2 perspective.</P><A NAME="ch27sb36"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Synchronize the value of <TT>IDBACK</TT> to the number of initiators for the DB2 job classes at your site. If non-DB2 jobs can be run in DB2 job classes, or if the initiator is available also for non-DB2 job classes, the value of <TT>IDBACK</TT> should be less than the total number of initiators assigned to DB2 job classes.</P></TD></TR></TABLE></P><br></LI><LI><P class="docList">Jobs are removed from the job queue for execution by an initiator in order of their selection priority. Selection priority is coded on the job card of your JCL (<TT>PRTY</TT>). Most shops disable the <TT>PRTY</TT> parameter and place strict controls on the selection priority of jobs and job classes.</P><P class="docList">Note that selection priority is different from dispatching priority. <span class="docEmphasis">Selection priority</span> controls the order in which jobs are queued for processing. <span class="docEmphasis">Dispatching priority</span> controls the resources available to a job after it is executing.<A NAME="ch27index324"></A></P></LI></UL>
<A NAME="ch27sb37"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Where initiators are at a premium (for example, fewer initiators than concurrent jobs), ensure that the DB2 jobs with the highest priority are assigned a higher selection priority than other DB2 jobs. This way, you can ensure that DB2 jobs are processed in order from most critical to least critical by the system.</P></TD></TR></TABLE></P><br>
<P class="docText">Operating system tuning is an important facet of DB2 tuning. After the z/OS environment has been tuned properly, it should operate smoothly with little intervention (from DB2's perspective). Getting to the optimal z/OS environment, however, can be an arduous task.<A NAME="ch27index325"></A><A NAME="ch27index326"></A><A NAME="ch27index327"></A></P>
<P class="docText">Tuning z/OS is only one component of DB2 environment tuning. Tuning the teleprocessing environment, discussed next, is vital in achieving proper online performance.</P>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch27.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch27lev1sec2.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
