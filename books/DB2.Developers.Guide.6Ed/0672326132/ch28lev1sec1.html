<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Tuning the DB2 Subsystem</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch28.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch28lev1sec2.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch28lev1sec1"></A><H3 class="docSection1Title">Tuning the DB2 Subsystem</H3>
<P class="docText">The first level of DB2 tuning to be discussed in this chapter is at the DB2 subsystem level. This type of tuning is generally performed by a DB2 systems programmer or database administrator. Several techniques can be used to tune DB2 itself. These techniques can be broken down into three basic categories:</P>
<UL><LI><P class="docList">DB2 Catalog tuning techniques</P></LI><LI><P class="docList">Tuning DB2 system parameters</P></LI><LI><P class="docList">Tuning the IRLM</P></LI></UL>
<P class="docText">Each of these tuning methods is covered in the following sections.</P>
<A NAME="ch28lev2sec1"></A><H4 class="docSection2Title">Tuning the DB2 Catalog</H4>
<P class="docText">One of the major factors influencing overall DB2 subsystem performance is the physical condition of the DB2 Catalog and DB2 Directory tablespaces. These tablespaces are not like regular DB2 tablespaces.<A NAME="ch28index01"></A><A NAME="ch28index02"></A><A NAME="ch28index03"></A><A NAME="ch28index04"></A></P>
<A NAME="ch28sb01"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Ensure that the DB2 Catalog data sets are not in multiple extents. When a data set spans more than one extent, overhead accrues due to the additional I/O needed to move from extent to extent. To increase the size of DB2 Catalog data sets, you must invoke a DB2 Catalog recovery. This procedure is documented in <A class="docLink" HREF="ch06.html#ch06">Chapter 6</A> of the IBM <span class="docEmphasis">DB2 Administration Guide</span>.<A NAME="ch28index05"></A><A NAME="ch28index06"></A><A NAME="ch28index07"></A><A NAME="ch28index08"></A><A NAME="ch28index09"></A><A NAME="ch28index10"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch28sb02"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Institute procedures to analyze the organization of the DB2 Catalog and DB2 Directory tablespaces and indexes. You can use DB2 utilities to reorganize inefficient objects in the DB2 Catalog and DB2 Directory. In-depth information on reorganizing the DB2 Catalog is provided in <A class="docLink" HREF="app08.html#app08">Appendix H</A>.<A NAME="ch28index11"></A><A NAME="ch28index12"></A><A NAME="ch28index13"></A><A NAME="ch28index14"></A><A NAME="ch28index15"></A><A NAME="ch28index16"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch28sb03"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">It also is possible to issue the <TT>REBUILD INDEX</TT> utility on the DB2 Catalog indexes, which reads the table to rebuild the index, and thereby reorganizes the index, too. You can choose to rebuild the DB2 Catalog indexes when DB2 use grows.<A NAME="ch28index17"></A><A NAME="ch28index18"></A><A NAME="ch28index19"></A><A NAME="ch28index20"></A><A NAME="ch28index21"></A><A NAME="ch28index22"></A><A NAME="ch28index23"></A></P></TD></TR></TABLE></P><br>
<P class="docText">DB2 does not make use of indexes when it accesses the DB2 Catalog for internal use. For example, binding, DDL execution, and authorization checking do not use DB2 indexes. Instead, DB2 traverses pointers, or links, maintained in the DB2 Catalog. These pointers make internal access to the DB2 Catalog very efficient.<A NAME="ch28index24"></A><A NAME="ch28index25"></A><A NAME="ch28index26"></A></P>
<P class="docText">The DB2 Catalog indexes are used only by users issuing queries against DB2 Catalog tables. Whether these indexes are used or not is based on the optimization of the DB2 Catalog queries and whether the DB2 optimizer deems that they are beneficial.</P>
<A NAME="ch28sb04"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Execute <TT>RUNSTATS</TT> on the DB2 Catalog tablespaces and indexes. Without current statistics, DB2 cannot optimize DB2 Catalog queries. Additionally, <TT>RUNSTATS</TT> provides statistics enabling DBAs to determine when to reorganize the DB2 Catalog tablespaces.<A NAME="ch28index27"></A><A NAME="ch28index28"></A><A NAME="ch28index29"></A></P></TD></TR></TABLE></P><br>
<P class="docText">Although it is difficult to directly influence the efficiency of internal access to the DB2 Catalog and DB2 Directory, certain measures can be taken to eliminate obstructions to performance. For instance, follow proper data set placement procedures to reduce DASD head contention.<A NAME="ch28index30"></A><A NAME="ch28index31"></A><A NAME="ch28index32"></A><A NAME="ch28index33"></A><A NAME="ch28index34"></A><A NAME="ch28index35"></A><A NAME="ch28index36"></A></P>
<A NAME="ch28sb05"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Do not place other data sets on the volumes occupied by the DB2 Catalog and DB2 Directory data sets. Place the DB2 Catalog data sets on different volumes than the DB2 Directory data sets. Place DB2 Catalog tablespaces on different volumes than the indexes on the DB2 Catalog.<A NAME="ch28index37"></A><A NAME="ch28index38"></A><A NAME="ch28index39"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch28sb06"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">If you have additional DASD, consider separating the DB2 Catalog tablespaces by function, on distinct volumes.<A NAME="ch28index40"></A><A NAME="ch28index41"></A><A NAME="ch28index42"></A><A NAME="ch28index43"></A><A NAME="ch28index44"></A><A NAME="ch28index45"></A></P>
<P class="docText">On volume #1, place <TT>SYSPLAN</TT>, which is the tablespace used by application programs for binding plans.</P>
<P class="docText">On volume #2, place <TT>SYSPKAGE</TT>, which is the tablespace used by application programs for binding packages. Keep these tablespaces on separate volumes. Because plans can be composed of multiple packages, DB2 may read from <TT>SYSPKAGE</TT> and write to <TT>SYSPLAN</TT> when binding plans. Failure to separate these two tablespaces can result in head contention.</P>
<P class="docText">On volume #3, place <TT>SYSCOPY</TT>, which is the tablespace used by utilities. This enhances the performance of DB2 utilities.</P>
<P class="docText">On volume #4, place the remaining DB2 Catalog tablespaces. These tablespaces can coexist safely on a single volume because they are rarely accessed in a way that causes head contention. You might choose to separate system-related tablespaces from application-related tablespaces. For example, <TT>SYSSEQ</TT>, <TT>SYSSEQ2</TT>, <TT>SYSJAVA</TT>, <TT>SYSJAUXA</TT>, <TT>SYSJAUXB</TT>, and <TT>SYSGRTNS</TT> are more application-focused and could be placed on a separate device from the other, more system-focused DB2 Catalog tablespaces.</P></TD></TR></TABLE></P><br>
<P class="docText">The DB2 Catalog is central to most facets of DB2 processing. It records the existence of every object used by DB2. As such, it is often queried by DBAs, programmers, and ad hoc users. Large queries against the DB2 Catalog can cause performance degradation.<A NAME="ch28index46"></A><A NAME="ch28index47"></A><A NAME="ch28index48"></A><A NAME="ch28index49"></A></P>
<A NAME="ch28sb07"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Consider isolating the DB2 Catalog tablespaces and indexes in a single buffer pool. This buffer pool must be <TT>BP0</TT> because DB2 forces the catalog objects to be created in <TT>BP0</TT>. To isolate the system catalog objects in <TT>BP0</TT>, ensure that all other objects are created in other buffer pools (<TT>BP1</TT> through <TT>BP49</TT>, <TT>BP8K0</TT> through <TT>BP8K9</TT>, <TT>BP16K0</TT> through <TT>BP16K9</TT>, <TT>BP32K</TT>, and <TT>BP32K1</TT> through <TT>BP32K9</TT>).</P></TD></TR></TABLE></P><br>
<A NAME="ch28sb08"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Consider monitoring the SQL access to DB2 Catalog tables and creating additional indexes on tables that are heavily accessed by non-indexed columns.<A NAME="ch28index50"></A><A NAME="ch28index51"></A><A NAME="ch28index52"></A><A NAME="ch28index53"></A><A NAME="ch28index54"></A><A NAME="ch28index55"></A></P></TD></TR></TABLE></P><br>
<P class="docText">Additionally, many DB2 add-on tools access the DB2 Catalog as they execute, which can result in a bottleneck. Because the DB2 Catalog provides a centralized repository of information on all objects defined to DB2, it is natural for programmers, analysts, and managers to request access to the DB2 Catalog tables for queries. This can cause contention and reduce performance.<A NAME="ch28index56"></A><A NAME="ch28index57"></A><A NAME="ch28index58"></A><A NAME="ch28index59"></A><A NAME="ch28index60"></A><A NAME="ch28index61"></A><A NAME="ch28index62"></A></P>
<A NAME="ch28sb09"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Consider making a shadow copy of the DB2 Catalog for programmer queries and use by vendor tools. This reduces DB2 Catalog contention. If most external access to the DB2 Catalog is redirected to a shadow copy, internal access is much quicker. The shadow DB2 Catalog tables should never be allowed to get too outdated. Consider updating them weekly.<A NAME="ch28index63"></A><A NAME="ch28index64"></A><A NAME="ch28index65"></A><A NAME="ch28index66"></A><A NAME="ch28index67"></A><A NAME="ch28index68"></A></P>
<P class="docText">To implement this strategy, you must plan a period of inactivity during which the DB2 Catalog can be successfully copied to the shadow tables. Consider using <TT>ISOLATION(UR)</TT> when unloading the DB2 Catalog rows for movement to the shadow copy. For assistance with implementing this strategy, follow the guidelines presented in <A class="docLink" HREF="ch05.html#ch05">Chapter 5</A>, "Data Definition Guidelines," for denormalizing with shadow tables.</P></TD></TR></TABLE></P><br>
<A NAME="ch28sb10"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">If you don't use a shadow copy of the DB2 Catalog, consider limiting access to the production DB2 Catalog by allowing queries only through views. You can create views so that users or applications can see only their own data. Additionally, views joining several DB2 Catalog tables can be created to ensure that DB2 Catalog tables are joined in the most efficient manner.</P></TD></TR></TABLE></P><br>
<P class="docText">Finally, remember that when DB2 objects are created, DB2 must read and update several DB2 Catalog tables. This results in many locks on DB2 Catalog pages as the objects are being built. To reduce contention and the resultant timeouts and deadlocks, schedule all DDL during off-peak processing periods (for example, in the early morning after the batch cycle but before the first online use, or over the weekend).<A NAME="ch28index69"></A><A NAME="ch28index70"></A><A NAME="ch28index71"></A><A NAME="ch28index72"></A><A NAME="ch28index73"></A><A NAME="ch28index74"></A><A NAME="ch28index75"></A><A NAME="ch28index76"></A><A NAME="ch28index77"></A><A NAME="ch28index78"></A></P>
<A NAME="ch28sb11"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Consider priming the DB2 Catalog with objects for each new authorization ID that will be used as a creator. This avoids what some people refer to as the "first-time effect." Whenever initial inserts are performed for an authorization ID, additional overhead is involved in updating indexes and pointers. So, for each new authorization ID, consider creating a dummy database, tablespace, table, index, synonym, view, package, and plan. As is the case with all DDL, you should do this only at an off-peak time. These objects need never be used and can be dropped or freed after actual DB2 objects have been created for the authorization ID. This is less of a concern for a test DB2 subsystem where performance is a less critical issue.<A NAME="ch28index79"></A><A NAME="ch28index80"></A><A NAME="ch28index81"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch28sb12"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Keep the DB2 Catalog and Directory as small as possible. Do not use the DB2 Catalog to retain historical objects, plans, packages, or recovery information. If any of this information might be beneficial, use a historical copy or version of the DB2 Catalog to retain this information. For example,<A NAME="ch28index82"></A><A NAME="ch28index83"></A><A NAME="ch28index84"></A><A NAME="ch28index85"></A><A NAME="ch28index86"></A><A NAME="ch28index87"></A></P>
<UL><LI><P class="docList">Delete the sample tables that do not apply to the current (and perhaps previous) version of DB2.</P></LI><LI><P class="docList">Be sure to delete the <TT>SYSDDF.SYSDDF</TT> data sets and objects. These were used by the communications database that was merged with the DB2 Catalog in Version 5.</P></LI><LI><P class="docList">Always delete plans and packages that are not used. For instance, V7 users should delete <TT>DSNTEP2</TT> plans that invoke V6 or earlier programs.</P></LI><LI><P class="docList">Delete <TT>SYSCOPY</TT> rows that are not useful. This is done using the <TT>MODIFY RECOVERY</TT> utility.</P></LI></UL></TD></TR></TABLE></P><br>
<A NAME="ch28lev2sec2"></A><H4 class="docSection2Title">DSNZPARMs</H4>
<P class="docText">The makeup of the DB2 environment is driven by a series of system parameters specified when DB2 is started. These system parameters are commonly referred to as DSNZPARMs, or ZPARMs for short. The DSNZPARMs define the settings for many performance-related items. Several of the ZPARMs influence overall system performance.<A NAME="ch28index88"></A><A NAME="ch28index89"></A><A NAME="ch28index90"></A><A NAME="ch28index91"></A><A NAME="ch28index92"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V7_icon.gif" ALT="graphics/V7_icon.gif"></td><td valign="top"><P class="docText"> Most of the DSNZPARMs can be modified dynamically using the <TT>SET SYSPARM</TT> command.</P></td></tr></table><br>
<A NAME="ch28note01"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Prior to DB2 V3, buffer pool specifications were coded into the ZPARMs. For DB2 V3 and subsequent versions they are set using the <TT>ALTER BUFFERPOOL</TT> command.</P></div><br>
<P class="docText">A complete listing of DSNZPARM parameters can be found <A class="docLink" HREF="app03.html#app03">Appendix C</A> of the IBM <span class="docEmphasis">DB2 Installation Guide</span>.</P>
<A NAME="ch28lev3sec1"></A><H5 class="docSection3Title">Traces</H5>
<P class="docText">Traces can be started automatically based on DSNZPARM specifications. Most shops use this feature to ensure that certain DB2 trace information is always available to track performance problems. The DSNZPARM options for automatically starting traces are <TT>AUDITST</TT>, <TT>TRACSTR</TT>, <TT>SMFACCT</TT>, <TT>SMFSTAT</TT>, and <TT>MON</TT>.<A NAME="ch28index93"></A><A NAME="ch28index94"></A><A NAME="ch28index95"></A><A NAME="ch28index96"></A><A NAME="ch28index97"></A></P>
<A NAME="ch28sb13"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Ensure that every trace that is automatically started is necessary. Recall from <A class="docLink" HREF="ch24.html#ch24">Chapter 24</A>, "Traditional DB2 Performance Monitoring," that traces add overhead. Stopping traces reduces overhead, thereby increasing performance.</P></TD></TR></TABLE></P><br>
<P class="docText">DB2 traces can be started by IFCID. The acronym IFCID stands for Instrumentation Facility Component Identifier. An IFCID basically names a single traceable event in DB2. By specifying IFCIDs when starting a trace, you can limit the amount of information collected to just those events you need to trace.</P>
<A NAME="ch28lev3sec2"></A><H5 class="docSection3Title">Locking</H5>
<P class="docText">Lock escalation thresholds are set by the following DSNZPARM options of the system parameters:<A NAME="ch28index98"></A><A NAME="ch28index99"></A><A NAME="ch28index100"></A><A NAME="ch28index101"></A><A NAME="ch28index102"></A></P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5"><COLGROUP><COL width="110"><COL width="440"></COLGROUP><THEAD></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>NUMLKTS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Maximum number of page or row locks for a single tablespace before escalating them to a tablespace lock<A NAME="ch28index103"></A><A NAME="ch28index104"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>NUMLKUS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Maximum number of page or row locks held by a single user on all table spaces before escalating all of that user's locks to a tablespace lock<A NAME="ch28index105"></A><A NAME="ch28index106"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch28sb14"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">To increase concurrency, set the <TT>NUMLKTS</TT> and <TT>NUMLKUS</TT> thresholds high to minimize lock escalation. For some environments, the default values are adequate (<TT>NUMLKTS=1000</TT> and <TT>NUMLKUS=10000</TT>). However, for a high-volume environment these numbers may need to be adjusted upward to avoid contention problems.</P></TD></TR></TABLE></P><br>
<P class="docText">Lock escalation can also be controlled on a tablespace-by-tablespace basis using the <TT>LOCKMAX</TT> parameter. Information on the <TT>LOCKMAX</TT> parameter can be found in <A class="docLink" HREF="ch05.html#ch05">Chapter 5</A>. When specified, the <TT>LOCKMAX</TT> parameter overrides <TT>NUMLKTS</TT>.</P>
<A NAME="ch28lev3sec3"></A><H5 class="docSection3Title">Logging</H5>
<P class="docText">The parameters that define DB2's logging features are also specified in the DSNZPARMs. Options can be used to affect the frequency of writing log buffers and the size of the log buffers. The DSNZPARM options that affect DB2 logging are <TT>CHKFREQ</TT>, <TT>INBUFF</TT>, and <TT>LOGAPSTG</TT>.<A NAME="ch28index107"></A><A NAME="ch28index108"></A><A NAME="ch28index109"></A><A NAME="ch28index110"></A><A NAME="ch28index111"></A><A NAME="ch28index112"></A></P>
<A NAME="ch28sb15"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">The <TT>CHKFREQ</TT> parameter indicates how often DB2 takes system checkpoints and it can be specified as either the number of log records written or as a time duration. Restart time is directly affected by how many log records are written after the latest system checkpoint. The more log records, the longer the restart time.<A NAME="ch28index113"></A><A NAME="ch28index114"></A></P>
<P class="docText">If the value of <TT>CHKFREQ</TT> is within the range of <TT>200</TT> to <TT>16000000</TT>, it indicates the number of log records written before a checkpoint is taken. If <TT>CHKFREQ</TT> is within the range of 1 to 60, it indicates the number of minutes between checkpoints.</P>
<P class="docText">Additionally, DB2 takes a checkpoint when an active log is switched. The active log is switched when it becomes full or the <TT>ARCHIVE LOG</TT> command is issued.</P>
<P class="docText">You can use the <TT>SET LOG</TT> command or the <TT>SET SYSPARM</TT> command to change the <TT>CHKFREQ</TT> parameter dynamically. If you use <TT>SET LOG</TT>, the value is changed, but only for as long as the DB2 subsystem remains operational. When DB2 shuts down and is restarted, <TT>CHKFREQ</TT> will reset back to its previous value. If you use <TT>SET SYSPARM</TT> to change <TT>CHKFREQ</TT>, the value is changed now and forevermore—even if DB2 is recycled.</P></TD></TR></TABLE></P><br>
<P class="docText">DB2 fills log buffers and eventually the log records are written to an active log data set. The write occurs when the buffers fill up, when the write threshold is reached or when the DB2 subsystem forces the log buffer to be written.</P>
<A NAME="ch28sb16"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Many shops simply use the default log output buffer size of 4000K. This is adequate for small shops (those with only one or two small, non-critical DB2 applications). The maximum value for <TT>OUTBUFF</TT> is 400MB. Shops with large, critical DB2 applications should probably specify a very large <TT>OUTBUFF</TT>—up to the maximum of 400MB if sufficient memory is available.<A NAME="ch28index115"></A><A NAME="ch28index116"></A><A NAME="ch28index117"></A></P>
<P class="docText">By increasing the <TT>OUTBUFF</TT> size, DB2 can perform better because more logging activity is performed in memory. Log writes can improve because DB2 is less likely to need to wait for a buffer. Log reads can improve because, if the information is in the log buffer, DB2 does not need to read the information from disk storage.</P>
<P class="docText">Be aware that when the log buffer is full the entire DB2 subsystem will stop until writes have completed and log buffers are available again.</P></TD></TR></TABLE></P><br>
<P class="docText">The <TT>LOGAPSTG</TT> parameter represents the maximum DBM1 storage that can be used by the fast log-apply process. The default value is 0MB, which means that the fast log-apply process is disabled except during DB2 restart. During DB2 restart, the fast log-apply process is always enabled.<A NAME="ch28index118"></A><A NAME="ch28index119"></A><A NAME="ch28index120"></A><A NAME="ch28index121"></A><A NAME="ch28index122"></A><A NAME="ch28index123"></A><A NAME="ch28index124"></A><A NAME="ch28index125"></A></P>
<A NAME="ch28sb17"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Plan for 10MB of storage for each concurrent <TT>RECOVER</TT> job that you want to have faster log apply processing. So, if you plan on having 3 concurrent <TT>RECOVER</TT> jobs, specify 30MB for <TT>LOGAPSTG</TT>.</P></TD></TR></TABLE></P><br>
<A NAME="ch28lev3sec4"></A><H5 class="docSection3Title">Timeouts</H5>
<P class="docText">The amount of time to wait for an unavailable resource to become available before timing out is controlled by the DSNZPARM value, <TT>IRLMRWT</TT>. When one user has a lock on a DB2 resource that another user needs, DB2 waits for the time specified by <TT>IRLMRWT</TT> and then issues a <TT>-911</TT> or <TT>-913 SQLCODE</TT>.<A NAME="ch28index126"></A><A NAME="ch28index127"></A><A NAME="ch28index128"></A><A NAME="ch28index129"></A><A NAME="ch28index130"></A></P>
<A NAME="ch28sb18"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText"><TT>IRLMRWT</TT> controls the amount of time to wait before timing out both foreground and background tasks. Therefore, you must balance a reasonable amount of time for a batch job to wait versus a reasonable amount of time for an online transaction to wait. If this value is too high, transactions wait too long for unavailable resources before timing out. If this value is too low, batch jobs abend with timeouts more frequently. The default value of 60 seconds is usually a reasonable setting.<A NAME="ch28index131"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch28sb19"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Sometimes it is impossible to find a compromise value for <TT>IRLMRWT</TT>. Online transactions wait too long to time out, or batch jobs time out too frequently. If this is the case, consider starting DB2 in the morning for online activity with a modest <TT>IRLMRWT</TT> value (45 or 60 seconds) and starting it again in the evening for batch jobs with a larger <TT>IRLMRWT</TT> value (90 to 120 seconds). In this scenario, DB2 must go down and come back up during the day. (This might be impossible for shops running 24 hours a day, 7 days a week.)</P></TD></TR></TABLE></P><br>
<P class="docText">Additionally, the <TT>UTIMOUT</TT> parameter can be used to indicate the number of resource timeout cycles that a utility will wait for a drain lock before timing out.<A NAME="ch28index132"></A><A NAME="ch28index133"></A><A NAME="ch28index134"></A><A NAME="ch28index135"></A><A NAME="ch28index136"></A><A NAME="ch28index137"></A><A NAME="ch28index138"></A></P>
<A NAME="ch28sb20"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">The value of <TT>UTIMOUT</TT> is based on the value of <TT>IRLMRWT</TT>. If <TT>UTIMOUT</TT> is set to 6 (which is the default), a utility will wait six times as long as an SQL statement before timing out.</P></TD></TR></TABLE></P><br>
<A NAME="ch28lev3sec5"></A><H5 class="docSection3Title">Active Users</H5>
<P class="docText">The number of active users can be controlled by the DSNZPARM settings, including the following:<A NAME="ch28index139"></A><A NAME="ch28index140"></A><A NAME="ch28index141"></A><A NAME="ch28index142"></A><A NAME="ch28index143"></A><A NAME="ch28index144"></A></P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5"><COLGROUP><COL width="121"><COL width="429"></COLGROUP><THEAD></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CTHREAD</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Controls the absolute number of maximum DB2 threads that can be running concurrently<A NAME="ch28index145"></A><A NAME="ch28index146"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>IDFORE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Sets the maximum number of TSO users that can be connected to DB2 simultaneously<A NAME="ch28index147"></A><A NAME="ch28index148"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>IDBACK</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Controls the number of background batch jobs accessing DB2<A NAME="ch28index149"></A><A NAME="ch28index150"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>MAXDBAT</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Specifies the maximum number of concurrent distributed threads that can be active at one time<A NAME="ch28index151"></A><A NAME="ch28index152"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch28sb21"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Use the <TT>CTHREAD</TT> parameter to ensure that no more than the planned maximum number of DB2 users can access DB2 at a single time. Failure to keep this number synchronized with other DB2 resources can cause performance degradation. For example, if your buffer pools and EDM pool are tuned to be optimal for 30 users, do not allow <TT>CTHREAD</TT> to exceed 30 until you have reexamined these other areas.</P>
<P class="docText">The same guideline applies for <TT>IDFORE</TT> to control TSO use, <TT>IDBACK</TT> to control the proliferation of batch DB2 jobs, and <TT>MAXDBAT</TT> to control distributed DB2 jobs.</P></TD></TR></TABLE></P><br>
<A NAME="ch28lev3sec6"></A><H5 class="docSection3Title">EDM Pool</H5>
<P class="docText">The size of the EDM pool is specified in the DSNZPARM value named <TT>EDMPOOL</TT>. The use of the EDM pool and its requirements are described in <A class="docLink" HREF="ch27.html#ch27">Chapter 27</A>, "Tuning DB2's Environment," in the section titled "<A class="docLink" HREF="ch27lev1sec1.html#ch27lev2sec1">Tuning Memory Use</A>."<A NAME="ch28index153"></A><A NAME="ch28index154"></A><A NAME="ch28index155"></A><A NAME="ch28index156"></A><A NAME="ch28index157"></A></P>
<A NAME="ch28lev2sec3"></A><H4 class="docSection2Title">Drowning in a Buffer Pool of Tears</H4>
<P class="docText">The single most critical system-related factor influencing DB2 performance is the setup of sufficient buffer pools. A buffer pool acts as a cache between DB2 and the physical disk storage devices on which the data resides. After data has been read, the DB2 Buffer Manager places the page into a buffer pool page stored in memory. Buffer pools, therefore, reduce the impact of I/O on the system by enabling DB2 to read and write data to memory locations synchronously, while performing time-intensive physical I/O asynchronously.<A NAME="ch28index158"></A><A NAME="ch28index159"></A><A NAME="ch28index160"></A></P>
<P class="docText">Through judicious management of the buffer pools, DB2 can keep the most recently used pages of data in memory so that they can be reused without incurring additional I/O. A page of data can remain in the buffer pool for quite some time, as long as it is being accessed frequently. <A class="docLink" HREF="#ch28fig01">Figure 28.1</A> shows pages of data being read into the buffer pool and reused by multiple programs before finally being written back to disk. Processing is more efficient as physical I/Os decrease and buffer pool I/Os increase.<A NAME="ch28index161"></A><A NAME="ch28index162"></A><A NAME="ch28index163"></A></P>
<A NAME="ch28fig01"></A><p><CENTER><H5 class="docFigureTitle">Figure 28.1. DB2 buffer pool processing.</H5>
<p class="docText"><IMG BORDER="0" width="500" height="399" SRC="images/0672326132/graphics/28fig01.gif" ALT="graphics/28fig01.gif"></p></CENTER></p><br>
<P class="docText">How does the buffer pool work? DB2 performs all I/O-related operations under the control of its Buffer Manager component. As pages are read, they are placed into pages in the buffer pool using a hashing algorithm based on an identifier for the data set and the number of the page in the data set. When data is subsequently requested, DB2 can check the buffer pool quickly using hashing techniques. This provides efficient data retrieval. Additionally, DB2 data modification operations write to the buffer pool, which is more efficient than writing directly to DASD.</P>
<P class="docText">How does DB2 keep track of what data is updated in the buffer pool? This is accomplished by attaching a state to each buffer pool page: available or not available. An available buffer page meets the following two criteria:<A NAME="ch28index164"></A><A NAME="ch28index165"></A><A NAME="ch28index166"></A></P>
<UL><LI><P class="docList">The page does not contain data updated by an SQL statement, which means that the page must be externalized to disk before another page can take its place.</P></LI><LI><P class="docList">The page does not contain data currently being used by a DB2 application.</P></LI></UL>
<P class="docText">An unavailable page is one that does not meet one of these criteria because it has either been updated and not yet written to disk, or it is currently in use. When a page is available, it is said to be available for stealing. <span class="docEmphasis">Stealing</span> is the process whereby DB2 replaces the current data in a buffer page with a different page of data. Usually, the least recently used available buffer page is stolen first (but it depends on the stealing algorithm used for the buffer pool). DB2 provide 80 buffer pools to monitor, tune, and tweak.<A NAME="ch28index167"></A><A NAME="ch28index168"></A><A NAME="ch28index169"></A><A NAME="ch28index170"></A><A NAME="ch28index171"></A><A NAME="ch28index172"></A></P>
<P class="docText">Although every shop's usage of buffer pools differs, some basic ideas can be used to separate different types of processing into disparate buffer pools. Consult <A class="docLink" HREF="#ch28table01">Table 28.1</A> for one possible buffer pool usage scenario. This is just one possible scenario and is not a general recommendation for buffer pool allocation.</P>
<A NAME="ch28table01"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 28.1. A Possible Buffer Pool Usage Scenario</h5></CAPTION><COLGROUP><COL width="132"><COL width="418"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Buffer Pool</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Usage</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BP0</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Isolate system resources <span class="docEmphasis">(DB2 Catalog and Directory, RLST, and so on)</span></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BP1</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Sequential tablespace buffer pool (usually accessed sequentially)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BP2</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Sequential index buffer pool (usually accessed sequentially)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BP3</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Code tables, lookup tables, and sequential number generation tables</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BP4</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Indexes for code tables, lookup tables, and sequential number generation tables</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BP5</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Dedicated buffer pool (for a single, critical tablespace or index)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BP6</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Dedicated buffer pool (for an entire application)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BP7</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Dedicate to sorting <span class="docEmphasis">(DSNDB07)</span></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BP8</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Random tablespace buffer pool (usually accessed randomly)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BP9</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Random index buffer pool (usually accessed randomly)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BP10</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Reserve for tuning and special testing</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BP11</TT>-<TT>BP49</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Additional dedicated buffer pools (per tablespace, index, partition, application, or any combination thereof)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BP8K0</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Reserved for DB2 Catalog objects with 8K pages (<TT>SYSDBASE</TT>, <TT>SYSGRTNS</TT>, <TT>SYSHIST</TT>, <TT>SYSOBJ</TT>, <TT>SYSSTR</TT> and <TT>SYSVIEWS</TT>)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BP8K1</TT>-<TT>BP8K9</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Use when 8K tablespaces have been defined</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BP16K0</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Reserved for DB2 Catalog objects with 16K pages (<TT>SYSSTATS</TT>)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BP16K1</TT>-<TT>BP16K9</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Use when 16K tablespaces have been defined</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>BP32K</TT>s</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">At least one BP32K for large joins; more if 32K tablespaces are permitted; be sure to separate 32K user tablespaces from 32K <TT>DSNDB07</TT> tablespaces<A NAME="ch28index175"></A><A NAME="ch28index176"></A><A NAME="ch28index177"></A><A NAME="ch28index178"></A><A NAME="ch28index179"></A></P></TD></TR></TABLE></P><br>
<P class="docText">I will examine several aspects of this scenario. The first buffer pool, <TT>BP0</TT>, should be reserved for system data sets such as the DB2 Catalog, QMF control tables, and Resource Limit Specification Tables. By isolating these resources into a separate buffer pool, system data pages will not contend for the same buffer pool space as application data pages.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> As of DB2 V8, some of the DB2 Catalog tablespaces require page sizes larger than 4K. These tablespaces use the <TT>BP8K0</TT> and <TT>BP16K0</TT> buffer pools.</P></td></tr></table><br>
<P class="docText">Likewise, a single buffer pool (for example, <TT>BP7</TT>) can be set aside for sorting. If your environment requires many large sorts that use physical work files, isolating <TT>DSNDB07</TT> (the sort work database) in its own buffer pool may be beneficial. This is accomplished by assigning all <TT>DSNDB07</TT> tablespaces to the targeted buffer pool (<TT>BP7</TT>).<A NAME="ch28index180"></A><A NAME="ch28index181"></A><A NAME="ch28index182"></A><A NAME="ch28index183"></A></P>
<P class="docText">Another technique for the allocation of buffer pools is to use separate buffer pools for indexes and tablespaces. This can be accomplished by creating tablespaces in one buffer pool (for example, <TT>BP1</TT>) and indexes in another (for example, <TT>BP2</TT>). The idea behind this strategy is to enable DB2 to maintain more frequently accessed data by type of object. For instance, if indexes are isolated in their own buffer pool, large sequential prefetch requests do not cause index pages to be flushed, because the sequential prefetch is occurring in a different buffer pool. Thus, index pages usually remain in memory longer, which increases performance for indexed access.</P>
<A NAME="ch28sb22"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Many organizations do not spend sufficient time tuning their buffer pools. If you do not have the time or the organizational support to highly tune your objects into separate buffer pools, at least separate the tablespaces from the indexes.<A NAME="ch28index184"></A><A NAME="ch28index185"></A></P>
<P class="docText">If you do nothing else with your buffer pool strategy, separating tablespaces and indexes in different buffer pools can give a nice performance boost for minimal administrative effort.</P></TD></TR></TABLE></P><br>
<P class="docText">You can further tune your buffer pool usage strategy by isolating random access from sequential access. Consider using say, <TT>BP1</TT> and <TT>BP2</TT> for objects that are predominantly accessed sequentially, and say, <TT>BP8</TT> and <TT>BP9</TT> for randomly accessed objects. It is then possible to further tune the buffer pool parameters so that each type of buffer pool is optimized for the predominant type of access (that is, random or sequential).<A NAME="ch28index186"></A><A NAME="ch28index187"></A><A NAME="ch28index188"></A></P>
<P class="docText">Tables providing specialized functions can also be isolated. This is depicted by <TT>BP5</TT> and <TT>BP6</TT>. Because these tables are very frequently accessed, they are often the cause of I/O bottlenecks that negatively impact performance. Creating the tablespaces for these tables in a specialized buffer pool can allow the entire table to remain in memory, vastly improving online performance. Additionally, the isolation of specialized tables into their own buffer pools enables pinpoint tuning for these frequently accessed tables (and indexes). General-purpose tables (and their associated indexes) accessed by multiple programs are good candidates for this type of strategy. Following are some examples:<A NAME="ch28index189"></A><A NAME="ch28index190"></A><A NAME="ch28index191"></A></P>
<UL><LI><P class="docList">Tables used to control the assignment of sequential numbers.</P></LI><LI><P class="docList">Lookup tables and code tables used by multiple applications.</P></LI><LI><P class="docList">Tables and indexes used to control application-based security.</P></LI><LI><P class="docList">Indexes with heavy index-only access. Isolating these indexes in their own buffer pool may enable the leaf pages to remain in memory.<A NAME="ch28index192"></A><A NAME="ch28index193"></A><A NAME="ch28index194"></A></P></LI></UL>
<A NAME="ch28sb23"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Regardless of the number of buffer pools that your shop intends to utilize, you should consider reserving one of the 4K buffer pools for tuning and testing (<TT>BP10</TT>, in the example). By reserving a buffer pool for tuning, you can <TT>ALTER</TT> problem objects to use the tuning buffer pool and run performance monitor reports to isolate I/O to the problem objects. The reports can be analyzed to assist in tuning.<A NAME="ch28index195"></A><A NAME="ch28index196"></A></P></TD></TR></TABLE></P><br>
<P class="docText">It is usually a wise idea to use multiple buffer pools for different types of processing. This should minimize buffer pool page contention. In the example, <TT>BP5</TT> is used to isolate one heavily accessed tablespace and/or index in its own buffer pool. Isolating a page set this way can ensure that no other processing will steal its buffer pages. Likewise, you may want to use a single buffer pool per application, such as <TT>BP6</TT> in the example. Isolating all of that application's objects into its own buffer pool can eliminate or reduce the instances where one application monopolizes a buffer pool to the detriment of another application using the same buffer pool. It can also make application monitoring easier because all I/O is through a single buffer pool.<A NAME="ch28index197"></A><A NAME="ch28index198"></A><A NAME="ch28index199"></A></P>
<P class="docText">The remaining buffer pools (<TT>BP11</TT> through <TT>BP49</TT>) can be used to further isolate specific objects or for further tuning.</P>
<P class="docText">The DB2 buffer pools have a huge impact on performance. There are several schools of thought on how best to implement DB2 buffer pools. For example, you may want to consider using separate buffer pools to do the following:<A NAME="ch28index200"></A><A NAME="ch28index201"></A><A NAME="ch28index202"></A></P>
<UL><LI><P class="docList">Separate ad hoc from production</P></LI><LI><P class="docList">Isolate QMF tablespaces used for the <TT>SAVE DATA</TT> command</P></LI><LI><P class="docList">Isolate infrequently used tablespaces and indexes</P></LI><LI><P class="docList">Isolate tablespaces and indexes used by third-party tools<A NAME="ch28index203"></A><A NAME="ch28index204"></A><A NAME="ch28index205"></A></P></LI></UL>
<A NAME="ch28note02"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Be careful that you do not allocate too many buffer pools. It is possible to allocate too many buffer pools to adequately manage. Be sure to align your performance needs for multiple buffer pools with your available administrative resources for monitoring and tuning those buffer pools.<A NAME="ch28index206"></A><A NAME="ch28index207"></A><A NAME="ch28index208"></A></P></div><br>
<A NAME="ch28lev3sec7"></A><H5 class="docSection3Title">One Large Buffer Pool?</H5>
<P class="docText">The general recommendation from consultants and some IBM engineers in years past was to use only <TT>BP0</TT>, specifying one very large buffer pool for all DB2 page sets. This strategy turns over to DB2 the entire control for buffer pool management. Because DB2 uses efficient buffer-handling techniques, the theory was that good performance could be achieved using a single large buffer pool.<A NAME="ch28index209"></A><A NAME="ch28index210"></A><A NAME="ch28index211"></A><A NAME="ch28index212"></A></P>
<P class="docText">In the olden days of DB2, this strategy worked fairly well. When only a few, small applications used DB2, it could manage a fairly efficient single buffer pool. Today though, only some very small DB2 implementations can get by with one large buffer pool, using <TT>BP0</TT> and letting DB2 do the buffer pool management. The days when most shops employed the single buffer pool strategy are over. As the amount of data stored in DB2 databases increases, specialized types of tuning are necessary to optimize data access. This usually results in the implementation of multiple buffer pools. Why else would IBM provide 80 of them?</P>
<A NAME="ch28sb24"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Avoid using one large DB2 buffer pool. Instead, share the wealth by assigning your DB2 objects to buffer pools based on access type.</P></TD></TR></TABLE></P><br>
<P class="docText">If your shop is memory constrained, or you have limited practical experience with DB2 buffer pools, you might want to consider starting with one DB2 buffer pool and then experimenting with specialized buffer pool strategies as you acquire additional memory and practical expertise.<A NAME="ch28index213"></A><A NAME="ch28index214"></A><A NAME="ch28index215"></A><A NAME="ch28index216"></A></P>
<A NAME="ch28lev3sec8"></A><H5 class="docSection3Title">Notes on Multiple Buffer Pool Use</H5>
<P class="docText">The following guidelines are helpful when allocating multiple buffer pools at your shop.<A NAME="ch28index217"></A><A NAME="ch28index218"></A><A NAME="ch28index219"></A><A NAME="ch28index220"></A></P>
<A NAME="ch28lev4sec1"></A><H5 class="docSection4Title">Ensure That Sufficient Memory Is Available</H5>
<P class="docText">Before implementing multiple buffer pools, be sure that your environment has the memory to back up the buffer pools. The specification of large buffer pools without sufficient memory to back them up can cause paging. Paging to DASD is extremely nasty and should be avoided at all costs.<A NAME="ch28index221"></A><A NAME="ch28index222"></A></P>
<A NAME="ch28lev4sec2"></A><H5 class="docSection4Title">Document Buffer Pool Assignments</H5>
<P class="docText">Be sure to keep track of which DB2 objects are assigned to which buffer pool. Failure to do so can result in confusion. Of course, DB2 Catalog queries can be used for obtaining this information.<A NAME="ch28index223"></A><A NAME="ch28index224"></A></P>
<A NAME="ch28lev4sec3"></A><H5 class="docSection4Title">Modify Buffer Pools to Reflect Processing Requirements</H5>
<P class="docText">Defining multiple buffer pools so that they are used optimally throughout the day is difficult. For example, suppose that <TT>DSNDB07</TT> is assigned to its own buffer pool. Because sorting activity is generally much higher during the batch window than during the day, buffers assigned to <TT>DSNDB07</TT> can go unused during the transaction processing window.<A NAME="ch28index225"></A><A NAME="ch28index226"></A></P>
<P class="docText">Another example is when you assign tables used heavily in the online world to their own buffer pool. Online transaction processing usually subsides (or stops entirely) when nightly batch jobs are running. Online tables might be accessed sparingly in batch, if at all. This causes the buffers assigned for those online tables to go unused during batch processing.</P>
<P class="docText">Unless you are using one large <TT>BP0</TT>, it is difficult to use resources optimally during the entire processing day. Ask yourself if the performance gained by the use of multiple buffer pools offsets the potential for wasted resources. Quite often, the answer is a resounding "Yes."</P>
<P class="docText">DB2 provides the capability to dynamically modify the size of buffer pools using the <TT>ALTER BUFFERPOOL</TT> command. Consider using <TT>ALTER BUFFERPOOL</TT> to change buffer pool sizes to reflect the type of processing being performed. For example, to optimize the <TT>DSNDB07</TT> scenario mentioned previously, try the following:</P>
<UL><LI><p class="docText">
<span class="docEmphRoman">Prior to batch processing, issue the following command</span>: 
<TT>-ALTER BUFFERPOOL BP1 VPSIZE(</TT><span class="docEmphasis"><TT>max amount</TT></span><TT>)</TT></p></LI><LI><p class="docText">
<span class="docEmphRoman">After batch processing, issue the following command</span>: 
<TT>-ALTER BUFFERPOOL BP1 VPSIZE(</TT><span class="docEmphasis"><TT>min amount</TT></span><TT>)</TT></p></LI></UL>
<P class="docText">The execution of these commands can be automated so that the appropriate buffer pool allocations are automatically invoked at the appropriate time in the batch schedule.<A NAME="ch28index227"></A><A NAME="ch28index228"></A><A NAME="ch28index229"></A><A NAME="ch28index230"></A></P>
<A NAME="ch28lev2sec4"></A><H4 class="docSection2Title">Buffer Pool Parameters</H4>
<P class="docText">DB2 provides many buffer pool tuning options that can be set using the <TT>ALTER BUFFERPOOL</TT> command. These options are described in the following paragraphs.<A NAME="ch28index231"></A><A NAME="ch28index232"></A><A NAME="ch28index233"></A><A NAME="ch28index234"></A></P>
<P class="docText">The first parameter, <TT>VPSIZE</TT>, is arguably the most important. It defines the size of the individual virtual pool. The value can range from 0 to 400,000 for 4K buffer pools, from 0 to 200,000 for 8K buffer pools, from 0 to 100,000 for 16K buffer pools, and from 0 to 50,000 for 32K buffer pools. The total <TT>VPSIZE</TT> for all buffer pools cannot be greater than 1.6 GB. The minimum size of BP0 is 56 because the DB2 Catalog tablespaces and indexes are required to use BP0.<A NAME="ch28index235"></A><A NAME="ch28index236"></A><A NAME="ch28index237"></A><A NAME="ch28index238"></A><A NAME="ch28index239"></A></P>
<P class="docText">The capability to dynamically alter the size of a virtual pool enables DBAs to expand and contract virtual pool sizes without stopping DB2. Altering <TT>VPSIZE</TT> causes the virtual pool to be dynamically resized. If <TT>VPSIZE</TT> is altered to zero, DB2 issues a quiesce and when all activity is complete, the virtual pool is deleted.</P>
<P class="docText">Prior to DB2 V8, virtual buffer pools can be allocated in data spaces. To accomplish this, use the <TT>VPTYPE</TT> parameter to indicate the type of buffer pool to be used. <TT>VPTYPE(DATASPACE)</TT> indicates that data spaces are to be used for the buffer pool; <TT>VPTYPE(PRIMARY)</TT> indicates that the buffer pool is to be allocated as before, in the DB2 database services address space. You should be running in 64 bit mode to take advantage of data space buffer pools.<A NAME="ch28index240"></A><A NAME="ch28index241"></A><A NAME="ch28index242"></A><A NAME="ch28index243"></A><A NAME="ch28index244"></A></P>
<A NAME="ch28sb25"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">The main reason to implement DB2 buffer pools in data spaces is to relieve storage constraints in DB2's database services (DBM1) address space. Another reason would be to provide greater opportunities for caching very large tablespaces or indexes.</P>
<P class="docText">Data space virtual buffer pools are no longer supported as of DB2 V8.</P></TD></TR></TABLE></P><br>
<P class="docText">The sequential steal threshold can be tuned using <TT>VPSEQT</TT>. <TT>VPSEQT</TT> is expressed as a percentage of the virtual pool size (<TT>VPSIZE</TT>). This number is the percentage of the virtual pool that can be monopolized by sequential processing, such as sequential prefetch. When this threshold is reached, sequential prefetch will be disabled. All subsequent reads will be performed one page at a time until the number of pages available drops below the specified threshold. The value of <TT>VPSEQT</TT> can range from <TT>0</TT> to <TT>100</TT>, and the default is <TT>80</TT>. When <TT>VPSEQT</TT> is set to <TT>0</TT>, prefetch is disabled.<A NAME="ch28index245"></A><A NAME="ch28index246"></A><A NAME="ch28index247"></A><A NAME="ch28index248"></A><A NAME="ch28index249"></A></P>
<A NAME="ch28sb26"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">If the sequential steal threshold is reached often, consider either increasing the <TT>VPSEQT</TT> percentage or increasing the size of the associated buffer pool. When sequential prefetch is disabled, performance degradation will ensue.<A NAME="ch28index250"></A><A NAME="ch28index251"></A><A NAME="ch28index252"></A><A NAME="ch28index253"></A><A NAME="ch28index254"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch28sb27"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">When all of the data from tables assigned to the buffer pool can be stored in the buffer pool, and access is almost exclusively random, specify <TT>VPSEQT=0</TT>. For example, consider specifying <TT>0</TT> for <TT>VPSEQT</TT> when a virtual buffer pool is used for small code and lookup tables.<A NAME="ch28index255"></A><A NAME="ch28index256"></A><A NAME="ch28index257"></A><A NAME="ch28index258"></A><A NAME="ch28index259"></A></P></TD></TR></TABLE></P><br>
<P class="docText">Additionally, the sequential steal threshold for parallel operations can be explicitly set using <TT>VPPSEQT</TT>. This parallel sequential steal threshold is expressed as a percentage of the nonparallel sequential steal threshold (<TT>VPSEQT</TT>). The value of <TT>VPPSEQT</TT> can range from <TT>0</TT> to <TT>100</TT>, and the default is <TT>50</TT>.<A NAME="ch28index260"></A><A NAME="ch28index261"></A><A NAME="ch28index262"></A><A NAME="ch28index263"></A><A NAME="ch28index264"></A></P>
<A NAME="ch28sb28"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Consider isolating data sets that are very frequently accessed sequentially into a buffer pool with <TT>VPSEQT</TT> set to <TT>95</TT>. This enables most of the buffer pool to be used for sequential access.</P></TD></TR></TABLE></P><br>
<A NAME="ch28sb29"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">By setting <TT>VPPSEQT</TT> to <TT>0</TT>, you can ensure that parallel I/O will not be available for this virtual pool. <span class="docEmphasis">I am not necessarily recommending this, just pointing it out.</span> If you want to ensure that I/O parallelism is not used for a particular buffer pool, setting <TT>VPPSEQT</TT> to <TT>0</TT> will do the trick. Use caution and take care before choosing to modify this parameter.<A NAME="ch28index265"></A><A NAME="ch28index266"></A><A NAME="ch28index267"></A><A NAME="ch28index268"></A><A NAME="ch28index269"></A></P></TD></TR></TABLE></P><br>
<P class="docText">The assisting parallel sequential threshold can be explicitly set using <TT>VPXPSEQT</TT>. This threshold sets the percentage of the parallel sequential threshold that is available to assist another parallel group member to process a query. The <TT>VPXPSEQT</TT> sequential threshold is expressed as a percentage of the parallel sequential steal threshold (<TT>VPPSEQT</TT>). The value of <TT>VPXPSEQT</TT> can range from <TT>0</TT> to <TT>100</TT>, and the default is <TT>0</TT>.<A NAME="ch28index270"></A><A NAME="ch28index271"></A><A NAME="ch28index272"></A><A NAME="ch28index273"></A><A NAME="ch28index274"></A></P>
<P class="docText">To understand the relationship that exists among the buffer pool parameters, refer to <A class="docLink" HREF="#ch28fig02">Figure 28.2</A>. This diagram depicts the different parameters and thresholds and their relationships to one another.</P>
<A NAME="ch28fig02"></A><p><CENTER><H5 class="docFigureTitle">Figure 28.2. The relationships among the buffer pool parameters.</H5>
<p class="docText"><IMG BORDER="0" width="500" height="197" SRC="images/0672326132/graphics/28fig02.gif" ALT="graphics/28fig02.gif"></p></CENTER></p><br>
<P class="docText">To better understand the buffer pool parameters, consider the impact of issuing the following command:</P>
<pre>

</pre><BR><pre>
-ALTER BUFFERPOOL BP1 VPSIZE(2000) VPSEQT(80) VPPSEQT(50) VPXPSEQT(25)
</pre><BR>
<P class="docText">The <TT>BP1</TT> buffer pool would be set to 8MB (2000 pages each 4KB in size). The sequential steal threshold (<TT>VPSEQT</TT>) is set to 80% of the buffer pool, which is 6.4MB (1600 pages). The parallel sequential steal threshold (<TT>VPPSEQT</TT>) is set to 50% of <TT>VPSEQT</TT>, which is 3.2MB (800 pages). Finally, the assisting parallel sequential steal threshold (<TT>VPXPSEQT</TT>) is set to 25% of <TT>VPPSEQT</TT>, which is .8MB (200 pages).<A NAME="ch28index275"></A><A NAME="ch28index276"></A><A NAME="ch28index277"></A><A NAME="ch28index278"></A></P>
<A NAME="ch28note03"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Setting these parameters can be quite confusing because they are set as percentages of other parameters. Take care to ensure that you are specifying the thresholds properly.</P></div><br>
<A NAME="ch28lev3sec9"></A><H5 class="docSection3Title">Deferred Write</H5>
<P class="docText"><TT>DWQT</TT> can be used to specify the deferred write threshold. This threshold is expressed as a percentage of the virtual pool size (<TT>VPSIZE</TT>). It specifies when deferred writes will begin to occur. When the percentage of unavailable pages exceeds the <TT>DWQT</TT> value, pages will be written to DASD immediately (not deferred, as normal) until the number of available pages reaches 10% of (<TT>DWQT</TT>x<TT>VPSIZE</TT>). The value of <TT>DWQT</TT> can range from <TT>0</TT> to <TT>100</TT>, and the default is <TT>50</TT>.<A NAME="ch28index279"></A><A NAME="ch28index280"></A><A NAME="ch28index281"></A><A NAME="ch28index282"></A><A NAME="ch28index283"></A><A NAME="ch28index284"></A><A NAME="ch28index285"></A></P>
<P class="docText">Additionally, <TT>VDWQT</TT> can be used to set the deferred write threshold per data set. <TT>VDWQT</TT> is expressed as a percentage of the virtual pool size (<TT>VPSIZE</TT>). As of DB2 V6, you can express the <TT>VDWQT</TT> threshold as an integer value instead of a percentage. When the percentage of pages containing updated data for a single data set exceeds this threshold, immediate writes will begin to occur. The value of <TT>VDWQT</TT> can range from <TT>0</TT> to <TT>90</TT> and the default is <TT>10</TT>. This value should be less than <TT>DWQT</TT>.<A NAME="ch28index286"></A><A NAME="ch28index287"></A><A NAME="ch28index288"></A><A NAME="ch28index289"></A><A NAME="ch28index290"></A></P>
<A NAME="ch28sb30"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Hitting either of the deferred write thresholds does not necessarily constitute a problem. Indeed, you can use these parameters to control how DB2 writes data.</P>
<P class="docText">Consider setting the deferred write thresholds to enable trickle writing. With trickle writing, DB2 will regularly hit the deferred write threshold to externalize data to disk, instead of deferring writes and externalizing them all in a big bang. The pages that are written will remain in the buffer pool if they are referenced often.</P></TD></TR></TABLE></P><br>
<A NAME="ch28lev3sec10"></A><H5 class="docSection3Title">Buffer Pool Page Stealing Algorithm</H5>
<P class="docText">You can modify the page-stealing algorithm used by DB2 virtual buffer pools using the <TT>PGSTEAL</TT> parameter. When DB2 removes a page from the buffer pool to make room for a newer page, this is called <span class="docEmphasis">page stealing</span>. The usual algorithm deployed by DB2 uses least-recently-used (LRU) processing for managing buffer pages. In other words, older pages are removed so more recently used pages can remain in the virtual buffer pool.<A NAME="ch28index291"></A><A NAME="ch28index292"></A><A NAME="ch28index293"></A><A NAME="ch28index294"></A><A NAME="ch28index295"></A><A NAME="ch28index296"></A><A NAME="ch28index297"></A><A NAME="ch28index298"></A><A NAME="ch28index299"></A><A NAME="ch28index300"></A><A NAME="ch28index301"></A><A NAME="ch28index302"></A><A NAME="ch28index303"></A><A NAME="ch28index304"></A></P>
<P class="docText">However, you can choose to use a different, first-in–first-out (FIFO) algorithm. With FIFO, DB2 does not keep track of how often a page is referenced. The oldest pages are removed, regardless of how frequently they are referenced. This approach to page stealing results in a small decrease in the cost of doing a <TT>GETPAGE</TT> operation, and it can reduce internal DB2 latch contention in environments that require very high concurrency.<A NAME="ch28index305"></A><A NAME="ch28index306"></A><A NAME="ch28index307"></A><A NAME="ch28index308"></A><A NAME="ch28index309"></A></P>
<A NAME="ch28sb31"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Use the LRU page-stealing algorithm in most cases. Consider FIFO when the tablespaces and/or indexes assigned to the buffer pool are read once and remain in memory. When the buffer pool has little or no I/O, the FIFO algorithm can provide a performance boost.</P>
<P class="docText">Be sure to define objects that can benefit from the FIFO algorithm in different buffer pools from other objects.</P></TD></TR></TABLE></P><br>
<A NAME="ch28lev2sec5"></A><H4 class="docSection2Title">Determining Buffer Pool Sizes</H4>
<P class="docText">Many database analysts and programmers are accustomed to working with buffer pools that are smaller than DB2 buffer pools (for example, IMS and VSAM buffers). DB2 just loves large buffer pools. Each shop must determine the size of its buffer pools based on the following factors:<A NAME="ch28index310"></A><A NAME="ch28index311"></A><A NAME="ch28index312"></A><A NAME="ch28index313"></A></P>
<UL><LI><P class="docList">Size of the DB2 applications that must be processed</P></LI><LI><P class="docList">Desired response time for DB2 applications</P></LI><LI><P class="docList">Amount of virtual and real storage available</P></LI></UL>
<P class="docText">Remember, though, that DB2 does not allocate buffer pool pages in memory until it needs them. A DB2 subsystem with very large buffer pools might not use them all of the time.</P>
<P class="docText">As with the number of buffer pools to use, there are several schools of thought on how best to determine the size of the buffer pool. Actually, buffer pool sizing is more an art than a science. Try to allocate your buffer pools based on your projected workload and within the limitations defined by the amount of real and virtual memory available. Of course, for DB2 V8 you have much more flexibility in creating larger DB2 buffer pools than you had in the past due to the exploitation of 64-bit virtual memory.</P>
<P class="docText">The following calculation can be used as a good rough starting point for determining the size of your DB2 buffer pools:</P>
<pre>

</pre><BR><pre>
[number of concurrent users x 80] +
[(desired number of transactions per second) x (average GETPAGEs per transaction)] +
[(Total # of leaf pages for all indexes) x .70]
</pre><BR>
<P class="docText">The resulting number represents the number of 4K pages to allocate for all of your buffer pools. If you are using only <TT>BP0</TT>, the entire amount can be coded for that buffer pool. If you are using multiple buffer pools, a percentage of this number must be apportioned to each buffer pool you are using. This formula is useful for estimating a buffer pool that balances the following:</P>
<UL><LI><P class="docList">Workload</P></LI><LI><P class="docList">Throughput</P></LI><LI><P class="docList">Size of the DB2 subsystem</P></LI></UL>
<P class="docText">Workload is factored in by the average <TT>GETPAGE</TT>s per transaction and the number of concurrent users. As workload (in terms of both number of users and amount of resources consumed) increases, so does the number of users and the average <TT>GETPAGE</TT>s per transaction.<A NAME="ch28index314"></A><A NAME="ch28index315"></A></P>
<P class="docText">Throughput is determined by the desired number of transactions per second. The size of the buffer pool increases as you increase the desired number of transactions per second. Larger buffer pools are useful in helping to force more work through DB2.<A NAME="ch28index316"></A><A NAME="ch28index317"></A></P>
<P class="docText">The size of the DB2 subsystem is represented by the number of index leaf pages. As the number of DB2 applications grows, the number of indexes defined for them grows also, thereby increasing the number of index leaf pages as DB2 use expands.<A NAME="ch28index318"></A><A NAME="ch28index319"></A></P>
<P class="docText">Recommendations for determining some of these values follow. Use the value of <TT>CTHREAD</TT> to determine the number of concurrent users. If you are sure that your system rarely reaches this maximum, you can reduce your estimate for concurrent users.</P>
<P class="docText">To estimate the number of transactions per second, use values from service-level agreement contracts for your applications. If service-level agreements are unavailable, estimate this value based on your experience and DB2-PM accounting summary reports.</P>
<P class="docText">To get an idea of overall workload and processing spikes (such as month-end processing), produce accounting summary reports for peak activity periods (for example, the most active two-hour period) across several days and during at least five weeks. Then arrive at an average for total transactions processed during that period by adding the <TT># OCCUR</TT> from the <TT>GRAND TOTAL</TT> line of each report and dividing by the total number of reports you created. This number is, roughly, the average number of transactions processed during the peak period. Divide this number by 7200 (the number of seconds in two hours) for the average number of transactions per second. Then double this number because the workload is probably not evenly distributed throughout the course of the two hours. Also, do not use a number that is less than 10 transactions per second.</P>
<P class="docText">You can approximate the average number of <TT>GETPAGE</TT>s per transaction with the accounting summary or accounting detail reports (such as those provided by DB2 PM). Add all <TT>GETPAGE</TT>s for all transactions reported, and then divide this number by the total number of transactions reported. Base this estimate on transactions only—including batch programs would cause a large overestimate. Online transactions are generally optimized to read a small amount of data, whereas batch jobs can read millions of pages.<A NAME="ch28index320"></A><A NAME="ch28index321"></A><A NAME="ch28index322"></A><A NAME="ch28index323"></A></P>
<P class="docText">To determine the number of leaf pages for the indexes in your DB2 subsystem, issue the following query:</P>
<pre>

</pre><BR><pre>
SELECT   SUM(NLEAF)
FROM     SYSIBM.SYSINDEXES;
</pre><BR>
<P class="docText">For this query to work properly, <TT>RUNSTATS</TT> statistics should be up to date and any unused objects should be excluded (using a <TT>WHERE</TT> clause).</P>
<A NAME="ch28note04"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Keep in mind that the formula just discussed for estimating buffer pool requirements should be used as just a very rough guideline. If you have the resources at your disposal, you should carefully analyze your DB2 workload requirements by reviewing each transaction and batch program in conjunction with transaction history and your batch job schedules. You can then create a model for a typical processing day and design your buffer pool strategy to meet that model.<A NAME="ch28index324"></A><A NAME="ch28index325"></A><A NAME="ch28index326"></A><A NAME="ch28index327"></A></P>
<P class="docText">There are also tools on the market that can assist you in setting up and managing your buffer pools. Examples include BMC Software's Pool Advisor and Responsive Systems' Buffer Pool Tool.</P></div><br>
<A NAME="ch28lev2sec6"></A><H4 class="docSection2Title">DB2 Buffer Pool Guidelines</H4>
<P class="docText">You can use the following guidelines to ensure an effective DB2 buffer pool specification at your shop.</P>
<A NAME="ch28lev4sec4"></A><H5 class="docSection3Title">Be Aware of Buffer Pool Thresholds</H5>
<P class="docText">Be aware of the following overall effects of the buffer pool thresholds:<A NAME="ch28index328"></A><A NAME="ch28index329"></A><A NAME="ch28index330"></A></P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5"><COLGROUP><COL width="181.5"><COL width="368.5"></COLGROUP><THEAD></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><span class="docEmphasis">Data Manager Threshold</span></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">This is referred to as a critical buffer pool. When 95% of a buffer pool's pages are unavailable, the Buffer Manager does a <TT>GETPAGE</TT> and a release of the page for every accessed row. This is very inefficient and should be avoided at all costs.</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><span class="docEmphasis">Immediate Write Threshold</span></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">When 97.5% of a buffer pool's pages are unavailable, deferred write is disabled. All writes are performed synchronously until the percentage of unavailable pages is below 97.5%.<A NAME="ch28index331"></A><A NAME="ch28index332"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch28sb32"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Increase the size of your buffer pools when these thresholds are reached:</P>
<P class="docText">Data Manager threshold : 95%</P>
<P class="docText">Immediate Write threshold (<TT>IWTH</TT>): 97.5%</P>
<P class="docText">It is best to avoid reaching these thresholds because they degrade performance. (The immediate write threshold degrades performance the most.)</P></TD></TR></TABLE></P><br>
<A NAME="ch28lev4sec5"></A><H5 class="docSection3Title">Be Generous with Your Buffer Pool Allocations</H5>
<P class="docText">A buffer pool that is too large is almost always better than a buffer pool that is too small. However, do not make the buffer pool so large that it requires paging to DASD.<A NAME="ch28index333"></A><A NAME="ch28index334"></A><A NAME="ch28index335"></A></P>
<A NAME="ch28lev4sec6"></A><H5 class="docSection3Title">Monitor <TT>BP0</TT> Carefully</H5>
<P class="docText">The DB2 Catalog and DB2 Directory are assigned to <TT>BP0</TT>. This cannot be changed. Therefore, even if other buffer pools are used for most of your application tablespaces and indexes, pay close attention to <TT>BP0</TT>. A poorly performing DB2 Catalog or DB2 Directory can severely hamper system-wide performance.<A NAME="ch28index336"></A><A NAME="ch28index337"></A><A NAME="ch28index338"></A><A NAME="ch28index339"></A></P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> As of DB2 V8, similar precautions should be taken with <TT>BP8K0</TT> and <TT>BP16K0</TT>, as these buffer pools also house DB2 Catalog objects.</P></td></tr></table><br>
<A NAME="ch28lev4sec7"></A><H5 class="docSection3Title">Allocate <TT>BP32K</TT></H5>
<P class="docText">Specify a 32K buffer pool—even if you have no tablespaces in your system with 32K pages—to ensure that joins requiring more than 4K can operate. If <TT>BP32K</TT> is not defined, at least with a minimal number of pages, joins referencing columns that add up to 4097 or greater can fail.<A NAME="ch28index340"></A><A NAME="ch28index341"></A><A NAME="ch28index342"></A></P>
<P class="docText">The default size of <TT>BP32K</TT> is 12 pages, which is small, but perhaps a good starting place if you allow large joins. Some shops avoid allocating <TT>BP32K</TT> to ensure that large joins are not attempted. Avoiding <TT>BP32K</TT> allocation is also an option, depending on your shop standards.</P>
<A NAME="ch28lev4sec8"></A><H5 class="docSection3Title">Be Aware of the 32K Buffer Pool Names</H5>
<P class="docText">Remember that <TT>BP32</TT> and <TT>BP32K</TT> are two different buffer pools. <TT>BP32</TT> is one of the 50 4K buffer pools. <TT>BP32K</TT> is one of the 10 32K buffer pools. If you miss or add an erroneous <span class="docEmphasis">K</span>, you may wind up using or allocating the wrong buffer pool.<A NAME="ch28index343"></A><A NAME="ch28index344"></A><A NAME="ch28index345"></A><A NAME="ch28index346"></A><A NAME="ch28index347"></A><A NAME="ch28index348"></A></P>
<A NAME="ch28lev4sec9"></A><H5 class="docSection3Title">Consider Reserving a Buffer Pool for Tuning</H5>
<P class="docText">Even if you do not utilize multiple buffer pools, consider using your unused buffer pools for performance monitoring and tuning. When a performance problem is identified, tablespaces or indexes suspected of causing the problem can be altered to use the tuning buffer pool. Then you can turn on traces and rerun the application causing the performance problem. When monitoring the performance of the application, I/O, <TT>GETPAGE</TT>s, and the usage characteristics of the buffer pool can be monitored separately from the other buffer pools.<A NAME="ch28index349"></A><A NAME="ch28index350"></A><A NAME="ch28index351"></A></P>
<A NAME="ch28lev4sec10"></A><H5 class="docSection3Title">Consider Defining a Sort Buffer Pool for <TT>DSNDB07</TT></H5>
<P class="docText">If you assign <TT>DSNDB07</TT> to its own buffer pool, consider the appropriate parameters to use. First of all, the <TT>VPSEQT</TT> parameter is quite useful. Recall that <TT>VPSEQT</TT> is used to set the sequential steal threshold. Since most activity to <TT>DSNDB07</TT> is sequential, <TT>VPSEQT</TT> should be set very high, to <TT>95</TT> for example. But do not set <TT>VPSEQT</TT> to <TT>100</TT> because not all sorting activity is sequential.<A NAME="ch28index352"></A><A NAME="ch28index353"></A><A NAME="ch28index354"></A></P>
<P class="docText">Furthermore, you can set the immediate write thresholds (<TT>DWQT</TT> and <TT>VDWQT</TT>) to the <TT>VPSEQT</TT> size.</P>
<A NAME="ch28note05"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Setting the deferred write thresholds is tricky business. If you set them relatively high (for example, same as <TT>VPSEQT</TT>) you will maintain pages in the pools and avoid writes. However, you may want to specify very low deferred write thresholds to set up trickle write. This avoids the problems that can ensue when DB2 has to write a huge amount of data because the write was deferred. Different options will work for different companies based on your processing requirements.</P></div><br>
<P class="docText">Finally, it is a good idea to use the <TT>BP7</TT> buffer pool for <TT>DSNDB07</TT> so as to minimize confusion. Because both end in the number 7, it is easy to remember that one works with the other.</P>
<A NAME="ch28lev4sec11"></A><H5 class="docSection3Title">Optimize <TT>BP0</TT></H5>
<P class="docText"><TT>BP0</TT> is probably the single most important buffer pool in a DB2 subsystem. The system resources, namely the DB2 Catalog and DB2 Directory objects, are assigned to <TT>BP0</TT> and cannot be moved. Therefore, many organizations decide to use <TT>BP0</TT> to hold only these resources by failing to assign other objects to <TT>BP0</TT>. This is a good strategy because placing other objects into <TT>BP0</TT> can degrade the performance of processes that access the DB2 Catalog or Directory.<A NAME="ch28index355"></A><A NAME="ch28index356"></A><A NAME="ch28index357"></A><A NAME="ch28index358"></A></P>
<P class="docText">The size of your DB2 subsystem dictates the proper sizing of <TT>BP0</TT>. Consider starting with a <TT>VPSIZE</TT> of 2000 pages. Monitor usage of <TT>BP0</TT> and increase <TT>VPSIZE</TT> if access patterns warrant.</P>
<P class="docText">The proper specification of <TT>VPSEQT</TT>, <TT>DWQT</TT>, and <TT>VDWQT</TT> will depend on your shop's access patterns against the DB2 Catalog and Directory.</P>
<A NAME="ch28lev4sec12"></A><H5 class="docSection3Title">Converting Active Buffer Pool to Use Data Space</H5>
<P class="docText">For DB2 V7, you can use data spaces for virtual buffer pools. To convert an active DB2 virtual buffer pool to use a data space, perform the following steps:<A NAME="ch28index359"></A><A NAME="ch28index360"></A><A NAME="ch28index361"></A></P>
<A NAME="ch28pr01"></A>


<div style="font-weight:bold"><OL class="docList" START="1"><LI value="1"><div style="font-weight:normal">Delete the active buffer pool by using <TT>ALTER BUFFERPOOL</TT> to specify <TT>VPSIZE(0)</TT>.<BR><BR></div></LI><LI value="2"><div style="font-weight:normal">Stop all tablespaces and indexes that are using the buffer pool.<BR><BR></div></LI><LI value="3"><div style="font-weight:normal">Issue the <TT>ALTER BUFFERPOOL</TT> command again specifying <TT>VPTYPE(DATASPACE)</TT>. You will also need to specify the appropriate <TT>VPSIZE</TT> for the buffer pool.<BR><BR></div></LI></OL></div>
<P class="docText">Start all of the objects that were previously stopped.</P>
<P class="docText">The total size of data space virtual buffer pools is limited to 32GB (for 4K page size). This limit is imposed because there is a maximum of 8 million "page manipulation blocks" in the DBM1 address space.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> Data space virtual buffer pools are no longer supported as of DB2 Version 8.</P></td></tr></table><br>
<A NAME="ch28lev2sec7"></A><H4 class="docSection2Title">Hiperpools</H4>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> For DB2 V7 and earlier releases, you can use hiperpools to back up your virtual buffer pools. Hiperpools are no longer supported as of DB2 V8, though.<A NAME="ch28index362"></A><A NAME="ch28index363"></A><A NAME="ch28index364"></A></P></td></tr></table><br>
<P class="docText">Hiperpools can be considered extensions to the regular buffer pools, which are also referred to as virtual pools. Hiperpools use hiperspaces to extend DB2 virtual buffer pools. Working in conjunction with the virtual pools, hiperpools provide a second level of data caching. When old information is targeted to be discarded from (or, moved out of) the virtual buffer pool, it will be moved to the hiperpool instead (if a hiperpool has been defined for that buffer pool).</P>
<P class="docText">Only clean pages will be moved to the hiperpool, though. Clean pages are those in which the data that was modified has already been written back to DASD. No data with pending modifications will ever reside in a hiperpool.</P>
<P class="docText">Each of the 80 virtual pools can optionally have a hiperpool associated with it. There is a one-to-one relationship between virtual pools and hiperpools. A virtual pool can have one and only one hiperpool associated with it, but it also can have none. A hiperpool must have one and only one virtual pool associated with it.</P>
<P class="docText">Hiperpools are page-addressable, so before data can be accessed by an application, it must be moved from the hiperpool to the virtual pool (which is byte-addressable). Hiperpools are backed by expanded storage only, whereas virtual pools are backed by central storage, expanded storage, and possibly DASD if paging occurs. The hiperpool page control blocks reside in the DBM1 address space and thus contribute to virtual storage constraints.</P>
<P class="docText">When you specify a virtual pool without a hiperpool, you are letting the operating system allocate the buffer pool storage required in both central and expanded memory. Keeping this information in mind, consider using hiperpools instead of specifying extremely large virtual pools without a hiperpool.</P>
<P class="docText">A good reason to utilize hiperpools is to overcome the 1.6GB limit for all virtual buffer pools (prior to V8). If your buffering needs exceed 1.6GB, you can specify virtual buffer pools up to 1.6GB, with larger hiperpools backing the virtual pools. Of course, you can also consider using data spaces for your virtual pools if you are running in 64 bit mode.</P>
<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><IMG BORDER="0" width="30" height="18" SRC="images/0672326132/graphics/V8_icon.gif" ALT="graphics/V8_icon.gif"></td><td valign="top"><P class="docText"> Of course, the maximum buffer pool sizes were increased for DB2 V8 to the limit of the z/OS architecture, which is 1TB. (Also, the term "virtual" buffer pool is obsolete as of DB2 V8; virtual pool, virtual buffer pool, and buffer pool are all synonymous as of DB2 V8.)<A NAME="ch28index365"></A><A NAME="ch28index366"></A><A NAME="ch28index367"></A></P></td></tr></table><br>
<A NAME="ch28sb33"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">For pre-V8 systems, consider specifying virtual pools that will completely fit in central storage and hiperpools associated with the virtual pools. The DB2 Buffer Manager will handle the movement from expanded to central storage and should be more efficient than simply implementing a single large virtual pool. Of course, you will need to monitor the system to ensure that the virtual pool is utilizing central storage in an optimally efficient manner.</P>
<P class="docText">Do not over-allocate hiperpool storage. If you exceed the amount of expanded storage you have available, performance will eventually suffer.</P></TD></TR></TABLE></P><br>
<P class="docText"><A class="docLink" HREF="#ch28fig03">Figure 28.3</A> illustrates the buffer pool to hiperpool relationship. This diagram outlines the basic functionality of hiperpools and buffer pools. Data is read from disk to central storage in the virtual buffer pool. Over time the data may be moved to the hiperpool. Once moved to the hiperpool, before it can be read again by a DB2 program, it must be moved back to the virtual buffer pool. Hiperpools are backed by expanded storage as a hiperspace. Virtual buffer pools are backed by central and expanded storage, and can possibly page to DASD for auxiliary storage.<A NAME="ch28index368"></A><A NAME="ch28index369"></A><A NAME="ch28index370"></A></P>
<A NAME="ch28fig03"></A><p><CENTER><H5 class="docFigureTitle">Figure 28.3. Hiperpool to buffer pool relationship.</H5>
<p class="docText"><IMG BORDER="0" width="500" height="427" SRC="images/0672326132/graphics/28fig03.gif" ALT="graphics/28fig03.gif"></p></CENTER></p><br>
<A NAME="ch28note06"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">The total of all hiperpools defined cannot exceed 8GB.</P></div><br>
<A NAME="ch28lev3sec11"></A><H5 class="docSection3Title">Hiperpool Parameters</H5>
<P class="docText">The <TT>ALTER BUFFERPOOL</TT> command can be used to tune hiperpool options as well as virtual pool options. The hiperpool parameter options are described in the following paragraphs.<A NAME="ch28index371"></A><A NAME="ch28index372"></A><A NAME="ch28index373"></A><A NAME="ch28index374"></A><A NAME="ch28index375"></A><A NAME="ch28index376"></A></P>
<P class="docText">The first option, <TT>CASTOUT</TT>, indicates whether hiperpool pages are stealable by the operating system. The value can be either <TT>YES</TT> or <TT>NO</TT>. Specifying <TT>YES</TT> enables OS/390 to discard data in the hiperpool if an expanded storage shortage is encountered. A value of <TT>NO</TT> prohibits OS/390 from discarding hiperpool data unless one of the following occurs:<A NAME="ch28index377"></A><A NAME="ch28index378"></A></P>
<UL><LI><P class="docList">The hiperpool is deleted</P></LI><LI><P class="docList">Hiperspace maintenance occurs</P></LI><LI><P class="docList">Hiperspace storage is explicitly released</P></LI></UL>
<P class="docText">Just as <TT>VPSIZE</TT> controls the size of virtual pools, <TT>HPSIZE</TT> is used to specify the size of each individual hiperpool. When the size of a hiperpool is altered, it immediately expands or contracts as specified. The value can range from 0 to 2,097,152 for 4K hiperpools, from 0 to 1,048,576 for 8KB hiperpools, from 0 to 524,288 for 16KB hiperpools, and from 0 to 262,144 for 32K hiperpools. The total of all hiperpools defined cannot exceed 8GB.<A NAME="ch28index379"></A><A NAME="ch28index380"></A></P>
<A NAME="ch28sb34"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">A good starting point for <TT>HPSIZE</TT> is three times the amount of <TT>VPSIZE</TT>. If necessary, you can increase <TT>HPSIZE</TT> from there as you tune your buffer pool and hiperpool usage. Hiperpools allocated with less than three times the associated <TT>VPSIZE</TT> are usually not very efficient.</P></TD></TR></TABLE></P><br>
<P class="docText">Sequential steal thresholds also can be specified for hiperpools, using the <TT>HPSEQT</TT> parameter. <TT>HPSEQT</TT> is expressed as a percentage of the hiperpool size (<TT>HPSIZE</TT>). It specifies the percentage of the hiperpool that can be monopolized by sequential processing, such as sequential prefetch. The value of <TT>HPSEQT</TT> can range from <TT>0</TT> to <TT>100</TT>, and the default is <TT>80</TT>.<A NAME="ch28index381"></A><A NAME="ch28index382"></A></P>
<A NAME="ch28sb35"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">If you know that the majority of your sequential prefetch requests will never be accessed again, you may want to tune your hiperpools to avoid sequential data. Do this by specifying <TT>HPSEQT=0</TT>. This ensures that only randomly accessed data will be moved to the hiperpool.</P></TD></TR></TABLE></P><br>
<P class="docText">There are no deferred write thresholds for hiperpools because only clean data is stored in the hiperpool. Therefore, pages never need to be written from the hiperpool to DASD.<A NAME="ch28index383"></A><A NAME="ch28index384"></A><A NAME="ch28index385"></A><A NAME="ch28index386"></A></P>
<A NAME="ch28lev2sec8"></A><H4 class="docSection2Title">Data Sharing Group Buffer Pools</H4>
<P class="docText">If data sharing is implemented, group buffer pools are required. A group buffer pool must be defined for each buffer pool defined to each data sharing member. Data is cached from the local buffer pools to the group buffer pools during the processing of a data sharing request.<A NAME="ch28index387"></A><A NAME="ch28index388"></A><A NAME="ch28index389"></A><A NAME="ch28index390"></A></P>
<P class="docText">A page set is said to be GBP-dependent when two or more data sharing group members have concurrent read/write interest in it. The page set is marked as GBP-dependent during the update process and changed pages are written to the group buffer pool. GBP-dependent marking also affects DB2 Catalog and Directory page sets of the shared DB2 catalog. For GBP-dependent page sets, all changed pages are first written to the group buffer pool.</P>
<P class="docText">Changed data pages are written to the coupling facility at <TT>COMMIT</TT> for GBP-dependent page sets. This enables committed data to be immediately available to the other DB2 data sharing group members. It also extends the length of time it takes to commit and therefore makes it important to issue frequent <TT>COMMIT</TT>s in your programs.</P>
<P class="docText">The following describes a few typical operations and how a page is passed among the local and group buffer pools. The following scenario is based on a data sharing environment with two member subsystems (<TT>DB2A</TT> and <TT>DB2B</TT>):</P>
<UL><LI><P class="docList">An application in <TT>DB2A</TT> updates a column. The <TT>DB2A</TT> subsystem checks the coupling facility to determine if it should read the page from the global buffer pools or directly from disk. If <TT>DB2A</TT> determines that the page is not cached globally, it will read the page(s) from shared DASD and store the page(s) in its local buffer pool—for example, BP6.</P></LI><LI><P class="docList">An application in <TT>DB2B</TT> wants to update the same page. A global lock (P-Lock, discussed in <A class="docLink" HREF="ch23.html#ch23">Chapter 23</A>, "Locking DB2 Data") is taken indicating to the member that the page is shared. <TT>DB2A</TT> is notified and writes the changed data page to global buffer pool GBP6.</P></LI><LI><P class="docList"><TT>DB2B</TT> retrieves the page from the global buffer pools and puts it in its own BP6.</P></LI><LI><P class="docList"><TT>DB2B</TT> updates the data page and moves it back to the global buffer pool. The coupling facility invalidates the page contained in the local buffer pool for <TT>DB2A</TT>.</P></LI><LI><P class="docList">If <TT>DB2A</TT> needs to reread the data page, it will determine that the page has been marked invalid. Therefore, the page is retrieved from global buffer pool GBP6.<A NAME="ch28index391"></A><A NAME="ch28index392"></A><A NAME="ch28index393"></A><A NAME="ch28index394"></A></P></LI></UL>
<A NAME="ch28lev3sec12"></A><H5 class="docSection3Title">The <TT>GBPCACHE</TT> Parameter</H5>
<P class="docText">The <TT>GBPCACHE</TT> clause can be specified on the <TT>CREATE</TT> and <TT>ALTER</TT> statement for tablespaces and indexes. <TT>GBPCACHE</TT> is used to indicate how the global buffer pool is to be used for a particular tablespace or index. There are two options for <TT>GBPCACHE</TT>: <TT>CHANGED</TT> and <TT>ALL</TT>.<A NAME="ch28index395"></A><A NAME="ch28index396"></A><A NAME="ch28index397"></A><A NAME="ch28index398"></A></P>
<P class="docText">If <TT>CHANGED</TT> is specified, and the tablespace or index has no inter-DB2 read/write interest, the group buffer pool will not be used. When an inter-DB2 read/write interest exists, only changed pages are written to the group buffer pool.</P>
<P class="docText">If <TT>GBPCACHE</TT> is set to <TT>ALL</TT>, changed pages are written to the group buffer pool. Clean pages are written to the group buffer pool as they are read from the shared disk.</P>
<A NAME="ch28lev3sec13"></A><H5 class="docSection3Title">The Castout Process</H5>
<P class="docText">Changed data is moved from a group buffer pool to disk by means of a castout process. The group buffer pool castout process reads the pages contained in the GBP and writes them to the owning DB2's local buffer, as well as to the physical DASD devices. This process is depicted in <A class="docLink" HREF="#ch28fig04">Figure 28.4</A>. The castout process moves data from a group buffer pool to DASD through one of the data sharing group members. This is required because there is no direct connection from a coupling facility to DASD.<A NAME="ch28index399"></A><A NAME="ch28index400"></A><A NAME="ch28index401"></A></P>
<A NAME="ch28fig04"></A><p><CENTER><H5 class="docFigureTitle">Figure 28.4. The castout process.</H5>
<p class="docText"><IMG BORDER="0" width="500" height="490" SRC="images/0672326132/graphics/28fig04.gif" ALT="graphics/28fig04.gif"></p></CENTER></p><br>
<P class="docText">The coupling facility is still able to update pages during the castout process. The castout process is triggered when:</P>
<UL><LI><P class="docList">The changed page threshold for a page set is reached.</P></LI><LI><P class="docList">The total changed page threshold for the group buffer pool is reached.</P></LI><LI><P class="docList">The group buffer pool checkpoint is reached.<A NAME="ch28index402"></A><A NAME="ch28index403"></A><A NAME="ch28index404"></A><A NAME="ch28index405"></A></P></LI></UL>
<A NAME="ch28note07"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">Because the coupling facility may contain data that is more recent than what is contained on the DASD devices, DB2 employs coupling facility recovery mechanisms to recover the data in case of coupling facility failure.</P></div><br>
<A NAME="ch28lev2sec9"></A><H4 class="docSection2Title">Data Sharing Buffer Pool Guidelines</H4>
<P class="docText">Consider the following guidelines when specifying buffer pools for data sharing.</P>
<A NAME="ch28lev4sec13"></A><H5 class="docSection3Title">Select Group Buffer Pool Thresholds with Care</H5>
<P class="docText">The castout process can have a negative impact on data sharing performance. Keep castout process execution to a minimum by carefully considering the thresholds that are related to each group buffer pool. You can control the castout process by changing the two group buffer pool thresholds:<A NAME="ch28index406"></A><A NAME="ch28index407"></A><A NAME="ch28index408"></A></P>
<UL><LI><P class="docList">The group buffer pool castout threshold determines the total number of changed pages that can exist in the group buffer pool before castout occurs. DB2 casts out a sufficient amount of data to ensure that the number of changed pages is below the threshold. The group buffer pool castout threshold is specified as a percentage of the total number of pages in the group buffer pool. The default value is <TT>50</TT>, which specifies that castout is initiated when the group buffer pool is 50% full of changed pages.<A NAME="ch28index409"></A><A NAME="ch28index410"></A><A NAME="ch28index411"></A><A NAME="ch28index412"></A></P></LI><LI><P class="docList">The class castout threshold also is used to control when data is cast out of a group buffer pool. DB2 internally maps modified data pages belonging to the same tablespace, index, or partition to the same castout class queues. A castout class queue is an internal mechanism used by DB2 to control the castout process for groups of page sets. When DB2 writes modified pages to the group buffer pool, it determines how many modified pages are in a particular class castout queue. When the number of modified pages for a castout class queue exceeds the threshold, DB2 casts out data pages from that queue. The castout class threshold is specified as a percentage of the total number of changed pages in the group buffer pool for a given castout class. The default for the class castout is <TT>10</TT>, indicating that castout is initiated when 10% of the group buffer pool contains modified pages for the class.</P></LI></UL>
<A NAME="ch28lev4sec14"></A><H5 class="docSection3Title">Do Not Underestimate the Size of the Cache Structure</H5>
<P class="docText">The size of the group buffer pool structure has a major influence on the frequency of castout process execution. This can negatively affect performance.<A NAME="ch28index413"></A><A NAME="ch28index414"></A><A NAME="ch28index415"></A></P>
<P class="docText">The total cache structure size affects performance similar to the way that <TT>VPSIZE</TT> affects the performance of non-group buffer pools (virtual pools). In addition, the less memory allocated to the group buffer pool, the more frequent the castout process.</P>
<P class="docText">The number of directory entries also affects performance. A directory entry contains control information for one page regardless of the number of places that page is cached. There is a one-to-one correspondence between cached physical data pages and directory entries. If a page is in the group buffer pool and in the virtual buffer pools of two members, there is only one directory entry for the page. Each directory entry is 208 bytes for 4K pages and 264 bytes for 32K pages. A directory entry is used by the coupling facility to determine where to send cross-invalidation signals when a page of data is changed or when that directory entry must be reused. The higher the write-to-read ratio, the more directory entries are needed.</P>
<P class="docText">The final impact on performance is the number of data entries. Data entries are the actual places where the data page resides. The greater the number of distinct pages that are cached, the more directory entries are needed.</P>
<A NAME="ch28lev4sec15"></A><H5 class="docSection3Title">Use Partitioned Tablespaces</H5>
<P class="docText">Design for parallel processing by using partitioned tablespaces for data that is accessed in a data sharing environment. This encourages the use of Sysplex query parallelism. DB2 performs effective parallel processing only when data is partitioned.<A NAME="ch28index416"></A><A NAME="ch28index417"></A><A NAME="ch28index418"></A><A NAME="ch28index419"></A></P>
<A NAME="ch28lev4sec16"></A><H5 class="docSection3Title">Consider Group Buffer Pool Duplexing</H5>
<P class="docText">Use group buffer pool duplexing to make recovery easier. Without duplexing, your only options for recovery in the event of a group buffer pool failure were to recover the group buffer pool or to rebuild it. With duplexing, a secondary group buffer pool is available on standby in another coupling facility. The secondary group buffer pool can take over if the primary group buffer pool fails.<A NAME="ch28index420"></A><A NAME="ch28index421"></A><A NAME="ch28index422"></A></P>
<P class="docText">With a duplexed group buffer pool, you have two allocations of the same group buffer pool that use one logical connection. One allocation is called the primary structure, the other is the secondary structure. The primary structure is used for cross-invalidation and page registration, and it is the structure from which changed data is cast out to DASD. When changes are written to the primary structure, they are written to the secondary structure, as well.<A NAME="ch28index423"></A><A NAME="ch28index424"></A><A NAME="ch28index425"></A><A NAME="ch28index426"></A></P>
<A NAME="ch28lev2sec10"></A><H4 class="docSection2Title">IRLM Tuning Options</H4>
<P class="docText">Until now, I have covered tuning options for the DB2 database address space and system services address space. You also can tune the IRLM address space.<A NAME="ch28index427"></A><A NAME="ch28index428"></A><A NAME="ch28index429"></A></P>
<P class="docText">When the IRLM is started, several parameters can be specified in the JCL for the IRLM. These options can have a significant effect on DB2 performance.</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5"><COLGROUP><COL width="93.5"><COL width="456.5"></COLGROUP><THEAD></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DEADLOK</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Indicates when the IRLM executes a deadlock detection cycle. The IRLM must check for deadlocks frequently to avoid long waits for resources that will never be made available.<A NAME="ch28index430"></A><A NAME="ch28index431"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>ITRACE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Indicates whether an IRLM trace will be started.<A NAME="ch28index432"></A><A NAME="ch28index433"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PC</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Indicates where IRLM locks will be stored in memory.<A NAME="ch28index434"></A><A NAME="ch28index435"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch28sb36"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">A good starting value for the <TT>DEADLOK</TT> parameter is 15 seconds. However, this parameter should be evenly divisible into the <TT>IRLMRWT</TT> DSNZPARM value to ensure synchronization between IRLM deadlock detection and DB2 timeout waits.</P></TD></TR></TABLE></P><br>
<A NAME="ch28sb37"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Never issue an IRLM trace for an IRLM used by DB2. Specify <TT>ITRACE=NO</TT>. The IRLM trace rapidly degrades performance and does not provide much useful information.</P></TD></TR></TABLE></P><br>
<A NAME="ch28sb38"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Specify <TT>PC=NO</TT>. This guarantees that cross memory services are not used for DB2 locking. Instead, locks are stored in ECSA and are directly addressable. This will optimize the locking performance.<A NAME="ch28index436"></A><A NAME="ch28index437"></A><A NAME="ch28index438"></A></P>
<P class="docText">Before using ECSA to store IRLM locks, though, be aware that ECSA is not protected and an erratic system task can potentially overwrite ECSA storage.</P></TD></TR></TABLE></P><br>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch28.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch28lev1sec2.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
