<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Tuning the Application</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch28lev1sec2.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch28lev1sec4.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch28lev1sec3"></A><H3 class="docSection1Title" >Tuning the Application</H3>
<P class="docText">As was evident from the DB2 performance tuning pie, tuning the application design provides the single greatest benefit to overall DB2 performance. You can use several methods to accomplish this, each of which is covered in this section. Before proceeding, however, I will review the access paths, particularly the information about filter factors.<A NAME="ch28index450"></A><A NAME="ch28index451"></A></P>
<A NAME="ch28lev2sec11"></A><H4 class="docSection2Title">Analyzing Access Paths</H4>
<P class="docText">To determine the actual "behind the scenes" operations being performed by DB2 for each SQL statement, you must analyze the access path chosen for the statement by the DB2 optimizer. An access path, as discussed in <A class="docLink" HREF="ch21.html#ch21">Chapter 21</A>, "The Optimizer," is the method DB2 chooses to carry out the data manipulation requested in SQL statements. The DB2 <TT>EXPLAIN</TT> statement places information about the access paths in a <TT>PLAN_TABLE</TT>, which can be inspected by a technical analyst. You can use the information in <A class="docLink" HREF="ch25.html#ch25">Chapter 25</A> in conjunction with the access path data to create a complete picture of the operations being performed for each SQL statement.<A NAME="ch28index452"></A><A NAME="ch28index453"></A><A NAME="ch28index454"></A></P>
<P class="docText">Is DB2 on its own when making access path determinations? The ideal answer to this question would be "Yes." It would be wonderful if DB2 always had all the information it needed, required no external input, and never chose the wrong access path. However, we do not yet live in this ideal world. DB2 sometimes chooses an inefficient access path over another, more efficient one for the following reasons:</P>
<UL><LI><P class="docList">The statistics might be outdated if <TT>RUNSTATS</TT> was never run or not run recently. This causes the access paths to be chosen based on incorrect assumptions about the current environment.</P></LI><LI><P class="docList">Certain physical parameters are not yet taken into account by the optimizer when it determines access paths. Some examples are differences between physical storage devices (the model of DASD device, or faster devices), the number of data set extents, and COBOL (or other 3GL and 4GL) code.</P></LI><LI><P class="docList">Concurrent processes (scheduling) are not considered by the optimizer.</P></LI><LI><P class="docList">The DB2 optimizer is prone to the same problems associated with every computer program; it is fallible. (However, given its complexity, its success rate is admirable.)</P></LI></UL>
<P class="docText">For these reasons, you may decide to artificially influence the optimizer's decision process. Techniques for accomplishing this are addressed in the next section.</P>
<P class="docText">Before I move on, I will survey the factors addressed by the DB2 optimizer. The first consideration is the versions of DB2 that are being used—they should be the same in test and production. Obviously, there are access path techniques available to newer releases of DB2 than were available to older releases.</P>
<P class="docText">The optimizer takes the size of the buffer pools into account when determining access paths. As the size of the buffer pools increases, DB2 assumes that read efficiency increases also.</P>
<P class="docText">The optimizer also takes into account the type of CPU being used during access path selection. DB2 chooses different access techniques based on the perceived performance of the processor. This is important to remember when modeling SQL in a test DB2 subsystem using production statistics. If the production DB2 subsystem has a different number of buffers or if it runs on a different CPU, the optimizer might choose a different access path in the production environment than it did in the test environment, even if the SQL and the DB2 Catalog statistics are identical.<A NAME="ch28index455"></A><A NAME="ch28index456"></A><A NAME="ch28index457"></A></P>
<P class="docText">To get around this, the following measures can be taken:</P>
<UL><LI><P class="docList">When evaluating access paths for SQL statements using production statistics, be sure that the test DB2 subsystem is using the same CPU or a different CPU of the same type. This may be difficult for larger shops with several DB2 subsystems running on various machines, all configured differently.</P></LI><LI><P class="docList">Specify test DB2 buffer pools to be the same as the production buffer pools to ensure that access paths do not change as a result of different buffer pool sizes. However, setting test buffer pools as high as production buffer pools can waste memory resources, and setting production buffer pools as low as test buffer pools will degrade performance.</P></LI></UL>
<P class="docText">The wisest course of action is simply to realize that access path differences will exist between DB2 subsystems and not to try to avoid access path discrepancies between DB2 subsystems. Running DB2 subsystems with artificial constraints such as those just outlined is counterproductive to optimizing DB2 performance. Just remember that a test access path determined using production statistics does not guarantee that the production access path will be identical. Besides, it is wise to continuously monitor the production access paths for all SQL statements, because they can change when plans or packages are bound or rebound, or when <TT>RUNSTATS</TT> is run for dynamic SQL.<A NAME="ch28index458"></A><A NAME="ch28index459"></A><A NAME="ch28index460"></A></P>
<A NAME="ch28sb40"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Analyze <span class="docEmphasis">all</span> production DB2 access paths. Some shops analyze only the access paths for static SQL embedded in application programs, but this is inadequate. Develop a plan for analyzing all components of DB2 programs, including the following:<A NAME="ch28index461"></A><A NAME="ch28index462"></A><A NAME="ch28index463"></A></P>
<UL><LI><P class="docList">The structure of the application program to ensure that proper coding techniques are used. Also be sure that otherwise efficient-looking SQL embedded in a program loop does not occur without a proper reason. In other words, a finely-tuned SQL statement inside of a loop that runs two million times is likely to cause performance problems.</P></LI><LI><P class="docList">All SQL, whether static or dynamic, embedded in application programs. This includes SQL in online transactions, batch programs, client/server programs, report writers, 4GLs, CASE tools, decision support systems, and packaged applications.</P></LI><LI><P class="docList">All regularly executed or critical ad hoc, dynamic SQL. This includes, but is not necessarily limited to, SQL executed by SPUFI, QMF, <TT>DSNTIAD</TT>, <TT>DSNTIAUL</TT>, or <TT>DSNTEP2</TT>, SQL generated by any application system "on the fly," dynamic SQL in packaged applications, SQL generated or submitted using vendor tools, data warehouse queries, and SQL shipped from remote sites, including remote mainframes, minis, and PC workstations.</P></LI><LI><P class="docList">All stored procedure and user-defined function programs that contain SQL.</P></LI><LI><P class="docList">All SQL in triggers. When a trigger is created DB2 also creates a trigger package but no <TT>EXPLAIN</TT> data. To <TT>EXPLAIN</TT> the trigger package you will need to <TT>REBIND</TT> it specifying <TT>EXPLAIN YES</TT>.</P></LI><LI><P class="docList">Every SQL statement in the DB2 program must be followed by a check of the <TT>SQLCODE</TT> or <TT>SQLSTATE</TT>.</P></LI></UL></TD></TR></TABLE></P><br>
<P class="docText">If you utilize triggers in your DB2 databases, you need to be aware that code exists within the triggers. This code needs to be examined regularly to ensure that it is optimal given the database design and the application processes that modify the data, causing the trigger to fire. Even if the SQL in the trigger is efficient, other processes performed by the trigger may not be efficient.<A NAME="ch28index464"></A><A NAME="ch28index465"></A><A NAME="ch28index466"></A></P>
<A NAME="ch28lev2sec12"></A><H4 class="docSection2Title">Influencing the Optimizer</H4>
<P class="docText">There are several methods of tuning the system to change access paths or influence access path selection. This section describes several observations on changing the access paths selected by DB2.<A NAME="ch28index467"></A><A NAME="ch28index468"></A><A NAME="ch28index469"></A><A NAME="ch28index470"></A></P>
<P class="docText">The DB2 optimizer is one of the most intricate pieces of software on the market. It does an admirable job of optimizing SQL requests. To achieve this level of success, the optimizer contains a great deal of performance-specific expertise. For example, the optimizer estimates both elapsed times and CPU times when choosing an access path. When a SQL statement is rebound, the optimizer might choose a new access path that increases CPU time but decreases elapsed time. Most shops choose to enhance elapsed time at the expense of additional CPU use because elapsed time has a measurable effect on user productivity. In other words, it is good to trade off CPU cycles for user satisfaction, and the DB2 optimizer attempts to accomplish this. Of course, if both CPU and elapsed time can be reduced, the optimizer will try to do so.</P>
<P class="docText">However, the optimizer is not infallible. Sometimes the application analyst understands the nature of the data better than DB2 (at the present time). You can influence the optimizer into choosing an access path that you know is a better one but the optimizer thinks is a worse one. As the functionality and complexity of the optimizer is enhanced from release to release of DB2, the need to trick the optimizer in this way will diminish.</P>
<P class="docText">There are five ways to influence the optimizer's access path decisions:</P>
<UL><LI><P class="docList">Standard, DB2-based methods</P></LI><LI><P class="docList">Tweaking SQL statements</P></LI><LI><P class="docList">Specifying the <TT>OPTIMIZE FOR </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS</TT> clause</P></LI><LI><P class="docList">Updating DB2 Catalog statistics</P></LI><LI><P class="docList">Using <TT>OPTHINT</TT> to indicate that an access path in the <TT>PLAN_TABLE</TT> should be chosen</P></LI></UL>
<P class="docText">The next section discusses each of these methods.<A NAME="ch28index471"></A><A NAME="ch28index472"></A></P>
<A NAME="ch28lev3sec14"></A><H5 class="docSection3Title">Standard Methods</H5>
<P class="docText">Of all the methods for influencing the DB2 optimizer, standard DB2 methods are the only mandatory ones. Try all the standard methods covered in this section before attempting one of the other methods. There are several reasons for this.<A NAME="ch28index473"></A><A NAME="ch28index474"></A><A NAME="ch28index475"></A><A NAME="ch28index476"></A></P>
<P class="docText">The standard methods place the burden for generating optimal access paths on the shoulders of DB2, which is where it usually belongs. They also use IBM-supported techniques available for every version and release of DB2. Finally, these methods generally provide the greatest gain for the smallest effort.</P>
<P class="docText">There are four standard methods for tuning DB2 access paths. The first method is ensuring that accurate statistics are available using the <TT>RUNSTATS</TT> utility and the <TT>BIND</TT> or <TT>REBIND</TT> command. <TT>RUNSTATS</TT>, which is discussed in detail in <A class="docLink" HREF="ch34.html#ch34">Chapter 34</A>, "Catalog Manipulation Utilities," populates the DB2 Catalog with statistics that indicate the state of your DB2 objects, including the following:</P>
<BLOCKQUOTE><P><P class="docList">Their organization</P></P><P><P class="docList">Clustering information</P></P><P><P class="docList">The cardinality of tablespaces, tables, columns, and indexes</P></P><P><P class="docList">The range of values for columns</P></P></BLOCKQUOTE>
<P class="docText">All of these factors are considered by the optimizer when it chooses what it deems to be the optimal access path for a given SQL statement.</P>
<A NAME="ch28sb41"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Execute <TT>RUNSTATS</TT> at least once for every tablespace, table, column, and index known to your DB2 subsystem. Schedule regular <TT>RUNSTATS</TT> executions for all DB2 objects that are not read-only. This keeps the DB2 Catalog information current, enabling proper access path selection.</P></TD></TR></TABLE></P><br>
<P class="docText">The second standard method for tuning DB2 access paths is ensuring that the DB2 objects are properly organized. Disorganized objects, if properly reorganized, might be chosen for an access path. An object is disorganized when data modification statements executed against the object cause data to be stored in a non-optimal fashion, such as non-clustered data or data that exists on a different page than its RID, thereby spanning more than one physical page. To organize these objects more efficiently, run the <TT>REORG</TT> utility, followed by <TT>RUNSTATS</TT> and <TT>REBIND</TT>. In-depth coverage of the <TT>REORG</TT> utility and guidelines for its use are in <A class="docLink" HREF="ch33.html#ch33">Chapter 33</A>, "Data Organization Utilities."<A NAME="ch28index477"></A><A NAME="ch28index478"></A><A NAME="ch28index479"></A><A NAME="ch28index480"></A></P>
<A NAME="ch28sb42"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Use the DB2 Catalog queries in <A class="docLink" HREF="ch26.html#ch26">Chapter 26</A>, "DB2 Object Monitoring Using the DB2 Catalog and RTS," to determine when your DB2 tablespaces and indexes need to be reorganized:</P>
<UL><LI><P class="docList">Reorganize a tablespace when the <TT>CLUSTERRATIO</TT> of its clustering index falls below 95%. (Schedule this so that it does not affect system performance and availability.)</P></LI><LI><P class="docList">Reorganize any index (or index partition) when <TT>LEAFDIST</TT> is greater than 200. If the value of <TT>FREEPAGE</TT> for the index is not 0, reorganize only when <TT>LEAFDIST</TT> is greater than 300. Of course, you should not blindly reorganize indexes when they reach these thresholds. You  should weigh the observed performance degradation against the cost of running the index reorganization jobs before reorganizing your application's indexes.<A NAME="ch28index481"></A><A NAME="ch28index482"></A><A NAME="ch28index483"></A><A NAME="ch28index484"></A></P></LI><LI><P class="docList">Reorganize all DB2 tablespaces and indexes when their data set is in multiple physical extents. Before reorganizing, ensure that space allocations have been modified to cause all data to be stored in a single extent.</P></LI></UL>
<P class="docText">You may want to reorganize more frequently than indicated here by creating scheduled <TT>REORG</TT> jobs for heavily accessed or critical DB2 tablespaces and indexes. This limits performance problems due to disorganized DB2 objects and reduces the number of reorganizations that must be manually scheduled or submitted by a DBA or performance analyst.</P></TD></TR></TABLE></P><br>
<P class="docText">The third standard method for tuning DB2 access paths is to encourage parallelism. Consider changing simple and segmented tablespaces to partitioned tablespaces to encourage I/O, CPU, and Sysplex parallelism. Furthermore, it may be advantageous to repartition already partitioned tablespaces to better align ranges of values, thereby promoting better parallel access.<A NAME="ch28index485"></A><A NAME="ch28index486"></A><A NAME="ch28index487"></A><A NAME="ch28index488"></A></P>
<P class="docText">The fourth and final standard method for tuning DB2 access paths is ensuring that there are proper indexes by creating new indexes or dropping unnecessary and unused indexes. DB2 relies on indexes to achieve optimum performance.</P>
<P class="docText">Analyze the predicates in your SQL statements to determine whether there is an index that DB2 can use. Indexes can be used efficiently by DB2 if the first column of the index key is specified in an indexable predicate in the SQL statement. Refer to <A class="docLink" HREF="ch02.html#ch02">Chapter 2</A>, "Data Manipulation Guidelines," for a discussion of indexable and non-indexable predicates. If no index meets these requirements, consider creating one. As you index more columns referenced in predicates, performance generally increases.</P>
<P class="docText">Dropping unused indexes is another critical part of application tuning. Every table <TT>INSERT</TT> and <TT>DELETE</TT> incurs I/O to every index defined for that table. Every <TT>UPDATE</TT> of indexed columns incurs I/O to every index defined for that column. If an index is not being used, drop it. This reduces the I/O incurred for data modification SQL statements, reduces <TT>RUNSTATS</TT> resource requirements, and speeds <TT>REORG</TT> and <TT>RECOVER</TT> processing.<A NAME="ch28index489"></A><A NAME="ch28index490"></A><A NAME="ch28index491"></A><A NAME="ch28index492"></A></P>
<A NAME="ch28lev3sec15"></A><H5 class="docSection3Title">Tweaking the SQL Statement</H5>
<P class="docText">If you do not want to change the DB2 Catalog statistics but the standard methods outlined in the preceding section are not helpful, you might consider tweaking the offending SQL statement. <span class="docEmphasis">Tweaking</span> is the process of changing a statement in a non-intuitive fashion, without altering its functionality.<A NAME="ch28index493"></A><A NAME="ch28index494"></A><A NAME="ch28index495"></A><A NAME="ch28index496"></A></P>
<P class="docText">At times, you may need to disable a specific index from being considered by the optimizer. One method of achieving this is to append <TT>OR 0 = 1</TT> to the predicate. For example, consider a query against the <TT>EMP</TT> table on which two indexes exist: one on <TT>EMPNO</TT> and one on <TT>WORKDEPT</TT>. Appending <TT>OR 0 = 1</TT> (as shown next) to the <TT>WORKDEPT</TT> predicate will cause DB2 to avoid using an index on <TT>WORKDEPT</TT>.</P>
<pre>

</pre><BR><pre>
SELECT  EMPNO, WORKDEPT, EDLEVEL, SALARY
FROM    DSN8610.EMP
WHERE   EMPNO BETWEEN '000020' AND '000350'
AND     (WORKDEPT &gt; 'A01' OR 0 = 1);
</pre><BR>
<P class="docText">The <TT>OR 0 = 1</TT> clause does not change the results of the query, but it can change the access path chosen.</P>
<P class="docText">Another method of tweaking SQL to influence DB2's access path selection is to code redundant predicates. Recall from <A class="docLink" HREF="ch21.html#ch21">Chapter 21</A> that when DB2 calculates the filter factor for a SQL statement, it multiplies the filter factors for all predicates connected with <TT>AND</TT>.</P>
<A NAME="ch28sb43"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">You can lower the filter factor of a query by adding redundant predicates as follows:</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="groups" CELLPADDING="5"><COLGROUP><COL width="137.5"><COL width="137.5"><COL width="137.5"><COL width="137.5"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">Change this statement</span></P></TH><TH class="bottomBorder thead" align="left" valign="top"><P class="docText"><span class="docEmphStrong">To this</span></P></TH><TH class="bottomBorder thead" align="left" valign="top">&nbsp;</TH><TH class="bottomBorder thead" align="left" valign="top">&nbsp;</TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SELECT</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>LASTNAME</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SELECT</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>LASTNAME</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>FROM</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DSN8810.EMP</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>FROM</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DSN8810.EMP</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>WHERE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>WORKDEPT = :VAR</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>WHERE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>WORKDEPT = :VAR</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>AND</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>WORKDEPT = :VAR</TT></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>AND</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>WORKDEPT = :VAR</TT></P></TD></TR></TABLE></P><br>
<P class="docText">The two predicates added to the end are redundant and do not affect SQL statement functionally. However, DB2 calculates a lower filter factor, which increases the possibility that an index on the <TT>WORKDEPT</TT> column will be chosen. The lower filter factor also increases the possibility that the table will be chosen as the outer table, if the redundant predicates are used for a join.</P></TD></TR></TABLE></P><br>
<A NAME="ch28sb44"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">When redundant predicates are added to enhance performance, as outlined in the preceding strategy, be sure to document the reasons for the extra predicates. Failure to do so may cause a maintenance programmer to assume that the redundant predicates are an error and thus remove them.<A NAME="ch28index497"></A><A NAME="ch28index498"></A></P></TD></TR></TABLE></P><br>
<P class="docText">Another option for getting a small amount of performance out of an SQL statement is to change the physical order of the predicates in your SQL code. DB2 evaluates predicates first by predicate type, then according to the order in which it encounters the predicates. The four types of SQL predicates are listed in the order that DB2 processes them:</P>
<BLOCKQUOTE><P><P class="docList">Equality, in which a column is tested for equivalence to another column, a variable, or a literal</P></P><P><P class="docList">Ranges, in which a column is tested against a range of values (for example, greater than, less than, or <TT>BETWEEN</TT>)</P></P><P><P class="docList"><TT>IN</TT>, where a column is tested for equivalence against a list of values</P></P><P><P class="docList">Stage 2 predicates<A NAME="ch28index499"></A><A NAME="ch28index500"></A><A NAME="ch28index501"></A><A NAME="ch28index502"></A></P></P></BLOCKQUOTE>
<A NAME="ch28sb45"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Place the most restrictive predicates at the beginning of your predicate list. For example, consider the following query:<A NAME="ch28index503"></A><A NAME="ch28index504"></A></P>
<pre>

</pre><BR><pre>
SELECT   LASTNAME
FROM     DSN8810.EMP
WHERE    WORKDEPT = 'A00'
AND      SEX = 'M'
</pre><BR>
<P class="docText">The first predicate has a lower filter factor than the second because there are fewer workers in department <TT>A00</TT> than there are males in the entire company. This does not increase performance by much, but it can shave a little off a query's processing time.</P></TD></TR></TABLE></P><br>
<P class="docText">Before deciding to tweak SQL statements to achieve different access paths, remember that you are changing SQL code in a nonintuitive fashion. For each modification you make to increase performance, document the reasons in the program, the data dictionary, and the system documentation. Otherwise, the tweaked SQL could be maintained after it is no longer required, or modified away when it still is required for performance.</P>
<P class="docText">Also remember that the changes could enhance performance for one release of DB2 but result in no gain or decreased efficiency in subsequent releases. Re-examine your SQL for each new version and release of DB2.<A NAME="ch28index505"></A><A NAME="ch28index506"></A><A NAME="ch28index507"></A><A NAME="ch28index508"></A></P>
<A NAME="ch28lev3sec16"></A><H5 class="docSection3Title"><TT>OPTIMIZE FOR </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS</TT></H5>
<P class="docText">Another method of influencing access path selection is to specify <TT>OPTIMIZE FOR </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS</TT> for a cursor <TT>SELECT</TT> statement. This clause enables programmers to specify the estimated maximum number of rows that will be retrieved.<A NAME="ch28index509"></A><A NAME="ch28index510"></A><A NAME="ch28index511"></A><A NAME="ch28index512"></A></P>
<P class="docText">By indicating that a different number of rows will be returned than DB2 anticipates, you can influence access path selection. For example, consider the following statement:</P>
<pre>

</pre><BR><pre>
EXEC SQL
    DECLARE OPT_CUR FOR
        SELECT   WORKDEPT, EMPNO, SALARY
        FROM     DSN8810.EMP
        WHERE    WORKDEPT IN ('A00', 'D11')
        OPTIMIZE FOR 5 ROWS
END-EXEC.
</pre><BR>
<P class="docText">The number of rows to be returned has been set to 5, even though this query could return more than 5 rows. DB2 formulates an access path optimized for 5 rows. More rows can be retrieved, but performance could suffer if you greatly exceed the estimated maximum.</P>
<P class="docText">This type of tuning is preferable to both updating the DB2 Catalog statistics and tweaking the SQL statement. It provides more information to DB2's optimization process, thereby giving DB2 the opportunity to establish a better access path. The crucial point, though, is that DB2 is doing the optimization; no manual updates or artificial SQL constructs are required.</P>
<A NAME="ch28sb46"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">When using the <TT>OPTIMIZE FOR </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS</TT> clause, make <span class="docEmphasis"><TT>n</TT></span> as accurate as possible. An accurate estimate gives DB2 the best opportunity to achieve optimum performance for the statement and also helps document the purpose of the SQL statement. Using an accurate value for <span class="docEmphasis"><TT>n</TT></span> also positions your application to take advantage of future enhancements to the <TT>OPTIMIZE FOR </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS</TT> clause.<A NAME="ch28index513"></A><A NAME="ch28index514"></A><A NAME="ch28index515"></A><A NAME="ch28index516"></A></P>
<P class="docText">When coding online transactions in which 25 rows (for example) are displayed on the screen, use the <TT>OPTIMIZE FOR </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS</TT> clause, setting <span class="docEmphasis"><TT>n</TT></span> equal to 25.</P></TD></TR></TABLE></P><br>
<A NAME="ch28note08"></A><div class="docNote"><p class="docNoteTitle">NOTE</p>

<P class="docText">When using <TT>OPTIMIZE FOR </TT><span class="docEmphasis"><TT>n</TT></span> <TT>ROWS</TT> to disable list prefetch, set the value of <span class="docEmphasis"><TT>n</TT></span> to 1. This technique works well to ensure that list prefetch is not used.</P></div><br>
<A NAME="ch28note09"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">DB2 uses the value of <span class="docEmphasis"><TT>n</TT></span> for the block size of a distributed network request. The smaller the value of <span class="docEmphasis"><TT>n</TT></span>, the fewer rows sent across the network for each block. The only exception is that when <span class="docEmphasis"><TT>n</TT></span>=1, DB2 will set the block size to 16.<A NAME="ch28index517"></A><A NAME="ch28index518"></A><A NAME="ch28index519"></A><A NAME="ch28index520"></A></P></div><br>
<A NAME="ch28lev3sec17"></A><H5 class="docSection3Title">Changing DB2 Catalog Statistics</H5>
<P class="docText">When the standard methods of influencing DB2's access path selection are not satisfactory, you can resort to updating the statistics in the DB2 Catalog. Only certain DB2 Catalog statistics can be modified using SQL <TT>UPDATE</TT>, <TT>INSERT</TT>, and <TT>DELETE</TT> statements instead of the normal method using <TT>RUNSTATS</TT>. This SQL modification of the DB2 Catalog can be performed only by a SYSADM.<A NAME="ch28index521"></A><A NAME="ch28index522"></A><A NAME="ch28index523"></A><A NAME="ch28index524"></A><A NAME="ch28index525"></A></P>
<P class="docText"><A class="docLink" HREF="#ch28table03">Table 28.3</A> lists the DB2 Catalog statistics that can be modified. You can use this table to determine which DB2 Catalog columns are updateable (using SQL) and which are used by the optimizer during sequential and parallel access path determination. Remember, for parallel queries, the sequential access path is generated and only then is the parallel access strategy generated.</P>
<A NAME="ch28table03"></A><P><TABLE CELLSPACING="0" FRAME="hsides" RULES="groups" CELLPADDING="5"><CAPTION><h5 class="docTableTitle">Table 28.3. The Updateable DB2 Catalog Statistics</h5></CAPTION><COLGROUP><COL width="132"><COL width="143"><COL width="60.5"><COL width="214.5"></COLGROUP><THEAD><TR><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><span class="docEmphStrong">Catalog Table</span></P></TH><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><span class="docEmphStrong">Column</span><A NAME="ch28index526"></A><A NAME="ch28index527"></A><A NAME="ch28index528"></A><A NAME="ch28index529"></A></P></TH><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><span class="docEmphStrong">How Used?</span></P></TH><TH class="bottomBorder thead" align="left" valign="bottom"><P class="docText"><span class="docEmphStrong">Description</span></P></TH></TR></THEAD><TR><TD class="docTableCell" align="left" valign="top" rowspan="7"><P class="docText"><TT>SYSCOLDIST</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>FREQUENCYF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Percentage that <TT>COLVALUE</TT> in the column named in <TT>NAME</TT> occurs<A NAME="ch28index530"></A><A NAME="ch28index531"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COLVALUE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Column value for this statistic</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CARDF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of distinct values</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COLGROUPCOLNO</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">The set of columns for the statistics</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>NUMCOLUMNS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of columns for the statistics</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>TYPE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Type of stats: <TT>C</TT> for cardinality, or <TT>F</TT> for frequent value</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>STATSTIME</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Indicates the time <TT>RUNSTATS</TT> was run to generate these statistics</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top" rowspan="8"><P class="docText"><TT>SYSCOLDISTSTATS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PARTITION</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">The partition to which this statistic applies<A NAME="ch28index532"></A><A NAME="ch28index533"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>FREQUENCYF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Percentage that <TT>COLVALUE</TT> in the column named in <TT>NAME</TT> occurs</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COLVALUE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Column value for this statistic</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>TYPE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Type of statistics (cardinality or frequent value)</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CARDF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of distinct values</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COLGROUPCOLNO</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">The set of columns for the statistics</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>KEYCARDDATA</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Representation of the estimate of distinct values in this partition</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>STATSTIME</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Indicates the time <TT>RUNSTATS</TT> was run to generate these statistics</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top" rowspan="7"><P class="docText"><TT>SYSCOLSTATS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>LOWKEY</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">P</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Lowest value for the column<A NAME="ch28index534"></A><A NAME="ch28index535"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>LOW2KEY</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">P</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Second lowest value for the column</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>HIGHKEY</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">P</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Highest value for the column</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>HIGH2KEY</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">P</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Second highest value for the column</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COLCARD</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">P</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of distinct values for the column</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COLCARDDATA</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">P</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of distinct values for the column</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>STATSTIME</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Indicates the time <TT>RUNSTATS</TT> was run to generate these statistics</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top" rowspan="4"><P class="docText"><TT>SYSCOLUMNS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>LOW2KEY</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Second lowest value for the column<A NAME="ch28index536"></A><A NAME="ch28index537"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>HIGH2KEY</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Second highest value for the column</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>COLCARDF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of distinct values for the column</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>STATSTIME</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Indicates the time <TT>RUNSTATS</TT> was run to generate these statistics<A NAME="ch28index538"></A><A NAME="ch28index539"></A><A NAME="ch28index540"></A><A NAME="ch28index541"></A><A NAME="ch28index542"></A><A NAME="ch28index543"></A><A NAME="ch28index544"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top" rowspan="7"><P class="docText"><TT>SYSINDEXES</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CLUSTERRATIOF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Percentage of rows in clustered order</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CLUSTERED</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Indicates whether the tablespace is actually clustered<A NAME="ch28index545"></A><A NAME="ch28index546"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>FIRSTKEYCARDF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of distinct values for the first column of the index key</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>FULLKEYCARDF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of distinct values for the full index key</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>NLEAF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of active leaf pages</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>NLEVELS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of index b-tree levels</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>STATSTIME</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Indicates the time <TT>RUNSTATS</TT> was run to generate these statistics</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top" rowspan="6"><P class="docText"><TT>SYSINDEXPART</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DSNUM</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of data sets</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>EXTENTS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of data set extents<A NAME="ch28index547"></A><A NAME="ch28index548"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>LEAFFAR</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of leaf pages far from previous leaf page</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>LEAFNEAR</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of leaf pages near previous leaf page</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PSEUDO_DEL_ENTRIES</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of pseudo deleted index keys</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SPACEF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Disk storage space</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top" rowspan="8"><P class="docText"><TT>SYSINDEXSTATS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CLUSTERRATIOF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Percentage of rows in clustered order</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>FIRSTKEYCARDF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of distinct values for the first column of the index key<A NAME="ch28index549"></A><A NAME="ch28index550"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>FULLKEYCARDF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of distinct values for the full index key</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>FULLKEYCARDDATA</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Representation of number of distinct values of the full key</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>NLEAF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of active leaf pages</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>NLEVELS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of index b-tree levels</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>KEYCOUNTF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of rows in the partition</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>STATSTIME</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Indicates the time <TT>RUNSTATS</TT> was run to generate these statistics</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top" rowspan="3"><P class="docText"><TT>SYSLOBSTATS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>AVGSIZE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Average size of LOB<A NAME="ch28index551"></A><A NAME="ch28index552"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>FREESPACE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Available space in the LOB tablespace</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>ORGRATIO</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Ratio of disorganization for LOB tablespace</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top" rowspan="5"><P class="docText"><TT>SYSROUTINES</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>IOS_PER_INVOC</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Estimated number of I/Os per invocation of the routine<A NAME="ch28index553"></A><A NAME="ch28index554"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INSTS_PER_INVOC</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Estimated number of instructions per invocation of the routine</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INITIAL_IOS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Estimated number of I/Os for the first invocation of the routine<A NAME="ch28index555"></A><A NAME="ch28index556"></A><A NAME="ch28index557"></A><A NAME="ch28index558"></A><A NAME="ch28index559"></A><A NAME="ch28index560"></A><A NAME="ch28index561"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>INITIAL_INSTS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Estimated number of instructions for the first invocation of the routine</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CARDINALITY</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Predicted cardinality of a table function</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top" rowspan="3"><P class="docText"><TT>SYSTABLEPART</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>DSNUM</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of data sets</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>EXTENTS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of data set extents<A NAME="ch28index562"></A><A NAME="ch28index563"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SPACEF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Disk storage space</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top" rowspan="8"><P class="docText"><TT>SYSTABLES</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CARDF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of rows for a table<A NAME="ch28index564"></A><A NAME="ch28index565"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>NPAGES</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of pages used by the table</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>NPAGESF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of pages used by the table</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PCTPAGES</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Percentage of tablespace pages that contain rows for this table</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PCTROWCOMP</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Percentage of rows compressed</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>AVGROWLEN</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Average row length</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>SPACEF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Disk storage space</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>STATSTIME</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Indicates the time <TT>RUNSTATS</TT> was run to generate these statistics</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top" rowspan="2"><P class="docText"><TT>SYSTABLESPACE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>NACTIVEF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Y</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of allocated tablespace pages<A NAME="ch28index566"></A><A NAME="ch28index567"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>STATSTIME</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Indicates the time <TT>RUNSTATS</TT> was run to generate these statistics</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top" rowspan="6"><P class="docText"><TT>SYSTABSTATS</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>CARDF</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">P</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of rows for the partition<A NAME="ch28index568"></A><A NAME="ch28index569"></A></P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>NPAGES</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">P</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of pages used by the partition</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>NACTIVE</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">P</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Number of active pages in the partition</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PCTPAGES</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">P</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Percentage of tablespace pages that contain rows for this partition</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>PCTROWCOMP</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">P</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Percentage (x100) of rows compressed</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><P class="docText"><TT>STATSTIME</TT></P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">N</P></TD><TD class="docTableCell" align="left" valign="top"><P class="docText">Indicates the time <TT>RUNSTATS</TT> was run to generate these statistics<A NAME="ch28index570"></A><A NAME="ch28index571"></A><A NAME="ch28index572"></A><A NAME="ch28index573"></A><A NAME="ch28index574"></A><A NAME="ch28index575"></A><A NAME="ch28index576"></A></P></TD></TR><TR><TD class="docTableFooter" valign="top" colspan="4"><P class="docText">Legend:</P>
<P class="docText">N = Not used by the optimizer</P>
<P class="docText">P = Used for parallel path generation</P>
<P class="docText">Y = Used by the optimizer</P></TD></TR></TABLE></P><br>
<P class="docText">The two predominant reasons for changing DB2 Catalog statistics to influence the access path selection are to influence DB2 to use an index and to influence DB2 to change the order in which tables are joined. In each case, the tuning methods require that you "play around" with the DB2 Catalog statistics to create a lower filter factor. You should keep in mind five rules when doing so.</P>
<BLOCKQUOTE><P><p class="docText"><span class="docEmphasis">Rule 1</span>: 
As first key cardinality (<TT>FIRSTKEYCARDF</TT>) increases, the filter factor decreases. As the filter factor decreases, DB2 is more inclined to use an index to satisfy the SQL statement.<A NAME="ch28index577"></A><A NAME="ch28index578"></A><A NAME="ch28index579"></A><A NAME="ch28index580"></A></p></P><P><p class="docText"><span class="docEmphasis">Rule 2</span>: 
As an index becomes more clustered, you increase the probability that DB2 will use it. To enhance the probability of an unclustered index being used, increase its cluster ratio (<TT>CLUSTERRATIOF</TT>) to a value between 96 and 100, preferably 100.<A NAME="ch28index581"></A><A NAME="ch28index582"></A><A NAME="ch28index583"></A><A NAME="ch28index584"></A><A NAME="ch28index585"></A><A NAME="ch28index586"></A><A NAME="ch28index587"></A><A NAME="ch28index588"></A></p><A NAME="ch28sb47"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">To influence DB2 to use an index, adjust the <TT>COLCARDF</TT>, <TT>FIRSTKEYCARDF</TT>, and <TT>FULLKEYCARDF</TT> columns to an artificially high value. As cardinality increases, the filter factor decreases. As the filter factor decreases, the chance that DB2 will use an available index becomes greater. DB2 assumes that a low filter factor means that only a few rows are being returned, causing indexed access to be more efficient. Adjusting <TT>COLCARDF</TT>, <TT>FIRSTKEYCARDF</TT>, and <TT>FULLKEYCARDF</TT> is also useful for getting DB2 to choose an unclustered index because DB2 is more reluctant to use an unclustered index with higher filter factors. You also can change the value of <TT>CLUSTERRATIOF</TT> to 100 to remove DB2's reluctance to use unclustered indexes from the access path selection puzzle.</P></TD></TR></TABLE></P><br></P><P><p class="docText"><span class="docEmphasis">Rule 3</span>: 
DB2's choice for inner and outer tables is a delicate trade-off. Because the inner table is accessed many times for each qualifying outer table row, it should be as small as possible to reduce the time needed to scan multiple rows for each outer table row. The more inner table rows, the longer the scan. But the outer table should also be as small as possible to reduce the overhead of opening and closing the internal cursor on the inner table.<A NAME="ch28index589"></A><A NAME="ch28index590"></A><A NAME="ch28index591"></A><A NAME="ch28index592"></A><A NAME="ch28index593"></A><A NAME="ch28index594"></A><A NAME="ch28index595"></A></p><P class="docList">It is impossible to choose the smallest table as both the inner table and the outer table. When two tables are joined, one must be chosen as the inner table, and the other must be chosen as the outer table. My experience has shown that as the size of a table grows, the DB2 optimizer favors using it as the outer table in a nested loop join. Therefore, changing the cardinality (<TT>CARDF</TT>) of the table that you want as the outer table to an artificially high value can influence DB2 to choose that table as the outer table.</P></P><P><p class="docText"><span class="docEmphasis">Rule 4</span>: 
As column cardinality (<TT>COLCARDF</TT>) decreases, DB2 favors the use of the nested loop join over the merge scan join. Lower the value of <TT>COLCARDF</TT> to favor the nested loop join.<A NAME="ch28index596"></A><A NAME="ch28index597"></A><A NAME="ch28index598"></A><A NAME="ch28index599"></A></p></P><P><p class="docText"><span class="docEmphasis">Rule 5</span>: 
<TT>HIGH2KEY</TT> and <TT>LOW2KEY</TT> can be altered to more accurately reflect the overall range of values stored in a column. This is particularly useful for influencing access path selection for data with a skewed distribution.<A NAME="ch28index600"></A><A NAME="ch28index601"></A><A NAME="ch28index602"></A></p></P></BLOCKQUOTE>
<P class="docText">The combination of <TT>HIGH2KEY</TT> and <TT>LOW2KEY</TT> provides a range of probable values accessed for a particular column. The absolute highest and lowest values are discarded to create a more realistic range. For certain types of predicates, DB2 uses the following formula when calculating filter factor:</P>
<pre>

</pre><BR><pre>
Filter factor = (Value-LOW2KEY) / (HIGH2KEY-LOW2KEY)
</pre><BR>
<P class="docText">Because <TT>HIGH2KEY</TT> and <TT>LOW2KEY</TT> can affect the size of the filter factor, the range of values that they provide can significantly affect access path selection.<A NAME="ch28index603"></A><A NAME="ch28index604"></A><A NAME="ch28index605"></A></P>
<A NAME="ch28sb48"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">For troublesome queries, check whether the distribution of data in the columns accessed is skewed. If you query <TT>SYSIBM.SYSCOLDIST</TT>, as discussed in <A class="docLink" HREF="ch26.html#ch26">Chapter 26</A>, the 10 most frequently occurring values are shown for indexed columns. To be absolutely accurate, however, obtain a count for each column value, not just the top 10:</P>
<pre>

</pre><BR><pre>
SELECT     COL, COUNT(*)
FROM       your.table
GROUP BY   COL
ORDER BY   COL
</pre><BR>
<P class="docText">This query produces an ordered listing of column values. You can use this list to determine the distribution of values. If a few values occur much more frequently than the other values, the data is not evenly distributed. In this circumstance, consider using dynamic SQL, hard coding predicate values, or binding with <TT>REOPT(VARS)</TT>. This enables DB2 to use nonuniform distribution statistics when calculating filter factors.<A NAME="ch28index606"></A><A NAME="ch28index607"></A><A NAME="ch28index608"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch28sb49"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Referring back to the results of the query in the preceding tuning strategy, if a few values are at the beginning or end of the report, consider changing <TT>LOW2KEY</TT> and <TT>HIGH2KEY</TT> to different values. DB2 uses <TT>LOW2KEY</TT> and <TT>HIGH2KEY</TT> when calculating filter factors. So, even though the valid domain of small integers is –32768 to +32767, the valid range for access path selection is defined by <TT>LOW2KEY</TT> and <TT>HIGH2KEY</TT>, which may set the range to +45 to +1249, for example. As the range of values decreases, the filter factor decreases because there are fewer potential values in the range of values.<A NAME="ch28index609"></A><A NAME="ch28index610"></A><A NAME="ch28index611"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch28sb50"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">If neither dynamic SQL nor hard-coded predicates are practical, change <TT>HIGH2KEY</TT> to a lower value and <TT>LOW2KEY</TT> to a higher value to reduce the range of possible values, thereby lowering the filter factor. Alternatively, or additionally, you can increase <TT>COLCARDF</TT>, <TT>FIRSTKEYCARDF</TT>, and <TT>FULLKEYCARDF</TT>.<A NAME="ch28index612"></A><A NAME="ch28index613"></A><A NAME="ch28index614"></A></P></TD></TR></TABLE></P><br>
<P class="docText">Remember that modifying DB2 Catalog statistics is not a trivial exercise. Simply making the changes indicated in this section might be insufficient to resolve your performance problems because of DB2's knowledge of the DB2 Catalog statistics. Some statistical values have implicit relationships. When one value changes, DB2 assumes that the others have changed also. For example, consider these relationships:<A NAME="ch28index615"></A><A NAME="ch28index616"></A><A NAME="ch28index617"></A></P>
<UL><LI><P class="docList">When you change <TT>COLCARDF</TT> for a column in an index, be sure to also change the <TT>FIRSTKEYCARDF</TT> of any index in which the column participates as the first column of the index key, and the <TT>FULLKEYCARDF</TT> of any index in which the column participates.</P></LI><LI><P class="docList">Provide a value to both <TT>HIGH2KEY</TT> and <TT>LOW2KEY</TT> when you change cardinality information. When <TT>COLCARDF</TT> is not –1, DB2 assumes that statistics are available. DB2 factors these high and low key values into its access path selection decision. Failure to provide both a <TT>HIGH2KEY</TT> and a <TT>LOW2KEY</TT> can result in the calculation of inaccurate filter factors and the selection of inappropriate access paths.<A NAME="ch28index618"></A><A NAME="ch28index619"></A><A NAME="ch28index620"></A></P></LI></UL>
<P class="docText">Before deciding to update DB2 Catalog statistics to force DB2 to choose different access paths, heed the following warnings.</P>
<P class="docText">First, never change the DB2 Catalog statistics without documenting the following:<A NAME="ch28index621"></A><A NAME="ch28index622"></A><A NAME="ch28index623"></A><A NAME="ch28index624"></A></P>
<UL><LI><P class="docList">Why the statistics will be modified</P></LI><LI><P class="docList">How the modifications will be made and how frequently the changes must be run</P></LI><LI><P class="docList">The current values for each statistic and the values they will be changed to</P></LI></UL>
<P class="docText">Secondly, be aware that when you change DB2 Catalog statistics, you are robbing from Peter to pay Paul. In other words, your changes might enhance the performance of one query at the expense of the performance of another query.</P>
<P class="docText">DB2 maintenance (PTFs, new releases, and new versions) might change the access path selection logic in the DB2 optimizer. As a result of applying maintenance, binding or rebinding static and dynamic SQL operations could result in different access paths, thereby invalidating your hard work. In other words, IBM might get around to correcting the problem in the logic of the optimizer (that you solved using trickery).<A NAME="ch28index625"></A><A NAME="ch28index626"></A><A NAME="ch28index627"></A><A NAME="ch28index628"></A></P>
<P class="docText">Choosing the correct values for the statistics and keeping the statistics accurate can be an intimidating task. Do not undertake this endeavor lightly. Plan to spend many hours changing statistics, rebinding plans, changing statistics again, rebinding again, and so on.<A NAME="ch28index629"></A><A NAME="ch28index630"></A><A NAME="ch28index631"></A></P>
<P class="docText">The situation that caused the need to tinker with the statistics in the DB2 Catalog could change. For example, the properties of the data could vary as your application ages. Distribution, table and column cardinality, and the range of values stored could change. If the statistics are not changing because they have been artificially set outside the jurisdiction of <TT>RUNSTATS</TT>, these newer changes to the data cannot be considered by the DB2 optimizer, and an inefficient access path could be used indefinitely.</P>
<A NAME="ch28sb51"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">When DB2 Catalog statistics have been changed to influence access path selection, periodically execute <TT>RUNSTATS</TT> and rebind to determine if the artificial statistics are still required. If they are, simply reissue the DB2 Catalog <TT>UPDATE</TT> statements. If not, eliminate this artificial constraint from your environment. Failure to implement this strategy eventually results in inefficient access paths in your environment (as DB2 and your applications mature).<A NAME="ch28index632"></A><A NAME="ch28index633"></A><A NAME="ch28index634"></A><A NAME="ch28index635"></A></P></TD></TR></TABLE></P><br>
<P class="docText">Only a <TT>SYSADM</TT> can update the DB2 Catalog. <TT>SYSADM</TT>s have a great amount of authority, so it is generally a good idea to limit the number of <TT>SYSADM</TT>s in your shop. When the DB2 Catalog needs to be altered, an undue burden is placed on the <TT>SYSADM</TT>s.<A NAME="ch28index636"></A><A NAME="ch28index637"></A><A NAME="ch28index638"></A><A NAME="ch28index639"></A></P>
<P class="docText">When the DB2 Catalog has been updated using SQL, all subsequent <TT>RUNSTATS</TT> executions must be followed by a series of SQL statements to reapply the updates to the DB2 Catalog.</P>
<A NAME="ch28sb52"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">If possible, give a single production userid <TT>SYSADM</TT> authority for modifying DB2 Catalog statistics. This userid has the following requirements:</P>
<UL><LI><P class="docList">Should not have online TSO logon capabilities because only batch jobs need to be run using it<A NAME="ch28index640"></A><A NAME="ch28index641"></A><A NAME="ch28index642"></A><A NAME="ch28index643"></A></P></LI><LI><P class="docList">Should be under the same strict controls placed on production jobs at your site</P></LI><LI><P class="docList">Should be used to run only DB2 Catalog update jobs</P></LI></UL>
<P class="docText">A DBA or some other knowledgeable user can then create <TT>UPDATE</TT> statements to change the DB2 Catalog statistics as desired. A batch job running under the authid for the production <TT>SYSADM</TT> can then run the <TT>UPDATE</TT> statements in production. Because the <TT>SYSADM</TT> userid has no logon capabilities, the possibility for abuse is limited to the controls placed on the production environment (such as who can update production job streams, who can submit them, or what review process is in place).<A NAME="ch28index644"></A><A NAME="ch28index645"></A><A NAME="ch28index646"></A></P></TD></TR></TABLE></P><br>
<A NAME="ch28lev3sec18"></A><H5 class="docSection3Title">Using Optimization Hints (<TT>OPTHINT</TT>) to Force an Access Path</H5>
<P class="docText">You also can influence access paths using the <TT>OPTHINT</TT> feature. Actually, though, this method does not "influence" the access path; instead it directs DB2 to use a specific access path instead of determining a new access path using statistics. IBM refers to this process as specifying optimization hints.<A NAME="ch28index647"></A><A NAME="ch28index648"></A><A NAME="ch28index649"></A><A NAME="ch28index650"></A></P>
<A NAME="ch28note10"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">The same basic cautions that apply to modifying DB2 Catalog statistics also apply to optimization hints. Only experienced analysts and DBAs should attempt to use optimization hints. However, optimization hints are much easier to apply than updating DB2 Catalog statistics.</P></div><br>
<P class="docText">Optimization hints are implemented using the <TT>PLAN_TABLE</TT>. However, before you can use optimization hints, the DB2 DSNZPARM parameter for optimization hints (<TT>OPTHINTS</TT>) must be set to <TT>YES</TT>. If it is set to <TT>NO</TT>, you cannot use optimization hints.<A NAME="ch28index651"></A><A NAME="ch28index652"></A><A NAME="ch28index653"></A><A NAME="ch28index654"></A><A NAME="ch28index655"></A></P>
<P class="docText">There are two ways to use the <TT>PLAN_TABLE</TT> to provide an optimization hint to DB2:</P>
<UL><LI><P class="docList">Alter the <TT>PLAN_TABLE</TT> to use an access path that was previously created by the DB2 optimizer</P></LI><LI><P class="docList"><TT>INSERT</TT> rows to the <TT>PLAN_TABLE</TT> to create a new access path independently</P></LI></UL>
<P class="docText">In general, favor the first method over the second method. It is a difficult task to create an accurate access path in the <TT>PLAN_TABLE</TT>. If you do not get every nuance of the access path correct, it is possible that DB2 will ignore the optimization hint and calculate an access path at bind time. However, if you use an access path that was originally created by DB2, you can be reasonably sure that the access path will be valid.</P>
<A NAME="ch28note11"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">Sometimes an access path created for an older version of DB2 will not be valid in a newer version of DB2. Of course, the opposite is true, too. Some access paths for a newer version of DB2 will not work for older versions.</P></div><br>
<P class="docText">You should consider using optimization hints for all of the same reasons you would choose to modify DB2 Catalog statistics or tweak SQL. The general reason is to bypass the access path chosen by DB2 and use a different, hopefully more efficient, access path.<A NAME="ch28index656"></A><A NAME="ch28index657"></A></P>
<P class="docText">In addition to this reason, optimization hints are very useful as you migrate from release to release of DB2. Sometimes, a new release or version of DB2 can cause different access paths to be chosen for queries that were running fine. Or perhaps new statistics were accumulated between binds causing access paths to change. By saving old access paths in a <TT>PLAN_TABLE</TT>, you can use optimization hints to direct DB2 to use the old access paths instead of the new, and perhaps undesirable, access paths due to the new release orstatistics.</P>
<P class="docText">Always test and analyze the results of any query that uses optimization hints to be sure that the desired performance is being achieved.<A NAME="ch28index658"></A><A NAME="ch28index659"></A><A NAME="ch28index660"></A><A NAME="ch28index661"></A></P>
<A NAME="ch28lev4sec17"></A><H5 class="docSection4Title">Defining an Optimization Hint</H5>
<P class="docText">To specify that an optimization hint is to be used, you will have to update the <TT>PLAN_TABLE</TT>. The first step is to make sure that your <TT>PLAN_TABLE</TT> includes the following columns:<A NAME="ch28index662"></A><A NAME="ch28index663"></A><A NAME="ch28index664"></A><A NAME="ch28index665"></A></P>
<pre>

</pre><BR><pre>
OPTHINT              CHAR(8)   NOT NULL WITH DEFAULT
HINT_USED            CHAR(8)   NOT NULL WITH DEFAULT
PRIMARY_ACCESSTYPE   CHAR(1)   NOT NULL WITH DEFAULT
</pre><BR>
<P class="docText">For more information on the <TT>PLAN_TABLE</TT> and a definition of all <TT>PLAN_TABLE</TT> columns, refer to <A class="docLink" HREF="ch25.html#ch25">Chapter 25</A>, "Using EXPLAIN."</P>
<P class="docText">To set an optimization hint, you need to first identify (or create) the <TT>PLAN_TABLE</TT> rows that refer to the desired access path. You will then need to update those rows in the <TT>PLAN_TABLE</TT>, specifying an identifier for the hint in the <TT>OPTHINT</TT> column. For example,</P>
<pre>

</pre><BR><pre>
UPDATE PLAN_TABLE
   SET OPTHINT = 'SQLHINT'
WHERE  PLANNO = 50
AND    APPLNAME = 'PLANNAME';
</pre><BR>
<P class="docText">Of course, this is just an example. You may need to use other predicates to specifically identify the <TT>PLAN_TABLE</TT> rows to include in the optimization hint. Some columns that might be useful, depending on your usage of dynamic SQL and packages, include <TT>QUERYNO</TT>, <TT>PROGNAME</TT>, <TT>VERSION</TT>, and <TT>COLLID</TT>.</P>
<A NAME="ch28note12"></A><div class="docNote"><p class="docNoteTitle">CAUTION</p>

<P class="docText">If you change a program that uses static SQL statements, the statement number might change, causing rows in the <TT>PLAN_TABLE</TT> to be out of sync with the modified application.</P></div><br>
<P class="docText">You can use the <TT>QUERYNO</TT> clause in SQL statements to ease correlation of SQL statements in your program with your optimization hints. Statements that use the <TT>QUERYNO</TT> clause are not dependent on the statement number. To use <TT>QUERYNO</TT>, you will need to modify the SQL in your application to specify a <TT>QUERYNO</TT>, as shown in the following:</P>
<pre>

</pre><BR><pre>
SELECT MGRNO
FROM   DEPT
WHERE  DEPNO = 'A00'
QUERYNO 200;
</pre><BR>
<P class="docText">You can then <TT>UPDATE</TT> the <TT>PLAN_TABLE</TT> more easily using <TT>QUERYNO</TT> and be sure that the optimization hint will take effect, as shown in the following:</P>
<pre>

</pre><BR><pre>
UPDATE PLAN_TABLE
   SET OPTHINT = 'SQLHINT'
WHERE  QUERYNO = 200
AND    APPLNAME = 'PLANNAME';
</pre><BR>
<P class="docText">When the <TT>PLAN_TABLE</TT> is correctly updated (as well as possibly the application), you must <TT>REBIND</TT> the plan or package to determine if the hint is being used by DB2. When rebinding you must specify the <TT>OPTHINT</TT> parameter:</P>
<pre>

</pre><BR><pre>
REBIND PLAN PLANNAME . . . OPTHINT(SQLHINT)
</pre><BR>
<P class="docText">Be aware that the optimization hints may not actually be used by DB2. For optimization hints to be used, the hint must be correctly specified, the <TT>REBIND</TT> must be accurately performed, and the environment must not have changed. For example, DB2 will not use an access path specified using an optimization hint if it relies on an index that has since been dropped.</P>
<P class="docText">Use <TT>EXPLAIN(YES)</TT> to verify whether the hint was actually used. If the hint was used, the <TT>HINT_USED</TT> column for the new access path will contain the name of the optimization hint (such as <TT>SQLHINT</TT> in the previous example).<A NAME="ch28index666"></A><A NAME="ch28index667"></A><A NAME="ch28index668"></A><A NAME="ch28index669"></A></P>
<A NAME="ch28lev2sec13"></A><H4 class="docSection2Title">Miscellaneous Guidelines</H4>
<P class="docText">The following miscellaneous guidelines provide you with useful general tips for improving DB2 performance.</P>
<A NAME="ch28lev4sec18"></A><H5 class="docSection3Title">Favor Optimization Hints Over Updating the DB2 Catalog</H5>
<P class="docText">Optimization hints to influence access paths are less intrusive and easier to implement than changing columns in the DB2 Catalog. However, use optimization hints only as a last resort. Do not use optimization  hints as a crutch to arrive at a specific access path. Optimization hints are best used when an access path changes and you want to go back to a previous, efficient access path.<A NAME="ch28index670"></A><A NAME="ch28index671"></A><A NAME="ch28index672"></A><A NAME="ch28index673"></A><A NAME="ch28index674"></A></P>
<A NAME="ch28lev4sec19"></A><H5 class="docSection3Title">Limit Ordering to Avoid Scanning</H5>
<P class="docText">The optimizer is more likely to choose an index scan when ordering is important (<TT>ORDER BY</TT>, <TT>GROUP BY</TT>, or <TT>DISTINCT</TT>) and the index is clustered by the columns to be sorted.<A NAME="ch28index675"></A><A NAME="ch28index676"></A><A NAME="ch28index677"></A></P>
<A NAME="ch28lev4sec20"></A><H5 class="docSection3Title">Maximize Buffers and Minimize Data Access</H5>
<P class="docText">If the inner table fits in 2% of the buffer pool, the nested loop join is favored. Therefore, to increase the chances of nested loop joins, increase the size of the buffer pool (or decrease the size of the inner table, if possible).<A NAME="ch28index678"></A><A NAME="ch28index679"></A><A NAME="ch28index680"></A></P>
<A NAME="ch28lev2sec14"></A><H4 class="docSection2Title">Consider Deleting Nonuniform Distribution Statistics</H4>
<P class="docText">To decrease wild fluctuations in the performance of dynamic SQL statements, consider removing the nonuniform distribution statistics (NUDS) from the DB2 Catalog. Although dynamic SQL makes the best use of these statistics, the overall performance of some applications that heavily use dynamic SQL can suffer. The optimizer might choose a different access path for the same dynamic SQL statement, depending on the values supplied to the predicates. In theory, this should be the desired goal. In practice, however, the results might be unexpected.<A NAME="ch28index681"></A><A NAME="ch28index682"></A><A NAME="ch28index683"></A><A NAME="ch28index684"></A><A NAME="ch28index685"></A></P>
<P class="docText">For example, consider the following dynamic SQL statement:</P>
<pre>

</pre><BR><pre>
SELECT   EMPNO, LASTNAME
FROM     DSN8810.EMP
WHERE    WORKDEPT = ?
</pre><BR>
<P class="docText">The access path might change depending on the value of <TT>WORKDEPT</TT> because the optimizer calculates different filter factors for each value, based on the distribution statistics. As the number of occurrences of distribution statistics increases, the filter factor decreases. This makes DB2 think that fewer rows will be returned, which increases the chance that an index will be used and affects the choice of inner and outer tables for joins.</P>
<P class="docText">These statistics are stored in the <TT>SYSIBM.SYSCOLDIST</TT> and <TT>SYSIBM.SYSCOLDISTSTATS</TT> tables and can be removed using SQL <TT>DELETE</TT> statements.</P>
<P class="docText">This suggested guideline does not mean that you should always delete the NUDS. My advice is quite to the contrary. When using dynamic SQL, allow DB2 the chance to use these statistics. Delete these statistics only when performance is unacceptable. (They can always be repopulated later with <TT>RUNSTATS</TT>.)</P>
<A NAME="ch28lev4sec21"></A><H5 class="docSection3Title">Consider Collecting More Than Just the Top Ten NUDS</H5>
<P class="docText">If non-uniform distribution impacts more than just the top ten most frequently occurring values, you should consider using the <TT>FREQVAL</TT> option of <TT>RUNSTATS</TT> to capture more than 10 values. Capture only as many as will prove to be useful for optimizing queries against the non-uniformly distributed data.<A NAME="ch28index686"></A><A NAME="ch28index687"></A><A NAME="ch28index688"></A><A NAME="ch28index689"></A><A NAME="ch28index690"></A></P>
<A NAME="ch28lev2sec15"></A><H4 class="docSection2Title">DB2 Referential Integrity Use</H4>
<P class="docText">Referential integrity (RI) is the implementation of constraints between tables so that values from one table control the values in another. Recall that a referential constraint between a parent table and a dependent table is defined by a relationship between the columns of the tables. The parent table's primary key columns control the values permissible in the dependent table's foreign key columns. For example, in the sample table, <TT>DSN8810.EMP</TT>, the <TT>WORKDEPT</TT> column (the foreign key) must reference a valid department as defined in the <TT>DSN8810.DEPT</TT> table's <TT>DEPTNO</TT> column (the primary key).<A NAME="ch28index691"></A><A NAME="ch28index692"></A><A NAME="ch28index693"></A><A NAME="ch28index694"></A></P>
<P class="docText">You have two options for implementing RI at your disposal: declarative and application. Declarative constraints provide DB2-enforced referential integrity and are specified by DDL options. All modifications, whether embedded in an application program or ad hoc, must comply with the referential constraints.<A NAME="ch28index695"></A><A NAME="ch28index696"></A><A NAME="ch28index697"></A><A NAME="ch28index698"></A></P>
<P class="docText">Application-enforced referential integrity is coded into application programs. Every program that can update referentially constrained tables must contain logic to enforce the referential integrity. This type of RI is not applicable to ad hoc updates.<A NAME="ch28index699"></A><A NAME="ch28index700"></A></P>
<P class="docText">With DB2-enforced RI, CPU use is reduced because the Data Manager component of DB2 performs DB2-enforced RI checking, whereas the RDS component of DB2 performs application-enforced RI checking. Additionally, rows accessed for RI checking when using application-enforced RI must be passed back to the application from DB2. DB2-enforced RI does not require this passing of data, further reducing CPU time.<A NAME="ch28index701"></A><A NAME="ch28index702"></A></P>
<P class="docText">In addition, DB2-enforced RI uses an index (if one is available) when enforcing the referential constraint. In application-enforced RI, index use is based on the SQL used by each program to enforce the constraint.</P>
<A NAME="ch28sb53"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">DB2-enforced referential integrity is generally more efficient than application-enforced RI. When you build new applications, use DB2-enforced referential integrity and consider retrofitting older applications that require performance tuning.</P>
<P class="docText">Declarative RI has the further benefit that it cannot be bypassed, like application-enforced RI.<A NAME="ch28index703"></A><A NAME="ch28index704"></A><A NAME="ch28index705"></A><A NAME="ch28index706"></A></P>
<P class="docText">Triggers also can be used to implement complex RI and data integrity rules. Triggers, like declarative RI, cannot be bypassed by ad hoc SQL. All SQL data modification, whether static or dynamic, planned or ad hoc, must conform to the trigger logic.</P></TD></TR></TABLE></P><br>
<A NAME="ch28sb54"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">If no ad hoc updating is permitted, consider using application-based RI in the following two situations:</P>
<UL><LI><P class="docList">If an application program can be written so that a single check is made for a row from the parent table, when multiple inserts to the child table are performed.</P></LI><LI><P class="docList">If the application processing needs are such that the parent table is read before inserting the child (even one child), DB2 just repeats the read process that the application must do anyway.</P></LI></UL>
<P class="docText">Of course, application-enforced RI still has the negative aspect of not being enforced for ad hoc data modifications.</P></TD></TR></TABLE></P><br>
<A NAME="ch28sb55"></A><P><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">TUNING STRATEGY</H2>
<P class="docText">Consider not implementing DB2-enforced or application-enforced RI in the following cases:</P>
<UL><LI><P class="docList">If DB2 tables are built from another system that is already referentially intact</P></LI><LI><P class="docList">If application tables are accessed as read-only<A NAME="ch28index707"></A><A NAME="ch28index708"></A><A NAME="ch28index709"></A><A NAME="ch28index710"></A></P></LI></UL></TD></TR></TABLE></P><br>
<A NAME="ch28lev2sec16"></A><H4 class="docSection2Title">General Application Tuning</H4>
<P class="docText">This chapter has concentrated on some of the more complex methods of tuning your DB2 applications. A wealth of less complex information about building efficient SQL is also available. For this type of general SQL coding advice, and guidelines for coding efficient, performance-oriented SQL (DCL, DDL, and DML), refer to <A class="docLink" HREF="ch02.html#ch02">Chapters 2</A> through <A class="docLink" HREF="ch10.html#ch10">10</A>.<A NAME="ch28index711"></A><A NAME="ch28index712"></A></P>
<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="ch28lev1sec2.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="ch28lev1sec4.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
