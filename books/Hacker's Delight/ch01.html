<html xmlns="http://www.w3.org/1999/xhtml">
   
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      
      <title>Chapter 1. Laying the Groundwork</title>
      
      <link href="9780133085013.css" rel="stylesheet" type="text/css" />
      
      <link href="page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
      
      <meta content="urn:uuid:767ce45a-85bb-4273-91f5-801bab42906b" name="Adept.expected.resource" />
      
   </head>
   
   <body>
      
      <h2><a id="page_1"></a><a id="ch01"></a>Chapter 1. Introduction
      </h2>
      
      <h3><a id="ch01lev1"></a><strong>1–1 Notation</strong></h3>
      
      <p class="noindent">This book distinguishes between mathematical expressions of ordinary arithmetic and
         those that describe the operation of a computer. In “computer arithmetic,” operands
         are bit strings, or bit vectors, of some definite fixed length. Expressions in computer
         arithmetic are similar to those of ordinary arithmetic, but the variables denote the
         contents of computer registers. The value of a computer arithmetic expression is simply
         a string of bits with no particular interpretation. An operator, however, interprets
         its operands in some particular way. For example, a comparison operator might interpret
         its operands as signed binary integers or as unsigned binary integers; our computer
         arithmetic notation uses distinct symbols to make the type of comparison clear.
      </p>
      
      <p class="indent">The main difference between computer arithmetic and ordinary arithmetic is that in
         computer arithmetic, the results of addition, subtraction, and multiplication are
         reduced modulo 2<sup><em>n</em></sup>, where <em>n</em> is the word size of the machine. Another difference is that computer arithmetic includes
         a large number of operations. In addition to the four basic arithmetic operations,
         computer arithmetic includes logical <em>and, exclusive or, compare, shift left</em>, and so on.
      </p>
      
      <p class="indent">Unless specified otherwise, the word size is 32 bits, and signed integers are represented
         in two’s-complement form.
      </p>
      
      <p class="indent">Expressions of computer arithmetic are written similarly to those of ordinary arithmetic,
         except that the variables that denote the contents of computer registers are in bold
         face type. This convention is commonly used in vector algebra. We regard a computer
         word as a vector of single bits. Constants also appear in bold-face type when they
         denote the contents of a computer register. (This has no analogy with vector algebra
         because in vector algebra the only way to write a constant is to display the vector’s
         components.) When a constant denotes part of an instruction, such as the immediate
         field of a <em>shift</em> instruction, light-face type is used.
      </p>
      
      <p class="indent">If an operator such as “+” has bold face operands, then that operator denotes the
         computer’s addition operation (“vector addition”). If the operands are light-faced,
         then the operator denotes the ordinary scalar arithmetic operation. We use a light-faced
         variable <em>x</em> to denote the arithmetic value of a bold-faced variable <strong><em>x</em></strong> under an interpretation (signed or unsigned) that should be clear from the context.
         Thus, if <strong><em>x</em></strong> = <strong>0x80000000</strong> and <strong><em>y</em></strong> = <strong>0x80000000</strong>, then, under signed integer interpretation, <strong><em>x</em> = <em>y</em> =</strong> –<strong>2<sup>31</sup>, <em>x</em> + <em>y</em> =</strong> – <strong>2<sup>32</sup></strong>, and <strong><em>x</em></strong> + <strong><em>y</em></strong> = <strong>0</strong>. Here, <strong>0x80000000</strong> is hexadecimal notation for a bit string consisting of a 1-bit followed by 31 0-bits.
      </p>
      
      <p class="indent">Bits are numbered from the right, with the rightmost (least significant) bit being
         bit 0. The terms “bits,” “nibbles,” “bytes,” “halfwords,” “words,” and “doublewords”
         refer to lengths of 1, 4, 8, 16, 32, and 64 bits, respectively.
      </p>
      
      <p class="indent"><a id="page_2"></a>Short and simple sections of code are written in computer algebra, using its assignment
         operator (left arrow) and occasionally an <em>if</em> statement. In this role, computer algebra is serving as little more than a machine-independent
         way of writing assembly language code.
      </p>
      
      <p class="indent">Programs too long or complex for computer algebra are written in the C programming
         language, as defined by the ISO 1999 standard.
      </p>
      
      <p class="indent">A complete description of C would be out of place in this book, but <a href="ch01.html#ch01tab1">Table 1–1</a> contains a brief summary of most of the elements of C [H&amp;S] that are used herein.
         This is provided for the benefit of the reader who is familiar with some procedural
         programming language, but not with C. <a href="ch01.html#ch01tab1">Table 1–1</a> also shows the operators of our computer-algebraic arithmetic language. Operators
         are listed from highest precedence (tightest binding) to lowest. In the Precedence
         column, L means left-associative; that is,
      </p>
      
      <p class="center">a • b • c = (a • b) • c</p>
      
      <p class="noindent">and R means right-associative. Our computer-algebraic notation follows C in precedence
         and associativity.
      </p>
      
      <p class="tab-caption"><a id="ch01tab1"></a>T<small>ABLE</small> 1–1. E<small>XPRESSIONS OF</small> C <small>AND</small> C<small>OMPUTER</small> A<small>LGEBR</small></p>
      
      <div class="image2"><img alt="Image" src="graphics/01tab01.jpg" /></div>
      
      <div class="image2"><a id="page_3"></a><img alt="Image" src="graphics/01tab01a.jpg" /></div>
      
      <div class="image2"><img alt="Image" src="graphics/01tab01b.jpg" /></div>
      
      <p class="indent">In addition to the notations described in <a href="ch01.html#ch01tab1">Table 1–1</a>, those of Boolean algebra and of standard mathematics are used, with explanations
         where necessary.
      </p>
      
      <p class="indent"><a id="page_4"></a>Our computer algebra uses other functions in addition to “abs,” “rem,” and so on.
         These are defined where introduced.
      </p>
      
      <p class="indent">In C, the expression <code>x &lt; y &lt; z</code> means to evaluate <code>x &lt; y</code> to a 0/1-valued result, and then compare that result to <code>z</code>. In computer algebra, the expression <strong><em>x</em></strong> &lt; <strong><em>y</em></strong> &lt; <strong><em>z</em></strong> means (<strong><em>x</em></strong> &lt; <strong><em>y</em></strong>) &amp; (<strong><em>y</em></strong> &lt; <strong><em>z</em></strong>).
      </p>
      
      <p class="indent">C has three loop control statements: <code>while</code>, <code>do</code>, and <code>for</code>. The <code>while</code> statement is written:
      </p>
      
      <p class="center"><code>while</code> (<em>expression</em>) <em>statement</em></p>
      
      <p class="noindent">First, <em>expression</em> is evaluated. If <strong>true</strong> (nonzero), <em>statement</em> is executed and control returns to evaluate <em>expression</em> again. If <em>expression</em> is <strong>false</strong> (0), the <em>while</em>-loop terminates.
      </p>
      
      <p class="indent">The <code>do</code> statement is similar, except the test is at the bottom of the loop. It is written:
      </p>
      
      <p class="center"><code>do</code> <em>statement</em> <code>while</code> (<em>expression</em>)
      </p>
      
      <p class="noindent">First, <em>statement</em> is executed, and then <em>expression</em> is evaluated. If <strong>true</strong>, the process is repeated, and if <strong>false</strong>, the loop terminates.
      </p>
      
      <p class="indent">The <code>for</code> statement is written:
      </p>
      
      <p class="center"><code>for</code> (<em>e</em><sub>1</sub>; <em>e</em><sub>2</sub>; <em>e</em><sub>3</sub>) <em>statement</em></p>
      
      <p class="noindent">First, <em>e</em><sub>1</sub>, usually an assignment statement, is executed. Then <em>e</em><sub>2</sub>, usually a comparison, is evaluated. If <strong>false</strong>, the for-loop terminates. If <strong>true</strong>, <em>statement</em> is executed. Finally, <em>e</em><sub>3</sub>, usually an assignment statement, is executed, and control returns to evaluate <em>e</em><sub>2</sub> again. Thus, the familiar “do i = 1 to n” is written:
      </p>
      
      <p class="codelink"><a href="images.html#p004pro01" id="p004pro01a">Click here to view code image</a></p>
      
      <p class="programlistings1">for (i = 1; i &lt;= n; i++)</p>
      
      <p class="noindent">(This is one of the few contexts in which we use the postincrement operator.)</p>
      
      <p class="indent">The ISO C standard does not specify whether right shifts (“<code>&gt;&gt;</code>” operator) of signed quantities are 0-propagating or sign-propagating. In the C code
         herein, it is assumed that if the left operand is signed, then a sign-propagating
         shift results (and if it is unsigned, then a 0-propagating shift results, following
         ISO). Most modern C compilers work this way.
      </p>
      
      <p class="indent">It is assumed here that left shifts are “logical.” (Some machines, mostly older ones,
         provide an “arithmetic” left shift, in which the sign bit is retained.)
      </p>
      
      <p class="indent">Another potential problem with shifts is that the ISO C standard specifies that if
         the shift amount is negative or is greater than or equal to the width of the left
         operand, the result is undefined. But, nearly all 32-bit machines treat shift amounts
         modulo 32 or 64. The code herein relies on one of these behaviors; an explanation
         is given when the distinction is important.
      </p>
      
      <h3><a id="page_5"></a><a id="ch01lev2"></a><strong>1–2 Instruction Set and Execution Time Model</strong></h3>
      
      <p class="noindent">To permit a rough comparison of algorithms, we imagine them being coded for a machine
         with an instruction set similar to that of today’s general purpose RISC computers,
         such as the IBM RS/6000, the Oracle SPARC, and the ARM architecture. The machine is
         three-address and has a fairly large number of general purpose registers—that is,
         16 or more. Unless otherwise specified, the registers are 32 bits long. General register
         0 contains a permanent 0, and the others can be used uniformly for any purpose.
      </p>
      
      <p class="indent">In the interest of simplicity there are no “special purpose” registers, such as a
         condition register or a register to hold status bits, such as “overflow.” The machine
         has no floating-point instructions. Floating-point is only a minor topic in this book,
         being mostly confined to <a href="ch17.html#ch17">Chapter 17</a>.
      </p>
      
      <p class="indent">We recognize two varieties of RISC: a “basic RISC,” having the instructions shown
         in <a href="ch01.html#ch01tab2">Table 1–2</a>, and a “full RISC,” having all the instructions of the basic RISC, plus those shown
         in <a href="ch01.html#ch01tab3">Table 1–3</a>.
      </p>
      
      <p class="tab-caption"><a id="ch01tab2"></a>T<small>ABLE</small> 1–2. B<small>ASIC</small> R<small>ISC</small> I<small>NSTRUCTION</small> S<small>ET</small></p>
      
      <div class="image2"><img alt="Image" src="graphics/01tab02.jpg" /></div>
      
      <div class="image"><a id="page_6"></a><img alt="Image" src="graphics/01tab02a.jpg" /></div>
      
      <p class="tab-caption"><a id="page_7"></a><a id="ch01tab3"></a>T<small>ABLE</small> 1–3. A<small>DDITIONAL</small> I<small>NSTRUCTIONS FOR THE</small> “F<small>ULL</small> R<small>ISC</small>”
      </p>
      
      <div class="image2"><img alt="Image" src="graphics/01tab03.jpg" /></div>
      
      <div class="image2"><img alt="Image" src="graphics/01tab03a.jpg" /></div>
      
      <p class="indent">In <a href="ch01.html#ch01tab2">Tables 1–2</a>, <a href="ch01.html#ch01tab3">1–3</a>, and <a href="ch01.html#ch01tab4">1–4</a>, RA and RB appearing as source operands really means the contents of those registers.
      </p>
      
      <p class="indent">A real machine would have branch and link (for subroutine calls), branch to the address
         contained in a register (for subroutine returns and “switches”), and possibly some
         instructions for dealing with special purpose registers. It would, of course, have
         a number of privileged instructions and instructions for calling on supervisor services.
         It might also have floating-point instructions.
      </p>
      
      <p class="indent">Some other computational instructions that a RISC computer might have are identified
         in <a href="ch01.html#ch01tab3">Table 1–3</a>. These are discussed in later chapters.
      </p>
      
      <p class="indent">It is convenient to provide the machine’s assembler with a few “extended mnemonics.”
         These are like macros whose expansion is usually a single instruction. Some possibilities
         are shown in <a href="ch01.html#ch01tab4">Table 1–4</a>.
      </p>
      
      <p class="tab-caption"><a id="page_8"></a><a id="ch01tab4"></a>T<small>ABLE</small> 1–4. E<small>XTENDED</small> M<small>NEMONICS</small></p>
      
      <div class="image2"><img alt="Image" src="graphics/01tab04.jpg" /></div>
      
      <p class="indent">The <em>load immediate</em> instruction expands into one or two instructions, as required by the immediate value
         <em>I</em>. For example, if 0 ≤ <em>I</em> &lt; 2<sup>16</sup>, an <em>or immediate</em> (<code>ori</code>) from R0 can be used. If – 2<sup>15</sup> ≤ <em>I</em> &lt; 0, an <em>add immediate</em> (<code>addi</code>) from R0 can be used. If the rightmost 16 bits of <em>I</em> are 0, <em>add immediate shifted</em> (<code>addis</code>) can be used. Otherwise, two instructions are required, such as <code>addis</code> followed by <code>ori</code>. (Alternatively, in the last case, a load from memory could be used, but for execution
         time and space estimates we assume that two elementary arithmetic instructions are
         used.)
      </p>
      
      <p class="indent">Of course, which instructions belong in the basic RISC and which belong in the full
         RISC is very much a matter of judgment. Quite possibly, <em>divide unsigned</em> and the <em>remainder</em> instructions should be moved to the full RISC category. Conversely, possibly <em>load byte signed</em> should be in the basic RISC category. It is in the full RISC set because it is probably
         of rather low frequency of use, and because in some technologies it is difficult to
         propagate a sign bit through so many positions and still make cycle time.
      </p>
      
      <p class="indent">The distinction between basic and full RISC involves many other such questionable
         judgments, but we won’t dwell on them.
      </p>
      
      <p class="indent">The instructions are limited to two source registers and one target, which simplifies
         the computer (e.g., the register file requires no more than two read ports and one
         write port). It also simplifies an optimizing compiler, because the compiler does
         not need to deal with instructions that have multiple targets. The price paid for
         this is that a program that wants both the quotient and remainder of two numbers (not
         uncommon) must execute two instructions (<em>divide</em> and <em>remainder</em>). The usual machine division algorithm produces the remainder as a by-product, so
         many machines make them both available as a result of one execution of <em>divide</em>. Similar remarks apply to obtaining the doubleword product of two words.
      </p>
      
      <p class="indent">The <em>conditional move</em> instructions (e.g., <code>moveq</code>) ostensibly have only two source operands, but in a sense they have three. Because
         the result of the instruction depends on the values in RT, RA, and RB, a machine that
         executes instructions out of order must treat RT in these instructions as both a <em>use</em> and a <em>set</em>. That is, an instruction that sets RT, followed by a <em>conditional move</em> that sets RT, must be executed in that order, and the result of the first instruction
         cannot be discarded. Thus, the designer of such a machine may elect to omit the <em>conditional move</em> instructions to avoid having to consider an instruction with (logically) three source
         operands. On the other hand, the <em>conditional move</em> instructions do save branches.
      </p>
      
      <p class="indent">Instruction formats are not relevant to the purposes of this book, but the full RISC
         instruction set described above, with floating-point and a few supervisory <a id="page_9"></a>instructions added, can be implemented with 32-bit instructions on a machine with
         32 general purpose registers (5-bit register fields). By reducing the immediate fields
         of <em>compare, load, store</em>, and <em>trap</em> instructions to 14 bits, the same holds for a machine with 64 general purpose registers
         (6-bit register fields).
      </p>
      
      <h4><strong>Execution Time</strong></h4>
      
      <p class="noindent">We assume that all instructions execute in one cycle, except for the <em>multiply, divide</em>, and <em>remainder</em> instructions, for which we do not assume any particular execution time. Branches
         take one cycle whether they branch or fall through.
      </p>
      
      <p class="indent">The <em>load immediate</em> instruction is counted as one or two cycles, depending on whether one or two elementary
         arithmetic instructions are required to generate the constant in a register.
      </p>
      
      <p class="indent">Although <em>load</em> and <em>store</em> instructions are not often used in this book, we assume they take one cycle and ignore
         any load delay (time lapse between when a load instruction completes in the arithmetic
         unit and when the requested data is available for a subsequent instruction).
      </p>
      
      <p class="indent">However, knowing the number of cycles used by all the arithmetic and logical instructions
         is often insufficient for estimating the execution time of a program. Execution can
         be slowed substantially by load delays and by delays in fetching instructions. These
         delays, although very important and increasing in importance, are not discussed in
         this book. Another factor, one that improves execution time, is what is called “instruction-level
         parallelism,” which is found in many contemporary RISC chips, particularly those for
         “high-end” machines.
      </p>
      
      <p class="indent">These machines have multiple execution units and sufficient instruction-dispatching
         capability to execute instructions in parallel when they are independent (that is,
         when neither uses a result of the other, and they don’t both set the same register
         or status bit). Because this capability is now quite common, the presence of independent
         operations is often pointed out in this book. Thus, we might say that such and such
         a formula can be coded in such a way that it requires eight instructions and executes
         in five cycles on a machine with unlimited instruction-level parallelism. This means
         that if the instructions are arranged in the proper order (“scheduled”), a machine
         with a sufficient number of adders, shifters, logical units, and registers can, in
         principle, execute the code in five cycles.
      </p>
      
      <p class="indent">We do not make too much of this, because machines differ greatly in their instruction-level
         parallelism capabilities. For example, an IBM RS/6000 processor from ca. 1992 has
         a three-input adder and can execute two consecutive <em>add</em>-type instructions in parallel even when one feeds the other (e.g., an <em>add</em> feeding a <em>compare</em>, or the base register of a <em>load</em>). As a contrary example, consider a simple computer, possibly for low-cost embedded
         applications, that has only one read port on its register file. Normally, this machine
         would take an extra cycle to do a second read of the register file for an instruction
         that has two register input operands. However, suppose it has a bypass so that if
         an instruction feeds an operand of the immediately following instruction, then that
         operand is available without <a id="page_10"></a>reading the register file. On such a machine, it is actually advantageous if each
         instruction feeds the next—that is, if the code has no parallelism.
      </p>
      
      <h4><strong>Exercises</strong></h4>
      
      <p class="question"><a href="ch19_answer.html#ch01ans1" id="ch01ansa1"><strong>1</strong>.</a> Express the loop
      </p>
      
      <p class="center"><code>for (</code><em>e</em><sub>1</sub>; <em>e</em><sub>2</sub>; <em>e</em><sub>3</sub>) <em>statement</em></p>
      
      <p class="indenthanging">in terms of a <code>while</code> loop.
      </p>
      
      <p class="indenthangingA">Can it be expressed as a <code>do</code> loop?
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch01ans2" id="ch01ansa2"><strong>2</strong>.</a> Code a loop in C in which the unsigned integer control variable <code>i</code> takes on all values from 0 to and including the maximum unsigned number, 0xFFFFFFFF
         (on a 32-bit machine).
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch01ans3" id="ch01ansa3"><strong>3</strong>.</a> For the more experienced reader: The instructions of the basic and full RISCs defined
         in this book can be executed with at most two register reads and one write. What are
         some common or plausible RISC instructions that either need more source operands or
         need to do more than one register write?
      </p>
      
   </body>
   
</html>