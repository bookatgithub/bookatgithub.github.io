<html xmlns="http://www.w3.org/1999/xhtml">
   
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      
      <title>Chapter 2. Basics</title>
      
      <link href="9780133085013.css" rel="stylesheet" type="text/css" />
      
      <link href="page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
      
      <meta content="urn:uuid:767ce45a-85bb-4273-91f5-801bab42906b" name="Adept.expected.resource" />
      
   </head>
   
   <body>
      
      <h2><a id="page_11"></a><a id="ch02"></a>Chapter 2. Basics
      </h2>
      
      <h3><a id="ch02lev1"></a><strong>2–1 Manipulating Rightmost Bits</strong></h3>
      
      <p class="noindent">Some of the formulas in this section find application in later chapters.</p>
      
      <p class="indent">Use the following formula to turn off the rightmost 1-bit in a word, producing 0 if
         none (e.g., 01011000 ⇒ 01010000):
      </p>
      
      <p class="center"><strong><em>x</em></strong> &amp; (<strong><em>x</em></strong> – <strong>1</strong>)
      </p>
      
      <p class="noindent">This can be used to determine if an unsigned integer is a power of 2 or is 0: apply
         the formula followed by a 0-test on the result.
      </p>
      
      <p class="indent">Use the following formula to turn on the rightmost 0-bit in a word, producing all
         1’s if none (e.g., 10100111 ⇒ 10101111):
      </p>
      
      <p class="center"><strong><em>x</em></strong> | (<strong><em>x</em></strong> + <strong>1</strong>)
      </p>
      
      <p class="indent">Use the following formula to turn off the trailing 1’s in a word, producing <strong><em>x</em></strong> if none (e.g., 10100111 ⇒ 10100000):
      </p>
      
      <p class="center"><strong><em>x</em></strong> &amp; (<strong><em>x</em></strong> + <strong>1</strong>)
      </p>
      
      <p class="noindent">This can be used to determine if an unsigned integer is of the form 2<sup><em>n</em></sup>– 1, 0, or all 1’s: apply the formula followed by a 0-test on the result.
      </p>
      
      <p class="indent">Use the following formula to turn on the trailing 0’s in a word, producing <strong><em>x</em></strong> if none (e.g., 10101000 ⇒ 10101111):
      </p>
      
      <p class="center"><strong><em>x</em></strong> | (<strong><em>x</em></strong>– <strong>1</strong>)
      </p>
      
      <p class="indent">Use the following formula to create a word with a single 1-bit at the position of
         the rightmost 0-bit in <strong><em>x</em></strong>, producing 0 if none (e.g., 10100111 ⇒ 00001000):
      </p>
      
      <p class="center">¬<strong><em>x</em></strong> &amp; (<strong><em>x</em></strong> + <strong>1</strong>)
      </p>
      
      <p class="indent">Use the following formula to create a word with a single 0-bit at the position of
         the rightmost 1-bit in <strong><em>x</em></strong>, producing all 1’s if none (e.g., 10101000 ⇒ 11110111):
      </p>
      
      <p class="center">¬<strong><em>x</em></strong> | (<strong><em>x</em></strong> – <strong>1</strong>)
      </p>
      
      <p class="indent"><a id="page_12"></a>Use one of the following formulas to create a word with 1’s at the positions of the
         trailing 0’s in <strong><em>x</em></strong>, and 0’s elsewhere, producing 0 if none (e.g., 01011000 ⇒ 00000111):
      </p>
      
      <div class="image"><img alt="Image" src="graphics/012equ01.jpg" /></div>
      
      <p class="noindent">The first formula has some instruction-level parallelism.</p>
      
      <p class="indent">Use the following formula to create a word with 0’s at the positions of the trailing
         1’s in <strong><em>x</em></strong>, and 0’s elsewhere, producing all 1’s if none (e.g., 10100111 ⇒ 11111000):
      </p>
      
      <p class="center">¬<strong><em>x</em></strong> | (<strong><em>x</em></strong> + <strong>1</strong>)
      </p>
      
      <p class="indent">Use the following formula to isolate the rightmost 1-bit, producing 0 if none (e.g.,
         01011000 ⇒ 00001000):
      </p>
      
      <p class="center"><strong><em>x</em></strong> &amp; (−<strong><em>x</em></strong>)
      </p>
      
      <p class="indent">Use the following formula to create a word with 1’s at the positions of the rightmost
         1-bit and the trailing 0’s in <strong><em>x</em></strong>, producing all 1’s if no 1-bit, and the integer 1 if no trailing 0’s (e.g., 01011000
         ⇒ 00001111):
      </p>
      
      <p class="center"><strong><em>x</em></strong> ⊕ (<strong><em>x</em></strong> − <strong>1</strong>)
      </p>
      
      <p class="indent">Use the following formula to create a word with 1’s at the positions of the rightmost
         0-bit and the trailing 1’s in <strong><em>x</em></strong>, producing all 1’s if no 0-bit, and the integer 1 if no trailing 1’s (e.g., 01010111
         ⇒ 00001111):
      </p>
      
      <p class="center"><strong><em>x</em></strong> ⊕ (<strong><em>x</em></strong> + <strong>1</strong>)
      </p>
      
      <p class="indent">Use either of the following formulas to turn off the rightmost contiguous string of
         1’s (e.g., 01011100 ==&gt; 01000000) [Wood]:
      </p>
      
      <p class="center">(((<em>x</em> | (<em>x</em> − 1)) + 1) &amp; <em>x</em>), or<br />((<em>x</em> &amp; −<em>x</em>) + <em>x</em>)&amp;<em>x</em></p>
      
      <p class="noindent">These can be used to determine if a nonnegative integer is of the form 2<sup><em>j</em></sup> − 2<em><sup>k</sup></em> for some <em>j ≥ k≥ 0:</em> apply the formula followed by a 0-test on the result.
      </p>
      
      <h4><strong>De Morgan’s Laws Extended</strong></h4>
      
      <p class="noindent">The logical identities known as De Morgan’s laws can be thought of as distributing,
         or “multiplying in,” the <em>not</em> sign. This idea can be extended to apply to the expressions of this section, and
         a few more, as shown here. (The first two are De Morgan’s laws.)
      </p>
      
      <div class="image"><a id="page_13"></a><img alt="Image" src="graphics/013equ01.jpg" /></div>
      
      <p class="indent">As an example of the application of these formulas, ¬(<strong><em>x</em></strong> | –(<strong><em>x</em></strong> + <strong>1</strong>)) = ¬<strong><em>x</em></strong> &amp;¬–(<strong><em>x</em></strong> + <strong>1</strong>) = ¬<strong><em>x</em></strong> &amp; ((<strong><em>x</em></strong> + <strong>1</strong>) – <strong>1</strong>) = ¬<strong><em>x</em></strong> &amp; <strong><em>x</em></strong> = 0.
      </p>
      
      <h4><strong>Right-to-Left Computability Test</strong></h4>
      
      <p class="noindent">There is a simple test to determine whether or not a given function can be implemented
         with a sequence of <em>add</em>’s, <em>subtract</em>’s, <em>and</em>’s, <em>or</em>’s, and <em>not</em>’s [War]. We can, of course, expand the list with other instructions that can be composed
         from the basic list, such as <em>shift left</em> by a fixed amount (which is equivalent to a sequence of <em>add</em>’s), or <em>multiply</em>. However, we exclude instructions that cannot be composed from the list. The test
         is contained in the following theorem.
      </p>
      
      <p class="indentaa">T<small>HEOREM</small>. <em>A function mapping words to words can be implemented with word-parallel</em> add, subtract, and, or, <em>and</em> not <em>instructions if and only if each bit of the result depends only on bits at and to
            the right of each input operand</em>.
      </p>
      
      <p class="indent">That is, imagine trying to compute the rightmost bit of the result by looking only
         at the rightmost bit of each input operand. Then, try to compute the next bit to the
         left by looking only at the rightmost two bits of each input operand, and continue
         in this way. If you are successful in this, then the function can be computed with
         a sequence of <em>add</em>’s, <em>and</em>’s, and so on. If the function cannot be computed in this right-to-left manner, then
         it cannot be implemented with a sequence of such instructions.
      </p>
      
      <p class="indent">The interesting part of this is the latter statement, and it is simply the contra-positive
         of the observation that the functions <em>add, subtract, and, or</em>, and <em>not</em> can all be computed in the right-to-left manner, so any combination of them must
         have this property.
      </p>
      
      <p class="indent">To see the “if” part of the theorem, we need a construction that is a little awkward
         to explain. We illustrate it with a specific example. Suppose that a function of two
         variables <em>x</em> and <em>y</em> has the right-to-left computability property, and suppose that bit 2 of the result
         <em>r</em> is given by
      </p>
      
      <div class="image"><img alt="Image" src="graphics/02equ01.jpg" /></div>
      
      <p class="noindent"><a id="page_14"></a>We number bits from right to left, 0 to 31. Because bit 2 of the result is a function
         of bits at and to the right of bit 2 of the input operands, bit 2 of the result is
         “right-to-left computable.”
      </p>
      
      <p class="indent">Arrange the computer words <strong><em>x, x</em></strong> shifted left two, and <strong><em>y</em></strong> shifted left one, as shown below. Also, add a mask that isolates bit 2.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/014equ01.jpg" /></div>
      
      <p class="noindent">Now, form the word-parallel <em>and</em> of lines 2 and 3, <em>or</em> the result with row 1 (following Equation (1)), and <em>and</em> the result with the mask (row 4 above). The result is a word of all 0’s except for
         the desired result bit in position 2. Perform similar computations for the other bits
         of the result, <em>or</em> the 32 resulting words together, and the result is the desired function.
      </p>
      
      <p class="indent">This construction does not yield an efficient program; rather, it merely shows that
         it can be done with instructions in the basic list.
      </p>
      
      <p class="indent">Using the theorem, we immediately see that there is no sequence of such instructions
         that turns off the leftmost 1-bit in a word, because to see if a certain 1-bit should
         be turned off, we must look to the left to see if it is the leftmost one. Similarly,
         there can be no such sequence for performing a right shift, or a rotate shift, or
         a left shift by a variable amount, or for counting the number of trailing 0’s in a
         word (to count trailing 0’s, the rightmost bit of the result will be 1 if there are
         an odd number of trailing 0’s, and we must look to the left of the rightmost position
         to determine that).
      </p>
      
      <h4><strong>A Novel Application</strong></h4>
      
      <p class="noindent">An application of the sort of bit twiddling discussed above is the problem of finding
         the next higher number after a given number that has the same number of 1-bits. You
         might very well wonder why anyone would want to compute that. It has application where
         bit strings are used to represent subsets. The possible members of a set are listed
         in a linear array, and a subset is represented by a word or sequence of words in which
         bit <em>i</em> is on if member <em>i</em> is in the subset. Set unions are computed by the logical <em>or</em> of the bit strings, intersections by <em>and</em>’s, and so on.
      </p>
      
      <p class="indent">You might want to iterate through all the subsets of a given size. This is easily
         done if you have a function that maps a given subset to the next higher number (interpreting
         the subset string as an integer) with the same number of 1-bits.
      </p>
      
      <p class="indent">A concise algorithm for this operation was devised by R. W. Gosper [HAK, item 175].<sup><a id="ch02fna1"></a><a href="footnotes.html#ch02fn1">1</a></sup> Given a word <strong><em>x</em></strong> that represents a subset, the idea is to find the <a id="page_15"></a>rightmost contiguous group of 1’s in <strong><em>x</em></strong> and the following 0’s, and “increment” that quantity to the next value that has the
         same number of 1’s. For example, the string xxx0 1111 0000, where xxx represents arbitrary
         bits, becomes xxx1 0000 0111. The algorithm first identifies the “smallest” 1-bit
         in <strong><em>x</em></strong>, with <strong><em>s</em></strong> = <strong><em>x</em></strong> &amp;–<strong><em>x</em></strong>, giving 0000 0001 0000. This is added to <strong><em>x</em></strong>, giving <strong><em>r</em></strong> = xxx1 0000 0000. The 1-bit here is one bit of the result. For the other bits, we
         need to produce a right-adjusted string of <em>n</em> – 1 1’s, where <em>n</em> is the size of the rightmost group of 1’s in <strong><em>x</em></strong>. This can be done by first forming the <em>exclusive or</em> of <strong><em>r</em></strong> and <strong><em>x</em></strong>, which gives 0001 1111 0000 in our example.
      </p>
      
      <p class="indent">This has two too many 1’s and needs to be right-adjusted. This can be accomplished
         by dividing it by <strong><em>s</em></strong>, which right-adjusts it (<strong><em>s</em></strong> is a power of 2), and shifting it right two more positions to discard the two unwanted
         bits. The final result is the <em>or</em> of this and <strong><em>r</em></strong>.
      </p>
      
      <p class="indent">In computer algebra notation, the result is <strong><em>y</em></strong> in
      </p>
      
      <div class="image"><img alt="Image" src="graphics/02equ02.jpg" /></div>
      
      <p class="indent">A complete C procedure is given in <a href="ch02.html#ch02fig1">Figure 2–1</a>. It executes in seven basic RISC instructions, one of which is division. (Do not
         use this procedure with <strong><em>x</em></strong> = 0; that causes division by 0.)
      </p>
      
      <p class="indent">If division is slow but you have a fast way to compute the <em>number of trailing zeros</em> function ntz(<strong><em>x</em></strong>), the <em>number of leading zeros</em> function nlz(<strong><em>x</em></strong>), or <em>population count</em> (pop(<strong><em>x</em></strong>) is the number of 1-bits in <strong><em>x</em></strong>), then the last line of Equation (2) can be replaced with one of the following formulas.
         (The first two methods can fail on a machine that has modulo 32 shifts.)
      </p>
      
      <div class="image"><img alt="Image" src="graphics/015equ01.jpg" /></div>
      
      <p class="codelink"><a href="images1.html#p02fig01" id="p02fig01a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch02fig1"></a>unsigned snoob(unsigned x) {<br />   unsigned smallest, ripple, ones;<br />                                //  x = xxx0  1111  0000<br />   smallest = x &amp; -x;           //      0000  0001  0000<br />   ripple = x + smallest;       //      xxx1  0000  0000<br />   ones = x ^ ripple;           //      0001  1111  0000<br />   ones = (ones &gt;&gt; 2)/smallest; //      0000  0000  0111<br />   return ripple | ones;        //      xxx1  0000  0111<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 2–1. Next higher number with same number of 1-bits.
      </p>
      
      <h3><a id="page_16"></a><a id="ch02lev2"></a><strong>2–2 Addition Combined with Logical Operations</strong></h3>
      
      <p class="noindent">We assume the reader is familiar with the elementary identities of ordinary algebra
         and Boolean algebra. Below is a selection of similar identities involving addition
         and subtraction combined with logical operations.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/016equ01.jpg" /></div>
      
      <p class="indent">Equation (d) can be applied to itself repeatedly, giving –¬–¬<strong><em>x</em></strong> = <strong><em>x</em></strong> + <strong>2</strong>, and so on. Similarly, from (e) we have ¬–¬– <strong><em>x</em></strong> = <strong><em>x</em></strong> – <strong>2</strong>. So we can add or subtract any constant using only the two forms of complementation.
      </p>
      
      <p class="indent">Equation (f) is the dual of (j), where (j) is the well-known relation that shows how
         to build a subtracter from an adder.
      </p>
      
      <p class="indent">Equations (g) and (h) are from HAKMEM memo [HAK, item 23]. Equation (g) forms a sum
         by first computing the sum with carries ignored (<strong><em>x</em></strong> ⊕ <strong><em>y</em></strong>), and then adding in the carries. Equation (h) is simply modifying the addition operands
         so that the combination 0 + 1 never occurs at any bit position; it is replaced with
         1 + 0.
      </p>
      
      <p class="indent"><a id="page_17"></a>It can be shown that in the ordinary addition of binary numbers with each bit independently
         equally likely to be 0 or 1, a carry occurs at each position with probability about
         0.5. However, for an adder built by preconditioning the inputs using (g), the probability
         is about 0.25. This observation is probably not of value in building an adder, because
         for that purpose the important characteristic is the maximum number of logic circuits
         the carry must pass through, and using (g) reduces the number of stages the carry
         propagates through by only one.
      </p>
      
      <p class="indent">Equations (k) and (l) are duals of (g) and (h), for subtraction. That is, (k) has
         the interpretation of first forming the difference ignoring the borrows (<strong><em>x</em></strong> ⊕ <strong><em>y</em></strong>), and then subtracting the borrows. Similarly, Equation (l) is simply modifying the
         subtraction operands so that the combination 1 – 1 never occurs at any bit position;
         it is replaced with 0 – 0.
      </p>
      
      <p class="indent">Equation (n) shows how to implement <em>exclusive or</em> in only three instructions on a basic RISC. Using only <em>and-or-not</em> logic requires four instructions ((<strong><em>x</em></strong> | <strong><em>y</em></strong>) &amp; ¬(<strong><em>x</em></strong> &amp; <strong><em>y</em></strong>)). Similarly, (u) and (v) show how to implement <em>and</em> and <em>or</em> in three other elementary instructions, whereas using DeMorgan’s laws requires four.
      </p>
      
      <h3><a id="ch02lev3"></a><strong>2–3 Inequalities among Logical and Arithmetic Expressions</strong></h3>
      
      <p class="noindent">Inequalities among binary logical expressions whose values are interpreted as unsigned
         integers are nearly trivial to derive. Here are two examples:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/017equ01.jpg" /></div>
      
      <p class="noindent">These can be derived from a list of all binary logical operations, shown in <a href="ch02.html#ch02tab1">Table 2–1</a>.
      </p>
      
      <p class="tab-caption"><a id="ch02tab1"></a>T<small>ABLE</small> 2–1. T<small>HE</small> 16 B<small>INARY</small> L<small>OGICAL</small> O<small>PERATIONS</small></p>
      
      <div class="image2"><img alt="Image" src="graphics/02tab01.jpg" /></div>
      
      <p class="indent">Let <em>f</em>(<em>x, y</em>) and <em>g</em>(<em>x, y</em>) represent two columns in <a href="ch02.html#ch02tab1">Table 2–1</a>. If for each row in which <em>f</em>(<em>x,y</em>) is 1, <em>g</em>(<em>x,y</em>) also is 1, then for all (<em>x,y</em>), <em>f</em>(<em>x, y</em>) <span class="middle"><img alt="Image" src="graphics/le.jpg" /></span> <em>g</em>(<em>x, y</em>). Clearly, this extends to word-parallel logical operations. One can easily read
         off such relations (most of which are trivial) as (<em>x</em> &amp; <em>y</em>) <span class="middle"><img alt="Image" src="graphics/le.jpg" /></span> <em>x</em> <span class="middle"><img alt="Image" src="graphics/le.jpg" /></span> (<em>x</em> | ¬ <em>y</em>), and so on. Furthermore, if two columns have a row in which one entry is 0 and the
         other is 1, <a id="page_18"></a>and another row in which the entries are 1 and 0, respectively, then no inequality
         relation exists between the corresponding logical expressions. So the question of
         whether or not <em>f</em>(<em>x, y</em>) <span class="middle"><img alt="Image" src="graphics/le.jpg" /></span> <em>g</em>(<em>x, y</em>) is completely and easily solved for all binary logical functions <em>f</em> and <em>g</em>.
      </p>
      
      <p class="indent">Use caution when manipulating these relations. For example, for ordinary arithmetic,
         if <em>x</em> + <em>y</em> ≤ <em>a</em> and <em>z</em> ≤ <em>x</em>, then <em>z</em> + <em>y</em> ≤ <em>a</em>, but this inference is not valid if “+” is replaced with <em>or</em>.
      </p>
      
      <p class="indent">Inequalities involving mixed logical and arithmetic expressions are more interesting.
         Below is a small selection.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/018equ01.jpg" /></div>
      
      <p class="noindent">The proofs of these are quite simple, except possibly for the relation |<strong><em>x</em></strong> − <strong><em>y</em></strong>| <span class="middle"><img alt="Image" src="graphics/le.jpg" /></span> (<strong><em>x</em></strong> ⊕ <strong><em>y</em></strong>). By |<strong><em>x</em></strong> − <strong><em>y</em></strong>| we mean the absolute value of <strong><em>x</em></strong> − <strong><em>y</em></strong>, which can be computed within the domain of unsigned numbers as max(<strong><em>x, y</em></strong>) − min(<strong><em>x, y</em></strong>). This relation can be proven by induction on the length of <strong><em>x</em></strong> and <strong><em>y</em></strong> (the proof is a little easier if you extend them on the left rather than on the right).
      </p>
      
      <h3><a id="ch02lev4"></a><strong>2–4 <em>Absolute Value</em> Function</strong></h3>
      
      <p class="noindent">If your machine does not have an instruction for computing the absolute value, this
         computation can usually be done in three or four branch-free instructions. First,
         compute <span class="middle"><img alt="Image" src="graphics/018equ04.jpg" /></span>, and then one of the following:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/018equ02.jpg" /></div>
      
      <p class="noindent">By “<em>2</em><strong><em>x</em></strong>” we mean, of course, <strong><em>x</em></strong> <em>+</em> <strong><em>x</em></strong> or <strong><em>x</em></strong> <span class="entity">&lt;&lt;</span> 1.
      </p>
      
      <p class="indent">If you have fast multiplication by a variable whose value is ±1, the following will
         do:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/018equ03.jpg" /></div>
      
      <h3><a id="page_19"></a><a id="ch02lev5"></a><strong>2–5 Average of Two Integers</strong></h3>
      
      <p class="noindent">The following formula can be used to compute the average of two unsigned integers,
         <span class="entity">⌊</span>(<em>x</em> + <em>y</em>)/2<span class="entity">⌋</span> without causing overflow [Dietz]:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/02equ03.jpg" /></div>
      
      <p class="noindent">The formula below computes <span class="entity">⌈</span>(<em>x</em> + <em>y</em>)/2<span class="entity">⌉</span> for unsigned integers:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/019equ01.jpg" /></div>
      
      <p class="indent">To compute the same quantities (“floor and ceiling averages”) for signed integers,
         use the same formulas, but with the unsigned shift replaced with a signed shift.
      </p>
      
      <p class="indent">For signed integers, one might also want the average with the division by 2 rounded
         toward 0. Computing this “truncated average” (without causing overflow) is a little
         more difficult. It can be done by computing the floor average and then correcting
         it. The correction is to add 1 if, arithmetically, <em>x</em> + <em>y</em> is negative and odd. But <em>x</em> + <em>y</em> is negative if and only if the result of (3), with the unsigned shift replaced with
         a signed shift, is negative. This leads to the following method (seven instructions
         on the basic RISC, after commoning the subexpression <strong><em>x</em> ⊕ <em>y</em></strong>):
      </p>
      
      <div class="image"><img alt="Image" src="graphics/019equ02.jpg" /></div>
      
      <p class="indent">Some common special cases can be done more efficiently. If <strong><em>x</em></strong> and <strong><em>y</em></strong> are signed integers and known to be nonnegative, then the average can be computed
         as simply <span class="middle"><img alt="Image" src="graphics/019fig01.jpg" /></span>. The sum can overflow, but the overflow bit is retained in the register that holds
         the sum, so that the unsigned shift moves the overflow bit to the proper position
         and supplies a zero sign bit.
      </p>
      
      <p class="indent">If <strong><em>x</em></strong> and <strong><em>y</em></strong> are unsigned integers and <span class="middle"><img alt="Image" src="graphics/019fig02.jpg" /></span>, or if <strong><em>x</em></strong> and <strong><em>y</em></strong> are signed integers and <strong><em>x</em> ≤ <em>y</em></strong> (signed comparison), then the average is given by <strong><em>x</em></strong> + <span class="middle"><img alt="Image" src="graphics/019fig03.jpg" /></span>. These are floor averages, for example, the average of −1 and 0 is −1.
      </p>
      
      <h3><a id="ch02lev6"></a><strong>2–6 Sign Extension</strong></h3>
      
      <p class="noindent">By “sign extension,” we mean to consider a certain bit position in a word to be the
         sign bit, and we wish to propagate that to the left, ignoring any other bits present.
         The standard way to do this is with <em>shift left logical</em> followed by <em>shift right signed</em>. However, if these instructions are slow or nonexistent on your machine, it can be
         <a id="page_20"></a>done with one of the following, where we illustrate by propagating bit position 7
         to the left:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/020equ01.jpg" /></div>
      
      <p class="noindent">The “+” above can also be “–” or “⊕.” The second formula is particularly useful if
         you know that the unwanted high-order bits are all 0’s, because then the <em>and</em> can be omitted.
      </p>
      
      <h3><a id="ch02lev7"></a><strong>2–7 Shift Right Signed from Unsigned</strong></h3>
      
      <p class="noindent">If your machine does not have the <em>shift right signed</em> instruction, it can be computed using the formulas shown below. The first formula
         is from [GM], and the second is based on the same idea. These formulas hold for 0
         ≤ <em>n</em> ≤ 31 and, if the machine has mod-64 shifts, the last holds for 0 ≤ <em>n</em> ≤ 63. The last formula holds for any <em>n</em> if by “holds” we mean “treats the shift amount to the same modulus as does the logical
         shift.”
      </p>
      
      <p class="indent">When <em>n</em> is a variable, each formula requires five or six instructions on a basic RISC.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/020equ02.jpg" /></div>
      
      <p class="noindent">In the first two formulas, an alternative for the expression <span class="middle"><img alt="Image" src="graphics/020fig01.jpg" /></span> is <strong>1</strong><span class="entity">&lt;&lt;</span><strong>31</strong> − <strong><em>n</em></strong>.
      </p>
      
      <p class="indent">If <em>n</em> is a constant, the first two formulas require only three instructions on many machines.
         If <em>n</em> = 31, the function can be done in two instructions with −<span class="middle"><img alt="Image" src="graphics/020fig02.jpg" /></span>.
      </p>
      
      <h3><a id="ch02lev8"></a><strong>2–8 <em>Sign</em> Function</strong></h3>
      
      <p class="noindent">The <em>sign</em>, or <em>signum</em>, function is defined by
      </p>
      
      <div class="image"><img alt="Image" src="graphics/020equ03.jpg" /></div>
      
      <p class="noindent"><a id="page_21"></a>It can be calculated with four instructions on most machines [Hop]:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/021equ01.jpg" /></div>
      
      <p class="indent">If you don’t have <em>shift right signed</em>, then use the substitute noted at the end of <a href="ch02.html#ch02lev7">Section 2–7</a>, giving the following nicely symmetric formula (five instructions):
      </p>
      
      <div class="image"><img alt="Image" src="graphics/021equ02.jpg" /></div>
      
      <p class="indent">Comparison predicate instructions permit a three-instruction solution, with either</p>
      
      <div class="image"><img alt="Image" src="graphics/02equ04.jpg" /></div>
      
      <p class="indent">Finally, we note that the formula <span class="middle"><img alt="Image" src="graphics/021fig01.jpg" /></span> almost works; it fails only for <strong><em>x</em></strong> = –<strong>2<sup>31</sup></strong>.
      </p>
      
      <h3><a id="ch02lev9"></a><strong>2–9 <em>Three-Valued Compare</em> Function</strong></h3>
      
      <p class="noindent">The <em>three-valued compare</em> function, a slight generalization of the <em>sign</em> function, is defined by
      </p>
      
      <div class="image"><img alt="Image" src="graphics/021equ03.jpg" /></div>
      
      <p class="noindent">There are both signed and unsigned versions, and unless otherwise specified, this
         section applies to both.
      </p>
      
      <p class="indent">Comparison predicate instructions permit a three-instruction solution, an obvious
         generalization of Equations in (4):
      </p>
      
      <div class="image"><img alt="Image" src="graphics/021equ04.jpg" /></div>
      
      <p class="indent">A solution for unsigned integers on PowerPC is shown below [CWG]. On this machine,
         “carry” is “not borrow.”
      </p>
      
      <p class="codelink"><a href="images1.html#p021equ05" id="p021equ05a">Click here to view code image</a></p>
      
      <p class="programlisting1">subf  R5,Ry,Rx    # R5 &lt;-- Rx - Ry.<br />subfc R6,Rx,Ry    # R6 &lt;-- Ry - Rx, set carry.<br />subfe R7,Ry,Rx    # R7 &lt;-- Rx - Ry + carry, set carry.<br />subfe R8,R7,R5    # R8 &lt;-- R5 - R7 + carry, (set carry).
      </p>
      
      <p class="indent"><a id="page_22"></a>If limited to the instructions of the basic RISC, there does not seem to be any particularly
         good way to compute this function. The comparison predicates <strong><em>x</em></strong> &lt; <strong><em>y, x</em> ≤ <em>y</em></strong>, and so on, require about five instructions (see <a href="ch02.html#ch02lev12">Section 2–12</a>), leading to a solution in about 12 instructions (using a small amount of commonality
         in computing <strong><em>x</em></strong> &lt; <strong><em>y</em></strong> and <strong><em>x</em></strong> &gt; <strong><em>y</em></strong>). On the basic RISC it’s probably preferable to use compares and branches (six instructions
         executed worst case if compares can be commoned).
      </p>
      
      <h3><a id="ch02lev10"></a><strong>2–10 <em>Transfer of Sign</em> Function</strong></h3>
      
      <p class="noindent">The <em>transfer of sign</em> function, called ISIGN in Fortran, is defined by
      </p>
      
      <div class="image"><img alt="Image" src="graphics/022equ01.jpg" /></div>
      
      <p class="noindent">This function can be calculated (modulo 2<sup>32</sup>) with four instructions on most machines:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/022equ02.jpg" /></div>
      
      <h3><a id="ch02lev11"></a><strong>2–11 Decoding a “Zero Means 2**<em>n</em>” Field</strong></h3>
      
      <p class="noindent">Sometimes a 0 or negative value does not make much sense for a quantity, so it is
         encoded in an <em>n</em>-bit field with a 0 value being understood to mean 2<em>n</em>, and a nonzero value having its normal binary interpretation. An example is the length
         field of PowerPC’s <em>load string word immediate</em> (<code>lswi</code>) instruction, which occupies five bits. It is not useful to have an instruction that
         loads zero bytes when the length is an immediate quantity, but it is definitely useful
         to be able to load 32 bytes. The length field could be encoded with values from 0
         to 31 denoting lengths from 1 to 32, but the “zero means 32” convention results in
         simpler logic when the processor must also support a corresponding instruction with
         a variable (in-register) length that employs straight binary encoding (e.g., PowerPC’s
         <code>lswx</code> instruction).
      </p>
      
      <p class="indent">It is trivial to encode an integer in the range 1 to 2<sup><em>n</em></sup> into the “zero means 2<sup><em>n</em></sup>” encoding—simply mask the integer with 2<sup><em>n</em></sup> − 1. To do the decoding without a test-and-branch is not quite as simple, but here
         are some possibilities, illustrated for a 3-bit field. They all require three instructions,
         not counting possible loads of constants.
      </p>
      
      <div class="image"><a id="page_23"></a><img alt="Image" src="graphics/023equ01.jpg" /></div>
      
      <h3><a id="ch02lev12"></a><strong>2–12 Comparison Predicates</strong></h3>
      
      <p class="noindent">A “comparison predicate” is a function that compares two quantities, producing a single
         bit result of 1 if the comparison is <strong>true</strong>, and 0 if the comparison is <strong>false</strong>. Below we show branch-free expressions to evaluate the result into the sign position.
         To produce the 1/0 value used by some languages (e.g., C), follow the code with a
         <em>shift right</em> of 31. To produce the −1/0 result used by some other languages (e.g., Basic), follow
         the code with a <em>shift right signed</em> of 31.
      </p>
      
      <p class="indent">These formulas are, of course, not of interest on machines such as MIPS and our model
         RISC, which have comparison instructions that compute many of these predicates directly,
         placing a 0/1-valued result in a general purpose register.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/023equ02.jpg" /></div>
      
      <p class="indent">A machine instruction that computes the negative of the absolute value is handy here.
         We show this function as “nabs.” Unlike absolute value, it is well defined in that
         it never overflows. Machines that do not have nabs, but have the more usual abs, can
         use −abs(<strong><em>x</em></strong>) for nabs(<strong><em>x</em></strong>). If <strong><em>x</em></strong> is the maximum negative <a id="page_24"></a>number, this overflows twice, but the result is correct. (We assume that the absolute
         value and the negation of the maximum negative number is itself.) Because some machines
         have neither abs nor nabs, we give an alternative that does not use them.
      </p>
      
      <p class="indent">The “nlz” function is the number of leading 0’s in its argument. The “doz” function
         (<em>difference or zero</em>) is described on page <a href="ch02.html#page_41">41</a>. For <strong><em>x</em></strong> &gt; <strong><em>y, x</em> ≥ <em>y</em></strong>, and so on, interchange <strong><em>x</em></strong> and <strong><em>y</em></strong> in the formulas for <strong><em>x</em></strong> &lt; <strong><em>y, x</em> ≤ <em>y</em></strong>, and so on. The <em>add</em> of <strong>0x8000 0000</strong> can be replaced with any instruction that inverts the high-order bit (in <strong><em>x, y</em></strong>, or <strong><em>x</em> − <em>y</em></strong>).
      </p>
      
      <p class="indent">Another class of formulas can be derived from the observation that the predicate <strong><em>x</em></strong> &lt; <strong><em>y</em></strong> is given by the sign of <strong><em>x</em></strong>/2 − <strong><em>y</em></strong>/2, and the subtraction in that expression cannot overflow. The result can be fixed
         up by subtracting 1 in the cases in which the shifts discard essential information,
         as follows:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/024equ01.jpg" /></div>
      
      <p class="noindent">These execute in seven instructions on most machines (six if it has <em>and not</em>), which is no better than what we have above (five to seven instructions, depending
         upon the fullness of the set of logic instructions).
      </p>
      
      <p class="indent">The formulas above involving nlz are due to [Shep], and his formula for the <strong><em>x</em></strong> = <strong><em>y</em></strong> predicate is particularly useful, because a minor variation of it gets the predicate
         evaluated to a 1/0-valued result with only three instructions:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/024equ02.jpg" /></div>
      
      <p class="indent">Signed comparisons to 0 are frequent enough to deserve special mention. There are
         some formulas for these, mostly derived directly from the above. Again, the result
         is in the sign position.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/024equ03.jpg" /></div>
      
      <p class="indent"><a id="page_25"></a>Signed comparisons can be obtained from their unsigned counterparts by biasing the
         signed operands upward by 2<sup>31</sup> and interpreting the results as unsigned integers. The reverse transformation also
         works.<sup><a id="ch02fna2"></a><a href="footnotes.html#ch02fn2">2</a></sup> Thus, we have
      </p>
      
      <div class="image"><img alt="Image" src="graphics/025equ01.jpg" /></div>
      
      <p class="noindent">Similar relations hold for ≤, <span class="middle"><img alt="Image" src="graphics/le.jpg" /></span>, and so on. In these relations, one can use addition, subtraction, or <em>exclusive or</em> with 2<sup>31</sup>. They are all equivalent, as they simply invert the sign bit. An instruction like
         the basic RISC’s <em>add immediate shifted</em> is useful to avoid loading the constant 2<sup>31</sup>.
      </p>
      
      <p class="indent">Another way to get signed comparisons from unsigned is based on the fact that if <strong><em>x</em></strong> and <strong><em>y</em></strong> have the same sign, then <span class="middle"><img alt="Image" src="graphics/025fig01.jpg" /></span>, whereas if they have opposite signs, then <span class="middle"><img alt="Image" src="graphics/025fig02.jpg" /></span> [Lamp]. Again, the reverse transformation also works, so we have
      </p>
      
      <div class="image"><img alt="Image" src="graphics/025equ02.jpg" /></div>
      
      <p class="noindent">where <strong><em>x</em></strong><sub>31</sub> and <em>y</em><sub>31</sub> are the sign bits of <strong><em>x</em></strong> and <strong><em>y</em></strong>, respectively. Similar relations hold for ≤, <span class="middle"><img alt="Image" src="graphics/le.jpg" /></span>, and so on.
      </p>
      
      <p class="indent">Using either of these devices enables computing all the usual comparison predicates
         other than = and ≠ in terms of any one of them, with at most three additional instructions
         on most machines. For example, let us take <span class="middle"><img alt="Image" src="graphics/025fig03.jpg" /></span> as primitive, because it is one of the simplest to implement (it is the carry bit
         from <strong><em>y</em></strong> − <strong><em>x</em></strong>). Then the other predicates can be obtained as follows:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/025equ03.jpg" /></div>
      
      <div class="image"><a id="page_26"></a><img alt="Image" src="graphics/026equ01.jpg" /></div>
      
      <h4><strong>Comparison Predicates from the Carry Bit</strong></h4>
      
      <p class="noindent">If the machine can easily deliver the carry bit into a general purpose register, this
         may permit concise code for some of the comparison predicates. Below are several of
         these relations. The notation carry(<em>expression</em>) means the carry bit generated by the outermost operation in <em>expression</em>. We assume the carry bit for the subtraction <strong><em>x</em></strong> – <strong><em>y</em></strong> is what comes out of the adder for <strong><em>x</em></strong> + <span class="middle"><img alt="Image" src="graphics/y-bar.jpg" /></span> + 1, which is the complement of “borrow.”
      </p>
      
      <div class="image"><img alt="Image" src="graphics/026equ02.jpg" /></div>
      
      <p class="noindent">For <strong><em>x</em></strong> &gt; <strong><em>y</em></strong>, use the complement of the expression for <strong><em>x</em></strong> ≤ <strong><em>y</em></strong>, and similarly for other relations involving “greater than.”
      </p>
      
      <p class="indent">The GNU Superoptimizer has been applied to the problem of computing predicate expressions
         on the IBM RS/6000 computer and its close relative PowerPC [GK]. The RS/6000 has instructions
         for abs(<strong><em>x</em></strong>), nabs(<strong><em>x</em></strong>), doz(<strong><em>x, y</em></strong>), and a number of forms of <em>add</em> and <em>subtract</em> that use the carry bit. It was found that the RS/6000 can <a id="page_27"></a>compute all the integer predicate expressions with three or fewer elementary (one-cycle)
         instructions, a result that surprised even the architects of the machine. “All” includes
         the six two-operand signed comparisons and the four two-operand unsigned comparisons,
         all of these with the second operand being 0, and all in forms that produce a 1/0
         result or a –1/0 result. PowerPC, which lacks abs(<strong><em>x</em></strong>), nabs(<strong><em>x</em></strong>), and doz(<strong><em>x, y</em></strong>), can compute all the predicate expressions in four or fewer elementary instructions.
      </p>
      
      <h4><strong>How the Computer Sets the Comparison Predicates</strong></h4>
      
      <p class="noindent">Most computers have a way of evaluating the integer comparison predicates to a 1-bit
         result. The result bit may be placed in a “condition register” or, for some machines
         (such as our RISC model), in a general purpose register. In either case, the facility
         is often implemented by subtracting the comparison operands and then performing a
         small amount of logic on the result bits to determine the 1-bit comparison result.
      </p>
      
      <p class="indent">Below is the logic for these operations. It is assumed that the machine computes <strong><em>x</em></strong> − <strong><em>y</em></strong> as <strong><em>x</em></strong> + <span class="middle"><img alt="Image" src="graphics/y-bar.jpg" /></span> + 1, and the following quantities are available in the result:
      </p>
      
      <p class="indentaa"><em>C<sub>o</sub></em>, the carry out of the high-order position
      </p>
      
      <p class="indentaa"><em>C<sub>i</sub></em>, the carry into the high-order position
      </p>
      
      <p class="indentaa"><em>N</em>, the sign bit of the result
      </p>
      
      <p class="indentaa"><em>Z</em>, which equals 1 if the result, exclusive of <em>C<sub>o</sub></em>, is all-0, and is otherwise 0
      </p>
      
      <p class="noindent">Then we have the following in Boolean algebra notation (juxtaposition denotes <em>and</em>, + denotes <em>or</em>):
      </p>
      
      <div class="image"><img alt="Image" src="graphics/027equ01.jpg" /></div>
      
      <h3><a id="page_28"></a><a id="ch02lev13"></a><strong>2–13 Overflow Detection</strong></h3>
      
      <p class="noindent">“Overflow” means that the result of an arithmetic operation is too large or too small
         to be correctly represented in the target register. This section discusses methods
         that a programmer might use to detect when overflow has occurred, without using the
         machine’s “status bits” that are often supplied expressly for this purpose. This is
         important, because some machines do not have such status bits (e.g., MIPS), and even
         if the machine is so equipped, it is often difficult or impossible to access the bits
         from a high-level language.
      </p>
      
      <h4 id="ch02lev"><strong>Signed Add/Subtract</strong></h4>
      
      <p class="noindent">When overflow occurs on integer addition and subtraction, contemporary machines invariably
         discard the high-order bit of the result and store the low-order bits that the adder
         naturally produces. Signed integer overflow of addition occurs if and only if the
         operands have the same sign and the sum has a sign opposite to that of the operands.
         Surprisingly, this same rule applies even if there is a carry into the adder—that
         is, if the calculation is <strong><em>x</em></strong> + <strong><em>y</em></strong> + 1. This is important for the application of adding multiword signed integers, in
         which the last addition is a signed addition of two fullwords and a carry-in that
         may be 0 or +1.
      </p>
      
      <p class="indent">To prove the rule for addition, let <em>x</em> and <em>y</em> denote the values of the one-word signed integers being added, let <em>c</em> (carry-in) be 0 or 1, and assume for simplicity a 4-bit machine. Then if the signs
         of <em>x</em> and <em>y</em> are different,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/028equ01.jpg" /></div>
      
      <p class="noindent">or similar bounds apply if <em>x</em> is nonnegative and <em>y</em> is negative. In either case, by adding these inequalities and optionally adding in
         1 for <em>c</em>,
      </p>
      
      <p class="center">–8 ≤ <em>x</em> + <em>y</em> + <em>c</em> ≤ 7.
      </p>
      
      <p class="noindent">This is representable as a 4-bit signed integer, and thus overflow does not occur
         when the operands have opposite signs.
      </p>
      
      <p class="indent">Now suppose <em>x</em> and <em>y</em> have the same sign. There are two cases:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/028equ02.jpg" /></div>
      
      <p class="noindent">Thus,</p>
      
      <div class="image"><img alt="Image" src="graphics/028equ03.jpg" /></div>
      
      <p class="noindent"><a id="page_29"></a>Overflow occurs if the sum is not representable as a 4-bit signed integer—that is,
         if
      </p>
      
      <div class="image"><img alt="Image" src="graphics/029equ01.jpg" /></div>
      
      <p class="noindent">In case (a), this is equivalent to the high-order bit of the 4-bit sum being 0, which
         is opposite to the sign of <strong><em>x</em></strong> and <strong><em>y</em></strong>. In case (b), this is equivalent to the high-order bit of the 4-bit sum being 1,
         which again is opposite to the sign of <strong><em>x</em></strong> and <strong><em>y</em></strong>.
      </p>
      
      <p class="indent">For subtraction of multiword integers, the computation of interest is <strong><em>x</em></strong> − <strong><em>y</em></strong> − <strong><em>c</em></strong>, where again <strong><em>c</em></strong> is <strong>0</strong> or <strong>1</strong>, with a value of <strong>1</strong> representing a borrow-in. From an analysis similar to the above, it can be seen that
         overflow in the final value of <strong><em>x</em></strong> − <strong><em>y</em></strong> − <strong><em>c</em></strong> occurs if and only if <strong><em>x</em></strong> and <strong><em>y</em></strong> have opposite signs and the sign of <strong><em>x</em></strong> − <strong><em>y</em></strong> − <strong><em>c</em></strong> is opposite to that of <strong><em>x</em></strong> (or, equivalently, the same as that of <strong><em>y</em></strong>).
      </p>
      
      <p class="indent">This leads to the following expressions for the overflow predicate, with the result
         being in the sign position. Following these with a <em>shift right</em> or <em>shift right signed</em> of 31 produces a 1/0- or a −1/0-valued result.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/029equ02.jpg" /></div>
      
      <p class="noindent">By choosing the second alternative in the first column, and the first alternative
         in the second column (avoiding the <em>equivalence</em> operation), our basic RISC can evaluate these tests with three instructions in addition
         to those required to compute <strong><em>x</em> + <em>y</em> + <em>c</em></strong> or <strong><em>x</em></strong> − <strong><em>y</em></strong> − <strong><em>c</em></strong>. A fourth instruction (<em>branch if negative</em>) can be added to branch to code where the overflow condition is handled.
      </p>
      
      <p class="indent">If executing with overflow interrupts enabled, the programmer may wish to test to
         see if a certain addition or subtraction will cause overflow, in a way that does not
         cause it. One branch-free way to do this is as follows:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/029equ03.jpg" /></div>
      
      <p class="noindent">The assignment to <strong><em>z</em></strong> in the left column sets <strong><em>z</em></strong> = <strong>0x80000000</strong> if <strong><em>x</em></strong> and <strong><em>y</em></strong> have the same sign, and sets <strong><em>z</em></strong> = <strong>0</strong> if they differ. Then, the addition in the second expression is done with <strong><em>x</em> ⊕ <em>z</em></strong> and <strong><em>y</em></strong> having different signs, so it can’t overflow. If <strong><em>x</em></strong> and <strong><em>y</em></strong> are nonnegative, the sign bit in the second expression will be 1 if and only if (<strong><em>x</em></strong> − <strong>2<sup>31</sup></strong>) + <strong><em>y</em></strong> + <strong><em>c</em> ≥ 0</strong>—that is, iff <em>x</em> + <em>y</em> + <em>c</em> ≥ 2<sup>31</sup>, which is the condition for overflow in evaluating <strong><em>x</em></strong> + <strong><em>y</em></strong> + <strong><em>c</em></strong>. If <strong><em>x</em></strong> and <strong><em>y</em></strong> are negative, the sign bit in the second expression will be 1 iff (<strong><em>x</em></strong> + <strong>2<sup>31</sup></strong>) + <strong><em>y</em></strong> + <strong><em>c</em></strong> &lt; <strong>0</strong>—that is, iff <em>x</em> + <em>y</em> + <em>c</em> &lt; −2<sup>31</sup>, which <a id="page_30"></a>again is the condition for overflow. The <em>and</em> with <strong><em>z</em></strong> ensures the correct result (0 in the sign position) if <strong><em>x</em></strong> and <strong><em>y</em></strong> have opposite signs. Similar remarks apply to the case of subtraction (right column).
         The code executes in nine instructions on the basic RISC.
      </p>
      
      <p class="indent">It might seem that if the carry from addition is readily available, this might help
         in computing the signed overflow predicate. This does not seem to be the case; however,
         one method along these lines is as follows.
      </p>
      
      <p class="indent">If <strong><em>x</em></strong> is a signed integer, then <strong><em>x</em></strong> + <strong>2<sup>31</sup></strong> is correctly represented as an unsigned number and is obtained by inverting the high-order
         bit of <strong><em>x</em></strong>. Signed overflow in the positive direction occurs if <em>x</em> + <em>y</em> ≥ 2<sup>31</sup>—that is, if (<em>x</em> + 2<sup>31</sup>) + (<em>y</em> + 2<sup>31</sup>) ≥ 3 · 2<sup>31</sup>. This latter condition is characterized by carry occurring in the unsigned add (which
         means that the sum is greater than or equal to 2<sup>32</sup>) and the high-order bit of the sum being 1. Similarly, overflow in the negative direction
         occurs if the carry is 0 and the high-order bit of the sum is also 0.
      </p>
      
      <p class="indent">This gives the following algorithm for detecting overflow for signed addition:</p>
      
      <p class="indenthangingNP">Compute (<strong><em>x</em> ⊕ 2<sup>31</sup></strong>) + (<strong><em>y</em> ⊕ 2<sup>31</sup></strong>), giving sum <strong><em>s</em></strong> and carry <em>c</em>.<br />Overflow occurred iff <em>c</em> equals the high-order bit of <strong><em>s</em></strong>.
      </p>
      
      <p class="noindent">The sum is the correct sum for the signed addition, because inverting the high-order
         bits of both operands does not change their sum.
      </p>
      
      <p class="indent">For subtraction, the algorithm is the same except that in the first step a subtraction
         replaces the addition. We assume that the carry is that which is generated by computing
         <strong><em>x</em></strong> − <strong><em>y</em></strong> as <strong><em>x</em></strong> + <span class="middle"><img alt="Image" src="graphics/y-bar.jpg" /></span> + 1. The subtraction is the correct difference for the signed subtraction.
      </p>
      
      <p class="indent">These formulas are perhaps interesting, but on most machines they would not be quite
         as efficient as the formulas that do not even use the carry bit (e.g., overflow =
         (<strong><em>x</em></strong> ≡ <strong><em>y</em></strong>)&amp; (<strong><em>s</em></strong> ⊕ <strong><em>x</em></strong>) for addition, and (<strong><em>x</em></strong> ⊕ <strong><em>y</em></strong>) &amp;(<strong><em>d</em></strong> ⊕ <strong><em>x</em></strong>) for subtraction, where <strong><em>s</em></strong> and <strong><em>d</em></strong> are the sum and difference, respectively, of <strong><em>x</em></strong> and <strong><em>y</em></strong>).
      </p>
      
      <h4><strong>How the Computer Sets Overflow for Signed Add/Subtract</strong></h4>
      
      <p class="noindent">Machines often set “overflow” for signed addition by means of the logic “the carry
         into the sign position is not equal to the carry out of the sign position.” Curiously,
         this logic gives the correct overflow indication for both addition and subtraction,
         assuming the subtraction <strong><em>x</em></strong> − <strong><em>y</em></strong> is done by <strong><em>x</em></strong> + <span class="middle"><img alt="Image" src="graphics/y-bar.jpg" /></span> + 1. Furthermore, it is correct whether or not there is a carry- or borrow-in. This
         does not seem to lead to any particularly good methods for computing the signed overflow
         predicate in software, however, even though it is easy to compute the carry into the
         sign position. For addition and subtraction, the carry/borrow into the sign position
         is given by the sign bit after evaluating the following expressions (where <strong><em>c</em></strong> is <strong>0</strong> or <strong>1</strong>):
      </p>
      
      <div class="image"><img alt="Image" src="graphics/030equ01.jpg" /></div>
      
      <p class="noindent">In fact, these expressions give, at each position <em>i</em>, the carry/borrow into position <em>i</em>.
      </p>
      
      <h4><a id="page_31"></a><strong>Unsigned Add/Subtract</strong></h4>
      
      <p class="noindent">The following branch-free code can be used to compute the overflow predicate for unsigned
         add/subtract, with the result being in the sign position. The expressions involving
         a right shift are probably useful only when it is known that <strong><em>c</em></strong> = <strong>0</strong>. The expressions in brackets compute the carry or borrow generated from the least
         significant position.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/031equ01.jpg" /></div>
      
      <p class="indent">For unsigned <em>add</em>’s and <em>subtract</em>’s, there are much simpler formulas in terms of comparisons [MIPS]. For unsigned addition,
         overflow (carry) occurs if the sum is less (by unsigned comparison) than either of
         the operands. This and similar formulas are given below. Unfortunately, there is no
         way in these formulas to allow for a variable <strong><em>c</em></strong> that represents the carry- or borrow-in. Instead, the program must test <strong><em>c</em></strong>, and use a different type of comparison depending upon whether <strong><em>c</em></strong> is <strong>0</strong> or <strong>1</strong>.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/031equ02.jpg" /></div>
      
      <p class="noindent">The first formula for each case above is evaluated before the add/subtract that may
         overflow, and it provides a way to do the test without causing overflow. The second
         formula for each case is evaluated after the add/subtract that may overflow.
      </p>
      
      <p class="indent">There does not seem to be a similar simple device (using comparisons) for computing
         the signed overflow predicate.
      </p>
      
      <h4><strong>Multiplication</strong></h4>
      
      <p class="noindent">For multiplication, overflow means that the result cannot be expressed in 32 bits
         (it can always be expressed in 64 bits, whether signed or unsigned). Checking for
         overflow is simple if you have access to the high-order 32 bits of the product. Let
         us denote the two halves of the 64-bit product by hi(<strong><em>x</em> × <em>y</em></strong>) and lo(<strong><em>x</em> × <em>y</em></strong>). Then the overflow predicates can be computed as follows [MIPS]:
      </p>
      
      <div class="image"><a id="page_32"></a><img alt="Image" src="graphics/032equ01.jpg" /></div>
      
      <p class="indent">One way to check for overflow of multiplication is to do the multiplication and then
         check the result by dividing. Care must be taken not to divide by 0, and there is
         a further complication for signed multiplication. Overflow occurs if the following
         expressions are <strong>true</strong>:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/032equ02.jpg" /></div>
      
      <p class="noindent">The complication arises when <strong><em>x</em></strong> = −<strong>2<sup>31</sup></strong> and <strong><em>y</em></strong> = −<strong>1</strong>. In this case the multiplication overflows, but the machine may very well give a
         result of −<strong>2<sup>31</sup></strong>. This causes the division to overflow, and thus any result is possible (for some
         machines). Therefore, this case has to be checked separately, which is done by the
         term <strong><em>y</em></strong> &lt; <strong>0</strong> &amp; <strong><em>x</em></strong> = −<strong>2<sup>31</sup></strong>. The above expressions use the “conditional <em>and</em>” operator to prevent dividing by 0 (in C, use the <code>&amp;&amp;</code> operator).
      </p>
      
      <p class="indent">It is also possible to use division to check for overflow of multiplication without
         doing the multiplication (that is, without causing overflow). For unsigned integers,
         the product overflows iff <em>xy</em> &gt; 2<sup>32</sup> − 1, or <em>x</em> &gt; ((2<sup>32</sup> − 1)/<em>y</em>), or, since <em>x</em> is an integer, <em>x</em> &gt; <span class="entity">⌊</span>(2<sup>32</sup> − 1)/<em>y</em><span class="entity">⌋</span>. Expressed in computer arithmetic, this is
      </p>
      
      <div class="image"><img alt="Image" src="graphics/032equ03.jpg" /></div>
      
      <p class="indent">For signed integers, the determination of overflow of <strong><em>x</em></strong> * <strong><em>y</em></strong> is not so simple. If <strong><em>x</em></strong> and <strong><em>y</em></strong> have the same sign, then overflow occurs iff <em>xy</em> &gt; 2<sup>31</sup> − 1. If they have opposite signs, then overflow occurs iff <em>xy</em> &lt; −2<sup>31</sup>. These conditions can be tested as indicated in <a href="ch02.html#ch02tab2">Table 2–2</a>, which employs signed division. This test is awkward to implement, because of the
         four cases. It is difficult to unify the expressions very much because of problems
         with overflow and with not being able to represent the number +2<sup>31</sup>.
      </p>
      
      <p class="indent">The test can be simplified if unsigned division is available. We can use the absolute
         values of <strong><em>x</em></strong> and <strong><em>y</em></strong>, which are correctly represented under unsigned integer interpretation. The complete
         test can then be computed as shown below. The variable <strong><em>c</em></strong> = <strong>2<sup>31</sup></strong> − <strong>1</strong> if <strong><em>x</em></strong> and <strong><em>y</em></strong> have the same sign, and <strong><em>c</em></strong> = <strong>2<sup>31</sup></strong> otherwise.
      </p>
      
      <p class="tab-caption"><a id="ch02tab2"></a>T<small>ABLE</small> 2–2. O<small>VERFLOW</small> T<small>EST FOR</small> S<small>IGNED</small> M<small>ULTIPLICATION</small></p>
      
      <div class="image2"><img alt="Image" src="graphics/02tab02.jpg" /></div>
      
      <div class="image"><a id="page_33"></a><img alt="Image" src="graphics/033equ01.jpg" /></div>
      
      <p class="indent">The <em>number of leading zeros</em> instruction can be used to give an estimate of whether or not <strong><em>x</em></strong> * <strong><em>y</em></strong> will overflow, and the estimate can be refined to give an accurate determination.
         First, consider the multiplication of unsigned numbers. It is easy to show that if
         <strong><em>x</em></strong> and <strong><em>y</em></strong>, as 32-bit quantities, have <em>m</em> and <em>n</em> leading 0’s, respectively, then the 64-bit product has either <em>m</em> + <em>n</em> or <em>m</em> + <em>n</em> + 1 leading 0’s (or 64, if either <strong><em>x</em></strong> = <strong>0</strong> or <strong><em>y</em></strong> = <strong>0</strong>). Overflow occurs if the 64-bit product has fewer than 32 leading 0’s. Hence,
      </p>
      
      <p class="indenthangingNP">nlz(<strong><em>x</em></strong>) + nlz(<strong><em>y</em></strong>) ≥ 32: Multiplication definitely does not overflow.<br />nlz(<strong><em>x</em></strong>) + nlz(<strong><em>y</em></strong>) ≤ 30: Multiplication definitely does overflow.
      </p>
      
      <p class="indent">For nlz(<strong><em>x</em></strong>) + nlz(<strong><em>y</em></strong>) = 31, overflow may or may not occur. In this case, the overflow assessment can be
         made by evaluating <em>t</em> = <em>x</em><span class="entity">⌊</span><em>y</em>/2<span class="entity">⌋</span>. This will not overflow. Since <em>xy</em> is 2<em>t</em> or, if <em>y</em> is odd, 2<em>t</em> + <em>x</em>, the product <em>xy</em> overflows if <em>t</em> ≥ 2<sup>31</sup>. These considerations lead to a plan for computing <em>xy</em>, but branching to “overflow” if the product overflows. This plan is shown in <a href="ch02.html#ch02fig2">Figure 2–2</a>.
      </p>
      
      <p class="indent">For the multiplication of signed integers, we can make a partial determination of
         whether or not overflow occurs from the number of leading 0’s of nonnegative arguments,
         and the number of leading 1’s of negative arguments. Let
      </p>
      
      <div class="image"><img alt="Image" src="graphics/033equ02.jpg" /></div>
      
      <p class="codelink"><a href="images1.html#p02fig02" id="p02fig02a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting1"><a id="ch02fig2"></a>unsigned x, y, z, m, n, t;<br /><br />m = nlz(x);<br />n = nlz(y);<br />if (m + n &lt;= 30) goto overflow;<br />t = x*(y &gt;&gt; 1);<br />if ((int)t &lt; 0) goto overflow;<br />z = t*2;<br />if (y &amp; 1) {<br />   z = z + x;<br />   if (z &lt; x) goto overflow;<br />}<br />// z is the correct product of x and y.
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 2–2. Determination of overflow of unsigned multiplication.
      </p>
      
      <p class="noindent"><a id="page_34"></a>Then, we have
      </p>
      
      <p class="indenthangingNP"><strong><em>m</em></strong> + <strong><em>n</em></strong> ≥ <strong>34</strong>: Multiplication definitely does not overflow.<br /><strong><em>m</em></strong> + <strong><em>n</em></strong> ≤ <strong>31</strong>: Multiplication definitely does overflow.
      </p>
      
      <p class="indent">There are two ambiguous cases: 32 and 33. The case <em>m</em> + <em>n</em> = 33 overflows only when both arguments are negative and the true product is exactly
         2<sup>31</sup> (machine result is −2<sup>31</sup>), so it can be recognized by a test that the product has the correct sign (that is,
         overflow occurred if <strong><em>m</em></strong> ⊕ <strong><em>n</em></strong> ⊕ (<strong><em>m</em></strong> * <strong><em>n</em></strong>) &lt; <strong>0</strong>). When <em>m</em> + <em>n</em> = 32, the distinction is not so easily made.
      </p>
      
      <p class="indent">We will not dwell on this further, except to note that an overflow estimate for signed
         multiplication can also be made based on nlz(abs(<strong><em>x</em></strong>)) + nlz(abs(<strong><em>y</em></strong>)), but again there are two ambiguous cases (a sum of 31 or 32).
      </p>
      
      <h4><strong>Division</strong></h4>
      
      <p class="noindent">For the signed division <strong><em>x</em></strong> ÷ <strong><em>y</em></strong>, overflow occurs if the following expression is <strong>true</strong>:
      </p>
      
      <p class="center"><strong><em>y</em></strong> = <strong>0</strong> | (<strong><em>x</em></strong> = <strong>0x80000000</strong> &amp; <strong><em>y</em></strong> = −<strong>1</strong>)
      </p>
      
      <p class="noindent">Most machines signal overflow (or trap) for the indeterminate form <strong>0 ÷ 0</strong>.
      </p>
      
      <p class="indent">Straightforward code for evaluating this expression, including a final branch to the
         overflow handling code, consists of seven instructions, three of which are branches.
         There do not seem to be any particularly good tricks to improve on this, but here
         are a few possibilities:
      </p>
      
      <p class="center">[abs(<strong><em>y</em></strong> ⊕ <strong>0x80000000</strong>) | (abs(<strong><em>x</em></strong>) &amp; abs(<strong><em>y</em></strong> = <strong>0x80000000</strong>))] &lt; <strong>0</strong></p>
      
      <p class="noindent">That is, evaluate the large expression in brackets, and branch if the result is less
         than 0. This executes in about nine instructions, counting the load of the constant
         and the final branch, on a machine that has the indicated instructions and that gets
         the “compare to 0” for free.
      </p>
      
      <p class="indent">Some other possibilities are to first compute <strong><em>z</em></strong> from
      </p>
      
      <p class="center"><strong><em>z</em></strong> ← (<strong><em>x</em></strong> ⊕ <strong>0x80000000</strong>) | (<strong><em>y</em></strong> + <strong>1</strong>)
      </p>
      
      <p class="noindent">(three instructions on many machines), and then do the test and branch on <strong><em>y</em></strong> = <strong>0</strong> | <strong><em>z</em></strong> = <strong>0</strong> in one of the following ways:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/034equ01.jpg" /></div>
      
      <p class="noindent">These execute in nine, seven, and eight instructions, respectively, on a machine that
         has the indicated instructions. The last line represents a good method for PowerPC.
      </p>
      
      <p class="indent"><a id="page_35"></a>For the unsigned division <span class="middle"><img alt="Image" src="graphics/035fig01.jpg" /></span>, overflow occurs if and only if <strong><em>y</em></strong> = <strong>0</strong>.
      </p>
      
      <p class="indent">Some machines have a “long division” instruction (see page <a href="ch09.html#page_192">192</a>), and you may want to predict, using elementary instructions, when it would overflow.
         We will discuss this in terms of an instruction that divides a doubleword by a fullword,
         producing a fullword quotient and possibly also a fullword remainder.
      </p>
      
      <p class="indent">Such an instruction overflows if either the divisor is 0 or if the quotient cannot
         be represented in 32 bits. Typically, in these overflow cases both the quotient and
         remainder are incorrect. The remainder cannot overflow in the sense of being too large
         to represent in 32 bits (it is less than the divisor in magnitude), so the test that
         the remainder will be correct is the same as the test that the quotient will be correct.
      </p>
      
      <p class="indent">We assume the machine either has 64-bit general registers or 32-bit registers and
         there is no problem doing elementary operations (shifts, adds, and so forth) on 64-bit
         quantities. For example, the compiler might implement a doubleword integer data type.
      </p>
      
      <p class="indent">In the unsigned case the test is trivial: for <strong><em>x</em></strong> ÷ <strong><em>y</em></strong> with <strong><em>x</em></strong> a doubleword and <strong><em>y</em></strong> a fullword, the division will not overflow if (and only if) either of the following
         equivalent expressions is true.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/035fig02.jpg" /></div>
      
      <p class="noindent">On a 32-bit machine, the shifts need not be done; simply compare <strong><em>y</em></strong> to the register that contains the high-order half of <strong><em>x</em></strong>. To ensure correct results on a 64-bit machine, it is also necessary to check that
         the divisor <strong><em>y</em></strong> is a 32-bit quantity (e.g., check that <span class="middle"><img alt="Image" src="graphics/035fig04.jpg" /></span>.
      </p>
      
      <p class="indent">The signed case is more interesting. It is first necessary to check that <strong><em>y</em></strong> ≠ 0 and, on a 64-bit machine, that <strong><em>y</em></strong> is correctly represented in 32 bits (check that <span class="middle"><img alt="Image" src="graphics/035fig05.jpg" /></span>. Assuming these tests have been done, the table that follows shows how the tests
         might be done to determine precisely whether or not the quotient is representable
         in 32 bits by considering separately the four cases of the dividend and divisor each
         being positive or negative. The expressions in the table are in ordinary arithmetic,
         not computer arithmetic.
      </p>
      
      <p class="indent">In each column, each relation follows from the one above it in an if-and-only-if way.
         To remove the floor and ceiling functions, some relations from Theorem D1 on page
         <a href="ch09.html#page_183">183</a> are used.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/035fig03.jpg" /></div>
      
      <p class="indent"><a id="page_36"></a>As an example of interpreting this table, consider the leftmost column. It applies
         to the case in which <em>x</em> ≥ 0 and <em>y</em> &gt; 0. In this case the quotient is <span class="entity">⌊</span><em>x</em>/<em>y</em><span class="entity">⌋</span>, and this must be strictly less than 2<sup>31</sup> to be representable as a 32-bit quantity. From this it follows that the real number
         <em>x</em>/<em>y</em> must be less than 2<sup>31</sup>, or <em>x</em> must be less than 2<sup>31</sup><em>y</em>. This test can be implemented by shifting <em>y</em> left 31 positions and comparing the result to <em>x</em>.
      </p>
      
      <p class="indent">When the signs of <em>x</em> and <em>y</em> differ, the quotient of conventional division is <span class="entity">⌈</span><em>x</em>/<em>y</em><span class="entity">⌉</span>. Because the quotient is negative, it can be as small as −2<sup>31</sup>.
      </p>
      
      <p class="indent">In the bottom row of each column the comparisons are all of the same type (less than).
         Because of the possibility that <em>x</em> is the maximum negative number, in the third and fourth columns an unsigned comparison
         must be used. In the first two columns the quantities being compared begin with a
         leading 0-bit, so an unsigned comparison can be used there, too.
      </p>
      
      <p class="indent">These tests can, of course, be implemented by using conditional branches to separate
         out the four cases, doing the indicated arithmetic, and then doing a final compare
         and branch to the code for the overflow or non-overflow case. However, branching can
         be reduced by taking advantage of the fact that when <em>y</em> is negative, −<em>y</em> is used, and similarly for <em>x</em>. Hence the tests can be made more uniform by using the absolute values of <em>x</em> and <em>y</em>. Also, using a standard device for optionally doing the additions in the second and
         third columns results in the following scheme:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/036equ01.jpg" /></div>
      
      <p class="noindent">Using the three-instruction method of computing the absolute value (see page <a href="ch02.html#page_18">18</a>), on a 64-bit version of the basic RISC this amounts to 12 instructions, plus a conditional
         branch.
      </p>
      
      <h3><a id="ch02lev14"></a><strong>2–14 Condition Code Result of <em>Add, Subtract</em>, and <em>Multiply</em></strong></h3>
      
      <p class="noindent">Many machines provide a “condition code” that characterizes the result of integer
         arithmetic operations. Often there is only one <em>add</em> instruction, and the characterization reflects the result for both unsigned and signed
         interpretation of the operands and result (but not for mixed types). The characterization
         usually consists of the following:
      </p>
      
      <p class="indenthangingB">• Whether or not carry occurred (unsigned overflow)</p>
      
      <p class="indenthangingB">• Whether or not signed overflow occurred</p>
      
      <p class="indenthangingB">• Whether the 32-bit result, interpreted as a signed two’s-complement integer and
         ignoring carry and overflow, is negative, 0, or positive
      </p>
      
      <p class="indent"><a id="page_37"></a>Some older machines give an indication of whether the infinite precision result (that
         is, 33-bit result for <em>add</em>’s and <em>subtract</em>’s) is positive, negative, or 0. However, this indication is not easily used by compilers
         of high-level languages, and so has fallen out of favor.
      </p>
      
      <p class="indent">For addition, only nine of the 12 combinations of these events are possible. The ones
         that cannot occur are “no carry, overflow, result &gt; 0,” “no carry, overflow, result
         = 0,” and “carry, overflow, result &lt; 0.” Thus, four bits are, just barely, needed
         for the condition code. Two of the combinations are unique in the sense that only
         one value of inputs produces them: Adding 0 to itself is the only way to get “no carry,
         no overflow, result = 0,” and adding the maximum negative number to itself is the
         only way to get “carry, overflow, result = 0.” These remarks remain true if there
         is a “carry in”—that is, if we are computing <strong><em>x</em></strong> + <strong><em>y</em></strong> + 1.
      </p>
      
      <p class="indent">For subtraction, let us assume that to compute <strong><em>x</em></strong> – <strong><em>y</em></strong> the machine actually computes <strong><em>x</em></strong> + <span class="middle"><img alt="Image" src="graphics/y-bar.jpg" /></span> + 1, with the carry produced as for an <em>add</em> (in this scheme the meaning of “carry” is reversed for subtraction, in that carry
         = 1 signifies that the result fits in a single word, and carry = 0 signifies that
         the result does not fit in a single word). Then for subtraction, only seven combinations
         of events are possible. The ones that cannot occur are the three that cannot occur
         for addition, plus “no carry, no overflow, result = 0,” and “carry, overflow, result
         = 0.”
      </p>
      
      <p class="indent">If a machine’s multiplier can produce a doubleword result, then two <em>multiply</em> instructions are desirable: one for signed and one for unsigned operands. (On a 4-bit
         machine, in hexadecimal, <strong>F</strong> × <strong>F</strong> = <strong>01</strong> signed, and <strong>F</strong> × <strong>F</strong> = <strong>E1</strong> unsigned.) For these instructions, neither carry nor overflow can occur, in the sense
         that the result will always fit in a doubleword.
      </p>
      
      <p class="indent">For a multiplication instruction that produces a one-word result (the low-order word
         of the doubleword result), let us take “carry” to mean that the result does not fit
         in a word with the operands and result interpreted as unsigned integers, and let us
         take “overflow” to mean that the result does not fit in a word with the operands and
         result interpreted as signed two’s-complement integers. Then again, there are nine
         possible combinations of results, with the missing ones being “no carry, overflow,
         result &gt; 0,” “no carry, overflow, result = 0,” and “carry, no overflow, result = 0.”
         Thus, considering addition, subtraction, and multiplication together, ten combinations
         can occur.
      </p>
      
      <h3><a id="ch02lev15"></a><strong>2–15 Rotate Shifts</strong></h3>
      
      <p class="noindent">These are rather trivial. Perhaps surprisingly, this code works for <em>n</em> ranging from 0 to 32 inclusive, even if the shifts are mod-32.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/037equ01.jpg" /></div>
      
      <p class="indent">If your machine has double-length shifts, they can be used to do rotate shifts. These
         instructions might be written
      </p>
      
      <p class="codelink"><a id="page_38"></a><a href="images1.html#p02pro01" id="p02pro01a">Click here to view code image</a></p>
      
      <p class="programlisting1">shldi RT,RA,RB,I<br />shrdi RT,RA,RB,I
      </p>
      
      <p class="noindent">They treat the concatenation of RA and RB as a single double-length quantity, and
         shift it left or right by the amount given by the immediate field <code>I</code>. (If the shift amount is in a register, the instructions are awkward to implement
         on most RISCs because they require reading three registers.) The result of the left
         shift is the high-order word of the shifted double-length quantity, and the result
         of the right shift is the low-order word.
      </p>
      
      <p class="indent">Using <code>shldi</code>, a rotate left of Rx can be accomplished by
      </p>
      
      <p class="codelink"><a href="images1.html#p02pro02" id="p02pro02a">Click here to view code image</a></p>
      
      <p class="programlisting1">shldi RT,Rx,Rx,I</p>
      
      <p class="noindent">and similarly a rotate right shift can be accomplished with <code>shrdi</code>.
      </p>
      
      <p class="indent">A rotate left shift of one position can be accomplished by adding the contents of
         a register to itself with “end-around carry” (adding the carry that results from the
         addition to the sum in the low-order position). Most machines do not have that instruction,
         but on many machines it can be accomplished with two instructions: (1) add the contents
         of the register to itself, generating a carry (into a status register), and (2) add
         the carry to the sum.
      </p>
      
      <h3><a id="ch02lev16"></a><strong>2–16 Double-Length Add/Subtract</strong></h3>
      
      <p class="noindent">Using one of the expressions shown on page <a href="ch02.html#page_31">31</a> for overflow of unsigned addition and subtraction, we can easily implement double-length
         addition and subtraction without accessing the machine’s carry bit. To illustrate
         with double-length addition, let the operands be (<strong><em>x</em></strong><sub>1</sub>, <strong><em>x</em></strong><sub>0</sub>) and (<strong><em>y</em></strong><sub>1</sub>, <strong><em>y</em></strong><sub>0</sub>), and the result be (<strong><em>z</em></strong><sub>1</sub>, <strong><em>z</em></strong><sub>0</sub>). Subscript 1 denotes the most significant half, and subscript 0 the least significant.
         We assume that all 32 bits of the registers are used. The less significant words are
         unsigned quantities.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/038equ01.jpg" /></div>
      
      <p class="noindent">This executes in nine instructions. The second line can be <span class="middle"><img alt="Image" src="graphics/038fig01.jpg" /></span>, permitting a four-instruction solution on machines that have this comparison operator
         in a form that gives the result as a <strong>1</strong> or <strong>0</strong> in a register, such as the “<code>SLTU</code>” (<em>Set on Less Than Unsigned</em>) instruction on MIPS [MIPS].
      </p>
      
      <p class="indent">Similar code for double-length subtraction (<strong><em>x</em></strong> – <strong><em>y</em></strong>) is
      </p>
      
      <div class="image"><img alt="Image" src="graphics/038equ02.jpg" /></div>
      
      <p class="noindent"><a id="page_39"></a>This executes in eight instructions on a machine that has a full set of logical instructions.
         The second line can be <span class="middle"><img alt="Image" src="graphics/039fig01.jpg" /></span>, permitting a four-instruction solution on machines that have the “<code>SLTU</code>” instruction.
      </p>
      
      <p class="indent">Double-length addition and subtraction can be done in five instructions on most machines
         by representing the multiple-length data using only 31 bits of the least significant
         words, with the high-order bit being 0 except momentarily when it contains a carry
         or borrow bit.
      </p>
      
      <h3><a id="ch02lev17"></a><strong>2–17 Double-Length Shifts</strong></h3>
      
      <p class="noindent">Let (<strong><em>x</em></strong><sub>1</sub>, <strong><em>x</em></strong><sub>0</sub>) be a pair of 32-bit words to be shifted left or right as if they were a single 64-bit
         quantity, with <strong><em>x</em></strong><sub>1</sub> being the most significant half. Let (<strong><em>y</em></strong><sub>1</sub>, <strong><em>y</em></strong><sub>0</sub>) be the result, interpreted similarly. Assume the shift amount <em>n</em> is a variable ranging from 0 to 63. Assume further that the machine’s shift instructions
         are modulo 64 or greater. That is, a shift amount in the range 32 to 63 or –32 to
         –1 results in an all-0 word, unless the shift is a signed right shift, in which case
         the result is 32 sign bits from the word shifted. (This code will not work on the
         Intel x86 machines, which have mod-32 shifts.)
      </p>
      
      <p class="indent">Under these assumptions, the <em>shift left double</em> operation can be accomplished as follows (eight instructions):
      </p>
      
      <div class="image"><img alt="Image" src="graphics/039equ01.jpg" /></div>
      
      <p class="noindent">The main connective in the first assignment must be <em>or</em>, not <em>plus</em>, to give the correct result when <em>n</em> = 32. If it is known that 0 ≤ <em>n</em> ≤ 32, the last term of the first assignment can be omitted, giving a six-instruction
         solution.
      </p>
      
      <p class="indent">Similarly, a <em>shift right double unsigned</em> operation can be done with
      </p>
      
      <div class="image"><img alt="Image" src="graphics/039equ02.jpg" /></div>
      
      <p class="indent"><em>Shift right double signed</em> is more difficult, because of an unwanted sign propagation in one of the terms. Straightforward
         code follows:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/039equ03.jpg" /></div>
      
      <p class="indent">If your machine has the <em>conditional move</em> instructions, it is a simple matter to express this in branch-free code, in which
         form it takes eight instructions. If the conditional move instructions are not available,
         the operation can be done in ten <a id="page_40"></a>instructions by using the familiar device of constructing a mask with the <em>shift right signed 31</em> instruction to mask the unwanted sign propagating term:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/040equ01.jpg" /></div>
      
      <h3><a id="ch02lev18"></a><strong>2–18 Multibyte <em>Add, Subtract, Absolute Value</em></strong></h3>
      
      <p class="noindent">Some applications deal with arrays of short integers (usually bytes or halfwords),
         and often execution is faster if they are operated on a word at a time. For definiteness,
         the examples here deal with the case of four 1-byte integers packed into a word, but
         the techniques are easily adapted to other packings, such as a word containing a 12-bit
         integer and two 10-bit integers, and so on. These techniques are of greater value
         on 64-bit machines, because more work is done in parallel.
      </p>
      
      <p class="indent">Addition must be done in a way that blocks the carries from one byte into another.
         This can be accomplished by the following two-step method:
      </p>
      
      <p class="indenthangingN">1. Mask out the high-order bit of each byte of each operand and <em>add</em> (there will then be no carries across byte boundaries).
      </p>
      
      <p class="indenthangingN">2. Fix up the high-order bit of each byte with a 1-bit <em>add</em> of the two operands and the carry into that bit.
      </p>
      
      <p class="indent">The carry into the high-order bit of each byte is given by the high-order bit of each
         byte of the sum computed in step 1. The subsequent similar method works for subtraction:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/040equ02.jpg" /></div>
      
      <p class="noindent">These execute in eight instructions, counting the load of <strong>0x7F7F7F7F</strong>, on a machine that has a full set of logical instructions. (Change the <em>and</em> and <em>or</em> of <strong>0x80808080</strong> to <em>and not</em> and <em>or not</em>, respectively, of <strong>0x7F7F7F7F</strong>.)
      </p>
      
      <p class="indent">There is a different technique for the case in which the word is divided into only
         two fields. In this case, addition can be done by means of a 32-bit addition followed
         by subtracting out the unwanted carry. On page <a href="ch02.html#page_30">30</a> we noted that the expression (<strong><em>x</em></strong> + <strong><em>y</em></strong>) ⊕ <strong><em>x</em></strong> ⊕ <strong><em>y</em></strong> gives the carries into each position. Using this and similar observations about subtraction
         gives the following code for adding/subtracting two halfwords modulo 2<sup>16</sup> (seven instructions):
      </p>
      
      <div class="image1"><a id="page_41"></a><img alt="Image" src="graphics/041equ01.jpg" /></div>
      
      <p class="indent">Multibyte <em>absolute value</em> is easily done by complementing and adding 1 to each byte that contains a negative
         integer (that is, has its high-order bit on). The following code sets each byte of
         <strong><em>y</em></strong> equal to the absolute value of each byte of <strong><em>x</em></strong> (eight instructions):
      </p>
      
      <div class="image1"><img alt="Image" src="graphics/041equ02.jpg" /></div>
      
      <p class="noindent">The third line could as well be <strong><em>m</em> ← <em>a</em></strong> + <strong><em>a</em></strong> − <strong><em>b</em></strong>. The addition of <strong><em>b</em></strong> in the fourth line cannot carry across byte boundaries, because the quantity <strong><em>x</em> ⊕ <em>m</em></strong> has a high-order 0 in each byte.
      </p>
      
      <h3><a id="ch02lev19"></a><strong>2–19 Doz, Max, Min</strong></h3>
      
      <p class="noindent">The “doz” function is “difference or zero,” defined as follows:</p>
      
      <div class="image"><img alt="Image" src="graphics/041equ03.jpg" /></div>
      
      <p class="noindent">It has been called “first grade subtraction” because the result is 0 if you try to
         take away too much.<sup><a id="ch02fna3"></a><a href="footnotes.html#ch02fn3">3</a></sup> If implemented as a computer instruction, perhaps its most important use is to implement
         the max(<strong><em>x, y</em></strong>) and min(<strong><em>x, y</em></strong>) functions (in both signed and unsigned forms) in just two simple instructions, as
         will be seen. Implementing max(<strong><em>x, y</em></strong>) and min(<strong><em>x, y</em></strong>) in hardware is difficult because the machine would need paths from the output ports
         of the register file back to an input port, bypassing the adder. These paths are not
         normally present. If supplied, they would be in a region that’s often crowded with
         wiring for register bypasses. The situation is illustrated in <a href="ch02.html#ch02fig3">Figure 2–3</a>. The adder is used (by the instruction) to do the subtraction <strong><em>x</em></strong> − <strong><em>y</em></strong>. The high-order bits of the result of the subtraction (sign bit and carries, as described
         on page <a href="ch02.html#page_27">27</a>) define whether <strong><em>x</em> ≥ <em>y</em></strong> or <strong><em>x</em></strong> &lt; <strong><em>y</em></strong> The comparison result is fed to a multiplexor <a id="page_42"></a>(MUX) that selects either <strong><em>x</em></strong> or <strong><em>y</em></strong> as the result to write into the target register. These paths, from register file
         outputs <strong><em>x</em></strong> and <strong><em>y</em></strong> to the multiplexor, are not normally present and would have little use. The <em>difference or zero</em> instructions can be implemented without these paths because it is the output of the
         adder (or 0) that is fed back to the register file.
      </p>
      
      <div class="image"><a id="ch02fig3"></a><img alt="Image" src="graphics/02fig03.jpg" /></div>
      
      <p class="fig-caption">F<small>IGURE</small> 2–3. Implementing max(<strong><em>x, y</em></strong>) and min(<strong><em>x, y</em>)</strong>.
      </p>
      
      <p class="indent">Using <em>difference or zero</em>, max(<strong><em>x, y</em></strong>) and min(<strong><em>x, y</em></strong>) can be implemented in two instructions as follows:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/042equ01.jpg" /></div>
      
      <p class="indent">In the signed case, the result of the <em>difference or zero</em> instruction can be negative. This happens if overflow occurs in the subtraction.
         Overflow should be ignored; the addition of <strong><em>y</em></strong> or subtraction from <strong><em>x</em></strong> will overflow again, and the result will be correct. When doz(<strong><em>x, y</em></strong>) is negative, it is actually the correct difference if it is interpreted as an unsigned
         integer.
      </p>
      
      <p class="indent">Suppose your computer does not have the <em>difference or zero</em> instructions, but you want to code doz(<strong><em>x, y</em></strong>), max(<strong><em>x, y</em></strong>), and so forth, in an efficient branch-free way. In the next few paragraphs we show
         how these functions might be coded if your machine has the <em>conditional move</em> instructions, comparison predicates, efficient access to the carry bit, or none of
         these.
      </p>
      
      <p class="indent">If your machine has the <em>conditional move</em> instructions, it can get doz(<strong><em>x, y</em></strong>) in three instructions, and destructive<sup><a id="ch02fna4"></a><a href="footnotes.html#ch02fn4">4</a></sup> max(<strong><em>x, y</em></strong>) and min(<strong><em>x, y</em></strong>) in two instructions. For example, on the full RISC, <strong><em>z</em></strong> ← doz(<strong><em>x, y</em></strong>) can be calculated as follows (r0 is a permanent zero register):
      </p>
      
      <p class="codelink"><a id="page_43"></a><a href="images1.html#p043equ01" id="p043equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">sub    z,x,y       Set z = x - y.<br />cmplt  t,x,y       Set t = 1 if x &lt; y, else 0.<br />movne  z,t,r0      Set z = 0 if x &lt; y.
      </p>
      
      <p class="noindent">Also on the full RISC, <strong><em>x</em> ←</strong> max(<strong><em>x, y</em></strong>) can be calculated as follows:
      </p>
      
      <p class="codelink"><a href="images1.html#p043equ02" id="p043equ02a">Click here to view code image</a></p>
      
      <p class="programlisting1">cmplt   t,x,y      Set t = 1 if x &lt; y, else 0.<br />movne   x,t,y      Set x = y if x &lt; y.
      </p>
      
      <p class="noindent">The min function, and the unsigned counterparts, are obtained by changing the comparison
         conditions.
      </p>
      
      <p class="indent">These functions can be computed in four or five instructions using comparison predicates
         (three or four if the comparison predicates give a result of –1 for “true”):
      </p>
      
      <div class="image"><img alt="Image" src="graphics/043equ03.jpg" /></div>
      
      <p class="indent">On some machines, the carry bit may be a useful aid to computing the unsigned versions
         of these functions. Let carry(<strong><em>x</em></strong> − <strong><em>y</em></strong>) denote the bit that comes out of the adder for the operation <strong><em>x</em></strong>+ <span class="middle"><img alt="Image" src="graphics/y-bar.jpg" /></span> + <strong><em>1</em></strong>, moved to a GPR. Thus, carry(<strong><em>x</em></strong> − <strong><em>y</em></strong>) = 1 iff <strong><em>x</em> ≥ <em>y</em></strong>. Then we have
      </p>
      
      <div class="image"><img alt="Image" src="graphics/043equ04.jpg" /></div>
      
      <p class="indent">On most machines that have a <em>subtract</em> that generates a carry or borrow, and another form of <em>subtract</em> that uses that carry or borrow as an input, the expression carry(<strong><em>x</em></strong> − <strong><em>y</em></strong>) − <strong>1</strong> can be computed in one more instruction after the subtraction of <strong><em>y</em></strong> from <strong><em>x</em></strong>. For example, on the Intel x86 machines, minu(<strong><em>x, y</em></strong>) can be computed in four instructions as follows:
      </p>
      
      <p class="codelink"><a href="images1.html#p043equ05" id="p043equ05a">Click here to view code image</a></p>
      
      <p class="programlisting1">sub eax,ecx   ; Inputs x and y are in eax and ecx resp.<br />sbb edx,edx   ; edx = 0 if x &gt;= y, else -1.<br />and eax,edx   ; 0 if x &gt;= y, else x - y.<br />add eax,ecx   ; Add y, giving y if x &gt;= y, else x.
      </p>
      
      <p class="noindent">In this way, all three of the functions can be computed in four instructions (three
         instructions for dozu(<strong><em>x, y</em></strong>) if the machine has <em>and with complement</em>).
      </p>
      
      <p class="indent"><a id="page_44"></a>A method that applies to nearly any RISC is to use one of the above expressions that
         employ a comparison predicate, and to substitute for the predicate one of the expressions
         given on page <a href="ch02.html#page_23">23</a>. For example:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/044equ01.jpg" /></div>
      
      <p class="noindent">These require from seven to ten instructions, depending on the computer’s instruction
         set, plus one more to get max or min.
      </p>
      
      <p class="indent">These operations can be done in four branch-free basic RISC instructions if it is
         known that −2<sup>31</sup> ≤ <em>x</em> − <em>y</em> ≤ 2<sup>31</sup> − 1 (that is an expression in ordinary arithmetic, not computer arithmetic). The
         same code works for both signed and unsigned integers, with the same restriction on
         <em>x</em> and <em>y</em>. A sufficient condition for these formulas to be valid is that, for signed integers,
         −2<sup>30</sup> ≤ <em>x, y</em> ≤ 2<sup>30</sup> − 1, and for unsigned integers, 0 ≤ <em>x,y</em> ≤2<sup>31</sup> −1.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/044equ02.jpg" /></div>
      
      <p class="indent">Some uses of the <em>difference or zero</em> instruction are given here. In these, the result of doz(<strong><em>x, y</em></strong>) must be interpreted as an unsigned integer.
      </p>
      
      <p class="indenthangingN">1. It directly implements the Fortran IDIM function.</p>
      
      <p class="indenthangingN">2. To compute the absolute value of a difference [Knu7]:</p>
      
      <div class="image"><img alt="Image" src="graphics/044equ03.jpg" /></div>
      
      <p class="indenthanging">Corollary: <strong>|<em>x</em>|</strong> = doz(<strong><em>x</em>, 0</strong>) + doz(<strong>0, <em>x</em></strong>) (other three-instruction solutions are given on page <a href="ch02.html#page_18">18</a>).
      </p>
      
      <p class="indenthangingN">3. To clamp the upper limit of the true sum of unsigned integers <strong><em>x</em></strong> and <strong><em>y</em></strong> to the maximum positive number (2<sup>32</sup> − 1) [Knu7]:
      </p>
      
      <p class="center">¬dozu(¬<strong><em>x, y</em></strong>).
      </p>
      
      <p class="indenthangingN">4. Some comparison predicates (four instructions each):</p>
      
      <div class="image"><img alt="Image" src="graphics/044equ04.jpg" /></div>
      
      <p class="indenthangingN"><a id="page_45"></a>5. The carry bit from the addition <strong><em>x</em></strong> + <strong><em>y</em></strong> (five instructions):
      </p>
      
      <div class="image"><img alt="Image" src="graphics/045equ01.jpg" /></div>
      
      <p class="indent">The expression doz(<strong><em>x</em></strong>, −<strong><em>y</em></strong>), with the result interpreted as an unsigned integer, is in most cases the true sum
         <em>x</em> + <em>y</em> with the lower limit clamped at 0. However, it fails if <strong><em>y</em></strong> is the maximum negative number.
      </p>
      
      <p class="indent">The IBM RS/6000 computer, and its predecessor the 801, have the signed version of
         <em>difference or zero</em>. Knuth’s MMIX computer [Knu7] has the unsigned version (including some varieties
         that operate on parts of words in parallel). This raises the question of how to get
         the signed version from the unsigned version, and vice versa. This can be done as
         follows (where the additions and subtractions simply complement the sign bit):
      </p>
      
      <p class="center">doz(<strong><em>x</em>,<em>y</em></strong>) = dozu(<strong><em>x</em></strong> + 2<sup>31</sup>, <em>y</em> + 2<sup>31</sup>),<br />dozu(<strong><em>x</em>,<em>y</em></strong>) = doz(<strong><em>x</em></strong> − 2<sup>31</sup>, <em>y</em> − 2<sup>31</sup>).
      </p>
      
      <p class="indent">Some other identities that may be useful are:</p>
      
      <p class="center">doz(¬<strong><em>x</em>, ¬<em>y</em></strong>) = doz(<strong><em>y, x</em></strong>),<br />dozu(¬<strong><em>x</em>, ¬<em>y</em></strong>) = dozu(<strong><em>y, x</em></strong>).
      </p>
      
      <p class="noindent">The relation doz(−<strong><em>x</em></strong>, −<strong><em>y</em></strong>) = doz(<strong><em>y, x</em></strong>) fails if either <strong><em>x</em></strong> or <strong><em>y</em></strong>, but not both, is the maximum negative number.
      </p>
      
      <h3><a id="ch02lev20"></a><strong>2–20 Exchanging Registers</strong></h3>
      
      <p class="noindent">A very old trick is exchanging the contents of two registers without using a third
         [IBM]:
      </p>
      
      <p class="center"><strong><em>x</em></strong> ← <strong><em>x</em></strong> ⊕ <strong><em>y</em></strong><br /><strong><em>y</em></strong> ← <strong><em>y</em></strong> ⊕ <strong><em>x</em></strong><br /><strong><em>x</em></strong> ← <strong><em>x</em></strong> ⊕ <strong><em>y</em></strong></p>
      
      <p class="indent">This works well on a two-address machine. The trick also works if ⊕ is replaced by
         the ≡ logical operation (complement of <em>exclusive or</em>) and can be made to work in various ways with <em>add</em>’s and <em>subtract</em>’s:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/045equ03.jpg" /></div>
      
      <p class="noindent">Unfortunately, each of these has an instruction that is unsuitable for a two-address
         machine, unless the machine has “reverse subtract.”
      </p>
      
      <p class="indent"><a id="page_46"></a>This little trick can actually be useful in the application of double buffering, in
         which two pointers are swapped. The first instruction can be factored out of the loop
         in which the swap is done (although this negates the advantage of saving a register):
      </p>
      
      <div class="image"><img alt="Image" src="graphics/046equ01.jpg" /></div>
      
      <h4><strong>Exchanging Corresponding Fields of Registers</strong></h4>
      
      <p class="noindent">The problem here is to exchange the contents of two registers <strong><em>x</em></strong> and <strong><em>y</em></strong> wherever a mask bit <strong><em>m</em></strong><sub><em>i</em></sub> = 1, and to leave <strong><em>x</em></strong> and <strong><em>y</em></strong> unaltered wherever <strong><em>m</em></strong><sub><em>i</em></sub> = 0. By “corresponding” fields, we mean that no shifting is required. The 1-bits
         of <strong><em>m</em></strong> need not be contiguous. The straightforward method is as follows:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/046equ02.jpg" /></div>
      
      <p class="noindent">By using “temporaries” for the four <em>and</em> expressions, this can be seen to require seven instructions, assuming that either
         <strong><em>m</em></strong> or <span class="middle"><img alt="Image" src="graphics/m-bar.jpg" /></span> can be loaded with a single instruction and the machine has <em>and not</em> as a single instruction. If the machine is capable of executing the four (independent)
         <em>and</em> expressions in parallel, the execution time is only three cycles.
      </p>
      
      <p class="indent">A method that is probably better (five instructions, but four cycles on a machine
         with unlimited instruction-level parallelism) is shown in column (a) below. It is
         suggested by the “three <em>exclusive or</em>” code for exchanging registers.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/046equ03.jpg" /></div>
      
      <p class="noindent">The steps in column (b) do the same exchange as that of column (a), but column (b)
         is useful if <strong><em>m</em></strong> does not fit in an immediate field, but <span class="middle"><img alt="Image" src="graphics/m-bar.jpg" /></span> does, and the machine has the <em>equivalence</em> instruction.
      </p>
      
      <p class="indent">Still another method is shown in column (c) above [GLS1]. It also takes five instructions
         (again assuming one instruction must be used to load <strong><em>m</em></strong> into a register), but executes in only three cycles on a machine with sufficient
         instruction-level parallelism.
      </p>
      
      <h4><a id="page_47"></a><strong>Exchanging Two Fields of the Same Register</strong></h4>
      
      <p class="noindent">Assume a register <strong><em>x</em></strong> has two fields (of the same length) that are to be swapped, without altering other
         bits in the register. That is, the object is to swap fields <em>B</em> and <em>D</em> without altering fields <em>A, C</em>, and <em>E</em>, in the computer word illustrated below. The fields are separated by a shift distance
         <em>k</em>.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/047fig01.jpg" /></div>
      
      <p class="indent">Straightforward code would shift <em>D</em> and <em>B</em> to their new positions, and combine the words with <em>and</em> and <em>or</em> operations, as follows:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/047equ01.jpg" /></div>
      
      <p class="noindent">Here, <strong><em>m</em></strong> is a mask with 1’s in field <em>D</em> (and 0’s elsewhere), and <strong><em>m</em></strong>′ is a mask with 1’s in fields <em>A, C</em>, and <em>E</em>. This code requires 11 instructions and six cycles on a machine with unlimited instruction-level
         parallelism, allowing for four instructions to generate the two masks.
      </p>
      
      <p class="indent">A method that requires only eight instructions and executes in five cycles, under
         the same assumptions, is shown below [GLS1]. It is similar to the code in column (c)
         on page <a href="ch02.html#page_46">46</a> for interchanging corresponding fields of two registers. Again, <strong><em>m</em></strong> is a mask that isolates field <em>D</em>.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/047equ02.jpg" /></div>
      
      <p class="noindent">The idea is that <strong><em>t</em></strong><sub>1</sub> contains <em>B</em> ⊕ <em>D</em> in position <em>D</em> (and 0’s elsewhere), and <strong><em>t</em></strong><sub>2</sub> contains <em>B</em> ⊕ <em>D</em> in position <em>B</em>. This code, and the straightforward code given earlier, work correctly if <em>B</em> and <em>D</em> are “split fields”—that is, if the 1-bits of mask <strong><em>m</em></strong> are not contiguous.
      </p>
      
      <h4><strong>Conditional Exchange</strong></h4>
      
      <p class="noindent">The exchange methods of the preceding two sections, which are based on <em>exclusive or</em>, degenerate into no-operations if the mask <strong><em>m</em></strong> is 0. Hence, they can perform an exchange of entire registers, or of corresponding
         fields of two registers, or of two fields of the same register, if <strong><em>m</em></strong> is set to all 1’s if some condition <em>c</em> is <strong>true</strong>, and to all 0’s if <em>c</em> is <strong>false</strong>. This gives branch-free code if <strong><em>m</em></strong> can be set up without branching.
      </p>
      
      <h3><a id="page_48"></a><a id="ch02lev21"></a><strong>2–21 Alternating among Two or More Values</strong></h3>
      
      <p class="noindent">Suppose a variable <em>x</em> can have only two possible values <em>a</em> and <em>b</em>, and you wish to assign to <em>x</em> the value other than its current one, and you wish your code to be independent of
         the values of <em>a</em> and <em>b</em>. For example, in a compiler <em>x</em> might be an opcode that is known to be either <em>branch true</em> or <em>branch false</em>, and whichever it is, you want to switch it to the other. The values of the opcodes
         <em>branch true</em> and <em>branch false</em> are arbitrary, probably defined by a C <code>#define</code> or <code>enum</code> declaration in a header file.
      </p>
      
      <p class="indent">The straightforward code to do the switch is</p>
      
      <p class="codelink"><a href="images1.html#p02pro03" id="p02pro03a">Click here to view code image</a></p>
      
      <p class="programlisting1">if (x == a) x = b;<br />else x = a;
      </p>
      
      <p class="noindent">or, as is often seen in C programs,</p>
      
      <p class="codelink"><a href="images1.html#p02pro04" id="p02pro04a">Click here to view code image</a></p>
      
      <p class="programlisting1">x = x == a ? b : a;</p>
      
      <p class="noindent">A far better (or at least more efficient) way to code it is either</p>
      
      <div class="image"><img alt="Image" src="graphics/048equ01.jpg" /></div>
      
      <p class="noindent">If <strong><em>a</em></strong> and <strong><em>b</em></strong> are constants, these require only one or two basic RISC instructions. Of course,
         overflow in calculating <strong><em>a</em></strong> + <strong><em>b</em></strong> can be ignored.
      </p>
      
      <p class="indent">This raises the question: Is there some particularly efficient way to cycle among
         three or more values? That is, given three arbitrary but distinct constants <em>a, b</em>, and <em>c</em>, we seek an easy-to-evaluate function <em>f</em> that satisfies
      </p>
      
      <div class="image"><img alt="Image" src="graphics/048equ02.jpg" /></div>
      
      <p class="indent">It is perhaps interesting to note that there is always a polynomial for such a function.
         For the case of three constants,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/02equ05.jpg" /></div>
      
      <p class="noindent">(The idea is that if <em>x</em> = <em>a</em>, the first and last terms vanish, and the middle term simplifies to <em>b</em>, and so on.) This requires 14 arithmetic operations to evaluate, and for arbitrary
         <em>a, b</em>, and <em>c</em>, the intermediate results exceed the computer’s word size. But it is just a quadratic;
         if written in the usual form for a polynomial and evaluated using <a id="page_49"></a>Horner’s rule,<sup><a id="ch02fna5"></a><a href="footnotes.html#ch02fn5">5</a></sup> it would require only five arithmetic operations (four for a quadratic with integer
         coefficients, plus one for a final division). Rearranging Equation (5) accordingly
         gives
      </p>
      
      <div class="image"><img alt="Image" src="graphics/049equ01.jpg" /></div>
      
      <p class="noindent">This is getting too complicated to be interesting, or practical.</p>
      
      <p class="indent">Another method, similar to Equation (5) in that just one of the three terms survives,
         is
      </p>
      
      <p class="center"><em>f</em>(<strong><em>x</em></strong>) = ((−(<strong><em>x</em></strong> = <strong><em>c</em></strong>)) &amp; <strong><em>a</em></strong>) + ((−(<strong><em>x</em></strong> = <strong><em>a</em></strong>)) &amp; <strong><em>b</em></strong>) + ((−(<strong><em>x</em></strong> = <strong><em>b</em></strong>)) &amp; <strong><em>c</em></strong>).
      </p>
      
      <p class="noindent">This takes 11 instructions if the machine has the <em>equal</em> predicate, not counting loads of constants. Because the two addition operations are
         combining two 0 values with a nonzero, they can be replaced with <em>or</em> or <em>exclusive or</em> operations.
      </p>
      
      <p class="indent">The formula can be simplified by precalculating <strong><em>a</em></strong> – <strong><em>c</em></strong> and <strong><em>b</em></strong> – <strong><em>c</em></strong>, and then using [GLS1]:
      </p>
      
      <p class="indenthangingNP"><em>f</em>(<strong><em>x</em></strong>) = ((−(<strong><em>x</em></strong> = <strong><em>c</em></strong>)) &amp; (<strong><em>a</em></strong> – <strong><em>c</em></strong>)) + ((−(<strong><em>x</em></strong> = <strong><em>a</em></strong>)) &amp; (<strong><em>b</em></strong> – <strong><em>c</em></strong>)) + <strong><em>c</em></strong>, or
      </p>
      
      <p class="indenthangingNP"><em>f</em> (<strong><em>x</em></strong>) = ((−(<strong><em>x</em></strong> = <strong><em>c</em></strong>)) &amp; (<strong><em>a</em></strong> ⊕ <strong><em>c</em></strong>)) ⊕ ((–(<strong><em>x</em></strong> = <strong><em>a</em></strong>)) &amp; (<strong><em>b</em></strong> ⊕ <strong><em>c</em></strong>)) ⊕<strong><em>c</em></strong>.
      </p>
      
      <p class="noindent">Each of these operations takes eight instructions, but on most machines these are
         probably no better than the straightforward C code shown below, which executes in
         four to six instructions for small <code>a</code>, <code>b</code>, and <code>c</code>.
      </p>
      
      <p class="codelink"><a href="images1.html#p02pro05" id="p02pro05a">Click here to view code image</a></p>
      
      <p class="programlisting1">if (x == a) x = b;<br />else if (x == b) x = c;<br />else x = a;
      </p>
      
      <p class="indent">Pursuing this matter, there is an ingenious branch-free method of cycling among three
         values on machines that do not have comparison predicate instructions [GLS1]. It executes
         in eight instructions on most machines.
      </p>
      
      <p class="indent">Because <strong><em>a, b</em></strong>, and <strong><em>c</em></strong> are distinct, there are two bit positions, <em>n</em><sub>1</sub> and <em>n</em><sub>2</sub>, where the bits of <strong><em>a, b</em></strong>, and <strong><em>c</em></strong> are not all the same, and where the “odd one out” (the one <a id="page_50"></a>whose bit differs in that position from the other two) is different in positions <em>n</em><sub>1</sub> and <em>n</em><sub>2</sub>. This is illustrated below for the values 21, 31, and 20, shown in binary.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/050equ01.jpg" /></div>
      
      <p class="indent">Without loss of generality, rename <strong><em>a, b</em></strong>, and <strong><em>c</em></strong> so that <strong><em>a</em></strong> has the odd one out in position <em>n</em><sub>1</sub> and <strong><em>b</em></strong> has the odd one out in position <em>n</em><sub>2</sub>, as shown above. Then there are two possibilities for the values of the bits at position
         <em>n</em><sub>1</sub>, namely (<strong><em>a</em></strong><sub><em>n</em><sub>1</sub></sub>, <strong><em>b</em></strong><sub><em>n</em><sub>1</sub></sub>, <strong><em>c</em></strong><sub><em>n</em><sub>1</sub></sub>) = (0, 1, 1) or (1, 0, 0). Similarly, there are two possibilities for the bits at
         position <em>n</em><sub>2</sub>, namely (<strong><em>a</em></strong><sub><em>n</em><sub>2</sub></sub>, <strong><em>b</em></strong><sub><em>n</em><sub>2</sub></sub>, <strong><em>c</em></strong><sub><em>n</em><sub>2</sub></sub>) = (0, 1, 0) or (1, 0, 1). This makes four cases in all, and formulas for each of
         these cases are shown below.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/050equ02.jpg" /></div>
      
      <p class="indent">In these formulas, the left operand of each multiplication is a single bit. A multiplication
         by 0 or 1 can be converted into an <em>and</em> with a value of 0 or all 1’s. Thus, the formulas can be rewritten as illustrated
         below for the first formula.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/050equ03.jpg" /></div>
      
      <p class="noindent">Because all variables except <strong><em>x</em></strong> are constants, this can be evaluated in eight instructions on the basic RISC. Here
         again, the additions and subtractions can be replaced with <em>exclusive or</em>.
      </p>
      
      <p class="indent">This idea can be extended to cycling among four or more constants. The essence of
         the idea is to find bit positions <em>n</em><sub>1</sub>, <em>n</em><sub>2</sub>, ..., at which the bits uniquely identify the constants. For four constants, three
         bit positions always suffice. Then <a id="page_51"></a>(for four constants) solve the following equation for <em>s, t, u</em>, and <em>v</em> (that is, solve the system of four linear equations in which <em>f</em>(<em>x</em>) is <em>a, b, c</em>, or <em>d</em>, and the coefficients <em>x<sub>n<sub>i</sub></sub></em> are 0 or 1):
      </p>
      
      <p class="center"><em>f</em>(<em>x</em>) = <em>x</em><sub><em>n</em><sub>1</sub></sub><em>s</em> + <em>x</em><sub><em>n</em><sub>2</sub></sub><em>t</em> + <em>x</em><sub><em>n</em><sub>3</sub></sub><em>u</em> + <em>v</em></p>
      
      <p class="noindent">If the four constants are uniquely identified by only two bit positions, the equation
         to solve is
      </p>
      
      <p class="center"><em>f</em>(<em>x</em>) = <em>x</em><sub><em>n</em><sub>1</sub></sub><em>s</em> + <em>x</em><sub><em>n</em><sub>2</sub></sub><em>t</em> + <em>x</em><sub><em>n</em><sub>1</sub></sub> <em>x</em><sub><em>n</em><sub>2</sub></sub><em>u</em> + <em>v</em>.
      </p>
      
      <h3><a id="ch02lev22"></a><strong>2–22 A Boolean Decomposition Formula</strong></h3>
      
      <p class="noindent">In this section, we have a look at the minimum number of binary Boolean operations,
         or instructions, that suffice to implement any Boolean function of three, four, or
         five variables. By a “Boolean function” we mean a Boolean-valued function of Boolean
         arguments.
      </p>
      
      <p class="indent">Our notation for Boolean algebra uses “+” for <em>or</em>, juxtaposition for <em>and</em>, ⊕ for <em>exclusive or</em>, and either an overbar or a prefix ¬ for <em>not</em>. These operators can be applied to single-bit operands or “bitwise” to computer words.
         Our main result is the following theorem:
      </p>
      
      <p class="indent">T<small>HEOREM</small>. <em>If f(x, y, z) is a Boolean function of three variables, then it can be decomposed
            into the form g</em>(<em>x, y</em>) ⊕ <em>zh</em>(<em>x, y</em>), <em>where g and h are Boolean functions of two variables.<sup><a id="ch02fna6"></a><a href="footnotes.html#ch02fn6">6</a></sup></em></p>
      
      <p class="indent"><em>Proof</em> [Ditlow]. <em>f</em>(<em>x, y, z</em>) can be expressed as a sum of minterms, and then <span class="middle"><img alt="Image" src="graphics/z-bar.jpg" /></span> and <em>z</em> can be factored out of their terms, giving
      </p>
      
      <div class="image"><img alt="Image" src="graphics/051equ01.jpg" /></div>
      
      <p class="noindent">Because the operands to “+” cannot both be 1, the <em>or</em> can be replaced with <em>exclusive or</em>, giving
      </p>
      
      <div class="image"><img alt="Image" src="graphics/051equ02.jpg" /></div>
      
      <p class="noindent">where we have twice used the identity (<em>a</em> ⊕ <em>b</em>) <em>c</em> = <em>ac</em> ⊕ <em>bc</em>.
      </p>
      
      <p class="indent"><a id="page_52"></a>This is in the required form with <em>g</em>(<em>x, y</em>) = <em>f</em><sub>0</sub>(<em>x, y</em>) and <em>h</em>(<em>x, y</em>) = <em>f</em><sub>0</sub>(<em>x, y</em>) ⊕ <em>f</em><sub>1</sub>(<em>x, y</em>). <em>f</em><sub>0</sub>(<em>x, y</em>), incidentally, is <em>f</em>(<em>x, y, z</em>) with <em>z</em> = 0, and <em>f</em><sub>1</sub>(<em>x, y</em>) is <em>f</em>(<em>x, y, z</em>) with <em>z</em> = 1.
      </p>
      
      <p class="indent">C<small>OROLLARY</small>. <em>If a computer’s instruction set includes an instruction for each of the 16 Boolean
            functions of two variables, then any Boolean function of three variables can be implemented
            with four (or fewer) instructions</em>.
      </p>
      
      <p class="noindent">One instruction implements <em>g</em>(<em>x, y</em>), another implements <em>h</em>(<em>x, y</em>), and these are combined with <em>and</em> and <em>exclusive or</em>.
      </p>
      
      <p class="indent">As an example, consider the Boolean function that is 1 if exactly two of <em>x, y</em>, and <em>z</em> are 1:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/052equ01.jpg" /></div>
      
      <p class="noindent">Before proceeding, the interested reader might like to try to implement <em>f</em> with four instructions, without using the theorem.
      </p>
      
      <p class="indent">From the proof of the theorem,</p>
      
      <div class="image"><img alt="Image" src="graphics/052equ02.jpg" /></div>
      
      <p class="noindent">which is four instructions.</p>
      
      <p class="indent">Clearly, the theorem can be extended to functions of four or more variables. That
         is, any Boolean function <em>f</em>(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ..., <em>x<sub>n</sub></em>) can be decomposed into the form <em>g</em>(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ..., <em>x</em><sub><em>n</em>–1</sub>) ⊕ <em>x<sub>n</sub>h</em>(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ..., <em>x</em><sub><em>n</em>–1</sub>). Thus, a function of four variables can be decomposed as follows:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/052equ03.jpg" /></div>
      
      <p class="noindent">This shows that a computer that has an instruction for each of the 16 binary Boolean
         functions can implement any function of four variables with ten instructions. Similarly,
         any function of five variables can be implemented with 22 instructions.
      </p>
      
      <p class="indent">However, it is possible to do much better. For functions of four or more variables
         there is probably no simple plug-in equation like the theorem gives, but exhaustive
         computer searches have been done. The results are that any Boolean function of four
         variables can be implemented with seven binary Boolean instructions, and any such
         function of five variables can be implemented with 12 such instructions [Knu4, 7.1.2].
      </p>
      
      <p class="indent"><a id="page_53"></a>In the case of five variables, only 1920 of the 2<sup>25</sup> = 4,294,967,296 functions require 12 instructions, and these 1920 functions are all
         essentially the same function. The variations are obtained by permuting the arguments,
         replacing some arguments with their complements, or complementing the value of the
         function.
      </p>
      
      <h3><a id="ch02lev23"></a><strong>2–23 Implementing Instructions for All 16 Binary Boolean Operations</strong></h3>
      
      <p class="noindent">The instruction sets of some computers include all 16 binary Boolean operations. Many
         of the instructions are useless in that their function can be accomplished with another
         instruction. For example, the function <em>f</em>(<em>x, y</em>) = 0 simply clears a register, and most computers have a variety of ways to do that.
         Nevertheless, one reason a computer designer might choose to implement all 16 is that
         there is a simple and quite regular circuit for doing it.
      </p>
      
      <p class="indent">Refer to <a href="ch02.html#ch02tab1">Table 2–1</a> on page <a href="ch02.html#page_17">17</a>, which shows all 16 binary Boolean functions. To implement these functions as instructions,
         choose four of the opcode bits to be the same as the function values shown in the
         table. Denoting these opcode bits by <em>c</em><sub>0</sub>, <em>c</em><sub>1</sub>, <em>c</em><sub>2</sub>, and <em>c</em><sub>3</sub>, reading from the bottom up in the table, and the input registers by <em>x</em> and <em>y</em>, the circuit for implementing all 16 binary Boolean operations is described by the
         logic expression
      </p>
      
      <div class="image"><img alt="Image" src="graphics/053equ01.jpg" /></div>
      
      <p class="noindent">For example, with <em>c</em><sub>0</sub> = <em>c</em><sub>1</sub> = <em>c</em><sub>2</sub> = <em>c</em><sub>3</sub> = 0, the instruction computes the zero function, <em>f</em>(<em>x, y</em>) = 0. With <em>c</em><sub>0</sub> = 1 and the other opcode bits 0 it is the <em>and</em> instruction. With <em>c</em><sub>0</sub> = <em>c</em><sub>3</sub> = 0 and <em>c</em><sub>1</sub> = <em>c</em><sub>2</sub> = 1 it is <em>exclusive or</em>, and so forth.
      </p>
      
      <p class="indent">This can be implemented with <em>n</em> 4:1 MUXs, where <em>n</em> is the word size of the machine. The data bits of <em>x</em> and <em>y</em> are the select lines, and the four opcode bits are the data inputs to each MUX. The
         MUX is a standard building block in today’s technology, and it is usually a very fast
         circuit. It is illustrated below.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/053fig01.jpg" /></div>
      
      <p class="noindent">The function of the circuit is to select <em>c</em><sub>0</sub>, <em>c</em><sub>1</sub>, <em>c</em><sub>2</sub>, or <em>c</em><sub>3</sub> to be the output, depending on whether <em>x</em> and <em>y</em> are 00, 01, 10, or 11, respectively. It is like a four-position rotary switch.
      </p>
      
      <p class="indent">Elegant as this is, it is somewhat expensive in opcode points, using 16 of them. There
         are a number of ways to implement all 16 Boolean operations using only eight opcode
         points, at the expense of less regular logic. One such scheme is illustrated in <a href="ch02.html#ch02tab3">Table 2–3</a>.
      </p>
      
      <p class="tab-caption"><a id="page_54"></a><a id="ch02tab3"></a>T<small>ABLE</small> 2–3. E<small>IGHT</small> S<small>UFFICIENT</small> B<small>OOLEAN</small> I<small>NSTRUCTIONS</small></p>
      
      <div class="image"><img alt="Image" src="graphics/02tab03.jpg" /></div>
      
      <p class="indent">The eight operations not shown in the table can be done with the eight instructions
         shown, by interchanging the inputs or by having both register fields of the instruction
         refer to the same register. See exercise 13.
      </p>
      
      <p class="indent">IBM’s POWER architecture uses this scheme, with the minor difference that POWER has
         <em>or with complement</em> rather than <em>complement and or</em>. The scheme shown in <a href="ch02.html#ch02tab3">Table 2–3</a> allows the last four instructions to be implemented by complementing the result of
         the first four instructions, respectively.
      </p>
      
      <h4><strong>Historical Notes</strong></h4>
      
      <p class="noindent">The algebra of logic expounded in George Boole’s <em>An Investigation of the Laws of Thought</em> (1854)<sup><a id="ch02fna7"></a><a href="footnotes.html#ch02fn7">7</a></sup> is somewhat different from what we know today as “Boolean algebra.” Boole used the
         <em>integers</em> 1 and 0 to represent truth and falsity, respectively, and he showed how they could
         be manipulated with the methods of ordinary numerical algebra to formalize natural
         language statements involving “and,” “or,” and “except.” He also used ordinary algebra
         to formalize statements in set theory involving intersection, union of disjoint sets,
         and complementation. He also formalized statements in probability theory, in which
         the variables take on real number values from 0 to 1. The work often deals with questions
         of philosophy, religion, and law.
      </p>
      
      <p class="indent">Boole is regarded as a great thinker about logic because he formalized it, allowing
         complex statements to be manipulated mechanically and flawlessly with the familiar
         methods of ordinary algebra.
      </p>
      
      <p class="indent">Skipping ahead in history, there are a few programming languages that include all
         16 Boolean operations. IBM’s PL/I (ca. 1966) includes a built-in function named BOOL.
         In BOOL(<em>x, y, z</em>), <em>z</em> is a bit string of length four (or converted to that <a id="page_55"></a>if necessary), and <em>x</em> and <em>y</em> are bit strings of equal length (or converted to that if necessary). Argument <em>z</em> specifies the Boolean operation to be performed on <em>x</em> and <em>y</em>. Binary 0000 is the zero function, 0001 is <em>xy</em>, 0010 is <em>x</em><span class="middle"><img alt="Image" src="graphics/y-bar.jpg" /></span>, and so forth.
      </p>
      
      <p class="indent">Another such language is Basic for the Wang System 2200B computer (ca. 1974), which
         provides a version of BOOL that operates on character strings rather than on bit strings
         or integers [Neum].
      </p>
      
      <p class="indent">Still another such language is MIT PDP-6 Lisp, later called MacLisp [GLS1].</p>
      
      <h4><strong>Exercises</strong></h4>
      
      <p class="question"><a href="ch19_answer.html#ch02ans1" id="ch02ansa1"><strong>1</strong>.</a> David de Kloet suggests the following code for the snoob function, for <strong><em>x</em> ≠ 0</strong>, where the final assignment to <strong><em>y</em></strong> is the result:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/055equ01.jpg" /></div>
      
      <p class="indenthanging">This is essentially the same as Gosper’s code (page <a href="ch02.html#page_15">15</a>), except the right shift is done with a <em>while</em>-loop rather than with a <em>divide</em> instruction. Because division is usually costly in time, this might be competitive
         with Gosper’s code if the while-loop is not executed too many times. Let <em>n</em> be the length of the bit strings <strong><em>x</em></strong> and <strong><em>y</em></strong>, <em>k</em> the number of 1-bits in the strings, and assume the code is executed for all values
         of <strong><em>x</em></strong> that have exactly <em>k</em> 1-bits. Then for each invocation of the function, how many times, on average, will
         the body of the <em>while</em>-loop be executed?
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch02ans2" id="ch02ansa2"><strong>2</strong>.</a> The text mentions that a left shift by a variable amount is not right-to-left computable.
         Consider the function <strong><em>x</em></strong> <span class="entity">&lt;&lt;</span> (<strong><em>x</em></strong> &amp; <strong>1</strong>) [Knu8]. This is a left shift by a variable amount, but it can be computed by
      </p>
      
      <p class="center"><strong><em>x</em> + (<em>x</em> &amp; 1) *<em>x</em></strong>, or<br /><strong><em>x</em> + (<em>x</em> &amp; (−(<em>x</em> &amp; 1)))</strong>,
      </p>
      
      <p class="indenthanging">which are all right-to-left computable operations. What is going on here? Can you
         think of another such function?
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch02ans3" id="ch02ansa3"><strong>3</strong>.</a> Derive Dietz’s formula for the average of two unsigned integers,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/055equ03.jpg" /></div>
      
      <p class="question"><a id="page_56"></a><a href="ch19_answer.html#ch02ans4" id="ch02ansa4"><strong>4</strong>.</a> Give an overflow-free method for computing the average of four unsigned integers,
         <span class="entity">⌊</span>(<em>a</em> + <em>b</em> + <em>c</em> + <em>d</em>)/4<span class="entity">⌋</span>.
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch02ans5" id="ch02ansa5"><strong>5</strong>.</a> Many of the comparison predicates shown on page <a href="ch02.html#page_23">23</a> can be simplified substantially if bit 31 of either <strong><em>x</em></strong> or <strong><em>y</em></strong> is known. Show how the seven-instruction expression for <span class="middle"><img alt="Image" src="graphics/025fig03.jpg" /></span> can be simplified to three basic RISC, non-comparison, instructions if <strong><em>y</em></strong><sub>31</sub> = 0.
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch02ans6" id="ch02ansa6"><strong>6</strong>.</a> Show that if two numbers, possibly distinct, are added with “end-around carry,” the
         addition of the carry bit cannot generate another carry out of the high-order position.
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch02ans7" id="ch02ansa7"><strong>7</strong>.</a> Show how end-around carry can be used to do addition if negative numbers are represented
         in one’s-complement notation. What is the maximum number of bit positions that a carry
         (from any bit position) might be propagated through?
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch02ans8" id="ch02ansa8"><strong>8</strong>.</a> Show that the MUX operation, (<strong><em>x</em></strong> &amp; <strong><em>m</em></strong>) | (<strong><em>y</em></strong> &amp; ~<strong><em>m</em></strong>), can be done in three instructions on the basic RISC (which does not have the <em>and with complement</em> instruction).
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch02ans9" id="ch02ansa9"><strong>9</strong>.</a> Show how to implement <strong><em>x</em></strong> ⊕ <strong><em>y</em></strong> in four instructions with <em>and</em>-<em>or</em>-<em>not</em> logic.
      </p>
      
      <p class="question1"><a href="ch19_answer.html#ch02ans10" id="ch02ansa10"><strong>10</strong>.</a> Given a 32-bit word <strong><em>x</em></strong> and two integer variables <strong><em>i</em></strong> and <strong><em>j</em></strong> (in registers), show code to copy the bit of <strong><em>x</em></strong> at position <strong><em>i</em></strong> to position <strong><em>j</em></strong>. The values of <strong><em>i</em></strong> and <strong><em>j</em></strong> have no relation, but assume that 0 ≤ <em>i, j</em> ≤ 31.
      </p>
      
      <p class="question1"><a href="ch19_answer.html#ch02ans11" id="ch02ansa11"><strong>11</strong>.</a> How many binary Boolean instructions are sufficient to evaluate any <em>n</em>-variable Boolean function if it is decomposed recursively by the method of the theorem?
      </p>
      
      <p class="question1"><a href="ch19_answer.html#ch02ans12" id="ch02ansa12"><strong>12</strong>.</a> Show that alternative decompositions of Boolean functions of three variables are
      </p>
      
      <p class="indenthanging">(a) <em>f</em>(<em>x, y, z</em>) = <em>g</em>(<em>x, y</em>) ⊕ <span class="middle"><img alt="Image" src="graphics/z-bar.jpg" /></span><em>h</em>(<em>x, y</em>) (the “negative Davio decomposition”), and<br />(b) <em>f</em>(<em>x, y, z</em>) = <em>g</em>(<em>x, y</em>) ⊕ (<em>z</em> + <em>h</em> (<em>x, y</em>)).
      </p>
      
      <p class="question1"><a href="ch19_answer.html#ch02ans13" id="ch02ansa13"><strong>13</strong>.</a> It is mentioned in the text that all 16 binary Boolean operations can be done with
         the eight instructions shown in <a href="ch02.html#ch02tab3">Table 2–3</a>, by interchanging the inputs or by having both register fields of the instruction
         refer to the same register. Show how to do this.
      </p>
      
      <p class="question1"><a href="ch19_answer.html#ch02ans14" id="ch02ansa14"><strong>14</strong>.</a> Suppose you are not concerned about the six Boolean functions that are really constants
         or unary functions, namely <em>f</em>(<em>x, y</em>) = 0, 1, <em>x, y</em>, <span class="middle"><img alt="Image" src="graphics/x-bar.jpg" /></span>, and <span class="middle"><img alt="Image" src="graphics/y-bar.jpg" /></span>, but you want your instruction set to compute the other ten functions with one instruction.
         Can this be done with fewer than eight binary Boolean instruction types (opcodes)?
      </p>
      
      <p class="question1"><a href="ch19_answer.html#ch02ans15" id="ch02ansa15"><strong>15</strong>.</a> Exercise 13 shows that eight instruction types suffice to compute any of the 16 two-operand
         Boolean operations with one R-R (register-register) instruction. Show that six instruction
         types suffice in the case of R-I (register-immediate) <a id="page_57"></a>instructions. With R-I instructions, the input operands cannot be interchanged or
         equated, but the second input operand (the immediate field) can be complemented or,
         in fact, set to any value at no cost in execution time. Assume for simplicity that
         the immediate fields are the same length as the general purpose registers.
      </p>
      
      <p class="question1"><a href="ch19_answer.html#ch02ans16" id="ch02ansa16"><strong>16</strong>.</a> Show that not all Boolean functions of three variables can be implemented with three
         binary logical instructions.<a id="page_58"></a></p>
      
   </body>
   
</html>