<html xmlns="http://www.w3.org/1999/xhtml">
   
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      
      <title>Chapter 7. Rearranging Bits and Bytes</title>
      
      <link href="9780133085013.css" rel="stylesheet" type="text/css" />
      
      <link href="page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
      
      <meta content="urn:uuid:767ce45a-85bb-4273-91f5-801bab42906b" name="Adept.expected.resource" />
      
   </head>
   
   <body>
      
      <h2><a id="page_129"></a><a id="ch07"></a>Chapter 7. Rearranging Bits and Bytes
      </h2>
      
      <h3><a id="ch07lev1"></a><strong>7–1 Reversing Bits and Bytes</strong></h3>
      
      <p class="noindent">By “reversing bits” we mean to reflect the contents of a register about the middle
         so that, for example,
      </p>
      
      <p class="center">rev(<strong>0x01234567</strong>) = <strong>0xE6A2C480</strong>.
      </p>
      
      <p class="noindent">By “reversing bytes” we mean a similar reflection of the four bytes of a register.
         Byte reversal is a necessary operation to convert data between the “little-endian”
         format used by DEC and Intel, and the “big-endian” format used by most other manufacturers.
      </p>
      
      <p class="indent">Bit reversal can be done quite efficiently by interchanging adjacent single bits,
         then interchanging adjacent 2-bit fields, and so on, as shown below [Aus1]. These
         five assignment statements can be executed in any order. This is the same algorithm
         as the first <em>population count</em> algorithm of <a href="ch05.html#ch05lev1">Section 5–1</a>, but with addition replaced with swapping.
      </p>
      
      <p class="codelink"><a href="images6.html#p129equ01" id="p129equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">x = (x &amp; 0x55555555)  <span class="entity">&lt;&lt;</span>   1 | (x &amp; 0xAAAAAAAA) &gt;&gt;  1;<br />x = (x &amp; 0x33333333)  <span class="entity">&lt;&lt;</span>   2 | (x &amp; 0xCCCCCCCC) &gt;&gt;  2;<br />x = (x &amp; 0x0F0F0F0F)  <span class="entity">&lt;&lt;</span>   4 | (x &amp; 0xF0F0F0F0) &gt;&gt;  4;<br />x = (x &amp; 0x00FF00FF)  <span class="entity">&lt;&lt;</span>   8 | (x &amp; 0xFF00FF00) &gt;&gt;  8;<br />x = (x &amp; 0x0000FFFF)  <span class="entity">&lt;&lt;</span>  16 | (x &amp; 0xFFFF0000) &gt;&gt; 16;
      </p>
      
      <p class="indent">A small improvement may result on some machines by using fewer distinct large constants
         and doing the last two assignments in a more straightforward way, as shown in <a href="ch07.html#ch07fig1">Figure 7–1</a> (30 basic RISC instructions, branch-free).
      </p>
      
      <p class="codelink"><a href="images6.html#p07fig01" id="p07fig01a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch07fig1"></a>unsigned rev(unsigned x) {<br />   x = (x &amp; 0x55555555) <span class="entity">&lt;&lt;</span> 1 | (x &gt;&gt; 1) &amp; 0x55555555;<br />   x = (x &amp; 0x33333333) <span class="entity">&lt;&lt;</span> 2 | (x &gt;&gt; 2) &amp; 0x33333333;<br />   x = (x &amp; 0x0F0F0F0F) <span class="entity">&lt;&lt;</span> 4 | (x &gt;&gt; 4) &amp; 0x0F0F0F0F;<br />   x = (x <span class="entity">&lt;&lt;</span> 24) | ((x &amp; 0xFF00) <span class="entity">&lt;&lt;</span> 8) |<br />       ((x &gt;&gt; 8) &amp; 0xFF00) | (x &gt;&gt; 24);<br />   return x;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 7–1. Reversing bits.
      </p>
      
      <p class="indent">The last assignment to <strong><em>x</em></strong> in this code does byte reversal in nine basic RISC instructions. If the machine has
         rotate shifts, however, this can be done in seven instructions with
      </p>
      
      <div class="image"><img alt="Image" src="graphics/129equ02.jpg" /></div>
      
      <p class="noindent"><a id="page_130"></a>PowerPC can do the byte-reversal operation in only three instructions [Hay1]: a <em>rotate left</em> of 8, which positions two of the bytes, followed by two “rlwimi” (<em>rotate left word immediate then mask insert</em>) instructions.
      </p>
      
      <p class="indent">The next algorithm, by Christopher Strachey [Strach 1961], is old by computer standards,
         but it is instructive. It reverses the rightmost 16 bits of a word, assuming the leftmost
         16 bits are clear at the start, and places the reversed halfword in the left half
         of the register.
      </p>
      
      <p class="indent">Its operation is based on the number of bit positions that each bit must move. The
         16 bits, taken from left to right, must move 1, 3, 5, ..., 31 positions. The bits
         that must move 16 or more positions are moved first, then those that must move eight
         or more positions, and so forth. The operation is illustrated below, where each letter
         denotes a single bit, and a period denotes a “don’t care” bit.
      </p>
      
      <p class="codelink"><a href="images6.html#p130equ01" id="p130equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">0000 0000 0000 0000 abcd efgh ijkl mnop Given<br />0000 0000 ijkl mnop abcd efgh .... .... After shl 16<br />0000 mnop ijkl efgh abcd .... .... .... After shl 8<br />00op mnkl ijgh efcd ab.. .... .... .... After shl 4<br />0pon mlkj ihgf edcb a... .... .... .... After shl 2<br />ponm lkji hgfe dcba .... .... .... .... After shl 1
      </p>
      
      <p class="indent">Straightforward code consists of 16 basic RISC instructions, plus 12 to load the constants:</p>
      
      <p class="codelink"><a href="images6.html#p130equ02" id="p130equ02a">Click here to view code image</a></p>
      
      <p class="programlisting1">x = x | ((x &amp; 0x000000FF) <span class="entity">&lt;&lt;</span> 16);<br />x = (x &amp; 0xF0F0F0F0) | ((x &amp; 0x0F0F0F0F) <span class="entity">&lt;&lt;</span> 8);<br />x = (x &amp; 0xCCCCCCCC) | ((x &amp; 0x33333333) <span class="entity">&lt;&lt;</span> 4);<br />x = (x &amp; 0xAAAAAAAA) | ((x &amp; 0x55555555) <span class="entity">&lt;&lt;</span> 2);<br />x = x <span class="entity">&lt;&lt;</span> 1;
      </p>
      
      <p class="indent">Complementation can be used to reduce the number of distinct masks. By using more
         irregular masks, the rightmost 16 bits can be preserved.
      </p>
      
      <p class="indent">If rotate shifts are available, Strachey’s idea can be used to reverse a 32-bit word.
         The idea is to consider how many bit positions each bit must move rotationally to
         the left to get to its final position. Taking the bits from left to right, the shift
         amounts are 1, 3, 5, ..., 31, 1, 3, 5, ..., 31 (no bit moves an even number of positions).
         The algorithm first rotate-moves those bits that must move 16 or more positions, then
         those that must move eight or more positions, and so forth, and finally those that
         must move one position (which is all of the bits, because all move amounts are odd).
         This scheme is shown below, for reversing a 32-bit word <code>x</code>. Function <code>shlr(x, y)</code> rotates <code>x</code> left <code>y</code> positions.
      </p>
      
      <p class="codelink"><a href="images6.html#p130equ03" id="p130equ03a">Click here to view code image</a></p>
      
      <p class="programlisting1">x = shlr(x &amp; 0x00FF00FF, 16) | x &amp; ~0x00FF00FF;<br />x = shlr(x &amp; 0x0F0F0F0F,  8) | x &amp; ~0x0F0F0F0F;<br />x = shlr(x &amp; 0x33333333,  4) | x &amp; ~0x33333333;<br />x = shlr(x &amp; 0x55555555,  2) | x &amp; ~0x55555555;<br />x = shlr(x, 1);
      </p>
      
      <p class="indent"><a id="page_131"></a>The code uses <em>and with complement</em> to avoid loading some masks. If your machine does not have that instruction, it can
         be avoided by rewriting the first line of code as
      </p>
      
      <p class="codelink"><a href="images6.html#p131equ01" id="p131equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">x = shlr(x, 16) &amp; 0x00FF00FF | x &amp; ~0x00FF00FF;</p>
      
      <p class="noindent">which is a MUX operation, and using the identity</p>
      
      <div class="image"><img alt="Image" src="graphics/131equ02.jpg" /></div>
      
      <p class="noindent">to obtain</p>
      
      <p class="codelink"><a href="images6.html#p131equ03" id="p131equ03a">Click here to view code image</a></p>
      
      <p class="programlisting1">x = ((shlr(x, 16) ^ x) &amp; 0x00FF00FF) ^ x;</p>
      
      <p class="noindent">and similarly for the other lines that have <em>and with complement</em>.
      </p>
      
      <p class="indent">A slightly better way for many machines, in that it has a little instruction-level
         parallelism, is to use the identity [Karv]
      </p>
      
      <div class="image"><img alt="Image" src="graphics/131equ04.jpg" /></div>
      
      <p class="noindent">and common the <em>and</em> expression. This gives the function shown in <a href="ch07.html#ch07fig2">Figure 7–2</a> (17 instructions, plus eight to load constants, or 25 in all).
      </p>
      
      <p class="codelink"><a href="images6.html#p07fig02" id="p07fig02a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch07fig2"></a>unsigned rev(unsigned x) {<br />   unsigned t;<br />   t = x &amp; 0x00FF00FF; x = shlr(t, 16) | t ^ x;<br />   t = x &amp; 0x0F0F0F0F; x = shlr(t,  8) | t ^ x;<br />   t = x &amp; 0x33333333; x = shlr(t,  4) | t ^ x;<br />   t = x &amp; 0x55555555; x = shlr(t,  2) | t ^ x;<br />   x = shlr(x, 1);<br />   return x;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 7–2. Reversing bits with rotate shifts.
      </p>
      
      <p class="indent">It is perhaps worth noting that the constants 0x00FF00FF, 0x0F0F0F0F, and so on can
         be generated one from another as shown below. This is not useful for 32-bit machines
         (it may even be harmful by reducing parallelism), because 32-bit RISC machines generally
         can load the constants in two instructions. But it might be useful for a 64-bit machine,
         for which it is illustrated.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/131equ05.jpg" /></div>
      
      <p class="indent"><a id="page_132"></a>Another way to reverse bits is to break the word up into three groups of bits, and
         swap the leftmost and rightmost groups, leaving the center group in place [Baum].
         For a 27-bit word, this works as illustrated below.
      </p>
      
      <p class="codelink"><a href="images6.html#p132equ01" id="p132equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">012345678 9abcdefgh ijklmnopq   The given 27-bit word<br />ijklmnopq 9abcdefgh 012345678   First ternary swap<br />opqlmnijk fghcde9ab 678345012   Second ternary swap<br />qponmlkji hgfedcba9 876543210   Third ternary swap
      </p>
      
      <p class="indent">Straightforward code for this follows. If run on a 32-bit machine, it reverses bits
         0 to 26, placing the result in bit positions 0 to 26, and clearing bits 27 to 31.
      </p>
      
      <p class="codelink"><a href="images6.html#p132equ02" id="p132equ02a">Click here to view code image</a></p>
      
      <p class="programlisting1">x = (x &amp; 0x000001FF) <span class="entity">&lt;&lt;</span> 18 | (x &amp; 0x0003FE00) |<br />    (x &gt;&gt; 18) &amp; 0x000001FF;<br />x = (x &amp; 0x001C0E07) <span class="entity">&lt;&lt;</span>  6 | (x &amp; 0x00E07038) |<br />    (x &gt;&gt; 6) &amp; 0x001C0E07;<br />x = (x &amp; 0x01249249) <span class="entity">&lt;&lt;</span>  2 | (x &amp; 0x02492492) |<br />    (x &gt;&gt; 2) &amp; 0x01249249;
      </p>
      
      <p class="noindent">This amounts to 21 basic RISC instructions, plus 10 to load the constants, or 31 in
         all. In comparison, the code of <a href="ch07.html#ch07fig1">Figure 7–1</a> is 24 basic RISC instructions, plus six to load constants, plus a shift right of
         5 to right-justify the result, or 31 in all. Thus, the ternary method is equal or
         superior when there are 27 or fewer bits to be reversed.
      </p>
      
      <p class="indent">The next function, by Donald E. Knuth [Knu8], is interesting because it reverses a
         32-bit word with only four stages, and the shifting and masking steps are unexpectedly
         irregular. It uses one rotate shift and three ternary swaps. It works as follows:
      </p>
      
      <p class="codelink"><a href="images6.html#p132equ03" id="p132equ03a">Click here to view code image</a></p>
      
      <p class="programlisting1">01234567 89abcdef ghijklmn opqrstuv   Given<br />fghijklm nopqrstu v0123456 789abcde   Rotate left 15<br />pqrstuvm nofghijk labcde56 78901234   10-swap<br />tuvspqrm nojklifg hebcda96 78541230   4-swap<br />vutsrqpo mnlkjihg fedcba98 76543210   2-swap
      </p>
      
      <p class="noindent">Straightforward code is shown below.</p>
      
      <p class="codelink"><a href="images6.html#p132equ04" id="p132equ04a">Click here to view code image</a></p>
      
      <p class="programlisting1">x = shlr(x, 15);             // Rotateleft 15.<br />x = (x &amp; 0x003F801F) <span class="entity">&lt;&lt;</span> 10 | (x &amp; 0x01C003E0) |<br />    (x &gt;&gt; 10) &amp; 0x003F801F;<br />x = (x &amp; 0x0E038421) <span class="entity">&lt;&lt;</span>  4 | (x &amp; 0x11C439CE) |<br />    (x &gt;&gt;  4) &amp; 0x0E038421;<br />x = (x &amp; 0x22488842) <span class="entity">&lt;&lt;</span>  2 | (x &amp; 0x549556B5) |<br />    (x &gt;&gt;  2) &amp; 0x22488842;
      </p>
      
      <p class="indent">An improvement in operation count, at the expense of parallelism, results from rewriting</p>
      
      <p class="codelink"><a href="images6.html#p133equ01" id="p133equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">x = (x &amp; M1) <span class="entity">&lt;&lt;</span> s | (x &amp; M2) | (x &gt;&gt; s) &amp; M1;
      </p>
      
      <p class="noindent">where <code>M2</code> is <code>~(M1 | (M1 <span class="entity">&lt;&lt;</span> s))</code>, as:
      </p>
      
      <p class="codelink"><a href="images6.html#p133equ03" id="p133equ03a">Click here to view code image</a></p>
      
      <p class="programlisting1">t = (x ^ (x &gt;&gt; s)) &amp; M1; x = (t | (t <span class="entity">&lt;&lt;</span> s)) ^ x;
      </p>
      
      <p class="noindent">This results in the code in <a href="ch07.html#ch07fig3">Figure 7–3</a> (19 full RISC instructions, plus six to load constants, or 25 in all).
      </p>
      
      <p class="codelink"><a id="page_133"></a><a href="images6.html#p07fig03" id="p07fig03a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch07fig3"></a>unsigned rev(unsigned x) {<br />   unsigned t;<br /><br />   x = shlr(x, 15);              // Rotateleft 15.<br />   t = (x ^ (x&gt;&gt;10)) &amp; 0x003F801F;  x = (t | (t<span class="entity">&lt;&lt;</span>10)) ^ x;<br />   t = (x ^ (x&gt;&gt; 4)) &amp; 0x0E038421;  x = (t | (t<span class="entity">&lt;&lt;</span> 4)) ^ x;<br />   t = (x ^ (x&gt;&gt; 2)) &amp; 0x22488842;  x = (t | (t<span class="entity">&lt;&lt;</span> 2)) ^ x;<br />   return x;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 7–3. Reversing bits, Knuth’s algorithm.
      </p>
      
      <p class="indent">Although Knuth’s algorithm does not beat the algorithm shown in <a href="ch07.html#ch07fig2">Figure 7–2</a> for reversing a 32-bit quantity with rotate shifts allowed (17 instructions, plus
         eight to load constants), Knuth’s code uses only one rotate shift instruction. If
         it is coded as
      </p>
      
      <p class="codelink"><a href="images6.html#p133equ04" id="p133equ04a">Click here to view code image</a></p>
      
      <p class="programlisting1">x = (x <span class="entity">&lt;&lt;</span> 15) | (x &gt;&gt; 17);    // Rotate left 15.
      </p>
      
      <p class="noindent">then Knuth’s algorithm is 21 instructions, plus six to load constants, which is the
         best found by these measures for rotating a 32-bit word using only basic RISC instructions.
         This makes one wonder if there is a simple way to predict the number of shifts and
         logical operations required to reverse a word of a given length.
      </p>
      
      <p class="indent">Can Knuth’s algorithm be extended to reversing 64 bits on a 64-bit machine? Yes, there
         is a simple way and a way that is more difficult to work out. The simple way is to
         first swap the two halves of the 64-bit register, and then apply the 32-bit version
         of Knuth’s algorithm to both halves, in parallel. The resulting code is shown in <a href="ch07.html#ch07fig4">Figure 7–4</a>. It is 24 operations, if the swap (rotate 32) counts as one.
      </p>
      
      <p class="codelink"><a href="images6.html#p07fig04" id="p07fig04a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch07fig4"></a>unsigned long long rev(unsigned long long x) {<br />   unsigned long long t;<br /><br />   x = (x <span class="entity">&lt;&lt;</span> 32) | (x &gt;&gt; 32);    // Swap register halves.<br />   x = (x &amp; 0x0001FFFF0001FFFFLL) <span class="entity">&lt;&lt;</span> 15 | // Rotate left<br />       (x &amp; 0xFFFE0000FFFE0000LL) &gt;&gt; 17;  // 15.<br />   t = (x ^ (x &gt;&gt; 10)) &amp; 0x003F801F003F801FLL;<br />   x = (t | (t <span class="entity">&lt;&lt;</span> 10)) ^ x;<br />   t = (x ^ (x &gt;&gt; 4)) &amp; 0x0E0384210E038421LL;<br />   x = (t | (t <span class="entity">&lt;&lt;</span> 4)) ^ x;<br />   t = (x ^ (x &gt;&gt; 2)) &amp; 0x2248884222488842LL;<br />   x = (t | (t <span class="entity">&lt;&lt;</span> 2)) ^ x;<br />   return x;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 7–4. Knuth’s algorithm applied to 64 bits.
      </p>
      
      <p class="indent">The other way is to find shift amounts and masks analogous to those used in Knuth’s
         32-bit reversal algorithm. This is shown below. It is 25 operations, if the rotate
         left shift of 31 positions counts as one operation.
      </p>
      
      <p class="codelink"><a id="page_134"></a><a href="images6.html#p134equ01" id="p134equ01a">Click here to view code image</a></p>
      
      <p class="programlisting">unsigned long long rev(unsigned long long x) {<br />   unsigned long long t;<br /><br />   x = (x <span class="entity">&lt;&lt;</span> 31) | (x &gt;&gt; 33);   // I.e., shlr(x, 31).<br />   t = (x ^ (x &gt;&gt; 20)) &amp; 0x00000FFF800007FFLL;<br />   x = (t | (t <span class="entity">&lt;&lt;</span> 20)) ^ x;<br />   t = (x ^ (x &gt;&gt; 8)) &amp; 0x00F8000F80700807LL;<br />   x = (t | (t <span class="entity">&lt;&lt;</span> 8)) ^ x;<br />   t = (x ^ (x &gt;&gt; 4)) &amp; 0x0808708080807008LL;<br />   x = (t | (t <span class="entity">&lt;&lt;</span> 4)) ^ x;<br />   t = (x ^ (x &gt;&gt; 2)) &amp; 0x1111111111111111LL;<br />   x = (t | (t <span class="entity">&lt;&lt;</span> 2)) ^ x;<br />   return x;<br />}
      </p>
      
      <p class="indent">Bit reversal can be aided by table lookup. The code that follows reverses a byte at
         a time, using a 256-byte table, and accumulates in reverse order the four bytes selected
         from the table. If the loop is strung out, this amounts to 13 basic RISC instructions,
         plus four loads, so it could be a winner on some machines.
      </p>
      
      <p class="codelink"><a href="images6.html#p134equ02" id="p134equ02a">Click here to view code image</a></p>
      
      <p class="programlisting"><br />unsigned rev(unsigned x) {<br />   static unsigned char table[256] = {0x00, 0x80, 0x40,<br />   0xC0, 0x20, 0xA0, 0x60, 0xE0, ..., 0xBF, 0x7F, 0xFF};<br />   int i;<br />   unsigned r;<br /><br />   r = 0;<br />   for (i = 3; i &gt;= 0; i--) {<br />      r = (r <span class="entity">&lt;&lt;</span> 8) + table[x &amp; 0xFF];<br />      x = x &gt;&gt; 8;<br />   }<br />   return r;<br />}
      </p>
      
      <h4><a id="page_135"></a><strong>Generalized Bit Reversal</strong></h4>
      
      <p class="noindent">[GLS1] suggests that the following sort of generalization of bit reversal, which he
         calls “flip,” is a good candidate to consider for a computer’s instruction set:
      </p>
      
      <p class="codelink"><a href="images6.html#p135equ01" id="p135equ01a">Click here to view code image</a></p>
      
      <p class="programlisting"><br />if (k &amp;  1) x = (x &amp; 0x55555555) <span class="entity">&lt;&lt;</span>  1 | (x &amp; 0xAAAAAAAA) &gt;&gt;  1;<br />if (k &amp;  2) x = (x &amp; 0x33333333) <span class="entity">&lt;&lt;</span>  2 | (x &amp; 0xCCCCCCCC) &gt;&gt;  2;<br />if (k &amp;  4) x = (x &amp; 0x0F0F0F0F) <span class="entity">&lt;&lt;</span>  4 | (x &amp; 0xF0F0F0F0) &gt;&gt;  4;<br />if (k &amp;  8) x = (x &amp; 0x00FF00FF) <span class="entity">&lt;&lt;</span>  8 | (x &amp; 0xFF00FF00) &gt;&gt;  8;<br />if (k &amp; 16) x = (x &amp; 0x0000FFFF) <span class="entity">&lt;&lt;</span> 16 | (x &amp; 0xFFFF0000) &gt;&gt; 16;
      </p>
      
      <p class="noindent">(The last two <em>and</em> operations can be omitted.) For <code>k</code> = 31, this operation reverses the bits in a word. For <code>k</code> = 24, it reverses the bytes in a word. For <code>k</code> = 7, it reverses the bits in each byte, without changing the positions of the bytes.
         For <code>k</code> = 16, it swaps the left and right halfwords of a word, and so on. In general, it
         moves the bit at position <em>m</em> to position <em>m</em> ⊕ <em>k</em>. It can be implemented in hardware very similarly to the way a rotate shifter is
         usually implemented (five stages of MUX’s, with each stage controlled by a bit of
         the shift amount <em>k</em>).
      </p>
      
      <h4><strong>Bit-Reversing Novelties</strong></h4>
      
      <p class="noindent">Item 167 in [HAK] contains rather esoteric expressions for reversing 6-, 7-, and 8-bit
         integers. Although these expressions are designed for a 36-bit machine, the one for
         reversing a 6-bit integer works on a 32-bit machine, and those for 7- and 8-bit integers
         work on a 64-bit machine. These expressions are as follows:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/135equ02.jpg" /></div>
      
      <p class="noindent">The result of all these is a “clean” integer—right-adjusted with no unused high-order
         bits set.
      </p>
      
      <p class="indent">In all these cases the remu function can instead be rem or mod, because its arguments
         are positive. The <em>remainder</em> function is simply summing the digits of a base-256 or base-1024 number, much like
         casting out nines. Hence, it can be replaced with a <em>multiply</em> and a <em>shift right</em>. For example, the 6-bit formula has the following alternative on a 32-bit machine
         (the multiplication must be modulo 2<sup>32</sup>):
      </p>
      
      <div class="image"><img alt="Image" src="graphics/135equ03.jpg" /></div>
      
      <p class="indent">These formulas are limited in their utility, because they involve a remaindering operation
         (20 cycles or more) and/or some multiplications, as well as loading <a id="page_136"></a>of large constants. The formula immediately above requires ten basic RISC instructions,
         two of which are <em>multiply</em>’s, which amounts to about 20 cycles on a present-day RISC. On the other hand, an
         adaptation of the code of <a href="ch07.html#ch07fig1">Figure 7–1</a> to reverse 6-bit integers requires about 15 instructions, and probably about 9 to
         15 cycles, depending on the amount of instruction-level parallelism in the machine.
         These techniques, however, do give compact code. Below are a few more techniques that
         might possibly be useful, all for a 32-bit machine. They involve a sort of double
         application of the idea from [HAK], to extend the technique to 8- and 9-bit integers
         on a 32-bit machine.
      </p>
      
      <p class="indent">The following is a formula for reversing an 8-bit integer:</p>
      
      <div class="image"><img alt="Image" src="graphics/136equ01.jpg" /></div>
      
      <p class="noindent">Here the remu cannot be changed to a <em>multiply</em> and <em>shift</em>. (You have to work these out, and look at the bit patterns, to see why.)
      </p>
      
      <p class="indent">Here is a similar formula for reversing an 8-bit integer, which is interesting because
         it can be simplified quite a bit:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/136equ02.jpg" /></div>
      
      <p class="indent">The simplifications are that the second product is just a <em>shift left</em> of the first product, the last mask can be generated from the second with just one
         instruction (<em>shift</em>), and the <em>remainder</em> can be replaced by a <em>multiply</em> and <em>shift</em>. It simplifies to 14 basic RISC instructions, two of which are <em>multiply</em>’s:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/136equ03.jpg" /></div>
      
      <p class="indent">The following is a formula for reversing a 9-bit integer:</p>
      
      <div class="image"><img alt="Image" src="graphics/136equ04.jpg" /></div>
      
      <p class="indent"><a id="page_137"></a>The second multiplication can be avoided, because the product is equal to the first
         product shifted right six positions. The last mask is equal to the second mask shifted
         right eight positions. With these simplifications, this requires 12 basic RISC instructions,
         including the one <em>multiply</em> and one <em>remainder</em>. The <em>remainder</em> operation must be unsigned, and it cannot be changed to a <em>multiply</em> and <em>shift</em>.
      </p>
      
      <p class="indent">The reader who studies these marvels will be able to devise similar code for other
         bit-permuting operations. As a simple (and artificial) example, suppose it is desired
         to extract every other bit from an 8-bit quantity and compress the four bits to the
         right. That is, the desired transformation is
      </p>
      
      <p class="codelink"><a href="images6.html#p137equ01" id="p137equ01a">Click here to view code image</a></p>
      
      <p class="programlisting2">0000 0000 0000 0000 0000 0000 abcd efgh ==&gt;<br />0000 0000 0000 0000 0000 0000 0000 bdfh
      </p>
      
      <p class="noindent">This can be computed as follows:</p>
      
      <div class="image"><img alt="Image" src="graphics/137equ02.jpg" /></div>
      
      <p class="indent">On most machines, the most practical way to do all these operations is by indexing
         into a table of 1-byte (or 9-bit) integers.
      </p>
      
      <h4><strong>Incrementing a Reversed Integer</strong></h4>
      
      <p class="noindent">The Fast Fourier Transform (FFT) algorithm employs an integer <strong><em>i</em></strong> and its bit reversal rev(<strong><em>i</em></strong>) in a loop in which <strong><em>i</em></strong> is incremented by 1 [PuBr]. Straightforward coding would increment <strong><em>i</em></strong> and then compute rev(<strong><em>i</em></strong>) on each loop iteration. For small integers, computing rev(<strong><em>i</em></strong>) by table lookup is fast and practical. For large integers, however, table lookup
         is not practical and, as we have seen, computing rev(<strong><em>i</em></strong>) requires some 29 instructions.
      </p>
      
      <p class="indent">If table lookup cannot be used, it is more efficient to maintain <strong><em>i</em></strong> in both normal and bit-reversed forms, incrementing them both on each loop iteration.
         This raises the question of how best to increment an integer that is in a register
         in reversed form. To illustrate, on a 4-bit machine we wish to successively step through
         the values (in hexadecimal)
      </p>
      
      <p class="codelink"><a href="images6.html#p137equ03" id="p137equ03a">Click here to view code image</a></p>
      
      <p class="programlisting1">0, 8, 4, C, 2, A, 6, E, 1, 9, 5, D, 3, B, 7, F.</p>
      
      <p class="indent">In the FFT algorithm, <strong><em>i</em></strong> and its reversal are both some specific number of bits in length, almost certainly
         less than 32, and they are both right-justified in the register. However, we assume
         here that <strong><em>i</em></strong> is a 32-bit integer. After adding 1 to the reversed 32-bit integer, a <em>shift right</em> of the appropriate number of bits will make the result usable by the FFT algorithm
         (both <strong><em>i</em></strong> and rev(<strong><em>i</em></strong>) are used to index an array in memory).
      </p>
      
      <p class="indent"><a id="page_138"></a>The straightforward way to increment a reversed integer is to scan from the left for
         the first 0-bit, set it to 1, and set all bits to the left of it (if any) to 0’s.
         One way to code this is
      </p>
      
      <p class="codelink"><a href="images6.html#p138equ01" id="p138equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">unsigned x, m;<br /><br />m = 0x80000000;<br />x = x ^ m;<br />if ((int)x &gt;= 0) {<br />   do {<br />      m = m &gt;&gt; 1;<br />      x = x ^ m;<br />   } while (x &lt; m);<br />}
      </p>
      
      <p class="indent">This executes in three basic RISC instructions if <code>x</code> begins with a 0-bit, and four additional instructions for each loop iteration. Because
         <code>x</code> begins with a 0-bit half the time, with 10 (binary) one-fourth of the time, and so
         on, the average number of instructions executed is approximately
      </p>
      
      <div class="image"><img alt="Image" src="graphics/138equ02.jpg" /></div>
      
      <p class="indent">In the second line we added and subtracted 1, with the first 1 in the form 1/2 + 1/4
         + 1/8 + 1/16 + .... This makes the series similar to the one analyzed on page <a href="ch05.html#page_113">113</a>. The number of instructions executed in the worst case, however, is quite large (131).
      </p>
      
      <p class="indent">If <em>number of leading zeros</em> is available, adding 1 to a reversed integer can be done as follows:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/138equ03.jpg" /></div>
      
      <p class="noindent">Either method requires five full RISC instructions and, to properly wrap around from
         <strong>0xFFFFFFFF</strong> to <strong>0</strong>, requires that the shifts be modulo 64. (These formulas fail in this respect on the
         Intel x86 machines, because the shifts are modulo 32.)
      </p>
      
      <p class="indent"><a id="page_139"></a>The rather puzzling one-liner below [Möbi] increments a reversed integer in six basic
         RISC instructions. It is free of branches and loads but includes an integer division
         operation. It works for integers of length up to that of the word size of the machine,
         less 1.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/139equ01.jpg" /></div>
      
      <p class="indent">To use this, both the non-reversed integer <strong><em>i</em></strong> and its reversal <strong><em>revi</em></strong> must be available. The variable <strong><em>m</em></strong> is the modulus; if we are dealing with <em>n</em>-bit integers, then <strong><em>m</em></strong> = 2<em><sup>n</sup></em>. Applying the formula gives the next value of the reversed integer. The non-reversed
         integer <strong><em>i</em></strong> would be incremented separately. The reversed integer is incremented “in place”;
         that is, it is not shifted to the high-order end of the register, as in the two preceding
         methods.
      </p>
      
      <p class="indent">A variation is</p>
      
      <div class="image"><img alt="Image" src="graphics/07equ01.jpg" /></div>
      
      <p class="noindent">which executes in five instructions if the machine has <em>and not</em>, and if <strong><em>m</em></strong> is a constant so that the calculation of <strong><em>m</em> / 2</strong> does not count. It works for integers of length up to that of the word size of the
         machine. (For full word-size integers, use 0 for the first occurrence of <strong><em>m</em></strong> in the formula, and <em>2<sup>n-1</sup></em> for <strong><em>m</em></strong> / <strong>2</strong>.)
      </p>
      
      <h3><a id="ch07lev2"></a><strong>7–2 Shuffling Bits</strong></h3>
      
      <p class="noindent">Another important permutation of the bits of a word is the “perfect shuffle” operation,
         which has applications in cryptography. There are two varieties, called the “outer”
         and “inner” perfect shuffles. They both interleave the bits in the two halves of a
         word in a manner similar to a perfect shuffle of a deck of 32 cards, but they differ
         in which card is allowed to fall first. In the outer perfect shuffle, the outer (end)
         bits remain in the outer positions, and in the inner perfect shuffle, bit 15 moves
         to the left end of the word (position 31). If the 32-bit word is (where each letter
         denotes a single bit)
      </p>
      
      <p class="codelink"><a href="images6.html#p139pro01" id="p139pro01a">Click here to view code image</a></p>
      
      <p class="programlistings1">abcd efgh ijkl mnop ABCD EFGH IJKL MNOP,</p>
      
      <p class="noindent">then after the outer perfect shuffle it is</p>
      
      <p class="codelink"><a href="images6.html#p139pro02" id="p139pro02a">Click here to view code image</a></p>
      
      <p class="programlistings1">aAbB cCdD eEfF gGhH iIjJ kKlL mMnN oOpP,</p>
      
      <p class="noindent">and after the inner perfect shuffle it is</p>
      
      <p class="codelink"><a href="images6.html#p139pro03" id="p139pro03a">Click here to view code image</a></p>
      
      <p class="programlistings1">AaBb CcDd EeFf GgHh IiJj KkLl MmNn OoPp.</p>
      
      <p class="indent"><a id="page_140"></a>Assume the word size <em>W</em> is a power of 2. Then the outer perfect shuffle operation can be accomplished with
         basic RISC instructions in log<sub>2</sub>(<em>W</em> / 2) steps, where each step swaps the second and third quartiles of successively
         smaller pieces [GLS1]. That is, a 32-bit word is transformed as follows:
      </p>
      
      <p class="codelink"><a href="images6.html#p140equ01" id="p140equ01a">Click here to view code image</a></p>
      
      <p class="programlistings1">abcd efgh ijkl mnop ABCD EFGH IJKL MNOP<br />abcd efgh ABCD EFGH ijkl mnop IJKL MNOP<br />abcd ABCD efgh EFGH ijkl IJKL mnop MNOP<br />abAB cdCD efEF ghGH ijIJ klKL mnMN opOP<br />aAbB cCdD eEfF gGhH iIjJ kKlL mMnN oOpP
      </p>
      
      <p class="indent">Straightforward code for this is</p>
      
      <p class="codelink"><a href="images6.html#p140equ02" id="p140equ02a">Click here to view code image</a></p>
      
      <p class="programlisting"><br />x = (x &amp; 0x0000FF00) <span class="entity">&lt;&lt;</span> 8 | (x &gt;&gt; 8) &amp; 0x0000FF00 | x &amp; 0xFF0000FF;<br />x = (x &amp; 0x00F000F0) <span class="entity">&lt;&lt;</span> 4 | (x &gt;&gt; 4) &amp; 0x00F000F0 | x &amp; 0xF00FF00F;<br />x = (x &amp; 0x0C0C0C0C) <span class="entity">&lt;&lt;</span> 2 | (x &gt;&gt; 2) &amp; 0x0C0C0C0C | x &amp; 0xC3C3C3C3;<br />x = (x &amp; 0x22222222) <span class="entity">&lt;&lt;</span> 1 | (x &gt;&gt; 1) &amp; 0x22222222 | x &amp; 0x99999999;
      </p>
      
      <p class="indent">which requires 42 basic RISC instructions. This can be reduced to 30 instructions,
         although at an increase from 17 to 21 cycles on a machine with unlimited instruction-level
         parallelism, by using the <em>exclusive or</em> method of exchanging two fields of a register (described on page <a href="ch02.html#page_47">47</a>). All quantities are unsigned:
      </p>
      
      <p class="codelink"><a href="images6.html#p140equ03" id="p140equ03a">Click here to view code image</a></p>
      
      <p class="programlisting1">t = (x ^ (x &gt;&gt; 8)) &amp; 0x0000FF00; x = x ^ t ^ (t <span class="entity">&lt;&lt;</span> 8);<br />t = (x ^ (x &gt;&gt; 4)) &amp; 0x00F000F0; x = x ^ t ^ (t <span class="entity">&lt;&lt;</span> 4);<br />t = (x ^ (x &gt;&gt; 2)) &amp; 0x0C0C0C0C; x = x ^ t ^ (t <span class="entity">&lt;&lt;</span> 2);<br />t = (x ^ (x &gt;&gt; 1)) &amp; 0x22222222; x = x ^ t ^ (t <span class="entity">&lt;&lt;</span> 1);
      </p>
      
      <p class="indent">The inverse operation, the outer unshuffle, is easily accomplished by performing the
         swaps in reverse order:
      </p>
      
      <p class="codelink"><a href="images6.html#p140equ04" id="p140equ04a">Click here to view code image</a></p>
      
      <p class="programlisting1"><br />t = (x ^ (x &gt;&gt; 1)) &amp; 0x22222222; x = x ^ t ^ (t <span class="entity">&lt;&lt;</span> 1);<br />t = (x ^ (x &gt;&gt; 2)) &amp; 0x0C0C0C0C; x = x ^ t ^ (t <span class="entity">&lt;&lt;</span> 2);<br />t = (x ^ (x &gt;&gt; 4)) &amp; 0x00F000F0; x = x ^ t ^ (t <span class="entity">&lt;&lt;</span> 4);<br />t = (x ^ (x &gt;&gt; 8)) &amp; 0x0000FF00; x = x ^ t ^ (t <span class="entity">&lt;&lt;</span> 8);
      </p>
      
      <p class="indent">Using only the last two steps of either of the above two shuffle sequences shuffles
         the bits of each byte separately. Using only the last three steps shuffles the bits
         of each halfword separately, and so on. Similar remarks apply to unshuffling, except
         by using the <em>first</em> two or three steps.
      </p>
      
      <p class="indent">To get the inner perfect shuffle, prepend to these sequences a step to swap the left
         and right halves of the register:
      </p>
      
      <p class="codelink"><a href="images6.html#p140equ05" id="p140equ05a">Click here to view code image</a></p>
      
      <p class="programlisting1">x = (x &gt;&gt; 16) | (x <span class="entity">&lt;&lt;</span> 16);
      </p>
      
      <p class="noindent">(or use a <em>rotate</em> of 16 bit positions). The unshuffle sequence can be similarly modified by <em>appending</em> this line of code.
      </p>
      
      <p class="indent"><a id="page_141"></a>Altering the transformation to swap the <em>first</em> and <em>fourth</em> quartiles of successively smaller pieces produces the bit reversal of the inner perfect
         shuffle.
      </p>
      
      <p class="indent">Perhaps worth mentioning is the special case in which the left half of the word <code>x</code> is all 0. In other words, we want to move the bits in the right half of <code>x</code> to every other bit position—that is, to transform the 32-bit word
      </p>
      
      <p class="codelink"><a href="images6.html#p141equ01" id="p141equ01a">Click here to view code image</a></p>
      
      <p class="programlistings1">0000 0000 0000 0000 ABCD EFGH IJKL MNOP</p>
      
      <p class="noindent">to</p>
      
      <p class="codelink"><a href="images6.html#p141equ02" id="p141equ02a">Click here to view code image</a></p>
      
      <p class="programlistings1">0A0B 0C0D 0E0F 0G0H 0I0J 0K0L 0M0N 0O0P.</p>
      
      <p class="indent">The outer perfect shuffle code can be simplified to do this task in 22 basic RISC
         instructions. The code below, however, does it in only 19, at no cost in execution
         time on a machine with unlimited instruction-level parallelism (12 cycles with either
         method). This code does not require that the left half of word <code>x</code> be initially cleared.
      </p>
      
      <p class="codelink"><a href="images6.html#p141equ03" id="p141equ03a">Click here to view code image</a></p>
      
      <p class="programlisting1">x = ((x &amp; 0xFF00) <span class="entity">&lt;&lt;</span> 8) | (x &amp; 0x00FF);<br />x = ((x <span class="entity">&lt;&lt;</span> 4) | x) &amp; 0x0F0F0F0F;<br />x = ((x <span class="entity">&lt;&lt;</span> 2) | x) &amp; 0x33333333;<br />x = ((x <span class="entity">&lt;&lt;</span> 1) | x) &amp; 0x55555555;
      </p>
      
      <p class="indent">Similarly, for the inverse of this “half shuffle” operation (a special case of <em>compress</em>; see page <a href="ch07.html#page_150">150</a>), the outer perfect unshuffle code can be simplified to do the task in 26 or 29 basic
         RISC instructions, depending on whether or not an initial <em>and</em> operation is required to clear the bits in the odd positions. The code below, however,
         does it in only 18 or 21 basic RISC instructions, and with less execution time on
         a machine with unlimited instruction-level parallelism (12 or 15 cycles).
      </p>
      
      <p class="codelink"><a href="images6.html#p141equ04" id="p141equ04a">Click here to view code image</a></p>
      
      <p class="programlisting">x = x &amp; 0x55555555;          // (If required.)<br />x = ((x &gt;&gt; 1) | x) &amp; 0x33333333;<br />x = ((x &gt;&gt; 2) | x) &amp; 0x0F0F0F0F;<br />x = ((x &gt;&gt; 4) | x) &amp; 0x00FF00FF;<br />x = ((x &gt;&gt; 8) | x) &amp; 0x0000FFFF;
      </p>
      
      <h3><a id="ch07lev3"></a><strong>7–3 Transposing a Bit Matrix</strong></h3>
      
      <p class="noindent">The transpose of a matrix <em>A</em> is a matrix whose columns are the rows of <em>A</em> and whose rows are the columns of <em>A</em>. Here we consider the problem of computing the transpose of a bit matrix whose elements
         are single bits that are packed eight per byte, with rows and columns beginning on
         byte boundaries. This seemingly simple transformation is surprisingly costly in instructions
         executed.
      </p>
      
      <p class="indent">On most machines it would be very slow to load and store individual bits, mainly due
         to the code that would be required to extract and (worse yet) to store individual
         bits. A better method is to partition the matrix into 8×8 submatrices, <a id="page_142"></a>load each 8×8 submatrix into registers, compute the transpose of the submatrix in
         registers, and then store the 8×8 result in the appropriate place in the target matrix.
         <a href="ch07.html#ch07fig5">Figure 7–5</a> illustrates the transposition of a bit matrix of size 2×3 bytes. <em>A, B</em>, ..., <em>F</em> are submatrices of size 8×8 bits. <em>A<sup>T</sup>, B<sup>T</sup></em>, ... denote the transpose of submatrices <em>A, B</em>, ....
      </p>
      
      <div class="image"><a id="ch07fig5"></a><img alt="Image" src="graphics/07fig05.jpg" /></div>
      
      <p class="fig-caption">F<small>IGURE</small> 7–5. Transposing a 16×24-bit matrix.
      </p>
      
      <p class="indent">For the purposes of transposing an 8×8 submatrix, it doesn’t matter whether the bit
         matrix is stored in row-major or column-major order; the operations are the same in
         either event. Assume for discussion that it’s in row-major order. Then the first byte
         of the matrix contains the top row of <em>A</em>, the next byte contains the top row of <em>B</em>, and so on. If <em>L</em> denotes the address of the first byte (top row) of a submatrix, then successive rows
         of the submatrix are at locations <em>L</em> + <em>n, L</em> + 2<em>n</em>, ..., <em>L</em> + 7<em>n</em>.
      </p>
      
      <p class="indent">For this problem we will depart from the usual assumption of a 32-bit machine and
         assume the machine has 64-bit general registers. The algorithms are simpler and more
         easily understood in this way, and it is not difficult to convert them for execution
         on a 32-bit machine. In fact, a compiler that supports 64-bit integer operations on
         a 32-bit machine will do the work for you (although probably not as effectively as
         you can do by hand).
      </p>
      
      <p class="indent">The overall scheme is to load a submatrix with eight <em>load byte</em> instructions and pack the bytes left-to-right into a 64-bit register. Then the transpose
         of the register’s contents is computed. Finally, the result is stored in the target
         area with eight <em>store byte</em> instructions.
      </p>
      
      <p class="indent">The transposition of an 8×8 bit matrix is illustrated here, where each character represents
         a single bit.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/142equ01.jpg" /></div>
      
      <p class="noindent"><a id="page_143"></a>In terms of doublewords, the transformation to be done is to change the first line
         to the second line below.
      </p>
      
      <p class="codelink"><a href="images6.html#p143equ01" id="p143equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">01234567 89abcdef ghijklmn opqrstuv wxyzABCD EFGHIJKL MNOPQRST UVWXYZ$.<br />08g0wEMU 19hpxFNV 2aiqyGOW 3bjrzHPX 4cksAIQY 5dltBJRZ 6emuCKS$ 7fnvDLT.
      </p>
      
      <p class="noindent">Notice that the bit denoted by 1 moves seven positions to the right, the bit denoted
         by 2 moves 14 positions to the right, and the bit denoted by 8 moves seven positions
         to the left. Every bit moves 0, 7, 14, 21, 28, 35, 42, or 49 positions to the left
         or right. Since there are 56 bits in the doubleword that have to be moved and only
         14 different nonzero movement amounts, an average of about four bits can be moved
         at once, with appropriate masking and shifting. Straightforward code for this follows.
      </p>
      
      <p class="codelink"><a href="images6.html#p143equ02" id="p143equ02a">Click here to view code image</a></p>
      
      <p class="programlisting1">y = x &amp; 0x8040201008040201LL        |<br />   (x &amp; 0x0080402010080402LL) <span class="entity">&lt;&lt;</span>  7 |<br />   (x &amp; 0x0000804020100804LL) <span class="entity">&lt;&lt;</span> 14 |<br />   (x &amp; 0x0000008040201008LL) <span class="entity">&lt;&lt;</span> 21 |<br />   (x &amp; 0x0000000080402010LL) <span class="entity">&lt;&lt;</span> 28 |<br />   (x &amp; 0x0000000000804020LL) <span class="entity">&lt;&lt;</span> 35 |<br />   (x &amp; 0x0000000000008040LL) <span class="entity">&lt;&lt;</span> 42 |<br />   (x &amp; 0x0000000000000080LL) <span class="entity">&lt;&lt;</span> 49 |<br />   (x &gt;&gt;  7) &amp; 0x0080402010080402LL |<br />   (x &gt;&gt; 14) &amp; 0x0000804020100804LL |<br />   (x &gt;&gt; 21) &amp; 0x0000008040201008LL |<br />   (x &gt;&gt; 28) &amp; 0x0000000080402010LL |<br />   (x &gt;&gt; 35) &amp; 0x0000000000804020LL |<br />   (x &gt;&gt; 42) &amp; 0x0000000000008040LL |<br />   (x &gt;&gt; 49) &amp; 0x0000000000000080LL;
      </p>
      
      <p class="indent">This executes in 43 instructions on the basic RISC, exclusive of mask generation (which
         is not important in the application of transposing a large bit matrix, because the
         masks are loop constants). Rotate shifts do not help. Some of the terms are of the
         form <code>(x &amp; mask)<span class="entity">&lt;&lt;</span> s</code>, and some are of the form <code>(x &gt;&gt; s)&amp; mask</code>. This reduces the number of masks required; the last seven are repeats of earlier
         masks. Notice that each mask after the first can be generated from the first with
         one <em>shift right</em> instruction. Because of this, it is a simple matter to write a more compact version
         of the code that uses a for-loop that is executed seven times.
      </p>
      
      <p class="indent">Another variation is to employ Steele’s method of using <em>exclusive or</em> to swap bit fields (described on page <a href="ch02.html#page_47">47</a>). That technique does not help much in this application. It results in a function
         that executes in 42 instructions, exclusive of mask generation. The code starts out
      </p>
      
      <p class="codelink"><a href="images6.html#p143equ03" id="p143equ03a">Click here to view code image</a></p>
      
      <p class="programlisting1">t = (x ^ (x &gt;&gt; 7)) &amp; 0x0080402010080402LL;<br />x = x ^ t ^ (t <span class="entity">&lt;&lt;</span> 7);
      </p>
      
      <p class="noindent">and there are seven such pairs of lines.</p>
      
      <p class="indent"><a id="page_144"></a>Although there does not seem to be a <em>really great</em> algorithm for this problem, the method to be described beats the straightforward
         method and its variations described above by approximately a factor of 2 on the basic
         RISC, for the calculation part (not counting loading and storing the submatrices or
         generating masks). The method gets its power from its high level of bit-parallelism.
         It would not be a good method if the matrix elements are words. For that, you can’t
         do better than loading each word and storing it where it goes.
      </p>
      
      <p class="indent">First, treat the 8×8-bit matrix as 16 2×2-bit matrices and transpose each of the 16
         2×2-bit matrices. Then treat the matrix as four 2×2 submatrices whose elements are
         2×2-bit matrices and transpose each of the four 2×2 submatrices. Finally, treat the
         matrix as a 2×2 matrix whose elements are 4×4-bit matrices and transpose the 2×2 matrix.
         These transformations are illustrated below [Floyd].
      </p>
      
      <div class="image"><img alt="Image" src="graphics/144equ01.jpg" /></div>
      
      <p class="indent">A complete procedure is shown in <a href="ch07.html#ch07fig6">Figure 7–6</a>. Parameter <code>A</code> is the address of the first byte of an 8×8 submatrix of the source matrix, and parameter
         <code>B</code> is the address of the first byte of an 8×8 submatrix in the target matrix.
      </p>
      
      <p class="indent">The calculation part of this function executes in 21 instructions. Each of the three
         major steps is swapping bits, so a version can be written that uses the Steele <em>exclusive or</em> bit field swapping device. Using it, the first assignment to x in <a href="ch07.html#ch07fig6">Figure 7–6</a> becomes:
      </p>
      
      <p class="codelink"><a href="images6.html#p144equ02" id="p144equ02a">Click here to view code image</a></p>
      
      <p class="programlisting1">t = (x ^ (x &gt;&gt; 7)) &amp; 0x00AA00AA00AA00AALL;<br />x = x ^ t ^ (t <span class="entity">&lt;&lt;</span> 7);
      </p>
      
      <p class="noindent">The calculation part of the revised function executes in only 18 instructions, but
         it has no instruction-level parallelism.
      </p>
      
      <p class="indent">The algorithm of <a href="ch07.html#ch07fig6">Figure 7–6</a> runs from fine to coarse granularity, based on the lengths of the groups of bits
         that are swapped. The method can also be run from coarse to fine granularity. To do
         this, first treat the 8×8-bit matrix as a 2×2 matrix whose elements are 4×4-bit matrices
         and transpose the 2×2 matrix. Then, treat each of the four 4×4 submatrices as a 2×2
         matrix whose elements are 2×2-bit matrices, and transpose each of the four 2×2 submatrices,
         and so forth. The code for this is the same as that of <a href="ch07.html#ch07fig6">Figure 7–6</a> except for the three assignments that do the bit rearranging being run in reverse
         order.
      </p>
      
      <p class="codelink"><a href="images6.html#p07fig06" id="p07fig06a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch07fig6"></a><br />void transpose8(unsigned char A[8], int m, int n,<br />                unsigned char B[8]) {<br />   unsigned long long x;<br />   int i;<br /><br />   for (i = 0; i &lt;= 7; i++)    // Load 8 bytes from the<br />      x = x <span class="entity">&lt;&lt;</span> 8 | A[m*i];    // input array and pack<br />                               // them into x.<br /><br />   x = x &amp; 0xAA55AA55AA55AA55LL        |<br />      (x &amp; 0x00AA00AA00AA00AALL) <span class="entity">&lt;&lt;</span>  7 |<br />      (x &gt;&gt; 7) &amp; 0x00AA00AA00AA00AALL;<br />   x = x &amp; 0xCCCC3333CCCC3333LL        |<br />      (x &amp; 0x0000CCCC0000CCCCLL) <span class="entity">&lt;&lt;</span> 14 |<br />      (x &gt;&gt; 14) &amp; 0x0000CCCC0000CCCCLL;<br />   x = x &amp; 0xF0F0F0F00F0F0F0FLL        |<br />      (x &amp; 0x00000000F0F0F0F0LL) <span class="entity">&lt;&lt;</span> 28 |<br />      (x &gt;&gt; 28) &amp; 0x00000000F0F0F0F0LL;<br /><br />   for (i = 7; i &gt;= 0; i--) {     // Store result into<br />      B[n*i] = x; x = x &gt;&gt; 8;}    // output array B.<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 7–6. Transposing an 8×8-bit matrix.
      </p>
      
      <p class="indent">As was mentioned, these functions can be modified for execution on a 32-bit machine
         by using two registers for each 64-bit quantity. If this is done and any calculations
         that would result in zero are used to make obvious simplifications, the <a id="page_145"></a>results are that a 32-bit version of the straightforward method described on page
         <a href="ch07.html#page_143">143</a> runs in 74 instructions (compared to 43 on a 64-bit machine), and a 32-bit version
         of the function of <a href="ch07.html#ch07fig6">Figure 7–6</a> runs in 36 instructions (compared to 21 on a 64-bit machine). Using Steele’s bit-swapping
         technique gives a reduction in instructions executed at the expense of instruction-level
         parallelism, as in the case of a 64-bit machine.
      </p>
      
      <h4><strong>Transposing a 32×32-Bit Matrix</strong></h4>
      
      <p class="noindent">The same recursive technique that was used for the 8×8-bit matrix can be used for
         larger matrices. For a 32×32-bit matrix it takes five stages.
      </p>
      
      <p class="indent">The details are quite different from <a href="ch07.html#ch07fig6">Figure 7–6</a>, because here we assume that the entire 32×32-bit matrix does not fit in the general
         register space, and we seek a compact procedure that indexes the appropriate words
         of the bit matrix to do the bit swaps. The algorithm to be described works best if
         run from coarse to fine granularity.
      </p>
      
      <p class="indent">In the first stage, treat the matrix as four 16×16-bit matrices, and transform it
         as follows:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/145equ01.jpg" /></div>
      
      <p class="noindent"><a id="page_146"></a><em>A</em> denotes the left half of the first 16 words of the matrix, <em>B</em> denotes the right half of the first 16 words, and so on. It should be clear that
         the above transformation can be accomplished by the following swaps:
      </p>
      
      <p class="center">Right half of word 0 with the left half of word 16,<br />Right half of word 1 with the left half of word 17,<br />...<br />Right half of word 15 with the left half of word 31.
      </p>
      
      <p class="noindent">To implement this in code, we will have an index <em>k</em> that ranges from 0 to 15. In a loop controlled by <em>k</em>, the right half of word <em>k</em> will be swapped with the left half of word <em>k</em> + 16.
      </p>
      
      <p class="indent">In the second stage, treat the matrix as 16 8×8-bit matrices, and transform it as
         follows:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/146equ01.jpg" /></div>
      
      <p class="noindent">This transformation can be accomplished by the following swaps:</p>
      
      <p class="indent2">Bits 0x00FF00FF of word 0 with bits 0xFF00FF00 of word 8,<br />Bits 0x00FF00FF of word 1 with bits 0xFF00FF00 of word 9, and so on.
      </p>
      
      <p class="noindent">This means that bits 0–7 (the least significant eight bits) of word 0 are swapped
         with bits 8–15 of word 8, and so on. The indexes of the first word in these swaps
         are <em>k</em> = 0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23. A way to step <em>k</em> through these values is
      </p>
      
      <div class="image"><img alt="Image" src="graphics/146equ02.jpg" /></div>
      
      <p class="noindent">In the loop controlled by <em>k</em>, bits of word <em>k</em> are swapped with bits of word <em>k</em> + 8.
      </p>
      
      <p class="indent">Similarly, the third stage does the following swaps:</p>
      
      <p class="indent2">Bits 0x0F0F0F0F of word 0 with bits 0xF0F0F0F0 of word 4,<br />Bits 0x0F0F0F0F of word 1 with bits 0xF0F0F0F0 of word 5, and so on.
      </p>
      
      <p class="noindent">The indexes of the first word in these swaps are <em>k</em> = 0, 1, 2, 3, 8, 9, 10, 11, 16, 17, 18, 19, 24, 25, 26, 27. A way to step <em>k</em> through these values is
      </p>
      
      <div class="image"><img alt="Image" src="graphics/146equ03.jpg" /></div>
      
      <p class="noindent">In the loop controlled by <em>k</em>, bits of word <em>k</em> are swapped with bits of word <em>k</em> + 4.
      </p>
      
      <p class="indent"><a id="page_147"></a>These considerations are coded rather compactly in the C function shown in <a href="ch07.html#ch07fig7">Figure 7–7</a> [GLS1]. The outer loop controls the five stages, with <code>j</code> taking on the values 16, 8, 4, 2, and 1. It also steps the mask <code>m</code> through the values 0x0000FFFF, 0x00FF00FF, 0x0F0F0F0F, 0x33333333, and 0x55555555.
         (The code for this, <code>m = m ^ (m <span class="entity">&lt;&lt;</span> j)</code>, is a nice little trick. It does not have an inverse, which is the main reason this
         code works best for coarse to fine transformations.) The inner loop steps <em>k</em> through the values described above. The inner loop body swaps the bits of <code>a[k]</code> identified by mask <code>m</code> with the bits of <code>a[k+j]</code> shifted right <code>j</code> and identified by <code>m</code>, which is equivalent to the bits of <code>a[k+j]</code> identified with the complement of <code>m</code>. The code for performing these swaps is an adaptation of the “three <em>exclusive or</em>” technique shown on page <a href="ch02.html#page_46">46</a> column (c).
      </p>
      
      <p class="codelink"><a href="images6.html#p07fig07" id="p07fig07a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch07fig7"></a>void transpose32(unsigned A[32]) {<br />   int j, k;<br />   unsigned m, t;<br /><br />   m = 0x0000FFFF;<br />   for (j = 16; j != 0; j = j &gt;&gt; 1, m = m ^ (m <span class="entity">&lt;&lt;</span> j)) {<br />      for (k = 0; k &lt; 32; k = (k + j + 1) &amp; ~j) {<br />           t = (A[k] ^ (A[k+j] &gt;&gt; j)) &amp; m;<br />           A[k] = A[k] ^ t;<br />           A[k+j] = A[k+j] ^ (t <span class="entity">&lt;&lt;</span> j);<br />      }<br />   }<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 7–7. Compact code for transposing a 32×32-bit matrix.
      </p>
      
      <p class="indent">Based on compiling this function with the GNU C compiler to a machine very similar
         to the basic RISC, this compiles into 31 instructions, with 20 in the inner loop,
         and 7 in the outer loop but not in the inner loop. Thus, it executes in 4 + 5(7 +
         16 · 20) = 1639 instructions. In contrast, if this function were performed using 16
         calls on the 8×8 transpose program of <a href="ch07.html#ch07fig6">Figure 7–6</a> (modified to run on a 32-bit machine), then it would take 16(101 + 5) = 1696 instructions,
         assuming the 16 calls are “strung out.” This includes five instructions for each function
         call (observed in compiled code). Therefore, the two methods are, on the surface anyway,
         very nearly equal in execution time.
      </p>
      
      <p class="indent">On the other hand, for a 64-bit machine the code of <a href="ch07.html#ch07fig7">Figure 7–7</a> can easily be modified to transpose a 64×64-bit matrix, and it would take about 4
         + 6(7 + 32 · 20) = 3886 instructions. Doing the job with 64 executions of the 8×8
         transpose method would take about 64(85 + 5) = 5760 instructions.
      </p>
      
      <p class="indent">The algorithm works in place, and thus if it is used to transpose a larger matrix,
         additional steps are required to move 32×32-bit submatrices. It can be made to put
         the result matrix in an area distinct from the source matrix by separating out either
         the first or last execution of the “for <em>j</em>-loop” and having it store the result in the other area.
      </p>
      
      <p class="indent"><a id="page_148"></a>About half the instructions executed by the function of <a href="ch07.html#ch07fig7">Figure 7–7</a> are for loop control, and the function loads and stores the entire matrix five times.
         Would it be reasonable to reduce this overhead by unrolling the loops? It would, if
         you are looking for the ultimate in speed, if memory space is not a problem, if your
         machine’s I-fetching can keep up with a large block of straight-line code, and especially
         if the branches or loads are costly in execution time. The bulk of the program will
         be the six instructions that do the bit swaps repeated 80 times (5 · 16). In addition,
         the program will need 32 <em>load</em> instructions to load the source matrix and 32 <em>store</em> instructions to store the result, for a total of at least 544 instructions.
      </p>
      
      <p class="indent"><a href="ch07.html#ch07fig8">Figure 7–8</a> outlines a program in which the unrolling is done by hand. This program is shown
         as not working in place, but it executes correctly in place, if that <a id="page_149"></a>is desired, by invoking it with identical arguments. The number of “swap” lines is
         80. Our GNU C compiler for the basic RISC machine compiles this into 576 instructions
         (branch-free, except for the function return), counting prologs and epilogs. This
         machine does not have the <em>store multiple</em> and <em>load multiple</em> instructions, but it can save and restore registers two at a time with <em>store double</em> and <em>load double</em> instructions.
      </p>
      
      <p class="codelink"><a href="images6.html#p07fig08" id="p07fig08a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch07fig8"></a><br />#define swap(a0, a1, j, m) t = (a0 ^ (a1 &gt;&gt;j)) &amp; m; \<br />                           a0 = a0 ^ t; \<br />                           a1 = a1 ^ (t <span class="entity">&lt;&lt;</span> j);<br /><br />void transpose32(unsigned A[32], unsigned B[32]) {<br />   unsigned m, t;<br />   unsigned a0, a1, a2, a3, a4, a5, a6, a7,<br />            a8, a9, a10, a11, a12, a13, a14, a15,<br />            a16, a17, a18, a19, a20, a21, a22, a23,<br />            a24, a25, a26, a27, a28, a29, a30, a31;<br /><br />   a0 = A[ 0]; a1 = A[ 1]; a2 = A[ 2]; a3 = A[ 3];<br />   a4 = A[ 4]; a5 = A[ 5]; a6 = A[ 6]; a7 = A[ 7];<br />   . . .<br />   a28 = A[28]; a29 = A[29]; a30 = A[30]; a31 = A[31];<br /><br />   m = 0x0000FFFF;<br />   swap(a0, a16, 16, m)<br />   swap(a1, a17, 16, m)<br />   . . .<br />   swap(a15, a31, 16, m)<br />   m = 0x00FF00FF;<br />   swap(a0, a8, 8, m)<br />   swap(a1, a9, 8, m)<br />   . . .<br />   . . .<br />   swap(a28, a29, 1, m)<br />   swap(a30, a31, 1, m)<br /><br />   B[ 0] = a0;   B[ 1] = a1;   B[ 2] = a2;   B[ 3] = a3;<br />   B[ 4] = a4;   B[ 5] = a5;   B[ 6] = a6;   B[ 7] = a7;<br />   . . .<br />   B[28] = a28;  B[29] = a29;  B[30] = a30;  B[31] = a31;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 7–8. Straight-line code for transposing a 32×32-bit matrix.
      </p>
      
      <p class="indent">There is a way to squeeze a little more performance out of this if your machine has
         a <em>rotate shift</em> instruction (either left or right). The idea is to replace all the <em>swap</em> operations of <a href="ch07.html#ch07fig8">Figure 7–8</a>, which take six instructions each, with simpler swaps that do not involve a shift,
         which take four instructions each (use the swap macro given, with the shifts omitted).
      </p>
      
      <p class="indent">First, rotate right words <em>A</em>[16..31] (that is, <em>A</em>[<em>k</em>] for 16 ≤ <em>k</em> ≤ 131) by 16 bit positions. Second, swap the right halves of <em>A</em>[0] with <em>A</em>[16], <em>A</em>[1] with <em>A</em>[17], and so on, similarly to the code of <a href="ch07.html#ch07fig8">Figure 7–8</a>. Third, rotate right words <em>A</em>[0..8] and <em>A</em>[24..31] by eight bit positions, and then swap the bits indicated by a mask of 0x00FF00FF
         in words <em>A</em>[0] and <em>A</em>[8], <em>A</em>[1] and <em>A</em>[9], and so on, as in the code of <a href="ch07.html#ch07fig8">Figure 7–8</a>. After five stages of this, you don’t quite have the transpose. Finally, you have
         to rotate left word <em>A</em>[1] by one bit position, <em>A</em>[2] by two bit positions, and so on (31 instructions). We do not show the code, but
         the steps are illustrated below for a 4×4-bit matrix.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/149equ01.jpg" /></div>
      
      <p class="indent">The bit-rearranging part of the program of <a href="ch07.html#ch07fig8">Figure 7–8</a> requires 480 instructions (80 swaps at six instructions each). The revised program,
         using <em>rotate</em> instructions, requires 80 swaps at four instructions each, plus 80 <em>rotate</em> instructions (16 · 5) for the first five stages, plus a final 31 <em>rotate</em> instructions, for a total of 431 instructions. The prolog and epilog code would be
         unchanged, so using <em>rotate</em> instructions in this way saves 49 instructions.
      </p>
      
      <p class="indent">There is another quite different method of transposing a bit matrix: apply three shearing
         transformations [GLS1]. If the matrix is <em>n×n</em>, the steps are (1) rotate row <em>i</em> to the right <em>i</em> bit positions, (2) rotate column <em>j</em> upwards (<em>j</em> + 1) mod <em>n</em> bit positions, (3) rotate row i to the right (<em>i</em> + 1) mod <em>n</em> bit positions, and (4) reflect the matrix about a horizontal axis through the midpoint.
         To illustrate, for a 4×4-bit matrix:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/149equ02.jpg" /></div>
      
      <p class="indent">This method is not quite competitive with the others, because step (2) is costly.
         (To do it at reasonable cost, rotate upward all columns that rotate by <em>n/2</em> <a id="page_150"></a>or more bit positions by <em>n</em> / 2 bit positions [these are columns <em>n</em> / 2 – 1 through <em>n</em>–2], then rotate certain columns upward <em>n</em> / 4 bit positions, and so on.) Steps 1 and 3 require only <em>n</em> – 1 instructions each, and step 4 requires no instructions at all if the results
         are simply stored to the appropriate locations.
      </p>
      
      <p class="indent">If an 8×8-bit matrix is stored in a 64-bit word in the obvious way (top row in the
         most significant eight bits, and so on), then the matrix transpose operation is equivalent
         to three outer perfect shuffles or unshuffles [GLS1]. This is a very good way to do
         it if your machine has shuffle or unshuffle as a single instruction, but it is not
         a good method on a basic RISC machine.
      </p>
      
      <h3><a id="ch07lev4"></a><strong>7–4 <em>Compress</em>, or <em>Generalized Extract</em></strong></h3>
      
      <p class="noindent">The APL language includes an operation called <em>compress</em>, written B/V, where B is a Boolean vector and V is vector of the same length as B,
         with arbitrary elements. The result of the operation is a vector consisting of the
         elements of V for which the corresponding bit in B is 1. The length of the result
         vector is equal to the number of 1’s in B.
      </p>
      
      <p class="indent">Here we consider a similar operation on the bits of a word. Given a mask <strong><em>m</em></strong> and a word <strong><em>x</em></strong>, the bits of <strong><em>x</em></strong> for which the corresponding mask bit is 1 are selected and moved (“compressed”) to
         the right. For example, if the word to be compressed is (where each letter denotes
         a single bit)
      </p>
      
      <p class="codelink"><a href="images6.html#p150pro01" id="p150pro01a">Click here to view code image</a></p>
      
      <p class="programlistings1">abcd efgh ijkl mnop qrst uvwx yzAB CDEF.</p>
      
      <p class="noindent">and the mask is</p>
      
      <p class="codelink"><a href="images6.html#p150pro02" id="p150pro02a">Click here to view code image</a></p>
      
      <p class="programlistings1">0000 1111 0011 0011 1010 1010 0101 0101,</p>
      
      <p class="noindent">then the result is</p>
      
      <p class="codelink"><a href="images6.html#p150pro03" id="p150pro03a">Click here to view code image</a></p>
      
      <p class="programlistings1">0000 0000 0000 0000 efgh klop qsuw zBDF.</p>
      
      <p class="noindent">This operation might also be called <em>generalized extract</em>, by analogy with the <em>extract</em> instruction found on many computers.
      </p>
      
      <p class="indent">We are interested in code for this operation with minimum worst-case execution time,
         and offer the simple loop of <a href="ch07.html#ch07fig9">Figure 7–9</a> as a straw man to be improved upon. This code has no branches in the loop, and it
         executes in 260 instructions worst case, including the subroutine prolog and epilog.
      </p>
      
      <p class="codelink"><a href="images6.html#p07fig09" id="p07fig09a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch07fig9"></a>unsigned compress(unsigned x, unsigned m) {<br />   unsigned r, s, b;    // Result, shift, mask bit.<br /><br />   r = 0;<br />   s = 0;<br />   do {<br />      b = m &amp; 1;<br />      r = r | ((x &amp; b) <span class="entity">&lt;&lt;</span> s);<br />      s = s + b;<br />      x = x &gt;&gt; 1;<br />      m = m &gt;&gt; 1;<br />   } while (m != 0);<br />   return r;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 7–9. A simple loop for the <em>compress</em> operation.
      </p>
      
      <p class="indent">It is possible to improve on this by repeatedly using the parallel suffix method (see
         page <a href="ch05.html#page_97">97</a>) with the <em>exclusive or</em> operation [GLS1]. We will denote the parallel suffix operation by PS-XOR. The basic
         idea is to first identify the bits of argument <strong><em>x</em></strong> that are to be moved right an odd number of bit positions, and move those. (This
         operation is simplified if <strong><em>x</em></strong> is first <em>and</em>ed with the mask, to clear out irrelevant bits.) Mask bits are moved in the same way.
         Next, we identify the bits of <strong><em>x</em></strong> that are to be moved an odd multiple of 2 positions (2, 6, 10, and so on), and then
         we move <a id="page_151"></a>these bits of <strong><em>x</em></strong> and the mask. Next, we identify and move the bits that are to be moved an odd multiple
         of 4 positions, then those that move an odd multiple of 8, and then those that move
         16 bit positions.
      </p>
      
      <p class="indent">Because this algorithm, believed to be original with [GLS1], is a bit difficult to
         understand, and because it is perhaps surprising that something along these lines
         can be done at all, we will describe its operation in some detail. Suppose the inputs
         are
      </p>
      
      <p class="codelink"><a href="images6.html#p151equ01" id="p151equ01a">Click here to view code image</a></p>
      
      <p class="program"><br />x = abcd efgh ijkl mnop qrst uvwx yzAB CDEF,<br />m = 1000 1000 1110 0000 0000 1111 0101 0101,<br />    1    1    111<br />    9    6    333            4444  3 2  1 0
      </p>
      
      <p class="noindent">where each letter in <code>x</code> represents a single bit (with value 0 or 1). The numbers below each 1-bit in the
         mask <code>m</code> denote how far the corresponding bit of <code>x</code> must move to the right. This is the number of 0’s in <code>m</code> to the right of the bit. As mentioned above, it is convenient to first clear out
         the irrelevant bits of <code>x</code>, giving
      </p>
      
      <p class="codelink"><a href="images6.html#p151equ02" id="p151equ02a">Click here to view code image</a></p>
      
      <p class="programlistings1">x = a000 e000 ijk0 0000 0000 uvwx 0z0B 0D0F.</p>
      
      <p class="indent">The plan is to first determine which bits move an odd number of positions (to the
         right), and move those one bit position. Recall that the PS-XOR operation results
         in a 1-bit at each position where the number of 1’s at and to the right of that position
         is odd. We wish to identify those bits for which the number of 0’s strictly to the
         right is odd. This can be done by computing <code>mk = ~m <span class="entity">&lt;&lt;</span> 1</code> and performing PS-XOR on the result. This gives
      </p>
      
      <p class="codelink"><a href="images6.html#p151equ03" id="p151equ03a">Click here to view code image</a></p>
      
      <p class="programlistings1">mk = 1110 1110 0011 1111 1110 0001 0101 0100,<br />mp = 1010 0101 1110 1010 1010 0000 1100 1100.
      </p>
      
      <p class="noindent">Observe that <code>mk</code> identifies the bits of <code>m</code> that have a 0 immediately to the right, and <code>mp</code> sums these, modulo 2, from the right. Thus, <code>mp</code> identifies the bits of <code>m</code> that have an odd number of 0’s to the right.
      </p>
      
      <p class="indent"><a id="page_152"></a>The bits that will be moved one position are those that are in positions that have
         an odd number of 0’s strictly to the right (identified by <code>mp</code>) and that have a 1-bit in the original mask. This is simply <code>mv = mp &amp; m</code>:
      </p>
      
      <p class="codelink"><a href="images6.html#p152equ01" id="p152equ01a">Click here to view code image</a></p>
      
      <p class="programlistings1">mv = 1000 0000 1110 0000 0000 0000 0100 0100.</p>
      
      <p class="indent">These bits of <code>m</code> can be moved with the assignment
      </p>
      
      <p class="codelink"><a href="images6.html#p152equ02" id="p152equ02a">Click here to view code image</a></p>
      
      <p class="programlisting1">m = (m ^ mv) | (mv &gt;&gt; 1);</p>
      
      <p class="noindent">and the same bits of <code>x</code> can be moved with the two assignments
      </p>
      
      <p class="codelink"><a href="images6.html#p152equ03" id="p152equ03a">Click here to view code image</a></p>
      
      <p class="programlisting1">t = x &amp; mv;<br />x = (x ^ t) | (t &gt;&gt; 1);
      </p>
      
      <p class="indent">(Moving the bits of <code>m</code> is simpler because all the selected bits are 1’s.) Here the <em>exclusive or</em> is turning off bits known to be 1 in <code>m</code> and <code>x</code>, and the <em>or</em> is turning on bits known to be 0 in <code>m</code> and <code>x</code>. The operations could also, alternatively, both be <em>exclusive or</em>, or <em>subtract</em> and <em>add</em>, respectively. The results, after moving the bits selected by <code>mv</code> right one position, are:
      </p>
      
      <p class="codelink"><a href="images6.html#p152equ04" id="p152equ04a">Click here to view code image</a></p>
      
      <p class="programlistings1">m = 0100 1000 0111 0000 0000 1111 0011 0011,<br />x = 0a00 e000 0ijk 0000 0000 uvwx 00zB 00DF.
      </p>
      
      <p class="indent">Now we must prepare a mask for the second iteration, in which we identify bits that
         are to move an odd multiple of 2 positions to the right. Notice that the quantity
         <code>mk &amp; ~mp</code> identifies those bits that have a 0 immediately to the right in the original mask
         <code>m</code>, and those bits that have an even number of 0’s to the right in the original mask.
         These properties apply jointly, although not individually, to the revised mask <code>m</code>. (That is to say, <code>mk</code> identifies <em>all</em> the positions in the revised mask <code>m</code> that have a 0 to the immediate right and an even number of 0’s to the right.) This
         is the quantity that, if summed from the right with PS-XOR, identifies those bits
         that move to the right an odd multiple of 2 positions (2, 6, 10, and so on). Therefore,
         the procedure is to assign this quantity to <code>mk</code> and perform a second iteration of the above steps. The revised value of <code>mk</code> is
      </p>
      
      <p class="codelink"><a href="images6.html#p152equ05" id="p152equ05a">Click here to view code image</a></p>
      
      <p class="programlistings1">mk = 0100 1010 0001 0101 0100 0001 0001 0000.</p>
      
      <p class="indent">A complete C function for this operation is shown in <a href="ch07.html#ch07fig10">Figure 7–10</a>. It does the job in 127 basic RISC instructions (constant)<sup><a id="ch07fna1"></a><a href="footnotes.html#ch07fn1">1</a></sup>, including the subroutine prolog <a id="page_153"></a>and epilog. <a href="ch07.html#ch07fig11">Figure 7–11</a> shows the sequence of values taken on by certain variables at key points in the computation,
         with the same inputs that were used in the discussion above. Observe that a by-product
         of the algorithm, in the last value assigned to <code>m</code>, is the original <code>m</code> with all its 1-bits compressed to the right.
      </p>
      
      <p class="codelink"><a href="images6.html#p07fig10" id="p07fig10a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch07fig10"></a><br />unsigned compress(unsigned x, unsigned m) {<br />   unsigned mk, mp, mv, t;<br />   int i;<br /><br />   x = x &amp; m;       // Clear irrelevant bits.<br />   mk = ~m <span class="entity">&lt;&lt;</span> 1;    // We will count 0's to right.<br /><br />   for (i = 0; i &lt; 5; i++) {<br />      mp = mk ^ (mk <span class="entity">&lt;&lt;</span> 1);            // Parallel suffix.<br />      mp = mp ^ (mp <span class="entity">&lt;&lt;</span> 2);<br />      mp = mp ^ (mp <span class="entity">&lt;&lt;</span> 4);<br />      mp = mp ^ (mp <span class="entity">&lt;&lt;</span> 8);<br />      mp = mp ^ (mp <span class="entity">&lt;&lt;</span> 16);<br />      mv = mp &amp; m;                    // Bits to move.<br />      m = m ^ mv | (mv &gt;&gt; (1 <span class="entity">&lt;&lt;</span> i));  // Compress m.<br />      t = x &amp; mv;<br />      x = x ^ t | (t &gt;&gt; (1 <span class="entity">&lt;&lt;</span> i));    // Compress x.<br />      mk = mk &amp; ~mp;<br />   }<br />   return x;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 7–10. Parallel suffix method for the <em>compress</em> operation.
      </p>
      
      <p class="indent">We calculate that the algorithm of <a href="ch07.html#ch07fig10">Figure 7–10</a> would execute in 169 instructions on a 64-bit basic RISC, as compared to 516 (worst
         case) for the algorithm of <a href="ch07.html#ch07fig9">Figure 7–9</a>.
      </p>
      
      <p class="indent">The number of instructions required by the algorithm of <a href="ch07.html#ch07fig10">Figure 7–10</a> can be reduced substantially if the mask <code>m</code> is a constant. This can occur in two situations: (1) a call to “<code>compress(x, m)</code>” occurs in a loop, in which the value of <code>m</code> is not known, but it is a loop constant, and (2) the value of <code>m</code> is known, and the code for <code>compress</code> is generated in advance, perhaps by a compiler.
      </p>
      
      <p class="indent">Notice that the value assigned to <code>x</code> in the loop in <a href="ch07.html#ch07fig10">Figure 7–10</a> is not used in the loop for anything other than the assignment to <code>x</code>. And <code>x</code> is dependent only on itself and variable <code>mv</code>. Therefore, the subroutine can be coded with all references to <code>x</code> deleted, and the five values computed for <code>mv</code> can be saved in variables <code>mv0, mv1,</code> ..., <code>mv4.</code> Then, in situation (1) the function without references to <code>x</code> can be placed outside the loop in which “<code>compress(x, m)</code>” occurs, and the following statements can be placed in the loop:
      </p>
      
      <p class="codelink"><a id="page_154"></a><a href="images6.html#p154equ01" id="p154equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">x = x &amp; m;<br />t = x &amp; mv0; x = x ^ t | (t &gt;&gt; 1);<br />t = x &amp; mv1; x = x ^ t | (t &gt;&gt; 2);<br />t = x &amp; mv2; x = x ^ t | (t &gt;&gt; 4);<br />t = x &amp; mv3; x = x ^ t | (t &gt;&gt; 8);<br />t = x &amp; mv4; x = x ^ t | (t &gt;&gt; 16);
      </p>
      
      <p class="noindent">This is only 21 instructions in the loop (the loading of the constants can be placed
         outside the loop), a considerable improvement over the 127 required by the full subroutine
         of <a href="ch07.html#ch07fig10">Figure 7–10</a>.
      </p>
      
      <p class="codelink"><a href="images6.html#p07fig11" id="p07fig11a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch07fig11"></a>           x = abcd efgh ijkl mnop qrst uvwx yzAB CDEF<br />           m = 1000 1000 1110 0000 0000 1111 0101 0101<br />           x = a000 e000 ijk0 0000 0000 uvwx 0z0B 0D0F<br /><br />i = 0,    mk = 1110 1110 0011 1111 1110 0001 0101 0100<br />After PS, mp = 1010 0101 1110 1010 1010 0000 1100 1100<br />          mv = 1000 0000 1110 0000 0000 0000 0100 0100<br />           m = 0100 1000 0111 0000 0000 1111 0011 0011<br />           x = 0a00 e000 0ijk 0000 0000 uvwx 00zB 00DF<br /><br />i = 1,    mk = 0100 1010 0001 0101 0100 0001 0001 0000<br />After PS, mp = 1100 0110 0000 1100 1100 0000 1111 0000<br />          mv = 0100 0000 0000 0000 0000 0000 0011 0000<br />           m = 0001 1000 0111 0000 0000 1111 0000 1111<br />           x = 000a e000 0ijk 0000 0000 uvwx 0000 zBDF<br /><br />i = 2,    mk = 0000 1000 0001 0001 0000 0001 0000 0000<br />After PS, mp = 0000 0111 1111 0000 1111 1111 0000 0000<br />          mv = 0000 0000 0111 0000 0000 1111 0000 0000<br />           m = 0001 1000 0000 0111 0000 0000 1111 1111<br />           x = 000a e000 0000 0ijk 0000 0000 uvwx zBDF<br /><br />i = 3,    mk = 0000 1000 0000 0001 0000 0000 0000 0000<br />After PS, mp = 0000 0111 1111 1111 0000 0000 0000 0000<br />          mv = 0000 0000 0000 0111 0000 0000 0000 0000<br />           m = 0001 1000 0000 0000 0000 0111 1111 1111<br />           x = 000a e000 0000 0000 0000 0ijk uvwx zBDF<br /><br />i = 4,    mk = 0000 1000 0000 0000 0000 0000 0000 0000<br />After PS, mp = 1111 1000 0000 0000 0000 0000 0000 0000<br />          mv = 0001 1000 0000 0000 0000 0000 0000 0000<br />           m = 0000 0000 0000 0000 0001 1111 1111 1111<br />           x = 0000 0000 0000 0000 000a eijk uvwx zBDF
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 7–11. Operation of the parallel suffix method for the <em>compress</em> operation.
      </p>
      
      <p class="indent"><a id="page_155"></a>In situation (2), in which the value of <code>m</code> is known, the same sort of thing can be done, and further optimization may be possible.
         It might happen that one of the five masks is 0, in which case one of the five lines
         shown above can be omitted. For example, mask <code>m1</code> is 0 if it happens that no bit moves an odd number of positions, and <code>m4</code> is 0 if no bit moves more than 15 positions, and so on.
      </p>
      
      <p class="indent">As an example, for</p>
      
      <p class="codelink"><a href="images6.html#p155pro01" id="p155pro01a">Click here to view code image</a></p>
      
      <p class="programlistings1">m = 0101 0101 0101 0101 0101 0101 0101 0101,</p>
      
      <p class="noindent">the calculated masks are</p>
      
      <p class="codelink"><a href="images6.html#p155pro02" id="p155pro02a">Click here to view code image</a></p>
      
      <p class="program">mv0 = 0100 0100 0100 0100 0100 0100 0100 0100<br />mv1 = 0011 0000 0011 0000 0011 0000 0011 0000<br />mv2 = 0000 1111 0000 0000 0000 1111 0000 0000<br />mv3 = 0000 0000 1111 1111 0000 0000 0000 0000<br />mv4 = 0000 0000 0000 0000 0000 0000 0000 0000
      </p>
      
      <p class="noindent">Because the last mask is 0, in the compiled code situation this compression operation
         is done in 17 instructions (not counting the loading of the masks). This is not quite
         as good as the code shown for this operation on page <a href="ch07.html#page_141">141</a> (13 instructions, not counting the loading of masks), which takes advantage of the
         fact that alternate bits are being selected.
      </p>
      
      <h4><strong>Using <em>Insert</em> and <em>Extract</em></strong></h4>
      
      <p class="noindent">If your computer has the <em>insert</em> instruction, preferably with immediate values for the operands that identify the
         bit field in the target register, then in the compiled situation <em>insert</em> can often be used to do the <em>compress</em> operation with fewer instructions than the methods discussed above. Furthermore,
         it doesn’t tie up registers holding the masks.
      </p>
      
      <p class="indent">The target register is initialized to 0, and then, for each contiguous group of 1’s
         in the mask <code>m</code>, variable <code>x</code> is shifted right to right-justify the next field, and the <em>insert</em> instruction is used to insert the bits of <code>x</code> in the appropriate place in the target register. This does the operation in 2<em>n</em> + 1 instructions, where <em>n</em> is the number of fields (groups of consecutive 1’s) in the mask. The worst case is
         33 instructions, because the maximum number of fields is 16 (which occurs for alternating
         1’s and 0’s).
      </p>
      
      <p class="indent">An example in which the <em>insert</em> method uses substantially fewer instructions is <code>m</code> = 0x0010084A. Compressing with this mask requires moving bits 1, 2, 4, 8, and 16
         positions. Thus, it takes the full 21 instructions for the parallel suffix method,
         but only 11 instructions for the <em>insert</em> method (there are five fields). A more extreme case is <code>m</code> = 0x80000000. Here a single bit moves 31 positions, requiring 21 instructions for
         the parallel suffix method, but only three instructions for the <em>insert</em> method and only one instruction (<em>shift right 31</em>) if you are not constrained to any particular scheme.
      </p>
      
      <p class="indent"><a id="page_156"></a>You can also use the <em>extract</em> instruction in various simple ways to do the <em>compress</em> operation with a known mask in 3<em>n</em> – 2 instructions, where <em>n</em> is the number of fields in the mask.
      </p>
      
      <p class="indent">Clearly, the problem of compiling optimal code for the <em>compress</em> operation with a known mask is a difficult one.
      </p>
      
      <h4><strong>Compress Left</strong></h4>
      
      <p class="noindent">To compress bits to the left, obviously you can reverse the argument <code>x</code> and the mask, compress right, and reverse the result. Another way is to compress
         right and then shift left by pop(<span class="middle"><img alt="Image" src="graphics/m-bar.jpg" /></span>). These might be satisfactory if your computer has an instruction for bit reversal
         or population count, but if not, the algorithm of <a href="ch07.html#ch07fig10">Figure 7–10</a> is easily adapted: Just reverse the direction of all the shifts except the two in
         the expressions <code>1 <span class="entity">&lt;&lt;</span> i</code> (eight to change).
      </p>
      
      <p class="indent">The BESM-6 computer (ca. 1967) had an instruction for the compress left function (“Pack
         Bits in A Masked by X”) and its inverse (“Unpack ...”), which operated on the machine’s
         48-bit registers. These instructions are not easy to implement. It is surmised by
         cryptography experts that their only use was for breaking US codes [Knu8]. The BESM-6
         also had the <em>population count</em> instruction which, as has been noted, seems to be important to the National Security
         Agency.
      </p>
      
      <h3><a id="ch07lev5"></a><strong>7–5 <em>Expand</em>, or <em>Generalized Insert</em></strong></h3>
      
      <p class="noindent">The inverse of the <em>compress right</em> function moves bits from the low-order end of a register to positions given by a
         mask, while keeping the bits in order. For example, expand(0000abcd, 10011010) = a00bc0d0.
         Thus
      </p>
      
      <p class="center">compress(expand(<strong><em>x, m</em></strong>), <strong><em>m</em></strong>) = <strong><em>x</em></strong>.
      </p>
      
      <p class="noindent">This function has also been called <em>unpack, scatter</em>, and <em>deposit</em>.
      </p>
      
      <p class="indent">It can be obtained by running the code of <a href="ch07.html#ch07fig10">Figure 7–10</a> in reverse [Allen]. To avoid overwriting bits in <code>x</code>, it is necessary to move (to the left) the bits that move a large distance first,
         and to move those that move only one position last. This means that the first five
         “move” quantities (<code>mv</code> in the code) must be computed, saved, and used in the reverse of the order in which
         they were computed. For many applications this is not a problem, because these applications
         apply the same mask <code>m</code> to large amounts of data, and so they would compute the move quantities in advance
         and reuse them anyway.
      </p>
      
      <p class="indent">The code is shown in <a href="ch07.html#ch07fig12">Figure 7–12</a>. It executes approximately 168 basic RISC instructions (constant), including five
         stores and five loads. A 64-bit version for a 64-bit machine would execute approximately
         200 instructions.
      </p>
      
      <p class="indent">For a machine that does not have the <em>and not</em> instruction, the MUX operation in the second loop can be coded in one fewer instruction
         with
      </p>
      
      <p class="codelink"><a href="images6.html#p156equ01" id="p156equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">x = ((x ^ y) &amp; mv) ^ x;</p>
      
      <p class="codelink"><a id="page_157"></a><a href="images6.html#p07fig12" id="p07fig12a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch07fig12"></a>unsigned expand(unsigned x, unsigned m) {<br />  unsigned m0, mk, mp, mv, t;<br />  unsigned array[5];<br />  int i;<br /><br />  m0 = m;        // Save original mask.<br />  mk = ~m <span class="entity">&lt;&lt;</span> 1;  // We will count 0's to right.<br /><br />  for (i = 0; i &lt; 5; i++) {<br />     mp = mk ^ (mk <span class="entity">&lt;&lt;</span> 1);             // Parallel suffix.<br />     mp = mp ^ (mp <span class="entity">&lt;&lt;</span> 2);<br />     mp = mp ^ (mp <span class="entity">&lt;&lt;</span> 4);<br />     mp = mp ^ (mp <span class="entity">&lt;&lt;</span> 8);<br />     mp = mp ^ (mp <span class="entity">&lt;&lt;</span> 16);<br />     mv = mp &amp; m;                     // Bits to move.<br />     array[i] = mv;<br />     m = (m ^ mv) | (mv &gt;&gt; (1 <span class="entity">&lt;&lt;</span> i)); // Compress m.<br />     mk = mk &amp; ~mp;<br />  }<br /><br />  for (i = 4; i &gt;= 0; i--) {<br />     mv = array[i];<br />     t = x <span class="entity">&lt;&lt;</span> (1 <span class="entity">&lt;&lt;</span> i);<br />     x = (x &amp; ~mv) | (t &amp; mv);<br />  } <br />  return x &amp; m0;    // Clear out extraneous bits.<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 7–12. Parallel suffix method for the <em>expand</em> operation.
      </p>
      
      <h3><a id="ch07lev6"></a><strong>7–6 Hardware Algorithms for Compress and Expand</strong></h3>
      
      <p class="noindent">This section gives hardware-oriented algorithms for the <em>compress right</em> function and its inverse [Zadeck]. Like the algorithms of the preceding sections,
         their execution times are proportional to the log of the computer’s word size. They
         are suitable for implementation in hardware, but do not yield fast code if implemented
         in basic RISC instructions. We simply describe how they work without giving C or machine
         code.
      </p>
      
      <h4><strong>Compress</strong></h4>
      
      <p class="noindent">To illustrate the operation of the algorithm, we represent each bit of <strong><em>x</em></strong> with a letter and consider a specific example mask <strong><em>m</em></strong>, shown below.
      </p>
      
      <p class="codelink"><a href="images6.html#p157equ01" id="p157equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1"><br />Input x =      abcd efgh ijkl mnop qrst uvwx yzAB CDEF<br />Mask m =       0111 1110 0110 1100 1010 1111 0011 0010
      </p>
      
      <p class="indent"><a id="page_158"></a>The algorithm works in log<sub>2</sub>(<em>W</em>) “phases,” where <em>W</em> is the computer’s word size in bits. Each phase operates in parallel on “pockets”
         of size 2<em><sup>n</sup></em> bits, for <em>n</em> ranging from 1 to log<sub>2</sub>(<em>W</em>). At the end of each phase, each pocket of <strong><em>x</em></strong> contains the original pocket of <strong><em>x</em></strong> with the bits selected by that pocket of <strong><em>m</em></strong> compressed to the right. Each pocket of <strong><em>m</em></strong> will contain an integer that is the number of 0-bits in that pocket of the original
         <strong><em>m</em></strong>. This is equal to the number of bits of <strong><em>x</em></strong> that are <em>not</em> compressed to the right. They are the known leading 0-bits in the pocket of <strong><em>x</em></strong>.
      </p>
      
      <p class="indent">In each phase, the algorithm performs the following steps, in parallel, on each pocket
         of <strong><em>x</em></strong> and <strong><em>m</em></strong>, where <em>w</em> is the pocket size in bits.
      </p>
      
      <p class="indenthangingN">1. Set <strong><em>L</em></strong> = the left half of the pocket of <strong><em>x</em></strong>, extended with <em>w</em> / 2 0-bits on the right.
      </p>
      
      <p class="indenthangingN">2. Shift <strong><em>L</em></strong> (all <em>w</em> bits) right by the amount given in the right half of the corresponding pocket of
         <strong><em>m</em></strong>, inserting 0’s on the left. No 1’s will be shifted out on the right, because the
         maximum shift amount is <em>w</em> / 2.
      </p>
      
      <p class="indenthangingN">3. Set <strong><em>R</em></strong> = <em>w</em> / 2 0-bits followed by the right half of the pocket of <strong><em>x</em></strong>.
      </p>
      
      <p class="indenthangingN">4. Replace the entire <em>w</em>-bit pocket of <strong><em>x</em></strong> with the <em>or</em> of <strong><em>R</em></strong> and the shifted <strong><em>L</em></strong>.
      </p>
      
      <p class="indenthangingN">5. Add the left and right halves of the pocket of <strong><em>m</em></strong>, and replace the entire pocket with the sum.
      </p>
      
      <p class="indent">To apply these steps to the first phase (<em>w</em> = 2) would require first <em>and</em>’ing <strong><em>x</em></strong> with <strong><em>m</em></strong>, to clear out irrelevant bits of <strong><em>x</em></strong>, and complementing <strong><em>m</em></strong> so that each bit of <strong><em>m</em></strong> is the number of 0-bits in each 1-bit half pocket. It is simpler to make an exception
         of the first phase, and combine these steps with the first compression operation by
         applying the logic shown in the table below to each 2-bit pocket of <strong><em>x</em></strong> and <strong><em>m</em></strong>.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/158tab01.jpg" /></div>
      
      <p class="noindent">The third line, for example, has <strong><em>m</em></strong> = 10 (binary). This means that the left bit of <strong><em>x</em></strong> is selected to be part of the result, but the right bit is not. Thus, the left bit
         (<code>a</code>) is compressed to the right. The other bit of <strong><em>x</em></strong> is cleared, which ensures that in the final result, all the high-order (not selected)
         bits will be 0.
      </p>
      
      <p class="indent">Applying this logic to the original <strong><em>x</em></strong> and <strong><em>m</em></strong> gives:
      </p>
      
      <p class="codelink"><a href="images6.html#p158equ01" id="p158equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">Bit pairs, x = 0bcd ef0g 0j0k mn00 0q0s uvwx 00AB 000E<br />           m = 0100 0001 0101 0010 0101 0000 1000 1001
      </p>
      
      <p class="indent">In the second phase, consider for example the second nibble above (<code>ef0g</code>). The quantities <strong><em>L</em></strong> = <code>ef00</code> and <strong><em>R</em></strong> = <code>000g</code> are formed. <strong><em>L</em></strong> is shifted right by one position (given by the right half of the nibble of <strong><em>m</em></strong>), giving <code>0ef0.</code> This is <em>or</em>’ed with <strong><em>R</em></strong>, giving <code>0efg</code> as the new value of the nibble. The left and right halves of <strong><em>m</em></strong> are added, giving <code>0001</code> (no change).
      </p>
      
      <p class="codelink"><a id="page_159"></a><a href="images6.html#p159equ01" id="p159equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">Nibbles,   x = 0bcd 0efg 00jk 00mn 00qs uvwx 00AB 000E<br />           m = 0001 0001 0010 0010 0010 0000 0010 0011
      </p>
      
      <p class="indent">Similarly, for the third, fourth, and fifth phases, each byte, halfword, and word
         of <strong><em>x</em></strong> are compressed, and <strong><em>m</em></strong> is updated, as follows:
      </p>
      
      <p class="codelink"><a href="images6.html#p159equ02" id="p159equ02a">Click here to view code image</a></p>
      
      <p class="programlisting1">Bytes,     x = 00bc defg 0000 jkmn 00qs uvwx 0000 0ABE<br />           m = 0000 0010 0000 0100 0000 0010 0000 0101
      </p>
      
      <p class="codelink"><a href="images6.html#p159equ03" id="p159equ03a">Click here to view code image</a></p>
      
      <p class="programlisting1">Halfwords, x = 0000 00bc defg jkmn 0000 000q suvw xABE<br />           m = 0000 0000 0000 0110 0000 0000 0000 0111
      </p>
      
      <p class="codelink"><a href="images6.html#p159equ04" id="p159equ04a">Click here to view code image</a></p>
      
      <p class="programlisting1">Words,     x = 0000 0000 0000 0bcd efgj kmnq suvw xABE<br />           m = 0000 0000 0000 0000 0000 0000 0000 1101
      </p>
      
      <p class="indent">Upon completion, <strong><em>m</em></strong> is an integer that gives the number of known leading 0’s in <strong><em>x</em></strong>. Subtracting this from the word size gives the number of compressed bits in <strong><em>x</em></strong>, which equals the number of 1-bits in the original mask <strong><em>m</em></strong>.
      </p>
      
      <p class="indent">The reason this is not a very good algorithm for implementation with basic RISC instructions
         is that it is hard to shift the half-pockets right by differing amounts. On the other
         hand, it might possibly be useful on an SIMD machine that has instructions that operate
         on the pockets of a word in parallel and independently.
      </p>
      
      <h4><strong>Expand</strong></h4>
      
      <p class="indent">The hardware compression algorithm can be turned into an expansion algorithm by, essentially,
         running it first forward and then in reverse. As in the algorithms based on the parallel
         suffix method, the five masks of the hardware compression algorithm are computed,
         saved, and used in the reverse of the order in which they were computed. Actually,
         the last mask is not used (nor is it used in the compression algorithm), but an additional
         one is required (<strong><em>m0</em></strong>) that is simply the complement of the original mask. In the forward pass, only the
         steps for computing the masks need be done; those involving the data <strong><em>x</em></strong> can be omitted.
      </p>
      
      <p class="indent">To illustrate, suppose we have</p>
      
      <p class="codelink"><a href="images6.html#p159equ05" id="p159equ05a">Click here to view code image</a></p>
      
      <p class="programlisting1">Input x = abcd efgh ijkl mnop qrst uvwx yzAB CDEF<br />Mask  m = 0111 1110 0110 1100 1010 1111 0011 0010
      </p>
      
      <p class="indent">Then the result of the expansion should be</p>
      
      <p class="codelink"><a href="images6.html#p159equ06" id="p159equ06a">Click here to view code image</a></p>
      
      <p class="programlistings1">0nop qrs0 0tu0 vw00 x0y0 zABC 00DE 00F0.</p>
      
      <p class="indent">The masks are shown below.</p>
      
      <p class="codelink"><a href="images6.html#p159equ07" id="p159equ07a">Click here to view code image</a></p>
      
      <p class="programlisting1">m0 = 1000 0001 1001 0011 0101 0000 1100 1101<br />m1 = 0100 0001 0101 0010 0101 0000 1000 1001<br />m2 = 0001 0001 0010 0010 0010 0000 0010 0011<br />m3 = 0000 0010 0000 0100 0000 0010 0000 0101<br />m4 = 0000 0000 0000 0110 0000 0000 0000 0111
      </p>
      
      <p class="indent"><a id="page_160"></a>The integer values of each half of <strong><em>m4</em></strong> give the number of 0-bits in the corresponding half of the original mask <strong><em>m</em></strong>. In particular, the right half of <strong><em>m</em></strong> has seven 0-bits. This means that the seven high-order bits of the right half of
         <strong><em>x</em></strong> do not belong there—they should be in the left half of <strong><em>x</em></strong>. Thus, bits 9 through 15 of <strong><em>x</em></strong> should be shifted left just enough to put them in the left half of <strong><em>x</em></strong>, and higher-order bits of <strong><em>x</em></strong> should be shifted left to accommodate them. This can be accomplished by shifting
         left the entire 32-bit word <strong><em>x</em></strong> by seven positions and replacing the left half of <strong><em>x</em></strong> with the left half of the shifted quantity. This gives
      </p>
      
      <p class="codelink"><a href="images6.html#p160equ01" id="p160equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">x = hijk lmno pqrs tuvw qrst uvwx yzAB CDEF.</p>
      
      <p class="indent">In general, the algorithm works with pocket sizes from 32 down to 2, in five phases,
         using masks <strong><em>m4</em></strong> down to <strong><em>m0</em></strong>. Each pocket (in parallel) is shifted left, discarding bits that are shifted out
         on the left, and supplying 0’s to vacated positions on the right, so that the shifted
         quantity is the same length as the pocket from which it came. Then the left half of
         the pocket is replaced by the left half of the shifted quantity. This will leave “garbage”
         bits in both halves of the pocket. They will be zeroed-out after the last phase by
         <em>and</em>’ing with the original mask.
      </p>
      
      <p class="indent">Continuing, we treat <strong><em>m3</em></strong> as two 16-bit pockets. The left pocket has the integer 4 in its right half, so the
         left pocket of <strong><em>x</em></strong> is shifted left four positions (giving <code>lmno pqrs tuvw 0000</code>), and the left half of this replaces the left half of the left pocket in <strong><em>x</em></strong>, making the left pocket of <strong><em>x</em></strong> = <code>lmno pqrs</code>. Performing the same operation on the right 16-bit pocket of <strong><em>x</em></strong> gives
      </p>
      
      <p class="codelink"><a href="images6.html#p160equ02" id="p160equ02a">Click here to view code image</a></p>
      
      <p class="programlisting1">x = lmno pqrs pqrs tuvw vwxy zABC yzAB CDEF.</p>
      
      <p class="indent">The next phase uses <strong><em>m2</em></strong>, which consists of four 8-bit pockets. Applying it to <strong><em>x</em></strong> gives
      </p>
      
      <p class="codelink"><a href="images6.html#p160equ03" id="p160equ03a">Click here to view code image</a></p>
      
      <p class="programlisting1">x = mnop pqrs rstu tuvw vwxy zABC BCDE CDEF.</p>
      
      <p class="indent">The next phase uses <strong><em>m1</em></strong>, which consists of eight 4-bit pockets. Applying it to <strong><em>x</em></strong> gives
      </p>
      
      <p class="codelink"><a href="images6.html#p160equ04" id="p160equ04a">Click here to view code image</a></p>
      
      <p class="programlisting1">x = mnop qrrs sttu vwvw wxxy zABC BCDE DEEF.</p>
      
      <p class="indent">The last phase uses <strong><em>m0</em></strong>, which consists of sixteen 2-bit pockets. Applying it to <strong><em>x</em></strong> gives
      </p>
      
      <p class="codelink"><a href="images6.html#p160equ05" id="p160equ05a">Click here to view code image</a></p>
      
      <p class="programlisting1">x = mnop qrss stuu vwww xxyy zABC CCDE EEFF.</p>
      
      <p class="indent">The final step is to <em>and</em> this with the original mask to clear irrelevant bits. This gives
      </p>
      
      <p class="codelink"><a href="images6.html#p160equ06" id="p160equ06a">Click here to view code image</a></p>
      
      <p class="programlisting1">x = 0nop qrs0 0tu0 vw00 x0y0 zABC 00DE 00F0.</p>
      
      <p class="indent"><a id="page_161"></a>The half-pockets of each computed mask contain a count of the number of 0-bits in
         the corresponding half-pocket of the original mask <strong><em>m</em></strong>. Therefore, as an alternative to computing the masks and saving them, the machine
         could employ circuits for doing a <em>population count</em> of the 0’s in the half-pockets “on the fly.”
      </p>
      
      <h3><a id="ch07lev7"></a><strong>7–7 General Permutations, Sheep and Goats Operation</strong></h3>
      
      <p class="noindent">To do general permutations of the bits in a word, or of anything else, a central problem
         is how to represent the permutation. It cannot be represented very compactly. Because
         there are 32! permutations of the bits in a 32-bit word, at least <span class="entity">⌈</span>log<sub>2</sub>(32!)<span class="entity">⌉</span> = 118 bits, or three words plus 22 bits, are required to designate one permutation
         out of the 32!.
      </p>
      
      <p class="indent">One interesting way to represent permutations is closely related to the compression
         operations discussed in <a href="ch07.html#ch07lev4">Section 7–4</a> [GLS1]. Start with the direct method of simply listing the bit position to which
         each bit moves. For example, for the permutation done by a rotate left of four bit
         positions, the bit at position 0 (the least significant bit) moves to position 4,
         1 moves to 5, ..., 31 moves to 3. This permutation can be represented by the vector
         of 32 5-bit indexes:
      </p>
      
      <p class="codelink"><a href="images6.html#p161equ01" id="p161equ01a">Click here to view code image</a></p>
      
      <p class="programlistings1">00100<br />00101<br />...<br />11111<br />00000<br />00001<br />00010<br />00011
      </p>
      
      <p class="indent">Treating that as a bit matrix, the representation we have in mind is its transpose,
         except reflected about the off diagonal so the top row contains the least significant
         bits and the result uses little-endian bit numbering. This we store as five 32-bit
         words in array <code>p</code>:
      </p>
      
      <p class="codelink"><a href="images6.html#p161equ02" id="p161equ02a">Click here to view code image</a></p>
      
      <p class="programlisting2">p[0] = 1010 1010 1010 1010 1010 1010 1010 1010<br />p[1] = 1100 1100 1100 1100 1100 1100 1100 1100<br />p[2] = 0000 1111 0000 1111 0000 1111 0000 1111<br />p[3] = 0000 1111 1111 0000 0000 1111 1111 0000<br />p[4] = 0000 1111 1111 1111 1111 0000 0000 0000
      </p>
      
      <p class="indent">Each bit of <code>p[0]</code> is the least significant bit of the position to which the corresponding bit of <code>x</code> moves, each bit of <code>p[1]</code> is the next more significant bit, and so on. This is similar to the encoding of the
         masks denoted by <code>mv</code> in the previous section, except that <code>mv</code> applies to revised masks in the compress algorithm, not to the original mask.
      </p>
      
      <p class="indent"><a id="page_162"></a>The compression operation we need compresses to the left all bits marked with 1’s
         in the mask, and compresses to the right all bits marked with 0’s.<sup><a id="ch07fna2"></a><a href="footnotes.html#ch07fn2">2</a></sup> This is sometimes called the “sheep and goats” operation (SAG), or “generalized unshuffle.”
         It can be calculated with
      </p>
      
      <p class="codelink"><a href="images6.html#p162equ01" id="p162equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">SAG(x, m) = compress_left(x, m) | compress(x, ~m).</p>
      
      <p class="indent">With SAG as a fundamental operation, and a permutation <code>p</code> as described above, the bits of a word <code>x</code> can be permuted by <code>p</code> in the following 15 steps:
      </p>
      
      <p class="codelink"><a href="images6.html#p162equ02" id="p162equ02a">Click here to view code image</a></p>
      
      <p class="programlisting3">x    = SAG(x,    p[0]);<br />p[1] = SAG(p[1], p[0]);<br />p[2] = SAG(p[2], p[0]);<br />p[3] = SAG(p[3], p[0]);<br />p[4] = SAG(p[4], p[0]);<br /><br />x    = SAG(x,    p[1]);<br />p[2] = SAG(p[2], p[1]);<br />p[3] = SAG(p[3], p[1]);<br />p[4] = SAG(p[4], p[1]);<br /><br />x    = SAG(x,    p[2]);<br />p[3] = SAG(p[3], p[2]);<br />p[4] = SAG(p[4], p[2]);<br /><br />x    = SAG(x,    p[3]);<br />p[4] = SAG(p[4], p[3]);<br /><br />x    = SAG(x,    p[4]);
      </p>
      
      <p class="indent">In these steps, SAG is used to perform a stable binary radix sort. Array <code>p</code> is used as 32 5-bit keys to sort the bits of <code>x</code>. In the first step, all bits of <code>x</code> for which <code>p[0]</code> = 1 are moved to the left half of the resulting word, and all those for which <code>p[0]</code> = 0 are moved to the right half. Other than this, the order of the bits is not changed
         (that is, the sort is “stable”). Then all the keys that will be used for the next
         round of sorting are similarly sorted. The sixth line is sorting <code>x</code> based on the second least significant bit of the key, and so on.
      </p>
      
      <p class="indent">Similar to the situation of compressing, if a certain permutation <code>p</code> is to be used on a number of words <code>x</code>, then a considerable savings results by precomputing most of the steps above. The
         permutation array is revised to
      </p>
      
      <p class="codelink"><a href="images6.html#p162equ03" id="p162equ03a">Click here to view code image</a></p>
      
      <p class="programlisting1">p[1] = SAG(p[1], p[0]);<br />p[2] = SAG(SAG(p[2], p[0]), p[1]);<br />p[3] = SAG(SAG(SAG(p[3], p[0]), p[1]), p[2]);<br />p[4] = SAG(SAG(SAG(SAG(p[4], p[0]), p[1]), p[2]), p[3]);
      </p>
      
      <p class="noindent"><a id="page_163"></a>and then each permutation is done with
      </p>
      
      <p class="codelink"><a href="images6.html#p163equ01" id="p163equ01a">Click here to view code image</a></p>
      
      <p class="programlistings1"><br />x = SAG(x, p[0]);<br />x = SAG(x, p[1]);<br />x = SAG(x, p[2]);<br />x = SAG(x, p[3]);<br />x = SAG(x, p[4]);
      </p>
      
      <p class="indent">A more direct (but perhaps less interesting) way to do general permutations of the
         bits in a word is to represent a permutation as a sequence of 32 5-bit indexes. The
         <em>k</em>th index is the bit number in the source from which the <em>k</em>th bit of the result comes. (This is a “comes from” list, whereas the SAG method uses
         a “goes to” list.) These could be packed six to a 32-bit word, thus requiring six
         words to hold all 32 bit indexes. An instruction can be implemented in hardware such
         as
      </p>
      
      <p class="codelink"><a href="images6.html#p163equ02" id="p163equ02a">Click here to view code image</a></p>
      
      <p class="programlistings1">bitgather Rt,Rx,Ri,</p>
      
      <p class="noindent">where register <code>Rt</code> is a target register (and also a source), register <code>Rx</code> contains the bits to be permuted, and register <code>Ri</code> contains six 5-bit indexes (and two unused bits). The operation of the instruction
         is
      </p>
      
      <div class="image"><img alt="Image" src="graphics/163equ03.jpg" /></div>
      
      <p class="indent">In words, the contents of the target register are shifted left six bit positions,
         and six bits are selected from word <strong><em>x</em></strong> and placed in the vacated six positions of <strong><em>t</em></strong>. The bits selected are given by the six 5-bit indexes in word <strong><em>i</em></strong>, taken in left-to-right order. The bit numbering in the indexes could be either little-
         or big-endian, and the operation would probably be as described for either type of
         machine.
      </p>
      
      <p class="indent">To permute a word, use a sequence of six such instructions, all with the same <code>Rt</code> and <code>Rx</code>, but different index registers. In the first index register of the sequence, only
         indexes <em>i</em><sub>4</sub> and <em>i</em><sub>5</sub> are significant, as the bits selected by the other four indexes are shifted out of
         the left end of <code>Rt</code>.
      </p>
      
      <p class="indent">An implementation of this instruction would most likely allow index values to be repeated,
         so the instruction can be used to do more than permute bits. It can be used to repeat
         any selected bit any number of times in the target register. The SAG operation lacks
         this generality.
      </p>
      
      <p class="indent">It is not unduly difficult to implement this as a fast (e.g., one cycle) instruction.
         The bit selection circuit consists of six 32:1 MUX’s. If these are built from five
         stages of 2:1 MUX’s in today’s technology (6 · 31 = 186 MUX’s in all), the instruction
         would be faster than a 32-bit <em>add</em> instruction [MD].
      </p>
      
      <p class="indent">Some of the Intel machines have instructions that work much like the bit permutation
         operation described, but that permute bytes, “words” (16 bits), and “doublewords”
         (32 bits). These are PSHUFB, PSHUFW, and PSHUFD (Shuffle Packed Bytes/Words/Doublewords).
      </p>
      
      <p class="indent"><a id="page_164"></a>Permuting bits has applications in cryptography, and the closely related operation
         of permuting subwords (e.g., permuting the bytes in a word) has applications in computer
         graphics. Both of these applications are more likely to deal with 64-bit words, or
         possibly with 128, than with 32. The SAG and <em>bitgather</em> methods apply with obvious changes to these larger word sizes.
      </p>
      
      <p class="indent">To encrypt or decrypt a message with the Data Encryption Standard (DES) algorithm
         requires a large number of permutation-like mappings. First, key generation is done,
         once per session. This involves 17 permutation-like mappings. The first, called “permuted
         choice 1,” maps from a 64-bit quantity to a 56-bit quantity (it selects the 56 non-parity
         bits from the key and permutes them). This is followed by 16 permutation-like mappings
         from 56 bits to 48 bits, all using the same mapping, called “permuted choice 2.”
      </p>
      
      <p class="indent">Following key generation, each block of 64 bits in the message is subjected to 34
         permutation-like operations. The first and last operations are 64-bit permutations,
         one being the inverse of the other. There are 16 permutations with repetitions that
         map 32-bit quantities to 48 bits, all using the same mapping. Finally, there are 16
         32-bit permutations, all using the same permutation. The total number of distinct
         mappings is six. They are all constants and are given in [DES].
      </p>
      
      <p class="indent">DES is obsolete, as it was proved to be insecure in 1998 by the Electronic Frontier
         Foundation, using special hardware. The National Institute of Standards and Technology
         (NIST) has endorsed a temporary replacement called Triple DES, which consists of DES
         run serially three times on each 64-bit block, each time with a different key (that
         is, the key length is 192 bits, including 24 parity bits). Hence, it takes three times
         as many permutation operations as does DES to encrypt or decrypt.
      </p>
      
      <p class="indent">The “permanent” replacement for DES and Triple DES, the Advanced Encryption Standard
         (previously known as the Rijndael algorithm [AES]), involves <em>no</em> bit-level permutations. The closest it comes to a permutation is a simple rotation
         of 32-bit words by a multiple of 8-bit positions. Other encryption methods proposed
         or in use generally involve far fewer bit-level permutations than DES.
      </p>
      
      <p class="indent">To compare the two permutation methods discussed here, the <em>bitgather</em> method has the advantages of (1) simpler preparation of the index words from the
         raw data describing the permutation, (2) simpler hardware, and (3) more general mappings.
         The SAG method has the advantages of (1) doing the permutation in five rather than
         six instructions, (2) having only two source registers in its instruction format (which
         might fit better in some RISC architectures), (3) scaling better to permute a doubleword
         quantity, and (4) permuting subwords more efficiently.
      </p>
      
      <p class="indent">Item (3) is discussed in [LSY]. The SAG instruction allows for doing a general permutation
         of a two-word quantity with two executions of the SAG instruction, a few basic RISC
         instructions, and two full permutations of single words. <a id="page_165"></a>The <em>bitgather</em> instruction allows for doing it by executing <em>three</em> full permutations of single words, plus a few basic RISC instructions. This does
         not count preprocessing of the permutation to produce new quantities that depend only
         on the permutation. We leave it to the reader to discover these methods.
      </p>
      
      <p class="indent">Regarding item (4), to permute, for example, the four bytes of a word with <em>bitgather</em> requires executing six instructions, the same as for a general bit permutation by
         <em>bitgather</em>. But with SAG it can be done in only two instructions, rather than the five required
         for a general bit permutation by SAG. The gain in efficiency applies even when the
         subwords are not a power of 2 in size; the number of steps required is <span class="entity">⌈</span>log<sub>2</sub><em>n</em><span class="entity">⌉</span>, where <em>n</em> is the number of subwords, not counting a possible non-participating group of bits
         that stays at one end or the other.
      </p>
      
      <p class="indent">[LSY] discusses the SAG and <em>bitgather</em> instructions (called “GRP” and “PPERM,” respectively), other possible permutation
         instructions based on networks, and permuting by table lookup.
      </p>
      
      <p class="indent">There is a neat hack to add 1 to the goats—that is, to compute</p>
      
      <div class="image"><img alt="Image" src="graphics/165equ01.jpg" /></div>
      
      <p class="noindent">without using the SAG function or its inverse [Knu8]. Here we assume SAG(<strong><em>x, m</em></strong>) puts the goats on the right, and the addition does not overflow into the “sheep”
         field. We leave to the reader the pleasure of discovering this trick.
      </p>
      
      <h3><a id="ch07lev8"></a><strong>7–8 Rearrangements and Index Transformations</strong></h3>
      
      <p class="noindent">Many simple rearrangements of the bits in a computer word correspond to even simpler
         transformations of the coordinates, or indexes, of the bits [GLS1]. These correspondences
         apply to rearrangements of the elements of any one-dimensional array provided the
         number of array elements is an integral power of 2. For programming purposes, they
         are useful primarily when the array elements are a computer word or larger in size.
      </p>
      
      <p class="indent">As an example, the outer perfect shuffle of the elements of an array <em>A</em> of size eight, with the result in array <em>B</em>, consists of the following moves:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/165equ02.jpg" /></div>
      
      <p class="noindent">Each <em>B</em>-index is the corresponding <em>A</em>-index rotated left one position, using a 3-bit rotator. The outer perfect <em>unshuffle</em> is, of course, accomplished by rotating <em>right</em> each index. Some similar correspondences are shown in <a href="ch07.html#ch07tab1">Table 7–1</a>. Here <em>n</em> is the number of array elements, “lsb” means least significant bit, and the rotations
         of indexes are done with a log<sub>2</sub><em>n</em>-bit rotator.
      </p>
      
      <p class="tab-caption"><a id="page_166"></a><a id="ch07tab1"></a>T<small>ABLE</small> 7–1. R<small>EARRANGEMENTS AND</small> I<small>NDEX</small> T<small>RANSFORMATIONS</small></p>
      
      <div class="image2"><img alt="Image" src="graphics/07tab01.jpg" /></div>
      
      <h3><a id="ch07lev9"></a><strong>7–9 An LRU Algorithm</strong></h3>
      
      <p class="noindent">Ever wonder how your computer keeps track of which cache line is the least recently
         used? Here we describe one such algorithm, known as the <em>reference matrix</em> method. It is primarily a hardware algorithm, but it might have application in software.
      </p>
      
      <p class="indent">We won’t go into a long discussion of the intriguing world of caches, but only say
         that we have in mind the high-speed caches that buffer data between a computer’s main
         memory and the processor. These caches may get a request for a word every computer
         cycle, and they should usually respond with the data within a cycle or two, so there
         is not much time for a complicated algorithm.
      </p>
      
      <p class="indent">A cache contains a copy of a subset of the data in main memory, and the problem we
         are addressing is: when a cache miss occurs (that is, when a word at a certain address
         is requested and the data at that address are not in the cache), how does the computer
         decide which block (or <em>line</em>, in cache jargon) to replace with the requested data? Ideally, it should replace
         the data in the line that will not be referenced for the longest time in the future.
         But we cannot know the future, so we have to guess. The best guess over a wide variety
         of application programs seems to be the <em>least recently used</em> (LRU) policy. This policy replaces the line that has not been referenced for the
         longest time.
      </p>
      
      <p class="indent"><a id="page_167"></a>Caches come in three varieties: <em>direct-mapped, fully associative</em>, and <em>set-associative</em>. In a direct-mapped cache, certain bits of the address of the load or store instruction
         directly address a particular cache line. When a miss occurs, there is no question
         as to what line to replace—it must be the addressed line. There is no need for an
         LRU or any other guessing policy.
      </p>
      
      <p class="indent">In a fully associative cache, a block from main memory can be placed in <em>any</em> cache line. When a load or store is executed, the address is looked up to see if
         it is in the cache. If not, it is necessary to replace the contents of some line.
         The machine has complete flexibility in the choice of line to replace. Several strategies
         have been used (FIFO, random, and LRU are the most common) and, as mentioned above,
         LRU seems to be the one that most often results in the lowest miss rate. Unfortunately,
         LRU is the most expensive to implement when there are many lines to consider for replacement.
      </p>
      
      <p class="indent">Often the set-associative organization is chosen. It is a compromise between direct-mapped
         and fully associative. The designer decides on the degree of associativity, which
         is usually 2, 4, 8, or 16. The cache is divided into a number of “sets,” each of which
         contains 2, 4, 8, or 16 lines (typically). The set is directly addressed, using certain
         bits of the load or store address, but the line within the set must be looked up.
         The lookup in the set is done much the same as in the case of a fully associative
         cache. Now, when it is necessary to replace a line, the LRU algorithm need only determine
         which of the lines within one set is the least recently used, and replace that.
      </p>
      
      <p class="indent">With this brief background, we can describe the reference matrix method. To illustrate,
         assume the cache is four-way set-associative. This means that there are four lines
         for which we wish to keep track of the least recently used (referenced). The cache
         may be fully associative and consist of only four lines, or it may be set-associative
         with four lines per set.
      </p>
      
      <p class="indent">The reference matrix method employs a square bit matrix of dimension equal to the
         degree of associativity (in principle; we will modify this statement later). Each
         associative set has one such matrix. The essence of the method is that when line <em>i</em> is referenced, row <em>i</em> of the matrix is set to 1’s, and then column <em>i</em> is set to 0’s. <a href="ch07.html#ch07fig13">Figure 7–13</a> illustrates the changes in the matrix from an initial state to its configuration
         after a reference to lines 3, 1, 0, 2, 0, 3, and 2, in that order.
      </p>
      
      <div class="image"><a id="ch07fig13"></a><img alt="Image" src="graphics/07fig13.jpg" /></div>
      
      <p class="fig-caption">F<small>IGURE</small> 7–13. Illustration of the reference matrix method.
      </p>
      
      <p class="indent">Each matrix has a row containing three 1’s, two 1’s, one 1, and no 1’s. The number
         of the row with no 1’s is the least recently used line. The number of the row <a id="page_168"></a>with one 1 is the next least recently used line, and so on. When a cache miss occurs,
         the machine finds the row with all 0’s and replaces the corresponding line. It then
         records it as the <em>most</em> recently used line by setting its row to all 1’s and its column to all 0’s.
      </p>
      
      <p class="indent">Why does this work? Denoting the matrix by <em>M</em>, the reason it works is that <em>M<sub>ij</sub></em> indicates whether or not line <em>i</em> is more recently used than line <em>j</em>. If <em>M<sub>ij</sub></em> = 1, line <em>i</em> is more recently used than line <em>j</em>, and if <em>M<sub>ij</sub></em> = 0, line <em>i</em> is not more recently used than line <em>j</em>.
      </p>
      
      <p class="indent">Consider an arbitrary 4×4 matrix for which line 2 is referenced. Then the matrix changes
         as shown in <a href="ch07.html#ch07fig14">Figure 7–14</a>. Setting row <em>i</em> to 1’s (except for the element on the main diagonal) is recording that line <em>i</em> is more recently used than line <em>j</em>, for all <em>j</em> ≠ <em>i</em>. Setting column <em>i</em> to 0’s is recording that line <em>j</em> is not more recently used than line <em>i</em>, for all <em>j</em>. Relations among cache lines other than <em>i</em> are not changed. When all the lines have been referenced, all the “more recently
         used” relations will be established.
      </p>
      
      <p class="indent">Thus, the reference matrix is antisymmetric and the main diagonal is always all 0’s.
         Therefore, only part of the matrix, either the elements above the main diagonal or
         those below the main diagonal, need be stored in the cache. That is what is done in
         practice. For an <em>n</em>-way associative set, <em>n</em>(<em>n</em> – 1)/2 memory bits are required. For <em>n</em> = 4, this is six; for <em>n</em> = 8, it is 28. Twenty-eight is getting to be a bit large, so the reference matrix
         method, and in fact the true LRU policy, is not often used for degrees of associativity
         greater than 8. Instead, there are approximate LRU methods and methods that are not
         LRU at all.
      </p>
      
      <p class="indent">In software, the LRU policy would probably be implemented with a list of the line
         numbers (either a simple vector or a linked list). When line <em>i</em> is referenced, the list is searched for <em>i</em>, and then <em>i</em> is moved to the top of the list. The least recently used line number then migrates
         to the bottom of the list.
      </p>
      
      <p class="indent">That method is relatively slow on references (because of rearranging the list), but
         fast in deciding which line to replace. Another method, with the opposite speed characteristics,
         is to have a vector of length equal to the degree of associativity, with position
         <em>i</em> holding both the address that line <em>i</em> holds and its “age” (actually “newness”) encoded as an integer. When line <em>i</em> is referenced, a single variable that holds the current “age” is incremented, and
         the resulting value is stored in the vector at position <em>i</em>. To find the least recently used line, the vector is searched for the line with the
         smallest value of “age.” This method fails if the “age” integer overflows.
      </p>
      
      <div class="image"><a id="ch07fig14"></a><img alt="Image" src="graphics/07fig14.jpg" /></div>
      
      <p class="fig-caption">F<small>IGURE</small> 7–14. One step of the reference matrix method.
      </p>
      
      <p class="indent"><a id="page_169"></a>There might be one “age” integer per associative set, or only one for the whole cache,
         or in hardware a cycle counter could be used.
      </p>
      
      <p class="indent">The reference matrix method might be useful in software when the degree of associativity
         is small. For example, suppose an application uses eight-way set-associativity and
         is to run on a 64-bit machine. Then the reference matrix can be stored in a single
         64-bit register. Let the low-order eight bits of the register hold row 0 of the matrix,
         the next eight bits hold row 1, and so forth. Then when line <em>i</em> is referenced, byte <em>i</em> of the register should be set to 1’s, and bits <em>i, i</em> + 8, ..., <em>i</em> + 56 should be cleared. Denoting the register by <strong><em>m</em></strong>, this is accomplished as shown here.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/169equ01.jpg" /></div>
      
      <p class="noindent">This amounts to five or six instructions, plus a few to load constants. To find the
         least recently used line, search for an all-zero byte (see <a href="ch06.html#ch06lev1">Section 6–1</a>). The advantage of this method over the other software methods briefly outlined above
         is that all the work is done in a register.
      </p>
      
      <h4><strong>Exercises</strong></h4>
      
      <p class="question"><a href="ch19_answer.html#ch07ans1" id="ch07ansa1"><strong>1</strong>.</a> Explain the workings of the second Möbius formula (Equation (1), page <a href="ch07.html#page_139">139</a>).
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch07ans2" id="ch07ansa2"><strong>2</strong>.</a> The perfect outer shuffle operation and its inverse employ the following masks:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/169equ02.jpg" /></div>
      
      <p class="indenthanging">What is a formula for the general case, <em>m<sub>k</sub></em>? A formula might be useful in situations in which an upper bound on the length of
         the integers being shuffled is not known in advance, such as in “bignum” applications.
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch07ans3" id="ch07ansa3"><strong>3</strong>.</a> Code a function similar to the compress function of <a href="ch07.html#ch07fig9">Figure 7–9</a> that does the expand operation.
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch07ans4" id="ch07ansa4"><strong>4</strong>.</a> For an <em>n</em>-way set-associative cache, what is the theoretical minimum number of bits required
         to implement the LRU policy? Compare that to the number of bits required for the reference
         matrix method, for a few small values of <em>n</em>.<a id="page_170"></a></p>
      
   </body>
   
</html>