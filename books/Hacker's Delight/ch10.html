<html xmlns="http://www.w3.org/1999/xhtml">
   
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      
      <title>Chapter 10. Integer Division By Constants</title>
      
      <link href="9780133085013.css" rel="stylesheet" type="text/css" />
      
      <link href="page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
      
      <meta content="urn:uuid:767ce45a-85bb-4273-91f5-801bab42906b" name="Adept.expected.resource" />
      
   </head>
   
   <body>
      
      <h2><a id="page_205"></a><a id="ch10"></a>Chapter 10. Integer Division By Constants
      </h2>
      
      <p class="noindent">On many computers, division is very time consuming and is to be avoided when possible.
         A value of 20 or more elementary <em>add</em> times is not uncommon, and the execution time is usually the same large value even
         when the operands are small. This chapter gives some methods for avoiding the <em>divide</em> instruction when the divisor is a constant.
      </p>
      
      <h3><a id="ch10lev1"></a><strong>10–1 Signed Division by a Known Power of 2</strong></h3>
      
      <p class="noindent">Apparently, many people have made the mistake of assuming that a <em>shift right signed</em> of <em>k</em> positions divides a number by 2<sup><em>k</em></sup>, using the usual truncating form of division [GLS2]. It’s a little more complicated
         than that. The code shown below computes <strong><em>q</em></strong> = <strong><em>n</em></strong> ÷ <strong>2</strong><sup><em>k</em></sup>, for 1 ≤ <em>k</em> ≤ 31 [Hop].
      </p>
      
      <p class="codelink"><a href="images9.html#p205equ01" id="p205equ01a">Click here to view code image</a></p>
      
      <p class="programlisting2">shrsi t,n,k-1        Form the integer<br />shri  t,t,32-k       2**k – 1 if n &lt; 0, else 0.<br />add   t,n,t          Add it to n,<br />shrsi q,t,k          and shift right (signed).
      </p>
      
      <p class="noindent">It is branch free. It simplifies to three instructions in the common case of division
         by 2 (<em>k</em> = 1). It does, however, rely on the machine’s being able to shift by a large amount
         in a short time. The case <em>k</em> = 31 does not make too much sense, because the number 2<sup>31</sup> is not representable in the machine. Nevertheless, the code does produce the correct
         result in that case (which is <em>q</em> = –1 if <em>n</em> = –2<sup>31</sup>and <em>q</em> = 0 for all other <em>n</em>).
      </p>
      
      <p class="indent">To divide by –2<sup><em>k</em></sup>, the above code can be followed by a <em>negate</em> instruction. There does not seem to be any better way to do it.
      </p>
      
      <p class="indent">The more straightforward code for dividing by 2<sup><em>k</em></sup> is
      </p>
      
      <p class="codelink"><a href="images9.html#p205equ02" id="p205equ02a">Click here to view code image</a></p>
      
      <p class="programlisting">        bge   n,label       Branch if n &gt;= 0.<br />        addi  n,n,2**k-1    Add 2**k - 1 to n,<br /> label  shrsi n,n,k         and shift right (signed).<br /><br /></p>
      
      <p class="noindent">This would be preferable on a machine with slow shifts and fast branches.</p>
      
      <p class="indent">PowerPC has an unusual device for speeding up division by a power of 2 [GGS]. The
         <em>shift right signed</em> instructions set the machine’s carry bit if the number being shifted is negative
         and one or more 1-bits are shifted out. That machine also has an instruction for adding
         the carry bit to a register, denoted <code>addze</code>. This allows division by any (positive) power of 2 to be done in two instructions:
      </p>
      
      <p class="codelink"><a id="page_206"></a><a href="images9.html#p206pro01" id="p206pro01a">Click here to view code image</a></p>
      
      <p class="programlisting1">shrsi q,n,k     <br />addze q,q
      </p>
      
      <p class="indent">A single <code>shrsi</code> of <em>k</em> positions does a kind of signed division by 2<sup><em>k</em></sup> that coincides with both modulus and floor division. This suggests that one of these
         might be preferable to truncating division for computers and HLL’s to use. That is,
         modulus and floor division mesh with <code>shrsi</code> better than does truncating division, permitting a compiler to translate the expression
         <em>n</em> / 2 to an <code>shrsi</code>. Furthermore, <code>shrsi</code> followed by <code>neg</code> (negate) does modulus division by –2<sup><em>k</em></sup>, which is a hint that maybe modulus division is best. (This is mainly an aesthetic
         issue. It is of little practical significance, because division by a negative constant
         is no doubt extremely rare.)
      </p>
      
      <h3><a id="ch10lev2"></a><strong>10–2 Signed Remainder from Division by a Known Power of 2</strong></h3>
      
      <p class="noindent">If both the quotient and remainder of <strong><em>n</em></strong> ÷ <strong>2</strong><sup><strong><em>k</em></strong></sup> are wanted, it is simplest to compute the remainder <strong><em>r</em></strong> from <strong><em>r</em></strong> = <strong><em>n</em></strong> – <strong><em>q</em></strong> * <strong>2</strong><sup><strong><em>k</em></strong></sup> This requires only two instructions after computing the quotient <strong><em>q</em></strong>:
      </p>
      
      <p class="codelink"><a href="images9.html#p206pro02" id="p206pro02a">Click here to view code image</a></p>
      
      <p class="programlisting1">shli  r,q,k<br />sub   r,n,r<br /></p>
      
      <p class="indent">To compute only the remainder seems to require about four or five instructions. One
         way to compute it is to use the four-instruction sequence above for signed division
         by 2<sup><em>k</em></sup>, followed by the two instructions shown immediately above to obtain the remainder.
         This results in two consecutive <em>shift</em> instructions that can be replaced by an <em>and</em>, giving a solution in five instructions (four if <em>k</em> = 1):
      </p>
      
      <p class="codelink"><a href="images9.html#p206equ01" id="p206equ01a">Click here to view code image</a></p>
      
      <p class="programlisting2">shrsi t,n,k-1      Form the integer<br />shri t,t,32-k      2**k - 1 if n &lt; 0, else 0.<br />add t,n,t          Add it to n,<br />andi t,t,-2**k     clear rightmost k bits,     <br />sub r,n,t          and subtract it from n.
      </p>
      
      <p class="indent">Another method is based on</p>
      
      <div class="image"><img alt="Image" src="graphics/206equ02.jpg" /></div>
      
      <p class="noindent">To use this, first compute <img alt="Image" src="graphics/206equ03.jpg" />, and then
      </p>
      
      <p class="center"><strong><em>r</em></strong> ← ((abs(<strong><em>n</em></strong>) &amp; (<strong>2</strong><sup><strong><em>k</em></strong></sup>– <strong>1</strong>)) ⊕ <strong><em>t</em></strong>) – <strong><em>t</em></strong></p>
      
      <p class="noindent">(five instructions) or, for <em>k</em> = 1, since (– <strong><em>n</em></strong>) &amp; <strong>1</strong> = <strong><em>n</em></strong> &amp; <strong>1</strong>,
      </p>
      
      <p class="center"><a id="page_207"></a><strong><em>r</em></strong> ← ((<strong><em>n</em></strong> &amp; <strong>1</strong>) ⊕ <strong><em>t</em></strong>) – <strong><em>t</em></strong></p>
      
      <p class="noindent">(four instructions). This method is not very good for <em>k</em> &gt; 1 if the machine does not have <em>absolute value</em> (computing the remainder would then require six instructions).
      </p>
      
      <p class="indent">Still another method is based on</p>
      
      <div class="image"><img alt="Image" src="graphics/207equ02.jpg" /></div>
      
      <p class="noindent">This leads to</p>
      
      <div class="image"><img alt="Image" src="graphics/207equ03.jpg" /></div>
      
      <p class="noindent">(five instructions for <em>k</em> &gt; 1, four for <em>k</em> = 1).
      </p>
      
      <p class="indent">The above methods all work for 1 ≤ <em>k</em> ≤ 31.
      </p>
      
      <p class="indent">Incidentally, if <em>shift right signed</em> is not available, the value that is 2<em><sup>k</sup></em> – 1 for <em>n</em> &lt; 0 and 0 for <em>n</em> ≥ 0 can be constructed from
      </p>
      
      <div class="image"><img alt="Image" src="graphics/207equ04.jpg" /></div>
      
      <p class="noindent">which adds only one instruction.</p>
      
      <h3><a id="ch10lev3"></a><strong>10–3 Signed Division and Remainder by Non-Powers of 2</strong></h3>
      
      <p class="noindent">The basic trick is to multiply by a sort of reciprocal of the divisor <em>d</em>, approximately 2<sup>32</sup>/<em>d</em>, and then to extract the leftmost 32 bits of the product. The details, however, are
         more complicated, particularly for certain divisors such as 7.
      </p>
      
      <p class="indent">Let us first consider a few specific examples. These illustrate the code that will
         be generated by the general method. We denote registers as follows:
      </p>
      
      <p class="indenthangingNP1"><code>n</code> – the input integer (numerator)<br /><code>M</code> – loaded with a “magic number”<br /><code>t</code> - a temporary register<br /><code>q</code> - will contain the quotient<br /><code>r</code> - will contain the remainder
      </p>
      
      <h4><strong>Division by 3</strong></h4>
      
      <p class="codelink"><a href="images9.html#p207equ05" id="p207equ05a">Click here to view code image</a></p>
      
      <p class="programlisting2">li      M,0x55555556    Load magic number, (2**32+2)/3.<br />mulhs   q,M,n           q = floor(M*n/2**32).<br /><a id="page_208"></a><br />shri    t,n,31          Add 1 to q if<br />add     q,q,t           n is negative.<br /><br />muli    t,q,3           Compute remainder from<br />sub     r,n,t           r = n - q*3.
      </p>
      
      <p class="indent"><em>Proof</em>. The <em>multiply high signed</em> operation (<code>mulhs</code>) cannot overflow, as the product of two 32-bit integers can always be represented
         in 64 bits and <code>mulhs</code> gives the high-order 32 bits of the 64-bit product. This is equivalent to dividing
         the 64-bit product by 2<sup>32</sup> and taking the floor of the result, and this is true whether the product is positive
         or negative. Thus, for <em>n</em> ≥ 0 the above code computes
      </p>
      
      <div class="image"><img alt="Image" src="graphics/208equ01.jpg" /></div>
      
      <p class="noindent">Now, <em>n</em> &lt; 2<sup>31</sup>, because 2<sup>31</sup> – 1 is the largest representable positive number. Hence, the “error” term 2<em>n</em> / (3 · 2<sup>32</sup>) is less than 1/3 (and is nonnegative), so by Theorem D4 (page <a href="ch09.html#page_183">183</a>) we have <em>q</em> = <span class="entity">⌊</span><em>n</em> / 3<strong><span class="entity">⌋</span></strong>, which is the desired result (Equation (1) on page <a href="ch09.html#page_182">182</a>).
      </p>
      
      <p class="indent">For <em>n</em> &lt; 0, there is an addition of 1 to the quotient. Hence the code computes
      </p>
      
      <div class="image"><img alt="Image" src="graphics/208equ02.jpg" /></div>
      
      <p class="noindent">where we have used Theorem D2. Hence</p>
      
      <div class="image"><img alt="Image" src="graphics/208equ03.jpg" /></div>
      
      <p class="noindent">For –2<sup>31</sup> ≤ <em>n</em> ≤ –1,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/208equ04.jpg" /></div>
      
      <p class="noindent">The error term is nonpositive and greater than –1 / 3, so by Theorem D4 <em>q</em> = <strong><span class="entity">⌈</span></strong><em>n</em> / 3<strong><span class="entity">⌉</span></strong>, which is the desired result (Equation (1) on page <a href="ch09.html#page_182">182</a>).
      </p>
      
      <p class="indent">This establishes that the quotient is correct. That the remainder is correct follows
         easily from the fact that the remainder must satisfy
      </p>
      
      <p class="center"><em>n</em> = <em>qd</em> + <em>r</em>,
      </p>
      
      <p class="noindent">the multiplication by 3 cannot overflow (because –2<sup>31</sup> / 3 ≤ <em>q</em> ≤ (2<sup>31</sup> – 1) / 3), and the <em>subtract</em> cannot overflow because the result must be in the range –2 to +2.
      </p>
      
      <p class="indent">The <em>multiply immediate</em> can be done with two <em>add</em>’s, or a <em>shift</em> and an <em>add</em>, if either gives an improvement in execution time.
      </p>
      
      <p class="indent"><a id="page_209"></a>On many present-day RISC computers, the quotient can be computed as shown above in
         nine or ten cycles, whereas the <em>divide</em> instruction might take 20 cycles or so.
      </p>
      
      <h4><strong>Division by 5</strong></h4>
      
      <p class="noindent">For division by 5, we would like to use the same code as for division by 3, except
         with a multiplier of (2<sup>32</sup> + 4) / 5. Unfortunately, the error term is then too large; the result is off by 1
         for about 1/5 of the values of <em>n</em> ≥ 2<sup>30</sup> in magnitude. However, we can use a multiplier of (2<sup>33</sup> + 3) / 5 and add a <em>shift right signed</em> instruction. The code is
      </p>
      
      <p class="codelink"><a href="images9.html#p209equ01" id="p209equ01a">Click here to view code image</a></p>
      
      <p class="programlisting2">li    M,0x66666667  Load magic number, (2**33+3)/5.<br />mulhs q,M,n         q = floor(M*n/2**32).<br />shrsi q,q,1<br />shri  t,n,31        Add 1 to q if<br />add   q,q,t         n is negative.<br /><br />muli  t,q,5         Compute remainder from<br />sub   r,n,t         r = n - q*5.<br /></p>
      
      <p class="indent"><em>Proof</em>. The <code>mulhs</code> produces the leftmost 32 bits of the 64-bit product, and then the code shifts this
         right by one position, signed (or “arithmetically”). This is equivalent to dividing
         the product by 2<sup>33</sup> and then taking the floor of the result. Thus, for <em>n</em> ≥ 0 the code computes
      </p>
      
      <div class="image"><img alt="Image" src="graphics/209equ02.jpg" /></div>
      
      <p class="noindent">For 0 ≤ <em>n</em> &lt; 2<sup>31</sup>, the error term 3<em>n</em> / 5 · 2<sup>33</sup> is nonnegative and less than 1/5, so by Theorem D4, <em>q</em> = <span class="entity">⌊</span> <em>n</em> / 5<strong><span class="entity">⌋</span></strong>.
      </p>
      
      <p class="indent">For <em>n</em> &lt; 0, the above code computes
      </p>
      
      <div class="image"><img alt="Image" src="graphics/209equ03.jpg" /></div>
      
      <p class="indent">The error term is nonpositive and greater than –1/5, so <em>q</em> = <strong><span class="entity">⌈</span></strong><em>n</em> / 5<strong><span class="entity">⌉</span></strong>.<br />That the remainder is correct follows as in the case of division by 3.<br />The <em>multiply immediate</em> can be done with a <em>shift left</em> of two and an <em>add</em>.
      </p>
      
      <h4><strong>Division by 7</strong></h4>
      
      <p class="noindent">Dividing by 7 creates a new problem. Multipliers of (2<sup>32</sup> + 3) / 7 and (2<sup>33</sup> + 6) / 7 give error terms that are too large. A multiplier of (2<sup>34</sup> + 5) / 7 would work, but it’s too large to represent in a 32-bit signed word. We
         can multiply by this large number by multiplying by (2<sup>34</sup> + 5) / 7 – 2<sup>32</sup> (a negative number), and then correcting the product by inserting an <code>add</code>. The code is
      </p>
      
      <p class="codelink"><a id="page_210"></a><a href="images9.html#p210equ01" id="p210equ01a">Click here to view code image</a></p>
      
      <p class="programlisting2">li    M,0x92492493  Magic num, (2**34+5)/7 - 2**32.<br />mulhs q,M,n         q = floor(M*n/2**32).<br />add   q,q,n         q = floor(M*n/2**32) + n.<br />shrsi q,q,2         q = floor(q/4).<br />shri  t,n,31        Add 1 to q if<br />add   q,q,t         n is negative.<br /><br />muli  t,q,7         Compute remainder from<br />sub   r,n,t         r = n - q*7.<br /></p>
      
      <p class="indent"><em>Proof</em>. It is important to note that the instruction <code>“add q,q,n”</code> above cannot overflow. This is because <em>q</em> and <em>n</em> have opposite signs, due to the multiplication by a negative number. Therefore, this
         “computer arithmetic” addition is the same as real number addition. Hence for <em>n</em> ≥ 0 the above code computes
      </p>
      
      <div class="image"><img alt="Image" src="graphics/210equ02.jpg" /></div>
      
      <p class="noindent">where we have used the corollary of Theorem D3.</p>
      
      <p class="indent">For 0 ≤ <em>n</em> ≤ 2<sup>31</sup>, the error term 5<em>n/</em> 7 · 2<sup>34</sup> is nonnegative and less than 1/7, so <em>q</em> = <span class="entity">⌊</span> n / 7<strong><span class="entity">⌋</span></strong>.
      </p>
      
      <p class="indent">For <em>n</em> &lt; 0, the above code computes
      </p>
      
      <div class="image"><img alt="Image" src="graphics/210equ03.jpg" /></div>
      
      <p class="noindent">The error term is nonpositive and greater than –1/7, so <em>q</em> = <strong><span class="entity">⌈</span></strong><em>n</em> / 7<strong><span class="entity">⌉</span></strong></p>
      
      <p class="indent">The <em>multiply immediate</em> can be done with a <em>shift left</em> of three and a <em>subtract</em>.
      </p>
      
      <h3><a id="ch10lev4"></a><strong>10–4 Signed Division by Divisors</strong> ≥ <strong>2</strong></h3>
      
      <p class="noindent">At this point you may wonder if other divisors present other problems. We see in this
         section that they do not; the three examples given illustrate the only cases that
         arise (for <em>d</em> ≥ 2).
      </p>
      
      <p class="indent">Some of the proofs are a bit complicated, so to be cautious, the work is done in terms
         of a general word size <em>W</em>.
      </p>
      
      <p class="indent">Given a word size <em>W</em> ≥ 3 and a divisor <em>d</em>, 2 ≤ <em>d</em> ≤ 2<sup><em>W</em> – 1</sup> we wish to find the least integer <em>m</em> and integer <em>p</em> such that
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ01a.jpg" /></div>
      
      <div class="image"><a id="page_211"></a><img alt="Image" src="graphics/10equ01b.jpg" /></div>
      
      <p class="noindent">with 0 ≤ <em>m</em>&lt; 2<sup><em>W</em></sup> and <em>p</em> ≥ <em>W</em>.
      </p>
      
      <p class="indent">The reason we want the <em>least</em> integer <em>m</em> is that a smaller multiplier may give a smaller shift amount (possibly zero) or may
         yield code similar to the “divide by 5” example, rather than the “divide by 7” example.
         We must have <em>m</em> ≤ 2<sup><em>W</em></sup>– 1 so the code has no more instructions than that of the “divide by 7” example (that
         is, we can handle a multiplier in the range 2<sup><em>W</em> –1</sup> to 2<sup><em>W</em></sup>– 1 by means of the <code>add</code> that was inserted in the “divide by 7” example, but we would rather not deal with
         larger multipliers). We must have <em>p</em> ≥ <em>W</em>, because the generated code extracts the left half of the product <em>mn</em>, which is equivalent to shifting right <em>W</em> positions. Thus, the total right shift is <em>W</em> or more positions.
      </p>
      
      <p class="indent">There is a distinction between the multiplier <em>m</em> and the “magic number,” denoted <em>M</em>. The magic number is the value used in the <em>multiply</em> instruction. It is given by
      </p>
      
      <div class="image"><img alt="Image" src="graphics/211equ01.jpg" /></div>
      
      <p class="indent">Because (1b) must hold for <em>n</em> = –<em>d</em>,<span class="entity">⌊</span>– <em>md</em>/ 2<sup><em>p</em></sup><strong><span class="entity">⌋</span></strong> + 1 = –1, which implies
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ02.jpg" /></div>
      
      <p class="indent">Let <em>n<sub>c</sub></em> be the largest (positive) value of <em>n</em> such that rem(<em>n<sub>c</sub>, d</em>) = <em>d</em> – 1. <em>n<sub>c</sub></em> exists because one possibility is <em>n<sub>c</sub></em> = <em>d</em> – 1. It can be calculated from <em>n<sub>c</sub></em> = <span class="entity">⌊</span> 2<sup><em>W</em> – 1</sup> / <em>d</em> <span class="entity">⌋</span> <em>d</em> – 1 = 2<sup><em>W</em> – 1</sup> – rem(2<sup><em>W</em> –1</sup>, <em>d</em>) – 1. <em>n<sub>c</sub></em> is one of the highest <em>d</em> admissible values of <em>n</em>, so
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ03a.jpg" /></div>
      
      <p class="noindent">and, clearly</p>
      
      <div class="image"><img alt="Image" src="graphics/10equ03b.jpg" /></div>
      
      <p class="noindent">Because (1a) must hold for <em>n</em> = <em>n<sub>c</sub></em></p>
      
      <div class="image"><img alt="Image" src="graphics/211equ02.jpg" /></div>
      
      <p class="noindent">or</p>
      
      <div class="image"><img alt="Image" src="graphics/211equ03.jpg" /></div>
      
      <p class="noindent"><a id="page_212"></a>Combining this with (2) gives
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ04.jpg" /></div>
      
      <p class="indent">Because <em>m</em> is to be the least integer satisfying (4), it is the next integer greater than 2<sup><em>p</em></sup> / <em>d</em>; that is,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ05.jpg" /></div>
      
      <p class="noindent">Combining this with the right half of (4) and simplifying gives</p>
      
      <div class="image"><img alt="Image" src="graphics/10equ06.jpg" /></div>
      
      <h4><strong>The Algorithm</strong></h4>
      
      <p class="noindent">Thus, the algorithm to find the magic number <em>M</em> and the shift amount <em>s</em> from <em>d</em> is to first compute <em>n<sub>c</sub></em>, and then solve (6) for <em>p</em> by trying successively larger values. If <em>p</em> &lt; <em>W</em>, set <em>p</em> = <em>W</em> (the theorem below shows that this value of <em>p</em> also satisfies (6)). When the smallest <em>p</em> ≥ <em>W</em> satisfying (6) is found, <em>m</em> is calculated from (5). This is the smallest possible value of <em>m</em>, because we found the smallest acceptable <em>p</em>, and from (4) clearly smaller values of <em>p</em> yield smaller values of <em>m</em>. Finally, <em>s</em> = <em>p</em>– <em>W</em> and <em>M</em> is simply a reinterpretation of <em>m</em> as a signed integer (which is how the <code>mulhs</code> instruction interprets it).
      </p>
      
      <p class="indent">Forcing <em>p</em> to be at least <em>W</em> is justified by the following:
      </p>
      
      <p class="indent">T<small>HEOREM</small> DC1. <em>If</em>(6) <em>is true for some value of p, then it is true for all larger values of p</em>.
      </p>
      
      <p class="indent"><em>Proof</em>. Suppose (6) is true for <em>p</em> = <em>p</em><sub>0</sub>. Multiplying (6) by 2 gives
      </p>
      
      <p class="center">2<sup><em>p</em><sub>0</sub> +1</sup> &gt; <em>n<sub>c</sub></em>(2 <em>d</em> – 2rem(2<sup><em>p</em><sub>0</sub></sup>, <em>d</em>)).
      </p>
      
      <p class="noindent">From Theorem D5, rem(2<sup><em>p</em><sub>0</sub> +1</sup>, <em>d</em>) ≥ 2rem(2<sup><em>p</em><sub>0</sub></sup>, <em>d</em>) – <em>d</em>. Combining gives
      </p>
      
      <p class="indenthangingNP1">2<sup><em>p</em><sub>0</sub>0 +1</sup> &gt; <em>n<sub>c</sub></em>((2<em>d</em> – (rem(2<sup><em>p</em><sub>0</sub> + 1</sup>, <em>d</em>) + <em>d</em>)), or<br />2<sup><em>p</em> 0 +1</sup> &gt; <em>n<sub>c</sub></em>(<em>d</em> – rem(2<sup><em>p</em><sub>0</sub> +1</sup>, <em>d</em>)).
      </p>
      
      <p class="noindent">Therefore, (6) is true for <em>p</em> = <em>p</em><sub>0</sub> + 1, and hence for all larger values.
      </p>
      
      <p class="indent"><a id="page_213"></a>Thus, one could solve (6) by a binary search, although a simple linear search (starting
         with <em>p</em> = <em>W</em>) is probably preferable, because usually <em>d</em> is small, and small values of <em>d</em> give small values of <em>p</em>.
      </p>
      
      <h4><strong>Proof That the Algorithm Is Feasible</strong></h4>
      
      <p class="noindent">We must show that (6) always has a solution and that 0 ≤ <em>m</em> &lt; 2<sup><em>W</em></sup>. (It is not necessary to show that <em>p</em> ≥ <em>W</em>, because that is forced.)
      </p>
      
      <p class="indent">We show that (6) always has a solution by getting an upper bound on <em>p</em>. As a matter of general interest, we also derive a lower bound under the assumption
         that <em>p</em> is not forced to be at least <em>W</em>. To get these bounds on <em>p</em>, observe that for any positive integer <em>x</em>, there is a power of 2 greater than <em>x</em> and less than or equal to 2<em>x</em>. Hence, from (6),
      </p>
      
      <p class="center"><em>n<sub>c</sub></em>(<em>d</em> – rem(2<sup><em>p</em></sup>, <em>d</em>)) &lt; 2<sup><em>p</em></sup> ≤ 2<em>n</em><sub><em>c</em></sub>((<em>d</em> – rem(2<sup><em>p</em></sup>, <em>d</em>)).
      </p>
      
      <p class="noindent">Because 0 ≤ rem(2<sup><em>p</em></sup>, <em>d</em>) ≤ <em>d</em> – 1,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ07.jpg" /></div>
      
      <p class="indent">From (3a) and (3b), <em>n<sub>c</sub></em> ≥ max(2<sup><em>W</em> – 1</sup> – <em>d, d</em> – 1). The lines <em>f</em><sub>1</sub>(<em>d</em>) = 2<sup><em>W</em> –1</sup> – <em>d</em> and <em>f</em><sub>2</sub>(<em>d</em>) = <em>d</em> – 1 cross at <em>d</em> = (2<sup><em>W</em> –1</sup> + 1) / 2. Hence <em>n<sub>c</sub></em> ≥ (2<sup><em>W</em> –1</sup> – 1) / 2. Because <em>n<sub>c</sub></em> is an integer, <em>n<sub>c</sub></em> ≥ 2<sup><em>W</em> –2</sup>. Because <em>n<sub>c</sub>, d</em> ≤ 2<sup><em>W</em> – 1</sup> – 1, (7) becomes
      </p>
      
      <p class="center">2<sup><em>w</em> –2</sup> + 1 ≤ 2<sup><em>p</em></sup> ≤ 2(2<sup><em>w</em> – 1</sup> – 1)<sup>2</sup></p>
      
      <p class="noindent">or</p>
      
      <div class="image"><img alt="Image" src="graphics/10equ08.jpg" /></div>
      
      <p class="indent">The lower bound <em>p</em> = <em>W</em> – 1 can occur (e.g., for <em>W</em> = 32, <em>d</em> = 3), but in that case we set <em>p</em> = <em>W</em>.
      </p>
      
      <p class="indent">If <em>p</em> is not forced to equal <em>W</em>, then from (4) and (7),
      </p>
      
      <div class="image"><img alt="Image" src="graphics/213equ02.jpg" /></div>
      
      <p class="noindent">Using (3b) gives</p>
      
      <div class="image"><img alt="Image" src="graphics/213equ03.jpg" /></div>
      
      <p class="noindent">Because <em>n<sub>c</sub></em> ≤ 2<sup><em>W</em> –1</sup> – 1 (3a),
      </p>
      
      <p class="center">2 ≤ <em>m</em> ≤ 2<sup><em>w</em></sup> – 1.
      </p>
      
      <p class="indent"><a id="page_214"></a>If <em>p</em> is forced to equal <em>W</em>, then from (4),
      </p>
      
      <div class="image"><img alt="Image" src="graphics/214equ01.jpg" /></div>
      
      <p class="noindent">Because 2 ≤ <em>d</em> ≤ 2<sup><em>W</em> –1</sup> – 1 and <em>n<sub>c</sub></em> ≥ 2<sup><em>W</em> –2</sup>,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/214equ02.jpg" /></div>
      
      <p class="indent">Hence in either case <em>m</em> is within limits for the code schema illustrated by the “divide by 7” example.
      </p>
      
      <h4><strong>Proof That the Product Is Correct</strong></h4>
      
      <p class="noindent">We must show that if <em>p</em> and <em>m</em> are calculated from (6) and (5), then Equations (1a) and (1b) are satisfied.
      </p>
      
      <p class="indent">Equation (5) and inequality (6) are easily seen to imply (4). (In the case that <em>p</em> is forced to be equal to <em>W</em>, (6) still holds, as shown by Theorem DC1.) In what follows, we consider separately
         the following five ranges of values of <em>n</em>:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/214equ03.jpg" /></div>
      
      <p class="noindent">From (4), because <em>m</em> is an integer,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/214equ04.jpg" /></div>
      
      <p class="noindent">Multiplying by <em>n</em> / 2<sup><em>p</em></sup>, for <em>n</em> ≥ 0 this becomes
      </p>
      
      <div class="image"><img alt="Image" src="graphics/214equ05.jpg" /></div>
      
      <p class="noindent">For 0 ≤ <em>n</em> ≤ <em>n<sub>c</sub></em>, 0 ≤ (2<sup><em>p</em></sup> – 1) <em>n</em> / (2<sup><em>p</em></sup><em>dn<sub>c</sub></em>) &lt; 1 / <em>d</em>, so by Theorem D4,
      </p>
      
      <div class="image"><a id="page_215"></a><img alt="Image" src="graphics/215equ01.jpg" /></div>
      
      <p class="noindent">Hence (1a) is satisfied in this case (0 ≤ <em>n</em> ≤ <em>n<sub>c</sub></em>).
      </p>
      
      <p class="indent">For <em>n</em> &gt; <em>n<sub>c</sub>, n</em> is limited to the range
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ09.jpg" /></div>
      
      <p class="noindent">because <em>n</em> ≥ <em>n<sub>c</sub></em> + <em>d</em> contradicts the choice of <em>n<sub>c</sub></em> as the largest value of <em>n</em> such that rem(<em>n<sub>c</sub>, d</em>) = <em>d</em> – 1 (alternatively, from (3a), <em>n</em> ≥ <em>n<sub>c</sub></em> + <em>d</em> implies <em>n</em> ≥ 2<sup><em>W</em> – 1</sup>). From (4), for <em>n</em> ≥ 0,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/215equ02.jpg" /></div>
      
      <p class="noindent">By elementary algebra, this can be written</p>
      
      <div class="image"><img alt="Image" src="graphics/10equ10.jpg" /></div>
      
      <p class="noindent">From (9), 1 ≤ <em>n</em> – <em>n<sub>c</sub></em> ≤ <em>d</em> – 1, so
      </p>
      
      <div class="image"><img alt="Image" src="graphics/215equ03.jpg" /></div>
      
      <p class="noindent">Because <em>n<sub>c</sub></em> ≥ <em>d</em> – 1 (by (3b)) and (<em>n<sub>c</sub></em> + 1) / <em>n<sub>c</sub></em> has its maximum when <em>n<sub>c</sub></em> has its minimum,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/215equ04.jpg" /></div>
      
      <p class="noindent">In (10), the term (<em>n<sub>c</sub></em> + 1) / <em>d</em> is an integer. The term (<em>n</em> – <em>n<sub>c</sub></em>)(<em>n<sub>c</sub></em> + 1) / <em>dn<sub>c</sub></em> is less than or equal to 1. Therefore, (10) becomes
      </p>
      
      <div class="image"><img alt="Image" src="graphics/215equ05.jpg" /></div>
      
      <p class="noindent">For all <em>n</em> in the range (9),<span class="entity">⌊</span><em>n</em>/ <em>d</em> <strong><span class="entity">⌋</span></strong> = (<em>n<sub>c</sub></em> + 1) / <em>d</em>. Hence, (1a) is satisfied in this case (<em>n<sub>c</sub></em> + 1 ≤ <em>n</em> ≤ <em>n<sub>c</sub></em> + <em>d</em> – 1).
      </p>
      
      <p class="indent">For <em>n</em> &lt; 0, from (4) we have, because <em>m</em> is an integer,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/215equ06.jpg" /></div>
      
      <p class="noindent"><a id="page_216"></a>Multiplying by <em>n</em> / 2<sup><em>p</em></sup>, for <em>n</em> &lt; 0 this becomes
      </p>
      
      <div class="image"><img alt="Image" src="graphics/216equ01.jpg" /></div>
      
      <p class="noindent">or</p>
      
      <div class="image"><img alt="Image" src="graphics/216equ02.jpg" /></div>
      
      <p class="noindent">Using Theorem D2 gives</p>
      
      <div class="image"><img alt="Image" src="graphics/216equ03.jpg" /></div>
      
      <p class="noindent">Because <em>n</em> + 1 ≤ 0, the right inequality can be weakened, giving
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ11.jpg" /></div>
      
      <p class="noindent">For –<em>n<sub>c</sub></em> ≤ <em>n</em> ≤ –1,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/216equ04.jpg" /></div>
      
      <p class="noindent">Hence, by Theorem D4,</p>
      
      <div class="image"><img alt="Image" src="graphics/216equ05.jpg" /></div>
      
      <p class="noindent">so that (1b) is satisfied in this case (–<em>n<sub>c</sub></em> ≤ <em>n</em> ≤ –1).
      </p>
      
      <p class="indent">For <em>n</em> &lt; –<em>n<sub>c</sub>, n</em> is limited to the range
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ12.jpg" /></div>
      
      <p class="noindent">(From (3a), <em>n</em> &lt; – <em>n<sub>c</sub></em> – <em>d</em> implies that <em>n</em> &lt; –2<sup><em>W</em> – 1</sup>, which is impossible.) Performing elementary algebraic manipulation of the left comparand
         of (11) gives
      </p>
      
      <div class="image"><a id="page_217"></a><img alt="Image" src="graphics/10equ13.jpg" /></div>
      
      <p class="indent">For – <em>n<sub>c</sub></em> – <em>d</em> + 1 ≤ <em>n</em> ≤ – <em>n<sub>c</sub></em> – 1,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/217equ01.jpg" /></div>
      
      <p class="noindent">The ratio (<em>n<sub>c</sub></em> + 1) / <em>n<sub>c</sub></em> is a maximum when <em>n<sub>c</sub></em> is a minimum; that is, <em>n<sub>c</sub></em> = <em>d</em> – 1.
      </p>
      
      <p class="noindent">Therefore,</p>
      
      <div class="image"><img alt="Image" src="graphics/217equ02.jpg" /></div>
      
      <p class="noindent">From (13), because (– <em>n<sub>c</sub></em> – 1) / <em>d</em> is an integer and the quantity added to it is between 0 and –1,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/217equ03.jpg" /></div>
      
      <p class="noindent">For <em>n</em> in the range – <em>n<sub>c</sub></em> – <em>d</em> + 1 ≤ <em>n</em> ≤ – <em>n<sub>c</sub></em> – 1,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/217equ04.jpg" /></div>
      
      <p class="noindent">Hence, <span class="entity">⌊</span><em>mn</em>/ 2<sup><em>p</em></sup><strong><span class="entity">⌋</span></strong> + 1 = <strong><span class="entity">⌈</span></strong><em>n</em> / <em>d</em><strong><span class="entity">⌉</span></strong>—that is, (1b) is satisfied.
      </p>
      
      <p class="indent">The last case, <em>n</em> = – <em>n<sub>c</sub></em> – <em>d</em>, can occur only for certain values of <em>d</em>. From (3a), – <em>n<sub>c</sub></em> – <em>d</em> ≤ –2<sup><em>W</em> – 1</sup>, so if <em>n</em> takes on this value, we must have <em>n</em> = – <em>n<sub>c</sub></em> – <em>d</em> = –2<sup><em>W</em> –1</sup>, and hence <em>n<sub>c</sub></em> = 2<sup><em>W</em> –1</sup> – <em>d</em>. Therefore, rem(2<sup><em>W</em> – 1</sup>, <em>d</em>) = rem(<em>n<sub>c</sub></em> + <em>d, d</em>) = <em>d</em> – 1 (that is, <em>d</em> divides 2<sup><em>W</em> –1</sup> + 1).
      </p>
      
      <p class="indent">For this case (<em>n</em> = – <em>n<sub>c</sub></em> – <em>d</em>), (6) has the solution <em>p</em> = <em>W</em> – 1 (the smallest possible value of <em>p</em>), because for <em>p</em> = <em>W</em> – 1,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/217equ05.jpg" /></div>
      
      <p class="noindent">Then from (5),</p>
      
      <div class="image"><img alt="Image" src="graphics/217equ06.jpg" /></div>
      
      <p class="noindent"><a id="page_218"></a>Therefore,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/218equ01.jpg" /></div>
      
      <p class="noindent">so that (1b) is satisfied.</p>
      
      <p class="indent">This completes the proof that if <em>m</em> and <em>p</em> are calculated from (5) and (6), then Equations (1a) and (1b) hold for all admissible
         values of <em>n</em>.
      </p>
      
      <h3><a id="ch10lev5"></a><strong>10–5 Signed Division by Divisors ≤ –2</strong></h3>
      
      <p class="noindent">Because signed integer division satisfies <em>n</em> ÷ (–<em>d</em>) = –(<em>n</em> ÷ <em>d</em>), it is adequate to generate code for <em>n</em> ÷ |<em>d</em>| and follow it with an instruction to negate the quotient. (This does not give the
         correct result for <em>d</em> = –2<sup><em>W</em> –1</sup>, but for this and other negative powers of 2, you can use the code in <a href="ch10.html#ch10lev1">Section 10–1</a>, “<a href="ch10.html#ch10lev1">Signed Division by a Known Power of 2</a>,” on page <a href="ch10.html#page_205">205</a>, followed by a negating instruction.) It will not do to negate the dividend, because
         of the possibility that it is the maximum negative number.
      </p>
      
      <p class="indent">It is possible to avoid the negating instruction. The scheme is to compute</p>
      
      <div class="image"><img alt="Image" src="graphics/218equ02.jpg" /></div>
      
      <p class="noindent">Adding 1 if <em>n</em> &gt; 0 is awkward (because one cannot simply use the sign bit of <em>n</em>), so the code will instead add 1 if <em>q</em> &lt; 0. This is equivalent, because the multiplier <em>m</em> is negative (as will be seen).
      </p>
      
      <p class="indent">The code to be generated is illustrated below for the case <em>W</em> = 32, <em>d</em> = –7.
      </p>
      
      <p class="codelink"><a href="images9.html#p218equ03" id="p218equ03a">Click here to view code image</a></p>
      
      <p class="programlisting2">li    M,0x6DB6DB6D  Magic num, -(2**34+5)/7 + 2**32.<br />mulhs q,M,n         q = floor(M*n/2**32).<br />sub   q,q,n         q = floor(M*n/2**32) - n.<br />shrsi q,q,2         q = floor(q/4).<br />shri  t,q,31        Add 1 to q if<br />add   q,q,t         q is negative (n is positive).<br /><br />muli  t,q,-7        Compute remainder from<br />sub   r,n,t         r = n - q*(-7).
      </p>
      
      <p class="indent">This code is the same as that for division by +7, except that it uses the negative
         of the multiplier for +7, and a <code>sub</code> rather than an <code>add</code> after the multiply, and the <code>shri</code> of 31 must use <em>q</em> rather than <em>n</em>, as discussed above. (The case of <em>d</em> = +7 could also use <em>q</em> here, but there would be less parallelism in the code.) The <a id="page_219"></a><em>subtract</em> will not overflow, because the operands have the same sign. This scheme, however,
         does not always work! Although the code above for <em>W</em> = 32, <em>d</em> = –7 is correct, the analogous alteration of the “divide by 3” code to produce code
         to divide by –3 does not give the correct result for <em>W</em> = 32, <em>n</em> = –2<sup>31</sup>.
      </p>
      
      <p class="indent">Let us look at the situation more closely.</p>
      
      <p class="indent">Given a word size <em>W</em> ≥ 3 and a divisor <em>d</em>, –2<sup><em>W</em> –1</sup> ≤ <em>d</em> ≤ –2, we wish to find the least (in absolute value) integer <em>m</em> and integer <em>p</em> such that
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ14a.jpg" /></div>
      
      <div class="image"><img alt="Image" src="graphics/10equ14b.jpg" /></div>
      
      <p class="noindent">with –2<sup><em>W</em></sup> ≤ <em>m</em> ≤ 0 and <em>p</em> ≥ <em>W</em>.
      </p>
      
      <p class="indent">Proceeding similarly to the case of division by a positive divisor, let <em>n<sub>c</sub></em> be the most negative value of <em>n</em> such that <em>n<sub>c</sub></em> = <em>kd</em> + 1 for some integer <em>k. n<sub>c</sub></em> exists, because one possibility is <em>n<sub>c</sub></em> = <em>d</em> + 1. It can be calculated from <em>n<sub>c</sub></em> = <span class="entity">⌊</span> (– 2<sup><em>W</em> –1</sup> – 1) / <em>d</em> <strong><span class="entity">⌋</span></strong> <em>d</em> + 1 = – 2<sup><em>W</em> – 1</sup> + rem(2<sup><em>W</em> –1</sup> + 1, <em>d</em>). <em>n<sub>c</sub></em> is one of the least |<em>d</em>| admissible values of <em>n</em>, so
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ15a.jpg" /></div>
      
      <p class="noindent">and, clearly</p>
      
      <div class="image"><img alt="Image" src="graphics/10equ15b.jpg" /></div>
      
      <p class="noindent">Because (14b) must hold for <em>n</em> = – <em>d</em>, and (14a) must hold for <em>n</em> = <em>n<sub>c</sub></em>, we obtain, analogous to (4),
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ16.jpg" /></div>
      
      <p class="noindent">Because <em>m</em> is to be the greatest integer satisfying (16), it is the next integer less than 2<sup><em>p</em></sup> / <em>d</em>—that is,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ17.jpg" /></div>
      
      <p class="noindent">Combining this with the left half of (16) and simplifying gives</p>
      
      <div class="image"><img alt="Image" src="graphics/10equ18.jpg" /></div>
      
      <p class="indent"><a id="page_220"></a>The proof that the algorithm suggested by (17) and (18) is feasible, and that the
         product is correct, is similar to that for a positive divisor, and will not be repeated.
         A difficulty arises in trying to prove that – 2<sup><em>W</em></sup> ≤ <em>m</em> ≤ 0. To prove this, consider separately the cases in which <em>d</em> is the negative of a power of 2, or some other number. For <em>d</em> = –2<sup><em>k</em></sup>, it is easy to show that <em>n<sub>c</sub></em> = –2<sup><em>w</em> – 1</sup> + 1, <em>p</em> = <em>W</em> + <em>k</em> – 1, and <em>m</em> = – 2<sup><em>w</em> –1</sup> –1 (which is within range). For <em>d</em> not of the form <em>–2<sup>k</sup></em>, it is straightforward to alter the earlier proof.
      </p>
      
      <h4><strong>For Which Divisors Is <em>m (–d</em>) ≠ – <em>m</em> (<em>d</em>)?</strong></h4>
      
      <p class="noindent">By <em>m</em>(<em>d</em>) we mean the multiplier corresponding to a divisor <em>d</em>. If <em>m</em>(–<em>d</em>) = –<em>m</em>(<em>d</em>), code for division by a negative divisor can be generated by calculating the multiplier
         for |<em>d</em>|, negating it, and then generating code similar to that of the “divide by –7” case
         illustrated above.
      </p>
      
      <p class="indent">By comparing (18) with (6) and (17) with (5), it can be seen that if the value of
         <em>n<sub>c</sub></em> for –<em>d</em> is the negative of that for <em>d</em>, then <em>m</em>(–<em>d</em>) = –<em>m</em>(<em>d</em>). Hence, <em>m</em>(–<em>d</em>) ≠ <em>m</em>(<em>d</em>) can occur only when the value of <em>n<sub>c</sub></em> calculated for the negative divisor is the maximum negative number, –2<sup><em>W</em> – 1</sup>. Such divisors are the negatives of the factors of 2<sup><em>W</em> –1</sup> + 1. These numbers are fairly rare, as illustrated by the factorings below (obtained
         from Scratchpad).
      </p>
      
      <p class="indenthangingNP1">2<sup>15</sup> + 1 = 3 · 11 · 331
      </p>
      
      <p class="indenthangingNP1">2<sup>31</sup> + 1 = 3 · 715,827,883
      </p>
      
      <p class="indenthangingNP1">2<sup>63</sup> + 1 = 3<sup>3</sup> · 19 · 43 · 5419 · 77,158,673,929
      </p>
      
      <p class="noindent">For <em>all</em> these factors, <em>m</em>(–<em>d</em>) ≠ <em>m</em>(<em>d</em>). Proof sketch: For <em>d</em> &gt; 0 we have <em>n<sub>c</sub></em> = 2<sup><em>w</em> – 1</sup> – <em>d</em>. Because rem(2<sup><em>w</em> – 1</sup>, <em>d</em>) = <em>d</em> – <em>1</em>, (6) is satisfied by <em>p</em> = <em>W</em> – 1 and hence also by <em>p</em> = <em>W</em>. For <em>d</em> &lt; 0, however, we have <em>n<sub>c</sub></em> = –2<sup><em>W</em> – 1</sup> and rem(2<sup><em>w</em> – 1</sup>, <em>d</em>) = <strong>|<em>d</em>|</strong> –1. Hence, (18) is not satisfied for <em>p</em> = <em>W</em> – 1 or for <em>p</em> = <em>W</em>, so <em>p</em> &gt; <em>W</em>.
      </p>
      
      <h3><a id="ch10lev6"></a><strong>10–6 Incorporation into a Compiler</strong></h3>
      
      <p class="noindent">For a compiler to change division by a constant into a multiplication, it must compute
         the magic number <em>M</em> and the shift amount <em>s</em>, given a divisor <em>d</em>. The straightforward computation is to evaluate (6) or (18) for <em>p</em> = <em>W, W</em> +1, ... until it is satisfied. Then, <em>m</em> is calculated from (5) or (17). <em>M</em> is simply a reinterpretation of <em>m</em> as a signed integer, and <em>s</em> = <em>p</em> − <em>W</em>.
      </p>
      
      <p class="indent">The scheme described below handles positive and negative <em>d</em> with only a little extra code, and it avoids doubleword arithmetic.
      </p>
      
      <p class="indent"><a id="page_221"></a>Recall that <em>n<sub>c</sub></em> is given by
      </p>
      
      <div class="image"><img alt="Image" src="graphics/221equ01.jpg" /></div>
      
      <p class="noindent">Hence, |<em>n<sub>c</sub></em>| can be computed from
      </p>
      
      <div class="image"><img alt="Image" src="graphics/221equ02.jpg" /></div>
      
      <p class="noindent">The remainder must be evaluated using unsigned division, because of the magnitude
         of the arguments. We have written rem(<em>t</em>, |<em>d</em>|) rather than the equivalent rem(<em>t, d</em>), to emphasize that the program must deal with two positive (and unsigned) arguments.
      </p>
      
      <p class="indent">From (6) and (18), <em>p</em> can be calculated from
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ19.jpg" /></div>
      
      <p class="noindent">and then |<em>m</em>| can be calculated from (c.f. (5) and (17)):
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ20.jpg" /></div>
      
      <p class="indent">Direct evaluation of rem(2<sup><em>p</em></sup>, |<em>d</em>|) in (19) requires “long division” (dividing a 2<em>W</em>-bit dividend by a <em>W</em>-bit divisor, giving a <em>W</em>-bit quotient and remainder), and, in fact, it must be <em>unsigned</em> long division. There is a way to solve (19), and to do all the calculations, that
         avoids long division and can easily be implemented in a conventional HLL using only
         <em>W</em>-bit arithmetic. We do, however, need unsigned division and unsigned comparisons.
      </p>
      
      <p class="indent">We can calculate rem(2<sup><em>p</em></sup>, |<em>d</em>|) incrementally, by initializing two variables <em>q</em> and <em>r</em> to the quotient and remainder of 2<sup><em>p</em></sup> divided by |<em>d</em>| with <em>p</em> = <em>W</em> – 1, and then updating <em>q</em> and <em>r</em> as <em>p</em> increases.
      </p>
      
      <p class="indent">As the search progresses—that is, when <em>p</em> is incremented by 1—<em>q</em> and <em>r</em> are updated from (see <a href="ch09.html#page_184">Theorem D5</a>(a))
      </p>
      
      <p class="codelink"><a href="images9.html#p221equ03" id="p221equ03a">Click here to view code image</a></p>
      
      <p class="programlisting1">q = 2*q;<br />r = 2*r;<br />if (r&gt;= abs(d)) {<br />   q = q + 1;<br />   r = r - abs(d);}
      </p>
      
      <p class="indent"><a id="page_222"></a>The left half of inequality (4) and the right half of (16), together with the bounds
         proved for <em>m</em>, imply that <em>q</em> = <span class="entity">⌊</span> 2<sup><em>p</em></sup> /|<em>d</em>|<span class="entity">⌋</span> &lt; 2<sup><em>W</em></sup>, so <em>q</em> is representable as a <em>W</em>-bit unsigned integer. Also, 0 ≤ <em>r</em> &lt; |<em>d</em>|, so <em>r</em> is representable as a <em>W</em>-bit signed or unsigned integer. (<em>Caution:</em> The intermediate result 2<em>r</em> can exceed 2<sup><em>W</em> –1</sup> – 1, so <em>r</em> should be unsigned and the comparison above should also be unsigned.)
      </p>
      
      <p class="indent">Next, calculate δ = |<em>d</em>| – <em>r</em>. Both terms of the subtraction are representable as <em>W</em>-bit unsigned integers, and the result is also (1 ≤ δ ≤ |<em>d</em>|), so there is no difficulty here.
      </p>
      
      <p class="indent">To avoid the long multiplication of (19), rewrite it as</p>
      
      <div class="image"><img alt="Image" src="graphics/222equ01.jpg" /></div>
      
      <p class="indent">The quantity 2<sup><em>p</em></sup> / |<em>n<sub>c</sub></em>| is representable as a <em>W</em>-bit unsigned integer (similar to (7), from (19) it can be shown that 2<em><sup>p</sup></em> ≤ 2|<em>n<sub>c</sub></em>| · <strong>|<em>d</em>|</strong> and, for <em>d</em> = –2<sup><em>W</em> – 1</sup>, <em>n<sub>c</sub></em> = –2<sup><em>w</em> – 1</sup> + 1 and <em>p</em> = 2<em>W</em> – 2, so that 2<sup><em>p</em></sup> / |<em>n<sub>c</sub></em>| = 2<sup>2<em>W</em> – 2</sup> / (2<sup><em>w</em> – 1</sup> − 1) &lt; 2<em><sup>W</sup></em> for <em>W</em> ≥ 3). Also, it is easily calculated incrementally (as <em>p</em> increases) in the same manner as for rem(2<sup><em>p</em></sup>, |<em>d</em>|). The comparison should be unsigned, for the case 2<sup><em>p</em></sup> / |<em>n<sub>c</sub></em>| ≥ 2<sup><em>W</em> – 1</sup> (which can occur, for large <em>d</em>).
      </p>
      
      <p class="indent">To compute <em>m</em>, we need not evaluate (20) directly (which would require long division). Observe
         that
      </p>
      
      <div class="image"><img alt="Image" src="graphics/222equ02.jpg" /></div>
      
      <p class="indent">The loop closure test 2<sup><em>p</em></sup> / |<em>n<sub>c</sub></em>| &gt; δ is awkward to evaluate. The quantity 2<sup><em>p</em></sup>/ |<em>n<sub>c</sub></em>| is available only in the form of a quotient <em>q</em><sub>1</sub> and a remainder <em>r</em><sub>1</sub>. 2<sup><em>p</em></sup> / |<em>n<sub>c</sub></em>| may or may not be an integer (it is an integer only for <em>d</em> = 2<sup><em>W</em> – 2</sup> + 1 and a few negative values of <em>d</em>). The test 2<sup><em>p</em></sup> / |<em>n<sub>c</sub></em>| ≤ δ can be coded as
      </p>
      
      <p class="center"><strong><em>q</em></strong><sub>1</sub> &lt; <strong>δ</strong> | (<strong><em>q</em></strong><sub>1</sub> = <strong>δ</strong> &amp; <strong><em>r</em></strong><sub>1</sub> = <strong>0</strong>).
      </p>
      
      <p class="indent">The complete procedure for computing <code>M</code> and <code>s</code> from <code>d</code> is shown in <a href="ch10.html#ch10fig1">Figure 10–1</a>, coded in C, for <em>W</em> = 32. There are a few places where overflow can occur, but the correct result is
         obtained if overflow is ignored.
      </p>
      
      <p class="indent">To use the results of this program, the compiler should generate the <code>li</code> and <code>mulhs</code> instructions, generate the <code>add</code> if <code>d</code> &gt; 0 and <code>M</code> &lt; 0, or the <code>sub</code> if <code>d</code> &lt; 0 and <code>M</code> &gt; 0, and generate the <code>shrsi</code> if <code>s</code> &gt; 0. Then, the <code>shri</code> and final <code>add</code> must be generated.
      </p>
      
      <p class="indent">For <em>W</em> = 32, handling a negative divisor can be avoided by simply returning a precomputed
         result for <em>d</em> = 3 and <em>d</em> = 715,827,883, and using <em>m</em>(– <em>d</em>) = – <em>m</em>(<em>d</em>) for other negative divisors. However, that program would not be significantly shorter,
         if at all, than the one given in <a href="ch10.html#ch10fig1">Figure 10–1</a>.
      </p>
      
      <hr />
      
      <p class="codelink"><a id="page_223"></a><a href="images9.html#p10fig01" id="p10fig01a">Click here to view code image</a></p>
      
      <p class="programlisting"><a id="ch10fig1"></a>struct ms {int M;          // Magic number<br />          int s;};          // and shift amount.<br /><br />struct ms magic(int d) {    // Must have 2 &lt;= d &lt;= 2**31-1<br />                           // or   -2**31 &lt;= d &lt;= -2.<br />   int p;<br />   unsigned ad, anc, delta, q1, r1, q2, r2, t;<br />   const unsigned two31 = 0x80000000;      // 2**31.<br />   struct ms mag;<br /><br />   ad = abs(d);<br />   t = two31 + ((unsigned)d &gt;&gt; 31);<br />   anc = t - 1 - t%ad;      // Absolute value of nc.<br />   p = 31;                 // Init. p.<br />   q1 = two31/anc;          // Init. q1 = 2**p/|nc|.<br />   r1 = two31 - q1*anc;     // Init. r1 = rem(2**p, |nc|).<br />   q2 = two31/ad;           // Init. q2 = 2**p/|d|.<br />   r2 = two31 - q2*ad;      // Init. r2 = rem(2**p, |d|).<br />   do {<br />      p = p + 1;<br />      q1 = 2*q1;            // Update q1 = 2**p/|nc|.<br />      r1 = 2*r1;           // Update r1 = rem(2**p, |nc|).<br />      if (r1 &gt;= anc) {      // (Must be an unsigned<br />         q1 = q1 + 1;       // comparison here.)<br />         r1 = r1 - anc;}<br />      q2 = 2*q2;            // Update q2 = 2**p/|d|.<br />      r2 = 2*r2;            // Update r2 = rem(2**p, |d|).<br />      if (r2 &gt;= ad) {       // (Must be an unsigned<br />         q2 = q2 + 1;       // comparison here.)<br />         r2 = r2 - ad;}<br />      delta = ad - r2;<br />   } while (q1 &lt; delta || (q1 == delta &amp;&amp; r1 == 0));<br /><br />   mag.M = q2 + 1;<br />   if (d &lt; 0) mag.M = -mag.M; // Magic number and<br />   mag.s = p - 32;             // shift amount to return.<br />   return mag;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–1. Computing the magic number for signed division.
      </p>
      
      <h3><a id="ch10lev7"></a><strong>10–7 Miscellaneous Topics</strong></h3>
      
      <p class="indent">T<small>HEOREM</small> DC2. <em>The least multiplier m is odd if p is not forced to equal W</em>.
      </p>
      
      <p class="indent"><em>Proof</em>. Assume that Equations (1a) and (1b) are satisfied with least (not forced) integer
         <em>p</em>, and <em>m</em> even. Then clearly <em>m</em> could be divided by 2 and <em>p</em> could <a id="page_224"></a>be decreased by 1, and (1a) and (1b) would still be satisfied. This contradicts the
         assumption that <em>p</em> is minimal.
      </p>
      
      <h4><strong>Uniqueness</strong></h4>
      
      <p class="noindent">The magic number for a given divisor is sometimes unique (e.g., for <em>W</em> = 32, <em>d</em> = 7), but often it is not. In fact, experimentation suggests that it is usually not
         unique. For example, for <em>W</em> = 32, <em>d</em> = 6, there are four magic numbers:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/224equ01.jpg" /></div>
      
      <p class="noindent">Nevertheless, there is the following uniqueness property:</p>
      
      <p class="indent">T<small>HEOREM</small> DC3. <em>For a given divisor d, there is only one multiplier m having the minimal value of
            p, if p is not forced to equal W</em>.
      </p>
      
      <p class="indent"><em>Proof</em>. First consider the case <em>d</em> &gt; 0. The difference between the upper and lower limits of inequality (4) is 2<sup><em>p</em></sup>/ <em>dn<sub>c</sub></em>. We have already proved (7) that if <em>p</em> is minimal, then 2<sup><em>p</em></sup>/<em>dn<sub>c</sub></em> ≤ 2. Therefore, there can be at most two values of <em>m</em> satisfying (4). Let <em>m</em> be the smaller of these values, given by (5); then <em>m</em> + 1 is the other.
      </p>
      
      <p class="indent">Let <em>p</em><sub>0</sub> be the least value of <em>p</em> for which <em>m</em> + 1 satisfies the right half of (4) (<em>p</em><sub>0</sub> is not forced to equal <em>W</em>). Then
      </p>
      
      <div class="image"><img alt="Image" src="graphics/224equ02.jpg" /></div>
      
      <p class="noindent">This simplifies to</p>
      
      <p class="center">2<sup><em>p</em><sub>0</sub></sup> &gt; <em>n<sub>c</sub></em> (2 <em>d</em> – rem(2<sup><em>p</em><sub>0</sub></sup>, <em>d</em>)).
      </p>
      
      <p class="noindent">Dividing by 2 gives</p>
      
      <div class="image"><img alt="Image" src="graphics/224equ04.jpg" /></div>
      
      <p class="noindent">Because rem(2<sup><em>p</em>0</sup>, <em>d</em>) ≤ 2rem(2<sup><em>p</em>0 – 1</sup>, <em>d</em>) (by Theorem D5 on page <a href="ch09.html#page_184">184</a>),
      </p>
      
      <p class="center">2<sup><em>p</em><sub>0</sub> – 1</sup> &gt; <em>n<sub>c</sub></em> (<em>d</em> – rem(2<sup><em>p</em><sub>0</sub> –1</sup>, <em>d</em>)),
      </p>
      
      <p class="noindent">contradicting the assumption that <em>p</em><sub>0</sub> is minimal.
      </p>
      
      <p class="indent">The proof for <em>d</em> &lt; 0 is similar and will not be given.
      </p>
      
      <h4 id="ch10lev01"><a id="page_225"></a><strong>The Divisors with the Best Programs</strong></h4>
      
      <p class="noindent">The program for <em>d</em> = 3, <em>W</em> = 32 is particularly short, because there is no <code>add</code> or <code>shrsi</code> after the <code>mulhs</code>. What other divisors have this short program?
      </p>
      
      <p class="indent">We consider only positive divisors. We wish to find integers <em>m</em> and <em>p</em> that satisfy Equations (1a) and (1b), and for which <em>p</em> = <em>W</em> and 0 ≤ <em>m</em> &lt; 2<sup><em>W</em> –1</sup>. Because any integers <em>m</em> and <em>p</em> that satisfy equations (1a) and (1b) must also satisfy (4), it suffices to find those
         divisors <em>d</em> for which (4) has a solution with <em>p</em> = <em>W</em> and 0 ≤ <em>m</em> &lt; 2<sup><em>W</em> –1</sup>. All solutions of (4) with <em>p</em> = <em>W</em> are given by
      </p>
      
      <div class="image"><img alt="Image" src="graphics/225equ01.jpg" /></div>
      
      <p class="noindent">Combining this with the right half of (4) and simplifying gives</p>
      
      <div class="image"><img alt="Image" src="graphics/10equ21.jpg" /></div>
      
      <p class="noindent">The weakest restriction on rem(2<sup><em>W</em></sup>, <em>d</em>) is with <em>k</em> = 1 and <em>n<sub>c</sub></em> at its minimal value of 2<sup><em>W</em> –2</sup>. Hence, we must have
      </p>
      
      <p class="center">rem(2<sup><em>W</em></sup>, <em>d</em>) &gt; <em>d</em> – 4;
      </p>
      
      <p class="noindent">that is, <em>d</em> divides 2<sup><em>W</em></sup>+ 1, 2<sup><em>W</em></sup>+ 2, or 2<sup><em>W</em></sup>+ 3.
      </p>
      
      <p class="indent">Now let us see which of these factors actually have optimal programs.</p>
      
      <p class="indent">If <em>d</em> divides 2<sup><em>W</em></sup>+ 1, then rem(2<sup><em>W</em></sup>, <em>d</em>) = <em>d</em> – 1. Then a solution of (6) is <em>p</em> = <em>W</em>, because the inequality becomes
      </p>
      
      <p class="center">2<sup><em>W</em></sup> &gt; <em>n<sub>c</sub></em> (<em>d</em> – (<em>d</em> – 1)) = <em>n<sub>c</sub></em>,
      </p>
      
      <p class="noindent">which is obviously true, because <em>n<sub>c</sub></em> &lt; 2<sup><em>W</em> –1</sup>. Then in the calculation of <em>m</em> we have
      </p>
      
      <div class="image"><img alt="Image" src="graphics/225equ02.jpg" /></div>
      
      <p class="noindent">which is less than 2<sup><em>W –1</em></sup> for <em>d</em> ≥ 3 (<em>d</em> ≠ 2 because <em>d</em> divides 2<sup><em>W</em></sup> + 1). Hence, all the factors of 2<sup><em>W</em></sup>+ 1 have optimal programs.
      </p>
      
      <p class="indent">Similarly, if <em>d</em> divides 2<sup><em>W</em></sup> + 2, then rem(2<sup><em>W</em></sup>, <em>d</em>) = <em>d</em> – 2. Again, a solution of (6) is <em>p</em> = <em>W</em>, because the inequality becomes
      </p>
      
      <p class="center">2<sup><em>W</em></sup> &gt; <em>n<sub>c</sub></em> (<em>d</em> – (<em>d</em> – 2)) = 2<em>n<sub>c</sub></em>,
      </p>
      
      <p class="noindent">which is obviously true. Then in the calculation of <em>m</em> we have
      </p>
      
      <div class="image"><img alt="Image" src="graphics/225equ03.jpg" /></div>
      
      <p class="noindent"><a id="page_226"></a>which exceeds 2<sup><em>W</em> –1</sup> – 1 for <em>d</em> = 2, but which is less than or equal to 2<sup><em>W</em> – 1</sup> – 1 for <em>W</em> ≥ 3, <em>d</em> ≥ 3 (the case <em>W</em> = 3 and <em>d</em> = 3 does not occur, because 3 is not a factor of 2<sup>3</sup> + 2 = 10). Hence all factors of 2<sup><em>W</em></sup> + 2, except for 2 and the cofactor of 2, have optimal programs. (The cofactor of
         2 is (2<sup><em>W</em></sup>+ 2) / 2, which is not representable as a <em>W</em>-bit signed integer).
      </p>
      
      <p class="indent">If <em>d</em> divides 2<sup><em>W</em></sup> + 3, the following argument shows that <em>d</em> does not have an optimal program. Because rem(2<sup><em>W</em></sup>, <em>d</em>) = <em>d</em> – 3, inequality (21) implies that we must have
      </p>
      
      <div class="image"><img alt="Image" src="graphics/226equ01.jpg" /></div>
      
      <p class="noindent">for some <em>k</em> = 1, 2, 3, .... The weakest restriction is with <em>k</em> = 1, so we must have <em>n<sub>c</sub></em> &lt; 2<sup><em>W</em></sup> / 3.
      </p>
      
      <p class="indent">From (3a), <em>n<sub>c</sub></em> ≥ 2<sup><em>W</em> –1</sup> – <em>d</em>, or <em>d</em> ≥ 2<sup><em>W</em> – 1</sup> – <em>n<sub>c</sub></em>. Hence, it is necessary that
      </p>
      
      <div class="image"><img alt="Image" src="graphics/226equ02.jpg" /></div>
      
      <p class="noindent">Also, because 2, 3, and 4 do not divide 2<sup><em>W</em></sup> + 3, the smallest possible factor of 2<sup><em>W</em></sup> + 3 is 5. Therefore, the largest possible factor is (2<sup><em>W</em></sup> + 3) / 5. Thus, if <em>d</em> divides 2<sup><em>W</em></sup> + 3 and <em>d</em> has an optimal program, it is necessary that
      </p>
      
      <div class="image"><img alt="Image" src="graphics/226equ03.jpg" /></div>
      
      <p class="noindent">Taking reciprocals of this with respect to 2<sup><em>W</em></sup> + 3 shows that the cofactor of <em>d</em>, (2<sup><em>W</em></sup> + 3) / <em>d</em>, has the limits
      </p>
      
      <div class="image"><img alt="Image" src="graphics/226equ04.jpg" /></div>
      
      <p class="noindent">For <em>W</em> ≥ 5, this implies that the only possible cofactors are 5 and 6. For <em>W</em> &lt; 5, it is easily verified that there are no factors of 2<sup><em>W</em></sup> + 3. Because 6 cannot be a factor of 2<sup><em>W</em></sup> + 3, the only possibility is 5. Therefore, the only possible factor of 2<sup><em>W</em></sup> + 3 that might have an optimal program is (2<sup><em>W</em></sup> + 3) / 5.
      </p>
      
      <p class="indent">For <em>d</em> = (2<sup><em>W</em></sup> + 3) / 5,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/226equ05.jpg" /></div>
      
      <p class="noindent">For <em>W</em> ≥ 4,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/226equ06.jpg" /></div>
      
      <p class="noindent"><a id="page_227"></a>so
      </p>
      
      <div class="image"><img alt="Image" src="graphics/227equ01.jpg" /></div>
      
      <p class="noindent">This exceeds (2<sup><em>W</em></sup> / 3), so <em>d</em> = (2<sup><em>W</em></sup> + 3) / 5 does not have an optimal program. Because for <em>W</em> &lt; 4 there are no factors of 2<sup><em>W</em></sup> + 3, we conclude that no factors of 2<sup><em>W</em></sup> + 3 have optimal programs.
      </p>
      
      <p class="indent">In summary, all the factors of 2<sup><em>W</em></sup> + 1 and of 2<sup><em>W</em></sup> + 2, except for 2 and (2<sup><em>W</em></sup> + 2) / 2, have optimal programs, and no other numbers do. Furthermore, the above
         proof shows that algorithm <em>magic</em> (<a href="ch10.html#ch10fig1">Figure 10–1</a> on page <a href="ch10.html#page_223">223</a>) always produces the optimal program when it exists.
      </p>
      
      <p class="indent">Let us consider the specific cases <em>W</em> = 16, 32, and 64. The relevant factorizations are shown below.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/227equ02.jpg" /></div>
      
      <p class="indent">The result for <em>W</em> = 16 is that there are 20 divisors that have optimal programs. The ones less than
         100 are 3, 6, 9, 11, 18, 22, 33, 66, and 99.
      </p>
      
      <p class="indent">For <em>W</em> = 32, there are six such divisors: 3, 6, 641, 6,700,417, 715,827,883, and 1,431,655,766.
      </p>
      
      <p class="indent">For <em>W</em> = 64, there are 126 such divisors. The ones less than 100 are 3, 6, 9, 18, 19, 27,
         38, 43, 54, 57, and 86.
      </p>
      
      <h3><a id="ch10lev8"></a><strong>10–8 Unsigned Division</strong></h3>
      
      <p class="noindent">Unsigned division by a power of 2 is, of course, implemented by a single <em>shift right logical</em> instruction, and remainder by <em>and immediate</em>.
      </p>
      
      <p class="indent">It might seem that handling other divisors will be simple: Just use the results for
         signed division with <em>d</em> &gt; 0, omitting the two instructions that add 1 if the quotient is negative. We will
         see, however, that some of the details are actually more complicated in the case of
         unsigned division.
      </p>
      
      <h4><strong>Unsigned Division by 3</strong></h4>
      
      <p class="noindent">For a non-power of 2, let us first consider unsigned division by 3 on a 32-bit machine.
         Because the dividend <em>n</em> can now be as large as 2<sup>32</sup> – 1, the multiplier (2<sup>32</sup> + 2) / 3 is inadequate, because the error term 2 <em>n</em> / 3 · 2<sup>32</sup> (see “divide by 3” <a id="page_228"></a>example above) can exceed 1/3. However, the multiplier (2<sup>33</sup> + 1) / 3 is adequate. The code is
      </p>
      
      <p class="codelink"><a href="images9.html#p228equ01" id="p228equ01a">Click here to view code image</a></p>
      
      <p class="programlisting2">li    M,0xAAAAAAAB  Load magic number, (2**33+1)/3.<br />mulhu q,M,n         q = floor(M*n/2**32).<br />shri  q,q,1<br /><br />muli  t,q,3         Compute remainder from<br />sub   r,n,t         r = n - q*3.
      </p>
      
      <p class="noindent">An instruction that gives the high-order 32 bits of a 64-bit unsigned product is required,
         which we show above as <code>mulhu</code>.
      </p>
      
      <p class="indent">To see that the code is correct, observe that it computes</p>
      
      <div class="image"><img alt="Image" src="graphics/228equ02.jpg" /></div>
      
      <p class="noindent">For 0 ≤ <em>n</em> &lt; 2<sup>32</sup>, 0 ≤ <em>n</em> / (3 · 2<sup>33</sup>) &lt; 1 / 3, so by Theorem D4, <em>q</em> = <span class="entity">⌊</span> <em>n/</em> 3<strong><span class="entity">⌋</span></strong>.
      </p>
      
      <p class="indent">In computing the remainder, the <em>multiply immediate</em> can overflow if we regard the operands as signed integers, but it does not overflow
         if we regard them and the result as unsigned. Also, the <em>subtract</em> cannot overflow, because the result is in the range 0 to 2, so the remainder is correct.
      </p>
      
      <h4><strong>Unsigned Division by 7</strong></h4>
      
      <p class="noindent">For unsigned division by 7 on a 32-bit machine, the multipliers (2<sup>32</sup> + 3) / 7, (2<sup>33</sup> + 6) / 7, and (2<sup>34</sup> + 5) / 7 are all inadequate, because they give too large an error term. The multiplier
         (2<sup>35</sup> + 3) / 7 is acceptable, but it’s too large to represent in a 32-bit unsigned word.
         We can multiply by this large number by multiplying by (2<sup>35</sup> + 3) / 7 – 2<sup>32</sup> and then correcting the product by inserting an <code>add</code>. The code is
      </p>
      
      <p class="codelink"><a href="images9.html#p228equ03" id="p228equ03a">Click here to view code image</a></p>
      
      <p class="programlisting2">li    M,0x24924925  Magic num, (2**35+3)/7 - 2**32. <br />mulhu q,M,n         q = floor(M*n/2**32). <br />add   q,q,n         Can overflow (sets carry). <br />shrxi q,q,3         Shift right with carry bit.<br /><br />muli  t,q,7         Compute remainder from <br />sub   r,n,t         r = n - q*7. <br /></p>
      
      <p class="indent">Here we have a problem: The <code>add</code> can overflow. To allow for this, we have invented the new instruction <em>shift right extended immediate</em> (<code>shrxi</code>), which treats the carry from the <code>add</code> and the 32 bits of register <em>q</em> as a single 33-bit quantity, and shifts it right with 0-fill. On the Motorola 68000
         family, this can be done with two instructions: <em>rotate with extend</em> right one position, followed by a logical right shift of three (<code>roxr</code> actually uses the X bit, but the <code>add</code> sets the X bit the same as the carry bit). On most machines, it will take more. For
         example, on PowerPC it takes <a id="page_229"></a>three instructions: clear rightmost three bits of <em>q</em>, add carry to <em>q</em>, and rotate right three positions.
      </p>
      
      <p class="indent">With <code>shrxi</code> implemented somehow, the code above computes
      </p>
      
      <div class="image"><img alt="Image" src="graphics/229equ01.jpg" /></div>
      
      <p class="noindent">For 0 ≤ <em>n</em> &lt; 2<sup>32</sup>, 0 ≤ 3 <em>n</em> /(7 · 2<sup>35</sup>) &lt; 1/7, so by Theorem D4, <em>q</em> = <span class="entity">⌊</span> <em>n</em> / 7 <strong><span class="entity">⌋</span></strong>.
      </p>
      
      <p class="indent">Granlund and Montgomery [GM] have a clever scheme for avoiding the <code>shrxi</code> instruction. It requires the same number of instructions as the above three-instruction
         sequence for <code>shrxi,</code> but it employs only elementary instructions that almost any machine would have, and
         it does not cause overflow at all. It uses the identity
      </p>
      
      <div class="image"><img alt="Image" src="graphics/229equ02.jpg" /></div>
      
      <p class="indent">Applying this to our problem, with <em>q</em> = <span class="entity">⌊</span> <em>Mn</em> / 2<sup>32</sup> <span class="entity">⌋</span> where 0 ≤ <em>M</em> &lt;2<sup>32</sup>, the subtraction will not overflow, because
      </p>
      
      <div class="image"><img alt="Image" src="graphics/229equ03.jpg" /></div>
      
      <p class="noindent">so that, clearly, 0 ≤ <em>n – q</em> &lt; 2<sup>32</sup>. Also, the addition will not overflow, because
      </p>
      
      <div class="image"><img alt="Image" src="graphics/229equ04.jpg" /></div>
      
      <p class="noindent">and 0 ≤ <em>n</em>,<em>q</em> &lt; 2<sup>32</sup>.
      </p>
      
      <p class="indent">Using this idea gives the following code for unsigned division by 7:</p>
      
      <p class="codelink"><a href="images9.html#p229equ05" id="p229equ05a">Click here to view code image</a></p>
      
      <p class="programlisting2">li    M,0x24924925  Magic num, (2**35+3)/7 - 2**32.<br />mulhu q,M,n         q = floor(M*n/2**32).<br />sub   t,n,q         t = n - q.<br />shri  t,t,1         t = (n - q)/2.<br />add   t,t,q         t = (n - q)/2 + q = (n + q)/2.<br />shri  q,t,2         q = (n+Mn/2**32)/8 = floor(n/7).<br /><br />muli  t,q,7         Compute remainder from<br />sub   r,n,t         r = n - q*7.<br /></p>
      
      <p class="indent">For this to work, the shift amount for the hypothetical <code>shrxi</code> instruction must be greater than 0. It can be shown that if <em>d</em> &gt; 1 and the multiplier <em>m</em> ≥ 2<sup>32</sup> (so that the <code>shrxi</code> instruction is needed), then the shift amount is greater than 0.
      </p>
      
      <h3><a id="page_230"></a><a id="ch10lev9"></a><strong>10–9 Unsigned Division by Divisors</strong> ≥ <strong>1</strong></h3>
      
      <p class="noindent">Given a word size <em>W</em> ≥ 1 and a divisor <em>d</em>, 1 ≤ <em>d</em> &lt; 2<sup><em>W</em></sup>, we wish to find the least integer <em>m</em> and integer <em>p</em> such that
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ22.jpg" /></div>
      
      <p class="noindent">with 0 ≤ <em>m</em> &lt; 2<sup><em>W</em>+1</sup> and <em>p</em> ≥ <em>W</em>.
      </p>
      
      <p class="indent">In the unsigned case, the magic number <em>M</em> is given by
      </p>
      
      <div class="image"><img alt="Image" src="graphics/230equ01.jpg" /></div>
      
      <p class="indent">Because (22) must hold for <em>n</em> = <em>d</em>, <span class="entity">⌊</span><em>md</em>/ 2<sup><em>p</em></sup><strong><span class="entity">⌋</span></strong> = 1, or
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ23.jpg" /></div>
      
      <p class="indent">As in the signed case, let <em>n<sub>c</sub></em> be the largest value of <em>n</em> such that rem(<em>n<sub>c</sub>, d</em>) = <em>d</em> – 1. It can be calculated from <em>n<sub>c</sub></em> = <span class="entity">⌊</span> 2<sup><em>W</em></sup> / <em>d</em> <span class="entity">⌋</span> <em>d</em> – 1 = 2<sup><em>W</em></sup> – rem(2<sup><em>W</em></sup>, <em>d</em>) – 1. Then
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ24a.jpg" /></div>
      
      <p class="noindent">and</p>
      
      <div class="image"><img alt="Image" src="graphics/10equ24b.jpg" /></div>
      
      <p class="noindent">These imply that <em>n<sub>c</sub></em> ≥ 2<sup><em>W</em> – 1</sup>.
      </p>
      
      <p class="indent">Because (22) must hold for <em>n</em> = <em>n<sub>c</sub></em></p>
      
      <div class="image"><img alt="Image" src="graphics/230equ02.jpg" /></div>
      
      <p class="noindent">or</p>
      
      <div class="image"><img alt="Image" src="graphics/230equ03.jpg" /></div>
      
      <p class="noindent">Combining this with (23) gives</p>
      
      <div class="image"><img alt="Image" src="graphics/10equ25.jpg" /></div>
      
      <p class="indent">Because <em>m</em> is to be the least integer satisfying (25), it is the next integer greater than or
         equal to 2<sup><em>p</em></sup> / <em>d</em>—that is,
      </p>
      
      <div class="image"><a id="page_231"></a><img alt="Image" src="graphics/10equ26.jpg" /></div>
      
      <p class="noindent">Combining this with the right half of (25) and simplifying gives</p>
      
      <div class="image"><img alt="Image" src="graphics/10equ27.jpg" /></div>
      
      <h4><strong>The Algorithm (Unsigned)</strong></h4>
      
      <p class="noindent">Thus, the algorithm is to find by trial and error the least <em>p</em> ≥ <em>W</em> satisfying (27). Then, <em>m</em> is calculated from (26). This is the smallest possible value of <em>m</em> satisfying (22) with <em>p</em> ≥ <em>W</em>. As in the signed case, if (27) is true for some value of <em>p</em>, then it is true for all larger values of <em>p</em>. The proof is essentially the same as that of Theorem DC1, except Theorem D5(b) is
         used instead of Theorem D5(a).
      </p>
      
      <h4><strong>Proof That the Algorithm Is Feasible (Unsigned)</strong></h4>
      
      <p class="noindent">We must show that (27) always has a solution and that 0 ≤ <em>m</em> &lt; 2<sup><em>W</em> +1</sup>.
      </p>
      
      <p class="indent">Because for any nonnegative integer <em>x</em> there is a power of 2 greater than <em>x</em> and less than or equal to 2 <em>x</em> + 1, from (27),
      </p>
      
      <p class="center"><em>n<sub>c</sub></em>(<em>d</em> – 1 – rem(2<sup><em>p</em></sup> – 1, <em>d</em>)) &lt; 2<sup><em>p</em></sup> ≤ 2<em>n<sub>c</sub></em>(<em>d</em> – 1 – rem(2<sup><em>p</em></sup> – 1, <em>d</em>)) + 1.
      </p>
      
      <p class="noindent">Because 0 ≤ rem(2<sup><em>p</em></sup>– 1, <em>d</em>) ≤ <em>d</em> – 1,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ28.jpg" /></div>
      
      <p class="noindent">Because <em>n<sub>c</sub>, d</em> ≤ 2<sup><em>W</em></sup> – 1, this becomes
      </p>
      
      <p class="center">1 ≤ 2<sup><em>p</em></sup> ≤ 2(2<sup><em>W</em></sup> – 1)(2<sup><em>W</em></sup> – 2) + 1,
      </p>
      
      <p class="noindent">or</p>
      
      <div class="image"><img alt="Image" src="graphics/10equ29.jpg" /></div>
      
      <p class="noindent">Thus, (27) always has a solution.</p>
      
      <p class="indent">If <em>p</em> is not forced to equal <em>W</em>, then from (25) and (28),
      </p>
      
      <div class="image"><img alt="Image" src="graphics/231equ01.jpg" /></div>
      
      <p class="indent"><a id="page_232"></a>If <em>p</em> is forced to equal <em>W</em>, then from (25),
      </p>
      
      <div class="image"><img alt="Image" src="graphics/232equ01.jpg" /></div>
      
      <p class="noindent">Because 1 ≤ <em>d</em> ≤ 2<sup><em>W</em></sup>– 1 and <em>n<sub>c</sub></em> ≥ 2<sup><em>W</em> – 1</sup>,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/232equ02.jpg" /></div>
      
      <p class="noindent">In either case <em>m</em> is within limits for the code schema illustrated by the “unsigned divide by 7” example.
      </p>
      
      <h4><strong>Proof That the Product Is Correct (Unsigned)</strong></h4>
      
      <p class="noindent">We must show that if <em>p</em> and <em>m</em> are calculated from (27) and (26), then (22) is satisfied.
      </p>
      
      <p class="indent">Equation (26) and inequality (27) are easily seen to imply (25). Inequality (25) is
         nearly the same as (4), and the remainder of the proof is nearly identical to that
         for signed division with <em>n</em> ≥ 0.
      </p>
      
      <h3><a id="ch10lev10"></a><strong>10–10 Incorporation into a Compiler (Unsigned)</strong></h3>
      
      <p class="noindent">There is a difficulty in implementing an algorithm based on direct evaluation of the
         expressions used in this proof. Although <em>p</em> ≤ 2 <em>W</em>, which is proved above, the case <em>p</em> = 2 <em>W</em> can occur (e.g., for <em>d</em> = 2<sup><em>W</em></sup> – 2 with <em>W</em> ≥ 4). When <em>p</em> = 2 <em>W</em>, it is difficult to calculate <em>m</em>, because the dividend in (26) does not fit in a 2<em>W</em>-bit word.
      </p>
      
      <p class="indent">However, it can be implemented by the “incremental division and remainder” technique
         of algorithm <em>magic</em>. The algorithm is given in <a href="ch10.html#ch10fig2">Figure 10–2</a> for <em>W</em> = 32. It passes back an indicator <code>a</code>, which tells whether or not to generate an <code>add</code> instruction. (In the case of signed division, the caller recognizes this by <code>M</code> and <code>d</code> having opposite signs.)
      </p>
      
      <p class="indent">Some key points in understanding this algorithm are as follows:</p>
      
      <p class="indenthangingB">• Unsigned overflow can occur at several places and should be ignored.</p>
      
      <p class="indenthangingB">• <em>n<sub>c</sub></em> = 2<sup><em>w</em></sup> – rem (2<sup><em>w</em></sup>,<em>d</em>) – 1 = (2<sup><em>W</em></sup> – 1) – rem(2<sup><em>W</em></sup> – <em>d, d</em>).
      </p>
      
      <p class="indenthangingB">• The quotient and remainder of dividing 2<sup><em>p</em></sup> by <em>n<sub>c</sub></em> cannot be updated in the same way as is done in algorithm <em>magic</em>, because here the quantity <code>2*r1</code> can overflow. Hence, the algorithm has the test <code>“if (r</code>1 <code>&gt; = nc – r l)</code>,” whereas <code>“if (2*rl &gt;= nc</code>)” would be more natural. A similar remark applies to computing the quotient and remainder
         of 2<sup><em>P</em></sup> –1 divided by <em>d</em>.
      </p>
      
      <p class="indenthangingB">• 0 ≤ δ ≤ <em>d</em> – 1, so δ is representable as a 32-bit unsigned integer.
      </p>
      
      <p class="codelink"><a id="page_233"></a><a href="images9.html#p10fig02" id="p10fig02a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig2"></a>struct mu {unsigned M;     // Magic number,<br />          int a;           // "add" indicator,<br />          int s;};         // and shift amount.<br /><br />struct mu magicu(unsigned d) {<br />                            // Must have 1 &lt;= d &lt;= 2**32-1.<br />   int p;<br />   unsigned nc, delta, q1, r1, q2, r2;<br />   struct mu magu;<br /><br />   magu.a = 0;             // Initialize "add" indicator.<br />   nc = -1 - (-d)%d;       // Unsigned arithmetic here.<br />   p = 31;                 // Init. p.<br />   q1 = 0x80000000/nc;     // Init. q1 = 2**p/nc.<br />   r1 = 0x80000000 - q1*nc;// Init. r1 = rem(2**p, nc).<br />   q2 = 0x7FFFFFFF/d;      // Init. q2 = (2**p - 1)/d.<br />   r2 = 0x7FFFFFFF - q2*d; // Init. r2 = rem(2**p - 1, d).<br />   do {<br />      p = p + 1;<br />      if (r1 &gt;= nc - r1) {<br />         q1 = 2*q1 + 1;             // Update q1.<br />         r1 = 2*r1 - nc;}           // Update r1.<br />      else {<br />         q1 = 2*q1;<br />         r1 = 2*r1;}<br />      if (r2 + 1 &gt;= d - r2) {<br />         if (q2 &gt;= 0x7FFFFFFF) magu.a = 1;<br />         q2 = 2*q2 + 1;             // Update q2.<br />         r2 = 2*r2 + 1 - d;}        // Update r2.<br />      else {<br />         if (q2 &gt;= 0x80000000) magu.a = 1;<br />         q2 = 2*q2;<br />         r2 = 2*r2 + 1;}<br />      delta = d - 1 - r2;<br />   } while (p &lt; 64 &amp;&amp;<br />           (q1 &lt; delta || (q1 == delta &amp;&amp; r1 == 0)));<br /><br />   magu.M = q2 + 1;        // Magic number<br />   magu.s = p - 32;        // and shift amount to return<br />   return magu;            // (magu.a was set above).<br />}<br /></p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–2. Computing the magic number for unsigned division.
      </p>
      
      <p class="indenthangingB"><a id="page_234"></a>• <em>m</em> = (2<sup><em>p</em></sup> +<em>d</em> – 1 – rem(2<sup><em>p</em></sup> – 1, <em>d</em>)) / <em>d</em> = <span class="entity">⌊</span> (2<sup><em>p</em></sup> – 1) / <em>d</em> <span class="entity">⌋</span> +1 = <em>q</em><sub>2</sub> + 1.
      </p>
      
      <p class="indenthangingB">• The subtraction of 2<sup><em>W</em></sup> when the magic number <code>M</code> exceeds 2<sup><em>W</em></sup> – 1 is not explicit in the program; it occurs if the computation of <code>q2</code> overflows.
      </p>
      
      <p class="indenthangingB">• The “add” indicator, <code>magu.a</code>, cannot be set by a straightforward comparison of <code>M</code> to 2<sup>32</sup>, or of <code>q2</code> to 2<sup>32</sup> – 1, because of overflow. Instead, the program tests <code>q2</code> before overflow can occur. If <code>q2</code> ever gets as large as 2<sup>32</sup> – 1, so that <code>M</code> will be greater than or equal to 2<sup>32</sup>, then <code>magu.a</code> is set equal to 1. If <code>q2</code> stays below 2<sup>32</sup> – 1, then <code>magu.a</code> is left at its initial value of 0.
      </p>
      
      <p class="indenthangingB">• Inequality (27) is equivalent to 2<sup><em>p</em></sup>/ <em>n<sub>c</sub></em> &gt; δ.
      </p>
      
      <p class="indenthangingB">• The loop test needs the condition <code>p &lt; 64,</code> because without it, overflow of <code>q1</code> would cause the program to loop too many times, giving incorrect results.
      </p>
      
      <p class="indent">To use the results of this program, the compiler should generate the <code>li</code> and <code>mulhu</code> instructions and, if the “add” indicator <code>a</code> = 0, generate the <code>shri</code> of <code>s</code> (if <code>s</code> &gt; 0), as illustrated by the example of “Unsigned Division by 3,” on page <a href="ch10.html#page_227">227</a>. If <code>a</code> = 1 and the machine has the <code>shrxi</code> instruction, the compiler should generate the <code>add</code> and <code>shrxi</code> of <code>s</code> as illustrated by the example of “Unsigned Division by 7,” on page <a href="ch10.html#page_228">228</a>. If <code>a</code> = 1 and the machine does not have the <code>shrxi</code> instruction, use the example on page <a href="ch10.html#page_229">229</a>: generate the <code>sub</code>, the <code>shri</code> of 1, the <code>add</code>, and finally the <code>shri</code> of <code>s</code> – 1 (if <code>s</code> – 1 &gt; 0; <code>s</code> will not be 0 at this point except in the trivial case of division by 1, which we
         assume the compiler deletes).
      </p>
      
      <h3><a id="ch10lev11"></a><strong>10–11 Miscellaneous Topics (Unsigned)</strong></h3>
      
      <p class="indent">T<small>HEOREM</small> DC2<small>U</small>. <em>The least multiplier m is odd if p is not forced to equal W</em>.
      </p>
      
      <p class="indent">T<small>HEOREM</small> DC3<small>U</small>. <em>For a given divisor d, there is only one multiplier m having the minimal value of
            p, if p is not forced to equal W</em>.
      </p>
      
      <p class="indent">The proofs of these theorems follow very closely the corresponding proofs for signed
         division.
      </p>
      
      <h4><strong>The Divisors with the Best Programs (Unsigned)</strong></h4>
      
      <p class="noindent">For unsigned division, to find the divisors (if any) with optimal programs of two
         instructions to obtain the quotient (<code>li</code>, <code>mulhu</code>), we can do an analysis similar to that of the signed case (see “<a href="ch10.html#ch10lev01">The Divisors with the Best Programs</a>” on page <a href="ch10.html#ch10lev01">225</a>). The result is that such divisors are the factors of 2<sup><em>W</em></sup> or 2<sup><em>W</em></sup> + 1, except for <em>d</em> = 1. For the common word sizes, this leaves very few nontrivial divisors that have
         optimal programs for unsigned division. For <em>W</em> = 16, there are none. For <a id="page_235"></a><em>W</em> = 32, there are only two: 641 and 6,700,417. For <em>W</em> = 64, again there are only two: 274,177 and 67,280,421,310,721.
      </p>
      
      <p class="indent">The case <em>d</em> = 2<sup><em>k</em></sup>, <em>k</em> = 1, 2, ..., deserves special mention. In this case, algorithm <em>magicu</em> produces <em>p</em> = <em>W</em> (forced), <em>m</em> = 2<sup>32 – <em>k</em></sup>. This is the minimal value of <em>m</em>, but it is not the minimal value of <em>M</em>. Better code results if <em>p</em> = <em>W</em> + <em>k</em> is used, if sufficient simplifications are done. Then, <em>m</em> = 2<sup><em>W</em></sup>, <em>M</em> = 0, <em>a</em> = 1, and <em>s</em> = <em>k</em>. The generated code involves a multiplication by 0 and can be simplified to a single
         <em>shift right k</em> instruction. As a practical matter, divisors that are a power of 2 would probably
         be special-cased without using <em>magicu</em>. (This phenomenon does not occur for signed division, because for signed division
         <em>m</em> cannot be a power of 2. Proof: For <em>d</em> &gt; 0, inequality (4) combined with (3b) implies that <em>d</em> – 1 &lt; 2<sup><em>p</em></sup> / <em>m</em> &lt; <em>d</em>. Therefore, 2<sup><em>p</em></sup> / <em>m</em> cannot be an integer. For <em>d</em> &lt; 0, the result follows similarly from (16) combined with (15b).)
      </p>
      
      <p class="indent">For unsigned division, the code for the case <em>m</em> ≥ 2<sup><em>W</em></sup> is considerably worse than the code for the case <em>m</em> &lt; 2<sup><em>W</em></sup> if the machine does not have <code>shrxi</code>. It is of interest to have some idea of how often the large multipliers arise. For
         <em>W</em> = 32, among the integers less than or equal to 100, there are 31 “bad” divisors:
         1, 7, 14, 19, 21, 27, 28, 31, 35, 37, 38, 39, 42, 45, 53, 54, 55, 56, 57, 62, 63,
         70, 73, 74, 76, 78, 84, 90, 91, 95, and 97.
      </p>
      
      <h4><strong>Using Signed in Place of Unsigned Multiply, and the Reverse</strong></h4>
      
      <p class="noindent">If your machine does not have <code>mulhu</code>, but it does have <code>mulhs</code> (or signed long multiplication), the trick given in “High-Order Product Signed from/to
         Unsigned,” on page <a href="ch08.html#page_174">174</a>, might make our method of doing unsigned division by a constant still useful.
      </p>
      
      <p class="indent">That section gives a seven-instruction sequence for getting <code>mulhu</code> from <code>mulhs</code>. However, for this application it simplifies, because the magic number <em>M</em> is known. Thus, the compiler can test the most significant bit of the magic number,
         and generate code such as the following for the operation “<code>mulhu q,M,n</code>.” Here <code>t</code> denotes a temporary register.
      </p>
      
      <p class="codelink"><a href="images9.html#p235equ01" id="p235equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">           M<sub>31</sub> = 0           M<sub>31</sub> = 1<br />         mulhs q,M,n       mulhs q,M,n<br />         shrsi t,n,31      shrsi t,n,31<br />         and   t,t,M       and   t,t,M<br />         add   q,q,t       add   t,t,n<br />                           add   q,q,t<br /></p>
      
      <p class="indent">Accounting for the other instructions used with <code>mulhu</code>, this uses a total of six to eight instructions to obtain the quotient of unsigned
         division by a constant on a machine that does not have unsigned multiply.
      </p>
      
      <p class="indent">This trick can be inverted, to get <code>mulhs</code> in terms of <code>mulhu</code>. The code is the same as that above, except the <code>mulhs</code> is changed to <code>mulhu</code> and the final <code>add</code> in each column is changed to <code>sub</code>.
      </p>
      
      <h4><a id="page_236"></a><strong>A Simpler Algorithm (Unsigned)</strong></h4>
      
      <p class="noindent">Dropping the requirement that the magic number be minimal yields a simpler algorithm.
         In place of (27) we can use
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ30.jpg" /></div>
      
      <p class="noindent">and then use (26) to compute <em>m</em>, as before.
      </p>
      
      <p class="indent">It should be clear that this algorithm is formally correct (that is, that the value
         of <em>m</em> computed does satisfy Equation (22)), because its only difference from the previous
         algorithm is that it computes a value of <em>p</em> that, for some values of <em>d</em>, is unnecessarily large. It can be proved that the value of <em>m</em> computed from (30) and (26) is less than 2<sup><em>W</em> +1</sup>. We omit the proof and simply give the algorithm (<a href="ch10.html#ch10fig3">Figure 10–3</a>).
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig03" id="p10fig03a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig3"></a>struct mu {unsigned M;      // Magic number,<br />          int a;            // "add" indicator,<br />          int s;};          // and shift amount.<br /><br />struct mu magicu2(unsigned d) {<br />                            // Must have 1 &lt;= d &lt;= 2**32-1.<br />   int p;<br />   unsigned p32, q, r, delta;<br />   struct mu magu;<br />   magu.a = 0;              // Initialize "add" indicator.<br />   p = 31;                  // Initialize p.<br />   q = 0x7FFFFFFF/d;        // Initialize q = (2**p - 1)/d.<br />   r = 0x7FFFFFFF - q*d;    // Init. r = rem(2**p - 1, d).<br />   do {<br />      p = p + 1;<br />      if (p == 32) p32 = 1;     // Set p32 = 2**(p-32).<br />      else p32 = 2*p32;<br />      if (r + 1 &gt;= d - r) {<br />         if (q &gt;= 0x7FFFFFFF) magu.a = 1;<br />         q = 2*q + 1;           // Update q.<br />         r = 2*r + 1 - d;       // Update r.<br />      }<br />      else {<br />         if (q &gt;= 0x80000000) magu.a = 1;<br />         q = 2*q;<br />         r = 2*r + 1;<br />      }<br />      delta = d - 1 - r;<br />   } while (p &lt; 64 &amp;&amp; p32 &lt; delta);<br />   magu.M = q + 1;         // Magic number and<br />   magu.s = p - 32;        // shift amount to return<br />   return magu;            // (magu.a was set above).<br />}<br /></p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–3. Simplified algorithm for computing the magic number, unsigned division.
      </p>
      
      <p class="indent"><a id="page_237"></a>Alverson [Alv] gives a much simpler algorithm, discussed in the next section, but
         it gives somewhat large values for <em>m</em>. The point of algorithm <em>magicu2</em> is that it nearly always gives the minimal value for <em>m</em> when <em>d</em> ≤ 2<sup><em>W</em> –1</sup>. For <em>W</em> = 32, the smallest divisor for which <em>magicu2</em> does not give the minimal multiplier is <em>d</em> = 102,807, for which <em>magicu</em> calculates <em>m</em> = 2,737,896,999 and <em>magicu2</em> calculates <em>m</em> = 5,475,793,997.
      </p>
      
      <p class="indent">There is an analog of <em>magicu2</em> for signed division by positive divisors, but it does not work out very well for
         signed division by arbitrary divisors.
      </p>
      
      <h3><a id="ch10lev12"></a><strong>10–12 Applicability to Modulus and Floor Division</strong></h3>
      
      <p class="noindent">It might seem that turning modulus or floor division by a constant into multiplication
         would be simpler, in that the “add 1 if the dividend is negative” step could be omitted.
         This is not the case. The methods given above do not apply in any obvious way to modulus
         and floor division. Perhaps something could be worked out; it might involve altering
         the multiplier <em>m</em> slightly, depending upon the sign of the dividend.
      </p>
      
      <h3><a id="ch10lev13"></a><strong>10–13 Similar Methods</strong></h3>
      
      <p class="noindent">Rather than coding algorithm <em>magic</em>, we can provide a table that gives the magic numbers and shift amounts for a few
         small divisors. Divisors equal to the tabulated ones multiplied by a power of 2 are
         easily handled as follows:
      </p>
      
      <p class="indenthangingN">1. Count the number of trailing 0’s in <em>d</em>, and let this be denoted by <em>k</em>.
      </p>
      
      <p class="indenthangingN">2. Use as the lookup argument <em>d</em> / 2<sup><em>k</em></sup> (shift right <em>k</em>).
      </p>
      
      <p class="indenthangingN">3. Use the magic number found in the table.</p>
      
      <p class="indenthangingN">4. Use the shift amount found in the table, increased by <em>k</em>.
      </p>
      
      <p class="noindent">Thus, if the table contains the divisors 3, 5, 25, and so on, divisors of 6, 10, 100,
         and so forth can be handled.
      </p>
      
      <p class="indent">This procedure usually gives the smallest magic number, but not always. The smallest
         positive divisor for which it fails in this respect for <em>W</em> = 32 is <em>d</em> = 334,972, for which it computes <em>m</em> = 3,361,176,179 and s = 18. However, the minimal magic number for <em>d</em> = 334,972 is <em>m</em> = 840,294,045, with <em>s</em> = 16. The procedure also fails to give the minimal magic number for <em>d</em> = –6. In both these cases, output code quality is affected.
      </p>
      
      <p class="indent">Alverson [Alv] is the first known to the author to state that the method described
         here works with complete accuracy for all divisors. Using our notation, his method
         for unsigned integer division by <em>d</em> is to set the shift amount <em>p</em> = <em>W</em> + <span class="entity">⌈</span> log<sub>2</sub> <em>d</em> <span class="entity">⌉</span>, and the multiplier <em>m</em> = <span class="entity">⌈</span> 2<sup><em>p</em></sup> / <em>d</em> <span class="entity">⌉</span> and then do the division by <span class="entity">⌋</span> <em>n</em> ÷ <em>d</em> = <span class="entity">⌊</span> <em>mn</em> / 2<sup><em>p</em></sup> <span class="entity">⌋</span> (that is, <em>multiply</em> and <em>shift right</em>). He proves that the multiplier <em>m</em> is less than, 2<sup><em>W</em>+1</sup> and that the method gets the exact quotient for all <em>n</em> expressible in <em>W</em> bits.
      </p>
      
      <p class="indent"><a id="page_238"></a>Alverson’s method is a simpler variation of ours in that it doesn’t require trial
         and error to determine <em>p</em>, and is therefore more suitable for building in hardware, which is his primary interest.
         His multiplier <em>m</em> is always greater than or equal to 2<sup><em>W</em></sup>, and hence for the software application always gives the code illustrated by the
         “unsigned divide by 7” example (that is, always has the <code>add</code> and <code>shrxi</code>, or the alternative four instructions). Because most small divisors can be handled
         with a multiplier less than 2<sup><em>W</em></sup>, it seems worthwhile to look for these cases.
      </p>
      
      <p class="indent">For signed division, Alverson suggests finding the multiplier for |<em>d</em>| and a word length of <em>W</em> – 1 (then 2<sup><em>W</em> –1</sup> ≤ <em>m</em> &lt; 2<sup><em>W</em></sup>), multiplying the dividend by it, and negating the result if the operands have opposite
         signs. (The multiplier must be such that it gives the correct result when the dividend
         is 2<sup><em>W</em> –1</sup>, the absolute value of the maximum negative number.) It seems possible that this
         suggestion might give better code than what has been given here in the case that the
         multiplier <em>m</em> ≥ 2<sup><em>W</em></sup>. Applying it to signed division by 7 gives the following code, where we have used
         the relation –<em>x</em> = <img alt="Image" src="graphics/x-bar.jpg" /> +1 to avoid a branch:
      </p>
      
      <p class="codelink"><a href="images9.html#p238equ01" id="p238equ01a">Click here to view code image</a></p>
      
      <p class="programlisting2">abs   an,n<br />li    M,0x92492493  Magic number, (2**34+5)/7.<br />mulhu q,M,an        q = floor(M*an/2**32).<br />shri  q,q,2<br />shrsi t,n,31        These three instructions<br />xor   q,q,t         negate q if n is<br />sub   q,q,t         negative.<br /></p>
      
      <p class="indent">This is not quite as good as the code we gave for signed division by 7 (six versus
         seven instructions), but it would be useful on a machine that has <code>abs</code> and <code>mulhu</code>, but not <code>mulhs</code>.
      </p>
      
      <p class="indent">The next section gives some representative magic numbers.</p>
      
      <h3><a id="ch10lev14"></a><strong>10–14 Sample Magic Numbers</strong></h3>
      
      <p class="tab-caption"><a id="ch10tab1"></a>T<small>ABLE</small>10–1. S<small>OME</small> M<small>AGIC</small> N<small>UMBERS FOR</small> <em>W</em> = 32
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10tab01.jpg" /></div>
      
      <p class="tab-caption"><a id="page_239"></a><a id="ch10tab2"></a>T<small>ABLE</small> 10–2. S<small>OME</small> M<small>AGIC</small> N<small>UMBERS FOR</small> <em>W</em> = 64
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10tab02.jpg" /></div>
      
      <h3><a id="ch10lev15"></a><strong>10–15 Simple Code in Python</strong></h3>
      
      <p class="noindent">Computing a magic number is greatly simplified if one is not limited to doing the
         calculations in the same word size as that of the environment in which the magic number
         will be used. For the unsigned case, for example, in Python it is straightforward
         to compute <em>n<sub>c</sub></em> and then evaluate Equations (27) and (26), as described in <a href="ch10.html#ch10lev9">Section 10–9</a>. <a href="ch10.html#ch10fig4">Figure 10–4</a> shows such a function.
      </p>
      
      <p class="codelink"><a id="page_240"></a><a href="images9.html#p10fig04" id="p10fig04a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig4"></a>def magicgu(nmax, d):<br />   nc = (nmax//d)*d - 1<br />   nbits = int(log(nmax, 2)) + 1<br />   for p in range(0, 2*nbits + 1):<br />      if 2**p &gt; nc*(d - 1 - (2**p - 1)%d):<br />         m = (2**p + d - 1 - (2**p - 1)%d)//d<br />         return (m, p)<br />   print "Can't find p, something is wrong."<br />   sys.exit(1)
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–4. Python code for computing the magic number for unsigned division.
      </p>
      
      <p class="indent">The function is given the maximum value of the dividend <code>nmax</code> and the divisor <code>d</code>. It returns a pair of integers: the magic number <code>m</code> and a shift amount <code>p</code>. To divide a dividend <code>x</code> by <code>d</code>, one multiplies <code>x</code> by <code>m</code> and then shifts the (full length) product right <code>p</code> bits.
      </p>
      
      <p class="indent">This program is more general than the others in this chapter in two ways: (1) one
         specifies the maximum value of the dividend (<code>nmax</code>), rather than the number of bits required for the dividend, and (2) the program can
         be used for arbitrarily large dividends and divisors (“bignums”). The advantage of
         specifying the maximum value of the dividend is that one sometimes gets a smaller
         magic number than would be obtained if the next power of two less 1 were used for
         the maximum value. For example, suppose the maximum value of the dividend is 90, and
         the divisor is 7. Then function <code>magicgu</code> returns (37, 8), meaning that the magic number is 37 (a 6-bit number) and the shift
         amount is 8. But if we asked for a magic number that can handle divisors up to 127,
         then the result is (147, 10), and 147 is an 8-bit number.
      </p>
      
      <h3><a id="ch10lev16"></a><strong>10–16 Exact Division by Constants</strong></h3>
      
      <p class="noindent">By “exact division,” we mean division in which it is known beforehand, somehow, that
         the remainder is 0. Although this situation is not common, it does arise, for example,
         when subtracting two pointers in the C language. In C, the result of <em>p</em> – <em>q</em>, where <em>p</em> and <em>q</em> are pointers, is well defined and portable only if <em>p</em> and <em>q</em> point to objects in the same array [H&amp;S, sec. 7.6.2]. If the array element size is
         <em>s</em>, the object code for the difference <em>p</em> – <em>q</em> computes (<em>p</em> – <em>q</em>) / <em>s</em>.
      </p>
      
      <p class="indent">The material in this section was motivated by [GM, sec. 9].</p>
      
      <p class="indent"><a id="page_241"></a>The method to be given applies to both signed and unsigned exact division, and is
         based on the following theorem.
      </p>
      
      <p class="indent">T<small>HEOREM</small> MI. <em>If a and m are relatively prime integers, then there exists an integer</em> <span class="entity">ā</span>, 1 ≤ <span class="entity">ā</span> &lt; <em>m, such that</em></p>
      
      <p class="center"><em>a<span class="entity">ā</span></em> ≡ 1 (mod <em>m</em>).
      </p>
      
      <p class="indent">That is, <span class="entity">ā</span> is a multiplicative inverse of <em>a</em>, modulo <em>m</em>. There are several ways to prove this theorem; three proofs are given in [<small>NZM</small>, p. 52]. The proof below requires only a very basic familiarity with congruences.
      </p>
      
      <p class="indent"><em>Proof</em>. We will prove something a little more general than the theorem. If <em>a</em> and <em>m</em> are relatively prime (therefore nonzero), then as <em>x</em> ranges over all <em>m</em> distinct values modulo <em>m, ax</em> takes on all <em>m</em> distinct values modulo <em>m</em>. For example, if <em>a</em> = 3 and <em>m</em> = 8, then as <em>x</em> ranges from 0 to 7, <em>ax</em> = 0, 3, 6, 9, 12, 15, 18, 21 or, reduced modulo 8, <em>ax</em> = 0, 3, 6, 1, 4, 7, 2, 5. Observe that all values from 0 to 7 are present in the
         last sequence.
      </p>
      
      <p class="indent">To see this in general, assume that it is not true. Then there exist distinct integers
         that map to the same value when multiplied by <em>a</em>; that is, there exist <em>x</em> and <em>y</em>, with <em>x</em> <span class="middle"><img alt="Image" src="graphics/ent02.jpg" /></span> <em>y</em>(mod <em>m</em>), such that
      </p>
      
      <p class="center"><em>ax</em> ≡ <em>ay</em> (mod <em>m</em>).
      </p>
      
      <p class="noindent">Then there exists an integer <em>k</em> such that
      </p>
      
      <p class="center"><em>ax</em> – <em>ay</em> = <em>km</em>, or
      </p>
      
      <p class="center"><em>a</em> (<em>x</em> – <em>y</em>) = <em>km</em>.
      </p>
      
      <p class="noindent">Because <em>a</em> has no factor in common with <em>m</em>, it must be that <em>x</em> – <em>y</em> is a multiple of <em>m</em>; that is,
      </p>
      
      <p class="center"><em>x</em> ≡ <em>y</em> (mod <em>m</em>).
      </p>
      
      <p class="noindent">This contradicts the hypothesis.</p>
      
      <p class="indent">Now, because <em>ax</em> takes on all <em>m</em> distinct values modulo <em>m</em>, as <em>x</em> ranges over the <em>m</em> values, it must take on the value 1 for some <em>x</em>.
      </p>
      
      <p class="indent">The proof shows that there is only one value (modulo <em>m</em>) of <em>x</em> such that <em>ax</em> ≡ 1 (mod <em>m</em>)—that is, the multiplicative inverse is unique, apart from additive multiples of
         <em>m</em>. It also shows that there is a unique (modulo <em>m</em>) integer <em>x</em> such that <em>ax</em> ≡ <em>b</em> (mod <em>m</em>), where <em>b</em> is any integer.
      </p>
      
      <p class="indent">As an example, consider the case <em>m</em> = 16. Then <img alt="Image" src="graphics/241equ01.jpg" />, because 3 · 11 = 33 ≡ 1 (mod 16). We could just as well take <img alt="Image" src="graphics/241equ02.jpg" />, because 3 · (–5) = –15 ≡ 1 (mod 16). Similarly <img alt="Image" src="graphics/241euq03.jpg" />, because (–3) · 5 = –15 ≡ 1 (mod 16).
      </p>
      
      <p class="indent"><a id="page_242"></a>These observations are important because they show that the concepts apply to both
         signed and unsigned numbers. If we are working in the domain of unsigned integers
         on a 4-bit machine, we take <img alt="Image" src="graphics/241equ01.jpg" />. In the domain of signed integers, we take <img alt="Image" src="graphics/241equ02.jpg" />. But 11 and –5 have the same representation in two’s-complement (because they differ
         by 16), so the same computer word contents can serve in both domains as the multiplicative
         inverse.
      </p>
      
      <p class="indent">The theorem applies directly to the problem of division (signed and unsigned) by an
         odd integer <em>d</em> on a <em>W</em>-bit computer. Because any odd integer is relatively prime to 2<sup><em>W</em></sup>, the theorem says that if <em>d</em> is odd, there exists an integer <img alt="Image" src="graphics/242equ04.jpg" />(unique in the range 0 to 2<sup><em>W</em></sup>– 1 or in the range –2<sup><em>W</em> – 1</sup> to 2<sup><em>W</em> –1</sup> – 1) such that
      </p>
      
      <div class="image"><img alt="Image" src="graphics/242equ01.jpg" /></div>
      
      <p class="noindent">Hence, for any integer <em>n</em> that is a multiple of <em>d</em>,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/242equ02.jpg" /></div>
      
      <p class="noindent">In other words, <em>n/d</em> can be calculated by multiplying <em>n</em> by <img alt="Image" src="graphics/242equ04.jpg" /> and retaining only the rightmost <em>W</em> bits of the product.
      </p>
      
      <p class="indent">If the divisor <em>d</em> is even, let <em>d</em> = <em>d</em><sub>o</sub> · 2<em><sup>k</sup></em>, where <em>d</em><sub>o</sub> is odd and <em>k</em> ≥ 1. Then, simply shift <em>n</em> right <em>k</em> positions (shifting out 0’s), and then multiply by <img alt="Image" src="graphics/242equ05.jpg" /> (the shift could be done after the multiplication as well).
      </p>
      
      <p class="indent">Below is the code for division of <em>n</em> by 7, where <em>n</em> is a multiple of 7. This code gives the correct result whether it is considered to
         be signed or unsigned division.
      </p>
      
      <p class="codelink"><a href="images9.html#p242equ03" id="p242equ03a">Click here to view code image</a></p>
      
      <p class="programlisting1">li    M,0xB6DB6DB7  Mult. inverse, (5*2**32 + 1)/7.<br />mul   q,M,n         q = n/7.<br /></p>
      
      <h4><strong>Computing the Multiplicative Inverse by the Euclidean Algorithm</strong></h4>
      
      <p class="noindent">How can we compute the multiplicative inverse? The standard method is by means of
         the “extended Euclidean algorithm.” This is briefly discussed below as it applies
         to our problem, and the interested reader is referred to [NZM, p. 13] and to [Knu2,
         4.5.2] for a more complete discussion.
      </p>
      
      <p class="indent">Given an odd divisor <em>d</em>, we wish to solve for <em>x</em></p>
      
      <p class="center"><em>dx</em> ≡ 1(mod/<em>m</em>),
      </p>
      
      <p class="noindent">where, in our application, <em>m</em> = 2<sup><em>W</em></sup> and <em>W</em> is the word size of the machine. This will be accomplished if we can solve for integers
         <em>x</em> and <em>y</em> (positive, negative, or 0) the equation
      </p>
      
      <p class="center"><em>dx</em> + <em>my</em> = 1.
      </p>
      
      <p class="indent"><a id="page_243"></a>Toward this end, first make <em>d</em> positive by adding a sufficient number of multiples of <em>m</em> to it. (<em>d</em> and <em>d</em> + <em>km</em> have the same multiplicative inverse.) Second, write the following equations (in
         which <em>d, m</em> &gt; 0):
      </p>
      
      <div class="image"><img alt="Image" src="graphics/243equ01.jpg" /></div>
      
      <p class="noindent">If <em>d</em> = 1, we are done, because (ii) shows that <em>x</em> = 1. Otherwise, compute
      </p>
      
      <div class="image"><img alt="Image" src="graphics/243equ02.jpg" /></div>
      
      <p class="noindent">Third, multiply Equation (ii) by <em>q</em> and subtract it from (i). This gives
      </p>
      
      <p class="center"><em>d</em> (– 1 – <em>q</em>) + <em>m</em>(1) = <em>m</em> – <em>d</em> – <em>qd</em> = rem(<em>m</em> – <em>d, d</em>).
      </p>
      
      <p class="noindent">This equation holds because we have simply multiplied one equation by a constant and
         subtracted it from another. If rem(<em>m</em> – <em>d, d</em>) = 1, we are done; this last equation is the solution and <em>x</em> = – 1 – <em>q</em>.
      </p>
      
      <p class="indent">Repeat this process on the last two equations, obtaining a fourth, and continue until
         the right-hand side of the equation is 1. The multiplier of <em>d</em>, reduced modulo <em>m</em>, is then the desired inverse of <em>d</em>.
      </p>
      
      <p class="indent">Incidentally, if <em>m</em> – <em>d</em> &lt; <em>d</em>, so that the first quotient is 0, then the third row will be a copy of the first,
         so that the second quotient will be nonzero. Furthermore, most texts start with the
         first row being
      </p>
      
      <p class="center"><em>d</em>(0) + <em>m</em>(1) = <em>m</em>,
      </p>
      
      <p class="noindent">but in our application <em>m</em> = 2<sup><em>W</em></sup> is not representable in the machine.
      </p>
      
      <p class="indent">The process is best illustrated by an example: Let <em>m</em> = 256 and <em>d</em> = 7. Then the calculation proceeds as follows. To get the third row, note that <em>q</em> = <span class="entity">⌊</span>249 / 7 <span class="entity">⌋</span> = 35.
      </p>
      
      <p class="codelink"><a href="images9.html#p243equ03" id="p243equ03a">Click here to view code image</a></p>
      
      <p class="programlisting2"> 7(-1) + 256( 1) = 249<br /> 7( 1) + 256( 0) = 7<br />7(-36) + 256( 1) = 4<br />7( 37) + 256(-1) = 3<br />7(-73) + 256( 2) = 1<br /></p>
      
      <p class="noindent">Thus, the multiplicative inverse of 7, modulo 256, is –73 or, expressed in the range
         0 to 255, is 183. Check: 7 · 183 = 1281 ≡ 1 (mod 256).
      </p>
      
      <p class="indent">From the third row on, the integers in the right-hand column are all remainders of
         dividing the number above it into the number two rows above it, so they form a sequence
         of strictly decreasing nonnegative integers. Therefore, the sequence must end in 0
         (as the above would if carried one more step). Furthermore, the value just before
         the 0 must be 1, for the following reason. Suppose the sequence ends in <em>b</em> <a id="page_244"></a>followed by 0, with <em>b</em> ≠ 1. Then, the integer preceding the <em>b</em> must be a multiple of <em>b</em>, let’s say <em>k</em><sub>1</sub><em>b</em>, for the next remainder to be 0. The integer preceding <em>k</em><sub>1</sub> <em>b</em> must be of the form <em>k</em><sub>1</sub><em>k</em><sub>2</sub> <em>b</em>+ <em>b</em>, for the next remainder to be <em>b</em>. Continuing up the sequence, every number must be a multiple of <em>b</em>, including the first two (in the positions of the 249 and the 7 in the above example).
         This is impossible, because the first two integers are <em>m</em> – <em>d</em> and <em>d</em>, which are relatively prime.
      </p>
      
      <p class="indent">This constitutes an informal proof that the above process terminates, with a value
         of 1 in the right-hand column, and hence it finds the multiplicative inverse of <em>d</em>.
      </p>
      
      <p class="indent">To carry this out on a computer, first note that if <em>d</em> &lt; 0, we should add 2<sup><em>W</em></sup> to it. With two’s-complement arithmetic it is not necessary to actually do anything
         here; simply interpret <em>d</em> as an unsigned number, regardless of how the application interprets it.
      </p>
      
      <p class="indent">The computation of <em>q</em> must use unsigned division.
      </p>
      
      <p class="indent">Observe that the calculations can be done modulo <em>m</em>, because this does not change the right-hand column (these values are in the range
         0 to <em>m</em> – 1 anyway). This is important, because it enables the calculations to be done in
         “single precision,” using the computer’s modulo-2<sup><em>W</em></sup> unsigned arithmetic.
      </p>
      
      <p class="indent">Most of the quantities in the table need not be represented. The column of multiples
         of 256 need not be represented, because in solving <em>dx</em> + <em>my</em> = 1, we do not need the value of <em>y</em>. There is no need to represent <em>d</em> in the first column. Reduced to its bare essentials, then, the calculation of the
         above example is carried out as follows:
      </p>
      
      <p class="codelink"><a href="images9.html#p244equ01" id="p244equ01a">Click here to view code image</a></p>
      
      <p class="programlisting2">255  249<br />  1    7<br />220    4<br /> 37    3<br />183    1
      </p>
      
      <p class="indent">A C program for performing this computation is shown in <a href="ch10.html#ch10fig5">Figure 10–5</a>.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig05" id="p10fig05a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig5"></a>unsigned mulinv(unsigned d) {           // d must be odd.<br />   unsigned x1, v1, x2, v2, x3, v3, q;<br /><br />   x1 = 0xFFFFFFFF;      v1 = -d;<br />   x2 = 1;              v2 = d;<br />   while (v2 &gt; 1) {<br />      q = v1/v2;<br />      x3 = x1 - q*x2;   v3 = v1 - q*v2;<br />      x1 = x2;           v1 = v2;<br />      x2 = x3;           v2 = v3;<br />   }<br />   return x2;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–5. Multiplicative inverse modulo 2<sup>32</sup> by the Euclidean algorithm.
      </p>
      
      <p class="indent"><a id="page_245"></a>The reason the loop continuation condition is <code>(v2 &gt; 1),</code> rather than the more natural <code>(v2 != 1),</code> is that if the latter condition were used, the loop would never terminate if the
         program were invoked with an even argument. It is best that programs not loop forever
         even if misused. (If the argument <code>d</code> is even, <code>v2</code> never takes on the value 1, but it does become 0.)
      </p>
      
      <p class="indent">What does the program compute if given an even argument? As written, it computes a
         number <em>x</em> such that <em>dx</em> ≡ 0 (mod 2<sup>32</sup>), which is probably not useful. However, with the minor modification of changing
         the loop continuation condition to <code>(v2 != 0)</code> and returning <code>x1</code> rather than <code>x2,</code> it computes a number <em>x</em> such that <em>dx</em> ≡ <em>g</em> (mod 2<sup>32</sup>), where <em>g</em> is the greatest common divisor of <em>d</em> and 2<sup>32</sup>—that is, the greatest power of 2 that divides <em>d</em>. The modified program still computes the multiplicative inverse of <em>d</em> for <em>d</em> odd, but it requires one more iteration than the unmodified program.
      </p>
      
      <p class="indent">As for the number of iterations (divisions) required by the above program, for <em>d</em> odd and less than 20, it requires a maximum of 3 and an average of 1.7. For <em>d</em> in the neighborhood of 1000, it requires a maximum of 11 and an average of about
         6.
      </p>
      
      <h4><strong>Computing the Multiplicative Inverse by Newton’s Method</strong></h4>
      
      <p class="noindent">It is well known that, over the real numbers, 1 / <em>d</em>, for <em>d</em> ≠ 0, can be calculated to ever-increasing accuracy by iteratively evaluating
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ31.jpg" /></div>
      
      <p class="noindent">provided the initial estimate <em>x</em><sub>0</sub> is sufficiently close to 1/<em>d</em>. The number of digits of accuracy approximately doubles with each iteration.
      </p>
      
      <p class="indent">It is not so well known that this same formula can be used to find the multiplicative
         inverse modulo any power of 2!. For example, to find the multiplicative inverse of
         3, modulo 256, start with <em>x</em><sub>0</sub> = 1 (any odd number will do). Then,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/245equ01.jpg" /></div>
      
      <p class="noindent">The iteration has reached a fixed point modulo 256, so –85, or 171, is the multiplicative
         inverse of 3 (modulo 256). All calculations can be done modulo 256.
      </p>
      
      <p class="indent">Why does this work? Because if <em>x<sub>n</sub></em> satisfies
      </p>
      
      <p class="center"><em>dx<sub>n</sub></em> ≡ 1 (mod <em>m</em>)
      </p>
      
      <p class="noindent">and if <em>x</em><sub>n + 1</sub> is defined by (31), then
      </p>
      
      <p class="center"><em>dx</em><sub><em>n</em> +1</sub> ≡ 1 (mod <em>m</em><sup>2</sup>).
      </p>
      
      <p class="noindent"><a id="page_246"></a>To see this, let <em>dx</em><sub><em>n</em></sub> = 1 + <em>km</em>. Then
      </p>
      
      <div class="image"><img alt="Image" src="graphics/246equ01.jpg" /></div>
      
      <p class="indent">In our application, <em>m</em> is a power of 2, say 2<sup><em>N</em></sup>. In this case, if
      </p>
      
      <div class="image"><img alt="Image" src="graphics/246equ02.jpg" /></div>
      
      <p class="noindent">In a sense, if <em>x<sub>n</sub></em> is regarded as a sort of approximation to <img alt="Image" src="graphics/242equ04.jpg" />, then each iteration of (31) doubles the number of bits of “accuracy” of the approximation.
      </p>
      
      <p class="indent">It happens that modulo 8, the multiplicative inverse of any (odd) number <em>d</em> is <em>d</em> itself. Thus, taking <em>x</em><sub>0</sub> = <em>d</em> is a reasonable and simple initial guess at <img alt="Image" src="graphics/242equ04.jpg" />. Then, (31) will give values of <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ..., such that
      </p>
      
      <div class="image"><img alt="Image" src="graphics/246equ03.jpg" /></div>
      
      <p class="indent">Thus, four iterations suffice to find the multiplicative inverse modulo 2<sup>32</sup> (if <em>x</em> ≡ 1 (mod 2<sup>48</sup>), then <em>x</em> ≡ 1 (mod 2<sup><em>n</em></sup>) for <em>n</em> ≤ 48). This leads to the C program in <a href="ch10.html#ch10fig6">Figure 10–6</a>, in which all computations are done modulo 2<sup>32</sup>.
      </p>
      
      <p class="indent">For about half the values of <em>d</em>, this program takes 4.5 iterations, or nine multiplications. For the other half (those
         for which the initial value of <code>xn</code> is “correct to 4 bits”—that is, <em>d</em><sup>2</sup> ≡ 1 (mod 16)), it takes seven or fewer, usually seven, multiplications. Thus, it
         takes about eight multiplications on average.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig06" id="p10fig06a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig6"></a>unsigned mulinv(unsigned d) {       // d must be odd.<br />   unsigned xn, t;<br /><br />   xn = d;<br />loop: t = d*xn;<br />      if (t == 1) return xn;<br />      xn = xn*(2 - t);<br />      goto loop;<br />}<br /></p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–6. Multiplicative inverse modulo 2<sup>32</sup> by Newton’s method.
      </p>
      
      <p class="indent"><a id="page_247"></a>A variation is to simply execute the loop four times, regardless of <em>d</em>, perhaps “strung out” to eliminate the loop control (eight multiplications). Another
         variation is to somehow make the initial estimate <em>x</em><sub>0</sub> “correct to 4 bits” (that is, find <em>x</em><sub>0</sub> that satisfies <em>dx</em><sub>0</sub> ≡ 1 (mod 16)). Then, only three loop iterations are required. Some ways to set the
         initial estimate are
      </p>
      
      <div class="image"><img alt="Image" src="graphics/247equ01.jpg" /></div>
      
      <p class="noindent">Here, the multiplication by 2 is a left shift, and the computations are done modulo
         2<sup>32</sup> (ignoring overflow). Because the second formula uses a multiplication, it saves only
         one.
      </p>
      
      <p class="indent">This concern about execution time is, of course, totally unimportant for the compiler
         application. For that application, the routine would be so seldom used that it should
         be coded for minimum space. But there may be applications in which it is desirable
         to compute the multiplicative inverse quickly.
      </p>
      
      <p class="indent">The “Newton method” described here applies only when (1) the modulus is an integral
         power of some number <em>a</em>, and (2) the multiplicative inverse of <em>d</em> modulo <em>a</em> is known. It works particularly well for <em>a</em> = 2, because then the multiplicative inverse of any (odd) number <em>d</em> modulo 2 is known immediately—it is 1.
      </p>
      
      <h4><strong>Sample Multiplicative Inverses</strong></h4>
      
      <p class="noindent">We conclude this section with a listing of some multiplicative inverses in <a href="ch10.html#ch10tab3">Table 10–3</a>.
      </p>
      
      <p class="tab-caption"><a id="ch10tab3"></a>T<small>ABLE</small> 10–3. S<small>AMPLE</small> M<small>ULTIPLICATIVE</small> I<small>NVERSES</small></p>
      
      <div class="image"><img alt="Image" src="graphics/10tab03.jpg" /></div>
      
      <p class="indent"><a id="page_248"></a>You may notice that in several cases (<em>d</em> = 3, 5, 9, 11), the multiplicative inverse of <em>d</em> is the same as the magic number for unsigned division by <em>d</em> (see <a href="ch10.html#ch10lev14">Section 10–14</a>, “<a href="ch10.html#ch10lev14">Sample Magic Numbers</a>,” on page <a href="ch10.html#page_238">238</a>). This is more or less a coincidence. It happens that for these numbers, the magic
         number <em>M</em> is equal to the multiplier <em>m</em>, and these are of the form (2<sup><em>p</em></sup> + 1) / <em>d</em>, with <em>p</em> ≥ 32. In this case, notice that
      </p>
      
      <div class="image"><img alt="Image" src="graphics/248equ01.jpg" /></div>
      
      <p class="noindent">so that <em>M</em> ≡ <img alt="Image" src="graphics/242equ04.jpg" />(mod 2<sup>32</sup>).
      </p>
      
      <h3><a id="ch10lev17"></a><strong>10–17 Test for Zero Remainder after Division by a Constant</strong></h3>
      
      <p class="noindent">The multiplicative inverse of a divisor <em>d</em> can be used to test for a zero remainder after division by <em>d</em>[GM].
      </p>
      
      <h4><strong>Unsigned</strong></h4>
      
      <p class="noindent">First, consider unsigned division with the divisor <em>d</em> odd. Denote by <img alt="Image" src="graphics/242equ04.jpg" /> the multiplicative inverse of <em>d</em>. Then, because <img alt="Image" src="graphics/242equ01.jpg" />, where <em>W</em> is the machine’s word size in bits, <img alt="Image" src="graphics/242equ04.jpg" /> is also odd. Thus, <img alt="Image" src="graphics/242equ04.jpg" /> is relatively prime to 2<sup><em>W</em></sup>, and as shown in the proof of theorem MI in the preceding section, as <em>n</em> ranges over all 2<sup><em>W</em></sup> distinct values modulo 2<sup><em>W</em></sup>, <img alt="Image" src="graphics/248equ03.jpg" /> takes on all 2<sup><em>W</em></sup> distinct values modulo 2<sup><em>W</em></sup>.
      </p>
      
      <p class="indent">It was shown in the preceding section that if <em>n</em> is a multiple of <em>d</em>,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/248equ02.jpg" /></div>
      
      <p class="noindent">That is, for <em>n</em> = 0, <em>d</em>, 2<em>d</em>, ..., <span class="entity">⌊</span>(2<sup><em>W</em></sup> – 1) / <em>d</em> <span class="entity">⌋</span> <em>d</em>, <img alt="Image" src="graphics/248equ03.jpg" /> ≡ 0, 1, 2, ..., <span class="entity">⌊</span>(2<sup><em>W</em></sup> – 1) / <em>d</em> <span class="entity">⌋</span>(mod 2<sup><em>W</em></sup>). Therefore, for <em>n not</em> a multiple of <em>d</em>, the value of <img alt="Image" src="graphics/248equ03.jpg" />, reduced modulo 2<sup><em>W</em></sup> to the range 0 to 2<sup><em>W</em></sup> – 1, must exceed <span class="entity">⌊</span>(2<sup><em>W</em></sup> – 1) / <em>d</em> <span class="entity">⌋</span>.
      </p>
      
      <p class="indent">This can be used to test for a zero remainder. For example, to test if an integer
         <em>n</em> is a multiple of 25, multiply <em>n</em> by <img alt="Image" src="graphics/248equ04.jpg" /> and compare the rightmost <em>W</em> bits to <span class="entity">⌊</span>(2<sup><em>W</em></sup>– 1) / 25 <strong><span class="entity">⌋</span></strong>. On our basic RISC:
      </p>
      
      <p class="codelink"><a id="page_249"></a><a href="images9.html#p249pro01" id="p249pro01a">Click here to view code image</a></p>
      
      <p class="programlisting1">li      M,0xC28F5C29  Load mult. inverse of 25.<br />mul    q,M,n          q = right half of M*n.<br />li      c,0x0A3D70A3  c = floor((2**32-1)/25).<br />cmpleu t,q,c          Compare q and c, and branch<br />bt     t,is_mult      if n is a multiple of 25.<br /></p>
      
      <p class="indent">To extend this to even divisors, let <em>d</em> = <em>d<sub>o</sub></em> · 2<em><sup>k</sup></em>, where <em>d<sub>o</sub></em> is odd and <em>k</em> ≥ 1. Then, because an integer is divisible by <em>d</em> if and only if it is divisible by <em>d<sub>o</sub></em> and by 2<sup><em>k</em></sup>, and because <em>n</em> and <img alt="Image" src="graphics/249equ06.jpg" /> have the same number of trailing zeros (<img alt="Image" src="graphics/242equ05.jpg" /> is odd), the test that <em>n</em> is a multiple of <em>d</em> is
      </p>
      
      <div class="image"><img alt="Image" src="graphics/249equ01.jpg" /></div>
      
      <p class="noindent">where the mod function is understood to reduce <img alt="Image" src="graphics/248equ03.jpg" /> to the interval [0, 2<sup><em>W</em></sup> –1].
      </p>
      
      <p class="indent">Direct implementation of this requires two tests and conditional branches, but it
         can be reduced to one <em>compare-branch</em> quite efficiently if the machine has the <em>rotate-shift</em> instruction. This follows from the following theorem, in which <img alt="Image" src="graphics/249equ07.jpg" /> denotes the computer word <strong><em>a</em></strong> rotated right <em>k</em> positions (0 ≤ <em>k</em> ≤ 32).
      </p>
      
      <p class="indent">T<small>HEOREM</small> ZRU. <img alt="Image" src="graphics/249equ08.jpg" /> <em>and</em> <strong><em>x</em></strong> <em>ends in k 0-bits if and only if</em> <img alt="Image" src="graphics/249equ09.jpg" /></p>
      
      <p class="indent"><em>Proof</em>. (Assume a 32-bit machine.) Suppose <img alt="Image" src="graphics/249equ08.jpg" />and <strong><em>x</em></strong> ends in <em>k</em> 0-bits. Then, because <img alt="Image" src="graphics/249equ08.jpg" />, <img alt="Image" src="graphics/249equ10.jpg" /> But <img alt="Image" src="graphics/249equ11.jpg" /> Therefore, <img alt="Image" src="graphics/249equ09.jpg" /> If <strong><em>x</em></strong> does not end in <em>k</em> 0-bits, then <img alt="Image" src="graphics/249equ12.jpg" /> does not begin with <em>k</em> 0-bits, whereas <span class="entity">⌊</span><strong><em>a</em></strong> /<em>2<sup>k</sup><strong><span class="entity">⌋</span></strong></em> does, so <img alt="Image" src="graphics/249equ09.jpg" /> Lastly, if <img alt="Image" src="graphics/249equ13.jpg" /> and <strong><em>x</em></strong> ends in <em>k</em> 0-bits, then the integer formed from the first 32 – <em>k</em> bits of <strong><em>x</em></strong> must exceed that formed from the first 32 - <em>k</em> bits of <strong><em>a</em></strong>, so that <img alt="Image" src="graphics/249equ14.jpg" /></p>
      
      <p class="indent">Using this theorem, the test that <em>n</em> is a multiple of <em>d</em>, where <em>n</em> and <em>d &gt;</em> 1 are unsigned integers and d = d<sub>o</sub> · 2<em><sup>k</sup></em> with d<sub>o</sub> odd, is
      </p>
      
      <div class="image"><img alt="Image" src="graphics/249equ03.jpg" /></div>
      
      <p class="noindent">Here we used <span class="entity">⌊</span><span class="entity">⌊</span>(2<sup><em>W</em></sup>– 1) / d<sub>o</sub> <strong><span class="entity">⌋</span></strong> / 2<sup><em>k</em></sup> <strong><span class="entity">⌋</span></strong> = <span class="entity">⌊</span>(2<sup><em>W</em></sup>– 1) / (d<sub>o</sub> · 2<sup><em>k</em></sup>)<strong><span class="entity">⌋</span></strong> = <span class="entity">⌊</span> (2<sup><em>W</em></sup>– 1) / <em>d</em><span class="entity">⌋</span>.
      </p>
      
      <p class="indent">As an example, the following code tests an unsigned integer <em>n</em> to see if it is a multiple of 100:
      </p>
      
      <p class="codelink"><a href="images9.html#p249equ05" id="p249equ05a">Click here to view code image</a></p>
      
      <p class="programlisting2">li     M,0xC28F5C29  Load mult. inverse of 25.<br />mul    q,M,n         q = right half of M*n.<br />shrri  q,q,2         Rotate right two positions.<br /><a id="page_250"></a>li     c,0x028F5C28  c = floor((2**32-1)/100).<br />cmpleu t,q,c         Compare q and c, and branch<br />bt     t,is_mult     if n is a multiple of 100.<br /></p>
      
      <h4><strong>Signed, Divisor ≥ 2</strong></h4>
      
      <p class="noindent">For signed division, it was shown in the preceding section that if <em>n</em> is a multiple of <em>d</em> and <em>d</em> is odd, then
      </p>
      
      <div class="image"><img alt="Image" src="graphics/250equ01.jpg" /></div>
      
      <p class="noindent">Thus, for <em>n</em> = <span class="entity">⌈</span> –2<sup><em>W</em> – 1</sup> /<em>d</em> <span class="entity">⌉</span> · <em>d</em>, ...,–<em>d</em>,0, <em>d</em>, ...,<span class="entity">⌊</span>(2<sup><em>W</em> – 1</sup> – 1) / <em>d</em> <span class="entity">⌋</span> · <em>d</em>, we have <img alt="Image" src="graphics/248equ03.jpg" /> ≡ <span class="entity">⌈</span>– 2<sup><em>W</em> – 1</sup> / <em>d</em>,...,–1,0, 1, ...,<span class="entity">⌊</span> (2<sup><em>W</em> –1</sup> – 1) / <em>d</em> <span class="entity">⌋</span> (mod 2<sup><em>W</em></sup>). Furthermore, because <em>d is</em> relatively prime to 2<sup><em>W</em></sup>, as <em>n</em> ranges over all 2<sup><em>W</em></sup> distinct values modulo 2<sup><em>W</em></sup>, <img alt="Image" src="graphics/248equ03.jpg" /> takes on all 2<sup><em>W</em></sup> distinct values modulo 2<sup><em>W</em></sup>. Therefore, <em>n</em> is a multiple of <em>d</em> if and only if
      </p>
      
      <div class="image"><img alt="Image" src="graphics/250equ02.jpg" /></div>
      
      <p class="noindent">where the mod function is understood to reduce <img alt="Image" src="graphics/248equ03.jpg" /> to the interval [–2<sup><em>W</em> – 1</sup> 2<sup><em>W</em> – 1</sup> –1]
      </p>
      
      <p class="indent">This can be simplified a little by observing that because <em>d</em> is odd and, as we are assuming, positive and not equal to 1, it does not divide 2<sup><em>W</em></sup>–1. Therefore,
      </p>
      
      <p class="center"><span class="entity">⌈</span> – 2<sup><em>W</em> – 1</sup> / <em>d</em> <span class="entity">⌉</span> = <strong><span class="entity">⌈</span></strong> (–2<sup><em>W</em> – 1</sup> + 1) <em>d</em> <span class="entity">⌉</span> = - <span class="entity">⌊</span>(2<sup><em>W–1</em></sup> –1)/<em>d</em><span class="entity">⌋</span>.
      </p>
      
      <p class="noindent">Thus, for signed numbers, the test that <em>n</em> is a multiple of <em>d</em>, where <em>d</em> = <em>d<sub>o</sub></em> · 2<em><sup>k</sup></em> and <em>d<sub>o</sub></em> is odd, is
      </p>
      
      <p class="indent">Set <em>q</em> = mod(<img alt="Image" src="graphics/249equ06.jpg" />, 2<em><sup>W</sup>);</em></p>
      
      <p class="indent">-<span class="entity">⌊</span> (2<sup><em>W</em> –1</sup> – 1) / <em>d</em><sub>o</sub> <span class="entity">⌋</span> ≤ <em>q</em> ≤ <span class="entity">⌊</span> (2<sup><em>W</em> – 1</sup> – 1)/<em>d</em><sub>o</sub> <span class="entity">⌋</span> and <em>q</em> ends in <em>k</em> or more 0-bits.
      </p>
      
      <p class="noindent">On the surface, this would seem to require three tests and branches. However, as in
         the unsigned case, it can be reduced to one <em>compare-branch</em> by use of the following theorem:
      </p>
      
      <p class="indent">T<small>HEOREM</small> ZRS. <em>If</em> <strong><em>a ≥ 0</em></strong>, <em>the following assertions are equivalent:</em></p>
      
      <div class="image"><img alt="Image" src="graphics/250equ04.jpg" /></div>
      
      <p class="indent"><em>where</em> <strong><em>a′</em></strong> <em>is</em> <strong><em>a</em></strong> <em>with its rightmost k bits set to</em> 0 (that is, <strong><em>a</em></strong> ′ = <strong><em>a</em></strong> &amp; –<strong>2</strong><sup><em>k</em></sup>).
      </p>
      
      <p class="indent"><a id="page_251"></a><em>Proof</em>. (Assume a 32-bit machine). To see that (1) is equivalent to (2), clearly the assertion
         – <strong><em>a</em></strong> ≤ <strong><em>x</em></strong> ≤ <strong><em>a</em></strong> is equivalent to abs(<strong><em>x</em></strong>) ≤ <strong><em>a</em></strong>. Then, Theorem ZRU applies, because both sides of this inequality are nonnegative.
      </p>
      
      <p class="indent">To see that (1) is equivalent to (3), note that assertion (1) is equivalent to itself
         with <strong><em>a</em></strong> replaced with <strong><em>a′</em></strong>. Then, by the theorem on bounds checking on page <a href="ch04.html#page_68">68</a>, this in turn is equivalent to
      </p>
      
      <div class="image"><img alt="Image" src="graphics/251equ01.jpg" /></div>
      
      <p class="noindent">Because <strong><em>x</em></strong> + <strong><em>a′</em></strong> ends in <em>k</em> 0-bits if and only if <strong><em>x</em></strong> does, Theorem ZRU applies, giving the result.
      </p>
      
      <p class="indent">Using part (3) of this theorem, the test that <em>n</em> is a multiple of <em>d</em>, where <em>n</em> and <em>d</em> ≥ 2 are signed integers and <em>d</em> = <em>d<sub>o</sub></em> · 2<sup><em>k</em></sup> with d<sub>o</sub> odd, is
      </p>
      
      <div class="image"><img alt="Image" src="graphics/251equ02.jpg" /></div>
      
      <p class="noindent">(<strong><em>a</em></strong>′ can be computed at compile time, because <em>d</em> is a constant.)
      </p>
      
      <p class="indent">As an example, the following code tests a signed integer <em>n</em> to see if it is a multiple of 100. Notice that the constant <span class="entity">⌊</span>2<strong><em>a′</em></strong> / 2<sup><em>k</em></sup><span class="entity">⌋</span> can always be derived from the constant <strong><em>a′</em></strong> by a shift of <em>k</em> – 1 bits, saving an instruction or a load from memory to develop the comparand.
      </p>
      
      <p class="codelink"><a href="images9.html#p251equ03" id="p251equ03a">Click here to view code image</a></p>
      
      <p class="programlisting2">li     M,0xC28F5C29  Load mult. inverse of 25.<br />mul    q,M,n         q = right half of M*n.<br />li     c,0x051EB850  c = floor((2**31 – 1)/25) &amp; –4.<br />add    q,q,c         Add c.<br />shrri  q,q,2         Rotate right two positions.<br />shri   c,c,1         Compute const. for comparison.<br />cmpleu t,q,c         Compare q and c, and<br />bt     t,is_mult     branch if n is a mult. of 100.<br /></p>
      
      <h3><a id="ch10lev18"></a><strong>10–18 Methods Not Using Multiply High</strong></h3>
      
      <p class="noindent">In this section we consider some methods for dividing by constants that do not use
         the <em>multiply high</em> instruction, or a multiplication instruction that gives a double-word result. We
         show how to change division by a constant into a sequence of <em>shift</em> and <em>add</em> instructions, or <em>shift, add</em>, and <em>multiply</em> for more compact code.
      </p>
      
      <h4><strong>Unsigned Division</strong></h4>
      
      <p class="noindent">For these methods, unsigned division is simpler than signed division, so we deal with
         unsigned division first. One method is to use the techniques given that use the <a id="page_252"></a><em>multiply high</em> instruction, but use the code shown in <a href="ch08.html#ch08fig2">Figure 8–2</a> on page <a href="ch08.html#page_174">174</a> to do the <em>multiply high</em> operation. <a href="ch10.html#ch10fig7">Figure 10–7</a> shows how this works out for the case of (unsigned) division by 3. This is a combination
         of the code on page <a href="ch10.html#page_228">228</a> and <a href="ch08.html#ch08fig2">Figure 8–2</a> with “<code>int</code>” changed to “<code>unsigned</code>.” The code is 15 instructions, including four multiplications. The multiplications
         are by large constants and would take quite a few instructions if converted to <em>shift</em>’s and <em>add</em>’s. Very similar code can be devised for the signed case. This method is not particularly
         good and won’t be discussed further.
      </p>
      
      <p class="indent">Another method [GLS1] is to compute in advance the reciprocal of the divisor, and
         multiply the dividend by that with a series of <em>shift right</em> and <em>add</em> instructions. This gives an approximation to the quotient. It is merely an approximation,
         because the reciprocal of the divisor (which we assume is not an exact power of two)
         is not expressed exactly in 32 bits, and also because each <em>shift right</em> discards bits of the dividend. Next, the remainder with respect to the approximate
         quotient is computed, and that is divided by the divisor to form a correction, which
         is added to the approximate quotient, giving the exact quotient. The remainder is
         generally small compared to the divisor (a few multiples thereof), so there is often
         a simple way to compute the correction without using a <em>divide</em> instruction.
      </p>
      
      <p class="indent">To illustrate this method, consider dividing by 3, that is, computing <span class="entity">⌊</span><em>n</em> / 3 <span class="entity">⌋</span> where 0 ≤ <em>n</em> &lt; 2<sup>32</sup>. The reciprocal of 3, in binary, is approximately
      </p>
      
      <p class="center">0.0101 0101 0101 0101 0101 0101 0101 0101.</p>
      
      <p class="noindent">To compute the approximate product of that and <em>n</em>, we could use
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ32.jpg" /></div>
      
      <p class="codelink"><a href="images9.html#p10fig07" id="p10fig07a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig7"></a>unsigned divu3(unsigned n) {<br />   unsigned n0, n1, w0, w1, w2, t, q;<br /><br />   n0 = n &amp; 0xFFFF;<br />   n1 = n &gt;&gt; 16;<br />   w0 = n0*0xAAAB;<br />   t = n1*0xAAAB + (w0 &gt;&gt; 16);<br />   w1 = t &amp; 0xFFFF;<br />   w2 = t &gt;&gt; 16;<br />   w1 = n0*0xAAAA + w1;<br />   q = n1*0xAAAA + w2 + (w1 &gt;&gt; 16);<br />   return q &gt;&gt; 1;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–7. Unsigned divide by 3 using simulated <em>multiply high unsigned</em>.
      </p>
      
      <p class="noindent">(29 instructions; the last 1 in the reciprocal is ignored because it would add the
         term <span class="middle"><img alt="Image" src="graphics/252equ01.jpg" /></span> which is obviously 0). However, the simple repeating pattern of 1’s <a id="page_253"></a>and 0’s in the reciprocal permits a method that is both faster (nine instructions)
         and more accurate:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/253equ02.jpg" /></div>
      
      <p class="indent">To compare these methods for their accuracy, consider the bits that are shifted out
         by each term of (32), if <strong><em>n</em></strong> is all 1-bits. The first term shifts out two 1-bits, the next four 1-bits, and so
         on. Each of these contributes an error of almost 1 in the least significant bit. Since
         there are 16 terms (counting the term we ignored), the shifts contribute an error
         of almost 16. There is an additional error due to the fact that the reciprocal is
         truncated to 32 bits; it turns out that the maximum total error is 16.
      </p>
      
      <p class="indent">For procedure (1), each right shift also contributes an error of almost 1 in the least
         significant bit. But there are only five shift operations. They contribute an error
         of almost 5, and there is a further error due to the fact that the reciprocal is truncated
         to 32 bits; it turns out that the maximum total error is 5.
      </p>
      
      <p class="indent">After computing the estimated quotient <strong><em>q</em></strong>, the remainder <strong><em>r</em></strong> is computed from
      </p>
      
      <p class="center"><strong><em>r</em></strong> ← <strong><em>n</em></strong> – <strong><em>q</em></strong> * 3.
      </p>
      
      <p class="noindent">The remainder cannot be negative, because <strong><em>q</em></strong> is never larger than the exact quotient. We need to know how large <strong><em>r</em></strong> can be to devise the simplest possible method for computing <span class="middle"><img alt="Image" src="graphics/253equ03.jpg" /></span> In general, for a divisor <em>d</em> and an estimated quotient <em>q</em> too low by <em>k</em>, the remainder will range from <em>k</em>*<em>d</em> to <em>k</em>*<em>d</em> + <em>d</em> – 1. (The upper limit is conservative; it may not actually be attained.) Thus, using
         (1), for which <strong><em>q</em></strong> is too low by at most 5, we expect the remainder to be at most 5*3 + 2 = 17. Experimentation
         reveals that it is actually at most 15. Thus, for the correction we must compute (exactly)
      </p>
      
      <div class="image"><img alt="Image" src="graphics/253equ01.jpg" /></div>
      
      <p class="indent">Since <strong><em>r</em></strong> is small compared to the largest value that a register can hold, this can be approximated
         by multiplying <strong><em>r</em></strong> by some approximation to 1/3 of the form <em>a</em>/<em>b</em> where <em>b</em> is a power of 2. This is easy to compute, because the division is simply a shift.
         The value of <em>a</em>/ <em>b</em> must be slightly larger than 1/3, so that after shifting the result will agree with
         truncated division. A sequence of such approximations is:
      </p>
      
      <p class="center">1/2, 2/4, 3/8, 6/16, 11/32, 22/64, 43/128, 86/256, 171/512, 342/1024, ....</p>
      
      <p class="indent"><a id="page_254"></a>Usually, the smaller fractions in the sequence are easier to compute, so we choose
         the smallest one that works; in the case at hand this is 11/32. Therefore, the final,
         exact, quotient is given by
      </p>
      
      <div class="image"><img alt="Image" src="graphics/254equ01.jpg" /></div>
      
      <p class="indent">The solution involves two multiplications by small numbers (3 and 11); these can be
         changed to <em>shift</em>’s and <em>add</em>’s.
      </p>
      
      <p class="indent"><a href="ch10.html#ch10fig8">Figure 10–8</a> shows the entire solution in C. As shown, it consists of 14 instructions, including
         two multiplications. If the multiplications are changed to <em>shift</em>’s and <em>add</em>’s, it amounts to 18 elementary instructions. However, if it is desired to avoid the
         multiplications, then either alternative <code>return</code> statement shown gives a solution in 17 elementary instructions. Alternative 2 has
         just a little instruction-level parallelism, but in truth this method generally has
         very little of that.
      </p>
      
      <p class="indent">A more accurate estimate of the quotient can be obtained by changing the first executable
         line to
      </p>
      
      <p class="codelink"><a href="images9.html#p254equ02" id="p254equ02a">Click here to view code image</a></p>
      
      <p class="programlisting1">q = (n &gt;&gt; 1) + (n &gt;&gt; 3);<br /></p>
      
      <p class="noindent">(which makes <code>q</code> too large by a factor of 2, but it has one more bit of accuracy), and then inserting
         just before the assignment to <code>r</code>,
      </p>
      
      <p class="codelink"><a href="images9.html#p254pro03" id="p254pro03a">Click here to view code image</a></p>
      
      <p class="programlisting1">q = q &gt;&gt; 1;<br /></p>
      
      <p class="noindent">With this variation, the remainder is at most 9. However, there does not seem to be
         any better code for calculating <span class="middle"><img alt="Image" src="graphics/253equ03.jpg" /></span> with <strong><em>r</em></strong> limited to 9 than there is for <strong><em>r</em></strong> limited to 15 (four elementary instructions in either case). Thus, using the idea
         would cost one instruction. This possibility is mentioned because it <em>does</em> give a code improvement for most divisors.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig08" id="p10fig08a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig8"></a>unsigned divu3(unsigned n) {<br />   unsigned q, r;<br /><br />   q = (n &gt;&gt; 2) + (n &gt;&gt; 4);     // q = n*0.0101 (approx).<br />   q = q + (q &gt;&gt; 4);            // q = n*0.01010101.<br />   q = q + (q &gt;&gt; 8);<br />   q = q + (q &gt;&gt; 16);<br />   r = n - q*3;                 // 0 &lt;= r &lt;= 15.<br />   return q + (11*r &gt;&gt; 5);      // Returning q + r/3.<br />// return q + (5*(r + 1) &gt;&gt; 4);         // Alternative 1.<br />// return q + ((r + 5 + (r &lt;&lt; 2)) &gt;&gt; 4);// Alternative 2.<br />}<br /></p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–8. Unsigned divide by 3.
      </p>
      
      <p class="indent"><a id="page_255"></a><a href="ch10.html#ch10fig9">Figure 10–9</a> shows two variations of this method for dividing by 5. The reciprocal of 5, in binary,
         is
      </p>
      
      <p class="center">0.0011 0011 0011 0011 0011 0011 0011 0011.</p>
      
      <p class="noindent">As in the case of division by 3, the simple repeating pattern of 1’s and 0’s allows
         a fairly efficient and accurate computing of the quotient estimate. The estimate of
         the quotient computed by the code on the left can be off by at most 5, and it turns
         out that the remainder is at most 25. The code on the right retains two additional
         bits of accuracy in computing the quotient estimate, which is off by at most 2. The
         remainder in this case is at most 10. The smaller maximum remainder permits approximating
         1/5 by 7/32 rather than 13/64, which gives a slightly more efficient program if the
         multiplications are done by <em>shift</em>’s and <em>add</em>’s. The instruction counts are, for the code on the left: 14 instructions including
         two multiplications, or 18 elementary instructions; for the code on the right: 15
         instructions including two multiplications, or 17 elementary instructions. The alternative
         code in the <code>return</code> statement is useful only if your machine has comparison predicate instructions. It
         doesn’t reduce the instruction count, but merely has a little instruction-level parallelism.
      </p>
      
      <p class="indent">For division by 6, the divide-by-3 code can be used, followed by a <em>shift right</em> of 1. However, the extra instruction can be saved by doing the computation directly,
         using the binary approximation
      </p>
      
      <p class="center">4/6 ≈ 0.1010 1010 1010 1010 1010 1010 1010 1010.</p>
      
      <div class="image"><a id="ch10fig9"></a><img alt="Image" src="graphics/10fig09.jpg" /></div>
      
      <p class="fig-caption">F<small>IGURE</small> 10–9. Unsigned divide by 5.
      </p>
      
      <p class="indent">The code is shown in <a href="ch10.html#ch10fig10">Figure 10–10</a>. The version on the left multiplies by an approximation to 1/6 and then corrects
         with a multiplication by 11/64. The version on the right takes advantage of the fact
         that by multiplying by an approximation to 4/6, the quotient estimate is off by only
         1 at most. This permits simpler code for the <a id="page_256"></a>correction; it simply adds 1 to <code>q</code> if <code>r</code> ≥ 6. The code in the second <code>return</code> statement is appropriate if the machine has the comparison predicate instructions.
         Function <code>divu6b</code> is 15 instructions, including one <em>multiply</em>, as shown, or 17 elementary instructions if the multiplication by 6 is changed to
         <em>shift</em>’s and <em>add</em>’s.
      </p>
      
      <div class="image"><a id="ch10fig10"></a><img alt="Image" src="graphics/10fig10.jpg" /></div>
      
      <p class="fig-caption">F<small>IGURE</small> 10–10. Unsigned divide by 6.
      </p>
      
      <p class="indent">For larger divisors, usually it seems to be best to use an approximation to 1/ <em>d</em> that is shifted left so that its most significant bit is 1. It seems that the quotient
         is then off by at most 1 usually (possibly always, this writer does not know), which
         permits efficient code for the correction step. <a href="ch10.html#ch10fig11">Figure 10–11</a> shows code for dividing by 7 and 9, using the binary approximations
      </p>
      
      <div class="image"><img alt="Image" src="graphics/256equ01.jpg" /></div>
      
      <p class="noindent">If the multiplications by 7 and 9 are expanded into <em>shift</em>’s and <em>add</em>’s, these functions take 16 and 15 elementary instructions, respectively.
      </p>
      
      <div class="image"><a id="ch10fig11"></a><img alt="Image" src="graphics/10fig11.jpg" /></div>
      
      <p class="fig-caption">F<small>IGURE</small> 10–11. Unsigned divide by 7 and 9.
      </p>
      
      <p class="indent"><a id="page_257"></a><a href="ch10.html#ch10fig12">Figures 10–12</a> and <a href="ch10.html#ch10fig13">10–13</a> show code for dividing by 10, 11, 12, and 13. These are based on the binary approximations:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/257equ01.jpg" /></div>
      
      <p class="noindent">If the multiplications are expanded into <em>shift</em>’s and <em>add</em>’s, these functions take 17, 20, 17, and 20 elementary instructions, respectively.
      </p>
      
      <div class="image"><a id="ch10fig12"></a><img alt="Image" src="graphics/10fig12.jpg" /></div>
      
      <p class="fig-caption">F<small>IGURE</small> 10–12. Unsigned divide by 10 and 11.
      </p>
      
      <div class="image"><a id="ch10fig13"></a><img alt="Image" src="graphics/10fig13.jpg" /></div>
      
      <p class="fig-caption">F<small>IGURE</small> 10–13. Unsigned divide by 12 and 13.
      </p>
      
      <p class="indent">The case of dividing by 13 is instructive because it shows how you must look for repeating
         strings in the binary expansion of the reciprocal of the divisor. The first assignment
         sets <code>q</code> equal to <code>n</code>*0.1001. The second assignment to <code>q</code> adds <code>n</code>*0.00001001 and <code>n</code>*0.000001001. At this point, <code>q</code> is (approximately) equal to <code>n</code>*0.100111011. The third assignment to <code>q</code> adds in repetitions of this pattern. It <a id="page_258"></a>sometimes helps to use subtraction, as in the case of <code>divu9</code> above. However, you must use care with subtraction, because it may cause the quotient
         estimate to be too large, in which case the remainder is negative and the method breaks
         down. It is quite complicated to get optimal code, and we don’t have a general cookbook
         method that you can put in a compiler to handle any divisor.
      </p>
      
      <p class="indent">The examples above are able to economize on instructions, because the reciprocals
         have simple repeating patterns, and because the multiplication in the computation
         of the remainder <code>r</code> is by a small constant, which can be done with only a few <em>shift</em>’s and <em>add</em>’s. One might wonder how successful this method is for larger divisors. To roughly
         assess this, <a href="ch10.html#ch10fig14">Figures 10–14</a> and <a href="ch10.html#ch10fig15">10–15</a> show code for dividing by 100 and by 1000 (decimal). The relevant reciprocals are
      </p>
      
      <div class="image"><img alt="Image" src="graphics/258equ01.jpg" /></div>
      
      <p class="noindent">If the multiplications are expanded into <em>shift</em>’s and <em>add</em>’s, these functions take 25 and 23 elementary instructions, respectively.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig14" id="p10fig14a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig14"></a>unsigned divu100(unsigned n) {<br />   unsigned q, r;<br /><br />   q = (n &gt;&gt; 1) + (n &gt;&gt; 3) + (n &gt;&gt; 6) - (n &gt;&gt; 10) +<br />       (n &gt;&gt; 12) + (n &gt;&gt; 13) - (n &gt;&gt; 16);<br />   q = q + (q &gt;&gt; 20);<br />   q = q &gt;&gt; 6;<br />   r = n - q*100;<br />   return q + ((r + 28) &gt;&gt; 7);<br />// return q + (r &gt; 99);<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–14. Unsigned divide by 100.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig15" id="p10fig15a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig15"></a>unsigned divu1000(unsigned n) {<br />   unsigned q, r, t;<br /><br />   t = (n &gt;&gt; 7) + (n &gt;&gt; 8) + (n &gt;&gt; 12);<br />   q = (n &gt;&gt; 1) + t + (n &gt;&gt; 15) + (t &gt;&gt; 11) + (t &gt;&gt; 14);<br />   q = q &gt;&gt; 9;<br />   r = n - q*1000;<br />   return q + ((r + 24) &gt;&gt; 10);<br />// return q + (r &gt; 999);<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–15. Unsigned divide by 1000.
      </p>
      
      <p class="indent"><a id="page_259"></a>In the case of dividing by 1000, the least significant eight bits of the reciprocal
         estimate are nearly ignored. The code of <a href="ch10.html#ch10fig15">Figure 10–15</a> replaces the binary 1001 0111 with 0100 0000, and still the quotient estimate is
         within one of the true quotient. Thus, it appears that although large divisors might
         have very little repetition in the binary representation of the reciprocal estimate,
         at least some bits can be ignored, which helps hold down the number of <em>shift</em>’s and <em>add</em>’s required to compute the quotient estimate.
      </p>
      
      <p class="indent">This section has shown, in a somewhat imprecise way, how unsigned division by a constant
         can be reduced to a sequence of, typically, about 20 elementary instructions. It is
         nontrivial to get an algorithm that generates these code sequences that is suitable
         for incorporation into a compiler, because of three difficulties in getting optimal
         code.
      </p>
      
      <p class="indenthangingN">1. It is necessary to search the reciprocal estimate bit string for repeating patterns.</p>
      
      <p class="indenthangingN">2. Negative terms (as in <code>divu10</code> and <code>divu100)</code> can be used sometimes, but the error analysis required to determine just when they
         can be used is difficult.
      </p>
      
      <p class="indenthangingN">3. Sometimes some of the least significant bits of the reciprocal estimate can be
         ignored (how many?).
      </p>
      
      <p class="noindent">Another difficulty for some target machines is that there are many variations on the
         code examples given that have more instructions, but that would execute faster on
         a machine with multiple shift and add units.
      </p>
      
      <p class="indent">The code of <a href="ch10.html#ch10fig7">Figures 10–7</a> through <a href="ch10.html#ch10fig15">10–15</a> has been tested for all 2<sup>32</sup> values of the dividends.
      </p>
      
      <h4><strong>Signed Division</strong></h4>
      
      <p class="noindent">The methods given above can be made to apply to signed division. The <em>right shift</em> instructions in computing the quotient estimate become <em>signed right shift</em> instructions, which compute floor division by powers of 2. Thus, the quotient estimate
         is too low (algebraically), so the remainder is nonnegative, as in the unsigned case.
      </p>
      
      <p class="indent">The code most naturally computes the floor division result, so we need a correction
         to make it compute the conventional truncated-toward-0 result. This can be done with
         three computational instructions by adding <em>d</em> – 1 to the dividend if the dividend is negative. For example, if the divisor is 6,
         the code begins with (the <em>shift</em> here is a <em>signed shift</em>)
      </p>
      
      <p class="codelink"><a href="images9.html#p259pro01" id="p259pro01a">Click here to view code image</a></p>
      
      <p class="programlisting1">n = n + (n &gt;&gt; 31 &amp; 5);</p>
      
      <p class="indent">Other than this, the code is very similar to that of the unsigned case. The number
         of elementary operations required is usually three more than in the corresponding
         unsigned division function. Several examples are given in <a href="ch10.html#ch10fig16">Figures 10–16</a> through <a href="ch10.html#ch10fig22">10–22</a>. All have been exhaustively tested.
      </p>
      
      <p class="codelink"><a id="page_260"></a><a href="images9.html#p10fig16" id="p10fig16a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig16"></a>int divs3(int n) {<br />   int q, r;<br /><br />   n = n + (n&gt;&gt;31 &amp; 2);         // Add 2 if n &lt; 0.<br />   q = (n &gt;&gt; 2) + (n &gt;&gt; 4);     // q = n*0.0101 (approx).<br />   q = q + (q &gt;&gt; 4);            // q = n*0.01010101.<br />   q = q + (q &gt;&gt; 8);<br />   q = q + (q &gt;&gt; 16);<br />   r = n - q*3;                 // 0 &lt;= r &lt;= 14.<br />   return q + (11*r &gt;&gt; 5);      // Returning q + r/3.<br />// return q + (5*(r + 1) &gt;&gt; 4);         // Alternative 1.<br />// return q + ((r + 5 + (r <span class="entity">&lt;&lt;</span> 2)) &gt;&gt; 4);// Alternative 2.<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–16. Signed divide by 3.
      </p>
      
      <div class="image"><a id="ch10fig17"></a><img alt="Image" src="graphics/10fig17.jpg" /></div>
      
      <p class="fig-caption">F<small>IGURE</small> 10–17. Signed divide by 5 and 6.
      </p>
      
      <div class="image"><a id="ch10fig18"></a><img alt="Image" src="graphics/10fig18.jpg" /></div>
      
      <p class="fig-caption">F<small>IGURE</small> 10–18. Signed divide by 7 and 9.
      </p>
      
      <div class="image"><a id="page_261"></a><a id="ch10fig19"></a><img alt="Image" src="graphics/10fig19.jpg" /></div>
      
      <p class="fig-caption">F<small>IGURE</small> 10–19. Signed divide by 10 and 11.
      </p>
      
      <div class="image"><a id="ch10fig20"></a><img alt="Image" src="graphics/10fig20.jpg" /></div>
      
      <p class="fig-caption">F<small>IGURE</small> 10–20. Signed divide by 12 and 13.
      </p>
      
      <div class="image"><a id="ch10fig21"></a><img alt="Image" src="graphics/10fig21.jpg" /></div>
      
      <p class="fig-caption">F<small>IGURE</small> 10–21. Signed divide by 100.
      </p>
      
      <p class="codelink"><a id="page_262"></a><a href="images9.html#p10fig22" id="p10fig22a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig22"></a>int divs1000(int n) {<br />   int q, r, t;<br /><br />   n = n + (n &gt;&gt; 31 &amp; 999);<br />   t = (n &gt;&gt; 7) + (n &gt;&gt; 8) + (n &gt;&gt; 12);<br />   q = (n &gt;&gt; 1) + t + (n &gt;&gt; 15) + (t &gt;&gt; 11) + (t &gt;&gt; 14) +<br />       (n &gt;&gt; 26) + (t &gt;&gt; 21);<br />   q = q &gt;&gt; 9;<br />   r = n - q*1000;<br />   return q + ((r + 24) &gt;&gt; 10);<br />// return q + (r &gt; 999);<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10-22. Signed divide by 1000.
      </p>
      
      <h3><a id="ch10lev19"></a><strong>10-19 Remainder by Summing Digits</strong></h3>
      
      <p class="noindent">This section addresses the problem of computing the remainder of division by a constant
         without computing the quotient. The methods of this section apply only to divisors
         of the form 2<sup><em>k</em></sup> ± 1, for <em>k</em> an integer greater than or equal to 2, and in most cases the code resorts to a table
         lookup (an indexed <em>load</em> instruction) after a fairly short calculation.
      </p>
      
      <p class="indent">We will make frequent use of the following elementary property of congruences:</p>
      
      <p class="indent">T<small>HEOREM</small> C. <em>If a</em> ≡ <em>b</em> (mod <em>m</em>) and <em>c</em> ≡ <em>d</em> (mod <em>m</em>), <em>then</em></p>
      
      <div class="image"><img alt="Image" src="graphics/262equ01.jpg" /></div>
      
      <p class="indent">The unsigned case is simpler and is dealt with first.</p>
      
      <h4><strong>Unsigned Remainder</strong></h4>
      
      <p class="noindent">For a divisor of 3, multiplying the trivial congruence 1 ≡ 1 (mod 3) repeatedly by
         the congruence 2 ≡ –1 (mod 3), we conclude by Theorem C that
      </p>
      
      <div class="image"><img alt="Image" src="graphics/262equ02.jpg" /></div>
      
      <p class="noindent">Therefore, a number <em>n</em> written in binary as ...<em>b</em><sub>3</sub> <em>b</em><sub>2</sub> <em>b</em><sub>1</sub> <em>b</em><sub>0</sub> satisfies
      </p>
      
      <p class="center">n = ... + <em>b</em><sub>3</sub> · 2<sup>3</sup> + <em>b</em><sub>2</sub> · 2<sup>2</sup> + <em>b</em><sub>1</sub> · 2 + <em>b</em><sub>0</sub> ≡ ...– <em>b</em><sub>3</sub> + <em>b</em><sub>2</sub> – <em>b</em><sub>1</sub> + <em>b</em><sub>0</sub> (mod 3),
      </p>
      
      <p class="noindent">which is derived by using Theorem C repeatedly. Thus, we can alternately add and subtract
         the bits in the binary representation of the number to obtain a smaller <a id="page_263"></a>number that has the same remainder upon division by 3. If the sum is negative, you
         must add a multiple of 3 to make it nonnegative. The process can then be repeated
         until the result is in the range 0 to 2.
      </p>
      
      <p class="indent">The same trick works for finding the remainder after dividing a decimal number by
         11.
      </p>
      
      <p class="indent">Thus, if the machine has the <em>population count</em> instruction, a function that computes the remainder modulo 3 of an unsigned number
         <code>n</code> might begin with
      </p>
      
      <p class="codelink"><a href="images9.html#p263equ01" id="p263equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">n = pop(n &amp; 0x55555555) - pop(n &amp; 0xAAAAAAAA);</p>
      
      <p class="noindent">This can be simplified by using the following surprising identity discovered by Paolo
         Bonzini [Bonz]:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/263equ02.jpg" /></div>
      
      <div class="image"><img alt="Image" src="graphics/263equ03.jpg" /></div>
      
      <p class="noindent">Since the references to 32 (the word size) cancel out, the result holds for any word
         size. Another way to prove (2) is to observe that it holds for <strong><em>x</em></strong> = <strong>0</strong>, and if a 0-bit in <strong><em>x</em></strong> is changed to a 1 where <strong><em>m</em></strong> is 1, then both sides of (2) decrease by 1, and if a 0-bit of <strong><em>x</em></strong> is changed to a 1 where <strong><em>m</em></strong> is 0, then both sides of (2) increase by 1.
      </p>
      
      <p class="indent">Applying (2) to the line of C code above gives</p>
      
      <p class="codelink"><a href="images9.html#p263pro04" id="p263pro04a">Click here to view code image</a></p>
      
      <p class="programlisting1">n = pop(n ^ 0xAAAAAAAA) - 16;</p>
      
      <p class="noindent">We want to apply this transformation again, until <code>n</code> is in the range 0 to 2, if possible. It is best to avoid producing a negative value
         of <code>n</code>, because the sign bit would not be treated properly on the next round. A negative
         value can be avoided by adding a sufficiently large multiple of 3 to <code>n</code>. Bonzini’s code, shown in <a href="ch10.html#ch10fig23">Figure 10–23</a>, increases the constant by 39. This is larger than necessary to make <code>n</code> nonnegative, but it causes <code>n</code> to range from –3 to 2 (rather than –3 to 3) after the second round of reduction.
         This simplifies the code on the <code>return</code> statement, which is adding 3 if <code>n</code> is negative. The function executes in 11 instructions, counting two to load the large
         constant.
      </p>
      
      <p class="indent"><a href="ch10.html#ch10fig24">Figure 10–24</a> shows a variation that executes in four instructions, plus a simple table lookup
         operation (e.g., an indexed <em>load byte</em> instruction).
      </p>
      
      <p class="codelink"><a id="page_264"></a><a href="images9.html#p10fig23" id="p10fig23a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig23"></a>int remu3(unsigned n) {<br />   n = pop(n ^ 0xAAAAAAAA) + 23;       // Now 23 &lt;= n &lt;= 55.<br />   n = pop(n ^ 0x2A) - 3;              // Now -3 &lt;= n &lt;= 2.<br />   return n + (((int)n &gt;&gt; 31) &amp; 3);<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–23. Unsigned remainder modulo 3, using <em>population count</em>.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig24" id="p10fig24a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig24"></a>int remu3(unsigned n) {<br /><br />   static char table[33] = {2, 0,1,2, 0,1,2, 0,1,2,<br />          0,1,2, 0,1,2, 0,1,2, 0,1,2, 0,1,2, 0,1,2,<br />          0,1,2, 0,1};<br /><br />   n = pop(n ^ 0xAAAAAAAA);<br />   return table[n];<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–24. Unsigned remainder modulo 3, using <em>population count</em> and a table lookup.
      </p>
      
      <p class="indent">To avoid the <em>population count</em> instruction, notice that because 4 ≡ 1 (mod 3), 4<sup><em>k</em></sup> ≡ 1 (mod 3). A binary number can be viewed as a base 4 number by taking its bits
         in pairs and interpreting the bits 00 to 11 as a base 4 digit ranging from 0 to 3.
         The pairs of bits can be summed using the code of <a href="ch05.html#ch05fig2">Figure 5–2</a> on page <a href="ch05.html#page_82">82</a>, omitting the first executable line (overflow does not occur in the additions). The
         final sum ranges from 0 to 48, and a table lookup can be used to reduce this to the
         range 0 to 2. The resulting function is 16 elementary instructions, plus an indexed
         <em>load</em>.
      </p>
      
      <p class="indent">There is a similar, but slightly better, way. As a first step, <code>n</code> can be reduced to a smaller number that is in the same congruence class modulo 3
         with
      </p>
      
      <p class="codelink"><a href="images9.html#p264pro01" id="p264pro01a">Click here to view code image</a></p>
      
      <p class="programlisting1">n = (n &gt;&gt; 16) + (n &amp; 0xFFFF);</p>
      
      <p class="noindent">This splits the number into two 16-bit portions, which are added together. The contribution
         modulo 3 of the left 16 bits of <code>n</code> is not altered by shifting them right 16 positions, because the shifted number, multiplied
         by 2<sup>16</sup>, is the original number, and 2<sup>16</sup> ≡ 1 (mod 3). More generally, 2<sup><em>k</em></sup> ≡ 1 (mod 3) if <em>k</em> is even. This is used repeatedly (five times) in the code shown in <a href="ch10.html#ch10fig25">Figure 10–25</a>. This code is 19 instructions. The instruction count can be reduced by cutting off
         the digit summing earlier and using an in-memory table lookup, as illustrated in <a href="ch10.html#ch10fig26">Figure 10–26</a> (nine instructions, plus an indexed <em>load</em>). The instruction count can be reduced to six (plus an indexed <em>load</em>) by using a table of size 0x2FE = 766 bytes.
      </p>
      
      <p class="indent">To compute the unsigned remainder modulo 5, the code of <a href="ch10.html#ch10fig27">Figure 10–27</a> uses the relations 16<sup><em>k</em></sup> ≡ 1 (mod 5) and 4 ≡ –1 (mod 5). It is 21 elementary instructions, assuming the multiplication
         by 3 is expanded into a <em>shift</em> and <em>add</em>.
      </p>
      
      <p class="codelink"><a id="page_265"></a><a href="images9.html#p10fig25" id="p10fig25a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig25"></a>int remu3(unsigned n) {<br />   n = (n &gt;&gt; 16) + (n &amp; 0xFFFF);       // Max 0x1FFFE.<br />   n = (n &gt;&gt;  8) + (n &amp; 0x00FF);       // Max 0x2FD.<br />   n = (n &gt;&gt;  4) + (n &amp; 0x000F);       // Max 0x3D.<br />   n = (n &gt;&gt;  2) + (n &amp; 0x0003);       // Max 0x11.<br />   n = (n &gt;&gt;  2) + (n &amp; 0x0003);       // Max 0x6.<br />   return (0x0924 &gt;&gt; (n <span class="entity">&lt;&lt;</span> 1)) &amp; 3;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–25. Unsigned remainder modulo 3, digit summing and an in-register lookup.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig26" id="p10fig26a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig26"></a>int remu3(unsigned n) {<br />   static char table[62] = {0,1,2, 0,1,2, 0,1,2, 0,1,2,<br />       0,1,2, 0,1,2, 0,1,2, 0,1,2, 0,1,2, 0,1,2, 0,1,2,<br />       0,1,2, 0,1,2, 0,1,2, 0,1,2, 0,1,2, 0,1,2, 0,1,2,<br />       0,1,2, 0,1,2,  0,1};<br /><br />   n = (n &gt;&gt; 16) + (n &amp; 0xFFFF);    // Max 0x1FFFE.<br />   n = (n &gt;&gt;  8) + (n &amp; 0x00FF);    // Max 0x2FD.<br />   n = (n &gt;&gt;  4) + (n &amp; 0x000F);    // Max 0x3D.<br />   return table[n];<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–26. Unsigned remainder modulo 3, digit summing and an in-memory lookup.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig27" id="p10fig27a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig27"></a>int remu5(unsigned n) {<br />   n = (n &gt;&gt; 16) + (n &amp; 0xFFFF);            // Max 0x1FFFE.<br />   n = (n &gt;&gt;  8) + (n &amp; 0x00FF);            // Max 0x2FD.<br />   n = (n &gt;&gt;  4) + (n &amp; 0x000F);            // Max 0x3D.<br />   n = (n&gt;&gt;4) - ((n&gt;&gt;2) &amp; 3) + (n &amp; 3);     // -3 to 6.<br />   return (01043210432 &gt;&gt; 3*(n + 3)) &amp; 7;   // Octal const.<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–27. Unsigned remainder modulo 5, digit summing method.
      </p>
      
      <p class="indent">The instruction count can be reduced by using a table, similar to what is done in
         <a href="ch10.html#ch10fig26">Figure 10–26</a>. In fact, the code is identical, except the table is:
      </p>
      
      <p class="codelink"><a href="images9.html#p265equ01" id="p265equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">static char table[62] = {0,1,2,3,4, 0,1,2,3,4,<br />   0,1,2,3,4, 0,1,2,3,4, 0,1,2,3,4, 0,1,2,3,4,<br />   0,1,2,3,4, 0,1,2,3,4, 0,1,2,3,4, 0,1,2,3,4,<br />   0,1,2,3,4, 0,1,2,3,4, 0,1};<br /></p>
      
      <p class="indent">For the unsigned remainder modulo 7, the code of <a href="ch10.html#ch10fig28">Figure 10–28</a> uses the relation 8<sup><em>k</em></sup> ≡ 1 (mod 7) (nine elementary instructions, plus an indexed <em>load</em>).
      </p>
      
      <p class="indent">As a final example, the code of <a href="ch10.html#ch10fig29">Figure 10–29</a> computes the remainder of unsigned division by 9. It is based on the relation 8 ≡
         –1 (mod 9). As shown, it is nine elementary instructions, plus an indexed load. The
         elementary instruction count can be reduced to six by using a table of size 831 (decimal).
      </p>
      
      <p class="codelink"><a id="page_266"></a><a href="images9.html#p10fig28" id="p10fig28a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig28"></a>int remu7(unsigned n) {<br /><br />   static char table[75] = {0,1,2,3,4,5,6, 0,1,2,3,4,5,6,<br />             0,1,2,3,4,5,6, 0,1,2,3,4,5,6, 0,1,2,3,4,5,6,<br />             0,1,2,3,4,5,6, 0,1,2,3,4,5,6, 0,1,2,3,4,5,6,<br />             0,1,2,3,4,5,6, 0,1,2,3,4,5,6, 0,1,2,3,4};<br /><br />   n = (n &gt;&gt; 15) + (n &amp; 0x7FFF);        // Max 0x27FFE.<br />   n = (n &gt;&gt;  9) + (n &amp; 0x001FF);       // Max 0x33D.<br />   n = (n &gt;&gt;  6) + (n &amp; 0x0003F);       // Max 0x4A.<br />   return table[n];<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–28. Unsigned remainder modulo 7, digit summing method.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig29" id="p10fig29a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig29"></a>int remu9(unsigned n) {<br /><br />   int r;<br />   static char table[75] = {0,1,2,3,4,5,6,7,8,<br />         0,1,2,3,4,5,6,7,8, 0,1,2,3,4,5,6,7,8,<br />         0,1,2,3,4,5,6,7,8, 0,1,2,3,4,5,6,7,8,<br />         0,1,2,3,4,5,6,7,8, 0,1,2,3,4,5,6,7,8,<br />         0,1,2,3,4,5,6,7,8, 0,1,2};<br /><br />   r = (n &amp; 0x7FFF) - (n &gt;&gt; 15);    // FFFE0001 to 7FFF.<br />   r = (r &amp; 0x01FF) - (r &gt;&gt;  9);    // FFFFFFC1 to 2FF.<br />   r = (r &amp; 0x003F) + (r &gt;&gt;  6);    // 0 to 4A.<br />   return table[r];<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–29. Unsigned remainder modulo 9, digit summing method.
      </p>
      
      <h4><strong>Signed Remainder</strong></h4>
      
      <p class="noindent">The digit summing method can be adapted to compute the remainder resulting from signed
         division. There seems to be no better way than to add a few steps to correct the result
         of the method as applied to unsigned division. Two corrections are necessary: (1)
         correct for a different interpretation of the sign bit, and (2) add or subtract a
         multiple of the divisor <em>d</em> to get the result in the range 0 to – (<em>d</em> – 1).
      </p>
      
      <p class="indent">For division by 3, the unsigned remainder code interprets the sign bit of the dividend
         <strong><em>n</em></strong> as contributing 2 to the remainder (because 2<sup>31</sup> mod 3 = 2). For the remainder of signed division, the sign bit contributes only 1
         (because (–2<sup>31</sup>) mod 3 = 1). Therefore, we can use the code for an unsigned remainder and correct
         its result by subtracting 1. Then, the result must be put in the range 0 to –2. That
         is, the result of the unsigned remainder code must be mapped as follows:
      </p>
      
      <p class="center">(0, 1, 2) ⇒ (–1, 0, 1) ⇒ (–1, 0, –2).</p>
      
      <p class="noindent">This adjustment can be done fairly efficiently by subtracting 1 from the unsigned
         remainder if it is 0 or 1, and subtracting 4 if it is 2 (when the dividend is negative).
         The code must not alter the dividend <code>n</code>, because it is needed in this last step.
      </p>
      
      <p class="indent">This procedure can easily be applied to any of the functions given for the unsigned
         remainder modulo 3. For example, applying it to <a href="ch10.html#ch10fig26">Figure 10–26</a> on page <a href="ch10.html#page_265">265</a> gives the function shown in <a href="ch10.html#ch10fig30">Figure 10–30</a>. It is 13 elementary instructions, plus an indexed <em>load</em>. The instruction count can be reduced by using a larger table.
      </p>
      
      <p class="codelink"><a id="page_267"></a><a href="images9.html#p10fig30" id="p10fig30a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig30"></a>int rems3(int n) {<br />   unsigned r;<br />   static char table[62] = {0,1,2, 0,1,2, 0,1,2, 0,1,2,<br />       0,1,2, 0,1,2, 0,1,2, 0,1,2, 0,1,2, 0,1,2, 0,1,2,<br />       0,1,2, 0,1,2, 0,1,2, 0,1,2, 0,1,2, 0,1,2, 0,1,2,<br />       0,1,2, 0,1,2, 0,1};<br /><br />   r = n;<br />   r = (r &gt;&gt; 16) + (r &amp; 0xFFFF);    // Max 0x1FFFE. <br />   r = (r &gt;&gt;  8) + (r &amp; 0x00FF);    // Max 0x2FD.<br />   r = (r &gt;&gt;  4) + (r &amp; 0x000F);    // Max 0x3D.<br />   r = table[r];<br />   return r - (((unsigned)n &gt;&gt; 31) <span class="entity">&lt;&lt;</span> (r &amp; 2));<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–30. Signed remainder modulo 3, digit summing method.
      </p>
      
      <p class="indent"><a href="ch10.html#ch10fig31">Figures 10–31</a> to <a href="ch10.html#ch10fig33">10–33</a> show similar code for computing the signed remainder of division by 5, 7, and 9.
         All the functions consist of 15 elementary operations, plus an indexed <em>load</em>. They use signed right shifts, and the final adjustment consists of subtracting the
         modulus if the dividend is negative and the remainder is nonzero. The number of instructions
         can be reduced by using larger tables.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig31" id="p10fig31a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig31"></a>int rems5(int n) {<br />   int r;<br />   static char table[62] = {2,3,4, 0,1,2,3,4, 0,1,2,3,4,<br />             0,1,2,3,4, 0,1,2,3,4, 0,1,2,3,4, 0,1,2,3,4,<br />             0,1,2,3,4, 0,1,2,3,4, 0,1,2,3,4, 0,1,2,3,4,<br />             0,1,2,3,4, 0,1,2,3};<br /><br />   r = (n &gt;&gt; 16) + (n &amp; 0xFFFF);  // FFFF8000 to 17FFE.<br />   r = (r &gt;&gt;  8) + (r &amp; 0x00FF);  // FFFFFF80 to 27D.<br />   r = (r &gt;&gt;  4) + (r &amp; 0x000F);  // -8 to 53 (decimal).<br />   r = table[r + 8];<br />   return r - (((int)(n &amp; -r) &gt;&gt; 31) &amp; 5);<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–31. Signed remainder modulo 5, digit summing method.
      </p>
      
      <p class="codelink"><a id="page_268"></a><a href="images9.html#p10fig32" id="p10fig32a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig32"></a>int rems7(int n) {<br />   int r;<br />   static char table[75] =   {5,6, 0,1,2,3,4,5,6,<br />     0,1,2,3,4,5,6, 0,1,2,3,4,5,6, 0,1,2,3,4,5,6,<br />     0,1,2,3,4,5,6, 0,1,2,3,4,5,6, 0,1,2,3,4,5,6,<br />     0,1,2,3,4,5,6, 0,1,2,3,4,5,6, 0,1,2,3,4,5,6, 0,1,2};<br /><br />   r = (n &gt;&gt; 15) + (n &amp; 0x7FFF);   // FFFF0000 to 17FFE.<br />   r = (r &gt;&gt;  9) + (r &amp; 0x001FF);  // FFFFFF80 to 2BD.<br />   r = (r &gt;&gt;  6) + (r &amp; 0x0003F);  // -2 to 72 (decimal).<br />   r = table[r + 2];<br />   return r - (((int)(n &amp; -r) &gt;&gt; 31) &amp; 7);<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–32. Signed remainder modulo 7, digit summing method.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig33" id="p10fig33a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig33"></a>int rems9(int n) {<br />   int r;<br />   static char table[75] = {7,8, 0,1,2,3,4,5,6,7,8,<br />              0,1,2,3,4,5,6,7,8, 0,1,2,3,4,5,6,7,8,<br />              0,1,2,3,4,5,6,7,8, 0,1,2,3,4,5,6,7,8,<br />              0,1,2,3,4,5,6,7,8, 0,1,2,3,4,5,6,7,8,<br />              0,1,2,3,4,5,6,7,8, 0};<br /><br />   r = (n &amp; 0x7FFF) - (n &gt;&gt; 15);   // FFFF7001 to 17FFF.<br />   r = (r &amp; 0x01FF) - (r &gt;&gt;  9);   // FFFFFF41 to 0x27F.<br />   r = (r &amp; 0x003F) + (r &gt;&gt;  6);   // -2 to 72 (decimal).<br />   r = table[r + 2];<br />   return r - (((int)(n &amp; -r) &gt;&gt; 31) &amp; 9);<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–33. Signed remainder modulo 9, digit summing method.
      </p>
      
      <h3><a id="ch10lev20"></a><strong>10–20 Remainder by Multiplication and Shifting Right</strong></h3>
      
      <p class="noindent">The method described in this section applies, in principle, to all integer divisors
         greater than 2, but as a practical matter only to fairly small divisors and to divisors
         of the form 2<sup><em>k</em></sup> – 1. As in the preceding section, in most cases the code resorts to a table lookup
         after a fairly short calculation.
      </p>
      
      <h4><strong>Unsigned Remainder</strong></h4>
      
      <p class="noindent">This section uses the mathematical (not computer algebra) notation <em>a</em> mod <em>b</em>, where <em>a</em> and <em>b</em> are integers and <em>b</em> &gt; 0, to denote the integer <em>x</em>, 0 ≤ <em>x</em> &lt; <em>b</em>, that satisfies <em>x</em> ≡ <em>a</em> (mod <em>b</em>).
      </p>
      
      <p class="indent"><a id="page_269"></a>To compute <em>n</em> mod 3, observe that
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10equ03.jpg" /></div>
      
      <p class="noindent">Proof: Let <em>n</em> = 3 <em>k</em> + δ, where δ and <em>k</em> are integers and 0 ≤ δ ≤ 2. Then
      </p>
      
      <div class="image"><img alt="Image" src="graphics/269equ01.jpg" /></div>
      
      <p class="noindent">Clearly, the value of the last expression is 0, 1, or 2 for δ = 0, 1, or 2 respectively.
         This allows changing the problem of computing the remainder modulo 3 to one of computing
         the remainder modulo 4, which is of course much easier on a binary computer.
      </p>
      
      <p class="indent">Relations like (3) do not hold for all moduli, but similar relations do hold if the
         modulus is of the form 2<sup><em>k</em></sup> – 1, for <em>k</em> an integer greater than 1. For example, it is easy to show that
      </p>
      
      <div class="image"><img alt="Image" src="graphics/269equ02.jpg" /></div>
      
      <p class="indent">For numbers not of the form 2<sup><em>k</em></sup> – 1, there is no such simple relation, but there is a certain uniqueness property
         that can be used to compute the remainder for other divisors. For example, if the
         divisor is 10 (decimal), consider the expression
      </p>
      
      <div class="image"><img alt="Image" src="graphics/269equ03.jpg" /></div>
      
      <p class="noindent">Let <em>n</em> = 10 <em>k</em> + δ where 0 ≤ δ ≤ 9. Then
      </p>
      
      <div class="image"><img alt="Image" src="graphics/269equ04.jpg" /></div>
      
      <p class="noindent">For δ = 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9, the last expression takes on the values
         0, 1, 3, 4, 6, 8, 9, 11, 12, and 14 respectively. The latter numbers are all distinct.
         Therefore, if we can find a reasonably easy way to compute (4), we can translate 0
         to 0, 1 to 1, 3 to 2, 4 to 3, and so on, to obtain the remainder of division by 10.
         This will generally require a translation table of size equal to the next power of
         2 greater than the divisor, so the method is practical only for fairly small divisors
         (and for divisors of the form 2<sup><em>k</em></sup> – 1, for which table lookup is not required).
      </p>
      
      <p class="indent">The code to be shown was derived by using a little of the above theory and a lot of
         trial and error.
      </p>
      
      <p class="indent">Consider the remainder of unsigned division by 3. Following (3), we wish to compute
         the rightmost two bits of the integer part of 4<em>n</em>/ 3. This can be done approximately by multiplying by <span class="entity">⌊</span>2<sup>32</sup> / 3<span class="entity">⌋</span> and then dividing by 2<sup>30</sup> using a <em>shift right</em> instruction. When the multiplication by <span class="entity">⌊</span>2<sup>32</sup> / 3<span class="entity">⌋</span> is done (using the <em>multiply</em> <a id="page_270"></a>instruction that gives the low-order 32 bits of the product), high-order bits will
         be lost. But that doesn’t matter, and, in fact, it’s helpful, because we want the
         result modulo 4. Therefore, because <span class="entity">⌊</span>2<sup>32</sup> / 3<span class="entity">⌋</span> = 0x55555555, a possible plan is to compute
      </p>
      
      <div class="image"><img alt="Image" src="graphics/270equ01.jpg" /></div>
      
      <p class="indent">Experiment indicates that this works for <strong><em>n</em></strong> in the range 0 to 2<sup>30</sup> + 2. It almost works, I should say; if <strong><em>n</em></strong> is nonzero and a multiple of 3, it gives the result 3. Therefore, it must be followed
         by a translation step that translates (0, 1, 2, 3) to (0, 1, 2, 0) respectively.
      </p>
      
      <p class="indent">To extend the range of applicability, the multiplication must be done more accurately.
         Two more bits of accuracy suffice (that is, multiplying by <strong>0x55555555.4</strong>). The following calculation, followed by the translation step, works for all <strong><em>n</em></strong> representable as an unsigned 32-bit integer:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/270equ02.jpg" /></div>
      
      <p class="noindent">It is, of course, possible to give a formal proof of this, but the algebra is quite
         lengthy and error prone.
      </p>
      
      <p class="indent">The translation step can be done in three or four instructions on most machines, but
         there is a way to avoid it at a cost of two instructions. The above expression for
         computing <strong><em>r</em></strong> estimates low. If you estimate slightly high, the result is always 0, 1, or 2. This
         gives the C function shown in <a href="ch10.html#ch10fig34">Figure 10–34</a> (eight instructions, including a <em>multiply</em>).
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig34" id="p10fig34a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig34"></a> int remu3(unsigned n) {<br />   return (0x55555555*n + (n &gt;&gt; 1) - (n &gt;&gt; 3)) &gt;&gt; 30;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–34. Unsigned remainder modulo 3, multiplication method.
      </p>
      
      <p class="indent">The multiplication can be expanded, giving the 13-instruction function shown in <a href="ch10.html#ch10fig35">Figure 10–35</a> that uses only <em>shift</em>’s and <em>add</em>’s.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig35" id="p10fig35a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig35"></a>int remu3(unsigned n) {<br />   unsigned r;<br /><br />   r = n + (n <span class="entity">&lt;&lt;</span> 2);<br />   r = r + (r <span class="entity">&lt;&lt;</span> 4);<br />   r = r + (r <span class="entity">&lt;&lt;</span> 8);<br />   r = r + (r <span class="entity">&lt;&lt;</span> 16);<br />   r = r + (n &gt;&gt; 1);<br />   r = r - (n &gt;&gt; 3);<br />   return r &gt;&gt; 30;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–35. Unsigned remainder modulo 3, multiplication (expanded) method.
      </p>
      
      <p class="indent"><a id="page_271"></a>The remainder of unsigned division by 5 can be computed very similarly to the remainder
         of division by 3. Let <em>n</em> = 5 <em>k</em> + <em>r</em> with 0 ≤ <em>r</em> ≤ 4. Then (8 / 5)<em>n</em> mod 8 = (8 / 5)(5 <em>k</em>+ <em>r</em>) mod 8 = (8 / 5)<em>r</em> mod 8. For <em>r</em> = 0, 1, 2, 3, and 4, this takes on the values 0, 1, 3, 4, and 6 respectively. Since
         <span class="entity">⌊</span>2<sup>32</sup> / 5<span class="entity">⌋</span> = 0x33333333, this leads to the function shown in <a href="ch10.html#ch10fig36">Figure 10–36</a> (11 instructions, including a <em>multiply</em>). The last step (code on the <code>return</code> statement) is mapping (0, 1, 3, 4, 6, 7) to (0, 1, 2, 3, 4, 0) respectively, using
         an in-register method rather than an indexed <em>load</em> from memory. By also mapping 2 to 2 and 5 to 4, the precision required in the multiplication
         by 2<sup>32</sup> / 5 is reduced to using just the term <code>n &gt;&gt; 3</code> to approximate the missing part of the multiplier (hexadecimal 0.333...). If the
         “accuracy” term <code>n &gt;&gt; 3</code> is omitted, the code still works for <code>n</code> ranging from 0 to 0x60000004.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig36" id="p10fig36a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig36"></a>int remu5(unsigned n) {<br />   n = (0x33333333*n + (n &gt;&gt; 3)) &gt;&gt; 29;<br />   return (0x04432210 &gt;&gt; (n <span class="entity">&lt;&lt;</span> 2)) &amp; 7;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–36. Unsigned remainder modulo 5, multiplication method.
      </p>
      
      <p class="indent">The code for computing the unsigned remainder modulo 7 is similar, but the mapping
         step is simpler; it is necessary only to convert 7 to 0. One way to code it is shown
         in <a href="ch10.html#ch10fig37">Figure 10–37</a> (11 instructions, including a <em>multiply</em>). If the accuracy term <code>n &gt;&gt; 4</code> is omitted, the code still works for <code>n</code> up to 0x40000006. With both accuracy terms omitted, it works for <code>n</code> up to 0x08000006.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig37" id="p10fig37a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig37"></a>int remu7(unsigned n) {<br />   n = (0x24924924*n + (n &gt;&gt; 1) + (n &gt;&gt; 4)) &gt;&gt; 29;<br />   return n &amp; ((int)(n - 7) &gt;&gt; 31);<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–37. Unsigned remainder modulo 7, multiplication method.
      </p>
      
      <p class="indent">Code for computing the unsigned remainder modulo 9 is shown in <a href="ch10.html#ch10fig38">Figure 10–38</a>. It is six instructions, including a <em>multiply</em>, plus an indexed <em>load</em>. If the accuracy term <code>n &gt;&gt; 1</code> is omitted and the multiplier is changed to 0x1C71C71D, the function works for <code>n</code> up to 0x1999999E.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig38" id="p10fig38a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig38"></a>int remu9(unsigned n) {<br />   static char table[16] = {0, 1, 1, 2, 2, 3, 3, 4,<br />                            5, 5, 6, 6, 7, 7, 8, 8};<br /><br />   n = (0x1C71C71C*n + (n &gt;&gt; 1)) &gt;&gt; 28;<br />   return table[n];<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–38. Unsigned remainder modulo 9, multiplication method.
      </p>
      
      <p class="indent"><a href="ch10.html#ch10fig39">Figure 10–39</a> shows a way to compute the unsigned remainder modulo 10. It is eight instructions,
         including a <em>multiply</em>, plus an indexed <em>load</em> instruction. If the <a id="page_272"></a>accuracy term <code>n &gt;&gt; 3</code> is omitted, the code works for <code>n</code> up to 0x40000004. If both accuracy terms are omitted, it works for <code>n</code> up to 0x0AAAAAAD.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig39" id="p10fig39a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig39"></a>int remu10(unsigned n) {<br />   static char table[16] = {0, 1, 2, 2, 3, 3, 4, 5,<br />                            5, 6, 7, 7, 8, 8, 9, 0};<br /><br />   n = (0x19999999*n + (n &gt;&gt; 1) + (n &gt;&gt; 3)) &gt;&gt; 28;<br />   return table[n];<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–39. Unsigned remainder modulo 10, multiplication method.
      </p>
      
      <p class="indent">As a final example, consider the computation of the remainder modulo 63. This function
         is used by the population count program at the top of page <a href="ch05.html#page_84">84</a>. Joe Keane [Keane] has come up with the rather mysterious code shown in <a href="ch10.html#ch10fig40">Figure 10–40</a>. It is 12 elementary instructions on the basic RISC.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig40" id="p10fig40a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig40"></a>int remu63(unsigned n) {<br />   unsigned t;<br /><br />   t = (((n &gt;&gt; 12) + n) &gt;&gt; 10) + (n <span class="entity">&lt;&lt;</span> 2);<br />   t = ((t &gt;&gt; 6) + t + 3) &amp; 0xFF;<br />   return (t - (t &gt;&gt; 6)) &gt;&gt; 2;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–40. Unsigned remainder modulo 63, Keane’s method.
      </p>
      
      <p class="indent">The “multiply and shift right” method leads to the code shown in <a href="ch10.html#ch10fig41">Figure 10–41</a>. This is 11 instructions on the basic RISC, one being a multiply. This would not
         be as fast as Keane’s method, unless the machine has a very fast multiply and the
         load of the constant 0x04104104 can move out of a loop.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig41" id="p10fig41a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig41"></a>int remu63(unsigned n) {<br />   n = (0x04104104*n + (n &gt;&gt; 4) + (n &gt;&gt; 10)) &gt;&gt; 26;<br />   return n &amp; ((n - 63) &gt;&gt; 6);   // Change 63 to 0.<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–41. Unsigned remainder modulo 63, multiplication method.
      </p>
      
      <p class="indent">On some machines, an improvement can result from expanding the multiplication into
         shifts and adds as follows (15 elementary instructions for the whole function):
      </p>
      
      <p class="codelink"><a href="images9.html#p272equ01" id="p272equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">r = (n <span class="entity">&lt;&lt;</span> 2) + (n <span class="entity">&lt;&lt;</span> 8);       // r = 0x104*n.<br />r = r + (r <span class="entity">&lt;&lt;</span> 12);             // r = 0x104104*n.<br />r = r + (n <span class="entity">&lt;&lt;</span> 26);             // r = 0x04104104*n.
      </p>
      
      <h4><a id="page_273"></a><strong>Signed Remainder</strong></h4>
      
      <p class="noindent">As in the case of the digit summing method, the “multiply and shift right” method
         can be adapted to compute the remainder resulting from signed division. Again, there
         seems to be no better way than to add a few steps to correct the result of the method
         as applied to unsigned division. For example, the code shown in <a href="ch10.html#ch10fig42">Figure 10–42</a> is derived from <a href="ch10.html#ch10fig34">Figure 10–34</a> on page <a href="ch10.html#page_270">270</a> (12 instructions, including a <em>multiply</em>).
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig42" id="p10fig42a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig42"></a>int rems3(int n) {<br />   unsigned r;<br /><br />   r = n;<br />   r = (0x55555555*r + (r &gt;&gt; 1) - (r &gt;&gt; 3)) &gt;&gt; 30;<br />   return r - (((unsigned)n &gt;&gt; 31) <span class="entity">&lt;&lt;</span> (r &amp; 2));<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–42. Signed remainder modulo 3, multiplication method.
      </p>
      
      <p class="indent">Some plausible ways to compute the remainder of signed division by 5, 7, 9, and 10
         are shown in <a href="ch10.html#ch10fig43">Figures 10–43</a> to <a href="ch10.html#ch10fig46">10–46</a>. The code for a divisor of 7 uses quite a few extra instructions (19 in all, including
         a <em>multiply</em>); it might be preferable to use a table similar to that shown for the cases in which
         the divisor is 5, 9, or 10. In the latter cases, the table used for unsigned division
         is doubled in size, with the sign bit of the divisor factored in to index the table.
         Entries shown as <code>u</code> are unused.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig43" id="p10fig43a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig43"></a>int rems5(int n) {<br />   unsigned r;<br />   static signed char table[16] = {0, 1, 2, 2, 3, u, 4, 0,<br />                                   u, 0,-4, u,-3,-2,-2,-1};<br />   r = n;<br />   r = ((0x33333333*r) + (r &gt;&gt; 3)) &gt;&gt; 29;<br />   return table[r + (((unsigned)n &gt;&gt; 31) <span class="entity">&lt;&lt;</span> 3)];<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–43. Signed remainder modulo 5, multiplication method.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig44" id="p10fig44a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig44"></a>int rems7(int n) {<br />   unsigned r;<br /><br />   r = n - (((unsigned)n &gt;&gt; 31) <span class="entity">&lt;&lt;</span> 2);  // Fix for sign.<br />   r = ((0x24924924*r) + (r &gt;&gt; 1) + (r &gt;&gt; 4)) &gt;&gt; 29;<br />   r = r &amp; ((int)(r - 7) &gt;&gt; 31);        // Change 7 to 0.<br />   return r - (((int)(n&amp;-r) &gt;&gt; 31) &amp; 7);// Fix n&lt;0 case.<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–44. Signed remainder modulo 7, multiplication method.
      </p>
      
      <p class="codelink"><a id="page_274"></a><a href="images9.html#p10fig45" id="p10fig45a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig45"></a>int rems9(int n) {<br />   unsigned r;<br />   static signed char table[32] = {0, 1, 1, 2, u, 3, u, 4,<br />                                   5, 5, 6, 6, 7, u, 8, u,<br />                                  -4, u,-3, u,-2,-1,-1, 0,<br />                                   u,-8, u,-7,-6,-6,-5,-5};<br />   r = n;<br />   r = (0x1C71C71C*r + (r &gt;&gt; 1)) &gt;&gt; 28;<br />   return table[r + (((unsigned)n &gt;&gt; 31) <span class="entity">&lt;&lt;</span> 4)];<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–45. Signed remainder modulo 9, multiplication method.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig46" id="p10fig46a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig46"></a>int rems10(int n) {<br />   unsigned r;<br />   static signed char table[32] = {0, 1, u, 2, 3, u, 4, 5,<br />                                   5, 6, u, 7, 8, u, 9, u,<br />                                  -6,-5, u,-4,-3,-3,-2, u,<br />                                  -1, 0, u,-9, u,-8,-7, u};<br />   r = n;<br />   r = (0x19999999*r + (r &gt;&gt; 1) + (r &gt;&gt; 3)) &gt;&gt; 28;<br />   return table[r + (((unsigned)n &gt;&gt; 31) <span class="entity">&lt;&lt;</span> 4)];<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–46. Signed remainder modulo 10, multiplication method.
      </p>
      
      <h3><a id="ch10lev21"></a><strong>10–21 Converting to Exact Division</strong></h3>
      
      <p class="noindent">Since the remainder can be computed without computing the quotient, the possibility
         arises of computing the quotient <em>q</em> = <span class="entity">⌊</span><em>n</em>/<em>d</em><span class="entity">⌋</span> by first computing the remainder, subtracting this from the dividend <em>n</em>, and then dividing the difference by the divisor <em>d</em>. This last division is an exact division, and it can be done by multiplying by the
         multiplicative inverse of <em>d</em> (see <a href="ch10.html#ch10lev16">Section 10–16</a>, “<a href="ch10.html#ch10lev16">Exact Division by Constants</a>,” on page <a href="ch10.html#page_240">240</a>). This method would be particularly attractive if both the quotient and remainder
         are wanted.
      </p>
      
      <p class="indent">Let us try this for the case of unsigned division by 3. Computing the remainder by
         the multiplication method (<a href="ch10.html#ch10fig34">Figure 10–34</a> on page <a href="ch10.html#page_270">270</a>) leads to the function shown in <a href="ch10.html#ch10fig47">Figure 10–47</a>.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig47" id="p10fig47a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig47"></a>unsigned divu3(unsigned n) {<br />   unsigned r;<br /><br />   r = (0x55555555*n + (n &gt;&gt; 1) - (n &gt;&gt; 3)) &gt;&gt; 30;<br />   return (n - r)*0xAAAAAAAB;<br />}<br /></p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–47. Unsigned remainder and quotient with divisor = 3, using exact division.
      </p>
      
      <p class="indent"><a id="page_275"></a>This is 11 instructions, including two multiplications by large numbers. (The constant
         <code>0x55555555</code> can be generated by shifting the constant <code>0xAAAAAAAB</code> right one position.) In contrast, the more straightforward method of computing the
         quotient <code>q</code> using (for example) the code of <a href="ch10.html#ch10fig8">Figure 10–8</a> on page <a href="ch10.html#page_254">254</a>, requires 14 instructions, including two multiplications by small numbers, or 17
         elementary operations if the multiplications are expanded into <em>shift</em>’s and <em>add</em>’s. If the remainder is also wanted, and it is computed from <code>r = n - q*3,</code> the more straightforward method requires 16 instructions, including three multiplications
         by small numbers, or 20 elementary instructions if the multiplications are expanded
         into <em>shift</em>’s and <em>add</em>’s.
      </p>
      
      <p class="indent">The code of <a href="ch10.html#ch10fig47">Figure 10–47</a> is not attractive if the multiplications are expanded into <em>shift</em>’s and <em>add</em>’s; the result is 24 elementary instructions. Thus, the exact division method might
         be a good one on a machine that does not have <em>multiply high</em> but does have a fast modulo 2<sup>32</sup> <em>multiply</em> and slow <em>divide</em>, particularly if it can easily deal with the large constants.
      </p>
      
      <p class="indent">For signed division by 3, the exact division method might be coded as shown in <a href="ch10.html#ch10fig48">Figure 10–48</a>. It is 15 instructions, including two multiplications by large constants.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig48" id="p10fig48a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig48"></a>int divs3(int n) {<br />   unsigned r;<br /><br />   r = n;<br />   r = (0x55555555*r + (r &gt;&gt; 1) - (r &gt;&gt; 3)) &gt;&gt; 30;<br />   r = r - (((unsigned)n &gt;&gt; 31) <span class="entity">&lt;&lt;</span> (r &amp; 2));<br />   return (n - r)*0xAAAAAAAB;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–48. Signed remainder and quotient with divisor = 3, using exact division.
      </p>
      
      <p class="indent">As a final example, <a href="ch10.html#ch10fig49">Figure 10–49</a> shows code for computing the quotient and remainder for unsigned division by 10.
         It is 12 instructions, including two multiplications by large constants, plus an indexed
         <em>load</em> instruction.
      </p>
      
      <p class="codelink"><a href="images9.html#p10fig49" id="p10fig49a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch10fig49"></a>unsigned divu10(unsigned n) {<br />   unsigned r;<br />   static char table[16] = {0, 1, 2, 2, 3, 3, 4, 5,<br />                            5, 6, 7, 7, 8, 8, 9, 0};<br /><br />   r = (0x19999999*n + (n &gt;&gt; 1) + (n &gt;&gt; 3)) &gt;&gt; 28;<br />   r = table[r];<br />   return ((n - r) &gt;&gt; 1)*0xCCCCCCCD;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 10–49. Signed remainder and quotient with divisor = 10, using exact division.
      </p>
      
      <h3><a id="page_276"></a><a id="ch10lev22"></a><strong>10–22 A Timing Test</strong></h3>
      
      <p class="noindent">Many machines have a 32×32 ⇒ 64 <em>multiply</em> instruction, so one would expect that to divide by a constant such as 3, the code
         shown on page <a href="ch10.html#page_228">228</a> would be fastest. If that <em>multiply</em> instruction is not present, but the machine has a fast 32×32 ⇒ 32 <em>multiply</em> instruction, then the exact division method might be a good one if the machine has
         a slow <em>divide</em> and a fast <em>multiply</em>. To test this conjecture, an assembly language program was constructed to compare
         four methods of dividing by 3. The results are shown in <a href="ch10.html#ch10tab4">Table 10–4</a>. The machine used was a 667 MHz Pentium III (ca. 2000), and one would expect similar
         results on many other machines.
      </p>
      
      <p class="tab-caption"><a id="ch10tab4"></a>T<small>ABLE</small> 10–4. U<small>NSIGNED</small> D<small>IVIDE BY</small> 3 <small>ON A</small> P<small>ENTIUM</small> III
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10tab04.jpg" /></div>
      
      <p class="indent">The first row gives the time in cycles for just two instructions: an <code>xorl</code> to clear the left half of the 64-bit source register, and the <code>divl</code> instruction, which evidently takes 40 cycles. The second row also gives the time
         for just two instructions: <em>multiply</em> and <em>shift right 1</em> (<code>mull</code> and <code>shrl</code>). The third row gives the time for a sequence of 21 elementary instructions. It is
         the code of <a href="ch10.html#ch10fig8">Figure 10–8</a> on page <a href="ch10.html#page_254">254</a> using alternative 2, and with the multiplication by 3 done with a single instruction
         (<code>leal</code>). Several <em>move</em> instructions are necessary because the machine is (basically) two-address. The last
         row gives the time for a sequence of 10 instructions: two multiplications (<code>imull</code>) and the rest elementary. The two <code>imull</code> instructions use 4-byte immediate fields for the large constants. (The signed <em>multiply</em> instruction <code>imull</code> is used rather than its unsigned counterpart <code>mull</code>, because they give the same result in the low-order 32 bits, and <code>imull</code> has more addressing modes available.)
      </p>
      
      <p class="indent">The exact division method would be even more favorable compared to the second and
         third methods if both the quotient and remainder were wanted, because they would require
         additional code for the computation <strong><em>r</em></strong> ← <strong><em>n</em></strong> – <strong><em>q</em></strong>*3. (The <code>divl</code> instruction produces the remainder as well as the quotient.)
      </p>
      
      <h3><a id="ch10lev23"></a><strong>10–23 A Circuit for Dividing by 3</strong></h3>
      
      <p class="noindent">There is a simple circuit for dividing by 3 that is about as complex as an adder.
         It can be constructed very similarly to the elementary way one constructs an <em>n</em>-bit <a id="page_277"></a>adder from <em>n</em> 1-bit “full adder” circuits. However, in the divider signals flow from most significant
         to least significant bit.
      </p>
      
      <p class="indent">Consider dividing by 3 the way it is taught in grade school, but in binary. To produce
         each bit of the quotient, you divide 3 into the next bit, but the bit is preceded
         by a remainder of 0, 1, or 2 from the previous stage. The logic is shown in <a href="ch10.html#ch10tab5">Table 10–5</a>. Here the remainder is represented by two bits <em>r<sub>i</sub></em> and <em>s<sub>i</sub></em>, with <em>r<sub>i</sub></em> being the most significant bit. The remainder is never 3, so the last two rows of
         the table represent “don’t care” cases.
      </p>
      
      <p class="indent">A circuit for 32-bit division by 3 is shown in <a href="ch10.html#ch10fig50">Figure 10–50</a>. The quotient is the word consisting of bits <em>y</em><sub>31</sub> through <em>y</em><sub>0</sub>, and the remainder is 2<em>r</em><sub>0</sub> + <em>s</em><sub>0</sub>.
      </p>
      
      <p class="indent">Another way to implement the divide-by-3 operation in hardware is to use the multiplier
         to multiply the dividend by the reciprocal of 3 (binary 0.010101...), with appropriate
         rounding and scaling. This is the technique shown on pages <a href="ch10.html#page_207">207</a> and <a href="ch10.html#page_228">228</a>.
      </p>
      
      <p class="tab-caption"><a id="ch10tab5"></a>T<small>ABLE</small> 10–5. L<small>OGIC FOR DIVIDING BY</small> 3
      </p>
      
      <div class="image"><img alt="Image" src="graphics/10tab05.jpg" /></div>
      
      <div class="image"><a id="ch10fig50"></a><img alt="Image" src="graphics/10fig50.jpg" /></div>
      
      <p class="fig-caption">F<small>IGURE</small> 10–50. Logic circuit for dividing by 3.
      </p>
      
      <h4><a id="page_278"></a><strong>Exercises</strong></h4>
      
      <p class="question"><a href="ch19_answer.html#ch10ans1" id="ch10ansa1"><strong>1</strong>.</a> Show that for unsigned division by an even number, the <code>shrxi</code> instruction (or equivalent code) can be avoided by first (a) turning off the low-order
         bit of the dividend (<em>and</em> operation) [CavWer] or (b) dividing the dividend by 2 (<em>shift right 1</em> instruction) and then dividing by half the divisor.
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch10ans2" id="ch10ansa2"><strong>2</strong>.</a> Code a function in Python similar to that of <a href="ch10.html#ch10fig4">Figure 10–4</a> on page <a href="ch10.html#page_240">240</a>, but for computing the magic number for signed division. Consider only positive divisors.
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch10ans3" id="ch10ansa3"><strong>3</strong>.</a> Show how you would use Newton’s method to calculate the multiplicative inverse of
         an integer <em>d</em> modulo 81. Show the calculations for <em>d</em> = 146.
      </p>
      
      <p class="indenthanging2a"><em>I think that I shall never envision</em></p>
      
      <p class="indenthanging2b"><em>An op unlovely as division</em>.
      </p>
      
      <p class="indenthanging2"><em>An op whose answer must be guessed</em></p>
      
      <p class="indenthanging2b"><em>And then, through multiply, assessed;</em></p>
      
      <p class="indenthanging2"><em>An op for which we dearly pay</em>,
      </p>
      
      <p class="indenthanging2b"><em>In cycles wasted every day</em>.
      </p>
      
      <p class="indenthanging2"><em>Division code is often hairy;</em></p>
      
      <p class="indenthanging2b"><em>Long division’s downright scary</em>.
      </p>
      
      <p class="indenthanging2"><em>The proofs can overtax your brain</em>,
      </p>
      
      <p class="indenthanging2b"><em>The ceiling and floor may drive you insane</em>.
      </p>
      
      <p class="indenthanging2"><em>Good code to divide takes a Knuthian hero</em>,
      </p>
      
      <p class="indenthanging2b"><em>But even God can’t divide by zero!</em></p>
      
   </body>
   
</html>