<html xmlns="http://www.w3.org/1999/xhtml">
   
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      
      <title>Chapter 11. Some Elementary Functions</title>
      
      <link href="9780133085013.css" rel="stylesheet" type="text/css" />
      
      <link href="page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
      
      <meta content="urn:uuid:767ce45a-85bb-4273-91f5-801bab42906b" name="Adept.expected.resource" />
      
   </head>
   
   <body>
      
      <h2><a id="page_279"></a><a id="ch11"></a>Chapter 11. Some Elementary Functions
      </h2>
      
      <h3><a id="ch11lev1"></a><strong>11–1 Integer Square Root</strong></h3>
      
      <p class="noindent">By the “integer square root” function, we mean the function <span class="entity">⌊</span><span class="middle"><img alt="Image" src="graphics/446fig02.jpg" /></span><span class="entity">⌋</span>. To extend its range of application and to avoid deciding what to do with a negative
         argument, we assume <em>x</em> is unsigned. Thus, 0 ≤ <em>x</em> ≤ 2<sup>32</sup> – 1.
      </p>
      
      <h4><strong>Newton’s Method</strong></h4>
      
      <p class="noindent">For floating-point numbers, the square root is almost universally computed by Newton’s
         method. This method begins by somehow obtaining a starting estimate <em>g</em><sub>0</sub> of <span class="middle"><img alt="Image" src="graphics/root-a.jpg" /></span>. Then, a series of more accurate estimates is obtained from
      </p>
      
      <div class="image"><img alt="Image" src="graphics/279equ01.jpg" /></div>
      
      <p class="noindent">The iteration converges quadratically—that is, if at some point <em>g<sub>n</sub></em> is accurate to <em>n</em> bits, then <em>g</em><sub><em>n</em> + 1</sub> is accurate to 2<em>n</em> bits. The program must have some means of knowing when it has iterated enough so
         it can terminate.
      </p>
      
      <p class="indent">It is a pleasant surprise that Newton’s method works fine in the domain of integers.
         To see this, we need the following theorem:
      </p>
      
      <p class="indent">T<small>HEOREM</small>. <em>Let g</em><sub><em>n</em> + 1</sub> = <span class="entity">⌊</span>(<em>g<sub>n</sub></em> + <span class="entity">⌊</span><em>a</em> / <em>g<sub>n</sub></em><span class="entity">⌋</span>)/2<span class="entity">⌋</span>, with <em>g<sub>n</sub>, a integers greater than</em> 0. <em>Then</em><br /><img alt="Image" src="graphics/279equ02.jpg" /></p>
      
      <p class="indent">That is, if we have an integral guess <em>g<sub>n</sub></em> to <span class="entity">⌊</span><span class="middle"><img alt="Image" src="graphics/root-a.jpg" /></span><span class="entity">⌋</span> that is too high, then the next guess <em>g</em><sub><em>n</em> + 1</sub> will be strictly less than the preceding one, but not less than <span class="entity">⌊</span><span class="middle"><img alt="Image" src="graphics/root-a.jpg" /></span><span class="entity">⌋</span>. Therefore, if we start with a guess that’s too high, the sequence converges monotonically.
         If the guess <em>g<sub>n</sub></em> = <span class="entity">⌊</span><span class="middle"><img alt="Image" src="graphics/root-a.jpg" /></span><span class="entity">⌋</span>, then the next guess is either equal to <em>g<sub>n</sub></em> or is 1 larger. This provides an easy way to determine when the sequence has converged:
         If we start with <em>g<sub>0</sub></em> ≥ <span class="entity">⌊</span><span class="middle"><img alt="Image" src="graphics/root-a.jpg" /></span><span class="entity">⌋</span>, convergence has occurred when <em>g</em><sub><em>n</em> + 1</sub> ≥ <em>g<sub>n</sub></em>, and then the result is precisely <em>g<sub>n</sub></em>.
      </p>
      
      <p class="indent">The case <em>a</em> = 0 must be treated specially, because this procedure would lead to dividing 0 by
         0.
      </p>
      
      <p class="indent"><a id="page_280"></a><em>Proof</em>. (a) Because <em>g<sub>n</sub></em> is an integer,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/280equ01.jpg" /></div>
      
      <p class="indent">Because <em>g<sub>n</sub></em> <span class="entity"> &gt; ⌊</span><span class="middle"><img alt="Image" src="graphics/root-a.jpg" /></span><span class="entity">⌋</span> and <em>g<sub>n</sub></em> is an integer, <em>g<sub>n</sub></em> &gt; <span class="middle"><img alt="Image" src="graphics/root-a.jpg" /></span>. Define ε by <em>g<sub>n</sub></em> = (1 + ε)<span class="middle"><img alt="Image" src="graphics/root-a.jpg" /></span>. Then ε &gt; 0 and
      </p>
      
      <div class="image"><img alt="Image" src="graphics/280equ02.jpg" /></div>
      
      <p class="indent">(b) Because <em>g<sub>n</sub></em> = <span class="entity">⌊</span><span class="middle"><img alt="Image" src="graphics/root-a.jpg" /></span><span class="entity">⌋</span>, <span class="middle"><img alt="Image" src="graphics/root-a.jpg" /></span> – 1 &lt; <em>g<sub>n</sub></em> ≤ <span class="middle"><img alt="Image" src="graphics/root-a.jpg" /></span>, so that <span class="middle"><img alt="Image" src="graphics/280equ04.jpg" /></span>. Hence, we have
      </p>
      
      <div class="image"><img alt="Image" src="graphics/280equ03.jpg" /></div>
      
      <p class="indent">The difficult part of using Newton’s method to calculate <span class="entity">⌊</span><span class="middle"><img alt="Image" src="graphics/446fig02.jpg" /></span><span class="entity">⌋</span> is getting the first guess. The procedure of <a href="ch11.html#ch11fig1">Figure 11–1</a> sets the first guess <em>g</em><sub>0</sub> equal to the least power of 2 that is greater than or equal to <span class="middle"><img alt="Image" src="graphics/446fig02.jpg" /></span> For example, for <em>x</em> = 4, <em>g</em><sub>0</sub> = 2, and for <em>x</em> = 5, <em>g</em><sub>0</sub> = 4.
      </p>
      
      <p class="codelink"><a id="page_281"></a><a href="images10.html#p011fig01" id="p011fig01a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch11fig1"></a>int isqrt(unsigned x) {<br />  unsigned x1;<br />  int s, g0, g1;<br /><br />  if (x &lt;= 1) return x;<br />  s = 1;<br />  x1 = x - 1;<br />  if (x1 &gt; 65535) {s = s + 8; x1 = x1 &gt;&gt; 16;}<br />  if (x1 &gt; 255)   {s = s + 4; x1 = x1 &gt;&gt; 8;}<br />  if (x1 &gt; 15)    {s = s + 2; x1 = x1 &gt;&gt; 4;}<br />  if (x1 &gt; 3)     {s = s + 1;}<br /><br />  g0 = 1 <span class="entity">&lt;&lt;</span> s;               // g0 = 2**s.<br />  g1 = (g0 + (x &gt;&gt; s)) &gt;&gt; 1; // g1 = (g0 + x/g0)/2.<br /><br />  while (g1 &lt; g0) {          // Do while approximations<br />     g0 = g1;                // strictly decrease.<br />     g1 = (g0 + (x/g0)) &gt;&gt; 1;<br />  }<br />  return g0;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 11–1. Integer square root, Newton’s method.
      </p>
      
      <p class="indent">Because the first guess <em>g</em><sub>0</sub> is a power of 2, it is not necessary to do a real division to get <em>g</em><sub>1</sub>; instead, a <em>shift right</em> suffices.
      </p>
      
      <p class="indent">Because the first guess is accurate to about one bit, and Newton’s method converges
         quadratically (the number of bits of accuracy doubles with each iteration), one would
         expect the procedure to converge within about five iterations (on a 32-bit machine),
         which requires four divisions (because the first iteration substitutes a <em>shift right)</em>. An exhaustive experiment reveals that the maximum number of divisions is five, or
         four for arguments up to 16,785,407.
      </p>
      
      <p class="indent">If <em>number of leading zeros</em> is available, then getting the first guess is very simple: Replace the first seven
         executable lines in the procedure above with
      </p>
      
      <p class="codelink"><a href="images10.html#p281equ01" id="p281equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">if (x &lt;= 1) return x;<br />s = 16 - nlz(x - 1)/2;
      </p>
      
      <p class="indent">Another alternative, if <em>number of leading zeros</em> is not available, is to compute <em>s</em> by means of a binary search tree. This method permits getting a slightly better value
         of <em>g<sub>0</sub></em>: the least power of 2 that is greater than or equal to <span class="entity">⌊</span><span class="middle"><img alt="Image" src="graphics/446fig02.jpg" /></span><span class="entity">⌋</span>. For some values of <em>x</em>, this gives a smaller value of <em>g</em><sub>0</sub>, but a value large enough so that the convergence criterion of the theorem still
         holds. The difference in these schemes is illustrated in the following table.
      </p>
      
      <div class="image"><a id="page_282"></a> <img alt="Image" src="graphics/282tab01.jpg" /></div>
      
      <p class="indent">This procedure is shown in <a href="ch11.html#ch11fig2">Figure 11–2</a>. It is convenient there to treat small values of <em>x</em>(0 ≤ <em>x</em> ≤ 24) specially, so that no divisions are done for them.
      </p>
      
      <p class="codelink"><a href="images10.html#p011fig02" id="p011fig02a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch11fig2"></a>int isqrt(unsigned x) {<br />   int s, g0, g1;<br /><br />   if (x &lt;= 4224)<br />      if (x &lt;= 24)<br />         if (x &lt;= 3) return (x + 3) &gt;&gt; 2;<br />         else if (x &lt;= 8) return 2;<br />         else return (x &gt;&gt; 4) + 3;<br />      else if (x &lt;= 288)<br />         if (x &lt;= 80) s = 3; else s = 4;<br />      else if (x &lt;= 1088) s = 5; else s = 6;<br />   else if (x &lt;= 1025*1025 - 1)<br />      if (x &lt;= 257*257 - 1)<br />         if (x &lt;= 129*129 - 1) s = 7; else s = 8;<br />      else if (x &lt;= 513*513 - 1) s = 9; else s = 10;<br />   else if (x &lt;= 4097*4097 - 1)<br />      if (x &lt;= 2049*2049 - 1) s = 11; else s = 12;<br />   else if (x &lt;= 16385*16385 - 1)<br />      if (x &lt;= 8193*8193 - 1) s = 13; else s = 14;<br />   else if (x &lt;= 32769*32769 - 1) s = 15; else s = 16;<br />   g0 = 1 <span class="entity">&lt;&lt;</span> s;            // g0 = 2**s.<br /><br />   // Continue as in Figure 11–1.
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 11–2. Integer square root, binary search for first guess.
      </p>
      
      <p class="indent">The worst-case execution time of the algorithm of <a href="ch11.html#ch11fig1">Figure 11–1</a>, on the basic RISC, is about 26 + (<em>D</em> + 6) <em>n</em> cycles, where <em>D</em> is the divide time in cycles and <em>n</em> is <a id="page_283"></a>the number of times the <em>while</em>-loop is executed. The worst-case execution time of <a href="ch11.html#ch11fig2">Figure 11–2</a> is about 27 + (<em>D</em> + 6) <em>n</em> cycles, assuming (in both cases) that the <em>branch</em> instructions take one cycle. The table that follows gives the average number of times
         the loop is executed by the two algorithms, for <em>x</em> uniformly distributed in the indicated range.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/283tab01.jpg" /></div>
      
      <p class="indent">If we assume a divide time of 20 cycles and <em>x</em> ranging uniformly from 0 to 9999, then both algorithms execute in about 81 cycles.
      </p>
      
      <h4><strong>Binary Search</strong></h4>
      
      <p class="noindent">Because the algorithms based on Newton’s method start out with a sort of binary search
         to obtain the first guess, why not do the whole computation with a binary search?
         This method would start out with two bounds, perhaps initialized to 0 and 2<sup>16</sup>. It would make a guess at the midpoint of the bounds. If the square of the midpoint
         is greater than the argument <em>x</em>, then the upper bound is changed to be equal to the midpoint. If the square of the
         midpoint is less than the argument <em>x</em>, then the lower bound is changed to be equal to the midpoint. The process ends when
         the upper and lower bounds differ by 1, and the result is the lower bound.
      </p>
      
      <p class="indent">This avoids division, but requires quite a few multiplications—16 if 0 and 2<sup>16</sup> are used as the initial bounds. (The method gets one more bit of precision with each
         iteration.) <a href="ch11.html#ch11fig3">Figure 11–3</a> illustrates a variation of this procedure, which uses initial values for the bounds
         that are slight improvements over 0 and 2<sup>16</sup>. The procedure shown in <a href="ch11.html#ch11fig3">Figure 11–3</a> also saves a cycle in the loop, for most RISC machines, by altering <em>a</em> and <em>b</em> in such a way that the comparison is <em>b</em> ≥ <em>a</em> rather than <em>b</em> – <em>a</em> ≥ 1.
      </p>
      
      <p class="indent">The predicates that must be maintained at the beginning of each iteration are <em>a</em> ≤ <span class="entity">⌊</span><span class="middle"><img alt="Image" src="graphics/446fig02.jpg" /></span><span class="entity">⌋</span> + 1 and <em>b</em> <span class="entity">≥</span> <span class="entity">⌊</span><span class="middle"><img alt="Image" src="graphics/446fig02.jpg" /></span><span class="entity">⌋</span>. The initial value of <em>b</em> should be something that’s easy to compute and close to <span class="entity">⌊</span><span class="middle"><img alt="Image" src="graphics/446fig02.jpg" /></span><span class="entity">⌋</span>. Reasonable initial values are <em>x, x</em> ÷ 4 + 1, <em>x</em> ÷ 8 + 2, <em>x</em> ÷ 16 + 4, <em>x</em> ÷ 32 + 8, <em>x</em> ÷ 64 + 16, and so on. Expressions near the beginning of this list are better initial
         bounds for small <em>x</em>, and those near the end are better for larger <em>x</em>. (The value <em>x</em> ÷ 2 + 1 is acceptable, but probably not useful, because <em>x</em> ÷ 4 + 1 is everywhere a better or equal bound.)
      </p>
      
      <p class="codelink"><a id="page_284"></a><a href="images10.html#p011fig03" id="p011fig03a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch11fig3"></a>int isqrt(unsigned x) {<br />   unsigned a, b, m;       // Limits and midpoint.<br /><br />   a = 1;<br />   b = (x &gt;&gt; 5) + 8;       // See text.<br />   if (b &gt; 65535) b = 65535;<br />   do {<br />      m = (a + b) &gt;&gt; 1;<br />      if (m*m &gt; x) b = m - 1;<br />      else         a = m + 1;<br />   } while (b &gt;= a);<br />   return a - 1;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 11–3. Integer square root, simple binary search.
      </p>
      
      <p class="indent">Seven variations on the procedure shown in <a href="ch11.html#ch11fig3">Figure 11–3</a> can be more or less mechanically generated by substituting <em>a</em> + 1 for <em>a</em>, or <em>b</em> – 1 for <em>b</em>, or by changing <em>m</em> = (<em>a</em> + <em>b</em>) ÷ 2 to <em>m</em> = (<em>a</em> + <em>b</em> + 1) ÷ 2, or some combination of these substitutions.
      </p>
      
      <p class="indent">The execution time of the procedure shown in <a href="ch11.html#ch11fig3">Figure 11–3</a> is about 6 + (<em>M</em> + 7.5)<em>n</em>, where <em>M</em> is the multiplication time in cycles and <em>n</em> is the number of times the loop is executed. The following table gives the average
         number of times the loop is executed, for <em>x</em> uniformly distributed in the indicated range.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/284tab01.jpg" /></div>
      
      <p class="indent">If we assume a multiplication time of 5 cycles and <em>x</em> ranging uniformly from 0 to 9999, the algorithm runs in about 94 cycles. The maximum
         execution time (<em>n</em> = 16) is about 206 cycles.
      </p>
      
      <p class="indent">If <em>number of leading zeros</em> is available, the initial bounds can be set from
      </p>
      
      <p class="codelink"><a href="images10.html#p284equ01" id="p284equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">b = (1 <span class="entity">&lt;&lt;</span> (33 - nlz(x))/2) - 1;<br />a = (b + 3)/2;
      </p>
      
      <p class="noindent">That is, <span class="middle"><img alt="Image" src="graphics/284equ02.jpg" /></span>. These are very good bounds for small values of <em>x</em> (one loop iteration for 0 ≤ <em>x</em> ≤ 15), but only a moderate improvement, for large <em>x</em>, <a id="page_285"></a>over the bounds calculated in <a href="ch11.html#ch11fig3">Figure 11–3</a>. For <em>x</em> in the range 0 to 9999, the average number of iterations is about 5.45, which gives
         an execution time of about 74 cycles, using the same assumptions as above.
      </p>
      
      <h4><strong>A Hardware Algorithm</strong></h4>
      
      <p class="noindent">There is a shift-and-subtract algorithm for computing the square root that is quite
         similar to the hardware division algorithm described in <a href="ch09.html#ch09fig2">Figure 9–2</a> on page <a href="ch09.html#page_193">193</a>. Embodied in hardware on a 32-bit machine, this algorithm employs a 64-bit register
         that is initialized to 32 0-bits followed by the argument <em>x</em>. On each iteration, the 64-bit register is shifted left two positions, and the current
         result <em>y</em> (initially 0) is shifted left one position. Then 2<em>y</em> + 1 is subtracted from the left half of the 64-bit register. If the result of the
         subtraction is nonnegative, it replaces the left half of the 64-bit register, and
         1 is added to <em>y</em> (this does not require an adder, because <em>y</em> ends in 0 at this point). If the result of the subtraction is negative, then the
         64-bit register and <em>y</em> are left unaltered. The iteration is done 16 times.
      </p>
      
      <p class="indent">This algorithm was described in 1945 [JVN].</p>
      
      <p class="indent">Perhaps surprisingly, this process runs in about half the time of that of the 64 ÷
         32 ⇒ 32 hardware division algorithm cited, because it does half as many iterations
         and each iteration is about equally complex in the two algorithms.
      </p>
      
      <p class="indent">To code this algorithm in software, it is probably best to avoid the use of a doubleword
         shift register, which requires about four instructions to shift. The algorithm in
         <a href="ch11.html#ch11fig4">Figure 11–4</a> [GLS1] accomplishes this by shifting <em>y</em> and a mask bit <em>m</em> to the right. It executes in about 149 basic RISC instructions (average). The two
         expressions <code>y | m</code> could also be <code>y + m.</code></p>
      
      <p class="indent">The operation of this algorithm is similar to the grade-school method. It is illustrated
         here, for finding <span class="middle"><img alt="Image" src="graphics/285fig01.jpg" /></span> on an 8-bit machine.
      </p>
      
      <p class="codelink"><a href="images10.html#p285equ01" id="p285equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">  1011 0011 x0  Initially, x = 179 (0xB3).<br /> - 1        b1<br />   ________<br />  0111 0011 x1  0100 0000 y1<br /> - 101      b2  0010 0000 y2<br />   ________<br />  0010 0011 x2  0011 0000 y2<br /> - 11 01    b3  0001 1000 y3<br />   ________<br />  0010 0011 x3  0001 1000 y3   (Can’t subtract).<br /> -  1 1001  b4  0000 1100 y4<br />   ________<br />  0000 1010 x4  0000 1101 y4
      </p>
      
      <p class="noindent">The result is 13 with a remainder of 10 left in register <code>x</code>.
      </p>
      
      <p class="codelink"><a id="page_286"></a><a href="images10.html#p011fig04" id="p011fig04a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch11fig4"></a>int isqrt(unsigned x) {<br />   unsigned m, y, b;<br /><br />   m = 0x40000000;<br />   y = 0;<br />   while(m != 0) {               // Do 16 times.<br />      b = y | m;<br />      y = y &gt;&gt; 1;<br />      if (x &gt;= b) {<br />         x = x - b;<br />         y = y | m;<br />      }<br />      m = m &gt;&gt; 2;<br />   }<br />   return y;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 11–4. Integer square root, hardware algorithm.
      </p>
      
      <p class="indent">It is possible to eliminate the <code>if x &gt;= b</code> test by the usual trickery involving <em>shift right signed 31</em>. It can be proved that the high-order bit of <code>b</code> is always zero (in fact, <em>b</em> ≤ 5 · 2<sup>28</sup>), which simplifies the <code>x &gt;= b</code> predicate (see page <a href="ch02.html#page_23">23</a>). The result is that the <em>if</em> statement group can be replaced with
      </p>
      
      <p class="codelink"><a href="images10.html#p286equ01" id="p286equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1"><br />t = (int)(x | ~(x - b)) &gt;&gt; 31;   // -1 if x &gt;= b, else 0.<br />x = x - (b &amp; t);<br />y = y | (m &amp; t);
      </p>
      
      <p class="noindent">This replaces an average of three cycles with seven, assuming the machine has <em>or not</em>, but it might be worthwhile if a conditional branch in this context takes more than
         five cycles.
      </p>
      
      <p class="indent">Somehow it seems that it should be easier than some hundred cycles to compute an integer
         square root in software. Toward this end, we offer the expressions that follow to
         compute it for very small values of the argument. These can be useful to speed up
         some of the algorithms given above, if the argument is expected to be small.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/286tab01.jpg" /></div>
      
      <p class="indenthanging2"><a id="page_287"></a><em>Ah, the elusive square root</em>,
      </p>
      
      <p class="indenthanging2"><em>It should be a cinch to compute</em>.
      </p>
      
      <p class="indenthanging3"><em>But the best we can do</em></p>
      
      <p class="indenthanging3"><em>Is use powers of two</em></p>
      
      <p class="indenthanging2"><em>And iterate the method of Newt!</em></p>
      
      <h3><a id="ch11lev2"></a><strong>11–2 Integer Cube Root</strong></h3>
      
      <p class="noindent">For cube roots, Newton’s method does not work out very well. The iterative formula
         is a bit complex:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/287equ01.jpg" /></div>
      
      <p class="noindent">and there is of course the problem of getting a good starting value <em>x</em><sub>0</sub>.
      </p>
      
      <p class="indent">However, there is a hardware algorithm, similar to the hardware algorithm for square
         root, that is not too bad for software. It is shown in <a href="ch11.html#ch11fig5">Figure 11–5</a>.
      </p>
      
      <p class="indent">The three <em>add</em>’s of 1 can be replaced by <em>or</em>’s of 1, because the value being incremented is even. Even with this change, the algorithm
         is of questionable value for implementation in hardware, mainly because of the multiplication
         <strong><em>y</em></strong> * (<strong><em>y</em></strong> + 1).
      </p>
      
      <p class="indent">This multiplication is easily avoided by applying the compiler optimization of strength
         reduction to the <code>y</code>-squared term. Introduce another unsigned variable <code>y2</code> that will have the value of <code>y</code>-squared, by updating <code>y2</code> appropriately wherever <code>y</code> receives a new value. Just before <code>y = 0</code> insert <code>y2 = 0</code>. Just before <code>y = 2*y</code> insert <code>y2 = 4*y2.</code> Change the assignment to <code>b</code> to <code>b = (3*y2 + 3*y + 1) <span class="entity">&lt;&lt;</span> s</code> (and factor out the 3). Just before <code>y = y + 1</code>, insert <code>y2 = y2 + 2*y + 1</code>. The resulting program has no multiplications except by small constants, which can
         be changed to <em>shift</em>’s and <em>add</em>’s. This program has three <em>add</em>’s of 1, which can all be changed to <em>or</em>’s of 1. It is faster unless your machine’s <em>multiply</em> instruction takes only two or fewer cycles.
      </p>
      
      <p class="codelink"><a id="page_288"></a><a href="images10.html#p011fig05" id="p011fig05a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch11fig5"></a>int icbrt(unsigned x) {<br />   int s;<br />   unsigned y, b;<br /><br />   y = 0;<br />   for (s = 30; s &gt;= 0; s = s - 3) {<br />      y = 2*y;<br />      b = (3*y*(y + 1) + 1) <span class="entity">&lt;&lt;</span> s;<br />      if (x &gt;= b) {<br />         x = x - b;<br />         y = y + 1;<br />      }<br />   }<br />   return y;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 11–5. Integer cube root, hardware algorithm.
      </p>
      
      <p class="indent"><em>Caution:</em> [GLS1] points out that the code of <a href="ch11.html#ch11fig5">Figure 11–5</a>, and its strength-reduced derivative, do not work if adapted in the obvious way to
         a 64-bit machine. The assignment to <code>b</code> can then overflow. This problem can be avoided by dropping the <em>shift left</em> of <code>s</code> from the assignment to <code>b</code>, inserting after the assignment to <code>b</code> the assignment <code>bs = b <span class="entity">&lt;&lt;</span> s</code>, and changing the two lines <code>if (x &gt;= b) {x = x – b ...</code> to <code>if (x &gt;= bs &amp;&amp; b == (bs &gt;&gt; s)) {x = x – bs ....</code></p>
      
      <h3><a id="ch11lev3"></a><strong>11–3 Integer Exponentiation</strong></h3>
      
      <h4><strong>Computing <em>x<sup>n</sup></em> by Binary Decomposition of <em>n</em></strong></h4>
      
      <p class="noindent">A well-known technique for computing <em>x<sup>n</sup></em>, when <em>n</em> is a nonnegative integer, involves the binary representation of <em>n</em>. The technique applies to the evaluation of an expression of the form <em>x</em> · <em>x</em> · <em>x</em> · ... · <em>x</em> where · is any associative operation, such as addition, multiplication including
         matrix multiplication, and string concatenation (as suggested by the notation (‘ab’)<sup>3</sup> = ‘ababab’). As an example, suppose we wish to compute <em>y</em> = <em>x</em><sup>13</sup>. Because 13 expressed in binary is 1101 (that is, 13 = 8 + 4 + 1),
      </p>
      
      <p class="center"><em>x</em><sup>13</sup> = <em>x</em><sup>8 + 4 + 1</sup> = <em>x</em><sup>8</sup> · <em>x</em><sup>4</sup> · <em>x</em><sup>1</sup>.
      </p>
      
      <p class="indent">Thus, <em>x</em><sup>13</sup> can be computed as follows:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/288equ02.jpg" /></div>
      
      <p class="noindent"><a id="page_289"></a>This requires five multiplications, considerably fewer than the 12 that would be required
         by repeated multiplication by <em>x</em>.
      </p>
      
      <p class="indent">If the exponent is a variable, known to be a nonnegative integer, the technique can
         be employed in a subroutine, as shown in <a href="ch11.html#ch11fig6">Figure 11–6</a>.
      </p>
      
      <p class="indent">The number of multiplications done by this method is, for exponent <em>n</em> ≥ 1,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/289equ01.jpg" /></div>
      
      <p class="noindent">This is not always the minimal number of multiplications. For example, for <em>n</em> = 27, the binary decomposition method computes
      </p>
      
      <p class="center"><em>x</em><sup>16</sup> · <em>x</em><sup>8</sup> · <em>x</em><sup>2</sup> · <em>x</em><sup>1</sup>,
      </p>
      
      <p class="noindent">which requires seven multiplications. However, the scheme illustrated by</p>
      
      <p class="center">((<em>x</em><sup>3</sup>)<sup>3</sup>)<sup>3</sup></p>
      
      <p class="noindent">requires only six. The smallest number for which the binary decomposition method is
         not optimal is <em>n</em> = 15 (<em>Hint: x</em><sup>15</sup> = (<em>x</em><sup>3</sup>)<sup>5</sup>).
      </p>
      
      <p class="indent">Perhaps surprisingly, there is no known simple method that, for all <em>n</em>, finds an optimal sequence of multiplications to compute <em>x<sup>n</sup></em>. The only known methods involve an extensive search. The problem is discussed at
         some length in [Knu2, 4.6.3].
      </p>
      
      <p class="indent">The binary decomposition method has a variant that scans the binary representation
         of the exponent in left-to-right order [Rib, 32], which is analogous to the left-to-right
         method of converting binary to decimal. Initialize the result <em>y</em> to 1, and scan the exponent from left to right. When a 0 is encountered, square <em>y</em>. When a 1 is encountered, square <em>y</em> and multiply it by <em>x</em>. This computes <span class="middle"><img alt="Image" src="graphics/289equ05.jpg" /></span> as
      </p>
      
      <p class="center">(((1<sup>2</sup> · <em>x</em>)<sup>2</sup> · <em>x</em>)<sup>2</sup>)<sup>2</sup> · <em>x</em>.
      </p>
      
      <p class="codelink"><a href="images10.html#p011fig06" id="p011fig06a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch11fig6"></a>int iexp(int x, unsigned n) {<br />   int p, y;<br /><br />   y = 1;                   // Initialize result<br />   p = x;                   // and p.<br />   while(1) {<br />      if (n &amp; 1) y = p*y;   // If n is odd, mult by p.<br />      n = n &gt;&gt; 1;           // Position next bit of n.<br />      if (n == 0) return y; // If no more bits in n.<br />      p = p*p;              // Power for next bit of n.<br />   }<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 11–6. Computing <em>x<sup>n</sup></em> by binary decomposition of <em>n</em>.
      </p>
      
      <p class="noindent"><a id="page_290"></a>It always requires the same number of (nontrivial) multiplications as the right-to-left
         method of <a href="ch11.html#ch11fig6">Figure 11–6</a>.
      </p>
      
      <h4><strong>2<sup><em>n</em></sup> in Fortran</strong></h4>
      
      <p class="noindent">The IBM XL Fortran compiler takes the definition of this function to be</p>
      
      <div class="image"><img alt="Image" src="graphics/290equ01.jpg" /></div>
      
      <p class="indent">It is assumed that <em>n</em> and the result are interpreted as signed integers. The ANSI/ISO Fortran standard
         requires that the result be 0 if <em>n</em> &lt; 0. The definition above for <em>n</em> ≥ 31 seems reasonable in that it is the correct result modulo 2<sup>32</sup>, and it agrees with what repeated multiplication would give.
      </p>
      
      <p class="indent">The standard way to compute 2<em><sup>n</sup></em> is to put the integer 1 in a register and shift it left <em>n</em> places. This does not satisfy the Fortran definition, because shift amounts are usually
         treated modulo 64 or modulo 32 (on a 32-bit machine), which gives incorrect results
         for large or negative shift amounts.
      </p>
      
      <p class="indent">If your machine has <em>number of leading zeros</em>, pow2(<strong><em>n</em></strong>) can be computed in four instructions as follows [Shep]:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/290equ02.jpg" /></div>
      
      <p class="noindent">The <em>shift right</em> operations are “logical” (not sign-propagating), even though <em>n</em> is a signed quantity.
      </p>
      
      <p class="indent">If the machine does not have the nlz instruction, its use above can be replaced with
         one of the <strong><em>x</em></strong> = <strong>0</strong> tests given in “Comparison Predicates” on page <a href="ch02.html#page_23">23</a>, changing the expression <span class="middle"><img alt="Image" src="graphics/290equ04.jpg" /></span>. A possibly better method is to realize that the predicate <strong>0 ≤ <em>x</em> ≤ 31</strong> is equivalent to <span class="middle"><img alt="Image" src="graphics/290equ05.jpg" /></span> and then simplify the expression for <span class="middle"><img alt="Image" src="graphics/290equ06.jpg" /></span> given in the cited section; it becomes <strong>¬<em>x</em> &amp; (<em>x</em> – 32</strong>). This gives a solution in five instructions (four if the machine has <em>and not</em>):
      </p>
      
      <div class="image"><img alt="Image" src="graphics/290equ03.jpg" /></div>
      
      <h3><a id="page_291"></a><a id="ch11lev4"></a><strong>11–4 Integer Logarithm</strong></h3>
      
      <p class="noindent">By the “integer logarithm” function we mean the function <span class="entity">⌊</span>log<sub><em>b</em></sub> <em>x</em><span class="entity">⌋</span>, where <em>x</em> is a positive integer and <em>b</em> is an integer greater than or equal to 2. Usually, <em>b</em> = 2 or 10, and we denote these functions by “ilog2” and “ilog10,” respectively. We
         use “ilog” when the base is unspecified.
      </p>
      
      <p class="indent">It is convenient to extend the definition to <em>x</em> = 0 by defining ilog(0) = –1 [CJS]. There are several reasons for this definition:
      </p>
      
      <p class="indenthangingB">• The function ilog2(<em>x</em>) is then related very simply to the <em>number of leading zeros</em> function, nlz(<strong><em>x</em></strong>), by the formula shown below, including the case <em>x</em> = 0. Thus, if one of these functions is implemented in hardware or software, the
         other is easily obtained.
      </p>
      
      <p class="center">ilog2(<em>x</em>) = 31 – nlz(<em>x</em>)
      </p>
      
      <p class="indenthangingB">• It is easy to compute <span class="entity">⌈</span>log(<em>x</em>)<span class="entity">⌉</span> using the formula below. For <em>x</em> = 1, this formula implies that ilog(0) = –1.
      </p>
      
      <p class="center"><span class="entity">⌈</span>log(<em>x</em>)<span class="entity">⌉</span> = ilog(<em>x</em> – 1) + 1
      </p>
      
      <p class="indenthangingB">• It makes the following identity hold for <em>x</em> = 1 (but it doesn’t hold for <em>x</em> = 0).
      </p>
      
      <p class="center">ilog2(<em>x</em> ÷ 2) = ilog2(<em>x</em>) – 1
      </p>
      
      <p class="indenthangingB">• It makes the result of ilog(<em>x</em>) a small dense set of integers (–1 to 31 for ilog2(<em>x</em>) on a 32-bit machine, with <em>x</em> unsigned), making it directly useful for indexing a table.
      </p>
      
      <p class="indenthangingB">• It falls naturally out of several algorithms for computing ilog2(<em>x</em>) and ilog10(<em>x</em>).
      </p>
      
      <p class="indent">Unfortunately, it isn’t the right definition for “number of digits of <em>x</em>,” which is ilog(<em>x</em>) + 1 for all <em>x</em> except <em>x</em> = 0. It seems best to consider that anomalous.
      </p>
      
      <p class="noindent">For <em>x</em> &lt; 0, ilog(<em>x</em>) is left undefined. To extend its range of utility, we define the function as mapping
         unsigned numbers to signed numbers. Thus, a negative argument cannot occur.
      </p>
      
      <h4><strong>Integer Log Base 2</strong></h4>
      
      <p class="noindent">Computing ilog2(<em>x</em>) is essentially the same as computing the number of leading zeros, which is discussed
         in “Counting Leading 0’s” on page <a href="ch05.html#page_99">99</a>. All the algorithms in that section can be easily modified to compute ilog2(<em>x</em>) directly, rather than by computing nlz(<strong><em>x</em></strong>) and subtracting the result from 31. (For the algorithm of <a href="ch05.html#ch05fig16">Figure 5–16</a> on page <a href="ch05.html#page_102">102</a>, change the line <code>return pop(~x)</code> to <code>return pop(x) – 1.)</code></p>
      
      <h4><a id="page_292"></a><strong>Integer Log Base 10</strong></h4>
      
      <p class="noindent">This function has application in converting a number to decimal for inclusion into
         a line with leading zeros suppressed. The conversion process successively divides
         by 10, producing the least significant digit first. It would be useful to know ahead
         of time where the least significant digit should be placed, to avoid putting the converted
         number in a temporary area and then moving it.
      </p>
      
      <p class="indent">To compute ilog10(<em>x</em>), a table search is quite reasonable. This could be a binary search, but because
         the table is small and in many applications <em>x</em> is usually small, a simple linear search is probably best. This rather straightforward
         program is shown in <a href="ch11.html#ch11fig7">Figure 11–7</a>.
      </p>
      
      <p class="indent">On the basic RISC, this program can be implemented to execute in about 9 + 4 <span class="entity">⌊</span>log<sub>10</sub><em>x</em><span class="entity">⌋</span> instructions. Thus, it executes in five to 45 instructions, with perhaps 13 (for
         10 ≤ <em>x</em> ≤ 99) being typical.
      </p>
      
      <p class="indent">The program in <a href="ch11.html#ch11fig7">Figure 11–7</a> can easily be changed into an “in register” version (not using a table). The executable
         part of such a program is shown in <a href="ch11.html#ch11fig8">Figure 11–8</a>. This might be useful if the machine has a fast way to multiply by 10.
      </p>
      
      <p class="codelink"><a href="images10.html#p011fig07" id="p011fig07a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch11fig7"></a>int ilog10(unsigned x) {<br />   int i;<br />   static unsigned table[11] = {0, 9, 99, 999, 9999,<br />      99999, 999999, 9999999, 99999999, 999999999,<br />      0xFFFFFFFF};<br /><br />   for (i = -1; ; i++) {<br />      if (x &lt;= table[i+1]) return i;<br />   }<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 11–7. Integer log base 10, simple table search.
      </p>
      
      <p class="codelink"><a href="images10.html#p011fig08" id="p011fig08a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch11fig8"></a>   p = 1;<br />   for (i = -1; i &lt;= 8; i++) {<br />      if (x &lt; p) return i;<br />      p = 10*p;<br />   }<br />   return i;
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 11–8. Integer log base 10, repeated multiplication by 10.
      </p>
      
      <p class="indent">This program can be implemented to execute in about 10 + 6 <span class="entity">⌊</span>log<sub>10</sub><em>x</em><span class="entity">⌋</span> instructions on the basic RISC (counting the <em>multiply</em> as one instruction). This amounts to 16 instructions for 10 ≤ <em>x</em> ≤ 99.
      </p>
      
      <p class="indent">A binary search can be used, giving an algorithm that is loop-free and does not use
         a table. Such an algorithm might compare <em>x</em> to 10<sup>4</sup>, then to either 10<sup>2</sup> or to 10<sup>6</sup>, and so on, until the exponent <em>n</em> is found such that 10<em><sup>n</sup></em> ≤ <em>x</em> &lt; 10<sup><em>n</em> + 1</sup>. The paths execute in ten to 18 instructions, four or five of which are branches
         (counting the final unconditional branch).
      </p>
      
      <p class="indent"><a id="page_293"></a>The program shown in <a href="ch11.html#ch11fig9">Figure 11–9</a> is a modification of the binary search that has a maximum of four branches on any
         path and is written in a way that favors small <em>x</em>. It executes in six basic RISC instructions for 10 ≤ <em>x</em> ≤ 99, and in 11 to 16 instructions for <em>x</em> ≥ 100.
      </p>
      
      <p class="indent">The <em>shift</em> instructions in this program are <em>signed</em> shifts (which is the reason for the <code>(int)</code> casts). If your machine does not have this instruction, one of the alternatives below,
         which use unsigned shifts, may be preferable. These are illustrated for the case of
         the first <code>return</code> statement. Unfortunately, the first two require <em>subtract from immediate</em> for efficient implementation, which most machines don’t have. The last involves adding
         a large constant (two instructions), but this does not matter for the second and third
         <code>return</code> statements, which require adding a large constant anyway. The large constant is 2<sup>31</sup> – 1000.
      </p>
      
      <p class="codelink"><a href="images10.html#p293equ01" id="p293equ01a">Click here to view code image</a></p>
      
      <p class="programlisting1">return 3 - ((x - 1000) &gt;&gt; 31);<br />return 2 + ((999 - x) &gt;&gt; 31);<br />return 2 + ((x + 2147482648) &gt;&gt; 31);
      </p>
      
      <p class="indent">An alternative for the fourth <code>return</code> statement is
      </p>
      
      <p class="codelink"><a href="images10.html#p293equ02" id="p293equ02a">Click here to view code image</a></p>
      
      <p class="programlisting1">return 8 + ((x + 1147483648) | x) &gt;&gt; 31;</p>
      
      <p class="noindent">where the large constant is 2<sup>31</sup> – 10<sup>9</sup>. This avoids both the <em>and not</em> and the signed shift.
      </p>
      
      <p class="indent">Alternatives for the last <em>if-else</em> construction are
      </p>
      
      <p class="codelink"><a href="images10.html#p293equ03" id="p293equ03a">Click here to view code image</a></p>
      
      <p class="programlisting1">return ((int)(x - 1) &gt;&gt; 31) | ((unsigned)(9 - x) &gt;&gt; 31);<br />return (x &gt; 9) + (x &gt; 0) - 1;
      </p>
      
      <p class="noindent">either of which saves a branch.</p>
      
      <p class="codelink"><a href="images10.html#p11fig09" id="p11fig09a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch11fig9"></a>int ilog10(unsigned x) {<br />   if (x &gt; 99)<br />      if (x &lt; 1000000)<br />         if (x &lt; 10000)<br />            return 3 + ((int)(x - 1000) &gt;&gt; 31);<br />         else<br />            return 5 + ((int)(x - 100000) &gt;&gt; 31);<br />      else<br />         if (x &lt; 100000000)<br />            return 7 + ((int)(x - 10000000) &gt;&gt; 31);<br />         else<br />            return 9 + ((int)((x-1000000000)&amp;~x) &gt;&gt; 31);<br />   else<br />      if (x &gt; 9) return 1;<br />      else       return ((int)(x - 1) &gt;&gt; 31);<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 11–9. Integer log base 10, modified binary search.
      </p>
      
      <p class="indent"><a id="page_294"></a>If nlz(<strong><em>x</em></strong>) or ilog2(<em>x</em>) is available as an instruction, there are better and more interesting ways to compute
         ilog10(<em>x</em>). For example, the program in <a href="ch11.html#ch11fig10">Figure 11–10</a> does it in two table lookups [CJS].
      </p>
      
      <p class="indent">From <code>table1</code> an approximation to ilog10(<em>x</em>) is obtained. The approximation is usually the correct value, but it is too high
         by 1 for <em>x</em> = 0 and for <em>x</em> in the range 8 to 9, 64 to 99, 512 to 999, 8192 to 9999, and so on. The second table
         gives the value below which the estimate must be corrected by subtracting 1.
      </p>
      
      <p class="indent">This scheme uses a total of 73 bytes for tables and can be coded in only six instructions
         on the IBM System/370 [CJS] (to achieve this, the values in <code>table1</code> must be four times the values shown). It executes in about ten instructions on a
         RISC that has <em>number of leading zeros</em>, but no other uncommon instructions. The other methods to be discussed are variants
         of this.
      </p>
      
      <p class="indent">The first variation eliminates the conditional branch that results from the <em>if</em> statement. Actually, the program in <a href="ch11.html#ch11fig10">Figure 11–10</a> can be coded free of branches if the machine has the <em>set less than unsigned</em> instruction, but the method to be described can be used on machines that have no
         unusual instructions (other than <em>number of leading zeros</em>).
      </p>
      
      <p class="indent">The method is to replace the <em>if</em> statement with a subtraction followed by a <em>shift right</em> of 31, so that the sign bit can be subtracted from <em>y</em>. A difficulty occurs for large <em>x</em>(<em>x</em> ≥ 2<sup>31</sup> + 10<sup>9</sup>), which can be fixed by adding an entry to <code>table2</code>, as shown in <a href="ch11.html#ch11fig11">Figure 11–11</a>.
      </p>
      
      <p class="indent">This executes in about 11 instructions on a RISC that has <em>number of leading zeros</em> but is otherwise quite “basic.” It can be modified to return the value 0, rather
         than –1, for <em>x</em> = 0 (which is preferable for the decimal conversion problem) by changing the last
         entry in <code>table1</code> to 1 (that is, by changing “0, 0, 0, 0” to “0, 0, 0, 1”).
      </p>
      
      <p class="codelink"><a href="images10.html#p11fig10" id="p11fig10a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch11fig10"></a>int ilog10(unsigned x) {<br />   int y;<br />   static unsigned char table1[33] = {9, 9, 9, 8, 8, 8,<br />       7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3, 3,<br />       2, 2, 2, 1, 1, 1, 0, 0, 0, 0};<br />   static unsigned table2[10] = { 1, 10, 100, 1000, 10000,<br />       100000, 1000000, 10000000, 100000000, 1000000000};<br /><br />   y = table1[nlz(x)];<br />   if (x &lt; table2[y]) y = y - 1;<br />   return y;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 11–10. Integer log base 10 from log base 2, double table lookup.
      </p>
      
      <p class="indent">The next variation replaces the first table lookup with a subtraction, a multiplication,
         and a shift. This seems likely to be possible because log<sub>10</sub><em>x</em> and log<sub>2</sub><em>x</em> are related by a multiplicative constant, namely log<sub>10</sub>2 = 0.30103.... Thus, it <a id="page_295"></a>may be possible to compute ilog10(<em>x</em>) by computing <span class="entity">⌊</span><em>c</em> ilog2(<em>x</em>)<span class="entity">⌋</span> for some suitable <em>c</em> ≈ 0.30103, and correcting the result by using a table such as <code>table2</code> in <a href="ch11.html#ch11fig11">Figure 11–11</a>.
      </p>
      
      <p class="codelink"><a href="images10.html#p11fig11" id="p11fig11a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch11fig11"></a>int ilog10(unsigned x) {<br />   int y;<br />   static unsigned char table1[33] = {10, 9, 9, 8, 8, 8,<br />       7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3, 3,<br />       2, 2, 2, 1, 1, 1, 0, 0, 0, 0};<br />   static unsigned table2[11] = {1, 10, 100, 1000, 10000,<br />       100000, 1000000, 10000000, 100000000, 1000000000,<br />       0};<br /><br />   y = table1[nlz(x)];<br />   y = y - ((x - table2[y]) &gt;&gt; 31);<br />   return y;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 11–11. Integer log base 10 from log base 2, double table lookup, branch free.
      </p>
      
      <p class="indent">To pursue this, let log<sub>10</sub>2 = <em>c</em> + ε, where <em>c</em> &gt; 0 is a rational approximation to log<sub>10</sub>2 that is a convenient multiplier, and ε &gt; 0. Then, for <em>x</em> ≥ 1,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/295equ01.jpg" /></div>
      
      <p class="indent">Thus, if we choose <em>c</em> so that <em>c</em> + εlog<sub>2</sub><em>x</em> &lt; 1, then <span class="entity">⌊</span><em>c</em> ilog2(<em>x</em>)<span class="entity">⌋</span> approximates ilog10(<em>x</em>) with an error of 0 or +1. Furthermore, if we take ilog2(0) = ilog10(0) = – 1, then
         <span class="entity">⌊</span><em>c</em> ilog2(0)<span class="entity">⌋</span> = ilog10(0) (because 0 &lt; <em>c</em> ≤ 1), so we need not be concerned about this case. (There are other definitions that
         would work here, such as ilog2(0) = ilog10(0) = 0.)
      </p>
      
      <p class="indent">Because ε = log<sub>10</sub>2 – <em>c</em>, we must choose <em>c</em> so that
      </p>
      
      <div class="image"><img alt="Image" src="graphics/295equ02.jpg" /></div>
      
      <p class="noindent">This is satisfied for <em>x</em> = 1 (because <em>c</em> &lt; 1) and 2. For larger <em>x</em>, we must have
      </p>
      
      <div class="image"><img alt="Image" src="graphics/295equ03.jpg" /></div>
      
      <p class="noindent"><a id="page_296"></a>The most stringent requirement on <em>c</em> occurs when <em>x</em> is large. For a 32-bit machine, <em>x</em> &lt; 2<sup>32</sup>, so choosing
      </p>
      
      <div class="image"><img alt="Image" src="graphics/296equ01.jpg" /></div>
      
      <p class="noindent">suffices. Because <em>c</em> &lt; 0.30103 (because ε &gt; 0), <em>c</em> = 9/32 = 0.28125 is a convenient value. Experimentation reveals that coarser values
         such as 5/16 and 1/4 are not adequate.
      </p>
      
      <p class="indent">This leads to the scheme illustrated in <a href="ch11.html#ch11fig12">Figure 11–12</a>, which estimates low and then corrects by adding 1. It executes in about 11 instructions
         on a RISC that has <em>number of leading zeros</em>, counting the <em>multiply</em> as one instruction.
      </p>
      
      <p class="indent">This can be made into a branch-free version, but again there is a difficulty with
         large <em>x</em>(<em>x</em> &gt; 2<sup>31</sup> + 10<sup>9</sup>), which can be fixed in either of two ways. One way is to use a different multiplier
         (19/64) and a slightly expanded table. The program is shown in <a href="ch11.html#ch11fig13">Figure 11–13</a> (about 11 instructions on a RISC that has <em>number of leading zeros</em>, counting the <em>multiply</em> as one instruction).
      </p>
      
      <p class="indent">The other “fix” is to <em>or x</em> into the result of the subtraction to force the sign bit to be on for <em>x</em> ≥ 2<sup>31</sup>; that is, change the second executable line of <a href="ch11.html#ch11fig12">Figure 11–12</a> to
      </p>
      
      <p class="codelink"><a href="images10.html#p296equ02" id="p296equ02a">Click here to view code image</a></p>
      
      <p class="programlisting1">y = y + (((table2[y+1] - x) | x) &gt;&gt; 31);</p>
      
      <p class="noindent">This is the preferable program if multiplication by 19 is substantially more difficult
         than multiplication by 9 (as it is for a <em>shift-</em>and-<em>add</em> sequence).
      </p>
      
      <p class="codelink"><a href="images10.html#p11fig12" id="p11fig12a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch11fig12"></a>   static unsigned table2[10] = {0, 9, 99, 999, 9999, 99999,<br />      999999, 9999999, 99999999, 999999999};<br /><br />   y = (9*(31 - nlz(x))) &gt;&gt; 5;<br />   if (x &gt; table2[y+1]) y = y + 1;<br />   return y;
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 11–12. Integer log base 10 from log base 2, one table lookup.
      </p>
      
      <p class="codelink"><a href="images10.html#p11fig13" id="p11fig13a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch11fig13"></a>int ilog10(unsigned x) {<br />   int y;<br />   static unsigned table2[11] = {0, 9, 99, 999, 9999,<br />       99999, 999999, 9999999, 99999999, 999999999,<br />       0xFFFFFFFF};<br /><br />   y = (19*(31 - nlz(x))) &gt;&gt; 6;<br />   y = y + ((table2[y + 1] - x) &gt;&gt; 31);<br />   return y;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 11–13. Integer log base 10 from log base 2, one table lookup, branch free.
      </p>
      
      <p class="indent"><a id="page_297"></a>For a 64-bit machine, choosing
      </p>
      
      <div class="image"><img alt="Image" src="graphics/297equ01.jpg" /></div>
      
      <p class="noindent">suffices. The value 19/64 = 0.296875 is convenient, and experimentation reveals that
         no coarser value is adequate. The program is (branch-free version)
      </p>
      
      <p class="codelink"><a href="images10.html#p297equ02" id="p297equ02a">Click here to view code image</a></p>
      
      <p class="programlisting1">unsigned table2[20] = {0, 9, 99, 999, 9999, ...,<br />   9999999999999999999};<br />y = ((19*(63 - nlz(x)) &gt;&gt; 6;<br />y = y + ((table2[y + 1] - x) &gt;&gt; 63;<br />return y;
      </p>
      
      <h4><strong>Exercises</strong></h4>
      
      <p class="question"><a href="ch19_answer.html#ch11ans1" id="ch11ansa1"><strong>1</strong>.</a> Is the correct integer fourth root of an integer <em>x</em> obtained by computing the integer square root of the integer square root of <em>x</em>? That is, does
      </p>
      
      <div class="image"><img alt="Image" src="graphics/297equ03.jpg" /></div>
      
      <p class="question"><a href="ch19_answer.html#ch11ans2" id="ch11ansa2"><strong>2</strong>.</a> Code the 64-bit version of the cube root routine that is mentioned at the end of
         <a href="ch11.html#ch11lev2">Section 11–2</a>. Use the “long long” C data type. Do you see an alternative method for handling the
         overflow of <code>b</code> that probably results in a faster routine?
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch11ans3" id="ch11ansa3"><strong>3</strong>.</a> How many multiplications does it take to compute <em>x</em><sup>23</sup> (modulo <em>2<sup>W</sup></em>, where <em>W</em> is the computer’s word size)?
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch11ans4" id="ch11ansa4"><strong>4</strong>.</a> Describe in simple terms the functions (a) 2<sup>ilog2(<em>x</em>)</sup> and (b) 2<sup>ilog2(<em>x</em> – 1) + 1</sup> for <em>x</em> an integer greater than 0.<a id="page_298"></a></p>
      
   </body>
   
</html>