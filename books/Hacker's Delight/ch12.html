<html xmlns="http://www.w3.org/1999/xhtml">
   
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      
      <title>Chapter 12. Unusual Bases for Number Systems</title>
      
      <link href="9780133085013.css" rel="stylesheet" type="text/css" />
      
      <link href="page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
      
      <meta content="urn:uuid:767ce45a-85bb-4273-91f5-801bab42906b" name="Adept.expected.resource" />
      
   </head>
   
   <body>
      
      <h2><a id="page_299"></a><a id="ch12"></a>Chapter 12. Unusual Bases for Number Systems
      </h2>
      
      <p class="indent">This section discusses a few unusual positional number systems. They are just interesting
         curiosities and are probably not practical for anything. We limit the discussion to
         integers, but they can all be extended to include digits after the radix point—which
         usually, but not always, denotes non-integers.
      </p>
      
      <h3><a id="ch12lev1"></a><strong>12–1 Base –2</strong></h3>
      
      <p class="noindent">By using –2 as the base, both positive and negative integers can be expressed without
         an explicit sign or other irregularity, such as having a negative weight for the most
         significant bit (Knu3). The digits used are 0 and 1, as in base +2; that is, the value
         represented by a string of 1’s and 0’s is understood to be
      </p>
      
      <p class="center">(<em>a<sub>n</sub></em>...<em>a</em><sub>3</sub><em>a</em><sub>2</sub><em>a</em><sub>1</sub><em>a</em><sub>0</sub>) = <em>a<sub>n</sub></em>(–2)<sup><em>n</em></sup> + ... + <em>a</em><sub>3</sub>(–2)<sup>3</sup> + <em>a</em><sub>2</sub>(–2)<sup>2</sup> + <em>a</em><sub>1</sub>(–2) + <em>a</em><sub>0</sub>.
      </p>
      
      <p class="indent">From this, it can be seen that a procedure for finding the base −2, or “negabinary,”
         representation of an integer is to successively divide the number by −2, recording
         the remainders. The division must be such that it always gives a remainder of 0 or
         1 (the digits to be used); that is, it must be modulus division. As an example, the
         plan below shows how to find the base −2 representation of –3.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/299equ02.jpg" /></div>
      
      <p class="noindent">Because we have reached a 0 quotient, the process terminates (if continued, the remaining
         quotients and remainders would all be 0). Thus, reading the remainders upward, we
         see that –3 is written 1101 in base –2.
      </p>
      
      <p class="indent">Table 12–1 shows, on the left, how each bit pattern from 0000 to 1111 is interpreted
         in base –2, and on the right, how integers in the range –15 to +15 are represented.
      </p>
      
      <p class="tab-caption"><a id="page_300"></a><a id="ch12tab1"></a>T<small>ABLE</small> 12–1. C<small>ONVERSIONS BETWEEN</small> D<small>ECIMAL AND</small> B<small>ASE–2</small></p>
      
      <div class="image"><img alt="Image" src="graphics/12tab01.jpg" /></div>
      
      <p class="indent">It is not obvious that the 2<sup><em>n</em></sup> possible bit patterns in an <em>n</em>-bit word uniquely represent all integers in a certain range, but this can be shown
         by induction. The inductive hypothesis is that an <em>n</em>-bit word represents all integers in the range
      </p>
      
      <div class="image"><img alt="Image" src="graphics/12equ01a.jpg" /></div>
      
      <div class="image"><img alt="Image" src="graphics/12equ01b.jpg" /></div>
      
      <p class="indent">Assume first that <em>n</em> is even. For <em>n</em> = 2, the representable integers are 10, 11, 00, and 01 in base –2, or
      </p>
      
      <p class="center">–2, –1, 0, 1.</p>
      
      <p class="noindent">This agrees with (1a), and each integer in the range is represented once and only
         once.
      </p>
      
      <p class="indent">A word of <em>n</em> + 1 bits can, with a leading bit of 0, represent all the integers given by (1a).
         In addition, with a leading bit of 1, it can represent all these integers biased by
         (–2)<sup><em>n</em></sup> = 2<sup><em>n</em></sup>. The new range is
      </p>
      
      <p class="center">2<sup><em>n</em></sup> − (2<sup><em>n</em> + 1</sup> – 2) / 3 to 2<sup><em>n</em></sup> + (2<sup><em>n</em></sup>– 1)/3,
      </p>
      
      <p class="noindent"><a id="page_301"></a>or
      </p>
      
      <p class="center">(2<sup><em>n</em></sup>−1)/3 + 1 to (2<sup><em>n</em> +2</sup> − 1)/3.
      </p>
      
      <p class="noindent">This is contiguous to the range given by (1a), so for a word size of <em>n</em> + 1 bits, all integers in the range
      </p>
      
      <p class="center">−(2<sup><em>n</em> + 1</sup> − 2)/3 to (2<sup><em>n</em> + 2</sup> − 1)/3
      </p>
      
      <p class="noindent">are represented once and only once. This agrees with (1b), with <em>n</em> replaced by <em>n</em> + 1.
      </p>
      
      <p class="indent">The proof that (1a) follows from (1b), for <em>n</em> odd, and that all integers in the range are uniquely represented, is similar.
      </p>
      
      <p class="indent">To add and subtract, the usual rules, such as 0 + 1 = 1 and 1 – 1 = 0, of course apply.
         Because 2 is written 110, and –1 is written 11, and so on, the following additional
         rules apply. These, together with the obvious ones, suffice.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/301equ01.jpg" /></div>
      
      <p class="indent">When adding or subtracting, there are sometimes two carry bits. The carry bits are
         to be <em>added</em> to their column, even when subtracting. It is convenient to place them both over
         the next bit to the left and simplify (when possible) using 11 + 1 = 0. If 11 is carried
         to a column that contains two 0’s, bring down a 1 and carry a 1. Below are examples.
      </p>
      
      <p class="codelink"><a href="images11.html#p301fig02" id="p301fig02a">Click here to view code image</a></p>
      
      <p class="programlisting1">        Addition                     Subtraction<br />  11 1 11    11                1 11  1     1<br />     1  0  1  1  1    19             1  0  1  0  1     21<br /> + 1 1  0  1  0  1 +(-11)        -1  0  1  1  1  0  -(-38)<br /> ----------------- ------         ----------------  -----<br />  0  1  1  0  0  0     8       1  0  0  1  1  1  1     59
      </p>
      
      <p class="indent">The only carries possible are 0, 1, and 11. Overflow occurs if there is a carry (either
         1 or 11) out of the high-order position. These remarks apply to both addition and
         subtraction.
      </p>
      
      <p class="indent">Because there are three possibilities for the carry, a base –2 adder would be more
         complex than a two’s-complement adder.
      </p>
      
      <p class="indent">There are two ways to negate an integer. It can be added to itself shifted left one
         position (that is, multiply by –1), or it can be subtracted from 0. There is no rule
         as simple and convenient as the “complement and add 1” rule of two’s-complement arithmetic.
         In two’s-complement, this rule is used to build a subtracter from an adder (to compute
         <strong><em>A</em></strong> – <strong><em>B</em></strong>, form <span class="middle"><img alt="Image" src="graphics/301fig01.jpg" /></span>).
      </p>
      
      <p class="indent"><a id="page_302"></a>For base –2, there is no device quite that simple, but a method that is nearly as
         simple is to complement the minuend (meaning to invert each bit), add the complemented
         minuend to the subtrahend, and then complement the sum [Lang]. Here is an example
         showing the subtraction of 13 from 6 using this scheme on an eight-bit machine.
      </p>
      
      <p class="codelink"><a href="images11.html#p302fig01" id="p302fig01a">Click here to view code image</a></p>
      
      <p class="programlisting1">00011010   6<br />00011101   13<br />11100101   6 complemented<br />--------<br />11110110   (6 complemented) + 13<br />00001001   Complement of the sum (-7)
      </p>
      
      <p class="noindent">This method is using</p>
      
      <p class="center"><strong><em>A</em></strong> − <strong><em>B</em></strong> = <strong><em>I</em></strong> − ((<strong><em>I</em></strong>−<strong><em>A</em></strong>)+<strong><em>B</em></strong>)
      </p>
      
      <p class="noindent">in base –2 arithmetic, with <strong><em>I</em></strong> a word of all 1’s.
      </p>
      
      <p class="indent">Multiplication of base –2 integers is straightforward. Just use the rule that 1 ×
         1 = 1 and 0 times either 0 or 1 is 0, and add the columns using base –2 addition.
      </p>
      
      <p class="indent">Division, however, is quite complicated. It is a real challenge to devise a reasonable
         hardware division algorithm—that is, one based on repeated subtraction and shifting.
         <a href="ch12.html#ch12fig1">Figure 12–1</a> shows an algorithm that is expressed, for definiteness, for an 8-bit machine. It
         does modulus division (nonnegative remainder).
      </p>
      
      <p class="indent">Although this program is written in C and was tested on a binary two’s-complement
         machine, that is immaterial—it should be viewed somewhat abstractly. The input quantities
         <code>n</code> and <code>d</code>, and all internal variables except for <code>q</code>, are simply numbers without any particular representation. The output <code>q</code> is a string of bits to be interpreted in base –2.
      </p>
      
      <p class="indent">This requires a little explanation. If the input quantities were in base –2, the algorithm
         would be very awkward to express in an executable form. For example, the test “<code>if (d &gt; 0</code>)” would have to test that the most significant bit of <code>d</code> is in an even position. The addition in “<code>c = c + d</code>” would have to be a base –2 addition. The code would be very hard to read. The way
         the algorithm is coded, you should think of <code>n</code> and <code>d</code> as numbers without any particular representation. The code shows the arithmetic operations
         to be performed, whatever encoding is used. If the numbers are encoded in base –2,
         as they would be in hardware that implements this algorithm, the multiplication by
         –128 is a left shift of seven positions, and the divisions by –2 are right shifts
         of one position.
      </p>
      
      <p class="indent">As examples, the code computes values as follows:</p>
      
      <p class="indent2">divbm2(6, 2) = 7 (six divided by two is 111<sub>–2</sub>)
      </p>
      
      <p class="indent2">divbm2(– 4, 3) = 2 (minus four divided by three is 10<sub>–2</sub>)
      </p>
      
      <p class="indent2">divbm2(–4, –3) = 6 (minus four divided by minus 3 is 110<sub>–2</sub>)
      </p>
      
      <p class="codelink"><a id="page_303"></a><a href="images11.html#p12fig01" id="p12fig01a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch12fig1"></a>int divbm2(int n, int d) {          // q = n/d in base -2.<br />   int r, dw, c, q, i;<br /><br />   r = n;                          // Init. remainder.<br />   dw = (-128)*d;                  // Position d.<br />   c = (-43)*d;                    // Init. comparand.<br />   if (d &gt; 0) c = c + d;<br />   q = 0;                          // Init. quotient.<br />   for (i = 7; i &gt;= 0; i--) {<br />      if (d &gt; 0 ^ (i&amp;1) == 0 ^ r &gt;= c {<br />         q = q | (1 <span class="entity">&lt;&lt;</span> i);         // Set a quotient bit.<br />         r = r - dw;               // Subtract d shifted.<br />      }<br />      dw = dw/(-2);                // Position d.<br />      if (d &gt; 0) c = c -2*d;       // Set comparand for<br />      else c = c + d;              // next iteration.<br />      c = c/(-2);<br />   }<br />   return q;                       // Return quotient in<br />                                   // base -2.<br />                                   // Remainder is r,<br />}                                  // 0 &lt;= r &lt; |d|.
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 12-1. Division in base –2.
      </p>
      
      <p class="noindent">The step <code>q = q | (1 <span class="entity">&lt;&lt;</span> i);</code> represents simply setting bit <em>i</em> of <code>q</code>. The next line—<code>r = r - dw</code>—represents reducing the remainder by the divisor <code>d</code> shifted left.
      </p>
      
      <p class="indent">The algorithm is difficult to describe in detail, but we will try to give the general
         idea.
      </p>
      
      <p class="indent">Consider determining the value of the first bit of the quotient, bit 7 of <code>q</code>. In base −2, 8-bit numbers that have their most significant bit “on” range in value
         from −170 to −43. Therefore, ignoring the possibility of overflow, the first (most
         significant) quotient bit will be 1 if (and only if) the quotient will be algebraically
         less than or equal to –43.
      </p>
      
      <p class="indent">Because <em>n</em> = <em>qd</em> + <em>r</em> and for a positive divisor <em>r</em> ≤ <em>d</em> − 1, for a positive divisor the first quotient bit will be 1 iff <em>n</em> ≤ − 43<em>d</em> + (<em>d</em> − 1), or <em>n</em> &lt; − 43<em>d</em> + <em>d</em>. For a negative divisor, the first quotient bit will be 1 iff <em>n</em> ≥ −43<em>d</em> (<em>r</em> ≥ 0 for modulus division).
      </p>
      
      <p class="indent">Thus, the first quotient bit is 1 iff</p>
      
      <p class="center">(<em>d</em> &gt; 0 &amp; ¬(<em>n</em> ≥ −43<em>d</em> + <em>d</em>)) | (<em>d</em> &lt; 0 &amp; <em>n</em> ≥ −43<em>d</em>).
      </p>
      
      <p class="noindent">Ignoring the possibility that <em>d</em> = 0, this can be written as
      </p>
      
      <p class="center"><em>d</em>&gt;0 ⊕ <em>n</em> ≥ <em>c</em>,
      </p>
      
      <p class="noindent">where <em>c</em> = −43<em>d</em> + <em>d</em> if <em>d</em> ≥ 0, and <em>c</em> = −43<em>d</em> if <em>d</em> &lt; 0.
      </p>
      
      <p class="indent"><a id="page_304"></a>This is the logic for determining a quotient bit for an odd-numbered bit position.
         For an even-numbered position, the logic is reversed. Hence, the test includes the
         term <code>(i&amp;1) ==</code> 0. (The <code>^</code> character in the program denotes <em>exclusive or</em>.)
      </p>
      
      <p class="indent">At each iteration, <code>c</code> is set equal to the smallest (closest to zero) integer that must have a 1-bit at
         position <code>i</code> after dividing by <code>d</code>. If the current remainder <code>r</code> exceeds that, then bit <code>i</code> of <code>q</code> is set to 1 and <code>r</code> is adjusted by subtracting the value of a 1 at that position, multiplied by the divisor
         <code>d</code>. No real multiplication is required here; <code>d</code> is simply positioned properly and subtracted.
      </p>
      
      <p class="indent">The algorithm is not elegant. It is awkward to implement because there are several
         additions, subtractions, and comparisons, and there is even a multiplication (by a
         constant) that must be done at the beginning. One might hope for a “uniform” algorithm—one
         that does not test the signs of the arguments and do different things depending on
         the outcome. Such a uniform algorithm, however, probably does not exist for base –2
         (or for two’s-complement arithmetic). The reason for this is that division is inherently
         a non-uniform process. Consider the simplest algorithm of the <em>shift</em>-and-<em>subtract</em> type. This algorithm would not shift at all, but for positive arguments would simply
         subtract the divisor from the dividend repeatedly, counting the number of subtractions
         performed until the remainder is less than the divisor. On the other hand, if the
         dividend is negative (and the divisor is positive), the process is to add the divisor
         repeatedly until the remainder is 0 or positive, and the quotient is the negative
         of the count obtained. The process is still different if the divisor is negative.
      </p>
      
      <p class="indent">In spite of this, division <em>is</em> a uniform process for the signed-magnitude representation of numbers. With such a
         representation, the magnitudes are positive, so the algorithm can simply subtract
         magnitudes and count until the remainder is negative, and then set the sign bit of
         the quotient to the <em>exclusive or</em> of the arguments, and the sign bit of the remainder equal to the sign of the dividend
         (this gives ordinary truncating division).
      </p>
      
      <p class="indent">The algorithm given above could be made more uniform, in a sense, by first complementing
         the divisor, if it is negative, and then performing the steps given as simplified
         by having <em>d</em> &gt; 0. Then a correction would be performed at the end. For modulus division, the correction
         is to negate the quotient and leave the remainder unchanged. This moves some of the
         tests out of the loop, but the algorithm as a whole is still not pretty.
      </p>
      
      <p class="indent">It is interesting to contrast the commonly used number representations and base –2
         regarding the question of whether or not the computer hardware treats numbers uniformly
         in carrying out the four fundamental arithmetic operations. We don’t have a precise
         definition of “uniformly,” but basically it means free of operations that might or
         might not be done, depending on the signs of the arguments. We consider setting the
         sign bit of the result equal to the <em>exclusive or</em> of the signs of the arguments to be a uniform operation. <a href="ch12.html#ch12tab2">Table 12–2</a> shows which operations treat their operands uniformly with various number representations.
      </p>
      
      <p class="indent">One’s-complement addition and subtraction are done uniformly by means of the “end
         around carry” trick. For addition, all bits, including the sign bit, are <a id="page_305"></a>added in the usual binary way, and the carry out of the leftmost bit (the sign bit)
         is added to the least significant position. This process always terminates right away
         (that is, the addition of the carry cannot generate another carry out of the sign
         bit position).
      </p>
      
      <p class="tab-caption"><a id="ch12tab2"></a>T<small>ABLE</small> 12–2. U<small>NIFORM</small> O<small>PERATIONS IN</small> V<small>ARIOUS</small> N<small>UMBER</small> E<small>NCODINGS</small></p>
      
      <div class="image"><img alt="Image" src="graphics/305tab01.jpg" /></div>
      
      <p class="indent">In the case of two’s-complement multiplication, the entry is “yes” if only the right
         half of the doubleword product is desired.
      </p>
      
      <p class="indent">We conclude this discussion of the base –2 number system with some observations about
         how to convert between straight binary and base –2.
      </p>
      
      <p class="indent">To convert to binary from base –2, form a word that has only the bits with positive
         weight, and subtract a word that has only the bits with negative weight, using the
         subtraction rules of binary arithmetic. An alternative method that may be a little
         simpler is to extract the bits appearing in the negative weight positions, shift them
         one position to the left, and subtract the extracted number from the original number
         using the subtraction rules of ordinary binary arithmetic.
      </p>
      
      <p class="indent">To convert to base –2 from binary, extract the bits appearing in the odd positions
         (positions weighted by 2<sup><em>n</em></sup> with <em>n</em> odd), shift them one position to the left, and add the two numbers using the addition
         rules of base –2. Here are two examples:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/305fig01.jpg" /></div>
      
      <p class="indent">On a computer, with its fixed word size, these conversions work for negative numbers
         if the carries out of the high-order position are simply discarded. To illustrate,
         the example on the right above can be regarded as converting −9 to base −2 from binary
         if the word size is six bits.
      </p>
      
      <p class="indent">The above algorithm for converting to base −2 cannot easily be implemented in software
         on a binary computer, because it requires doing addition in base −2. Schroeppel [HAK,
         item 128] overcomes this with a much more clever and useful way to do the conversions
         in both directions. To convert to binary, his method is
      </p>
      
      <p class="center"><strong><em>B</em></strong> ← (<strong><em>N</em></strong> ⊕ <strong>0b10... 1010) − 0b10 ... 1010</strong>.
      </p>
      
      <p class="indent"><a id="page_306"></a>To see why this works, let the base –2 number consist of the four digits <em>abcd</em>. Then, interpreted (erroneously) in straight binary, this is 8<em>a</em> + <em>4b</em> + 2 <em>c</em> + <em>d</em>. After the <em>exclusive or</em>, interpreted in binary it is 8(1 − <em>a)</em> + <em>4b</em> + 2(1 − <em>c</em>) + <em>d</em>. After the (binary) subtraction of 8 + 2, it is − 8 <em>a</em> + 4<em>b</em> − 2 <em>c</em> + <em>d</em>, which is its value interpreted in base –2.
      </p>
      
      <p class="indent">Schroeppel’s formula can be readily solved for <strong><em>N</em></strong> in terms of <strong><em>B</em></strong>, so it gives a three-instruction method for converting in the other direction. Collecting
         these results, we have the following formulas for converting to binary for a 32-bit
         machine:
      </p>
      
      <p class="indenthangingNP1"><strong><em>B</em></strong> ← <strong>(<em>N</em> &amp; 0x55555555) − (<em>N</em> &amp; ¬0x55555555)</strong>,<br /><strong><em>B</em></strong> ← <strong><em>N</em> − ((<em>N</em>&amp; 0xAAAAAAAA) <span class="entity">&lt;&lt;</span> 1)</strong>,<br /><strong><em>B</em></strong> ← <strong>(<em>N</em> ⊕ 0xAAAAAAAA) − 0xAAAAAAAA</strong>,
      </p>
      
      <p class="noindent">and the following, for converting to base –2 from binary:</p>
      
      <p class="indenthangingNP1"><strong><em>N</em></strong> ← <strong>(<em>B</em> + 0xAAAAAAAA) ⊕ 0xAAAAAAAA</strong>.
      </p>
      
      <h3><a id="ch12lev2"></a><strong>12-2 Base –1 + <em>i</em></strong></h3>
      
      <p class="noindent">By using – 1 + <em>i</em> as the base, where <em>i</em> is <span class="middle"><img alt="Image" src="graphics/302fig02.jpg" /></span>, all <em>complex</em> integers (complex numbers with integral real and imaginary parts) can be expressed
         as a single “number” without an explicit sign or other irregularity. Surprisingly,
         this can be done using only 0 and 1 for digits, and all integers are represented uniquely.
         We will not prove this or much else about this number system, but will just describe
         it very briefly.
      </p>
      
      <p class="indent">It is not entirely trivial to discover how to write the integer 2.<sup><a id="ch12fna1"></a><a href="footnotes.html#ch12fn1">1</a></sup> But it can be determined algorithmically by successively dividing 2 by the base and
         recording the remainders. What does a “remainder” mean in this context? We want the
         remainder after dividing by – 1 + <em>i</em> to be 0 or 1, if possible (so that the digits will be 0 or 1). To see that it is
         always possible, assume that we are to divide an arbitrary complex integer <em>a</em> + <em>bi</em> by − 1 + <em>i</em>. Then, we wish to find <em>q</em> and <em>r</em> such that <em>q</em> is a complex integer, <em>r</em> = 0 or 1, and
      </p>
      
      <p class="center"><em>a</em> + <em>bi</em> = (<em>q<sub>r</sub></em> + <em>q<sub>i</sub>i</em>)(− 1 + <em>i</em>)+<em>r</em>,
      </p>
      
      <p class="noindent">where <em>q<sub>r</sub></em> and <em>q<sub>t</sub></em> denote the real and imaginary parts of <em>q</em>, respectively. Equating real and imaginary parts and solving the two simultaneous
         equations for <em>q</em> gives
      </p>
      
      <div class="image"><img alt="Image" src="graphics/306equ02.jpg" /></div>
      
      <p class="noindent"><a id="page_307"></a>Clearly, if <em>a</em> and <em>b</em> are both even or are both odd, then by choosing <em>r</em> = 0, <em>q</em> is a complex integer. Furthermore, if one of <em>a</em> and <em>b</em> is even and the other is odd, then by choosing <em>r</em> = 1, <em>q</em> is a complex integer.
      </p>
      
      <p class="indent">Thus, the integer 2 can be converted to base – 1 + <em>i</em> by the plan illustrated below.
      </p>
      
      <p class="indent">Because the real and imaginary parts of the integer 2 are both even, we simply do
         the division, knowing that the remainder will be 0:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/307equ01.jpg" /></div>
      
      <p class="indent">Because the real and imaginary parts of – 1 – <em>i</em> are both odd, again we simply divide, knowing that the remainder is 0:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/307equ02.jpg" /></div>
      
      <p class="indent">Because the real and imaginary parts of <em>i</em> are even and odd, respectively, the remainder will be 1. It is simplest to account
         for this at the beginning by subtracting 1 from the dividend.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/307equ03.jpg" /></div>
      
      <p class="indent">Because the real and imaginary parts of 1 are odd and even, the next remainder will
         be 1. Subtracting this from the dividend gives
      </p>
      
      <div class="image"><img alt="Image" src="graphics/307equ04.jpg" /></div>
      
      <p class="indent">Because we have reached a 0 quotient, the process terminates, and the base – 1 + <em>i</em> representation for 2 is seen to be 1100 (reading the remainders upward).
      </p>
      
      <p class="indent">Table 12–3 shows how each bit pattern from 0000 to 1111 is interpreted in base – 1
         + <em>i</em> and how the real integers in the range –15 to +15 are represented.
      </p>
      
      <p class="indent">The addition rules for base – 1 + <em>i</em> (in addition to the trivial ones involving a 0-bit) are as follows:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/307equ05.jpg" /></div>
      
      <p class="tab-caption"><a id="page_308"></a><a id="ch12tab3"></a>T<small>ABLE</small> 12–3. C<small>ONVERSIONS BETWEEN</small> D<small>ECIMAL AND</small> B<small>ASE –1</small> + <em>i</em></p>
      
      <div class="image"><img alt="Image" src="graphics/308tab01.jpg" /></div>
      
      <p class="indent">When adding two numbers, the largest number of carries that occurs in one column is
         six, so the largest sum of a column is 8 (111000000). This makes for a rather complicated
         adder. If one were to build a complex arithmetic machine, it would no doubt be best
         to keep the real and imaginary parts separate,<sup><a id="ch12fna2"></a><a href="footnotes.html#ch12fn2">2</a></sup> with each represented in some sensible way such as two’s-complement.
      </p>
      
      <h3><a id="ch12lev3"></a><strong>12–3 Other Bases</strong></h3>
      
      <p class="noindent">The base – 1 – <em>i</em> has essentially the same properties as the base – 1 + <em>i</em> discussed above. If a certain bit pattern represents the number <em>a</em> + <em>bi</em> in one of these bases, then the same bit pattern represents the number <em>a</em> – <em>bi</em> in the other base.
      </p>
      
      <p class="indent"><a id="page_309"></a>The bases 1 + <em>i</em> and 1 – <em>i</em> can also represent all the complex integers, using only 0 and 1 for digits. These
         two bases have the same complex-conjugate relationship to each other, as do the bases
         – 1 ± <em>i</em>. In bases 1 ± <em>i</em>, the representation of some integers has an infinite string of 1’s on the left, similar
         to the two’s-complement representation of negative integers. This arises naturally
         by using uniform rules for addition and subtraction, as in the case of two’s-complement.
         One such integer is 2, which (in either base) is written ...11101100. Thus, these
         bases have the rather complex addition rule 1 + 1 = ...11101100.
      </p>
      
      <p class="indent">By grouping into pairs the bits in the base –2 representation of an integer, one obtains
         a base 4 representation for the positive and negative numbers, using the digits –2,
         –1, 0, and 1. For example,
      </p>
      
      <p class="center">−14<sub>decimal</sub> = 110110<sub>−2</sub> = (−1)(1)(−2)<sub>4</sub> = −1 · 4<sup>2</sup> + 1 · −4<sup>1</sup> −2 · 4<sup>0</sup></p>
      
      <p class="indent">Similarly, by grouping into pairs the bits in the base – 1 + <em>i</em> representation of a complex integer, we obtain a base –2<em>i</em> representation for the complex integers using the digits 0, 1, – 1 + <em>i</em>, and <em>i</em>. This is a bit too complicated to be interesting.
      </p>
      
      <p class="indent">The “quater-imaginary” system (Knu2) is similar. It represents the complex integers
         using 2<em>i</em> as a base, and the digits 0, 1, 2, and 3 (with no sign). To represent some integers,
         namely those with an odd imaginary component, it is necessary to use a digit to the
         right of the radix point. For example, <em>i</em> is written 10.2 in base 2<em>i</em>.
      </p>
      
      <h3><a id="ch12lev4"></a><strong>12–4 What Is the Most Efficient Base?</strong></h3>
      
      <p class="noindent">Suppose you are building a computer and you are trying to decide what base to use
         to represent integers. For the registers you have available circuits that are 2-state
         (binary), 3-state, 4-state, and so on. Which should you use?
      </p>
      
      <p class="indent">Let us assume that the cost of a <em>b</em>-state circuit is proportional to <em>b</em>. Thus, a 3-state circuit costs 50% more than a binary circuit, a 4-state circuit
         costs twice as much as a binary circuit, and so on.
      </p>
      
      <p class="indent">Suppose you want the registers to be able to hold integers from 0 to some maximum
         <em>M</em>. Encoding integers from 0 to <em>M</em> in base <em>b</em> requires <span class="entity">⌈</span>log<sub><em>b</em></sub>(<em>M</em> + 1)<span class="entity">⌉</span> digits (e.g., to represent all integers from 0 to 999,999 in decimal requires log<sub>10</sub>(1,000,000) = 6 digits).
      </p>
      
      <p class="indent">One would expect the cost of a register to be equal to the product of the number of
         digits required times the cost to represent each digit:
      </p>
      
      <p class="center"><em>c</em> = <em>k</em>log<sub><em>b</em></sub>(<em>M</em> + 1) · <em>b</em>,
      </p>
      
      <p class="noindent">where <em>c</em> is the cost of a register and <em>k</em> is a constant of proportionality. For a given <em>M</em>, we wish to find <em>b</em> that minimizes the cost.
      </p>
      
      <p class="indent"><a id="page_310"></a>The minimum of this function occurs for that value of <em>b</em> that makes <em>dc</em>/<em>db</em> = 0. Thus, we have
      </p>
      
      <div class="image"><img alt="Image" src="graphics/310equ01.jpg" /></div>
      
      <p class="noindent">This is zero when 1n<em>b</em> = 1, or <em>b</em> = <em>e</em>.
      </p>
      
      <p class="indent">This is not a very satisfactory result. Because <em>e</em> ≈ 2.718, 2 and 3 must be the most efficient integral bases. Which is more efficient?
         The ratio of the cost of a base 2 register to the cost of a base 3 register is
      </p>
      
      <div class="image"><img alt="Image" src="graphics/310equ02.jpg" /></div>
      
      <p class="noindent">Thus, base 2 is more costly than base 3, but only by a small amount.</p>
      
      <p class="indent">By the same analysis, base 2 is more costly than base <em>e</em> by a factor of about 1.062.
      </p>
      
      <h4><strong>Exercises</strong></h4>
      
      <p class="question"><a href="ch19_answer.html#ch12ans1" id="ch12ansa1"><strong>1</strong>.</a> Schroeppel’s formula for converting from base –2 to binary has a dual involving the
         constant 0x5555555. Can you find it?
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch12ans2" id="ch12ansa2"><strong>2</strong>.</a> Show how to add 1 to a base –2 number using the arithmetic and logical operations
         of a binary computer. For example, 0b111 ⇒ 0b100.
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch12ans3" id="ch12ansa3"><strong>3</strong>.</a> Show how to round a base –2 number down (in the negative direction) to a multiple
         of 16 using the arithmetic and logical operations of a binary computer. For example,
         0b10 ⇒ 0b110000.
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch12ans4" id="ch12ansa4"><strong>4</strong>.</a> Write a program, in a language of your choice, to convert a base – 1 + <em>i</em> integer to the form <em>a</em> + <em>bi</em>, where <em>a</em> and <em>b</em> are real integers. For example, if you give the program the integer 33, or 0x21,
         it should display something like 5 − 4i.
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch12ans5" id="ch12ansa5"><strong>5</strong>.</a> How would you convert a number in base − 1 + <em>i</em> to its negative? Extract its real part? Extract its imaginary part? Convert it to
         its complex conjugate? (The complex conjugate of <em>a</em> + <em>bi</em> is <em>a</em> − <em>bi</em>.)
      </p>
      
   </body>
   
</html>