<html xmlns="http://www.w3.org/1999/xhtml">
   
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      
      <title>Chapter 16. Hilbert’s Curve</title>
      
      <link href="9780133085013.css" rel="stylesheet" type="text/css" />
      
      <link href="page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
      
      <meta content="urn:uuid:767ce45a-85bb-4273-91f5-801bab42906b" name="Adept.expected.resource" />
      
   </head>
   
   <body>
      
      <h2><a id="page_355"></a><a id="ch16"></a>Chapter 16. Hilbert’s Curve
      </h2>
      
      <p class="noindent">In 1890, Giuseppe Peano discovered a planar curve<sup><a id="ch16fna1"></a><a href="footnotes.html#ch16fn1">1</a></sup> with the rather surprising property that it is “space-filling.” The curve winds around
         the unit square and hits every point (<em>x, y</em>) at least once.
      </p>
      
      <p class="indent">Peano’s curve is based on dividing each side of the unit square into three equal parts,
         which divides the square into nine smaller squares. His curve traverses these nine
         squares in a certain order. Then, each of the nine small squares is similarly divided
         into nine still smaller squares, and the curve is modified to traverse all these squares
         in a certain order. The curve can be described using fractions expressed in base 3;
         in fact, that’s the way Peano first described it.
      </p>
      
      <p class="indent">In 1891, David Hilbert [Hil] discovered a variation of Peano’s curve based on dividing
         each side of the unit square into two equal parts, which divides the square into four
         smaller squares. Then, each of the four small squares is similarly divided into four
         still smaller squares, and so on. For each stage of this division, Hilbert gives a
         curve that traverses all the squares. Hilbert’s curve, sometimes called the “Peano-Hilbert
         curve,” is the limit curve of this division process. It can be described using fractions
         expressed in base 2.
      </p>
      
      <p class="indent"><a href="ch16.html#ch16fig1">Figure 16–1</a> shows the first three steps in the sequence that leads to Hilbert’s space-filling
         curve, as they were depicted in his 1891 paper.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/16fig01.jpg" /></div>
      
      <p class="fig-caption"><a id="ch16fig1"></a>F<small>IGURE</small> 16–1. First three curves in the sequence defining Hilbert’s curve.
      </p>
      
      <p class="indent">Here, we do things a little differently. We use the term “Hilbert curve” for any of
         the curves on the sequence whose limit is the Hilbert space-filling curve. The “Hilbert
         curve of order <em>n</em>” means the <em>n</em>th curve in the sequence. In <a href="ch16.html#ch16fig1">Figure 16–1</a>, the curves are of order 1, 2, and 3. We shift the curves down and to the left so
         that the corners of the curves coincide with the intersections of the lines in the
         boxes above. Finally, we scale the size of the order <em>n</em> curve up by a factor of 2<sup><em>n</em></sup>, so that the coordinates of the corners of the curves are integers. Thus, our order
         <em>n</em> Hilbert curve has corners at integers ranging from 0 to 2<sup><em>n</em></sup> – 1 in both <em>x</em> and <em>y</em>. We take the <a id="page_356"></a>positive direction along the curve to be from (<em>x, y</em>) = (0, 0) to (2<sup><em>n</em></sup> – 1.0). <a href="ch16.html#ch16fig2">Figure 16–2</a> shows the Hilbert curves of orders 1 through 6.
      </p>
      
      <h3><a id="ch16lev1"></a><strong>16–1 A Recursive Algorithm for Generating the Hilbert Curve</strong></h3>
      
      <p class="noindent">To see how to generate a Hilbert curve, examine the curves in <a href="ch16.html#ch16fig2">Figure 16–2</a>. The order 1 curve goes up, right, and down. The order 2 curve follows this overall
         pattern. First, it makes a U-shaped curve that goes up, in net effect. Second, it
         takes a unit step up. Third, it takes a U-shaped curve, a step, and another U, all
         to the right. Finally, it takes a step down, followed by a U that goes down, in net
         effect.
      </p>
      
      <div class="image"><a id="page_357"></a><img alt="Image" src="graphics/16fig02.jpg" /></div>
      
      <p class="fig-caption"><a id="ch16fig2"></a>F<small>IGURE</small> 16–2. Hilbert curves of orders 1–6.
      </p>
      
      <p class="indent">The order 1 inverted U is converted into the order 2 Y-shaped curve.</p>
      
      <p class="indent">We can regard the Hilbert curve of any order as a series of U-shaped curves of various
         orientations, each of which, except for the last, is followed by a unit step in a
         certain direction. In transforming a Hilbert curve of one order to the next, each
         U-shaped curve is transformed into a Y-shaped curve with the same general orientation,
         and each unit step is transformed to a unit step in the same direction.
      </p>
      
      <p class="indent">The transformation of the order 1 Hilbert curve (a U curve with a net direction to
         the right and a clockwise rotational orientation) to the order 2 Hilbert curve goes
         as follows:
      </p>
      
      <p class="indenthangingN">1. Draw a U that goes up and has a counterclockwise rotation.</p>
      
      <p class="indenthangingN">2. Draw a step up.</p>
      
      <p class="indenthangingN">3. Draw a U that goes to the right and has a clockwise rotation.</p>
      
      <p class="indenthangingN">4. Draw a step to the right.</p>
      
      <p class="indenthangingN">5. Draw a U that goes to the right and has a clockwise rotation.</p>
      
      <p class="indenthangingN">6. Draw a step down.</p>
      
      <p class="indenthangingN">7. Draw a U that goes down and has a counterclockwise rotation.</p>
      
      <p class="indent">We can see by inspection that all U’s that are oriented as the order 1 Hilbert curve
         are transformed in the same way. A similar set of rules can be made for transforming
         U’s with other orientations. These rules are embodied in the recursive program shown
         in <a href="ch16.html#ch16fig3">Figure 16–3</a> [Voor]. In this program, the orientation of a U curve is characterized by two integers
         that specify the net linear and the rotational directions, encoded as follows:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/356fig01.jpg" /></div>
      
      <p class="indent">Actually, <code>dir</code> can take on other values, but its congruency modulo 4 is what matters.
      </p>
      
      <p class="codelink"><a id="page_358"></a><a href="images15.html#p16fig03" id="p16fig03a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch16fig3"></a>void step(int);<br /><br />void hilbert(int dir, int rot, int order) {<br /><br />   if (order == 0) return;<br /><br />   dir = dir + rot;<br />   hilbert(dir, -rot, order - 1);<br />   step(dir);<br />   dir = dir - rot;<br />   hilbert(dir, rot, order - 1);<br />   step(dir);<br />   hilbert(dir, rot, order - 1);<br />   dir = dir - rot;<br />   step(dir);<br />   hilbert(dir, -rot, order - 1);<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 16–3. Hilbert curve generator.
      </p>
      
      <p class="indent"><a href="ch16.html#ch16fig4">Figure 16–4</a> shows a driver program and function <code>step</code> that is used by program <code>hilbert</code>. This program is given the order of a Hilbert curve to construct, and it displays
         a list of line segments, giving for each the direction of movement, the length along
         the curve to the end of the segment, and the coordinates of the end of the segment.
         For example, for order 2 it displays
      </p>
      
      <p class="codelink"><a href="images15.html#p358fig01" id="p358fig01a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting1"> 0  0000  00  00<br /> 0  0001  01  00<br /> 1  0010  01  01<br /> 2  0011  00  01<br /> 1  0100  00  10<br /> 1  0101  00  11<br /> 0  0110  01  11<br />-1  0111  01  10<br /> 0  1000  10  10<br /> 1  1001  10  11<br /> 0  1010  11  11<br />-1  1011  11  10<br />-1  1100  11  01<br />-2  1101  10  01<br />-1  1110  10  00<br /> 0  1111  11  00
      </p>
      
      <p class="codelink"><a id="page_359"></a><a href="images15.html#p16fig04" id="p16fig04a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch16fig4"></a>#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br /><br />int x = -1, y = 0;        // Global variables.<br />int s = 0;                // Dist. along curve.<br />int blen;                 // Length to print.<br /><br />void hilbert(int dir, int rot, int order);<br /><br />void binary(unsigned k, int len, char *s) {<br />/* Converts the unsigned integer k to binary character form. Result is string s of
         length len. */<br />  int i;<br /><br />  s[len] = 0;<br />  for (i = len - 1; i &gt;= 0; i--) {<br />     if (k &amp; 1) s[i] = ‘1’;<br />     else   s[i] = ‘0’;<br />     k = k &gt;&gt; 1;<br />  }<br />}<br />void step(int dir) {<br />   char ii[33], xx[17], yy[17];<br /><br />   switch(dir &amp; 3) {<br />      case 0: x = x + 1; break;<br />      case 1: y = y + 1; break;<br />      case 2: x = x - 1; break;<br />      case 3: y = y - 1; break;<br />   }<br />   binary(s, 2*blen, ii);<br />   binary(x, blen, xx);<br />   binary(y, blen, yy);<br />   printf("%5d %s %s %s\n", dir, ii, xx, yy);<br />   s = s + 1;             // Increment distance.<br />}<br />int main(int argc, char *argv[]) {<br />   int order;<br /><br />   order = atoi(argv[1]);<br />   blen = order;<br />   step(0);               // Print init. point.<br />   hilbert(0, 1, order);<br />   return 0;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 16–4. Driver program for Hilbert curve generator.
      </p>
      
      <h3><a id="ch16lev2"></a><strong>16–2 Coordinates from Distance along the Hilbert Curve</strong></h3>
      
      <p class="noindent">To find the (<em>x, y</em>) coordinates of a point located at a distance <em>s</em> along the order <em>n</em> Hilbert curve, observe that the most significant two bits of the 2<em>n</em>-bit integer <em>s</em></p>
      
      <p class="noindent"><a id="page_360"></a>determine which major quadrant the point is in. This is because the Hilbert curve
         of any order follows the overall pattern of the order 1 curve. If the most significant
         two bits of <em>s</em> are 00, the point is somewhere in the lower-left quadrant, if 01 it is in the upper-left
         quadrant, if 10 it is in the upper-right quadrant, and if 11 it is in the lower-right
         quadrant. Thus, the most significant two bits of <em>s</em> determine the most significant bits of the <em>n</em>-bit integers <em>x</em> and <em>y</em>, as follows:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/360tab01.jpg" /></div>
      
      <p class="indent">In any Hilbert curve, only four of the eight possible U-shapes occur. These are shown
         in <a href="ch16.html#ch16tab1">Table 16–1</a> as graphics and as maps from two bits of <em>s</em> to a single bit of each of <em>x</em> and <em>y</em>.
      </p>
      
      <p class="fig-caption"><a id="ch16tab1"></a>T<small>ABLE</small> 16-1. T<small>HE</small> F<small>OUR</small> P<small>OSSIBLE</small> M<small>APPINGS</small></p>
      
      <div class="image"><img alt="Image" src="graphics/360tab02.jpg" /></div>
      
      <p class="indent">Observe from <a href="ch16.html#ch16fig2">Figure 16–2</a> that in all cases the U-shape represented by map A <img alt="Image" src="graphics/360fig01.jpg" /> becomes, at the next level of detail, a U-shape represented by maps B, A, A, or D,
         depending on whether the length traversed in the first-mentioned map A is 0, 1, 2,
         or 3, respectively. Similarly, a U-shape represented by map B <img alt="Image" src="graphics/360fig02.jpg" /> becomes, at the next level of detail, a U-shape represented by maps A, B, B, or C,
         depending on whether the length traversed in the first-mentioned map B is 0, 1, 2,
         or 3, respectively.
      </p>
      
      <p class="fig-caption"><a id="page_361"></a><a id="ch16tab2"></a>T<small>ABLE</small> 16–2. S<small>TATE</small> T<small>RANSITION</small> T<small>ABLE</small> F<small>OR</small> C<small>OMPUTING (<em>X, Y</em>) FROMS</small></p>
      
      <div class="image"><img alt="Image" src="graphics/361tab01.jpg" /></div>
      
      <p class="indent">These observations lead to the state transition table shown in <a href="ch16.html#ch16tab2">Table 16–2</a>, in which the states correspond to the mappings shown in <a href="ch16.html#ch16tab1">Table 16–1</a>.
      </p>
      
      <p class="indent">To use the table, start in state A. The integer <em>s</em> should be padded with leading zeros so that its length is <em>2n</em>, where <em>n</em> is the order of the Hilbert curve. Scan the bits of <em>s</em> in pairs from left to right. The first row of <a href="ch16.html#ch16tab2">Table 16–2</a> means that if the current state is A and the currently scanned bits of <em>s</em> are 00, then output (0, 0) and enter state B. Then, advance to the next two bits
         of <em>s</em>. Similarly, the second row means that if the current state is A and the scanned bits
         are 01, then output (0, 1) and stay in state A.
      </p>
      
      <p class="indent">The output bits are accumulated in left-to-right order. When the end of <em>s</em> is reached, the <em>n</em>-bit output quantities <em>x</em> and <em>y</em> are defined.
      </p>
      
      <p class="indent">As an example, suppose <em>n</em> = 3 and
      </p>
      
      <p class="center"><em>s</em> = 110100.
      </p>
      
      <p class="noindent">Because the process starts in state A and the initial bits scanned are 11, the process
         outputs (1, 0) and enters state D (fourth row). Then, in state D and scanning 01,
         the process outputs (0, 1) and stays in state D. Lastly, the process outputs (1, 1)
         and enters state C, although the state is now immaterial.
      </p>
      
      <p class="indent">Thus, the output is (101, 011)—that is, <em>x</em> = 5 and <em>y</em> = 3.
      </p>
      
      <p class="indent">A C program implementing these steps is shown in <a href="ch16.html#ch16fig5">Figure 16–5</a>. In this program, the current state is represented by an integer from 0 to 3 for
         states A through D, respectively. In the assignment to variable <code>row</code>, the current state is concatenated with the next two bits of <code>s</code>, giving an integer from 0 to 15, which is the applicable row number in <a href="ch16.html#ch16tab2">Table 16–2</a>. Variable <code>row</code> is used to access integers (expressed in hexadecimal) that are used as bit strings
         to represent the rightmost two columns of <a href="ch16.html#ch16tab2">Table 16–2</a>; that is, these accesses are in-register table lookups. Left-to-right in the hexadecimal
         values corresponds to bottom-to-top in <a href="ch16.html#ch16tab2">Table 16–2</a>.
      </p>
      
      <p class="codelink"><a id="page_362"></a><a href="images15.html#p16fig05" id="p16fig05a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch16fig5"></a>void hil_xy_from_s(unsigned s, int n, unsigned *xp,<br />                                      unsigned *yp) {<br />    int i;<br />    unsigned state, x, y, row;<br /><br />    state = 0;                          // Initialize.<br />    x = y = 0;<br /><br />    for (i = 2*n - 2; i &gt;= 0; i -= 2) { // Do n times.<br />       row = 4*state | (s &gt;&gt; i) &amp; 3;    // Row in table.<br />       x = (x &lt;&lt; 1) | (0x936C &gt;&gt; row) &amp; 1;<br />       y = (y &lt;&lt; 1) | (0x39C6 &gt;&gt; row) &amp; 1;<br />       state = (0x3E6B94C1 &gt;&gt; 2*row) &amp; 3; // New state.<br />   }<br />   *xp = x;                               // Pass back<br />   *yp = y;                               // results.<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 16–5. Program for computing (<em>x, y</em>) from <em>s</em>.
      </p>
      
      <p class="indent">[L&amp;S] give a quite different algorithm. Unlike the algorithm of <a href="ch16.html#ch16fig5">Figure 16–5</a>, it scans the bits of <em>s</em> from right to left. It is based on the observation that one can map the least significant
         two bits of <em>s</em> to (<em>x, y</em>) based on the order 1 Hilbert curve, and then test the next two bits of <em>s</em> to the left. If they are 00, the values of <em>x</em> and <em>y</em> just computed should be interchanged, which corresponds to reflecting the order 1
         Hilbert curve about the line <em>x</em> = <em>y</em>. (Refer to the curves of orders 1 and 2 shown in <a href="ch16.html#ch16fig1">Figure 16–1</a> on page <a href="ch16.html#page_355">355</a>.) If these two bits are 01 or 10, the values of <em>x</em> and <em>y</em> are not changed. If they are 11, the values of <em>x</em> and <em>y</em> are interchanged and complemented. These same rules apply as one progresses leftward
         along the bits of <em>s</em>. They are embodied in <a href="ch16.html#ch16tab3">Table 16–3</a> and the code of <a href="ch16.html#ch16fig6">Figure 16–6</a>. It is somewhat curious that the bits can be prepended to <em>x</em> and <em>y</em> first, and then the swap and complement operations can be done, including these newly
         prepended bits; the results are the same.
      </p>
      
      <p class="fig-caption"><a id="ch16tab3"></a>T<small>ABLE</small> 16–3. L<small>AM AND</small> S<small>HAPIRO</small> M<small>ETHOD FOR</small> C<small>OMPUTING (<em>X, Y</em>) FROM</small> <small><em>S</em></small></p>
      
      <div class="image"><img alt="Image" src="graphics/362tab01.jpg" /></div>
      
      <p class="codelink"><a id="page_363"></a><a href="images15.html#p16fig06" id="p16fig06a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch16fig6"></a>void hil_xy_from_s(unsigned s, int n, unsigned *xp,<br />                                      unsigned *yp) {<br />   int i, sa, sb;<br />   unsigned x, y, temp;<br /><br />   for (i = 0; i &lt; 2*n; i += 2) {<br />      sa = (s &gt;&gt; (i+1)) &amp; 1;        // Get bit i+1 of s.<br />      sb = (s &gt;&gt; i) &amp; 1;            // Get bit i of s.<br /><br />      if ((sa ^ sb) == 0) {         // If sa,sb = 00 or 11,<br />         temp = x;                  // swap x and y,<br />         x = y ^ (-sa);             // and if sa = 1,<br />         y = temp ^ (-sa);          // complement them.<br />      }<br />      x = (x &gt;&gt; 1) | (sa <span class="entity">&lt;&lt;</span> 31);// Prepend sa to x and<br />      y = (y &gt;&gt; 1) | ((sa ^ sb) <span class="entity">&lt;&lt;</span> 31); // (sa ^ sb) to y.<br />  }<br />  *xp = x &gt;&gt; (32 - n);            // Right-adjust x and y<br />  *yp = y &gt;&gt; (32 - n);            // and return them to<br />}                                   // the caller.
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 16–6. Lam and Shapiro method for computing (<em>x, y</em>) from <em>s</em>.
      </p>
      
      <p class="indent">In <a href="ch16.html#ch16fig6">Figure 16–6</a>, variables <code>x</code> and <code>y</code> are uninitialized, which might cause an error message from some compilers, but the
         code functions correctly for whatever values <code>x</code> and <code>y</code> have initially.
      </p>
      
      <p class="indent">The branch in the loop of <a href="ch16.html#ch16fig6">Figure 16–6</a> can be avoided by doing the swap operation with the “three <em>exclusive or</em>” trick given in <a href="ch02.html#ch02lev20">Section 2–20</a> on page <a href="ch02.html#page_45">45</a>. The <em>if</em> block can be replaced by the following code, where <code>swap</code> and <code>cmpl</code> are unsigned integers:
      </p>
      
      <p class="codelink"><a href="images15.html#p363fig01" id="p363fig01a">Click here to view code image</a></p>
      
      <p class="programlisting1">swap = (sa ^ sb) - 1;   // -1 if should swap, else 0.<br />cmpl = -(sa &amp; sb);      // -1 if should compl’t, else 0.<br />x = x ^ y;<br />y = y ^ (x &amp; swap) ^ cmpl;<br />x = x ^ y;
      </p>
      
      <p class="noindent">This is nine instructions, versus about two or six for the <em>if</em> block, so the branch cost would have to be quite high for this to be a good choice.
      </p>
      
      <p class="indent">The “swap and complement” idea of [L&amp;S] suggests a logic circuit for generating the
         Hilbert curve. The idea behind the circuit, described below, is that as you trace
         along the path of an order <em>n</em> curve, you basically map pairs of bits of <em>s</em> to (<em>x, y</em>) according to map A of <a href="ch16.html#ch16tab1">Table 16–1</a>. As the trace enters various regions, the mapping output gets swapped, complemented,
         or both. The circuit of <a href="ch16.html#ch16fig7">Figure 16–7</a> keeps track of the swap and complement requirements of each stage, uses the <a id="page_364"></a>appropriate mapping to map two bits of <em>s</em> to (<em>x<sub>i</sub>, y<sub>i</sub></em>), and generates the swap and complement signals for the next stage.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/16fig07.jpg" /></div>
      
      <p class="fig-caption"><a id="ch16fig7"></a>F<small>IGURE</small> 16–7. Logic circuit for computing (<em>x, y</em>) from <em>s</em>.
      </p>
      
      <p class="indent">Assume there is a register containing the path length <em>s</em> and circuits for incrementing it. Then, to find the next point on the Hilbert curve,
         first increment <em>s</em> and then transform it as described in <a href="ch16.html#ch16tab4">Table 16–4</a>. This is a left-to-right process, which is a bit of a problem because incrementing
         <em>s</em> is a right-to-left process. Thus, the time to generate a new point on an order <em>n</em> Hilbert curve is proportional to 2<em>n</em> (for incrementing <em>s</em>) plus <em>n</em> (for transforming <em>s</em> to (<em>x, y</em>)).
      </p>
      
      <p class="fig-caption"><a id="ch16tab4"></a>T<small>ABLE</small> 16–4. L<small>OGIC FOR</small> C<small>OMPUTING (<em>X, Y</em>) FROM <em>S</em></small></p>
      
      <div class="image"><img alt="Image" src="graphics/364tab01.jpg" /></div>
      
      <p class="indent"><a href="ch16.html#ch16fig7">Figure 16–7</a> shows this computation as a logic circuit. In this figure, <em>S</em> denotes the swap signal and <em>C</em> denotes the complement signal.
      </p>
      
      <p class="indent">The logic circuit of <a href="ch16.html#ch16fig7">Figure 16–7</a> suggests another way to compute (<em>x, y</em>) from <em>s</em>. Notice how the swap and complement signals propagate from left to right through
         the <em>n</em> stages. This suggests that it might be possible to use the parallel prefix operation
         to quickly (in log<sub>2</sub><em>n</em> steps rather than <em>n</em> – 1) propagate the swap and complement information to each stage, and then do some
         word-parallel logical operations to compute <em>x</em> and <em>y</em>, using the equations in <a href="ch16.html#ch16fig7">Figure 16–7</a>. The values <a id="page_365"></a>of <em>x</em> and <em>y</em> are intermingled in the even and odd bit positions of a word, so they have to be
         separated by the unshuffle operation (see page <a href="ch07.html#page_140">140</a>). This might seem a bit complicated, and likely to pay off only for rather large
         values of <em>n</em>, but let us see how it goes.
      </p>
      
      <p class="indent">A procedure for this operation is shown in <a href="ch16.html#ch16fig8">Figure 16–8</a> [GLS1]. The procedure operates on fullword quantities, so it first pads the input
         <em>s</em> on the left with ‘01’ bits. This bit combination does not affect the swap and complement
         quantities. Next, a <a id="page_366"></a>quantity <code>cs</code> (complement-swap) is computed. This word is of the form <code>cscs...cs</code>, where each <code>c</code> (a single bit), if 1, means that the corresponding pair of bits is to be complemented,
         and each <code>s</code> means that the corresponding pair of bits is to be swapped, following <a href="ch16.html#ch16tab3">Table 16–3</a>. In other words, these two statements map each pair of bits of <em>s</em> as follows:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/366tab01.jpg" /></div>
      
      <p class="codelink"><a href="images15.html#p16fig08" id="p16fig08a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch16fig8"></a>void hil_xy_from_s(unsigned s, int n, unsigned *xp,<br />                                      unsigned *yp) {<br />   unsigned comp, swap, cs, t, sr;<br /><br />   s = s | (0x55555555 &lt;&lt; 2*n); // Pad s on left with 01<br />   sr = (s &gt;&gt; 1) &amp; 0x55555555;  // (no change) groups.<br />   cs = ((s &amp; 0x55555555) + sr) // Compute complement &amp;<br />        ^ 0x55555555;           // swap info in two-bit<br />                                // groups.<br />   // Parallel prefix xor op to propagate both complement<br />   // and swap info together from left to right (there is<br />   // no step "cs ^= cs &gt;&gt; 1", so in effect it computes<br />   // two independent parallel prefix operations on two<br />   // interleaved sets of sixteen bits).<br /><br />   cs = cs ^ (cs &gt;&gt; 2);<br />   cs = cs ^ (cs &gt;&gt; 4);<br />   cs = cs ^ (cs &gt;&gt; 8);<br />   cs = cs ^ (cs &gt;&gt; 16);<br />   swap = cs &amp; 0x55555555;      // Separate the swap and<br />   comp = (cs &gt;&gt; 1) &amp; 0x55555555;  // complement bits.<br /><br />   t = (s &amp; swap) ^ comp;       // Calculate x and y in<br />   s = s ^ sr ^ t ^ (t &lt;&lt; 1);   // the odd &amp; even bit<br />                                // positions, resp.<br />   s = s &amp; ((1 &lt;&lt; 2*n) - 1);    // Clear out any junk<br />                                // on the left (unpad).<br /><br />   // Now "unshuffle" to separate the x and y bits.<br /><br />   t = (s ^ (s &gt;&gt; 1)) &amp; 0x22222222; s = s ^ t ^ (t &lt;&lt; 1);<br />   t = (s ^ (s &gt;&gt; 2)) &amp; 0x0C0C0C0C; s = s ^ t ^ (t &lt;&lt; 2);<br />   t = (s ^ (s &gt;&gt; 4)) &amp; 0x00F000F0; s = s ^ t ^ (t &lt;&lt; 4);<br />   t = (s ^ (s &gt;&gt; 8)) &amp; 0x0000FF00; s = s ^ t ^ (t &lt;&lt; 8);<br /><br />   *xp = s &gt;&gt; 16;              // Assign the two halves<br />   *yp = s &amp; 0xFFFF;           // of t to x and y.<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 16–8. Parallel prefix method for computing (<em>x, y</em>) from <em>s</em>.
      </p>
      
      <p class="indent">This is the quantity to which we want to apply the parallel prefix operation. PP-XOR
         is the one to use, going from left to right, because successive 1-bits meaning to
         complement or to swap have the same logical properties as <em>exclusive or</em>: Two successive 1-bits cancel each other.
      </p>
      
      <p class="indent">Both signals (complement and swap) are propagated in the same PP-XOR operation, each
         working with every other bit of <code>cs</code>.
      </p>
      
      <p class="indent">The next four assignment statements have the effect of translating each pair of bits
         of <code>s</code> into (<code>x</code>, <code>y</code>) values, with <code>x</code> being in the odd (leftmost) bit positions, and <code>y</code> being in the even bit positions. Although the logic may seem obscure, it is not difficult
         to verify that each pair of bits of <code>s</code> is transformed by the logic of the first two Boolean equations in <a href="ch16.html#ch16fig7">Figure 16–7</a>. (<em>Suggestion:</em> Consider separately how the even and odd bit positions are transformed, using the
         fact that <code>t</code> and <code>sr</code> are 0 in the odd positions.)
      </p>
      
      <p class="indent">The rest of the procedure is self-explanatory. It executes in 66 basic RISC instructions
         (constant, branch-free), versus about 19<em>n</em> + 10 (average) for the code of <a href="ch16.html#ch16fig6">Figure 16–6</a> (based on compiled code; includes prologs and epilogs, which are essentially nil).
         Thus, the parallel prefix method is faster for <em>n</em> ≥ 3.
      </p>
      
      <h3><a id="ch16lev3"></a><strong>16–3 Distance from Coordinates on the Hilbert Curve</strong></h3>
      
      <p class="indent">Given the coordinates of a point on the Hilbert curve, the distance from the origin
         to the point can be calculated by means of a state transition table similar to <a href="ch16.html#ch16tab2">Table 16–2</a>. <a href="ch16.html#ch16tab5">Table 16–5</a> is such a table.
      </p>
      
      <p class="fig-caption"><a id="page_367"></a><a id="ch16tab5"></a>T<small>ABLE</small> 16–5. S<small>TATE</small> T<small>RANSITION</small> T<small>ABLE FOR</small> C<small>OMPUTING <em>S</em> FROM (<em>X, Y</em>)</small></p>
      
      <div class="image"><img alt="Image" src="graphics/367tab01.jpg" /></div>
      
      <p class="indent">Its interpretation is similar to that of the previous section. First, <em>x</em> and <em>y</em> should be padded with leading zeros so that they are of length <em>n</em> bits, where <em>n</em> is the order of the Hilbert curve. Second, the bits of <em>x</em> and <em>y</em> are scanned from left to right, and <em>s</em> is built up from left to right.
      </p>
      
      <p class="indent">A C program implementing these steps is shown in <a href="ch16.html#ch16fig9">Figure 16–9</a>.
      </p>
      
      <p class="codelink"><a href="images15.html#p16fig09" id="p16fig09a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch16fig9"></a>unsigned hil_s_from_xy(unsigned x, unsigned y, int n) {<br /><br />   int i;<br />   unsigned state, s, row;<br /><br />   state = 0;                         // Initialize.<br />   s = 0;<br /><br />   for (i = n - 1; i &gt;= 0; i--) {<br />      row = 4*state | 2*((x &gt;&gt; i) &amp; 1) | (y &gt;&gt; i) &amp; 1;<br />      s = (s &lt;&lt; 2) | (0x361E9CB4 &gt;&gt; 2*row) &amp; 3;<br />      state = (0x8FE65831 &gt;&gt; 2*row) &amp; 3;<br />   }<br />   return s;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 16–9. Program for computing <em>s</em> from (<em>x, y</em>).
      </p>
      
      <p class="indent">[L&amp;S] give an algorithm for computing <em>s</em> from (<em>x, y</em>) that is similar to their algorithm for going in the other direction (<a href="ch16.html#ch16tab3">Table 16–3</a>). It is a left-to-right algorithm, shown in <a href="ch16.html#ch16tab6">Table 16–6</a> and <a href="ch16.html#ch16fig10">Figure 16–10</a>.
      </p>
      
      <p class="fig-caption"><a id="page_368"></a><a id="ch16tab6"></a>T<small>ABLE</small> 16–6. L<small>AM AND</small> S<small>HAPIRO</small> M<small>ETHOD FOR</small> C<small>OMPUTING <em>S</em> FROM (<em>X, Y</em>)</small></p>
      
      <div class="image"><img alt="Image" src="graphics/368tab01.jpg" /></div>
      
      <p class="codelink"><a href="images15.html#p16fig10" id="p16fig10a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch16fig10"></a>unsigned hil_s_from_xy(unsigned x, unsigned y, int n) {<br /><br />   int i, xi, yi;<br />   unsigned s, temp;<br /><br />   s = 0;                          // Initialize.<br />   for (i = n - 1; i &gt;= 0; i--) {<br />      xi = (x &gt;&gt; i) &amp; 1;            // Get bit i of x.<br />      yi = (y &gt;&gt; i) &amp; 1;           // Get bit i of y.<br /><br />      if (yi == 0) {<br />         temp = x;                 // Swap x and y and,<br />         x = y^(-xi);              // if xi = 1,<br />         y = temp^(-xi);           // complement them.<br />      }<br />      s = 4*s + 2*xi + (xi^yi);    // Append two bits to s.<br />   }<br />   return s;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 16–10. Lam and Shapiro method for computing <em>s</em> from (<em>x, y</em>).
      </p>
      
      <h3><a id="ch16lev4"></a><strong>16–4 Incrementing the Coordinates on the Hilbert Curve</strong></h3>
      
      <p class="noindent">Given the (<em>x, y</em>) coordinates of a point on the order <em>n</em> Hilbert curve, how can one find the coordinates of the next point? One way is to
         convert (<em>x, y</em>) to <em>s</em>, add 1 to <em>s</em>, and then convert the new value of <em>s</em> back to (<em>x, y</em>), using algorithms given above.
      </p>
      
      <p class="indent">A slightly (but not dramatically) better way is based on the fact that as one moves
         along the Hilbert curve, at each step either <em>x</em> or <em>y</em>, but not both, is either incremented or decremented (by 1). The algorithm to be described
         scans the coordinate numbers from left to right to determine the type of U-curve that
         the rightmost two bits are on. Then, based on the U-curve and the value of the rightmost
         two bits, it increments or decrements either <em>x</em> or <em>y</em>.
      </p>
      
      <p class="indent">That’s basically it, but there is a complication when the path is at the end of a
         U-curve (which happens once every four steps). At this point, the direction to take
         is determined by the <em>previous</em> bits of <em>x</em> and <em>y</em> and by the higher order U-curve with <a id="page_369"></a>which these bits are associated. If that point is also at the end of its U-curve,
         then the previous bits and the U-curve there determine the direction to take, and
         so on.
      </p>
      
      <p class="indent"><a href="ch16.html#ch16tab7">Table 16–7</a> describes this algorithm. In this table, the A, B, C, and D denote the U-curves as
         shown in <a href="ch16.html#ch16tab1">Table 16–1</a> on page <a href="ch16.html#page_360">360</a>. To use the table, first pad <em>x</em> and <em>y</em> with leading zeros so they are <em>n</em> bits long, where <em>n</em> is the order of the Hilbert curve. Start in state A and scan the bits of <em>x</em> and <em>y</em> from left to right. The first row of <a href="ch16.html#ch16tab7">Table 16–7</a> means that if the current state is A and the currently scanned bits are (0, 0), then
         set a variable to indicate to increment <em>y</em>, and enter state B. The other rows are interpreted similarly, with a suffix minus
         sign indicating to decrement the associated coordinate. A dash in the third column
         means do not alter the variable that keeps track of the coordinate changes.
      </p>
      
      <p class="fig-caption"><a id="ch16tab7"></a>T<small>ABLE</small> 16–7. T<small>AKING</small> O<small>NE</small> S<small>TEP ON THE</small> H<small>ILBERT</small> C<small>URVE</small></p>
      
      <div class="image"><img alt="Image" src="graphics/369tab01.jpg" /></div>
      
      <p class="indent">After scanning the last (rightmost) bits of <em>x</em> and <em>y</em>, increment or decrement the appropriate coordinate as indicated by the final value
         of the variable.
      </p>
      
      <p class="indent">A C program implementing these steps is shown in <a href="ch16.html#ch16fig11">Figure 16–11</a>. Variable <code>dx</code> is initialized in such a way that if invoked many times, the algorithm cycles around,
         generating the same Hilbert curve over and over again. (However, the step that connects
         one cycle to the next is not a unit step.)
      </p>
      
      <p class="codelink"><a id="page_370"></a><a href="images15.html#p16fig11" id="p16fig11a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting"><a id="ch16fig11"></a>void hil_inc_xy(unsigned *xp, unsigned *yp, int n) {<br /><br />   int i;<br />   unsigned x, y, state, dx, dy, row, dochange;<br /><br />   x = *xp;<br />   y = *yp;<br />   state = 0;                     // Initialize.<br />   dx = -((1 <span class="entity">&lt;&lt;</span> n) - 1);        // Init. -(2**n - 1).<br />   dy = 0;<br /><br />   for (i = n-1; i &gt;= 0; i--) {         // Do n times.<br />      row = 4*state | 2*((x &gt;&gt; i) &amp; 1) | (y &gt;&gt; i) &amp; 1;<br />      dochange = (0xBDDB &gt;&gt; row) &amp; 1;<br />      if (dochange) {<br />         dx = ((0x16451659 &gt;&gt; 2*row) &amp; 3) - 1;<br />         dy = ((0x51166516 &gt;&gt; 2*row) &amp; 3) - 1;<br />      }<br />      state = (0x8FE65831 &gt;&gt; 2*row) &amp; 3;<br />   }<br />   *xp = *xp + dx;<br />   *yp = *yp + dy;<br />}
      </p>
      
      <hr />
      
      <p class="fig-caption">F<small>IGURE</small> 16–11. Program for taking one step on the Hilbert curve.
      </p>
      
      <p class="indent"><a href="ch16.html#ch16tab7">Table 16–7</a> can readily be implemented in logic, as shown in <a href="ch16.html#ch16fig12">Figure 16–12</a>. In this figure, the variables have the following meanings:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/370fig01.jpg" /></div>
      
      <p class="noindent"><em>S</em> and <em>C</em> together identify the “state” of <a href="ch16.html#ch16tab7">Table 16–7</a>, with (<em>C, S</em>) = (0,0), (0,1), (1,0), and (1,1) denoting states A, B, C, and D, respectively. The
         output signals are <em>I</em><sub>0</sub> and <em>W</em><sub>0</sub>, which tell, respectively, whether to increment or decrement, and which variable
         to change. (In addition to the logic shown, an incrementer/decrementer circuit is
         required, with MUX’s to route either <em>x</em> or <em>y</em> to the incrementer/decrementer, and a circuit to route the altered value back to
         the register that holds <em>x</em> or <em>y</em>. Alternatively, two incrementer/decrementer circuits could be used.)
      </p>
      
      <div class="image"><a id="page_371"></a><img alt="Image" src="graphics/16fig12.jpg" /></div>
      
      <p class="fig-caption"><a id="ch16fig12"></a>F<small>IGURE</small> 16–12. Logic circuit for incrementing <em>(x, y)</em> by one step along the Hilbert curve.
      </p>
      
      <h3><a id="ch16lev5"></a><strong>16–5 Non-Recursive Generating Algorithms</strong></h3>
      
      <p class="noindent">The algorithms of <a href="ch16.html#ch16tab2">Tables 16–2 and 16–7</a> provide two non-recursive algorithms for generating the Hilbert curve of any order.
         Either algorithm can be implemented in hardware without great difficulty. Hardware
         based on <a href="ch16.html#ch16tab2">Table 16–2</a> includes a register holding <em>s</em>, which it increments for each step, and then converts to (<em>x, y</em>) coordinates. Hardware based on <a href="ch16.html#ch16tab7">Table 16–7</a> would not have to include a register for <em>s</em>, but the algorithm is more complicated.
      </p>
      
      <h3><a id="ch16lev6"></a><strong>16–6 Other Space-Filling Curves</strong></h3>
      
      <p class="noindent">As was mentioned, Peano was first, in 1890, to discover a space-filling curve. The
         many variations discovered since then are often called “Peano curves.” One interesting
         variation of Hilbert’s curve was discovered by Eliakim Hastings Moore in 1900. It
         is “cyclic” in the sense that the end point is one step away from the starting point.
         The Peano curve of order 3, and the Moore curve of order 4, are shown in <a href="ch16.html#ch16fig13">Figure 16–13</a>. Moore’s curve has an irregularity in that the order 1 curve is upright-down <img alt="Image" src="graphics/371fig01.jpg" />, but this shape does not appear in the higher-order curves. Except for this minor
         exception, the algorithms for dealing with Moore’s curve are very similar to those
         for the Hilbert curve.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/16fig13.jpg" /></div>
      
      <p class="fig-caption"><a id="ch16fig13"></a>F<small>IGURE</small> 16–13. Peano (left) and Moore (right) curves.
      </p>
      
      <p class="indent">The Hilbert curve has been generalized to arbitrary rectangles and to three and higher
         dimensions. The basic building block for a three-dimensional Hilbert <a id="page_372"></a>curve is shown below. It hits all eight points of a 2×2×2 cube. These and many other
         space-filling curves are discussed in [Sagan].
      </p>
      
      <div class="image"><img alt="Image" src="graphics/16fig14.jpg" /></div>
      
      <h3><a id="ch16lev7"></a><strong>16–7 Applications</strong></h3>
      
      <p class="noindent">Space-filling curves have applications in image processing: compression, halftoning,
         and textural analysis [L&amp;S]. Another application is to improve computer performance
         in ray tracing, a graphics-rendering technique. Conventionally, a scene is scanned
         by projecting rays across the scene in ordinary raster scan line order (left to right
         across the screen, and then top to bottom). When a ray hits an object in the simulated
         scene’s database, the color and other properties of the object at that point are determined,
         and the results are used to illuminate the pixel through which the ray was sent. (This
         is an oversimplification, but it’s adequate for our purposes.) One problem is that
         the database is often large and the data on each object must be paged in and cast
         out as various objects are hit by the scanning ray. When the ray scans across a line,
         it often hits many objects that were hit in the previous scan, requiring them to be
         paged in again. Paging operations would be reduced if the scanning had some kind of
         locality property. For example, it might be helpful to scan a quadrant of the screen
         completely before going on to another quadrant.
      </p>
      
      <p class="indent">The Hilbert curve seems to have the locality property we are seeking. It scans a quadrant
         completely before scanning another, recursively, and also does not make a long jump
         when going from one quadrant to another.
      </p>
      
      <p class="indent"><a id="page_373"></a>Douglas Voorhies [Voor] has simulated what the paging behavior would likely be for
         the conventional uni-directional scan line traversal, the Peano curve, and the Hilbert
         curve. His method is to scatter circles of a given size randomly on the screen. A
         scan path hitting a circle represents touching a new object, and paging it in. When
         a scan leaves a circle, it is presumed that the object’s data remains in memory until
         the scan exits a circle of radius twice that of the “object” circle. Thus, if the
         scan leaves the object for just a short distance and then returns to it, it is assumed
         that no paging operation occurred. He repeats this experiment for many different sizes
         of circles, on a simulated 1024×1024 screen.
      </p>
      
      <p class="indent">Assume that entering an object circle and leaving its surrounding circle represent
         one paging operation. Then, clearly the normal scan line causes <em>D</em> paging operations in covering a (not too big) circle of diameter <em>D</em> pixels, because each scan line that enters it leaves its outer circle. The interesting
         result of Voorhies’s simulation is that for the Peano curve, the number of paging
         operations to scan a circle is about 2.7 and, perhaps surprisingly, is independent
         of the circle’s diameter. For the Hilbert curve, the figure is about 1.4, also independent
         of the circle’s diameter. Thus, the experiment suggests that the Hilbert curve is
         superior to the Peano curve, and vastly superior to the normal scan line path, in
         reducing paging operations. (The result that the page count is independent of the
         circles’ diameters is probably an artifact of the outer circle’s being proportional
         in size to the object circle.)
      </p>
      
      <p class="indent">The Hilbert curve has been used to assign jobs to processors when the processors are
         interconnected in a rectangular 2D or 3D grid [Cplant]. The processor allocation system
         software uses a linear list of the processors that follows a Hilbert curve over the
         grid. When a job that requires a number of processors is scheduled to run, the allocator
         allocates them from the linear list, much as a memory allocator would do. The allocated
         processors tend to be close together on the grid, which leads to good intercommunication
         properties.
      </p>
      
      <h4><strong>Exercises</strong></h4>
      
      <p class="question"><a href="ch19_answer.html#ch16ans1" id="ch16ansa1"><strong>1</strong>.</a> A simple way to cover an <em>n</em> × <em>n</em> grid in a way that doesn’t make too many big jumps, and hits every point once and
         only once, is to have a 2<em>n</em>-bit variable <em>s</em> that is incremented at each step, and form <em>x</em> from the first and every other bit of <em>s</em>, and <em>y</em> from the second and every other bit of <em>s</em>. This is equivalent to computing the perfect outer unshuffle of <em>s</em>, and then letting <em>x</em> and <em>y</em> be the left and right halves of the result. Investigate this curve’s locality property
         by sketching the curve for <em>n</em> = 3.
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch16ans2" id="ch16ansa2"><strong>2</strong>.</a> A variation of exercise 1 is to first transform <em>s</em> into Gray(<em>s</em>) (see page <a href="ch13.html#page_312">312</a>), and then let <em>x</em> and <em>y</em> be formed from every other bit of the result, as in exercise 1. Sketch the curve
         for <em>n</em> = 3. Has this improved the locality property?
      </p>
      
      <p class="question"><a href="ch19_answer.html#ch16ans3" id="ch16ansa3"><strong>3</strong>.</a> How would you construct a three-dimensional analog of the curve of exercise 1?<a id="page_374"></a></p>
      
   </body>
   
</html>