<html xmlns="http://www.w3.org/1999/xhtml">
   
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      
      <title>Answers To Exercises</title>
      
      <link href="9780133085013.css" rel="stylesheet" type="text/css" />
      
      <link href="page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
      
      <meta content="urn:uuid:767ce45a-85bb-4273-91f5-801bab42906b" name="Adept.expected.resource" />
      
   </head>
   
   <body>
      
      <h2><a id="page_405"></a><a id="answer"></a>Answers To Exercises
      </h2>
      
      <h3><strong>Chapter 1: Introduction</strong></h3>
      
      <p class="answer"><a href="ch01.html#ch01ansa1" id="ch01ans1"><strong>1</strong>.</a> The following is pretty accurate:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/405fig01.jpg" /></div>
      
      <p class="indenthanging">If <em>e</em><sub>2</sub> is not present in the <code>for</code> loop, the constant 1 is used for it in the above expansion (which would then be a
         nonterminating loop, unless something in <em>statement</em> terminates it).
      </p>
      
      <p class="indenthangingBB">Expressing a <code>for</code> loop in terms of a <code>do</code> loop is somewhat awkward, because the body of a <code>do</code> loop is always executed at least once, whereas the body of a <code>for</code> loop may not be executed at all, depending on <em>e</em><sub>1</sub> and <em>e</em><sub>2</sub>. Nevertheless, the <code>for</code> loop can be expressed as follows.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/405fig02.jpg" /></div>
      
      <p class="indenthanging">Again, if <em>e</em><sub>2</sub> is not present in the <code>for</code> loop, then use 1 for it above.
      </p>
      
      <p class="answer"><a href="ch01.html#ch01ansa2" id="ch01ans2"><strong>2</strong>.</a> If your code is
      </p>
      
      <p class="codelink"><a href="images17.html#p405fig04" id="p405fig04a">Click here to view code image</a></p>
      
      <p class="programlisting2">for (i = 0; i &lt;= 0xFFFFFFFF; i++) {...}</p>
      
      <p class="indenthanging">then you have an infinite loop. A loop that works is</p>
      
      <p class="codelink"><a href="images17.html#p405fig03" id="p405fig03a">Click here to view code image</a></p>
      
      <p class="programlisting2">i = 0xFFFFFFFF;<br />do {i = i + 1;...} while (i &lt; 0xFFFFFFFF);
      </p>
      
      <p class="answer"><a href="ch01.html#ch01ansa3" id="ch01ans3"><strong>3</strong>.</a> The text mentions <em>multiply</em>, which for 32 × 32 ==&lt; 64-bit multiplication needs two output registers.
      </p>
      
      <p class="indenthangingBB">It also mentions <em>divide</em>. The usual implementation of this instruction produces a remainder as well as the
         quotient, and execution time would be saved in many programs if both results were
         available.
      </p>
      
      <p class="indenthangingBB">Actually, the most natural machine division operation takes a doubleword dividend,
         a single word divisor, and produces a quotient and remainder. This uses three source
         registers and two targets.
      </p>
      
      <p class="indenthangingBB">Indexed store instructions use three source registers: the register being stored,
         the base register, and the index register.
      </p>
      
      <p class="indenthangingBB">To efficiently deal with bit fields in a register, many machines provide <em>extract</em> and <em>insert</em> instructions. The general form of <em>extract</em> needs three sources and one target. The source registers are the register that contains
         the field being extracted, a starting bit number, and an ending bit number or length.
         The <a id="page_406"></a>result is right justified and either zero- or sign-extended and placed in the target
         register. Some machines provide this instruction only in the form in which the field
         length is an immediate quantity, which is a reasonable compromise because that is
         the common case.
      </p>
      
      <p class="indenthangingBB">The general <em>insert</em> instruction reads four source registers and writes one target register. As commonly
         implemented, the sources are a register that contains the source bits to be inserted
         in the target (these come from the low-order end of the source register), the starting
         bit position in the target, and the length. In addition to reading these three registers,
         the instruction must read the target register, combine it with the bits to be inserted,
         and write the result to the target register. As in the case of <em>extract</em>, the field length may be an immediate quantity, in which case the instruction does
         three register reads and one write.
      </p>
      
      <p class="indenthangingBB">Some machines provide a family of <em>select</em> instructions:
      </p>
      
      <p class="codelink"><a href="images17.html#p406fig01" id="p406fig01a">Click here to view code image</a></p>
      
      <p class="programlistings1">SELcc RT,RA,RB,RC</p>
      
      <p class="indenthanging">Register RC is tested, and if it satisfies the condition specified in the opcode (shown
         as <code>cc</code>, which may be <code>EQ, GT, GE</code>, etc.), then RA is selected; otherwise, RB is selected. The selected register is
         copied to the target.
      </p>
      
      <p class="indenthangingBB">Although not common, a plausible instruction is <em>bit select</em>, or <em>multiplex</em>:
      </p>
      
      <p class="codelink"><a href="images17.html#p406fig02" id="p406fig02a">Click here to view code image</a></p>
      
      <p class="programlistings1">MUX RT,RA,RB,RC</p>
      
      <p class="indenthanging">Here RC contains a mask. Wherever the mask is 1, the corresponding bit of RA is selected,
         and wherever it is 0, the corresponding bit of RB is selected. That is, it performs
         the operation
      </p>
      
      <p class="codelink"><a href="images17.html#p406fig03" id="p406fig03a">Click here to view code image</a></p>
      
      <p class="programlistings1">RT &lt;-- RA &amp; RC | RB &amp; ~RC</p>
      
      <p class="indenthangingBB">Shift right/left double: A sometimes useful instruction is</p>
      
      <p class="codelink"><a href="images17.html#p406fig04" id="p406fig04a">Click here to view code image</a></p>
      
      <p class="programlistings1">SHLD RT,RA,RB,RC</p>
      
      <p class="indenthanging">This concatenates RA and RB, treating them as a double-length register, and shifts
         them left (or right) by an amount given by RC. RT gets the part of the result that
         has bits from RA and RB. These instructions are useful in “bignum” arithmetic and
         in more mundane situations.
      </p>
      
      <p class="indenthangingBB">In signal processing and other applications, it is helpful to have an instruction
         that computes A*B + C. This applies to both integer and floating-point data.
      </p>
      
      <p class="indenthangingBB">Of course, there are <em>load multiple</em> and <em>store multiple</em>, which require many register reads or writes. Although many RISCs have them, they
         are not usually considered to be RISC instructions.
      </p>
      
      <h3><a id="page_407"></a><strong>Chapter 2: Basics</strong></h3>
      
      <p class="answer"><a href="ch02.html#ch02ansa1" id="ch02ans1"><strong>1</strong>.</a> (Derivation by David de Kloet) Clearly the body of the <em>while</em>-loop is executed a number of times equal to the number of trailing 0’s in <strong><em>x</em></strong>. The <em>k</em> 1-bits partition the <em>n</em>-bit word into <em>k</em> + 1 segments, each containing 0 or more 0-bits. The number of 0’s in each word <em>is n-k</em>. If <em>N</em> is the number of words <img alt="Image" src="graphics/407fig01.jpg" />, but that need not concern us here), then the total number of 0’s in all the words
         is <em>N(n – k)</em>. By symmetry, the number of 0’s in any segment, summed over all N words, is the same,
         and is therefore equal to <em>N(n – k)/(k</em> + 1). Thus, the average number of 0’s in any segment is <em>(n-k)/(k+1)</em>, and this applies to the last segment, which is the number of trailing 0’s.
      </p>
      
      <p class="indenthangingBB">As an example, if <em>n</em> = 32 and <em>k</em> = 3, then the <em>while</em>-loop is executed 7.25 times, on average. On many machines the <em>while</em>-loop can be implemented in as few as three instructions <em>(and, shift right</em>, and <em>conditional branch)</em>, which might take as few as four cycles. With these parameters, the <em>while</em>-loop takes 4•7.25 = 29 cycles on average. This is less than the divide time on most
         32-bit machines, resulting in de Kloet’s algorithm being faster than Gosper’s. For
         larger values of <em>k</em>, de Kloet’s is still more favorable.
      </p>
      
      <p class="answer"><a href="ch02.html#ch02ansa2" id="ch02ans2"><strong>2</strong>.</a> The <em>and</em> with <strong>1</strong> makes the shift amount independent of all bits of <strong><em>x</em></strong> except for its rightmost bit. Therefore, by looking at only the rightmost bit of
         the shift amount, one can ascertain whether the result is <strong><em>x</em></strong> or <em>x</em> <span class="entity">&lt;&lt;</span> 1. Since both <strong><em>x</em></strong> and <strong><em>x</em></strong> <span class="entity">&lt;&lt;</span> 1 are right-to-left computable, choosing one of these based on a rightmost bit is
         also. The function <strong><em>x</em></strong> <span class="entity">&lt;&lt;</span> (<strong><em>x</em></strong> &amp; <strong>2</strong>), incidentally, is not right-to-left computable. But (<strong><em>x</em></strong> &amp; -<strong>2</strong>) <span class="entity">&lt;&lt;</span> (<strong><em>x</em></strong> &amp; <strong>2</strong>) is.
      </p>
      
      <p class="indenthangingBB">Another example is the function <strong><em>x</em><sup><em>n</em></sup></strong>, where we take <strong><em>x</em></strong><sup><strong>0</strong></sup> to be 1. This is not right-to-left computable because if <strong><em>x</em></strong> is even, then the rightmost bit of the result depends upon whether or not <strong><em>x</em></strong> <em>=</em> <strong>0</strong>, and thus is a function of bits to the left of the rightmost position. But if it
         were known <em>a priori</em> that the variable <strong><em>n</em></strong> is either 0 or 1, then <strong><em>x<sup>n</sup></em></strong> is right-to-left computable. Similarly, <strong><em>x<sup>n&amp;1</sup></em></strong> is right-to-left computable, for example, by
      </p>
      
      <div class="image"><img alt="Image" src="graphics/407equ01.jpg" /></div>
      
      <p class="indenthangingBB">Notice that <strong><em>x<sup>n</sup></em></strong> is like the left shift function in that <strong><em>x<sup>n</sup></em></strong> is right-to-left computable for any particular value of <strong><em>n</em></strong>, or if <strong><em>n</em></strong> is a variable restricted to the values 0 and 1, but not if <strong><em>n</em></strong> is an unrestricted variable.
      </p>
      
      <p class="answer"><a href="ch02.html#ch02ansa3" id="ch02ans3"><strong>3</strong>.</a> A somewhat obvious formula for addition is given on page <a href="ch02.html#page_16">16</a>, item (g):
      </p>
      
      <p class="center"><em>x</em> + <em>y</em> = (<em>x</em> ⊕ <em>y</em>) +2(<em>x</em> &amp; <em>y</em>).
      </p>
      
      <p class="indenthanging">Dividing each side by 2 gives Dietz’s formula. The addition in Dietz’s formula cannot
         overflow because the average of two representable integers is representable.
      </p>
      
      <p class="indenthangingBB"><a id="page_408"></a>Notice that if we start with item (i) on page <a href="ch02.html#page_16">16</a>, we obtain the formula given in the text for the ceiling average of two unsigned
         integers.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/408equ01.jpg" /></div>
      
      <p class="answer"><a href="ch02.html#ch02ansa4" id="ch02ans4"><strong>4</strong>.</a> Compute the floor average of <strong><em>a</em></strong> and <strong><em>b</em></strong>, and also of <strong><em>c</em></strong> and <strong><em>d</em></strong>, using Dietz’s formula. Then compute the floor average of <strong><em>x</em></strong> and <strong><em>y</em></strong>, and apply a correction:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/408equ02.jpg" /></div>
      
      <p class="indenthangingBB">The correction step is really four operations, not the seven that it appears to be,
         because the <em>exclusive or</em> terms were calculated earlier. It was arrived at by the following reasoning: The
         computed value of <strong><em>x</em></strong> can be lower than the true (real number) average by 1/2, and this error occurs if
         <strong><em>a</em></strong> is odd and <strong><em>b</em></strong> is even, or vice versa. This error amounts to 1/4 after <strong><em>x</em></strong> and <strong><em>y</em></strong> are averaged. If this were the only truncation error, the first value computed for
         <strong><em>r</em></strong> would be correct, because in this case the true average is an integer plus 1/4, and
         we want the floor average, so we want to discard the 1/4 anyway. Similarly, the truncation
         in computing <strong><em>y</em></strong> can make the computed average lower than the true average by 1/4. The first computed
         value of <strong><em>r</em></strong> can be lower than the true average of <strong><em>x</em></strong> and <strong><em>y</em></strong> by 1/2. These errors accumulate. If they sum to an error less than 1, they can be
         ignored, because we want to discard the fractional part of the true average anyway.
         But if all three errors occur, they sum to 1 / 4 + 1 / 4 + 1 / 2 = 1, which must be
         corrected by adding 1 to <strong><em>r</em></strong>. The last line does this: if one of <strong><em>a</em></strong> and <strong><em>b</em></strong> is odd, and one of <strong><em>c</em></strong> and <strong><em>d</em></strong> is odd, and one of <strong><em>x</em></strong> and <strong><em>y</em></strong> is odd, then we want to add 1, which the last line does.
      </p>
      
      <p class="answer"><a href="ch02.html#ch02ansa5" id="ch02ans5"><strong>5</strong>.</a> The expression for <img alt="Image" src="graphics/408fig01.jpg" /> to be simplified is
      </p>
      
      <p class="center">(<strong><em>¬x</em></strong> | <strong><em>y</em></strong>) &amp; ((<strong><em>x</em></strong> ⊕ <strong><em>y</em></strong>) | ¬(<strong><em>y</em></strong> – <strong><em>x</em></strong>)).
      </p>
      
      <p class="indenthangingBB">Only bit 31 of <strong><em>x</em></strong> and <strong><em>y</em></strong> is relevant in the logical operations of this expression. Because <strong><em>y</em></strong><sub>31</sub> = 0, the expression immediately simplifies to
      </p>
      
      <p class="center"><strong><em>¬x</em></strong> &amp; (<strong><em>x</em></strong> | ¬(<strong><em>y</em></strong>– <strong><em>x</em></strong>)).
      </p>
      
      <p class="indenthanging">“Multiplying in” the ¬<strong><em>x</em></strong> (distributive law) gives
      </p>
      
      <p class="center"><strong><em>¬x</em></strong>&amp;¬(<strong><em>y</em></strong> – <strong><em>x</em></strong>),
      </p>
      
      <p class="indenthanging"><a id="page_409"></a>and applying De Morgan’s law further simplifies it to three elementary instructions:
      </p>
      
      <p class="center">¬(<strong><em>x</em></strong> | (<strong><em>y</em></strong> – <strong><em>x</em></strong>)).
      </p>
      
      <p class="indenthanging">(Removing the complementation operator gives a two-instruction solution for the predicate
         <img alt="Image" src="graphics/409fig01.jpg" />.)
      </p>
      
      <p class="indenthangingBB">If <strong>y</strong> is a constant, we can use the identity ¬<strong><em>u</em></strong>= – 1 – <strong><em>u</em></strong> to rewrite the expression obtained from the distributive law as
      </p>
      
      <p class="center"><strong><em>¬x</em></strong> &amp; (<strong><em>x</em></strong> – (<strong><em>y</em></strong> + 1)),
      </p>
      
      <p class="indenthanging">which is three instuctions because the addition of 1 to <strong><em>y</em></strong> can be done before evaluating the expression. This form is preferable when <strong><em>y</em></strong> is a small constant, because the <em>add immediate</em> instruction can be used. (Problem suggested by George Timms.)
      </p>
      
      <p class="answer"><a href="ch02.html#ch02ansa6" id="ch02ans6"><strong>6</strong>.</a> To get a carry from the second addition, the carry from the first addition must be
         1, and the low-order 32 bits of the first sum must be all 1’s. That is, the first
         sum must be at least 2<sup>33</sup> – 1. But the operands are each at most 2<sup>32</sup> – 1, so their sum is at most 2<sup>33</sup> – 2.
      </p>
      
      <p class="answer"><a href="ch02.html#ch02ansa7" id="ch02ans7"><strong>7</strong>.</a> For notational simplicity, let us consider a 4-bit machine. Let <em>x</em> and <em>y</em> denote the integer values of 4-bit quantities under unsigned binary interpretation.
         Let <em>f</em> (<em>x, y</em>) denote the integer result of applying ordinary binary addition with end-around carry,
         to <em>x</em> and <em>y</em>, with a 4-bit adder and a 4-bit result. Then,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/409equ01.jpg" /></div>
      
      <div class="image"><img alt="Image" src="graphics/409tab01.jpg" /></div>
      
      <p class="indenthangingBB">The table at the right shows the one’s-complement interpretation of 4-bit binary words.
         Observe that the one’s-complement interpretation of a word whose straight binary interpretation
         is <em>x</em> is given by
      </p>
      
      <div class="image"><img alt="Image" src="graphics/409equ02.jpg" /></div>
      
      <p class="indenthangingBB">We must show that <em>f</em> (<em>x, y</em>), when interpreted as a one’s-complement integer, is the sum of <em>x</em> and <em>y</em> when they are interpreted as one’s-complement integers. That is, we must show that
      </p>
      
      <p class="center">ones(<em>x</em>) + ones(<em>y</em>) = ones(<em>f</em> (<em>x, y</em>)).
      </p>
      
      <p class="indenthanging">We are interested only in the non-overflow cases (that is, when the sum can be expressed
         as a one’s-complement integer).
      </p>
      
      <p class="indenthanging"><a id="page_410"></a>Case 0, 0 ≤ <em>x, y</em> ≤ 7. Then, ones(<em>x</em>) + ones(<em>y</em>) = <em>x</em> + <em>y</em>, and
      </p>
      
      <p class="center"><em>f</em> (<em>x, y</em>) = mod(<em>x</em> + <em>y</em> + 0, 16) = <em>x</em> + <em>y</em>.
      </p>
      
      <p class="indenthanging">For no overflow, the one’s-complement result must be in the range 0 to 7, and from
         the table it is apparent that we must have <em>x</em> + <em>y</em> ≤ 7. Therefore, ones(<em>x</em> + <em>y</em>) = <em>x</em> + <em>y</em>.
      </p>
      
      <p class="indenthangingBB">Case 1, 0 ≤ <em>x</em> ≤ 7, 8 ≤ <em>y</em> ≤ 15. Overflow cannot occur because ones(<em>x</em>) ≥ 0 and ones(<em>y</em>) ≤ 0. In this case, ones(<em>x</em>) + ones(<em>y</em>) = <em>x</em> + <em>y</em> – 15. If <em>x</em> + <em>y</em> &lt; 16,
      </p>
      
      <p class="center"><em>f</em> (<em>x, y</em>) = mod(<em>x</em> + <em>y</em> + 0, 16) = <em>x</em> + <em>y</em>.
      </p>
      
      <p class="indenthanging">In this case <em>x</em> + <em>y</em> must be at least 8, so ones(<em>x</em> + <em>y</em>) = <em>x</em> + <em>y</em> – 15. On the other hand, if <em>x</em> + <em>y</em> ≥ 16,
      </p>
      
      <p class="center"><em>f</em> (<em>x, y</em>) = mod(<em>x</em> + <em>y</em> + 1, 16) = <em>x</em> + <em>y</em> + 1 – 16 = <em>x</em> + <em>y</em> – 15.
      </p>
      
      <p class="indenthanging">Because <em>x</em> + <em>y</em> is at most 22 and is at least 16, 1 ≤ <em>x</em> + <em>y</em> – 15 ≤ 7, so that ones(<em>x</em> + <em>y</em> – 15) = <em>x</em> + <em>y</em> – 15.
      </p>
      
      <p class="indenthangingBB">Case 2, 8 ≤ <em>x</em> ≤ 15, 0 ≤ <em>y</em> ≤ 7. This is similar to case 1 above.
      </p>
      
      <p class="indenthangingBB">Case 3, 8 ≤ <em>x</em> ≤ 15, 8 ≤ <em>y</em> ≤ 15. Then, ones(<em>x</em>) + ones(<em>y</em>) = <em>x</em> – 15 + <em>y</em> – 15 = <em>x</em> + <em>y</em> – 30, and
      </p>
      
      <p class="center"><em>f</em> (<em>x, y</em>) = mod(<em>x</em> + <em>y</em> + 1, 16) = <em>x</em> + <em>y</em> + 1 – 16 = <em>x</em> + <em>y</em> – 15.
      </p>
      
      <p class="indenthanging">Because of the limits on <em>x</em> and <em>y</em>, 16 ≤ <em>x</em> + <em>y</em> ≤ 30. To avoid overflow, the table reveals that we must have <em>x</em> + <em>y</em> ≥ 23. For, in terms of one’s-complement interpretation, we can add –6 and –1, or
         –6 and –0, but not –6 and –2, without getting overflow. Therefore, 23 ≤ <em>x</em> + <em>y</em> ≤ 30. Hence 8 ≤ <em>x</em> + <em>y</em> – 15 ≤ 15, so that ones(<em>x</em> + <em>y</em> – 15) = <em>x</em> + <em>y</em> – 30.
      </p>
      
      <p class="indenthangingBB">For the carry propagation question, for one’s-complement addition, the worst case
         occurs for something like
      </p>
      
      <p class="codelink"><a href="images17.html#p410fig01" id="p410fig01a">Click here to view code image</a></p>
      
      <p class="programlisting2">  111...1111<br />+ 000...0100<br />  ----------<br />  000...0011<br />+          1 (end-around carry)<br />  ----------<br />  000...0100
      </p>
      
      <p class="indenthanging">for which the carry is propagated <em>n</em> places, where <em>n</em> is the word size. In two’s-complement addition, the worst case is <em>n</em> – 1 places, assuming the carry out of the high-order position is discarded.
      </p>
      
      <p class="indenthangingBB">The following comparisons are interesting, using 4-bit quantities for illustration:
         In straight binary (unsigned) or two’s-complement arithmetic, the sum <a id="page_411"></a>of two numbers is always (even if overflow occurs) correct modulo 16. In one’s-complement,
         the sum is always correct modulo 15. If <em>x</em><sub><em>n</em></sub> denotes bit <em>n</em> of <em>x</em>, then in two’s-complement notation, <em>x</em> = -8<em>x</em><sub>3</sub> + 4<em>x</em><sub>2</sub> + 2x<sub>1</sub> + <em>x</em><sub>0</sub>. In one’s-complement notation, <em>x</em> = -7<em>x</em><sub>3</sub> + 4<em>x</em><sub>2</sub> + 2x<sub>1</sub> + <em>x</em><sub>0</sub>.
      </p>
      
      <p class="answer"><a href="ch02.html#ch02ansa8" id="ch02ans8"><strong>8</strong>.</a> ((<strong><em>x</em></strong> ⊕ <strong><em>y</em></strong>)&amp; <strong><em>m</em></strong>) ⊕ <strong><em>y</em></strong>.
      </p>
      
      <p class="answer"><a href="ch02.html#ch02ansa9" id="ch02ans9"><strong>9</strong>.</a> <strong><em>x</em></strong> ⊕ <strong><em>y</em></strong> = (<strong><em>x</em></strong> | <strong><em>y</em></strong>) &amp; ¬(<strong><em>x</em></strong> &amp; <strong><em>y</em></strong>).
      </p>
      
      <p class="answer1"><a href="ch02.html#ch02ansa10" id="ch02ans10"><strong>10</strong>.</a> [Arndt] Variable <strong><em>t</em></strong> is 1 if the bits differ (six instructions).
      </p>
      
      <div class="image"><img alt="Image" src="graphics/411equ01.jpg" /></div>
      
      <p class="indenthanging">Adding the line <em>x</em> ← <em>x</em> ⊕ (<em>t</em> <span class="entity">&lt;&lt;</span> <em>i</em>) makes it swap bits <em>i</em> and <em>j</em></p>
      
      <p class="answer1"><a href="ch02.html#ch02ansa11" id="ch02ans11"><strong>11</strong>.</a> As described in the text, any Boolean function <em>f(x<sub>1</sub>, x<sub>2</sub>,..., x<sub>n</sub></em>) can be decomposed into the form <em>g(x<sub>1</sub>, x<sub>2</sub>,..., x<sub>n–1</sub></em>)⊕<em>x<sub>n</sub> h</em> (<em>x</em><sub>1</sub>,<em>x</em><sub>2</sub>,...,<em>x<sub>n—1,</sub></em>). Let <em>c</em> (<em>n</em>) be the number of instructions required for the decomposition of an <em>n</em>-variable Boolean function into binary Boolean instructions, for <em>n</em> ≥ <em>2</em>. Then
      </p>
      
      <p class="center"><em>c<sub>n+1</sub></em> = 2<em>c<sub>n</sub></em> + 2,
      </p>
      
      <p class="indenthanging">with <em>c</em><sub>2</sub> = 1. This has the solution
      </p>
      
      <p class="center"><em>c<sub>n</sub></em> = 3·2<sup><em>n</em> – 2</sup> –2.
      </p>
      
      <p class="indenthanging">(The least upper bound is much smaller.)</p>
      
      <p class="answer1"><a href="ch02.html#ch02ansa12" id="ch02ans12"><strong>12</strong>.</a> (a)
      </p>
      
      <div class="image"><img alt="Image" src="graphics/411equ02.jpg" /></div>
      
      <p class="indenthanging">which is in the required form.</p>
      
      <p class="indenthanging">(b) From part (a),</p>
      
      <div class="image"><img alt="Image" src="graphics/411equ03.jpg" /></div>
      
      <p class="indenthanging">which is in the required form.</p>
      
      <p class="answer1"><a id="page_412"></a><a href="ch02.html#ch02ansa13" id="ch02ans13"><strong>13</strong>.</a> Using the notation of <a href="ch02.html#ch02tab3">Table 2–3</a> on page <a href="ch02.html#page_54">54</a>, the missing functions can be obtained from 0000 = <em>andc</em> (<em>x, x</em>), 0011 = <em>and</em> (<em>x, x</em>), 0100 = <em>andc</em> (<em>y, x</em>), 0101 = <em>and</em> (<em>y, y</em>), 1010 = <em>nand</em> (<em>y, y</em>), 1011 = <em>cor</em> (<em>y, x</em>), 1100 = <em>nand</em> (<em>x, x</em>), and 1111 = <em>cor</em> (<em>x, x</em>).
      </p>
      
      <p class="answer1"><a href="ch02.html#ch02ansa14" id="ch02ans14"><strong>14</strong>.</a> No. The ten truly binary functions are, in numeric form,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/412fig01.jpg" /></div>
      
      <p class="indenthanging">By implementing function 0010 you get 0100 by interchanging the operands, and, similarly,
         1011 yields 1101. That’s all you can accomplish by interchanging the operands, because
         the other functions are commutative. Equating the operands, of course, reduces a function
         to a constant or unary function. Therefore, you need eight instruction types.
      </p>
      
      <p class="answer1"><a href="ch02.html#ch02ansa15" id="ch02ans15"><strong>15</strong>.</a> The table below shows one set of six instruction types that accomplish the task.
         Here, <em>x</em> denotes the contents of the register operand, and <em>k</em> denotes the contents of the immediate field.
      </p>
      
      <p class="tab-caption">S<small>IX</small> S<small>UFFICIENT</small> R-I B<small>OOLEAN</small> I<small>NSTRUCTIONS</small></p>
      
      <div class="image"><img alt="Image" src="graphics/412tab01.jpg" /></div>
      
      <p class="indenthangingBB">The missing functions can be obtained from 0000 = <em>and</em> (<em>x</em>, 0), 0010 = <em>and</em> (<em>x</em>, <img alt="Image" src="graphics/k-bar.jpg" />), 0011 = <em>or</em> (<em>x</em>, 0), 0100 = <em>nor</em> (<em>x</em>, <img alt="Image" src="graphics/k-bar.jpg" />), 1001 = <em>xor</em> (<em>x</em>, <img alt="Image" src="graphics/k-bar.jpg" />), 1010 = <em>const</em> (<em>x</em>, <img alt="Image" src="graphics/k-bar.jpg" />), 1011 = <em>or</em> (<em>x</em>, <img alt="Image" src="graphics/k-bar.jpg" />), 1100 = <em>nor</em> (<em>x</em>, 0), 1101 = <em>nand</em> (<em>x</em>, <img alt="Image" src="graphics/k-bar.jpg" />), and 1111 = <em>nand</em> (<em>x</em>, 0).
      </p>
      
      <p class="answer1"><a href="ch02.html#ch02ansa16" id="ch02ans16"><strong>16</strong>.</a> This writer does not know of an “analytic” way to do this. But it is not difficult
         to write a program that generates all Boolean functions of three variables that can
         be implemented with three binary instructions. Such a program is given in C below.
         It is written in as simple a way as possible to give a convincing answer to the question.
         Some optimizations are possible, which are mentioned below.
      </p>
      
      <p class="indenthangingBB">The program represents a function by an 8-bit string that is the truth table of the
         function, with the values for <em>x, y</em>, and <em>z</em> written in the usual way for a truth table. Each time a function is generated, it
         is checked off by setting a byte in vector <code>found</code> to 1. This vector is 256 bytes long and is initially all zero.
      </p>
      
      <p class="indenthanging"><a id="page_413"></a>The truth table that the program works with is shown in the table below.
      </p>
      
      <p class="fig-caption">T<small>RUTH</small> T<small>ABLE FOR</small> T<small>HREE</small> V<small>ARIABLES</small></p>
      
      <div class="image"><img alt="Image" src="graphics/413tab01.jpg" /></div>
      
      <p class="indenthangingBB">The six columns of the truth table are stored in a vector <code>fun</code>. The first three positions of <code>fun</code> contain the truth table columns for <em>x, y</em>, and <em>z</em>. These columns have the values hexadecimal 0F, 33, and 55, which represent the trivial
         functions <em>f</em> (<em>x, y, z</em>) = <em>x, f</em> (<em>x, y, z</em>) = <em>y</em>, and <em>f</em> (<em>x, y, z</em>) = <em>z</em>. The next three positions will contain the truth table columns for the functions
         generated by one, two, and three binary instructions, respectively, for the current
         trial.
      </p>
      
      <p class="indenthangingBB">The program conceptually consists of three nested loops, one for each instruction
         currently being tried. The outermost loop iterates over all 16 binary Boolean operations,
         operating on all pairs of <em>x, y</em>, and <em>z</em> (16*3*3 = 144 iterations). For each iteration, the result of operating on all eight
         bits of <em>x, y</em>, and/or <em>z</em> in parallel is put in <code>fun[3]</code>.
      </p>
      
      <p class="indenthangingBB">The next level of looping similarly iterates over all 16 binary Boolean operations,
         operating on all pairs of <em>x, y, z</em>, and the result of the outermost loop (16*4*4 = 256 iterations). For each iteration,
         the result is put in <code>fun[4]</code>.
      </p>
      
      <p class="indenthangingBB">The innermost level of looping similarly iterates over all 16 binary Boolean operations,
         operating on all pairs of <em>x, y, z</em>, and the results of the outer two loops (16*5*5 = 400 iterations). For each of these
         calculated functions, the corresponding byte of <code>found</code> is set to 1.
      </p>
      
      <p class="indenthangingBB">At the end, the program writes out vector <code>found</code> in 16 rows of 16 vector elements each. Several positions of vector <code>found</code> are 0, showing that three binary Boolean instructions do not suffice to implement
         all 256 Boolean functions of three variables. The first function that was not calculated
         is number 0x16, or binary 00010110, which represents the function <em><img alt="Image" src="graphics/x-bar.jpg" />yz</em> + <em>x<img alt="Image" src="graphics/y-bar.jpg" />z</em> + <em>xy<img alt="Image" src="graphics/z-bar.jpg" /></em>.
      </p>
      
      <p class="indenthangingBB">There are many symmetries that could be used to reduce the number of iterations. For
         example, for a given operation <em>op</em> and operands <em>x</em> and <em>y</em>, it is not necessary to evaluate both <em>op</em>(<em>x, y</em>) and <em>op</em>(<em>y, x</em>), because if <em>op</em>(<em>x, y</em>) is evaluated, then <em>op</em>(<em>y, x</em>) will result from <em>op’</em>(<em>x, y</em>) where <em>op’</em> is another of the 16 binary operations. Similarly, it is not necessary to evaluate
         <em>op</em>(<em>x, x</em>), because that will be equal to <em>op’</em>(<em>x, y</em>) for some other function <em>op’</em>. Thus, the outermost loops that select combinations of operands to try could be written
      </p>
      
      <p class="codelink"><a id="page_414"></a><a href="images17.html#p414fig02" id="p414fig02a">Click here to view code image</a></p>
      
      <p class="programlisting2">for (i1 = 0; i1 &lt; 3; i1++) {<br />for (i2 = i1 + 1; i2 &lt; 3; i2++) {
      </p>
      
      <p class="indenthanging">and similarly for the other loops.</p>
      
      <p class="indenthangingBB">Another improvement results from observing that it is not necessary to include all
         16 binary Boolean operations in the table. The operations numbered 0, 3, 5, 10, 12,
         and 15 can be omitted, reducing the loops that iterate over the operations from 16
         to ten iterations. The argument in support of this is a little lengthy and is not
         given here.
      </p>
      
      <p class="indenthangingBB">The program can be easily changed to experiment with smaller instruction sets, or
         allow more instructions, or handle more variables. But be forewarned: The execution
         time increases dramatically with the number of instructions being allowed, because
         that determines the level of nesting in the main program. As a practical matter, you
         can’t go beyond five instructions.
      </p>
      
      <p class="codelink"><a href="images17.html#p414fig01" id="p414fig01a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting">/* Determines which of the 256 Boolean functions of three variables can be implemented
         with three binary Boolean instructions if the instruction set includes all 16 binary
         Boolean operations. */<br /><br />#include &lt;stdio.h&gt;<br /><br />char found[256];<br /><br />unsigned char boole(int op, unsigned char x,<br />                            unsigned char y) {<br />    switch (op) {<br />      case 0: return 0;<br />      case 1: return x &amp; y;<br />      case 2: return x &amp; ~y;<br />      case 3: return x;<br />      case 4: return ~x &amp; y;<br />      case 5: return y;<br />      case 6: return x ^ y;<br />      case 7: return x | y;<br />      case 8: return ~(x | y);<br />      case 9: return ~(x ^ y);<br />      case 10: return ~y;<br />      case 11: return x | ~y;<br />      case 12: return ~x;<br />      case 13: return ~x | y;<br />      case 14: return ~(x &amp; y);<br />      case 15: return 0xFF;<br />    }<br />} <a id="page_415"></a><br />#define NB 16            // Number of Boolean operations.<br />int main() {<br /><br />   int i, j, o1, i1, i2, o2, j1, j2, o3, k1, k2;<br />   unsigned char fun[6];// Truth table, 3 columns for<br />                        // x, y, and z, and 3 columns<br />                        // for computed functions.<br /><br />   fun[0] = 0xOF;       // Truth table column for x,<br />   fun[1] = 0x33;       // y,<br />   fun[2] = 0x55;       // and z.<br /><br />   for (o1 = 0; o1 &lt; NB; ol++) {<br />   for (i1 = 0; i1 &lt; 3; i1++) {<br />   for (i2 = 0; i2 &lt; 3; i2++) {<br />      fun[3] = boole(ol, fun[i1], fun[i2]);<br />      for (o2 = 0; o2 &lt; NB; o2++) {<br />      for (j1 = 0; j1&lt; 4; j1++) {<br />      for (j2 = 0; j2 &lt; 4; j2++) {<br />        fun[4] = boole(o2, fun[j1], fun[j2]);<br />        for (o3 = 0; o3 &lt; NB; o3++) {<br />        for (k1 = 0; k1 &lt; 5; k1++) {<br />        for (k2 = 0; k2 &lt; 5; k2++) {<br />          fun[5] = boole(o3, fun[kl], fun[k2]);<br />          found[fun[5]] = 1;<br />        }}}<br />      }}}<br />   }}}<br />   printf("0 1 2 3 4 5 6 7 8 9 A B C D E F\n");<br />   for (i = 0; i &lt; 16; i++) {<br />       printf("%X", i);<br />       for (j = 0; j &lt; 16; j++)<br />          printf("%2d", found[16*i + j]);<br />       printf("\n");<br />   }<br />   return 0;<br />}
      </p>
      
      <hr />
      
      <p class="center">All ternary Boolean functions computable with three instructions, <em>continued</em>.
      </p>
      
      <h3><strong>Chapter 3: Power-of-2 Boundaries</strong></h3>
      
      <p class="answer"><a href="ch03.html#ch03ansa1" id="ch03ans1"><strong>1</strong>.</a> (a) (<strong><em>x</em></strong> + <strong>4</strong>) &amp; –<strong>8</strong>.
      </p>
      
      <p class="indenthanging">(b) (<strong><em>x</em></strong> + <strong>3</strong>) &amp; –<strong>8</strong>.
      </p>
      
      <p class="indenthanging">(c) (<strong><em>x</em></strong> + <strong>3</strong> + ((<img alt="Image" src="graphics/415fig02.jpg" />) &amp; <strong>1</strong>)) &amp; –<strong>8</strong>.
      </p>
      
      <p class="indenthangingBB">Part (c) can be done in four instructions if the <em>extract</em> instruction is available; it can do (<img alt="Image" src="graphics/415fig02.jpg" />) &amp; <strong>1</strong> in one instruction.
      </p>
      
      <p class="indenthangingBB"><em>Note:</em> Unbiased rounding preserves the average value of a large set of random integers.
      </p>
      
      <p class="answer"><a id="page_416"></a><a href="ch03.html#ch03ansa2" id="ch03ans2"><strong>2</strong>.</a> The standard way to do part (a) is <img alt="Image" src="graphics/416fig01.jpg" />. If the remainder function is readily available, it can also be done with <strong><em>x</em></strong> + <strong>5</strong> – remu(<strong><em>x</em></strong> + <strong>5, 10</strong>), which saves a multiplication at the expense of an addition.
      </p>
      
      <p class="indenthangingBB">Part (b) is similar, but replace the 5 with 4 in the answer for part (a).</p>
      
      <p class="indenthangingBB">Part (c): Use the fact that an integer is an odd multiple of 10 if and only if it
         is an odd multiple of 2.
      </p>
      
      <p class="codelink"><a href="images17.html#p416fig02" id="p416fig02a">Click here to view code image</a></p>
      
      <p class="programlisting2">r = x % 10;<br />y = x - r;<br />if (r &gt; 5 | (r == 5 &amp; (y &amp; 2) != 0)<br />    y = y + 10;
      </p>
      
      <p class="indenthanging">An alternative (must have <strong><em>x</em></strong> ≤ <strong>2<sup>32</sup></strong> – <strong>6</strong>):
      </p>
      
      <p class="codelink"><a href="images17.html#p416fig03" id="p416fig03a">Click here to view code image</a></p>
      
      <p class="programlisting2">r = (x + 5)%10;<br />y = x + 5 - r;<br />if (r == 0 &amp; (y &amp; 2) != 0)<br />    y = y - 10;
      </p>
      
      <p class="answer"><a href="ch03.html#ch03ansa3" id="ch03ans3"><strong>3</strong>.</a> A possible implementation in C is shown below.
      </p>
      
      <p class="codelink"><a href="images17.html#p416fig04" id="p416fig04a">Click here to view code image</a></p>
      
      <p class="programlisting1">int loadUnaligned(int *a) {<br />   int *alo, *ahi;<br />   int xlo, xhi, shift;<br /><br />   alo = (int *)((int)a &amp; -4);<br />   ahi = (int *)(((int)a + 3) &amp; -4);<br />   xlo = *alo;<br />   xhi = *ahi;<br />   shift = ((int)a &amp; 3) <span class="entity">&lt;&lt;</span> 3;<br />   return ((unsigned)xlo &gt;&gt; shift) | (xhi <span class="entity">&lt;&lt;</span>; (32-shift));<br />}
      </p>
      
      <h3><strong>Chapter 4: Arithmetic Bounds</strong></h3>
      
      <p class="answer"><a href="ch04.html#ch04ansa1" id="ch04ans1"><strong>1</strong>.</a> For <strong><em>a</em></strong> <em>=</em> <strong><em>c</em></strong> <em>=</em> <strong>0</strong>, inequalities (5) become
      </p>
      
      <div class="image"><img alt="Image" src="graphics/416fig05.jpg" /></div>
      
      <p class="indenthangingBB">Because the quantities are unsigned, <em>-d</em> &lt; 0 is equivalent to <em>d</em> ≠ 0, and <em>b</em> ≥ 0 is true. Therefore, the inequalities simplify to
      </p>
      
      <div class="image"><img alt="Image" src="graphics/416fig06.jpg" /></div>
      
      <p class="indenthangingBB"><a id="page_417"></a>This is simply the observation that if <strong><em>d</em></strong>= <strong>0</strong>, then <strong><em>y</em></strong>= <strong>0</strong> and so, trivially, <strong>0</strong> ≤ <strong><em>x</em></strong>– <strong><em>y</em></strong>≤ <strong><em>b</em></strong>. On the other hand, if <strong><em>d</em></strong> ≠ 0, then the difference can attain the value <strong>0</strong> by choosing <strong><em>x</em></strong>= <strong><em>y</em></strong>= <strong>0</strong>, and it can attain the maximum unsigned number by choosing <strong><em>x</em></strong>= <strong>0</strong> and <strong><em>y</em></strong>= <strong>1</strong>.
      </p>
      
      <p class="answer"><a href="ch04.html#ch04ansa2" id="ch04ans2"><strong>2</strong>.</a> If <code>a</code> = 0, the test <code>if (temp &gt;= a)</code> is always true. Therefore, when the first position (from the left) is found in which
         the bits of <code>b</code> and <code>d</code> are 1, the program sets that bit of <code>b</code> equal to <code>0</code> and the following bits equal to 1, and returns that value <em>or</em>’ed with <code>d</code>. This can be accomplished more simply with the following replacement for the body
         of the procedure. The <code>if</code> statement is required only on machines that have mod 32 shifts, such as the Intel
         x86 family.
      </p>
      
      <p class="codelink"><a href="images17.html#p417fig01" id="p417fig01a">Click here to view code image</a></p>
      
      <p class="programlisting2">temp = nlz(c &amp; d);<br />if (temp == 0) return 0xFFFFFFFF;<br />m = 1 <span class="entity">&lt;&lt;</span> (32 - temp);<br />return b | d | (m - 1);
      </p>
      
      <p class="indenthanging">For example, suppose</p>
      
      <div class="image"><img alt="Image" src="graphics/417fig02.jpg" /></div>
      
      <p class="indenthanging">Then to find the maximum value of <strong><em>x</em></strong>| <strong><em>y</em></strong>, the procedure is to scan from the left for the first position in which <strong><em>b</em></strong> and <strong><em>d</em></strong> are both <strong>1</strong>. The maximum value is <strong><em>c</em></strong>| <strong><em>d</em></strong> for bits to the left of that position, and <strong>1</strong>’s for bits at and to the right of that position. For the example, this is <strong>0b01001000</strong> | <strong>0b00101010</strong> | <strong>0b0000 1111</strong> = <strong>0b0110 1111</strong>.
      </p>
      
      <h3><strong>Chapter 5: Counting Bits</strong></h3>
      
      <p class="answer"><a href="ch05.html#ch05ansa1" id="ch05ans1"><strong>1</strong>.</a> A version from Norbert Juffa:
      </p>
      
      <p class="codelink"><a href="images17.html#p417fig03" id="p417fig03a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting1">int ntz (unsigned int n) {<br />    static unsigned char tab[32] =<br />    {  0, 1, 2, 24, 3, 19, 6, 25,<br />      22, 4, 20, 10, 16, 7, 12, 26,<br />      31, 23, 18, 5, 21, 9, 15, 11,<br />      30, 17, 8, 14, 29, 13, 28, 27<br />    };<br />    unsigned int k;<br />    n = n &amp; (-n);     /* isolate lsb */<br />#if defined(SLOW_MUL)<br />    k = (n &lt;&lt; 11) - n;<br />    k = (k &lt;&lt; 2) + k;<br />    k = (k &lt;&lt; 8) + n;<br />    k = (k &lt;&lt; 5) - k; <a id="page_418"></a><br />#else<br />    k = n * 0x4d7651f;<br />#endif<br />    return n ? tab[k&gt;&gt;27] : 32;<br />}
      </p>
      
      <hr />
      
      <p class="answer"><a href="ch05.html#ch05ansa2" id="ch05ans2"><strong>2</strong>.</a> <img alt="Image" src="graphics/418fig01.jpg" />. This is used in the snoob function (page 15).
      </p>
      
      <p class="answer"><a href="ch05.html#ch05ansa3" id="ch05ans3"><strong>3</strong>.</a> Denote the parallel prefix operation applied to <strong><em>x</em></strong> by PP-XOR(<strong><em>x</em></strong>). Then, if <img alt="Image" src="graphics/418fig02.jpg" />. To see this, let <strong><em>x</em></strong> be the 4-bit quantity <em>abcd</em> (where each letter denotes a single bit). Then
      </p>
      
      <div class="image"><img alt="Image" src="graphics/418fig03.jpg" /></div>
      
      <p class="indenthanging">For the parallel suffix operation, if <strong><em>y</em></strong>= PS-XOR(<strong><em>x</em></strong>) then, as you might guess, <strong><em>x</em></strong>= <strong><em>y</em></strong> ⊕ (<strong><em>y</em></strong>&lt;&lt; 1).
      </p>
      
      <h3><strong>Chapter 6: Searching Words</strong></h3>
      
      <p class="answer"><a href="ch06.html#ch06ansa1" id="ch06ans1"><strong>1</strong>.</a> Length and position of the longest string of 1’s (c.f. Norbert Juffa):
      </p>
      
      <p class="codelink"><a href="images17.html#p418fig04" id="p418fig04a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting1">int fmaxstr1(unsigned x, int *apos) {<br />   int k;<br />   unsigned oldx;<br /><br />   oldx = 0;<br />   for (k = 0; x != 0; k++) {<br />      oldx = x;<br />      x &amp;= 2*x;<br />   }<br />   *apos = nlz(oldx);<br />   return k;<br />}
      </p>
      
      <hr />
      
      <p class="answer"><a href="ch06.html#ch06ansa2" id="ch06ans2"><strong>2</strong>.</a> As said in the text, this can be done by first left-propagating the 0’s in <em>x</em> by <em>n</em> – 1 positions, and then finding the shortest string of 1’s in the revised <em>x</em>. A good way to do the left-propagation is to use the code of <a href="ch06.html#ch06fig5">Figure 6–5</a> on page <a href="ch06.html#page_125">125</a>, which is logarithmic in its execution time. (But the second part of the algorithm
         is linear in the length of the shortest string of 1’s in the revised <em>x</em>.) The code is shown below. It assumes that 1 ≤ <em>n</em> ≤ 32. In the “not found” case, the function returns with apos = 32. In this case,
         the length should be regarded as undefined, but it happens to return a length of <em>n</em> – 1.
      </p>
      
      <p class="codelink"><a id="page_419"></a><a href="images17.html#p419fig01" id="p419fig01a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting">int bestfit(unsigned x, int n, int *apos) {<br />   int m, s;<br /><br />   m = n;<br />   while (m &gt; 1) {<br />      s = m &gt;&gt; 1;<br />      x = x &amp; (x &lt;&lt; s);<br />      m = m - s;<br />   }<br />   return fminstr1(x, apos) + n - 1;<br />}
      </p>
      
      <hr />
      
      <p class="answer"><a href="ch06.html#ch06ansa3" id="ch06ans3"><strong>3</strong>.</a> The code below uses an expression from page 12 for turning off the rightmost contiguous
         string of 1’s.
      </p>
      
      <p class="codelink"><a href="images17.html#p419fig02" id="p419fig02a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting">int fminstr1(unsigned x, int *apos) {<br />   int k, kmin, y0, y;<br />   unsigned int x0, xmin;<br /><br />   kmin = 32;<br />   y0 = pop(x);<br />   x0 = x;<br />   do {<br />      x = ((x &amp; -x) + x) &amp; x;   // Turn off rightmost<br />      y = pop(x);               // string.<br />      k = y0 - y;               // k = length of string<br />      if (k &lt;= kmin) {          // turned off.<br />         kmin = k;              // Save shortest length<br />         xmin = x;              // found, and the string.<br />      }<br />      y0 = y;<br />   } while (x != 0);<br />   *apos = nlz(x0 ^ xmin);<br />   return kmin;<br />}
      </p>
      
      <hr />
      
      <p class="indenthangingBB">The function executes in 5 + 11<em>n</em> instructions, where <em>n</em> is the number of strings of 1’s in <em>x</em>, for <em>n</em> ≥ 1 (that is, for <em>x</em> ≠ 0.) This assumes the <em>if</em>-test goes either way half the time, and that pop(<strong><em>x</em></strong>) and nlz(<strong><em>x</em></strong>) count as one instruction each. By making changes to the sense of the <code>“if (k &lt;= kmin)”</code> test, and to the initialization of <code>kmin</code>, it can be made to find the longest string of 1’s, and either the leftmost or the
         rightmost in the case of equally long strings. It is also easily modified to perform
         the “best fit” function.
      </p>
      
      <p class="answer"><a href="ch06.html#ch06ansa4" id="ch06ans4"><strong>4</strong>.</a> The first bit of <strong><em>x</em></strong> will be 1, and hence mark the beginning of a string of 1’s, with probability 0.5.
         Any other bit marks the beginning of a string of 1’s with <a id="page_420"></a>probability 0.25 (it must be 1, and the bit to its left must be 0). Therefore the
         average number of strings of 1’s is 0.5 + 31•0.25 = 8.25.
      </p>
      
      <p class="answer"><a href="ch06.html#ch06ansa5" id="ch06ans5"><strong>5</strong>.</a> One would expect the vast majority of words, if they are fairly long, to contain
         a string of 1’s of length 1. For, if it begins with 10, or ends with 01, or contains
         the string 010, then its shortest contained string of 1’s is of length 1. Therefore
         the average length is probably just slightly more than 1.
      </p>
      
      <p class="indenthangingBB">An exhaustive check of all 2<sup>32</sup> words shows that the average length of the shortest string of 1’s is approximately
         1.011795.
      </p>
      
      <p class="answer"><a href="ch06.html#ch06ansa6" id="ch06ans6"><strong>6</strong>.</a> (Solution by John Gunnels) This problem is surprisingly difficult, but the technique
         used is a good one to know. The solution is based on a recursion that counts the number
         of words in each of four sets, as shown in the table below. In this table, “singleton”
         means a string of 1’s of length 1, “nnn” denotes a string of length ≥ 0 that does
         not contain a singleton, and “sss” means a string of length ≥ 1 that contains a singleton.
         The ellipsis means 0 or more of the preceding bit. Every binary word is in one and
         only one of these four sets.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/420tab01.jpg" /></div>
      
      <p class="indenthangingBB">At each step, a bit is appended to the right-hand end of the word. As this is done,
         a word moves from one set to another as shown below. It moves to the left alternative
         if a 0 is appended, and to the right alternative if a 1 is appended.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/420equ01.jpg" /></div>
      
      <p class="indenthanging">For example, the word 1101 is in set <em>B</em>. If a 0 is appended, it becomes 11010, which is in set <em>D</em>. If a 1 is appended, it becomes 11011, which is in set <em>C</em>.
      </p>
      
      <p class="indenthangingBB">Let <em>a<sub>n</sub>, b<sub>n</sub>, c<sub>n</sub></em>, and <em>d<sub>n</sub></em> denote the sizes of sets <em>A, B, C</em>, and <em>D</em>, respectively, after <em>n</em> steps (when the words are of length <em>n</em>). Then
      </p>
      
      <div class="image"><img alt="Image" src="graphics/420equ02.jpg" /></div>
      
      <p class="indenthanging"><a id="page_421"></a>This is because set <em>A</em> at step <em>n</em> + 1 contains every member of set <em>A</em> at step <em>n</em>, with a 0 appended, and also every member of set <em>C</em> at step <em>n</em>, with a 0 appended. Set <em>B</em> at step <em>n</em> + 1 contains only every member of set <em>A</em> at step <em>n</em>, with a 1 appended, and so on.
      </p>
      
      <p class="indenthangingBB">The initial conditions are <em>a</em><sub>0</sub> = 1 and <em>b</em><sub>0</sub> = <em>c</em><sub>0</sub> = <em>d</em><sub>0</sub> = 0.
      </p>
      
      <p class="indenthangingBB">It is a simple matter to evaluate these difference equations with a computer program
         or even by hand. The result, for <em>n</em> = 32, is
      </p>
      
      <div class="image"><img alt="Image" src="graphics/421equ01.jpg" /></div>
      
      <p class="indenthanging">The last line gives the number we are interested in—the number of words for which
         their shortest contained string of 1’s is of length 1. It is about 98.9 percent of
         the number of 32-bit words (2<sup>32</sup>).
      </p>
      
      <p class="indenthangingBB">What about a closed-form solution? This is also difficult to obtain. We will just
         sketch a solution.
      </p>
      
      <p class="indenthangingBB">Let <em>e<sub>n</sub> = b<sub>n</sub> + d<sub>n</sub></em>, which is the quantity we desire to find. Then, from the difference equations, and
         using the fact that <em>a<sub>n</sub> + b<sub>n</sub> + c<sub>n</sub>+ d<sub>n</sub></em> = 2<sup><em>n</em></sup>,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/421equ02.jpg" /></div>
      
      <p class="indenthanging">Thus, if we can find a closed-form formula for <em>a<sub>n</sub></em>, we will have one for <em>e<sub>n</sub></em>.
      </p>
      
      <p class="indenthangingBB">We can find a single-variable difference equation for <em>a<sub>n</sub></em> as follows. From the difference equations,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/421equ03.jpg" /></div>
      
      <p class="indenthangingBB">This difference equation can be solved by well-known methods. The process is a bit
         lengthy and messy and won’t be gone into here. It involves the solution of a cubic
         polynomial that has two complex roots. When combined with the equation for <em>e<sub>n</sub></em>, we obtain, approximately,
      </p>
      
      <div class="image"><a id="page_422"></a><img alt="Image" src="graphics/422equ01.jpg" /></div>
      
      <p class="indenthanging">If <em>n</em> is an integer, the imaginary parts cancel out, which is not hard to prove. (<em>Hint:</em> If <em>x</em> and <em>y</em> are complex conjugates, then so are <em>x<sup>n</sup></em> and <em>y<sup>n</sup></em>.)
      </p>
      
      <p class="indenthangingBB">We can get a formula involving only real numbers. The real part of the second term
         of the formula above is certainly less than
      </p>
      
      <p class="center">|0.29425 – 0.13811 <em>i</em> |·|0.12256 + 0.74486<em>i</em> |<sup><em>n</em> +1</sup></p>
      
      <p class="indenthanging">which is, for <em>n</em> = 0,
      </p>
      
      <p class="center">0.32505 · 0.75488 ≈ 0.24537,</p>
      
      <p class="indenthanging">and is still smaller for <em>n</em> &gt; 0. The same holds for the last term of the equation for <em>e<sub>n</sub></em>. Therefore the real part of the last two terms sum to less than 0.5. Since <em>e<sub>n</sub></em> is known a priori to be an integer, this means that <em>e<sub>n</sub></em> is given by the first term rounded to the nearest integer, or
      </p>
      
      <div class="image"><img alt="Image" src="graphics/422equ02.jpg" /></div>
      
      <p class="answer"><a href="ch06.html#ch06ansa7" id="ch06ans7"><strong>7</strong>.</a> Briefly, this problem can be solved by using 10 sets of words, described below. In
         this table, “nnn” denotes a string of length ≥ 0 whose shortest contained string of
         1’s is of length 0 or is ≥ 3, “ddd” denotes a string of length ≥ 2 whose shortest
         contained string of 1’s is of length 2, and “sss” denotes a string of length ≥ 1 whose
         shortest contained string of 1’s is of length 1. (The sets keep track of the words
         that contain a singleton at a position other than the rightmost, because such words
         will never have a shortest contained string of 1’s of length 2.) The ellipsis means
         0 or more of the preceding bit.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/422tab01.jpg" /></div>
      
      <p class="indenthangingBB">At each step, as a bit is appended to the right-hand end of a word from one of these
         sets, it moves to another set as shown below. It moves to the left alternative if
         a 0 is appended, and to the right alternative if a 1 is appended.
      </p>
      
      <div class="image"><a id="page_423"></a><img alt="Image" src="graphics/423fig01.jpg" /></div>
      
      <p class="indenthangingBB">Let <em>a<sub>n</sub>, b<sub>n</sub>, ..., j<sub>n</sub></em> denote the sizes of sets <em>A, B, n</em> steps (when the words are of length <em>n</em>). Then
      </p>
      
      <div class="image"><img alt="Image" src="graphics/423fig02.jpg" /></div>
      
      <p class="indenthanging">The initial conditions are <em>a</em><sub>0</sub> = 1 and all other variables are 0.
      </p>
      
      <p class="indenthangingBB">The quantity we are interested in, the number of words whose shortest contained string
         of 1’s is of length 2, is given by <em>c<sub>n</sub> + e<sub>n</sub> + g<sub>n</sub> + h<sub>n</sub></em>. For <em>n</em> = 32, the difference equations give for this the value 44,410,452, which is about
         1.034 percent of the number of 32-bit words. As an additional result, the number of
         words whose shortest contained string of 1’s is of length 1 is given by <em>b<sub>n</sub> + f<sub>n</sub> + i<sub>n</sub> + j<sub>n</sub></em>, which for <em>n</em> = 32 evaluates to 4,247,705,401, confirming the result of the preceding exercise.
      </p>
      
      <p class="indenthangingBB">This is as far as we are going with this problem.</p>
      
      <h3><strong>Chapter 7: Rearranging Bits and Bytes</strong></h3>
      
      <p class="answer"><a href="ch07.html#ch07ansa1" id="ch07ans1"><strong>1</strong>.</a> An ordinary integer can be incremented by complementing a certain number of consecutive
         low-order bits.<sup><a id="ansfna1"></a><a href="footnotes.html#ansfn1">1</a></sup> For example, to add <strong>1</strong> to <strong>0x321F</strong>, it suffices to apply the <em>exclusive or</em> operation to it with the mask <strong>0x003F</strong>. Similarly, to increment a reversed integer, it suffices to complement some high-order
         bits with a mask that consists of an initial string of 1’s followed by 0’s. Möbius’s
         formula computes this mask and applies it to the reversed integer. (The method in
         the text that uses the nlz operation also does this.)
      </p>
      
      <p class="indenthangingBB">For an ordinary integer, the mask consists of 0’s followed by 1’s from the rightmost
         0-bit to the low-order bit. The integer that consists of a 1-bit at the position of
         the rightmost 0-bit in <strong><em>i</em></strong> is given by the expression ¬<strong><em>i</em></strong>&amp; (<strong><em>i</em></strong>+ <strong>1</strong>) (see <a href="ch02.html#ch02lev1">Section 2–1</a>). To increment an ordinary integer <strong><em>x</em></strong>, we would compute a mask by right-propagating the 1-bit in this integer, and then
         <em>exclusive or</em> the result to <strong><em>x</em></strong>. To increment a reversed integer, we need to compute the reflection, or bit <a id="page_424"></a>reversal, of that mask. The one-bit (power of 2) quantity ¬<strong><em>i</em></strong>&amp; (<strong><em>i</em></strong>+ <strong>1</strong>) can be reflected by dividing it into <strong><em>m</em></strong>/ <strong>2</strong>. (This step is the key to this algorithm.) For example, in the case of 4-bit integers,
         <strong><em>m</em></strong>/ <strong>2</strong> = <strong>8</strong>. <strong>8</strong> / <strong>1</strong> = <strong>8, 8</strong> / <strong>2</strong> = <strong>4, 8</strong> / <strong>4</strong> = <strong>2</strong>, and <strong>8</strong> / <strong>8</strong> = <strong>1</strong>. To compute the mask, it is necessary only to left-propagate the 1-bit of the quotient,
         which is done by subtracting the quotient from <strong><em>m</em></strong>. Finally, the mask is <em>exclusive-or</em>’ed to the reversed integer, which produces the next reversed integer.
      </p>
      
      <p class="indenthangingBB">As an example, suppose the integers are eight bits in length, so that <strong><em>m</em></strong> = <strong>256</strong>. Let <strong><em>i</em></strong> = <strong>19</strong> (binary <strong>00010011</strong>), so that <strong><em>revi</em></strong> = binary <strong>11001000</strong>. Then ¬<strong><em>i</em></strong>&amp; (<strong><em>i</em></strong>+ 1) = binary <strong>00000100</strong> (decimal <strong>4</strong>). Dividing this into <strong><em>m</em></strong>/ <strong>2</strong> gives a quotient of <strong>32</strong> (binary <strong>00100000</strong>). Subtracting this from <strong><em>m</em></strong> gives binary <strong>1110 0000</strong>. Finally, <em>exclusive or</em>’ing this mask to <strong><em>revi</em></strong> gives binary <strong>00101000</strong>, which is the reversed integer for decimal <strong>20</strong>.
      </p>
      
      <p class="answer"><a href="ch07.html#ch07ansa2" id="ch07ans2"><strong>2</strong>.</a> Notice that
      </p>
      
      <div class="image"><img alt="Image" src="graphics/424fig01.jpg" /></div>
      
      <p class="indenthanging">Also, notice that</p>
      
      <div class="image"><img alt="Image" src="graphics/424fig02.jpg" /></div>
      
      <p class="indenthanging">Thus, we have the formulas</p>
      
      <div class="image"><img alt="Image" src="graphics/424fig03.jpg" /></div>
      
      <p class="indenthanging">In general,</p>
      
      <div class="image"><img alt="Image" src="graphics/424fig04.jpg" /></div>
      
      <p class="indenthanging">where <em>W</em> is the length of the word being shuffled, which must be a power of 2.
      </p>
      
      <p class="answer"><a id="page_425"></a><a href="ch07.html#ch07ansa3" id="ch07ans3"><strong>3</strong>.</a> It is necessary only to change the two lines
      </p>
      
      <p class="codelink"><a href="images17.html#p425fig01" id="p425fig01a">Click here to view code image</a></p>
      
      <p class="programlisting2">s = s + b;<br />x = x &gt;&gt; 1;
      </p>
      
      <p class="indenthanging">to</p>
      
      <p class="codelink"><a href="images17.html#p425fig02" id="p425fig02a">Click here to view code image</a></p>
      
      <p class="programlisting2">s = s + 1;<br />x = x &gt;&gt; b;
      </p>
      
      <p class="answer"><a href="ch07.html#ch07ansa4" id="ch07ans4"><strong>4</strong>.</a> Any true LRU algorithm must record the complete order of references to the <em>n</em> cache lines in a set. Since there are <em>n</em>! orderings of <em>n</em> things, any implementation of LRU must use at least <span class="entity">⌈</span>log<sub>2</sub> <em>n</em>!<span class="entity">⌉</span> memory bits. The table below compares this to the number of bits required by the
         reference matrix method.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/425tab01.jpg" /></div>
      
      <h3><strong>Chapter 8: Multiplication</strong></h3>
      
      <p class="answer"><a href="ch08.html#ch08ansa1" id="ch08ans1"><strong>1</strong>.</a> As shown in <a href="ch08.html#ch08lev3">Section 8–3</a>, if <em>x</em> and <em>y</em> are the multiplication operands interpreted as signed integers, then their product
         interpreted as unsigned integers is
      </p>
      
      <p class="center">(<em>x</em> + 2<sup>32</sup><em>x</em><sub>31</sub>)(<em>y</em> + 2<sup>32</sup><em>y</em><sub>31</sub>) = <em>xy</em> + 2<sup>32</sup>(<em>x</em><sub>31</sub> <em>y</em> + <em>y</em><sub>31</sub><em>x</em>) + 2<sup>64</sup><em>x</em><sub>31</sub><em>y</em><sub>31</sub>,
      </p>
      
      <p class="indenthanging">where <em>x</em><sub>31</sub> and <em>y</em><sub>31</sub> are the sign bits of <em>x</em> and <em>y</em>, respectively, as integers 0 or 1. Because the product differs from <em>xy</em> by a multiple of 2<sup>32</sup>, the low-order 32 bits of the product are the same.
      </p>
      
      <p class="answer"><a href="ch08.html#ch08ansa2" id="ch08ans2"><strong>2</strong>.</a> Method 1: Chances are the machine has a multiplication instruction that gives the
         low-order 32 bits of the product of two 32-bit integers. That is,
      </p>
      
      <p class="codelink"><a href="images17.html#p425fig03" id="p425fig03a">Click here to view code image</a></p>
      
      <p class="programlisting2">low = u*v;</p>
      
      <p class="indenthanging">Method 2: Just before the <code>return</code> statement, insert
      </p>
      
      <p class="codelink"><a href="images17.html#p425fig04" id="p425fig04a">Click here to view code image</a></p>
      
      <p class="programlisting2">low = (w1 &lt;&lt; 16) + (w0 &amp; 0xFFFF);</p>
      
      <p class="indenthanging">Method 3: Save the products <code>u1*v0</code> and <code>u0*v1</code> in temporaries <code>t1</code> and <code>t2</code>. Then
      </p>
      
      <p class="codelink"><a href="images17.html#p425fig05" id="p425fig05a">Click here to view code image</a></p>
      
      <p class="programlisting2">low = ((t1 + t2) &lt;&lt; 16) + w0;</p>
      
      <p class="indenthangingBB"><a id="page_426"></a>Methods 2 and 3 are three basic RISC instructions each, and they work for both <code>mulhs</code> and its unsigned counterpart (and may be faster than method 1).
      </p>
      
      <p class="answer"><a href="ch08.html#ch08ansa3" id="ch08ans3"><strong>3</strong>.</a> Partition the 32-bit operands <em>u</em> and <em>v</em> into 16-bit unsigned components <em>a, b, c</em>, and <em>d</em>, so that
      </p>
      
      <div class="image"><img alt="Image" src="graphics/426equ01.jpg" /></div>
      
      <p class="indenthanging">where 0 ≤ <em>a, b, c, d</em> ≤ 2<sup>16</sup> – 1. Let
      </p>
      
      <div class="image"><img alt="Image" src="graphics/426equ02.jpg" /></div>
      
      <p class="indenthanging">Then <em>uv</em> = 2<sup>32</sup> <em>p</em> + 2<sup>16</sup>(<em>r</em> + <em>p</em> + <em>q</em>) + <em>q</em>, which is easily verified.
      </p>
      
      <p class="indenthanging">Now 0 ≤ <em>p, q</em> ≤ 2<sup>32</sup> – 2<sup>17</sup> + 1, so that <em>p</em> and <em>q</em> can be represented by 32-bit unsigned integers. However, it is easily calculated
         that
      </p>
      
      <p class="center">-2<sup>32</sup> + 2<sup>17</sup> 1 ≤ <em>r</em> ≤ 2<sup>32</sup> -2<sup>17</sup>+1,
      </p>
      
      <p class="indenthanging">so that <em>r</em> is a signed 33-bit quantity. It will be convenient to represent it by a signed 64-bit
         integer, with the high-order 32 bits being either all 0’s or all 1’s. The machine’s
         multiply instruction will compute the low-order 32 bits of <em>r</em>, and the high-order 32 bits can be ascertained from the values of – <em>a</em> + <em>b</em> and <em>c</em> – <em>d</em>. These are 17-bit signed integers. If they have opposite signs and are nonzero, then
         <em>r</em> is negative and hence its high-order 32 bits are all 1’s. If they have the same signs
         or either is 0, then <em>r</em> is nonnegative and hence its high-order 32 bits are all 0’s. The test that either
         – <em>a</em> + <em>b</em> or <em>c</em> – <em>d</em> is 0 can be done by testing only the low-order 32 bits of <em>r</em>. If they are 0, then one of the factors must be 0, because <em>r</em> &lt; 2<sup>32</sup>.
      </p>
      
      <p class="indenthangingBB">These considerations lead to the following function for computing the high-order 32
         bits of the product of <em>u</em> and <em>v</em>.
      </p>
      
      <p class="codelink"><a href="images17.html#p426fig01" id="p426fig01a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting">unsigned mulhu(unsigned u, unsigned v) {<br />    unsigned a, b, c, d, p, q, rlow, rhigh;<br /><br />    a = u &gt;&gt; 16; b = u &amp; 0xFFFF;<br />    c = v &gt;&gt; 16; d = v &amp; 0xFFFF;<br /><br />    p = a*c;<br />    q = b*d;<br />    rlow = (-a + b)*(c - d);<br />    rhigh = (int)((-a + b)^(c - d)) &gt;&gt; 31;<br />    if (rlow == 0) rhigh = 0; // Correction.<a id="page_427"></a><br />    q = q + (q &gt;&gt; 16);      // Overflow cannot occur here.<br />    rlow = rlow + p;<br />    if (rlow &lt; p) rhigh = rhigh + 1;<br />    rlow = rlow + q;<br />    if (rlow &lt; q) rhigh = rhigh + 1;<br /><br />    return p + (rlow &gt;&gt; 16) + (rhigh <span class="entity">&lt;&lt;</span> 16);<br />}
      </p>
      
      <hr />
      
      <p class="indenthangingBB">After computing <code>p, q, rlow</code>, and <code>rhigh</code>, the function does the following addition:
      </p>
      
      <p class="codelink"><a href="images17.html#p427fig01" id="p427fig01a">Click here to view code image</a></p>
      
      <p class="programlisting2">        |...... p.......|<br />|....rhigh..... ||..... rlow...... |<br />                 |....... p....... |<br />                 |....... q....... |<br />                          |....... q....... |
      </p>
      
      <p class="indenthanging">The statement “<code>if (rlow &lt; p) rhigh = rhigh +</code> 1” is adding 1 to <code>rhigh</code> if there is a carry from the addition of <code>p</code> to <code>rlow</code> in the previous statement.
      </p>
      
      <p class="indenthangingBB">The low-order 32 bits of the product can be obtained from the following expression,
         inserted just after the “correction” step above:
      </p>
      
      <p class="codelink"><a href="images17.html#p427fig03" id="p427fig03a">Click here to view code image</a></p>
      
      <p class="programlisting2">q + ((p + q + rlow) &lt;&lt; 16)</p>
      
      <p class="indenthanging">A branch-free version follows.</p>
      
      <p class="codelink"><a href="images17.html#p427fig02" id="p427fig02a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting">unsigned mulhu(unsigned u, unsigned v) {<br />    unsigned a, b, c, d, p, q, x, y, rlow, rhigh, t;<br /><br />    a = u &gt;&gt; 16; b = u &amp; 0xFFFF;<br />    c = v &gt;&gt; 16; d = v &amp; 0xFFFF;<br /><br />    p = a*c;<br />    q = b*d;<br />    x = -a + b;<br />    y = c - d;<br />    rlow = x*y;<br />    rhigh = (x ^ y) &amp; (rlow | -rlow);<br />    rhigh = (int)rhigh &gt;&gt; 31;<br /><br />    q = q + (q &gt;&gt; 16); // Overflow cannot occur here.<br />    t = (rlow &amp; 0xFFFF) + (p &amp; 0xFFFF) + (q &amp; 0xFFFF);<br />    p += (t &gt;&gt; 16) + (rlow &gt;&gt; 16) + (p &gt;&gt; 16) + (q &gt;&gt; 16);<br />    p += (rhigh &lt;&lt; 16);<br />    return p;<br />}
      </p>
      
      <hr />
      
      <p class="indenthangingBB"><a id="page_428"></a>These functions have more overhead than the four-multiplication function of <a href="ch08.html#ch08fig2">Figure 8–2</a> on page <a href="ch08.html#page_174">174</a>, and will be superior only if the machine’s multiply instruction is slower than that
         found on most modern computers. In “bignum” arithmetic (arithmetic on multiword integers),
         the time to multiply is substantially more than the time to add two integers of similar
         sizes. For that application, a method known as Karatsuba multiplication [Karat] applies
         the three-multiplication scheme recursively, and it is faster than the straightforward
         four-multiplication scheme for sufficiently large numbers. Actually, Karatsuba multiplication,
         as usually described, uses
      </p>
      
      <div class="image"><img alt="Image" src="graphics/428equ01.jpg" /></div>
      
      <p class="indenthanging">For our application, that method does not work out very well because <em>r</em> can be nearly as large as 2<sup>34</sup>, and there does not seem to be any easy way to calculate the high-order two bits
         of the 34-bit quantity <em>r</em>.
      </p>
      
      <p class="indenthangingBB">A signed version of the functions above has problems with overflow. It is just as
         well to use the unsigned function and correct it as described in <a href="ch08.html#ch08lev3">Section 8–3</a> on page <a href="ch08.html#page_174">174</a>.
      </p>
      
      <h3><strong>Chapter 9: Integer Division</strong></h3>
      
      <p class="answer"><a href="ch09.html#ch09ansa1" id="ch09ans1"><strong>1</strong>.</a> Let <em>x</em> = <em>x</em><sub>0</sub> + δ, where <em>x</em><sub>0</sub> is an integer and 0 ≤ δ &lt; 1. Then <img alt="Image" src="graphics/428fig01.jpg" /> by the definition of the ceiling function as the next integer greater than or equal
         to its argument. Hence <img alt="Image" src="graphics/428fig02.jpg" />, which is <img alt="Image" src="graphics/428fig03.jpg" />.
      </p>
      
      <p class="answer"><a href="ch09.html#ch09ansa2" id="ch09ans2"><strong>2</strong>.</a> Let <em>n</em> / <em>d</em> denote the quotient of signed, truncating, integer division. Then we must compute
      </p>
      
      <div class="image"><img alt="Image" src="graphics/428equ02.jpg" /></div>
      
      <p class="indenthanging">(If <em>d</em> = 0 the result is immaterial.) This can be computed as <em>n</em> / <em>d</em> + <em>c</em>, where
      </p>
      
      <div class="image"><img alt="Image" src="graphics/428equ03.jpg" /></div>
      
      <p class="indenthanging">which is four instructions to compute <em>c</em> (the term <img alt="Image" src="graphics/428fig04.jpg" /> commons). Another way to compute <em>c</em> in four instructions, but with the shifts unsigned, is
      </p>
      
      <div class="image"><a id="page_429"></a><img alt="Image" src="graphics/429equ01.jpg" /></div>
      
      <p class="indenthanging">If your machine has mod-32 shifts, <em>c</em> can be computed in three instructions:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/429equ02.jpg" /></div>
      
      <p class="indenthangingBB">For the remainder, let rem(<em>n, d</em>) denote the remainder upon dividing the signed integer <em>n</em> by the signed integer <em>d</em>, using truncating division. Then we must compute
      </p>
      
      <div class="image"><img alt="Image" src="graphics/429equ03.jpg" /></div>
      
      <p class="indenthanging">The amount to add to rem(<em>n, d</em>) is 0 or the absolute value of <em>d</em>. This can be computed from
      </p>
      
      <div class="image"><img alt="Image" src="graphics/429equ04.jpg" /></div>
      
      <p class="indenthanging">which is five instructions to compute <em>c</em>. It can be computed in four instructions if your machine has mod-32 shifts and you
         use the multiply instruction (details omitted).
      </p>
      
      <p class="answer"><a href="ch09.html#ch09ansa3" id="ch09ans3"><strong>3</strong>.</a> To get the quotient of floor division, it is necessary only to subtract 1 from the
         quotient of truncating division if the dividend and divisor have opposite signs:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/429equ05.jpg" /></div>
      
      <p class="indenthangingBB">For the remainder, it is necessary only to add the divisor to the remainder of truncating
         division if the dividend and divisor have opposite signs:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/429equ06.jpg" /></div>
      
      <p class="answer"><a href="ch09.html#ch09ansa4" id="ch09ans4"><strong>4</strong>.</a> The usual method, most likely, is to compute <span class="middle"><img alt="Image" src="graphics/ent05.jpg" /></span>(<em>n + d – 1)/d</em><span class="middle"><img alt="Image" src="graphics/ent06.jpg" /></span>. The problem is that <strong><em>n</em></strong> <em>+</em> <strong><em>d</em></strong><em>-</em> <strong><em>1</em></strong> can overflow. (Consider computing <span class="entity">⌈</span>12/5<span class="entity">⌉</span> on a 4-bit machine.)
      </p>
      
      <p class="indenthangingBB">Another standard method is to compute <em>q</em> = <span class="middle"><img alt="Image" src="graphics/ent05.jpg" /></span><em>n</em> / <em>d</em> <span class="middle"><img alt="Image" src="graphics/ent06.jpg" /></span> using the machine’s <em>divide</em> instruction, then compute the remainder as <strong><em>r</em></strong> <em>=</em> <strong><em>n</em></strong><em>-</em> <strong><em>qd</em></strong>, and if <strong><em>r</em></strong> is nonzero, add <strong>1</strong> to <strong><em>q</em></strong>. (Alternatively, add <strong>1</strong> if <strong><em>n</em></strong> ≠ <strong><em>qd</em></strong>.) This gives the correct result for all <strong><em>n</em></strong> and <strong><em>d</em></strong> ≠ <strong>0</strong>, but it is somewhat expensive because of the multiply, <a id="page_430"></a>subtract, and conditional add of <strong>1</strong>. On the other hand, if your machine’s <em>divide</em> instruction gives the remainder as a by-product, and especially if it has an efficient
         way to do the computation <strong><em>q</em></strong> = <strong><em>q</em></strong> + (<strong><em>r</em></strong> <span class="middle"><img alt="Image" src="graphics/ent02.jpg" /></span> <strong>0</strong>), then this is a good way to do it.
      </p>
      
      <p class="indenthangingBB">Still another way is to compute <strong><em>q</em></strong> = <span class="middle"><img alt="Image" src="graphics/ent05.jpg" /></span>(<strong><em>n</em></strong> – <strong>1</strong>) / <strong><em>d</em></strong><span class="middle"><img alt="Image" src="graphics/ent06.jpg" /></span> + <strong>1</strong>. Unfortunately, this fails for <strong><em>n</em></strong> = <strong>0</strong>. It can be fixed if the machine has a simple way to compute the <strong><em>x</em></strong> <span class="middle"><img alt="Image" src="graphics/ent02.jpg" /></span> <strong>0</strong> predicate, such as by means of a <em>compare</em> instruction that sets the target GPR to the integer <strong>1</strong> or <strong>0</strong> (see also <a href="ch02.html#ch02lev12">Section 2–12</a> on page <a href="ch02.html#page_23">23</a>). Then one can compute:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/430equ01.jpg" /></div>
      
      <p class="indenthangingBB">Lastly, one can compute <strong><em>q</em></strong> = <span class="middle"><img alt="Image" src="graphics/ent05.jpg" /></span>(<strong><em>n</em></strong> – <strong>1</strong>) / <strong><em>d</em></strong><span class="middle"><img alt="Image" src="graphics/ent06.jpg" /></span> + <strong>1</strong> and then change the result to <strong>0</strong> if <strong>n</strong> = <strong>0</strong>, by means of a conditional move or select instruction, for example.
      </p>
      
      <p class="answer"><a href="ch09.html#ch09ansa5" id="ch09ans5"><strong>5</strong>.</a> Let <em>f</em> (<img alt="Image" src="graphics/428fig03.jpg" />) = <em>a</em> and <em>f</em> (<em>x</em>) = <em>b</em>, as illustrated below.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/430fig01.jpg" /></div>
      
      <p class="indenthangingBB">If <em>b</em> is an integer, then by property (c), <em>x</em> is also, so that <img alt="Image" src="graphics/428fig03.jpg" /> = <em>x</em>, and there is nothing to prove. Therefore, assume in what follows that <em>b</em> is not an integer, but <em>a</em> may or may not be.
      </p>
      
      <p class="indenthangingBB">There cannot be an integer <em>k</em> such that <em>a</em> &lt; <em>k</em> ≤ <em>b</em>, because if there were, there would be an integer between <img alt="Image" src="graphics/428fig03.jpg" /> and <em>x</em> (by properties (a), (b), and (c)), which is impossible. Therefore <em><span class="middle"><img alt="Image" src="graphics/ent05.jpg" /></span>a<span class="middle"><img alt="Image" src="graphics/ent06.jpg" /></span></em> = <em><span class="middle"><img alt="Image" src="graphics/ent05.jpg" /></span>b<span class="middle"><img alt="Image" src="graphics/ent06.jpg" /></span></em>; that is, <em><span class="middle"><img alt="Image" src="graphics/ent05.jpg" /></span>f</em> (<img alt="Image" src="graphics/428fig03.jpg" />)<span class="middle"><img alt="Image" src="graphics/ent06.jpg" /></span> = <span class="middle"><img alt="Image" src="graphics/ent05.jpg" /></span><em>f</em> (<em>x</em>)<span class="middle"><img alt="Image" src="graphics/ent06.jpg" /></span>.
      </p>
      
      <p class="indenthanging">As examples of the utility of this, we have, for <em>a</em> and <em>b</em> integers,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/430equ02.jpg" /></div>
      
      <p class="indenthanging">It can similarly be shown that if <em>f</em> (<em>x</em>) has properties (a), (b), and (c), then
      </p>
      
      <div class="image"><img alt="Image" src="graphics/430equ03.jpg" /></div>
      
      <h3><a id="page_431"></a><strong>Chapter 10: Integer Division by Constants</strong></h3>
      
      <p class="answer"><a href="ch10.html#ch10ansa1" id="ch10ans1"><strong>1</strong>.</a> (a) If the divisor is even, then the low-order bit of the dividend does not affect
         the quotient (of floor division); if it is 1 it makes the remainder odd. After turning
         this bit off, the remainder of the division will be an even number. Hence for an even
         divisor <em>d</em>, the remainder is at most <em>d</em> – 2. This slight change in the maximum possible remainder results in the maximum
         multiplier <em>m</em> being a <em>W</em>-bit number rather than a (<em>W</em> + 1)-bit number (and hence the <code>shrxi</code> instruction is not needed), as we will now see. In fact, we will investigate what
         simplifications occur if the divisor ends in <em>z</em> 0-bits, that is, if it is a multiple of 2<sup><em>z</em></sup>, for <em>z</em> ≥ 0. In this case, the <em>z</em> low-order bits of the dividend can be cleared without affecting the quotient, and
         after clearing those bits, the maximum remainder is <em>d</em> – 2<sup><em>z</em></sup>.
      </p>
      
      <p class="indenthangingBB">Following the derivation of <a href="ch10.html#ch10lev9">Section 10–9</a> on page <a href="ch10.html#page_230">230</a>, but changed so that the maximum remainder is <em>d</em> – 2<sup><em>z</em></sup>, we have <em>n<sub>c</sub></em> = 2<sup><em>W</em></sup> – rem(2<sup><em>W</em></sup>, <em>d</em>) – 2<sup><em>z</em></sup>, and inequality (24a) becomes
      </p>
      
      <p class="center"><em>2<sup>w</sup>-d≤n<sub>c</sub>≤2<sup>w</sup>-2<sup>z</sup></em>.
      </p>
      
      <p class="indenthanging">Inequality (25) becomes</p>
      
      <div class="image"><img alt="Image" src="graphics/431equ01.jpg" /></div>
      
      <p class="indenthanging">Equation (26) is unchanged, and inequality (27) becomes</p>
      
      <div class="image"><img alt="Image" src="graphics/431equ02.jpg" /></div>
      
      <p class="indenthanging">Inequality (28) becomes</p>
      
      <div class="image"><img alt="Image" src="graphics/431equ03.jpg" /></div>
      
      <p class="indenthangingBB">In the case that <em>p</em> is not forced to equal <em>W</em>, combining these inequalities gives
      </p>
      
      <div class="image"><img alt="Image" src="graphics/431equ04.jpg" /></div>
      
      <p class="indenthanging"><a id="page_432"></a>Thus if <em>z</em> ≥ 1, <em>m</em> &lt; 2<sup><em>W</em></sup>, so that <em>m</em> fits in a <em>W</em>-bit word. The same result follows in the case that <em>p</em> is forced to equal <em>W</em>.
      </p>
      
      <p class="indenthangingBB">To calculate the multiplier for a given divisor, calculate <em>n<sub>c</sub></em> as shown above, then find the smallest <em>p</em> ≥ <em>W</em> that satisfies (27’), and calculate <em>m</em> from (26). As an example, for <em>d</em> = 14 and <em>W</em> = 32, we have <em>n<sub>c</sub></em> = 2<sup>32</sup> – rem(2<sup>32</sup>, 14) – 2 = 0xFFFFFFFA. Repeated use of (27′) gives <em>p</em> = 35, from which (26) gives <em>m</em> = (2<sup>35</sup> + 14 – 1 – 3) / 14 = 0x92492493. Thus, the code to divide by 14 is
      </p>
      
      <p class="codelink"><a href="images17.html#p432fig01" id="p432fig01a">Click here to view code image</a></p>
      
      <p class="programlisting2">ins   n,R0,0,1      Clear low-order bit of n.<br />li    M,0x92492493  Load magic number.<br />mulhu q,M,n         q = floor(M*n/2**32).<br />shri  q,q,3         q = q/8.
      </p>
      
      <p class="indenthanging">(b) Again, if the divisor is a multiple of 2<sup><em>z</em></sup>, then the low-order <em>z</em> bits of the dividend do not affect the quotient. Therefore, we can clear the low-order
         <em>z</em> bits of the dividend, and divide the divisor by 2<sup><em>z</em></sup>, without changing the quotient. (The division of the divisor would be done at compile
         time.)
      </p>
      
      <p class="indenthangingBB">Using the revised <em>n</em> and <em>d</em>, both less than 2<sup><em>W–z</em></sup>, (24a) becomes
      </p>
      
      <p class="center"><em>2<sup>w-z</sup>-d≤n<sub>c</sub>≤2<sup>w-z</sup>-1</em></p>
      
      <p class="indenthangingBB">Equation (26) and inequality (27) are not changed, but they are to be used with the
         revised values of <em>n<sub>c</sub></em> and <em>d</em>. We omit the proof that the multiplier will be less than 2<sup><em>W</em></sup> and give an example again for <em>d</em> = 14 and <em>W</em> = 32. In the equations, we use <em>d</em> = 7. Thus, we have <em>n<sub>c</sub></em> = 2<sup>31</sup> – rem(2<sup>31</sup>, 7) – 1 = 0x7FFFFFFF. Repeated use of (27) gives <em>p</em> = 34, from which (26) gives <em>m</em> = (2<sup>34</sup> + 5) / 7 = 0x92492493, and the code to divide by 14 is
      </p>
      
      <p class="codelink"><a href="images17.html#p432fig02" id="p432fig02a">Click here to view code image</a></p>
      
      <p class="programlisting2">shri   n,n,1         Halve the dividend.<br />li     M,0x92492493  Load magic number.<br />mulhu  q,M,n         q = floor(M*n/2**32).<br />shri   q,q,2         q = q/4.
      </p>
      
      <p class="indenthangingBB">These methods should not <em>always</em> be used when the divisor is an even number. For example, to divide by 10, 12, 18,
         or 22 it is better to use the method described in the text, because there’s no need
         for an instruction to clear the low-order bits of the dividend, or to shift the dividend
         right. Instead, the algorithm of <a href="ch10.html#ch10fig3">Figure 10–3</a> on page <a href="ch10.html#page_236">236</a> should be used, and if it gives an “add” indicator of 1 and the divisor is even,
         then one of the above techniques can be used to get better code on most machines.
         Among the divisors less than or equal to 100, these techniques are useful for 14,
         28, 38, 42, 54, 56, 62, 70, 74, 76, 78, 84, and 90.
      </p>
      
      <p class="indenthangingBB">Which is better, (a) or (b)? Experimentation indicates that method (b) is preferable
         in terms of the number of instructions required, because it seems to always require
         either the same number of instructions as (a), or one fewer. However, there are cases
         in which (a) and (b) require the same number of <a id="page_433"></a>instructions, but (a) yields a smaller multiplier. Some representative cases are shown
         below. The “Book” method is the code that <a href="ch10.html#ch10fig3">Figure 10–3</a> gives. We assume here that the computer’s <em>and immediate</em> instruction sign-propagates the high-order bit of the immediate field (our basic
         RISC would use the <em>insert</em> instruction).
      </p>
      
      <div class="image"><img alt="Image" src="graphics/433tab01.jpg" /></div>
      
      <p class="indenthangingBB">These techniques are not useful for signed division. In that case, the difference
         between the best and worst code is only two instructions (as illustrated by the code
         for dividing by 3 and by 7, shown in <a href="ch10.html#ch10lev3">Section 10–3</a> on page <a href="ch10.html#page_207">207</a>). The fix-up code for method (a) would require adding 1 to the dividend if it is
         negative and odd, and subtracting 1 if the dividend is nonnegative and odd, which
         would require more than two instructions. For method (b), the fix-up code is to divide
         the dividend by 2, which requires three basic RISC instructions (see <a href="ch10.html#ch10lev1">Section 10–1</a> on page <a href="ch10.html#page_205">205</a>), so this method is also not a winner.
      </p>
      
      <p class="answer"><a href="ch10.html#ch10ansa2" id="ch10ans2"><strong>2</strong>.</a> Python code is shown below.
      </p>
      
      <p class="codelink"><a href="images17.html#p433fig01" id="p433fig01a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting1">def magicg(nmax, d):<br />   nc = (nmax//d)*d - 1<br />   nbits = int(log(nmax, 2)) + 1<br />   for p in range(0, 2*nbits - 1):<br />      if 2**p &gt; nc*(d - (2**p)%d):<br />         m = (2**p + d - (2**p)%d)//d<br />         return (m, p)<br />   print "Can't find p, something is wrong."<br />   sys.exit(1)
      </p>
      
      <hr />
      
      <p class="answer"><a href="ch10.html#ch10ansa3" id="ch10ans3"><strong>3</strong>.</a> Because 81 = 3<sup>4</sup>, we need for the starting value, the multiplicative inverse of <em>d</em> modulo 3. This is simply the remainder of dividing <em>d</em> by 3, because 1 · 1 ≡ 1 (mod 3) and 2 · 2 ≡ 1 (mod 3) (and if the remainder is 0,
         there is no multiplicative inverse). For <em>d</em> = 146, the calculation proceeds as follows.
      </p>
      
      <div class="image"><a id="page_434"></a><img alt="Image" src="graphics/434fig01.jpg" /></div>
      
      <p class="indenthanging">A fixed point was reached, so the multiplicative inverse of 146 modulo 81 is 5. Check:
         146 · 5 = 730 ≡ 1 (mod 81). Actually, it is known <em>a priori</em> that two iterations suffice.
      </p>
      
      <h3><strong>Chapter 11: Some Elementary Functions</strong></h3>
      
      <p class="answer"><a href="ch11.html#ch11ansa1" id="ch11ans1"><strong>1</strong>.</a> Yes. The result is correct in spite of the double truncation. Suppose <img alt="Image" src="graphics/434fig02.jpg" />. Then by the definition of this operation, <em>a</em> is an integer such that <em>a</em><sup>2</sup> ≤ <em>x</em> and (<em>a</em> + 1)<sup>2</sup> &lt; <em>x</em>.
      </p>
      
      <p class="indenthangingBB">Let <img alt="Image" src="graphics/434fig03.jpg" />. Then <em>b</em><sup>2</sup> ≤ <em>a</em> and (<em>b</em> +1)<sup>2</sup> &lt; <em>a</em>. Thus, <em>b</em><sup>4</sup> ≤ <em>a</em><sup>2</sup> and, because <em>a</em><sup>2</sup> ≤ <em>x, b</em><sup>4</sup> ≤ <em>x</em>.
      </p>
      
      <p class="indenthangingBB">Because (<em>b</em> + 1)<sup>2</sup> <em>a</em>, (<em>b</em> + 1)2 ≥ <em>a</em> + 1, so that <em>(b</em> + 1)<sup>4</sup>≥ <em>(a</em> + 1)<sup>2</sup> Because (<em>a</em>+ 1)<sup>2</sup><em>x</em>, (<em>b</em> + 1)<sup>4</sup><em>x</em>. Hence <em>b</em> is the integer fourth root of <em>x</em>.
      </p>
      
      <p class="indenthangingBB">This follows more easily from exercise 5 of <a href="ch09.html#ch09">Chapter 9</a>.
      </p>
      
      <p class="answer"><a href="ch11.html#ch11ansa2" id="ch11ans2"><strong>2</strong>.</a> Straightforward code is shown below.
      </p>
      
      <p class="codelink"><a href="images17.html#p434fig04" id="p434fig04a">Click here to view code image</a></p>
      
      <p class="programlisting2">int icbrt64(unsigned long long x) {<br />   int s;<br />   unsigned long long y, b, bs;<br /><br />   y = 0;<br />   for (s = 63; s &gt;= 0; s = s - 3) {<br />      y = 2*y;<br />      b = 3*y*(y + 1) + 1;<br />      bs = b <span class="entity">&lt;&lt;</span> s;<br />      if (x &gt;= bs &amp;&amp; b == (bs &gt;&gt; s)) {<br />         x = x - bs;<br />         y = y + 1;<br />      }<br />   }<br />   return y;<br />}
      </p>
      
      <p class="indenthangingBB">Overflow of <code>b</code> (<code>bs</code> in the above code) can occur only on the second loop iteration. Therefore, another
         way to deal with the overflow is to expand the first two iterations of the loop, and
         then execute the loop only from <code>s</code> = 57 on down, with the phrase <code>“&amp;&amp; b == (bs &gt;&gt; s)”</code> deleted.
      </p>
      
      <p class="indenthangingBB">By inspection, the effect of the first two loop iterations is:</p>
      
      <p class="indenthangingBB">If <em>x</em> ≥ 2<sup>63</sup>, set <em>x</em> = <em>x</em> – 2<sup>63</sup> and set <em>y</em> = 2.
      </p>
      
      <p class="indenthangingBB">If 2<sup>60</sup> ≤ <em>x</em> &lt; 2<sup>63</sup>, set <em>x</em> = <em>x</em> – 2<sup>60</sup> and set <em>y</em> = 1.
      </p>
      
      <p class="indenthangingBB">If <em>x</em> &lt; 2<sup>60</sup>, set <em>y</em> = 0 (and don’t change <em>x</em>).
      </p>
      
      <p class="indenthanging"><a id="page_435"></a>Therefore, the beginning of the routine can be coded as shown below.
      </p>
      
      <p class="codelink"><a href="images17.html#p435fig01" id="p435fig01a">Click here to view code image</a></p>
      
      <p class="programlisting2">y = 0;<br />if (x &gt;= 0x1000000000000000LL) {<br />   if (x &gt;= 0x8000000000000000LL) {<br />      x = x - 0x8000000000000000LL;<br />      y = 2;<br />   } else {<br />      x = x - 0x1000000000000000LL;<br />      y = 1;<br />   }<br />}<br /><br />for (s = 57; s &gt;= 0; s = s - 3) {<br />     ...
      </p>
      
      <p class="indenthanging">And, as mentioned, the phrase <code>“&amp;&amp; b == (bs &gt;&gt; s)”</code> can be deleted.
      </p>
      
      <p class="answer"><a href="ch11.html#ch11ansa3" id="ch11ans3"><strong>3</strong>.</a> Six [Knu2]. The binary decomposition method, based on <em>x</em><sup>23</sup> = <em>x</em><sup>16</sup> · <em>x</em><sup>4</sup> · <em>x</em><sup>2</sup> · <em>x</em>, takes seven. Factoring <em>x</em><sup>23</sup> as (<em>x</em><sup>11</sup>)<sup>2</sup> · <em>x</em> or as ((<em>x</em><sup>5</sup>)<sup>2</sup> · <em>x</em>)<sup>2</sup> · <em>x</em> also takes seven. But computing powers of <em>x</em> in the order <em>x</em><sup>2</sup>, <em>x</em><sup>3</sup>, <em>x</em><sup>5</sup>, <em>x</em><sup>10</sup>, <em>x</em><sup>13</sup>, <em>x</em><sup>23</sup>, in which each term is a product of two previous terms or of <em>x</em>, does it in six multiplications.
      </p>
      
      <p class="answer"><a href="ch11.html#ch11ansa4" id="ch11ans4"><strong>4</strong>.</a> (a) <em>x</em> rounded down to an integral power of 2. (b) <em>x</em> rounded up to an integral power of 2 (in both cases, <em>x</em> itself if <em>x</em> is an integral power of 2).
      </p>
      
      <h3><strong>Chapter 12: Unusual Bases for Number Systems</strong></h3>
      
      <p class="answer"><a href="ch12.html#ch12ansa1" id="ch12ans1"><strong>1</strong>.</a> If <strong><em>B</em></strong> is a binary number and <strong><em>N</em></strong> is its base –2 equivalent, then
      </p>
      
      <div class="image"><img alt="Image" src="graphics/435equ01.jpg" /></div>
      
      <p class="answer"><a href="ch12.html#ch12ansa2" id="ch12ans2"><strong>2</strong>.</a> An easy way to do this is to convert the base –2 number <strong><em>x</em></strong> to binary, add 1, and convert back to base –2. Using Schroeppel’s formula and simplifying,
         the result is
      </p>
      
      <div class="image"><img alt="Image" src="graphics/435equ02.jpg" /></div>
      
      <p class="answer"><a href="ch12.html#ch12ansa3" id="ch12ans3"><strong>3</strong>.</a> As in exercise 1, one could convert the base –2 number <strong><em>x</em></strong> to binary, <em>and</em> with 0xFFFFFFF0, and convert back to base –2. This would be five operations. However,
         it can be done in four operations with either of the formulas below.<sup><a id="ansfna2"></a><a href="footnotes.html#ansfn2">2</a></sup></p>
      
      <div class="image"><a id="page_436"></a><img alt="Image" src="graphics/436equ01.jpg" /></div>
      
      <p class="indenthanging">The formulas below round a number <em>up</em> to the next greater power of 16.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/436equ02.jpg" /></div>
      
      <p class="indenthanging">There are similar formulas for rounding up or down to other powers of 2.</p>
      
      <p class="answer"><a href="ch12.html#ch12ansa4" id="ch12ans4"><strong>4</strong>.</a> This is very easy to program in Python, because that language supports complex numbers.
      </p>
      
      <p class="codelink"><a href="images17.html#p436fig01" id="p436fig01a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting">import sys<br />import cmath<br /><br />num = sys.argv[1:]<br />if len(num) == 0:<br />   print "Converts a base -1 + 1j number, given in decimal"<br />   print "or hex, to the form a + bj, with a, b real."<br />   sys.exit()<br />num = eval(num[0])<br />r = 0<br />weight = 1<br />while num &gt; 0:<br />   if num &amp; 1:<br />      r = r + weight;<br />   weight = (-1 + 1j)*weight<br />   num = num &gt;&gt; 1;<br />print ‘r =’, r
      </p>
      
      <hr />
      
      <p class="answer"><a href="ch12.html#ch12ansa5" id="ch12ans5"><strong>5</strong>.</a> To convert a base – 1 + <em>i</em> number to its negative, either subtract it from 0 or multiply it by –1 (11101), using
         the rules for base – 1 + <em>i</em> arithmetic.
      </p>
      
      <p class="indenthangingBB">To extract the real part of a number <em>x</em>, add in the negative of its imaginary part. Process the bits of <em>x</em> in groups of four, starting at the right (low-order) end. Number the bits in each
         group 0, 1, 2, and 3, from the right. Then:
      </p>
      
      <p class="indenthangingBB">If bit 1 is on, add – <em>i</em> (0111) at the current group’s position.
      </p>
      
      <p class="indenthangingBB">If bit 2 is on, add 2 <em>i</em> (1110100) at the current group’s position.
      </p>
      
      <p class="indenthangingBB">If bit 3 is on, add –2 <em>i</em> (0100) at the current group’s position.
      </p>
      
      <p class="indenthangingBB">Bit 1 has a weight of – 1 + <em>i</em>, so adding in – <em>i</em> cancels its imaginary component. A similar remark applies to bits 2 and 3. There
         is no need to do anything for bit 0, because that has no imaginary component. Each
         group of four bits has a weight of – 4 times the weight of the group immediately to
         its right, because 10000 in base – 1 + <em>i</em> is – 4 decimal. Thus, the weight of bit <em>n</em> of <em>x</em> is a real number (– 4) times the weight of bit <em>n</em> – 4.
      </p>
      
      <p class="indenthangingBB"><a id="page_437"></a>The example below illustrates extracting the real part of the base -1 + <em>i</em> number 101101101.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/437fig01.jpg" /></div>
      
      <p class="indenthangingBB">The reader may verify that <em>x</em> is 23 + 4<em>i</em>, and the sum is 23. In working out this addition, <em>many</em> carries are generated, which are not shown above. Several shortcuts are possible:
         If bits 2 and 3 are both on, there is no need to add anything in for these bits, because
         we would be adding in 2<em>i</em> and –2<em>i</em>. If a group ends in 11, these bits can be simply dropped, because they constitute
         a pure imaginary (<em>i</em>). Similarly, bit 2 can be simply dropped, as its weight is a pure imaginary (–2<em>i</em>).
      </p>
      
      <p class="indenthangingBB">Carried to its extreme, a method employing these kinds of shortcuts would translate
         each group of four bits independently to its real part. In some cases a carry is generated,
         and these carries would be added to the translated number. To illustrate, let us represent
         each group of four bits in hexadecimal. The translation is shown below.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/437fig02.jpg" /></div>
      
      <p class="indenthangingBB">The digits 2 and 6 have real part –1, which is written 1D in base – 1 + <em>i</em>. For these digits, replace the source digit with D and carry a 1. The carries can
         be added in using the basic rules of addition in base – 1 + <em>i</em>, but for hand work there is a more expedient way. After translation, there are only
         four possible digits: 0, 1, C, and D, as the translation table shows. Rules for adding
         1 to these digits are shown in the left-hand column below.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/437fig03.jpg" /></div>
      
      <p class="indenthanging">Adding 1 to D generates a carry of 1D (because 3 + 1 = 4). We will carry both digits
         to the same column. The right-hand column above shows how to handle the carry of 1D.
         In doing the addition, it is possible to get a carry of both 1 and <a id="page_438"></a>1D in the same column (the first carry from the translation and the second from the
         addition). In this case, the carries cancel each other, because 1D is –1 in base –
         1 + <em>i</em>. It is not possible to get two carries of 1, or two of 1D, in the same column.
      </p>
      
      <p class="indenthangingBB">The example below illustrates the use of this method to extract the real part of the
         base – 1 + <em>i</em> number EA26 (written in hexadecimal).
      </p>
      
      <div class="indenthangingBB"><img alt="Image" src="graphics/438fig01.jpg" /></div>
      
      <p class="indenthanging">The reader may verify that <em>x</em> is – 45 + 21 <em>i</em> and the sum is – 45.
      </p>
      
      <p class="indenthangingBB">Incidentally, a base – 1 + <em>i</em> number is real iff all of its digits, expressed in hexadecimal, are 0, 1, C, or D.
      </p>
      
      <p class="indenthangingBB">To extract the imaginary part from <em>x</em>, one can, of course, extract the real part and subtract that from <em>x</em>. To do it directly by the “shortcut” method, the table below shows the translation
         of each hexadecimal digit to its pure imaginary part.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/438fig02.jpg" /></div>
      
      <p class="indenthangingBB">Thus, a carry of 7 can occur, so we need addition rules to add 7 to the four possible
         translated digits of 0, 3, 4, and 7. These are shown in the left-hand column below.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/438fig03.jpg" /></div>
      
      <p class="indenthanging">Now a carry of 3 can occur, and the right-hand column above shows how to deal with
         that.
      </p>
      
      <p class="indenthangingBB">The example below illustrates the use of this method to extract the imaginary part
         of the base – 1 + <em>i</em> number 568A (written in hexadecimal).
      </p>
      
      <div class="indenthangingBB"><img alt="Image" src="graphics/438fig04.jpg" /></div>
      
      <p class="indenthanging"><a id="page_439"></a>The reader may verify that <em>x</em> is – 87 + 107 <em>i</em> and the sum is 107<em>i</em>.
      </p>
      
      <p class="indenthangingBB">A base – 1 + <em>i</em> number is imaginary iff all of its digits, expressed in hexadecimal, are 0, 3, 4,
         or 7.
      </p>
      
      <p class="indenthangingBB">To convert a number to its complex conjugate, subtract twice a number’s imaginary
         part. A table can be used, as above, but the conversion is more complicated because
         more carries can be generated, and the translated number can contain any of the 16
         hexadecimal digits. The translation table is shown below.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/439fig01.jpg" /></div>
      
      <p class="indenthangingBB">The carries can be added in using base – 1 + <em>i</em> arithmetic or by devising a table that does the addition a hexadecimal digit at a
         time. The table is larger than those above, because the carries can be added to any
         of the 16 possible hexadecimal digits.
      </p>
      
      <h3><strong>Chapter 13: Gray Code</strong></h3>
      
      <p class="answer"><a href="ch13.html#ch13ansa1" id="ch13ans1"><strong>1</strong>.</a> Proof sketch 1: It is apparent from the construction of the reflected binary Gray
         code.
      </p>
      
      <p class="indenthangingBB">Proof sketch 2: From the formula <img alt="Image" src="graphics/439fig02.jpg" />, it can be seen that G(<strong><em>x</em></strong>) is 1 at position <em>i</em> wherever there is a transition from 0 to 1 or from 1 to 0 from position <em>i</em> to the bit to the left of <em>i</em>, and is 0 otherwise. If <em>x</em> is even, there are an even number of transitions, and if <em>x</em> is odd, there are an odd number of transitions.
      </p>
      
      <p class="indenthangingBB">Proof sketch 3: By induction on the length of <strong><em>x</em></strong>, using the formula given above: The statement is true for the one-bit words 0 and
         1. Let <strong><em>x</em></strong> be a binary word of length <em>n</em>, and assume inductively that the statement is true for <strong><em>x</em></strong>. If <strong><em>x</em></strong> is prepended with a 0-bit, G(<strong><em>x</em></strong>) is also prepended with a 0-bit, and the remaining bits are G(<strong><em>x</em></strong>). If <strong><em>x</em></strong> is prepended with a 1-bit, then G(<strong><em>x</em></strong>) is also prepended with a 1-bit, and its next most significant bit is complemented.
         The remaining bits are unchanged. Therefore, the number of 1-bits in G(<strong><em>x</em></strong>) is either increased by 2 or is unchanged.
      </p>
      
      <p class="indenthangingBB">Thus, one can construct a random number generator that generates integers with an
         even (or odd) number of 1-bits by using a generator of uniformly distributed integers,
         setting the least significant bit to 0 (or to 1), and converting the result to Gray
         code [Arndt].
      </p>
      
      <p class="answer"><a href="ch13.html#ch13ansa2" id="ch13ans2"><strong>2</strong>.</a> (a) Because each column is a cyclic shift of column 1, the result follows immediately.
      </p>
      
      <p class="indenthanging"><a id="page_440"></a>(b) No such code exists. This is not difficult to verify by enumerating all possible
         Gray codes for <em>n</em> = 3. Without loss of generality, one can start with
      </p>
      
      <p class="codelink"><a href="images17.html#p440fig01" id="p440fig01a">Click here to view code image</a></p>
      
      <p class="programlistings1">000<br />001<br />011
      </p>
      
      <p class="indenthanging">because any Gray code can be made to start that way by complementing columns and rearranging
         columns. Corollary: There is no STGC for <em>n</em> = 3 that has eight code words.
      </p>
      
      <p class="answer"><a href="ch13.html#ch13ansa3" id="ch13ans3"><strong>3</strong>.</a> The code below was devised by reflecting the first five code words of the reflected
         binary Gray code.
      </p>
      
      <p class="codelink"><a href="images17.html#p440fig02" id="p440fig02a">Click here to view code image</a></p>
      
      <p class="programlistings1">0000<br />0001<br />0011<br />0010<br />0110<br />1110<br />1010<br />1011<br />1001<br />1000
      </p>
      
      <p class="indenthangingBB">Another code can be derived by taking the “excess 3” binary coded decimal (BCD) code
         and converting it to Gray. The result turns out to be cyclic. The excess 3 code for
         encoding decimal digits has the property that addition of coded words generates a
         carry precisely when addition of the decimal digits would.
      </p>
      
      <p class="fig-caption">E<small>XCESS</small> T<small>HREE</small> G<small>RAY</small> C<small>ODE</small></p>
      
      <div class="image"><img alt="Image" src="graphics/440tab01.jpg" /></div>
      
      <p class="answer"><a id="page_441"></a><a href="ch13.html#ch13ansa4" id="ch13ans4"><strong>4</strong>.</a> It is a simple matter to derive a “mixed base” Gray code, using the principle of
         reflection. For a number with prime decomposition 2<sup><em><sup>e</sup></em> 1</sup>3<sup><em><sup>e</sup></em> 2</sup>5<sup><em><sup>e</sup></em> 3</sup>, the columns of the Gray code should be in base <em>e</em><sub>1</sub> + 1, <em>e</em><sub>2</sub> + 1, <em>e</em><sub>3</sub> + 1,.... For example, for the number 72 = 2<sup>3</sup> · 3<sup>2</sup>, the list below shows a “base 4 - base 3” Gray code and the divisor of 72 that each
         code word represents.
      </p>
      
      <p class="codelink"><a href="images17.html#p441fig01" id="p441fig01a">Click here to view code image</a></p>
      
      <p class="programlistings1">00   1<br />01   3<br />02   9<br />12  18<br />11   6<br />10   2<br />20   4<br />21  12<br />22  36<br />32  72<br />31  24<br />30   8
      </p>
      
      <p class="indenthanging">Clearly each divisor follows from the previous one by one multiplication or division
         by a prime number.
      </p>
      
      <p class="indenthangingBB">Even simpler: A binary Gray code can be used to iterate over the subsets of a set
         in such a way that in each step only one member is added or removed.
      </p>
      
      <h3><strong>Chapter 14: Cyclic Redundancy Check</strong></h3>
      
      <p class="answer"><a href="ch14.html#ch14ansa1" id="ch14ans1"><strong>1</strong>.</a> From the text, a message polynomial <em>M</em> and generator polynomial <em>G</em> satisfy <em>Mx<sup>r</sup></em> = <em>QG</em> + <em>R</em>, where <em>R</em> is the checksum polynomial. Let <em>M</em> ′ be a message polynomial that differs from <em>M</em> at term <em>x<sup>e</sup></em>. (That is, the binary message differs at bit position <em>e</em>.) Then <em>M</em> ′ = <em>M</em> + <em>x<sup>e</sup></em>, and
      </p>
      
      <p class="center"><em>M'x<sup>r</sup> = (M+x<sup>e</sup>)x<sup>r</sup> = Mx<sup>r</sup> + x<sup>e+r</sup> = QG+R+x<sup>e+r</sup></em></p>
      
      <p class="indenthanging">The term <em>x<sup>e</sup> + r</em> is not divisible by <em>G</em>, because <em>G</em> has two or more terms. (The only divisors of <em>x<sup>e</sup> + r</em> are of the form <em>x&gt;&gt;.)</em> Therefore, the remainder upon dividing <em>M'x<sup>r</sup></em> by <em>G</em> is distinct from <em>R</em>, so the error is detected.
      </p>
      
      <p class="answer"><a href="ch14.html#ch14ansa2" id="ch14ans2"><strong>2</strong>.</a> The main loop might be coded as shown below, where <code>word</code> is an <code>unsigned int</code> [Danne].
      </p>
      
      <p class="codelink"><a href="images17.html#p441fig02" id="p441fig02a">Click here to view code image</a></p>
      
      <p class="programlisting1">crc = 0xFFFFFFFF;<br />while (((word = *(unsigned int *)message) &amp; 0xFF) != 0) {<br />    crc = crc ^ word;<br />    crc = (crc &gt;&gt; 8) ^ table[crc &amp; 0xFF];<br />    crc = (crc &gt;&gt; 8) ^ table[crc &amp; 0xFF];<br />    crc = (crc &gt;&gt; 8) ^ table[crc &amp; 0xFF];<br />    crc = (crc &gt;&gt; 8) ^ table[crc &amp; 0xFF];<br />    message = message + 4;<br />}
      </p>
      
      <p class="indenthangingBB"><a id="page_442"></a>Compared to the code of <a href="ch14.html#ch14fig7">Figure 14–7</a> on page <a href="ch14.html#page_329">329</a>, this saves three <em>load byte</em> and three <em>exclusive or</em> instructions for each word of <code>message</code>. And, there are fewer loop control instructions executed.
      </p>
      
      <h3><strong>Chapter 15: Error-Correcting Codes</strong></h3>
      
      <p class="answer"><a href="ch15.html#ch15ansa1" id="ch15ans1"><strong>1</strong>.</a> Your table should look like <a href="ch15.html#ch15tab1">Table 15–1</a> on page <a href="ch15.html#page_333">333</a>, with the rightmost column and the odd numbered rows deleted.
      </p>
      
      <p class="answer"><a href="ch15.html#ch15ansa2" id="ch15ans2"><strong>2</strong>.</a> In the first case, if an error occurs in a check bit, the receiver cannot know that,
         and it will make an erroneous “correction” to the information bits.
      </p>
      
      <p class="indenthangingBB">In the second case, if an error occurs in a check bit, the syndrome will be one of
         100...0, 010...0, 001...0, ..., 000...1 (<em>k</em> distinct values). Therefore <em>k</em> must be large enough to encode these <em>k</em> values, as well as the <em>m</em> values to encode a single error in one of the <em>m</em> information bits, and a value for “no errors.” So the Hamming rule stands.
      </p>
      
      <p class="indenthangingBB">One thing along these lines that could be done is to have a single parity bit for
         the <em>k</em> check bits, and have the <em>k</em> check bits encode values that designate one error in an information bit (and where
         it is), or no errors occurred. For this code, <em>k</em> could be chosen as the smallest value for which 2<sup><em><sup>k</sup></em></sup> ≥ <em>m</em> + 1. The code length would be <em>m</em> + <em>k</em> + 1, where the “+1” is for the parity bit on the check bits. But this code length
         is nowhere better than that given by the Hamming rule, and is sometimes worse.
      </p>
      
      <p class="answer"><a href="ch15.html#ch15ansa3" id="ch15ans3"><strong>3</strong>.</a> Treating <em>k</em> and <em>m</em> as real numbers, the following iteration converges from below quite rapidly:
      </p>
      
      <div class="image"><img alt="Image" src="graphics/442equ01.jpg" /></div>
      
      <p class="indenthanging">where lg(<em>x</em>) is the log base 2 of <em>x</em>. The correct result is given by ceil(<em>k</em><sub>2</sub>) is, only two iterations are required for all <em>m</em> ≥ 0.
      </p>
      
      <p class="indenthangingBB">Taking another tack, it is not difficult to prove that for <em>m</em> ≥ 0,
      </p>
      
      <p class="center">bitsize(<em>m</em>) ≤ <em>k</em> ≤ bitsize(<em>m</em>) + 1.
      </p>
      
      <p class="indenthanging">Here bitsize(<em>m</em>) is the size of <em>m</em> in bits, for example, bitsize(3) = 2, bitsize(4) = 3, and so forth. (This is different
         from the function of the same name described in <a href="ch05.html#ch05lev3">Section 5–3</a> on page <a href="ch05.html#page_99">99</a>, which is for signed integers.) <em>Hint:</em> bitsize(<em>m</em>) = <span class="entity">⌈</span>lg(<em>m</em> + 1)<span class="entity">⌉</span> = <span class="middle"><img alt="Image" src="graphics/ent03.jpg" /></span>lg(<em>m</em>) + 1<span class="middle"><img alt="Image" src="graphics/ent04.jpg" /></span>, where we take lg(0) to be –1. Thus, one can try <em>k</em> = bitsize(<em>m</em>), test it, and if it proves to be too small then simply add 1 to the trial value.
         Using the <em>number of leading zeros</em> function to compute bitsize(<em>m</em>), one way to commit this to code is:
      </p>
      
      <div class="image"><a id="page_443"></a><img alt="Image" src="graphics/443equ01.jpg" /></div>
      
      <p class="indenthanging">where <em>W</em> is the machine’s word size and 0 ≤ <em>m</em> ≤ 2<sup><em>w</em></sup> – 1.
      </p>
      
      <p class="answer"><a href="ch15.html#ch15ansa4" id="ch15ans4"><strong>4</strong>.</a> Answer: If <em>d</em>(<em>x</em>,<em>z</em>)&gt;<em>d</em>(<em>x</em>,<em>y</em>) + <em>d</em>(<em>y</em>,<em>z</em>), it must be that for at least one bit position <em>i</em>, that bit position contributes 1 to <em>d(x,z)</em> and 0 to <em>d</em>(<em>x</em>,<em>y</em>) + <em>d</em>(<em>y</em>,<em>z</em>). This implies that <em>x<sub>i</sub></em> ≠ <em>z<sub>i</sub></em>, but <em>x<sub>i</sub></em> = <em>y<sub>i</sub></em> and <em>y<sub>i</sub></em> = <em>z<sub>i</sub></em>, clearly a contradiction.
      </p>
      
      <p class="answer"><a href="ch15.html#ch15ansa5" id="ch15ans5"><strong>5</strong>.</a> Given a code of length <em>n</em> and minimum distance <em>d</em>, simply double-up each 1 and each 0 in each code word. The resulting code is of length
         <em>2n</em>, minimum distance <em>2d</em>, and is the same size.
      </p>
      
      <p class="answer"><a href="ch15.html#ch15ansa6" id="ch15ans6"><strong>6</strong>.</a> Given a code of length <em>n</em>, minimum distance <em>d</em>, and size <em>A</em>(<em>n, d</em>), think of it as being displayed as in <a href="ch15.html#ch15tab1">Table 15–1</a> on page <a href="ch15.html#page_333">333</a>. Remove an arbitrary <em>d-</em> 1 columns. The resulting code words, of length <em>n-(d-1)</em>, have a minimum distance of at least 1. That is, they are all distinct. Hence their
         number cannot be more than 2”–<sup>(<em>d</em> – 1)</sup>. Since deleting columns did not change the code size, the original code’s size is
         at most 2<sup><em>n(d–1)</em></sup>, so that <em>A</em>(<em>n</em>,<em>d</em>)≤ 2<sup><em>n</em> – <em>d</em> + 1</sup>.
      </p>
      
      <p class="answer"><a href="ch15.html#ch15ansa7" id="ch15ans7"><strong>7</strong>.</a> The Hamming rule applies to the case that <em>d</em> = 3 and the code has 2<sup><em>m</em></sup> code words, where <em>m</em> is the number of information bits. The right-hand part of inequality (6), with <em>A</em> (<em>n, d</em>) = 2<sup><em>m</em></sup> and <em>d</em> = 3, is
      </p>
      
      <div class="image"><img alt="Image" src="graphics/443equ02.jpg" /></div>
      
      <p class="indenthanging">Replacing <em>n</em> with <em>m</em> + <em>k</em> gives
      </p>
      
      <div class="image"><img alt="Image" src="graphics/443equ03.jpg" /></div>
      
      <p class="indenthanging">which on cancelling <em>2<sup>m</sup></em> on each side becomes inequality (1).
      </p>
      
      <p class="answer"><a href="ch15.html#ch15ansa8" id="ch15ans8"><strong>8</strong>.</a> The code must consist of an arbitrary bit string and its one’s-complement, so its
         size is 2. That these codes are perfect, for odd <em>n</em>, can be seen by showing that they achieve the upper bound in inequality (6). Proof
         sketch: An <em>n</em> -bit binary integer may be thought of as representing uniquely a choice from <em>n</em> objects, with a 1-bit meaning to choose and a 0-bit meaning not to choose the corresponding
         object. Therefore, there are 2<sup><em>n</em></sup> ways to choose from 0 to <em>n</em> objects from <em>n</em> objects—that is, <img alt="Image" src="graphics/443fig01.jpg" />. If <em>n</em> is odd, <em>i</em> ranging from 0 to (<em>n</em> – 1)/2 covers half the terms of this sum, and because of the symmetry <img alt="Image" src="graphics/443fig02.jpg" />, it accounts for half the sum. Therefore <img alt="Image" src="graphics/443fig03.jpg" />, so that the upper bound in (6) is 2. Thus, the code achieves the upper bound of
         (6).
      </p>
      
      <p class="answer"><a id="page_444"></a><a href="ch15.html#ch15ansa9" id="ch15ans9"><strong>9</strong>.</a> For ease of exposition, this proof will make use of the notion of <em>equivalence</em> of codes. Clearly a code is not changed in any substantial way by rearranging its
         columns (as depicted in <a href="ch15.html#ch15tab1">Table 15–1</a> on page <a href="ch15.html#page_333">333</a>) or by complementing any column. If one code can be derived from another by such
         transformations, they are said to be <em>equivalent</em>. Because a code is an unordered set of code words, the order of a display of its
         code words is immaterial. By complementing columns, any code can be transformed into
         an equivalent code that has a code word that is all 0’s.
      </p>
      
      <p class="indenthangingBB">Also for ease of exposition, we illustrate this proof by using the case <em>n</em> = 9 and <em>d</em> = 6.
      </p>
      
      <p class="indenthangingBB">Wlog (without loss of generality), let code word 0 (the first, which we will call
         cw<sub>0</sub>) be 000 000 000. Then all other code words must have at least six 1’s, to differ
         from cw<sub>0</sub> in at least six places.
      </p>
      
      <p class="indenthangingBB">Assume (which will be shown) that the code has at least three code words. Then no
         code word can have seven or more 1’s. For if one did, then another code word (which
         necessarily has six or more 1’s) would have at least four of its 1’s in the same columns
         as the word with seven or more 1’s. This means the code words would be equal in four
         or more positions, so they could differ in five or fewer positions (9 – 4), violating
         the requirement that <em>d</em> = 6. Therefore, all code words other than the first must have exactly six 1’s.
      </p>
      
      <p class="indenthangingBB">Wlog, rearrange the columns so that the first two code words are</p>
      
      <p class="indenthangingBB">cw<sub>0</sub>: 000 000 000
      </p>
      
      <p class="indenthangingBB">cw<sub>1</sub>: 111 111 000
      </p>
      
      <p class="indenthanging">The next code word, cw<sub>2</sub>, cannot have four or more of its 1’s in the left six columns, because then it would
         be the same as cw<sub>1</sub> in four or more positions, so it would differ from cw<sub>1</sub> in five or fewer positions. Therefore it has three or fewer of its 1’s in the left
         six columns, so that three of its 1’s must be in the right three positions. Therefore
         exactly three of its 1’s are in the left six columns. Rearrange the left six columns
         (of all three code words) so that cw<sub>2</sub> looks like this:
      </p>
      
      <p class="indenthangingBB">cw<sub>2</sub>: 111 000 111
      </p>
      
      <p class="indenthangingBB">By similar reasoning, the next code word (cw<sub>3</sub>) cannot have four of its 1’s in the left three and right three positions together,
         because it would then equal cw<sub>2</sub> in four positions. Therefore it has three fewer 1’s in the left three and right three
         positions, so that three of its 1’s must be in the middle three positions. By similarly
         comparing it to cw<sub>1</sub>, we conclude that three of its 1’s must be in the right three positions. Therefore
         cw<sub>3</sub> is:
      </p>
      
      <p class="indenthangingBB">cw<sub>3</sub>: 000 111 111
      </p>
      
      <p class="indenthangingBB">By comparing the next code word, if one is possible, with cw<sub>1</sub>, we conclude that it must have three 1’s in the right three positions. By comparing
         it with cw<sub>2</sub>, we conclude it must have three 1’s in the middle three positions.
      </p>
      
      <p class="indenthanging"><a id="page_445"></a>Thus, the code word is 000 111 111, which is the same as cw<sub>3</sub>. Therefore a fifth code word is impossible. By inspection, the above four code words
         satisfy <em>d</em> = 6, so <em>A</em>(9, 6) = 4.
      </p>
      
      <p class="answer1"><a href="ch15.html#ch15ansa10" id="ch15ans10"><strong>10</strong>.</a> Obviously <em>A</em>(<em>n, d</em>) is at least 2, because the two code words can be all 0’s and all 1’s. Reasoning
         as in the previous exercise, let one code word, cw<sub>0</sub>, be all 0’s. Then all other code words must have more than 2<em>n</em>/3 1’s. If the code has three or more code words, then any two code words other than
         cw<sub>0</sub> must have 1’s in the same positions for more than 2<em>n</em>/3 – <em>n</em>/3 = <em>n</em>/3 positions, as suggested by the figure below.
      </p>
      
      <div class="image"><img alt="Image" src="graphics/445equ01.jpg" /></div>
      
      <p class="indenthanging">(The figure represents cw<sub>1</sub> with its 1’s pushed to the left. Imagine placing the more than 2<em>n</em>/3 1’s of cw<sub>2</sub> to minimize the overlap of the 1’s.) Since cw<sub>1</sub> and cw<sub>2</sub> overlap in more than <em>n</em>/3 positions, they can differ in less than <em>n</em> – <em>n</em>/3 = 2<em>n</em>/3 positions, resulting in a minimum distance less than 2<em>n</em>/3.
      </p>
      
      <p class="answer1"><a href="ch15.html#ch15ansa11" id="ch15ans11"><strong>11</strong>.</a> It is SEC-DED, because the minimum distance between code words is 4. To see this,
         assume first that two code words differ in a single information bit. Then in addition
         to the information bit, the row parity, column parity, and corner check bits will
         be different in the two code words, making their distance equal to 4. If the information
         words differ in two bits, and they are in the same row, then the row parity bit will
         be the same in the two code words, but the column parity bit will differ in two columns.
         Hence their distance is 4. The same result follows if they are in the same column.
         If the two differing information bits are in different rows and columns, then the
         distance between the code words is 6. Lastly, if the information words differ in three
         bits, it is easy to verify that no matter what their distribution among the rows and
         columns, at least one parity bit will differ. Hence the distance is at least 4.
      </p>
      
      <p class="indenthangingBB">If the corner bit is not used, the minimum distance is 3. Therefore it is not SEC-DED,
         but it is a SEC code.
      </p>
      
      <p class="indenthangingBB">Whether the corner check bit is a row sum or a column sum, it is the modulo 2 sum
         of all 64 information bits, so it has the same value in either case.
      </p>
      
      <p class="indenthangingBB">The code requires 17 check bits, whereas the Hamming code requires eight (see <a href="ch15.html#ch15tab3">Table 15–3</a> on page <a href="ch15.html#page_336">336</a>), so it is not very efficient in that respect.
      </p>
      
      <p class="indenthangingBB">But it <em>is</em> effective in detecting burst errors. Assume the 9×9 array is transmitted over a bit
         serial channel in the order row 0, row 1,..., row 8. Then any sequence of ten or fewer
         bits is in one or two rows with at most one bit of overlap. Hence if the only errors
         in a transmission are a subset of ten consecutive bits, the error will be detected
         by checking the column parities in most cases, or the row parity bits in the case
         that the first and tenth bits only are in error.
      </p>
      
      <p class="indenthangingBB">An error that is <em>not</em> detected is four corrupted bits arranged in a rectangle.
      </p>
      
      <h3><a id="page_446"></a><strong>Chapter 16: Hilbert’s Curve</strong></h3>
      
      <p class="answer"><a href="ch16.html#ch16ansa1" id="ch16ans1"><strong>1</strong>.</a> and <a href="ch16.html#ch16ansa2" id="ch16ans2"><strong>2</strong>.</a></p>
      
      <div class="image"><img alt="Image" src="graphics/446fig01.jpg" /></div>
      
      <p class="indenthangingBB">The average jump distance for the traversal shown at the left above is approximately
         1.46. That for the traversal shown at the right is approximately 1.33. Therefore,
         using the Gray code seems to improve locality, at least by this measure. (For the
         Hilbert curve, the jumps are all of distance 1.)
      </p>
      
      <p class="indenthangingBB">At Edsger Dijkstra’s suggestion, the shuffle algorithm was used in an early Algol
         compiler to map a matrix onto backing store. The aim was to reduce paging operations
         when inverting a matrix. He called it the “zip-fastener algorithm.” It seems likely
         that many people have discovered it independently.
      </p>
      
      <p class="answer"><a href="ch16.html#ch16ansa3" id="ch16ans3"><strong>3</strong>.</a> Use every third bit of <em>s</em>.
      </p>
      
      <h3><strong>Chapter 17: Floating-Point</strong></h3>
      
      <p class="answer"><a href="ch17.html#ch17ansa1" id="ch17ans1"><strong>1</strong>.</a> ±0, ±2.0, and certain NaNs.
      </p>
      
      <p class="answer"><a href="ch17.html#ch17ansa2" id="ch17ans2"><strong>2</strong>.</a> Yes! The program is easily derived by noting that if <em>x = 2<sup>n</sup>(1+f)</em>, then
      </p>
      
      <div class="image"><img alt="Image" src="graphics/446equ01.jpg" /></div>
      
      <p class="indenthangingBB">Ignoring the fraction, this shows that we must change the biased exponent from 127
         <em>+ n</em> to 127 + <em>n</em> /2. The latter is (127 <em>+n)/2</em> + 127/2. Thus, it seems that a rough approximation to <img alt="Image" src="graphics/446fig02.jpg" /> is obtained by shifting rep(<em>x</em>) right one position and adding 63 in the exponent position, which is 0x1F800000.
         This approximation,
      </p>
      
      <div class="image"><img alt="Image" src="graphics/446equ02.jpg" /></div>
      
      <p class="indenthanging">also has the property that if we find an optimal value of <em>k</em> for values of <em>x</em> in the range 1.0 to 4.0, then the same value of <em>k</em> is optimal for all normal numbers. After refining the value of <em>k</em> with the aid of a program that finds the maximum <a id="page_447"></a>and minimum error for a given value of <em>k</em>, we obtain the program shown below. It includes one step of Newton-Raphson iteration.
      </p>
      
      <p class="codelink"><a href="images17.html#p447fig01" id="p447fig01a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting1">float asqrt(float x0) {<br />   union {int ix; float x;};<br /><br />   x = x0;                       // x can be viewed as int.<br />   ix = 0x1fbb67a8 + (ix &gt;&gt; 1); // Initial guess.<br />   x = 0.5f*(x + x0/x);         // Newton step.<br />   return x;<br />}
      </p>
      
      <hr />
      
      <p class="indenthangingBB">For normal numbers, the relative error ranges from 0 to approximately 0.000601. It
         gets the correct result for <em>x</em> = inf and <em>x</em> = NaN (inf and NaN, respectively). For <em>x</em> = 0 the result is approximately 4.0 × 10<sup>–20</sup>. For <em>x</em> = –0, the result is the rather useless –1.35 × 10<sup>19</sup>. For <em>x</em> a positive denorm, the result is either within the stated tolerance or is a positive
         number less than 10<sup>–19</sup>.
      </p>
      
      <p class="indenthangingBB">The Newton step uses division, so on most machines the program is not as fast as that
         for the reciprocal square root.
      </p>
      
      <p class="indenthangingBB">If a second Newton step is added, the relative error for normal numbers ranges from
         0 to approximately 0.00000023. The optimal constant is 0x1FBB3F80. If no Newton step
         is included, the relative error is slightly less than ±0.035, using a constant of
         0x1FBB4F2E. This is about the same as the relative error of the reciprocal square
         root routine without a Newton step, and like it, uses only two integer operations.
      </p>
      
      <p class="answer"><a href="ch17.html#ch17ansa3" id="ch17ans3"><strong>3</strong>.</a> Yes, one can do cube roots of positive normal numbers with basically the same method.
         The key statement is the first approximation:
      </p>
      
      <p class="codelink"><a href="images17.html#p447fig02" id="p447fig02a">Click here to view code image</a></p>
      
      <p class="programlisting2">i = 0x2a51067f + i/3;       // Initial guess.</p>
      
      <p class="indenthanging">This computes the cube root with a relative error of approximately ±0.0316. The division
         by 3 can be approximated with
      </p>
      
      <div class="image"><img alt="Image" src="graphics/447equ01.jpg" /></div>
      
      <p class="indenthanging">(where the divisions by powers of 2 are implemented as right shifts). This can be
         evaluated with seven instructions and slightly improved accuracy as shown in the program
         below. (This division trick is discussed in <a href="ch10.html#ch10lev18">Section 10–18</a> on page <a href="ch10.html#page_251">251</a>.)
      </p>
      
      <p class="codelink"><a id="page_448"></a><a href="images17.html#p448fig01" id="p448fig01a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting1">float acbrt(float x0) {<br />   union {int ix; float x;};<br /><br />   x = x0;                   // x can be viewed as int.<br />   ix = ix/4 + ix/16;        // Approximate divide by 3.<br />   ix = ix + ix/16;<br />   ix = ix + ix/256;<br />   ix = 0x2a5137a0 + ix;     // Initial guess.<br />   x = 0.33333333f*(2.0f*x + x0/(x*x));  // Newton step.<br />   return x;<br />}
      </p>
      
      <hr />
      
      <p class="indenthangingBB">Although we avoided the division by 3 (at a cost of seven elementary integer instructions),
         there is a division and four other instructions in the Newton step. The relative error
         ranges from 0 to approximately +0.00103. Thus, the method is not as successful as
         in the case of reciprocal square root and square root, but it might be useful in some
         situations.
      </p>
      
      <p class="indenthangingBB">If the Newton step is repeated and the same constant is used, the relative error ranges
         from 0 to approximately +0.00000116.
      </p>
      
      <p class="answer"><a href="ch17.html#ch17ansa4" id="ch17ans4"><strong>4</strong>.</a> Yes. The program below computes the reciprocal square root of a double-precision
         floating-point number with an accuracy of about ±3.5%. It is straightforward to improve
         its accuracy with one or two steps of Newton-Raphson iteration. Using the constant
         0x5fe80...0 gives a relative error in the range 0 to approximately +0.887, and the
         constant 0x5fe618fdf80...0 gives a relative error in the range 0 to approximately
         –0.0613.
      </p>
      
      <p class="codelink"><a href="images17.html#p448fig02" id="p448fig02a">Click here to view code image</a></p>
      
      <hr />
      
      <p class="programlisting1">double rsqrtd(double x0) {<br />    union {long long ix; double x;};<br /><br />    x = x0;<br />    ix = 0x5fe6ec85e8000000LL - (ix &gt;&gt; 1);<br />    return x;<br />}
      </p>
      
      <hr />
      
      <h3><strong>Chapter 18: Formulas for Primes</strong></h3>
      
      <p class="answer"><a href="ch18.html#ch18ansa1" id="ch18ans1"><strong>1</strong>.</a> Let <em>f(x) = a<sub>n</sub>x<sup>n</sup> + a<sub>n-1</sub>x<sup>n-1</sup> +... + a<sup>0</sup></em>. Such a polynomial monotonically approaches infinity, in magnitude, as <em>x</em> approaches infinity. (For sufficiently large <em>x</em>, the first term exceeds in magnitude the sum of the others.)
      </p>
      
      <p class="indenthangingBB">Let <em>x</em><sub>0</sub> be an integer such that |<em>f(x)</em>| ≥ 2 for all <em>x</em> &gt; <em>x</em><sub>0</sub>. Let <em>f</em> (<em>x</em><sub>0</sub>) = <em>k</em>, and let <em>r</em> be any positive integer. Then |<em>k</em> |≥ 2, and
      </p>
      
      <div class="image"><img alt="Image" src="graphics/448fig03.jpg" /></div>
      
      <p class="indenthanging"><a id="page_449"></a>Thus, as <em>r</em> increases, |<em>f(x<sub>0</sub> + rk)</em> | ranges over composites that increase in magnitude, and hence are distinct. Therefore
         <em>f</em> (<em>x</em>) takes on an infinite number of composite values.
      </p>
      
      <p class="indenthangingBB">Another way to state the theorem is that there is no non-constant polynomial in one
         variable that takes on only prime numbers, even for sufficiently large values of its
         argument.
      </p>
      
      <p class="indenthangingBB">Example: Let <em>f</em> (<em>x</em>) = <em>x</em><sup>2</sup> + <em>x</em> + 41. Then <em>f</em> (1) = 43 and
      </p>
      
      <div class="image"><img alt="Image" src="graphics/449fig01.jpg" /></div>
      
      <p class="indenthanging">which clearly produces ever-increasing multiples of 43 as <em>r</em> increases.
      </p>
      
      <p class="answer"><a href="ch18.html#ch18ansa2" id="ch18ans2"><strong>2</strong>.</a> Suppose <em>p</em> is composite. Write the congruence as
      </p>
      
      <p class="center">(<em>p</em> – 1)! = <em>pk</em> – 1,
      </p>
      
      <p class="indenthanging">for some integer <em>k</em>. Let <em>a</em> be a proper factor of <em>p</em>. Then <em>a</em> divides the left side, but not the right side, so equality cannot hold.
      </p>
      
      <p class="indenthangingBB">The theorem is easily seen to be true for <em>p</em> = 1, 2, and 3. Suppose <em>p</em> is a prime greater than 3. Then in the factorial
      </p>
      
      <p class="center">(<em>p</em> – 1)! = (<em>p</em> – 1)(<em>p</em> – 2)...(3)(2),
      </p>
      
      <p class="indenthanging">the first term, <em>p</em> – 1, is congruent to –1 modulo <em>p</em>. Each of the other terms is relatively prime to <em>p</em> and therefore has a multiplicative inverse modulo <em>p</em> (see <a href="ch10.html#ch10lev16">Section 10–16</a> on page <a href="ch10.html#page_240">240</a>), and furthermore, the inverse is unique and not equal to itself.
      </p>
      
      <p class="indenthangingBB">To see that the multiplicative inverse modulo a prime is not equal to itself (except
         for 1 and <em>p</em> – 1), suppose <em>a</em><sup>2</sup> ≡ 1 (mod <em>p</em>). Then <em>a</em><sup>2</sup> – 1 ≡ 0 (mod <em>p</em>), so that (<em>a</em> – 1)(<em>a</em> + 1) ≡ 0 (mod <em>p</em>). Because <em>p</em> is a prime, either <em>a</em> – 1 or <em>a</em> + 1 is congruent to 0 modulo <em>p</em>. In the former case <em>a</em> ≡ 1 (mod <em>p</em>) and in the latter case <em>a</em> ≡ –1 ≡ <em>p</em> – 1 (mod <em>p</em>).
      </p>
      
      <p class="indenthangingBB">Therefore, the integers <em>p</em> – 2, <em>p</em> – 3, ..., 2 can be paired so that the product of each pair is congruent to 1 modulo
         <em>p</em>. That is,
      </p>
      
      <p class="center">(<em>p</em> – 1)! = (<em>p</em> – 1)(<em>ab</em>)(<em>cd</em>)...,
      </p>
      
      <p class="indenthanging">where <em>a</em> and <em>b</em> are multiplicative inverses, as are <em>c</em> and <em>d</em>, and so forth. Thus
      </p>
      
      <p class="center">(<em>p-1)! <strong>=</strong> (-1)(1)(1) ≡ -1 (mod p</em>).
      </p>
      
      <p class="indenthangingBB"><a id="page_450"></a>Example, <em>p</em> = 11: 10! (mod 11)= 10 • 9 • 8 • 7 • 6 • 5 • 4 • 3 • 2 (mod 11) <em>=</em> 10-(9-5)(8-7)(6-2)(4-3) (mod 11) <em>=</em> (-1)(1)(1)(1)(1) (mod 11) <em>=</em> -1 (mod 11).
      </p>
      
      <p class="indenthangingBB">The theorem is named for John Wilson, a student of the English mathematician Edward
         Waring. Waring announced it without proof in 1770. The first published proof was by
         Lagrange in 1773. The theorem was known in medieval Europe around 1000 AD.
      </p>
      
      <p class="answer"><a href="ch18.html#ch18ansa3" id="ch18ans3"><strong>3</strong>.</a> If <em>n = ab</em>, with <em>a</em> and <em>b</em> distinct and neither equal to 1 or <em>n</em>, then clearly <em>a</em> and <em>b</em> are less than <em>n</em> and hence are terms of (<em>n</em> – 1)!. Therefore <em>n</em> divides (<em>n</em> –1)!.
      </p>
      
      <p class="indenthangingBB">If <em>n = a<sup>2</sup></em>, then for <em>a &gt;</em> 2, <em>a<sup>2</sup> = n&gt;2a</em>, so that both <em>a</em> and <em>2a</em> are terms of <em>(n -</em> 1)!. Therefore <em>a<sup>2</sup></em> divides <em>(n</em> – 1)!.
      </p>
      
      <p class="answer"><a href="ch18.html#ch18ansa4" id="ch18ans4"><strong>4</strong>.</a> This is probably a case in which a calculation gives more insight into a mathematical
         truth than does a formal proof.
      </p>
      
      <p class="indenthangingBB">According to Mills’s theorem, there exists a real number θ such that <span class="middle"><img alt="Image" src="graphics/ent05.jpg" /></span>θ<sup>3n</sup><span class="middle"><img alt="Image" src="graphics/ent06.jpg" /></span> is prime for all integers <em>n</em> ≥1. Let us try the possibility that for <em>n =</em> 1, the prime is 2. Then
      </p>
      
      <p class="center"><span class="middle"><img alt="Image" src="graphics/ent05.jpg" /></span>θ<sup>31</sup><span class="middle"><img alt="Image" src="graphics/ent06.jpg" /></span> = 2,
      </p>
      
      <p class="indenthanging">so that</p>
      
      <div class="image"><img alt="Image" src="graphics/450equ01.jpg" /></div>
      
      <p class="indenthanging">Cubing inequality (1) gives</p>
      
      <div class="image"><img alt="Image" src="graphics/450equ02.jpg" /></div>
      
      <p class="indenthanging">There is a prime in this range. (From our assumption, there is a prime between 2<sup>3</sup> and (2 + 1)<sup>3</sup>.) Let us choose 11 for the second prime. Then, we will have <span class="middle"><img alt="Image" src="graphics/ent05.jpg" /></span>θ<sup>32</sup><span class="middle"><img alt="Image" src="graphics/ent06.jpg" /></span> = 11 if we further constrain (2) to
      </p>
      
      <div class="image"><img alt="Image" src="graphics/450equ03.jpg" /></div>
      
      <p class="indenthanging">Continuing, we cube (3), giving</p>
      
      <div class="image"><img alt="Image" src="graphics/450equ04.jpg" /></div>
      
      <p class="indenthanging">We are assured that there is a prime between 1331 and 1728. Let us choose the smallest
         one, 1361. Further constraining (4),
      </p>
      
      <p class="center">1361 ≤ θ<sup>33</sup> &lt; 1362.
      </p>
      
      <p class="indenthangingBB"><a id="page_451"></a>So far, we have shown that there exists a real number theta such that <span class="middle"><img alt="Image" src="graphics/ent05.jpg" /></span>θ<sup>3<em>n</em></sup> <span class="middle"><img alt="Image" src="graphics/ent06.jpg" /></span> is prime for <em>n</em> = 1, 2, and 3 and, by taking 27th roots of 1361 and 1362, that θ is between 1.30637
         and 1.30642.
      </p>
      
      <p class="indenthangingBB">Obviously the process can be continued. It can be shown that a limiting value of θ
         exists, but that is not really necessary. If, in the limit, θ is an arbitrary number
         in some finite range, that still verifies Mills’s theorem.
      </p>
      
      <p class="indenthangingBB">The above calculation shows that Mills’s theorem is a little contrived. As far as
         its being a formula for primes, you have to know the primes to determine θ. It is
         like the formula for primes involving the constant
      </p>
      
      <p class="center">a = 0.203005000700011000013...,</p>
      
      <p class="indenthanging">given on page <a href="ch18.html#page_392">392</a>. The theorem clearly has little to do with primes. A similar theorem holds for any
         increasing sequence provided it is sufficiently dense.
      </p>
      
      <p class="indenthangingBB">The steps above calculate the smallest theta that satisfies Mills’s theorem. It is
         sometimes called Mills’ constant, and it has been calculated to over 6850 decimal
         places [CC].
      </p>
      
      <p class="answer"><a href="ch18.html#ch18ansa5" id="ch18ans5"><strong>5</strong>.</a> Suppose that there exist integers <em>a, b, c</em>, and <em>d</em> such that
      </p>
      
      <div class="image"><img alt="Image" src="graphics/451equ01.jpg" /></div>
      
      <p class="indenthanging">Equating real and imaginary parts,</p>
      
      <div class="image"><img alt="Image" src="graphics/451equ02.jpg" /></div>
      
      <div class="image"><img alt="Image" src="graphics/451equ03.jpg" /></div>
      
      <p class="indenthangingBB">Clearly <em>c</em> ≠ 0, because if <em>c</em> = 0 then from (6), -5b<em>d</em> = 2, which has no solution in integers.
      </p>
      
      <p class="indenthangingBB">Also <em>b</em> ≠ 0, because if <em>b</em> = 0, then from (7), either <em>a</em> or <em>d</em> is 0. <em>a</em> = 0 does not satisfy (5). Therefore <em>d</em> = 0. Then (5) becomes <em>ac</em> = 2, so one of the factors in (5) is a unit, which is not an acceptable decomposition.
      </p>
      
      <p class="indenthangingBB">From (7), <em>abd</em> + <em>b</em><sup>2</sup><em>c</em> = 0. From (6), <em>a</em><sup>2</sup><em>c</em> – 5 <em>abd</em> = 2<em>a</em>. Combining, <em>a</em><sup>2</sup><em>c</em> + 5<em>b</em><sup>2</sup><em>c</em> = 2<em>a</em>, or
      </p>
      
      <div class="image"><img alt="Image" src="graphics/451equ04.jpg" /></div>
      
      <p class="indenthanging">(recall that <em>c</em> ≠ 0). The left side of (8) is at least <em>a</em><sup>2</sup> + 5, which exceeds 2<em>a</em>/<em>c</em> whatever the values of <em>a</em> and <em>c</em> are.
      </p>
      
      <p class="indenthangingBB">To see that 3 is prime, the equation</p>
      
      <p class="center"><em>a</em><sup>2</sup> + 5<em>b</em><sup>2</sup> = <em>3a/c</em></p>
      
      <p class="indenthanging"><a id="page_452"></a>can be similarly derived, with <em>b</em> ≠ 0 and <em>c</em> ≠ 0. This also cannot be satisfied in integers.
      </p>
      
      <p class="indenthangingBB">The number 6 has two distinct decompositions into primes:</p>
      
      <div class="image"><img alt="Image" src="graphics/452equ01.jpg" /></div>
      
      <p class="indenthanging">We have not shown that <img alt="Image" src="graphics/452fig01.jpg" /> are primes. This can be shown by arguments similar to those given above (although
         somewhat longer), but it is not really necessary to do so to demonstrate that prime
         factorization is not unique in this ring. This is because however each of these numbers
         might factor into primes, the total decomposition will not be 2.3.
      </p>
      
   </body>
   
</html>