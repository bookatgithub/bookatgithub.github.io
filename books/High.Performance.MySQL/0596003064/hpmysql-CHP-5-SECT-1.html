<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>5.1 Query Processing Basics</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="hpmysql-CHP-5.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="hpmysql-CHP-5-SECT-2.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="hpmysql-CHP-5-SECT-1"></A>
<H3 class="docSection1Title">5.1 Query Processing Basics</H3>

<P class="docText"><A NAME="hpmysql-CHP-5-ITERM-1388"></A>How
MySQL goes from receiving a query to sending the results back to a
client is relatively straightforward. The work happens in several
distinct stages. Let's walk through them.</P>

<A NAME="hpmysql-CHP-5-SECT-1.1"></A>
<H4 class="docSection2Title">5.1.1 Query Cache</H4>

<P class="docText"><A NAME="hpmysql-CHP-5-ITERM-1389"></A><A NAME="hpmysql-CHP-5-ITERM-1390"></A>You
can enable the query cache (available as of MySQL 4.0.1) by setting
<TT>query_cache_type</TT><A NAME="hpmysql-CHP-5-ITERM-1391"></A> to an appropriate
value in <I>my.cnf</I>:</P>

<PRE>query_cache_type = 1</PRE>

<P class="docText">MySQL attempts to locate the results of any <TT>SELECT</TT>
query in the query cache before bothering to analyze or execute it.
It does this by hashing the query and using the hashed value to check
for the results in the cache. MySQL uses the exact query text it
receives, so the cache is sensitive to the most trivial variations.</P>

<P class="docText">As far as the cache is concerned, the query:</P>

<PRE>SELECT * FROM table1</PRE>

<P class="docText">is different from:</P>

<PRE>select * FROM table1</PRE>

<P class="docText">The same goes for variations in
<A NAME="hpmysql-CHP-5-ITERM-1392"></A><A NAME="hpmysql-CHP-5-ITERM-1393"></A>whitespace. MySQL
doesn't trim extra space from the beginning or end
of queries. This is rarely a problem because most repetitive queries
are generated by applications rather than humans sitting at a
keyboard.</P>

<P class="docText"><A NAME="hpmysql-CHP-5-ITERM-1394"></A>To save some effort, MySQL cheats a bit. It
only bothers to hash <TT>SELECT</TT> queries, since
they're the only ones it makes any sense to cache.
Unfortunately, older 4.0 versions of
<A NAME="hpmysql-CHP-5-ITERM-1395"></A><A NAME="hpmysql-CHP-5-ITERM-1396"></A>MySQL
don't consider every <TT>SELECT</TT>
query. The logic it uses simply checks the first three characters of
your query, looking for <TT>SEL</TT> in a case-insensitive
way.</P>

<P class="docText">As a result of this three-character "tunnel
vision," any time you introduce whitespace or
anything else at the beginning of the query, MySQL
won't bother with the query cache. This can be a
real problem in some applications. We know of a feed-processing
system in which the developers uses comments to embed extra
information at the beginning of each query:</P>

<PRE>/* &lt;b&gt;GetLatestStuff&lt;/b&gt; */ SELECT * FROM sometable WHERE ...</PRE>

<P class="docText">The comment made is easier to identify the queries in an
administrative tool that grabs the output of <TT>SHOW
PROCESSLIST</TT> for display on a web page. Unfortunately,
there's no way to tell MySQL to
"try harder" when deciding whether
a query is a <TT>SELECT</TT>, so these queries are never
cached. Luckily, this problem is cured with a simple upgrade to MySQL
5.0.</P>

<P class="docText"><A NAME="hpmysql-CHP-5-ITERM-1397"></A>It is possible to tell MySQL that it
should <span class="docEmphasis">not</span> cache a given query, however. The way
to dodge the query cache is to add the
<TT>SQL_NO_CACHE</TT><A NAME="hpmysql-CHP-5-ITERM-1398"></A> hint to your query.</P>

<PRE>SELECT SQL_NO_CACHE * FROM mytable</PRE>

<P class="docText">This is helpful in controlling cache pollution. If your application
has a set of queries that will never benefit from the query cache
(perhaps because they run only once a day), there's
no sense in caching them. Telling MySQL not to cache such queries
leaves more room for storing the results of repetitive queries.</P>

<P class="docText">When the query cache is running in ondemand mode (set
<TT>query_cache_type</TT> to 2 in
<I>my.cnf</I>), MySQL does the work of trying to find a
query in the cache only when it sees a
<TT>SQL_CACHE</TT><A NAME="hpmysql-CHP-5-ITERM-1399"></A> hint in the query:</P>

<PRE>SELECT SQL_CACHE * FROM mytable</PRE>

<P class="docText">If the query's hashed value is found in the cache,
MySQL sends the results from the cache to the client, bypassing any
additional effort, just as expected.</P>

<P class="docText">The format of the results in the query cache is identical to the
format used when sending them to a client. So there is very little
overhead in retrieving results from the cache and sending them to a
client. MySQL simply sends the data over the network.
We'll look at query cache performance in <A class="docLink" HREF="hpmysql-CHP-6.html#hpmysql-CHP-6">Chapter 6</A>.<A NAME="hpmysql-CHP-5-ITERM-1400"></A><A NAME="hpmysql-CHP-5-ITERM-1401"></A></P>


<A NAME="hpmysql-CHP-5-SECT-1.2"></A>
<H4 class="docSection2Title">5.1.2 Parsing, Analysis, and Optimization</H4>

<P class="docText"><A NAME="hpmysql-CHP-5-ITERM-1402"></A>Before
MySQL can do anything interesting (or useful) with a noncached query,
it must parse the query into its component parts. As part of that
process, it verifies that the query is syntactically valid and
gathers some basic information about the query:</P>

<UL><LI><P class="docList"><A NAME="hpmysql-CHP-5-ITERM-1403"></A>What
type of query is this? Is it a <TT>SELECT</TT>,
<TT>INSERT</TT>, <TT>UPDATE</TT>, or
<TT>DELETE</TT>, or some other administrative command such
as <TT>SET</TT> or <TT>GRANT</TT>?</P></LI><LI><P class="docList">Which tables are involved? Are there any aliases used?</P></LI><LI><P class="docList">What is the <TT>WHERE</TT> clause?</P></LI><LI><P class="docList">Are there other hints or modifiers involved?</P></LI></UL>
<P class="docText">Once a query is broken down into more basic pieces, MySQL begins the
more challenging work of figuring out what to do with it. This is
where the <I>query
optimizer</I><A NAME="hpmysql-CHP-5-ITERM-1404"></A> kicks in. The query
optimizer's goal, simply put, is to find the most
efficient way to execute a query given all the available information.
Most of the time, this means the optimizer works to limit the number
of records it must examine. It does this because the time associated
with disk I/O is often (but not always) the governing factor that
determines how long a query will take. Intuitively, this makes
complete sense. It is an extension of the very same logic that
explains why indexes are so helpful.</P>

<P class="docText"><A NAME="hpmysql-CHP-5-ITERM-1405"></A>How
the optimizer goes about making decisions is often regarded by people
unfamiliar with MySQL internals as something like voodoo. Of course,
it's not voodoo at all. MySQL has a set of rules and
heuristics that have been evolving since its early days. These rules
guide its decision-making process. But like any computer program that
must deal with the infinite ways humans can assemble data and ask
questions about it, the optimizer's not perfect. The
rules and heuristics it uses work very well much of the time, but, on
occasion, they do not.</P>

<P class="docText">The MySQL developers are constantly improving the
optimizer—attempting to make it smarter and faster with each
new release. Based on feedback from real-world users, they are always
looking for ways to refine MySQL's ability to make
the right decision. If you find a query that causes MySQL to make bad
decisions, be sure to report it. Unreported problems are rarely
fixed.</P>

<P class="docText">To make good decisions, MySQL tries to answer several important
questions.</P>

<UL><LI><P class="docList">Are there any indexes that are candidates for finding the rows
quickly?</P></LI><LI><P class="docList">Which index is best? If multiple tables are involved, which index is
best for each table?</P></LI><LI><P class="docList">Which tables depend on which other tables in the join?</P></LI><LI><P class="docList">What's the optimal join order for the tables?</P></LI></UL>
<P class="docText">Of course, MySQL needs to make a decision very quickly and without
actually testing all the options. Otherwise it might spend more time
deciding how to execute the query than actually executing it!</P>

<P class="docText">The bulk of MySQL's effort centers around indexes
and table join order. These aren't the only factors,
but they're certainly the important ones. To get a
better understanding of what MySQL is thinking about a
<TT>SELECT</TT> query, it's best to look
at the <A NAME="hpmysql-CHP-5-ITERM-1406"></A><TT>EXPLAIN</TT> output for the
query.</P>


<A NAME="hpmysql-CHP-5-SECT-1.3"></A>
<H4 class="docSection2Title">5.1.3 Using EXPLAIN</H4>

<P class="docText"><A NAME="hpmysql-CHP-5-ITERM-1407"></A>So, what sort of knowledge can MySQL
gather without expending a lot of effort and time?
Let's look at a some queries against a news headline
table—the sort of thing you might use to build a customizable
news web site. The structure of the table is listed next. Rather than
guessing what MySQL will probably do, we'll use its
under-appreciated
<A NAME="hpmysql-CHP-5-ITERM-1408"></A><TT>EXPLAIN</TT> command to help
figure that out. In doing so, we'll see how adding
an index or simply rephrasing a query can often better use an
existing index and greatly improve performance.</P>

<PRE>mysql&gt; <B>describe Headline;</B>
+------------+------------------+------+-----+---------+----------------+
| Field      | Type             | Null | Key | Default | Extra          |
+------------+------------------+------+-----+---------+----------------+
| Id         | int(10) unsigned |      | PRI | NULL    | auto_increment |
| Headline   | varchar(255)     |      |     |         |                |
| Url        | varchar(255)     |      | UNI |         |                |
| Time       | int(10) unsigned |      | MUL | 0       |                |
| ExpireTime | int(10) unsigned |      |     | 0       |                |
| Date       | varchar(6)       |      |     |         |                |
| Summary    | text             | YES  |     | NULL    |                |
| ModTime    | timestamp        | YES  |     | NULL    |                |
+------------+------------------+------+-----+---------+----------------+
8 rows in set (0.00 sec)</PRE>

<P class="docText">As you can tell, the <TT>Headline</TT> table contains
information about news stories: title, summary, date, and so on.
Headlines can be associated with multiple topics, which are defined
in the <TT>Topic</TT> table. The <TT>T2H</TT>
table maps topics to headlines and vice versa. The relationship is
many-to-many because a single headline may be associated with
multiple topics.</P>

<P class="docText">When you write a query against a primary key or unique index, MySQL
should know that there can be only a single match for each value.
Indeed, this query is very fast:</P>

<PRE>mysql&gt; <B>SELECT Headline, Url FROM Headline WHERE Id = 13950120 \G</B>
*************************** 1. row ***************************
Headline: Midwest Cash Grain PM - Soy off, USDA data awaited
     Url: http://biz.yahoo.com/rm/030328/markets_grain_cash_2.html
1 row in set (0.00 sec)</PRE>

<P class="docText">Just as it's obvious to you or me, MySQL knows that
only one record can possibly match. Its strategy for finding the row
is straightforward: simply check the primary index for a match. If it
exists, fetch the row. To verify that, let's
<TT>EXPLAIN</TT> it:</P>

<PRE>mysql&gt; <B>EXPLAIN SELECT Headline, Url FROM Headline WHERE id = 13950120 \G</B>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: Headline
         type: const
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: const
         rows: 1
        Extra:
1 row in set (0.00 sec)</PRE>

<P class="docText">Just as expected, MySQL knows there's only one
matching row. The <TT>rows</TT> value tells you so. What
MySQL says here isn't always to be completely
trusted, however, as you'll see in a little bit.</P>

<P class="docText">Of course, <A NAME="hpmysql-CHP-5-ITERM-1409"></A>EXPLAIN is relating much more than how many
rows to expect. Let's quickly review the information
it provides:</P>

<A NAME="hpmysql-CHP-5-ITERM-1410"></A><DL class="docList"><br><p><DT><I><span class="docPubcolor">id</span></I></DT></p>
<DD>
<P class="docList">The ID of this table in the query. <TT>EXPLAIN</TT>
produces one output record for each table in the query.</P>
</DD>
<br><p><DT><I><span class="docPubcolor">select_type</span></I></DT></p>
<DD>
<P class="docList">What is this table's role in the larger query?
Possible values are <TT>SIMPLE</TT>,
<TT>PRIMARY</TT>, <TT>UNION</TT>,
<TT>DEPENDENT UNION</TT>, <TT>SUBSELECT</TT>, and
<TT>DERIVED</TT>. As we look at the more complicated
queries, the meaning will become clearer.</P>
</DD>
<br><p><DT><I><span class="docPubcolor">table</span></I></DT></p>
<DD>
<P class="docList">The name of the table MySQL will read records from.</P>
</DD>
<br><p><DT><I><span class="docPubcolor">type</span></I></DT></p>
<DD>
<P class="docList">What type of join will MySQL use? In this example, you see
<TT>const</TT> because there was a constant value in the
query. Other possible values are <TT>system</TT>,
<TT>eq_ref</TT>, <TT>ref</TT>,
<TT>range</TT>, <TT>index</TT>, or
<TT>ALL</TT>. We'll revisit this in more
detail in the "Joins" section,
later in this chapter.</P>
</DD>
<br><p><DT><I><span class="docPubcolor">possible_keys</span></I></DT></p>
<DD>
<P class="docList">A list of the indexes (or NULL if none) MySQL can use to find rows in
the table.</P>
</DD>
<br><p><DT><I><span class="docPubcolor">key</span></I></DT></p>
<DD>
<P class="docList">The name of the index MySQL decides to use, after checking all
possible indexes (listed in <TT>possible_keys</TT>) and
choosing the best.</P>
</DD>
<br><p><DT><I><span class="docPubcolor">key_len</span></I></DT></p>
<DD>
<P class="docList">The size of the key value (in bytes).</P>
</DD>
<br><p><DT><I><span class="docPubcolor">ref</span></I></DT></p>
<DD>
<P class="docList">The columns or values that are used to match against the key.</P>
</DD>
<br><p><DT><I><span class="docPubcolor">rows</span></I></DT></p>
<DD>
<P class="docList">The number of rows MySQL thinks it needs to examine to satisfy the
query. If you frequently add and remove records from the table,
running <TT>ANALYZE TABLE</TT><A NAME="hpmysql-CHP-5-ITERM-1410"></A> lets MySQL update the index
statistics so it can make better estimates.</P>
</DD>
<br><p><DT><I><span class="docPubcolor">Extra</span></I></DT></p>
<DD>
<P class="docList">Any extra information MySQL wishes to convey about the execution of
this query. We'll see some examples of that shortly.</P>
</DD>
</DL>

<P class="docText">The simple case is just that—simple. Let's ask
for a range of values instead.</P>

<PRE>mysql&gt; <B>SELECT Url FROM Headline WHERE id BETWEEN 13950120 AND 13950125;</B>
+----------------------------------------------------------+
| Url                                                      |
+----------------------------------------------------------+
| http://biz.yahoo.com/rm/030328/markets_grain_cash_2.html |
| http://biz.yahoo.com/prnews/030328/cgf038_1.html         |
| http://biz.yahoo.com/bw/030328/285487_1.html             |
| http://biz.yahoo.com/rc/030328/turkey_hijack_5.html      |
| http://biz.yahoo.com/rm/030328/food_aid_iraq_1.html      |
+----------------------------------------------------------+
5 rows in set (0.00 sec)

mysql&gt; <B>EXPLAIN SELECT Url FROM Headline WHERE id BETWEEN 13950120 AND 13950125 \G</B>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: Headline
         type: range
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: NULL
         rows: 3
        Extra: Using where
1 row in set (0.00 sec)</PRE>

<P class="docText">In this case, the <TT>type</TT> has switched from
<TT>const</TT> to <TT>range</TT> to indicate that
a search for more than one value. Similarly, <TT>ref</TT>
is now <TT>NULL</TT>.</P>

<P class="docText"><A NAME="hpmysql-CHP-5-ITERM-1411"></A>Every thing seems reasonable unless you
look closely. When executed, the query returns five rows, but the
<TT>rows</TT> says three. That's because
the <TT>rows</TT> value is merely an estimate. It probably
should have been called <TT>estimated_rows</TT>.</P>

<P class="docText">The estimate is based on the index MySQL is using. Based on the
distribution of records across the possible key values, it simply
approximates that there are three valid records between 13950120 and
13950125.</P>

<P class="docText">Also notice that the <TT>Extra</TT> column says
<TT>Using where</TT>. That's
MySQL's reassuring way of telling you that
it's using the limitations specified in the
<TT>WHERE</TT> clause to select records. It
wasn't present in the first example because MySQL
treats a single-row lookup using the primary key as special case.</P>

<P class="docText">What if we try fetching records based on a nonindexed column:</P>

<PRE>mysql&gt; <B>SELECT COUNT(*) FROM Headline WHERE ExpireTime &gt;= 1112201600;</B>
+----------+
| COUNT(*) |
+----------+
|     3971 |
+----------+
1 row in set (1.04 sec)

mysql&gt; <B>EXPLAIN SELECT COUNT(*) FROM Headline WHERE ExpireTime &gt;= 1112201600 \G</B>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: Headline
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 302116
        Extra: Using where
1 row in set (0.00 sec)</PRE>

<P class="docText">The <TT>NULL</TT> value in the <TT>key</TT>
column of the <TT>EXPLAIN</TT> output tell us that MySQL
won't be using an index for this query. In fact, the
<TT>NULL</TT> value in the <TT>possible_keys</TT>
column tells us that there were no indexes to pick from at all. If
this type of query is likely to be common, we can simply add an index
and rerun the query (or the <TT>EXPLAIN</TT>) to verify
that MySQL uses it.</P>

<PRE>mysql&gt; <B>ALTER TABLE Headline ADD INDEX (ExpireTime);</B>
Query OK, 302116 rows affected (40.02 sec)
Records: 302116  Duplicates: 0  Warnings: 0

mysql&gt; <B>SELECT COUNT(*) FROM Headline WHERE ExpireTime &gt;= 1112201600;</B>
+----------+
| COUNT(*) |
+----------+
|     3971 |
+----------+
1 row in set (0.01 sec)

mysql&gt; <B>EXPLAIN SELECT COUNT(*) FROM Headline WHERE ExpireTime &gt;= 1112201600 \G</B>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: Headline
         type: range
possible_keys: ExpireTime
          key: ExpireTime
      key_len: 4
          ref: NULL
         rows: 12009
        Extra: Using where; Using index
1 row in set (0.00 sec)</PRE>

<P class="docText">The query now runs in 0.01 seconds instead of 1.04. The
<TT>EXPLAIN</TT> output looks much better, with the new
<TT>ExpireTime</TT> index being used for a
<TT>range</TT> search. Note again the discrepancy between
<TT>rows</TT> (12009) and the actual row count (3971). In a
case like this, it might be possible to improve the estimate that
MySQL makes by running either <TT>ANALYZE</TT>
<TT>TABLE</TT> or <TT>OPTIMIZE</TT>
<TT>TABLE</TT> on the <TT>Headline</TT> table.</P>

<P class="docText">Also, notice that MySQL said <TT>Using index</TT>. That
means this is an <I>index-only
query</I><A NAME="hpmysql-CHP-5-ITERM-1412"></A><A NAME="hpmysql-CHP-5-ITERM-1413"></A>. MySQL is able to get all the data it
needs from the <TT>ExpireTime</TT> index, so it
doesn't bother fetching any of the rows from disk.</P>

<P class="docText">But what if you need to fetch multiple headlines, and you know their
IDs? Should you use <TT>OR</TT> or
<TT>IN(...)</TT>? Let's find out what
MySQL can tell us, using the lowest and highest headline IDs as well
as one in between:</P>

<PRE>mysql&gt; <B>SELECT Url FROM Headline WHERE Id IN(1531513, 10231599, 13962322);</B>
+----------------------------------------------+
| Url                                          |
+----------------------------------------------+
| http://biz.yahoo.com/bond/010117/bf.html     |
| http://biz.yahoo.com/e/021101/yhoo10-q.html  |
| http://biz.yahoo.com/bw/030331/315850_1.html |
+----------------------------------------------+
3 rows in set (0.00 sec)

mysql&gt; <B>EXPLAIN SELECT Url FROM Headline WHERE Id IN(1531513, 10231599, 13962322) \G</B>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: Headline
         type: range
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: NULL
         rows: 3
        Extra: Using where
1 row in set (0.00 sec)

mysql&gt; <B> SELECT Url FROM Headline WHERE Id = 1531513 OR Id = 10231599 OR Id = 13962322;</B>
+----------------------------------------------+
| Url                                          |
+----------------------------------------------+
| http://biz.yahoo.com/bond/010117/bf.html     |
| http://biz.yahoo.com/e/021101/yhoo10-q.html  |
| http://biz.yahoo.com/bw/030331/315850_1.html |
+----------------------------------------------+
3 rows in set (0.03 sec)

mysql&gt; <B> EXPLAIN SELECT Url FROM Headline WHERE Id = 1531513 OR Id = 10231599 OR Id = 
13962322 \G</B>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: Headline
         type: range
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: NULL
         rows: 3
        Extra: Using where
1 row in set (0.00 sec)</PRE>

<P class="docText">Both queries execute very quickly, and their
<TT>EXPLAIN</TT> output is the same.
They're functionally the same. It's
clear that either query may return anywhere from zero to three rows.
We're querying based on a unique index (the primary
key), so there isn't much for MySQL to think about.
As it turns out, we happen to know that in this case, MySQL
internally changed the multi-<TT>OR</TT> query to one that
uses a single <TT>IN(...)</TT> list. However,
it's clear that as the number of IDs increases, the
query string will be smaller if you use the
<TT>IN(..)</TT>. A smaller query means less parsing
overhead and better performance.</P>

<P class="docText">What if we use a subquery to fetch the URL for the highest numbered
headline?</P>

<PRE>mysql&gt; <B>EXPLAIN SELECT Url FROM Headline WHERE Id IN (SELECT MAX(Id) FROM Headline);</B></PRE>

<P class="docText">After waiting five minutes, we killed the query. Either we did
something wrong, or MySQL wasn't using the obvious
approach to resolve this query. Hmm.</P>

<P class="docText">To find out, let's explain it.</P>

<PRE>mysql&gt; <B>EXPLAIN SELECT Url FROM Headline WHERE Id IN (SELECT MAX(id) FROM Headline) \G</B>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: Headline
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 302116
        Extra: Using where
*************************** 2. row ***************************
           id: 2
  select_type: DEPENDENT SUBSELECT
        table: Headline
         type: index
possible_keys: NULL
          key: PRIMARY
      key_len: 4
          ref: NULL
         rows: 302116
        Extra: Using index
2 rows in set (0.00 sec)</PRE>

<P class="docText">Yikes!</P>

<P class="docText">MySQL isn't using any indexes! Notice that both
<TT>possible_keys</TT> fields are <TT>NULL</TT>.
Is this a bug? Perhaps, especially when you consider that the
<TT>key</TT> field in the dependent subselect says that it
selected the primary key. But it wasn't in the list
of possible keys. And, worse yet, MySQL believes it must examine
302,116 rows to resolve a single-record lookup supposedly based on a
primary key.</P>

<P class="docText">Of course, this testing was performed with MySQL 4.1.0 alpha,
prerelease code in which the query optimizer hadn't
been properly tuned to handle subselects well.<sup class="docFootnote"><A class="docLink" HREF="#hpmysql-CHP-5-FNOTE-1">[1]</A></sup> The point
isn't that MySQL didn't do the
right thing. No matter how well tuned it is, MySQL will make a bad
decision once in a while. When it does, you need to be able to
diagnose the problem and, in some cases, come up with a workaround.</P><blockquote><p class="docFootnote"><sup><A NAME="hpmysql-CHP-5-FNOTE-1">[1]</A></sup> Subsequent tests with the 4.1.2 alpha version proved that the
query optimizer no longer had this bug.</p></blockquote>

<P class="docText">So let's rewrite the query a bit to simplify things.
We're using <TT>IN(...)</TT> in a query
that can only return one row. So let's change that
to an equality (=) test.</P>

<PRE>mysql&gt; <B>SELECT Url FROM Headline WHERE Id = (SELECT MAX(id) FROM Headline);</B>
+----------------------------------------------+
| Url                                          |
+----------------------------------------------+
| http://biz.yahoo.com/bw/030331/315850_1.html |
+----------------------------------------------+
1 row in set (0.00 sec)

mysql&gt; <B>EXPLAIN SELECT Url FROM Headline WHERE Id = (SELECT MAX(id) FROM Headline) \G</B>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: Headline
         type: const
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: const
         rows: 1
        Extra:
*************************** 2. row ***************************
           id: 2
  select_type: SUBSELECT
        table: NULL
         type: NULL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
        Extra: Select tables optimized away
2 rows in set (0.00 sec)</PRE>

<P class="docText">A-ha! That did it. The query ran in a split second.</P>

<P class="docText">The <TT>EXPLAIN</TT> output is interesting too. MySQL
noticed that we were attempting something very trivial and optimized
away the second table. All those <TT>NULL</TT> values are
MySQL's way of saying, "These
simply don't matter."</P>

<P class="docText">But what if that hadn't worked? Or what if
we're using an older MySQL that
doesn't have subselects yet? Simple. We can rewrite
the query as two <TT>SELECT</TT> statements and store the
intermediate value in a variable on the server side so that no
client-side state is required:</P>

<PRE>mysql&gt; SELECT @max := MAX(Id) FROM Headline;
+-----------------+
| @max := MAX(Id) |
+-----------------+
|        13962322 |
+-----------------+
1 row in set (0.00 sec)

mysql&gt; SELECT Url FROM Headline WHERE Id = @max;
+----------------------------------------------+
| Url                                          |
+----------------------------------------------+
| http://biz.yahoo.com/bw/030331/315850_1.html |
+----------------------------------------------+
1 row in set (0.00 sec)</PRE>

<P class="docText">We don't even need to explain those queries. Based
on what we already know, they'll obviously be fast
(and they are). Both are queries on primary keys and fetch single
values.</P>

<P class="docText">And, for completeness, the most MySQL-like way to write that query is
to use an <TT>ORDER BY</TT> and <TT>LIMIT</TT>:</P>

<PRE>SELECT Url FROM Headline ORDER BY Id DESC LIMIT 1;</PRE>

<P class="docText">Let's look at one last example. What if you query
based on two different indexed fields? MySQL tries to select the
index that will result in the fewest rows being examined. So the
results will vary depending on your data and the values you choose.</P>

<PRE>mysql&gt; <B>SELECT COUNT(*) FROM Headline WHERE ExpireTime &gt;= 1112201600 AND Id &lt;= 
5000000;</B>
+----------+
| COUNT(*) |
+----------+
|     1175 |
+----------+
1 row in set (0.04 sec)

mysql&gt; <B>EXPLAIN SELECT COUNT(*) FROM Headline</B>
    -&gt; <B>WHERE ExpireTime &gt;= 1112201600 AND Id &lt;= 5000000 \G</B>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: Headline
         type: range
possible_keys: PRIMARY,ExpireTime
          key: ExpireTime
      key_len: 4
          ref: NULL
         rows: 12009
        Extra: Using where
1 row in set (0.00 sec)</PRE>

<P class="docText">For this query, given the choice between the primary key field
(<TT>Id</TT>) and the <TT>ExpireTime</TT>, MySQL
decided to use <TT>ExpireTime</TT>. However, if the
<TT>ExpireTime</TT> value is changed so that it matches
many more rows, MySQL should favor the primary key:</P>

<PRE>mysql&gt; <B>EXPLAIN SELECT COUNT(*) FROM Headline WHERE ExpireTime &gt;= 1012201600 AND Id &lt;= 
5000000 \G</B>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: Headline
         type: range
possible_keys: PRIMARY,ExpireTime
          key: PRIMARY
      key_len: 4
          ref: NULL
         rows: 13174
        Extra: Using where
1 row in set (0.00 sec)</PRE>

<P class="docText">As expected, it does.</P>

<P class="docText">Again, this decision-making process is all based on
MySQL's notion of what the data looks like—how
evenly distributed the values are. Different storage engines (InnoDB,
MyISAM, BDB) use different methods to gather those statistics. As a
result, you may find that some queries are executed differently if
you convert your data to a different table type. Of course, running
<TT>ANALYZE</TT> <TT>TABLE</TT> will also affect
MySQL's statistics.<A NAME="hpmysql-CHP-5-ITERM-1414"></A></P>

<A NAME="hpmysql-CHP-5-SECT-1.3.1"></A>
<H5 class="docSection3Title">5.1.3.1 Joins</H5>

<P class="docText"><A NAME="hpmysql-CHP-5-ITERM-1415"></A>Things become slightly
more complex when you're querying multiple tables.
MySQL has to decide which order makes the most sense. Again, the goal
it to read as few rows as possible, so it will consider each table
and estimate how many rows it must read from each. In doing so, it
also needs to understand the relationship among the tables. For
example, with a query like this, it's clear that
MySQL can't read the table <TT>order</TT>
first:</P>

<PRE>SELECT customer.name, order.date_placed, region.name
FROM customer, order, region
WHERE order.customer_id = customer.id
AND customer.region_id = region.id
AND customer.name = 'John Doe'</PRE>

<P class="docText">The rows MySQL will need to retrieve from the
<TT>order</TT> table depend on the
<TT>customer</TT> table. So it must read
<TT>customer</TT> before <TT>order</TT>. In fact,
the same is true of <TT>region</TT>. So in this case, MySQL
has to read <TT>customer</TT> records first. From there it
will decide to read the remaining tables in whatever order it
chooses.</P>

<P class="docText">Unfortunately, finding the optimal join order is one of
MySQL's weakest skills. Rather than being clever
about this problem, the optimizer simply tries to brute-force its way
through. It tries every possible combination before choosing one.
That can spell disaster in a some cases. We've seen
at least one case in which MySQL took 29 seconds to decide how to
execute a multitable join and then 1 second to actually execute it.
In this particular case, there were over 10 tables involved. Since
MySQL is considering all possible combinations, performance begins to
degrade quite drastically as you go beyond a handful of tables. The
exact number, of course, depends on how powerful CPUs are this year.</P>



<A NAME="hpmysql-CHP-5-SECT-1.4"></A>
<H4 class="docSection2Title">5.1.4 Execution</H4>

<P class="docText"><A NAME="hpmysql-CHP-5-ITERM-1416"></A>There's
not a lot to say about query execution. MySQL simply follows its
plan, fetching rows from each table in order and joining based on the
relevant columns (hopefully using indexes). Along the way, it may
need to create a temporary table (in memory or on disk) to store the
results. Once all the rows are available, it sends them to the
client.</P>

<P class="docText">Along the way, MySQL gathers some information and statistics about
each query it executes, including:</P>

<UL><LI><P class="docList">Who issued the query</P></LI><LI><P class="docList">How long the process took</P></LI><LI><P class="docList">How many rows were returned</P></LI></UL>
<P class="docText">That information will appear in the slow query log (discussed later
in this chapter) if the query time exceeds the
server's threshold, and the log is enabled. If the
query is issued interactively, it will also appear after the query
results.<A NAME="hpmysql-CHP-5-ITERM-1417"></A></P>



<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="hpmysql-CHP-5.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="hpmysql-CHP-5-SECT-2.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
