<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>2.3 Designing algorithms</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0015.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0017.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch02"></a>
<div class="section">
<h2 class="first-section-title">
<a name="88"></a><a name="ch02lev1sec3"></a><span class="section-titlelabel">2.3 </span>Designing algorithms</h2>
<p class="first-para">There are many ways to design algorithms. Insertion sort uses an <b class="bold"><i class="emphasis">incremental</i></b> approach: having sorted the subarray <i class="emphasis">A</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">j</i> - 1], we insert the single element <i class="emphasis">A</i>[<i class="emphasis">j</i>] into its proper place, yielding the sorted subarray <i class="emphasis">A</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">j</i>].<a name="89"></a><a name="IDX-28"></a>
</p>
<p class="para">In this section, we examine an alternative design approach, known as "divide-and-conquer." We shall use divide-and-conquer to design a sorting algorithm whose worst-case running time is much less than that of insertion sort. One advantage of divide-and-conquer algorithms is that their running times are often easily determined using techniques that will be introduced in <a href="DDU0022.html#203" target="_parent" class="chapterjump">Chapter 4</a>.</p>
<div class="section">
<h3 class="sect3-title">
<a name="90"></a><a name="ch02lev2sec1"></a><span class="section-titlelabel">2.3.1 </span>The divide-and-conquer approach</h3>
<p class="first-para">Many useful algorithms are <b class="bold"><i class="emphasis">recursive</i></b> in structure: to solve a given problem, they call themselves recursively one or more times to deal with closely related subproblems. These algorithms typically follow a <b class="bold"><i class="emphasis">divide-and-conquer</i></b> approach: they break the problem into several subproblems that are similar to the original problem but smaller in size, solve the subproblems recursively, and then combine these solutions to create a solution to the original problem.</p>
<p class="para">The divide-and-conquer paradigm involves three steps at each level of the recursion:</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">
<b class="bold">Divide</b> the problem into a number of subproblems.</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">Conquer</b> the subproblems by solving them recursively. If the subproblem sizes are small enough, however, just solve the subproblems in a straightforward manner.</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">Combine</b> the solutions to the subproblems into the solution for the original problem.</p>
</li>
</ul>
<p class="para">The <b class="bold"><i class="emphasis">merge sort</i></b> algorithm closely follows the divide-and-conquer paradigm. Intuitively, it operates as follows.</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="para">
<b>Divide:</b> Divide the <i class="emphasis">n</i>-element sequence to be sorted into two subsequences of <i class="emphasis">n</i>/2 elements each.</p>
</li>
<li class="listitem">
<p class="para">
<b>Conquer:</b> Sort the two subsequences recursively using merge sort.</p>
</li>
<li class="listitem">
<p class="para">
<b>Combine:</b> Merge the two sorted subsequences to produce the sorted answer.</p>
</li>
</ul>
<p class="para">The recursion "bottoms out" when the sequence to be sorted has length 1, in which case there is no work to be done, since every sequence of length 1 is already in sorted order.</p>
<p class="para">The key operation of the merge sort algorithm is the merging of two sorted sequences in the "combine" step. To perform the merging, we use an auxiliary procedure MERGE(<i class="emphasis">A</i>, <i class="emphasis">p</i>, <i class="emphasis">q</i>, <i class="emphasis">r</i>), where <i class="emphasis">A</i> is an array and <i class="emphasis">p</i>, <i class="emphasis">q</i>, and <i class="emphasis">r</i> are indices numbering elements of the array such that <i class="emphasis">p</i> <span class="unicode">&le;</span> <i class="emphasis">q</i> <span class="unicode">&lt;</span> <i class="emphasis">r</i>. The procedure assumes that the subarrays <i class="emphasis">A</i>[<i class="emphasis">p <span class="unicode">&#8229;</span> q</i>] and <i class="emphasis">A</i>[<i class="emphasis">q</i> + 1 <span class="unicode">&#8229;</span> <i class="emphasis">r</i>] are in sorted order. It <b class="bold"><i class="emphasis">merges</i></b> them to form a single sorted subarray that replaces the current subarray <i class="emphasis">A</i>[<i class="emphasis">p <span class="unicode">&#8229;</span> r</i>].</p>
<p class="para">Our MERGE procedure takes time <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>), where <i class="emphasis">n</i> = <i class="emphasis">r</i> - <i class="emphasis">p</i> + 1 is the number of elements being merged, and it works as follows. Returning to our card-playing <a name="91"></a><a name="IDX-29"></a>motif, suppose we have two piles of cards face up on a table. Each pile is sorted, with the smallest cards on top. We wish to merge the two piles into a single sorted output pile, which is to be face down on the table. Our basic step consists of choosing the smaller of the two cards on top of the face-up piles, removing it from its pile (which exposes a new top card), and placing this card face down onto the output pile. We repeat this step until one input pile is empty, at which time we just take the remaining input pile and place it face down onto the output pile. Computationally, each basic step takes constant time, since we are checking just two top cards. Since we perform at most <i class="emphasis">n</i> basic steps, merging takes <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) time.</p>
<p class="para">The following pseudocode implements the above idea, but with an additional twist that avoids having to check whether either pile is empty in each basic step. The idea is to put on the bottom of each pile a <b class="bold"><i class="emphasis">sentinel</i></b> card, which contains a special value that we use to simplify our code. Here, we use <span class="unicode">&infin;</span> as the sentinel value, so that whenever a card with <span class="unicode">&infin;</span> is exposed, it cannot be the smaller card unless both piles have their sentinel cards exposed. But once that happens, all the nonsentinel cards have already been placed onto the output pile. Since we know in advance that exactly <i class="emphasis">r</i> - <i class="emphasis">p</i> + 1 cards will be placed onto the output pile, we can stop once we have performed that many basic steps.</p>
<div class="informalexample">
<pre class="literallayout-normal">
MERGE(<i class="emphasis">A</i>, <i class="emphasis">p</i>, <i class="emphasis">q</i>, <i class="emphasis">r</i>)
 1  <i class="emphasis">n</i><sub>1</sub> <span class="unicode">&larr;</span> <i class="emphasis">q</i> - <i class="emphasis">p</i> + 1
 2  <i class="emphasis">n</i><sub>2</sub> <span class="unicode">&larr;</span> <i class="emphasis">r</i> - <i class="emphasis">q</i>
 3  create arrays <i class="emphasis">L</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i><sub>1</sub> + 1] and <i class="emphasis">R</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i><sub>2</sub> + 1]
 4  <b class="bold">for</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">n</i><sub>1</sub>
 5       <b class="bold">do</b> <i class="emphasis">L</i>[<i class="emphasis">i</i>] <span class="unicode">&larr;</span> <i class="emphasis">A</i>[<i class="emphasis">p</i> + <i class="emphasis">i</i> - 1]
 6  <b class="bold">for</b> <i class="emphasis">j</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">n</i><sub>2</sub>
 7       <b class="bold">do</b> <i class="emphasis">R</i>[<i class="emphasis">j</i>] <span class="unicode">&larr;</span> <i class="emphasis">A</i>[<i class="emphasis">q</i> + <i class="emphasis">j</i>]
 8  <i class="emphasis">L</i>[<i class="emphasis">n</i><sub>1</sub> + 1] <span class="unicode">&larr;</span> <span class="unicode">&infin;</span>
 9  <i class="emphasis">R</i>[<i class="emphasis">n</i><sub>2</sub> + 1] <span class="unicode">&larr;</span> <span class="unicode">&infin;</span>
10  <i class="emphasis">i</i> <span class="unicode">&larr;</span> 1
11  <i class="emphasis">j</i> <span class="unicode">&larr;</span> 1
12  <b class="bold">for</b> <i class="emphasis">k</i> <span class="unicode">&larr;</span> <i class="emphasis">p</i> <b class="bold">to</b> <i class="emphasis">r</i>
13       <b class="bold">do if</b> <i class="emphasis">L</i>[<i class="emphasis">i</i>] <span class="unicode">&le;</span> <i class="emphasis">R</i>[<i class="emphasis">j</i>]
14             <b class="bold">then</b> <i class="emphasis">A</i>[<i class="emphasis">k</i>] <span class="unicode">&larr;</span> <i class="emphasis">L</i>[<i class="emphasis">i</i>]
15                  <i class="emphasis">i</i> <span class="unicode">&larr;</span> <i class="emphasis">i</i> + 1
16             <b class="bold">else</b> <i class="emphasis">A</i>[<i class="emphasis">k</i>] <span class="unicode">&larr;</span> <i class="emphasis">R</i>[<i class="emphasis">j</i>]
17                  <i class="emphasis">j</i> <span class="unicode">&larr;</span> <i class="emphasis">j</i> + 1
</pre>
</div>
<p class="para">In detail, the MERGE procedure works as follows. Line 1 computes the length <i class="emphasis">n</i><sub>1</sub> of the subarray <i class="emphasis">A</i>[<i class="emphasis">p</i> <span class="unicode">&#8229;</span> <i class="emphasis">q</i>], and line 2 computes the length <i class="emphasis">n</i><sub>2</sub> of the subarray <i class="emphasis">A</i>[<i class="emphasis">q</i> + 1 <span class="unicode">&#8229;</span> <i class="emphasis">r</i>]. We create arrays <i class="emphasis">L</i> and <i class="emphasis">R</i> ("left" and "right"), of lengths <i class="emphasis">n</i><sub>1</sub> + 1 and <i class="emphasis">n</i><sub>2</sub> + 1, respectively, in line 3. The <b class="bold">for</b> loop of lines 4<span class="unicode">-</span>5 copies the subar<a name="92"></a><a name="IDX-30"></a>ray <i class="emphasis">A</i>[<i class="emphasis">p</i> <span class="unicode">&#8229;</span> <i class="emphasis">q</i>] into <i class="emphasis">L</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i><sub>1</sub>], and the <b class="bold">for</b> loop of lines 6<span class="unicode">-</span>7 copies the subarray <i class="emphasis">A</i>[<i class="emphasis">q</i> + 1 <span class="unicode">&#8229;</span> <i class="emphasis">r</i>] into <i class="emphasis">R</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i><sub>2</sub>]. Lines 8<span class="unicode">-</span>9 put the sentinels at the ends of the arrays <i class="emphasis">L</i> and <i class="emphasis">R</i>. Lines 10<span class="unicode">-</span>17, illustrated in <a class="internaljump" href="#ch02fig03">Figure 2.3</a>, perform the <i class="emphasis">r</i> - <i class="emphasis">p</i> + 1 basic steps by maintaining the following loop invariant:</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">At the start of each iteration of the <b class="bold">for</b> loop of lines 12<span class="unicode">-</span>17, the subarray <i class="emphasis">A</i>[<i class="emphasis">p <span class="unicode">&#8229;</span> k</i> - 1] contains the <i class="emphasis">k</i> - <i class="emphasis">p</i> smallest elements of <i class="emphasis">L</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i><sub>1</sub> + 1] and <i class="emphasis">R</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i><sub>2</sub> + 1], in sorted order. Moreover, <i class="emphasis">L</i>[<i class="emphasis">i</i>] and <i class="emphasis">R</i>[<i class="emphasis">j</i>] are the smallest elements of their arrays that have not been copied back into <i class="emphasis">A</i>.</p>
</li>
</ul>
<div class="figure">
<a name="93"></a><a name="ch02fig03"></a><span class="figuremediaobject"><a href="images/fig52%5F01%5F0%2Ejpg" NAME="IMG_24" target="_parent"><img src="images/fig52_01.jpg" height="162" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 2.3: </span>The operation of lines 10<span class="unicode">-</span>17 in the call MERGE(<i class="emphasis">A</i>, 9, 12, 16), when the subarray <i class="emphasis">A</i>[9 <span class="unicode">&#8229;</span> 16] contains the sequence <span class="unicode">&#12296;</span>2, 4, 5, 7, 1, 2, 3, 6<span class="unicode">&#12297;</span>. After copying and inserting sentinels, the array <i class="emphasis">L</i> contains <span class="unicode">&#12296;</span>2, 4, 5, 7, <span class="unicode">&infin;</span><span class="unicode">&#12297;</span>, and the array <i class="emphasis">R</i> contains <span class="unicode">&#12296;</span>1, 2, 3, 6, <span class="unicode">&infin;</span><span class="unicode">&#12297;</span>. Lightly shaded positions in <i class="emphasis">A</i> contain their final values, and lightly shaded positions in <i class="emphasis">L</i> and <i class="emphasis">R</i> contain values that have yet to be copied back into <i class="emphasis">A</i>. Taken together, the lightly shaded positions always comprise the values originally in <i class="emphasis">A</i>[9 <span class="unicode">&#8229;</span> 16], along with the two sentinels. Heavily shaded positions in <i class="emphasis">A</i> contain values that will be copied over, and heavily shaded positions in <i class="emphasis">L</i> and <i class="emphasis">R</i> contain values that have already been copied back into <i class="emphasis">A</i>. <i class="emphasis">(a)<span class="unicode">-</span>(h)</i> The arrays <i class="emphasis">A, L</i>, and <i class="emphasis">R</i>, and their respective indices <i class="emphasis">k, i</i>, and <i class="emphasis">j</i> prior to each iteration of the loop of lines 12<span class="unicode">-</span>17. <i class="emphasis">(i)</i> The arrays and indices at termination. At this point, the subarray in <i class="emphasis">A</i>[9 <span class="unicode">&#8229;</span> 16] is sorted, and the two sentinels in <i class="emphasis">L</i> and <i class="emphasis">R</i> are the only two elements in these arrays that have not been copied into <i class="emphasis">A</i>.</span>
</div>
<p class="para">We must show that this loop invariant holds prior to the first iteration of the <b class="bold">for</b> loop of lines 12<span class="unicode">-</span>17, that each iteration of the loop maintains the invariant, and that the invariant provides a useful property to show correctness when the loop terminates.</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">
<b class="bold">Initialization:</b> Prior to the first iteration of the loop, we have <i class="emphasis">k</i> = <i class="emphasis">p</i>, so that the subarray <i class="emphasis">A</i>[<i class="emphasis">p <span class="unicode">&#8229;</span> k</i> - 1] is empty. This empty subarray contains the <i class="emphasis">k</i> - <i class="emphasis">p</i> = 0 <a name="94"></a><a name="IDX-31"></a>smallest elements of <i class="emphasis">L</i> and <i class="emphasis">R</i>, and since <i class="emphasis">i</i> = <i class="emphasis">j</i> = 1, both <i class="emphasis">L</i>[<i class="emphasis">i</i>] and <i class="emphasis">R</i>[<i class="emphasis">j</i>] are the smallest elements of their arrays that have not been copied back into <i class="emphasis">A</i>.</p>
<div class="informalfigure">
<span class="figuremediaobject"><a href="images/fig53%5F01%5F0%2Ejpg" NAME="IMG_25" target="_parent"><img src="images/fig53_01.jpg" height="254" width="350" alt="Click To expand" border="0"></a></span>
</div>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">Maintenance:</b> To see that each iteration maintains the loop invariant, let us first suppose that <i class="emphasis">L</i>[<i class="emphasis">i</i>] <span class="unicode">&le;</span> <i class="emphasis">R</i>[<i class="emphasis">j</i>]. Then <i class="emphasis">L</i>[<i class="emphasis">i</i>] is the smallest element not yet copied back into <i class="emphasis">A</i>. Because <i class="emphasis">A</i>[<i class="emphasis">p <span class="unicode">&#8229;</span> k</i> - 1] contains the <i class="emphasis">k</i> - <i class="emphasis">p</i> smallest elements, after line 14 copies <i class="emphasis">L</i>[<i class="emphasis">i</i>] into <i class="emphasis">A</i>[<i class="emphasis">k</i>], the subarray <i class="emphasis">A</i>[<i class="emphasis">p <span class="unicode">&#8229;</span> k</i>] will contain the <i class="emphasis">k</i> - <i class="emphasis">p</i> + 1 smallest elements. Incrementing <i class="emphasis">k</i> (in the <b class="bold">for</b> loop update) and <i class="emphasis">i</i> (in line 15) reestablishes the loop invariant for the next iteration. If instead <i class="emphasis">L</i>[<i class="emphasis">i</i>] <span class="unicode">&gt;</span> <i class="emphasis">R</i>[<i class="emphasis">j</i>], then lines 16<span class="unicode">-</span>17 perform the appropriate action to maintain the loop invariant.</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">Termination:</b> At termination, <i class="emphasis">k</i> = <i class="emphasis">r</i> + 1. By the loop invariant, the subarray <i class="emphasis">A</i>[<i class="emphasis">p <span class="unicode">&#8229;</span> k</i> - 1], which is <i class="emphasis">A</i>[<i class="emphasis">p <span class="unicode">&#8229;</span> r</i>], contains the <i class="emphasis">k</i> - <i class="emphasis">p</i> = <i class="emphasis">r</i> - <i class="emphasis">p</i> + 1 smallest elements of <i class="emphasis">L</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i><sub>1</sub> + 1] and <i class="emphasis">R</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i><sub>2</sub> + 1], in sorted order. The arrays <i class="emphasis">L</i> and <i class="emphasis">R</i> together contain <i class="emphasis">n</i><sub>1</sub> + <i class="emphasis">n</i><sub>2</sub> + 2 = <i class="emphasis">r</i> - <i class="emphasis">p</i> + 3 elements. All but the two largest have been copied back into <i class="emphasis">A</i>, and these two largest elements are the sentinels.</p>
</li>
</ul>
<p class="para">To see that the MERGE procedure runs in <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) time, where <i class="emphasis">n</i> = <i class="emphasis">r</i> - <i class="emphasis">p</i> + 1, observe that each of lines 1<span class="unicode">-</span>3 and 8<span class="unicode">-</span>11 takes constant time, the <b class="bold">for</b> loops of <a name="95"></a><a name="IDX-32"></a>lines 4<span class="unicode">-</span>7 take <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sub>1</sub> + <i class="emphasis">n</i><sub>2</sub>) = <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) time,<sup>[<a name="N1334" href="#ftn.N1334">6</a>]</sup> and there are <i class="emphasis">n</i> iterations of the <b class="bold">for</b> loop of lines 12<span class="unicode">-</span>17, each of which takes constant time.</p>
<p class="para">We can now use the MERGE procedure as a subroutine in the merge sort algorithm. The procedure MERGE-SORT(<i class="emphasis">A</i>, <i class="emphasis">p</i>, <i class="emphasis">r</i>) sorts the elements in the subarray <i class="emphasis">A</i>[<i class="emphasis">p <span class="unicode">&#2025;</span> r</i>]. If <i class="emphasis">p</i> <span class="unicode">&ge;</span> <i class="emphasis">r</i>, the subarray has at most one element and is therefore already sorted. Otherwise, the divide step simply computes an index <i class="emphasis">q</i> that partitions <i class="emphasis">A</i>[<i class="emphasis">p</i> <span class="unicode">&#8229;</span> <i class="emphasis">r</i>] into two subarrays: <i class="emphasis">A</i>[<i class="emphasis">p</i> <span class="unicode">&#8229;</span> <i class="emphasis">q</i>], containing <span class="unicode">&lceil;</span><i class="emphasis">n</i>/2<span class="unicode">&rceil;</span> elements, and <i class="emphasis">A</i>[<i class="emphasis">q</i> + 1 <span class="unicode">&#8229;</span> <i class="emphasis">r</i>], containing <span class="unicode">&lfloor;</span><i class="emphasis">n</i>/2<span class="unicode">&rfloor;</span> elements.<sup>[<a name="N1454" href="#ftn.N1454">7</a>]</sup>
</p>
<div class="informalexample">
<pre class="literallayout-normal">
MERGE-SORT(<i class="emphasis">A</i>, <i class="emphasis">p</i>, <i class="emphasis">r</i>)
1 <b class="bold">if</b> <i class="emphasis">p</i> <span class="unicode">&lt;</span> <i class="emphasis">r</i>
2   <b class="bold">then</b> <i class="emphasis">q</i> <span class="unicode">&larr;</span> <span class="unicode">&lfloor;</span>(<i class="emphasis">p</i> + <i class="emphasis">r</i>)/2<span class="unicode">&rfloor;</span>
3        MERGE-SORT(<i class="emphasis">A</i>, <i class="emphasis">p</i>, <i class="emphasis">q</i>)
4        MERGE-SORT(<i class="emphasis">A</i>, <i class="emphasis">q</i> + 1, <i class="emphasis">r</i>)
5        MERGE(<i class="emphasis">A</i>, <i class="emphasis">p</i>, <i class="emphasis">q</i>, <i class="emphasis">r</i>)
</pre>
</div>
<p class="para">To sort the entire sequence <i class="emphasis">A</i> = <span class="unicode">&#12296;</span><i class="emphasis">A</i>[1], <i class="emphasis">A</i>[2], . . . , <i class="emphasis">A</i>[<i class="emphasis">n</i>]<span class="unicode">&#12297;</span>, we make the initial call MERGE-SORT(<i class="emphasis">A</i>, 1, <i class="emphasis">length</i>[<i class="emphasis">A</i>]), where once again <i class="emphasis">length</i>[<i class="emphasis">A</i>] = <i class="emphasis">n</i>. <a class="internaljump" href="#ch02fig04">Figure 2.4</a> illustrates the operation of the procedure bottom-up when <i class="emphasis">n</i> is a power of 2. The algorithm consists of merging pairs of 1-item sequences to form sorted sequences of length 2, merging pairs of sequences of length 2 to form sorted sequences of length 4, and so on, until two sequences of length <i class="emphasis">n</i>/2 are merged to form the final sorted sequence of length <i class="emphasis">n</i>.</p>
<div class="figure">
<a name="96"></a><a name="ch02fig04"></a><span class="figuremediaobject"><a href="images/fig55%5F01%5F0%2Ejpg" NAME="IMG_26" target="_parent"><img src="images/fig55_01.jpg" height="241" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 2.4: </span>The operation of merge sort on the array <i class="emphasis">A</i> = <span class="unicode">&#12296;</span>5, 2, 4, 7, 1, 3, 2, 6<span class="unicode">&#12297;</span>. The lengths of the sorted sequences being merged increase as the algorithm progresses from bottom to top.</span>
</div>

</div>
<div class="section">
<h3 class="sect3-title">
<a name="97"></a><a name="ch02lev2sec2"></a><span class="section-titlelabel">2.3.2 </span>Analyzing divide-and-conquer algorithms</h3>
<p class="first-para">When an algorithm contains a recursive call to itself, its running time can often be described by a <b class="bold"><i class="emphasis">recurrence equation</i></b> or <b class="bold"><i class="emphasis">recurrence</i></b>, which describes the overall running time on a problem of size <i class="emphasis">n</i> in terms of the running time on smaller inputs. We can then use mathematical tools to solve the recurrence and provide bounds on the performance of the algorithm.</p>
<p class="para">A recurrence for the running time of a divide-and-conquer algorithm is based on the three steps of the basic paradigm. As before, we let <i class="emphasis">T</i> (<i class="emphasis">n</i>) be the running time on a problem of size <i class="emphasis">n</i>. If the problem size is small enough, say <i class="emphasis">n</i> <span class="unicode">&le;</span> <i class="emphasis">c</i> <a name="98"></a><a name="IDX-33"></a>for some constant <i class="emphasis">c</i>, the straightforward solution takes constant time, which we write as <span class="unicode">&Theta;</span>(1). Suppose that our division of the problem yields <i class="emphasis">a</i> subproblems, each of which is 1/<i class="emphasis">b</i> the size of the original. (For merge sort, both <i class="emphasis">a</i> and <i class="emphasis">b</i> are 2, but we shall see many divide-and-conquer algorithms in which <i class="emphasis">a</i> <span class="unicode">&ne;</span> <i class="emphasis">b</i>.) If we take <i class="emphasis">D</i>(<i class="emphasis">n</i>) time to divide the problem into subproblems and <i class="emphasis">C</i>(<i class="emphasis">n</i>) time to combine the solutions to the subproblems into the solution to the original problem, we get the recurrence</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig55_02.jpg" height="38" width="284" alt="" border="0"></span>
</div>
<p class="para">In <a href="DDU0022.html#203" target="_parent" class="chapterjump">Chapter 4</a>, we shall see how to solve common recurrences of this form.</p>
<div class="section">
<h4 class="sect4-title">Analysis of merge sort</h4>
<p class="first-para">Although the pseudocode for MERGE-SORT works correctly when the number of elements is not even, our recurrence-based analysis is simplified if we assume that the original problem size is a power of 2. Each divide step then yields two subsequences of size exactly <i class="emphasis">n</i>/2. In <a href="DDU0022.html#203" target="_parent" class="chapterjump">Chapter 4</a>, we shall see that this assumption does not affect the order of growth of the solution to the recurrence.<a name="99"></a><a name="IDX-34"></a>
</p>
<p class="para">We reason as follows to set up the recurrence for <i class="emphasis">T</i> (<i class="emphasis">n</i>), the worst-case running time of merge sort on <i class="emphasis">n</i> numbers. Merge sort on just one element takes constant time. When we have <i class="emphasis">n</i> <span class="unicode">&gt;</span> 1 elements, we break down the running time as follows.</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="para">
<b>Divide:</b> The divide step just computes the middle of the subarray, which takes constant time. Thus, <i class="emphasis">D</i>(<i class="emphasis">n</i>) = <span class="unicode">&Theta;</span>(1).</p>
</li>
<li class="listitem">
<p class="para">
<b>Conquer:</b> We recursively solve two subproblems, each of size <i class="emphasis">n</i>/2, which contributes 2<i class="emphasis">T</i> (<i class="emphasis">n</i>/2) to the running time.</p>
</li>
<li class="listitem">
<p class="para">
<b>Combine:</b> We have already noted that the MERGE procedure on an <i class="emphasis">n</i>-element subarray takes time <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>), so <i class="emphasis">C</i>(<i class="emphasis">n</i>) = <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>).</p>
</li>
</ul>
<p class="para">When we add the functions <i class="emphasis">D</i>(<i class="emphasis">n</i>) and <i class="emphasis">C</i>(<i class="emphasis">n</i>) for the merge sort analysis, we are adding a function that is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) and a function that is <span class="unicode">&Theta;</span>(1). This sum is a linear function of <i class="emphasis">n</i>, that is, <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>). Adding it to the 2<i class="emphasis">T</i> (<i class="emphasis">n</i>/2) term from the "conquer" step gives the recurrence for the worst-case running time <i class="emphasis">T</i> (<i class="emphasis">n</i>) of merge sort:</p>
<div class="equation">
<a name="100"></a><a name="ch02eq01"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(2.1)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig56_01.jpg" height="37" width="225" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">In <a href="DDU0022.html#203" target="_parent" class="chapterjump">Chapter 4</a>, we shall see the "master theorem," which we can use to show that <i class="emphasis">T</i> (<i class="emphasis">n</i>) is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>), where lg <i class="emphasis">n</i> stands for log<sub>2</sub> <i class="emphasis">n</i>. Because the logarithm function grows more slowly than any linear function, for large enough inputs, merge sort, with its <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) running time, outperforms insertion sort, whose running time is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>2</sup>), in the worst case.</p>
<p class="para">We do not need the master theorem to intuitively understand why the solution to the recurrence (<a class="internaljump" href="#ch02eq01">2.1</a>) is <i class="emphasis">T</i> (<i class="emphasis">n</i>) = <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>). Let us rewrite recurrence (<a class="internaljump" href="#ch02eq01">2.1</a>) as</p>
<div class="equation">
<a name="101"></a><a name="ch02eq02"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(2.2)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig56_02.jpg" height="37" width="209" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">where the constant <i class="emphasis">c</i> represents the time required to solve problems of size 1 as well as the time per array element of the divide and combine steps.<sup>[<a name="N2112" href="#ftn.N2112">8</a>]</sup>
</p>
<p class="para">
<a class="internaljump" href="#ch02fig05">Figure 2.5</a> shows how we can solve the recurrence (<a class="internaljump" href="#ch02eq02">2.2</a>). For convenience, we assume that <i class="emphasis">n</i> is an exact power of 2. Part (a) of the figure shows <i class="emphasis">T</i> (<i class="emphasis">n</i>), which in part (b) has been expanded into an equivalent tree representing the recurrence. The <i class="emphasis">cn</i> term is the root (the cost at the top level of recursion), and the two subtrees <a name="102"></a><a name="IDX-35"></a><a name="103"></a><a name="IDX-36"></a>of the root are the two smaller recurrences <i class="emphasis">T</i> (<i class="emphasis">n</i>/2). Part (c) shows this process carried one step further by expanding <i class="emphasis">T</i> (<i class="emphasis">n</i>/2). The cost for each of the two subnodes at the second level of recursion is <i class="emphasis">cn</i>/2. We continue expanding each node in the tree by breaking it into its constituent parts as determined by the recurrence, until the problem sizes get down to 1, each with a cost of <i class="emphasis">c</i>. Part (d) shows the resulting tree.</p>
<div class="figure">
<a name="104"></a><a name="ch02fig05"></a><span class="figuremediaobject"><a href="images/fig57%5F01%5F0%2Ejpg" NAME="IMG_30" target="_parent"><img src="images/fig57_01.jpg" height="493" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 2.5: </span>The construction of a recursion tree for the recurrence <i class="emphasis">T</i>(<i class="emphasis">n</i>) = 2<i class="emphasis">T</i>(<i class="emphasis">n</i>/2) + <i class="emphasis">cn</i>. Part <i class="emphasis">(a)</i> shows <i class="emphasis">T</i>(<i class="emphasis">n</i>), which is progressively expanded in <i class="emphasis">(b)<span class="unicode">-</span>(d)</i> to form the recursion tree. The fully expanded tree in part (d) has lg <i class="emphasis">n</i> + 1 levels (i.e., it has height lg <i class="emphasis">n</i>, as indicated), and each level contributes a total cost of <i class="emphasis">cn</i>. The total cost, therefore, is <i class="emphasis">cn</i> lg <i class="emphasis">n</i> + <i class="emphasis">cn</i>, which is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>).</span>
</div>
<p class="para">Next, we add the costs across each level of the tree. The top level has total cost <i class="emphasis">cn</i>, the next level down has total cost <i class="emphasis">c</i>(<i class="emphasis">n</i>/2) + <i class="emphasis">c</i>(<i class="emphasis">n</i>/2) = <i class="emphasis">cn</i>, the level after that has total cost <i class="emphasis">c</i>(<i class="emphasis">n</i>/4) + <i class="emphasis">c</i>(<i class="emphasis">n</i>/4) + <i class="emphasis">c</i>(<i class="emphasis">n</i>/4) + <i class="emphasis">c</i>(<i class="emphasis">n</i>/4) = <i class="emphasis">cn</i>, and so on. In general, the level <i class="emphasis">i</i> below the top has 2<sup><i class="emphasis">i</i></sup> nodes, each contributing a cost of <i class="emphasis">c</i>(<i class="emphasis">n</i>/2<sup><i class="emphasis">i</i></sup>), so that the <i class="emphasis">i</i>th level below the top has total cost 2<sup><i class="emphasis">i</i></sup> <i class="emphasis">c</i>(<i class="emphasis">n</i>/2<sup><i class="emphasis">i</i></sup>) = <i class="emphasis">cn</i>. At the bottom level, there are <i class="emphasis">n</i> nodes, each contributing a cost of <i class="emphasis">c</i>, for a total cost of <i class="emphasis">cn</i>.</p>
<p class="para">The total number of levels of the "recursion tree" in <a class="internaljump" href="#ch02fig05">Figure 2.5</a> is lg <i class="emphasis">n</i> + 1. This fact is easily seen by an informal inductive argument. The base case occurs when <i class="emphasis">n</i> = 1, in which case there is only one level. Since lg 1 = 0, we have that lg <i class="emphasis">n</i> + 1 gives the correct number of levels. Now assume as an inductive hypothesis that the number of levels of a recursion tree for 2<sup><i class="emphasis">i</i></sup> nodes is lg 2<sup><i class="emphasis">i</i></sup> + 1 = <i class="emphasis">i</i> + 1 (since for any value of <i class="emphasis">i</i>, we have that lg 2<sup><i class="emphasis">i</i></sup> = <i class="emphasis">i</i>). Because we are assuming that the original input size is a power of 2, the next input size to consider is 2<sup><i class="emphasis">i</i>+1</sup>. A tree with 2<sup><i class="emphasis">i</i>+1</sup> nodes has one more level than a tree of 2<sup><i class="emphasis">i</i></sup> nodes, and so the total number of levels is (<i class="emphasis">i</i> + 1) + 1 = lg 2<sup><i class="emphasis">i</i>+1</sup> + 1.</p>
<p class="para">To compute the total cost represented by the recurrence (<a class="internaljump" href="#ch02eq02">2.2</a>), we simply add up the costs of all the levels. There are lg <i class="emphasis">n</i> + 1 levels, each costing <i class="emphasis">cn</i>, for a total cost of <i class="emphasis">cn</i>(lg <i class="emphasis">n</i> + 1) = <i class="emphasis">cn</i> lg <i class="emphasis">n</i> + <i class="emphasis">cn</i>. Ignoring the low-order term and the constant <i class="emphasis">c</i> gives the desired result of <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>).</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 2.3-1</span></span><a name="105"></a><a name="ch02ex09"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Using <a class="internaljump" href="#ch02fig04">Figure 2.4</a> as a model, illustrate the operation of merge sort on the array <i class="emphasis">A</i> = <span class="unicode">&#12296;</span>3, 41, 52, 26, 38, 57, 9, 49<span class="unicode">&#12297;</span>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 2.3-2</span></span><a name="106"></a><a name="ch02ex10"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Rewrite the MERGE procedure so that it does not use sentinels, instead stopping once either array <i class="emphasis">L</i> or <i class="emphasis">R</i> has had all its elements copied back to <i class="emphasis">A</i> and then copying the remainder of the other array back into <i class="emphasis">A</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 2.3-3</span></span><a name="107"></a><a name="ch02ex11"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Use mathematical induction to show that when <i class="emphasis">n</i> is an exact power of 2, the solution of the recurrence<a name="108"></a><a name="IDX-37"></a>
</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig59_01.jpg" height="59" width="263" alt="" border="0"></span>
</div>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 2.3-4</span></span><a name="109"></a><a name="ch02ex12"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Insertion sort can be expressed as a recursive procedure as follows. In order to sort <i class="emphasis">A</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>], we recursively sort <i class="emphasis">A</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i> -1] and then insert <i class="emphasis">A</i>[<i class="emphasis">n</i>] into the sorted array <i class="emphasis">A</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i> - 1]. Write a recurrence for the running time of this recursive version of insertion sort.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 2.3-5</span></span><a name="110"></a><a name="ch02ex13"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Referring back to the searching problem (see <a href="DDU0014.html#72" target="_parent" class="chapterjump">Exercise 2.1-3</a>), observe that if the sequence <i class="emphasis">A</i> is sorted, we can check the midpoint of the sequence against <i class="emphasis">v</i> and eliminate half of the sequence from further consideration. <b class="bold"><i class="emphasis">Binary search</i></b> is an algorithm that repeats this procedure, halving the size of the remaining portion of the sequence each time. Write pseudocode, either iterative or recursive, for binary search. Argue that the worst-case running time of binary search is <span class="unicode">&Theta;</span>(lg <i class="emphasis">n</i>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 2.3-6</span></span><a name="111"></a><a name="ch02ex14"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Observe that the <b class="bold">while</b> loop of lines 5 <span class="unicode">-</span> 7 of the INSERTION-SORT procedure in <a href="DDU0014.html#59" target="_parent" class="chapterjump">Section 2.1</a> uses a linear search to scan (backward) through the sorted subarray <i class="emphasis">A</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">j</i> - 1]. Can we use a binary search (see <a class="internaljump" href="#ch02ex13">Exercise 2.3-5</a>) instead to improve the overall worst-case running time of insertion sort to <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>)?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 2.3-7: </span><span class="unicode">&#9733;</span></span><a name="112"></a><a name="ch02ex15"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Describe a <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>)-time algorithm that, given a set <i class="emphasis">S</i> of <i class="emphasis">n</i> integers and another integer <i class="emphasis">x</i>, determines whether or not there exist two elements in <i class="emphasis">S</i> whose sum is exactly <i class="emphasis">x</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 2-1: </span>Insertion sort on small arrays in merge sort</span><a name="113"></a><a name="ch02ex16"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Although merge sort runs in <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) worst-case time and insertion sort runs in <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>2</sup>) worst-case time, the constant factors in insertion sort make it faster for small <i class="emphasis">n</i>. Thus, it makes sense to use insertion sort within merge sort when subproblems become sufficiently small. Consider a modification to merge sort in which <i class="emphasis">n</i>/<i class="emphasis">k</i> sublists of length <i class="emphasis">k</i> are sorted using insertion sort and then merged using the standard merging mechanism, where <i class="emphasis">k</i> is a value to be determined.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Show that the <i class="emphasis">n</i>/<i class="emphasis">k</i> sublists, each of length <i class="emphasis">k</i>, can be sorted by insertion sort in <span class="unicode">&Theta;</span>(<i class="emphasis">nk</i>) worst-case time.</p>
<a name="114"></a><a name="IDX-38"></a>
</li>
<li class="listitem">
<p class="first-para">Show that the sublists can be merged in <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg (<i class="emphasis">n</i>/<i class="emphasis">k</i>) worst-case time.</p>
</li>
<li class="listitem">
<p class="first-para">Given that the modified algorithm runs in <span class="unicode">&Theta;</span>(<i class="emphasis">nk</i> + <i class="emphasis">n</i> lg (<i class="emphasis">n</i>/<i class="emphasis">k</i>)) worst-case time, what is the largest asymptotic (<span class="unicode">&Theta;</span>notation) value of <i class="emphasis">k</i> as a function of <i class="emphasis">n</i> for which the modified algorithm has the same asymptotic running time as standard merge sort?</p>
</li>
<li class="listitem">
<p class="first-para">How should <i class="emphasis">k</i> be chosen in practice?</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 2-2: </span>Correctness of bubblesort</span><a name="115"></a><a name="ch02ex17"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Bubblesort is a popular sorting algorithm. It works by repeatedly swapping adjacent elements that are out of order.</p>
<pre class="literallayout-normal">
BUBBLESORT(<i class="emphasis">A</i>)
1 <b class="bold">for</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">length</i>[<i class="emphasis">A</i>]
2     <b class="bold">do for</b> <i class="emphasis">j</i> <span class="unicode">&larr;</span> <i class="emphasis">length</i>[<i class="emphasis">A</i>] <b class="bold">downto</b> <i class="emphasis">i</i> + 1
3            <b class="bold">do if</b> <i class="emphasis">A</i>[<i class="emphasis">j</i>] <span class="unicode">&lt;</span> <i class="emphasis">A</i>[<i class="emphasis">j</i> - 1]
4                  <b class="bold">then</b> exchange <i class="emphasis">A</i>[<i class="emphasis">j</i>] <span class="unicode">&harr;</span> <i class="emphasis">A</i>[<i class="emphasis">j</i> - 1]
</pre>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Let <i class="emphasis">A</i><span class="unicode">&prime;</span> denote the output of BUBBLESORT(<i class="emphasis">A</i>). To prove that BUBBLESORT is correct, we need to prove that it terminates and that</p>
<div class="equation">
<a name="116"></a><a name="ch02eq03"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(2.3)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig60_01.jpg" height="15" width="175" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="last-para">where <i class="emphasis">n</i> = <i class="emphasis">length</i>[<i class="emphasis">A</i>]. What else must be proved to show that BUBBLESORT actually sorts?</p>
</li>
</ol>
<p class="para">The next two parts will prove inequality (<a class="internaljump" href="#ch02eq03">2.3</a>).</p>
<ol class="orderedlist" start="2" type="a">
<li class="first-listitem">
<p class="first-para">State precisely a loop invariant for the <b class="bold">for</b> loop in lines 2<span class="unicode">-</span>4, and prove that this loop invariant holds. Your proof should use the structure of the loop invariant proof presented in this chapter.</p>
</li>
<li class="listitem">
<p class="first-para">Using the termination condition of the loop invariant proved in part (b), state a loop invariant for the <b class="bold">for</b> loop in lines 1<span class="unicode">-</span>4 that will allow you to prove inequality (<a class="internaljump" href="#ch02eq03">2.3</a>). Your proof should use the structure of the loop invariant proof presented in this chapter.</p>
</li>
<li class="listitem">
<p class="first-para">What is the worst-case running time of bubblesort? How does it compare to the running time of insertion sort?</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="117"></a><a name="IDX-39"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 2-3: </span>Correctness of Horner's rule</span><a name="118"></a><a name="ch02ex18"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The following code fragment implements Horner's rule for evaluating a polynomial</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig61_01.jpg" height="61" width="345" alt="" border="0"></span>
</div>
<p class="para">given the coefficients <i class="emphasis">a</i><sub>0</sub>, <i class="emphasis">a</i><sub>1</sub>, . . . , <i class="emphasis">a<sub>n</sub></i> and a value for <i class="emphasis">x</i>:</p>
<pre class="literallayout-normal">
1  <i class="emphasis">y</i> <span class="unicode">&larr;</span> 0
2  <i class="emphasis">i</i> <span class="unicode">&larr;</span> <i class="emphasis">n</i>
3  <b class="bold">while</b> <i class="emphasis">i</i> <span class="unicode">&ge;</span> 0
4      <b class="bold">do</b> <i class="emphasis">y</i> <span class="unicode">&larr;</span> <i class="emphasis">a<sub>i</sub></i> + <i class="emphasis">x</i> <span class="unicode">&middot;</span> <i class="emphasis">y</i>
5         <i class="emphasis">i</i> <span class="unicode">&larr;</span> <i class="emphasis">i</i> - 1
</pre>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">What is the asymptotic running time of this code fragment for Horner's rule?</p>
</li>
<li class="listitem">
<p class="first-para">Write pseudocode to implement the naive polynomial-evaluation algorithm that computes each term of the polynomial from scratch. What is the running time of this algorithm? How does it compare to Horner's rule?</p>
</li>
<li class="listitem">
<p class="first-para">Prove that the following is a loop invariant for the <b class="bold">while</b> loop in lines 3 <span class="unicode">-</span>5.</p>
<p class="para">At the start of each iteration of the <b class="bold">while</b> loop of lines 3<span class="unicode">-</span>5,</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig61_02.jpg" height="43" width="127" alt="" border="0"></span>
</div>
<p class="last-para">Interpret a summation with no terms as equaling 0. Your proof should follow the structure of the loop invariant proof presented in this chapter and should show that, at termination, <span class="inlinemediaobject"><img src="images/fig61_03.jpg" height="14" width="68" alt="" border="0"></span>.</p>
</li>
<li class="listitem">
<p class="first-para">Conclude by arguing that the given code fragment correctly evaluates a polynomial characterized by the coefficients <i class="emphasis">a</i><sub>0</sub>, <i class="emphasis">a</i><sub>1</sub>, . . . , <i class="emphasis">a<sub>n</sub></i>.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 2-4: </span>Inversions</span><a name="119"></a><a name="ch02ex19"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">A</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>] be an array of <i class="emphasis">n</i> distinct numbers. If <i class="emphasis">i</i> <span class="unicode">&lt;</span> <i class="emphasis">j</i> and <i class="emphasis">A</i>[<i class="emphasis">i</i>] <span class="unicode">&gt;</span> <i class="emphasis">A</i>[<i class="emphasis">j</i>], then the pair (<i class="emphasis">i</i>, <i class="emphasis">j</i>) is called an <b class="bold"><i class="emphasis">inversion</i></b> of <i class="emphasis">A</i>.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">List the five inversions of the array <span class="unicode">&#12296;</span>2, 3, 8, 6, 1<span class="unicode">&#12297;</span>.</p>
</li>
<li class="listitem">
<p class="first-para">What array with elements from the set {1, 2, . . . , <i class="emphasis">n</i>} has the most inversions? How many does it have?</p>
<a name="120"></a><a name="IDX-40"></a>
</li>
<li class="listitem">
<p class="first-para">What is the relationship between the running time of insertion sort and the number of inversions in the input array? Justify your answer.</p>
</li>
<li class="listitem">
<p class="first-para">Give an algorithm that determines the number of inversions in any permutation on <i class="emphasis">n</i> elements in <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) worst-case time. (<i class="emphasis">Hint:</i> Modify merge sort.)</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>

</div>
<div class="footnotes">
<div class="footnote">
<p>
<sup>[<a name="ftn.N1334" href="#N1334">6</a>]</sup>We shall see in <a href="DDU0018.html#122" target="_parent" class="chapterjump">Chapter 3</a> how to formally interpret equations containing <span class="unicode">&Theta;</span>-notation.</p>
</div>
<div class="footnote">
<p>
<sup>[<a name="ftn.N1454" href="#N1454">7</a>]</sup>The expression <span class="unicode">&lceil;</span><i class="emphasis">x</i><span class="unicode">&rceil;</span> denotes the least integer greater than or equal to <i class="emphasis">x</i>, and <span class="unicode">&lfloor;</span><i class="emphasis">x</i><span class="unicode">&rfloor;</span> denotes the greatest integer less than or equal to <i class="emphasis">x</i>. These notations are defined in <a href="DDU0018.html#122" target="_parent" class="chapterjump">Chapter 3</a>. The easiest way to verify that setting <i class="emphasis">q</i> to <span class="unicode">&lfloor;</span>( <i class="emphasis">p</i> + <i class="emphasis">r</i>)/2<span class="unicode">&rfloor;</span> yields subarrays <i class="emphasis">A</i>[<i class="emphasis">p <span class="unicode">&#8229;</span> q</i>] and <i class="emphasis">A</i>[<i class="emphasis">q</i> + 1 <span class="unicode">&#8229;</span> <i class="emphasis">r</i>] of sizes <span class="unicode">&lceil;</span><i class="emphasis">n</i>/2<span class="unicode">&rceil;</span> and <span class="unicode">&lfloor;</span><i class="emphasis">n</i>/2<span class="unicode">&rfloor;</span>, respectively, is to examine the four cases that arise depending on whether each of <i class="emphasis">p</i> and <i class="emphasis">r</i> is odd or even.</p>
</div>
<div class="footnote">
<p>
<sup>[<a name="ftn.N2112" href="#N2112">8</a>]</sup>It is unlikely that the same constant exactly represents both the time to solve problems of size 1 and the time per array element of the divide and combine steps. We can get around this problem by letting <i class="emphasis">c</i> be the larger of these times and understanding that our recurrence gives an upper bound on the running time, or by letting <i class="emphasis">c</i> be the lesser of these times and understanding that our recurrence gives a lower bound on the running time. Both bounds will be on the order of <i class="emphasis">n</i> lg <i class="emphasis">n</i> and, taken together, give a <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) running time.</p>
</div>
</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0015.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0017.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
