<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>7.2 Performance of quicksort</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0042.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0044.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch07"></a>
<div class="section">
<h2 class="first-section-title">
<a name="460"></a><a name="ch07lev1sec2"></a><span class="section-titlelabel">7.2 </span>Performance of quicksort</h2>
<p class="first-para">The running time of quicksort depends on whether the partitioning is balanced or unbalanced, and this in turn depends on which elements are used for partitioning. If the partitioning is balanced, the algorithm runs asymptotically as fast as merge sort. If the partitioning is unbalanced, however, it can run asymptotically as slowly as insertion sort. In this section, we shall informally investigate how quicksort performs under the assumptions of balanced versus unbalanced partitioning.</p>
<div class="section">
<h4 class="sect4-title">
<a name="461"></a><a name="ch07lev3sec2"></a>Worst-case partitioning</h4>
<p class="first-para">The worst-case behavior for quicksort occurs when the partitioning routine produces one subproblem with <i class="emphasis">n</i> - 1 elements and one with 0 elements. (This claim is proved in <a href="DDU0045.html#483" target="_parent" class="chapterjump">Section 7.4.1</a>.) Let us assume that this unbalanced partitioning arises in each recursive call. The partitioning costs <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) time. Since the recursive call <a name="462"></a><a name="IDX-150"></a>on an array of size 0 just returns, <i class="emphasis">T</i>(0) = <span class="unicode">&Theta;</span>(1), and the recurrence for the running time is</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">T</i>(<i class="emphasis">n</i>)</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">T</i>(<i class="emphasis">n</i> - 1) + <i class="emphasis">T</i>(0) + <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">T</i>(<i class="emphasis">n</i> - 1) + <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>).</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">Intuitively, if we sum the costs incurred at each level of the recursion, we get an arithmetic series (equation (<a href="DDU0244.html#3283" target="_parent" class="chapterjump">A.2</a>)), which evaluates to <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>2</sup>). Indeed, it is straightforward to use the substitution method to prove that the recurrence <i class="emphasis">T</i>(<i class="emphasis">n</i>) = <i class="emphasis">T</i>(<i class="emphasis">n</i> - 1) + <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) has the solution <i class="emphasis">T</i>(<i class="emphasis">n</i>) = <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>2</sup>). (See <a class="internaljump" href="#ch07ex05">Exercise 7.2-1</a>.)</p>
<p class="last-para">Thus, if the partitioning is maximally unbalanced at every recursive level of the algorithm, the running time is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>2</sup>). Therefore the worst-case running time of quicksort is no better than that of insertion sort. Moreover, the <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>2</sup>) running time occurs when the input array is already completely sorted<span class="unicode">-</span>a common situation in which insertion sort runs in <i class="emphasis">O</i>(<i class="emphasis">n</i>) time.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="463"></a><a name="ch07lev3sec3"></a>Best-case partitioning</h4>
<p class="first-para">In the most even possible split, PARTITION produces two subproblems, each of size no more than <i class="emphasis">n</i>/2, since one is of size <span class="unicode">&lfloor;</span><i class="emphasis">n</i>/2<span class="unicode">&rfloor;</span> and one of size <span class="unicode">&lceil;</span><i class="emphasis">n</i>/2<span class="unicode">&rceil;</span>- 1. In this case, quicksort runs much faster. The recurrence for the running time is then</p>
<p class="para">
<i class="emphasis">T</i> (<i class="emphasis">n</i>) <span class="unicode">&le;</span> 2<i class="emphasis">T</i> (<i class="emphasis">n</i>/2) + <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) ,</p>
<p class="last-para">which by case 2 of the master theorem (<a href="DDU0026.html#244" target="_parent" class="chapterjump">Theorem 4.1</a>) has the solution <i class="emphasis">T</i> (<i class="emphasis">n</i>) = <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>). Thus, the equal balancing of the two sides of the partition at every level of the recursion produces an asymptotically faster algorithm.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="464"></a><a name="ch07lev3sec4"></a>Balanced partitioning</h4>
<p class="first-para">The average-case running time of quicksort is much closer to the best case than to the worst case, as the analyses in <a href="DDU0045.html#481" target="_parent" class="chapterjump">Section 7.4</a> will show. The key to understanding why is to understand how the balance of the partitioning is reflected in the recurrence that describes the running time.</p>
<p class="para">Suppose, for example, that the partitioning algorithm always produces a 9-to-1 proportional split, which at first blush seems quite unbalanced. We then obtain the recurrence</p>
<p class="para">
<i class="emphasis">T</i>(<i class="emphasis">n</i>) <span class="unicode">&le;</span> <i class="emphasis">T</i> (9<i class="emphasis">n</i>/10) + <i class="emphasis">T</i> (<i class="emphasis">n</i>/10) + <i class="emphasis">cn</i>
</p>
<p class="para">on the running time of quicksort, where we have explicitly included the constant <i class="emphasis">c</i> hidden in the <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) term. <a class="internaljump" href="#ch07fig04">Figure 7.4</a> shows the recursion tree for this recurrence. Notice that every level of the tree has cost <i class="emphasis">cn</i>, until a boundary condition is reached at depth log<sub>10</sub><i class="emphasis">n</i> = <span class="unicode">&Theta;</span>(lg<i class="emphasis">n</i>), and then the levels have cost at most <i class="emphasis">cn</i>. The recursion terminates at depth log<sub>10/9</sub><i class="emphasis">n</i> = <span class="unicode">&Theta;</span>(lg <i class="emphasis">n</i>). The total cost of quicksort is <a name="465"></a><a name="IDX-151"></a>therefore <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>). Thus, with a 9-to-1 proportional split at every level of recursion, which intuitively seems quite unbalanced, quicksort runs in <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) time<span class="unicode">-</span>asymptotically the same as if the split were right down the middle. In fact, even a 99-to-1 split yields an <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) running time. The reason is that any split of <i class="emphasis">constant</i> proportionality yields a recursion tree of depth <span class="unicode">&Theta;</span>(lg <i class="emphasis">n</i>), where the cost at each level is <i class="emphasis">O</i>(<i class="emphasis">n</i>). The running time is therefore <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) whenever the split has constant proportionality.</p>
<div class="figure">
<a name="466"></a><a name="ch07fig04"></a><span class="figuremediaobject"><a href="images/fig173%5F01%5F0%2Ejpg" NAME="IMG_277" target="_parent"><img src="images/fig173_01.jpg" height="231" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 7.4: </span>A recursion tree for QUICKSORT in which PARTITION always produces a 9-to-1 split, yielding a running time of <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>). Nodes show subproblem sizes, with per-level costs on the right. The per-level costs include the constant <i class="emphasis">c</i> implicit in the <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) term.</span>
</div>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="467"></a><a name="ch07lev3sec5"></a>Intuition for the average case</h4>
<p class="first-para">To develop a clear notion of the average case for quicksort, we must make an assumption about how frequently we expect to encounter the various inputs. The behavior of quicksort is determined by the relative ordering of the values in the array elements given as the input, and not by the particular values in the array. As in our probabilistic analysis of the hiring problem in <a href="DDU0030.html#308" target="_parent" class="chapterjump">Section 5.2</a>, we will assume for now that all permutations of the input numbers are equally likely.</p>
<p class="para">When we run quicksort on a random input array, it is unlikely that the partitioning always happens in the same way at every level, as our informal analysis has assumed. We expect that some of the splits will be reasonably well balanced and that some will be fairly unbalanced. For example, <a class="internaljump" href="#ch07ex10">Exercise 7.2-6</a> asks you to show <a name="468"></a><a name="IDX-152"></a>that about 80 percent of the time PARTITION produces a split that is more balanced than 9 to 1, and about 20 percent of the time it produces a split that is less balanced than 9 to 1.</p>
<p class="para">In the average case, PARTITION produces a mix of "good" and "bad" splits. In a recursion tree for an average-case execution of PARTITION, the good and bad splits are distributed randomly throughout the tree. Suppose for the sake of intuition, however, that the good and bad splits alternate levels in the tree, and that the good splits are best-case splits and the bad splits are worst-case splits. <a class="internaljump" href="#ch07fig05">Figure 7.5(a)</a> shows the splits at two consecutive levels in the recursion tree. At the root of the tree, the cost is <i class="emphasis">n</i> for partitioning, and the subarrays produced have sizes <i class="emphasis">n</i> - 1 and 0: the worst case. At the next level, the subarray of size <i class="emphasis">n</i> - 1 is best-case partitioned into subarrays of size (<i class="emphasis">n</i> - 1)/2 - 1 and (<i class="emphasis">n</i> - 1)/2. Let's assume that the boundary-condition cost is 1 for the subarray of size 0.</p>
<div class="figure">
<a name="469"></a><a name="ch07fig05"></a><span class="figuremediaobject"><a href="images/fig174%5F01%5F0%2Ejpg" NAME="IMG_278" target="_parent"><img src="images/fig174_01.jpg" height="82" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 7.5: </span><i class="emphasis">(a)</i> Two levels of a recursion tree for quicksort. The partitioning at the root costs <i class="emphasis">n</i> and produces a "bad" split: two subarrays of sizes 0 and <i class="emphasis">n</i> - 1. The partitioning of the subarray of size <i class="emphasis">n</i> - 1 costs <i class="emphasis">n</i> - 1 and produces a "good" split: subarrays of size (<i class="emphasis">n</i> - 1)/2 - 1 and (<i class="emphasis">n</i> - 1)/2. <i class="emphasis">(b)</i> A single level of a recursion tree that is very well balanced. In both parts, the partitioning cost for the subproblems shown with elliptical shading is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>). Yet the subproblems remaining to be solved in (a), shown with square shading, are no larger than the corresponding subproblems remaining to be solved in (b).</span>
</div>
<p class="para">The combination of the bad split followed by the good split produces three subarrays of sizes 0, (<i class="emphasis">n</i> - 1)/2 - 1, and (<i class="emphasis">n</i> - 1)/2 at a combined partitioning cost of <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) + <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> - 1) = <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>). Certainly, this situation is no worse than that in <a class="internaljump" href="#ch07fig05">Figure 7.5(b)</a>, namely a single level of partitioning that produces two subarrays of size (<i class="emphasis">n</i> - 1)/2, at a cost of <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>). Yet this latter situation is balanced! Intuitively, the <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> - 1) cost of the bad split can be absorbed into the <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) cost of the good split, and the resulting split is good. Thus, the running time of quicksort, when levels alternate between good and bad splits, is like the running time for good splits alone: still <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>), but with a slightly larger constant hidden by the <i class="emphasis">O</i>-notation. We shall give a rigorous analysis of the average case in <a href="DDU0045.html#486" target="_parent" class="chapterjump">Section 7.4.2</a>.<a name="470"></a><a name="IDX-153"></a>
</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 7.2-1</span></span><a name="471"></a><a name="ch07ex05"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Use the substitution method to prove that the recurrence <i class="emphasis">T</i> (<i class="emphasis">n</i>) = <i class="emphasis">T</i> (<i class="emphasis">n</i> - 1) + <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) has the solution <i class="emphasis">T</i> (<i class="emphasis">n</i>) = <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>2</sup>), as claimed at the beginning of <a class="internaljump" href="#ch07lev1sec2">Section 7.2</a>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 7.2-2</span></span><a name="472"></a><a name="ch07ex06"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">What is the running time of QUICKSORT when all elements of array <i class="emphasis">A</i> have the same value?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 7.2-3</span></span><a name="473"></a><a name="ch07ex07"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that the running time of QUICKSORT is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>2</sup>) when the array <i class="emphasis">A</i> contains distinct elements and is sorted in decreasing order.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 7.2-4</span></span><a name="474"></a><a name="ch07ex08"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Banks often record transactions on an account in order of the times of the transactions, but many people like to receive their bank statements with checks listed in order by check number. People usually write checks in order by check number, and merchants usually cash them with reasonable dispatch. The problem of converting time-of-transaction ordering to check-number ordering is therefore the problem of sorting almost-sorted input. Argue that the procedure INSERTION-SORT would tend to beat the procedure QUICKSORT on this problem.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 7.2-5</span></span><a name="475"></a><a name="ch07ex09"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that the splits at every level of quicksort are in the proportion 1 - <i class="emphasis"><span class="unicode">&alpha;</span></i> to <i class="emphasis"><span class="unicode">&alpha;</span></i>, where 0 <span class="unicode">&lt;</span> <i class="emphasis"><span class="unicode">&alpha;</span></i> <span class="unicode">&le;</span> 1/2 is a constant. Show that the minimum depth of a leaf in the recursion tree is approximately - lg <i class="emphasis">n</i>/ lg <i class="emphasis"><span class="unicode">&alpha;</span></i> and the maximum depth is approximately -lg <i class="emphasis">n</i>/ lg(1 - <i class="emphasis"><span class="unicode">&alpha;</span></i>). (Don't worry about integer round-off.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 7.2-6: </span><span class="unicode">&#8902;</span></span><a name="476"></a><a name="ch07ex10"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Argue that for any constant 0 <span class="unicode">&lt;</span> <i class="emphasis"><span class="unicode">&alpha;</span></i> <span class="unicode">&le;</span> 1/2, the probability is approximately 1 - 2<i class="emphasis"><span class="unicode">&alpha;</span></i> that on a random input array, PARTITION produces a split more balanced than 1-<i class="emphasis"><span class="unicode">&alpha;</span></i> to <i class="emphasis"><span class="unicode">&alpha;</span></i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0042.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0044.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
