<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>7.4 Analysis of quicksort</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0044.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0046.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch07"></a>
<div class="section">
<h2 class="first-section-title">
<a name="481"></a><a name="ch07lev1sec4"></a><span class="section-titlelabel">7.4 </span>Analysis of quicksort</h2>
<a name="482"></a><a name="IDX-155"></a>
<p class="para">
<a href="DDU0043.html#460" target="_parent" class="chapterjump">Section 7.2</a> gave some intuition for the worst-case behavior of quicksort and for why we expect it to run quickly. In this section, we analyze the behavior of quicksort more rigorously. We begin with a worst-case analysis, which applies to either QUICKSORT or RANDOMIZED-QUICKSORT, and conclude with an average-case analysis of RANDOMIZED-QUICKSORT.</p>
<div class="section">
<h3 class="sect3-title">
<a name="483"></a><a name="ch07lev2sec1"></a><span class="section-titlelabel">7.4.1 </span>Worst-case analysis</h3>
<p class="first-para">We saw in <a href="DDU0043.html#460" target="_parent" class="chapterjump">Section 7.2</a> that a worst-case split at every level of recursion in quicksort produces a <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>2</sup>) running time, which, intuitively, is the worst-case running time of the algorithm. We now prove this assertion.</p>
<p class="para">Using the substitution method (see <a href="DDU0024.html#211" target="_parent" class="chapterjump">Section 4.1</a>), we can show that the running time of quicksort is <i class="emphasis">O</i>(<i class="emphasis">n</i><sup>2</sup>). Let <i class="emphasis">T</i> (<i class="emphasis">n</i>) be the worst-case time for the procedure QUICKSORT on an input of size <i class="emphasis">n</i>. We have the recurrence</p>
<div class="equation">
<a name="484"></a><a name="ch07eq01"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(7.1)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig177_01.jpg" height="25" width="290" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">where the parameter <i class="emphasis">q</i> ranges from 0 to <i class="emphasis">n</i> - 1 because the procedure PARTITION produces two subproblems with total size <i class="emphasis">n</i> - 1. We guess that <i class="emphasis">T</i> (<i class="emphasis">n</i>) <span class="unicode">&le;</span> <i class="emphasis">cn</i><sup>2</sup> for some constant <i class="emphasis">c</i>. Substituting this guess into recurrence (<a class="internaljump" href="#ch07eq01">7.1</a>), we obtain</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig177_02.jpg" height="59" width="298" alt="" border="0"></span>
</div>
<p class="para">The expression <i class="emphasis">q</i><sup>2</sup> +(<i class="emphasis">n</i>-<i class="emphasis">q</i>-1)<sup>2</sup> achieves a maximum over the parameter's range 0 <span class="unicode">&le;</span> <i class="emphasis">q</i> <span class="unicode">&le;</span> <i class="emphasis">n</i> - 1 at either endpoint, as can be seen since the second derivative of the expression with respect to <i class="emphasis">q</i> is positive (see <a class="internaljump" href="#ch07ex14">Exercise 7.4-3</a>). This observation gives us the bound max<sub><span class="unicode">&le;</span><i class="emphasis">q</i><span class="unicode">&le;</span><i class="emphasis">n</i>-1</sub>(<i class="emphasis">q</i><sup>2</sup>+ (<i class="emphasis">n</i> - <i class="emphasis">q</i> - 1)<sup>2</sup>) <span class="unicode">&le;</span> (<i class="emphasis">n</i> - 1)<sup>2</sup> = <i class="emphasis">n</i><sup>2</sup> - 2<i class="emphasis">n</i> + 1. Continuing with our bounding of <i class="emphasis">T</i> (<i class="emphasis">n</i>), we obtain</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">T</i>(<i class="emphasis">n</i>)</p>
</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&le;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">cn</i><sup>2</sup> - <i class="emphasis">c</i>(2<i class="emphasis">n</i> - 1) + <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&le;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">cn</i><sup>2</sup>,</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">since we can pick the constant <i class="emphasis">c</i> large enough so that the <i class="emphasis">c</i>(2<i class="emphasis">n</i> - 1) term dominates the <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) term. Thus, <i class="emphasis">T</i> (<i class="emphasis">n</i>) = <i class="emphasis">O</i>(<i class="emphasis">n</i><sup>2</sup>). We saw in <a href="DDU0043.html#460" target="_parent" class="chapterjump">Section 7.2</a> a specific case in which quicksort takes <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>2</sup>) time: when partitioning is unbalanced. Alternatively, <a class="internaljump" href="#ch07ex13">Exercise 7.4-1</a> asks you to show that recurrence (<a class="internaljump" href="#ch07eq01">7.1</a>) has a solution of <i class="emphasis">T</i> (<i class="emphasis">n</i>) = <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>2</sup>). Thus, the (worst-case) running time of quicksort is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>2</sup>).</p>
<a name="485"></a><a name="IDX-156"></a>

</div>
<div class="section">
<h3 class="sect3-title">
<a name="486"></a><a name="ch07lev2sec2"></a><span class="section-titlelabel">7.4.2 </span>Expected running time</h3>
<p class="first-para">We have already given an intuitive argument why the average-case running time of RANDOMIZED-QUICKSORT is <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>): if, in each level of recursion, the split induced by RANDOMIZED-PARTITION puts any constant fraction of the elements on one side of the partition, then the recursion tree has depth <span class="unicode">&Theta;</span>(lg <i class="emphasis">n</i>), and <i class="emphasis">O</i>(<i class="emphasis">n</i>) work is performed at each level. Even if we add new levels with the most unbalanced split possible between these levels, the total time remains <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>). We can analyze the expected running time of RANDOMIZED-QUICKSORT precisely by first understanding how the partitioning procedure operates and then using this understanding to derive an <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) bound on the expected running time. This upper bound on the expected running time, combined with the <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) best-case bound we saw in <a href="DDU0043.html#460" target="_parent" class="chapterjump">Section 7.2</a>, yields a <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) expected running time.</p>
<div class="section">
<h4 class="sect4-title">Running time and comparisons</h4>
<p class="first-para">The running time of QUICKSORT is dominated by the time spent in the PARTITION procedure. Each time the PARTITION procedure is called, a pivot element is selected, and this element is never included in any future recursive calls to QUICK-SORT and PARTITION. Thus, there can be at most <i class="emphasis">n</i> calls to PARTITION over the entire execution of the quicksort algorithm. One call to PARTITION takes <i class="emphasis">O</i>(1) time plus an amount of time that is proportional to the number of iterations of the <b class="bold">for</b> loop in lines 3<span class="unicode">-</span>6. Each iteration of this <b class="bold">for</b> loop performs a comparison inline 4, comparing the pivot element to another element of the array <i class="emphasis">A</i>. Therefore, if we can count the total number of times that line 4 is executed, we can bound the total time spent in the <b class="bold">for</b> loop during the entire execution of QUICKSORT.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 7.1</span></span><a name="487"></a><a name="ch07ex13"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">X</i> be the number of comparisons performed in line 4 of PARTITION over the entire execution of QUICKSORT on an <i class="emphasis">n</i>-element array. Then the running time of QUICKSORT is <i class="emphasis">O</i>(<i class="emphasis">n</i> + <i class="emphasis">X</i>).</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> By the discussion above, there are <i class="emphasis">n</i> calls to PARTITION, each of which does a constant amount of work and then executes the <b class="bold">for</b> loop some number of times. Each iteration of the <b class="bold">for</b> loop executes line 4.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">Our goal, therefore is to compute <i class="emphasis">X</i>, the total number of comparisons performed in all calls to PARTITION. We will not attempt to analyze how many comparisons are made in <i class="emphasis">each</i> call to PARTITION. Rather, we will derive an overall bound on the total number of comparisons. To do so, we must understand when the algorithm compares two elements of the array and when it does not. For ease of analysis, we rename the elements of the array <i class="emphasis">A</i> as <i class="emphasis">z</i><sub>1</sub>, <i class="emphasis">z</i><sub>2</sub>,..., <i class="emphasis">z<sub>n</sub></i>, with <i class="emphasis">z<sub>i</sub></i> being the <i class="emphasis">i</i>th smallest <a name="488"></a><a name="IDX-157"></a>element. We also define the set <i class="emphasis">Z<sub>ij</sub></i> = {<i class="emphasis">z<sub>i</sub></i>, <i class="emphasis">z</i><sub><i class="emphasis">i</i>+1</sub>,..., <i class="emphasis">z<sub>j</sub></i>} to be the set of elements between <i class="emphasis">z<sub>i</sub></i> and <i class="emphasis">z<sub>j</sub></i>, inclusive.</p>
<p class="para">When does the algorithm compare <i class="emphasis">z<sub>i</sub></i> and <i class="emphasis">z<sub>j</sub></i>? To answer this question, we first observe that each pair of elements is compared at most once. Why? Elements are compared only to the pivot element and, after a particular call of PARTITION finishes, the pivot element used in that call is never again compared to any other elements.</p>
<p class="para">Our analysis uses indicator random variables (see <a href="DDU0030.html#308" target="_parent" class="chapterjump">Section 5.2</a>). We define</p>
<p class="para">
<i class="emphasis">X<sub>ij</sub></i> = <b class="bold">I</b> {<i class="emphasis">z<sub>i</sub></i> is compared to <i class="emphasis">z<sub>j</sub></i>} ,</p>
<p class="para">where we are considering whether the comparison takes place at any time during the execution of the algorithm, not just during one iteration or one call of PARTITION. Since each pair is compared at most once, we can easily characterize the total number of comparisons performed by the algorithm:</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig179_01.jpg" height="45" width="115" alt="" border="0"></span>
</div>
<p class="para">Taking expectations of both sides, and then using linearity of expectation and <a href="DDU0030.html#311" target="_parent" class="chapterjump">Lemma 5.1</a>, we obtain</p>
<div class="equation">
<a name="489"></a><a name="ch07eq02"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(7.2)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig179_02.jpg" height="147" width="281" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">It remains to compute Pr {<i class="emphasis">z<sub>i</sub></i> is compared to <i class="emphasis">z<sub>j</sub></i>}.</p>
<p class="para">It is useful to think about when two items are <i class="emphasis">not</i> compared. Consider an input to quicksort of the numbers 1 through 10 (in any order), and assume that the first pivot element is 7. Then the first call to PARTITION separates the numbers into two sets: {1, 2, 3, 4, 5, 6} and {8, 9, 10}. In doing so, the pivot element 7 is compared to all other elements, but no number from the first set (e.g., 2) is or ever will be compared to any number from the second set (e.g., 9).</p>
<p class="para">In general, once a pivot <i class="emphasis">x</i> is chosen with <i class="emphasis">z<sub>i</sub></i> <span class="unicode">&lt;</span> <i class="emphasis">x</i> <span class="unicode">&lt;</span> <i class="emphasis">z<sub>j</sub></i>, we know that <i class="emphasis">z<sub>i</sub></i> and <i class="emphasis">z<sub>j</sub></i> cannot be compared at any subsequent time. If, on the other hand, <i class="emphasis">z<sub>i</sub></i> is chosen as a pivot before any other item in <i class="emphasis">Z<sub>ij</sub></i>, then <i class="emphasis">z<sub>i</sub></i> will be compared to each item in <i class="emphasis">Z<sub>ij</sub></i>, except for itself. Similarly, if <i class="emphasis">z<sub>j</sub></i> is chosen as a pivot before any other item in <i class="emphasis">Z<sub>ij</sub></i>, then <i class="emphasis">z<sub>j</sub></i> will be compared to each item in <i class="emphasis">Z<sub>ij</sub></i> , except for itself. In our example, the <a name="490"></a><a name="IDX-158"></a>values 7 and 9 are compared because 7 is the first item from <i class="emphasis">Z</i><sub>7,9</sub> to be chosen as a pivot. In contrast, 2 and 9 will never be compared because the first pivot element chosen from <i class="emphasis">Z</i><sub>2,9</sub> is 7. Thus, <i class="emphasis">z<sub>i</sub></i> and <i class="emphasis">z<sub>j</sub></i> are compared if and only if the first element to be chosen as a pivot from <i class="emphasis">Z<sub>ij</sub></i> is either <i class="emphasis">z<sub>i</sub></i> or <i class="emphasis">z<sub>j</sub></i>.</p>
<p class="para">We now compute the probability that this event occurs. Prior to the point at which an element from <i class="emphasis">Z<sub>ij</sub></i> has been chosen as a pivot, the whole set <i class="emphasis">Z<sub>ij</sub></i> is together in the same partition. Therefore, any element of <i class="emphasis">Z<sub>ij</sub></i> is equally likely to be the first one chosen as a pivot. Because the set <i class="emphasis">Z<sub>ij</sub></i> has <i class="emphasis">j</i> - <i class="emphasis">i</i> + 1 elements, the probability that any given element is the first one chosen as a pivot is 1/(<i class="emphasis">j</i> - <i class="emphasis">i</i> + 1). Thus, we have</p>
<div class="equation">
<a name="491"></a><a name="ch07eq03"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(7.3)&nbsp;</span></td><td valign="top"><span class="equation-image"><a href="images/fig180%5F01%2Ejpg" NAME="IMG_283" target="_parent"><img src="images/fig180_01.jpg" height="128" width="400" alt="Click To expand" border="0"></a></span></td>
</tr>
</table>
</div>
<p class="para">The second line follows because the two events are mutually exclusive. Combining equations (<a class="internaljump" href="#ch07eq02">7.2</a>) and (<a class="internaljump" href="#ch07eq03">7.3</a>), we get that</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig180_02.jpg" height="45" width="177" alt="" border="0"></span>
</div>
<p class="para">We can evaluate this sum using a change of variables (<i class="emphasis">k</i> = <i class="emphasis">j</i> - <i class="emphasis">i</i>) and the bound on the harmonic series in equation (<a href="DDU0244.html#3291" target="_parent" class="chapterjump">A.7</a>):</p>
<div class="equation">
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(7.4)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig180_03.jpg" height="211" width="187" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">Thus we conclude that, using RANDOMIZED-PARTITION, the expected running time of quicksort is <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>).<a name="492"></a><a name="IDX-159"></a>
</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 7.4-1</span></span><a name="493"></a><a name="ch07ex14"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that in the recurrence</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig181_01.jpg" height="53" width="291" alt="" border="0"></span>
</div>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 7.4-2</span></span><a name="494"></a><a name="ch07ex15"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that quicksort's best-case running time is <span class="unicode">&#8486;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 7.4-3</span></span><a name="495"></a><a name="ch07ex16"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that <i class="emphasis">q</i><sup>2</sup> + (<i class="emphasis">n</i> - <i class="emphasis">q</i> - 1)<sup>2</sup> achieves a maximum over <i class="emphasis">q</i> = 0, 1,..., <i class="emphasis">n</i> - 1 when <i class="emphasis">q</i> = 0 or <i class="emphasis">q</i> = <i class="emphasis">n</i> - 1.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 7.4-4</span></span><a name="496"></a><a name="ch07ex17"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that RANDOMIZED-QUICKSORT's expected running time is <span class="unicode">&#8486;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 7.4-5</span></span><a name="497"></a><a name="ch07ex18"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The running time of quicksort can be improved in practice by taking advantage of the fast running time of insertion sort when its input is "nearly" sorted. When quicksort is called on a subarray with fewer than <i class="emphasis">k</i> elements, let it simply return without sorting the subarray. After the top-level call to quicksort returns, run insertion sort on the entire array to finish the sorting process. Argue that this sorting algorithm runs in <i class="emphasis">O</i>(<i class="emphasis">nk</i> + <i class="emphasis">n</i> lg(<i class="emphasis">n</i>/<i class="emphasis">k</i>)) expected time. How should <i class="emphasis">k</i> be picked, both in theory and in practice?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 7.4-6: </span><span class="unicode">&#8902;</span></span><a name="498"></a><a name="ch07ex19"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Consider modifying the PARTITION procedure by randomly picking three elements from array <i class="emphasis">A</i> and partitioning about their median (the middle value of the three elements). Approximate the probability of getting at worst an <i class="emphasis"><span class="unicode">&alpha;</span></i>to-(1 - <i class="emphasis"><span class="unicode">&alpha;</span></i>) split, as a function of <i class="emphasis"><span class="unicode">&alpha;</span></i> in the range 0 <span class="unicode">&lt;</span> <i class="emphasis"><span class="unicode">&alpha;</span></i> <span class="unicode">&lt;</span> 1.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 7-1: </span>Hoare partition correctness</span><a name="499"></a><a name="ch07ex20"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The version of PARTITION given in this chapter is not the original partitioning algorithm. Here is the original partition algorithm, which is due to T. Hoare:<a name="500"></a><a name="IDX-160"></a>
</p>
<pre class="literallayout-normal">
HOARE-PARTITION(<i class="emphasis">A</i>, <i class="emphasis">p</i>, <i class="emphasis">r</i>)
 1  <i class="emphasis">x</i> <span class="unicode">&larr;</span> <i class="emphasis">A</i>[<i class="emphasis">p</i>]
 2  <i class="emphasis">i</i> <span class="unicode">&larr;</span> <i class="emphasis">p</i> - 1
 3  <i class="emphasis">j</i> <span class="unicode">&larr;</span> <i class="emphasis">r</i> + 1
 4  <b class="bold">while</b> TRUE
 5      <b class="bold">do repeat</b> <i class="emphasis">j</i> <span class="unicode">&larr;</span> <i class="emphasis">j</i> - 1
 6           <b class="bold">until</b> <i class="emphasis">A</i>[<i class="emphasis">j</i>] <span class="unicode">&le;</span> <i class="emphasis">x</i>
 7         <b class="bold">repeat</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> <i class="emphasis">i</i> + 1
 8           <b class="bold">until</b> <i class="emphasis">A</i>[<i class="emphasis">i</i>] <span class="unicode">&ge;</span> <i class="emphasis">x</i>
 9         <b class="bold">if</b> <i class="emphasis">i</i> <span class="unicode">&lt;</span> <i class="emphasis">j</i>
10            <b class="bold">then</b> exchange <i class="emphasis">A</i>[<i class="emphasis">i</i>] <span class="unicode">&harr;</span> <i class="emphasis">A</i>[<i class="emphasis">j</i>]
11            <b class="bold">else return</b> <i class="emphasis">j</i>
</pre>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Demonstrate the operation of HOARE-PARTITION on the array <i class="emphasis">A</i> = <span class="unicode">&#12296;</span>13, 19, 9, 5, 12, 8, 7, 4, 11, 2, 6, 21<span class="unicode">&#12297;</span>, showing the values of the array and auxiliary values after each iteration of the <b class="bold">for</b> loop in lines 4<span class="unicode">-</span>11.</p>
</li>
</ol>
<p class="para">The next three questions ask you to give a careful argument that the procedure HOARE-PARTITION is correct. Prove the following:</p>
<ol class="orderedlist" start="2" type="a">
<li class="first-listitem">
<p class="first-para">The indices <i class="emphasis">i</i> and <i class="emphasis">j</i> are such that we never access an element of <i class="emphasis">A</i> outside the subarray <i class="emphasis">A</i>[<i class="emphasis">p</i> <span class="unicode">&#8229;</span> <i class="emphasis">r</i>].</p>
</li>
<li class="listitem">
<p class="first-para">When HOARE-PARTITION terminates, it returns a value <i class="emphasis">j</i> such that <i class="emphasis">p</i> <span class="unicode">&le;</span> <i class="emphasis">j</i> <span class="unicode">&lt;</span> <i class="emphasis">r</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Every element of <i class="emphasis">A</i>[<i class="emphasis">p</i> <span class="unicode">&#8229;</span> <i class="emphasis">j</i>] is less than or equal to every element of <i class="emphasis">A</i>[<i class="emphasis">j</i> +1 <span class="unicode">&#8229;</span> <i class="emphasis">r</i>] when HOARE-PARTITION terminates.</p>
</li>
</ol>
<p class="para">The PARTITION procedure in <a href="DDU0042.html#447" target="_parent" class="chapterjump">Section 7.1</a> separates the pivot value (originally in <i class="emphasis">A</i>[<i class="emphasis">r</i>]) from the two partitions it forms. The HOARE-PARTITION procedure, on the other hand, always places the pivot value (originally in <i class="emphasis">A</i>[<i class="emphasis">p</i>]) into one of the two partitions <i class="emphasis">A</i>[<i class="emphasis">p</i> <span class="unicode">&#8229;</span> <i class="emphasis">j</i>] and <i class="emphasis">A</i>[<i class="emphasis">j</i> + 1 <span class="unicode">&#8229;</span> <i class="emphasis">r</i>]. Since <i class="emphasis">p</i> <span class="unicode">&le;</span> <i class="emphasis">j</i> <span class="unicode">&lt;</span> <i class="emphasis">r</i>, this split is always nontrivial.</p>
<ol class="orderedlist" start="5" type="a">
<li class="first-listitem">
<p class="first-para">Rewrite the QUICKSORT procedure to use HOARE-PARTITION.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 7-2: </span>Alternative quicksort analysis</span><a name="501"></a><a name="ch07ex21"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">An alternative analysis of the running time of randomized quicksort focuses on the expected running time of each individual recursive call to QUICKSORT, rather than on the number of comparisons performed.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Argue that, given an array of size <i class="emphasis">n</i>, the probability that any particular element is chosen as the pivot is 1/<i class="emphasis">n</i>. Use this to define indicator random variables <i class="emphasis">X<sub>i</sub></i> = I{<i class="emphasis">i</i>th smallest element is chosen as the pivot}. What is E [<i class="emphasis">X<sub>i</sub></i>]?</p>
<a name="502"></a><a name="IDX-161"></a>
</li>
<li class="listitem">
<p class="first-para">Let <i class="emphasis">T</i> (<i class="emphasis">n</i>) be a random variable denoting the running time of quicksort on an array of size <i class="emphasis">n</i>. Argue that</p>
<div class="equation">
<a name="503"></a><a name="ch07eq05"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(7.5)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig183_01.jpg" height="47" width="341" alt="" border="0"></span></td>
</tr>
</table>
</div>
</li>
<li class="listitem">
<p class="first-para">Show that equation (<a class="internaljump" href="#ch07eq05">7.5</a>) simplifies to</p>
<div class="equation">
<a name="504"></a><a name="ch07eq06"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(7.6)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig183_02.jpg" height="45" width="214" alt="" border="0"></span></td>
</tr>
</table>
</div>
</li>
<li class="listitem">
<p class="first-para">Show that</p>
<div class="equation">
<a name="505"></a><a name="ch07eq07"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(7.7)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig183_03.jpg" height="42" width="172" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="last-para">(<i class="emphasis">Hint:</i> Split the summation into two parts, one for <i class="emphasis">k</i> = 1, 2,..., <span class="unicode">&lceil;</span><i class="emphasis">n</i>/2<span class="unicode">&rceil;</span> - 1 and one for <i class="emphasis">k</i> = <span class="unicode">&lceil;</span><i class="emphasis">n</i>/2<span class="unicode">&rceil;</span>,..., <i class="emphasis">n</i> - 1.)</p>
</li>
<li class="listitem">
<p class="first-para">Using the bound from equation (<a class="internaljump" href="#ch07eq07">7.7</a>), show that the recurrence in equation (<a class="internaljump" href="#ch07eq06">7.6</a>) has the solution E [<i class="emphasis">T</i> (<i class="emphasis">n</i>)] = <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>). (<i class="emphasis">Hint:</i> Show, by substitution, that E[<i class="emphasis">T</i> (<i class="emphasis">n</i>)] <span class="unicode">&le;</span> <i class="emphasis">an</i> log <i class="emphasis">n</i> - <i class="emphasis">bn</i> for some positive constants <i class="emphasis">a</i> and <i class="emphasis">b</i>.)</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 7-3: </span>Stooge sort</span><a name="506"></a><a name="ch07ex22"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Professors Howard, Fine, and Howard have proposed the following "elegant" sorting algorithm:</p>
<pre class="literallayout-normal">
STOOGE-SORT(<i class="emphasis">A</i>, <i class="emphasis">i</i>, <i class="emphasis">j</i>)
1  <b class="bold">if</b> <i class="emphasis">A</i>[<i class="emphasis">i</i>] <span class="unicode">&gt;</span> <i class="emphasis">A</i>[<i class="emphasis">j</i>]
2     <b class="bold">then</b> exchange <i class="emphasis">A</i>[<i class="emphasis">i</i>] <span class="unicode">&harr;</span> <i class="emphasis">A</i>[<i class="emphasis">j</i>]
3  <b class="bold">if</b> <i class="emphasis">i</i> + 1 <span class="unicode">&ge;</span> <i class="emphasis">j</i>
4     <b class="bold">then return</b>
5  <i class="emphasis">k</i> <span class="unicode">&larr;</span> <span class="unicode">&lfloor;</span>(<i class="emphasis">j</i> - <i class="emphasis">i</i> + 1)/3<span class="unicode">&rfloor;</span>             <span class="unicode">&#9657;</span> Round down.
6  STOOGE-SORT(<i class="emphasis">A</i>, <i class="emphasis">i</i>, <i class="emphasis">j</i> - <i class="emphasis">k</i>)         <span class="unicode">&#9657;</span> First two-thirds.
7  STOOGE-SORT(<i class="emphasis">A</i>, <i class="emphasis">i</i> + <i class="emphasis">k</i>, <i class="emphasis">j</i>)         <span class="unicode">&#9657;</span> Last two-thirds.
8  STOOGE-SORT(<i class="emphasis">A</i>, <i class="emphasis">i</i>, <i class="emphasis">j</i> - <i class="emphasis">k</i>)         <span class="unicode">&#9657;</span> First two-thirds again.
</pre>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Argue that, if <i class="emphasis">n</i> = <i class="emphasis">length</i>[<i class="emphasis">A</i>], then STOOGE-SORT(<i class="emphasis">A</i>, 1, <i class="emphasis">length</i>[<i class="emphasis">A</i>]) correctly sorts the input array <i class="emphasis">A</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>].</p>
</li>
<li class="listitem">
<p class="first-para">Give a recurrence for the worst-case running time of STOOGE-SORT and a tight asymptotic (<span class="unicode">&Theta;</span>-notation) bound on the worst-case running time.</p>
<a name="507"></a><a name="IDX-162"></a>
</li>
<li class="listitem">
<p class="first-para">Compare the worst-case running time of STOOGE-SORT with that of insertion sort, merge sort, heapsort, and quicksort. Do the professors deserve tenure?</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 7-4: </span>Stack depth for quicksort</span><a name="508"></a><a name="ch07ex23"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The QUICKSORT algorithm of <a href="DDU0042.html#447" target="_parent" class="chapterjump">Section 7.1</a> contains two recursive calls to itself. After the call to PARTITION, the left subarray is recursively sorted and then the right subarray is recursively sorted. The second recursive call in QUICKSORT is not really necessary; it can be avoided by using an iterative control structure. This technique, called <b class="bold"><i class="emphasis">tail recursion</i></b>, is provided automatically by good compilers. Consider the following version of quicksort, which simulates tail recursion.</p>
<pre class="literallayout-normal">
QUICKSORT'(<i class="emphasis">A</i>, <i class="emphasis">p</i>, <i class="emphasis">r</i>)
1  <b class="bold">while</b> <i class="emphasis">p</i> <span class="unicode">&lt;</span> <i class="emphasis">r</i>
2        <b class="bold">do</b> <span class="unicode">&#9656;</span> Partition and sort left subarray.
3             <i class="emphasis">q</i> <span class="unicode">&larr;</span> PARTITION(<i class="emphasis">A</i>, <i class="emphasis">p</i>, <i class="emphasis">r</i>)
4             QUICKSORT'(<i class="emphasis">A</i>, <i class="emphasis">p</i>, <i class="emphasis">q</i> - 1)
5             <i class="emphasis">p</i> <span class="unicode">&larr;</span> <i class="emphasis">q</i> + 1
</pre>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Argue that QUICKSORT'(<i class="emphasis">A</i>, 1, length[<i class="emphasis">A</i>]) correctly sorts the array <i class="emphasis">A</i>.</p>
</li>
</ol>
<p class="para">Compilers usually execute recursive procedures by using a <b class="bold"><i class="emphasis">stack</i></b> that contains pertinent information, including the parameter values, for each recursive call. The information for the most recent call is at the top of the stack, and the information for the initial call is at the bottom. When a procedure is invoked, its information is <b class="bold"><i class="emphasis">pushed</i></b> onto the stack; when it terminates, its information is <b class="bold"><i class="emphasis">popped</i></b>. Since we assume that array parameters are represented by pointers, the information for each procedure call on the stack requires <i class="emphasis">O</i>(1) stack space. The <b class="bold"><i class="emphasis">stack depth</i></b> is the maximum amount of stack space used at any time during a computation.</p>
<ol class="orderedlist" start="2" type="a">
<li class="first-listitem">
<p class="first-para">Describe a scenario in which the stack depth of QUICKSORT' is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) on an <i class="emphasis">n</i>-element input array.</p>
</li>
<li class="listitem">
<p class="first-para">Modify the code for QUICKSORT' so that the worst-case stack depth is <span class="unicode">&Theta;</span>(lg <i class="emphasis">n</i>). Maintain the <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) expected running time of the algorithm.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 7-5: </span>Median-of-3 partition</span><a name="509"></a><a name="ch07ex24"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">One way to improve the RANDOMIZED-QUICKSORT procedure is to partition around a pivot that is chosen more carefully than by picking a random element from the subarray. One common approach is the <b class="bold"><i class="emphasis">median-of-3</i></b> method: choose the pivot as the median (middle element) of a set of 3 elements randomly selected from the subarray. (See <a class="internaljump" href="#ch07ex18">Exercise 7.4-6</a>.) For this problem, let us assume that the elements in the input array <i class="emphasis">A</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>] are distinct and that <i class="emphasis">n</i> <span class="unicode">&ge;</span> 3. We denote the <a name="510"></a><a name="IDX-163"></a>sorted output array by <i class="emphasis">A</i>'[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>]. Using the median-of-3 method to choose the pivot element <i class="emphasis">x</i>, define <i class="emphasis">p<sub>i</sub></i> = Pr{<i class="emphasis">x</i> = <i class="emphasis">A</i>'[<i class="emphasis">i</i>]}.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Give an exact formula for <i class="emphasis">p<sub>i</sub></i> as a function of <i class="emphasis">n</i> and <i class="emphasis">i</i> for <i class="emphasis">i</i> = 2, 3,..., <i class="emphasis">n</i> - 1. (Note that <i class="emphasis">p</i><sub>1</sub> = <i class="emphasis">p<sub>n</sub></i> = 0.)</p>
</li>
<li class="listitem">
<p class="first-para">By what amount have we increased the likelihood of choosing the pivot as <i class="emphasis">x</i> = A'[<span class="unicode">&lfloor;</span>(<i class="emphasis">n</i> + 1/2<span class="unicode">&rfloor;</span>], the median of <i class="emphasis">A</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>], compared to the ordinary implementation? Assume that <i class="emphasis">n</i> <span class="unicode">&rarr;</span> <span class="unicode">&infin;</span>, and give the limiting ratio of these probabilities.</p>
</li>
<li class="listitem">
<p class="first-para">If we define a "good" split to mean choosing the pivot as <i class="emphasis">x</i> = <i class="emphasis">A</i>'[<i class="emphasis">i</i>], where <i class="emphasis">n</i>/ <span class="unicode">&le;</span> <i class="emphasis">i</i> <span class="unicode">&le;</span> 2<i class="emphasis">n</i>/3, by what amount have we increased the likelihood of getting a good split compared to the ordinary implementation? (<i class="emphasis">Hint:</i> Approximate the sum by an integral.)</p>
</li>
<li class="listitem">
<p class="first-para">Argue that in the <span class="unicode">&#8486;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) running time of quicksort, the median-of-3 method affects only the constant factor.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 7-6: </span>Fuzzy sorting of intervals</span><a name="511"></a><a name="ch07ex25"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Consider a sorting problem in which the numbers are not known exactly. Instead, for each number, we know an interval on the real line to which it belongs. That is, we are given <i class="emphasis">n</i> closed intervals of the form [<i class="emphasis">a<sub>i</sub></i>, <i class="emphasis">b<sub>i</sub></i>], where <i class="emphasis">a<sub>i</sub></i> <span class="unicode">&le;</span> <i class="emphasis">b<sub>i</sub></i>. The goal is to <b class="bold"><i class="emphasis">fuzzy-sort</i></b> these intervals, i.e., produce a permutation <span class="unicode">&#12296;</span><i class="emphasis">i</i><sub>1</sub>, <i class="emphasis">i</i><sub>2</sub>,..., <i class="emphasis">i<sub>n</sub></i><span class="unicode">&#12297;</span> of the intervals such that there exist <span class="inlinemediaobject"><img src="images/fig185_01.jpg" height="14" width="61" alt="" border="0"></span>, satisfying <i class="emphasis">c</i><sub>1</sub> <span class="unicode">&le;</span> <i class="emphasis">c</i><sub>2</sub> <span class="unicode">&le;</span> <span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&middot;</span> <span class="unicode">&le;</span> <i class="emphasis">c<sub>n</sub></i>.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Design an algorithm for fuzzy-sorting <i class="emphasis">n</i> intervals. Your algorithm should have the general structure of an algorithm that quicksorts the left endpoints (the <i class="emphasis">a<sub>i</sub></i> 's), but it should take advantage of overlapping intervals to improve the running time. (As the intervals overlap more and more, the problem of fuzzy-sorting the intervals gets easier and easier. Your algorithm should take advantage of such overlapping, to the extent that it exists.)</p>
</li>
<li class="listitem">
<p class="first-para">Argue that your algorithm runs in expected time <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) in general, but runs in expected time <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) when all of the intervals overlap (i.e., when there exists a value <i class="emphasis">x</i> such that <i class="emphasis">x</i> <span class="unicode">&isin;</span> [<i class="emphasis">a<sub>i</sub></i>, <i class="emphasis">b<sub>i</sub></i>] for all <i class="emphasis">i</i>). Your algorithm should not be checking for this case explicitly; rather, its performance should naturally improve as the amount of overlap increases.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0044.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0046.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
