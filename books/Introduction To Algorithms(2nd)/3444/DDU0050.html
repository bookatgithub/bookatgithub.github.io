<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>8.3 Radix sort</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0049.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0051.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch08"></a>
<div class="section">
<h2 class="first-section-title">
<a name="538"></a><a name="ch08lev1sec3"></a><span class="section-titlelabel">8.3 </span>Radix sort</h2>
<p class="first-para">
<b class="bold"><i class="emphasis">Radix sort</i></b> is the algorithm used by the card-sorting machines you now find only in computer museums. The cards are organized into 80 columns, and in each column a hole can be punched in one of 12 places. The sorter can be mechanically "programmed" to examine a given column of each card in a deck and distribute the <a name="539"></a><a name="IDX-171"></a>card into one of 12 bins depending on which place has been punched. An operator can then gather the cards bin by bin, so that cards with the first place punched are on top of cards with the second place punched, and so on.</p>
<p class="para">For decimal digits, only 10 places are used in each column. (The other two places are used for encoding nonnumeric characters.) A <i class="emphasis">d</i>-digit number would then occupy a field of <i class="emphasis">d</i> columns. Since the card sorter can look at only one column at a time, the problem of sorting <i class="emphasis">n</i> cards on a <i class="emphasis">d</i>-digit number requires a sorting algorithm.</p>
<p class="para">Intuitively, one might want to sort numbers on their <i class="emphasis">most significant</i> digit, sort each of the resulting bins recursively, and then combine the decks in order. Unfortunately, since the cards in 9 of the 10 bins must be put aside to sort each of the bins, this procedure generates many intermediate piles of cards that must be kept track of. (See <a class="internaljump" href="#ch08ex17">Exercise 8.3-5</a>.)</p>
<p class="para">Radix sort solves the problem of card sorting counterintuitively by sorting on the <i class="emphasis">least significant</i> digit first. The cards are then combined into a single deck, with the cards in the 0 bin preceding the cards in the 1 bin preceding the cards in the 2 bin, and so on. Then the entire deck is sorted again on the second-least significant digit and recombined in a like manner. The process continues until the cards have been sorted on all <i class="emphasis">d</i> digits. Remarkably, at that point the cards are fully sorted on the <i class="emphasis">d</i>-digit number. Thus, only <i class="emphasis">d</i> passes through the deck are required to sort. <a class="internaljump" href="#ch08fig03">Figure 8.3</a> shows how radix sort operates on a "deck" of seven 3-digit numbers.</p>
<div class="figure">
<a name="540"></a><a name="ch08fig03"></a><span class="figuremediaobject"><img src="images/fig193_01.jpg" height="149" width="320" alt="" border="0"></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 8.3: </span>The operation of radix sort on a list of seven 3-digit numbers. The leftmost column is the input. The remaining columns show the list after successive sorts on increasingly significant digit positions. Shading indicates the digit position sorted on to produce each list from the previous one.</span>
</div>
<p class="para">It is essential that the digit sorts in this algorithm be stable. The sort performed by a card sorter is stable, but the operator has to be wary about not changing the order of the cards as they come out of a bin, even though all the cards in a bin have the same digit in the chosen column.</p>
<p class="para">In a typical computer, which is a sequential random-access machine, radix sort is sometimes used to sort records of information that are keyed by multiple fields. For example, we might wish to sort dates by three keys: year, month, and day. We could run a sorting algorithm with a comparison function that, given two dates, compares years, and if there is a tie, compares months, and if another tie occurs, <a name="541"></a><a name="IDX-172"></a>compares days. Alternatively, we could sort the information three times with a stable sort: first on day, next on month, and finally on year.</p>
<p class="para">The code for radix sort is straightforward. The following procedure assumes that each element in the <i class="emphasis">n</i>-element array <i class="emphasis">A</i> has <i class="emphasis">d</i> digits, where digit 1 is the lowest-order digit and digit <i class="emphasis">d</i> is the highest-order digit.</p>
<div class="informalexample">
<pre class="literallayout-normal">
RADIX-SORT(<i class="emphasis">A</i>, <i class="emphasis">d</i>)
1  <b class="bold">for</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">d</i>
2     <b class="bold">do</b> use a stable sort to sort array <i class="emphasis">A</i> on digit <i class="emphasis">i</i>
</pre>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 8.3</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Given <i class="emphasis">n d</i>-digit numbers in which each digit can take on up to <i class="emphasis">k</i> possible values, RADIX-SORT correctly sorts these numbers in <span class="unicode">&Theta;</span>(<i class="emphasis">d</i>(<i class="emphasis">n</i> + <i class="emphasis">k</i>)) time.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> The correctness of radix sort follows by induction on the column being sorted (see <a class="internaljump" href="#ch08ex15">Exercise 8.3-3</a>). The analysis of the running time depends on the stable sort used as the intermediate sorting algorithm. When each digit is in the range 0 to <i class="emphasis">k</i>-1 (so that it can take on <i class="emphasis">k</i> possible values), and <i class="emphasis">k</i> is not too large, counting sort is the obvious choice. Each pass over <i class="emphasis">n d</i>-digit numbers then takes time <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> + <i class="emphasis">k</i>). There are <i class="emphasis">d</i> passes, so the total time for radix sort is <span class="unicode">&Theta;</span>(<i class="emphasis">d</i>(<i class="emphasis">n</i> + <i class="emphasis">k</i>)).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">When <i class="emphasis">d</i> is constant and <i class="emphasis">k</i> = <i class="emphasis">O</i>(<i class="emphasis">n</i>), radix sort runs in linear time. More generally, we have some flexibility in how to break each key into digits.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 8.4</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Given <i class="emphasis">n b</i>-bit numbers and any positive integer <i class="emphasis">r</i> <span class="unicode">&le;</span> <i class="emphasis">b</i>, RADIX-SORT correctly sorts these numbers in <span class="unicode">&Theta;</span>((<i class="emphasis">b/r</i>)(<i class="emphasis">n</i> + 2<sup><i class="emphasis">r</i></sup>)) time.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> For a value <i class="emphasis">r</i> <span class="unicode">&le;</span> <i class="emphasis">b</i>, we view each key as having <i class="emphasis">d</i> = <span class="unicode">&lceil;</span><i class="emphasis">b/r</i><span class="unicode">&rceil;</span> digits of <i class="emphasis">r</i> bits each. Each digit is an integer in the range 0 to 2<sup><i class="emphasis">r</i></sup> - 1, so that we can use counting sort with <i class="emphasis">k</i> = 2<sup><i class="emphasis">r</i></sup> - 1. (For example, we can view a 32-bit word as having 4 8-bit digits, so that <i class="emphasis">b</i> = 32, <i class="emphasis">r</i> = 8, <i class="emphasis">k</i> = 2<sup><i class="emphasis">r</i></sup> - 1 = 255, and <i class="emphasis">d</i> = <i class="emphasis">b/r</i> = 4.) Each pass of counting sort takes time <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> + <i class="emphasis">k</i>) = <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> + 2<sup><i class="emphasis">r</i></sup>) and there are <i class="emphasis">d</i> passes, for a total running time of <span class="unicode">&Theta;</span>(<i class="emphasis">d</i>(<i class="emphasis">n</i> + 2<sup><i class="emphasis">r</i></sup> )) = <span class="unicode">&Theta;</span>((<i class="emphasis">b</i>/<i class="emphasis">r</i>)(<i class="emphasis">n</i> + 2<sup><i class="emphasis">r</i></sup>)).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">For given values of <i class="emphasis">n</i> and <i class="emphasis">b</i>, we wish to choose the value of <i class="emphasis">r</i>, with <i class="emphasis">r</i> <span class="unicode">&le;</span> <i class="emphasis">b</i>, that minimizes the expression (<i class="emphasis">b/r</i>)(<i class="emphasis">n</i> + 2<sup><i class="emphasis">r</i></sup>). If <i class="emphasis">b</i> <span class="unicode">&lt;</span> <span class="unicode">&lfloor;</span>lg <i class="emphasis">n</i><span class="unicode">&rfloor;</span>, then for any value of <i class="emphasis">r</i> <i class="emphasis">b</i>, we have that (<i class="emphasis">n</i> + 2<sup><i class="emphasis">r</i></sup>) = <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>). Thus, choosing <i class="emphasis">r</i> = <i class="emphasis">b</i> yields a running time of (<i class="emphasis">b/b</i>)(<i class="emphasis">n</i> + 2<sup><i class="emphasis">b</i></sup>) = <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>), which is asymptotically optimal. If <i class="emphasis">b</i> <span class="unicode">&ge;</span> <span class="unicode">&lfloor;</span>lg <i class="emphasis">n</i><span class="unicode">&rfloor;</span>, then choosing <i class="emphasis">r</i> = <span class="unicode">&lfloor;</span>lg <i class="emphasis">n</i><span class="unicode">&rfloor;</span> gives the best time to within a constant factor, which we can see as follows. Choosing <i class="emphasis">r</i> = <span class="unicode">&lfloor;</span>lg <i class="emphasis">n</i><span class="unicode">&rfloor;</span> yields a running time of <span class="unicode">&Theta;</span>(<i class="emphasis">bn</i>/ lg <i class="emphasis">n</i>). As we increase <i class="emphasis">r</i> above <span class="unicode">&lfloor;</span>lg <i class="emphasis">n</i><span class="unicode">&rfloor;</span>, the 2<sup><i class="emphasis">r</i></sup> term in the numerator increases faster than <a name="542"></a><a name="IDX-173"></a>the <i class="emphasis">r</i> term in the denominator, and so increasing <i class="emphasis">r</i> above <span class="unicode">&lfloor;</span>lg <i class="emphasis">n</i><span class="unicode">&rfloor;</span> yields a running time of <span class="unicode">&Theta;</span>(<i class="emphasis">bn</i>/ lg <i class="emphasis">n</i>). If instead we were to decrease <i class="emphasis">r</i> below <span class="unicode">&lfloor;</span>lg <i class="emphasis">n</i><span class="unicode">&rfloor;</span>, then the <i class="emphasis">b/r</i> term increases and the <i class="emphasis">n</i> + 2<sup><i class="emphasis">r</i></sup> term remains at <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>).</p>
<p class="para">Is radix sort preferable to a comparison-based sorting algorithm, such as quick-sort? If <i class="emphasis">b</i> = <i class="emphasis">O</i>(lg <i class="emphasis">n</i>), as is often the case, and we choose <i class="emphasis">r</i> <span class="unicode">&asymp;</span> lg <i class="emphasis">n</i>, then radix sort's running time is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>), which appears to be better than quicksort's average-case time of <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>). The constant factors hidden in the <span class="unicode">&Theta;</span>-notation differ, however. Although radix sort may make fewer passes than quicksort over the <i class="emphasis">n</i> keys, each pass of radix sort may take significantly longer. Which sorting algorithm is preferable depends on the characteristics of the implementations, of the underlying machine (e.g., quicksort often uses hardware caches more effectively than radix sort), and of the input data. Moreover, the version of radix sort that uses counting sort as the intermediate stable sort does not sort in place, which many of the <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>)-time comparison sorts do. Thus, when primary memory storage is at a premium, an in-place algorithm such as quicksort may be preferable.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 8.3-1</span></span><a name="543"></a><a name="ch08ex13"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Using <a class="internaljump" href="#ch08fig03">Figure 8.3</a> as a model, illustrate the operation of RADIX-SORT on the following list of English words: COW, DOG, SEA, RUG, ROW, MOB, BOX, TAB, BAR, EAR, TAR, DIG, BIG, TEA, NOW, FOX.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 8.3-2</span></span><a name="544"></a><a name="ch08ex14"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Which of the following sorting algorithms are stable: insertion sort, merge sort, heapsort, and quicksort? Give a simple scheme that makes any sorting algorithm stable. How much additional time and space does your scheme entail?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 8.3-3</span></span><a name="545"></a><a name="ch08ex15"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Use induction to prove that radix sort works. Where does your proof need the assumption that the intermediate sort is stable?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 8.3-4</span></span><a name="546"></a><a name="ch08ex16"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show how to sort <i class="emphasis">n</i> integers in the range 0 to <i class="emphasis">n</i><sup>2</sup> - 1 in <i class="emphasis">O</i>(<i class="emphasis">n</i>) time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 8.3-5: </span><span class="unicode">&#8902;</span></span><a name="547"></a><a name="ch08ex17"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">In the first card-sorting algorithm in this section, exactly how many sorting passes are needed to sort <i class="emphasis">d</i>-digit decimal numbers in the worst case? How many piles of cards would an operator need to keep track of in the worst case?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="548"></a><a name="IDX-174"></a>
<div class="section">
<h3 class="sect3-title">
<a name="549"></a><a name="ch08lev1sec4"></a><span class="section-titlelabel">8.4 </span>Bucket sort</h3>
<p class="first-para">
<b class="bold"><i class="emphasis">Bucket sort</i></b> runs in linear time when the input is drawn from a uniform distribution. Like counting sort, bucket sort is fast because it assumes something about the input. Whereas counting sort assumes that the input consists of integers in a small range, bucket sort assumes that the input is generated by a random process that distributes elements uniformly over the interval [0, 1). (See <a href="DDU0254.html#3444" target="_parent" class="chapterjump">Section C.2</a> for a definition of uniform distribution.)</p>
<p class="para">The idea of bucket sort is to divide the interval [0, 1) into <i class="emphasis">n</i> equal-sized subintervals, or <b class="bold"><i class="emphasis">buckets</i></b>, and then distribute the <i class="emphasis">n</i> input numbers into the buckets. Since the inputs are uniformly distributed over [0, 1), we don't expect many numbers to fall into each bucket. To produce the output, we simply sort the numbers in each bucket and then go through the buckets in order, listing the elements in each.</p>
<p class="para">Our code for bucket sort assumes that the input is an <i class="emphasis">n</i>-element array <i class="emphasis">A</i> and that each element <i class="emphasis">A</i>[<i class="emphasis">i</i>] in the array satisfies 0 <span class="unicode">&le;</span> <i class="emphasis">A</i>[<i class="emphasis">i</i>] <i class="emphasis"><span class="unicode">&lt;</span></i> 1. The code requires an auxiliary array <i class="emphasis">B</i>[0 <span class="unicode">&#8229;</span> <i class="emphasis">n</i> - 1] of linked lists (buckets) and assumes that there is a mechanism for maintaining such lists. (<a href="DDU0059.html#638" target="_parent" class="chapterjump">Section 10.2</a> describes how to implement basic operations on linked lists.)</p>
<div class="informalexample">
<pre class="literallayout-normal">
BUCKET-SORT(<i class="emphasis">A</i>)
1  <i class="emphasis">n</i> <span class="unicode">&larr;</span> <i class="emphasis">length</i>[<i class="emphasis">A</i>]
2  <b class="bold">for</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">n</i>
3     <b class="bold">do</b> insert <i class="emphasis">A</i>[<i class="emphasis">i</i>] into list <i class="emphasis">B</i>[<span class="unicode">&lfloor;</span><i class="emphasis">n A</i>[<i class="emphasis">i</i>]<span class="unicode">&rfloor;</span>]
4  <b class="bold">for</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> 0 <b class="bold">to</b> <i class="emphasis">n</i> - 1
5     <b class="bold">do</b> sort list <i class="emphasis">B</i>[<i class="emphasis">i</i>] with insertion sort
6  concatenate the lists <i class="emphasis">B</i>[0], <i class="emphasis">B</i>[1], . . ., <i class="emphasis">B</i>[<i class="emphasis">n</i> - 1] together in order
</pre>
</div>
<p class="para">
<a class="internaljump" href="#ch08fig04">Figure 8.4</a> shows the operation of bucket sort on an input array of 10 numbers.</p>
<div class="figure">
<a name="550"></a><a name="ch08fig04"></a><span class="figuremediaobject"><a href="images/fig197%5F01%5F0%2Ejpg" NAME="IMG_295" target="_parent"><img src="images/fig197_01.jpg" height="193" width="236" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 8.4: </span>The operation of BUCKET-SORT. <i class="emphasis">(a)</i> The input array <i class="emphasis">A</i>[1 <span class="unicode">&#8229;</span> 10]. <i class="emphasis">(b)</i> The array <i class="emphasis">B</i>[0 <span class="unicode">&#8229;</span> 9] of sorted lists (buckets) after line 5 of the algorithm. Bucket <i class="emphasis">i</i> holds values in the half-open interval [<i class="emphasis">i</i>/10, (<i class="emphasis">i</i> + 1)/10). The sorted output consists of a concatenation in order of the lists <i class="emphasis">B</i>[0], <i class="emphasis">B</i>[1], . . ., <i class="emphasis">B</i>[9].</span>
</div>
<p class="para">To see that this algorithm works, consider two elements <i class="emphasis">A</i>[<i class="emphasis">i</i>] and <i class="emphasis">A</i>[<i class="emphasis">j</i>]. Assume without loss of generality that <i class="emphasis">A</i>[<i class="emphasis">i</i>] <span class="unicode">&le;</span> <i class="emphasis">A</i>[<i class="emphasis">j</i>]. Since <span class="unicode">&lfloor;</span><i class="emphasis">n A</i>[<i class="emphasis">i</i>]<span class="unicode">&rfloor;</span> <span class="unicode">&lfloor;</span><i class="emphasis">n A</i>[<i class="emphasis">j</i>]<span class="unicode">&rfloor;</span>, element <i class="emphasis">A</i>[<i class="emphasis">i</i>] is placed either into the same bucket as <i class="emphasis">A</i>[<i class="emphasis">j</i>] or into a bucket with a lower index. If <i class="emphasis">A</i>[<i class="emphasis">i</i>] and <i class="emphasis">A</i>[<i class="emphasis">j</i>] are placed into the same bucket, then the <b class="bold">for</b> loop of lines 4<span class="unicode">-</span>5 puts them into the proper order. If <i class="emphasis">A</i>[<i class="emphasis">i</i>] and <i class="emphasis">A</i>[<i class="emphasis">j</i>] are placed into different buckets, then line 6 puts them into the proper order. Therefore, bucket sort works correctly.</p>
<p class="para">To analyze the running time, observe that all lines except line 5 take <i class="emphasis">O</i>(<i class="emphasis">n</i>) time in the worst case. It remains to balance the total time taken by the <i class="emphasis">n</i> calls to insertion sort in line 5.</p>
<p class="para">To analyze the cost of the calls to insertion sort, let <i class="emphasis">n<sub>i</sub></i> be the random variable denoting the number of elements placed in bucket <i class="emphasis">B</i>[<i class="emphasis">i</i>]. Since insertion sort runs in quadratic time (see <a href="DDU0015.html#74" target="_parent" class="chapterjump">Section 2.2</a>), the running time of bucket sort is<a name="551"></a><a name="IDX-175"></a>
</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig197_02.jpg" height="43" width="167" alt="" border="0"></span>
</div>
<p class="para">Taking expectations of both sides and using linearity of expectation, we have</p>
<div class="equation">
<a name="552"></a><a name="ch08eq01"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(8.1)&nbsp;</span></td><td valign="top"><span class="equation-image"><a href="images/fig197%5F03%2Ejpg" NAME="IMG_297" target="_parent"><img src="images/fig197_03.jpg" height="139" width="400" alt="Click To expand" border="0"></a></span></td>
</tr>
</table>
</div>
<p class="para">We claim that</p>
<div class="equation">
<a name="553"></a><a name="ch08eq02"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(8.2)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig197_04.jpg" height="20" width="103" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">for <i class="emphasis">i</i> = 0, 1, . . ., <i class="emphasis">n</i> - 1. It is no surprise that each bucket <i class="emphasis">i</i> has the same value of <span class="inlinemediaobject"><img src="images/fig197_05.jpg" height="14" width="27" alt="" border="0"></span>, since each value in the input array <i class="emphasis">A</i> is equally likely to fall in any bucket. To prove <a class="internaljump" href="#ch08eq02">equation (8.2)</a>, we define indicator random variables</p>
<p class="para">
<i class="emphasis">X<sub>ij</sub></i> = I{<i class="emphasis">A</i>[<i class="emphasis">j</i>] falls in bucket <i class="emphasis">i</i>}</p>
<p class="para">for <i class="emphasis">i</i> = 0, 1, . . ., <i class="emphasis">n</i> - 1 and <i class="emphasis">j</i> = 1, 2, . . ., <i class="emphasis">n</i>. Thus,<a name="554"></a><a name="IDX-176"></a>
</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig198_01.jpg" height="41" width="83" alt="" border="0"></span>
</div>
<p class="para">To compute <span class="inlinemediaobject"><img src="images/fig198_02.jpg" height="14" width="26" alt="" border="0"></span>, we expand the square and regroup terms:</p>
<div class="equation">
<a name="555"></a><a name="ch08eq03"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(8.3)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig198_03.jpg" height="216" width="300" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">where the last line follows by linearity of expectation. We evaluate the two summations separately. Indicator random variable <i class="emphasis">X<sub>ij</sub></i> is 1 with probability 1/<i class="emphasis">n</i> and 0 otherwise, and therefore</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig198_04.jpg" height="73" width="202" alt="" border="0"></span>
</div>
<p class="para">When <i class="emphasis">k</i> <span class="unicode">&ne;</span> <i class="emphasis">j</i>, the variables <i class="emphasis">X<sub>ij</sub></i> and <i class="emphasis">X<sub>ik</sub></i> are independent, and hence</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig198_05.jpg" height="89" width="186" alt="" border="0"></span>
</div>
<p class="para">Substituting these two expected values in <a class="internaljump" href="#ch08eq03">equation (8.3)</a>, we obtain</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig198_06.jpg" height="161" width="213" alt="" border="0"></span>
</div>
<a name="556"></a><a name="IDX-177"></a>
<p class="para">which proves <a class="internaljump" href="#ch08eq02">equation (8.2)</a>.</p>
<p class="para">Using this expected value in <a class="internaljump" href="#ch08eq01">equation (8.1)</a>, we conclude that the expected time for bucket sort is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) + <i class="emphasis">n</i> <span class="unicode">&middot;</span> <i class="emphasis">O</i>(2 - 1/<i class="emphasis">n</i>) = <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>). Thus, the entire bucket sort algorithm runs in linear expected time.</p>
<p class="para">Even if the input is not drawn from a uniform distribution, bucket sort may still run in linear time. As long as the input has the property that the sum of the squares of the bucket sizes is linear in the total number of elements, <a class="internaljump" href="#ch08eq01">equation (8.1)</a> tells us that bucket sort will run in linear time.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 8.4-1</span></span><a name="557"></a><a name="ch08ex18"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Using <a class="internaljump" href="#ch08fig04">Figure 8.4</a> as a model, illustrate the operation of BUCKET-SORT on the array <i class="emphasis">A</i> = <span class="unicode">&#12296;</span>.79, .13, .16, .64, .39, .20, .89, .53, .71, .42<span class="unicode">&#12297;</span>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 8.4-2</span></span><a name="558"></a><a name="ch08ex19"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">What is the worst-case running time for the bucket-sort algorithm? What simple change to the algorithm preserves its linear expected running time and makes its worst-case running time <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>)?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 8.4-3</span></span><a name="559"></a><a name="ch08ex20"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">X</i> be a random variable that is equal to the number of heads in two flips of a fair coin. What is E [<i class="emphasis">X</i><sup>2</sup>]? What is E<sup>2</sup> [<i class="emphasis">X</i>]?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 8.4-4: </span><span class="unicode">&#8902;</span></span><a name="560"></a><a name="ch08ex21"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">We are given <i class="emphasis">n</i> points in the unit circle, <i class="emphasis">p<sub>i</sub></i> = (<i class="emphasis">x<sub>i</sub></i>, <i class="emphasis">y<sub>i</sub></i>), such that <span class="inlinemediaobject"><img src="images/fig199_01.jpg" height="14" width="78" alt="" border="0"></span> for <i class="emphasis">i</i> = 1, 2, . . ., <i class="emphasis">n</i>. Suppose that the points are uniformly distributed; that is, the probability of finding a point in any region of the circle is proportional to the area of that region. Design a <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) expected-time algorithm to sort the <i class="emphasis">n</i> points by their distances <span class="inlinemediaobject"><img src="images/fig199_02.jpg" height="22" width="71" alt="" border="0"></span> from the origin. (<i class="emphasis">Hint:</i> Design the bucket sizes in BUCKET-SORT to reflect the uniform distribution of the points in the unit circle.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 8.4-5: </span><span class="unicode">&#8902;</span></span><a name="561"></a><a name="ch08ex22"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">A <b class="bold"><i class="emphasis">probability distribution function</i></b> <i class="emphasis">P</i>(<i class="emphasis">x</i>) for a random variable <i class="emphasis">X</i> is defined by <i class="emphasis">P</i>(<i class="emphasis">x</i>) = Pr {<i class="emphasis">X</i> <span class="unicode">&le;</span> <i class="emphasis">x</i>}. Suppose that a list of <i class="emphasis">n</i> random variables <i class="emphasis">X</i><sub>1</sub>, <i class="emphasis">X</i><sub>2</sub>, . . .,<i class="emphasis">X<sub>n</sub></i> is drawn from a continuous probability distribution function <i class="emphasis">P</i> that is computable in <i class="emphasis">O</i>(1) time. Show how to sort these numbers in linear expected time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="562"></a><a name="IDX-178"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 8-1: </span>Average-case lower bounds on comparison sorting</span><a name="563"></a><a name="ch08ex23"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">In this problem, we prove an <span class="unicode">&#8486;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) lower bound on the expected running time of any deterministic or randomized comparison sort on <i class="emphasis">n</i> distinct input elements. We begin by examining a deterministic comparison sort <i class="emphasis">A</i> with decision tree <i class="emphasis">T<sub>A</sub></i>. We assume that every permutation of <i class="emphasis">A</i>'s inputs is equally likely.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Suppose that each leaf of <i class="emphasis">T<sub>A</sub></i> is labeled with the probability that it is reached given a random input. Prove that exactly <i class="emphasis">n</i>! leaves are labeled 1/<i class="emphasis">n</i>! and that the rest are labeled 0.</p>
</li>
<li class="listitem">
<p class="first-para">Let <i class="emphasis">D</i>(<i class="emphasis">T</i>) denote the external path length of a decision tree <i class="emphasis">T</i> ; that is, <i class="emphasis">D</i>(<i class="emphasis">T</i>) is the sum of the depths of all the leaves of <i class="emphasis">T</i>. Let <i class="emphasis">T</i> be a decision tree with <i class="emphasis">k</i> <span class="unicode">&gt;</span> 1 leaves, and let <i class="emphasis">LT</i> and <i class="emphasis">RT</i> be the left and right subtrees of <i class="emphasis">T</i>. Show that <i class="emphasis">D</i>(<i class="emphasis">T</i>) = <i class="emphasis">D</i>(<i class="emphasis">LT</i>) + <i class="emphasis">D</i>(<i class="emphasis">RT</i>) + <i class="emphasis">k</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Let <i class="emphasis">d</i>(<i class="emphasis">k</i>) be the minimum value of <i class="emphasis">D</i>(<i class="emphasis">T</i>) over all decision trees <i class="emphasis">T</i> with <i class="emphasis">k</i> <span class="unicode">&gt;</span> 1 leaves. Show that <i class="emphasis">d</i>(<i class="emphasis">k</i>) = min<sub><span class="unicode">&le;</span><i class="emphasis">i</i><span class="unicode">&le;</span><i class="emphasis">k</i>-1</sub> {<i class="emphasis">d</i>(<i class="emphasis">i</i>) + <i class="emphasis">d</i>(<i class="emphasis">k</i> - <i class="emphasis">i</i>) + <i class="emphasis">k</i>}. (<i class="emphasis">Hint:</i> Consider a decision tree <i class="emphasis">T</i> with <i class="emphasis">k</i> leaves that achieves the minimum. Let <i class="emphasis">i</i><sub>0</sub> be the number of leaves in <i class="emphasis">LT</i> and <i class="emphasis">k</i> - <i class="emphasis">i</i><sub>0</sub> the number of leaves in <i class="emphasis">RT</i>.)</p>
</li>
<li class="listitem">
<p class="first-para">Prove that for a given value of <i class="emphasis">k</i> <span class="unicode">&gt;</span> 1 and <i class="emphasis">i</i> in the range 1 <span class="unicode">&le;</span> <i class="emphasis">i</i> <i class="emphasis">k</i> - 1, the function <i class="emphasis">i</i> lg <i class="emphasis">i</i> + (<i class="emphasis">k</i> - <i class="emphasis">i</i>) lg(<i class="emphasis">k</i> - <i class="emphasis">i</i>) is minimized at <i class="emphasis">i</i> = <i class="emphasis">k</i>/2. Conclude that <i class="emphasis">d</i>(<i class="emphasis">k</i>) = <span class="unicode">&Theta;</span>(<i class="emphasis">k</i> lg <i class="emphasis">k)</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Prove that <i class="emphasis">D</i>(<i class="emphasis">T<sub>A</sub></i>) = <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>! lg(<i class="emphasis">n</i>!)), and conclude that the expected time to sort <i class="emphasis">n</i> elements is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>).</p>
</li>
</ol>
<p class="para">Now, consider a <i class="emphasis">randomized</i> comparison sort <i class="emphasis">B</i>. We can extend the decision-tree model to handle randomization by incorporating two kinds of nodes: ordinary comparison nodes and "randomization" nodes. A randomization node models a random choice of the form RANDOM(1, <i class="emphasis">r</i>) made by algorithm <i class="emphasis">B</i>; the node has <i class="emphasis">r</i> children, each of which is equally likely to be chosen during an execution of the algorithm.</p>
<ol class="orderedlist" start="6" type="a">
<li class="first-listitem">
<p class="first-para">Show that for any randomized comparison sort <i class="emphasis">B</i>, there exists a deterministic comparison sort <i class="emphasis">A</i> that makes no more comparisons on the average than <i class="emphasis">B</i> does.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 8-2: </span>Sorting in place in linear time</span><a name="564"></a><a name="ch08ex24"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that we have an array of <i class="emphasis">n</i> data records to sort and that the key of each record has the value 0 or 1. An algorithm for sorting such a set of records might possess some subset of the following three desirable characteristics:<a name="565"></a><a name="IDX-179"></a>
</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="first-para">The algorithm runs in <i class="emphasis">O</i>(<i class="emphasis">n</i>) time.</p>
</li>
<li class="listitem">
<p class="first-para">The algorithm is stable.</p>
</li>
<li class="listitem">
<p class="first-para">The algorithm sorts in place, using no more than a constant amount of storage space in addition to the original array.</p>
</li>
</ol>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Give an algorithm that satisfies criteria 1 and 2 above.</p>
</li>
<li class="listitem">
<p class="first-para">Give an algorithm that satisfies criteria 1 and 3 above.</p>
</li>
<li class="listitem">
<p class="first-para">Give an algorithm that satisfies criteria 2 and 3 above.</p>
</li>
<li class="listitem">
<p class="first-para">Can any of your sorting algorithms from parts (a)<span class="unicode">-</span>(c) be used to sort <i class="emphasis">n</i> records with <i class="emphasis">b</i>-bit keys using radix sort in <i class="emphasis">O</i>(<i class="emphasis">bn</i>) time? Explain how or why not.</p>
</li>
<li class="listitem">
<p class="first-para">Suppose that the <i class="emphasis">n</i> records have keys in the range from 1 to <i class="emphasis">k</i>. Show how to modify counting sort so that the records can be sorted in place in <i class="emphasis">O</i>(<i class="emphasis">n</i> + <i class="emphasis">k</i>) time. You may use <i class="emphasis">O</i>(<i class="emphasis">k</i>) storage outside the input array. Is your algorithm stable? (<i class="emphasis">Hint:</i> How would you do it for <i class="emphasis">k</i> = 3?)</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 8-3: </span>Sorting variable-length items</span><a name="566"></a><a name="ch08ex25"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">You are given an array of integers, where different integers may have different numbers of digits, but the total number of digits over <i class="emphasis">all</i> the integers in the array is <i class="emphasis">n</i>. Show how to sort the array in <i class="emphasis">O</i>(<i class="emphasis">n</i>) time.</p>
</li>
<li class="listitem">
<p class="first-para">You are given an array of strings, where different strings may have different numbers of characters, but the total number of characters over all the strings is <i class="emphasis">n</i>. Show how to sort the strings in <i class="emphasis">O</i>(<i class="emphasis">n</i>) time.</p>
<p class="last-para">(Note that the desired order here is the standard alphabetical order; for example, <span class="fixed">a <span class="unicode">&lt;</span> ab <span class="unicode">&lt;</span> b</span>.)</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 8-4: </span>Water jugs</span><a name="567"></a><a name="ch08ex26"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that you are given <i class="emphasis">n</i> red and <i class="emphasis">n</i> blue water jugs, all of different shapes and sizes. All red jugs hold different amounts of water, as do the blue ones. Moreover, for every red jug, there is a blue jug that holds the same amount of water, and vice versa.</p>
<p class="para">It is your task to find a grouping of the jugs into pairs of red and blue jugs that hold the same amount of water. To do so, you may perform the following operation: pick a pair of jugs in which one is red and one is blue, fill the red jug with water, and then pour the water into the blue jug. This operation will tell you whether the red or the blue jug can hold more water, or if they are of the same volume. Assume that such a comparison takes one time unit. Your goal is to find an algorithm that <a name="568"></a><a name="IDX-180"></a>makes a minimum number of comparisons to determine the grouping. Remember that you may not directly compare two red jugs or two blue jugs.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Describe a deterministic algorithm that uses <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>2</sup>) comparisons to group the jugs into pairs.</p>
</li>
<li class="listitem">
<p class="first-para">Prove a lower bound of <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) for the number of comparisons an algorithm solving this problem must make.</p>
</li>
<li class="listitem">
<p class="first-para">Give a randomized algorithm whose expected number of comparisons is <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>), and prove that this bound is correct. What is the worst-case number of comparisons for your algorithm?</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 8-5: </span>Average sorting</span><a name="569"></a><a name="ch08ex27"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that, instead of sorting an array, we just require that the elements increase on average. More precisely, we call an <i class="emphasis">n</i>-element array <i class="emphasis">A</i> <b class="bold"><i class="emphasis">k-sorted</i></b> if, for all <i class="emphasis">i</i> = 1, 2, . . ., <i class="emphasis">n</i> - <i class="emphasis">k</i>, the following holds:</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig202_01.jpg" height="40" width="185" alt="" border="0"></span>
</div>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">What does it mean for an array to be 1-sorted?</p>
</li>
<li class="listitem">
<p class="first-para">Give a permutation of the numbers 1, 2, . . ., 10 that is 2-sorted, but not sorted.</p>
</li>
<li class="listitem">
<p class="first-para">Prove that an <i class="emphasis">n</i>-element array is <i class="emphasis">k</i>-sorted if and only if <i class="emphasis">A</i>[<i class="emphasis">i</i>] <span class="unicode">&le;</span> <i class="emphasis">A</i>[<i class="emphasis">i</i> + <i class="emphasis">k</i>] for all <i class="emphasis">i</i> = 1, 2, . . ., <i class="emphasis">n</i> - <i class="emphasis">k</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Give an algorithm that <i class="emphasis">k</i>-sorts an <i class="emphasis">n</i>-element array in <i class="emphasis">O</i>(<i class="emphasis">n</i> lg(<i class="emphasis">n</i>/<i class="emphasis">k</i>)) time.</p>
</li>
</ol>
<p class="para">We can also show a lower bound on the time to produce a <i class="emphasis">k</i>-sorted array, when <i class="emphasis">k</i> is a constant.</p>
<ol class="orderedlist" start="5" type="a">
<li class="first-listitem">
<p class="first-para">Show that a <i class="emphasis">k</i>-sorted array of length <i class="emphasis">n</i> can be sorted in <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">k</i>) time. (<i class="emphasis">Hint:</i> Use the solution to <a href="DDU0040.html#438" target="_parent" class="chapterjump">Exercise 6.5-8</a>.)</p>
</li>
<li class="listitem">
<p class="first-para">Show that when <i class="emphasis">k</i> is a constant, it requires <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) time to <i class="emphasis">k</i>-sort an <i class="emphasis">n</i>-element array. (<i class="emphasis">Hint:</i> Use the solution to the previous part along with the lower bound on comparison sorts.)</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 8-6: </span>Lower bound on merging sorted lists</span><a name="570"></a><a name="ch08ex28"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The problem of merging two sorted lists arises frequently. It is used as a subroutine of MERGE-SORT, and the procedure to merge two sorted lists is given as MERGE in <a href="DDU0016.html#90" target="_parent" class="chapterjump">Section 2.3.1.</a> In this problem, we will show that there is a lower bound of 2<i class="emphasis">n</i> - 1 <a name="571"></a><a name="IDX-181"></a>on the worst-case number of comparisons required to merge two sorted lists, each containing <i class="emphasis">n</i> items.</p>
<p class="para">First we will show a lower bound of 2<i class="emphasis">n</i> - <i class="emphasis">o</i>(<i class="emphasis">n</i>) comparisons by using a decision tree.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Show that, given 2<i class="emphasis">n</i> numbers, there are <span class="inlinemediaobject"><img src="images/fig203_01.jpg" height="16" width="15" alt="" border="0"></span> possible ways to divide them into two sorted lists, each with <i class="emphasis">n</i> numbers.</p>
</li>
<li class="listitem">
<p class="first-para">Using a decision tree, show that any algorithm that correctly merges two sorted lists uses at least 2<i class="emphasis">n</i> - <i class="emphasis">o</i>(<i class="emphasis">n</i>) comparisons.</p>
</li>
</ol>
<p class="para">Now we will show a slightly tighter 2<i class="emphasis">n</i> - 1 bound.</p>
<ol class="orderedlist" start="3" type="a">
<li class="first-listitem">
<p class="first-para">Show that if two elements are consecutive in the sorted order and from opposite lists, then they must be compared.</p>
</li>
<li class="listitem">
<p class="first-para">Use your answer to the previous part to show a lower bound of 2<i class="emphasis">n</i> - 1 comparisons for merging two sorted lists.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0049.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0051.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
