<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title></title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0056.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0058.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="part">
<a name="pt03"></a>
<h1 class="part-title">
<span class="chapter-titlelabel">Part III: </span>Data Structures</h1>
<div name="listofchapters">
<h2 class="lot-title">Chapter List</h2>
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0058.html#620" target="_parent" class="chapterjump">Chapter 10:</a> Elementary Data Structures</dt>
<dt class="lotentry">
<a href="DDU0063.html#698" target="_parent" class="chapterjump">Chapter 11:</a> Hash Tables</dt>
<dt class="lotentry">
<a href="DDU0070.html#793" target="_parent" class="chapterjump">Chapter 12:</a> Binary Search Trees</dt>
<dt class="lotentry">
<a href="DDU0076.html#861" target="_parent" class="chapterjump">Chapter 13:</a> Red-Black Trees</dt>
<dt class="lotentry">
<a href="DDU0081.html#945" target="_parent" class="chapterjump">Chapter 14:</a> Augmenting Data Structures</dt>
</dl>
</div>
</div>
<div class="partintro">
<h3 class="partintro-title">

</h3>
<a name="616"></a><a name="IDX-196"></a><a name="617"></a><a name="IDX-197"></a>
<div class="section">
<h2 class="sect2-title">Introduction</h2>
<p class="first-para">Sets are as fundamental to computer science as they are to mathematics. Whereas mathematical sets are unchanging, the sets manipulated by algorithms can grow, shrink, or otherwise change over time. We call such sets <b class="bold"><i class="emphasis">dynamic</i></b>. The next five chapters present some basic techniques for representing finite dynamic sets and manipulating them on a computer.</p>
<p class="para">Algorithms may require several different types of operations to be performed on sets. For example, many algorithms need only the ability to insert elements into, delete elements from, and test membership in a set. A dynamic set that supports these operations is called a <b class="bold"><i class="emphasis">dictionary</i></b>. Other algorithms require more complicated operations. For example, min-priority queues, which were introduced in <a href="DDU0035.html#382" target="_parent" class="chapterjump">Chapter 6</a> in the context of the heap data structure, support the operations of inserting an element into and extracting the smallest element from a set. The best way to implement a dynamic set depends upon the operations that must be supported.</p>
<div class="section">
<h3 class="sect3-title">Elements of a dynamic set</h3>
<p class="first-para">In a typical implementation of a dynamic set, each element is represented by an object whose fields can be examined and manipulated if we have a pointer to the object. (<a href="DDU0060.html#658" target="_parent" class="chapterjump">Section 10.3</a> discusses the implementation of objects and pointers in programming environments that do not contain them as basic data types.) Some kinds of dynamic sets assume that one of the object's fields is an identifying <b class="bold"><i class="emphasis">key</i></b> field. If the keys are all different, we can think of the dynamic set as being a set of key values. The object may contain <b class="bold"><i class="emphasis">satellite data</i></b>, which are carried around in other object fields but are otherwise unused by the set implementation. It may also have <a name="618"></a><a name="IDX-198"></a>fields that are manipulated by the set operations; these fields may contain data or pointers to other objects in the set.</p>
<p class="last-para">Some dynamic sets presuppose that the keys are drawn from a totally ordered set, such as the real numbers, or the set of all words under the usual alphabetic ordering. (A totally ordered set satisfies the trichotomy property, defined on page 49.) A total ordering allows us to define the minimum element of the set, for example, or speak of the next element larger than a given element in a set.</p>

</div>
<div class="section">
<h3 class="sect3-title">Operations on dynamic sets</h3>
<p class="first-para">Operations on a dynamic set can be grouped into two categories: <b class="bold"><i class="emphasis">queries</i></b>, which simply return information about the set, and <b class="bold"><i class="emphasis">modifying operations</i></b>, which change the set. Here is a list of typical operations. Any specific application will usually require only a few of these to be implemented.</p>
<p class="para">SEARCH(<i class="emphasis">S</i>, <i class="emphasis">k</i>)</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">A query that, given a set <i class="emphasis">S</i> and a key value <i class="emphasis">k</i>, returns a pointer <i class="emphasis">x</i> to an element in <i class="emphasis">S</i> such that <i class="emphasis">key</i>[<i class="emphasis">x</i>] = <i class="emphasis">k</i>, or NIL if no such element belongs to <i class="emphasis">S</i>.</p>
</li>
</ul>
<p class="para">INSERT(<i class="emphasis">S</i>, <i class="emphasis">x</i>)</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">A modifying operation that augments the set <i class="emphasis">S</i> with the element pointed to by <i class="emphasis">x</i>. We usually assume that any fields in element <i class="emphasis">x</i> needed by the set implementation have already been initialized.</p>
</li>
</ul>
<p class="para">DELETE(<i class="emphasis">S</i>, <i class="emphasis">x</i>)</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">A modifying operation that, given a pointer <i class="emphasis">x</i> to an element in the set <i class="emphasis">S</i>, removes <i class="emphasis">x</i> from <i class="emphasis">S</i>. (Note that this operation uses a pointer to an element <i class="emphasis">x</i>, not a key value.)</p>
</li>
</ul>
<p class="para">MINIMUM(<i class="emphasis">S</i>)</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">A query on a totally ordered set <i class="emphasis">S</i> that returns a pointer to the element of <i class="emphasis">S</i> with the smallest key.</p>
</li>
</ul>
<p class="para">MAXIMUM(<i class="emphasis">S</i>)</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">A query on a totally ordered set <i class="emphasis">S</i> that returns a pointer to the element of <i class="emphasis">S</i> with the largest key.</p>
</li>
</ul>
<p class="para">SUCCESSOR(<i class="emphasis">S</i>, <i class="emphasis">x</i>)</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">A query that, given an element <i class="emphasis">x</i> whose key is from a totally ordered set <i class="emphasis">S</i>, returns a pointer to the next larger element in <i class="emphasis">S</i>, or NIL if <i class="emphasis">x</i> is the maximum element.</p>
</li>
</ul>
<p class="para">PREDECESSOR(<i class="emphasis">S</i>, <i class="emphasis">x</i>)</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">A query that, given an element <i class="emphasis">x</i> whose key is from a totally ordered set <i class="emphasis">S</i>, returns a pointer to the next smaller element in <i class="emphasis">S</i>, or NIL if <i class="emphasis">x</i> is the minimum element.</p>
</li>
</ul>
<a name="619"></a><a name="IDX-199"></a>
<p class="para">The queries SUCCESSOR and PREDECESSOR are often extended to sets with non-distinct keys. For a set on <i class="emphasis">n</i> keys, the normal presumption is that a call to MINIMUM followed by <i class="emphasis">n</i> - 1 calls to SUCCESSOR enumerates the elements in the set in sorted order.</p>
<p class="last-para">The time taken to execute a set operation is usually measured in terms of the size of the set given as one of its arguments. For example, <a href="DDU0076.html#861" target="_parent" class="chapterjump">Chapter 13</a> describes a data structure that can support any of the operations listed above on a set of size <i class="emphasis">n</i> in time <i class="emphasis">O</i>(lg <i class="emphasis">n</i>).</p>

</div>
<div class="section">
<h3 class="sect3-title">Overview of Part III</h3>
<p class="first-para">Chapters 10<span class="unicode">-</span>14 describe several data structures that can be used to implement dynamic sets; many of these will be used later to construct efficient algorithms for a variety of problems. Another important data structure<span class="unicode">-</span>the heap<span class="unicode">-</span>has already been introduced in <a href="DDU0035.html#382" target="_parent" class="chapterjump">Chapter 6</a>.</p>
<p class="para">
<a href="DDU0058.html#620" target="_parent" class="chapterjump">Chapter 10</a> presents the essentials of working with simple data structures such as stacks, queues, linked lists, and rooted trees. It also shows how objects and pointers can be implemented in programming environments that do not support them as primitives. Much of this material should be familiar to anyone who has taken an introductory programming course.</p>
<p class="para">
<a href="DDU0063.html#698" target="_parent" class="chapterjump">Chapter 11</a> introduces hash tables, which support the dictionary operations INSERT, DELETE, and SEARCH. In the worst case, hashing requires <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) time to perform a SEARCH operation, but the expected time for hash-table operations is <i class="emphasis">O</i>(1). The analysis of hashing relies on probability, but most of the chapter requires no background in the subject.</p>
<p class="para">Binary search trees, which are covered in <a href="DDU0070.html#793" target="_parent" class="chapterjump">Chapter 12</a>, support all the dynamic-set operations listed above. In the worst case, each operation takes <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) time on a tree with <i class="emphasis">n</i> elements, but on a randomly built binary search tree, the expected time for each operation is <i class="emphasis">O</i>(lg <i class="emphasis">n</i>). Binary search trees serve as the basis for many other data structures.</p>
<p class="para">Red-black trees, a variant of binary search trees, are introduced in <a href="DDU0076.html#861" target="_parent" class="chapterjump">Chapter 13</a>. Unlike ordinary binary search trees, red-black trees are guaranteed to perform well: operations take <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) time in the worst case. A red-black tree is a balanced search tree; <a href="DDU0107.html#1323" target="_parent" class="chapterjump">Chapter 18</a> presents another kind of balanced search tree, called a B-tree. Although the mechanics of red-black trees are somewhat intricate, you can glean most of their properties from the chapter without studying the mechanics in detail. Nevertheless, walking through the code can be quite instructive.</p>
<p class="last-para">In <a href="DDU0081.html#945" target="_parent" class="chapterjump">Chapter 14</a>, we show how to augment red-black trees to support operations other than the basic ones listed above. First, we augment them so that we can dynamically maintain order statistics for a set of keys. Then, we augment them in a different way to maintain intervals of real numbers.</p>

</div>

</div>
</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0056.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0058.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
