<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>11.3 Hash functions</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0065.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0067.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch11"></a>
<div class="section">
<h2 class="first-section-title">
<a name="725"></a><a name="ch11lev1sec3"></a><span class="section-titlelabel">11.3 </span>Hash functions</h2>
<p class="first-para">In this section, we discuss some issues regarding the design of good hash functions and then present three schemes for their creation. Two of the schemes, hashing by division and hashing by multiplication, are heuristic in nature, whereas the third scheme, universal hashing, uses randomization to provide provably good performance.</p>
<div class="section">
<h4 class="sect4-title">
<a name="726"></a><a name="ch11lev3sec3"></a>What makes a good hash function?</h4>
<p class="first-para">A good hash function satisfies (approximately) the assumption of simple uniform hashing: each key is equally likely to hash to any of the <i class="emphasis">m</i> slots, independently of where any other key has hashed to. Unfortunately, it is typically not possible to check this condition, since one rarely knows the probability distribution according to which the keys are drawn, and the keys may not be drawn independently.<a name="727"></a><a name="IDX-230"></a>
</p>
<p class="para">Occasionally we do know the distribution. For example, if the keys are known to be random real numbers <i class="emphasis">k</i> independently and uniformly distributed in the range 0 <span class="unicode">&le;</span> <i class="emphasis">k</i> <span class="unicode">&lt;</span> 1, the hash function</p>
<p class="para">
<i class="emphasis">h</i>(<i class="emphasis">k</i>) = <span class="unicode">&lfloor;</span><i class="emphasis">km</i><span class="unicode">&rfloor;</span>
</p>
<p class="para">satisfies the condition of simple uniform hashing.</p>
<p class="para">In practice, heuristic techniques can often be used to create a hash function that performs well. Qualitative information about distribution of keys may be useful in this design process. For example, consider a compiler's symbol table, in which the keys are character strings representing identifiers in a program. Closely related symbols, such as <span class="fixed">pt</span> and <span class="fixed">pts</span>, often occur in the same program. A good hash function would minimize the chance that such variants hash to the same slot.</p>
<p class="para">A good approach is to derive the hash value in a way that is expected to be independent of any patterns that might exist in the data. For example, the "division method" (discussed in <a class="internaljump" href="#ch11lev2sec1">Section 11.3.1</a>) computes the hash value as the remainder when the key is divided by a specified prime number. This method frequently gives good results, assuming that the prime number is chosen to be unrelated to any patterns in the distribution of keys.</p>
<p class="last-para">Finally, we note that some applications of hash functions might require stronger properties than are provided by simple uniform hashing. For example, we might want keys that are "close" in some sense to yield hash values that are far apart. (This property is especially desirable when we are using linear probing, defined in <a href="DDU0067.html#750" target="_parent" class="chapterjump">Section 11.4.</a>) Universal hashing, described in <a class="internaljump" href="#ch11lev2sec3">Section 11.3.3</a>, often provides the desired properties.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="728"></a><a name="ch11lev3sec4"></a>Interpreting keys as natural numbers</h4>
<p class="first-para">Most hash functions assume that the universe of keys is the set <b class="bold">N</b> = {0, 1, 2, ...} of natural numbers. Thus, if the keys are not natural numbers, a way is found to interpret them as natural numbers. For example, a character string can be interpreted as an integer expressed in suitable radix notation. Thus, the identifier <span class="fixed">pt</span> might be interpreted as the pair of decimal integers (112, 116), since <span class="fixed">p</span> = 112 and <span class="fixed">t</span> = 116 in the ASCII character set; then, expressed as a radix-128 integer, <span class="fixed">pt</span> becomes (112<span class="unicode">&middot;</span>128)+116 = 14452. It is usually straightforward in an application to devise some such method for interpreting each key as a (possibly large) natural number. In what follows, we assume that the keys are natural numbers.</p>

</div>
<div class="section">
<h3 class="sect3-title">
<a name="729"></a><a name="ch11lev2sec1"></a><span class="section-titlelabel">11.3.1 </span>The division method</h3>
<p class="first-para">In the <b class="bold"><i class="emphasis">division method</i></b> for creating hash functions, we map a key <i class="emphasis">k</i> into one of <i class="emphasis">m</i> slots by taking the remainder of <i class="emphasis">k</i> divided by <i class="emphasis">m</i>. That is, the hash function is</p>
<p class="para">
<i class="emphasis">h</i>(<i class="emphasis">k</i>) = <i class="emphasis">k</i> mod <i class="emphasis">m</i>.<a name="730"></a><a name="IDX-231"></a>
</p>
<p class="para">For example, if the hash table has size <i class="emphasis">m</i> = 12 and the key is <i class="emphasis">k</i> = 100, then <i class="emphasis">h</i>(<i class="emphasis">k</i>) = 4. Since it requires only a single division operation, hashing by division is quite fast.</p>
<p class="para">When using the division method, we usually avoid certain values of <i class="emphasis">m</i>. For example, <i class="emphasis">m</i> should not be a power of 2, since if <i class="emphasis">m</i> = 2<sup><i class="emphasis">p</i></sup>, then <i class="emphasis">h</i>(<i class="emphasis">k</i>) is just the <i class="emphasis">p</i> lowest-order bits of <i class="emphasis">k</i>. Unless it is known that all low-order <i class="emphasis">p</i>-bit patterns are equally likely, it is better to make the hash function depend on all the bits of the key. As <a class="internaljump" href="#ch11ex17">Exercise 11.3-3</a> asks you to show, choosing <i class="emphasis">m</i> = 2<sup><i class="emphasis">p</i></sup> - 1 when <i class="emphasis">k</i> is a character string interpreted in radix 2<sup><i class="emphasis">p</i></sup> may be a poor choice, because permuting the characters of <i class="emphasis">k</i> does not change its hash value.</p>
<p class="para">A prime not too close to an exact power of 2 is often a good choice for <i class="emphasis">m</i>. For example, suppose we wish to allocate a hash table, with collisions resolved by chaining, to hold roughly <i class="emphasis">n</i> = 2000 character strings, where a character has 8 bits. We don't mind examining an average of 3 elements in an unsuccessful search, so we allocate a hash table of size <i class="emphasis">m</i> = 701. The number 701 is chosen because it is a prime near 2000/3 but not near any power of 2. Treating each key <i class="emphasis">k</i> as an integer, our hash function would be</p>
<p class="last-para">
<i class="emphasis">h</i>(<i class="emphasis">k</i>) = <i class="emphasis">k</i> mod 701.</p>

</div>
<div class="section">
<h3 class="sect3-title">
<a name="731"></a><a name="ch11lev2sec2"></a><span class="section-titlelabel">11.3.2 </span>The multiplication method</h3>
<p class="first-para">The <b class="bold"><i class="emphasis">multiplication method</i></b> for creating hash functions operates in two steps. First, we multiply the key <i class="emphasis">k</i> by a constant <i class="emphasis">A</i> in the range 0 <span class="unicode">&lt;</span> <i class="emphasis">A</i> <span class="unicode">&lt;</span> 1 and extract the fractional part of <i class="emphasis">kA</i>. Then, we multiply this value by <i class="emphasis">m</i> and take the floor of the result. In short, the hash function is</p>
<p class="para">
<i class="emphasis">h</i>(<i class="emphasis">k</i>) = <span class="unicode">&lfloor;</span><i class="emphasis">m</i>(<i class="emphasis">kA</i> mod 1)<span class="unicode">&rfloor;</span>,</p>
<p class="para">where "<i class="emphasis">k A</i> mod 1" means the fractional part of <i class="emphasis">kA</i>, that is, <i class="emphasis">kA</i> - <span class="unicode">&lfloor;</span><i class="emphasis">kA</i><span class="unicode">&rfloor;</span>.</p>
<p class="para">An advantage of the multiplication method is that the value of <i class="emphasis">m</i> is not critical. We typically choose it to be a power of 2 (<i class="emphasis">m</i> = 2<sup><i class="emphasis">p</i></sup> for some integer <i class="emphasis">p</i>) since we can then easily implement the function on most computers as follows. Suppose that the word size of the machine is <i class="emphasis">w</i> bits and that <i class="emphasis">k</i> fits into a single word. We restrict <i class="emphasis">A</i> to be a fraction of the form <i class="emphasis">s</i>/2<sup><i class="emphasis">w</i></sup>, where <i class="emphasis">s</i> is an integer in the range 0 <span class="unicode">&lt;</span> <i class="emphasis">s</i> <span class="unicode">&lt;</span> 2<sup><i class="emphasis">w</i></sup>. Referring to <a class="internaljump" href="#ch11fig04">Figure 11.4</a>, we first multiply <i class="emphasis">k</i> by the <i class="emphasis">w</i>-bit integer <i class="emphasis">s</i> = <i class="emphasis">A</i> <span class="unicode">&middot;</span> 2<sup><i class="emphasis">w</i></sup>. The result is a 2<i class="emphasis">w</i>-bit value <i class="emphasis">r</i><sub>1</sub>2<sup><i class="emphasis">w</i></sup> + <i class="emphasis">r</i><sub>0</sub>, where <i class="emphasis">r</i><sub>1</sub> is the high-order word of the product and <i class="emphasis">r</i><sub>0</sub> is the low-order word of the product. The desired <i class="emphasis">p</i>-bit hash value consists of the <i class="emphasis">p</i> most significant bits of <i class="emphasis">r</i><sub>0</sub>.</p>
<div class="figure">
<a name="732"></a><a name="ch11fig04"></a><span class="figuremediaobject"><a href="images/fig254%5F01%5F0%2Ejpg" NAME="IMG_347" target="_parent"><img src="images/fig254_01.jpg" height="131" width="271" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 11.4: </span>The multiplication method of hashing. The <i class="emphasis">w</i>-bit representation of the key <i class="emphasis">k</i> is multiplied by the <i class="emphasis">w</i>-bit value <i class="emphasis">s</i> = A <span class="unicode">&middot;</span> 2<sup><i class="emphasis">w</i></sup>. The <i class="emphasis">p</i> highest-order bits of the lower <i class="emphasis">w</i>-bit half of the product form the desired hash value <i class="emphasis">h</i>(<i class="emphasis">k</i>).</span>
</div>
<p class="para">Although this method works with any value of the constant <i class="emphasis">A</i>, it works better with some values than with others. The optimal choice depends on the characteristics of the data being hashed. <a href="DDU0259.html#3740" target="_parent" class="chapterjump">Knuth [185]</a> suggests that<a name="733"></a><a name="IDX-232"></a>
</p>
<div class="equation">
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(11.2)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig254_02.jpg" height="21" width="223" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">is likely to work reasonably well.</p>
<p class="last-para">As an example, suppose we have <i class="emphasis">k</i> = 123456, <i class="emphasis">p</i> = 14, <i class="emphasis">m</i> = 2<sup>14</sup> = 16384, and <i class="emphasis">w</i> = 32. Adapting Knuth's suggestion, we choose <i class="emphasis">A</i> to be the fraction of the form <i class="emphasis">s</i>/2<sup>32</sup> that is closest to <span class="inlinemediaobject"><img src="images/fig254_03.jpg" height="14" width="53" alt="" border="0"></span>, so that <i class="emphasis">A</i> = 2654435769/2<sup>32</sup>. Then <i class="emphasis">k</i> <span class="unicode">&middot;</span> <i class="emphasis">s</i> = 327706022297664 = (76300 <span class="unicode">&middot;</span> 2<sup>32</sup>) + 17612864, and so <i class="emphasis">r</i><sub>1</sub> = 76300 and <i class="emphasis">r</i><sub>0</sub> = 17612864. The 14 most significant bits of <i class="emphasis">r</i><sub>0</sub> yield the value <i class="emphasis">h</i>(<i class="emphasis">k</i>) = 67.</p>

</div>
<div class="section">
<h3 class="sect3-title">
<a name="734"></a><a name="ch11lev2sec3"></a><span class="section-titlelabel">11.3.3 </span><span class="unicode">&#9733;</span> Universal hashing</h3>
<p class="para">If a malicious adversary chooses the keys to be hashed by some fixed hash function, then he can choose <i class="emphasis">n</i> keys that all hash to the same slot, yielding an average retrieval time of <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>). Any fixed hash function is vulnerable to such terrible worst-case behavior; the only effective way to improve the situation is to choose the hash function <i class="emphasis">randomly</i> in a way that is <i class="emphasis">independent</i> of the keys that are actually going to be stored. This approach, called <b class="bold"><i class="emphasis">universal hashing</i></b>, can yield provably good performance on average, no matter what keys are chosen by the adversary.</p>
<p class="para">The main idea behind universal hashing is to select the hash function at random from a carefully designed class of functions at the beginning of execution. As in the case of quicksort, randomization guarantees that no single input will always evoke worst-case behavior. Because of the randomization, the algorithm can behave differently on each execution, even for the same input, guaranteeing good average-case performance for any input. Returning to the example of a compiler's symbol table, we find that the programmer's choice of identifiers cannot now cause consistently poor hashing performance. Poor performance occurs only when the compiler chooses a random hash function that causes the set of identifiers to hash <a name="735"></a><a name="IDX-233"></a>poorly, but the probability of this situation occurring is small and is the same for any set of identifiers of the same size.</p>
<p class="para">Let <span class="unicode">&#8459;</span> be a finite collection of hash functions that map a given universe <i class="emphasis">U</i> of keys into the range {0, 1, ..., <i class="emphasis">m</i> - 1}. Such a collection is said to be <b class="bold"><i class="emphasis">universal</i></b> if for each pair of distinct keys <i class="emphasis">k</i>, <i class="emphasis">l</i> <span class="unicode">&isin;</span> <i class="emphasis">U</i> , the number of hash functions <i class="emphasis">h</i> <span class="unicode">&isin;</span> <span class="unicode">&#8459;</span> for which <i class="emphasis">h</i>(<i class="emphasis">k</i>) = <i class="emphasis">h</i>(<i class="emphasis">l</i>) is at most |<span class="unicode">&#8459;</span>| /<i class="emphasis">m</i>. In other words, with a hash function randomly chosen from <span class="unicode">&#8459;</span>, the chance of a collision between distinct keys <i class="emphasis">k</i> and <i class="emphasis">l</i> is no more than the chance 1/<i class="emphasis">m</i> of a collision if <i class="emphasis">h</i>(<i class="emphasis">k</i>) and <i class="emphasis">h</i>(<i class="emphasis">l</i>) were randomly and independently chosen from the set {0, 1, ..., <i class="emphasis">m</i> - 1}.</p>
<p class="para">The following theorem shows that a universal class of hash functions gives good average-case behavior. Recall that <i class="emphasis">n<sub>i</sub></i> denotes the length of list <i class="emphasis">T</i>[<i class="emphasis">i</i>].</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 11.3</span></span><a name="736"></a><a name="ch11ex12"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that a hash function <i class="emphasis">h</i> is chosen from a universal collection of hash functions and is used to hash <i class="emphasis">n</i> keys into a table <i class="emphasis">T</i> of size <i class="emphasis">m</i>, using chaining to resolve collisions. If key <i class="emphasis">k</i> is not in the table, then the expected length E[<i class="emphasis">n<sub>h(k)</sub></i>] of the list that key <i class="emphasis">k</i> hashes to is at most <span class="unicode">&alpha;</span>. If key <i class="emphasis">k</i> is in the table, then the expected length E[<i class="emphasis">n<sub>h(k)</sub></i>] of the list containing key <i class="emphasis">k</i> is at most 1 + <span class="unicode">&alpha;</span>.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> We note that the expectations here are over the choice of the hash function, and do not depend on any assumptions about the distribution of the keys. For each pair <i class="emphasis">k</i> and <i class="emphasis">l</i> of distinct keys, define the indicator random variable <i class="emphasis">X<sub>kl</sub></i> = I{<i class="emphasis">h</i>(<i class="emphasis">k</i>) = <i class="emphasis">h</i>(<i class="emphasis">l</i>)}. Since by definition, a single pair of keys collides with probability at most 1/<i class="emphasis">m</i>, we have Pr{<i class="emphasis">h</i>(<i class="emphasis">k</i>) = <i class="emphasis">h</i>(<i class="emphasis">l</i>)} <span class="unicode">&le;</span> 1/<i class="emphasis">m</i>, and so <a href="DDU0030.html#311" target="_parent" class="chapterjump">Lemma 5.1</a> implies that E[<i class="emphasis">X<sub>kl</sub></i>] <span class="unicode">&le;</span> 1/<i class="emphasis">m</i>.</p>
<p class="para">Next we define, for each key <i class="emphasis">k</i>, the random variable <i class="emphasis">Y<sub>k</sub></i> that equals the number of keys other than <i class="emphasis">k</i> that hash to the same slot as <i class="emphasis">k</i>, so that</p>
<p class="para">
<div class="informalequation">
<span class="equation-image"><img src="images/fig255_01.jpg" height="43" width="85" alt="" border="0"></span>
</div>
</p>
<p class="para">Thus we have</p>
<p class="para">
<div class="informalequation">
<span class="equation-image"><img src="images/fig255_02.jpg" height="145" width="322" alt="" border="0"></span>
</div>
</p>
<p class="para">The remainder of the proof depends on whether key <i class="emphasis">k</i> is in table <i class="emphasis">T</i>.<a name="737"></a><a name="IDX-234"></a>
</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">If <i class="emphasis">k</i> <span class="unicode">&notin;</span> <i class="emphasis">T</i>, then <i class="emphasis">n<sub>h(k)</sub></i> = <i class="emphasis">Y<sub>k</sub></i> and |{<i class="emphasis">l</i> : <i class="emphasis">l</i> <span class="unicode">&isin;</span> <i class="emphasis">T</i> and <i class="emphasis">l</i> <span class="unicode">&ne;</span> <i class="emphasis">k</i>}| = <i class="emphasis">n</i>. Thus E[<i class="emphasis">n<sub>h(k)</sub></i>] = E[<i class="emphasis">Y<sub>k</sub></i>] <span class="unicode">&le;</span> <i class="emphasis">n</i>/<i class="emphasis">m</i> = <span class="unicode">&alpha;</span>.</p>
</li>
<li class="listitem">
<p class="first-para">If <i class="emphasis">k</i> <span class="unicode">&isin;</span> <i class="emphasis">T</i> , then because key <i class="emphasis">k</i> appears in list <i class="emphasis">T</i>[<i class="emphasis">h</i>(<i class="emphasis">k</i>)] and the count <i class="emphasis">Y<sub>k</sub></i> does not include key <i class="emphasis">k</i>, we have <i class="emphasis">n<sub>h(k)</sub></i> = <i class="emphasis">Y<sub>k</sub></i> + 1 and |{<i class="emphasis">l</i> : <i class="emphasis">l</i> <span class="unicode">&isin;</span> <i class="emphasis">T</i> and <i class="emphasis">l</i> <span class="unicode">&ne;</span> <i class="emphasis">k</i>}| = <i class="emphasis">n</i> - 1. Thus E[<i class="emphasis">n<sub>h(k)</sub></i>] = E[<i class="emphasis">Y<sub>k</sub></i>] + 1 <span class="unicode">&le;</span> (<i class="emphasis">n</i> - 1)/<i class="emphasis">m</i> + 1 = 1 + <span class="unicode">&alpha;</span> - 1/<i class="emphasis">m</i> <span class="unicode">&lt;</span> 1 + <span class="unicode">&alpha;</span>.</p>
</li>
</ul>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">The following corollary says universal hashing provides the desired payoff: it is now impossible for an adversary to pick a sequence of operations that forces the worst-case running time. By cleverly randomizing the choice of hash function at run time, we guarantee that every sequence of operations can be handled with good expected running time.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Corollary 11.4</span></span><a name="738"></a><a name="ch11ex13"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Using universal hashing and collision resolution by chaining in a table with <i class="emphasis">m</i> slots, it takes expected time <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) to handle any sequence of <i class="emphasis">n</i> INSERT, SEARCH and DELETE operations containing <i class="emphasis">O</i>(<i class="emphasis">m</i>) INSERT operations.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Since the number of insertions is <i class="emphasis">O</i>(<i class="emphasis">m</i>), we have <i class="emphasis">n</i> = <i class="emphasis">O</i>(<i class="emphasis">m</i>) and so <span class="unicode">&alpha;</span> = <i class="emphasis">O</i>(1). The INSERT and DELETE operations take constant time and, by <a class="internaljump" href="#ch11ex12">Theorem 11.3</a>, the expected time for each SEARCH operation is <i class="emphasis">O</i>(1). By linearity of expectation, therefore, the expected time for the entire sequence of operations is <i class="emphasis">O</i>(<i class="emphasis">n</i>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="section">
<h4 class="sect4-title">Designing a universal class of hash functions</h4>
<p class="first-para">It is quite easy to design a universal class of hash functions, as a little number theory will help us prove. You may wish to consult <a href="DDU0199.html#2624" target="_parent" class="chapterjump">Chapter 31</a> first if you are unfamiliar with number theory.</p>
<p class="para">We begin by choosing a prime number <i class="emphasis">p</i> large enough so that every possible key <i class="emphasis">k</i> is in the range 0 to <i class="emphasis">p</i> - 1, inclusive. Let <b class="bold">Z</b><sub><i class="emphasis">p</i></sub> denote the set {0, 1, ..., <i class="emphasis">p</i> - 1}, and let <span class="inlinemediaobject"><img src="images/fig256_01.jpg" height="14" width="13" alt="" border="0"></span> denote the set {1, 2, ..., <i class="emphasis">p</i> - 1}. Since <i class="emphasis">p</i> is prime, we can solve equations modulo <i class="emphasis">p</i> with the methods given in <a href="DDU0199.html#2624" target="_parent" class="chapterjump">Chapter 31</a>. Because we assume that the size of the universe of keys is greater than the number of slots in the hash table, we hav <i class="emphasis">p</i> <span class="unicode">&gt;</span> <i class="emphasis">m</i>.</p>
<p class="para">We now define the hash function <i class="emphasis">h<sub>a,b</sub></i> for any <span class="inlinemediaobject"><img src="images/fig256_02.jpg" height="15" width="35" alt="" border="0"></span> and any <i class="emphasis">b</i> <span class="unicode">&isin;</span> <b class="bold">Z</b><sub><i class="emphasis">p</i></sub> using a linear transformation followed by reductions modulo <i class="emphasis">p</i> and then modulo <i class="emphasis">m</i>:</p>
<div class="equation">
<a name="739"></a><a name="ch11eq03"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(11.3)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig256_03.jpg" height="17" width="221" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">For example, with <i class="emphasis">p</i> = 17 and <i class="emphasis">m</i> = 6, we have <i class="emphasis">h</i><sub>3,4</sub>(8) = 5. The family of all such hash functions is</p>
<div class="equation">
<a name="740"></a><a name="ch11eq04"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(11.4)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig256_04.jpg" height="21" width="224" alt="" border="0"></span></td>
</tr>
</table>
</div>
<a name="741"></a><a name="IDX-235"></a>
<p class="para">Each hash function <i class="emphasis">h<sub>a,b</sub></i> maps <b class="bold">Z</b><sub><i class="emphasis">p</i></sub> to <b class="bold">Z</b><sub><i class="emphasis">m</i></sub>. This class of hash functions has the nice property that the size <i class="emphasis">m</i> of the output range is arbitrary<span class="unicode">-</span>not necessarily prime<span class="unicode">-</span>a feature which we shall use in <a href="DDU0068.html#773" target="_parent" class="chapterjump">Section 11.5.</a> Since there are <i class="emphasis">p</i> - 1 choices for <i class="emphasis">a</i> and there are <i class="emphasis">p</i> choices for <i class="emphasis">b</i>, there are <i class="emphasis">p</i>(<i class="emphasis">p</i> - 1) hash functions in <span class="unicode">&#8459;</span><sub><i class="emphasis">p,m</i></sub>.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 11.5</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The class <span class="unicode">&#8459;</span><sub><i class="emphasis">p,m</i></sub> of hash functions defined by equations <a class="internaljump" href="#ch11eq03">(11.3)</a> and <a class="internaljump" href="#ch11eq04">(11.4)</a> is universal.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> Consider two distinct keys <i class="emphasis">k</i> and <i class="emphasis">l</i> from <b class="bold">Z</b><sub><i class="emphasis">p</i></sub>, so that <i class="emphasis">k</i> <span class="unicode">&ne;</span> <i class="emphasis">l</i>. For a given hash function <i class="emphasis">h<sub>a,b</sub></i> we let</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">r</i>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">(<i class="emphasis">ak</i> + <i class="emphasis">b</i>) mod <i class="emphasis">p</i>,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">s</i>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">(<i class="emphasis">al</i> + <i class="emphasis">b</i>) mod <i class="emphasis">p</i>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">We first note that <i class="emphasis">r</i> <span class="unicode">&ne;</span> <i class="emphasis">s</i>. Why? Observe that</p>
<p class="para">
<i class="emphasis">r</i> - <i class="emphasis">s</i> <span class="unicode">&equiv;</span> <i class="emphasis">a</i>(<i class="emphasis">k</i> - <i class="emphasis">l</i>) (mod <i class="emphasis">p</i>).</p>
<p class="para">It follows that <i class="emphasis">r</i> <span class="unicode">&ne;</span> <i class="emphasis">s</i> because <i class="emphasis">p</i> is prime and both <i class="emphasis">a</i> and (<i class="emphasis">k</i> - <i class="emphasis">l</i>) are nonzero modulo <i class="emphasis">p</i>, and so their product must also be nonzero modulo <i class="emphasis">p</i> by <a href="DDU0200.html#2647" target="_parent" class="chapterjump">Theorem 31.6</a>. Therefore, during the computation of any <i class="emphasis">h<sub>a,b</sub></i> in <span class="unicode">&#8459;</span><sub><i class="emphasis">p,m</i></sub>, distinct inputs <i class="emphasis">k</i> and <i class="emphasis">l</i> map to distinct values <i class="emphasis">r</i> and <i class="emphasis">s</i> modulo <i class="emphasis">p</i>; there are no collisions yet at the "mod <i class="emphasis">p</i> level." Moreover, each of the possible <i class="emphasis">p</i>(<i class="emphasis">p</i> - 1) choices for the pair (<i class="emphasis">a</i>, <i class="emphasis">b</i>) with <i class="emphasis">a</i> <span class="unicode">&ne;</span> 0 yields a <i class="emphasis">different</i> resulting pair (<i class="emphasis">r</i>, <i class="emphasis">s</i>) with <i class="emphasis">r</i> <span class="unicode">&ne;</span> <i class="emphasis">s</i>, since we can solve for <i class="emphasis">a</i> and <i class="emphasis">b</i> given <i class="emphasis">r</i> and <i class="emphasis">s</i>:</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">a</i>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">((<i class="emphasis">r</i> - <i class="emphasis">s</i>)((<i class="emphasis">k</i> - <i class="emphasis">l</i>)<sup>-1</sup> mod <i class="emphasis">p</i>)) mod <i class="emphasis">p</i>,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">b</i>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">(<i class="emphasis">r</i> - <i class="emphasis">ak</i>) mod <i class="emphasis">p</i>,</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">where ((<i class="emphasis">k</i> - <i class="emphasis">l</i>)<sup>-1</sup> mod <i class="emphasis">p</i>) denotes the unique multiplicative inverse, modulo <i class="emphasis">p</i>, of <i class="emphasis">k</i> - <i class="emphasis">l</i>. Since there are only <i class="emphasis">p</i>(<i class="emphasis">p</i> - 1) possible pairs (<i class="emphasis">r</i>, <i class="emphasis">s</i>) with <i class="emphasis">r</i> <span class="unicode">&ne;</span> <i class="emphasis">s</i>, there is a one-to-one correspondence between pairs (<i class="emphasis">a</i>, <i class="emphasis">b</i>) with <i class="emphasis">a</i> <span class="unicode">&ne;</span> = 0 and pairs (<i class="emphasis">r</i>, <i class="emphasis">s</i>) with <i class="emphasis">r</i> <span class="unicode">&ne;</span> <i class="emphasis">s</i>. Thus, for any given pair of inputs <i class="emphasis">k</i> and <i class="emphasis">l</i>, if we pick (<i class="emphasis">a</i>, <i class="emphasis">b</i>) uniformly at random from <span class="inlinemediaobject"><img src="images/fig257_01.jpg" height="14" width="40" alt="" border="0"></span>, the resulting pair (<i class="emphasis">r</i>, <i class="emphasis">s</i>) is equally likely to be any pair of distinct values modulo <i class="emphasis">p</i>.</p>
<p class="para">It then follows that the probability that distinct keys <i class="emphasis">k</i> and <i class="emphasis">l</i> collide is equal to the probability that <i class="emphasis">r</i> <span class="unicode">&equiv;</span> <i class="emphasis">s</i> (mod <i class="emphasis">m</i>) when <i class="emphasis">r</i> and <i class="emphasis">s</i> are randomly chosen as distinct values modulo <i class="emphasis">p</i>. For a given value of <i class="emphasis">r</i>, of the <i class="emphasis">p</i> - 1 possible remaining values for <i class="emphasis">s</i>, the number of values <i class="emphasis">s</i> such that <i class="emphasis">s</i> <span class="unicode">&ne;</span> <i class="emphasis">r</i> and <i class="emphasis">s</i> <span class="unicode">&equiv;</span> <i class="emphasis">r</i> (mod <i class="emphasis">m</i>) is at most</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<span class="unicode">&lceil;</span><i class="emphasis">p</i>/<i class="emphasis">m</i><span class="unicode">&rceil;</span> - 1</p>
</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&le;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">((<i class="emphasis">p</i> + <i class="emphasis">m</i> - 1)/<i class="emphasis">m</i>) - 1 (by inequality <a href="DDU0020.html#160" target="_parent" class="chapterjump">(3.7)</a>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">(<i class="emphasis">p</i> - 1)/<i class="emphasis">m</i>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">The probability that <i class="emphasis">s</i> collides with <i class="emphasis">r</i> when reduced modulo <i class="emphasis">m</i> is at most ((<i class="emphasis">p</i> - 1)/<i class="emphasis">m</i>)/(<i class="emphasis">p</i> - 1) = 1/<i class="emphasis">m</i>.<a name="742"></a><a name="IDX-236"></a>
</p>
<p class="para">Therefore, for any pair of distinct values <i class="emphasis">k</i>, <i class="emphasis">l</i> <span class="unicode">&isin;</span> <b class="bold">Z</b><sub><i class="emphasis">p</i></sub>,</p>
<p class="para">Pr{<i class="emphasis">h<sub>a,b</sub></i>(<i class="emphasis">k</i>) = <i class="emphasis">h<sub>a,b</sub></i>(<i class="emphasis">l</i>)} <span class="unicode">&le;</span> 1/<i class="emphasis">m</i>,</p>
<p class="last-para">so that <span class="unicode">&#8459;</span><sub><i class="emphasis">p,m</i></sub> is indeed universal.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 11.3-1</span></span><a name="743"></a><a name="ch11ex15"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose we wish to search a linked list of length <i class="emphasis">n</i>, where each element contains a key <i class="emphasis">k</i> along with a hash value <i class="emphasis">h</i>(<i class="emphasis">k</i>). Each key is a long character string. How might we take advantage of the hash values when searching the list for an element with a given key?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 11.3-2</span></span><a name="744"></a><a name="ch11ex16"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that a string of <i class="emphasis">r</i> characters is hashed into <i class="emphasis">m</i> slots by treating it as a radix-128 number and then using the division method. The number <i class="emphasis">m</i> is easily represented as a 32-bit computer word, but the string of <i class="emphasis">r</i> characters, treated as a radix-128 number, takes many words. How can we apply the division method to compute the hash value of the character string without using more than a constant number of words of storage outside the string itself?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 11.3-3</span></span><a name="745"></a><a name="ch11ex17"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Consider a version of the division method in which <i class="emphasis">h</i>(<i class="emphasis">k</i>) = <i class="emphasis">k</i> mod <i class="emphasis">m</i>, where <i class="emphasis">m</i> = 2<sup><i class="emphasis">p</i></sup> - 1 and <i class="emphasis">k</i> is a character string interpreted in radix 2<sup><i class="emphasis">p</i></sup>. Show that if string <i class="emphasis">x</i> can be derived from string <i class="emphasis">y</i> by permuting its characters, then <i class="emphasis">x</i> and <i class="emphasis">y</i> hash to the same value. Give an example of an application in which this property would be undesirable in a hash function.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 11.3-4</span></span><a name="746"></a><a name="ch11ex18"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Consider a hash table of size <i class="emphasis">m</i> = 1000 and a corresponding hash function <i class="emphasis">h</i>(<i class="emphasis">k</i>) = <span class="unicode">&lfloor;</span><i class="emphasis">m</i>(<i class="emphasis">k A</i> mod 1)<span class="unicode">&rfloor;</span> for <span class="inlinemediaobject"><img src="images/fig258_01.jpg" height="14" width="78" alt="" border="0"></span>. Compute the locations to which the keys 61, 62, 63, 64, and 65 are mapped.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 11.3-5: </span><span class="unicode">&#8902;</span></span><a name="747"></a><a name="ch11ex19"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Define a family <span class="unicode">&#8459;</span> of hash functions from a finite set <i class="emphasis">U</i> to a finite set <i class="emphasis">B</i> to be <b class="bold"><i class="emphasis"><span class="unicode">&isin;</span>-universal</i></b> if for all pairs of distinct elements <i class="emphasis">k</i> and <i class="emphasis">l</i> in <i class="emphasis">U</i>,</p>
<p class="para">Pr {<i class="emphasis">h</i>(<i class="emphasis">k</i>) = <i class="emphasis">h</i>(<i class="emphasis">l</i>)} <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&isin;</span></i>,</p>
<p class="para">where the probability is taken over the drawing of hash function <i class="emphasis">h</i> at random from the family <span class="unicode">&#8459;</span>. Show that an <i class="emphasis"><span class="unicode">&isin;</span></i>-universal family of hash functions must have</p>
<p class="last-para">
<div class="informalequation">
<span class="equation-image"><img src="images/fig258_02.jpg" height="36" width="99" alt="" border="0"></span>
</div>
</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="748"></a><a name="IDX-237"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 11.3-6: </span><span class="unicode">&#8902;</span></span><a name="749"></a><a name="ch11ex20"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">U</i> be the set of <i class="emphasis">n</i>-tuples of values drawn from <b class="bold">Z</b><sub><i class="emphasis">p</i></sub>, and let <i class="emphasis">B</i> = <b class="bold">Z</b><sub><i class="emphasis">p</i></sub>, where <i class="emphasis">p</i> is prime. Define the hash function <i class="emphasis">h<sub>b</sub></i> : <i class="emphasis">U</i> <span class="unicode">&rarr;</span> <i class="emphasis">B</i> for <i class="emphasis">b</i> <span class="unicode">&isin;</span> <b class="bold">Z</b><sub><i class="emphasis">p</i></sub> on an input <i class="emphasis">n</i>-tuple <span class="unicode">&#12296;</span><i class="emphasis">a</i><sub>0</sub>, <i class="emphasis">a</i><sub>1</sub>, ..., <i class="emphasis">a<sub>n-1</sub></i><span class="unicode">&#12297;</span> from <i class="emphasis">U</i> as</p>
<p class="para">
<div class="informalequation">
<span class="equation-image"><img src="images/fig259_01.jpg" height="44" width="199" alt="" border="0"></span>
</div>
</p>
<p class="last-para">and let <span class="unicode">&#8459;</span> = {<i class="emphasis">h<sub>b</sub></i> : <i class="emphasis">b</i> <span class="unicode">&isin;</span> <b class="bold">Z</b><sub><i class="emphasis">p</i></sub>}. Argue that <span class="unicode">&#8459;</span> is ((<i class="emphasis">n</i> - 1)/<i class="emphasis">p</i>)-universal according to the definition of <span class="unicode">&isin;</span>-universal in <a class="internaljump" href="#ch11ex19">Exercise 11.3-5</a>. (<i class="emphasis">Hint:</i> See <a href="DDU0200.html#2655" target="_parent" class="chapterjump">Exercise 31.4-4</a>.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0065.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0067.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
