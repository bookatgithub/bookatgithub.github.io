<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>11.4 Open addressing</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0066.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0068.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch11"></a>
<div class="section">
<h2 class="first-section-title">
<a name="750"></a><a name="ch11lev1sec4"></a><span class="section-titlelabel">11.4 </span>Open addressing</h2>
<p class="first-para">In <b class="bold"><i class="emphasis">open addressing</i></b>, all elements are stored in the hash table itself. That is, each table entry contains either an element of the dynamic set or NIL. When searching for an element, we systematically examine table slots until the desired element is found or it is clear that the element is not in the table. There are no lists and no elements stored outside the table, as there are in chaining. Thus, in open addressing, the hash table can "fill up" so that no further insertions can be made; the load factor <i class="emphasis"><span class="unicode">&alpha;</span></i> can never exceed 1.</p>
<p class="para">Of course, we could store the linked lists for chaining inside the hash table, in the otherwise unused hash-table slots (see <a href="DDU0065.html#723" target="_parent" class="chapterjump">Exercise 11.2-4</a>), but the advantage of open addressing is that it avoids pointers altogether. Instead of following pointers, we <i class="emphasis">compute</i> the sequence of slots to be examined. The extra memory freed by not storing pointers provides the hash table with a larger number of slots for the same amount of memory, potentially yielding fewer collisions and faster retrieval.</p>
<p class="para">To perform insertion using open addressing, we successively examine, or <b class="bold"><i class="emphasis">probe</i></b>, the hash table until we find an empty slot in which to put the key. Instead of being fixed in the order 0, 1, ..., <i class="emphasis">m</i> - 1 (which requires <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) search time), the sequence of positions probed <i class="emphasis">depends upon the key being inserted</i>. To determine which slots to probe, we extend the hash function to include the probe number (starting from 0) as a second input. Thus, the hash function becomes</p>
<p class="para">
<i class="emphasis">h</i> : <i class="emphasis">U</i> <span class="unicode">&times;</span> {0, 1, ..., <i class="emphasis">m</i> - 1} <span class="unicode">&rarr;</span> {0, 1, ..., <i class="emphasis">m</i> - 1}.</p>
<p class="para">With open addressing, we require that for every key <i class="emphasis">k</i>, the <b class="bold"><i class="emphasis">probe sequence</i></b>
</p>
<p class="para">
<span class="unicode">&#12296;</span><i class="emphasis">h</i>(<i class="emphasis">k</i>,0),<i class="emphasis">h</i>(<i class="emphasis">k</i>,1), ..., <i class="emphasis">h</i>(<i class="emphasis">k</i>,<i class="emphasis">m</i> - 1)<span class="unicode">&#12297;</span>
</p>
<p class="para">be a permutation of <span class="unicode">&#12296;</span>0, 1, ..., <i class="emphasis">m</i> -1<span class="unicode">&#12297;</span>, so that every hash-table position is eventually considered as a slot for a new key as the table fills up. In the following pseudocode, <a name="751"></a><a name="IDX-238"></a>we assume that the elements in the hash table <i class="emphasis">T</i> are keys with no satellite information; the key <i class="emphasis">k</i> is identical to the element containing key <i class="emphasis">k</i>. Each slot contains either a key or NIL (if the slot is empty).</p>
<div class="informalexample">
<pre class="literallayout-normal">
HASH-INSERT(<i class="emphasis">T</i>, <i class="emphasis">k</i>)
1  <i class="emphasis">i</i> <span class="unicode">&larr;</span> 0
2  <b class="bold">repeat</b> <i class="emphasis">j</i> <span class="unicode">&larr;</span> <i class="emphasis">h</i>(<i class="emphasis">k</i>, <i class="emphasis">i</i>)
3         <b class="bold">if</b> <i class="emphasis">T</i>[<i class="emphasis">j</i>] = NIL
4            <b class="bold">then</b> <i class="emphasis">T</i>[<i class="emphasis">j</i>] <span class="unicode">&larr;</span> <i class="emphasis">k</i>
5                 <b class="bold">return</b> <i class="emphasis">j</i>
6            <b class="bold">else</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> <i class="emphasis">i</i> + 1
7   <b class="bold">until</b> <i class="emphasis">i</i> = <i class="emphasis">m</i>
8 <b class="bold">error</b> "hash table overflow"
</pre>
</div>
<p class="para">The algorithm for searching for key <i class="emphasis">k</i> probes the same sequence of slots that the insertion algorithm examined when key <i class="emphasis">k</i> was inserted. Therefore, the search can terminate (unsuccessfully) when it finds an empty slot, since <i class="emphasis">k</i> would have been inserted there and not later in its probe sequence. (This argument assumes that keys are not deleted from the hash table.) The procedure HASH-SEARCH takes as input a hash table <i class="emphasis">T</i> and a key <i class="emphasis">k</i>, returning <i class="emphasis">j</i> if slot <i class="emphasis">j</i> is found to contain key <i class="emphasis">k</i>, or NIL if key <i class="emphasis">k</i> is not present in table <i class="emphasis">T</i>.</p>
<div class="informalexample">
<pre class="literallayout-normal">
HASH-SEARCH(<i class="emphasis">T</i>, <i class="emphasis">k</i>)
1  <i class="emphasis">i</i> <span class="unicode">&larr;</span> 0
2  <b class="bold">repeat</b> <i class="emphasis">j</i> <span class="unicode">&larr;</span> <i class="emphasis">h</i>(<i class="emphasis">k</i>, <i class="emphasis">i</i>)
3         <b class="bold">if</b> <i class="emphasis">T</i>[<i class="emphasis">j</i>] = <i class="emphasis">k</i>
4            <b class="bold">then return</b> <i class="emphasis">j</i>
5         <i class="emphasis">i</i> <span class="unicode">&larr;</span> <i class="emphasis">i</i> + 1
6    <b class="bold">until</b> <i class="emphasis">T</i>[<i class="emphasis">j</i>] = NIL or <i class="emphasis">i</i> = <i class="emphasis">m</i>
7  <b class="bold">return</b> NIL
</pre>
</div>
<p class="para">Deletion from an open-address hash table is difficult. When we delete a key from slot <i class="emphasis">i</i>, we cannot simply mark that slot as empty by storing NIL in it. Doing so might make it impossible to retrieve any key <i class="emphasis">k</i> during whose insertion we had probed slot <i class="emphasis">i</i> and found it occupied. One solution is to mark the slot by storing in it the special value DELETED instead of NIL. We would then modify the procedure HASH-INSERT to treat such a slot as if it were empty so that a new key can be inserted. No modification of HASH-SEARCH is needed, since it will pass over DELETED values while searching. When we use the special value DELETED, however, search times are no longer dependent on the load factor <span class="unicode">&alpha;</span>, and for this reason chaining is more commonly selected as a collision resolution technique when keys must be deleted.<a name="752"></a><a name="IDX-239"></a>
</p>
<p class="para">In our analysis, we make the assumption of <b class="bold"><i class="emphasis">uniform hashing</i></b>: we assume that each key is equally likely to have any of the <i class="emphasis">m</i>! permutations of <span class="unicode">&#12296;</span>0, 1, ..., <i class="emphasis">m</i> - 1<span class="unicode">&#12297;</span> as its probe sequence. Uniform hashing generalizes the notion of simple uniform hashing defined earlier to the situation in which the hash function produces not just a single number, but a whole probe sequence. True uniform hashing is difficult to implement, however, and in practice suitable approximations (such as double hashing, defined below) are used.</p>
<p class="para">Three techniques are commonly used to compute the probe sequences required for open addressing: linear probing, quadratic probing, and double hashing. These techniques all guarantee that <span class="unicode">&#12296;</span><i class="emphasis">h</i>(<i class="emphasis">k</i>, 0), <i class="emphasis">h</i>(<i class="emphasis">k</i>, 1), ..., <i class="emphasis">h</i>(<i class="emphasis">k</i>, <i class="emphasis">m</i> - 1)<span class="unicode">&#12297;</span> is a permutation of <span class="unicode">&#12296;</span>0, 1, ..., <i class="emphasis">m</i> - 1<span class="unicode">&#12297;</span> for each key <i class="emphasis">k</i>. None of these techniques fulfills the assumption of uniform hashing, however, since none of them is capable of generating more than <i class="emphasis">m</i><sup>2</sup> different probe sequences (instead of the <i class="emphasis">m</i>! that uniform hashing requires). Double hashing has the greatest number of probe sequences and, as one might expect, seems to give the best results.</p>
<div class="section">
<h4 class="sect4-title">
<a name="753"></a><a name="ch11lev3sec6"></a>Linear probing</h4>
<p class="first-para">Given an ordinary hash function <i class="emphasis">h</i>' : <i class="emphasis">U</i> <span class="unicode">&rarr;</span> {0, 1, ..., <i class="emphasis">m</i> - 1}, which we refer to as an <b class="bold"><i class="emphasis">auxiliary hash function</i></b>, the method of <b class="bold"><i class="emphasis">linear probing</i></b> uses the hash function</p>
<p class="para">
<i class="emphasis">h</i>(<i class="emphasis">k</i>, <i class="emphasis">i</i>) = (<i class="emphasis">h</i>'(<i class="emphasis">k</i>) + <i class="emphasis">i</i>) mod <i class="emphasis">m</i>
</p>
<p class="para">for <i class="emphasis">i</i> = 0, 1, ..., <i class="emphasis">m</i> - 1. Given key <i class="emphasis">k</i>, the first slot probed is <i class="emphasis">T</i>[<i class="emphasis">h</i>'(<i class="emphasis">k</i>)], i.e., the slot given by the auxiliary hash function. We next probe slot <i class="emphasis">T</i>[<i class="emphasis">h</i>'(<i class="emphasis">k</i>) + 1], and so on up to slot <i class="emphasis">T</i>[<i class="emphasis">m</i> - 1]. Then we wrap around to slots <i class="emphasis">T</i>[0], <i class="emphasis">T</i>[1], ..., until we finally probe slot <i class="emphasis">T</i>[<i class="emphasis">h</i>'(<i class="emphasis">k</i>) - 1]. Because the initial probe determines the entire probe sequence, there are only <i class="emphasis">m</i> distinct probe sequences.</p>
<p class="last-para">Linear probing is easy to implement, but it suffers from a problem known as <b class="bold"><i class="emphasis">primary clustering</i></b>. Long runs of occupied slots build up, increasing the average search time. Clusters arise since an empty slot preceded by <i class="emphasis">i</i> full slots gets filled next with probability (<i class="emphasis">i</i> + 1)/<i class="emphasis">m</i>. Long runs of occupied slots tend to get longer, and the average search time increases.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="754"></a><a name="ch11lev3sec7"></a>Quadratic probing</h4>
<p class="first-para">
<b class="bold"><i class="emphasis">Quadratic probing</i></b> uses a hash function of the form</p>
<div class="equation">
<a name="755"></a><a name="ch11eq05"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(11.5)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig261_01.jpg" height="19" width="230" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="last-para">where <i class="emphasis">h</i>' is an auxiliary hash function, <i class="emphasis">c</i><sub>1</sub> and <i class="emphasis">c</i><sub>2</sub> <span class="unicode">&ne;</span> 0 are auxiliary constants, and <i class="emphasis">i</i> = 0, 1, ..., <i class="emphasis">m</i> - 1. The initial position probed is <i class="emphasis">T</i>[<i class="emphasis">h</i>'(<i class="emphasis">k</i>)]; later positions probed are offset by amounts that depend in a quadratic manner on the probe number <i class="emphasis">i</i>. This method works much better than linear probing, but to make full use of the <a name="756"></a><a name="IDX-240"></a>hash table, the values of <i class="emphasis">c</i><sub>1</sub>, <i class="emphasis">c</i><sub>2</sub>, and <i class="emphasis">m</i> are constrained. <a href="DDU0068.html#788" target="_parent" class="chapterjump">Problem 11-3</a> shows one way to select these parameters. Also, if two keys have the same initial probe position, then their probe sequences are the same, since <i class="emphasis">h</i>(<i class="emphasis">k</i><sub>1</sub>, 0) = <i class="emphasis">h</i>(<i class="emphasis">k</i><sub>2</sub>, 0) implies <i class="emphasis">h</i>(<i class="emphasis">k</i><sub>1</sub>, <i class="emphasis">i</i>) = <i class="emphasis">h</i>(<i class="emphasis">k</i><sub>2</sub>, <i class="emphasis">i</i>). This property leads to a milder form of clustering, called <b class="bold"><i class="emphasis">secondary clustering</i></b>. As in linear probing, the initial probe determines the entire sequence, so only <i class="emphasis">m</i> distinct probe sequences are used.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="757"></a><a name="ch11lev3sec8"></a>Double hashing</h4>
<p class="first-para">Double hashing is one of the best methods available for open addressing because the permutations produced have many of the characteristics of randomly chosen permutations. <b class="bold"><i class="emphasis">Double hashing</i></b> uses a hash function of the form</p>
<p class="para">
<i class="emphasis">h</i>(<i class="emphasis">k</i>, <i class="emphasis">i</i>) = (<i class="emphasis">h</i><sub>1</sub>(<i class="emphasis">k</i>) + <i class="emphasis">ih</i><sub>2</sub>(<i class="emphasis">k</i>)) mod <i class="emphasis">m</i>,</p>
<p class="para">where <i class="emphasis">h</i><sub>1</sub> and <i class="emphasis">h</i><sub>2</sub> are auxiliary hash functions. The initial probe is to position <i class="emphasis">T</i>[<i class="emphasis">h</i><sub>1</sub>(<i class="emphasis">k</i>)]; successive probe positions are offset from previous positions by the amount <i class="emphasis">h</i><sub>2</sub>(<i class="emphasis">k</i>), modulo <i class="emphasis">m</i>. Thus, unlike the case of linear or quadratic probing, the probe sequence here depends in two ways upon the key <i class="emphasis">k</i>, since the initial probe position, the offset, or both, may vary. <a class="internaljump" href="#ch11fig05">Figure 11.5</a> gives an example of insertion by double hashing.</p>
<div class="figure">
<a name="758"></a><a name="ch11fig05"></a><span class="figuremediaobject"><img src="images/fig262_01.jpg" height="356" width="98" alt="" border="0"></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 11.5: </span>Insertion by double hashing. Here we have a hash table of size 13 with <i class="emphasis">h</i><sub>1</sub>(<i class="emphasis">k</i>) = <i class="emphasis">k</i> mod 13 and <i class="emphasis">h</i><sub>2</sub>(<i class="emphasis">k</i>) = 1 + (<i class="emphasis">k</i> mod 11). Since 14 <span class="unicode">&equiv;</span> 1 (mod 13) and 14 <span class="unicode">&equiv;</span> 3 (mod 11), the key 14 is inserted into empty slot 9, after slots 1 and 5 are examined and found to be occupied.</span>
</div>
<p class="para">The value <i class="emphasis">h</i><sub>2</sub>(<i class="emphasis">k</i>) must be relatively prime to the hash-table size <i class="emphasis">m</i> for the entire hash table to be searched. (See <a class="internaljump" href="#ch11ex26">Exercise 11.4-3</a>.) A convenient way to ensure this <a name="759"></a><a name="IDX-241"></a>condition is to let <i class="emphasis">m</i> be a power of 2 and to design <i class="emphasis">h</i><sub>2</sub> so that it always produces an odd number. Another way is to let <i class="emphasis">m</i> be prime and to design <i class="emphasis">h</i><sub>2</sub> so that it always returns a positive integer less than <i class="emphasis">m</i>. For example, we could choose <i class="emphasis">m</i> prime and let</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">h</i><sub>1</sub>(<i class="emphasis">k</i>)</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">k</i> mod <i class="emphasis">m</i>,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">h</i><sub>2</sub>(<i class="emphasis">k</i>)</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">1 + (<i class="emphasis">k</i> mod <i class="emphasis">m</i>'),</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">where <i class="emphasis">m</i>' is chosen to be slightly less than <i class="emphasis">m</i> (say, <i class="emphasis">m</i> - 1). For example, if <i class="emphasis">k</i> = 123456, <i class="emphasis">m</i> = 701, and <i class="emphasis">m</i>' = 700, we have <i class="emphasis">h</i><sub>1</sub>(<i class="emphasis">k</i>) = 80 and <i class="emphasis">h</i><sub>2</sub>(<i class="emphasis">k</i>) = 257, so the first probe is to position 80, and then every 257th slot (modulo <i class="emphasis">m</i>) is examined until the key is found or every slot is examined.</p>
<p class="last-para">Double hashing improves over linear or quadratic probing in that <span class="unicode">&Theta;</span>(<i class="emphasis">m</i><sup>2</sup>) probe sequences are used, rather than <span class="unicode">&Theta;</span>(<i class="emphasis">m</i>), since each possible (<i class="emphasis">h</i><sub>1</sub>(<i class="emphasis">k</i>), <i class="emphasis">h</i><sub>2</sub>(<i class="emphasis">k</i>)) pair yields a distinct probe sequence. As a result, the performance of double hashing appears to be very close to the performance of the "ideal" scheme of uniform hashing.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="760"></a><a name="ch11lev3sec9"></a>Analysis of open-address hashing</h4>
<p class="first-para">Our analysis of open addressing, like our analysis of chaining, is expressed in terms of the load factor <span class="unicode">&alpha;</span> = <i class="emphasis">n</i>/<i class="emphasis">m</i> of the hash table, as <i class="emphasis">n</i> and <i class="emphasis">m</i> go to infinity. Of course, with open addressing, we have at most one element per slot, and thus <i class="emphasis">n</i> <span class="unicode">&le;</span> <i class="emphasis">m</i>, which implies <span class="unicode">&alpha;</span> <span class="unicode">&le;</span> 1.</p>
<p class="para">We assume that uniform hashing is used. In this idealized scheme, the probe sequence <span class="unicode">&#12296;</span><i class="emphasis">h</i>(<i class="emphasis">k</i>, 0), <i class="emphasis">h</i>(<i class="emphasis">k</i>, 1), ..., <i class="emphasis">h</i>(<i class="emphasis">k</i>, <i class="emphasis">m</i> - 1)<span class="unicode">&#12297;</span> used to insert or search for each key <i class="emphasis">k</i> is equally likely to be any permutation of <span class="unicode">&#12296;</span>0, 1, ..., <i class="emphasis">m</i> - 1<span class="unicode">&#12297;</span>. Of course, a given key has a unique fixed probe sequence associated with it; what is meant here is that, considering the probability distribution on the space of keys and the operation of the hash function on the keys, each possible probe sequence is equally likely.</p>
<p class="para">We now analyze the expected number of probes for hashing with open addressing under the assumption of uniform hashing, beginning with an analysis of the number of probes made in an unsuccessful search.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 11.6</span></span><a name="761"></a><a name="ch11ex21"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Given an open-address hash table with load factor <span class="unicode">&alpha;</span> = <i class="emphasis">n</i>/<i class="emphasis">m</i> <span class="unicode">&lt;</span> 1, the expected number of probes in an unsuccessful search is at most 1/(1-<span class="unicode">&alpha;</span>), assuming uniform hashing.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> In an unsuccessful search, every probe but the last accesses an occupied slot that does not contain the desired key, and the last slot probed is empty. Let us define the random variable <i class="emphasis">X</i> to be the number of probes made in an unsuccessful search, and let us also define the event <i class="emphasis">A<sub>i</sub></i> , for <i class="emphasis">i</i> = 1, 2, ..., to be the event that <a name="762"></a><a name="IDX-242"></a>there is an <i class="emphasis">i</i>th probe and it is to an occupied slot. Then the event {<i class="emphasis">X</i> <span class="unicode">&ge;</span> <i class="emphasis">i</i>} is the intersection of events <i class="emphasis">A</i><sub>1</sub> <span class="unicode">&cap;</span> <i class="emphasis">A</i><sub>2</sub> <span class="unicode">&cap;</span> <span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&middot;</span> <span class="unicode">&cap;</span> <i class="emphasis">A</i><sub><i class="emphasis">i</i>-1</sub>. We will bound Pr {<i class="emphasis">X</i> <span class="unicode">&ge;</span> <i class="emphasis">i</i>} by bounding Pr {<i class="emphasis">A</i><sub>1</sub> <span class="unicode">&cap;</span> <i class="emphasis">A</i><sub>2</sub> <span class="unicode">&cap;</span> <span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&middot;</span> <span class="unicode">&cap;</span> <i class="emphasis">A</i><sub><i class="emphasis">i</i>-1</sub>}. By <a href="DDU0254.html#3466" target="_parent" class="chapterjump">Exercise C.2-6</a>,</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">Pr {<i class="emphasis">A</i><sub>1</sub> <span class="unicode">&cap;</span> <i class="emphasis">A</i><sub>2</sub> <span class="unicode">&cap;</span> <span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&middot;</span> <span class="unicode">&cap;</span> <i class="emphasis">A</i><sub><i class="emphasis">i</i>-1</sub>}</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">Pr{<i class="emphasis">A</i><sub>1</sub>} <span class="unicode">&middot;</span> Pr{<i class="emphasis">A</i><sub>2</sub> | <i class="emphasis">A</i><sub>1</sub>} <span class="unicode">&middot;</span> Pr{<i class="emphasis">A</i><sub>3</sub> | <i class="emphasis">A</i><sub>1</sub> <span class="unicode">&cap;</span> <i class="emphasis">A</i><sub>2</sub>}</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">&nbsp;</td><td class="td" align="left">
<p class="table-para">Pr{<i class="emphasis">A</i><sub><i class="emphasis">i</i>-1</sub> | <i class="emphasis">A</i><sub>1</sub> <span class="unicode">&cap;</span> <i class="emphasis">A</i><sub>2</sub> <span class="unicode">&cap;</span> <span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&middot;</span> <span class="unicode">&cap;</span> <i class="emphasis">A</i><sub><i class="emphasis">i</i>-2</sub>}.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">Since there are <i class="emphasis">n</i> elements and <i class="emphasis">m</i> slots, Pr {<i class="emphasis">A</i><sub>1</sub>} = <i class="emphasis">n</i>/<i class="emphasis">m</i>. For <i class="emphasis">j</i> <span class="unicode">&gt;</span> 1, the probability that there is a <i class="emphasis">j</i>th probe and it is to an occupied slot, given that the first <i class="emphasis">j</i> - 1 probes were to occupied slots, is (<i class="emphasis">n</i> - <i class="emphasis">j</i> + 1)/(<i class="emphasis">m</i> - <i class="emphasis">j</i> + 1). This probability follows because we would be finding one of the remaining (<i class="emphasis">n</i> - (<i class="emphasis">j</i> - 1)) elements in one of the (<i class="emphasis">m</i> - (<i class="emphasis">j</i> - 1)) unexamined slots, and by the assumption of uniform hashing, the probability is the ratio of these quantities. Observing that <i class="emphasis">n</i> <span class="unicode">&lt;</span> <i class="emphasis">m</i> implies that (<i class="emphasis">n</i> - <i class="emphasis">j</i>)/(<i class="emphasis">m</i> - <i class="emphasis">j</i>) <span class="unicode">&le;</span> <i class="emphasis">n</i>/<i class="emphasis">m</i> for all <i class="emphasis">j</i> such that 0 <span class="unicode">&le;</span> <i class="emphasis">j</i> <span class="unicode">&lt;</span> <i class="emphasis">m</i>, we have for all <i class="emphasis">i</i> such that 1 <span class="unicode">&le;</span> <i class="emphasis">i</i> <span class="unicode">&le;</span> <i class="emphasis">m</i>,</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig264_01.jpg" height="89" width="301" alt="" border="0"></span>
</div>
<p class="para">Now we use equation <a href="DDU0255.html#3480" target="_parent" class="chapterjump">(C.24)</a> to bound the expected number of probes:</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig264_02.jpg" height="171" width="157" alt="" border="0"></span>
</div>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">The above bound of 1+<span class="unicode">&alpha;</span>+<span class="unicode">&alpha;</span><sup>2</sup>+<span class="unicode">&alpha;</span><sup>3</sup>+<span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&middot;</span> has an intuitive interpretation. One probe is always made. With probability approximately <span class="unicode">&alpha;</span>, the first probe finds an occupied slot so that a second probe is necessary. With probability approximately <span class="unicode">&alpha;</span><sup>2</sup>, the first two slots are occupied so that a third probe is necessary, and so on.</p>
<p class="para">If <span class="unicode">&alpha;</span> is a constant, <a class="internaljump" href="#ch11ex21">Theorem 11.6</a> predicts that an unsuccessful search runs in <i class="emphasis">O</i>(1) time. For example, if the hash table is half full, the average number of probes in an unsuccessful search is at most 1/(1 - .5) = 2. If it is 90 percent full, the average number of probes is at most 1/(1 - .9) = 10.<a name="763"></a><a name="IDX-243"></a>
</p>
<p class="para">
<a class="internaljump" href="#ch11ex21">Theorem 11.6</a> gives us the performance of the HASH-INSERT procedure almost immediately.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Corollary 11.7</span></span><a name="764"></a><a name="ch11ex22"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Inserting an element into an open-address hash table with load factor <span class="unicode">&alpha;</span> requires at most 1/(1 - <span class="unicode">&alpha;</span>) probes on average, assuming uniform hashing.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> An element is inserted only if there is room in the table, and thus <span class="unicode">&alpha;</span> <span class="unicode">&lt;</span> 1. Inserting a key requires an unsuccessful search followed by placement of the key in the first empty slot found. Thus, the expected number of probes is at most 1/(1 - <span class="unicode">&alpha;</span>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">Computing the expected number of probes for a successful search requires a little more work.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 11.8</span></span><a name="765"></a><a name="ch11ex23"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Given an open-address hash table with load factor <span class="unicode">&alpha;</span> <span class="unicode">&lt;</span> 1, the expected number of probes in a successful search is at most</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig265_01.jpg" height="34" width="74" alt="" border="0"></span>
</div>
<p class="para">assuming uniform hashing and assuming that each key in the table is equally likely to be searched for.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> A search for a key <i class="emphasis">k</i> follows the same probe sequence as was followed when the element with key <i class="emphasis">k</i> was inserted. By <a class="internaljump" href="#ch11ex22">Corollary 11.7</a>, if <i class="emphasis">k</i> was the (<i class="emphasis">i</i> + 1)st key inserted into the hash table, the expected number of probes made in a search for <i class="emphasis">k</i> is at most 1/(1 - <i class="emphasis">i</i>/<i class="emphasis">m</i>) = <i class="emphasis">m</i>/(<i class="emphasis">m</i> - <i class="emphasis">i</i>). Averaging over all <i class="emphasis">n</i> keys in the hash table gives us the average number of probes in a successful search:</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig265_02.jpg" height="81" width="214" alt="" border="0"></span>
</div>
<p class="para">where <span class="inlinemediaobject"><img src="images/fig265_03.jpg" height="16" width="71" alt="" border="0"></span> is the <i class="emphasis">i</i>th harmonic number (as defined in equation <a href="DDU0244.html#3282" target="_parent" class="chapterjump">(A.7)</a>). Using the technique of bounding a summation by an integral, as described in <a href="DDU0245.html#3307" target="_parent" class="chapterjump">Section A.2</a>, we obtain<a name="766"></a><a name="IDX-244"></a>
</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig266_01.jpg" height="155" width="371" alt="" border="0"></span>
</div>
<p class="last-para">for a bound on the expected number of probes in a successful search.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">If the hash table is half full, the expected number of probes in a successful search is less than 1.387. If the hash table is 90 percent full, the expected number of probes is less than 2.559.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 11.4-1</span></span><a name="767"></a><a name="ch11ex24"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Consider inserting the keys 10, 22, 31, 4, 15, 28, 17, 88, 59 into a hash table of length <i class="emphasis">m</i> = 11 using open addressing with the primary hash function <i class="emphasis">h</i>'(<i class="emphasis">k</i>) = <i class="emphasis">k</i> mod <i class="emphasis">m</i>. Illustrate the result of inserting these keys using linear probing, using quadratic probing with <i class="emphasis">c</i><sub>1</sub> = 1 and <i class="emphasis">c</i><sub>2</sub> = 3, and using double hashing with <i class="emphasis">h</i><sub>2</sub>(<i class="emphasis">k</i>) = 1 + (<i class="emphasis">k</i> mod (<i class="emphasis">m</i> - 1)).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 11.4-2</span></span><a name="768"></a><a name="ch11ex25"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Write pseudocode for HASH-DELETE as outlined in the text, and modify HASH-INSERT to handle the special value DELETED.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 11.4-3: </span><span class="unicode">&#8902;</span></span><a name="769"></a><a name="ch11ex26"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that we use double hashing to resolve collisions; that is, we use the hash function <i class="emphasis">h</i>(<i class="emphasis">k</i>, <i class="emphasis">i</i>) = (<i class="emphasis">h</i><sub>1</sub>(<i class="emphasis">k</i>)+<i class="emphasis">ih</i><sub>2</sub>(<i class="emphasis">k</i>)) mod <i class="emphasis">m</i>. Show that if <i class="emphasis">m</i> and <i class="emphasis">h</i><sub>2</sub>(<i class="emphasis">k</i>) have greatest common divisor <i class="emphasis">d</i> <span class="unicode">&ge;</span> 1 for some key <i class="emphasis">k</i>, then an unsuccessful search for key <i class="emphasis">k</i> examines (1/<i class="emphasis">d</i>)th of the hash table before returning to slot <i class="emphasis">h</i><sub>1</sub>(<i class="emphasis">k</i>). Thus, when <i class="emphasis">d</i> = 1, so that <i class="emphasis">m</i> and <i class="emphasis">h</i><sub>2</sub>(<i class="emphasis">k</i>) are relatively prime, the search may examine the entire hash table. (<i class="emphasis">Hint:</i> See <a href="DDU0199.html#2624" target="_parent" class="chapterjump">Chapter 31</a>.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 11.4-4</span></span><a name="770"></a><a name="ch11ex27"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Consider an open-address hash table with uniform hashing. Give upper bounds on the expected number of probes in an unsuccessful search and on the expected number of probes in a successful search when the load factor is 3/4 and when it is 7/8.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="771"></a><a name="IDX-245"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 11.4-5: </span><span class="unicode">&#8902;</span></span><a name="772"></a><a name="ch11ex28"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Consider an open-address hash table with a load factor <span class="unicode">&alpha;</span>. Find the nonzero value <span class="unicode">&alpha;</span> for which the expected number of probes in an unsuccessful search equals twice the expected number of probes in a successful search. Use the upper bounds given by <a class="internaljump" href="#ch11ex21">Theorems 11.6</a> and <a class="internaljump" href="#ch11ex23">11.8</a> for these expected numbers of probes.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0066.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0068.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
