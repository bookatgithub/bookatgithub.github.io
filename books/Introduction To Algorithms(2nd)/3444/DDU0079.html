<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>13.4 Deletion</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0078.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0080.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch13"></a>
<div class="section">
<h2 class="first-section-title">
<a name="908"></a><a name="ch13lev1sec4"></a><span class="section-titlelabel">13.4 </span>Deletion</h2>
<a name="909"></a><a name="IDX-288"></a>
<p class="para">Like the other basic operations on an <i class="emphasis">n</i>-node red-black tree, deletion of a node takes time <i class="emphasis">O</i>(lg <i class="emphasis">n</i>). Deleting a node from a red-black tree is only slightly more complicated than inserting a node.</p>
<p class="para">The procedure RB-DELETE is a minor modification of the TREE-DELETE procedure (<a href="DDU0073.html#824" target="_parent" class="chapterjump">Section 12.3</a>). After splicing out a node, it calls an auxiliary procedure RB-DELETE-FIXUP that changes colors and performs rotations to restore the red-black properties.</p>
<div class="informalexample">
<pre class="literallayout-normal">
RB-DELETE(<i class="emphasis">T</i>, <i class="emphasis">z</i>)
 1 <b class="bold">if</b> <i class="emphasis">left</i>[<i class="emphasis">z</i>] = <i class="emphasis">nil</i>[<i class="emphasis">T</i>] or <i class="emphasis">right</i>[<i class="emphasis">z</i>] = <i class="emphasis">nil</i>[<i class="emphasis">T</i>]
 2    <b class="bold">then</b> <i class="emphasis">y</i> <span class="unicode">&larr;</span> <i class="emphasis">z</i>
 3    <b class="bold">else</b> <i class="emphasis">y</i> <span class="unicode">&larr;</span> TREE-SUCCESSOR(<i class="emphasis">z</i>)
 4 <b class="bold">if</b> <i class="emphasis">left</i>[<i class="emphasis">y</i>] <span class="unicode">&ne;</span> <i class="emphasis">nil</i>[<i class="emphasis">T</i>]
 5    <b class="bold">then</b> <i class="emphasis">x</i> <span class="unicode">&larr;</span> <i class="emphasis">left</i>[<i class="emphasis">y</i>]
 6    <b class="bold">else</b> <i class="emphasis">x</i> <span class="unicode">&larr;</span> <i class="emphasis">right</i>[<i class="emphasis">y</i>]
 7 <i class="emphasis">p</i>[<i class="emphasis">x</i>] <span class="unicode">&larr;</span> <i class="emphasis">p</i>[<i class="emphasis">y</i>]
 8 <b class="bold">if</b> <i class="emphasis">p</i>[<i class="emphasis">y</i>] = <i class="emphasis">nil</i>[<i class="emphasis">T</i>]
 9    <b class="bold">then</b> <i class="emphasis">root</i>[<i class="emphasis">T</i>] <span class="unicode">&larr;</span> <i class="emphasis">x</i>
10    <b class="bold">else if</b> <i class="emphasis">y</i> = <i class="emphasis">left</i>[<i class="emphasis">p</i>[<i class="emphasis">y</i>]]
11            <b class="bold">then</b> <i class="emphasis">left</i>[<i class="emphasis">p</i>[<i class="emphasis">y</i>]] <span class="unicode">&larr;</span> <i class="emphasis">x</i>
12            <b class="bold">else</b> <i class="emphasis">right</i>[<i class="emphasis">p</i>[<i class="emphasis">y</i>]] <span class="unicode">&larr;</span> <i class="emphasis">x</i>
13 <b class="bold">if</b> <i class="emphasis">y</i> 3<span class="unicode">&ne;</span> <i class="emphasis">z</i>
14    <b class="bold">then</b> <i class="emphasis">key</i>[<i class="emphasis">z</i>] <span class="unicode">&larr;</span> <i class="emphasis">key</i>[<i class="emphasis">y</i>]
15         copy <i class="emphasis">y</i>'s satellite data into <i class="emphasis">z</i>
16 <b class="bold">if</b> <i class="emphasis">color</i>[<i class="emphasis">y</i>] = BLACK
17    <b class="bold">then</b> RB-DELETE-FIXUP(<i class="emphasis">T</i>, <i class="emphasis">x</i>)
18 <b class="bold">return</b> <i class="emphasis">y</i>
</pre>
</div>
<p class="para">There are three differences between the procedures TREE-DELETE and RB-DELETE. First, all references to NIL in TREE-DELETE are replaced by references to the sentinel <i class="emphasis">nil</i>[<i class="emphasis">T</i> ] in RB-DELETE. Second, the test for whether <i class="emphasis">x</i> is NIL in line 7 of TREE-DELETE is removed, and the assignment <i class="emphasis">p</i>[<i class="emphasis">x</i>] <span class="unicode">&larr;</span> <i class="emphasis">p</i>[<i class="emphasis">y</i>] is performed unconditionally in line 7 of RB-DELETE. Thus, if <i class="emphasis">x</i> is the sentinel <i class="emphasis">nil</i>[<i class="emphasis">T</i>], its parent pointer points to the parent of the spliced-out node <i class="emphasis">y</i>. Third, a call to RB-DELETE-FIXUP is made in lines 16<span class="unicode">-</span>17 if <i class="emphasis">y</i> is black. If <i class="emphasis">y</i> is red, the red-black properties still hold when <i class="emphasis">y</i> is spliced out, for the following reasons:</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">no black-heights in the tree have changed,</p>
</li>
<li class="listitem">
<p class="first-para">no red nodes have been made adjacent, and</p>
<a name="910"></a><a name="IDX-289"></a>
</li>
<li class="listitem">
<p class="first-para">since <i class="emphasis">y</i> could not have been the root if it was red, the root remains black.</p>
</li>
</ul>
<p class="para">The node <i class="emphasis">x</i> passed to RB-DELETE-FIXUP is one of two nodes: either the node that was <i class="emphasis">y</i>'s sole child before <i class="emphasis">y</i> was spliced out if <i class="emphasis">y</i> had a child that was not the sentinel <i class="emphasis">nil</i>[<i class="emphasis">T</i> ], or, if <i class="emphasis">y</i> had no children, <i class="emphasis">x</i> is the sentinel <i class="emphasis">nil</i>[<i class="emphasis">T</i> ]. In the latter case, the unconditional assignment in line 7 guarantees that <i class="emphasis">x</i>'s parent is now the node that was previously <i class="emphasis">y</i>'s parent, whether <i class="emphasis">x</i> is a key-bearing internal node or the sentinel <i class="emphasis">nil</i>[<i class="emphasis">T</i>].</p>
<p class="para">We can now examine how the procedure RB-DELETE-FIXUP restores the red-black properties to the search tree.</p>
<div class="informalexample">
<pre class="literallayout-normal">
RB-DELETE-FIXUP(<i class="emphasis">T</i>, <i class="emphasis">x</i>)
 1 <b class="bold">while</b> <i class="emphasis">x</i> <span class="unicode">&ne;</span> <i class="emphasis">root</i>[<i class="emphasis">T</i>] and <i class="emphasis">color</i>[<i class="emphasis">x</i>] = BLACK
 2     <b class="bold">do if</b> <i class="emphasis">x</i> = <i class="emphasis">left</i>[<i class="emphasis">p</i>[<i class="emphasis">x</i>]]
 3           <b class="bold">then</b> <i class="emphasis">w</i> <span class="unicode">&larr;</span> <i class="emphasis">right</i>[<i class="emphasis">p</i>[<i class="emphasis">x</i>]]
 4                <b class="bold">if</b> <i class="emphasis">color</i>[<i class="emphasis">w</i>] = RED
 5                   <b class="bold">then</b> <i class="emphasis">color</i>[<i class="emphasis">w</i>] <span class="unicode">&larr;</span> BLACK                        <span class="unicode">&#9657;</span>  Case 1
 6                        <i class="emphasis">color</i>[<i class="emphasis">p</i>[<i class="emphasis">x</i>]] <span class="unicode">&larr;</span> RED                       <span class="unicode">&#9657;</span>  Case 1
 7                        LEFT-ROTATE(<i class="emphasis">T</i>, <i class="emphasis">p</i>[<i class="emphasis">x</i>])                    <span class="unicode">&#9657;</span>  Case 1
 8                        <i class="emphasis">w</i> <span class="unicode">&larr;</span> <i class="emphasis">right</i>[<i class="emphasis">p</i>[<i class="emphasis">x</i>]]                         <span class="unicode">&#9657;</span>  Case 1
 9                <b class="bold">if</b> <i class="emphasis">color</i>[<i class="emphasis">left</i>[<i class="emphasis">w</i>]] = BLACK and <i class="emphasis">color</i>[<i class="emphasis">right</i>[<i class="emphasis">w</i>]] = BLACK
10                   <b class="bold">then</b> <i class="emphasis">color</i>[<i class="emphasis">w</i>] <span class="unicode">&larr;</span> RED                          <span class="unicode">&#9657;</span>  Case 2
11                        <i class="emphasis">x</i> <i class="emphasis">p</i>[<i class="emphasis">x</i>]                                  <span class="unicode">&#9657;</span>  Case 2
12                   <b class="bold">else if</b> <i class="emphasis">color</i>[<i class="emphasis">right</i>[<i class="emphasis">w</i>]] = BLACK
13                           <b class="bold">then</b> <i class="emphasis">color</i>[<i class="emphasis">left</i>[<i class="emphasis">w</i>]] <span class="unicode">&larr;</span> BLACK          <span class="unicode">&#9657;</span>  Case 3
14                                <i class="emphasis">color</i>[<i class="emphasis">w</i>] <span class="unicode">&larr;</span> RED                  <span class="unicode">&#9657;</span>  Case 3
15                                RIGHT-ROTATE(<i class="emphasis">T</i>, <i class="emphasis">w</i>)              <span class="unicode">&#9657;</span>  Case 3
16                                <i class="emphasis">w</i> <span class="unicode">&larr;</span> <i class="emphasis">right</i>[<i class="emphasis">p</i>[<i class="emphasis">x</i>]]                 <span class="unicode">&#9657;</span>  Case 3
17                         <i class="emphasis">color</i>[<i class="emphasis">w</i>] <span class="unicode">&larr;</span> <i class="emphasis">color</i>[<i class="emphasis">p</i>[<i class="emphasis">x</i>]]                 <span class="unicode">&#9657;</span>  Case 4
18                         <i class="emphasis">color</i>[<i class="emphasis">p</i>[<i class="emphasis">x</i>]] <span class="unicode">&larr;</span> BLACK                    <span class="unicode">&#9657;</span>  Case 4
19                         <i class="emphasis">color</i>[<i class="emphasis">right</i>[<i class="emphasis">w</i>]] <span class="unicode">&larr;</span> BLACK                <span class="unicode">&#9657;</span>  Case 4
20                         LEFT-ROTATE(<i class="emphasis">T</i>, <i class="emphasis">p</i>[<i class="emphasis">x</i>])                   <span class="unicode">&#9657;</span>  Case 4
21                         <i class="emphasis">x</i> <span class="unicode">&larr;</span> <i class="emphasis">root</i>[<i class="emphasis">T</i>]                            <span class="unicode">&#9657;</span>  Case 4
22        <b class="bold">else</b> (same as <b class="bold">then</b> clause with "right" and "left" exchanged)
23 <i class="emphasis">color</i>[<i class="emphasis">x</i>] <span class="unicode">&larr;</span> BLACK
</pre>
</div>
<p class="para">If the spliced-out node <i class="emphasis">y</i> in RB-DELETE is black, three problems may arise. First, if <i class="emphasis">y</i> had been the root and a red child of <i class="emphasis">y</i> becomes the new root, we have violated property 2. Second, if both <i class="emphasis">x</i> and <i class="emphasis">p</i>[<i class="emphasis">y</i>] (which is now also <i class="emphasis">p</i>[<i class="emphasis">x</i>]) were red, then we have violated property 4. Third, <i class="emphasis">y</i>'s removal causes any path that previously contained <i class="emphasis">y</i> to have one fewer black node. Thus, property 5 is now violated by any ancestor of <i class="emphasis">y</i> in the tree. We can correct this problem by saying <a name="911"></a><a name="IDX-290"></a>that node <i class="emphasis">x</i> has an "extra" black. That is, if we add 1 to the count of black nodes on any path that contains <i class="emphasis">x</i>, then under this interpretation, property 5 holds. When we splice out the black node <i class="emphasis">y</i>, we "push" its blackness onto its child. The problem is that now node <i class="emphasis">x</i> is neither red nor black, thereby violating property 1. Instead, node <i class="emphasis">x</i> is either "doubly black" or "red-and-black," and it contributes either 2 or 1, respectively, to the count of black nodes on paths containing <i class="emphasis">x</i>. The <i class="emphasis">color</i> attribute of <i class="emphasis">x</i> will still be either RED (if <i class="emphasis">x</i> is red-and-black) or BLACK (if <i class="emphasis">x</i> is doubly black). In other words, the extra black on a node is reflected in <i class="emphasis">x</i>'s pointing to the node rather than in the <i class="emphasis">color</i> attribute.</p>
<p class="para">The procedure RB-DELETE-FIXUP restores properties 1, 2, and 4. <a class="internaljump" href="#ch13ex20">Exercises 13.4-1</a> and <a class="internaljump" href="#ch13ex21">13.4-2</a> ask you to show that the procedure restores properties 2 and 4, and so in the remainder of this section, we shall focus on property 1. The goal of the <b class="bold">while</b> loop in lines 1<span class="unicode">-</span>22 is to move the extra black up the tree until</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="first-para">
<i class="emphasis">x</i> points to a red-and-black node, in which case we color <i class="emphasis">x</i> (singly) black in line 23,</p>
</li>
<li class="listitem">
<p class="first-para">
<i class="emphasis">x</i> points to the root, in which case the extra black can be simply "removed," or</p>
</li>
<li class="listitem">
<p class="first-para">suitable rotations and recolorings can be performed.</p>
</li>
</ol>
<p class="para">Within the <b class="bold">while</b> loop, <i class="emphasis">x</i> always points to a nonroot doubly black node. We determine in line 2 whether <i class="emphasis">x</i> is a left child or a right child of its parent <i class="emphasis">p</i>[<i class="emphasis">x</i>]. (We have given the code for the situation in which <i class="emphasis">x</i> is a left child; the situation in which <i class="emphasis">x</i> is a right child<span class="unicode">-</span>line 22<span class="unicode">-</span>is symmetric.) We maintain a pointer <i class="emphasis">w</i> to the sibling of <i class="emphasis">x</i>. Since node <i class="emphasis">x</i> is doubly black, node <i class="emphasis">w</i> cannot be <i class="emphasis">nil</i>[<i class="emphasis">T</i>]; otherwise, the number of blacks on the path from <i class="emphasis">p</i>[<i class="emphasis">x</i>] to the (singly black) leaf <i class="emphasis">w</i> would be smaller than the number on the path from <i class="emphasis">p</i>[<i class="emphasis">x</i>] to <i class="emphasis">x</i>.</p>
<p class="para">The four cases<sup>[<a name="N1056" href="#ftn.N1056">2</a>]</sup> in the code are illustrated in <a class="internaljump" href="#ch13fig07">Figure 13.7</a>. Before examining each case in detail, let's look more generally at how we can verify that the transformation in each of the cases preserves property 5. The key idea is that in each case the number of black nodes (including <i class="emphasis">x</i>'s extra black) from (and including) the root of the subtree shown to each of the subtrees <span class="unicode">&alpha;</span>, <span class="unicode">&beta;</span>, ..., <span class="unicode">&zeta;</span> is preserved by the transformation. Thus, if property 5 holds prior to the transformation, it continues to hold afterward. For example, in <a class="internaljump" href="#ch13fig07">Figure 13.7(a)</a>, which illustrates case 1, the number of black nodes from the root to either subtree <span class="unicode">&alpha;</span> or <span class="unicode">&beta;</span> is 3, both before and after the transformation. (Again, remember that node <i class="emphasis">x</i> adds an extra black.) Similarly, the number of black nodes from the root to any of <span class="unicode">&gamma;</span>, <span class="unicode">&delta;</span>, <span class="unicode">&epsilon;</span>, and is <span class="unicode">&zeta;</span>, both before and after the transformation. In <a class="internaljump" href="#ch13fig07">Figure 13.7(b)</a>, the counting must involve the value <i class="emphasis">c</i> of the <i class="emphasis">color</i> attribute of the root of the subtree shown, which can be either RED or BLACK. If we define count(RED) = 0 and count(BLACK) = 1, then the num<a name="912"></a><a name="IDX-291"></a><a name="913"></a><a name="IDX-292"></a>ber of black nodes from the root to <span class="unicode">&alpha;</span> is 2 + count(<i class="emphasis">c</i>), both before and after the transformation. In this case, after the transformation, the new node <i class="emphasis">x</i> has <i class="emphasis">color</i> attribute <i class="emphasis">c</i>, but this node is really either red-and-black (if <i class="emphasis">c</i> = RED) or doubly black (if <i class="emphasis">c</i> = BLACK). The other cases can be verified similarly (see <a class="internaljump" href="#ch13ex24">Exercise 13.4-5</a>).</p>
<div class="figure">
<a name="914"></a><a name="ch13fig07"></a><span class="figuremediaobject"><a href="images/fig313%5F01%5F0%2Ejpg" NAME="IMG_424" target="_parent"><img src="images/fig313_01.jpg" height="313" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 13.7: </span>The cases in the <i class="emphasis">while</i> loop of the procedure RB-DELETE-FIXUP. Darkened nodes have <i class="emphasis">color</i> attributes BLACK, heavily shaded nodes have <i class="emphasis">color</i> attributes RED, and lightly shaded nodes have <i class="emphasis">color</i> attributes represented by <i class="emphasis">c</i> and <i class="emphasis">c<span class="unicode">&prime;</span></i>, which may be either RED or BLACK. The letters <span class="unicode">&alpha;</span>, <i class="emphasis"><span class="unicode">&beta;</span></i>, ..., <span class="unicode">&zeta;</span> represent arbitrary subtrees. In each case, the configuration on the left is transformed into the configuration on the right by changing some colors and/or performing a rotation. Any node pointed to by <i class="emphasis">x</i> has an extra black and is either doubly black or red-and-black. The only case that causes the loop to repeat is case 2. <i class="emphasis">(a)</i> Case 1 is transformed to case 2, 3, or 4 by exchanging the colors of nodes <i class="emphasis">B</i> and <i class="emphasis">D</i> and performing a left rotation. <i class="emphasis">(b)</i> In case 2, the extra black represented by the pointer <i class="emphasis">x</i> is moved up the tree by coloring node <i class="emphasis">D</i> red and setting <i class="emphasis">x</i> to point to node <i class="emphasis">B</i>. If we enter case 2 through case 1, the <i class="emphasis">while</i> loop terminates because the new node <i class="emphasis">x</i> is red-and-black, and therefore the value <i class="emphasis">c</i> of its <i class="emphasis">color</i> attribute is RED. <i class="emphasis">(c)</i> Case 3 is transformed to case 4 by exchanging the colors of nodes <i class="emphasis">C</i> and <i class="emphasis">D</i> and performing a right rotation. <i class="emphasis">(d)</i> In Case 4, the extra black represented by <i class="emphasis">x</i> can be removed by changing some colors and performing a left rotation (without violating the red-black properties), and the loop terminates.</span>
</div>
<div class="section">
<h5 class="sect5-title">
<a name="915"></a><a name="ch13lev4sec4"></a><span class="section-titlelabel">Case 1: </span>x's sibling w is red</h5>
<p class="first-para">Case 1 (lines 5<span class="unicode">-</span>8 of RB-DELETE-FIXUP and <a class="internaljump" href="#ch13fig07">Figure 13.7(a)</a>) occurs when node <i class="emphasis">w</i>, the sibling of node <i class="emphasis">x</i>, is red. Since <i class="emphasis">w</i> must have black children, we can switch the colors of <i class="emphasis">w</i> and <i class="emphasis">p</i>[<i class="emphasis">x</i>] and then perform a left-rotation on <i class="emphasis">p</i>[<i class="emphasis">x</i>] without violating any of the red-black properties. The new sibling of <i class="emphasis">x</i>, which is one of <i class="emphasis">w</i>'s children prior to the rotation, is now black, and thus we have converted case 1 into case 2, 3, or 4.</p>
<p class="last-para">Cases 2, 3, and 4 occur when node <i class="emphasis">w</i> is black; they are distinguished by the colors of <i class="emphasis">w</i>'s children.</p>

</div>
<div class="section">
<h5 class="sect5-title">
<a name="916"></a><a name="ch13lev4sec5"></a><span class="section-titlelabel">Case 2: </span>x's sibling w is black, and both of w's children are black</h5>
<p class="first-para">In case 2 (lines 10<span class="unicode">-</span>11 of RB-DELETE-FIXUP and <a class="internaljump" href="#ch13fig07">Figure 13.7(b)</a>), both of <i class="emphasis">w</i>'s children are black. Since <i class="emphasis">w</i> is also black, we take one black off both <i class="emphasis">x</i> and <i class="emphasis">w</i>, leaving <i class="emphasis">x</i> with only one black and leaving <i class="emphasis">w</i> red. To compensate for removing one black from <i class="emphasis">x</i> and <i class="emphasis">w</i>, we would like to add an extra black to <i class="emphasis">p</i>[<i class="emphasis">x</i>], which was originally either red or black. We do so by repeating the <b class="bold">while</b> loop with <i class="emphasis">p</i>[<i class="emphasis">x</i>] as the new node <i class="emphasis">x</i>. Observe that if we enter case 2 through case 1, the new node <i class="emphasis">x</i> is red-and-black, since the original <i class="emphasis">p</i>[<i class="emphasis">x</i>] was red. Hence, the value <i class="emphasis">c</i> of the <i class="emphasis">color</i> attribute of the new node <i class="emphasis">x</i> is RED, and the loop terminates when it tests the loop condition. The new node <i class="emphasis">x</i> is then colored (singly) black in line 23.</p>

</div>
<div class="section">
<h5 class="sect5-title">
<a name="917"></a><a name="ch13lev4sec6"></a><span class="section-titlelabel">Case 3: </span>x's sibling w is black, w's left child is red, and w's right child is black</h5>
<p class="first-para">Case 3 (lines 13<span class="unicode">-</span>16 and <a class="internaljump" href="#ch13fig07">Figure 13.7(c)</a>) occurs when <i class="emphasis">w</i> is black, its left child is red, and its right child is black. We can switch the colors of <i class="emphasis">w</i> and its left child <i class="emphasis">left</i>[<i class="emphasis">w</i>] and then perform a right rotation on <i class="emphasis">w</i> without violating any of the red-black properties. The new sibling <i class="emphasis">w</i> of <i class="emphasis">x</i> is now a black node with a red right child, and thus we have transformed case 3 into case 4.</p>

</div>
<div class="section">
<h5 class="sect5-title">
<a name="918"></a><a name="ch13lev4sec7"></a><span class="section-titlelabel">Case 4: </span>x's sibling w is black, and w's right child is red</h5>
<p class="first-para">Case 4 (lines 17<span class="unicode">-</span>21 and <a class="internaljump" href="#ch13fig07">Figure 13.7(d)</a>) occurs when node <i class="emphasis">x</i>'s sibling <i class="emphasis">w</i> is black and <i class="emphasis">w</i>'s right child is red. By making some color changes and performing a left rotation on <i class="emphasis">p</i>[<i class="emphasis">x</i>], we can remove the extra black on <i class="emphasis">x</i>, making it singly black, without violating any of the red-black properties. Setting <i class="emphasis">x</i> to be the root causes the <b class="bold">while</b> loop to terminate when it tests the loop condition.</p>
<a name="919"></a><a name="IDX-293"></a>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="920"></a><a name="ch13lev3sec2"></a>Analysis</h4>
<p class="first-para">What is the running time of RB-DELETE? Since the height of a red-black tree of <i class="emphasis">n</i> nodes is <i class="emphasis">O</i>(lg <i class="emphasis">n</i>), the total cost of the procedure without the call to RB-DELETE-FIXUP takes <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) time. Within RB-DELETE-FIXUP, cases 1, 3, and 4 each terminate after performing a constant number of color changes and at most three rotations. Case 2 is the only case in which the <b class="bold">while</b> loop can be repeated, and then the pointer <i class="emphasis">x</i> moves up the tree at most <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) times and no rotations are performed. Thus, the procedure RB-DELETE-FIXUP takes <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) time and performs at most three rotations, and the overall time for RB-DELETE is therefore also <i class="emphasis">O</i>(lg <i class="emphasis">n</i>).</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 13.4-1</span></span><a name="921"></a><a name="ch13ex20"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Argue that after executing RB-DELETE-FIXUP, the root of the tree must be black.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 13.4-2</span></span><a name="922"></a><a name="ch13ex21"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Argue that if in RB-DELETE both <i class="emphasis">x</i> and <i class="emphasis">p</i>[<i class="emphasis">y</i>] are red, then property 4 is restored by the call RB-DELETE-FIXUP(<i class="emphasis">T</i>, <i class="emphasis">x</i>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 13.4-3</span></span><a name="923"></a><a name="ch13ex22"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">In <a href="DDU0078.html#903" target="_parent" class="chapterjump">Exercise 13.3-2</a>, you found the red-black tree that results from successively inserting the keys 41, 38, 31, 12, 19, 8 into an initially empty tree. Now show the red-black trees that result from the successive deletion of the keys in the order 8, 12, 19, 31, 38, 41.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 13.4-4</span></span><a name="924"></a><a name="ch13ex23"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">In which lines of the code for RB-DELETE-FIXUP might we examine or modify the sentinel <i class="emphasis">nil</i>[<i class="emphasis">T</i>]?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 13.4-5</span></span><a name="925"></a><a name="ch13ex24"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">In each of the cases of <a class="internaljump" href="#ch13fig07">Figure 13.7</a>, give the count of black nodes from the root of the subtree shown to each of the subtrees <span class="unicode">&alpha;</span>, <i class="emphasis"><span class="unicode">&beta;</span></i>, ..., <span class="unicode">&zeta;</span>, and verify that each count remains the same after the transformation. When a node has a <i class="emphasis">color</i> attribute <i class="emphasis">c</i> or <i class="emphasis">c</i><span class="unicode">&prime;</span>, use the notation count(<i class="emphasis">c</i>) or count(<i class="emphasis">c</i><span class="unicode">&prime;</span>) symbolically in your count.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 13.4-6</span></span><a name="926"></a><a name="ch13ex25"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Professors Skelton and Baron are concerned that at the start of case 1 of RB-DELETE-FIXUP, the node <i class="emphasis">p</i>[<i class="emphasis">x</i>] might not be black. If the professors are correct, then lines 5<span class="unicode">-</span>6 are wrong. Show that <i class="emphasis">p</i>[<i class="emphasis">x</i>] must be black at the start of case 1, so that the professors have nothing to worry about.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="927"></a><a name="IDX-294"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 13.4-7</span></span><a name="928"></a><a name="ch13ex26"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that a node <i class="emphasis">x</i> is inserted into a red-black tree with RB-INSERT and then immediately deleted with RB-DELETE. Is the resulting red-black tree the same as the initial red-black tree? Justify your answer.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 13-1: </span>Persistent dynamic sets</span><a name="929"></a><a name="ch13ex27"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">During the course of an algorithm, we sometimes find that we need to maintain past versions of a dynamic set as it is updated. Such a set is called <b class="bold"><i class="emphasis">persistent</i></b>. One way to implement a persistent set is to copy the entire set whenever it is modified, but this approach can slow down a program and also consume much space. Sometimes, we can do much better.</p>
<p class="para">Consider a persistent set <i class="emphasis">S</i> with the operations INSERT, DELETE, and SEARCH, which we implement using binary search trees as shown in <a class="internaljump" href="#ch13fig08">Figure 13.8(a)</a>. We maintain a separate root for every version of the set. In order to insert the key 5 into the set, we create a new node with key 5. This node becomes the left child of a new node with key 7, since we cannot modify the existing node with key 7. Similarly, the new node with key 7 becomes the left child of a new node with key 8 whose right child is the existing node with key 10. The new node with key 8 becomes, in turn, the right child of a new root <i class="emphasis">r</i><span class="unicode">&prime;</span> with key 4 whose left child is the existing node with key 3. We thus copy only part of the tree and share some of the nodes with the original tree, as shown in <a class="internaljump" href="#ch13fig08">Figure 13.8(b)</a>.</p>
<p class="para">
<div class="figure">
<a name="930"></a><a name="ch13fig08"></a><span class="figuremediaobject"><a href="images/fig317%5F01%5F0%2Ejpg" NAME="IMG_425" target="_parent"><img src="images/fig317_01.jpg" height="160" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 13.8: </span><i class="emphasis">(a)</i> A binary search tree with keys 2, 3, 4, 7, 8, 10. <i class="emphasis">(b)</i> The persistent binary search tree that results from the insertion of key 5. The most recent version of the set consists of the nodes reachable from the root <i class="emphasis">r<span class="unicode">&prime;</span></i>, and the previous version consists of the nodes reachable from <i class="emphasis">r</i>. Heavily shaded nodes are added when key 5 is inserted.</span>
</div>
</p>
<p class="para">Assume that each tree node has the fields <i class="emphasis">key</i>, <i class="emphasis">left</i>, and <i class="emphasis">right</i> but no parent field. (See also <a href="DDU0078.html#907" target="_parent" class="chapterjump">Exercise 13.3-6</a>.)</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">For a general persistent binary search tree, identify the nodes that need to be changed to insert a key <i class="emphasis">k</i> or delete a node <i class="emphasis">y</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Write a procedure PERSISTENT-TREE-INSERT that, given a persistent tree <i class="emphasis">T</i> and a key <i class="emphasis">k</i> to insert, returns a new persistent tree <i class="emphasis">T</i><span class="unicode">&prime;</span> that is the result of inserting <i class="emphasis">k</i> into <i class="emphasis">T</i>.</p>
</li>
<li class="listitem">
<p class="first-para">If the height of the persistent binary search tree <i class="emphasis">T</i> is <i class="emphasis">h</i>, what are the time and space requirements of your implementation of PERSISTENT-TREE-INSERT? (The space requirement is proportional to the number of new nodes allocated.)</p>
</li>
<li class="listitem">
<p class="first-para">Suppose that we had included the parent field in each node. In this case, PERSISTENT-TREE-INSERT would need to perform additional copying. Prove that PERSISTENT-TREE-INSERT would then require <span class="unicode">&Omega;</span>(<i class="emphasis">n</i>) time and space, where <i class="emphasis">n</i> is the number of nodes in the tree.<a name="931"></a><a name="IDX-295"></a>
</p>
</li>
<li class="listitem">
<p class="first-para">Show how to use red-black trees to guarantee that the worst-case running time and space are <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) per insertion or deletion.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 13-2: </span>Join operation on red-black trees</span><a name="932"></a><a name="ch13ex28"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The <b class="bold"><i class="emphasis">join</i></b> operation takes two dynamic sets <i class="emphasis">S</i><sub>1</sub> and <i class="emphasis">S</i><sub>2</sub> and an element <i class="emphasis">x</i> such that for any <i class="emphasis">x</i><sub>1</sub> <span class="unicode">&isin;</span> <i class="emphasis">S</i><sub>1</sub> and <i class="emphasis">x</i><sub>2</sub> <span class="unicode">&isin;</span> <i class="emphasis">S</i><sub>2</sub>, we have <i class="emphasis">key</i>[<i class="emphasis">x</i><sub>1</sub>] <span class="unicode">&le;</span> <i class="emphasis">key</i>[<i class="emphasis">x</i>] <span class="unicode">&le;</span> <i class="emphasis">key</i>[<i class="emphasis">x</i><sub>2</sub>]. It returns a set <i class="emphasis">S</i> = <i class="emphasis">S</i><sub>1</sub> <span class="unicode">&cup;</span> {<i class="emphasis">x</i>} <span class="unicode">&cup;</span> <i class="emphasis">S</i><sub>2</sub>. In this problem, we investigate how to implement the join operation on red-black trees.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Given a red-black tree <i class="emphasis">T</i>, we store its black-height as the field <i class="emphasis">bh</i>[<i class="emphasis">T</i>]. Argue that this field can be maintained by RB-INSERT and RB-DELETE without requiring extra storage in the nodes of the tree and without increasing the asymptotic running times. Show that while descending through <i class="emphasis">T</i>, we can determine the black-height of each node we visit in <i class="emphasis">O</i>(1) time per node visited.</p>
</li>
</ol>
<p class="para">We wish to implement the operation RB-JOIN(<i class="emphasis">T</i><sub>1</sub>, <i class="emphasis">x</i>, <i class="emphasis">T</i><sub>2</sub>), which destroys <i class="emphasis">T</i><sub>1</sub> and <i class="emphasis">T</i><sub>2</sub> and returns a red-black tree <i class="emphasis">T</i> = <i class="emphasis">T</i><sub>1</sub> <span class="unicode">&cup;</span> {<i class="emphasis">x</i>} <span class="unicode">&cup;</span> <i class="emphasis">T</i><sub>2</sub>. Let <i class="emphasis">n</i> be the total number of nodes in <i class="emphasis">T</i><sub>1</sub> and <i class="emphasis">T</i><sub>2</sub>.</p>
<ol class="orderedlist" start="2" type="a">
<li class="first-listitem">
<p class="first-para">Assume that <i class="emphasis">bh</i>[<i class="emphasis">T</i><sub>1</sub>] <span class="unicode">&ge;</span> <i class="emphasis">bh</i>[<i class="emphasis">T</i><sub>2</sub>]. Describe an <i class="emphasis">O</i>(lg <i class="emphasis">n</i>)-time algorithm that finds a black node <i class="emphasis">y</i> in <i class="emphasis">T</i><sub>1</sub> with the largest key from among those nodes whose black-height is <i class="emphasis">bh</i>[<i class="emphasis">T</i><sub>2</sub>].</p>
<a name="933"></a><a name="IDX-296"></a>
</li>
<li class="listitem">
<p class="first-para">Let <i class="emphasis">T<sub>y</sub></i> be the subtree rooted at <i class="emphasis">y</i>. Describe how <i class="emphasis">T<sub>y</sub></i> <span class="unicode">&cup;</span> {<i class="emphasis">x</i>} <span class="unicode">&cup;</span> <i class="emphasis">T</i><sub>2</sub> can replace <i class="emphasis">T<sub>y</sub></i> in <i class="emphasis">O</i>(1) time without destroying the binary-search-tree property.</p>
</li>
<li class="listitem">
<p class="first-para">What color should we make <i class="emphasis">x</i> so that red-black properties 1, 3, and 5 are maintained? Describe how properties 2 and 4 can be enforced in <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) time.</p>
</li>
<li class="listitem">
<p class="first-para">Argue that no generality is lost by making the assumption in part (b). Describe the symmetric situation that arises when <i class="emphasis">bh</i>[<i class="emphasis">T</i><sub>1</sub>] = <i class="emphasis">bh</i>[<i class="emphasis">T</i><sub>2</sub>].</p>
</li>
<li class="listitem">
<p class="first-para">Argue that the running time of RB-JOIN is <i class="emphasis">O</i>(lg <i class="emphasis">n</i>).</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 13-3: </span>AVL trees</span><a name="934"></a><a name="ch13ex29"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">An <b class="bold"><i class="emphasis">AVL tree</i></b> is a binary search tree that is <b class="bold"><i class="emphasis">height balanced</i></b>: for each node <i class="emphasis">x</i>, the heights of the left and right subtrees of <i class="emphasis">x</i> differ by at most 1. To implement an AVL tree, we maintain an extra field in each node: <i class="emphasis">h</i>[<i class="emphasis">x</i>] is the height of node <i class="emphasis">x</i>. As for any other binary search tree <i class="emphasis">T</i>, we assume that <i class="emphasis">root</i>[<i class="emphasis">T</i>] points to the root node.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Prove that an AVL tree with n nodes has height <i class="emphasis">O</i>(lg <i class="emphasis">n</i>). (<i class="emphasis">Hint:</i> Prove that in an AVL tree of height <i class="emphasis">h</i>, there are at least <i class="emphasis">F<sub>h</sub></i> nodes, where <i class="emphasis">F<sub>h</sub></i> is the <i class="emphasis">h</i>th Fibonacci number.)</p>
</li>
<li class="listitem">
<p class="first-para">To insert into an AVL tree, a node is first placed in the appropriate place in binary search tree order. After this insertion, the tree may no longer be height balanced. Specifically, the heights of the left and right children of some node may differ by 2. Describe a procedure BALANCE(<i class="emphasis">x</i>), which takes a subtree rooted at <i class="emphasis">x</i> whose left and right children are height balanced and have heights that differ by at most 2, i.e., |<i class="emphasis">h</i>[<i class="emphasis">right</i>[<i class="emphasis">x</i>]] - <i class="emphasis">h</i>[<i class="emphasis">left</i>[<i class="emphasis">x</i>]]| <span class="unicode">&le;</span> 2, and alters the subtree rooted at <i class="emphasis">x</i> to be height balanced. (<i class="emphasis">Hint:</i> Use rotations.)</p>
</li>
<li class="listitem">
<p class="first-para">Using part (b), describe a recursive procedure AVL-INSERT(<i class="emphasis">x</i>, <i class="emphasis">z</i>), which takes a node <i class="emphasis">x</i> within an AVL tree and a newly created node <i class="emphasis">z</i> (whose key has already been filled in), and adds <i class="emphasis">z</i> to the subtree rooted at <i class="emphasis">x</i>, maintaining the property that <i class="emphasis">x</i> is the root of an AVL tree. As in TREE-INSERT from <a href="DDU0073.html#824" target="_parent" class="chapterjump">Section 12.3</a>, assume that <i class="emphasis">key</i>[<i class="emphasis">z</i>] has already been filled in and that <i class="emphasis">left</i>[<i class="emphasis">z</i>] = NIL and <i class="emphasis">right</i>[<i class="emphasis">z</i>] = NIL; also assume that <i class="emphasis">h</i>[<i class="emphasis">z</i>] = 0. Thus, to insert the node <i class="emphasis">z</i> into the AVL tree <i class="emphasis">T</i>, we call AVL-INSERT(<i class="emphasis">root</i>[<i class="emphasis">T</i>], <i class="emphasis">z</i>).</p>
</li>
<li class="listitem">
<p class="first-para">Give an example of an <i class="emphasis">n</i>-node AVL tree in which an AVL-INSERT operation causes <span class="unicode">&Omega;</span>(lg <i class="emphasis">n</i>) rotations to be performed.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 13-4: </span>Treaps</span><a name="935"></a><a name="ch13ex30"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">If we insert a set of <i class="emphasis">n</i> items into a binary search tree, the resulting tree may be horribly unbalanced, leading to long search times. As we saw in <a href="DDU0074.html#839" target="_parent" class="chapterjump">Section 12.4</a>, however, <a name="936"></a><a name="IDX-297"></a>randomly built binary search trees tend to be balanced. Therefore, a strategy that, on average, builds a balanced tree for a fixed set of items is to randomly permute the items and then insert them in that order into the tree.</p>
<p class="para">What if we do not have all the items at once? If we receive the items one at a time, can we still randomly build a binary search tree out of them?</p>
<p class="para">We will examine a data structure that answers this question in the affirmative. A <b class="bold"><i class="emphasis">treap</i></b> is a binary search tree with a modified way of ordering the nodes. <a class="internaljump" href="#ch13fig09">Figure 13.9</a> shows an example. As usual, each node <i class="emphasis">x</i> in the tree has a key value <i class="emphasis">key</i>[<i class="emphasis">x</i>]. In addition, we assign <i class="emphasis">priority</i>[<i class="emphasis">x</i>], which is a random number chosen independently for each node. We assume that all priorities are distinct and also that all keys are distinct. The nodes of the treap are ordered so that the keys obey the binary-search-tree property and the priorities obey the min-heap order property:</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">If <i class="emphasis">v</i> is a left child of <i class="emphasis">u</i>, then <i class="emphasis">key</i>[<i class="emphasis">v</i>] <span class="unicode">&lt;</span> <i class="emphasis">key</i>[<i class="emphasis">u</i>].</p>
</li>
<li class="listitem">
<p class="first-para">If <i class="emphasis">v</i> is a right child of <i class="emphasis">u</i>, then <i class="emphasis">key</i>[<i class="emphasis">v</i>] <span class="unicode">&gt;</span> <i class="emphasis">key</i>[<i class="emphasis">u</i>].</p>
</li>
<li class="listitem">
<p class="first-para">If <i class="emphasis">v</i> is a child of <i class="emphasis">u</i>, then <i class="emphasis">priority</i>[<i class="emphasis">v</i>] <span class="unicode">&gt;</span> <i class="emphasis">priority</i>[<i class="emphasis">u</i>].</p>
</li>
</ul>
<p class="para">
<div class="figure">
<a name="937"></a><a name="ch13fig09"></a><span class="figuremediaobject"><img src="images/fig319_01.jpg" height="194" width="327" alt="" border="0"></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 13.9: </span>A treap. Each node <i class="emphasis">x</i> is labeled with <i class="emphasis">key</i>[<i class="emphasis">x</i>] : <i class="emphasis">Priority</i>[<i class="emphasis">x</i>]. For example, the root has key <i class="emphasis">G</i> and priority 4.</span>
</div>
</p>
<p class="para">(This combination of properties is why the tree is called a "treap;" it has features of both a binary search tree and a heap.)</p>
<p class="para">It helps to think of treaps in the following way. Suppose that we insert nodes <i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, ..., <i class="emphasis">x<sub>n</sub></i>, with associated keys, into a treap. Then the resulting treap is the tree that would have been formed if the nodes had been inserted into a normal binary search tree in the order given by their (randomly chosen) priorities, i.e., <i class="emphasis">priority</i>[<i class="emphasis">x<sub>i</sub></i>] <span class="unicode">&lt;</span> <i class="emphasis">priority</i>[<i class="emphasis">x<sub>j</sub></i>] means that <i class="emphasis">x<sub>i</sub></i> was inserted before <i class="emphasis">x<sub>j</sub></i>.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Show that given a set of nodes <i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, ..., <i class="emphasis">x<sub>n</sub></i>, with associated keys and priorities (all distinct), there is a unique treap associated with these nodes.</p>
<a name="938"></a><a name="IDX-298"></a>
</li>
<li class="listitem">
<p class="first-para">Show that the expected height of a treap is <span class="unicode">&Theta;</span>(lg <i class="emphasis">n</i>), and hence the time to search for a value in the treap is <span class="unicode">&Theta;</span>(lg <i class="emphasis">n</i>).</p>
</li>
</ol>
<p class="para">Let us see how to insert a new node into an existing treap. The first thing we do is assign to the new node a random priority. Then we call the insertion algorithm, which we call TREAP-INSERT, whose operation is illustrated in <a class="internaljump" href="#ch13fig10">Figure 13.10</a>.</p>
<p class="para">
<div class="figure">
<a name="939"></a><a name="ch13fig10"></a><span class="figuremediaobject"><a href="images/fig321%5F01%5F0%2Ejpg" NAME="IMG_427" target="_parent"><img src="images/fig321_01.jpg" height="348" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 13.10: </span>The operation of TREAP-INSERT. <i class="emphasis">(a)</i> The original treap, prior to insertion. <i class="emphasis">(b)</i> The treap after inserting a node with key <i class="emphasis">C</i> and priority 25. <i class="emphasis">(c)<span class="unicode">-</span>(d)</i> Intermediate stages when inserting a node with key <i class="emphasis">D</i> and priority 9. <i class="emphasis">(e)</i> The treap after the insertion of parts (c) and (d) is done. <i class="emphasis">(f)</i> The treap after inserting a node with key <i class="emphasis">F</i> and priority 2.</span>
</div>
</p>
<ol class="orderedlist" start="3" type="a">
<li class="first-listitem">
<p class="first-para">Explain how TREAP-INSERT works. Explain the idea in English and give pseudocode. (<i class="emphasis">Hint:</i> Execute the usual binary-search-tree insertion procedure and then perform rotations to restore the min-heap order property.)</p>
</li>
<li class="listitem">
<p class="first-para">Show that the expected running time of TREAP-INSERT is <span class="unicode">&Theta;</span>(lg <i class="emphasis">n</i>).</p>
</li>
</ol>
<p class="para">TREAP-INSERT performs a search and then a sequence of rotations. Although these two operations have the same expected running time, they have different costs in practice. A search reads information from the treap without modifying it. In contrast, a rotation changes parent and child pointers within the treap. On most computers, read operations are much faster than write operations. Thus we would like TREAP-INSERT to perform few rotations. We will show that the expected number of rotations performed is bounded by a constant.</p>
<p class="para">In order to do so, we will need some definitions, which are illustrated in <a class="internaljump" href="#ch13fig11">Figure 13.11</a>. The <b class="bold"><i class="emphasis">left spine</i></b> of a binary search tree <i class="emphasis">T</i> is the path from the root to the node with the smallest key. In other words, the left spine is the path from the root that consists of only left edges. Symmetrically, the <b class="bold"><i class="emphasis">right spine</i></b> of <i class="emphasis">T</i> is the path from the root consisting of only right edges. The <b class="bold"><i class="emphasis">length</i></b> of a spine is the number of nodes it contains.</p>
<p class="para">
<div class="figure">
<a name="940"></a><a name="ch13fig11"></a><span class="figuremediaobject"><a href="images/fig322%5F01%5F0%2Ejpg" NAME="IMG_428" target="_parent"><img src="images/fig322_01.jpg" height="100" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 13.11: </span>Spines of a binary search tree. The left spine is shaded in <i class="emphasis">(a)</i>, and the right spine is shaded in <i class="emphasis">(b)</i>.</span>
</div>
</p>
<ol class="orderedlist" start="5" type="a">
<li class="first-listitem">
<p class="first-para">Consider the treap <i class="emphasis">T</i> immediately after <i class="emphasis">x</i> is inserted using TREAP-INSERT. Let <i class="emphasis">C</i> be the length of the right spine of the left subtree of <i class="emphasis">x</i>. Let <i class="emphasis">D</i> be the length of the left spine of the right subtree of <i class="emphasis">x</i>. Prove that the total number of rotations that were performed during the insertion of <i class="emphasis">x</i> is equal to <i class="emphasis">C</i> + <i class="emphasis">D</i>.</p>
</li>
</ol>
<p class="para">We will now calculate the expected values of <i class="emphasis">C</i> and <i class="emphasis">D</i>. Without loss of generality, we assume that the keys are 1, 2, ..., <i class="emphasis">n</i>, since we are comparing them only to one another.</p>
<p class="para">For nodes <i class="emphasis">x</i> and <i class="emphasis">y</i>, where <i class="emphasis">y</i> <span class="unicode">&ne;</span> <i class="emphasis">x</i>, let <i class="emphasis">k</i> = <i class="emphasis">key</i>[<i class="emphasis">x</i>] and <i class="emphasis">i</i> = <i class="emphasis">key</i>[<i class="emphasis">y</i>]. We define indicator random variables</p>
<p class="para">
<i class="emphasis">X<sub>i,k</sub></i> = I {<i class="emphasis">y</i> is in the right spine of the left subtree of <i class="emphasis">x</i> (in <i class="emphasis">T</i>)}.</p>
<ol class="orderedlist" start="6" type="a">
<li class="first-listitem">
<p class="first-para">Show that <i class="emphasis">X<sub>i,k</sub></i> = 1 if and only if <i class="emphasis">priority</i>[<i class="emphasis">y</i>] <span class="unicode">&gt;</span> <i class="emphasis">priority</i>[<i class="emphasis">x</i>], <i class="emphasis">key</i>[<i class="emphasis">y</i>] <span class="unicode">&lt;</span> <i class="emphasis">key</i>[<i class="emphasis">x</i>], and, for every <i class="emphasis">z</i> such that <i class="emphasis">key</i>[<i class="emphasis">y</i>] <span class="unicode">&lt;</span> <i class="emphasis">key</i>[<i class="emphasis">z</i>] <span class="unicode">&lt;</span> <i class="emphasis">key</i>[<i class="emphasis">x</i>], we have <i class="emphasis">priority</i>[<i class="emphasis">y</i>] <span class="unicode">&lt;</span> <i class="emphasis">priority</i>[<i class="emphasis">z</i>].</p>
</li>
</ol>
<a name="941"></a><a name="IDX-299"></a><a name="942"></a><a name="IDX-300"></a>
<ol class="orderedlist" start="7" type="a">
<li class="first-listitem">
<p class="first-para">Show that</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig322_02.jpg" height="37" width="310" alt="" border="0"></span>
</div>
</li>
<li class="listitem">
<p class="first-para">Show that</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig322_03.jpg" height="45" width="194" alt="" border="0"></span>
</div>
</li>
<li class="listitem">
<p class="first-para">Use a symmetry argument to show that</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig322_04.jpg" height="35" width="148" alt="" border="0"></span>
</div>
</li>
<li class="listitem">
<p class="first-para">Conclude that the expected number of rotations performed when inserting a node into a treap is less than 2.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
<div class="footnotes">
<div class="footnote">
<p>
<sup>[<a name="ftn.N1056" href="#N1056">2</a>]</sup>As in RB-INSERT-FIXUP, the cases in RB-DELETE-FIXUP are not mutually exclusive.</p>
</div>
</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0078.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0080.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
