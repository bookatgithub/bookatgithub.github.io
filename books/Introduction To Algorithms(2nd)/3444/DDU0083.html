<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>14.3 Interval Trees</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0082.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0084.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch14"></a>
<div class="section">
<h2 class="first-section-title">
<a name="978"></a><a name="ch14lev1sec3"></a><span class="section-titlelabel">14.3 </span>Interval Trees</h2>
<p class="first-para">In this section, we shall augment red-black trees to support operations on dynamic sets of intervals. A <b class="bold"><i class="emphasis">closed interval</i></b> is an ordered pair of real numbers [<i class="emphasis">t</i><sub>1</sub>, <i class="emphasis">t</i><sub>2</sub>], with <i class="emphasis">t</i><sub>1</sub> <span class="unicode">&le;</span> <i class="emphasis">t</i><sub>2</sub>. The interval [<i class="emphasis">t</i><sub>1</sub>, <i class="emphasis">t</i><sub>2</sub>] represents the set {<i class="emphasis">t</i> <span class="unicode">&isin;</span> <b class="bold">R</b> : <i class="emphasis">t</i><sub>1</sub> <span class="unicode">&le;</span> <i class="emphasis">t</i> <span class="unicode">&le;</span> <i class="emphasis">t</i><sub>2</sub>}. <b class="bold"><i class="emphasis">Open</i></b> and <b class="bold"><i class="emphasis">half-open</i></b> intervals omit both or one of the endpoints from the set, respectively. In this section, we shall assume that intervals are closed; extending the results to open and half-open intervals is conceptually straightforward.</p>
<p class="para">Intervals are convenient for representing events that each occupy a continuous period of time. We might, for example, wish to query a database of time intervals to find out what events occurred during a given interval. The data structure in this section provides an efficient means for maintaining such an interval database.</p>
<p class="para">We can represent an interval [<i class="emphasis">t</i><sub>1</sub>, <i class="emphasis">t</i><sub>2</sub>] as an object <i class="emphasis">i</i>, with fields <i class="emphasis">low</i>[<i class="emphasis">i</i>] = <i class="emphasis">t</i><sub>1</sub> (the <b class="bold"><i class="emphasis">low endpoint</i></b>) and <i class="emphasis">high</i>[<i class="emphasis">i</i>] = <i class="emphasis">t</i><sub>2</sub>(the <b class="bold"><i class="emphasis">high endpoint</i></b>). We say that intervals <i class="emphasis">i</i> and <i class="emphasis">i</i>' <b class="bold"><i class="emphasis">overlap</i></b> if <i class="emphasis">i</i> <span class="unicode">&cap;</span> <i class="emphasis">i</i>' <span class="unicode">&ne;</span> <span class="unicode">&oslash;</span>, that is, if <i class="emphasis">low</i>[<i class="emphasis">i</i>] <span class="unicode">&le;</span> <i class="emphasis">high</i>[<i class="emphasis">i</i>'] and <i class="emphasis">low</i>[<i class="emphasis">i</i>'] <span class="unicode">&le;</span> <i class="emphasis">high</i>[<i class="emphasis">i</i>]. Any two intervals <i class="emphasis">i</i> and <i class="emphasis">i</i>' satisfy the <b class="bold"><i class="emphasis">interval trichotomy</i></b>; that is, exactly one of the following three properties holds:</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">
<i class="emphasis">i</i> and <i class="emphasis">i</i>' overlap,</p>
</li>
<li class="listitem">
<p class="first-para">
<i class="emphasis">i</i> is to the left of <i class="emphasis">i</i>' (i.e., <i class="emphasis">high</i>[<i class="emphasis">i</i>]<span class="unicode">&lt;</span> <i class="emphasis">low</i>[<i class="emphasis">i</i>']),</p>
</li>
<li class="listitem">
<p class="first-para">
<i class="emphasis">i</i> is to the right of <i class="emphasis">i</i>' (i.e., <i class="emphasis">high</i>[<i class="emphasis">i</i>']<span class="unicode">&lt;</span> <i class="emphasis">low</i>[<i class="emphasis">i</i>]).</p>
</li>
</ol>
<p class="para">
<a class="internaljump" href="#ch14fig03">Figure 14.3</a> shows the three possibilities.</p>
<div class="figure">
<a name="979"></a><a name="ch14fig03"></a><span class="figuremediaobject"><a href="images/fig334%5F01%5F0%2Ejpg" NAME="IMG_435" target="_parent"><img src="images/fig334_01.jpg" height="142" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 14.3: </span>The interval trichotomy for two closed intervals <i class="emphasis">i</i> and <i class="emphasis">i</i>'. <i class="emphasis">(a)</i> If <i class="emphasis">i</i> and <i class="emphasis">i</i>' overlap, there are four situations; in each, <i class="emphasis">low</i>[<i class="emphasis">i</i>] <span class="unicode">&le;</span> <i class="emphasis">high</i>[<i class="emphasis">i</i>'] and <i class="emphasis">low</i>[<i class="emphasis">i</i>'] <span class="unicode">&le;</span> <i class="emphasis">high</i>[<i class="emphasis">i</i>]. <i class="emphasis">(b)</i> The intervals do not overlap, and <i class="emphasis">high</i>[<i class="emphasis">i</i>]<span class="unicode">&lt;</span> <i class="emphasis">low</i>[<i class="emphasis">i</i>']. <i class="emphasis">(c)</i> The intervals do not overlap, and <i class="emphasis">high</i>[<i class="emphasis">i</i>']<span class="unicode">&lt;</span> <i class="emphasis">low</i>[<i class="emphasis">i</i>].</span>
</div>
<a name="980"></a><a name="IDX-312"></a>
<p class="para">An <b class="bold"><i class="emphasis">interval tree</i></b> is a red-black tree that maintains a dynamic set of elements, with each element <i class="emphasis">x</i> containing an interval <i class="emphasis">int</i>[<i class="emphasis">x</i>]. Interval trees support the following operations.</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">INTERVAL-INSERT(<i class="emphasis">T, x</i>) adds the element <i class="emphasis">x</i>, whose <i class="emphasis">int</i> field is assumed to contain an interval, to the interval tree <i class="emphasis">T</i>.</p>
</li>
<li class="listitem">
<p class="first-para">INTERVAL-DELETE(<i class="emphasis">T, x</i>) removes the element <i class="emphasis">x</i> from the interval tree <i class="emphasis">T</i>.</p>
</li>
<li class="listitem">
<p class="first-para">INTERVAL-SEARCH(<i class="emphasis">T, i</i>) returns a pointer to an element <i class="emphasis">x</i> in the interval tree <i class="emphasis">T</i> such that <i class="emphasis">int</i>[<i class="emphasis">x</i>] overlaps interval <i class="emphasis">i</i>, or the sentinel <i class="emphasis">nil</i>[<i class="emphasis">T</i>] if no such element is in the set.</p>
</li>
</ul>
<p class="para">
<a class="internaljump" href="#ch14fig04">Figure 14.4</a> shows how an interval tree represents a set of intervals. We shall track the four-step method from <a href="DDU0082.html#967" target="_parent" class="chapterjump">Section 14.2</a> as we review the design of an interval tree and the operations that run on it.</p>
<div class="figure">
<a name="981"></a><a name="ch14fig04"></a><span class="figuremediaobject"><a href="images/fig335%5F01%5F0%2Ejpg" NAME="IMG_436" target="_parent"><img src="images/fig335_01.jpg" height="287" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 14.4: </span>An interval tree. <i class="emphasis">(a)</i> A set of 10 intervals, shown sorted bottom to top by left endpoint. <i class="emphasis">(b)</i> The interval tree that represents them. An inorder tree walk of the tree lists the nodes in sorted order by left endpoint.</span>
</div>
<div class="section">
<h4 class="sect4-title">
<a name="982"></a><a name="ch14lev3sec5"></a><span class="section-titlelabel">Step 1: </span>Underlying Data Structure</h4>
<p class="first-para">We choose a red-black tree in which each node <i class="emphasis">x</i> contains an interval <i class="emphasis">int</i>[<i class="emphasis">x</i>] and the key of <i class="emphasis">x</i> is the low endpoint, <i class="emphasis">low</i>[<i class="emphasis">int</i>[<i class="emphasis">x</i>]], of the interval. Thus, an inorder tree walk of the data structure lists the intervals in sorted order by low endpoint.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="983"></a><a name="ch14lev3sec6"></a><span class="section-titlelabel">Step 2: </span>Additional Information</h4>
<p class="first-para">In addition to the intervals themselves, each node <i class="emphasis">x</i> contains a value <i class="emphasis">max</i>[<i class="emphasis">x</i>], which is the maximum value of any interval endpoint stored in the subtree rooted at <i class="emphasis">x</i>.<a name="984"></a><a name="IDX-313"></a>
</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="985"></a><a name="ch14lev3sec7"></a><span class="section-titlelabel">Step 3: </span>Maintaining the Information</h4>
<p class="first-para">We must verify that insertion and deletion can be performed in <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) time on an interval tree of <i class="emphasis">n</i> nodes. We can determine <i class="emphasis">max</i>[<i class="emphasis">x</i>] given interval <i class="emphasis">int</i>[<i class="emphasis">x</i>] and the <i class="emphasis">max</i> values of node <i class="emphasis">x</i>'s children:</p>
<p class="para">
<i class="emphasis">max</i>[<i class="emphasis">x</i>] = max(<i class="emphasis">high</i>[<i class="emphasis">int</i>[<i class="emphasis">x</i>]], <i class="emphasis">max</i>[<i class="emphasis">left</i>[<i class="emphasis">x</i>]], <i class="emphasis">max</i>[<i class="emphasis">right</i>[<i class="emphasis">x</i>]]).</p>
<p class="para">Thus, by <a href="DDU0082.html#970" target="_parent" class="chapterjump">Theorem 14.1</a>, insertion and deletion run in <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) time. In fact, updating the <i class="emphasis">max</i> fields after a rotation can be accomplished in <i class="emphasis">O</i>(1) time, as is shown in <a href="DDU0082.html#976" target="_parent" class="chapterjump">Exercises 14.2-4</a> and <a class="internaljump" href="#ch14ex16">14.3-1</a>.</p>
<a name="986"></a><a name="IDX-314"></a>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="987"></a><a name="ch14lev3sec8"></a><span class="section-titlelabel">Step 4: </span>Developing New Operations</h4>
<p class="first-para">The only new operation we need is INTERVAL-SEARCH(<i class="emphasis">T, i</i>), which finds a node in tree <i class="emphasis">T</i> whose interval overlaps interval <i class="emphasis">i</i>. If there is no interval that overlaps <i class="emphasis">i</i> in the tree, a pointer to the sentinel <i class="emphasis">nil</i>[<i class="emphasis">T</i>] is returned.</p>
<div class="informalexample">
<pre class="literallayout-normal">
INTERVAL-SEARCH(<i class="emphasis">T</i>, <i class="emphasis">i</i>)
1  <i class="emphasis">x</i> <span class="unicode">&larr;</span> <i class="emphasis">root</i>[<i class="emphasis">T</i>]
2  <b class="bold">while</b> <i class="emphasis">x</i> <span class="unicode">&ne;</span> <i class="emphasis">nil</i>[<i class="emphasis">T</i>] and <i class="emphasis">i</i> does not overlap <i class="emphasis">int</i>[<i class="emphasis">x</i>]
3      <b class="bold">do if</b> <i class="emphasis">left</i>[<i class="emphasis">x</i>] <span class="unicode">&ne;</span> <i class="emphasis">nil</i>[<i class="emphasis">T</i>] and <i class="emphasis">max</i>[<i class="emphasis">left</i>[<i class="emphasis">x</i>]] <span class="unicode">&ge;</span> <i class="emphasis">low</i>[<i class="emphasis">i</i>]
4            <b class="bold">then</b> <i class="emphasis">x</i> <span class="unicode">&larr;</span> <i class="emphasis">left</i>[<i class="emphasis">x</i>]
5            <b class="bold">else</b> <i class="emphasis">x</i> <span class="unicode">&larr;</span> <i class="emphasis">right</i>[<i class="emphasis">x</i>]
6  <b class="bold">return</b> <i class="emphasis">x</i>
</pre>
</div>
<p class="para">The search for an interval that overlaps <i class="emphasis">i</i> starts with <i class="emphasis">x</i> at the root of the tree and proceeds downward. It terminates when either an overlapping interval is found or <i class="emphasis">x</i> points to the sentinel <i class="emphasis">nil</i>[<i class="emphasis">T</i>]. Since each iteration of the basic loop takes <i class="emphasis">O</i>(1) time, and since the height of an <i class="emphasis">n</i>-node red-black tree is <i class="emphasis">O</i>(lg <i class="emphasis">n</i>), the INTERVAL-SEARCH procedure takes <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) time.</p>
<p class="para">Before we see why INTERVAL-SEARCH is correct, let's examine how it works on the interval tree in <a class="internaljump" href="#ch14fig04">Figure 14.4</a>. Suppose we wish to find an interval that overlaps the interval <i class="emphasis">i</i> = [<a href="DDU0259.html#3578" target="_parent" class="chapterjump">22</a>, <a href="DDU0259.html#3581" target="_parent" class="chapterjump">25</a>]. We begin with <i class="emphasis">x</i> as the root, which contains [<a href="DDU0259.html#3572" target="_parent" class="chapterjump">16</a>, <a href="DDU0259.html#3577" target="_parent" class="chapterjump">21</a>] and does not overlap <i class="emphasis">i</i>. Since <i class="emphasis">max</i>[<i class="emphasis">left</i>[<i class="emphasis">x</i>]] = 23 is greater than <i class="emphasis">low</i>[<i class="emphasis">i</i>] = 22, the loop continues with <i class="emphasis">x</i> as the left child of the root<span class="unicode">-</span>the node containing [<a href="DDU0259.html#3564" target="_parent" class="chapterjump">8</a>, <a href="DDU0259.html#3565" target="_parent" class="chapterjump">9</a>], which also does not overlap <i class="emphasis">i</i>. This time, <i class="emphasis">max</i>[<i class="emphasis">left</i>[<i class="emphasis">x</i>]] = 10 is less than <i class="emphasis">low</i>[<i class="emphasis">i</i>] = 22, so the loop continues with the right child of <i class="emphasis">x</i> as the new <i class="emphasis">x</i>. The interval [<a href="DDU0259.html#3571" target="_parent" class="chapterjump">15</a>, <a href="DDU0259.html#3579" target="_parent" class="chapterjump">23</a>] stored in this node overlaps <i class="emphasis">i</i>, so the procedure returns this node.</p>
<p class="para">As an example of an unsuccessful search, suppose we wish to find an interval that overlaps <i class="emphasis">i</i> = [<a href="DDU0259.html#3567" target="_parent" class="chapterjump">11</a>, <a href="DDU0259.html#3570" target="_parent" class="chapterjump">14</a>] in the interval tree of <a class="internaljump" href="#ch14fig04">Figure 14.4</a>. We once again begin with <i class="emphasis">x</i> as the root. Since the root's interval [<a href="DDU0259.html#3572" target="_parent" class="chapterjump">16</a>, <a href="DDU0259.html#3577" target="_parent" class="chapterjump">21</a>] does not overlap <i class="emphasis">i</i>, and since <i class="emphasis">max</i>[<i class="emphasis">left</i>[<i class="emphasis">x</i>]] = 23 is greater than <i class="emphasis">low</i>[<i class="emphasis">i</i>] = 11, we go left to the node containing [<a href="DDU0259.html#3564" target="_parent" class="chapterjump">8</a>, <a href="DDU0259.html#3565" target="_parent" class="chapterjump">9</a>]. (Note that no interval in the right subtree overlaps <i class="emphasis">i</i><span class="unicode">-</span>we shall see why later.) Interval [<a href="DDU0259.html#3564" target="_parent" class="chapterjump">8</a>, <a href="DDU0259.html#3565" target="_parent" class="chapterjump">9</a>] does not overlap <i class="emphasis">i</i>, and <i class="emphasis">max</i>[<i class="emphasis">left</i>[<i class="emphasis">x</i>]] = 10 is less than <i class="emphasis">low</i>[<i class="emphasis">i</i>] = 11, so we go right. (Note that no interval in the left subtree overlaps <i class="emphasis">i</i>.) Interval [<a href="DDU0259.html#3571" target="_parent" class="chapterjump">15</a>, <a href="DDU0259.html#3579" target="_parent" class="chapterjump">23</a>] does not overlap <i class="emphasis">i</i>, and its left child is <i class="emphasis">nil</i>[<i class="emphasis">T</i>], so we go right, the loop terminates, and the sentinel <i class="emphasis">nil</i>[<i class="emphasis">T</i>] is returned.</p>
<p class="para">To see why INTERVAL-SEARCH is correct, we must understand why it suffices to examine a single path from the root. The basic idea is that at any node <i class="emphasis">x</i>, if <i class="emphasis">int</i>[<i class="emphasis">x</i>] does not overlap <i class="emphasis">i</i>, the search always proceeds in a safe direction: an overlapping interval will definitely be found if there is one in the tree. The following theorem states this property more precisely.<a name="988"></a><a name="IDX-315"></a>
</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 14.2</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Any execution of INTERVAL-SEARCH(<i class="emphasis">T, i</i>) either returns a node whose interval overlaps <i class="emphasis">i</i>, or it returns <i class="emphasis">nil</i>[<i class="emphasis">T</i>] and the tree <i class="emphasis">T</i> contains no node whose interval overlaps <i class="emphasis">i</i>.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> The <b class="bold">while</b> loop of lines 2<span class="unicode">-</span>5 terminates either when <i class="emphasis">x</i> = <i class="emphasis">nil</i>[<i class="emphasis">T</i>] or <i class="emphasis">i</i> overlaps <i class="emphasis">int</i>[<i class="emphasis">x</i>]. In the latter case, it is certainly correct to return <i class="emphasis">x</i>. Therefore, we focus on the former case, in which the <b class="bold">while</b> loop terminates because <i class="emphasis">x</i> = <i class="emphasis">nil</i>[<i class="emphasis">T</i>].</p>
<p class="para">We use the following invariant for the <b class="bold">while</b> loop of lines 2<span class="unicode">-</span>5:</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">If tree <i class="emphasis">T</i> contains an interval that overlaps <i class="emphasis">i</i>, then there is such an interval in the subtree rooted at <i class="emphasis">x</i>.</p>
</li>
</ul>
<p class="para">We use this loop invariant as follows:</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">
<b class="bold">Initialization:</b> Prior to the first iteration, line 1 sets <i class="emphasis">x</i> to be the root of <i class="emphasis">T</i> , so that the invariant holds.</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">Maintenance:</b> In each iteration of the <b class="bold">while</b> loop, either line 4 or line 5 is executed. We shall show that the loop invariant is maintained in either case.</p>
<p class="para">If line 5 is executed, then because of the branch condition in line 3, we have <i class="emphasis">left</i>[<i class="emphasis">x</i>] = <i class="emphasis">nil</i>[<i class="emphasis">T</i>], or <i class="emphasis">max</i>[<i class="emphasis">left</i>[<i class="emphasis">x</i>]]<span class="unicode">&lt;</span> <i class="emphasis">low</i>[<i class="emphasis">i</i>]. If <i class="emphasis">left</i>[<i class="emphasis">x</i>] = <i class="emphasis">nil</i>[<i class="emphasis">T</i>], the subtree rooted at <i class="emphasis">left</i>[<i class="emphasis">x</i>] clearly contains no interval that overlaps <i class="emphasis">i</i>, and so setting <i class="emphasis">x</i> to <i class="emphasis">right</i>[<i class="emphasis">x</i>] maintains the invariant. Suppose, therefore, that <i class="emphasis">left</i>[<i class="emphasis">x</i>] <span class="unicode">&ne;</span> <i class="emphasis">nil</i>[<i class="emphasis">T</i>] and <i class="emphasis">max</i>[<i class="emphasis">left</i>[<i class="emphasis">x</i>]]<span class="unicode">&lt;</span> <i class="emphasis">low</i>[<i class="emphasis">i</i>]. As <a class="internaljump" href="#ch14fig05">Figure 14.5(a)</a> shows, for each interval <i class="emphasis">i</i>' in <i class="emphasis">x</i>'s left subtree, we have</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">high</i>[<i class="emphasis">i</i>']</p>
</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&le;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">max</i>[<i class="emphasis">left</i>[<i class="emphasis">x</i>]]</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&lt;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">low</i>[<i class="emphasis">i</i>].</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="figure">
<a name="989"></a><a name="ch14fig05"></a><span class="figuremediaobject"><a href="images/fig337%5F01%5F0%2Ejpg" NAME="IMG_437" target="_parent"><img src="images/fig337_01.jpg" height="110" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 14.5: </span>Intervals in the proof of Theorem 14.2. The value of <i class="emphasis">max</i>[<i class="emphasis">left</i>[<i class="emphasis">x</i>]] is shown in each case as a dashed line. <i class="emphasis">(a)</i> The search goes right. No interval <i class="emphasis">i</i>' in <i class="emphasis">x</i>'s left subtree can overlap <i class="emphasis">i</i>. <i class="emphasis">(b)</i> The search goes left. The left subtree of <i class="emphasis">x</i> contains an interval that overlaps <i class="emphasis">i</i> (situation not shown), or there is an interval <i class="emphasis">i</i>' in <i class="emphasis">x</i>'s left subtree such that <i class="emphasis">high</i>[<i class="emphasis">i</i>'] = <i class="emphasis">max</i>[<i class="emphasis">left</i>[<i class="emphasis">x</i>]]. Since <i class="emphasis">i</i> does not overlap <i class="emphasis">i</i>', neither does it overlap any interval <i class="emphasis">i</i>" in <i class="emphasis">x</i>'s right subtree, since <i class="emphasis">low</i>[<i class="emphasis">i</i>'] <span class="unicode">&le;</span> <i class="emphasis">low</i>[<i class="emphasis">i</i>"].</span>
</p>
<a name="990"></a><a name="IDX-316"></a>
<p class="para">By the interval trichotomy, therefore, <i class="emphasis">i</i>' and <i class="emphasis">i</i> do not overlap. Thus, the left subtree of <i class="emphasis">x</i> contains no intervals that overlap <i class="emphasis">i</i>, so that setting <i class="emphasis">x</i> to <i class="emphasis">right</i>[<i class="emphasis">x</i>] maintains the invariant.</p>
<p class="para">If, on the other hand, line 4 is executed, then we will show that the contrapositive of the loop invariant holds. That is, if there is no interval overlapping <i class="emphasis">i</i> in the subtree rooted at <i class="emphasis">left</i>[<i class="emphasis">x</i>], then there is no interval overlapping <i class="emphasis">i</i> anywhere in the tree. Since line 4 is executed, then because of the branch condition in line 3, we have <i class="emphasis">max</i>[<i class="emphasis">left</i>[<i class="emphasis">x</i>]] <span class="unicode">&ge;</span> <i class="emphasis">low</i>[<i class="emphasis">i</i>]. Moreover, by definition of the <i class="emphasis">max</i> field, there must be some interval <i class="emphasis">i</i>' in <i class="emphasis">x</i>'s left subtree such that</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">high</i>[<i class="emphasis">i</i>']</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">max</i>[<i class="emphasis">left</i>[<i class="emphasis">x</i>]]</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&ge;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">low</i>[<i class="emphasis">i</i>].</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">(<a class="internaljump" href="#ch14fig05">Figure 14.5(b)</a> illustrates the situation.) Since <i class="emphasis">i</i> and <i class="emphasis">i</i>' do not overlap, and since it is not true that <i class="emphasis">high</i>[<i class="emphasis">i</i>']<span class="unicode">&lt;</span> <i class="emphasis">low</i>[<i class="emphasis">i</i>], it follows by the interval trichotomy that <i class="emphasis">high</i>[<i class="emphasis">i</i>]<span class="unicode">&lt;</span> <i class="emphasis">low</i>[<i class="emphasis">i</i>']. Interval trees are keyed on the low endpoints of intervals, and thus the search-tree property implies that for any interval <i class="emphasis">i</i>" in <i class="emphasis">x</i>'s right subtree,</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">high</i>[<i class="emphasis">i</i>]</p>
</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&lt;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">low</i>[<i class="emphasis">i</i>']</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&le;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">low</i>[<i class="emphasis">i</i>"].</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="last-para">By the interval trichotomy, <i class="emphasis">i</i> and <i class="emphasis">i</i>" do not overlap. We conclude that whether or not any interval in <i class="emphasis">x</i>'s left subtree overlaps <i class="emphasis">i</i>, setting <i class="emphasis">x</i> to <i class="emphasis">left</i>[<i class="emphasis">x</i>] maintains the invariant.</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">Termination:</b> If the loop terminates when <i class="emphasis">x</i> = <i class="emphasis">nil</i>[<i class="emphasis">T</i>], there is no interval overlapping <i class="emphasis">i</i> in the subtree rooted at <i class="emphasis">x</i>. The contrapositive of the loop invariant implies that <i class="emphasis">T</i> contains no interval that overlaps <i class="emphasis">i</i>. Hence it is correct to return <i class="emphasis">x</i> = <i class="emphasis">nil</i>[<i class="emphasis">T</i>].</p>
</li>
</ul>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">Thus, the INTERVAL-SEARCH procedure works correctly.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 14.3-1</span></span><a name="991"></a><a name="ch14ex16"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Write pseudocode for LEFT-ROTATE that operates on nodes in an interval tree and updates the <i class="emphasis">max</i> fields in <i class="emphasis">O</i>(1) time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 14.3-2</span></span><a name="992"></a><a name="ch14ex17"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Rewrite the code for INTERVAL-SEARCH so that it works properly when all intervals are assumed to be open.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="993"></a><a name="IDX-317"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 14.3-3</span></span><a name="994"></a><a name="ch14ex18"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Describe an efficient algorithm that, given an interval <i class="emphasis">i</i>, returns an interval overlapping <i class="emphasis">i</i> that has the minimum low endpoint, or <i class="emphasis">nil</i>[<i class="emphasis">T</i>] if no such interval exists.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 14.3-4</span></span><a name="995"></a><a name="ch14ex19"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Given an interval tree <i class="emphasis">T</i> and an interval <i class="emphasis">i</i>, describe how all intervals in <i class="emphasis">T</i> that overlap <i class="emphasis">i</i> can be listed in <i class="emphasis">O</i>(min(<i class="emphasis">n</i>, <i class="emphasis">k</i> lg <i class="emphasis">n</i>)) time, where <i class="emphasis">k</i> is the number of intervals in the output list. (<i class="emphasis">Optional:</i> Find a solution that does not modify the tree.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 14.3-5</span></span><a name="996"></a><a name="ch14ex20"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suggest modifications to the interval-tree procedures to support the new operation INTERVAL-SEARCH-EXACTLY(<i class="emphasis">T, i</i>), which returns a pointer to a node <i class="emphasis">x</i> in interval tree <i class="emphasis">T</i> such that <i class="emphasis">low</i>[<i class="emphasis">int</i>[<i class="emphasis">x</i>]] = <i class="emphasis">low</i>[<i class="emphasis">i</i>] and <i class="emphasis">high</i>[<i class="emphasis">int</i>[<i class="emphasis">x</i>]] = <i class="emphasis">high</i>[<i class="emphasis">i</i>], or <i class="emphasis">nil</i>[<i class="emphasis">T</i>] if <i class="emphasis">T</i> contains no such node. All operations, including INTERVAL-SEARCH-EXACTLY, should run in <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) time on an <i class="emphasis">n</i>-node tree.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 14.3-6</span></span><a name="997"></a><a name="ch14ex21"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show how to maintain a dynamic set <i class="emphasis">Q</i> of numbers that supports the operation MIN-GAP, which gives the magnitude of the difference of the two closest numbers in <i class="emphasis">Q</i>. For example, if <i class="emphasis">Q</i> = {1, 5, 9, 15, 18, 22}, then MIN-GAP(<i class="emphasis">Q</i>) returns 18 - 15 = 3, since 15 and 18 are the two closest numbers in <i class="emphasis">Q</i>. Make the operations INSERT, DELETE, SEARCH, and MIN-GAP as efficient as possible, and analyze their running times.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 14.3-7: </span><span class="unicode">&#8902;</span></span><a name="998"></a><a name="ch14ex22"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">VLSI databases commonly represent an integrated circuit as a list of rectangles. Assume that each rectangle is rectilinearly oriented (sides parallel to the <i class="emphasis">x</i>- and <i class="emphasis">y</i>-axis), so that a representation of a rectangle consists of its minimum and maximum <i class="emphasis">x</i>- and <i class="emphasis">y</i>-coordinates. Give an <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>)-time algorithm to decide whether or not a set of rectangles so represented contains two rectangles that overlap. Your algorithm need not report all intersecting pairs, but it must report that an overlap exists if one rectangle entirely covers another, even if the boundary lines do not intersect. (<i class="emphasis">Hint:</i> Move a "sweep" line across the set of rectangles.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="999"></a><a name="IDX-318"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 14-1: </span>Point of Maximum Overlap</span><a name="1000"></a><a name="ch14ex23"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that we wish to keep track of a <b class="bold"><i class="emphasis">point of maximum overlap</i></b> in a set of intervals<span class="unicode">-</span>a point that has the largest number of intervals in the database overlapping it.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Show that there will always be a point of maximum overlap which is an endpoint of one of the segments.</p>
</li>
<li class="listitem">
<p class="first-para">Design a data structure that efficiently supports the operations INTERVAL-INSERT, INTERVAL-DELETE, and FIND-POM, which returns a point of maximum overlap. (<i class="emphasis">Hint:</i> Keep a red-black tree of all the endpoints. Associate a value of +1 with each left endpoint, and associate a value of -1 with each right endpoint. Augment each node of the tree with some extra information to maintain the point of maximum overlap.)</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 14-2: </span>Josephus Permutation</span><a name="1001"></a><a name="ch14ex24"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The <b class="bold"><i class="emphasis">Josephus problem</i></b> is defined as follows. Suppose that <i class="emphasis">n</i> people are arranged in a circle and that we are given a positive integer <i class="emphasis">m</i> <span class="unicode">&le;</span> <i class="emphasis">n</i>. Beginning with a designated first person, we proceed around the circle, removing every <i class="emphasis">m</i>th person. After each person is removed, counting continues around the circle that remains. This process continues until all <i class="emphasis">n</i> people have been removed. The order in which the people are removed from the circle defines the (<b class="bold"><i class="emphasis">n, m)-Josephus permutation</i></b> of the integers 1, 2,..., <i class="emphasis">n</i>. For example, the (7, 3)-Josephus permutation is <span class="unicode">&#12296;</span>3, 6, 2, 7, 5, 1, 4<span class="unicode">&#12297;</span>.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Suppose that <i class="emphasis">m</i> is a constant. Describe an <i class="emphasis">O</i>(<i class="emphasis">n</i>)-time algorithm that, given an integer <i class="emphasis">n</i>, outputs the (<i class="emphasis">n</i>, <i class="emphasis">m</i>)-Josephus permutation.</p>
</li>
<li class="listitem">
<p class="first-para">Suppose that <i class="emphasis">m</i> is not a constant. Describe an <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>)-time algorithm that, given integers <i class="emphasis">n</i> and <i class="emphasis">m</i>, outputs the (<i class="emphasis">n</i>, <i class="emphasis">m</i>)-Josephus permutation.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0082.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0084.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
