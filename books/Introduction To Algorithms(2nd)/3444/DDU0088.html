<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>15.2 Matrix-chain multiplication</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0087.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0089.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch15"></a>
<div class="section">
<h2 class="first-section-title">
<a name="1039"></a><a name="ch15lev1sec2"></a><span class="section-titlelabel">15.2 </span>Matrix-chain multiplication</h2>
<p class="first-para">Our next example of dynamic programming is an algorithm that solves the problem of matrix-chain multiplication. We are given a sequence (chain) <span class="unicode">&#12296;</span><i class="emphasis">A</i><sub>1</sub>, <i class="emphasis">A</i><sub>2</sub>, ..., <i class="emphasis">A<sub>n</sub></i><span class="unicode">&#12297;</span> of <i class="emphasis">n</i> matrices to be multiplied, and we wish to compute the product</p>
<div class="equation">
<a name="1040"></a><a name="ch15eq10"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(15.10)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig353_02.jpg" height="15" width="79" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">We can evaluate the expression (<a class="internaljump" href="#ch15eq10">15.10</a>) using the standard algorithm for multiplying pairs of matrices as a subroutine once we have parenthesized it to resolve all ambiguities in how the matrices are multiplied together. A product of matrices is <b class="bold"><i class="emphasis">fully parenthesized</i></b> if it is either a single matrix or the product of two fully parenthesized matrix products, surrounded by parentheses. Matrix multiplication is associative, and so all parenthesizations yield the same product. For example, if the chain of matrices is <span class="unicode">&#12296;</span><i class="emphasis">A</i><sub>1</sub>, <i class="emphasis">A</i><sub>2</sub>, <i class="emphasis">A</i><sub>3</sub>, <i class="emphasis">A</i><sub>4</sub><span class="unicode">&#12297;</span>, the product <i class="emphasis">A</i><sub>1</sub> <i class="emphasis">A</i><sub>2</sub> <i class="emphasis">A</i><sub>3</sub> <i class="emphasis">A</i><sub>4</sub> can be fully parenthesized in five distinct ways:</p>
<p class="para">(<i class="emphasis">A</i><sub>1</sub> (<i class="emphasis">A</i><sub>2</sub> (<i class="emphasis">A</i><sub>3</sub> <i class="emphasis">A</i><sub>4</sub>))) ,</p>
<p class="para">(<i class="emphasis">A</i><sub>1</sub> ((<i class="emphasis">A</i><sub>2</sub> <i class="emphasis">A</i><sub>3</sub>) <i class="emphasis">A</i><sub>4</sub>)) ,</p>
<p class="para">((<i class="emphasis">A</i><sub>1</sub> <i class="emphasis">A</i><sub>2</sub>) (<i class="emphasis">A</i><sub>3</sub> <i class="emphasis">A</i><sub>4</sub>)) ,</p>
<p class="para">((<i class="emphasis">A</i><sub>1</sub> (<i class="emphasis">A</i><sub>2</sub> <i class="emphasis">A</i><sub>3</sub>)) <i class="emphasis">A</i><sub>4</sub>) ,</p>
<p class="para">(((<i class="emphasis">A</i><sub>1</sub> <i class="emphasis">A</i><sub>2</sub>) <i class="emphasis">A</i><sub>3</sub>) <i class="emphasis">A</i><sub>4</sub>).<a name="1041"></a><a name="IDX-332"></a>
</p>
<p class="para">The way we parenthesize a chain of matrices can have a dramatic impact on the cost of evaluating the product. Consider first the cost of multiplying two matrices. The standard algorithm is given by the following pseudocode. The attributes <i class="emphasis">rows</i> and <i class="emphasis">columns</i> are the numbers of rows and columns in a matrix.</p>
<div class="informalexample">
<pre class="literallayout-normal">
MATRIX-MULTIPLY(<i class="emphasis">A</i>, <i class="emphasis">B</i>)
1 <b class="bold">if</b> <i class="emphasis">columns</i>[<i class="emphasis">A</i>] <span class="unicode">&ne;</span> <i class="emphasis">rows</i>[<i class="emphasis">B</i>]
2     <b class="bold">then error</b> "incompatible dimensions"
3     <b class="bold">else for</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">rows</i>[<i class="emphasis">A</i>]
4               <b class="bold">do for</b> <i class="emphasis">j</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">columns</i>[<i class="emphasis">B</i>]
5                       <b class="bold">do</b> <i class="emphasis">C</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] <span class="unicode">&larr;</span> 0
6                          <b class="bold">for</b> <i class="emphasis">k</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">columns</i>[<i class="emphasis">A</i>]
7                               <b class="bold">do</b> <i class="emphasis">C</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] <span class="unicode">&larr;</span> <i class="emphasis">C</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] + <i class="emphasis">A</i>[<i class="emphasis">i</i>, <i class="emphasis">k</i>] <span class="unicode">&middot;</span> <i class="emphasis">B</i>[<i class="emphasis">k</i>, <i class="emphasis">j</i>]
8          <b class="bold">return</b> <i class="emphasis">C</i>
</pre>
</div>
<p class="para">We can multiply two matrices <i class="emphasis">A</i> and <i class="emphasis">B</i> only if they are <b class="bold"><i class="emphasis">compatible</i></b>: the number of columns of <i class="emphasis">A</i> must equal the number of rows of <i class="emphasis">B</i>. If <i class="emphasis">A</i> is a <i class="emphasis">p</i> <span class="unicode">&times;</span> <i class="emphasis">q</i> matrix and <i class="emphasis">B</i> is a <i class="emphasis">q</i> <span class="unicode">&times;</span> <i class="emphasis">r</i> matrix, the resulting matrix <i class="emphasis">C</i> is a <i class="emphasis">p</i> <span class="unicode">&times;</span> <i class="emphasis">r</i> matrix. The time to compute <i class="emphasis">C</i> is dominated by the number of scalar multiplications in line 7, which is <i class="emphasis">pqr</i>. In what follows, we shall express costs in terms of the number of scalar multiplications.</p>
<p class="para">To illustrate the different costs incurred by different parenthesizations of a matrix product, consider the problem of a chain <span class="unicode">&#12296;</span><i class="emphasis">A</i><sub>1</sub>, <i class="emphasis">A</i><sub>2</sub>, <i class="emphasis">A</i><sub>3</sub><span class="unicode">&#12297;</span> of three matrices. Suppose that the dimensions of the matrices are 10 <span class="unicode">&times;</span> 100, 100 <span class="unicode">&times;</span> 5, and 5 <span class="unicode">&times;</span> 50, respectively. If we multiply according to the parenthesization ((<i class="emphasis">A</i><sub>1</sub> <i class="emphasis">A</i><sub>2</sub>) <i class="emphasis">A</i><sub>3</sub>), we perform 10 <span class="unicode">&middot;</span> 100 <span class="unicode">&middot;</span> 5 = 5000 scalar multiplications to compute the 10 <span class="unicode">&times;</span> 5 matrix product <i class="emphasis">A</i><sub>1</sub> <i class="emphasis">A</i><sub>2</sub>, plus another 10 <span class="unicode">&middot;</span> 5 <span class="unicode">&middot;</span> 50 = 2500 scalar multiplications to multiply this matrix by <i class="emphasis">A</i><sub>3</sub>, for a total of 7500 scalar multiplications. If instead we multiply according to the parenthesization (<i class="emphasis">A</i><sub>1</sub> (<i class="emphasis">A</i><sub>2</sub> <i class="emphasis">A</i><sub>3</sub>)), we perform 100 <span class="unicode">&middot;</span> 5 <span class="unicode">&middot;</span> 50 = 25,000 scalar multiplications to compute the 100 <span class="unicode">&times;</span> 50 matrix product <i class="emphasis">A</i><sub>2</sub> <i class="emphasis">A</i><sub>3</sub>, plus another 10 <span class="unicode">&middot;</span> 100 <span class="unicode">&middot;</span> 50 = 50,000 scalar multiplications to multiply <i class="emphasis">A</i><sub>1</sub> by this matrix, for a total of 75,000 scalar multiplications. Thus, computing the product according to the first parenthesization is 10 times faster.</p>
<p class="para">The <b class="bold"><i class="emphasis">matrix-chain multiplication problem</i></b> can be stated as follows: given a chain <span class="unicode">&#12296;</span><i class="emphasis">A</i><sub>1</sub>, <i class="emphasis">A</i><sub>2</sub>, ..., <i class="emphasis">A<sub>n</sub></i><span class="unicode">&#12297;</span> of <i class="emphasis">n</i> matrices, where for <i class="emphasis">i</i> = 1, 2, ..., <i class="emphasis">n</i>, matrix <i class="emphasis">A<sub>i</sub></i> has dimension <i class="emphasis">p</i><sub><i class="emphasis">i</i>-1</sub> <span class="unicode">&times;</span> <i class="emphasis">p<sub>i</sub></i>, fully parenthesize the product <i class="emphasis">A</i><sub>1</sub> <i class="emphasis">A</i><sub>2</sub> <i class="emphasis">A<sub>n</sub></i> in a way that minimizes the number of scalar multiplications.</p>
<p class="para">Note that in the matrix-chain multiplication problem, we are not actually multiplying matrices. Our goal is only to determine an order for multiplying matrices that has the lowest cost. Typically, the time invested in determining this optimal order is more than paid for by the time saved later on when actually performing the matrix multiplications (such as performing only 7500 scalar multiplications instead of 75,000).<a name="1042"></a><a name="IDX-333"></a>
</p>
<div class="section">
<h4 class="sect4-title">
<a name="1043"></a><a name="ch15lev3sec5"></a>Counting the number of parenthesizations</h4>
<p class="first-para">Before solving the matrix-chain multiplication problem by dynamic programming, let us convince ourselves that exhaustively checking all possible parenthesizations does not yield an efficient algorithm. Denote the number of alternative parenthesizations of a sequence of <i class="emphasis">n</i> matrices by <i class="emphasis">P</i>(<i class="emphasis">n</i>). When <i class="emphasis">n</i> = 1, there is just one matrix and therefore only one way to fully parenthesize the matrix product. When <i class="emphasis">n</i> <span class="unicode">&ge;</span> 2, a fully parenthesized matrix product is the product of two fully parenthesized matrix subproducts, and the split between the two subproducts may occur between the <i class="emphasis">k</i>th and (<i class="emphasis">k</i> + 1)st matrices for any <i class="emphasis">k</i> = 1, 2, ..., <i class="emphasis">n</i> - 1. Thus, we obtain the recurrence</p>
<div class="equation">
<a name="1044"></a><a name="ch15eq11"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(15.11)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig355_01.jpg" height="64" width="237" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="last-para">
<a href="DDU0074.html#858" target="_parent" class="chapterjump">Problem 12-4</a> asked you to show that the solution to a similar recurrence is the sequence of <b class="bold"><i class="emphasis">Catalan numbers</i></b>, which grows as <span class="unicode">&#8486;</span>(4<sup><i class="emphasis">n</i></sup>/<i class="emphasis">n</i><sup>3/2</sup>). A simpler exercise (see <a class="internaljump" href="#ch15ex08">Exercise 15.2-3</a>) is to show that the solution to the recurrence (<a class="internaljump" href="#ch15eq11">15.11</a>) is <span class="unicode">&#8486;</span>(2<sup><i class="emphasis">n</i></sup>). The number of solutions is thus exponential in <i class="emphasis">n</i>, and the brute-force method of exhaustive search is therefore a poor strategy for determining the optimal parenthesization of a matrix chain.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1045"></a><a name="ch15lev3sec6"></a><span class="section-titlelabel">Step 1: </span>The structure of an optimal parenthesization</h4>
<p class="first-para">Our first step in the dynamic-programming paradigm is to find the optimal substructure and then use it to construct an optimal solution to the problem from optimal solutions to subproblems. For the matrix-chain multiplication problem, we can perform this step as follows. For convenience, let us adopt the notation <i class="emphasis">A</i><sub><i class="emphasis">i<span class="unicode">&#8229;</span>j</i></sub>, where <i class="emphasis">i</i> <span class="unicode">&le;</span> <i class="emphasis">j</i>, for the matrix that results from evaluating the product <i class="emphasis">A<sub>i</sub></i> <i class="emphasis">A</i><sub><i class="emphasis">i</i>+1</sub> <i class="emphasis">A<sub>j</sub></i>. Observe that if the problem is nontrivial, i.e., <i class="emphasis">i</i> <span class="unicode">&lt;</span> <i class="emphasis">j</i>, then any parenthesization of the product <i class="emphasis">A<sub>i</sub></i> <i class="emphasis">A</i><sub><i class="emphasis">i</i>+1</sub> <i class="emphasis">A<sub>j</sub></i> must split the product between <i class="emphasis">A<sub>k</sub></i> and <i class="emphasis">A</i><sub><i class="emphasis">k</i>+1</sub> for some integer <i class="emphasis">k</i> in the range <i class="emphasis">i</i> <span class="unicode">&le;</span> <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">j</i>. That is, for some value of <i class="emphasis">k</i>, we first compute the matrices <i class="emphasis">A</i><sub><i class="emphasis">i<span class="unicode">&#8229;</span>k</i></sub> and <i class="emphasis">A</i><sub><i class="emphasis">k</i>+1<i class="emphasis"><span class="unicode">&#8229;</span></i><i class="emphasis">j</i></sub> and then multiply them together to produce the final product <i class="emphasis">A</i><sub><i class="emphasis">i<span class="unicode">&#8229;</span>j</i></sub>. The cost of this parenthesization is thus the cost of computing the matrix <i class="emphasis">A</i><sub><i class="emphasis">i<span class="unicode">&#8229;</span>k</i></sub>, plus the cost of computing <i class="emphasis">A</i><sub><i class="emphasis">k</i>+1<i class="emphasis"><span class="unicode">&#8229;</span></i><i class="emphasis">j</i></sub>, plus the cost of multiplying them together.</p>
<p class="para">The optimal substructure of this problem is as follows. Suppose that an optimal parenthesization of <i class="emphasis">A<sub>i</sub></i> <i class="emphasis">A</i><sub><i class="emphasis">i</i>+1</sub> <i class="emphasis">A<sub>j</sub></i> splits the product between <i class="emphasis">A<sub>k</sub></i> and <i class="emphasis">A</i><sub><i class="emphasis">k</i>+1</sub>. Then the parenthesization of the "prefix" subchain <i class="emphasis">A<sub>i</sub></i> <i class="emphasis">A</i><sub><i class="emphasis">i</i>+1</sub> <i class="emphasis">A<sub>k</sub></i> within this optimal parenthesization of <i class="emphasis">A<sub>i</sub></i> <i class="emphasis">A</i><sub><i class="emphasis">i</i>+1</sub> <i class="emphasis">A<sub>j</sub></i> must be an optimal parenthesization of <i class="emphasis">A<sub>i</sub></i> <i class="emphasis">A</i><sub><i class="emphasis">i</i>+1</sub> <i class="emphasis">A<sub>k</sub></i>. Why? If there were a less costly way to parenthesize <i class="emphasis">A<sub>i</sub></i> <i class="emphasis">A</i><sub><i class="emphasis">i</i>+1</sub> <i class="emphasis">A<sub>k</sub></i>, substituting that parenthesization in the optimal parenthesization of <i class="emphasis">A<sub>i</sub></i> <i class="emphasis">A</i><sub><i class="emphasis">i</i>+1</sub> <i class="emphasis">A<sub>j</sub></i> <a name="1046"></a><a name="IDX-334"></a>would produce another parenthesization of <i class="emphasis">A<sub>i</sub></i> <i class="emphasis">A</i><sub><i class="emphasis">i</i>+1</sub> <i class="emphasis">A<sub>j</sub></i> whose cost was lower than the optimum: a contradiction. A similar observation holds for the parenthesization of the subchain <i class="emphasis">A</i><sub><i class="emphasis">k</i>+1</sub> <i class="emphasis">A</i><sub><i class="emphasis">k</i>+2</sub> <i class="emphasis">A<sub>j</sub></i> in the optimal parenthesization of <i class="emphasis">A<sub>i</sub></i> <i class="emphasis">A</i><sub><i class="emphasis">i</i>+1</sub> <i class="emphasis">A<sub>j</sub></i>: it must be an optimal parenthesization of <i class="emphasis">A</i><sub><i class="emphasis">k</i>+1</sub> <i class="emphasis">A</i><sub><i class="emphasis">k</i>+2</sub> <i class="emphasis">A<sub>j</sub></i>.</p>
<p class="last-para">Now we use our optimal substructure to show that we can construct an optimal solution to the problem from optimal solutions to subproblems. We have seen that any solution to a nontrivial instance of the matrix-chain multiplication problem requires us to split the product, and that any optimal solution contains within it optimal solutions to subproblem instances. Thus, we can build an optimal solution to an instance of the matrix-chain multiplication problem by splitting the problem into two subproblems (optimally parenthesizing <i class="emphasis">A<sub>i</sub></i> <i class="emphasis">A</i><sub><i class="emphasis">i</i>+1</sub> <i class="emphasis">A<sub>k</sub></i> and <i class="emphasis">A</i><sub><i class="emphasis">k</i>+1</sub> <i class="emphasis">A</i><sub><i class="emphasis">k</i>+2</sub> <i class="emphasis">A<sub>j</sub></i>), finding optimal solutions to subproblem instances, and then combining these optimal subproblem solutions. We must ensure that when we search for the correct place to split the product, we have considered all possible places so that we are sure of having examined the optimal one.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1047"></a><a name="ch15lev3sec7"></a><span class="section-titlelabel">Step 2: </span>A recursive solution</h4>
<p class="first-para">Next, we define the cost of an optimal solution recursively in terms of the optimal solutions to subproblems. For the matrix-chain multiplication problem, we pick as our subproblems the problems of determining the minimum cost of a parenthesization of <i class="emphasis">A<sub>i</sub></i> <i class="emphasis">A</i><sub><i class="emphasis">i</i>+1</sub> <i class="emphasis">A<sub>j</sub></i> for 1 <span class="unicode">&le;</span> <i class="emphasis">i</i> <span class="unicode">&le;</span> <i class="emphasis">j</i> <span class="unicode">&le;</span> <i class="emphasis">n</i>. Let <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] be the minimum number of scalar multiplications needed to compute the matrix <i class="emphasis">A</i><sub><i class="emphasis">i<span class="unicode">&#8229;</span>j</i></sub>; for the full problem, the cost of a cheapest way to compute <i class="emphasis">A</i><sub>1<i class="emphasis"><span class="unicode">&#8229;</span>n</i></sub> would thus be <i class="emphasis">m</i>[1, <i class="emphasis">n</i>].</p>
<p class="para">We can define <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] recursively as follows. If <i class="emphasis">i</i> = <i class="emphasis">j</i>, the problem is trivial; the chain consists of just one matrix <i class="emphasis">A</i><sub><i class="emphasis">i<span class="unicode">&#8229;</span>i</i></sub> = <i class="emphasis">A<sub>i</sub></i>, so that no scalar multiplications are necessary to compute the product. Thus, <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">i</i>] = 0 for <i class="emphasis">i</i> = 1, 2, ..., <i class="emphasis">n</i>. To compute <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] when <i class="emphasis">i</i> <span class="unicode">&lt;</span> <i class="emphasis">j</i>, we take advantage of the structure of an optimal solution from step 1. Let us assume that the optimal parenthesization splits the product <i class="emphasis">A<sub>i</sub></i> <i class="emphasis">A</i><sub><i class="emphasis">i</i>+1</sub> <i class="emphasis">A<sub>j</sub></i> between <i class="emphasis">A<sub>k</sub></i> and <i class="emphasis">A</i><sub><i class="emphasis">k</i>+1</sub>, where <i class="emphasis">i</i> <span class="unicode">&le;</span> <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">j</i>. Then, <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] is equal to the minimum cost for computing the subproducts <i class="emphasis">A</i><sub><i class="emphasis">i<span class="unicode">&#8229;</span>k</i></sub> and <i class="emphasis">A</i><sub><i class="emphasis">k</i>+1<i class="emphasis"><span class="unicode">&#8229;</span></i><i class="emphasis">j</i></sub>, plus the cost of multiplying these two matrices together. Recalling that each matrix <i class="emphasis">A<sub>i</sub></i> is <i class="emphasis">p</i><sub><i class="emphasis">i</i>-1</sub> <span class="unicode">&times;</span> <i class="emphasis">p<sub>i</sub></i>, we see that computing the matrix product <i class="emphasis">A</i><sub><i class="emphasis">i<span class="unicode">&#8229;</span>k</i></sub> <i class="emphasis">A</i><sub><i class="emphasis">k</i>+1<i class="emphasis"><span class="unicode">&#8229;</span>j</i></sub> takes <i class="emphasis">p</i><sub><i class="emphasis">i</i>-1</sub> <i class="emphasis">p<sub>k</sub></i> <i class="emphasis">p<sub>j</sub></i> scalar multiplications. Thus, we obtain</p>
<p class="para">
<i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i> ] = <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">k</i>] + <i class="emphasis">m</i>[<i class="emphasis">k</i> + 1, <i class="emphasis">j</i> ] + <i class="emphasis">p</i><sub><i class="emphasis">i</i>-1</sub> <i class="emphasis">p<sub>k</sub></i> <i class="emphasis">p<sub>j</sub></i>.</p>
<p class="para">This recursive equation assumes that we know the value of <i class="emphasis">k</i>, which we do not. There are only <i class="emphasis">j</i> - <i class="emphasis">i</i> possible values for <i class="emphasis">k</i>, however, namely <i class="emphasis">k</i> = <i class="emphasis">i</i>, <i class="emphasis">i</i> + 1, ..., <i class="emphasis">j</i> - 1. Since the optimal parenthesization must use one of these values for <i class="emphasis">k</i>, we need only check them all to find the best. Thus, our recursive definition for the minimum cost of parenthesizing the product <i class="emphasis">A<sub>i</sub></i> <i class="emphasis">A</i><sub><i class="emphasis">i</i>+1</sub> <i class="emphasis">A<sub>j</sub></i> becomes<a name="1048"></a><a name="IDX-335"></a>
</p>
<div class="equation">
<a name="1049"></a><a name="ch15eq12"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(15.12)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig357_01.jpg" height="47" width="381" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="last-para">The <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] values give the costs of optimal solutions to subproblems. To help us keep track of how to construct an optimal solution, let us define <i class="emphasis">s</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] to be a value of <i class="emphasis">k</i> at which we can split the product <i class="emphasis">A<sub>i</sub></i> <i class="emphasis">A</i><sub><i class="emphasis">i</i>+1</sub> <i class="emphasis">A<sub>j</sub></i> to obtain an optimal parenthesization. That is, <i class="emphasis">s</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] equals a value <i class="emphasis">k</i> such that <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] = <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">k</i>] + <i class="emphasis">m</i>[<i class="emphasis">k</i> + 1, <i class="emphasis">j</i>] + <i class="emphasis">p</i><sub><i class="emphasis">i</i>-1</sub> <i class="emphasis">p<sub>k</sub></i> <i class="emphasis">p<sub>j</sub></i>.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1050"></a><a name="ch15lev3sec8"></a><span class="section-titlelabel">Step 3: </span>Computing the optimal costs</h4>
<p class="first-para">At this point, it is a simple matter to write a recursive algorithm based on recurrence (<a class="internaljump" href="#ch15eq12">15.12</a>) to compute the minimum cost <i class="emphasis">m</i>[1, <i class="emphasis">n</i>] for multiplying <i class="emphasis">A</i><sub>1</sub> <i class="emphasis">A</i><sub>2</sub> <i class="emphasis">A<sub>n</sub></i>. As we shall see in <a href="DDU0089.html#1062" target="_parent" class="chapterjump">Section 15.3</a>, however, this algorithm takes exponential time, which is no better than the brute-force method of checking each way of parenthesizing the product.</p>
<p class="para">The important observation that we can make at this point is that we have relatively few subproblems: one problem for each choice of <i class="emphasis">i</i> and <i class="emphasis">j</i> satisfying 1 <span class="unicode">&le;</span> <i class="emphasis">i</i> <span class="unicode">&le;</span> <i class="emphasis">j</i> <span class="unicode">&le;</span> <i class="emphasis">n</i>, or <span class="inlinemediaobject"><img src="images/fig357_02.jpg" height="15" width="77" alt="" border="0"></span> in all. A recursive algorithm may encounter each subproblem many times in different branches of its recursion tree. This property of overlapping subproblems is the second hallmark of the applicability of dynamic programming (the first hallmark being optimal substructure).</p>
<p class="para">Instead of computing the solution to recurrence (<a class="internaljump" href="#ch15eq12">15.12</a>) recursively, we perform the third step of the dynamic-programming paradigm and compute the optimal cost by using a tabular, bottom-up approach. The following pseudocode assumes that matrix <i class="emphasis">A<sub>i</sub></i> has dimensions <i class="emphasis">p</i><sub><i class="emphasis">i</i>-1</sub> <span class="unicode">&times;</span> <i class="emphasis">p<sub>i</sub></i> for <i class="emphasis">i</i> = 1, 2, ..., <i class="emphasis">n</i>. The input is a sequence <i class="emphasis">p</i> = <span class="unicode">&#12296;</span><i class="emphasis">p</i><sub>0</sub>, <i class="emphasis">p</i><sub>1</sub>, ..., <i class="emphasis">p<sub>n</sub></i><span class="unicode">&#12297;</span>, where <i class="emphasis">length</i>[<i class="emphasis">p</i>] = <i class="emphasis">n</i> + 1. The procedure uses an auxiliary table <i class="emphasis">m</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>, 1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>] for storing the <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] costs and an auxiliary table <i class="emphasis">s</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>, 1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>] that records which index of <i class="emphasis">k</i> achieved the optimal cost in computing <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>]. We will use the table <i class="emphasis">s</i> to construct an optimal solution.</p>
<p class="para">In order to correctly implement the bottom-up approach, we must determine which entries of the table are used in computing <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>]. <a class="internaljump" href="#ch15eq12">Equation (15.12)</a> shows that the cost <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] of computing a matrix-chain product of <i class="emphasis">j</i> - <i class="emphasis">i</i> + 1 matrices depends only on the costs of computing matrix-chain products of fewer than <i class="emphasis">j</i> - <i class="emphasis">i</i> + 1 matrices. That is, for <i class="emphasis">k</i> = <i class="emphasis">i</i>, <i class="emphasis">i</i> + 1, ..., <i class="emphasis">j</i> - 1, the matrix <i class="emphasis">A</i><sub><i class="emphasis">i<span class="unicode">&#8229;</span>k</i></sub> is a product of <i class="emphasis">k</i> - <i class="emphasis">i</i> + 1 <span class="unicode">&lt;</span> <i class="emphasis">j</i> - <i class="emphasis">i</i> + 1 matrices and the matrix <i class="emphasis">A</i><sub><i class="emphasis">k</i>+1<i class="emphasis"><span class="unicode">&#8229;</span>j</i></sub> is a product of <i class="emphasis">j</i> - <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">j</i> - <i class="emphasis">i</i> + 1 matrices. Thus, the algorithm should fill in the table <i class="emphasis">m</i> in a manner that corresponds to solving the parenthesization problem on matrix chains of increasing length.<a name="1051"></a><a name="IDX-336"></a>
</p>
<div class="informalexample">
<pre class="literallayout-normal">
MATRIX-CHAIN-ORDER(<i class="emphasis">p</i>)
 1 <i class="emphasis">n</i> <span class="unicode">&larr;</span> <i class="emphasis">length</i>[<i class="emphasis">p</i>] - 1
 2 <b class="bold">for</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">n</i>
 3      <b class="bold">do</b> <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">i</i>] <span class="unicode">&larr;</span> 0
 4 <b class="bold">for</b> <i class="emphasis">l</i> <span class="unicode">&larr;</span> 2 <b class="bold">to</b> <i class="emphasis">n</i>      <span class="unicode">&#9657;</span><i class="emphasis">l</i> is the chain length.
 5      <b class="bold">do for</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">n</i> - <i class="emphasis">l</i> + 1
 6             <b class="bold">do</b> <i class="emphasis">j</i> <span class="unicode">&larr;</span> <i class="emphasis">i</i> + <i class="emphasis">l</i> - 1
 7                <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] <span class="unicode">&larr;</span> <span class="unicode">&infin;</span>
 8                <b class="bold">for</b> <i class="emphasis">k</i> <span class="unicode">&larr;</span> <i class="emphasis">i</i> <b class="bold">to</b> <i class="emphasis">j</i> - 1
 9                    <b class="bold">do</b> <i class="emphasis">q</i> <span class="unicode">&larr;</span> <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">k</i>] + <i class="emphasis">m</i>[<i class="emphasis">k</i> + 1, <i class="emphasis">j</i>] + <i class="emphasis">p</i><sub><i class="emphasis">i</i>-1</sub> <i class="emphasis">p<sub>k</sub>p<sub>j</sub></i>
10                       <b class="bold">if</b> <i class="emphasis">q</i> <span class="unicode">&lt;</span> <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>]
11                          <b class="bold">then</b> <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] <span class="unicode">&larr;</span> <i class="emphasis">q</i>
12                               <i class="emphasis">s</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] <span class="unicode">&larr;</span> <i class="emphasis">k</i>
13 <b class="bold">return</b> <i class="emphasis">m</i> and <i class="emphasis">s</i>
</pre>
</div>
<p class="para">The algorithm first computes <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">i</i>] <span class="unicode">&larr;</span> 0 for <i class="emphasis">i</i> = 1, 2, ..., <i class="emphasis">n</i> (the minimum costs for chains of length 1) in lines 2<span class="unicode">-</span>3. It then uses recurrence (<a class="internaljump" href="#ch15eq12">15.12</a>) to compute <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">i</i> + 1] for <i class="emphasis">i</i> = 1, 2, ..., <i class="emphasis">n</i> - 1 (the minimum costs for chains of length <i class="emphasis">l</i> = 2) during the first execution of the loop in lines 4<span class="unicode">-</span>12. The second time through the loop, it computes <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">i</i> + 2] for <i class="emphasis">i</i> = 1, 2, ..., <i class="emphasis">n</i> - 2 (the minimum costs for chains of length <i class="emphasis">l</i> = 3), and so forth. At each step, the <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] cost computed in lines 9<span class="unicode">-</span>12 depends only on table entries <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">k</i>] and <i class="emphasis">m</i>[<i class="emphasis">k</i> + 1, <i class="emphasis">j</i>] already computed.</p>
<p class="para">
<a class="internaljump" href="#ch15fig03">Figure 15.3</a> illustrates this procedure on a chain of <i class="emphasis">n</i> = 6 matrices. Since we have defined <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] only for <i class="emphasis">i</i> <span class="unicode">&le;</span> <i class="emphasis">j</i>, only the portion of the table <i class="emphasis">m</i> strictly above the main diagonal is used. The figure shows the table rotated to make the main diagonal run horizontally. The matrix chain is listed along the bottom. Using this layout, the minimum cost <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] for multiplying a subchain <i class="emphasis">A<sub>i</sub></i> <i class="emphasis">A</i><sub><i class="emphasis">i</i>+1</sub> <i class="emphasis">A<sub>j</sub></i> of matrices can be found at the intersection of lines running northeast from <i class="emphasis">A<sub>i</sub></i> and northwest from <i class="emphasis">A<sub>j</sub></i>. Each horizontal row in the table contains the entries for matrix chains of the same length. MATRIX-CHAIN-ORDER computes the rows from bottom to top and from left to right within each row. An entry <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] is computed using the products <i class="emphasis">p</i><sub><i class="emphasis">i</i>-1</sub> <i class="emphasis">p<sub>k</sub></i> <i class="emphasis">p<sub>j</sub></i> for <i class="emphasis">k</i> = <i class="emphasis">i</i>, <i class="emphasis">i</i> + 1, ..., <i class="emphasis">j</i> - 1 and all entries southwest and southeast from <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>].</p>
<div class="figure">
<a name="1052"></a><a name="ch15fig03"></a><span class="figuremediaobject"><a href="images/fig359%5F01%5F0%2Ejpg" NAME="IMG_454" target="_parent"><img src="images/fig359_01.jpg" height="130" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 15.3: </span>The <i class="emphasis">m</i> and <i class="emphasis">s</i> tables computed by MATRIX-CHAIN-ORDER for <i class="emphasis">n</i> = 6 and the following matrix dimensions:</span>
</div>
<div class="informaltable">
<table border="0">
<thead>
<tr valign="top">
<th class="th" scope="col" align="center">
<p class="table-para">matrix</p>
</th><th class="th" scope="col" align="left">
<p class="table-para">dimension</p>
</th>
</tr>
<tr>
<td colspan="2">
<hr>
</td>
</tr>
</thead>
<tbody>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">
<i class="emphasis">A</i><sub>1</sub>
</p>
</td><td class="td" align="left">
<p class="table-para">30 <span class="unicode">&times;</span> 35</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">
<i class="emphasis">A</i><sub>2</sub>
</p>
</td><td class="td" align="left">
<p class="table-para">35 <span class="unicode">&times;</span> 15</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">
<i class="emphasis">A</i><sub>3</sub>
</p>
</td><td class="td" align="left">
<p class="table-para">15 <span class="unicode">&times;</span> 5</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">
<i class="emphasis">A</i><sub>4</sub>
</p>
</td><td class="td" align="left">
<p class="table-para">5 <span class="unicode">&times;</span> 10</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">
<i class="emphasis">A</i><sub>5</sub>
</p>
</td><td class="td" align="left">
<p class="table-para">10 <span class="unicode">&times;</span> 20</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">
<i class="emphasis">A</i><sub>6</sub>
</p>
</td><td class="td" align="left">
<p class="table-para">20 <span class="unicode">&times;</span> 25</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">The tables are rotated so that the main diagonal runs horizontally. Only the main diagonal and upper triangle are used in the <i class="emphasis">m</i> table, and only the upper triangle is used in the <i class="emphasis">s</i> table. The minimum number of scalar multiplications to multiply the 6 matrices is <i class="emphasis">m</i>[1, 6] = 15,125. Of the darker entries, the pairs that have the same shading are taken together in line 9 when computing</p>
<div class="informalequation">
<span class="equation-image"><a href="images/fig359%5F02%2Ejpg" NAME="IMG_455" target="_parent"><img src="images/fig359_02.jpg" height="63" width="400" alt="Click To expand" border="0"></a></span>
</div>
<p class="last-para">A simple inspection of the nested loop structure of MATRIX-CHAIN-ORDER yields a running time of <i class="emphasis">O</i>(<i class="emphasis">n</i><sup>3</sup>) for the algorithm. The loops are nested three deep, and each loop index (<i class="emphasis">l</i>, <i class="emphasis">i</i>, and <i class="emphasis">k</i>) takes on at most <i class="emphasis">n</i> -1 values. <a class="internaljump" href="#ch15ex09">Exercise 15.2-4</a> asks you to show that the running time of this algorithm is in fact also <span class="unicode">&#8486;</span>(<i class="emphasis">n</i><sup>3</sup>). The algorithm requires <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>2</sup>) space to store the <i class="emphasis">m</i> and <i class="emphasis">s</i> tables. Thus, MATRIX-CHAIN-ORDER is much more efficient than the exponential-time method of enumerating all possible parenthesizations and checking each one.<a name="1053"></a><a name="IDX-337"></a>
</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1054"></a><a name="ch15lev3sec9"></a><span class="section-titlelabel">Step 4: </span>Constructing an optimal solution</h4>
<p class="first-para">Although MATRIX-CHAIN-ORDER determines the optimal number of scalar multiplications needed to compute a matrix-chain product, it does not directly show how to multiply the matrices. It is not difficult to construct an optimal solution from the computed information stored in the table <i class="emphasis">s</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>, 1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>]. Each entry <i class="emphasis">s</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] records the value of <i class="emphasis">k</i> such that the optimal parenthesization of <i class="emphasis">A<sub>i</sub></i> <i class="emphasis">A</i><sub><i class="emphasis">i</i>+1</sub> <span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&middot;</span> <i class="emphasis">A<sub>j</sub></i> splits the product between <i class="emphasis">A<sub>k</sub></i> and <i class="emphasis">A</i><sub><i class="emphasis">k</i>+1</sub>. Thus, we know that the final matrix multiplication in computing <i class="emphasis">A</i><sub>1<i class="emphasis"><span class="unicode">&#8229;</span>n</i></sub> optimally is <i class="emphasis">A</i><sub>1<i class="emphasis"><span class="unicode">&#8229;</span>s</i>[1,<i class="emphasis">n</i>]</sub> <i class="emphasis">A</i><sub><i class="emphasis">s</i>[1,<i class="emphasis">n</i>]+1<i class="emphasis"><span class="unicode">&#8229;</span>n</i></sub>. The earlier matrix multiplications can be computed recursively, since <i class="emphasis">s</i>[1, <i class="emphasis">s</i>[1, <i class="emphasis">n</i>]] determines <a name="1055"></a><a name="IDX-338"></a>the last matrix multiplication in computing <i class="emphasis">A</i><sub>1<i class="emphasis"><span class="unicode">&#8229;</span>s</i>[1,<i class="emphasis">n</i>]</sub>, and <i class="emphasis">s</i>[<i class="emphasis">s</i>[1, <i class="emphasis">n</i>] + 1, <i class="emphasis">n</i>] determines the last matrix multiplication in computing <i class="emphasis">A</i><sub><i class="emphasis">s</i>[1,<i class="emphasis">n</i>]+1<i class="emphasis"><span class="unicode">&#8229;</span>n</i></sub>. The following recursive procedure prints an optimal parenthesization of <span class="unicode">&#12296;</span><i class="emphasis">A<sub>i</sub></i>, <i class="emphasis">A</i><sub><i class="emphasis">i</i>+1</sub>, ..., <i class="emphasis">A<sub>j</sub></i><span class="unicode">&#12297;</span>, given the <i class="emphasis">s</i> table computed by MATRIX-CHAIN-ORDER and the indices <i class="emphasis">i</i> and <i class="emphasis">j</i>. The initial call PRINT-OPTIMAL-PARENS(<i class="emphasis">s</i>, 1, <i class="emphasis">n</i>) prints an optimal parenthesization of <span class="unicode">&#12296;</span><i class="emphasis">A</i><sub>1</sub>, <i class="emphasis">A</i><sub>2</sub>, ..., <i class="emphasis">A<sub>n</sub></i><span class="unicode">&#12297;</span>.</p>
<div class="informalexample">
<pre class="literallayout-normal">
PRINT-OPTIMAL-PARENS(<i class="emphasis">s</i>, <i class="emphasis">i</i>, <i class="emphasis">j</i>)
1 <b class="bold">if</b> <i class="emphasis">i</i> = <i class="emphasis">j</i>
2     <b class="bold">then</b> print "<i class="emphasis">A</i>"<sub><i class="emphasis">i</i></sub>
3     <b class="bold">else</b> print "("
4          PRINT-OPTIMAL-PARENS(<i class="emphasis">s</i>, <i class="emphasis">i</i>, <i class="emphasis">s</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>])
5          PRINT-OPTIMAL-PARENS(<i class="emphasis">s</i>, <i class="emphasis">s</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] + 1, <i class="emphasis">j</i>)
6          print ")"
</pre>
</div>
<p class="para">In the example of <a class="internaljump" href="#ch15fig03">Figure 15.3</a>, the call PRINT-OPTIMAL-PARENS(<i class="emphasis">s</i>, 1, 6) prints the parenthesization ((<i class="emphasis">A</i><sub>1</sub> (<i class="emphasis">A</i><sub>2</sub> <i class="emphasis">A</i><sub>3</sub>)) ((<i class="emphasis">A</i><sub>4</sub> <i class="emphasis">A</i><sub>5</sub>)<i class="emphasis">A</i><sub>6</sub>)).</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 15.2-1</span></span><a name="1056"></a><a name="ch15ex06"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Find an optimal parenthesization of a matrix-chain product whose sequence of dimensions is <span class="unicode">&#12296;</span>5, 10, 3, 12, 5, 50, 6<span class="unicode">&#12297;</span>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 15.2-2</span></span><a name="1057"></a><a name="ch15ex07"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Give a recursive algorithm MATRIX-CHAIN-MULTIPLY(<i class="emphasis">A</i>, <i class="emphasis">s</i>, <i class="emphasis">i</i>, <i class="emphasis">j</i>) that actually performs the optimal matrix-chain multiplication, given the sequence of matrices <span class="unicode">&#12296;</span><i class="emphasis">A</i><sub>1</sub>, <i class="emphasis">A</i><sub>2</sub>, ..., <i class="emphasis">A<sub>n</sub></i><span class="unicode">&#12297;</span>, the <i class="emphasis">s</i> table computed by MATRIX-CHAIN-ORDER, and the indices <i class="emphasis">i</i> and <i class="emphasis">j</i>. (The initial call would be MATRIX-CHAIN-MULTIPLY(<i class="emphasis">A</i>, <i class="emphasis">s</i>, 1, <i class="emphasis">n</i>).)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 15.2-3</span></span><a name="1058"></a><a name="ch15ex08"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Use the substitution method to show that the solution to the recurrence (<a class="internaljump" href="#ch15eq11">15.11</a>) is <span class="unicode">&#8486;</span>(2<sup><i class="emphasis">n</i></sup>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 15.2-4</span></span><a name="1059"></a><a name="ch15ex09"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">R</i>(<i class="emphasis">i</i>, <i class="emphasis">j</i>) be the number of times that table entry <i class="emphasis">m</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] is referenced while computing other table entries in a call of MATRIX-CHAIN-ORDER. Show that the total number of references for the entire table is</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig360_01.jpg" height="43" width="158" alt="" border="0"></span>
</div>
<p class="last-para">(<i class="emphasis">Hint:</i> You may find <a href="DDU0244.html#3286" target="_parent" class="chapterjump">equation (A.3)</a> useful.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1060"></a><a name="IDX-339"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 15.2-5</span></span><a name="1061"></a><a name="ch15ex10"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that a full parenthesization of an <i class="emphasis">n</i>-element expression has exactly <i class="emphasis">n</i> - 1 pairs of parentheses.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0087.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0089.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
