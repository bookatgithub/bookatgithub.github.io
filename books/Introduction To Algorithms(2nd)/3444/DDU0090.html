<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>15.4 Longest common subsequence</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0089.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0091.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch15"></a>
<div class="section">
<h2 class="first-section-title">
<a name="1085"></a><a name="ch15lev1sec4"></a><span class="section-titlelabel">15.4 </span>Longest common subsequence</h2>
<p class="first-para">In biological applications, we often want to compare the DNA of two (or more) different organisms. A strand of DNA consists of a string of molecules called <b class="bold"><i class="emphasis">bases</i></b>, where the possible bases are adenine, guanine, cytosine, and thymine. Representing each of these bases by their initial letters, a strand of DNA can be expressed as a string over the finite set {<span class="fixed">A</span>, <span class="fixed">C</span>, <span class="fixed">G</span>, <span class="fixed">T</span>}. (See <a href="DDU0253.html#3407" target="_parent" class="chapterjump">Appendix C</a> for a definition of a string.) For example, the DNA of one organism may be <i class="emphasis">S</i><sub>1</sub>= <span class="fixed">ACCGGTCGAGTGCGCGGAAGCCGGCCGAA</span>, while the DNA of another organism may be <i class="emphasis">S</i><sub>2</sub> = <span class="fixed">GTCGTTCGGAATGCCGTTGCTCTGTAAA</span>. One goal of comparing two strands of DNA is to determine how "similar" the two strands are, as some measure of how closely related the two organisms are. Similarity can be and is defined in many different ways. For example, we can say that two DNA strands are similar if one is a substring of the other. (<a href="DDU0210.html#2821" target="_parent" class="chapterjump">Chapter 32</a> explores algorithms to solve this problem.) In our example, neither <i class="emphasis">S</i><sub>1</sub> nor <i class="emphasis">S</i><sub>2</sub> is a substring of the other. Alternatively, we could say that two strands are similar if the number of changes needed to turn one into the other is small. (<a href="DDU0091.html#1132" target="_parent" class="chapterjump">Problem 15-3</a> looks at this notion.) Yet another way to measure the similarity of strands <i class="emphasis">S</i><sub>1</sub> and <i class="emphasis">S</i><sub>2</sub> is by finding a third strand <i class="emphasis">S</i><sub>3</sub> in which the bases in <i class="emphasis">S</i><sub>3</sub> appear in each of <i class="emphasis">S</i><sub>1</sub> and <i class="emphasis">S</i><sub>2</sub>; these bases must appear in the same order, but not necessarily consecutively. The longer the strand <i class="emphasis">S</i><sub>3</sub> we can find, the more similar <i class="emphasis">S</i><sub>1</sub> and <i class="emphasis">S</i><sub>2</sub> are. In our example, the longest strand <i class="emphasis">S</i><sub>3</sub> is <span class="fixed">GTCGTCGGAAGCCGGCCGAA</span>.</p>
<p class="para">We formalize this last notion of similarity as the longest-common-subsequence problem. A subsequence of a given sequence is just the given sequence with zero or more elements left out. Formally, given a sequence <i class="emphasis">X</i> = <span class="unicode">&#12296;</span><i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, ..., <i class="emphasis">x<sub>m</sub></i><span class="unicode">&#12297;</span>, another sequence <i class="emphasis">Z</i> = <span class="unicode">&#12296;</span><i class="emphasis">z</i><sub>1</sub>, <i class="emphasis">z</i><sub>2</sub>, ..., <i class="emphasis">z<sub>k</sub></i><span class="unicode">&#12297;</span> is a <b class="bold"><i class="emphasis">subsequence</i></b> of <i class="emphasis">X</i> if there exists a strictly increasing sequence <span class="unicode">&#12296;</span><i class="emphasis">i</i><sub>1</sub>,<i class="emphasis">i</i><sub>2</sub>, ..., <i class="emphasis">i<sub>k</sub></i><span class="unicode">&#12297;</span> of indices of <i class="emphasis">X</i> such that for all <i class="emphasis">j</i> = 1, 2, ..., <i class="emphasis">k</i>, <a name="1086"></a><a name="IDX-351"></a>we have <i class="emphasis">x<sub>ij</sub></i> = <i class="emphasis">z<sub>j</sub></i> . For example, <i class="emphasis">Z</i> = <span class="unicode">&#12296;</span><i class="emphasis">B</i>, <i class="emphasis">C</i>, <i class="emphasis">D</i>, <i class="emphasis">B</i><span class="unicode">&#12297;</span> is a subsequence of <i class="emphasis">X</i> = <span class="unicode">&#12296;</span><i class="emphasis">A</i>, <i class="emphasis">B</i>, <i class="emphasis">C</i>, <i class="emphasis">B</i>, <i class="emphasis">D</i>, <i class="emphasis">A</i>, <i class="emphasis">B</i><span class="unicode">&#12297;</span> with corresponding index sequence <span class="unicode">&#12296;</span>2, 3, 5, 7<span class="unicode">&#12297;</span>.</p>
<p class="para">Given two sequences <i class="emphasis">X</i> and <i class="emphasis">Y</i> , we say that a sequence <i class="emphasis">Z</i> is a <b class="bold"><i class="emphasis">common subsequence</i></b> of <i class="emphasis">X</i> and <i class="emphasis">Y</i> if <i class="emphasis">Z</i> is a subsequence of both <i class="emphasis">X</i> and <i class="emphasis">Y</i> . For example, if <i class="emphasis">X</i> = <span class="unicode">&#12296;</span><i class="emphasis">A</i>, <i class="emphasis">B</i>, <i class="emphasis">C</i>, <i class="emphasis">B</i>, <i class="emphasis">D</i>, <i class="emphasis">A</i>, <i class="emphasis">B</i><span class="unicode">&#12297;</span> and <i class="emphasis">Y</i> = <span class="unicode">&#12296;</span><i class="emphasis">B</i>, <i class="emphasis">D</i>, <i class="emphasis">C</i>, <i class="emphasis">A</i>, <i class="emphasis">B</i>, <i class="emphasis">A</i><span class="unicode">&#12297;</span>, the sequence <span class="unicode">&#12296;</span><i class="emphasis">B</i>, <i class="emphasis">C</i>, <i class="emphasis">A</i><span class="unicode">&#12297;</span> is a common subsequence of both <i class="emphasis">X</i> and <i class="emphasis">Y</i> . The sequence <span class="unicode">&#12296;</span><i class="emphasis">B</i>, <i class="emphasis">C</i>, <i class="emphasis">A</i><span class="unicode">&#12297;</span> is not a <i class="emphasis">longest</i> common subsequence (LCS) of <i class="emphasis">X</i> and <i class="emphasis">Y</i> , however, since it has length 3 and the sequence <span class="unicode">&#12296;</span><i class="emphasis">B</i>, <i class="emphasis">C</i>, <i class="emphasis">B</i>, <i class="emphasis">A</i><span class="unicode">&#12297;</span>, which is also common to both <i class="emphasis">X</i> and <i class="emphasis">Y</i> , has length 4. The sequence <span class="unicode">&#12296;</span><i class="emphasis">B</i>, <i class="emphasis">C</i>, <i class="emphasis">B</i>, <i class="emphasis">A</i><span class="unicode">&#12297;</span> is an LCS of <i class="emphasis">X</i> and <i class="emphasis">Y</i> , as is the sequence <span class="unicode">&#12296;</span><i class="emphasis">B</i>, <i class="emphasis">D</i>, <i class="emphasis">A</i>, <i class="emphasis">B</i><span class="unicode">&#12297;</span>, since there is no common subsequence of length 5 or greater.</p>
<p class="para">In the <b class="bold"><i class="emphasis">longest-common-subsequence problem</i></b>, we are given two sequences <i class="emphasis">X</i> = <span class="unicode">&#12296;</span><i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, ..., <i class="emphasis">x<sub>m</sub></i><span class="unicode">&#12297;</span> and <i class="emphasis">Y</i> = <span class="unicode">&#12296;</span><i class="emphasis">y</i><sub>1</sub>, <i class="emphasis">y</i><sub>2</sub>, ..., <i class="emphasis">y<sub>n</sub></i><span class="unicode">&#12297;</span> and wish to find a maximum-length common subsequence of <i class="emphasis">X</i> and <i class="emphasis">Y</i> . This section shows that the LCS problem can be solved efficiently using dynamic programming.</p>
<div class="section">
<h4 class="sect4-title">
<a name="1087"></a><a name="ch15lev3sec14"></a><span class="section-titlelabel">Step 1: </span>Characterizing a longest common subsequence</h4>
<p class="first-para">A brute-force approach to solving the LCS problem is to enumerate all subsequences of <i class="emphasis">X</i> and check each subsequence to see if it is also a subsequence of <i class="emphasis">Y</i> , keeping track of the longest subsequence found. Each subsequence of <i class="emphasis">X</i> corresponds to a subset of the indices {1, 2, ..., <i class="emphasis">m</i>} of <i class="emphasis">X</i>. There are 2<i class="emphasis"><sup>m</sup></i> subsequences of <i class="emphasis">X</i>, so this approach requires exponential time, making it impractical for long sequences.</p>
<p class="para">The LCS problem has an optimal-substructure property, however, as the following theorem shows. As we shall see, the natural classes of subproblems correspond to pairs of "prefixes" of the two input sequences. To be precise, given a sequence <i class="emphasis">X</i> = <span class="unicode">&#12296;</span><i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, ..., <i class="emphasis">x<sub>m</sub></i><span class="unicode">&#12297;</span>, we define the <i class="emphasis">i</i>th <b class="bold"><i class="emphasis">prefix</i></b> of <i class="emphasis">X</i>, for <i class="emphasis">i</i> = 0, 1, ..., <i class="emphasis">m</i>, as <i class="emphasis">X<sub>i</sub></i> = <span class="unicode">&#12296;</span><i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, ..., <i class="emphasis">x<sub>i</sub></i><span class="unicode">&#12297;</span>. For example, if <i class="emphasis">X</i> = <span class="unicode">&#12296;</span><i class="emphasis">A</i>, <i class="emphasis">B</i>, <i class="emphasis">C</i>, <i class="emphasis">B</i>, <i class="emphasis">D</i>, <i class="emphasis">A</i>, <i class="emphasis">B</i><span class="unicode">&#12297;</span>, then <i class="emphasis">X</i><sub>4</sub> = <span class="unicode">&#12296;</span><i class="emphasis">A</i>, <i class="emphasis">B</i>, <i class="emphasis">C</i>, <i class="emphasis">B</i><span class="unicode">&#12297;</span> and <i class="emphasis">X</i><sub>0</sub> is the empty sequence.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 15.1: </span>(Optimal substructure of an LCS)</span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">X</i> = <span class="unicode">&#12296;</span><i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, ..., <i class="emphasis">x<sub>m</sub></i><span class="unicode">&#12297;</span> and <i class="emphasis">Y</i> = <span class="unicode">&#12296;</span><i class="emphasis">y</i><sub>1</sub>, <i class="emphasis">y</i><sub>2</sub>, ..., <i class="emphasis">y<sub>n</sub></i><span class="unicode">&#12297;</span> be sequences, and let <i class="emphasis">Z</i> = <span class="unicode">&#12296;</span><i class="emphasis">z</i><sub>1</sub>, <i class="emphasis">z</i><sub>2</sub>, ..., <i class="emphasis">z<sub>k</sub></i><span class="unicode">&#12297;</span> be any LCS of <i class="emphasis">X</i> and <i class="emphasis">Y</i>.</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="first-para">If <i class="emphasis">x<sub>m</sub></i> = <i class="emphasis">y<sub>n</sub></i>, then <i class="emphasis">z<sub>k</sub></i> = <i class="emphasis">x<sub>m</sub></i> = <i class="emphasis">y<sub>n</sub></i> and <i class="emphasis">Z</i><sub><i class="emphasis">k</i>-1</sub> is an LCS of <i class="emphasis">X</i><sub><i class="emphasis">m</i>-1</sub> and <i class="emphasis">Y</i><sub><i class="emphasis">n</i>-1</sub>.</p>
</li>
<li class="listitem">
<p class="first-para">If <i class="emphasis">x<sub>m</sub></i> <span class="unicode">&ne;</span> <i class="emphasis">y<sub>n</sub></i>, then <i class="emphasis">z<sub>k</sub></i> <span class="unicode">&ne;</span> <i class="emphasis">x<sub>m</sub></i> implies that <i class="emphasis">Z</i> is an LCS of <i class="emphasis">X</i><sub><i class="emphasis">m</i>-1</sub> and <i class="emphasis">Y</i>.</p>
</li>
<li class="listitem">
<p class="first-para">If <i class="emphasis">x<sub>m</sub></i> <span class="unicode">&ne;</span> <i class="emphasis">y<sub>n</sub></i>, then <i class="emphasis">z<sub>k</sub></i> <span class="unicode">&ne;</span> <i class="emphasis">y<sub>n</sub></i> implies that <i class="emphasis">Z</i> is an LCS of <i class="emphasis">X</i> and <i class="emphasis">Y</i><sub><i class="emphasis">n</i>-1</sub>.</p>
</li>
</ol>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> (1) If <i class="emphasis">z<sub>k</sub></i> <span class="unicode">&ne;</span> <i class="emphasis">x<sub>m</sub></i>, then we could append <i class="emphasis">x<sub>m</sub></i> = <i class="emphasis">y<sub>n</sub></i> to <i class="emphasis">Z</i> to obtain a common subsequence of <i class="emphasis">X</i> and <i class="emphasis">Y</i> of length <i class="emphasis">k</i> + 1, contradicting the supposition that <i class="emphasis">Z</i> is a <i class="emphasis">longest</i> common subsequence of <i class="emphasis">X</i> and <i class="emphasis">Y</i> . Thus, we must have <i class="emphasis">z<sub>k</sub></i> = <i class="emphasis">x<sub>m</sub></i> = <i class="emphasis">y<sub>n</sub></i>. <a name="1088"></a><a name="IDX-352"></a>Now, the prefix <i class="emphasis">Z</i><sub><i class="emphasis">k</i>-1</sub> is a length-(<i class="emphasis">k</i> - 1) common subsequence of <i class="emphasis">X</i><sub><i class="emphasis">m</i>-1</sub> and <i class="emphasis">Y</i><sub><i class="emphasis">n</i>-1</sub>. We wish to show that it is an LCS. Suppose for the purpose of contradiction that there is a common subsequence <i class="emphasis">W</i> of <i class="emphasis">X</i><sub><i class="emphasis">m</i>-1</sub> and <i class="emphasis">Y</i><sub><i class="emphasis">n</i>-1</sub> with length greater than <i class="emphasis">k</i> - 1. Then, appending <i class="emphasis">x<sub>m</sub></i> = <i class="emphasis">y<sub>n</sub></i> to <i class="emphasis">W</i> produces a common subsequence of <i class="emphasis">X</i> and <i class="emphasis">Y</i> whose length is greater than <i class="emphasis">k</i>, which is a contradiction.</p>
<p class="para">(2) If <i class="emphasis">z<sub>k</sub></i> <span class="unicode">&ne;</span> <i class="emphasis">x<sub>m</sub></i>, then <i class="emphasis">Z</i> is a common subsequence of <i class="emphasis">X</i><sub><i class="emphasis">m</i>-1</sub> and <i class="emphasis">Y</i>. If there were a common subsequence <i class="emphasis">W</i> of <i class="emphasis">X</i><sub><i class="emphasis">m</i>-1</sub> and <i class="emphasis">Y</i> with length greater than <i class="emphasis">k</i>, then <i class="emphasis">W</i> would also be a common subsequence of <i class="emphasis">X<sub>m</sub></i> and <i class="emphasis">Y</i> , contradicting the assumption that <i class="emphasis">Z</i> is an LCS of <i class="emphasis">X</i> and <i class="emphasis">Y</i>.</p>
<p class="last-para">(3) The proof is symmetric to (2).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="last-para">The characterization of <a href="DDU0087.html#1019" target="_parent" class="chapterjump">Theorem 15.1</a> shows that an LCS of two sequences contains within it an LCS of prefixes of the two sequences. Thus, the LCS problem has an optimal-substructure property. A recursive solution also has the overlapping-subproblems property, as we shall see in a moment.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1089"></a><a name="ch15lev3sec15"></a><span class="section-titlelabel">Step 2: </span>A recursive solution</h4>
<p class="first-para">
<a href="DDU0087.html#1019" target="_parent" class="chapterjump">Theorem 15.1</a> implies that there are either one or two subproblems to examine when finding an LCS of <i class="emphasis">X</i> = <span class="unicode">&#12296;</span><i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, ..., <i class="emphasis">x<sub>m</sub></i><span class="unicode">&#12297;</span> and <i class="emphasis">Y</i> = <span class="unicode">&#12296;</span><i class="emphasis">y</i><sub>1</sub>, <i class="emphasis">y</i><sub>2</sub>, ..., <i class="emphasis">y<sub>n</sub></i><span class="unicode">&#12297;</span>. If <i class="emphasis">x<sub>m</sub></i> = <i class="emphasis">y<sub>n</sub></i>, we must find an LCS of <i class="emphasis">X</i><sub><i class="emphasis">m</i>-1</sub> and <i class="emphasis">Y</i><sub><i class="emphasis">n</i>-1</sub>. Appending <i class="emphasis">x<sub>m</sub></i> = <i class="emphasis">y<sub>n</sub></i> to this LCS yields an LCS of <i class="emphasis">X</i> and <i class="emphasis">Y</i>. If <i class="emphasis">x<sub>m</sub></i> <span class="unicode">&ne;</span> <i class="emphasis">y<sub>n</sub></i>, then we must solve two subproblems: finding an LCS of <i class="emphasis">X</i><sub><i class="emphasis">m</i>-1</sub> and <i class="emphasis">Y</i> and finding an LCS of <i class="emphasis">X</i> and <i class="emphasis">Y</i><sub><i class="emphasis">n</i>-1</sub>. Whichever of these two LCS's is longer is an LCS of <i class="emphasis">X</i> and <i class="emphasis">Y</i>. Because these cases exhaust all possibilities, we know that one of the optimal subproblem solutions must be used within an LCS of <i class="emphasis">X</i> and <i class="emphasis">Y</i> .</p>
<p class="para">We can readily see the overlapping-subproblems property in the LCS problem. To find an LCS of <i class="emphasis">X</i> and <i class="emphasis">Y</i> , we may need to find the LCS's of <i class="emphasis">X</i> and <i class="emphasis">Y</i><sub><i class="emphasis">n</i>-1</sub> and of <i class="emphasis">X</i><sub><i class="emphasis">m</i>-1</sub> and <i class="emphasis">Y</i> . But each of these subproblems has the subsubproblem of finding the LCS of <i class="emphasis">X</i><sub><i class="emphasis">m</i>-1</sub> and <i class="emphasis">Y</i><sub><i class="emphasis">n</i>-1</sub>. Many other subproblems share subsubproblems.</p>
<p class="para">As in the matrix-chain multiplication problem, our recursive solution to the LCS problem involves establishing a recurrence for the value of an optimal solution. Let us define <i class="emphasis">c</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] to be the length of an LCS of the sequences <i class="emphasis">X<sub>i</sub></i> and <i class="emphasis">Y<sub>j</sub></i> . If either <i class="emphasis">i</i> = 0 or <i class="emphasis">j</i> = 0, one of the sequences has length 0, so the LCS has length 0. The optimal substructure of the LCS problem gives the recursive formula</p>
<div class="equation">
<a name="1090"></a><a name="ch15eq14"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(15.14)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig374_01.jpg" height="55" width="387" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="last-para">Observe that in this recursive formulation, a condition in the problem restricts which subproblems we may consider. When <i class="emphasis">x<sub>i</sub></i> = <i class="emphasis">y<sub>j</sub></i> , we can and should consider the subproblem of finding the LCS of <i class="emphasis">X</i><sub><i class="emphasis">i</i>-1</sub> and <i class="emphasis">Y</i><sub><i class="emphasis">j</i>-1</sub>. Otherwise, we in <a name="1091"></a><a name="IDX-353"></a>stead consider the two subproblems of finding the LCS of <i class="emphasis">X<sub>i</sub></i> and <i class="emphasis">Y</i><sub><i class="emphasis">j</i>-1</sub> and of <i class="emphasis">X</i><sub><i class="emphasis">i</i>-1</sub> and <i class="emphasis">Y<sub>j</sub></i>. In the previous dynamic-programming algorithms we have examined<span class="unicode">-</span>for assembly-line scheduling and matrix-chain multiplication<span class="unicode">-</span>no subproblems were ruled out due to conditions in the problem. Finding the LCS is not the only dynamic-programming algorithm that rules out subproblems based on conditions in the problem. For example, the edit-distance problem (see <a href="DDU0091.html#1132" target="_parent" class="chapterjump">Problem 15-3</a>) has this characteristic.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1092"></a><a name="ch15lev3sec16"></a><span class="section-titlelabel">Step 3: </span>Computing the length of an LCS</h4>
<p class="first-para">Based on <a class="internaljump" href="#ch15eq14">equation (15.14</a>), we could easily write an exponential-time recursive algorithm to compute the length of an LCS of two sequences. Since there are only <span class="unicode">&Theta;</span>(<i class="emphasis">mn</i>) distinct subproblems, however, we can use dynamic programming to compute the solutions bottom up.</p>
<p class="para">Procedure LCS-LENGTH takes two sequences <i class="emphasis">X</i> = <span class="unicode">&#12296;</span><i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, ..., <i class="emphasis">x<sub>m</sub></i><span class="unicode">&#12297;</span> and <i class="emphasis">Y</i> = <span class="unicode">&#12296;</span><i class="emphasis">y</i><sub>1</sub>, <i class="emphasis">y</i><sub>2</sub>, ..., <i class="emphasis">y<sub>n</sub></i><span class="unicode">&#12297;</span> as inputs. It stores the <i class="emphasis">c</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] values in a table <i class="emphasis">c</i>[0 <span class="unicode">&#8229;</span> <i class="emphasis">m</i>, 0 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>] whose entries are computed in row-major order. (That is, the first row of <i class="emphasis">c</i> is filled in from left to right, then the second row, and so on.) It also maintains the table <i class="emphasis">b</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">m</i>, 1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>] to simplify construction of an optimal solution. Intuitively, <i class="emphasis">b</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] points to the table entry corresponding to the optimal subproblem solution chosen when computing <i class="emphasis">c</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>]. The procedure returns the <i class="emphasis">b</i> and <i class="emphasis">c</i> tables; <i class="emphasis">c</i>[<i class="emphasis">m</i>, <i class="emphasis">n</i>] contains the length of an LCS of <i class="emphasis">X</i> and <i class="emphasis">Y</i>.</p>
<div class="informalexample">
<pre class="literallayout-normal">
LCS-LENGTH(<i class="emphasis">X</i>, <i class="emphasis">Y</i>)
 1 <i class="emphasis">m</i> <span class="unicode">&larr;</span> <i class="emphasis">length</i>[<i class="emphasis">X</i>]
 2 <i class="emphasis">n</i> <span class="unicode">&larr;</span> <i class="emphasis">length</i>[<i class="emphasis">Y</i>]
 3 <b class="bold">for</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">m</i>
 4      <b class="bold">do</b> <i class="emphasis">c</i>[<i class="emphasis">i</i>, 0] <span class="unicode">&larr;</span> 0
 5 <b class="bold">for</b> <i class="emphasis">j</i> <span class="unicode">&larr;</span> 0 <b class="bold">to</b> <i class="emphasis">n</i>
 6      <b class="bold">do</b> <i class="emphasis">c</i>[0, <i class="emphasis">j</i>] <span class="unicode">&larr;</span> 0
 7 <b class="bold">for</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">m</i>
 8      <b class="bold">do for</b> <i class="emphasis">j</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">n</i>
 9             <b class="bold">do if</b> <i class="emphasis">x<sub>i</sub></i> = <i class="emphasis">y<sub>j</sub></i>
10                   <b class="bold">then</b> <i class="emphasis">c</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] <span class="unicode">&larr;</span> <i class="emphasis">c</i>[<i class="emphasis">i</i> - 1, <i class="emphasis">j</i> - 1] + 1
11                        <i class="emphasis">b</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] <span class="unicode">&larr;</span> "<span class="unicode">&#8598;</span>"
12                   <b class="bold">else if</b> <i class="emphasis">c</i>[<i class="emphasis">i</i> - 1, <i class="emphasis">j</i>] <span class="unicode">&ge;</span> <i class="emphasis">c</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i> - 1]
13                           <b class="bold">then</b> <i class="emphasis">c</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] <span class="unicode">&larr;</span> <i class="emphasis">c</i>[<i class="emphasis">i</i> - 1, <i class="emphasis">j</i>]
14                                <i class="emphasis">b</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] <span class="unicode">&larr;</span> "<span class="unicode">&uarr;</span>"
15                           <b class="bold">else</b> <i class="emphasis">c</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] <span class="unicode">&larr;</span> <i class="emphasis">c</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i> - 1]
16                                <i class="emphasis">b</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] <span class="unicode">&larr;</span> <span class="unicode">&larr;</span>
17 <b class="bold">return</b> <i class="emphasis">c</i> and <i class="emphasis">b</i>
</pre>
</div>
<a name="1093"></a><a name="IDX-354"></a>
<p class="para">
<a class="internaljump" href="#ch15fig06">Figure 15.6</a> shows the tables produced by LCS-LENGTH on the sequences <i class="emphasis">X</i> = <span class="unicode">&#12296;</span><i class="emphasis">A</i>, <i class="emphasis">B</i>, <i class="emphasis">C</i>, <i class="emphasis">B</i>, <i class="emphasis">D</i>, <i class="emphasis">A</i>, <i class="emphasis">B</i><span class="unicode">&#12297;</span> and <i class="emphasis">Y</i> = <span class="unicode">&#12296;</span><i class="emphasis">B</i>, <i class="emphasis">D</i>, <i class="emphasis">C</i>, <i class="emphasis">A</i>, <i class="emphasis">B</i>, <i class="emphasis">A</i><span class="unicode">&#12297;</span>. The running time of the procedure is <i class="emphasis">O</i>(<i class="emphasis">mn</i>), since each table entry takes <i class="emphasis">O</i>(1) time to compute.</p>
<div class="figure">
<a name="1094"></a><a name="ch15fig06"></a><span class="figuremediaobject"><img src="images/fig376_01.jpg" height="361" width="324" alt="" border="0"></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 15.6: </span>The <i class="emphasis">c</i> and <i class="emphasis">b</i> tables computed by LCS-LENGTH on the sequences <i class="emphasis">X</i> = <i class="emphasis"><span class="unicode">&#12296;</span>A, B, C, B, D, A, B<span class="unicode">&#12297;</span></i> and <i class="emphasis">Y</i> = <i class="emphasis"><span class="unicode">&#12296;</span>B, D, C, A, B, A<span class="unicode">&#12297;</span></i>. The square in row <i class="emphasis">i</i> and column <i class="emphasis">j</i> contains the value of <i class="emphasis">c</i>[<i class="emphasis">i, j</i>] and the appropriate arrow for the value of <i class="emphasis">b</i>[<i class="emphasis">i, j</i>]. The entry 4 in <i class="emphasis">c</i>[7, 6]<span class="unicode">-</span>the lower right-hand corner of the table<span class="unicode">-</span>is the length of an LCS <i class="emphasis"><span class="unicode">&#12296;</span>B, C, B, A<span class="unicode">&#12297;</span></i> of <i class="emphasis">X</i> and <i class="emphasis">Y</i> . For <i class="emphasis">i, j</i> <span class="unicode">&gt;</span> 0, entry <i class="emphasis">c</i>[<i class="emphasis">i, j</i>] depends only on whether <i class="emphasis">x<sub>i</sub></i> = <i class="emphasis">y<sub>j</sub></i> and the values in entries <i class="emphasis">c</i>[<i class="emphasis">i</i> - 1, <i class="emphasis">j</i>], <i class="emphasis">c</i>[<i class="emphasis">i, j</i> - 1], and <i class="emphasis">c</i>[<i class="emphasis">i</i> - 1, <i class="emphasis">j</i> - 1], which are computed before <i class="emphasis">c</i>[<i class="emphasis">i, j</i>]. To reconstruct the elements of an LCS, follow the <i class="emphasis">b</i>[<i class="emphasis">i, j</i>] arrows from the lower right-hand corner; the path is shaded. Each "<span class="unicode">&#8598;</span>" on the path corresponds to an entry (highlighted) for which <i class="emphasis">x<sub>i</sub></i> = <i class="emphasis">y<sub>j</sub></i> is a member of an LCS.</span>
</div>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1095"></a><a name="ch15lev3sec17"></a><span class="section-titlelabel">Step 4: </span>Constructing an LCS</h4>
<p class="first-para">The <i class="emphasis">b</i> table returned by LCS-LENGTH can be used to quickly construct an LCS of <i class="emphasis">X</i> = <span class="unicode">&#12296;</span><i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, ..., <i class="emphasis">x<sub>m</sub></i><span class="unicode">&#12297;</span> and <i class="emphasis">Y</i> = <span class="unicode">&#12296;</span><i class="emphasis">y</i><sub>1</sub>, <i class="emphasis">y</i><sub>2</sub>, ..., <i class="emphasis">y<sub>n</sub></i><span class="unicode">&#12297;</span>. We simply begin at <i class="emphasis">b</i>[<i class="emphasis">m</i>, <i class="emphasis">n</i>] and trace through the table following the arrows. Whenever we encounter a "<span class="unicode">&#8598;</span>" in entry <i class="emphasis">b</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>], it implies that <i class="emphasis">x<sub>i</sub></i> = <i class="emphasis">y<sub>j</sub></i> is an element of the LCS. The elements of the LCS are encountered in reverse order by this method. The following recursive procedure prints out an LCS of <i class="emphasis">X</i> and <i class="emphasis">Y</i> in the proper, forward order. The initial invocation is PRINT-LCS(<i class="emphasis">b</i>, <i class="emphasis">X</i>, <i class="emphasis">length</i>[<i class="emphasis">X</i>], <i class="emphasis">length</i>[<i class="emphasis">Y</i>]).<a name="1096"></a><a name="IDX-355"></a>
</p>
<div class="informalexample">
<pre class="literallayout-normal">
PRINT-LCS(<i class="emphasis">b</i>, <i class="emphasis">X</i>, <i class="emphasis">i</i>, <i class="emphasis">j</i>)
1 <b class="bold">if</b> <i class="emphasis">i</i> = 0 or <i class="emphasis">j</i> = 0
2     <b class="bold">then return</b>
3 <b class="bold">if</b> <i class="emphasis">b</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] = "<span class="unicode">&#8598;</span>"
4     <b class="bold">then</b> PRINT-LCS(<i class="emphasis">b</i>, <i class="emphasis">X</i>, <i class="emphasis">i</i> - 1, <i class="emphasis">j</i> - 1)
5          print <i class="emphasis">x<sub>i</sub></i>
6 <b class="bold">elseif</b> <i class="emphasis">b</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] = "<span class="unicode">&uarr;</span>"
7    <b class="bold">then</b> PRINT-LCS(<i class="emphasis">b</i>, <i class="emphasis">X</i>, <i class="emphasis">i</i> - 1, <i class="emphasis">j</i>)
8 <b class="bold">else</b> PRINT-LCS(<i class="emphasis">b</i>, <i class="emphasis">X</i>, <i class="emphasis">i</i>, <i class="emphasis">j</i> - 1)
</pre>
</div>
<p class="last-para">For the <i class="emphasis">b</i> table in <a class="internaljump" href="#ch15fig06">Figure 15.6</a>, this procedure prints "<i class="emphasis">BCBA</i>." The procedure takes time <i class="emphasis">O</i>(<i class="emphasis">m</i> + <i class="emphasis">n</i>), since at least one of <i class="emphasis">i</i> and <i class="emphasis">j</i> is decremented in each stage of the recursion.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1097"></a><a name="ch15lev3sec18"></a>Improving the code</h4>
<p class="first-para">Once you have developed an algorithm, you will often find that you can improve on the time or space it uses. This is especially true of straightforward dynamic-programming algorithms. Some changes can simplify the code and improve constant factors but otherwise yield no asymptotic improvement in performance. Others can yield substantial asymptotic savings in time and space.</p>
<p class="para">For example, we can eliminate the <i class="emphasis">b</i> table altogether. Each <i class="emphasis">c</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] entry depends on only three other <i class="emphasis">c</i> table entries: <i class="emphasis">c</i>[<i class="emphasis">i</i> - 1, <i class="emphasis">j</i> - 1], <i class="emphasis">c</i>[<i class="emphasis">i</i> - 1, <i class="emphasis">j</i>], and <i class="emphasis">c</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i> - 1]. Given the value of <i class="emphasis">c</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>], we can determine in <i class="emphasis">O</i>(1) time which of these three values was used to compute <i class="emphasis">c</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>], without inspecting table <i class="emphasis">b</i>. Thus, we can reconstruct an LCS in <i class="emphasis">O</i>(<i class="emphasis">m</i> + <i class="emphasis">n</i>) time using a procedure similar to PRINT-LCS. (<a class="internaljump" href="#ch15ex18">Exercise 15.4-2</a> asks you to give the pseudocode.) Although we save <span class="unicode">&Theta;</span>(<i class="emphasis">mn</i>) space by this method, the auxiliary space requirement for computing an LCS does not asymptotically decrease, since we need <span class="unicode">&Theta;</span>(<i class="emphasis">mn</i>) space for the <i class="emphasis">c</i> table anyway.</p>
<p class="para">We can, however, reduce the asymptotic space requirements for LCS-LENGTH, since it needs only two rows of table <i class="emphasis">c</i> at a time: the row being computed and the previous row. (In fact, we can use only slightly more than the space for one row of <i class="emphasis">c</i> to compute the length of an LCS. See <a class="internaljump" href="#ch15ex20">Exercise 15.4-4</a>.) This improvement works if we need only the length of an LCS; if we need to reconstruct the elements of an LCS, the smaller table does not keep enough information to retrace our steps in <i class="emphasis">O</i>(<i class="emphasis">m</i> + <i class="emphasis">n</i>) time.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 15.4-1</span></span><a name="1098"></a><a name="ch15ex17"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Determine an LCS of <span class="unicode">&#12296;</span>1, 0, 0, 1, 0, 1, 0, 1<span class="unicode">&#12297;</span> and <span class="unicode">&#12296;</span>0, 1, 0, 1, 1, 0, 1, 1, 0<span class="unicode">&#12297;</span>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1099"></a><a name="IDX-356"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 15.4-2</span></span><a name="1100"></a><a name="ch15ex18"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show how to reconstruct an LCS from the completed <i class="emphasis">c</i> table and the original sequences <i class="emphasis">X</i> = <span class="unicode">&#12296;</span><i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, ..., <i class="emphasis">x<sub>m</sub></i><span class="unicode">&#12297;</span> and <i class="emphasis">Y</i> = <span class="unicode">&#12296;</span><i class="emphasis">y</i><sub>1</sub>, <i class="emphasis">y</i><sub>2</sub>, ..., <i class="emphasis">y<sub>n</sub></i><span class="unicode">&#12297;</span> in <i class="emphasis">O</i>(<i class="emphasis">m</i> +<i class="emphasis">n</i>) time, without using the <i class="emphasis">b</i> table.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 15.4-3</span></span><a name="1101"></a><a name="ch15ex19"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Give a memoized version of LCS-LENGTH that runs in <i class="emphasis">O</i>(<i class="emphasis">mn</i>) time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 15.4-4</span></span><a name="1102"></a><a name="ch15ex20"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show how to compute the length of an LCS using only 2 <span class="unicode">&middot;</span> min(<i class="emphasis">m</i>, <i class="emphasis">n</i>) entries in the <i class="emphasis">c</i> table plus <i class="emphasis">O</i>(1) additional space. Then show how to do this using min(<i class="emphasis">m</i>, <i class="emphasis">n</i>) entries plus <i class="emphasis">O</i>(1) additional space.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 15.4-5</span></span><a name="1103"></a><a name="ch15ex21"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Give an <i class="emphasis">O</i>(<i class="emphasis">n</i><sup>2</sup>)-time algorithm to find the longest monotonically increasing subsequence of a sequence of <i class="emphasis">n</i> numbers.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 15.4-6: </span><span class="unicode">&#8902;</span></span><a name="1104"></a><a name="ch15ex22"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Give an <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>)-time algorithm to find the longest monotonically increasing sub-sequence of a sequence of <i class="emphasis">n</i> numbers. (<i class="emphasis">Hint:</i> Observe that the last element of a candidate subsequence of length <i class="emphasis">i</i> is at least as large as the last element of a candidate subsequence of length <i class="emphasis">i</i> - 1. Maintain candidate subsequences by linking them through the input sequence.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0089.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0091.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
