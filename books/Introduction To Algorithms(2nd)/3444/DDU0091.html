<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>15.5 Optimal binary search trees</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0090.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0092.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch15"></a>
<div class="section">
<h2 class="first-section-title">
<a name="1105"></a><a name="ch15lev1sec5"></a><span class="section-titlelabel">15.5 </span>Optimal binary search trees</h2>
<p class="first-para">Suppose that we are designing a program to translate text from English to French. For each occurrence of each English word in the text, we need to look up its French equivalent. One way to perform these lookup operations is to build a binary search tree with <i class="emphasis">n</i> English words as keys and French equivalents as satellite data. Because we will search the tree for each individual word in the text, we want the total time spent searching to be as low as possible. We could ensure an <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) search time per occurrence by using a red-black tree or any other balanced binary search tree. Words appear with different frequencies, however, and it may be the case that a frequently used word such as "the" appears far from the root while a rarely used word such as "mycophagist" appears near the root. Such an organization would slow down the translation, since the number of nodes visited when searching for a key in a binary search tree is one plus the depth of the node containing the key. We <a name="1106"></a><a name="IDX-357"></a>want words that occur frequently in the text to be placed nearer the root.<sup>[<a name="N38" href="#ftn.N38">5</a>]</sup> Moreover, there may be words in the text for which there is no French translation, and such words might not appear in the binary search tree at all. How do we organize a binary search tree so as to minimize the number of nodes visited in all searches, given that we know how often each word occurs?</p>
<p class="para">What we need is known as an <b class="bold"><i class="emphasis">optimal binary search tree</i></b>. Formally, we are given a sequence <i class="emphasis">K</i> = <span class="unicode">&#12296;</span><i class="emphasis">k<sub>1</sub></i>, <i class="emphasis">k</i><sub>2</sub>, ..., <i class="emphasis">k<sub>n</sub></i><span class="unicode">&#12297;</span> of <i class="emphasis">n</i> distinct keys in sorted order (so that <i class="emphasis">k</i><sub>1</sub> <span class="unicode">&lt;</span> <i class="emphasis">k</i><sub>2</sub> <span class="unicode">&lt;</span> <span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&middot;</span> <span class="unicode">&lt;</span> <i class="emphasis">k<sub>n</sub></i>), and we wish to build a binary search tree from these keys. For each key <i class="emphasis">k<sub>i</sub></i>, we have a probability <i class="emphasis">p<sub>i</sub></i> that a search will be for <i class="emphasis">k<sub>i</sub></i>. Some searches may be for values not in <i class="emphasis">K</i>, and so we also have <i class="emphasis">n</i> + 1 "dummy keys" <i class="emphasis">d</i><sub>0</sub>, <i class="emphasis">d</i><sub>1</sub>, <i class="emphasis">d</i><sub>2</sub>, ..., <i class="emphasis">d<sub>n</sub></i> representing values not in <i class="emphasis">K</i>. In particular, <i class="emphasis">d<sub>0</sub></i> represents all values less than <i class="emphasis">k</i><sub>1</sub>, <i class="emphasis">d<sub>n</sub></i> represents all values greater than <i class="emphasis">k<sub>n</sub></i>, and for <i class="emphasis">i</i> = 1, 2, ..., <i class="emphasis">n</i> -1, the dummy key <i class="emphasis">d<sub>i</sub></i> represents all values between <i class="emphasis">k<sub>i</sub></i> and <i class="emphasis">k</i><sub><i class="emphasis">i</i>+1</sub>. For each dummy key <i class="emphasis">d<sub>i</sub></i>, we have a probability <i class="emphasis">q<sub>i</sub></i> that a search will correspond to <i class="emphasis">d<sub>i</sub></i>. <a class="internaljump" href="#ch15fig07">Figure 15.7</a> shows two binary search trees for a set of <i class="emphasis">n</i> = 5 keys. Each key <i class="emphasis">k<sub>i</sub></i> is an internal node, and each dummy key <i class="emphasis">d<sub>i</sub></i> is a leaf. Every search is either successful (finding some key <i class="emphasis">k<sub>i</sub></i>) or unsuccessful (finding some dummy key <i class="emphasis">d<sub>i</sub></i>), and so we have</p>
<div class="figure">
<a name="1107"></a><a name="ch15fig07"></a><span class="figuremediaobject"><a href="images/fig379%5F01%5F0%2Ejpg" NAME="IMG_476" target="_parent"><img src="images/fig379_01.jpg" height="162" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 15.7: </span>Two Binary Search Trees for a Set of <i class="emphasis">n</i> = 5 Keys with the Following Probabilities:</span>
</div>
<div class="informaltable">
<table border="0">
<thead>
<tr valign="top">
<th class="th" scope="col" align="left">
<p class="table-para">
<i class="emphasis">i</i>
</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">0</p>
</th><th class="th" scope="col" align="char">
<p class="table-para">1</p>
</th><th class="th" scope="col" align="char">
<p class="table-para">2</p>
</th><th class="th" scope="col" align="char">
<p class="table-para">3</p>
</th><th class="th" scope="col" align="char">
<p class="table-para">4</p>
</th><th class="th" scope="col" align="char">
<p class="table-para">5</p>
</th>
</tr>
<tr>
<td colspan="7">
<hr>
</td>
</tr>
</thead>
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">p<sub>i</sub></i>
</p>
</td><td class="td" align="center">&nbsp;</td><td class="td" align="char">
<p class="table-para">0.15</p>
</td><td class="td" align="char">
<p class="table-para">0.10</p>
</td><td class="td" align="char">
<p class="table-para">0.05</p>
</td><td class="td" align="char">
<p class="table-para">0.10</p>
</td><td class="td" align="char">
<p class="table-para">0.20</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">q<sub>i</sub></i>
</p>
</td><td class="td" align="center">
<p class="table-para">0.05</p>
</td><td class="td" align="char">
<p class="table-para">0.10</p>
</td><td class="td" align="char">
<p class="table-para">0.05</p>
</td><td class="td" align="char">
<p class="table-para">0.05</p>
</td><td class="td" align="char">
<p class="table-para">0.05</p>
</td><td class="td" align="char">
<p class="table-para">0.10</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="informalexample">
<p class="first-para">
<b class="bold">(a)</b> A binary search tree with expected search cost 2.80. <b class="bold">(b)</b> A binary search tree with expected search cost 2.75. This tree is optimal.</p>
</div>
<a name="1108"></a><a name="IDX-358"></a>
<div class="equation">
<a name="1109"></a><a name="ch15eq15"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(15.15)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig380_01.jpg" height="41" width="123" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">Because we have probabilities of searches for each key and each dummy key, we can determine the expected cost of a search in a given binary search tree <i class="emphasis">T</i>. Let us assume that the actual cost of a search is the number of nodes examined, i.e., the depth of the node found by the search in <i class="emphasis">T</i>, plus 1. Then the expected cost of a search in <i class="emphasis">T</i> is</p>
<div class="equation">
<a name="1110"></a><a name="ch15eq16"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(15.16)&nbsp;</span></td><td valign="top"><span class="equation-image"><a href="images/fig380%5F02%2Ejpg" NAME="IMG_478" target="_parent"><img src="images/fig380_02.jpg" height="78" width="400" alt="Click To expand" border="0"></a></span></td>
</tr>
</table>
</div>
<p class="para">where depth<sub><i class="emphasis">T</i></sub> denotes a node's depth in the tree <i class="emphasis">T</i>. The last equality follows from <a class="internaljump" href="#ch15eq15">equation (15.15)</a>. In <a class="internaljump" href="#ch15fig07">Figure 15.7(a)</a>, we can calculate the expected search cost node by node:</p>
<div class="informaltable">
<table border="0">
<thead>
<tr valign="top">
<th class="th" scope="col" align="center">
<p class="table-para">node</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">depth</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">probability</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">contribution</p>
</th>
</tr>
<tr>
<td colspan="4">
<hr>
</td>
</tr>
</thead>
<tbody>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">
<i class="emphasis">k</i><sub>1</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">1</p>
</td><td class="td" align="center">
<p class="table-para">0.15</p>
</td><td class="td" align="center">
<p class="table-para">0.30</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">
<i class="emphasis">k</i><sub>2</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">0</p>
</td><td class="td" align="center">
<p class="table-para">0.10</p>
</td><td class="td" align="center">
<p class="table-para">0.10</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">
<i class="emphasis">k</i><sub>3</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">2</p>
</td><td class="td" align="center">
<p class="table-para">0.05</p>
</td><td class="td" align="center">
<p class="table-para">0.15</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">
<i class="emphasis">k</i><sub>4</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">1</p>
</td><td class="td" align="center">
<p class="table-para">0.10</p>
</td><td class="td" align="center">
<p class="table-para">0.20</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">
<i class="emphasis">k</i><sub>5</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">2</p>
</td><td class="td" align="center">
<p class="table-para">0.20</p>
</td><td class="td" align="center">
<p class="table-para">0.60</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">
<i class="emphasis">d</i><sub>0</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">2</p>
</td><td class="td" align="center">
<p class="table-para">0.05</p>
</td><td class="td" align="center">
<p class="table-para">0.15</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">
<i class="emphasis">d</i><sub>1</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">2</p>
</td><td class="td" align="center">
<p class="table-para">0.10</p>
</td><td class="td" align="center">
<p class="table-para">0.30</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">
<i class="emphasis">d</i><sub>2</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">3</p>
</td><td class="td" align="center">
<p class="table-para">0.05</p>
</td><td class="td" align="center">
<p class="table-para">0.20</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">
<i class="emphasis">d</i><sub>3</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">3</p>
</td><td class="td" align="center">
<p class="table-para">0.05</p>
</td><td class="td" align="center">
<p class="table-para">0.20</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">
<i class="emphasis">d</i><sub>4</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">3</p>
</td><td class="td" align="center">
<p class="table-para">0.05</p>
</td><td class="td" align="center">
<p class="table-para">0.20</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">
<i class="emphasis">d</i><sub>5</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">3</p>
</td><td class="td" align="center">
<p class="table-para">0.10</p>
</td><td class="td" align="center">
<p class="table-para">0.40</p>
</td>
</tr>
<tr>
<td colspan="4">
<hr>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">Total</p>
</td><td class="td" align="center">&nbsp;</td><td class="td" align="center">&nbsp;</td><td class="td" align="center">
<p class="table-para">2.80</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">For a given set of probabilities, our goal is to construct a binary search tree whose expected search cost is smallest. We call such a tree an <b class="bold"><i class="emphasis">optimal binary search tree</i></b>. <a class="internaljump" href="#ch15fig07">Figure 15.7(b)</a> shows an optimal binary search tree for the probabilities given in the figure caption; its expected cost is 2.75. This example shows that an optimal binary search tree is not necessarily a tree whose overall height is smallest. Nor can we necessarily construct an optimal binary search tree by always putting the key with the greatest probability at the root. Here, key <i class="emphasis">k</i><sub>5</sub> has the greatest search probability of any key, yet the root of the optimal binary search tree shown is <i class="emphasis">k</i><sub>2</sub>. (The lowest expected cost of any binary search tree with <i class="emphasis">k</i><sub>5</sub> at the root is 2.85.)</p>
<p class="para">As with matrix-chain multiplication, exhaustive checking of all possibilities fails to yield an efficient algorithm. We can label the nodes of any <i class="emphasis">n</i>-node binary tree with the keys <i class="emphasis">k</i><sub>1</sub>, <i class="emphasis">k</i><sub>2</sub>, ..., <i class="emphasis">k<sub>n</sub></i> to construct a binary search tree, and then add in the dummy keys as leaves. In <a href="DDU0074.html#858" target="_parent" class="chapterjump">Problem 12-4</a>, we saw that the number of binary trees <a name="1111"></a><a name="IDX-359"></a>with <i class="emphasis">n</i> nodes is <span class="unicode">&#8486;</span>(4<sup><i class="emphasis">n</i></sup>/<i class="emphasis">n</i><sup>3/2</sup>), and so there are an exponential number of binary search trees that we would have to examine in an exhaustive search. Not surprisingly, we will solve this problem with dynamic programming.</p>
<div class="section">
<h4 class="sect4-title">
<a name="1112"></a><a name="ch15lev3sec19"></a><span class="section-titlelabel">Step 1: </span>The structure of an optimal binary search tree</h4>
<p class="first-para">To characterize the optimal substructure of optimal binary search trees, we start with an observation about subtrees. Consider any subtree of a binary search tree. It must contain keys in a contiguous range <i class="emphasis">k<sub>i</sub></i>, ..., <i class="emphasis">k<sub>j</sub></i>, for some 1 <span class="unicode">&le;</span> <i class="emphasis">i</i> <span class="unicode">&le;</span> <i class="emphasis">j</i> <span class="unicode">&le;</span> <i class="emphasis">n</i>. In addition, a subtree that contains keys <i class="emphasis">k<sub>i</sub></i>, ..., <i class="emphasis">k<sub>j</sub></i> must also have as its leaves the dummy keys <i class="emphasis">d</i><sub><i class="emphasis">i</i>-1</sub>, ..., <i class="emphasis">d<sub>j</sub></i>.</p>
<p class="para">Now we can state the optimal substructure: if an optimal binary search tree <i class="emphasis">T</i> has a subtree <i class="emphasis">T</i><span class="unicode">&prime;</span> containing keys <i class="emphasis">k<sub>i</sub></i>, ..., <i class="emphasis">k<sub>j</sub></i>, then this subtree <i class="emphasis">T</i><span class="unicode">&prime;</span> must be optimal as well for the subproblem with keys <i class="emphasis">k<sub>i</sub></i>, ..., <i class="emphasis">k<sub>j</sub></i> and dummy keys <i class="emphasis">d</i><sub><i class="emphasis">i</i>-1</sub>, ..., <i class="emphasis">d<sub>j</sub></i>. The usual cut-and-paste argument applies. If there were a subtree <i class="emphasis">T</i>" whose expected cost is lower than that of <i class="emphasis">T</i><span class="unicode">&prime;</span>, then we could cut <i class="emphasis">T</i><span class="unicode">&prime;</span> out of <i class="emphasis">T</i> and paste in <i class="emphasis">T</i>", resulting in a binary search tree of lower expected cost than <i class="emphasis">T</i>, thus contradicting the optimality of <i class="emphasis">T</i>.</p>
<p class="para">We need to use the optimal substructure to show that we can construct an optimal solution to the problem from optimal solutions to subproblems. Given keys <i class="emphasis">k<sub>i</sub></i>, ..., <i class="emphasis">k<sub>j</sub></i>, one of these keys, say <i class="emphasis">k<sub>r</sub></i> (<i class="emphasis">i</i> <span class="unicode">&le;</span> <i class="emphasis">r</i> <span class="unicode">&le;</span> <i class="emphasis">j</i>), will be the root of an optimal subtree containing these keys. The left subtree of the root <i class="emphasis">k<sub>r</sub></i> will contain the keys <i class="emphasis">k<sub>i</sub></i>, ..., <i class="emphasis">k</i><sub><i class="emphasis">r</i>-1</sub> (and dummy keys <i class="emphasis">d</i><sub><i class="emphasis">i</i>-1</sub>, ..., <i class="emphasis">d</i><sub><i class="emphasis">r</i>-1</sub>), and the right subtree will contain the keys <i class="emphasis">k</i><sub><i class="emphasis">r</i>+1</sub>, ..., <i class="emphasis">k<sub>j</sub></i> (and dummy keys <i class="emphasis">d<sub>r</sub></i>, ..., <i class="emphasis">d<sub>j</sub></i>). As long as we examine all candidate roots <i class="emphasis">k<sub>r</sub></i>, where <i class="emphasis">i</i> <span class="unicode">&le;</span> <i class="emphasis">r</i> <span class="unicode">&le;</span> <i class="emphasis">j</i>, and we determine all optimal binary search trees containing <i class="emphasis">k<sub>i</sub></i>, ..., <i class="emphasis">k</i><sub><i class="emphasis">r</i>-1</sub> and those containing <i class="emphasis">k</i><sub><i class="emphasis">r</i>+1</sub>, ..., <i class="emphasis">k<sub>j</sub></i>, we are guaranteed that we will find an optimal binary search tree.</p>
<p class="last-para">There is one detail worth noting about "empty" subtrees. Suppose that in a subtree with keys <i class="emphasis">k<sub>i</sub></i>, ..., <i class="emphasis">k<sub>j</sub></i>, we select <i class="emphasis">k<sub>i</sub></i> as the root. By the above argument, <i class="emphasis">k<sub>i</sub></i>'s left subtree contains the keys <i class="emphasis">k<sub>i</sub></i>, ..., <i class="emphasis">k</i><sub><i class="emphasis">i</i>-1</sub>. It is natural to interpret this sequence as containing no keys. Bear in mind, however, that subtrees also contain dummy keys. We adopt the convention that a subtree containing keys <i class="emphasis">k<sub>i</sub></i>, ..., <i class="emphasis">k</i><sub><i class="emphasis">i</i>-1</sub> has no actual keys but does contain the single dummy key <i class="emphasis">d</i><sub><i class="emphasis">i</i>-1</sub>. Symmetrically, if we select <i class="emphasis">k<sub>j</sub></i> as the root, then <i class="emphasis">k<sub>j</sub></i>'s right subtree contains the keys <i class="emphasis">k</i><sub><i class="emphasis">j</i> +1</sub>, ..., <i class="emphasis">k<sub>j</sub></i>; this right subtree contains no actual keys, but it does contain the dummy key <i class="emphasis">d<sub>j</sub></i>.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1113"></a><a name="ch15lev3sec20"></a><span class="section-titlelabel">Step 2: </span>A recursive solution</h4>
<p class="first-para">We are ready to define the value of an optimal solution recursively. We pick our subproblem domain as finding an optimal binary search tree containing the keys <i class="emphasis">k<sub>i</sub></i>, ..., <i class="emphasis">k<sub>j</sub></i>, where <i class="emphasis">i</i> <span class="unicode">&ge;</span> 1, <i class="emphasis">j</i> <span class="unicode">&le;</span> <i class="emphasis">n</i>, and <i class="emphasis">j</i> <span class="unicode">&ge;</span> <i class="emphasis">i</i> - 1. (It is when <i class="emphasis">j</i> = <i class="emphasis">i</i> - 1 that there are no actual keys; we have just the dummy key <i class="emphasis">d</i><sub><i class="emphasis">i</i>-1</sub>.) Let us define <i class="emphasis">e</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] as <a name="1114"></a><a name="IDX-360"></a>the expected cost of searching an optimal binary search tree containing the keys <i class="emphasis">k<sub>i</sub></i>, ..., <i class="emphasis">k<sub>j</sub></i>. Ultimately, we wish to compute <i class="emphasis">e</i>[1, <i class="emphasis">n</i>].</p>
<p class="para">The easy case occurs when <i class="emphasis">j</i> = <i class="emphasis">i</i> - 1. Then we have just the dummy key <i class="emphasis">d</i><sub><i class="emphasis">i</i>-1</sub>. The expected search cost is <i class="emphasis">e</i>[<i class="emphasis">i</i>, <i class="emphasis">i</i> - 1] = <i class="emphasis">q</i><sub><i class="emphasis">i</i>-1</sub>.</p>
<p class="para">When <i class="emphasis">j</i> <span class="unicode">&ge;</span> <i class="emphasis">i</i>, we need to select a root <i class="emphasis">k<sub>r</sub></i> from among <i class="emphasis">k<sub>i</sub></i>, ..., <i class="emphasis">k<sub>j</sub></i> and then make an optimal binary search tree with keys <i class="emphasis">k<sub>i</sub></i>, ..., <i class="emphasis">k</i><sub><i class="emphasis">r</i>-1</sub> its left subtree and an optimal binary search tree with keys <i class="emphasis">k</i><sub><i class="emphasis">r</i>+1</sub>, ..., <i class="emphasis">k<sub>j</sub></i> its right subtree. What happens to the expected search cost of a subtree when it becomes a subtree of a node? The depth of each node in the subtree increases by 1. By <a class="internaljump" href="#ch15eq16">equation (15.16)</a>, the expected search cost of this subtree increases by the sum of all the probabilities in the subtree. For a subtree with keys <i class="emphasis">k<sub>i</sub></i>, ..., <i class="emphasis">k<sub>j</sub></i>, let us denote this sum of probabilities as</p>
<div class="equation">
<a name="1115"></a><a name="ch15eq17"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(15.17)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig382_01.jpg" height="43" width="165" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">Thus, if <i class="emphasis">k<sub>r</sub></i> is the root of an optimal subtree containing keys <i class="emphasis">k<sub>i</sub></i>, ..., <i class="emphasis">k<sub>j</sub></i>, we have</p>
<p class="para">
<i class="emphasis">e</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i> ] = <i class="emphasis">p<sub>r</sub></i> + (<i class="emphasis">e</i>[<i class="emphasis">i</i>, <i class="emphasis">r</i> - 1] + <i class="emphasis">w</i>(<i class="emphasis">i</i>, <i class="emphasis">r</i> - 1)) + (<i class="emphasis">e</i>[<i class="emphasis">r</i> + 1, <i class="emphasis">j</i>] + <i class="emphasis">w</i>(<i class="emphasis">r</i> + 1, <i class="emphasis">j</i>)).</p>
<p class="para">Noting that</p>
<p class="para">
<i class="emphasis">w</i>(<i class="emphasis">i</i>, <i class="emphasis">j</i>) = <i class="emphasis">w</i>(<i class="emphasis">i</i>, <i class="emphasis">r</i> - 1) + <i class="emphasis">p<sub>r</sub></i> + <i class="emphasis">w</i>(<i class="emphasis">r</i> + 1, <i class="emphasis">j</i>),</p>
<p class="para">we rewrite <i class="emphasis">e</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] as</p>
<div class="equation">
<a name="1116"></a><a name="ch15eq18"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(15.18)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig382_02.jpg" height="18" width="265" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">The recursive <a class="internaljump" href="#ch15eq18">equation (15.18)</a> assumes that we know which node <i class="emphasis">k<sub>r</sub></i> to use as the root. We choose the root that gives the lowest expected search cost, giving us our final recursive formulation:</p>
<div class="equation">
<a name="1117"></a><a name="ch15eq19"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(15.19)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig382_03.jpg" height="46" width="398" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="last-para">The <i class="emphasis">e</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] values give the expected search costs in optimal binary search trees. To help us keep track of the structure of optimal binary search trees, we define <i class="emphasis">root</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>], for 1 <span class="unicode">&le;</span> <i class="emphasis">i</i> <span class="unicode">&le;</span> <i class="emphasis">j</i> <span class="unicode">&le;</span> <i class="emphasis">n</i>, to be the index <i class="emphasis">r</i> for which <i class="emphasis">k<sub>r</sub></i> is the root of an optimal binary search tree containing keys <i class="emphasis">k<sub>i</sub></i>, ..., <i class="emphasis">k<sub>j</sub></i>. Although we will see how to compute the values of <i class="emphasis">root</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>], we leave the construction of the optimal binary search tree from these values as <a class="internaljump" href="#ch15ex23">Exercise 15.5-1</a>.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1118"></a><a name="ch15lev3sec21"></a><span class="section-titlelabel">Step 3: </span>Computing the expected search cost of an optimal binary search tree</h4>
<p class="first-para">At this point, you may have noticed some similarities between our characterizations of optimal binary search trees and matrix-chain multiplication. For both problem <a name="1119"></a><a name="IDX-361"></a>domains, our subproblems consist of contiguous index subranges. A direct, recursive implementation of <a class="internaljump" href="#ch15eq19">equation (15.19)</a> would be as inefficient as a direct, recursive matrix-chain multiplication algorithm. Instead, we store the <i class="emphasis">e</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] values in a table <i class="emphasis">e</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i> + 1, 0 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>]. The first index needs to run to <i class="emphasis">n</i> + 1 rather than <i class="emphasis">n</i> because in order to have a subtree containing only the dummy key <i class="emphasis">d<sub>n</sub></i>, we will need to compute and store <i class="emphasis">e</i>[<i class="emphasis">n</i> + 1, <i class="emphasis">n</i>]. The second index needs to start from 0 because in order to have a subtree containing only the dummy key <i class="emphasis">d</i><sub>0</sub>, we will need to compute and store <i class="emphasis">e</i>[1, 0]. We will use only the entries <i class="emphasis">e</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] for which <i class="emphasis">j</i> <span class="unicode">&ge;</span> <i class="emphasis">i</i> - 1. We also use a table <i class="emphasis">root</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>], for recording the root of the subtree containing keys <i class="emphasis">k<sub>i</sub></i>, ..., <i class="emphasis">k<sub>j</sub></i>. This table uses only the entries for which 1 <span class="unicode">&le;</span> <i class="emphasis">i</i> <span class="unicode">&le;</span> <i class="emphasis">j</i> <span class="unicode">&le;</span> <i class="emphasis">n</i>.</p>
<p class="para">We will need one other table for efficiency. Rather than compute the value of <i class="emphasis">w</i>(<i class="emphasis">i</i>, <i class="emphasis">j</i>) from scratch every time we are computing <i class="emphasis">e</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>]<span class="unicode">-</span>which would take <span class="unicode">&Theta;</span>(<i class="emphasis">j</i> - <i class="emphasis">i</i>) additions<span class="unicode">-</span>we store these values in a table <i class="emphasis">w</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i> + 1, 0 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>]. For the base case, we compute <i class="emphasis">w</i>[<i class="emphasis">i</i>, <i class="emphasis">i</i> - 1] = <i class="emphasis">q</i><sub><i class="emphasis">i</i>-1</sub> for 1 <span class="unicode">&le;</span> <i class="emphasis">i</i> <span class="unicode">&le;</span> <i class="emphasis">n</i>. For <i class="emphasis">j</i> <span class="unicode">&ge;</span> <i class="emphasis">i</i>, we compute</p>
<div class="equation">
<a name="1120"></a><a name="ch15eq20"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(15.20)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig383_01.jpg" height="25" width="298" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">Thus, we can compute the <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>2</sup>) values of <i class="emphasis">w</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] in <span class="unicode">&Theta;</span>(1) time each.</p>
<p class="para">The pseudocode that follows takes as inputs the probabilities <i class="emphasis">p</i><sub>1</sub>, ..., <i class="emphasis">p<sub>n</sub></i> and <i class="emphasis">q</i><sub>0</sub>, ..., <i class="emphasis">q<sub>n</sub></i> and the size <i class="emphasis">n</i>, and it returns the tables <i class="emphasis">e</i> and <i class="emphasis">root</i>.</p>
<div class="informalexample">
<pre class="literallayout-normal">
OPTIMAL-BST(<i class="emphasis">p</i>, <i class="emphasis">q</i>, <i class="emphasis">n</i>)
 1  <b class="bold">for</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">n</i> + 1
 2       <b class="bold">do</b> <i class="emphasis">e</i>[<i class="emphasis">i</i>, <i class="emphasis">i</i> - 1] <span class="unicode">&larr;</span> <i class="emphasis">q</i><sub><i class="emphasis">i</i>-1</sub>
 3          <i class="emphasis">w</i>[<i class="emphasis">i</i>, <i class="emphasis">i</i> - 1] <span class="unicode">&larr;</span> <i class="emphasis">q</i><sub><i class="emphasis">i</i>-1</sub>
 4  <b class="bold">for</b> <i class="emphasis">l</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">n</i>
 5       <b class="bold">do for</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">n</i> - <i class="emphasis">l</i> + 1
 6               <b class="bold">do</b> <i class="emphasis">j</i> <span class="unicode">&larr;</span> <i class="emphasis">i</i> + <i class="emphasis">l</i> - 1
 7                  <i class="emphasis">e</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] <span class="unicode">&larr;</span> <span class="unicode">&infin;</span>
 8                  <i class="emphasis">w</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] <span class="unicode">&larr;</span> <i class="emphasis">w</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i> - 1] + <i class="emphasis">p<sub>j</sub></i> + <i class="emphasis">q<sub>j</sub></i>
 9                  <b class="bold">for</b> <i class="emphasis">r</i> <span class="unicode">&larr;</span> <i class="emphasis">i</i> <b class="bold">to</b> <i class="emphasis">j</i>
10                       <b class="bold">do</b> <i class="emphasis">t</i> <span class="unicode">&larr;</span> <i class="emphasis">e</i>[<i class="emphasis">i</i>, <i class="emphasis">r</i> - 1] + <i class="emphasis">e</i>[<i class="emphasis">r</i> + 1, <i class="emphasis">j</i>] + <i class="emphasis">w</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>]
11                          <b class="bold">if</b> <i class="emphasis">t</i> <span class="unicode">&lt;</span> <i class="emphasis">e</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>]
12                             <b class="bold">then</b> <i class="emphasis">e</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] <span class="unicode">&larr;</span> <i class="emphasis">t</i>
13                                  <i class="emphasis">root</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] <span class="unicode">&larr;</span> <i class="emphasis">r</i>
14  return <i class="emphasis">e</i> and <i class="emphasis">root</i>
</pre>
</div>
<p class="para">From the description above and the similarity to the MATRIX-CHAIN-ORDER procedure in <a href="DDU0088.html#1039" target="_parent" class="chapterjump">Section 15.2</a>, the operation of this procedure should be fairly straightforward. The <b class="bold">for</b> loop of lines 1<span class="unicode">-</span>3 initializes the values of <i class="emphasis">e</i>[<i class="emphasis">i</i>, <i class="emphasis">i</i> - 1] and <i class="emphasis">w</i>[<i class="emphasis">i</i>, <i class="emphasis">i</i> - 1]. The <b class="bold">for</b> loop of lines 4<span class="unicode">-</span>13 then uses the recurrences (<a class="internaljump" href="#ch15eq19">15.19</a>) and (<a class="internaljump" href="#ch15eq20">15.20</a>) to compute <i class="emphasis">e</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] and <i class="emphasis">w</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] for all 1 <span class="unicode">&le;</span> <i class="emphasis">i</i> <span class="unicode">&le;</span> <i class="emphasis">j</i> <span class="unicode">&le;</span> <i class="emphasis">n</i>. In the first iteration, when <i class="emphasis">l</i> = 1, the loop computes <i class="emphasis">e</i>[<i class="emphasis">i</i>, <i class="emphasis">i</i>] and <i class="emphasis">w</i>[<i class="emphasis">i</i>, <i class="emphasis">i</i>] for <i class="emphasis">i</i> = 1, 2, ..., <i class="emphasis">n</i>. The second iteration, with <a name="1121"></a><a name="IDX-362"></a><i class="emphasis">l</i> = 2, computes <i class="emphasis">e</i>[<i class="emphasis">i</i>, <i class="emphasis">i</i> + 1] and <i class="emphasis">w</i>[<i class="emphasis">i</i>, <i class="emphasis">i</i> +1] for <i class="emphasis">i</i> = 1, 2, ..., <i class="emphasis">n</i> - 1, and so forth. The innermost <b class="bold">for</b> loop, in lines 9<span class="unicode">-</span>13, tries each candidate index <i class="emphasis">r</i> to determine which key <i class="emphasis">k<sub>r</sub></i> to use as the root of an optimal binary search tree containing keys <i class="emphasis">k<sub>i</sub></i>, ..., <i class="emphasis">k<sub>j</sub></i>. This <b class="bold">for</b> loop saves the current value of the index <i class="emphasis">r</i> in <i class="emphasis">root</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] whenever it finds a better key to use as the root.</p>
<p class="para">
<a class="internaljump" href="#ch15fig08">Figure 15.8</a> shows the tables <i class="emphasis">e</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>], <i class="emphasis">w</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>], and <i class="emphasis">root</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] computed by the procedure OPTIMAL-BST on the key distribution shown in <a class="internaljump" href="#ch15fig07">Figure 15.7</a>. As in the matrix-chain multiplication example, the tables are rotated to make the diagonals run horizontally. OPTIMAL-BST computes the rows from bottom to top and from left to right within each row.</p>
<div class="figure">
<a name="1122"></a><a name="ch15fig08"></a><span class="figuremediaobject"><a href="images/fig384%5F01%5F0%2Ejpg" NAME="IMG_483" target="_parent"><img src="images/fig384_01.jpg" height="223" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 15.8: </span>The tables <i class="emphasis">e</i>[<i class="emphasis">i, j</i>], w[<i class="emphasis">i, j</i>], and <i class="emphasis">root</i>[<i class="emphasis">i, j</i>] computed by OPTIMAL-BST on the key distribution shown in Figure 15.7. The tables are rotated so that the diagonals run horizontally.</span>
</div>
<p class="para">The OPTIMAL-BST procedure takes <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>3</sup>) time, just like MATRIX-CHAIN-ORDER. It is easy to see that the running time is <i class="emphasis">O</i>(<i class="emphasis">n</i><sup>3</sup>), since its <b class="bold">for</b> loops are nested three deep and each loop index takes on at most <i class="emphasis">n</i> values. The loop indices in OPTIMAL-BST do not have exactly the same bounds as those in MATRIX-CHAIN-ORDER, but they are within at most 1 in all directions. Thus, like MATRIX-CHAIN-ORDER, the OPTIMAL-BST procedure takes <span class="unicode">&#8486;</span>(<i class="emphasis">n</i><sup>3</sup>) time.<a name="1123"></a><a name="IDX-363"></a>
</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 15.5-1</span></span><a name="1124"></a><a name="ch15ex23"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Write pseudocode for the procedure CONSTRUCT-OPTIMAL-BST(<i class="emphasis">root</i>) which, given the table <i class="emphasis">root</i>, outputs the structure of an optimal binary search tree. For the example in <a class="internaljump" href="#ch15fig08">Figure 15.8</a>, your procedure should print out the structure</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">
<i class="emphasis">k</i><sub>2</sub> is the root</p>
</li>
<li class="listitem">
<p class="first-para">
<i class="emphasis">k</i><sub>1</sub> is the left child of <i class="emphasis">k</i><sub>2</sub>
</p>
</li>
<li class="listitem">
<p class="first-para">
<i class="emphasis">d</i><sub>0</sub> is the left child of <i class="emphasis">k</i><sub>1</sub>
</p>
</li>
<li class="listitem">
<p class="first-para">
<i class="emphasis">d</i><sub>1</sub> is the right child of <i class="emphasis">k</i><sub>1</sub>
</p>
</li>
<li class="listitem">
<p class="first-para">
<i class="emphasis">k</i><sub>5</sub> is the right child of <i class="emphasis">k</i><sub>2</sub>
</p>
</li>
<li class="listitem">
<p class="first-para">
<i class="emphasis">k</i><sub>4</sub> is the left child of <i class="emphasis">k</i><sub>5</sub>
</p>
</li>
<li class="listitem">
<p class="first-para">
<i class="emphasis">k</i><sub>3</sub> is the left child of <i class="emphasis">k</i><sub>4</sub>
</p>
</li>
<li class="listitem">
<p class="first-para">
<i class="emphasis">d</i><sub>2</sub> is the left child of <i class="emphasis">k</i><sub>3</sub>
</p>
</li>
<li class="listitem">
<p class="first-para">
<i class="emphasis">d</i><sub>3</sub> is the right child of <i class="emphasis">k</i><sub>3</sub>
</p>
</li>
<li class="listitem">
<p class="first-para">
<i class="emphasis">d</i><sub>4</sub> is the right child of <i class="emphasis">k</i><sub>4</sub>
</p>
</li>
<li class="listitem">
<p class="first-para">
<i class="emphasis">d</i><sub>5</sub> is the right child of <i class="emphasis">k</i><sub>5</sub>
</p>
</li>
</ul>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">corresponding to the optimal binary search tree shown in <a class="internaljump" href="#ch15fig07">Figure 15.7(b)</a>.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 15.5-2</span></span><a name="1125"></a><a name="ch15ex24"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Determine the cost and structure of an optimal binary search tree for a set of <i class="emphasis">n</i> = 7 keys with the following probabilities:</p>
<div class="informaltable">
<table border="0">
<thead>
<tr valign="top">
<th class="th" scope="col" align="center">
<p class="table-para">
<i class="emphasis">i</i>
</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">0</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">1</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">2</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">3</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">4</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">5</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">6</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">7</p>
</th>
</tr>
<tr>
<td colspan="9">
<hr>
</td>
</tr>
</thead>
<tbody>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">
<i class="emphasis">p<sub>i</sub></i>
</p>
</td><td class="td" align="center">&nbsp;</td><td class="td" align="center">
<p class="table-para">0.04</p>
</td><td class="td" align="center">
<p class="table-para">0.06</p>
</td><td class="td" align="center">
<p class="table-para">0.08</p>
</td><td class="td" align="center">
<p class="table-para">0.02</p>
</td><td class="td" align="center">
<p class="table-para">0.10</p>
</td><td class="td" align="center">
<p class="table-para">0.12</p>
</td><td class="td" align="center">
<p class="table-para">0.14</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">
<i class="emphasis">q<sub>i</sub></i>
</p>
</td><td class="td" align="center">
<p class="table-para">0.06</p>
</td><td class="td" align="center">
<p class="table-para">0.06</p>
</td><td class="td" align="center">
<p class="table-para">0.06</p>
</td><td class="td" align="center">
<p class="table-para">0.06</p>
</td><td class="td" align="center">
<p class="table-para">0.05</p>
</td><td class="td" align="center">
<p class="table-para">0.05</p>
</td><td class="td" align="center">
<p class="table-para">0.05</p>
</td><td class="td" align="center">
<p class="table-para">0.05</p>
</td>
</tr>
</tbody>
</table>
</div>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 15.5-3</span></span><a name="1126"></a><a name="ch15ex25"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that instead of maintaining the table <i class="emphasis">w</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>], we computed the value of <i class="emphasis">w</i>(<i class="emphasis">i</i>, <i class="emphasis">j</i>) directly from <a class="internaljump" href="#ch15eq17">equation (15.17)</a> in line 8 of OPTIMAL-BST and used this computed value in line 10. How would this change affect the asymptotic running time of OPTIMAL-BST?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 15.5-4: </span><span class="unicode">&#8902;</span></span><a name="1127"></a><a name="ch15ex26"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">
<a href="DDU0259.html#3739" target="_parent" class="chapterjump">Knuth [184]</a> has shown that there are always roots of optimal subtrees such that <i class="emphasis">root</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i> - 1] <span class="unicode">&le;</span> <i class="emphasis">root</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] <span class="unicode">&le;</span> <i class="emphasis">root</i>[<i class="emphasis">i</i> + 1, <i class="emphasis">j</i>] for all 1 <span class="unicode">&le;</span> <i class="emphasis">i</i> <span class="unicode">&lt;</span> <i class="emphasis">j</i> <span class="unicode">&le;</span> <i class="emphasis">n</i>. Use this fact to modify the OPTIMAL-BST procedure to run in <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>2</sup>) time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1128"></a><a name="IDX-364"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 15-1: </span>Bitonic euclidean traveling-salesman problem</span><a name="1129"></a><a name="ch15ex27"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The <b class="bold"><i class="emphasis">euclidean traveling-salesman problem</i></b> is the problem of determining the shortest closed tour that connects a given set of <i class="emphasis">n</i> points in the plane. <a class="internaljump" href="#ch15fig09">Figure 15.9(a)</a> shows the solution to a 7-point problem. The general problem is NP-complete, and its solution is therefore believed to require more than polynomial time (see <a href="DDU0223.html#3001" target="_parent" class="chapterjump">Chapter 34</a>).</p>
<p class="para">
<div class="figure">
<a name="1130"></a><a name="ch15fig09"></a><span class="figuremediaobject"><a href="images/fig387%5F01%5F0%2Ejpg" NAME="IMG_484" target="_parent"><img src="images/fig387_01.jpg" height="136" width="343" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 15.9: </span>Seven points in the plane, shown on a unit grid. <i class="emphasis">(a)</i> The shortest closed tour, with length approximately 24.89. This tour is not bitonic. <i class="emphasis">(b)</i> The shortest bitonic tour for the same set of points. Its length is approximately 25.58.</span>
</div>
</p>
<p class="para">J. L. Bentley has suggested that we simplify the problem by restricting our attention to <b class="bold"><i class="emphasis">bitonic tours</i></b>, that is, tours that start at the leftmost point, go strictly left to right to the rightmost point, and then go strictly right to left back to the starting point. <a class="internaljump" href="#ch15fig09">Figure 15.9(b)</a> shows the shortest bitonic tour of the same 7 points. In this case, a polynomial-time algorithm is possible.</p>
<p class="last-para">Describe an <i class="emphasis">O</i>(<i class="emphasis">n</i><sup>2</sup>)-time algorithm for determining an optimal bitonic tour. You may assume that no two points have the same <i class="emphasis">x</i>-coordinate. (<i class="emphasis">Hint:</i> Scan left to right, maintaining optimal possibilities for the two parts of the tour.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 15-2: </span>Printing neatly</span><a name="1131"></a><a name="ch15ex28"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Consider the problem of neatly printing a paragraph on a printer. The input text is a sequence of <i class="emphasis">n</i> words of lengths <i class="emphasis">l</i><sub>1</sub>, <i class="emphasis">l</i><sub>2</sub>, ..., <i class="emphasis">l<sub>n</sub></i>, measured in characters. We want to print this paragraph neatly on a number of lines that hold a maximum of <i class="emphasis">M</i> characters each. Our criterion of "neatness" is as follows. If a given line contains words <i class="emphasis">i</i> through <i class="emphasis">j</i>, where <i class="emphasis">i</i> <span class="unicode">&le;</span> <i class="emphasis">j</i>, and we leave exactly one space between words, the number of extra space characters at the end of the line is <span class="inlinemediaobject"><img src="images/fig386_01.jpg" height="16" width="94" alt="" border="0"></span>, which must be nonnegative so that the words fit on the line. We wish to minimize the sum, over all lines except the last, of the cubes of the numbers of extra space characters at the ends of lines. Give a dynamic-programming algorithm to print a paragraph of <i class="emphasis">n</i> words neatly on a printer. Analyze the running time and space requirements of your algorithm.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 15-3: </span>Edit distance</span><a name="1132"></a><a name="ch15ex29"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">In order to transform one source string of text <i class="emphasis">x</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">m</i>] to a target string <i class="emphasis">y</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>], we can perform various transformation operations. Our goal is, given <i class="emphasis">x</i> and <i class="emphasis">y</i>, to produce a series of transformations that change <i class="emphasis">x</i> to <i class="emphasis">y</i>. We use an array <i class="emphasis">z</i><span class="unicode">-</span>assumed to be large enough to hold all the characters it will need<span class="unicode">-</span>to hold the intermediate results. Initially, <i class="emphasis">z</i> is empty, and at termination, we should have <i class="emphasis">z</i>[<i class="emphasis">j</i>] = <i class="emphasis">y</i>[<i class="emphasis">j</i>] for <i class="emphasis">j</i> = 1, 2, ..., <i class="emphasis">n</i>. We maintain current indices <i class="emphasis">i</i> into <i class="emphasis">x</i> and <i class="emphasis">j</i> into <i class="emphasis">z</i>, and the operations are allowed to alter <i class="emphasis">z</i> and these indices. Initially, <i class="emphasis">i</i> = <i class="emphasis">j</i> = 1. We are required <a name="1133"></a><a name="IDX-365"></a>to examine every character in <i class="emphasis">x</i> during the transformation, which means that at the end of the sequence of transformation operations, we must have <i class="emphasis">i</i> = <i class="emphasis">m</i> + 1.</p>
<p class="para">There are six transformation operations:</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">
<b class="bold">Copy</b> a character from <i class="emphasis">x</i> to <i class="emphasis">z</i> by setting <i class="emphasis">z</i>[<i class="emphasis">j</i>] <span class="unicode">&larr;</span> <i class="emphasis">x</i>[<i class="emphasis">i</i>] and then incrementing both <i class="emphasis">i</i> and <i class="emphasis">j</i>. This operation examines <i class="emphasis">x</i>[<i class="emphasis">i</i>].</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">Replace</b> a character from <i class="emphasis">x</i> by another character <i class="emphasis">c</i>, by setting <i class="emphasis">z</i>[<i class="emphasis">j</i>] <span class="unicode">&larr;</span> <i class="emphasis">c</i>, and then incrementing both <i class="emphasis">i</i> and <i class="emphasis">j</i>. This operation examines <i class="emphasis">x</i>[<i class="emphasis">i</i>].</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">Delete</b> a character from <i class="emphasis">x</i> by incrementing <i class="emphasis">i</i> but leaving <i class="emphasis">j</i> alone. This operation examines <i class="emphasis">x</i>[<i class="emphasis">i</i>].</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">Insert</b> the character <i class="emphasis">c</i> into <i class="emphasis">z</i> by setting <i class="emphasis">z</i>[<i class="emphasis">j</i>] <span class="unicode">&larr;</span> <i class="emphasis">c</i> and then incrementing <i class="emphasis">j</i>, but leaving <i class="emphasis">i</i> alone. This operation examines no characters of <i class="emphasis">x</i>.</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">Twiddle</b> (i.e., exchange) the next two characters by copying them from <i class="emphasis">x</i> to <i class="emphasis">z</i> but in the opposite order; we do so by setting <i class="emphasis">z</i>[<i class="emphasis">j</i>] <span class="unicode">&larr;</span> <i class="emphasis">x</i>[<i class="emphasis">i</i> + 1] and <i class="emphasis">z</i>[<i class="emphasis">j</i> + 1] <span class="unicode">&larr;</span> <i class="emphasis">x</i>[<i class="emphasis">i</i>] and then setting <i class="emphasis">i</i> <span class="unicode">&larr;</span> <i class="emphasis">i</i> + 2 and <i class="emphasis">j</i> <span class="unicode">&larr;</span> <i class="emphasis">j</i> + 2. This operation examines <i class="emphasis">x</i>[<i class="emphasis">i</i>] and <i class="emphasis">x</i>[<i class="emphasis">i</i> + 1].</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">Kill</b> the remainder of <i class="emphasis">x</i> by setting <i class="emphasis">i</i> <span class="unicode">&larr;</span> <i class="emphasis">m</i> + 1. This operation examines all characters in <i class="emphasis">x</i> that have not yet been examined. If this operation is performed, it must be the final operation.</p>
</li>
</ul>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">As an example, one way to transform the source string <span class="fixed">algorithm</span> to the target string <span class="fixed">altruistic</span> is to use the following sequence of operations, where the underlined characters are <i class="emphasis">x</i>[<i class="emphasis">i</i>] and <i class="emphasis">z</i>[<i class="emphasis">j</i>] after the operation:<a name="1134"></a><a name="IDX-366"></a>
</p>
<div class="informaltable">
<table border="0">
<thead>
<tr valign="top">
<th class="th" scope="col" align="left">
<p class="table-para">Operation</p>
</th><th class="th" scope="col" align="left">
<p class="table-para">
<i class="emphasis">x</i>
</p>
</th><th class="th" scope="col" align="left">
<p class="table-para">
<i class="emphasis">z</i>
</p>
</th>
</tr>
<tr>
<td colspan="3">
<hr>
</td>
</tr>
</thead>
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">initial strings</i>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed"><u class="underline">a</u>lgorithm</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">_</span>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">copy</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">a<u class="underline">l</u>gorithm</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">a_</span>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">copy</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">al<u class="underline">g</u>orithm</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">al_</span>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">replace by <span class="fixed">t</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">alg<u class="underline">o</u>rithm</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">alt_</span>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">delete</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">algo<u class="underline">r</u>ithm</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">alt_</span>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">copy</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">algor<u class="underline">i</u>thm</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">altr_</span>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">insert <span class="fixed">u</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">algor<u class="underline">i</u>thm</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">altru_</span>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">insert <span class="fixed">i</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">algor<u class="underline">i</u>thm</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">altrui_</span>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">insert <span class="fixed">s</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">algor<u class="underline">i</u>thm</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">altruis_</span>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">twiddle</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">algorit<u class="underline">h</u>m</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">altruisti_</span>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">insert <span class="fixed">c</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">algorit<u class="underline">h</u>m</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">altruistic_</span>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">kill</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">algorithm_</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="fixed">altruistic_</span>
</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">Note that there are several other sequences of transformation operations that transform <span class="fixed">algorithm</span> to <span class="fixed">altruistic</span>.</p>
<p class="para">Each of the transformation operations has an associated cost. The cost of an operation depends on the specific application, but we assume that each operation's cost is a constant that is known to us. We also assume that the individual costs of the copy and replace operations are less than the combined costs of the delete and insert operations; otherwise, the copy and replace operations would not be used. The cost of a given sequence of transformation operations is the sum of the costs of the individual operations in the sequence. For the sequence above, the cost of transforming <span class="fixed">algorithm</span> to <span class="fixed">altruistic</span> is</p>
<p class="para">(3 <span class="unicode">&middot;</span> cost(copy)) + cost(replace) + cost(delete) + (4 <span class="unicode">&middot;</span> cost(insert)) + cost(twiddle) + cost(kill).</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Given two sequences <i class="emphasis">x</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">m</i>] and <i class="emphasis">y</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>] and set of transformation-operation costs, the <b class="bold"><i class="emphasis">edit distance</i></b> from <i class="emphasis">x</i> to <i class="emphasis">y</i> is the cost of the least expensive operation sequence that transforms <i class="emphasis">x</i> to <i class="emphasis">y</i>. Describe a dynamic-programming algorithm that finds the edit distance from <i class="emphasis">x</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">m</i>] to <i class="emphasis">y</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>] and prints an optimal operation sequence. Analyze the running time and space requirements of your algorithm.</p>
</li>
</ol>
<p class="para">The edit-distance problem is a generalization of the problem of aligning two DNA sequences (see, for example, <a href="DDU0259.html#3827" target="_parent" class="chapterjump">Setubal and Meidanis [272</a>, Section 3.2]). There are several methods for measuring the similarity of two DNA sequences by aligning them. One such method to align two sequences <i class="emphasis">x</i> and <i class="emphasis">y</i> consists of inserting spaces at arbitrary locations in the two sequences (including at either end) so that the resulting sequences <i class="emphasis">x</i><span class="unicode">&prime;</span> and <i class="emphasis">y</i><span class="unicode">&prime;</span> have the same length but do not have a space in the same position (i.e., for no position <i class="emphasis">j</i> are both <i class="emphasis">x</i><span class="unicode">&prime;</span>[<i class="emphasis">j</i>] and <i class="emphasis">y</i><span class="unicode">&prime;</span>[<i class="emphasis">j</i>] a space.) Then we assign a "score" to each position. Position <i class="emphasis">j</i> receives a score as follows:<a name="1135"></a><a name="IDX-367"></a>
</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">+1 if <i class="emphasis">x</i><span class="unicode">&prime;</span>[<i class="emphasis">j</i>] = <i class="emphasis">y</i><span class="unicode">&prime;</span>[<i class="emphasis">j</i>] and neither is a space,</p>
</li>
<li class="listitem">
<p class="first-para">-1 if <i class="emphasis">x</i><span class="unicode">&prime;</span>[<i class="emphasis">j</i>] <span class="unicode">&ne;</span> <i class="emphasis">y</i><span class="unicode">&prime;</span>[<i class="emphasis">j</i>] and neither is a space,</p>
</li>
<li class="listitem">
<p class="first-para">-2 if either <i class="emphasis">x</i><span class="unicode">&prime;</span>[<i class="emphasis">j</i>] or <i class="emphasis">y</i><span class="unicode">&prime;</span>[<i class="emphasis">j</i>] is a space.</p>
</li>
</ul>
<p class="para">The score for the alignment is the sum of the scores of the individual positions. For example, given the sequences <i class="emphasis">x</i> = <span class="fixed">GATCGGCAT</span> and <i class="emphasis">y</i> = <span class="fixed">CAATGTGAATC</span>, one alignment is</p>
<div class="informalexample">
<pre class="literallayout">
G ATCG GCAT
CAAT GTGAATC
-*++*+*+-++*
</pre>
</div>
<p class="para">A <span class="fixed">+</span> under a position indicates a score of +1 for that position, a <span class="fixed">-</span> indicates a score of -1, and a <span class="fixed"><span class="unicode">&#8902;</span></span> indicates a score of -2, so that this alignment has a total score of 6 <span class="unicode">&middot;</span> 1 - 2 <span class="unicode">&middot;</span> 1 - 4 <span class="unicode">&middot;</span> 2 _ -4.</p>
<ol class="orderedlist" start="2" type="a">
<li class="first-listitem">
<p class="first-para">Explain how to cast the problem of finding an optimal alignment as an edit distance problem using a subset of the transformation operations copy, replace, delete, insert, twiddle, and kill.</p>
</li>
</ol>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 15-4: </span>Planning a company party</span><a name="1136"></a><a name="ch15ex30"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Professor Stewart is consulting for the president of a corporation that is planning a company party. The company has a hierarchical structure; that is, the supervisor relation forms a tree rooted at the president. The personnel office has ranked each employee with a conviviality rating, which is a real number. In order to make the party fun for all attendees, the president does not want both an employee and his or her immediate supervisor to attend.</p>
<p class="last-para">Professor Stewart is given the tree that describes the structure of the corporation, using the left-child, right-sibling representation described in <a href="DDU0061.html#675" target="_parent" class="chapterjump">Section 10.4</a>. Each node of the tree holds, in addition to the pointers, the name of an employee and that employee's conviviality ranking. Describe an algorithm to make up a guest list that maximizes the sum of the conviviality ratings of the guests. Analyze the running time of your algorithm.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 15-5: </span>Viterbi algorithm</span><a name="1137"></a><a name="ch15ex31"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">We can use dynamic programming on a directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) for speech recognition. Each edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i> is labeled with a sound <span class="unicode">&sigma;</span>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) from a finite set <span class="unicode">&Sigma;</span> of sounds. The labeled graph is a formal model of a person speaking a restricted language. Each path in the graph starting from a distinguished vertex <i class="emphasis">v</i><sub>0</sub> <span class="unicode">&isin;</span> <i class="emphasis">V</i> corresponds to a possible sequence of sounds produced by the model. The label of a directed path is defined to be the concatenation of the labels of the edges on that path.<a name="1138"></a><a name="IDX-368"></a>
</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Describe an efficient algorithm that, given an edge-labeled graph <i class="emphasis">G</i> with distinguished vertex <i class="emphasis">v</i><sub>0</sub> and a sequence <i class="emphasis">s</i> = <span class="unicode">&#12296;</span><i class="emphasis"><span class="unicode">&sigma;</span></i><sub>1</sub>, <i class="emphasis"><span class="unicode">&sigma;</span></i><sub>2</sub>, ..., <i class="emphasis"><span class="unicode">&sigma;</span><sub>k</sub></i><span class="unicode">&#12297;</span> of characters from <span class="unicode">&Sigma;</span>, returns a path in <i class="emphasis">G</i> that begins at <i class="emphasis">v</i><sub>0</sub> and has <i class="emphasis">s</i> as its label, if any such path exists. Otherwise, the algorithm should return NO-SUCH-PATH. Analyze the running time of your algorithm. (<i class="emphasis">Hint:</i> You may find concepts from <a href="DDU0129.html#1579" target="_parent" class="chapterjump">Chapter 22</a> useful.)</p>
</li>
</ol>
<p class="para">Now, suppose that every edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i> has also been given an associated nonnegative probability <i class="emphasis">p</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) of traversing the edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) from vertex <i class="emphasis">u</i> and thus producing the corresponding sound. The sum of the probabilities of the edges leaving any vertex equals 1. The probability of a path is defined to be the product of the probabilities of its edges. We can view the probability of a path beginning at <i class="emphasis">v</i><sub>0</sub> as the probability that a "random walk" beginning at <i class="emphasis">v</i><sub>0</sub> will follow the specified path, where the choice of which edge to take at a vertex <i class="emphasis">u</i> is made probabilistically according to the probabilities of the available edges leaving <i class="emphasis">u</i>.</p>
<ol class="orderedlist" start="2" type="a">
<li class="first-listitem">
<p class="first-para">Extend your answer to part (a) so that if a path is returned, it is a <i class="emphasis">most probable path</i> starting at <i class="emphasis">v</i><sub>0</sub> and having label <i class="emphasis">s</i>. Analyze the running time of your algorithm.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 15-6: </span>Moving on a checkerboard</span><a name="1139"></a><a name="ch15ex32"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that you are given an <i class="emphasis">n</i> <span class="unicode">&times;</span> <i class="emphasis">n</i> checkerboard and a checker. You must move the checker from the bottom edge of the board to the top edge of the board according to the following rule. At each step you may move the checker to one of three squares:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="first-para">the square immediately above,</p>
</li>
<li class="listitem">
<p class="first-para">the square that is one up and one to the left (but only if the checker is not already in the leftmost column),</p>
</li>
<li class="listitem">
<p class="first-para">the square that is one up and one to the right (but only if the checker is not already in the rightmost column).</p>
</li>
</ol>
<p class="para">Each time you move from square <i class="emphasis">x</i> to square <i class="emphasis">y</i>, you receive <i class="emphasis">p</i>(<i class="emphasis">x</i>, <i class="emphasis">y</i>) dollars. You are given <i class="emphasis">p</i>(<i class="emphasis">x</i>, <i class="emphasis">y</i>) for all pairs (<i class="emphasis">x</i>, <i class="emphasis">y</i>) for which a move from <i class="emphasis">x</i> to <i class="emphasis">y</i> is legal. Do not assume that <i class="emphasis">p</i>(<i class="emphasis">x</i>, <i class="emphasis">y</i>) is positive.</p>
<p class="last-para">Give an algorithm that figures out the set of moves that will move the checker from somewhere along the bottom edge to somewhere along the top edge while gathering as many dollars as possible. Your algorithm is free to pick any square along the bottom edge as a starting point and any square along the top edge as a destination in order to maximize the number of dollars gathered along the way. What is the running time of your algorithm?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1140"></a><a name="IDX-369"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 15-7: </span>Scheduling to maximize profit</span><a name="1141"></a><a name="ch15ex33"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose you have one machine and a set of <i class="emphasis">n</i> jobs <i class="emphasis">a</i><sub>1</sub>, <i class="emphasis">a</i><sub>2</sub>, ..., <i class="emphasis">a<sub>n</sub></i> to process on that machine. Each job <i class="emphasis">a<sub>j</sub></i> has a processing time <i class="emphasis">t<sub>j</sub></i>, a profit <i class="emphasis">p<sub>j</sub></i>, and a deadline <i class="emphasis">d<sub>j</sub></i>. The machine can process only one job at a time, and job <i class="emphasis">a<sub>j</sub></i> must run uninterruptedly for <i class="emphasis">t<sub>j</sub></i> consecutive time units. If job <i class="emphasis">a<sub>j</sub></i> is completed by its deadline <i class="emphasis">d<sub>j</sub></i>, you receive a profit <i class="emphasis">p<sub>j</sub></i>, but if it is completed after its deadline, you receive a profit of 0. Give an algorithm to find the schedule that obtains the maximum amount of profit, assuming that all processing times are integers between 1 and <i class="emphasis">n</i>. What is the running time of your algorithm?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
<div class="footnotes">
<div class="footnote">
<p>
<sup>[<a name="ftn.N38" href="#N38">5</a>]</sup>If the subject of the text is edible mushrooms, we might want "mycophagist" to appear near the root.</p>
</div>
</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0090.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0092.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
