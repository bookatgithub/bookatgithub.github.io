<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>16.1 An activity-selection problem</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0093.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0095.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch16"></a>
<div class="section">
<h2 class="first-section-title">
<a name="1146"></a><a name="ch16lev1sec1"></a><span class="section-titlelabel">16.1 </span>An activity-selection problem</h2>
<a name="1147"></a><a name="IDX-371"></a>
<p class="para">Our first example is the problem of scheduling several competing activities that require exclusive use of a common resource, with a goal of selecting a maximum-size set of mutually compatible activities. Suppose we have a set <i class="emphasis">S</i> = {<i class="emphasis">a</i><sub>1</sub>, <i class="emphasis">a</i><sub>2</sub>, ..., <i class="emphasis">a<sub>n</sub></i>} of <i class="emphasis">n</i> proposed <b class="bold"><i class="emphasis">activities</i></b> that wish to use a resource, such as a lecture hall, which can be used by only one activity at a time. Each activity <i class="emphasis">a<sub>i</sub></i> has a <b class="bold"><i class="emphasis">start time</i></b> <i class="emphasis">s<sub>i</sub></i> and a <b class="bold"><i class="emphasis">finish time</i></b> <i class="emphasis">f<sub>i</sub></i>, where 0 <span class="unicode">&le;</span> <i class="emphasis">s<sub>i</sub></i> <span class="unicode">&lt;</span> <i class="emphasis">f<sub>i</sub></i> <span class="unicode">&lt;</span> <span class="unicode">&infin;</span>. If selected, activity <i class="emphasis">a<sub>i</sub></i> takes place during the half-open time interval [<i class="emphasis">s<sub>i</sub>, f<sub>i</sub></i>). Activities <i class="emphasis">a<sub>i</sub></i> and <i class="emphasis">a<sub>j</sub></i> are <b class="bold"><i class="emphasis">compatible</i></b> if the intervals [<i class="emphasis">s<sub>i</sub>, f<sub>i</sub></i>) and [<i class="emphasis">s<sub>j</sub></i> <i class="emphasis">f<sub>j</sub></i>) do not overlap (i.e., <i class="emphasis">a<sub>i</sub></i> and <i class="emphasis">a<sub>j</sub></i> are compatible if <i class="emphasis">s<sub>i</sub></i> <span class="unicode">&ge;</span> <i class="emphasis">f<sub>j</sub></i> or <i class="emphasis">s<sub>j</sub></i> <span class="unicode">&ge;</span> <i class="emphasis">f<sub>i</sub></i>). The <b class="bold"><i class="emphasis">activity-selection problem</i></b> is to select a maximum-size subset of mutually compatible activities. For example, consider the following set <i class="emphasis">S</i> of activities, which we have sorted in monotonically increasing order of finish time:</p>
<div class="informaltable">
<table border="0">
<thead>
<tr valign="top">
<th class="th" scope="col" align="left">
<p class="table-para">
<i class="emphasis">i</i>
</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">1</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">2</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">3</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">4</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">5</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">6</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">7</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">8</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">9</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">10</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">11</p>
</th>
</tr>
<tr>
<td colspan="12">
<hr>
</td>
</tr>
</thead>
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">s<sub>i</sub></i>
</p>
</td><td class="td" align="center">
<p class="table-para">1</p>
</td><td class="td" align="center">
<p class="table-para">3</p>
</td><td class="td" align="center">
<p class="table-para">0</p>
</td><td class="td" align="center">
<p class="table-para">5</p>
</td><td class="td" align="center">
<p class="table-para">3</p>
</td><td class="td" align="center">
<p class="table-para">5</p>
</td><td class="td" align="center">
<p class="table-para">6</p>
</td><td class="td" align="center">
<p class="table-para">8</p>
</td><td class="td" align="center">
<p class="table-para">8</p>
</td><td class="td" align="center">
<p class="table-para">2</p>
</td><td class="td" align="center">
<p class="table-para">12</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">f<sub>i</sub></i>
</p>
</td><td class="td" align="center">
<p class="table-para">4</p>
</td><td class="td" align="center">
<p class="table-para">5</p>
</td><td class="td" align="center">
<p class="table-para">6</p>
</td><td class="td" align="center">
<p class="table-para">7</p>
</td><td class="td" align="center">
<p class="table-para">8</p>
</td><td class="td" align="center">
<p class="table-para">9</p>
</td><td class="td" align="center">
<p class="table-para">10</p>
</td><td class="td" align="center">
<p class="table-para">11</p>
</td><td class="td" align="center">
<p class="table-para">12</p>
</td><td class="td" align="center">
<p class="table-para">13</p>
</td><td class="td" align="center">
<p class="table-para">14</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">(We shall see shortly why it is advantageous to consider activities in sorted order.) For this example, the subset {<i class="emphasis">a</i><sub>3</sub>, <i class="emphasis">a</i><sub>9</sub>, <i class="emphasis">a</i><sub>11</sub>} consists of mutually compatible activities. It is not a maximal subset, however, since the subset {<i class="emphasis">a</i><sub>1</sub>, <i class="emphasis">a</i><sub>4</sub>, <i class="emphasis">a</i><sub>8</sub>, <i class="emphasis">a</i><sub>11</sub>} is larger. In fact, {<i class="emphasis">a</i><sub>1</sub>, <i class="emphasis">a</i><sub>4</sub>, <i class="emphasis">a</i><sub>8</sub>, <i class="emphasis">a</i><sub>11</sub>} is a largest subset of mutually compatible activities; another largest subset is {<i class="emphasis">a</i><sub>2</sub>, <i class="emphasis">a</i><sub>4</sub>, <i class="emphasis">a</i><sub>9</sub>, <i class="emphasis">a</i><sub>11</sub>}.</p>
<p class="para">We shall solve this problem in several steps. We start by formulating a dynamic-programming solution to this problem in which we combine optimal solutions to two subproblems to form an optimal solution to the original problem. We consider several choices when determining which subproblems to use in an optimal solution. We shall then observe that we need only consider one choice<span class="unicode">-</span>the greedy choice<span class="unicode">-</span>and that when we make the greedy choice, one of the subproblems is guaranteed to be empty, so that only one nonempty subproblem remains. Based on these observations, we shall develop a recursive greedy algorithm to solve the activity-scheduling problem. We shall complete the process of developing a greedy solution by converting the recursive algorithm to an iterative one. Although the steps we shall go through in this section are more involved than is typical for the development of a greedy algorithm, they illustrate the relationship of greedy algorithms and dynamic programming.</p>
<div class="section">
<h4 class="sect4-title">
<a name="1148"></a><a name="ch16lev3sec1"></a>The optimal substructure of the activity-selection problem</h4>
<p class="first-para">As mentioned above, we start by developing a dynamic-programming solution to the activity-selection problem. As in <a href="DDU0086.html#1007" target="_parent" class="chapterjump">Chapter 15</a>, our first step is to find the optimal <a name="1149"></a><a name="IDX-372"></a>substructure and then use it to construct an optimal solution to the problem from optimal solutions to subproblems.</p>
<p class="para">We saw in <a href="DDU0086.html#1007" target="_parent" class="chapterjump">Chapter 15</a> that we need to define an appropriate space of subproblems. Let us start by defining sets</p>
<p class="para">
<i class="emphasis">S<sub>ij</sub></i> = {<i class="emphasis">a<sub>k</sub></i> <span class="unicode">&isin;</span> <i class="emphasis">S</i> : <i class="emphasis">f<sub>i</sub></i> <span class="unicode">&le;</span> <i class="emphasis">s<sub>k</sub></i> <span class="unicode">&lt;</span> <i class="emphasis">f<sub>k</sub></i> <span class="unicode">&le;</span> <i class="emphasis">s<sub>j</sub></i>} ,</p>
<p class="para">so that <i class="emphasis">S<sub>ij</sub></i> is the subset of activities in <i class="emphasis">S</i> that can start after activity <i class="emphasis">a<sub>i</sub></i> finishes and finish before activity <i class="emphasis">a<sub>j</sub></i> starts. In fact, <i class="emphasis">S<sub>ij</sub></i> consists of all activities that are compatible with <i class="emphasis">a<sub>i</sub></i> and <i class="emphasis">a<sub>j</sub></i> and are also compatible with all activities that finish no later than <i class="emphasis">a<sub>i</sub></i> finishes and all activities that start no earlier than <i class="emphasis">a<sub>j</sub></i> starts. In order to represent to entire problem, we add fictitious activities <i class="emphasis">a</i><sub>0</sub> and <i class="emphasis">a</i><sub><i class="emphasis">n</i>+1</sub> and adopt the conventions that <i class="emphasis">f</i><sub>0</sub> = 0 and <i class="emphasis">s</i><sub><i class="emphasis">n</i>+1</sub> = <span class="unicode">&infin;</span>. Then <i class="emphasis">S</i> = <i class="emphasis">S</i><sub>0.<i class="emphasis">n</i>+1</sub>, and the ranges for <i class="emphasis">i</i> and <i class="emphasis">j</i> are given by 0 <span class="unicode">&le;</span> <i class="emphasis">i, j</i> <span class="unicode">&le;</span> <i class="emphasis">n</i> + 1.</p>
<p class="para">We can further restrict the ranges of <i class="emphasis">i</i> and <i class="emphasis">j</i> as follows. Let us assume that the activities are sorted in monotonically increasing order of finish time:</p>
<div class="equation">
<a name="1150"></a><a name="ch16eq01"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(16.1)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig394_01.jpg" height="16" width="203" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">We claim that <i class="emphasis">S<sub>ij</sub></i> = <span class="unicode">&Oslash;</span> whenever <i class="emphasis">i</i> <span class="unicode">&ge;</span> <i class="emphasis">j</i>. Why? Suppose that there exists an activity <i class="emphasis">a<sub>k</sub></i> <span class="unicode">&isin;</span> <i class="emphasis">S<sub>ij</sub></i> for some <i class="emphasis">i</i> <span class="unicode">&ge;</span> <i class="emphasis">j</i>, so that <i class="emphasis">a<sub>i</sub></i> follows <i class="emphasis">a<sub>j</sub></i> in the sorted order. Then we would have <i class="emphasis">f<sub>i</sub></i> <span class="unicode">&le;</span> <i class="emphasis">s<sub>k</sub></i> <span class="unicode">&lt;</span> <i class="emphasis">f<sub>k</sub></i> <span class="unicode">&le;</span> <i class="emphasis">s<sub>j</sub></i> <span class="unicode">&lt;</span> <i class="emphasis">f<sub>j</sub></i>. Thus, <i class="emphasis">f<sub>i</sub></i> <span class="unicode">&lt;</span> <i class="emphasis">f<sub>j</sub></i>, which contradicts our assumption that <i class="emphasis">a<sub>i</sub></i> follows <i class="emphasis">a<sub>j</sub></i> in the sorted order. We can conclude that, assuming that we have sorted the activities in monotonically increasing order of finish time, our space of subproblems is to select a maximum-size subset of mutually compatible activities from <i class="emphasis">S<sub>ij</sub></i>, for 0 <span class="unicode">&le;</span> <i class="emphasis">i</i> <span class="unicode">&lt;</span> <i class="emphasis">j</i> <span class="unicode">&le;</span> <i class="emphasis">n</i> + 1, knowing that all other <i class="emphasis">S<sub>ij</sub></i> are empty.</p>
<p class="para">To see the substructure of the activity-selection problem, consider some non-empty subproblem <i class="emphasis">S<sub>ij</sub></i>,<sup>[<a name="N833" href="#ftn.N833">1</a>]</sup> and suppose that a solution to <i class="emphasis">S<sub>ij</sub></i> includes some activity <i class="emphasis">a<sub>k</sub></i>, so that <i class="emphasis">f<sub>i</sub></i> <span class="unicode">&le;</span> <i class="emphasis">s<sub>k</sub></i> <span class="unicode">&lt;</span> <i class="emphasis">f<sub>k</sub></i> <span class="unicode">&le;</span> <i class="emphasis">s<sub>j</sub></i>. Using activity <i class="emphasis">a<sub>k</sub></i> generates two subproblems, <i class="emphasis">S<sub>ik</sub></i> (activities that start after <i class="emphasis">a<sub>i</sub></i> finishes and finish before <i class="emphasis">a<sub>k</sub></i> starts) and <i class="emphasis">S<sub>kj</sub></i> (activities that start after <i class="emphasis">a<sub>k</sub></i> finishes and finish before <i class="emphasis">a<sub>j</sub></i> starts), each of which consists of a subset of the activities in <i class="emphasis">S<sub>ij</sub></i>. Our solution to <i class="emphasis">S<sub>ij</sub></i> is the union of the solutions to <i class="emphasis">S<sub>ik</sub></i> and <i class="emphasis">S<sub>kj</sub></i>, along with the activity <i class="emphasis">a<sub>k</sub></i>. Thus, the number of activities in our solution to <i class="emphasis">S<sub>ij</sub></i> is the size of our solution to <i class="emphasis">S<sub>ik</sub></i>, plus the size of our solution to <i class="emphasis">S<sub>kj</sub></i> , plus one (for <i class="emphasis">a<sub>k</sub></i>).</p>
<p class="para">The optimal substructure of this problem is as follows. Suppose now that an optimal solution <i class="emphasis">A<sub>ij</sub></i> to <i class="emphasis">S<sub>ij</sub></i> includes activity <i class="emphasis">a<sub>k</sub></i>. Then the solutions <i class="emphasis">A<sub>ik</sub></i> to <i class="emphasis">S<sub>ik</sub></i> and <i class="emphasis">A<sub>kj</sub></i> to <i class="emphasis">S<sub>kj</sub></i> used within this optimal solution to <i class="emphasis">S<sub>ij</sub></i> must be optimal as well. The usual cut-and-paste argument applies. If we had a solution <span class="inlinemediaobject"><img src="images/fig394_02.jpg" height="14" width="15" alt="" border="0"></span> to <i class="emphasis">S<sub>ik</sub></i> that included <a name="1151"></a><a name="IDX-373"></a>more activities than <i class="emphasis">A<sub>ik</sub></i>, we could cut out <i class="emphasis">A<sub>ik</sub></i> from <i class="emphasis">A<sub>ij</sub></i> and paste in <span class="inlinemediaobject"><img src="images/fig395_01.jpg" height="14" width="15" alt="" border="0"></span>, thus producing a another solution to <i class="emphasis">S<sub>ij</sub></i> with more activities than <i class="emphasis">A<sub>ij</sub></i>. Because we assumed that <i class="emphasis">A<sub>ij</sub></i> is an optimal solution, we have derived a contradiction. Similarly, if we had a solution <span class="inlinemediaobject"><img src="images/fig395_02.jpg" height="14" width="16" alt="" border="0"></span> to <i class="emphasis">S<sub>kj</sub></i> with more activities than <i class="emphasis">A<sub>kj</sub></i>, we could replace <i class="emphasis">A<sub>kj</sub></i> by <span class="inlinemediaobject"><img src="images/fig395_03.jpg" height="15" width="15" alt="" border="0"></span> to produce a solution to <i class="emphasis">S<sub>ij</sub></i> with more activities than <i class="emphasis">A<sub>ij</sub></i>.</p>
<p class="para">Now we use our optimal substructure to show that we can construct an optimal solution to the problem from optimal solutions to subproblems. We have seen that any solution to a nonempty subproblem <i class="emphasis">S<sub>ij</sub></i> includes some activity <i class="emphasis">a<sub>k</sub></i>, and that any optimal solution contains within it optimal solutions to subproblem instances <i class="emphasis">S<sub>ik</sub></i> and <i class="emphasis">S<sub>kj</sub></i>. Thus, we can build an maximum-size subset of mutually compatible activities in <i class="emphasis">S<sub>ij</sub></i> by splitting the problem into two subproblems (finding maximum-size subsets of mutually compatible activities in <i class="emphasis">S<sub>ik</sub></i> and <i class="emphasis">S<sub>kj</sub></i>), finding maximum-size subsets <i class="emphasis">A<sub>ik</sub></i> and <i class="emphasis">A<sub>kj</sub></i> of mutually compatible activities for these subproblems, and forming our maximum-size subset <i class="emphasis">A<sub>ij</sub></i> of mutually compatible activities as</p>
<div class="equation">
<a name="1152"></a><a name="ch16eq02"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(16.2)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig395_04.jpg" height="17" width="144" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="last-para">An optimal solution to the entire problem is a solution to <i class="emphasis">S</i><sub>0,<i class="emphasis">n</i>+1</sub>.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1153"></a><a name="ch16lev3sec2"></a>A recursive solution</h4>
<p class="first-para">The second step in developing a dynamic-programming solution is to recursively define the value of an optimal solution. For the activity-selection problem, we let <i class="emphasis">c</i>[<i class="emphasis">i, j</i>] be the number of activities in a maximum-size subset of mutually compatible activities in <i class="emphasis">S<sub>ij</sub></i>. We have <i class="emphasis">c</i>[<i class="emphasis">i, j</i>] = 0 whenever <i class="emphasis">S<sub>ij</sub></i> = <span class="unicode">&Oslash;</span>; in particular, <i class="emphasis">c</i>[<i class="emphasis">i, j</i>] = 0 for <i class="emphasis">i</i> <span class="unicode">&ge;</span> <i class="emphasis">j</i>.</p>
<p class="para">Now consider a nonempty subset <i class="emphasis">S<sub>ij</sub></i>. As we have seen, if <i class="emphasis">a<sub>k</sub></i> is used in a maximum-size subset of mutually compatible activities of <i class="emphasis">S<sub>ij</sub></i>, we also use maximum-size subsets of mutually compatible activities for the subproblems <i class="emphasis">S<sub>ik</sub></i> and <i class="emphasis">S<sub>kj</sub></i>. Using <a class="internaljump" href="#ch16eq02">equation (16.2)</a>, we have the recurrence</p>
<p class="para">
<i class="emphasis">c</i>[<i class="emphasis">i, j</i> ] = <i class="emphasis">c</i>[<i class="emphasis">i, k</i>] + <i class="emphasis">c</i>[<i class="emphasis">k, j</i> ] + 1.</p>
<p class="para">This recursive equation assumes that we know the value of <i class="emphasis">k</i>, which we do not. There are <i class="emphasis">j</i> - <i class="emphasis">i</i> - 1 possible values for <i class="emphasis">k</i>, namely <i class="emphasis">k</i> = <i class="emphasis">i</i> + 1, ..., <i class="emphasis">j</i> - 1. Since the maximum-size subset of <i class="emphasis">S<sub>ij</sub></i> must use one of these values for <i class="emphasis">k</i>, we check them all to find the best. Thus, our full recursive definition of <i class="emphasis">c</i>[<i class="emphasis">i, j</i>] becomes</p>
<div class="equation">
<a name="1154"></a><a name="ch16eq03"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(16.3)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig395_05.jpg" height="47" width="305" alt="" border="0"></span></td>
</tr>
</table>
</div>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1155"></a><a name="ch16lev3sec3"></a>Converting a dynamic-programming solution to a greedy solution</h4>
<p class="first-para">At this point, it would be a straightforward exercise to write a tabular, bottom-up, dynamic-programming algorithm based on recurrence (<a class="internaljump" href="#ch16eq03">16.3</a>). In fact, <a class="internaljump" href="#ch16ex02">Exercise 16.1-1</a> <a name="1156"></a><a name="IDX-374"></a>asks you to do just that. There are two key observations, however, that allow us to simplify our solution.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 16.1</span></span><a name="1157"></a><a name="ch16ex01"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Consider any nonempty subproblem <i class="emphasis">S<sub>ij</sub></i>, and let <i class="emphasis">a<sub>m</sub></i> be the activity in <i class="emphasis">S<sub>ij</sub></i> with the earliest finish time:</p>
<p class="para">
<i class="emphasis">f<sub>m</sub></i> = min {<i class="emphasis">f<sub>k</sub></i> : <i class="emphasis">a<sub>k</sub></i> <span class="unicode">&isin;</span> <i class="emphasis">S<sub>ij</sub></i>}.</p>
<p class="para">Then</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="first-para">Activity <i class="emphasis">a<sub>m</sub></i> is used in some maximum-size subset of mutually compatible activities of <i class="emphasis">S<sub>ij</sub></i>.</p>
</li>
<li class="listitem">
<p class="first-para">The subproblem <i class="emphasis">S<sub>im</sub></i> is empty, so that choosing <i class="emphasis">a<sub>m</sub></i> leaves the subproblem <i class="emphasis">S<sub>mj</sub></i> as the only one that may be nonempty.</p>
</li>
</ol>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> We shall prove the second part first, since it's a bit simpler. Suppose that <i class="emphasis">S<sub>im</sub></i> is nonempty, so that there is some activity <i class="emphasis">a<sub>k</sub></i> such that <i class="emphasis">f<sub>i</sub></i> <span class="unicode">&le;</span> <i class="emphasis">s<sub>k</sub></i> <span class="unicode">&lt;</span> <i class="emphasis">f<sub>k</sub></i> <span class="unicode">&le;</span> <i class="emphasis">s<sub>m</sub></i> <span class="unicode">&lt;</span> <i class="emphasis">f<sub>m</sub></i>. Then <i class="emphasis">a<sub>k</sub></i> is also in <i class="emphasis">S<sub>ij</sub></i> and it has an earlier finish time than <i class="emphasis">a<sub>m</sub></i>, which contradicts our choice of <i class="emphasis">a<sub>m</sub></i>. We conclude that <i class="emphasis">S<sub>im</sub></i> is empty.</p>
<p class="last-para">To prove the first part, we suppose that <i class="emphasis">A<sub>ij</sub></i> is a maximum-size subset of mutually compatible activities of <i class="emphasis">S<sub>ij</sub></i>, and let us order the activities in <i class="emphasis">A<sub>ij</sub></i> in monotonically increasing order of finish time. Let <i class="emphasis">a<sub>k</sub></i> be the first activity in <i class="emphasis">A<sub>ij</sub></i>. If <i class="emphasis">a<sub>k</sub></i> = <i class="emphasis">a<sub>m</sub></i>, we are done, since we have shown that <i class="emphasis">a<sub>m</sub></i> is used in some maximum-size subset of mutually compatible activities of <i class="emphasis">S<sub>ij</sub></i>. If <i class="emphasis">a<sub>k</sub></i> <span class="unicode">&ne;</span> <i class="emphasis">a<sub>m</sub></i>, we construct the subset <span class="inlinemediaobject"><img src="images/fig396_01.jpg" height="14" width="28" alt="" border="0"></span><span class="inlinemediaobject"><img src="images/fig396_02.jpg" height="14" width="79" alt="" border="0"></span> The activities in <span class="inlinemediaobject"><img src="images/fig396_03.jpg" height="14" width="15" alt="" border="0"></span> are disjoint, since the activities in <i class="emphasis">A<sub>ij</sub></i> are, <i class="emphasis">a<sub>k</sub></i> is the first activity in <i class="emphasis">A<sub>ij</sub></i> to finish, and <i class="emphasis">f<sub>m</sub></i> <span class="unicode">&le;</span> <i class="emphasis">f<sub>k</sub></i>. Noting that <span class="inlinemediaobject"><img src="images/fig396_04.jpg" height="14" width="15" alt="" border="0"></span> has the same number of activities as <i class="emphasis">A<sub>ij</sub></i>, we see that <span class="inlinemediaobject"><img src="images/fig396_05.jpg" height="15" width="15" alt="" border="0"></span> is a maximum-size subset of mutually compatible activities of <i class="emphasis">S<sub>ij</sub></i> that includes <i class="emphasis">a<sub>m</sub></i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">Why is <a class="internaljump" href="#ch16ex01">Theorem 16.1</a> so valuable? Recall from <a href="DDU0089.html#1062" target="_parent" class="chapterjump">Section 15.3</a> that optimal sub-structure varies in how many subproblems are used in an optimal solution to the original problem and in how many choices we have in determining which subproblems to use. In our dynamic-programming solution, two subproblems are used in an optimal solution, and there are <i class="emphasis">j</i>-<i class="emphasis">i</i>-1 choices when solving the subproblem <i class="emphasis">S<sub>ij</sub></i>. <a class="internaljump" href="#ch16ex01">Theorem 16.1</a> reduces both of these quantities significantly: only one subproblem is used in an optimal solution (the other subproblem is guaranteed to be empty), and when solving the subproblem <i class="emphasis">S<sub>ij</sub></i>, we need consider only one choice: the one with the earliest finish time in <i class="emphasis">S<sub>ij</sub></i>. Fortunately, we can easily determine which activity this is.</p>
<p class="para">In addition to reducing the number of subproblems and the number of choices, <a class="internaljump" href="#ch16ex01">Theorem 16.1</a> yields another benefit: we can solve each subproblem in a top-down <a name="1158"></a><a name="IDX-375"></a>fashion, rather than the bottom-up manner typically used in dynamic programming. To solve the subproblem <i class="emphasis">S<sub>ij</sub></i>, we choose the activity <i class="emphasis">a<sub>m</sub></i> in <i class="emphasis">S<sub>ij</sub></i> with the earliest finish time and add to this solution the set of activities used in an optimal solution to the subproblem <i class="emphasis">S<sub>ij</sub></i>. Because we know that, having chosen <i class="emphasis">a<sub>m</sub></i>, we will certainly be using a solution to <i class="emphasis">S<sub>mj</sub></i> in our optimal solution to <i class="emphasis">S<sub>ij</sub></i>, we do not need to solve <i class="emphasis">S<sub>mj</sub></i> <i class="emphasis">before</i> solving <i class="emphasis">S<sub>ij</sub></i>. To solve <i class="emphasis">S<sub>ij</sub></i>, we can <i class="emphasis">first</i> choose <i class="emphasis">a<sub>m</sub></i> as the activity in <i class="emphasis">S<sub>ij</sub></i> with the earliest finish time and <i class="emphasis">then</i> solve <i class="emphasis">S<sub>mj</sub></i>.</p>
<p class="para">Note also that there is a pattern to the subproblems that we solve. Our original problem is <i class="emphasis">S</i> = <i class="emphasis">S</i><sub>0.<i class="emphasis">n</i>+1</sub>. Suppose that we choose <span class="inlinemediaobject"><img src="images/fig397_01.jpg" height="10" width="15" alt="" border="0"></span> as the activity in <i class="emphasis">S</i><sub>0.<i class="emphasis">n</i>+1</sub> with the earliest finish time. (Since we have sorted activities by monotonically increasing finish times and <i class="emphasis">f</i><sub>0</sub> = 0, we must have <i class="emphasis">m</i><sub>1</sub> = 1.) Our next subproblem is <span class="inlinemediaobject"><img src="images/fig397_02.jpg" height="13" width="32" alt="" border="0"></span>. Now suppose that we choose <span class="inlinemediaobject"><img src="images/fig397_03.jpg" height="10" width="15" alt="" border="0"></span> as the activity in <span class="inlinemediaobject"><img src="images/fig397_04.jpg" height="13" width="32" alt="" border="0"></span> with the earliest finish time. (It is not necessarily the case that <i class="emphasis">m</i><sub>2</sub> = 2.) Our next subproblem is <span class="inlinemediaobject"><img src="images/fig397_05.jpg" height="13" width="32" alt="" border="0"></span>. Continuing, we see that each subproblem will be of the form <span class="inlinemediaobject"><img src="images/fig397_06.jpg" height="13" width="31" alt="" border="0"></span> for some activity number <i class="emphasis">m<sub>i</sub></i>. In other words, each subproblem consists of the last activities to finish, and the number of such activities varies from subproblem to subproblem.</p>
<p class="para">There is also a pattern to the activities that we choose. Because we always choose the activity with the earliest finish time in <span class="inlinemediaobject"><img src="images/fig397_07.jpg" height="12" width="31" alt="" border="0"></span>, the finish times of the activities chosen over all subproblems will be strictly increasing over time. More-over, we can consider each activity just once overall, in monotonically increasing order of finish times.</p>
<p class="last-para">The activity <i class="emphasis">a<sub>m</sub></i> that we choose when solving a subproblem is always the one with the earliest finish time that can be legally scheduled. The activity picked is thus a "greedy" choice in the sense that, intuitively, it leaves as much opportunity as possible for the remaining activities to be scheduled. That is, the greedy choice is the one that maximizes the amount of unscheduled time remaining.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1159"></a><a name="ch16lev3sec4"></a>A recursive greedy algorithm</h4>
<p class="first-para">Now that we have seen how to streamline our dynamic-programming solution, and how to treat it as a top-down method, we are ready to see an algorithm that works in a purely greedy, top-down fashion. We give a straightforward, recursive solution as the procedure RECURSIVE-ACTIVITY-SELECTOR. It takes the start and finish times of the activities, represented as arrays <i class="emphasis">s</i> and <i class="emphasis">f</i>, as well as the starting indices <i class="emphasis">i</i> and <i class="emphasis">j</i> of the subproblem <i class="emphasis">S</i><sub><i class="emphasis">i</i>.<i class="emphasis">j</i></sub> it is to solve. It returns a maximum-size set of mutually compatible activities in <i class="emphasis">S</i><sub><i class="emphasis">i</i>.<i class="emphasis">j</i></sub>. We assume that the <i class="emphasis">n</i> input activities are ordered by monotonically increasing finish time, according to equation (<a class="internaljump" href="#ch16eq01">16.1</a>). If not, we can sort them into this order in <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) time, breaking ties arbitrarily. The initial call is RECURSIVE-ACTIVITY-SELECTOR(<i class="emphasis">s, f</i>, 0, <i class="emphasis">n</i> + 1).<a name="1160"></a><a name="IDX-376"></a>
</p>
<div class="informalexample">
<pre class="literallayout-normal">
RECURSIVE-ACTIVITY-SELECTOR(<i class="emphasis">s, f, i, j</i>)
1 <i class="emphasis">m</i> <span class="unicode">&larr;</span> <i class="emphasis">i</i> + 1
2 <b class="bold">while</b> <i class="emphasis">m</i>  <span class="unicode">&lt;</span> <i class="emphasis">j</i> and <i class="emphasis">s<sub>m</sub></i> <span class="unicode">&lt;</span> <i class="emphasis">f<sub>i</sub></i> <span class="unicode">&#9657;</span> Find the first activity in <i class="emphasis">S<sub>ij</sub></i>.
3     <b class="bold">do</b> <i class="emphasis">m</i> <span class="unicode">&larr;</span> <i class="emphasis">m</i> + 1
4 <b class="bold">if</b> <i class="emphasis">m</i> <span class="unicode">&lt;</span> <i class="emphasis">j</i>
5    <b class="bold">then return</b> {<i class="emphasis">a<sub>m</sub></i>} <span class="unicode">&cup;</span> RECURSIVE-ACTIVITY-SELECTOR(<i class="emphasis">s, f, m, j</i>)
6    <b class="bold">else return</b> <span class="unicode">&Oslash;</span>
</pre>
</div>
<p class="para">
<a class="internaljump" href="#ch16fig01">Figure 16.1</a> shows the operation of the algorithm. In a given recursive call RECURSIVE-ACTIVITY-SELECTOR(<i class="emphasis">s, f, i, j</i>), the <b class="bold">while</b> loop of lines 2<span class="unicode">-</span>3 looks for the first activity in <i class="emphasis">S<sub>ij</sub></i>. The loop examines <i class="emphasis">a</i><sub><i class="emphasis">i</i>+1</sub>, <i class="emphasis">a</i><sub><i class="emphasis">i</i>+2</sub>, ..., <i class="emphasis">a</i><sub><i class="emphasis">j</i>-1</sub>, until it finds the first activity <i class="emphasis">a<sub>m</sub></i> that is compatible with <i class="emphasis">a<sub>i</sub></i>; such an activity has <i class="emphasis">s<sub>m</sub></i> <span class="unicode">&ge;</span> <i class="emphasis">f<sub>i</sub></i>. If the loop terminates because it finds such an activity, the procedure returns in line 5 the union of {<i class="emphasis">a<sub>m</sub></i>} and the maximum-size subset of <i class="emphasis">S<sub>mj</sub></i> returned by the recursive call RECURSIVE-ACTIVITY-SELECTOR(<i class="emphasis">s, f, m, j</i>). Alternatively, the loop may terminate because <i class="emphasis">m</i> <span class="unicode">&ge;</span> <i class="emphasis">j</i>, in which case we have examined all activities whose finish times are before that of <i class="emphasis">a<sub>j</sub></i> without finding one that is compatible with <i class="emphasis">a<sub>i</sub></i>. In this case, <i class="emphasis">S<sub>ij</sub></i> = <span class="unicode">&Oslash;</span>, and so the procedure returns <span class="unicode">&Oslash;</span> in line 6.</p>
<div class="figure">
<a name="1161"></a><a name="ch16fig01"></a><span class="figuremediaobject"><a href="images/fig399%5F01%5F0%2Ejpg" NAME="IMG_505" target="_parent"><img src="images/fig399_01.jpg" height="389" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 16.1: </span>The operation of RECURSIVE-ACTIVITY-SELECTOR on the 11 activities given earlier. Activities considered in each recursive call appear between horizontal lines. The fictitious activity <i class="emphasis">a</i><sub>0</sub> finishes at time 0, and in the initial call, RECURSIVE-ACTIVITY-SELECTOR(<i class="emphasis">s, f</i>, 0, 12), activity <i class="emphasis">a</i><sub>1</sub> is selected. In each recursive call, the activities that have already been selected are shaded, and the activity shown in white is being considered. If the starting time of an activity occurs before the finish time of the most recently added activity (the arrow between them points left), it is rejected. Otherwise (the arrow points directly up or to the right), it is selected. The last recursive call, RECURSIVE-ACTIVITY-SELECTOR(<i class="emphasis">s, f</i>, 11, 12), returns <span class="unicode">&Oslash;</span>. The resulting set of selected activities is {<i class="emphasis">a</i><sub>1</sub>, <i class="emphasis">a</i><sub>4</sub>, <i class="emphasis">a</i><sub>8</sub>, <i class="emphasis">a</i><sub>11</sub>}.</span>
</div>
<p class="last-para">Assuming that the activities have already been sorted by finish times, the running time of the call RECURSIVE-ACTIVITY-SELECTOR(<i class="emphasis">s, f</i>, 0, <i class="emphasis">n</i> + 1) is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>), which we can see as follows. Over all recursive calls, each activity is examined exactly once in the <b class="bold">while</b> loop test of line 2. In particular, activity <i class="emphasis">a</i><i class="emphasis">k</i> is examined in the last call made in which <i class="emphasis">i</i> <span class="unicode">&lt;</span> <i class="emphasis">k</i>.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1162"></a><a name="ch16lev3sec5"></a>An iterative greedy algorithm</h4>
<p class="first-para">We easily can convert our recursive procedure to an iterative one. The procedure RECURSIVE-ACTIVITY-SELECTOR is almost "tail recursive" (see <a href="DDU0045.html#508" target="_parent" class="chapterjump">Problem 7-4</a>): it ends with a recursive call to itself followed by a union operation. It is usually a straightforward task to transform a tail-recursive procedure to an iterative form; in fact, some compilers for certain programming languages perform this task automatically. As written, RECURSIVE-ACTIVITY-SELECTOR works for any subproblem <i class="emphasis">S<sub>ij</sub></i>, but we have seen that we need to consider only subproblems for which <i class="emphasis">j</i> = <i class="emphasis">n</i> + 1, i.e., subproblems that consist of the last activities to finish.</p>
<p class="para">The procedure GREEDY-ACTIVITY-SELECTOR is an iterative version of the procedure RECURSIVE-ACTIVITY-SELECTOR. It also assumes that the input activities are ordered by monotonically increasing finish time. It collects selected activities into a set <i class="emphasis">A</i> and returns this set when it is done.<a name="1163"></a><a name="IDX-377"></a>
</p>
<a name="1164"></a><a name="IDX-378"></a>
<div class="informalexample">
<pre class="literallayout-normal">
GREEDY-ACTIVITY-SELECTOR(<i class="emphasis">s, f</i>)
1 <i class="emphasis">n</i> <span class="unicode">&larr;</span> <i class="emphasis">length</i>[<i class="emphasis">s</i>]
2 <i class="emphasis">A</i> <span class="unicode">&larr;</span> {<i class="emphasis">a</i><sub>1</sub>}
3 <i class="emphasis">i</i> <span class="unicode">&larr;</span> 1
4 <b class="bold">for</b> m <span class="unicode">&larr;</span> 2 to <i class="emphasis">n</i>
5      <b class="bold">do if</b> <i class="emphasis">s<sub>m</sub></i> <span class="unicode">&ge;</span> <i class="emphasis">f<sub>i</sub></i>
6            <b class="bold">then</b> A <span class="unicode">&larr;</span> <i class="emphasis">A</i> <span class="unicode">&cup;</span> {<i class="emphasis">a<sub>m</sub></i>}
7                 <i class="emphasis">i</i> <span class="unicode">&larr;</span> <i class="emphasis">m</i>
8 <b class="bold">return</b> <i class="emphasis">A</i>
</pre>
</div>
<p class="para">The procedure works as follows. The variable <i class="emphasis">i</i> indexes the most recent addition to <i class="emphasis">A</i>, corresponding to the activity <i class="emphasis">a<sub>i</sub></i> in the recursive version. Since the activities are considered in order of monotonically increasing finish time, <i class="emphasis">f<sub>i</sub></i> is always the maximum finish time of any activity in <i class="emphasis">A</i>. That is,</p>
<div class="equation">
<a name="1165"></a><a name="ch16eq04"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(16.4)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig400_01.jpg" height="16" width="147" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">Lines 2<span class="unicode">-</span>3 select activity <i class="emphasis">a</i><sub>1</sub>, initialize <i class="emphasis">A</i> to contain just this activity, and initialize <i class="emphasis">i</i> to index this activity. The <b class="bold">for</b> loop of lines 4<span class="unicode">-</span>7 finds the earliest activity to finish in <i class="emphasis">S</i><sub><i class="emphasis">i.n</i>+1</sub>. The loop considers each activity <i class="emphasis">a<sub>m</sub></i> in turn and adds <i class="emphasis">a</i><i class="emphasis"><sub>m</sub></i> to <i class="emphasis">A</i> if it is compatible with all previously selected activities; such an activity is the earliest to finish in <i class="emphasis">S</i><sub><i class="emphasis">i.n</i>+1</sub>. To see if activity <i class="emphasis">a<sub>m</sub></i> is compatible with every activity currently in <i class="emphasis">A</i>, it suffices by equation (<a class="internaljump" href="#ch16eq04">16.4</a>) to check (line 5) that its start time <i class="emphasis">s<sub>m</sub></i> is not earlier than the finish time <i class="emphasis">f<sub>i</sub></i> of the activity most recently added to <i class="emphasis">A</i>. If activity <i class="emphasis">a<sub>m</sub></i> is compatible, then lines 6<span class="unicode">-</span>7 add activity <i class="emphasis">a<sub>m</sub></i> to <i class="emphasis">A</i> and set <i class="emphasis">i</i> to <i class="emphasis">m</i>. The set <i class="emphasis">A</i> returned by the call GREEDY-ACTIVITY-SELECTOR(<i class="emphasis">s, f</i>) is precisely the set returned by the call RECURSIVE-ACTIVITY-SELECTOR(<i class="emphasis">s, f</i>, 0, <i class="emphasis">n</i> + 1).</p>
<p class="para">Like the recursive version, GREEDY-ACTIVITY-SELECTOR schedules a set of <i class="emphasis">n</i> activities in <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) time, assuming that the activities were already sorted initially by their finish times.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 16.1-1</span></span><a name="1166"></a><a name="ch16ex02"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Give a dynamic-programming algorithm for the activity-selection problem, based on the recurrence (<a class="internaljump" href="#ch16eq03">16.3</a>). Have your algorithm compute the sizes <i class="emphasis">c</i>[<i class="emphasis">i, j</i>] as defined above and also produce the maximum-size subset <i class="emphasis">A</i> of activities. Assume that the inputs have been sorted as in equation (<a class="internaljump" href="#ch16eq01">16.1</a>). Compare the running time of your solution to the running time of GREEDY-ACTIVITY-SELECTOR.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 16.1-2</span></span><a name="1167"></a><a name="ch16ex03"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that instead of always selecting the first activity to finish, we instead select the last activity to start that is compatible with all previously selected activities. De<a name="1168"></a><a name="IDX-379"></a>scribe how this approach is a greedy algorithm, and prove that it yields an optimal solution.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 16.1-3</span></span><a name="1169"></a><a name="ch16ex04"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that we have a set of activities to schedule among a large number of lecture halls. We wish to schedule all the activities using as few lecture halls as possible. Give an efficient greedy algorithm to determine which activity should use which lecture hall.</p>
<p class="last-para">(This is also known as the <b class="bold"><i class="emphasis">interval-graph coloring problem</i></b>. We can create an interval graph whose vertices are the given activities and whose edges connect incompatible activities. The smallest number of colors required to color every vertex so that no two adjacent vertices are given the same color corresponds to finding the fewest lecture halls needed to schedule all of the given activities.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 16.1-4</span></span><a name="1170"></a><a name="ch16ex05"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Not just any greedy approach to the activity-selection problem produces a maximum-size set of mutually compatible activities. Give an example to show that the approach of selecting the activity of least duration from those that are compatible with previously selected activities does not work. Do the same for the approaches of always selecting the compatible activity that overlaps the fewest other remaining activities and always selecting the compatible remaining activity with the earliest start time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
<div class="footnotes">
<div class="footnote">
<p>
<sup>[<a name="ftn.N833" href="#N833">1</a>]</sup>We will sometimes speak of the sets <i class="emphasis">S<sub>ij</sub></i> as subproblems rather than just sets of activities. It will always be clear from the context whether we are referring to <i class="emphasis">S<sub>ij</sub></i> as a set of activities or the subproblem whose input is that set.</p>
</div>
</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0093.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0095.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
