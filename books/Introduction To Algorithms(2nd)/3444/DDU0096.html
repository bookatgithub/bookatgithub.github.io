<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>16.3 Huffman codes</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0095.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0097.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch16"></a>
<div class="section">
<h2 class="first-section-title">
<a name="1188"></a><a name="ch16lev1sec3"></a><span class="section-titlelabel">16.3 </span>Huffman codes</h2>
<a name="1189"></a><a name="IDX-385"></a>
<p class="para">Huffman codes are a widely used and very effective technique for compressing data; savings of 20% to 90% are typical, depending on the characteristics of the data being compressed. We consider the data to be a sequence of characters. Huffman's greedy algorithm uses a table of the frequencies of occurrence of the characters to build up an optimal way of representing each character as a binary string.</p>
<p class="para">Suppose we have a 100,000-character data file that we wish to store compactly. We observe that the characters in the file occur with the frequencies given by <a class="internaljump" href="#ch16fig03">Figure 16.3</a>. That is, only six different characters appear, and the character <span class="fixed">a</span> occurs 45,000 times.</p>
<div class="miscfigure">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start Figure" border="0"></b></font></td>
</tr>
</table>
<a name="1190"></a><a name="ch16fig03"></a>
<div class="miscfigure-informaltable">
<table border="0">
<thead>
<tr valign="top">
<th class="th" scope="col" align="left">&nbsp;</th><th class="th" scope="col" align="center">
<p class="table-para">
<span class="fixed">a</span>
</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">
<span class="fixed">b</span>
</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">
<span class="fixed">c</span>
</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">
<span class="fixed">d</span>
</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">
<span class="fixed">e</span>
</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">
<span class="fixed">f</span>
</p>
</th>
</tr>
<tr>
<td colspan="7">
<hr>
</td>
</tr>
</thead>
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">Frequency (in thousands)</p>
</td><td class="td" align="center">
<p class="table-para">45</p>
</td><td class="td" align="center">
<p class="table-para">13</p>
</td><td class="td" align="center">
<p class="table-para">12</p>
</td><td class="td" align="center">
<p class="table-para">16</p>
</td><td class="td" align="center">
<p class="table-para">9</p>
</td><td class="td" align="center">
<p class="table-para">5</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">Fixed-length codeword</p>
</td><td class="td" align="center">
<p class="table-para">000</p>
</td><td class="td" align="center">
<p class="table-para">001</p>
</td><td class="td" align="center">
<p class="table-para">010</p>
</td><td class="td" align="center">
<p class="table-para">011</p>
</td><td class="td" align="center">
<p class="table-para">100</p>
</td><td class="td" align="center">
<p class="table-para">101</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">Variable-length codeword</p>
</td><td class="td" align="center">
<p class="table-para">0</p>
</td><td class="td" align="center">
<p class="table-para">101</p>
</td><td class="td" align="center">
<p class="table-para">100</p>
</td><td class="td" align="center">
<p class="table-para">111</p>
</td><td class="td" align="center">
<p class="table-para">1101</p>
</td><td class="td" align="center">
<p class="table-para">1100</p>
</td>
</tr>
</tbody>
</table>
</div>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End Figure" border="0"></b></font></td>
</tr>
</table>
<br style="line-height: 1">
<span class="miscfigure-title"><span class="figure-titlelabel">Figure 16.3: </span>A character-coding problem. A data file of 100,000 characters contains only the characters <span class="fixed">a<span class="unicode">-</span>f</span>, with the frequencies indicated. If each character is assigned a 3-bit codeword, the file can be encoded in 300,000 bits. Using the variable-length code shown, the file can be encoded in 224,000 bits.</span>
</div>
<p class="para">There are many ways to represent such a file of information. We consider the problem of designing a <b class="bold"><i class="emphasis">binary character code</i></b> (or <b class="bold"><i class="emphasis">code</i></b> for short) wherein each character is represented by a unique binary string. If we use a <b class="bold"><i class="emphasis">fixed-length code</i></b>, we need 3 bits to represent six characters: <span class="fixed">a</span> = 000, <span class="fixed">b</span> = 001, ..., <span class="fixed">f</span> = 101. This method requires 300,000 bits to code the entire file. Can we do better?</p>
<p class="para">A <b class="bold"><i class="emphasis">variable-length code</i></b> can do considerably better than a fixed-length code, by giving frequent characters short codewords and infrequent characters long codewords. <a class="internaljump" href="#ch16fig03">Figure 16.3</a> shows such a code; here the 1-bit string 0 represents <span class="fixed">a</span>, and the 4-bit string 1100 represents <span class="fixed">f</span>. This code requires</p>
<p class="para">(45 <span class="unicode">&middot;</span> 1 + 13 <span class="unicode">&middot;</span> 3 + 12 <span class="unicode">&middot;</span> 3 + 16 <span class="unicode">&middot;</span> 3 + 9 <span class="unicode">&middot;</span> 4 + 5 <span class="unicode">&middot;</span> 4) <span class="unicode">&middot;</span> 1,000 = 224,000 bits</p>
<p class="para">to represent the file, a savings of approximately 25%. In fact, this is an optimal character code for this file, as we shall see.</p>
<div class="section">
<h4 class="sect4-title">
<a name="1191"></a><a name="ch16lev3sec9"></a>Prefix codes</h4>
<p class="first-para">We consider here only codes in which no codeword is also a prefix of some other codeword. Such codes are called <b class="bold"><i class="emphasis">prefix codes</i></b>.<sup>[<a name="N296" href="#ftn.N296">2</a>]</sup> It is possible to show (although we won't do so here) that the optimal data compression achievable by a character code can always be achieved with a prefix code, so there is no loss of generality in restricting attention to prefix codes.</p>
<p class="para">Encoding is always simple for any binary character code; we just concatenate the codewords representing each character of the file. For example, with the variable-length prefix code of <a class="internaljump" href="#ch16fig03">Figure 16.3</a>, we code the 3-character file <span class="fixed">abc</span> as 0<span class="unicode">&middot;</span>101<span class="unicode">&middot;</span>100 = 0101100, where we use "<span class="unicode">&middot;</span>" to denote concatenation.<a name="1192"></a><a name="IDX-386"></a>
</p>
<p class="para">Prefix codes are desirable because they simplify decoding. Since no codeword is a prefix of any other, the codeword that begins an encoded file is unambiguous. We can simply identify the initial codeword, translate it back to the original character, and repeat the decoding process on the remainder of the encoded file. In our example, the string 001011101 parses uniquely as 0 <span class="unicode">&middot;</span> 0 <span class="unicode">&middot;</span> 101 <span class="unicode">&middot;</span> 1101, which decodes to <span class="fixed">aabe</span>.</p>
<p class="para">The decoding process needs a convenient representation for the prefix code so that the initial codeword can be easily picked off. A binary tree whose leaves are the given characters provides one such representation. We interpret the binary codeword for a character as the path from the root to that character, where 0 means "go to the left child" and 1 means "go to the right child." <a class="internaljump" href="#ch16fig04">Figure 16.4</a> shows the trees for the two codes of our example. Note that these are not binary search trees, since the leaves need not appear in sorted order and internal nodes do not contain character keys.</p>
<div class="figure">
<a name="1193"></a><a name="ch16fig04"></a><span class="figuremediaobject"><a href="images/fig409%5F01%5F0%2Ejpg" NAME="IMG_509" target="_parent"><img src="images/fig409_01.jpg" height="151" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 16.4: </span>Trees corresponding to the coding schemes in Figure 16.3. Each leaf is labeled with a character and its frequency of occurrence. Each internal node is labeled with the sum of the frequencies of the leaves in its subtree. <i class="emphasis">(a)</i> The tree corresponding to the fixed-length code <span class="fixed">a</span> = 000, ..., <span class="fixed">f</span> = 101. <i class="emphasis">(b)</i> The tree corresponding to the optimal prefix code <span class="fixed">a</span> = 0, <span class="fixed">b</span> = 101, ..., <span class="fixed">f</span> = 1100.</span>
</div>
<p class="para">An optimal code for a file is always represented by a <i class="emphasis">full</i> binary tree, in which every nonleaf node has two children (see <a class="internaljump" href="#ch16ex16">Exercise 16.3-1</a>). The fixed-length code in our example is not optimal since its tree, shown in <a class="internaljump" href="#ch16fig04">Figure 16.4(a)</a>, is not a full binary tree: there are codewords beginning 10..., but none beginning 11.... Since we can now restrict our attention to full binary trees, we can say that if <i class="emphasis">C</i> is the alphabet from which the characters are drawn and all character frequencies are positive, then the tree for an optimal prefix code has exactly |<i class="emphasis">C</i>| leaves, one for each letter of the alphabet, and exactly |<i class="emphasis">C</i>| - 1 internal nodes (see <a href="DDU0251.html#3396" target="_parent" class="chapterjump">Exercise B.5-3</a>).</p>
<p class="para">Given a tree <i class="emphasis">T</i> corresponding to a prefix code, it is a simple matter to compute the number of bits required to encode a file. For each character <i class="emphasis">c</i> in the alphabet <i class="emphasis">C</i>, let <i class="emphasis">f</i> (<i class="emphasis">c</i>) denote the frequency of <i class="emphasis">c</i> in the file and let <i class="emphasis">d<sub>T</sub></i>(<i class="emphasis">c</i>) denote the depth of <i class="emphasis">c</i>'s leaf in the tree. Note that <i class="emphasis">d<sub>T</sub></i>(<i class="emphasis">c</i>) is also the length of the codeword for character <i class="emphasis">c</i>. The number of bits required to encode a file is thus</p>
<div class="equation">
<a name="1194"></a><a name="ch16eq05"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(16.5)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig408_01.jpg" height="31" width="143" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="last-para">which we define as the <b class="bold"><i class="emphasis">cost</i></b> of the tree <i class="emphasis">T</i>.<a name="1195"></a><a name="IDX-387"></a>
</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1196"></a><a name="ch16lev3sec10"></a>Constructing a Huffman code</h4>
<p class="first-para">Huffman invented a greedy algorithm that constructs an optimal prefix code called a <b class="bold"><i class="emphasis">Huffman code</i></b>. Keeping in line with our observations in <a href="DDU0095.html#1171" target="_parent" class="chapterjump">Section 16.2</a>, its proof of correctness relies on the greedy-choice property and optimal substructure. Rather than demonstrating that these properties hold and then developing pseudocode, we present the pseudocode first. Doing so will help clarify how the algorithm makes greedy choices.</p>
<p class="para">In the pseudocode that follows, we assume that <i class="emphasis">C</i> is a set of <i class="emphasis">n</i> characters and that each character <i class="emphasis">c</i> <span class="unicode">&isin;</span> <i class="emphasis">C</i> is an object with a defined frequency <i class="emphasis">f</i> [<i class="emphasis">c</i>]. The algorithm builds the tree <i class="emphasis">T</i> corresponding to the optimal code in a bottom-up manner. It begins with a set of |<i class="emphasis">C</i>| leaves and performs a sequence of |<i class="emphasis">C</i>| - 1 "merging" operations to create the final tree. A min-priority queue <i class="emphasis">Q</i>, keyed on <i class="emphasis">f</i> , is used to identify the two least-frequent objects to merge together. The result of the merger of two objects is a new object whose frequency is the sum of the frequencies of the two objects that were merged.<a name="1197"></a><a name="IDX-388"></a>
</p>
<div class="informalexample">
<pre class="literallayout-normal">
HUFFMAN(<i class="emphasis">C</i>)
1  <i class="emphasis">n</i> <span class="unicode">&larr;</span> |<i class="emphasis">C</i>|
2  <i class="emphasis">Q</i> <span class="unicode">&larr;</span> <i class="emphasis">C</i>
3  <b class="bold">for</b> <i class="emphasis">i</i> 1 <b class="bold">to</b> <i class="emphasis">n</i> - 1
4       <b class="bold">do</b> allocate a new node <i class="emphasis">z</i>
5          <i class="emphasis">left</i>[<i class="emphasis">z</i>] <span class="unicode">&larr;</span> <i class="emphasis">x</i> <span class="unicode">&larr;</span> EXTRACT-MIN (<i class="emphasis">Q</i>)
6          <i class="emphasis">right</i>[<i class="emphasis">z</i>] <span class="unicode">&larr;</span> <i class="emphasis">y</i> <span class="unicode">&larr;</span> EXTRACT-MIN (<i class="emphasis">Q</i>)
7          <i class="emphasis">f</i> [<i class="emphasis">z</i>] <span class="unicode">&larr;</span> <i class="emphasis">f</i> [<i class="emphasis">x</i>] + <i class="emphasis">f</i> [<i class="emphasis">y</i>]
8          INSERT(<i class="emphasis">Q, z</i>)
9  <b class="bold">return</b> EXTRACT-MIN(<i class="emphasis">Q</i>)   <span class="unicode">&#9657;</span>Return the root of the tree.
</pre>
</div>
<p class="para">For our example, Huffman's algorithm proceeds as shown in <a class="internaljump" href="#ch16fig05">Figure 16.5</a>. Since there are 6 letters in the alphabet, the initial queue size is <i class="emphasis">n</i> = 6, and 5 merge steps are required to build the tree. The final tree represents the optimal prefix code. The codeword for a letter is the sequence of edge labels on the path from the root to the letter.</p>
<div class="figure">
<a name="1198"></a><a name="ch16fig05"></a><span class="figuremediaobject"><a href="images/fig411%5F01%5F0%2Ejpg" NAME="IMG_511" target="_parent"><img src="images/fig411_01.jpg" height="237" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 16.5: </span>The steps of Huffman's algorithm for the frequencies given in Figure 16.3. Each part shows the contents of the queue sorted into increasing order by frequency. At each step, the two trees with lowest frequencies are merged. Leaves are shown as rectangles containing a character and its frequency. Internal nodes are shown as circles containing the sum of the frequencies of its children. An edge connecting an internal node with its children is labeled 0 if it is an edge to a left child and 1 if it is an edge to a right child. The codeword for a letter is the sequence of labels on the edges connecting the root to the leaf for that letter. <i class="emphasis">(a)</i> The initial set of <i class="emphasis">n</i> = 6 nodes, one for each letter. <i class="emphasis">(b)</i><span class="unicode">-</span><i class="emphasis">(e)</i> Intermediate stages. <i class="emphasis">(f)</i> The final tree.</span>
</div>
<p class="para">Line 2 initializes the min-priority queue <i class="emphasis">Q</i> with the characters in <i class="emphasis">C</i>. The <b class="bold">for</b> loop in lines 3<span class="unicode">-</span>8 repeatedly extracts the two nodes <i class="emphasis">x</i> and <i class="emphasis">y</i> of lowest frequency from the queue, and replaces them in the queue with a new node <i class="emphasis">z</i> representing their merger. The frequency of <i class="emphasis">z</i> is computed as the sum of the frequencies of <i class="emphasis">x</i> and <i class="emphasis">y</i> in line 7. The node <i class="emphasis">z</i> has <i class="emphasis">x</i> as its left child and <i class="emphasis">y</i> as its right child. (This order is arbitrary; switching the left and right child of any node yields a different code of the same cost.) After <i class="emphasis">n</i> - 1 mergers, the one node left in the queue<span class="unicode">-</span>the root of the code tree<span class="unicode">-</span>is returned in line 9.</p>
<p class="last-para">The analysis of the running time of Huffman's algorithm assumes that <i class="emphasis">Q</i> is implemented as a binary min-heap (see <a href="DDU0035.html#382" target="_parent" class="chapterjump">Chapter 6</a>). For a set <i class="emphasis">C</i> of <i class="emphasis">n</i> characters, the initialization of <i class="emphasis">Q</i> in line 2 can be performed in <i class="emphasis">O</i> (<i class="emphasis">n</i>) time using the BUILD-MIN-HEAP procedure in <a href="DDU0038.html#407" target="_parent" class="chapterjump">Section 6.3</a>. The <b class="bold">for</b> loop in lines 3<span class="unicode">-</span>8 is executed exactly <i class="emphasis">n</i> - 1 times, and since each heap operation requires time <i class="emphasis">O</i> (lg <i class="emphasis">n</i>), the loop contributes <i class="emphasis">O</i> (<i class="emphasis">n</i> lg <i class="emphasis">n</i>) to the running time. Thus, the total running time of HUFFMAN on a set of <i class="emphasis">n</i> characters is <i class="emphasis">O</i> (<i class="emphasis">n</i> lg <i class="emphasis">n</i>).</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1199"></a><a name="ch16lev3sec11"></a>Correctness of Huffman's algorithm</h4>
<p class="first-para">To prove that the greedy algorithm HUFFMAN is correct, we show that the problem of determining an optimal prefix code exhibits the greedy-choice and optimal-substructure properties. The next lemma shows that the greedy-choice property holds.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 16.2</span></span><a name="1200"></a><a name="ch16ex13"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">C</i> be an alphabet in which each character <i class="emphasis">c</i> <span class="unicode">&isin;</span> <i class="emphasis">C</i> has frequency <i class="emphasis">f</i> [<i class="emphasis">c</i>]. Let <i class="emphasis">x</i> and <i class="emphasis">y</i> be two characters in <i class="emphasis">C</i> having the lowest frequencies. Then there exists an <a name="1201"></a><a name="IDX-389"></a>optimal prefix code for <i class="emphasis">C</i> in which the codewords for <i class="emphasis">x</i> and <i class="emphasis">y</i> have the same length and differ only in the last bit.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> The idea of the proof is to take the tree <i class="emphasis">T</i> representing an arbitrary optimal prefix code and modify it to make a tree representing another optimal prefix code such that the characters <i class="emphasis">x</i> and <i class="emphasis">y</i> appear as sibling leaves of maximum depth in the new tree. If we can do this, then their codewords will have the same length and differ only in the last bit.<a name="1202"></a><a name="IDX-390"></a>
</p>
<p class="para">Let <i class="emphasis">a</i> and <i class="emphasis">b</i> be two characters that are sibling leaves of maximum depth in <i class="emphasis">T</i>. Without loss of generality, we assume that <i class="emphasis">f</i>[<i class="emphasis">a</i>] <span class="unicode">&le;</span> <i class="emphasis">f</i>[<i class="emphasis">b</i>] and <i class="emphasis">f</i>[<i class="emphasis">x</i>] <span class="unicode">&le;</span> <i class="emphasis">f</i>[<i class="emphasis">y</i>]. Since <i class="emphasis">f</i>[<i class="emphasis">x</i>] and <i class="emphasis">f</i>[<i class="emphasis">y</i>] are the two lowest leaf frequencies, in order, and <i class="emphasis">f</i>[<i class="emphasis">a</i>] and <i class="emphasis">f</i>[<i class="emphasis">b</i>] are two arbitrary frequencies, in order, we have <i class="emphasis">f</i> [<i class="emphasis">x</i>] <span class="unicode">&le;</span> <i class="emphasis">f</i>[<i class="emphasis">a</i>] and <i class="emphasis">f</i>[<i class="emphasis">y</i>] <span class="unicode">&le;</span> <i class="emphasis">f</i>[<i class="emphasis">b</i>]. As shown in <a class="internaljump" href="#ch16fig06">Figure 16.6</a>, we exchange the positions in <i class="emphasis">T</i> of <i class="emphasis">a</i> and <i class="emphasis">x</i> to produce a tree <i class="emphasis">T</i><span class="unicode">&prime;</span>, and then we exchange the positions in <i class="emphasis">T</i><span class="unicode">&prime;</span> of <i class="emphasis">b</i> and <i class="emphasis">y</i> to produce a tree <i class="emphasis">T</i><span class="unicode">&Prime;</span>. By equation (<a class="internaljump" href="#ch16eq05">16.5</a>), the difference in cost between <i class="emphasis">T</i> and <i class="emphasis">T</i><span class="unicode">&prime;</span> is</p>
<div class="informalequation">
<span class="equation-image"><a href="images/fig412%5F02%2Ejpg" NAME="IMG_512" target="_parent"><img src="images/fig412_02.jpg" height="105" width="400" alt="Click To expand" border="0"></a></span>
</div>
<p class="para">
<div class="figure">
<a name="1203"></a><a name="ch16fig06"></a><span class="figuremediaobject"><a href="images/fig412%5F01%5F0%2Ejpg" NAME="IMG_513" target="_parent"><img src="images/fig412_01.jpg" height="58" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 16.6: </span>An illustration of the key step in the proof of Lemma 16.2. In the optimal tree <i class="emphasis">T</i>, leaves <i class="emphasis">a</i> and <i class="emphasis">b</i> are two of the deepest leaves and are siblings. Leaves <i class="emphasis">x</i> and <i class="emphasis">y</i> are the two leaves that Huffman's algorithm merges together first; they appear in arbitrary positions in <i class="emphasis">T</i> . Leaves <i class="emphasis">a</i> and <i class="emphasis">x</i> are swapped to obtain tree <i class="emphasis">T</i><span class="unicode">&prime;</span>. Then, leaves <i class="emphasis">b</i> and <i class="emphasis">y</i> are swapped to obtain tree <i class="emphasis">T</i><span class="unicode">&Prime;</span>. Since each swap does not increase the cost, the resulting tree <i class="emphasis">T</i><span class="unicode">&Prime;</span> is also an optimal tree.</span>
</div>
</p>
<p class="last-para">because both <i class="emphasis">f</i>[<i class="emphasis">a</i>] - <i class="emphasis">f</i>[<i class="emphasis">x</i>] and <i class="emphasis">d<sub>T</sub></i> (<i class="emphasis">a</i>) - <i class="emphasis">d<sub>T</sub></i> (<i class="emphasis">x</i>) are nonnegative. More specifically, <i class="emphasis">f</i>[<i class="emphasis">a</i>] - <i class="emphasis">f</i>[<i class="emphasis">x</i>] is nonnegative because <i class="emphasis">x</i> is a minimum-frequency leaf, and <i class="emphasis">d<sub>T</sub></i> (<i class="emphasis">a</i>) - <i class="emphasis">d<sub>T</sub></i> (<i class="emphasis">x</i>) is nonnegative because <i class="emphasis">a</i> is a leaf of maximum depth in <i class="emphasis">T</i>. Similarly, exchanging <i class="emphasis">y</i> and <i class="emphasis">b</i> does not increase the cost, and so <i class="emphasis">B</i>(<i class="emphasis">T</i><span class="unicode">&prime;</span>) - <i class="emphasis">B</i>(<i class="emphasis">T</i><span class="unicode">&Prime;</span>) is nonnegative. Therefore, <i class="emphasis">B</i>(<i class="emphasis">T</i><span class="unicode">&Prime;</span>) <span class="unicode">&le;</span> <i class="emphasis">B</i>(<i class="emphasis">T</i>), and since <i class="emphasis">T</i> is optimal, <i class="emphasis">B</i>(<i class="emphasis">T</i>) <span class="unicode">&le;</span> <i class="emphasis">B</i>(<i class="emphasis">T</i><span class="unicode">&Prime;</span>), which implies <i class="emphasis">B</i>(<i class="emphasis">T</i><span class="unicode">&Prime;</span>) = <i class="emphasis">B</i>(<i class="emphasis">T</i>). Thus, <i class="emphasis">T</i><span class="unicode">&Prime;</span> is an optimal tree in which <i class="emphasis">x</i> and <i class="emphasis">y</i> appear as sibling leaves of maximum depth, from which the lemma follows.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">
<a class="internaljump" href="#ch16ex13">Lemma 16.2</a> implies that the process of building up an optimal tree by mergers can, without loss of generality, begin with the greedy choice of merging together those two characters of lowest frequency. Why is this a greedy choice? We can view the cost of a single merger as being the sum of the frequencies of the two items being merged. <a class="internaljump" href="#ch16ex18">Exercise 16.3-3</a> shows that the total cost of the tree constructed is the sum of the costs of its mergers. Of all possible mergers at each step, HUFFMAN chooses the one that incurs the least cost.<a name="1204"></a><a name="IDX-391"></a>
</p>
<p class="para">The next lemma shows that the problem of constructing optimal prefix codes has the optimal-substructure property.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 16.3</span></span><a name="1205"></a><a name="ch16ex14"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">C</i> be a given alphabet with frequency <i class="emphasis">f</i>[<i class="emphasis">c</i>] defined for each character <i class="emphasis">c</i> <span class="unicode">&isin;</span> <i class="emphasis">C</i>. Let <i class="emphasis">x</i> and <i class="emphasis">y</i> be two characters in <i class="emphasis">C</i> with minimum frequency. Let <i class="emphasis">C</i><span class="unicode">&prime;</span> be the alphabet <i class="emphasis">C</i> with characters <i class="emphasis">x, y</i> removed and (new) character <i class="emphasis">z</i> added, so that <i class="emphasis">C</i><span class="unicode">&prime;</span> = <i class="emphasis">C</i> - {<i class="emphasis">x, y</i>} <span class="unicode">&cup;</span> {<i class="emphasis">z</i>}; define <i class="emphasis">f</i> for <i class="emphasis">C</i><span class="unicode">&prime;</span> as for <i class="emphasis">C</i>, except that <i class="emphasis">f</i>[<i class="emphasis">z</i>] = <i class="emphasis">f</i>[<i class="emphasis">x</i>] + <i class="emphasis">f</i>[<i class="emphasis">y</i>]. Let <i class="emphasis">T</i><span class="unicode">&prime;</span> be any tree representing an optimal prefix code for the alphabet <i class="emphasis">C</i><span class="unicode">&prime;</span>. Then the tree <i class="emphasis">T</i>, obtained from <i class="emphasis">T</i><span class="unicode">&prime;</span> by replacing the leaf node for <i class="emphasis">z</i> with an internal node having <i class="emphasis">x</i> and <i class="emphasis">y</i> as children, represents an optimal prefix code for the alphabet <i class="emphasis">C</i>.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> We first show that the cost <i class="emphasis">B</i>(<i class="emphasis">T</i>) of tree <i class="emphasis">T</i> can be expressed in terms of the cost <i class="emphasis">B</i>(<i class="emphasis">T</i><span class="unicode">&prime;</span>) of tree <i class="emphasis">T</i><span class="unicode">&prime;</span> by considering the component costs in equation (<a class="internaljump" href="#ch16eq05">16.5</a>). For each <i class="emphasis">c</i> <span class="unicode">&isin;</span> <i class="emphasis">C</i> - {<i class="emphasis">x, y</i>}, we have <i class="emphasis">d<sub>T</sub></i> (<i class="emphasis">c</i>) = <i class="emphasis">d<sub>T</sub></i><span class="unicode">&prime;</span> (<i class="emphasis">c</i>), and hence <i class="emphasis">f</i>[<i class="emphasis">c</i>]<i class="emphasis">d<sub>T</sub></i>(<i class="emphasis">c</i>) = <i class="emphasis">f</i>[<i class="emphasis">c</i>]<i class="emphasis">d<sub><span class="unicode">&prime;</span></sub></i>(<i class="emphasis">c</i>). Since <i class="emphasis">d<sub>T</sub></i> (<i class="emphasis">x</i>) = <i class="emphasis">d<sub>T</sub></i> (<i class="emphasis">y</i>) = <i class="emphasis">d<sub><span class="unicode">&prime;</span></sub></i>(<i class="emphasis">z</i>) + 1, we have</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">f</i>[<i class="emphasis">x</i>]<i class="emphasis">d<sub>T</sub></i> (<i class="emphasis">x</i>) + <i class="emphasis">f</i>[<i class="emphasis">y</i>]<i class="emphasis">d<sub>T</sub></i> (<i class="emphasis">y</i>)</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">(<i class="emphasis">f</i>[<i class="emphasis">x</i>] + <i class="emphasis">f</i>[<i class="emphasis">y</i>])(<i class="emphasis">d<sub><span class="unicode">&prime;</span></sub></i> (<i class="emphasis">z</i>) + 1)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">f</i>[<i class="emphasis">z</i>]<i class="emphasis">d<sub><span class="unicode">&prime;</span></sub></i>(<i class="emphasis">z</i>) + (<i class="emphasis">f</i>[<i class="emphasis">x</i>] + <i class="emphasis">f</i>[<i class="emphasis">y</i>]),</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">from which we conclude that</p>
<p class="para">
<i class="emphasis">B</i>(<i class="emphasis">T</i>) = <i class="emphasis">B</i>(<i class="emphasis">T</i><span class="unicode">&prime;</span>) + <i class="emphasis">f</i>[<i class="emphasis">x</i>] + <i class="emphasis">f</i>[<i class="emphasis">y</i>]</p>
<p class="para">or, equivalently,</p>
<p class="para">
<i class="emphasis">B</i>(<i class="emphasis">T</i><span class="unicode">&prime;</span>) = <i class="emphasis">B</i>(<i class="emphasis">T</i>) - <i class="emphasis">f</i>[<i class="emphasis">x</i>] - <i class="emphasis">f</i>[<i class="emphasis">y</i>].</p>
<p class="para">We now prove the lemma by contradiction. Suppose that <i class="emphasis">T</i> does not represent an optimal prefix code for <i class="emphasis">C</i>. Then there exists a tree <i class="emphasis">T</i><span class="unicode">&Prime;</span> such that <i class="emphasis">B</i>(<i class="emphasis">T</i><span class="unicode">&Prime;</span>) <span class="unicode">&lt;</span> <i class="emphasis">B</i>(<i class="emphasis">T</i>). Without loss of generality (by <a class="internaljump" href="#ch16ex13">Lemma 16.2</a>), <i class="emphasis">T</i><span class="unicode">&Prime;</span> has <i class="emphasis">x</i> and <i class="emphasis">y</i> as siblings. Let <i class="emphasis">T</i><span class="unicode">&prime;</span><span class="unicode">&prime;</span><span class="unicode">&prime;</span> be the tree <i class="emphasis">T</i><span class="unicode">&Prime;</span> with the common parent of <i class="emphasis">x</i> and <i class="emphasis">y</i> replaced by a leaf <i class="emphasis">z</i> with frequency <i class="emphasis">f</i>[<i class="emphasis">z</i>] = <i class="emphasis">f</i>[<i class="emphasis">x</i>] + <i class="emphasis">f</i>[<i class="emphasis">y</i>]. Then</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">B</i>(<i class="emphasis">T</i><span class="unicode">&#8244;</span>)</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">B</i>(<i class="emphasis">T</i><span class="unicode">&Prime;</span>) - <i class="emphasis">f</i>[<i class="emphasis">x</i>] - <i class="emphasis">f</i>[<i class="emphasis">y</i>]</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&lt;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">B</i>(<i class="emphasis">T</i>) - <i class="emphasis">f</i>[<i class="emphasis">x</i>] - <i class="emphasis">f</i>[<i class="emphasis">y</i>]</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">B</i>(<i class="emphasis">T</i><span class="unicode">&prime;</span>),</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="last-para">yielding a contradiction to the assumption that <i class="emphasis">T</i><span class="unicode">&prime;</span> represents an optimal prefix code for <i class="emphasis">C</i><span class="unicode">&prime;</span>. Thus, <i class="emphasis">T</i> must represent an optimal prefix code for the alphabet <i class="emphasis">C</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 16.4</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Procedure HUFFMAN produces an optimal prefix code.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Immediate from <a class="internaljump" href="#ch16ex13">Lemmas 16.2</a> and <a class="internaljump" href="#ch16ex14">16.3</a>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1206"></a><a name="IDX-392"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 16.3-1</span></span><a name="1207"></a><a name="ch16ex16"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Prove that a binary tree that is not full cannot correspond to an optimal prefix code.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 16.3-2</span></span><a name="1208"></a><a name="ch16ex17"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">What is an optimal Huffman code for the following set of frequencies, based on the first 8 Fibonacci numbers?</p>
<p class="last-para">
<span class="fixed">a:</span>1 <span class="fixed">b:</span>1 <span class="fixed">c:</span>2 <span class="fixed">d:</span>3 <span class="fixed">e:</span>5 <span class="fixed">f:</span>8 <span class="fixed">g:</span>13 <span class="fixed">h:</span>21</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">Can you generalize your answer to find the optimal code when the frequencies are the first <i class="emphasis">n</i> Fibonacci numbers?</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 16.3-3</span></span><a name="1209"></a><a name="ch16ex18"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Prove that the total cost of a tree for a code can also be computed as the sum, over all internal nodes, of the combined frequencies of the two children of the node.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 16.3-4</span></span><a name="1210"></a><a name="ch16ex19"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Prove that if we order the characters in an alphabet so that their frequencies are monotonically decreasing, then there exists an optimal code whose codeword lengths are monotonically increasing.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 16.3-5</span></span><a name="1211"></a><a name="ch16ex20"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose we have an optimal prefix code on a set <i class="emphasis">C</i> = {0, 1, ..., <i class="emphasis">n</i> - 1} of characters and we wish to transmit this code using as few bits as possible. Show how to represent any optimal prefix code on <i class="emphasis">C</i> using only 2<i class="emphasis">n</i> - 1 + <i class="emphasis">n</i> <span class="unicode">&lceil;</span>lg <i class="emphasis">n</i><span class="unicode">&rceil;</span> bits. (<i class="emphasis">Hint:</i> Use 2<i class="emphasis">n</i> - 1 bits to specify the structure of the tree, as discovered by a walk of the tree.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 16.3-6</span></span><a name="1212"></a><a name="ch16ex21"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Generalize Huffman's algorithm to ternary codewords (i.e., codewords using the symbols 0, 1, and 2), and prove that it yields optimal ternary codes.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 16.3-7</span></span><a name="1213"></a><a name="ch16ex22"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose a data file contains a sequence of 8-bit characters such that all 256 characters are about as common: the maximum character frequency is less than twice the minimum character frequency. Prove that Huffman coding in this case is no more efficient than using an ordinary 8-bit fixed-length code.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 16.3-8</span></span><a name="1214"></a><a name="ch16ex23"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that no compression scheme can expect to compress a file of randomly chosen 8-bit characters by even a single bit. (<i class="emphasis">Hint:</i> Compare the number of files with the number of possible encoded files.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
<div class="footnotes">
<div class="footnote">
<p>
<sup>[<a name="ftn.N296" href="#N296">2</a>]</sup>Perhaps "prefix-free codes" would be a better name, but the term "prefix codes" is standard in the literature.</p>
</div>
</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0095.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0097.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
