<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>17.4 Dynamic tables</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0103.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0105.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch17"></a>
<div class="section">
<h2 class="first-section-title">
<a name="1291"></a><a name="ch17lev1sec4"></a><span class="section-titlelabel">17.4 </span>Dynamic tables</h2>
<p class="first-para">In some applications, we do not know in advance how many objects will be stored in a table. We might allocate space for a table, only to find out later that it is not enough. The table must then be reallocated with a larger size, and all objects stored in the original table must be copied over into the new, larger table. Similarly, if many objects have been deleted from the table, it may be worthwhile to reallocate the table with a smaller size. In this section, we study this problem of dynamically expanding and contracting a table. Using amortized analysis, we shall show that the <a name="1292"></a><a name="IDX-417"></a>amortized cost of insertion and deletion is only <i class="emphasis">O</i>(1), even though the actual cost of an operation is large when it triggers an expansion or a contraction. Moreover, we shall see how to guarantee that the unused space in a dynamic table never exceeds a constant fraction of the total space.</p>
<p class="para">We assume that the dynamic table supports the operations TABLE-INSERT and TABLE-DELETE. TABLE-INSERT inserts into the table an item that occupies a single <b class="bold"><i class="emphasis">slot</i></b>, that is, a space for one item. Likewise, TABLE-DELETE can be thought of as removing an item from the table, thereby freeing a slot. The details of the data-structuring method used to organize the table are unimportant; we might use a stack (<a href="DDU0058.html#622" target="_parent" class="chapterjump">Section 10.1</a>), a heap (<a href="DDU0035.html#382" target="_parent" class="chapterjump">Chapter 6</a>), or a hash table (<a href="DDU0063.html#698" target="_parent" class="chapterjump">Chapter 11</a>). We might also use an array or collection of arrays to implement object storage, as we did in <a href="DDU0060.html#658" target="_parent" class="chapterjump">Section 10.3.</a>
</p>
<p class="para">We shall find it convenient to use a concept introduced in our analysis of hashing (<a href="DDU0063.html#698" target="_parent" class="chapterjump">Chapter 11</a>). We define the <b class="bold"><i class="emphasis">load factor</i></b> <span class="unicode">&alpha;</span> (<i class="emphasis">T</i>) of a nonempty table <i class="emphasis">T</i> to be the number of items stored in the table divided by the size (number of slots) of the table. We assign an empty table (one with no items) size 0, and we define its load factor to be 1. If the load factor of a dynamic table is bounded below by a constant, the unused space in the table is never more than a constant fraction of the total amount of space.</p>
<p class="para">We start by analyzing a dynamic table in which only insertions are performed. We then consider the more general case in which both insertions and deletions are allowed.</p>
<div class="section">
<h3 class="sect3-title">
<a name="1293"></a><a name="ch17lev2sec1"></a><span class="section-titlelabel">17.4.1 </span>Table expansion</h3>
<p class="first-para">Let us assume that storage for a table is allocated as an array of slots. A table fills up when all slots have been used or, equivalently, when its load factor is 1.<sup>[<a name="N82" href="#ftn.N82">1</a>]</sup> In some software environments, if an attempt is made to insert an item into a full table, there is no alternative but to abort with an error. We shall assume, however, that our software environment, like many modern ones, provides a memory-management system that can allocate and free blocks of storage on request. Thus, when an item is inserted into a full table, we can <b class="bold"><i class="emphasis">expand</i></b> the table by allocating a new table with more slots than the old table had. Because we always need the table to reside in contiguous memory, we must allocate a new array for the larger table and then copy items from the old table into the new table.</p>
<p class="para">A common heuristic is to allocate a new table that has twice as many slots as the old one. If only insertions are performed, the load factor of a table is always at <a name="1294"></a><a name="IDX-418"></a>least 1/2, and thus the amount of wasted space never exceeds half the total space in the table.</p>
<p class="para">In the following pseudocode, we assume that <i class="emphasis">T</i> is an object representing the table. The field <i class="emphasis">table</i>[<i class="emphasis">T</i>] contains a pointer to the block of storage representing the table. The field <i class="emphasis">num</i>[<i class="emphasis">T</i>] contains the number of items in the table, and the field <i class="emphasis">size</i>[<i class="emphasis">T</i>] is the total number of slots in the table. Initially, the table is empty: <i class="emphasis">num</i>[<i class="emphasis">T</i>] = <i class="emphasis">size</i>[<i class="emphasis">T</i> ] = 0.</p>
<div class="informalexample">
<pre class="literallayout-normal">
TABLE-INSERT (<i class="emphasis">T</i> , <i class="emphasis">x</i>)
 1  <b class="bold">if</b> <i class="emphasis">size</i>[<i class="emphasis">T</i> ] = 0
 2      <b class="bold">then</b> allocate <i class="emphasis">table</i>[<i class="emphasis">T</i>] with 1 slot
 3           <i class="emphasis">size</i>[<i class="emphasis">T</i>]  <span class="unicode">&larr;</span> 1
 4  <b class="bold">if</b> <i class="emphasis">num</i>[<i class="emphasis">T</i>] = <i class="emphasis">size</i>[<i class="emphasis">T</i>]
 5      <b class="bold">then</b> allocate <i class="emphasis">new-table</i> with 2 <span class="unicode">&middot;</span> <i class="emphasis">size</i>[<i class="emphasis">T</i>] slots
 6           insert all items in <i class="emphasis">table</i>[<i class="emphasis">T</i>] into <i class="emphasis">new-table</i>
 7           free <i class="emphasis">table</i>[<i class="emphasis">T</i>]
 8           <i class="emphasis">table</i>[<i class="emphasis">T</i>] <span class="unicode">&rarr;</span> <i class="emphasis">new-table</i>
 9           <i class="emphasis">size</i>[<i class="emphasis">T</i>] <span class="unicode">&rarr;</span> 2 <span class="unicode">&middot;</span> <i class="emphasis">size</i>[<i class="emphasis">T</i>]
10  insert <i class="emphasis">x</i> into <i class="emphasis">table</i>[<i class="emphasis">T</i>]
11  <i class="emphasis">num</i>[<i class="emphasis">T</i>] <span class="unicode">&rarr;</span> <i class="emphasis">num</i>[<i class="emphasis">T</i>] + 1
</pre>
</div>
<p class="para">Notice that we have two "insertion" procedures here: the TABLE-INSERT procedure itself and the <b class="bold"><i class="emphasis">elementary insertion</i></b> into a table in lines 6 and 10. We can analyze the running time of TABLE-INSERT in terms of the number of elementary insertions by assigning a cost of 1 to each elementary insertion. We assume that the actual running time of TABLE-INSERT is linear in the time to insert individual items, so that the overhead for allocating an initial table in line 2 is constant and the overhead for allocating and freeing storage in lines 5 and 7 is dominated by the cost of transferring items in line 6. We call the event in which the <b class="bold">then</b> clause in lines 5<span class="unicode">-</span>9 is executed an <b class="bold"><i class="emphasis">expansion</i></b>.</p>
<p class="para">Let us analyze a sequence of <i class="emphasis">n</i> TABLE-INSERT operations on an initially empty table. What is the cost <i class="emphasis">c<sub>i</sub></i> of the <i class="emphasis">i</i>th operation? If there is room in the current table (or if this is the first operation), then <i class="emphasis">c<sub>i</sub></i> = 1, since we need only perform the one elementary insertion in line 10. If the current table is full, however, and an expansion occurs, then <i class="emphasis">c<sub>i</sub></i> = <i class="emphasis">i</i>: the cost is 1 for the elementary insertion in line 10 plus <i class="emphasis">i</i> - 1 for the items that must be copied from the old table to the new table in line 6. If <i class="emphasis">n</i> operations are performed, the worst-case cost of an operation is <i class="emphasis">O</i>(<i class="emphasis">n</i>), which leads to an upper bound of <i class="emphasis">O</i>(<i class="emphasis">n</i><sup>2</sup>) on the total running time for <i class="emphasis">n</i> operations.</p>
<p class="para">This bound is not tight, because the cost of expanding the table is not borne often in the course of <i class="emphasis">n</i> TABLE-INSERT operations. Specifically, the <i class="emphasis">i</i>th operation causes an expansion only when <i class="emphasis">i</i> - 1 is an exact power of 2. The amortized cost of an <a name="1295"></a><a name="IDX-419"></a>operation is in fact <i class="emphasis">O</i>(1), as we can show using aggregate analysis. The cost of the <i class="emphasis">i</i>th operation is</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig441_01.jpg" height="38" width="243" alt="" border="0"></span>
</div>
<p class="para">The total cost of <i class="emphasis">n</i> TABLE-INSERT operations is therefore</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig441_02.jpg" height="87" width="139" alt="" border="0"></span>
</div>
<p class="para">since there are at most <i class="emphasis">n</i> operations that cost 1 and the costs of the remaining operations form a geometric series. Since the total cost of <i class="emphasis">n</i> TABLE-INSERT operations is 3<i class="emphasis">n</i>, the amortized cost of a single operation is 3.</p>
<p class="para">By using the accounting method, we can gain some feeling for why the amortized cost of a TABLE-INSERT operation should be 3. Intuitively, each item pays for 3 elementary insertions: inserting itself in the current table, moving itself when the table is expanded, and moving another item that has already been moved once when the table is expanded. For example, suppose that the size of the table is <i class="emphasis">m</i> immediately after an expansion. Then, the number of items in the table is <i class="emphasis">m</i>/2, and the table contains no credit. We charge 3 dollars for each insertion. The elementary insertion that occurs immediately costs 1 dollar. Another dollar is placed as credit on the item inserted. The third dollar is placed as credit on one of the <i class="emphasis">m</i>/2 items already in the table. Filling the table requires <i class="emphasis">m</i>/2 - 1 additional insertions, and thus, by the time the table contains <i class="emphasis">m</i> items and is full, each item has a dollar to pay for its reinsertion during the expansion.</p>
<p class="para">The potential method can also be used to analyze a sequence of <i class="emphasis">n</i> TABLE-INSERT operations, and we shall use it in <a class="internaljump" href="#ch17lev2sec2">Section 17.4.2</a> to design a TABLE-DELETE operation that has <i class="emphasis">O</i>(1) amortized cost as well. We start by defining a potential function <span class="unicode">&Phi;</span> that is 0 immediately after an expansion but builds to the table size by the time the table is full, so that the next expansion can be paid for by the potential. The function</p>
<div class="equation">
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(17.5)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig441_03.jpg" height="16" width="177" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">is one possibility. Immediately after an expansion, we have <i class="emphasis">num</i>[<i class="emphasis">T</i>] = <i class="emphasis">size</i>[<i class="emphasis">T</i>]/2, and thus <span class="unicode">&Phi;</span>(<i class="emphasis">T</i>) = 0, as desired. Immediately before an expansion, we have <i class="emphasis">num</i>[<i class="emphasis">T</i>] = <i class="emphasis">size</i>[<i class="emphasis">T</i>], and thus <span class="unicode">&Phi;</span>(<i class="emphasis">T</i>) = <i class="emphasis">num</i>[<i class="emphasis">T</i>], as desired. The initial value of the potential is 0, and since the table is always at least half full, <i class="emphasis">num</i>[<i class="emphasis">T</i>] <span class="unicode">&ge;</span> <i class="emphasis">size</i>[<i class="emphasis">T</i>]/2, which implies that <span class="unicode">&Phi;</span>(<i class="emphasis">T</i>) is always nonnegative. Thus, the sum of the amortized costs of <i class="emphasis">n</i> TABLE-INSERT operations is an upper bound on the sum of the actual costs.<a name="1296"></a><a name="IDX-420"></a>
</p>
<p class="para">To analyze the amortized cost of the <i class="emphasis">i</i>th TABLE-INSERT operation, we let <i class="emphasis">num<sub>i</sub></i> denote the number of items stored in the table after the <i class="emphasis">i</i>th operation, <i class="emphasis">size<sub>i</sub></i> denote the total size of the table after the <i class="emphasis">i</i>th operation, and <span class="unicode">&Phi;</span><i class="emphasis"><sub>i</sub></i> denote the potential after the <i class="emphasis">i</i>th operation. Initially, we have <i class="emphasis">num</i><sub>0</sub> = 0, <i class="emphasis">size</i><sub>0</sub> = 0, and <span class="unicode">&Phi;</span><sub>0</sub> = 0.</p>
<p class="para">If the <i class="emphasis">i</i>th TABLE-INSERT operation does not trigger an expansion, then we have <i class="emphasis">size<sub>i</sub></i> = <i class="emphasis">size</i><sub><i class="emphasis">i</i>-1</sub> and the amortized cost of the operation is</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<span class="inlinemediaobject"><img src="images/fig442_01.jpg" height="17" width="13" alt="" border="0"></span>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">c<sub>i</sub></i> + <span class="unicode">&Phi;</span><i class="emphasis"><sub>i</sub></i> - <span class="unicode">&Phi;</span><sub><i class="emphasis">i</i>-1</sub>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">1 + (2 <span class="unicode">&middot;</span> <i class="emphasis">num<sub>i</sub></i> -<i class="emphasis">size<sub>i</sub></i>) - (2 <span class="unicode">&middot;</span> <i class="emphasis">num</i><sub><i class="emphasis">i</i>-1</sub> -<i class="emphasis">size</i><sub><i class="emphasis">i</i>-1</sub>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">1 + (2 <span class="unicode">&middot;</span> <i class="emphasis">num<sub>i</sub></i> -<i class="emphasis">size<sub>i</sub></i>) - (2(<i class="emphasis">num</i><sub><i class="emphasis">i</i> -1</sub>) - <i class="emphasis">size<sub>i</sub></i>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">3.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">If the <i class="emphasis">i</i>th operation does trigger an expansion, then we have <i class="emphasis">size<sub>i</sub></i> = 2 <span class="unicode">&middot;</span> <i class="emphasis">size</i><sub><i class="emphasis">i</i>-1</sub> and <i class="emphasis">size</i><sub><i class="emphasis">i</i>-1</sub> = <i class="emphasis">num</i><sub><i class="emphasis">i</i>-1</sub> = <i class="emphasis">num</i><sub><i class="emphasis">i</i>-1</sub>, which implies that <i class="emphasis">size<sub>i</sub></i> = 2 <span class="unicode">&middot;</span> (<i class="emphasis">num</i><sub><i class="emphasis">i</i>-1</sub>). Thus, the amortized cost of the operation is</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<span class="inlinemediaobject"><img src="images/fig442_02.jpg" height="17" width="13" alt="" border="0"></span>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">c<sub>i</sub></i> + <span class="unicode">&Phi;</span><sub><i class="emphasis">i</i></sub> - <span class="unicode">&Phi;</span><sub><i class="emphasis">i</i>-1</sub>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">num<sub>i</sub></i> + (2 <span class="unicode">&middot;</span> <i class="emphasis">num<sub>i</sub></i> - <i class="emphasis">size<sub>i</sub></i>) - (2 <span class="unicode">&middot;</span> <i class="emphasis">num</i><sub><i class="emphasis">i</i>-1</sub> - <i class="emphasis">size</i><sub><i class="emphasis">i</i>-1</sub>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">num<sub>i</sub></i> +(2 <span class="unicode">&middot;</span> <i class="emphasis">num<sub>i</sub></i> -2 <span class="unicode">&middot;</span> (<i class="emphasis">num<sub>i</sub></i> - 1)) - (2(<i class="emphasis">num<sub>i</sub></i> - 1) - (<i class="emphasis">num<sub>i</sub></i> - 1))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">num<sub>i</sub></i> + 2 - (<i class="emphasis">num<sub>i</sub></i> - 1)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">3.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">
<a class="internaljump" href="#ch17fig03">Figure 17.3</a> plots the values of <i class="emphasis">num<sub>i</sub></i>, <i class="emphasis">size<sub>i</sub></i>, and <span class="unicode">&Phi;</span><sub><i class="emphasis">i</i></sub> against <i class="emphasis">i</i>. Notice how the potential builds to pay for the expansion of the table.</p>
<div class="figure">
<a name="1297"></a><a name="ch17fig03"></a><span class="figuremediaobject"><a href="images/fig443%5F01%5F0%2Ejpg" NAME="IMG_541" target="_parent"><img src="images/fig443_01.jpg" height="218" width="228" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 17.3: </span>The effect of a sequence of <i class="emphasis">n</i> TABLE-INSERT operations on the number <i class="emphasis">num<sub>i</sub></i> of items in the table, the number <i class="emphasis">size<sub>i</sub></i> of slots in the table, and the potential <span class="unicode">&Phi;</span><i class="emphasis"><sub>i</sub></i> = 2<span class="unicode">&middot;</span><i class="emphasis">num<sub>i</sub></i> - <i class="emphasis">size<sub>i</sub></i>, each being measured after the <i class="emphasis">i</i>th operation. The thin line shows <i class="emphasis">num<sub>i</sub></i>, the dashed line shows <i class="emphasis">size<sub>i</sub></i>, and the thick line shows <span class="unicode">&Phi;</span><i class="emphasis"><sub>i</sub></i>. Notice that immediately before an expansion, the potential has built up to the number of items in the table, and therefore it can pay for moving all the items to the new table. Afterwards, the potential drops to 0, but it is immediately increased by 2 when the item that caused the expansion is inserted.</span>
</div>

</div>
<div class="section">
<h3 class="sect3-title">
<a name="1298"></a><a name="ch17lev2sec2"></a><span class="section-titlelabel">17.4.2 </span>Table expansion and contraction</h3>
<p class="first-para">To implement a TABLE-DELETE operation, it is simple enough to remove the specified item from the table. It is often desirable, however, to <b class="bold"><i class="emphasis">contract</i></b> the table when the load factor of the table becomes too small, so that the wasted space is not exorbitant. Table contraction is analogous to table expansion: when the number of items in the table drops too low, we allocate a new, smaller table and then copy the items from the old table into the new one. The storage for the old table can then be freed by returning it to the memory-management system. Ideally, we would like to preserve two properties:</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">the load factor of the dynamic table is bounded below by a constant, and</p>
</li>
<li class="listitem">
<p class="first-para">the amortized cost of a table operation is bounded above by a constant.</p>
</li>
</ul>
<p class="para">We assume that cost can be measured in terms of elementary insertions and deletions.</p>
<p class="para">A natural strategy for expansion and contraction is to double the table size when an item is inserted into a full table and halve the size when a deletion would cause <a name="1299"></a><a name="IDX-421"></a>the table to become less than half full. This strategy guarantees that the load factor of the table never drops below 1/2, but unfortunately, it can cause the amortized cost of an operation to be quite large. Consider the following scenario. We perform <i class="emphasis">n</i> operations on a table <i class="emphasis">T</i> , where <i class="emphasis">n</i> is an exact power of 2. The first <i class="emphasis">n</i>/2 operations are insertions, which by our previous analysis cost a total of <span class="unicode">&Phi;</span>(<i class="emphasis">n</i>). At the end of this sequence of insertions, <i class="emphasis">num</i>[<i class="emphasis">T</i>] = <i class="emphasis">size</i>[<i class="emphasis">T</i>] = <i class="emphasis">n</i>/2. For the second <i class="emphasis">n</i>/2 operations, we perform the following sequence:</p>
<p class="para">I, D, D, I, I, D, D, I, I, ... ,</p>
<p class="para">where I stands for an insertion and D stands for a deletion. The first insertion causes an expansion of the table to size <i class="emphasis">n</i>. The two following deletions cause a contraction of the table back to size <i class="emphasis">n</i>/2. Two further insertions cause another expansion, and so forth. The cost of each expansion and contraction is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>), and there are <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) of them. Thus, the total cost of the <i class="emphasis">n</i> operations is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>2</sup>), and the amortized cost of an operation is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>).</p>
<p class="para">The difficulty with this strategy is obvious: after an expansion, we do not perform enough deletions to pay for a contraction. Likewise, after a contraction, we do not perform enough insertions to pay for an expansion.<a name="1300"></a><a name="IDX-422"></a>
</p>
<p class="para">We can improve upon this strategy by allowing the load factor of the table to drop below 1/2. Specifically, we continue to double the table size when an item is inserted into a full table, but we halve the table size when a deletion causes the table to become less than 1/4 full, rather than 1/2 full as before. The load factor of the table is therefore bounded below by the constant 1/4. The idea is that after an expansion, the load factor of the table is 1/2. Thus, half the items in the table must be deleted before a contraction can occur, since contraction does not occur unless the load factor would fall below 1/4. Likewise, after a contraction, the load factor of the table is also 1/2. Thus, the number of items in the table must be doubled by insertions before an expansion can occur, since expansion occurs only when the load factor would exceed 1.</p>
<p class="para">We omit the code for TABLE-DELETE, since it is analogous to TABLE-INSERT. It is convenient to assume for analysis, however, that if the number of items in the table drops to 0, the storage for the table is freed. That is, if <i class="emphasis">num</i>[<i class="emphasis">T</i>] = 0, then <i class="emphasis">size</i>[<i class="emphasis">T</i>] = 0.</p>
<p class="para">We can now use the potential method to analyze the cost of a sequence of <i class="emphasis">n</i> TABLE-INSERT and TABLE-DELETE operations. We start by defining a potential function <span class="unicode">&Phi;</span> that is 0 immediately after an expansion or contraction and builds as the load factor increases to 1 or decreases to 1/4. Let us denote the load factor of a nonempty table <i class="emphasis">T</i> by <span class="unicode">&alpha;</span>(<i class="emphasis">T</i>) = <i class="emphasis">num</i>[<i class="emphasis">T</i>]/ <i class="emphasis">size</i>[<i class="emphasis">T</i>]. Since for an empty table, <i class="emphasis">num</i>[<i class="emphasis">T</i>] = <i class="emphasis">size</i>[<i class="emphasis">T</i>] = 0 and <span class="unicode">&alpha;</span>[<i class="emphasis">T</i>] = 1, we always have <i class="emphasis">num</i>[<i class="emphasis">T</i>] = <span class="unicode">&alpha;</span>(<i class="emphasis">T</i>) <span class="unicode">&middot;</span> <i class="emphasis">size</i>[<i class="emphasis">T</i>], whether the table is empty or not. We shall use as our potential function</p>
<div class="equation">
<a name="1301"></a><a name="ch17eq06"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(17.6)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig444_01.jpg" height="38" width="290" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">Observe that the potential of an empty table is 0 and that the potential is never negative. Thus, the total amortized cost of a sequence of operations with respect to <span class="unicode">&Phi;</span> is an upper bound on the actual cost of the sequence.</p>
<p class="para">Before proceeding with a precise analysis, we pause to observe some properties of the potential function. Notice that when the load factor is 1/2, the potential is 0. When the load factor is 1, we have <i class="emphasis">size</i>[<i class="emphasis">T</i>] = <i class="emphasis">num</i>[<i class="emphasis">T</i>], which implies <span class="unicode">&Phi;</span>(<i class="emphasis">T</i>) = <i class="emphasis">num</i>[<i class="emphasis">T</i>], and thus the potential can pay for an expansion if an item is inserted. When the load factor is 1/4, we have <i class="emphasis">size</i>[<i class="emphasis">T</i>] = 4 <span class="unicode">&middot;</span> <i class="emphasis">num</i>[<i class="emphasis">T</i>], which implies <span class="unicode">&Phi;</span>(<i class="emphasis">T</i>) = <i class="emphasis">num</i>[<i class="emphasis">T</i>], and thus the potential can pay for a contraction if an item is deleted. <a class="internaljump" href="#ch17fig04">Figure 17.4</a> illustrates how the potential behaves for a sequence of operations.</p>
<div class="figure">
<a name="1302"></a><a name="ch17fig04"></a><span class="figuremediaobject"><a href="images/fig445%5F01%5F0%2Ejpg" NAME="IMG_544" target="_parent"><img src="images/fig445_01.jpg" height="213" width="343" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 17.4: </span>The effect of a sequence of <i class="emphasis">n</i> TABLE-INSERT and TABLE-DELETE operations on the number <i class="emphasis">num<sub>i</sub></i> of items in the table, the number <i class="emphasis">size<sub>i</sub></i> of slots in the table, and the potential <span class="inlinemediaobject"><img src="images/fig445_02.jpg" height="31" width="188" alt="" border="0"></span> each being measured after the <i class="emphasis">i</i>th operation. The thin line shows <i class="emphasis">num<sub>i</sub></i>, the dashed line shows <i class="emphasis">size<sub>i</sub></i>, and the thick line shows <span class="unicode">&Phi;</span><sub><i class="emphasis">i</i></sub>. Notice that immediately before an expansion, the potential has built up to the number of items in the table, and therefore it can pay for moving all the items to the new table. Likewise, immediately before a contraction, the potential has built up to the number of items in the table.</span>
</div>
<p class="para">To analyze a sequence of <i class="emphasis">n</i> TABLE-INSERT and TABLE-DELETE operations, we let <i class="emphasis">c<sub>i</sub></i> denote the actual cost of the <i class="emphasis">i</i>th operation, <span class="inlinemediaobject"><img src="images/fig444_02.jpg" height="17" width="13" alt="" border="0"></span> denote its amortized cost with respect to <span class="unicode">&Phi;</span>, <i class="emphasis">num<sub>i</sub></i> denote the number of items stored in the table after the <i class="emphasis">i</i>th operation, <i class="emphasis">size<sub>i</sub></i> denote the total size of the table after the <i class="emphasis">i</i>th operation, <span class="unicode">&alpha;</span><sub><i class="emphasis">i</i></sub> denote the load factor of the table after the <i class="emphasis">i</i>th operation, and <span class="unicode">&Phi;</span><i class="emphasis"><sub>i</sub></i> denote the potential after the <i class="emphasis">i</i>th operation. Initially, <i class="emphasis">num</i><sub>0</sub> = 0, <i class="emphasis">size</i><sub>0</sub> = 0, <span class="unicode">&alpha;</span><sub>0</sub> = 1, and <span class="unicode">&Phi;</span>0 = 0.<a name="1303"></a><a name="IDX-423"></a>
</p>
<p class="para">We start with the case in which the <i class="emphasis">i</i>th operation is TABLE-INSERT. The analysis is identical to that for table expansion in <a class="internaljump" href="#ch17lev2sec1">Section 17.4.1</a> if <span class="unicode">&alpha;</span><sub><i class="emphasis">i</i>-1</sub> <span class="unicode">&ge;</span> 1/2. Whether the table expands or not, the amortized cost <span class="inlinemediaobject"><img src="images/fig445_03.jpg" height="17" width="13" alt="" border="0"></span> of the operation is at most 3. If <span class="unicode">&alpha;</span><sub><i class="emphasis">i</i>-1</sub> <span class="unicode">&lt;</span> 1/2, the table cannot expand as a result of the operation, since expansion occurs only when <span class="unicode">&alpha;</span><sub><i class="emphasis">i</i>-1</sub> = 1. If <span class="unicode">&alpha;</span><sub><i class="emphasis">i</i></sub> <span class="unicode">&lt;</span> 1/2 as well, then the amortized cost of the <i class="emphasis">i</i>th operation is</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<span class="inlinemediaobject"><img src="images/fig445_04.jpg" height="17" width="13" alt="" border="0"></span>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">c<sub>i</sub></i> + <span class="unicode">&Phi;</span><sub><i class="emphasis">i</i></sub> - <span class="unicode">&Phi;</span><sub><i class="emphasis">i</i>-1</sub>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">1 + (<i class="emphasis">size<sub>i</sub></i>/2 - <i class="emphasis">num<sub>i</sub></i>) - (<i class="emphasis">size</i><sub><i class="emphasis">i</i>-1</sub>/2 - <i class="emphasis">num<sub>i</sub></i>-1)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">1 + (<i class="emphasis">size<sub>i</sub></i>/2 - <i class="emphasis">num<sub>i</sub></i>) - (<i class="emphasis">size<sub>i</sub></i>/2 - (<i class="emphasis">num<sub>i</sub></i> - 1))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">0.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">If <span class="unicode">&alpha;</span><sub><i class="emphasis">i</i>-1</sub> <span class="unicode">&lt;</span> 1/2 but <span class="unicode">&alpha;</span><sub><i class="emphasis">i</i></sub> <span class="unicode">&ge;</span> 1/2, then<a name="1304"></a><a name="IDX-424"></a>
</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<span class="inlinemediaobject"><img src="images/fig446_01.jpg" height="17" width="13" alt="" border="0"></span>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">c</i><sub><i class="emphasis">i</i></sub>+<span class="unicode">&Phi;</span><sub><i class="emphasis">i</i></sub>-<span class="unicode">&Phi;</span><sub><i class="emphasis">i</i>-1</sub>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">1 + (2 <span class="unicode">&middot;</span> <i class="emphasis">num<sub>i</sub></i> - <i class="emphasis">size<sub>i</sub></i>) - (<i class="emphasis">size</i><sub><i class="emphasis">i</i>-1</sub> /2 - <i class="emphasis">num</i><sub><i class="emphasis">i</i>-1</sub>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">1 + (2(<i class="emphasis">num</i><sub><i class="emphasis">i</i>-1</sub> +1) - <i class="emphasis">size</i><sub><i class="emphasis">i</i>-1</sub>) - (<i class="emphasis">size</i><sub><i class="emphasis">i</i>-1</sub>/2 - <i class="emphasis">num</i><sub><i class="emphasis">i</i>-1</sub>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">3 <span class="unicode">&middot;</span> <i class="emphasis">num</i><sub><i class="emphasis">i</i>-1</sub> - 3/2; <i class="emphasis">size</i><sub><i class="emphasis">i</i>-1</sub> +3</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">3<span class="unicode">&alpha;</span><sub><i class="emphasis">i</i>-1</sub> <i class="emphasis">size</i><sub><i class="emphasis">i</i>-1</sub> - 3/2 <i class="emphasis">size</i><sub><i class="emphasis">i</i>-1</sub> +3</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&lt;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">3/2 <i class="emphasis">size</i><sub><i class="emphasis">i</i>-1</sub> - 3/2 <i class="emphasis">size</i><sub><i class="emphasis">i</i>-1</sub> +3</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">3.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">Thus, the amortized cost of a TABLE-INSERT operation is at most 3.</p>
<p class="para">We now turn to the case in which the <i class="emphasis">i</i>th operation is TABLE-DELETE. In this case, <i class="emphasis">num<sub>i</sub></i> = <i class="emphasis">num</i><sub><i class="emphasis">i</i>-1</sub> -1. If <i class="emphasis">a</i><sub><i class="emphasis">i</i>-1</sub> <span class="unicode">&lt;</span> 1/2, then we must consider whether the operation causes a contraction. If it does not, then <i class="emphasis">size<sub>i</sub></i> = <i class="emphasis">size</i><sub><i class="emphasis">i</i>-1</sub> and the amortized cost of the operation is</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<span class="inlinemediaobject"><img src="images/fig446_02.jpg" height="17" width="13" alt="" border="0"></span>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">c<sub>i</sub></i> + <span class="unicode">&Phi;</span><sub><i class="emphasis">i</i></sub> - <span class="unicode">&Phi;</span><sub><i class="emphasis">i</i>-1</sub>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">1 + (<i class="emphasis">size<sub>i</sub></i> /2 - <i class="emphasis">num<sub>i</sub></i>) - (<i class="emphasis">size</i><sub><i class="emphasis">i</i>-1</sub> /2 - <i class="emphasis">num</i><sub><i class="emphasis">i</i>-1</sub>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">1 + (<i class="emphasis">size<sub>i</sub></i> /2 - <i class="emphasis">num<sub>i</sub></i>) - (<i class="emphasis">size<sub>i</sub></i> /2 - (<i class="emphasis">num<sub>i</sub></i> +1))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">2.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">If <span class="unicode">&alpha;</span><sub><i class="emphasis">i</i></sub>-1 <span class="unicode">&lt;</span> 1/2 and the <i class="emphasis">i</i>th operation does trigger a contraction, then the actual cost of the operation is <i class="emphasis">c<sub>i</sub></i> = <i class="emphasis">num<sub>i</sub></i> +1, since we delete one item and move <i class="emphasis">num<sub>i</sub></i> items. We have <i class="emphasis">size<sub>i</sub></i>/2 = <i class="emphasis">size</i><sub><i class="emphasis">i</i>-1</sub>/4 = <i class="emphasis">num</i><sub><i class="emphasis">i</i>-1</sub> = <i class="emphasis">num<sub>i</sub></i> +1, and the amortized cost of the operation is</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<span class="inlinemediaobject"><img src="images/fig446_03.jpg" height="17" width="13" alt="" border="0"></span>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">c<sub>i</sub></i> + <span class="unicode">&Phi;</span><i class="emphasis"><sub>i</sub></i> - <span class="unicode">&Phi;</span><sub><i class="emphasis">i</i>-1</sub>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">(<i class="emphasis">num<sub>i</sub></i> +1) + (<i class="emphasis">size<sub>i</sub></i>/2 - <i class="emphasis">num<sub>i</sub></i>) (<i class="emphasis">size</i><sub><i class="emphasis">i</i>-1</sub>/2 - <i class="emphasis">num</i><sub><i class="emphasis">i</i>-1</sub>) = (<i class="emphasis">num<sub>i</sub></i> +1) + ((<i class="emphasis">num<sub>i</sub></i> +1) - <i class="emphasis">num<sub>i</sub></i>) - ((2 <span class="unicode">&middot;</span> <i class="emphasis">num<sub>i</sub></i> +2) - (<i class="emphasis">num<sub>i</sub></i> +1))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">1.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">When the <i class="emphasis">i</i>th operation is a TABLE-DELETE and <span class="unicode">&alpha;</span><sub><i class="emphasis">i</i>-1</sub> <span class="unicode">&ge;</span> 1/2, the amortized cost is also bounded above by a constant. The analysis is left as <a class="internaljump" href="#ch17ex15">Exercise 17.4-2</a>.</p>
<p class="para">In summary, since the amortized cost of each operation is bounded above by a constant, the actual time for any sequence of <i class="emphasis">n</i> operations on a dynamic table is <i class="emphasis">O</i>(<i class="emphasis">n</i>).</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 17.4-1</span></span><a name="1305"></a><a name="ch17ex14"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that we wish to implement a dynamic, open-address hash table. Why might we consider the table to be full when its load factor reaches some value <span class="unicode">&alpha;</span> <a name="1306"></a><a name="IDX-425"></a>that is strictly less than 1? Describe briefly how to make insertion into a dynamic, open-address hash table run in such a way that the expected value of the amortized cost per insertion is <i class="emphasis">O</i>(1). Why is the expected value of the actual cost per insertion not necessarily <i class="emphasis">O</i>(1) for all insertions?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 17.4-2</span></span><a name="1307"></a><a name="ch17ex15"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that if <span class="unicode">&alpha;</span><sub><i class="emphasis">i</i>-1</sub> <span class="unicode">&ge;</span> 1/2 and the <i class="emphasis">i</i>th operation on a dynamic table is TABLE-DELETE, then the amortized cost of the operation with respect to the potential function (<a class="internaljump" href="#ch17eq06">17.6</a>) is bounded above by a constant.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 17.4-3</span></span><a name="1308"></a><a name="ch17ex16"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that instead of contracting a table by halving its size when its load factor drops below 1/4, we contract it by multiplying its size by 2/3 when its load factor drops below 1/3. Using the potential function</p>
<p class="para">
<span class="unicode">&Phi;</span>(<i class="emphasis">T</i>) = |2 <span class="unicode">&middot;</span> <i class="emphasis">num</i>[<i class="emphasis">T</i>] - <i class="emphasis">size</i>[<i class="emphasis">T</i>]| ,</p>
<p class="last-para">show that the amortized cost of a TABLE-DELETE that uses this strategy is bounded above by a constant.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 17-1: </span>Bit-reversed binary counter</span><a name="1309"></a><a name="ch17ex17"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">
<a href="DDU0193.html#2538" target="_parent" class="chapterjump">Chapter 30</a> examines an important algorithm called the Fast Fourier Transform, or FFT. The first step of the FFT algorithm performs a <b class="bold"><i class="emphasis">bit-reversal permutation</i></b> on an input array <i class="emphasis">A</i>[0 <span class="unicode">&#8229;</span> <i class="emphasis">n</i> - 1] whose length is <i class="emphasis">n</i> = 2<sup><i class="emphasis">k</i></sup> for some nonnegative integer <i class="emphasis">k</i>. This permutation swaps elements whose indices have binary representations that are the reverse of each other.</p>
<p class="para">We can express each index <i class="emphasis">a</i> as a <i class="emphasis">k</i>-bit sequence <span class="unicode">&#12296;</span><i class="emphasis">a</i><sub><i class="emphasis">k</i>-1</sub>, <i class="emphasis">a</i><sub><i class="emphasis">k</i>-2</sub>, ..., <i class="emphasis">a</i><sub>0</sub><span class="unicode">&#12297;</span>, where <span class="inlinemediaobject"><img src="images/fig447_01.jpg" height="16" width="70" alt="" border="0"></span>. We define</p>
<p class="para">rev<i class="emphasis">k</i>(<span class="unicode">&#12296;</span><i class="emphasis">a</i><sub><i class="emphasis">k</i>-1</sub>, <i class="emphasis">a</i><sub><i class="emphasis">k</i>-2</sub>, ..., <i class="emphasis">a</i><sub>0</sub><span class="unicode">&#12297;</span>) = <span class="unicode">&#12296;</span><i class="emphasis">a</i><sub>0</sub>, <i class="emphasis">a</i><sub>1</sub>, ..., <i class="emphasis">a</i><sub><i class="emphasis">k</i>-1</sub><span class="unicode">&#12297;</span>;</p>
<p class="para">thus,</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig447_02.jpg" height="43" width="145" alt="" border="0"></span>
</div>
<p class="para">For example, if <i class="emphasis">n</i> = 16 (or, equivalently, <i class="emphasis">k</i> = 4), then rev<sub><i class="emphasis">k</i></sub>(3) = 12, since the 4-bit representation of 3 is 0011, which when reversed gives 1100, the 4-bit representation of 12.<a name="1310"></a><a name="IDX-426"></a>
</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Given a function rev<sub><i class="emphasis">k</i></sub> that runs in <span class="unicode">&Phi;</span>(<i class="emphasis">k</i>) time, write an algorithm to perform the bit-reversal permutation on an array of length <i class="emphasis">n</i> = 2<sup><i class="emphasis">k</i></sup> in <i class="emphasis">O</i>(<i class="emphasis">nk</i>) time.</p>
</li>
</ol>
<p class="para">We can use an algorithm based on an amortized analysis to improve the running time of the bit-reversal permutation. We maintain a "bit-reversed counter" and a procedure BIT-REVERSED-INCREMENT that, when given a bit-reversed-counter value <i class="emphasis">a</i>, produces rev<sub><i class="emphasis">k</i></sub>(rev<sub><i class="emphasis">k</i></sub>(<i class="emphasis">a</i>) + 1). If <i class="emphasis">k</i> = 4, for example, and the bit-reversed counter starts at 0, then successive calls to BIT-REVERSED-INCREMENT produce the sequence</p>
<p class="para">0000, 1000, 0100, 1100, 0010, 1010, ... = 0, 8, 4, 12, 2, 10, ... .</p>
<ol class="orderedlist" start="2" type="a">
<li class="first-listitem">
<p class="first-para">Assume that the words in your computer store <i class="emphasis">k</i>-bit values and that in unit time, your computer can manipulate the binary values with operations such as shifting left or right by arbitrary amounts, bitwise-AND, bitwise-OR, etc. Describe an implementation of the BIT-REVERSED-INCREMENT procedure that allows the bit-reversal permutation on an <i class="emphasis">n</i>-element array to be performed in a total of <i class="emphasis">O</i>(<i class="emphasis">n</i>) time.</p>
</li>
<li class="listitem">
<p class="first-para">Suppose that you can shift a word left or right by only one bit in unit time. Is it still possible to implement an <i class="emphasis">O</i>(<i class="emphasis">n</i>)-time bit-reversal permutation?</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 17-2: </span>Making binary search dynamic</span><a name="1311"></a><a name="ch11ex"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Binary search of a sorted array takes logarithmic search time, but the time to insert a new element is linear in the size of the array. We can improve the time for insertion by keeping several sorted arrays.</p>
<p class="para">Specifically, suppose that we wish to support SEARCH and INSERT on a set of <i class="emphasis">n</i> elements. Let <i class="emphasis">k</i> = <span class="unicode">&lceil;</span>lg(<i class="emphasis">n</i> + 1)<span class="unicode">&rceil;</span>, and let the binary representation of <i class="emphasis">n</i> be <span class="unicode">&#12296;</span><i class="emphasis">n</i><sub><i class="emphasis">k</i>-1</sub>, <i class="emphasis">n</i><sub><i class="emphasis">k</i>-2</sub>, ..., <i class="emphasis">n</i><sub>0</sub><span class="unicode">&#12297;</span>. We have <i class="emphasis">k</i> sorted arrays <i class="emphasis">A</i><sub>0</sub>, <i class="emphasis">A</i><sub>1</sub>, ..., <i class="emphasis">A</i><sub><i class="emphasis">k</i>-1</sub>, where for <i class="emphasis">i</i> = 0, 1, ..., <i class="emphasis">k</i> - 1, the length of array <i class="emphasis">A<sub>i</sub></i> is 2<sup><i class="emphasis">i</i></sup>. Each array is either full or empty, depending on whether <i class="emphasis">n<sub>i</sub></i> = 1 or <i class="emphasis">n<sub>i</sub></i> = 0, respectively. The total number of elements held in all <i class="emphasis">k</i> arrays is therefore <span class="inlinemediaobject"><img src="images/fig448_01.jpg" height="16" width="70" alt="" border="0"></span>. Although each individual array is sorted, there is no particular relationship between elements in different arrays.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Describe how to perform the SEARCH operation for this data structure. Analyze its worst-case running time.</p>
</li>
<li class="listitem">
<p class="first-para">Describe how to insert a new element into this data structure. Analyze its worst-case and amortized running times.</p>
</li>
<li class="listitem">
<p class="first-para">Discuss how to implement DELETE.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1312"></a><a name="IDX-427"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 17-3: </span>Amortized weight-balanced trees</span><a name="1313"></a><a name="ch17ex18"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Consider an ordinary binary search tree augmented by adding to each node <i class="emphasis">x</i> the field <i class="emphasis">size</i>[<i class="emphasis">x</i>] giving the number of keys stored in the subtree rooted at <i class="emphasis">x</i>. Let <span class="unicode">&alpha;</span> be a constant in the range 1/2 <span class="unicode">&le;</span> <span class="unicode">&alpha;</span> <span class="unicode">&lt;</span> 1. We say that a given node <i class="emphasis">x</i> is <b class="bold"><i class="emphasis"><span class="unicode">&alpha;</span>-balanced</i></b> if <i class="emphasis">size</i>[<i class="emphasis">left</i>[<i class="emphasis">x</i>]] <span class="unicode">&le;</span> <span class="unicode">&alpha;</span> <span class="unicode">&middot;</span> <i class="emphasis">size</i>[<i class="emphasis">x</i>]</p>
<p class="para">and</p>
<p class="para">
<i class="emphasis">size</i>[<i class="emphasis">right</i>[<i class="emphasis">x</i>]] <span class="unicode">&le;</span> <span class="unicode">&alpha;</span> <span class="unicode">&middot;</span> <i class="emphasis">size</i>[<i class="emphasis">x</i>].</p>
<p class="para">The tree as a whole is <b class="bold"><i class="emphasis"><span class="unicode">&alpha;</span>-balanced</i></b> if every node in the tree is <span class="unicode">&alpha;</span>-balanced. The following amortized approach to maintaining weight-balanced trees was suggested by G. Varghese.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">A 1/2-balanced tree is, in a sense, as balanced as it can be. Given a node <i class="emphasis">x</i> in an arbitrary binary search tree, show how to rebuild the subtree rooted at <i class="emphasis">x</i> so that it becomes 1/2-balanced. Your algorithm should run in time <span class="unicode">&Theta;</span>(<i class="emphasis">size</i>[<i class="emphasis">x</i>]), and it can use <i class="emphasis">O</i>(<i class="emphasis">size</i>[<i class="emphasis">x</i>]) auxiliary storage.</p>
</li>
<li class="listitem">
<p class="first-para">Show that performing a search in an <i class="emphasis">n</i>-node <span class="unicode">&alpha;</span>-balanced binary search tree takes <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) worst-case time.</p>
</li>
</ol>
<p class="para">For the remainder of this problem, assume that the constant <span class="unicode">&alpha;</span> is strictly greater than 1/2. Suppose that INSERT and DELETE are implemented as usual for an <i class="emphasis">n</i>-node binary search tree, except that after every such operation, if any node in the tree is no longer <span class="unicode">&alpha;</span>-balanced, then the subtree rooted at the highest such node in the tree is "rebuilt" so that it becomes 1/2-balanced.</p>
<p class="para">We shall analyze this rebuilding scheme using the potential method. For a node <i class="emphasis">x</i> in a binary search tree <i class="emphasis">T</i> , we define</p>
<p class="para">
<span class="unicode">&Delta;</span>(<i class="emphasis">x</i>) = |<i class="emphasis">size</i>[<i class="emphasis">left</i>[<i class="emphasis">x</i>]] - <i class="emphasis">size</i>[<i class="emphasis">right</i>[<i class="emphasis">x</i>]]| ,</p>
<p class="para">and we define the potential of <i class="emphasis">T</i> as</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig449_01.jpg" height="34" width="131" alt="" border="0"></span>
</div>
<p class="para">where <i class="emphasis">c</i> is a sufficiently large constant that depends on <span class="unicode">&alpha;</span>.</p>
<ol class="orderedlist" start="3" type="a">
<li class="first-listitem">
<p class="first-para">Argue that any binary search tree has nonnegative potential and that a 1/2-balanced tree has potential 0.</p>
</li>
<li class="listitem">
<p class="first-para">Suppose that <i class="emphasis">m</i> units of potential can pay for rebuilding an <i class="emphasis">m</i>-node subtree. How large must <i class="emphasis">c</i> be in terms of <span class="unicode">&alpha;</span> in order for it to take <i class="emphasis">O</i>(1) amortized time to rebuild a subtree that is not <span class="unicode">&alpha;</span>-balanced?</p>
</li>
<li class="listitem">
<p class="first-para">Show that inserting a node into or deleting a node from an <i class="emphasis">n</i>-node <span class="unicode">&alpha;</span>-balanced tree costs <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) amortized time.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1314"></a><a name="IDX-428"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 17-4: </span>The cost of restructuring red-black trees</span><a name="1315"></a><a name="ch17ex19"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">There are four basic operations on red-black trees that perform <b class="bold"><i class="emphasis">structural modifications</i></b>: node insertions, node deletions, rotations, and color modifications. We have seen that RB-INSERT and RB-DELETE use only <i class="emphasis">O</i>(1) rotations, node insertions, and node deletions to maintain the red-black properties, but they may make many more color modifications.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Describe a legal red-black tree with <i class="emphasis">n</i> nodes such that calling RB-INSERT to add the (<i class="emphasis">n</i> + 1)st node causes <span class="unicode">&Omega;</span>(lg <i class="emphasis">n</i>) color modifications. Then describe a legal red-black tree with <i class="emphasis">n</i> nodes for which calling RB-DELETE on a particular node causes <span class="unicode">&Omega;</span>(lg <i class="emphasis">n</i>) color modifications.</p>
</li>
</ol>
<p class="para">Although the worst-case number of color modifications per operation can be logarithmic, we shall prove that any sequence of <i class="emphasis">m</i> RB-INSERT and RB-DELETE operations on an initially empty red-black tree causes <i class="emphasis">O</i>(<i class="emphasis">m</i>) structural modifications in the worst case.</p>
<ol class="orderedlist" start="2" type="a">
<li class="first-listitem">
<p class="first-para">Some of the cases handled by the main loop of the code of both RB-INSERT-FIXUP and RB-DELETE-FIXUP are <b class="bold"><i class="emphasis">terminating</i></b>: once encountered, they cause the loop to terminate after a constant number of additional operations. For each of the cases of RB-INSERT-FIXUP and RB-DELETE-FIXUP, specify which are terminating and which are not. (<i class="emphasis">Hint:</i> Look at <a href="DDU0078.html#894" target="_parent" class="chapterjump">Figures 13.5</a>, <a href="DDU0078.html#899" target="_parent" class="chapterjump">13.6</a> and <a href="DDU0079.html#914" target="_parent" class="chapterjump">13.7</a>.)</p>
</li>
</ol>
<p class="para">We shall first analyze the structural modifications when only insertions are performed. Let <i class="emphasis">T</i> be a red-black tree, and define <span class="unicode">&Phi;</span>(<i class="emphasis">T</i>) to be the number of red nodes in <i class="emphasis">T</i> . Assume that 1 unit of potential can pay for the structural modifications performed by any of the three cases of RB-INSERT-FIXUP.</p>
<ol class="orderedlist" start="3" type="a">
<li class="first-listitem">
<p class="first-para">Let <i class="emphasis">T</i><span class="unicode">&prime;</span> be the result of applying Case 1 of RB-INSERT-FIXUP to <i class="emphasis">T</i> . Argue that <span class="unicode">&Phi;</span>(<i class="emphasis">T</i><span class="unicode">&prime;</span>) = <span class="unicode">&Phi;</span>(<i class="emphasis">T</i>) - 1.</p>
</li>
<li class="listitem">
<p class="first-para">Node insertion into a red-black tree using RB-INSERT can be broken down into three parts. List the structural modifications and potential changes resulting from lines 1<span class="unicode">-</span>16 of RB-INSERT, from nonterminating cases of RB-INSERT-FIXUP, and from terminating cases of RB-INSERT-FIXUP.</p>
</li>
<li class="listitem">
<p class="first-para">Using part (d), argue that the amortized number of structural modifications performed by any call of RB-INSERT is <i class="emphasis">O</i>(1).</p>
</li>
</ol>
<p class="para">We now wish to prove that there are <i class="emphasis">O</i>(<i class="emphasis">m</i>) structural modifications when there are both insertions and deletions. Let us define, for each node <i class="emphasis">x</i>,</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig450_01.jpg" height="73" width="304" alt="" border="0"></span>
</div>
<a name="1316"></a><a name="IDX-429"></a>
<p class="para">Now we redefine the potential of a red-black tree <i class="emphasis">T</i> as</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig451_01.jpg" height="33" width="115" alt="" border="0"></span>
</div>
<p class="para">and let <i class="emphasis">T</i><span class="unicode">&prime;</span> be the tree that results from applying any nonterminating case of RB-INSERT-FIXUP or RB-DELETE-FIXUP to <i class="emphasis">T</i> .</p>
<ol class="orderedlist" start="6" type="a">
<li class="first-listitem">
<p class="first-para">Show that <span class="unicode">&Phi;</span>(<i class="emphasis">T</i><span class="unicode">&prime;</span>) <span class="unicode">&le;</span> <span class="unicode">&Phi;</span>(<i class="emphasis">T</i>) - 1 for all nonterminating cases of RB-INSERT-FIXUP. Argue that the amortized number of structural modifications performed by any call of RB-INSERT-FIXUP is <i class="emphasis">O</i>(1).</p>
</li>
<li class="listitem">
<p class="first-para">Show that <span class="unicode">&Phi;</span>(<i class="emphasis">T</i><span class="unicode">&prime;</span>) <span class="unicode">&le;</span> <span class="unicode">&Phi;</span>(<i class="emphasis">T</i>) - 1 for all nonterminating cases of RB-DELETE-FIXUP. Argue that the amortized number of structural modifications performed by any call of RB-DELETE-FIXUP is <i class="emphasis">O</i>(1).</p>
</li>
<li class="listitem">
<p class="first-para">Complete the proof that in the worst case, any sequence of <i class="emphasis">m</i> RB-INSERT and RB-DELETE operations performs <i class="emphasis">O</i>(<i class="emphasis">m</i>) structural modifications.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
<div class="footnotes">
<div class="footnote">
<p>
<sup>[<a name="ftn.N82" href="#N82">1</a>]</sup>In some situations, such as an open-address hash table, we may wish to consider a table to be full if its load factor equals some constant strictly less than 1. (See <a class="internaljump" href="#ch17ex14">Exercise 17.4-1</a>.)</p>
</div>
</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0103.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0105.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
