<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title></title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0105.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0107.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="part">
<a name="pt05"></a>
<h1 class="part-title">
<span class="chapter-titlelabel">Part V: </span>Advanced Data Structures</h1>
<div name="listofchapters">
<h2 class="lot-title">Chapter List</h2>
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0107.html#1323" target="_parent" class="chapterjump">Chapter 18:</a> B-Trees</dt>
<dt class="lotentry">
<a href="DDU0113.html#1379" target="_parent" class="chapterjump">Chapter 19:</a> Binomial Heaps</dt>
<dt class="lotentry">
<a href="DDU0117.html#1439" target="_parent" class="chapterjump">Chapter 20:</a> Fibonacci Heaps</dt>
<dt class="lotentry">
<a href="DDU0123.html#1496" target="_parent" class="chapterjump">Chapter 21:</a> Data Structures for Disjoint Sets</dt>
</dl>
</div>
</div>
<div class="partintro">
<h3 class="partintro-title">

</h3>
<a name="1319"></a><a name="IDX-430"></a><a name="1320"></a><a name="IDX-431"></a>
<div class="section">
<h2 class="sect2-title">Introduction</h2>
<p class="first-para">This part returns to the examination of data structures that support operations on dynamic sets but at a more advanced level than <a href="DDU0057.html#615" target="_parent" class="chapterjump">Part III</a>. Two of the chapters, for example, make extensive use of the amortized analysis techniques we saw in <a href="DDU0100.html#1250" target="_parent" class="chapterjump">Chapter 17</a>.</p>
<p class="para">
<a href="DDU0107.html#1323" target="_parent" class="chapterjump">Chapter 18</a> presents B-trees, which are balanced search trees specifically designed to be stored on magnetic disks. Because magnetic disks operate much more slowly than random-access memory, we measure the performance of B-trees not only by how much computing time the dynamic-set operations consume but also by how many disk accesses are performed. For each B-tree operation, the number of disk accesses increases with the height of the B-tree, which is kept low by the B-tree operations.</p>
<p class="para">
<a href="DDU0113.html#1379" target="_parent" class="chapterjump">Chapters 19</a> and <a href="DDU0117.html#1439" target="_parent" class="chapterjump">20</a> give implementations of mergeable heaps, which support the operations INSERT, MINIMUM, EXTRACT-MIN, and UNION.<sup>[<a name="N56" href="#ftn.N56">1</a>]</sup> The UNION operation unites, or merges, two heaps. The data structures in these chapters also support the operations DELETE and DECREASE-KEY.</p>
<p class="para">Binomial heaps, which appear in <a href="DDU0113.html#1379" target="_parent" class="chapterjump">Chapter 19</a>, support each of these operations in <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) worst-case time, where <i class="emphasis">n</i> is the total number of elements in the input heap (or in the two input heaps together in the case of UNION). When the UNION operation must be supported, binomial heaps are superior to the binary heaps in<a name="1321"></a><a name="IDX-432"></a>troduced in <a href="DDU0035.html#382" target="_parent" class="chapterjump">Chapter 6</a>, because it takes <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) time to unite two binary heaps in the worst case.</p>
<p class="para">Fibonacci heaps, in <a href="DDU0117.html#1439" target="_parent" class="chapterjump">Chapter 20</a>, improve upon binomial heaps, at least in a theoretical sense. We use amortized time bounds to measure the performance of Fibonacci heaps. The operations INSERT, MINIMUM, and UNION take only <i class="emphasis">O</i>(1) actual and amortized time on Fibonacci heaps, and the operations EXTRACT-MIN and DELETE take <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) amortized time. The most significant advantage of Fibonacci heaps, however, is that DECREASE-KEY takes only <i class="emphasis">O</i>(1) amortized time. The low amortized time of the DECREASE-KEY operation is why Fibonacci heaps are key components of some of the asymptotically fastest algorithms to date for graph problems.</p>
<p class="para">Finally, <a href="DDU0123.html#1496" target="_parent" class="chapterjump">Chapter 21</a> presents data structures for disjoint sets. We have a universe of <i class="emphasis">n</i> elements that are grouped into dynamic sets. Initially, each element belongs to its own singleton set. The operation UNION unites two sets, and the query FIND-SET identifies the set that a given element is in at the moment. By representing each set by a simple rooted tree, we obtain surprisingly fast operations: a sequence of <i class="emphasis">m</i> operations runs in <i class="emphasis">O</i>(<i class="emphasis">m <span class="unicode">&alpha;</span></i>(<i class="emphasis">n</i>)) time, where <i class="emphasis"><span class="unicode">&alpha;</span></i>(<i class="emphasis">n</i>) is an incredibly slowly growing function<span class="unicode">-</span><i class="emphasis"><span class="unicode">&alpha;</span></i>(<i class="emphasis">n</i>) is at most 4 in any conceivable application. The amortized analysis that proves this time bound is as complex as the data structure is simple.</p>
<p class="para">The topics covered in this part are by no means the only examples of "advanced" data structures. Other advanced data structures include the following:</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">
<b class="bold"><i class="emphasis">Dynamic trees</i></b>, introduced by <a href="DDU0259.html#3836" target="_parent" class="chapterjump">Sleator and Tarjan [281]</a> and discussed by <a href="DDU0259.html#3847" target="_parent" class="chapterjump">Tarjan [292]</a>, maintain a forest of disjoint rooted trees. Each edge in each tree has a real-valued cost. Dynamic trees support queries to find parents, roots, edge costs, and the minimum edge cost on a path from a node up to a root. Trees may be manipulated by cutting edges, updating all edge costs on a path from a node up to a root, linking a root into another tree, and making a node the root of the tree it appears in. One implementation of dynamic trees gives an <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) amortized time bound for each operation; a more complicated implementation yields <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) worst-case time bounds. Dynamic trees are used in some of the asymptotically fastest network-flow algorithms.</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold"><i class="emphasis">Splay trees</i></b>, developed by <a href="DDU0259.html#3837" target="_parent" class="chapterjump">Sleator and Tarjan [282]</a> and discussed by <a href="DDU0259.html#3847" target="_parent" class="chapterjump">Tarjan [292]</a>, are a form of binary search tree on which the standard search-tree operations run in <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) amortized time. One application of splay trees simplifies dynamic trees.</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold"><i class="emphasis">Persistent</i></b> data structures allow queries, and sometimes updates as well, on past versions of a data structure. <a href="DDU0259.html#3637" target="_parent" class="chapterjump">Driscoll, Sarnak, Sleator, and Tarjan [82]</a> present techniques for making linked data structures persistent with only a small time and space cost. <a href="DDU0079.html#929" target="_parent" class="chapterjump">Problem 13-1</a> gives a simple example of a persistent dynamic set.</p>
<a name="1322"></a><a name="IDX-433"></a>
</li>
<li class="listitem">
<p class="first-para">Several data structures allow a faster implementation of dictionary operations (INSERT, DELETE, and SEARCH) for a restricted universe of keys. By taking advantage of these restrictions, they are able to achieve better worst-case asymptotic running times than comparison-based data structures. A data structure invented by <a href="DDU0259.html#3856" target="_parent" class="chapterjump">van Emde Boas [301]</a> supports the operations MINIMUM, MAXIMUM, INSERT, DELETE, SEARCH, EXTRACT-MIN, EXTRACT-MAX, PREDECESSOR, and SUCCESSOR in worst-case time <i class="emphasis">O</i>(lg lg <i class="emphasis">n</i>), subject to the restriction that the universe of keys is the set {1, 2,..., <i class="emphasis">n</i>}. Fredman and Willard introduced <b class="bold"><i class="emphasis">fusion trees</i></b> <a href="DDU0259.html#3654" target="_parent" class="chapterjump">[99]</a>, which were the first data structure to allow faster dictionary operations when the universe is restricted to integers. They showed how to implement these operations in <i class="emphasis">O</i>(lg <i class="emphasis">n</i>/ lg lg <i class="emphasis">n</i>) time. Several subsequent data structures, including <b class="bold"><i class="emphasis">exponential search trees</i></b> <a href="DDU0259.html#3572" target="_parent" class="chapterjump">[16]</a>, have also given improved bounds on some or all of the dictionary operations and are mentioned in the chapter notes throughout this book.</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold"><i class="emphasis">Dynamic graph data structures</i></b> support various queries while allowing the structure of a graph to change through operations that insert or delete vertices or edges. Examples of the queries that are supported include vertex connectivity <a href="DDU0259.html#3699" target="_parent" class="chapterjump">[144]</a>, edge connectivity, minimum spanning trees <a href="DDU0259.html#3698" target="_parent" class="chapterjump">[143]</a>, biconnectivity, and transitive closure <a href="DDU0259.html#3697" target="_parent" class="chapterjump">[142]</a>.</p>
</li>
</ul>
<p class="last-para">Chapter notes throughout this book mention additional data structures.</p>

</div>
</div>
<div class="footnotes">
<div class="footnote">
<p>
<sup>[<a name="ftn.N56" href="#N56">1</a>]</sup>As in <a href="DDU0061.html#691" target="_parent" class="chapterjump">Problem 10-2</a>, we have defined a mergeable heap to support MINIMUM and EXTRACT-MIN, and so we can also refer to it as a <b class="bold"><i class="emphasis">mergeable min-heap</i></b>. Alternatively, if it supported MAXIMUM and EXTRACT-MAX, it would be a <b class="bold"><i class="emphasis">mergeable max-heap</i></b>. Unless we specify otherwise, mergeable heaps will be by default mergeable min-heaps.</p>
</div>
</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0105.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0107.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
