<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>19.2 Operations on binomial heaps</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0114.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0116.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch19"></a>
<div class="section">
<h2 class="first-section-title">
<a name="1400"></a><a name="ch19lev1sec2"></a><span class="section-titlelabel">19.2 </span>Operations on binomial heaps</h2>
<p class="first-para">In this section, we show how to perform operations on binomial heaps in the time bounds shown in <a href="DDU0113.html#1382" target="_parent" class="chapterjump">Figure 19.1</a>. We shall only show the upper bounds; the lower bounds are left as <a class="internaljump" href="#ch19ex15">Exercise 19.2-10</a>.</p>
<div class="section">
<h4 class="sect4-title">
<a name="1401"></a><a name="ch19lev3sec2"></a>Creating a new binomial heap</h4>
<p class="first-para">To make an empty binomial heap, the MAKE-BINOMIAL-HEAP procedure simply allocates and returns an object <i class="emphasis">H</i> , where <i class="emphasis">head</i>[<i class="emphasis">H</i> ] = NIL. The running time is <span class="unicode">&Theta;</span>(1).</p>
<a name="1402"></a><a name="IDX-462"></a>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1403"></a><a name="ch19lev3sec3"></a>Finding the minimum key</h4>
<p class="first-para">The procedure BINOMIAL-HEAP-MINIMUM returns a pointer to the node with the minimum key in an <i class="emphasis">n</i>-node binomial heap <i class="emphasis">H</i>. This implementation assumes that there are no keys with value <span class="unicode">&infin;</span>. (See <a class="internaljump" href="#ch19ex10">Exercise 19.2-5</a>.)</p>
<div class="informalexample">
<pre class="literallayout-normal">
BINOMIAL-HEAP-MINIMUM(<i class="emphasis">H</i>)
1  <i class="emphasis">y</i> <span class="unicode">&larr;</span> NIL
2  <i class="emphasis">x</i> <span class="unicode">&larr;</span> <i class="emphasis">head</i>[<i class="emphasis">H</i>]
3  <i class="emphasis">min</i> <span class="unicode">&larr;</span> <span class="unicode">&infin;</span>
4  <b class="bold">while</b> <i class="emphasis">x</i> <span class="unicode">&ne;</span> NIL
5     <b class="bold">do if</b> <i class="emphasis">key</i>[<i class="emphasis">x</i>] <span class="unicode">&lt;</span> <i class="emphasis">min</i>
6           <b class="bold">then</b> <i class="emphasis">min</i> <span class="unicode">&larr;</span> <i class="emphasis">key</i>[<i class="emphasis">x</i>]
7                <i class="emphasis">y</i> <span class="unicode">&larr;</span> <i class="emphasis">x</i>
8         <i class="emphasis">x</i> <span class="unicode">&larr;</span> <i class="emphasis">sibling</i>[<i class="emphasis">x</i>]
9  <b class="bold">return</b> <i class="emphasis">y</i>
</pre>
</div>
<p class="para">Since a binomial heap is min-heap-ordered, the minimum key must reside in a root node. The BINOMIAL-HEAP-MINIMUM procedure checks all roots, which number at most<span class="unicode">&lfloor;</span>lg <i class="emphasis">n</i><span class="unicode">&rfloor;</span> + 1, saving the current minimum in <i class="emphasis">min</i> and a pointer to the current minimum in <i class="emphasis">y</i>. When called on the binomial heap of <a href="DDU0114.html#1393" target="_parent" class="chapterjump">Figure 19.3</a>, BINOMIAL-HEAP-MINIMUM returns a pointer to the node with key 1.</p>
<p class="last-para">Because there are at most <span class="unicode">&lfloor;</span>lg <i class="emphasis">n</i><span class="unicode">&rfloor;</span> + 1 roots to check, the running time of BINOMIAL-HEAP-MINIMUM is <i class="emphasis">O</i>(lg <i class="emphasis">n</i>).</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1404"></a><a name="ch19lev3sec4"></a>Uniting two binomial heaps</h4>
<p class="first-para">The operation of uniting two binomial heaps is used as a subroutine by most of the remaining operations. The BINOMIAL-HEAP-UNION procedure repeatedly links binomial trees whose roots have the same degree. The following procedure links the <i class="emphasis">B</i><sub><i class="emphasis">k</i>-1</sub> tree rooted at node <i class="emphasis">y</i> to the <i class="emphasis">B</i><sub><i class="emphasis">k</i>-1</sub> tree rooted at node <i class="emphasis">z</i>; that is, it makes <i class="emphasis">z</i> the parent of <i class="emphasis">y</i>. Node <i class="emphasis">z</i> thus becomes the root of a <i class="emphasis">B<sub>k</sub></i> tree.</p>
<div class="informalexample">
<pre class="literallayout-normal">
BINOMIAL-LINK(<i class="emphasis">y</i>, <i class="emphasis">z</i>)
1  <i class="emphasis">p</i>[<i class="emphasis">y</i>] <span class="unicode">&larr;</span> <i class="emphasis">z</i>
2  <i class="emphasis">sibling</i>[<i class="emphasis">y</i>] <span class="unicode">&larr;</span> <i class="emphasis">child</i>[<i class="emphasis">z</i>]
3  <i class="emphasis">child</i>[<i class="emphasis">z</i>] <span class="unicode">&larr;</span> <i class="emphasis">y</i>
4  <i class="emphasis">degree</i>[<i class="emphasis">z</i>] <span class="unicode">&larr;</span> <i class="emphasis">degree</i>[<i class="emphasis">z</i>] + 1
</pre>
</div>
<p class="para">The BINOMIAL-LINK procedure makes node <i class="emphasis">y</i> the new head of the linked list of node <i class="emphasis">z</i>'s children in <i class="emphasis">O</i>(1) time. It works because the left-child, right-sibling representation of each binomial tree matches the ordering property of the tree: in a <i class="emphasis">B<sub>k</sub></i> tree, the leftmost child of the root is the root of a <i class="emphasis">B</i><sub><i class="emphasis">k</i>-1</sub> tree.<a name="1405"></a><a name="IDX-463"></a>
</p>
<p class="para">The following procedure unites binomial heaps <i class="emphasis">H</i><sub>1</sub> and <i class="emphasis">H</i><sub>2</sub>, returning the resulting heap. It destroys the representations of <i class="emphasis">H</i><sub>1</sub> and <i class="emphasis">H</i><sub>2</sub> in the process. Besides BINOMIAL-LINK, the procedure uses an auxiliary procedure BINOMIAL-HEAP-MERGE that merges the root lists of <i class="emphasis">H</i><sub>1</sub> and <i class="emphasis">H</i><sub>2</sub> into a single linked list that is sorted by degree into monotonically increasing order. The BINOMIAL-HEAP-MERGE procedure, whose pseudocode we leave as <a class="internaljump" href="#ch19ex06">Exercise 19.2-1</a>, is similar to the MERGE procedure in <a href="DDU0016.html#90" target="_parent" class="chapterjump">Section 2.3.1</a>.</p>
<div class="informalexample">
<pre class="literallayout-normal">
BINOMIAL-HEAP-UNION(<i class="emphasis">H</i><sub>1</sub>, <i class="emphasis">H</i><sub>2</sub>)
 1  <i class="emphasis">H</i> <span class="unicode">&larr;</span> MAKE-BINOMIAL-HEAP()
 2  <i class="emphasis">head</i>[<i class="emphasis">H</i>] <span class="unicode">&larr;</span> BINOMIAL-HEAP-MERGE(<i class="emphasis">H</i><sub>1</sub>, <i class="emphasis">H</i><sub>2</sub>)
 3  free the objects <i class="emphasis">H</i><sub>1</sub> and <i class="emphasis">H</i><sub>2</sub> but not the lists they point to
 4  <b class="bold">if</b> <i class="emphasis">head</i>[<i class="emphasis">H</i>] = NIL
 5     <b class="bold">then return</b> <i class="emphasis">H</i>
 6  <i class="emphasis">prev</i>-<i class="emphasis">x</i> <span class="unicode">&larr;</span> NIL
 7  <i class="emphasis">x</i> <span class="unicode">&larr;</span> <i class="emphasis">head</i>[<i class="emphasis">H</i>]
 8  <i class="emphasis">next</i>-<i class="emphasis">x</i> <span class="unicode">&larr;</span> <i class="emphasis">sibling</i>[<i class="emphasis">x</i>]
 9  <b class="bold">while</b> <i class="emphasis">next</i>-<i class="emphasis">x</i> <span class="unicode">&ne;</span> NIL
10      <b class="bold">do if</b> (<i class="emphasis">degree</i>[<i class="emphasis">x</i>] <span class="unicode">&ne;</span> <i class="emphasis">degree</i>[<i class="emphasis">next</i>-<i class="emphasis">x</i>]) or 
                (<i class="emphasis">sibling</i>[<i class="emphasis">next</i>-<i class="emphasis">x</i>] <span class="unicode">&ne;</span> NIL and <i class="emphasis">degree</i>[<i class="emphasis">sibling</i>[<i class="emphasis">next</i>-<i class="emphasis">x</i>]] = <i class="emphasis">degree</i>[<i class="emphasis">x</i>])
11            <b class="bold">then</b> <i class="emphasis">prev</i>-<i class="emphasis">x</i> <span class="unicode">&larr;</span> <i class="emphasis">x</i>                                <span class="unicode">&#9657;</span> Cases 1 and 2
12                 <i class="emphasis">x</i> <span class="unicode">&larr;</span> <i class="emphasis">next</i>-<i class="emphasis">x</i>                                <span class="unicode">&#9657;</span> Cases 1 and 2
13            <b class="bold">else if</b> <i class="emphasis">key</i>[<i class="emphasis">x</i>] <span class="unicode">&le;</span> <i class="emphasis">key</i>[<i class="emphasis">next</i>-<i class="emphasis">x</i>]
14                    <b class="bold">then</b> <i class="emphasis">sibling</i>[<i class="emphasis">x</i>] <span class="unicode">&larr;</span> <i class="emphasis">sibling</i>[<i class="emphasis">next</i>-<i class="emphasis">x</i>]          <span class="unicode">&#9657;</span> Case 3
15                         BINOMIAL-LINK(<i class="emphasis">next</i>-<i class="emphasis">x</i>, <i class="emphasis">x</i>)               <span class="unicode">&#9657;</span> Case 3
16                    <b class="bold">else if</b> <i class="emphasis">prev</i>-<i class="emphasis">x</i> = NIL                        <span class="unicode">&#9657;</span> Case 4
17                            <b class="bold">then</b> <i class="emphasis">head</i>[<i class="emphasis">H</i>] <span class="unicode">&larr;</span> <i class="emphasis">next</i>-<i class="emphasis">x</i>              <span class="unicode">&#9657;</span> Case 4
18                            <b class="bold">else</b> <i class="emphasis">sibling</i>[<i class="emphasis">prev</i>-<i class="emphasis">x</i>] <span class="unicode">&larr;</span> <i class="emphasis">next</i>-<i class="emphasis">x</i>       <span class="unicode">&#9657;</span> Case 4
19                         BINOMIAL-LINK(<i class="emphasis">x</i>, <i class="emphasis">next</i>-<i class="emphasis">x</i>)               <span class="unicode">&#9657;</span> Case 4
20                         <i class="emphasis">x</i> <span class="unicode">&larr;</span> <i class="emphasis">next</i>-<i class="emphasis">x</i>                            <span class="unicode">&#9657;</span> Case 4
21         <i class="emphasis">next</i>-<i class="emphasis">x</i> <span class="unicode">&larr;</span> <i class="emphasis">sibling</i>[<i class="emphasis">x</i>]
22  <b class="bold">return</b> <i class="emphasis">H</i>
</pre>
</div>
<p class="para">
<a class="internaljump" href="#ch19fig05">Figure 19.5</a> shows an example of BINOMIAL-HEAP-UNION in which all four cases given in the pseudocode occur.</p>
<div class="figure">
<a name="1406"></a><a name="ch19fig05"></a><span class="figuremediaobject"><a href="images/fig486%5F01%5F0%2Ejpg" NAME="IMG_582" target="_parent"><img src="images/fig486_01.jpg" height="252" width="350" alt="Click To expand" border="0"></a></span><span class="figurespace">&nbsp;</span><span class="figuremediaobject"><a href="images/fig487%5F01%5F0%2Ejpg" NAME="IMG_583" target="_parent"><img src="images/fig487_01.jpg" height="311" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 19.5: </span>The execution of BINOMIAL-HEAP-UNION. <i class="emphasis">(a)</i> Binomial heaps <i class="emphasis">H</i><sub>1</sub> and <i class="emphasis">H</i><sub>2</sub>. <i class="emphasis">(b)</i> Binomial heap <i class="emphasis">H</i> is the output of BINOMIAL-HEAP-MERGE(<i class="emphasis">H</i><sub>1</sub>, <i class="emphasis">H</i><sub>2</sub>). Initially, <i class="emphasis">x</i> is the first root on the root list of <i class="emphasis">H</i> . Because both <i class="emphasis">x</i> and <i class="emphasis">next-x</i> have degree 0 and <i class="emphasis">key</i>[<i class="emphasis">x</i>] <span class="unicode">&lt;</span> <i class="emphasis">key</i>[<i class="emphasis">next-x</i>], case 3 applies. <i class="emphasis">(c)</i> After the link occurs, <i class="emphasis">x</i> is the first of three roots with the same degree, so case 2 applies. <i class="emphasis">(d)</i> After all the pointers move down one position in the root list, case 4 applies, since <i class="emphasis">x</i> is the first of two roots of equal degree. <i class="emphasis">(e)</i> After the link occurs, case 3 applies. <i class="emphasis">(f)</i> After another link, case 1 applies, because <i class="emphasis">x</i> has degree 3 and <i class="emphasis">next-x</i> has degree 4. This iteration of the <i class="emphasis">while</i> loop is the last, because after the pointers move down one position in the root list, <i class="emphasis">next-x</i> = NIL.</span>
</div>
<p class="para">The BINOMIAL-HEAP-UNION procedure has two phases. The first phase, performed by the call of BINOMIAL-HEAP-MERGE, merges the root lists of binomial heaps <i class="emphasis">H</i><sub>1</sub> and <i class="emphasis">H</i><sub>2</sub> into a single linked list <i class="emphasis">H</i> that is sorted by degree into monotonically increasing order. There might be as many as two roots (but no more) of each degree, however, so the second phase links roots of equal degree until at most one root remains of each degree. Because the linked list <i class="emphasis">H</i> is sorted by degree, we can perform all the link operations quickly.<a name="1407"></a><a name="IDX-464"></a>
</p>
<p class="para">In detail, the procedure works as follows. Lines 1<span class="unicode">-</span>3 start by merging the root lists of binomial heaps <i class="emphasis">H</i><sub>1</sub> and <i class="emphasis">H</i><sub>2</sub> into a single root list <i class="emphasis">H</i> . The root lists of <i class="emphasis">H</i><sub>1</sub> and <i class="emphasis">H</i><sub>2</sub> are sorted by strictly increasing degree, and BINOMIAL-HEAP-MERGE returns a root list <i class="emphasis">H</i> that is sorted by monotonically increasing degree. If the root lists of <i class="emphasis">H</i><sub>1</sub> and <i class="emphasis">H</i><sub>2</sub> have <i class="emphasis">m</i> roots altogether, BINOMIAL-HEAP-MERGE runs in <i class="emphasis">O</i>(<i class="emphasis">m</i>) time by repeatedly examining the roots at the heads of the two root lists and appending the root with the lower degree to the output root list, removing it from its input root list in the process.<a name="1408"></a><a name="IDX-465"></a>
</p>
<p class="para">The BINOMIAL-HEAP-UNION procedure next initializes some pointers into the root list of <i class="emphasis">H</i> . First, it simply returns in lines 4<span class="unicode">-</span>5 if it happens to be uniting two empty binomial heaps. From line 6 on, therefore, we know that <i class="emphasis">H</i> has at least one root. Throughout the procedure, we maintain three pointers into the root list:</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">
<i class="emphasis">x</i> points to the root currently being examined,</p>
</li>
<li class="listitem">
<p class="first-para">
<i class="emphasis">prev</i>-<i class="emphasis">x</i> points to the root preceding <i class="emphasis">x</i> on the root list: <i class="emphasis">sibling</i>[<i class="emphasis">prev</i>-<i class="emphasis">x</i>] = <i class="emphasis">x</i> (since initially <i class="emphasis">x</i> has no predecessor, we start with <i class="emphasis">prev</i>-<i class="emphasis">x</i> set to NIL), and</p>
</li>
<li class="listitem">
<p class="first-para">
<i class="emphasis">next</i>-<i class="emphasis">x</i> points to the root following <i class="emphasis">x</i> on the root list: <i class="emphasis">sibling</i>[<i class="emphasis">x</i>] = <i class="emphasis">next</i>-<i class="emphasis">x</i>.</p>
</li>
</ul>
<p class="para">Initially, there are at most two roots on the root list <i class="emphasis">H</i> of a given degree: because <i class="emphasis">H</i><sub>1</sub> and <i class="emphasis">H</i><sub>2</sub> were binomial heaps, they each had at most one root of a given degree. Moreover, BINOMIAL-HEAP-MERGE guarantees us that if two roots in <i class="emphasis">H</i> have the same degree, they are adjacent in the root list.</p>
<p class="para">In fact, during the execution of BINOMIAL-HEAP-UNION, there may be three roots of a given degree appearing on the root list <i class="emphasis">H</i> at some time. We shall see <a name="1409"></a><a name="IDX-466"></a>in a moment how this situation could occur. At each iteration of the <b class="bold">while</b> loop of lines 9<span class="unicode">-</span>21, therefore, we decide whether to link <i class="emphasis">x</i> and <i class="emphasis">next</i>-<i class="emphasis">x</i> based on their degrees and possibly the degree of <i class="emphasis">sibling</i>[<i class="emphasis">next</i>-<i class="emphasis">x</i>]. An invariant of the loop is that each time we start the body of the loop, both <i class="emphasis">x</i> and <i class="emphasis">next</i>-<i class="emphasis">x</i> are non-NIL. (See <a class="internaljump" href="#ch19ex09">Exercise 19.2-4</a> for a precise loop invariant.)</p>
<p class="para">Case 1, shown in <a class="internaljump" href="#ch19fig06">Figure 19.6(a)</a>, occurs when <i class="emphasis">degree</i>[<i class="emphasis">x</i>] <span class="unicode">&ne;</span> <i class="emphasis">degree</i>[<i class="emphasis">next</i>-<i class="emphasis">x</i>], that is, when <i class="emphasis">x</i> is the root of a <i class="emphasis">B<sub>k</sub></i>-tree and <i class="emphasis">next</i>-<i class="emphasis">x</i> is the root of a <i class="emphasis">B<sub>l</sub></i>-tree for some <i class="emphasis">l</i> <i class="emphasis"><span class="unicode">&gt;</span></i> <i class="emphasis">k</i>. Lines 11<span class="unicode">-</span>12 handle this case. We don't link <i class="emphasis">x</i> and <i class="emphasis">next</i>-<i class="emphasis">x</i>, so we simply march the pointers one position farther down the list. Updating <i class="emphasis">next</i>-<i class="emphasis">x</i> to point to the node following the new node <i class="emphasis">x</i> is handled in line 21, which is common to every case.</p>
<div class="figure">
<a name="1410"></a><a name="ch19fig06"></a><span class="figuremediaobject"><a href="images/fig489%5F01%5F0%2Ejpg" NAME="IMG_584" target="_parent"><img src="images/fig489_01.jpg" height="261" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 19.6: </span>The four cases that occur in BINOMIAL-HEAP-UNION. Labels <i class="emphasis">a, b, c</i>, and <i class="emphasis">d</i> serve only to identify the roots involved; they do not indicate the degrees or keys of these roots. In each case, <i class="emphasis">x</i> is the root of a <i class="emphasis">B<sub>k</sub></i>-tree and <i class="emphasis">l</i> <span class="unicode">&gt;</span> <i class="emphasis">k</i>. <i class="emphasis">(a)</i> Case 1: <i class="emphasis">degree</i>[<i class="emphasis">x</i>] <span class="unicode">&ne;</span> <i class="emphasis">degree</i>[<i class="emphasis">next-x</i>]. The pointers move one position farther down the root list. <i class="emphasis">(b)</i> Case 2: <i class="emphasis">degree</i>[<i class="emphasis">x</i>] = <i class="emphasis">degree</i>[<i class="emphasis">next-x</i>] = <i class="emphasis">degree</i>[<i class="emphasis">sibling</i>[<i class="emphasis">next-x</i>]]. Again, the pointers move one position farther down the list, and the next iteration executes either case 3 or case 4. <i class="emphasis">(c)</i> Case 3: <i class="emphasis">degree</i>[<i class="emphasis">x</i>] = <i class="emphasis">degree</i>[<i class="emphasis">next-x</i>] <span class="unicode">&ne;</span> <i class="emphasis">degree</i>[<i class="emphasis">sibling</i>[<i class="emphasis">next-x</i>]] and <i class="emphasis">key</i>[<i class="emphasis">x</i>] <span class="unicode">&le;</span> <i class="emphasis">key</i>[<i class="emphasis">next-x</i>]. We remove <i class="emphasis">next-x</i> from the root list and link it to <i class="emphasis">x</i>, creating a <i class="emphasis">B</i><sub><i class="emphasis">k</i>+1</sub>-tree. <i class="emphasis">(d)</i> Case 4: <i class="emphasis">degree</i>[<i class="emphasis">x</i>] = <i class="emphasis">degree</i>[<i class="emphasis">next-x</i>] <span class="unicode">&ne;</span> <i class="emphasis">degree</i>[<i class="emphasis">sibling</i>[<i class="emphasis">next-x</i>]] and <i class="emphasis">key</i>[<i class="emphasis">next-x</i>] <span class="unicode">&le;</span> <i class="emphasis">key</i>[<i class="emphasis">x</i>]. We remove <i class="emphasis">x</i> from the root list and link it to <i class="emphasis">next-x</i>, again creating a <i class="emphasis">B</i><sub><i class="emphasis">k</i>+1</sub>-tree.</span>
</div>
<p class="para">Case 2, shown in <a class="internaljump" href="#ch19fig06">Figure 19.6(b)</a>, occurs when <i class="emphasis">x</i> is the first of three roots of equal degree, that is, when</p>
<p class="para">
<i class="emphasis">degree</i>[<i class="emphasis">x</i>] = <i class="emphasis">degree</i>[<i class="emphasis">next</i>-<i class="emphasis">x</i>] = <i class="emphasis">degree</i>[<i class="emphasis">sibling</i>[<i class="emphasis">next</i>-<i class="emphasis">x</i>]].</p>
<p class="para">We handle this case in the same manner as case 1: we just march the pointers one position farther down the list. The next iteration will execute either case 3 or case 4 to combine the second and third of the three equal-degree roots. Line 10 tests for both cases 1 and 2, and lines 11<span class="unicode">-</span>12 handle both cases.</p>
<p class="para">Cases 3 and 4 occur when <i class="emphasis">x</i> is the first of two roots of equal degree, that is, when</p>
<p class="para">
<i class="emphasis">degree</i>[<i class="emphasis">x</i>] = <i class="emphasis">degree</i>[<i class="emphasis">next</i>-<i class="emphasis">x</i>] <span class="unicode">&ne;</span> <i class="emphasis">degree</i>[<i class="emphasis">sibling</i>[<i class="emphasis">next</i>-<i class="emphasis">x</i>]].</p>
<p class="para">These cases may occur in any iteration, but one of them always occurs immediately following case 2. In cases 3 and 4, we link <i class="emphasis">x</i> and <i class="emphasis">next</i>-<i class="emphasis">x</i>. The two cases are distinguished by whether <i class="emphasis">x</i> or <i class="emphasis">next</i>-<i class="emphasis">x</i> has the smaller key, which determines the node that will be the root after the two are linked.</p>
<p class="para">In case 3, shown in <a class="internaljump" href="#ch19fig06">Figure 19.6(c)</a>, <i class="emphasis">key</i>[<i class="emphasis">x</i>] <span class="unicode">&le;</span> <i class="emphasis">key</i>[<i class="emphasis">next</i>-<i class="emphasis">x</i>], so <i class="emphasis">next</i>-<i class="emphasis">x</i> is linked to <i class="emphasis">x</i>. Line 14 removes <i class="emphasis">next</i>-<i class="emphasis">x</i> from the root list, and line 15 makes <i class="emphasis">next</i>-<i class="emphasis">x</i> the leftmost child of <i class="emphasis">x</i>.</p>
<p class="para">In case 4, shown in <a class="internaljump" href="#ch19fig06">Figure 19.6(d)</a>, <i class="emphasis">next</i>-<i class="emphasis">x</i> has the smaller key, so <i class="emphasis">x</i> is linked to <i class="emphasis">next</i>-<i class="emphasis">x</i>. Lines 16<span class="unicode">-</span>18 remove <i class="emphasis">x</i> from the root list; there are two cases depending on whether <i class="emphasis">x</i> is the first root on the list (line 17) or is not (line 18). Line 19 then makes <i class="emphasis">x</i> the leftmost child of <i class="emphasis">next</i>-<i class="emphasis">x</i>, and line 20 updates <i class="emphasis">x</i> for the next iteration.</p>
<p class="para">Following either case 3 or case 4, the setup for the next iteration of the <b class="bold">while</b> loop is the same. We have just linked two <i class="emphasis">B<sub>k</sub></i>-trees to form a <i class="emphasis">B</i><sub><i class="emphasis">k</i>+1</sub>-tree, which <i class="emphasis">x</i> now points to. There were already zero, one, or two other <i class="emphasis">B</i><sub><i class="emphasis">k</i>+1</sub>-trees on the root list resulting from BINOMIAL-HEAP-MERGE, so <i class="emphasis">x</i> is now the first of either one, two, or three <i class="emphasis">B</i><sub><i class="emphasis">k</i>+1</sub>-trees on the root list. If <i class="emphasis">x</i> is the only one, then we enter case 1 in the next iteration: <i class="emphasis">degree</i>[<i class="emphasis">x</i>] <span class="unicode">&ne;</span> <i class="emphasis">degree</i>[<i class="emphasis">next</i>-<i class="emphasis">x</i>]. If <i class="emphasis">x</i> is the first of two, then we enter either case 3 or case 4 in the next iteration. It is when <i class="emphasis">x</i> is the first of three that we enter case 2 in the next iteration.</p>
<p class="last-para">The running time of BINOMIAL-HEAP-UNION is <i class="emphasis">O</i>(lg <i class="emphasis">n</i>), where <i class="emphasis">n</i> is the total number of nodes in binomial heaps <i class="emphasis">H</i><sub>1</sub> and <i class="emphasis">H</i><sub>2</sub>. We can see this as follows. Let <i class="emphasis">H</i><sub>1</sub> <a name="1411"></a><a name="IDX-467"></a>contain <i class="emphasis">n</i><sub>1</sub> nodes and <i class="emphasis">H</i><sub>2</sub> contain <i class="emphasis">n</i><sub>2</sub> nodes, so that <i class="emphasis">n</i> = <i class="emphasis">n</i><sub>1</sub> + <i class="emphasis">n</i><sub>2</sub>. Then <i class="emphasis">H</i><sub>1</sub> contains at most <span class="unicode">&lfloor;</span>lg <i class="emphasis">n</i><sub>1</sub><span class="unicode">&rfloor;</span>+1 roots and <i class="emphasis">H</i><sub>2</sub> contains at most <span class="unicode">&lfloor;</span>lg <i class="emphasis">n</i><sub>2</sub><span class="unicode">&rfloor;</span>+1 roots, and so <i class="emphasis">H</i> contains at most <span class="unicode">&lfloor;</span>lg <i class="emphasis">n</i><sub>1</sub><span class="unicode">&rfloor;</span>+<span class="unicode">&lfloor;</span>lg <i class="emphasis">n</i><sub>2</sub><span class="unicode">&rfloor;</span>+2 <span class="unicode">&le;</span> 2<span class="unicode">&lfloor;</span>lg <i class="emphasis">n</i><span class="unicode">&rfloor;</span>+2 = <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) roots immediately after the call of BINOMIAL-HEAP-MERGE. The time to perform BINOMIAL-HEAP-MERGE is thus <i class="emphasis">O</i>(lg <i class="emphasis">n</i>). Each iteration of the <b class="bold">while</b> loop takes <i class="emphasis">O</i>(1) time, and there are at most <span class="unicode">&lfloor;</span>lg <i class="emphasis">n</i><sub>1</sub><span class="unicode">&rfloor;</span> + <span class="unicode">&lfloor;</span>lg<i class="emphasis">n</i><sub>2</sub><span class="unicode">&rfloor;</span> + 2 iterations because each iteration either advances the <a name="1412"></a><a name="IDX-468"></a>pointers one position down the root list of <i class="emphasis">H</i> or removes a root from the root list. The total time is thus <i class="emphasis">O</i>(lg <i class="emphasis">n</i>).</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1413"></a><a name="ch19lev3sec5"></a>Inserting a node</h4>
<p class="first-para">The following procedure inserts node <i class="emphasis">x</i> into binomial heap <i class="emphasis">H</i> , assuming that <i class="emphasis">x</i> has already been allocated and <i class="emphasis">key</i>[<i class="emphasis">x</i>] has already been filled in.</p>
<div class="informalexample">
<pre class="literallayout-normal">
BINOMIAL-HEAP-INSERT(<i class="emphasis">H</i>, <i class="emphasis">x</i>)
1  <i class="emphasis">H</i><span class="unicode">&prime;</span> <span class="unicode">&larr;</span> MAKE-BINOMIAL-HEAP()
2  <i class="emphasis">p</i>[<i class="emphasis">x</i>] <span class="unicode">&larr;</span> NIL
3  <i class="emphasis">child</i>[<i class="emphasis">x</i>] <span class="unicode">&larr;</span> NIL
4  <i class="emphasis">sibling</i>[<i class="emphasis">x</i>] <span class="unicode">&larr;</span> NIL
5  <i class="emphasis">degree</i>[<i class="emphasis">x</i>] <span class="unicode">&larr;</span> 0
6  <i class="emphasis">head</i>[<i class="emphasis">H</i><span class="unicode">&prime;</span>] <span class="unicode">&larr;</span> <i class="emphasis">x</i>
7  <i class="emphasis">H</i> <span class="unicode">&larr;</span> BINOMIAL-HEAP-UNION(<i class="emphasis">H</i>, <i class="emphasis">H</i><span class="unicode">&prime;</span>)
</pre>
</div>
<p class="last-para">The procedure simply makes a one-node binomial heap <i class="emphasis">H</i><span class="unicode">&prime;</span> in <i class="emphasis">O</i>(1) time and unites it with the <i class="emphasis">n</i>-node binomial heap <i class="emphasis">H</i> in <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) time. The call to BINOMIAL-HEAP-UNION takes care of freeing the temporary binomial heap <i class="emphasis">H</i><span class="unicode">&prime;</span>. (A direct implementation that does not call BINOMIAL-HEAP-UNION is given as <a class="internaljump" href="#ch19ex13">Exercise 19.2-8</a>.)</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1414"></a><a name="ch19lev3sec6"></a>Extracting the node with minimum key</h4>
<p class="first-para">The following procedure extracts the node with the minimum key from binomial heap <i class="emphasis">H</i> and returns a pointer to the extracted node.</p>
<div class="informalexample">
<pre class="literallayout-normal">
BINOMIAL-HEAP-EXTRACT-MIN(<i class="emphasis">H</i>)
1  find the root <i class="emphasis">x</i> with the minimum key in the root list of <i class="emphasis">H</i>,
            and remove <i class="emphasis">x</i> from the root list of <i class="emphasis">H</i>
2  <i class="emphasis">H</i><span class="unicode">&prime;</span> <span class="unicode">&larr;</span> MAKE-BINOMIAL-HEAP()
3  reverse the order of the linked list of <i class="emphasis">x</i>'s children,
            and set <i class="emphasis">head</i>[<i class="emphasis">H</i><span class="unicode">&prime;</span>] to point to the head of the resulting list
4  <i class="emphasis">H</i> <span class="unicode">&larr;</span> BINOMIAL-HEAP-UNION(<i class="emphasis">H</i>, <i class="emphasis">H</i><span class="unicode">&prime;</span>)
5  <b class="bold">return</b> <i class="emphasis">x</i>
</pre>
</div>
<p class="para">This procedure works as shown in <a class="internaljump" href="#ch19fig07">Figure 19.7</a>. The input binomial heap <i class="emphasis">H</i> is shown in <a class="internaljump" href="#ch19fig07">Figure 19.7(a)</a>. <a class="internaljump" href="#ch19fig07">Figure 19.7(b)</a> shows the situation after line 1: the root <i class="emphasis">x</i> with the minimum key has been removed from the root list of <i class="emphasis">H</i> . If <i class="emphasis">x</i> is the root of a <i class="emphasis">B</i><sub><i class="emphasis">k</i></sub>-tree, then by property 4 of <a href="DDU0114.html#1388" target="_parent" class="chapterjump">Lemma 19.1</a>, <i class="emphasis">x</i>'s children, from left to right, are roots of <i class="emphasis">B</i><sub><i class="emphasis">k</i>-1</sub>-, <i class="emphasis">B</i><sub><i class="emphasis">k</i>-2</sub>-, ..., <i class="emphasis">B</i><sub>0</sub>-trees. <a class="internaljump" href="#ch19fig07">Figure 19.7(c)</a> shows that by reversing the list of <i class="emphasis">x</i>'s children in line 3, we have a binomial heap <i class="emphasis">H</i><span class="unicode">&prime;</span> that contains every node <a name="1415"></a><a name="IDX-469"></a>in <i class="emphasis">x</i>'s tree except for <i class="emphasis">x</i> itself. Because <i class="emphasis">x</i>'s tree was removed from <i class="emphasis">H</i> in line 1, the binomial heap that results from uniting <i class="emphasis">H</i> and <i class="emphasis">H</i><span class="unicode">&prime;</span> in line 4, shown in <a class="internaljump" href="#ch19fig07">Figure 19.7(d)</a>, contains all the nodes originally in <i class="emphasis">H</i> except for <i class="emphasis">x</i>. Finally, line 5 returns <i class="emphasis">x</i>.</p>
<div class="figure">
<a name="1416"></a><a name="ch19fig07"></a><span class="figuremediaobject"><a href="images/fig491%5F01%5F0%2Ejpg" NAME="IMG_585" target="_parent"><img src="images/fig491_01.jpg" height="304" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 19.7: </span>The action of BINOMIAL-HEAP-EXTRACT-MIN. <i class="emphasis">(a)</i> A binomial heap <i class="emphasis">H</i>. <i class="emphasis">(b)</i> The root <i class="emphasis">x</i> with minimum key is removed from the root list of <i class="emphasis">H</i> . <i class="emphasis">(c)</i> The linked list of <i class="emphasis">x</i>'s children is reversed, giving another binomial heap <i class="emphasis">H</i><span class="unicode">&prime;</span>. <i class="emphasis">(d)</i> The result of uniting <i class="emphasis">H</i> and <i class="emphasis">H'</i>.</span>
</div>
<p class="para">Since each of lines 1<span class="unicode">-</span>4 takes <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) time if <i class="emphasis">H</i> has <i class="emphasis">n</i> nodes, BINOMIAL-HEAP-EXTRACT-MIN runs in <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) time.</p>
<a name="1417"></a><a name="IDX-470"></a>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1418"></a><a name="ch19lev3sec7"></a>Decreasing a key</h4>
<p class="first-para">The following procedure decreases the key of a node <i class="emphasis">x</i> in a binomial heap <i class="emphasis">H</i> to a new value <i class="emphasis">k</i>. It signals an error if <i class="emphasis">k</i> is greater than <i class="emphasis">x</i>'s current key.</p>
<div class="informalexample">
<pre class="literallayout-normal">
BINOMIAL-HEAP-DECREASE-KEY(<i class="emphasis">H</i>, <i class="emphasis">x</i>, <i class="emphasis">k</i>)
 1 <b class="bold">if</b> <i class="emphasis">k</i> <span class="unicode">&gt;</span> <i class="emphasis">key</i>[<i class="emphasis">x</i>]
 2    <b class="bold">then error</b> "new key is greater than current key"
 3 <i class="emphasis">key</i>[<i class="emphasis">x</i>] <span class="unicode">&larr;</span> <i class="emphasis">k</i>
 4 <i class="emphasis">y</i> <span class="unicode">&larr;</span> <i class="emphasis">x</i>
 5 <i class="emphasis">z</i> <span class="unicode">&larr;</span> <i class="emphasis">p</i>[<i class="emphasis">y</i>]
 6 <b class="bold">while</b> <i class="emphasis">z</i> <span class="unicode">&ne;</span> NIL and <i class="emphasis">key</i>[<i class="emphasis">y</i>] <span class="unicode">&lt;</span> <i class="emphasis">key</i>[<i class="emphasis">z</i>]
 7     <b class="bold">do</b> exchange <i class="emphasis">key</i>[<i class="emphasis">y</i>] <span class="unicode">&harr;</span> <i class="emphasis">key</i>[<i class="emphasis">z</i>]
 8        <span class="unicode">&#9656;</span> If <i class="emphasis">y</i> and <i class="emphasis">z</i> have satellite fields, exchange them, too.
 9        <i class="emphasis">y</i> <span class="unicode">&larr;</span> <i class="emphasis">z</i>
10        <i class="emphasis">z</i> <span class="unicode">&larr;</span> <i class="emphasis">p</i>[<i class="emphasis">y</i>]
</pre>
</div>
<p class="para">As shown in <a class="internaljump" href="#ch19fig08">Figure 19.8</a>, this procedure decreases a key in the same manner as in a binary min-heap: by "bubbling up" the key in the heap. After ensuring that the new key is in fact no greater than the current key and then assigning the new key to <i class="emphasis">x</i>, the procedure goes up the tree, with <i class="emphasis">y</i> initially pointing to node <i class="emphasis">x</i>. In each iteration of the <b class="bold">while</b> loop of lines 6<span class="unicode">-</span>10, <i class="emphasis">key</i>[<i class="emphasis">y</i>] is checked against the key of <i class="emphasis">y</i>'s parent <i class="emphasis">z</i>. If <i class="emphasis">y</i> is the root or <i class="emphasis">key</i>[<i class="emphasis">y</i>] <span class="unicode">&ge;</span> <i class="emphasis">key</i>[<i class="emphasis">z</i>], the binomial tree is now min-heap-ordered. Otherwise, node <i class="emphasis">y</i> violates min-heap ordering, and so its key is exchanged with the key of its parent <i class="emphasis">z</i>, along with any other satellite information. The procedure then sets <i class="emphasis">y</i> to <i class="emphasis">z</i>, going up one level in the tree, and continues with the next iteration.</p>
<div class="figure">
<a name="1419"></a><a name="ch19fig08"></a><span class="figuremediaobject"><a href="images/fig493%5F01%5F0%2Ejpg" NAME="IMG_586" target="_parent"><img src="images/fig493_01.jpg" height="326" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 19.8: </span>The action of BINOMIAL-HEAP-DECREASE-KEY. <i class="emphasis">(a)</i> The situation just before line 6 of the first iteration of the <i class="emphasis">while</i> loop. Node <i class="emphasis">y</i> has had its key decreased to 7, which is less than the key of <i class="emphasis">y</i>'s parent <i class="emphasis">z</i>. <i class="emphasis">(b)</i> The keys of the two nodes are exchanged, and the situation just before line 6 of the second iteration is shown. Pointers <i class="emphasis">y</i> and <i class="emphasis">z</i> have moved up one level in the tree, but min-heap order is still violated. <i class="emphasis">(c)</i> After another exchange and moving pointers <i class="emphasis">y</i> and <i class="emphasis">z</i> up one more level, we find that min-heap order is satisfied, so the <i class="emphasis">while</i> loop terminates.</span>
</div>
<p class="last-para">The BINOMIAL-HEAP-DECREASE-KEY procedure takes <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) time. By property 2 of <a href="DDU0114.html#1388" target="_parent" class="chapterjump">Lemma 19.1</a>, the maximum depth of <i class="emphasis">x</i> is <span class="unicode">&lfloor;</span>lg <i class="emphasis">n</i><span class="unicode">&rfloor;</span>, so the <b class="bold">while</b> loop of lines 6<span class="unicode">-</span>10 iterates at most <span class="unicode">&lfloor;</span>lg <i class="emphasis">n</i><span class="unicode">&rfloor;</span> times.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1420"></a><a name="ch19lev3sec8"></a>Deleting a key</h4>
<p class="first-para">It is easy to delete a node <i class="emphasis">x</i>'s key and satellite information from binomial heap <i class="emphasis">H</i> in <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) time. The following implementation assumes that no node currently in the binomial heap has a key of -<span class="unicode">&infin;</span>.</p>
<div class="informalexample">
<pre class="literallayout-normal">
BINOMIAL-HEAP-DELETE(<i class="emphasis">H</i>, <i class="emphasis">x</i>)
1  BINOMIAL-HEAP-DECREASE-KEY(<i class="emphasis">H</i>, <i class="emphasis">x</i>, -<span class="unicode">&infin;</span>)
2  BINOMIAL-HEAP-EXTRACT-MIN(<i class="emphasis">H</i>)
</pre>
</div>
<p class="para">The BINOMIAL-HEAP-DELETE procedure makes node <i class="emphasis">x</i> have the unique minimum key in the entire binomial heap by giving it a key of -<span class="unicode">&infin;</span>. (<a class="internaljump" href="#ch19ex11">Exercise 19.2-6</a><a name="1421"></a><a name="IDX-471"></a> deals with the situation in which -<span class="unicode">&infin;</span> cannot appear as a key, even temporarily.) It then bubbles this key and the associated satellite information up to a root by calling BINOMIAL-HEAP-DECREASE-KEY. This root is then removed from <i class="emphasis">H</i> by a call of BINOMIAL-HEAP-EXTRACT-MIN.</p>
<p class="para">The BINOMIAL-HEAP-DELETE procedure takes <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) time.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 19.2-1</span></span><a name="1422"></a><a name="ch19ex06"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Write pseudocode for BINOMIAL-HEAP-MERGE.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1423"></a><a name="IDX-472"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 19.2-2</span></span><a name="1424"></a><a name="ch19ex07"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show the binomial heap that results when a node with key 24 is inserted into the binomial heap shown in <a class="internaljump" href="#ch19fig07">Figure 19.7(d)</a>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 19.2-3</span></span><a name="1425"></a><a name="ch19ex08"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show the binomial heap that results when the node with key 28 is deleted from the binomial heap shown in <a class="internaljump" href="#ch19fig08">Figure 19.8(c)</a>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 19.2-4</span></span><a name="1426"></a><a name="ch19ex09"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Argue the correctness of BINOMIAL-HEAP-UNION using the following loop invariant:</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">At the start of each iteration of the <b class="bold">while</b> loop of lines 9<span class="unicode">-</span>21, <i class="emphasis">x</i> points to a root that is one of the following:</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">the only root of its degree,</p>
</li>
<li class="listitem">
<p class="first-para">the first of the only two roots of its degree, or</p>
</li>
<li class="listitem">
<p class="first-para">the first or second of the only three roots of its degree.</p>
</li>
</ul>
</li>
<li class="listitem">
<p class="first-para">Moreover, all roots preceding <i class="emphasis">x</i>'s predecessor on the root list have unique degrees on the root list, and if <i class="emphasis">x</i>'s predecessor has a degree different from that of <i class="emphasis">x</i>, its degree on the root list is unique, too. Finally, node degrees monotonically increase as we traverse the root list.</p>
</li>
</ul>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 19.2-5</span></span><a name="1427"></a><a name="ch19ex10"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Explain why the BINOMIAL-HEAP-MINIMUM procedure might not work correctly if keys can have the value <span class="unicode">&infin;</span>. Rewrite the pseudocode to make it work correctly in such cases.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 19.2-6</span></span><a name="1428"></a><a name="ch19ex11"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose there is no way to represent the key -<span class="unicode">&infin;</span>. Rewrite the BINOMIAL-HEAP-DELETE procedure to work correctly in this situation. It should still take <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 19.2-7</span></span><a name="1429"></a><a name="ch19ex12"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Discuss the relationship between inserting into a binomial heap and incrementing a binary number and the relationship between uniting two binomial heaps and adding two binary numbers.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 19.2-8</span></span><a name="1430"></a><a name="ch19ex13"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">In light of <a class="internaljump" href="#ch19ex12">Exercise 19.2-7</a>, rewrite BINOMIAL-HEAP-INSERT to insert a node directly into a binomial heap without calling BINOMIAL-HEAP-UNION.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1431"></a><a name="IDX-473"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 19.2-9</span></span><a name="1432"></a><a name="ch19ex14"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that if root lists are kept in strictly decreasing order by degree (instead of strictly increasing order), each of the binomial heap operations can be implemented without changing its asymptotic running time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 19.2-10</span></span><a name="1433"></a><a name="ch19ex15"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Find inputs that cause BINOMIAL-HEAP-EXTRACT-MIN, BINOMIAL-HEAP-DECREASE-KEY, and BINOMIAL-HEAP-DELETE to run in <span class="unicode">&#8486;</span>(lg <i class="emphasis">n</i>) time. Explain why the worst-case running times of BINOMIAL-HEAP-INSERT, BINOMIAL-HEAP-MINIMUM, and BINOMIAL-HEAP-UNION are <span class="inlinemediaobject"><img src="images/fig495_01.jpg" height="16" width="33" alt="" border="0"></span> but not <span class="unicode">&#8486;</span>(lg <i class="emphasis">n</i>). (See <a href="DDU0020.html#198" target="_parent" class="chapterjump">Problem 3-5</a>.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 19-1: </span>2-3-4 heaps</span><a name="1434"></a><a name="ch19ex16"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">
<a href="DDU0107.html#1323" target="_parent" class="chapterjump">Chapter 18</a> introduced the 2-3-4 tree, in which every internal node (other than possibly the root) has two, three, or four children and all leaves have the same depth. In this problem, we shall implement <b class="bold"><i class="emphasis">2-3-4 heaps</i></b>, which support the mergeable-heap operations.</p>
<p class="para">The 2-3-4 heaps differ from 2-3-4 trees in the following ways. In 2-3-4 heaps, only leaves store keys, and each leaf <i class="emphasis">x</i> stores exactly one key in the field <i class="emphasis">key</i>[<i class="emphasis">x</i>]. There is no particular ordering of the keys in the leaves; that is, from left to right, the keys may be in any order. Each internal node <i class="emphasis">x</i> contains a value <i class="emphasis">small</i>[<i class="emphasis">x</i>] that is equal to the smallest key stored in any leaf in the subtree rooted at <i class="emphasis">x</i>. The root <i class="emphasis">r</i> contains a field <i class="emphasis">height</i>[<i class="emphasis">r</i>] that is the height of the tree. Finally, 2-3-4 heaps are intended to be kept in main memory, so that disk reads and writes are not needed.</p>
<p class="para">Implement the following 2-3-4 heap operations. Each of the operations in parts (a)<span class="unicode">-</span>(e) should run in <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) time on a 2-3-4 heap with <i class="emphasis">n</i> elements. The UNION operation in part (f) should run in <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) time, where <i class="emphasis">n</i> is the number of elements in the two input heaps.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">MINIMUM, which returns a pointer to the leaf with the smallest key.</p>
</li>
<li class="listitem">
<p class="first-para">DECREASE-KEY, which decreases the key of a given leaf <i class="emphasis">x</i> to a given value <i class="emphasis">k</i> <span class="unicode">&le;</span> <i class="emphasis">key</i>[<i class="emphasis">x</i>].</p>
</li>
<li class="listitem">
<p class="first-para">INSERT, which inserts leaf <i class="emphasis">x</i> with key <i class="emphasis">k</i>.</p>
</li>
<li class="listitem">
<p class="first-para">DELETE, which deletes a given leaf <i class="emphasis">x</i>.</p>
</li>
<li class="listitem">
<p class="first-para">EXTRACT-MIN, which extracts the leaf with the smallest key.</p>
<a name="1435"></a><a name="IDX-474"></a>
</li>
<li class="listitem">
<p class="first-para">UNION, which unites two 2-3-4 heaps, returning a single 2-3-4 heap and de-stroying the input heaps.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 19-2: </span>Minimum-spanning-tree algorithm using binomial heaps</span><a name="1436"></a><a name="ch19ex17"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">
<a href="DDU0135.html#1692" target="_parent" class="chapterjump">Chapter 23</a> presents two algorithms to solve the problem of finding a minimum spanning tree of an undirected graph. Here, we shall see how binomial heaps can be used to devise a different minimum-spanning-tree algorithm.</p>
<p class="para">We are given a connected, undirected graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) with a weight function <i class="emphasis">w</i> : <i class="emphasis">E</i> <span class="unicode">&rarr;</span> <b class="bold">R</b>. We call <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) the weight of edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>). We wish to find a minimum spanning tree for <i class="emphasis">G</i>: an acyclic subset <i class="emphasis">T</i> <span class="unicode">&sube;</span> <i class="emphasis">E</i> that connects all the vertices in <i class="emphasis">V</i> and whose total weight</p>
<p class="para">
<div class="informalequation">
<span class="equation-image"><img src="images/fig496_01.jpg" height="35" width="135" alt="" border="0"></span>
</div>
</p>
<p class="para">is minimized.</p>
<p class="para">The following pseudocode, which can be proven correct using techniques from <a href="DDU0136.html#1697" target="_parent" class="chapterjump">Section 23.1</a>, constructs a minimum spanning tree <i class="emphasis">T</i> . It maintains a partition {<i class="emphasis">V<sub>i</sub></i>} of the vertices of <i class="emphasis">V</i> and, with each set <i class="emphasis">V<sub>i</sub></i>, a set</p>
<p class="para">
<i class="emphasis">E<sub>i</sub></i> <span class="unicode">&sube;</span> (<i class="emphasis">u</i>, <i class="emphasis">v</i>): <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V<sub>i</sub></i> or <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V<sub>i</sub></i>}</p>
<p class="para">of edges incident on vertices in <i class="emphasis">V</i><i class="emphasis"><sub>I</sub></i>.</p>
<pre class="literallayout-normal">
MST(<i class="emphasis">G</i>)
 1  <i class="emphasis">T</i> <span class="unicode">&larr;</span> <span class="unicode">&Oslash;</span>
 2  <b class="bold">for</b> each vertex <i class="emphasis">v<sub>i</sub></i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>[<i class="emphasis">G</i>]
 3       <b class="bold">do</b> <i class="emphasis">V<sub>i</sub></i> <span class="unicode">&larr;</span> {<i class="emphasis">v<sub>i</sub></i>}
 4          <i class="emphasis">E<sub>i</sub></i> <span class="unicode">&larr;</span> {(<i class="emphasis">v<sub>i</sub></i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>[<i class="emphasis">G</i>]}
 5  <b class="bold">while</b> there is more than one set <i class="emphasis">V<sub>i</sub></i>
 6      <b class="bold">do</b> choose any set <i class="emphasis">V<sub>i</sub></i>
 7         extract the minimum-weight edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) from <i class="emphasis">E<sub>i</sub></i>
 8         assume without loss of generality that <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V<sub>i</sub></i> and <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V<sub>j</sub></i>
 9         <b class="bold">if</b> <i class="emphasis">i</i> <span class="unicode">&ne;</span> <i class="emphasis">j</i>
10            <b class="bold">then</b> <i class="emphasis">T</i> <span class="unicode">&larr;</span> <i class="emphasis">T</i> <span class="unicode">&cup;</span> {(<i class="emphasis">u</i>, <i class="emphasis">v</i>)}
11                 <i class="emphasis">V<sub>i</sub></i> <span class="unicode">&larr;</span> <i class="emphasis">V<sub>i</sub></i> <span class="unicode">&cup;</span> <i class="emphasis">V<sub>j</sub></i>, destroying <i class="emphasis">V<sub>j</sub></i>
12                 <i class="emphasis">E<sub>i</sub></i> <span class="unicode">&larr;</span> <i class="emphasis">E<sub>i</sub></i> <span class="unicode">&cup;</span> <i class="emphasis">E<sub>j</sub></i>
</pre>
<p class="last-para">Describe how to implement this algorithm using binomial heaps to manage the vertex and edge sets. Do you need to change the representation of a binomial heap? Do you need to add operations beyond the mergeable-heap operations given in <a href="DDU0113.html#1382" target="_parent" class="chapterjump">Figure 19.1</a>? Give the running time of your implementation.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0114.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0116.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
