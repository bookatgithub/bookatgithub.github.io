<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>21.4 &#9733; Analysis of union by rank with path compression</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0125.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0127.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch21"></a>
<div class="section">
<h2 class="first-section-title">
<a name="1536"></a><a name="ch21lev1sec4"></a><span class="section-titlelabel">21.4 </span><span class="unicode">&#9733;</span> Analysis of union by rank with path compression</h2>
<p class="first-para">As noted in <a href="DDU0125.html#1522" target="_parent" class="chapterjump">Section 21.3</a>, the running time of the combined union-by-rank and path-compression heuristic is <i class="emphasis">O</i>(<i class="emphasis">m</i> <span class="unicode">&alpha;</span> (<i class="emphasis">n</i>)) for <i class="emphasis">m</i> disjoint-set operations on <i class="emphasis">n</i> elements. In this section, we shall examine the function <span class="unicode">&alpha;</span> to see just how slowly it grows. Then we prove this running time using the potential method of amortized analysis.</p>
<div class="section">
<h4 class="sect4-title">
<a name="1537"></a><a name="ch21lev3sec7"></a>A very quickly growing function and its very slowly growing inverse</h4>
<p class="first-para">For integers <i class="emphasis">k</i> <span class="unicode">&ge;</span> 0 and <i class="emphasis">j</i> <span class="unicode">&ge;</span> 1, we define the function <i class="emphasis">A<sub>k</sub></i>(<i class="emphasis">j</i>) as</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig531_01.jpg" height="39" width="189" alt="" border="0"></span>
</div>
<a name="1538"></a><a name="IDX-510"></a>
<p class="para">where the expression <span class="inlinemediaobject"><img src="images/fig532_01.jpg" height="16" width="43" alt="" border="0"></span> uses the functional-iteration notation given in <a href="DDU0020.html#156" target="_parent" class="chapterjump">Section 3.2.</a> Specifically, <span class="inlinemediaobject"><img src="images/fig532_02.jpg" height="15" width="58" alt="" border="0"></span> and <span class="inlinemediaobject"><img src="images/fig532_03.jpg" height="16" width="122" alt="" border="0"></span> for <i class="emphasis">i</i> <span class="unicode">&ge;</span> 1. We will refer to the parameter <i class="emphasis">k</i> as the <b class="bold"><i class="emphasis">level</i></b> of the function <i class="emphasis">A</i>.</p>
<p class="para">The function <i class="emphasis">A<sub>k</sub></i>(<i class="emphasis">j</i>) strictly increases with both <i class="emphasis">j</i> and <i class="emphasis">k</i>. To see just how quickly this function grows, we first obtain closed-form expressions for <i class="emphasis">A</i><sub>1</sub>(<i class="emphasis">j</i>) and <i class="emphasis">A</i><sub>2</sub>(<i class="emphasis">j</i>).</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 21.2</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">For any integer <i class="emphasis">j</i> <span class="unicode">&ge;</span> 1, we have <i class="emphasis">A</i><sub>1</sub>(<i class="emphasis">j</i>) = 2 <i class="emphasis">j</i> + 1.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> We first use induction on <i class="emphasis">i</i> to show that <span class="inlinemediaobject"><img src="images/fig532_04.jpg" height="16" width="67" alt="" border="0"></span>. For the base case, we have <span class="inlinemediaobject"><img src="images/fig532_05.jpg" height="16" width="100" alt="" border="0"></span>. For the inductive step, assume that <span class="inlinemediaobject"><img src="images/fig532_06.jpg" height="16" width="55" alt="" border="0"></span> <span class="inlinemediaobject"><img src="images/fig532_07.jpg" height="12" width="51" alt="" border="0"></span>. Then <span class="inlinemediaobject"><img src="images/fig532_08.jpg" height="16" width="238" alt="" border="0"></span>. Finally, we note that <span class="inlinemediaobject"><img src="images/fig532_09.jpg" height="16" width="194" alt="" border="0"></span>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 21.3</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">For any integer <i class="emphasis">j</i> <span class="unicode">&ge;</span> 1, we have <i class="emphasis">A</i><sub>2</sub>(<i class="emphasis">j</i>) = 2<sup><i class="emphasis">j</i>+1</sup>(<i class="emphasis">j</i> + 1) - 1.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> We first use induction on <i class="emphasis">i</i> to show that <span class="inlinemediaobject"><img src="images/fig532_10.jpg" height="16" width="113" alt="" border="0"></span>. For the base case, we have <span class="inlinemediaobject"><img src="images/fig532_11.jpg" height="16" width="141" alt="" border="0"></span>. For the inductive step, assume that <span class="inlinemediaobject"><img src="images/fig532_12.jpg" height="16" width="136" alt="" border="0"></span>. Then <span class="inlinemediaobject"><img src="images/fig532_13.jpg" height="16" width="128" alt="" border="0"></span> <span class="inlinemediaobject"><img src="images/fig532_14.jpg" height="14" width="356" alt="" border="0"></span>. Finally, we note that <span class="inlinemediaobject"><img src="images/fig532_15.jpg" height="16" width="168" alt="" border="0"></span>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">Now we can see how quickly <i class="emphasis">A<sub>k</sub></i>(<i class="emphasis">j</i>) grows by simply examining <i class="emphasis">A<sub>k</sub></i> (1) for levels <i class="emphasis">k</i> = 0, 1, 2, 3, 4. From the definition of <i class="emphasis">A</i><sub>0</sub>(<i class="emphasis">k</i>) and the above lemmas, we have <i class="emphasis">A</i><sub>0</sub>(1) = 1 + 1 = 2, <i class="emphasis">A</i><sub>1</sub>(1) = 2 <span class="unicode">&middot;</span> 1 + 1 = 3, and <i class="emphasis">A</i><sub>2</sub>(1) = 2<sup>1+1</sup> <span class="unicode">&middot;</span> (1 + 1) - 1 = 7. We also have</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">A</i><sub>3</sub>(1)</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="inlinemediaobject"><img src="images/fig532_16.jpg" height="16" width="32" alt="" border="0"></span>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">A</i><sub>2</sub>(<i class="emphasis">A</i><sub>2</sub>(1))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">A</i><sub>2</sub>(7)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">2<sup>8</sup> <span class="unicode">&middot;</span> 8 - 1</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">2<sup>11</sup> - 1</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">2047</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">and</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">A</i><sub>4</sub>(1)</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="inlinemediaobject"><img src="images/fig532_17.jpg" height="17" width="33" alt="" border="0"></span>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">A</i><sub>3</sub>(<i class="emphasis">A</i><sub>3</sub>(1))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">A</i><sub>3</sub>(2047)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="inlinemediaobject"><img src="images/fig532_18.jpg" height="16" width="59" alt="" border="0"></span>
</p>
<a name="1539"></a><a name="IDX-511"></a></td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&#8811;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">A</i><sub>2</sub>(2047)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">1<sup>2048</sup><span class="unicode">&middot;</span> 2048 - 1</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&gt;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">2<sup>2048</sup>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">(2<sup>4</sup>)<sup>512</sup>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">16<sup>512</sup>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&#8811;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">10<sup>80</sup>,</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">which is the estimated number of atoms in the observable universe.</p>
<p class="para">We define the inverse of the function <i class="emphasis">A<sub>k</sub></i> (<i class="emphasis">n</i>), for integer <i class="emphasis">n</i> <span class="unicode">&ge;</span> 0, by</p>
<p class="para">
<span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) = min {<i class="emphasis">k</i> : <i class="emphasis">A<sub>k</sub></i>(1) = <i class="emphasis">n</i>} .</p>
<p class="para">In words, <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) is the lowest level <i class="emphasis">k</i> for which <i class="emphasis">A<sub>k</sub></i>(1) is at least <i class="emphasis">n</i>. From the above values of <i class="emphasis">A<sub>k</sub></i>(1), we see that</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig533_01.jpg" height="90" width="219" alt="" border="0"></span>
</div>
<p class="last-para">It is only for impractically large values of <i class="emphasis">n</i> (greater than <i class="emphasis">A</i><sub>4</sub>(1), a huge number) that <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) <span class="unicode">&gt;</span> 4, and so <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) <span class="unicode">&le;</span> 4 for all practical purposes.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1540"></a><a name="ch21lev3sec8"></a>Properties of ranks</h4>
<p class="first-para">In the remainder of this section, we prove an <i class="emphasis">O</i>(<i class="emphasis">m</i> <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>)) bound on the running time of the disjoint-set operations with union by rank and path compression. In order to prove this bound, we first prove some simple properties of ranks.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 21.4</span></span><a name="1541"></a><a name="ch21ex16"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">For all nodes <i class="emphasis">x</i>, we have <i class="emphasis">rank</i>[<i class="emphasis">x</i>] <span class="unicode">&le;</span> <i class="emphasis">rank</i>[<i class="emphasis">p</i>[<i class="emphasis">x</i>]], with strict inequality if <i class="emphasis">x</i> <span class="unicode">&ne;</span> <i class="emphasis">p</i>[<i class="emphasis">x</i>]. The value of <i class="emphasis">rank</i>[<i class="emphasis">x</i>] is initially 0 and increases through time until <i class="emphasis">x</i> <span class="unicode">&ne;</span> <i class="emphasis">p</i>[<i class="emphasis">x</i>]; from then on, <i class="emphasis">rank</i>[<i class="emphasis">x</i>] does not change. The value of <i class="emphasis">rank</i>[<i class="emphasis">p</i>[<i class="emphasis">x</i>]] monotonically increases over time.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> The proof is a straightforward induction on the number of operations, using the implementations of MAKE-SET, UNION, and FIND-SET that appear in <a href="DDU0125.html#1522" target="_parent" class="chapterjump">Section 21.3.</a> We leave it as <a class="internaljump" href="#ch21ex26">Exercise 21.4-1</a>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Corollary 21.5</span></span><a name="1542"></a><a name="ch21ex17"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">As we follow the path from any node toward a root, the node ranks strictly increase.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1543"></a><a name="IDX-512"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 21.6</span></span><a name="1544"></a><a name="ch21ex18"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Every node has rank at most <i class="emphasis">n</i> - 1.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Each node's rank starts at 0, and it increases only upon LINK operations. Because there are at most <i class="emphasis">n</i> - 1 UNION operations, there are also at most <i class="emphasis">n</i> - 1 LINK operations. Because each LINK operation either leaves all ranks alone or increases some node's rank by 1, all ranks are at most <i class="emphasis">n</i> - 1.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="last-para">
<a class="internaljump" href="#ch21ex18">Lemma 21.6</a> provides a weak bound on ranks. In fact, every node has rank at most <span class="unicode">&lfloor;</span>lg <i class="emphasis">n</i><span class="unicode">&rfloor;</span> (see <a class="internaljump" href="#ch21ex27">Exercise 21.4-2</a>). The looser bound of <a class="internaljump" href="#ch21ex18">Lemma 21.6</a> will suffice for our purposes, however.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1545"></a><a name="ch21lev3sec9"></a>Proving the time bound</h4>
<p class="first-para">We shall use the potential method of amortized analysis (see <a href="DDU0103.html#1275" target="_parent" class="chapterjump">Section 17.3</a>) to prove the <i class="emphasis">O</i>(<i class="emphasis">m</i><span class="unicode">&alpha;</span>(<i class="emphasis">n</i>)) time bound. In performing the amortized analysis, it is convenient to assume that we invoke the LINK operation rather than the UNION operation. That is, since the parameters of the LINK procedure are pointers to two roots, we assume that the appropriate FIND-SET operations are performed separately. The following lemma shows that even if we count the extra FIND-SET operations induced by UNION calls, the asymptotic running time remains unchanged.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 21.7</span></span><a name="1546"></a><a name="ch21ex19"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose we convert a sequence <i class="emphasis">S</i>' of <i class="emphasis">m</i>' MAKE-SET, UNION, and FIND-SET operations into a sequence <i class="emphasis">S</i> of <i class="emphasis">m</i> MAKE-SET, LINK, and FIND-SET operations by turning each UNION into two FIND-SET operations followed by a LINK. Then, if sequence <i class="emphasis">S</i> runs in <i class="emphasis">O</i>(<i class="emphasis">m</i> <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>)) time, sequence <i class="emphasis">S</i>' runs in <i class="emphasis">O</i>(<i class="emphasis">m</i>' <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>)) time.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Since each UNION operation in sequence <i class="emphasis">S</i>' is converted into three operations in <i class="emphasis">S</i>, we have <i class="emphasis">m</i>' <span class="unicode">&le;</span> <i class="emphasis">m</i> <span class="unicode">&le;</span> 3<i class="emphasis">m</i>'. Since <i class="emphasis">m</i> = <i class="emphasis">O</i>(<i class="emphasis">m</i>'), an <i class="emphasis">O</i>(<i class="emphasis">m</i> <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>)) time bound for the converted sequence <i class="emphasis">S</i> implies an <i class="emphasis">O</i>(<i class="emphasis">m</i>' <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>)) time bound for the original sequence <i class="emphasis">S</i>'.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">In the remainder of this section, we shall assume that the initial sequence of <i class="emphasis">m</i>' MAKE-SET, UNION, and FIND-SET operations has been converted to a sequence of <i class="emphasis">m</i> MAKE-SET, LINK, and FIND-SET operations. We now prove an <i class="emphasis">O</i>(<i class="emphasis">m</i> <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>)) time bound for the converted sequence and appeal to <a class="internaljump" href="#ch21ex19">Lemma 21.7</a> to prove the <i class="emphasis">O</i>(<i class="emphasis">m</i>' <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>)) running time of the original sequence of <i class="emphasis">m</i>' operations.</p>
<a name="1547"></a><a name="IDX-513"></a>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1548"></a><a name="ch21lev3sec10"></a>Potential function</h4>
<p class="first-para">The potential function we use assigns a potential <i class="emphasis"><span class="unicode">&phi;</span><sub>q</sub></i>(<i class="emphasis">x</i>) to each node <i class="emphasis">x</i> in the disjoint-set forest after <i class="emphasis">q</i> operations. We sum the node potentials for the potential of the entire forest: <span class="unicode">&Phi;</span><sub><i class="emphasis">q</i></sub> = <span class="unicode">&Sigma;</span><sub><i class="emphasis">x</i></sub><span class="unicode">&phi;</span> (<i class="emphasis">x</i>), where <span class="unicode">&Phi;</span><sub><i class="emphasis">q</i></sub> denotes the potential of the forest after <i class="emphasis">q</i> operations. The forest is empty prior to the first operation, and we arbitrarily set <span class="unicode">&Phi;</span><sub>0</sub> = 0. No potential <span class="unicode">&Phi;</span><sub><i class="emphasis">q</i></sub> will ever be negative.</p>
<p class="para">The value of <i class="emphasis"><span class="unicode">&phi;</span></i><sub><i class="emphasis">q</i></sub>(<i class="emphasis">x</i>) depends on whether <i class="emphasis">x</i> is a tree root after the <i class="emphasis">q</i>th operation. If it is, or if <i class="emphasis">rank</i>[<i class="emphasis">x</i>] = 0, then <i class="emphasis"><span class="unicode">&phi;</span></i><sub><i class="emphasis">q</i></sub>(<i class="emphasis">x</i>) = <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) <span class="unicode">&middot;</span> <i class="emphasis">rank</i>[<i class="emphasis">x</i>].</p>
<p class="para">Now suppose that after the <i class="emphasis">q</i>th operation, <i class="emphasis">x</i> is not a root and that <i class="emphasis">rank</i>[<i class="emphasis">x</i>] <span class="unicode">&ge;</span> 1. We need to define two auxiliary functions on <i class="emphasis">x</i> before we can define <i class="emphasis"><span class="unicode">&phi;</span></i><sub><i class="emphasis">q</i></sub>(<i class="emphasis">x</i>). First we define</p>
<p class="para">level(<i class="emphasis">x</i>) = max {<i class="emphasis">k</i> : <i class="emphasis">rank</i>[<i class="emphasis">p</i>[<i class="emphasis">x</i>]] <span class="unicode">&ge;</span> <i class="emphasis">A<sub>k</sub></i> (<i class="emphasis">rank</i>[<i class="emphasis">x</i>])} .</p>
<p class="para">That is, level(<i class="emphasis">x</i>) is the greatest level <i class="emphasis">k</i> for which <i class="emphasis">A<sub>k</sub></i>, applied to <i class="emphasis">x</i>'s rank, is no greater than <i class="emphasis">x</i>'s parent's rank.</p>
<p class="para">We claim that</p>
<div class="equation">
<a name="1549"></a><a name="ch21eq01"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(21.1)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig535_01.jpg" height="15" width="130" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">which we see as follows. We have</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">rank</i>[<i class="emphasis">p</i>[<i class="emphasis">x</i>]]</p>
</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&ge;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">rank</i>[<i class="emphasis">x</i>] + 1</p>
</td><td class="td" align="left">
<p class="table-para">(by <a class="internaljump" href="#ch21ex16">Lemma 21.4</a>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">A</i><sub>0</sub>(<i class="emphasis">rank</i>[<i class="emphasis">x</i>])</p>
</td><td class="td" align="left">
<p class="table-para">(by definition of <i class="emphasis">A</i><sub>0</sub>(<i class="emphasis">j</i>)) ,</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">which implies that level(<i class="emphasis">x</i>) <span class="unicode">&ge;</span> 0, and we have</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">A</i><sub><i class="emphasis"><span class="unicode">&alpha;</span>(<i class="emphasis">n</i>)</i></sub>(<i class="emphasis">rank</i>[<i class="emphasis">x</i>])</p>
</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&ge;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">A</i><sub><i class="emphasis"><span class="unicode">&alpha;</span>(<i class="emphasis">n</i>)</i></sub>(1)</p>
</td><td class="td" align="left">
<p class="table-para">(because <i class="emphasis">A<sub>k</sub></i>(<i class="emphasis">j</i>) is strictly increasing)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&ge;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">n</i>
</p>
</td><td class="td" align="left">
<p class="table-para">(by the definition of <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&gt;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">rank</i>[<i class="emphasis">p</i>[<i class="emphasis">x</i>]]</p>
</td><td class="td" align="left">
<p class="table-para">(by <a class="internaljump" href="#ch21ex18">Lemma 21.6</a>) ,</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">which implies that level(<i class="emphasis">x</i>) <span class="unicode">&lt;</span> <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>). Note that because <i class="emphasis">rank</i>[<i class="emphasis">p</i>[<i class="emphasis">x</i>]] monotonically increases over time, so does level(<i class="emphasis">x</i>).</p>
<p class="para">The second auxiliary function is</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig535_02.jpg" height="23" width="310" alt="" border="0"></span>
</div>
<p class="para">That is, iter(<i class="emphasis">x</i>) is the largest number of times we can iteratively apply <i class="emphasis">A</i><sub>level(<i class="emphasis">x</i>),</sub> applied initially to <i class="emphasis">x</i>'s rank, before we get a value greater than <i class="emphasis">x</i>'s parent's rank.</p>
<p class="para">We claim that</p>
<div class="equation">
<a name="1550"></a><a name="ch21eq02"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(21.2)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig535_03.jpg" height="16" width="137" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">which we see as follows. We have</p>
<div class="informalequation">
<span class="equation-image"><a href="images/fig535%5F04%2Ejpg" NAME="IMG_636" target="_parent"><img src="images/fig535_04.jpg" height="39" width="400" alt="Click To expand" border="0"></a></span>
</div>
<a name="1551"></a><a name="IDX-514"></a>
<p class="para">which implies that iter(<i class="emphasis">x</i>) <span class="unicode">&ge;</span> 1, and we have</p>
<div class="informalequation">
<span class="equation-image"><a href="images/fig536%5F01%2Ejpg" NAME="IMG_637" target="_parent"><img src="images/fig536_01.jpg" height="38" width="400" alt="Click To expand" border="0"></a></span>
</div>
<p class="para">which implies that iter(<i class="emphasis">x</i>) <span class="unicode">&le;</span> <i class="emphasis">rank</i>[<i class="emphasis">x</i>]. Note that because <i class="emphasis">rank</i>[<i class="emphasis">p</i>[<i class="emphasis">x</i>]] monotonically increases over time, in order for iter(<i class="emphasis">x</i>) to decrease, level(<i class="emphasis">x</i>) must increase. As long as level(<i class="emphasis">x</i>) remains unchanged, iter(<i class="emphasis">x</i>) must either increase or remain unchanged.</p>
<p class="para">With these auxiliary functions in place, we are ready to define the potential of node <i class="emphasis">x</i> after <i class="emphasis">q</i> operations:</p>
<div class="informalequation">
<span class="equation-image"><a href="images/fig536%5F02%2Ejpg" NAME="IMG_638" target="_parent"><img src="images/fig536_02.jpg" height="31" width="400" alt="Click To expand" border="0"></a></span>
</div>
<p class="para">The next two lemmas give useful properties of node potentials.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 21.8</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">For every node <i class="emphasis">x</i>, and for all operation counts <i class="emphasis">q</i>, we have</p>
<p class="para">0 <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&phi;</span><sub>q</sub></i>(<i class="emphasis">x</i>) <span class="unicode">&le;</span> <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) <span class="unicode">&middot;</span> <i class="emphasis">rank</i>[<i class="emphasis">x</i>].</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> If <i class="emphasis">x</i> is a root or <i class="emphasis">rank</i>[<i class="emphasis">x</i>] = 0, then <i class="emphasis"><span class="unicode">&phi;</span><sub>q</sub></i>(<i class="emphasis">x</i>) = <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) <span class="unicode">&middot;</span> <i class="emphasis">rank</i>[<i class="emphasis">x</i>] by definition. Now suppose that <i class="emphasis">x</i> is not a root and that <i class="emphasis">rank</i>[<i class="emphasis">x</i>] <span class="unicode">&ge;</span> 1. We obtain a lower bound on <i class="emphasis"><span class="unicode">&phi;</span><sub>q</sub></i>(<i class="emphasis">x</i>) by maximizing level(<i class="emphasis">x</i>) and iter(<i class="emphasis">x</i>). By the bound (<a class="internaljump" href="#ch21eq01">21.1</a>), level(<i class="emphasis">x</i>) <span class="unicode">&le;</span> <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) - 1, and by the bound (<a class="internaljump" href="#ch21eq02">21.2</a>), iter(<i class="emphasis">x</i>) <span class="unicode">&le;</span> <i class="emphasis">rank</i>[<i class="emphasis">x</i>]. Thus,</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&phi;</span><sub>q</sub></i>(<i class="emphasis">x</i>)</p>
</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&ge;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">(<span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) - (<span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) - 1)) <span class="unicode">&middot;</span> <i class="emphasis">rank</i>[<i class="emphasis">x</i>] - <i class="emphasis">rank</i>[<i class="emphasis">x</i>]</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">rank</i>[<i class="emphasis">x</i>] - <i class="emphasis">rank</i>[<i class="emphasis">x</i>]</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">0.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">Similarly, we obtain an upper bound on <i class="emphasis"><span class="unicode">&phi;</span><sub>q</sub></i>(<i class="emphasis">x</i>) by minimizing level(<i class="emphasis">x</i>) and iter(<i class="emphasis">x</i>). By the bound (<a class="internaljump" href="#ch21eq01">21.1</a>), level(<i class="emphasis">x</i>) <span class="unicode">&ge;</span> 0, and by the bound (<a class="internaljump" href="#ch21eq02">21.2</a>), iter(<i class="emphasis">x</i>) <span class="unicode">&ge;</span> 1. Thus,</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&phi;</span><sub>q</sub></i>(<i class="emphasis">x</i>)</p>
</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&le;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">(<span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) - 0) <span class="unicode">&middot;</span> <i class="emphasis">rank</i>[<i class="emphasis">x</i>] - 1</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) <span class="unicode">&middot;</span> <i class="emphasis">rank</i>[<i class="emphasis">x</i>] - 1</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&lt;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) <span class="unicode">&middot;</span> <i class="emphasis">rank</i>[<i class="emphasis">x</i>].</p>
</td>
</tr>
</tbody>
</table>
</div>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1552"></a><a name="ch21lev3sec11"></a>Potential changes and amortized costs of operations</h4>
<p class="first-para">We are now ready to examine how the disjoint-set operations affect node potentials. With an understanding of the change in potential due to each operation, we can determine each operation's amortized cost.<a name="1553"></a><a name="IDX-515"></a>
</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 21.9</span></span><a name="1554"></a><a name="ch21ex21"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">x</i> be a node that is not a root, and suppose that the <i class="emphasis">q</i>th operation is either a LINK or FIND-SET. Then after the <i class="emphasis">q</i>th operation, <i class="emphasis"><span class="unicode">&phi;</span><sub>q</sub></i>(<i class="emphasis">x</i>) <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&phi;</span></i><sub><i class="emphasis">q</i>-1</sub>(<i class="emphasis">x</i>). Moreover, if <i class="emphasis">rank</i>[<i class="emphasis">x</i>] <span class="unicode">&ge;</span> 1 and either level(<i class="emphasis">x</i>) or iter(<i class="emphasis">x</i>) changes due to the <i class="emphasis">q</i>th operation, then <i class="emphasis"><span class="unicode">&phi;</span><sub>q</sub></i>(<i class="emphasis">x</i>) <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&phi;</span></i><sub><i class="emphasis">q</i>-1</sub>(<i class="emphasis">x</i>) - 1. That is, <i class="emphasis">x</i>'s potential cannot increase, and if it has positive rank and either level(<i class="emphasis">x</i>) or iter(<i class="emphasis">x</i>) changes, then <i class="emphasis">x</i>'s potential drops by at least 1.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> Because <i class="emphasis">x</i> is not a root, the <i class="emphasis">q</i>th operation does not change <i class="emphasis">rank</i>[<i class="emphasis">x</i>], and because <i class="emphasis">n</i> does not change after the initial <i class="emphasis">n</i> MAKE-SET operations, <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) remains unchanged as well. Hence, these components of the formula for <i class="emphasis">x</i>'s potential remain the same after the <i class="emphasis">q</i>th operation. If <i class="emphasis">rank</i>[<i class="emphasis">x</i>] = 0, then <i class="emphasis"><span class="unicode">&phi;</span><sub>q</sub></i>(<i class="emphasis">x</i>) = <i class="emphasis"><span class="unicode">&phi;</span></i><sub><i class="emphasis">q</i>-1</sub>(<i class="emphasis">x</i>) = 0. Now assume that <i class="emphasis">rank</i>[<i class="emphasis">x</i>] <span class="unicode">&ge;</span> 1.</p>
<p class="para">Recall that level(<i class="emphasis">x</i>) monotonically increases over time. If the <i class="emphasis">q</i>th operation leaves level(<i class="emphasis">x</i>) unchanged, then iter(<i class="emphasis">x</i>) either increases or remains unchanged. If both level(<i class="emphasis">x</i>) and iter(<i class="emphasis">x</i>) are unchanged, then <i class="emphasis"><span class="unicode">&phi;</span><sub>q</sub></i>(<i class="emphasis">x</i>) = <i class="emphasis"><span class="unicode">&phi;</span></i><sub><i class="emphasis">q</i>-1</sub>(<i class="emphasis">x</i>). If level(<i class="emphasis">x</i>) is unchanged and iter(<i class="emphasis">x</i>) increases, then it increases by at least 1, and so <i class="emphasis"><span class="unicode">&phi;</span><sub>q</sub></i>(<i class="emphasis">x</i>) <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&phi;</span></i><sub><i class="emphasis">q</i>-1</sub>(<i class="emphasis">x</i>) - 1.</p>
<p class="last-para">Finally, if the <i class="emphasis">q</i>th operation increases level(<i class="emphasis">x</i>), it increases by at least 1, so that the value of the term (<span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) - level(<i class="emphasis">x</i>)) <span class="unicode">&middot;</span> <i class="emphasis">rank</i>[<i class="emphasis">x</i>] drops by at least <i class="emphasis">rank</i>[<i class="emphasis">x</i>]. Because level(<i class="emphasis">x</i>) increased, the value of iter(<i class="emphasis">x</i>) might drop, but according to the bound (<a class="internaljump" href="#ch21eq02">21.2</a>), the drop is by at most <i class="emphasis">rank</i>[<i class="emphasis">x</i>] - 1. Thus, the increase in potential due to the change in iter(<i class="emphasis">x</i>) is less than the decrease in potential due to the change in level(<i class="emphasis">x</i>), and we conclude that <i class="emphasis"><span class="unicode">&phi;</span><sub>q</sub></i>(<i class="emphasis">x</i>) <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&phi;</span></i><sub><i class="emphasis">q</i>-1</sub>(<i class="emphasis">x</i>) - 1.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">Our final three lemmas show that the amortized cost of each MAKE-SET, LINK, and FIND-SET operation is <i class="emphasis">O</i>(<span class="unicode">&alpha;</span>(<i class="emphasis">n</i>)). Recall from <a href="DDU0103.html#1277" target="_parent" class="chapterjump">equation (17.2)</a> that the amortized cost of each operation is its actual cost plus the increase in potential due to the operation.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 21.10</span></span><a name="1555"></a><a name="ch21ex22"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The amortized cost of each MAKE-SET operation is <i class="emphasis">O</i>(1).</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Suppose that the <i class="emphasis">q</i>th operation is MAKE-SET(<i class="emphasis">x</i>). This operation creates node <i class="emphasis">x</i> with rank 0, so that <i class="emphasis"><span class="unicode">&phi;</span><sub>q</sub></i>(<i class="emphasis">x</i>) = 0. No other ranks or potentials change, and so <span class="unicode">&Phi;</span><sub><i class="emphasis">q</i></sub> = <span class="unicode">&Phi;</span><sub><i class="emphasis">q</i>-1</sub>. Noting that the actual cost of the MAKE-SET operation is <i class="emphasis">O</i>(1) completes the proof.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 21.11</span></span><a name="1556"></a><a name="ch21ex23"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The amortized cost of each LINK operation is <i class="emphasis">O</i>(<span class="unicode">&alpha;</span>(<i class="emphasis">n</i>)).<a name="1557"></a><a name="IDX-516"></a>
</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> Suppose that the <i class="emphasis">q</i>th operation is LINK(<i class="emphasis">x</i>, <i class="emphasis">y</i>). The actual cost of the LINK operation is <i class="emphasis">O</i>(1). Without loss of generality, suppose that the LINK makes <i class="emphasis">y</i> the parent of <i class="emphasis">x</i>.</p>
<p class="para">To determine the change in potential due to the LINK, we note that the only nodes whose potentials may change are <i class="emphasis">x</i>, <i class="emphasis">y</i>, and the children of <i class="emphasis">y</i> just prior to the operation. We shall show that the only node whose potential can increase due to the LINK is <i class="emphasis">y</i>, and that its increase is at most <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>):</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">By <a class="internaljump" href="#ch21ex21">Lemma 21.9</a>, any node that is <i class="emphasis">y</i>'s child just before the LINK cannot have its potential increase due to the LINK.</p>
</li>
<li class="listitem">
<p class="first-para">From the definition of <i class="emphasis"><span class="unicode">&phi;</span><sub>q</sub></i>(<i class="emphasis">x</i>), we see that, since <i class="emphasis">x</i> was a root just before the <i class="emphasis">q</i>th operation, <i class="emphasis"><span class="unicode">&phi;</span></i><sub><i class="emphasis">q</i>-1</sub>(<i class="emphasis">x</i>) = <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) <span class="unicode">&middot;</span> <i class="emphasis">rank</i>[<i class="emphasis">x</i>]. If <i class="emphasis">rank</i>[<i class="emphasis">x</i>] = 0, then <i class="emphasis"><span class="unicode">&phi;</span><sub>q</sub></i>(<i class="emphasis">x</i>) = <i class="emphasis"><span class="unicode">&phi;</span></i><sub><i class="emphasis">q</i>-1</sub>(<i class="emphasis">x</i>) = 0. Otherwise,</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&phi;</span><sub>q</sub></i>(<i class="emphasis">x</i>)</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">(<span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) - level(<i class="emphasis">x</i>)) <span class="unicode">&middot;</span> <i class="emphasis">rank</i>[<i class="emphasis">x</i>] - iter(<i class="emphasis">x</i>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&lt;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) <span class="unicode">&middot;</span> <i class="emphasis">rank</i>[<i class="emphasis">x</i>] (by inequalities (<a class="internaljump" href="#ch21eq01">21.1</a>) and (<a class="internaljump" href="#ch21eq02">21.2</a>)).</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="last-para">Because this last quantity is <i class="emphasis"><span class="unicode">&phi;</span></i><sub><i class="emphasis">q</i>-1</sub>(<i class="emphasis">x</i>), we see that <i class="emphasis">x</i>'s potential decreases.</p>
</li>
<li class="listitem">
<p class="first-para">Because <i class="emphasis">y</i> is a root prior to the LINK, <i class="emphasis"><span class="unicode">&phi;</span></i><sub><i class="emphasis">q</i>-1</sub>(<i class="emphasis">y</i>) = <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) <span class="unicode">&middot;</span> <i class="emphasis">rank</i>[<i class="emphasis">y</i>]. The LINK operation leaves <i class="emphasis">y</i> as a root, and it either leaves <i class="emphasis">y</i>'s rank alone or it increases <i class="emphasis">y</i>'s rank by 1. Therefore, either <i class="emphasis"><span class="unicode">&phi;</span><sub>q</sub></i>(<i class="emphasis">y</i>) = <i class="emphasis"><span class="unicode">&phi;</span></i><sub><i class="emphasis">q</i>-1</sub>(<i class="emphasis">y</i>) or <i class="emphasis"><span class="unicode">&phi;</span><sub>q</sub></i>(<i class="emphasis">y</i>) = <i class="emphasis"><span class="unicode">&phi;</span></i><sub><i class="emphasis">q</i>-1</sub>(<i class="emphasis">y</i>) + <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>).</p>
</li>
</ul>
<p class="last-para">The increase in potential due to the LINK operation, therefore, is at most <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>). The amortized cost of the LINK operation is <i class="emphasis">O</i>(1) + <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) = <i class="emphasis">O</i>(<span class="unicode">&alpha;</span>(<i class="emphasis">n</i>)).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 21.12</span></span><a name="1558"></a><a name="ch21ex24"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The amortized cost of each FIND-SET operation is <i class="emphasis">O</i>(<span class="unicode">&alpha;</span>(<i class="emphasis">n</i>)).</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> Suppose that the <i class="emphasis">q</i>th operation is a FIND-SET and that the find path contains <i class="emphasis">s</i> nodes. The actual cost of the FIND-SET operation is <i class="emphasis">O</i>(<i class="emphasis">s</i>). We shall show that no node's potential increases due to the FIND-SET and that at least max(0, <i class="emphasis">s</i> - (<span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) + 2)) nodes on the find path have their potential decrease by at least 1.</p>
<p class="para">To see that no node's potential increases, we first appeal to <a class="internaljump" href="#ch21ex21">Lemma 21.9</a> for all nodes other than the root. If <i class="emphasis">x</i> is the root, then its potential is <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) <span class="unicode">&middot;</span> <i class="emphasis">rank</i>[<i class="emphasis">x</i>], which does not change.</p>
<p class="para">Now we show that at least max(0, <i class="emphasis">s</i> - (<span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) + 2)) nodes have their potential decrease by at least 1. Let <i class="emphasis">x</i> be a node on the find path such that <i class="emphasis">rank</i>[<i class="emphasis">x</i>] <span class="unicode">&gt;</span> 0 and <i class="emphasis">x</i> is followed somewhere on the find path by another node <i class="emphasis">y</i> that is not a root, where level(<i class="emphasis">y</i>) = level(<i class="emphasis">x</i>) just before the FIND-SET operation. (Node <i class="emphasis">y</i> need not <i class="emphasis">immediately</i> follow <i class="emphasis">x</i> on the find path.) All but at most <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) + 2 nodes on the find path satisfy these constraints on <i class="emphasis">x</i>. Those that do not satisfy them are the first node <a name="1559"></a><a name="IDX-517"></a>on the find path (if it has rank 0), the last node on the path (i.e., the root), and the last node <i class="emphasis">w</i> on the path for which level(<i class="emphasis">w</i>) = <i class="emphasis">k</i>, for each <i class="emphasis">k</i> = 0, 1, 2, ..., <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) - 1.</p>
<p class="para">Let us fix such a node <i class="emphasis">x</i>, and we shall show that <i class="emphasis">x</i>'s potential decreases by at least 1. Let <i class="emphasis">k</i> = level(<i class="emphasis">x</i>) = level(<i class="emphasis">y</i>). Just prior to the path compression caused by the FIND-SET, we have</p>
<div class="informalequation">
<span class="equation-image"><a href="images/fig539%5F01%2Ejpg" NAME="IMG_639" target="_parent"><img src="images/fig539_01.jpg" height="81" width="400" alt="Click To expand" border="0"></a></span>
</div>
<p class="para">Putting these inequalities together and letting <i class="emphasis">i</i> be the value of iter(<i class="emphasis">x</i>) before path compression, we have</p>
<div class="informalequation">
<span class="equation-image"><a href="images/fig539%5F02%2Ejpg" NAME="IMG_640" target="_parent"><img src="images/fig539_02.jpg" height="75" width="400" alt="Click To expand" border="0"></a></span>
</div>
<p class="para">Because path compression will make <i class="emphasis">x</i> and <i class="emphasis">y</i> have the same parent, we know that after path compression, <i class="emphasis">rank</i>[<i class="emphasis">p</i>[<i class="emphasis">x</i>]] = <i class="emphasis">rank</i>[<i class="emphasis">p</i>[<i class="emphasis">y</i>]] and that the path compression does not decrease <i class="emphasis">rank</i>[<i class="emphasis">p</i>[<i class="emphasis">y</i>]]. Since <i class="emphasis">rank</i>[<i class="emphasis">x</i>] does not change, after path compression we have that <span class="inlinemediaobject"><img src="images/fig539_03.jpg" height="15" width="130" alt="" border="0"></span>. Thus, path compression will cause either iter(<i class="emphasis">x</i>) to increase (to at least <i class="emphasis">i</i> + 1) or level(<i class="emphasis">x</i>) to increase (which occurs if iter(<i class="emphasis">x</i>) increases to at least <i class="emphasis">rank</i>[<i class="emphasis">x</i>] + 1). In either case, by <a class="internaljump" href="#ch21ex21">Lemma 21.9</a>, we have <i class="emphasis"><span class="unicode">&phi;</span><sub>q</sub></i>(<i class="emphasis">x</i>) <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&phi;</span></i><sub><i class="emphasis">q</i>-1</sub>(<i class="emphasis">x</i>) - 1. Hence, <i class="emphasis">x</i>'s potential decreases by at least 1.</p>
<p class="last-para">The amortized cost of the FIND-SET operation is the actual cost plus the change in potential. The actual cost is <i class="emphasis">O</i>(<i class="emphasis">s</i>), and we have shown that the total potential decreases by at least max(0, <i class="emphasis">s</i> - (<span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) + 2)). The amortized cost, therefore, is at most <i class="emphasis">O</i>(<i class="emphasis">s</i>) - (<i class="emphasis">s</i> - (<span class="unicode">&alpha;</span>(<i class="emphasis">n</i>) + 2)) = <i class="emphasis">O</i>(<i class="emphasis">s</i>) - <i class="emphasis">s</i> + <i class="emphasis">O</i>(<span class="unicode">&alpha;</span>(<i class="emphasis">n</i>)) = <i class="emphasis">O</i>(<span class="unicode">&alpha;</span>(<i class="emphasis">n</i>)), since we can scale up the units of potential to dominate the constant hidden in <i class="emphasis">O</i>(<i class="emphasis">s</i>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">Putting the preceding lemmas together yields the following theorem.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 21.13</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">A sequence of <i class="emphasis">m</i> MAKE-SET, UNION, and FIND-SET operations, <i class="emphasis">n</i> of which are MAKE-SET operations, can be performed on a disjoint-set forest with union by rank and path compression in worst-case time <i class="emphasis">O</i>(<i class="emphasis">m</i> <span class="unicode">&alpha;</span>(<i class="emphasis">n</i>)).</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Immediate from <a class="internaljump" href="#ch21ex19">Lemmas 21.7</a>, <a class="internaljump" href="#ch21ex22">21.10</a>, <a class="internaljump" href="#ch21ex23">21.11</a>, and <a class="internaljump" href="#ch21ex24">21.12</a>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1560"></a><a name="IDX-518"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 21.4-1</span></span><a name="1561"></a><a name="ch21ex26"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Prove <a class="internaljump" href="#ch21ex16">Lemma 21.4</a>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 21.4-2</span></span><a name="1562"></a><a name="ch21ex27"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Prove that every node has rank at most <span class="unicode">&lfloor;</span>lg <i class="emphasis">n</i><span class="unicode">&rfloor;</span>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 21.4-3</span></span><a name="1563"></a><a name="ch21ex28"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">In light of <a class="internaljump" href="#ch21ex27">Exercise 21.4-2</a>, how many bits are necessary to store <i class="emphasis">rank</i>[<i class="emphasis">x</i>] for each node <i class="emphasis">x</i>?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 21.4-4</span></span><a name="1564"></a><a name="ch21ex29"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Using <a class="internaljump" href="#ch21ex27">Exercise 21.4-2</a>, give a simple proof that operations on a disjoint-set forest with union by rank but without path compression run in <i class="emphasis">O</i>(<i class="emphasis">m</i> lg <i class="emphasis">n</i>) time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 21.4-5</span></span><a name="1565"></a><a name="ch21ex30"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Professor Dante reasons that because node ranks increase strictly along a path to the root, node levels must monotonically increase along the path. In other words, if <i class="emphasis">rank</i>(<i class="emphasis">x</i>) <span class="unicode">&gt;</span> 0 and <i class="emphasis">p</i>[<i class="emphasis">x</i>] is not a root, then level(<i class="emphasis">x</i>) <span class="unicode">&le;</span> level(<i class="emphasis">p</i>[<i class="emphasis">x</i>]). Is the professor correct?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 21.4-6: </span><span class="unicode">&#8902;</span></span><a name="1566"></a><a name="ch21ex31"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Consider the function <span class="unicode">&alpha;</span>'(<i class="emphasis">n</i>) = min {<i class="emphasis">k</i> : <i class="emphasis">A<sub>k</sub></i> (1) <span class="unicode">&ge;</span> lg(<i class="emphasis">n</i> + 1)}. Show that <span class="unicode">&alpha;</span>'(<i class="emphasis">n</i>) <span class="unicode">&le;</span> 3 for all practical values of <i class="emphasis">n</i> and, using <a class="internaljump" href="#ch21ex27">Exercise 21.4-2</a>, show how to modify the potential-function argument to prove that a sequence of <i class="emphasis">m</i> MAKE-SET, UNION, and FIND-SET operations, <i class="emphasis">n</i> of which are MAKE-SET operations, can be performed on a disjoint-set forest with union by rank and path compression in worst-case time <i class="emphasis">O</i>(<i class="emphasis">m</i> <span class="unicode">&alpha;</span>'(<i class="emphasis">n</i>)).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 21-1: </span>Off-line minimum</span><a name="1567"></a><a name="ch21ex32"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The <b class="bold"><i class="emphasis">off-line minimum problem</i></b> asks us to maintain a dynamic set <i class="emphasis">T</i> of elements from the domain {1, 2, ..., <i class="emphasis">n</i>} under the operations INSERT and EXTRACT-MIN. We are given a sequence <i class="emphasis">S</i> of <i class="emphasis">n</i> INSERT and <i class="emphasis">m</i> EXTRACT-MIN calls, where each key in {1, 2, ..., <i class="emphasis">n</i>} is inserted exactly once. We wish to determine which key is returned by each EXTRACT-MIN call. Specifically, we wish to fill in an array <i class="emphasis">extracted</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">m</i>], where for <i class="emphasis">i</i> = 1, 2, ..., <i class="emphasis">m</i>, <i class="emphasis">extracted</i>[<i class="emphasis">i</i>] is the key returned by the <i class="emphasis">i</i>th EXTRACT-MIN call. The problem is "off-line" in the sense that we are <a name="1568"></a><a name="IDX-519"></a>allowed to process the entire sequence <i class="emphasis">S</i> before determining any of the returned keys.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">In the following instance of the off-line minimum problem, each INSERT is represented by a number and each EXTRACT-MIN is represented by the letter E:</p>
<p class="para">4, 8, E, 3, E, 9, 2, 6, E, E, E, 1, 7, E, 5.</p>
<p class="last-para">Fill in the correct values in the <i class="emphasis">extracted</i> array.</p>
</li>
</ol>
<p class="para">To develop an algorithm for this problem, we break the sequence <i class="emphasis">S</i> into homogeneous subsequences. That is, we represent <i class="emphasis">S</i> by</p>
<p class="para">I<sub>1</sub>, E, I<sub>2</sub>, E, I<sub>3</sub>, ..., I<sub><i class="emphasis">m</i></sub>, E, I<sub><i class="emphasis">m</i>+1</sub>,</p>
<p class="para">where each E represents a single EXTRACT-MIN call and each I<sub><i class="emphasis">j</i></sub> represents a (possibly empty) sequence of INSERT calls. For each subsequence I<sub><i class="emphasis">j</i></sub>, we initially place the keys inserted by these operations into a set <i class="emphasis">K<sub>j</sub></i> , which is empty if I<sub><i class="emphasis">j</i></sub> is empty. We then do the following.</p>
<div class="informalexample">
<pre class="literallayout-normal">
OFF-LINE-MINIMUM(<i class="emphasis">m</i>, <i class="emphasis">n</i>)
1  <b class="bold">for</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">n</i>
2       <b class="bold">do</b> determine <i class="emphasis">j</i> such that <i class="emphasis">i</i> <span class="unicode">&isin;</span> <i class="emphasis">K<sub>j</sub></i>
3          <b class="bold">if</b> <i class="emphasis">j</i> <span class="unicode">&ne;</span> <i class="emphasis">m</i> + 1
4             <b class="bold">then</b> <i class="emphasis">extracted</i>[<i class="emphasis">j</i>] <span class="unicode">&larr;</span> <i class="emphasis">i</i>
5                  let <i class="emphasis">l</i> be the smallest value greater than <i class="emphasis">j</i>
                                   for which set <i class="emphasis">K<sub>l</sub></i> exists
6                  <i class="emphasis">K<sub>l</sub></i> <span class="unicode">&larr;</span> <i class="emphasis">K<sub>j</sub></i> <span class="unicode">&cup;</span> <i class="emphasis">K<sub>l</sub></i>, destroying <i class="emphasis">K<sub>j</sub></i>
7  <b class="bold">return</b> extracted
</pre>
</div>
<ol class="orderedlist" start="2" type="a">
<li class="first-listitem">
<p class="first-para">Argue that the array <i class="emphasis">extracted</i> returned by OFF-LINE-MINIMUM is correct.</p>
</li>
<li class="listitem">
<p class="first-para">Describe how to implement OFF-LINE-MINIMUM efficiently with a disjoint-set data structure. Give a tight bound on the worst-case running time of your implementation.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 21-2: </span>Depth determination</span><a name="1569"></a><a name="ch21ex33"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">In the <b class="bold"><i class="emphasis">depth-determination problem</i></b>, we maintain a forest <span class="inlinemediaobject"><img src="images/fig541_01.jpg" height="12" width="40" alt="" border="0"></span> of rooted trees under three operations:<a name="1570"></a><a name="IDX-520"></a>
</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">MAKE-TREE(<i class="emphasis">v</i>) creates a tree whose only node is <i class="emphasis">v</i>.</p>
</li>
<li class="listitem">
<p class="first-para">FIND-DEPTH(<i class="emphasis">v</i>) returns the depth of node <i class="emphasis">v</i> within its tree.</p>
</li>
<li class="listitem">
<p class="first-para">GRAFT(<i class="emphasis">r</i>, <i class="emphasis">v</i>) makes node <i class="emphasis">r</i>, which is assumed to be the root of a tree, become the child of node <i class="emphasis">v</i>, which is assumed to be in a different tree than <i class="emphasis">r</i> but may or may not itself be a root.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Suppose that we use a tree representation similar to a disjoint-set forest: <i class="emphasis">p</i>[<i class="emphasis">v</i>] is the parent of node <i class="emphasis">v</i>, except that <i class="emphasis">p</i>[<i class="emphasis">v</i>] = <i class="emphasis">v</i> if <i class="emphasis">v</i> is a root. If we implement GRAFT(<i class="emphasis">r</i>, <i class="emphasis">v</i>) by setting <i class="emphasis">p</i>[<i class="emphasis">r</i>] <span class="unicode">&larr;</span> <i class="emphasis">v</i> and FIND-DEPTH(<i class="emphasis">v</i>) by following the find path up to the root, returning a count of all nodes other than <i class="emphasis">v</i> encountered, show that the worst-case running time of a sequence of <i class="emphasis">m</i> MAKE-TREE, FIND-DEPTH, and GRAFT operations is <span class="unicode">&Theta;</span>(<i class="emphasis">m</i><sup>2</sup>).</p>
</li>
</ol>
</li>
</ul>
<p class="para">By using the union-by-rank and path-compression heuristics, we can reduce the worst-case running time. We use the disjoint-set forest <span class="inlinemediaobject"><img src="images/fig542_01.jpg" height="12" width="40" alt="" border="0"></span>, where each set <i class="emphasis">S<sub>i</sub></i> (which is itself a tree) corresponds to a tree <i class="emphasis">T<sub>i</sub></i> in the forest <span class="inlinemediaobject"><img src="images/fig542_02.jpg" height="11" width="12" alt="" border="0"></span>. The tree structure within a set <i class="emphasis">S<sub>i</sub></i>, however, does not necessarily correspond to that of <i class="emphasis">T<sub>i</sub></i>. In fact, the implementation of <i class="emphasis">S<sub>i</sub></i> does not record the exact parent-child relationships but nevertheless allows us to determine any node's depth in <i class="emphasis">T<sub>i</sub></i>.</p>
<p class="para">The key idea is to maintain in each node <i class="emphasis">v</i> a "pseudodistance" <i class="emphasis">d</i>[<i class="emphasis">v</i>], which is defined so that the sum of the pseudodistances along the path from <i class="emphasis">v</i> to the root of its set <i class="emphasis">S<sub>i</sub></i> equals the depth of <i class="emphasis">v</i> in <i class="emphasis">T<sub>i</sub></i>. That is, if the path from <i class="emphasis">v</i> to its root in <i class="emphasis">S<sub>i</sub></i> is <i class="emphasis">v</i><sub>0</sub>, <i class="emphasis">v</i><sub>1</sub>, ..., <i class="emphasis">v<sub>k</sub></i>, where <i class="emphasis">v</i><sub>0</sub> = <i class="emphasis">v</i> and <i class="emphasis">v<sub>k</sub></i> is <i class="emphasis">S<sub>i</sub></i>'s root, then the depth of <i class="emphasis">v</i> in <i class="emphasis">T<sub>i</sub></i> is <span class="inlinemediaobject"><img src="images/fig542_03.jpg" height="17" width="55" alt="" border="0"></span>.</p>
<ol class="orderedlist" start="2" type="a">
<li class="first-listitem">
<p class="first-para">Give an implementation of MAKE-TREE.</p>
</li>
<li class="listitem">
<p class="first-para">Show how to modify FIND-SET to implement FIND-DEPTH. Your implementation should perform path compression, and its running time should be linear in the length of the find path. Make sure that your implementation updates pseudodistances correctly.</p>
</li>
<li class="listitem">
<p class="first-para">Show how to implement GRAFT(<i class="emphasis">r</i>, <i class="emphasis">v</i>), which combines the sets containing <i class="emphasis">r</i> and <i class="emphasis">v</i>, by modifying the UNION and LINK procedures. Make sure that your implementation updates pseudodistances correctly. Note that the root of a set <i class="emphasis">S<sub>i</sub></i> is not necessarily the root of the corresponding tree <i class="emphasis">T<sub>i</sub></i>.</p>
</li>
<li class="listitem">
<p class="first-para">Give a tight bound on the worst-case running time of a sequence of <i class="emphasis">m</i> MAKE-TREE, FIND-DEPTH, and GRAFT operations, <i class="emphasis">n</i> of which are MAKE-TREE operations.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1571"></a><a name="IDX-521"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 21-3: </span>Tarjan's off-line least-common-ancestors algorithm</span><a name="1572"></a><a name="ch21ex34"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The <b class="bold"><i class="emphasis">least common ancestor</i></b> of two nodes <i class="emphasis">u</i> and <i class="emphasis">v</i> in a rooted tree <i class="emphasis">T</i> is the node <i class="emphasis">w</i> that is an ancestor of both <i class="emphasis">u</i> and <i class="emphasis">v</i> and that has the greatest depth in <i class="emphasis">T</i>. In the <b class="bold"><i class="emphasis">off-line least-common-ancestors problem</i></b>, we are given a rooted tree <i class="emphasis">T</i> and an arbitrary set <i class="emphasis">P</i> = {{<i class="emphasis">u</i>, <i class="emphasis">v</i>}} of unordered pairs of nodes in <i class="emphasis">T</i>, and we wish to determine the least common ancestor of each pair in <i class="emphasis">P</i>.</p>
<p class="para">To solve the off-line least-common-ancestors problem, the following procedure performs a tree walk of <i class="emphasis">T</i> with the initial call LCA(<i class="emphasis">root</i>[<i class="emphasis">T</i>]). Each node is assumed to be colored WHITE prior to the walk.</p>
<div class="informalexample">
<pre class="literallayout-normal">
LCA(<i class="emphasis">u</i>)
 1  MAKE-SET(<i class="emphasis">u</i>)
 2  <i class="emphasis">ancestor</i>[FIND-SET(u)] <span class="unicode">&larr;</span> <i class="emphasis">u</i>
 3  <b class="bold">for</b> each child <i class="emphasis">v</i> of <i class="emphasis">u</i> in <i class="emphasis">T</i>
 4       <b class="bold">do</b> LCA(<i class="emphasis">v</i>)
 5          UNION(<i class="emphasis">u</i>, <i class="emphasis">v</i>)
 6          <i class="emphasis">ancestor</i>[FIND-SET(<i class="emphasis">u</i>)] <span class="unicode">&larr;</span> <i class="emphasis">u</i>
 7  <i class="emphasis">color</i>[<i class="emphasis">u</i>] <span class="unicode">&larr;</span> BLACK
 8  <b class="bold">for</b> each node <i class="emphasis">v</i> such that {<i class="emphasis">u</i>, <i class="emphasis">v</i>} <span class="unicode">&isin;</span> <i class="emphasis">P</i>
 9       <b class="bold">do if</b> <i class="emphasis">color</i>[<i class="emphasis">v</i>] = BLACK
10            <b class="bold">then</b> print "The least common ancestor of"
                          <i class="emphasis">u</i> "and" <i class="emphasis">v</i> "is" <i class="emphasis">ancestor</i>[FIND-SET(<i class="emphasis">v</i>)]
</pre>
</div>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Argue that line 10 is executed exactly once for each pair {<i class="emphasis">u</i>, <i class="emphasis">v</i>} <span class="unicode">&isin;</span> <i class="emphasis">P</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Argue that at the time of the call LCA(<i class="emphasis">u</i>), the number of sets in the disjoint-set data structure is equal to the depth of <i class="emphasis">u</i> in <i class="emphasis">T</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Prove that LCA correctly prints the least common ancestor of <i class="emphasis">u</i> and <i class="emphasis">v</i> for each pair {<i class="emphasis">u</i>, <i class="emphasis">v</i>} <span class="unicode">&isin;</span> <i class="emphasis">P</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Analyze the running time of LCA, assuming that we use the implementation of the disjoint-set data structure in <a href="DDU0125.html#1522" target="_parent" class="chapterjump">Section 21.3.</a>
</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0125.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0127.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
