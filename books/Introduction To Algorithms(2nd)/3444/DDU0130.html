<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>22.2 Breadth-first search</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0129.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0131.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch22"></a>
<div class="section">
<h2 class="first-section-title">
<a name="1596"></a><a name="ch22lev1sec2"></a><span class="section-titlelabel">22.2 </span>Breadth-first search</h2>
<p class="first-para">
<b class="bold"><i class="emphasis">Breadth-first search</i></b> is one of the simplest algorithms for searching a graph and the archetype for many important graph algorithms. Prim's minimum-spanning-tree algorithm (<a href="DDU0137.html#1718" target="_parent" class="chapterjump">Section 23.2</a>) and Dijkstra's single-source shortest-paths algorithm (<a href="DDU0150.html#1788" target="_parent" class="chapterjump">Section 24.3</a>) use ideas similar to those in breadth-first search.</p>
<p class="para">Given a graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) and a distinguished <b class="bold"><i class="emphasis">source</i></b> vertex <i class="emphasis">s</i>, breadth-first search systematically explores the edges of <i class="emphasis">G</i> to "discover" every vertex that is reachable from <i class="emphasis">s</i>. It computes the distance (smallest number of edges) from <i class="emphasis">s</i> to each reachable vertex. It also produces a "breadth-first tree" with root <i class="emphasis">s</i> that contains all reachable vertices. For any vertex <i class="emphasis">v</i> reachable from <i class="emphasis">s</i>, the path in the breadth-first tree from <i class="emphasis">s</i> to <i class="emphasis">v</i> corresponds to a "shortest path" from <i class="emphasis">s</i> to <i class="emphasis">v</i> in <i class="emphasis">G</i>, that is, a path containing the smallest number of edges. The algorithm works on both directed and undirected graphs.</p>
<p class="para">Breadth-first search is so named because it expands the frontier between discovered and undiscovered vertices uniformly across the breadth of the frontier. That is, the algorithm discovers all vertices at distance <i class="emphasis">k</i> from <i class="emphasis">s</i> before discovering any vertices at distance <i class="emphasis">k</i> + 1.</p>
<p class="para">To keep track of progress, breadth-first search colors each vertex white, gray, or black. All vertices start out white and may later become gray and then black. A vertex is <b class="bold"><i class="emphasis">discovered</i></b> the first time it is encountered during the search, at which time it becomes nonwhite. Gray and black vertices, therefore, have been discovered, but <a name="1597"></a><a name="IDX-532"></a>breadth-first search distinguishes between them to ensure that the search proceeds in a breadth-first manner. If (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i> and vertex <i class="emphasis">u</i> is black, then vertex <i class="emphasis">v</i> is either gray or black; that is, all vertices adjacent to black vertices have been discovered. Gray vertices may have some adjacent white vertices; they represent the frontier between discovered and undiscovered vertices.</p>
<p class="para">Breadth-first search constructs a breadth-first tree, initially containing only its root, which is the source vertex <i class="emphasis">s</i>. Whenever a white vertex <i class="emphasis">v</i> is discovered in the course of scanning the adjacency list of an already discovered vertex <i class="emphasis">u</i>, the vertex <i class="emphasis">v</i> and the edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) are added to the tree. We say that <i class="emphasis">u</i> is the <b class="bold"><i class="emphasis">predecessor</i></b> or <b class="bold"><i class="emphasis">parent</i></b> of <i class="emphasis">v</i> in the breadth-first tree. Since a vertex is discovered at most once, it has at most one parent. Ancestor and descendant relationships in the breadth-first tree are defined relative to the root <i class="emphasis">s</i> as usual: if <i class="emphasis">u</i> is on a path in the tree from the root <i class="emphasis">s</i> to vertex <i class="emphasis">v</i>, then <i class="emphasis">u</i> is an ancestor of <i class="emphasis">v</i> and <i class="emphasis">v</i> is a descendant of <i class="emphasis">u</i>.</p>
<p class="para">The breadth-first-search procedure BFS below assumes that the input graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) is represented using adjacency lists. It maintains several additional data structures with each vertex in the graph. The color of each vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> is stored in the variable <i class="emphasis">color</i>[<i class="emphasis">u</i>], and the predecessor of <i class="emphasis">u</i> is stored in the variable <span class="unicode">&pi;</span>[<i class="emphasis">u</i>]. If <i class="emphasis">u</i> has no predecessor (for example, if <i class="emphasis">u</i> = <i class="emphasis">s</i> or <i class="emphasis">u</i> has not been discovered), then <i class="emphasis"><span class="unicode">&pi;</span></i>[<i class="emphasis">u</i>] = NIL. The distance from the source <i class="emphasis">s</i> to vertex <i class="emphasis">u</i> computed by the algorithm is stored in <i class="emphasis">d</i>[<i class="emphasis">u</i>]. The algorithm also uses a first-in, first-out queue <i class="emphasis">Q</i> (see <a href="DDU0058.html#622" target="_parent" class="chapterjump">Section 10.1</a>) to manage the set of gray vertices.</p>
<div class="informalexample">
<pre class="literallayout-normal">
BFS(<i class="emphasis">G</i>, <i class="emphasis">s</i>)
 1  <b class="bold">for</b> each vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> [<i class="emphasis">G</i>] - {<i class="emphasis">s</i>}
 2       <b class="bold">do</b> <i class="emphasis">color</i>[<i class="emphasis">u</i>] <span class="unicode">&larr;</span> WHITE
 3          <i class="emphasis">d</i>[<i class="emphasis">u</i>] <span class="unicode">&larr;</span> <span class="unicode">&infin;</span>
 4          <i class="emphasis"><span class="unicode">&pi;</span></i>[<i class="emphasis">u</i>] <span class="unicode">&larr;</span> NIL
 5  <i class="emphasis">color</i>[<i class="emphasis">s</i>] <span class="unicode">&larr;</span> GRAY
 6  <i class="emphasis">d</i>[<i class="emphasis">s</i>] <span class="unicode">&larr;</span> 0
 7  <i class="emphasis"><span class="unicode">&pi;</span></i>[<i class="emphasis">s</i>] <span class="unicode">&larr;</span> NIL
 8  <i class="emphasis">Q</i> <span class="unicode">&larr;</span> <span class="unicode">&Oslash;</span>
 9  ENQUEUE(<i class="emphasis">Q</i>, <i class="emphasis">s</i>)
10  <b class="bold">while</b> <i class="emphasis">Q</i> <span class="unicode">&ne;</span> <span class="unicode">&Oslash;</span>
11      <b class="bold">do</b> <i class="emphasis">u</i> <span class="unicode">&larr;</span> DEQUEUE(<i class="emphasis">Q</i>)
12         <b class="bold">for</b> each <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">Adj</i>[<i class="emphasis">u</i>]
13             <b class="bold">do if</b> <i class="emphasis">color</i>[<i class="emphasis">v</i>] = WHITE
14                   <b class="bold">then</b> <i class="emphasis">color</i>[<i class="emphasis">v</i>] <span class="unicode">&larr;</span> GRAY
15                        <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&larr;</span> <i class="emphasis">d</i>[<i class="emphasis">u</i>] + 1
16                        <i class="emphasis"><span class="unicode">&pi;</span></i>[<i class="emphasis">v</i>] <span class="unicode">&larr;</span> <i class="emphasis">u</i>
17                        ENQUEUE(<i class="emphasis">Q</i>, <i class="emphasis">v</i>)
18         <i class="emphasis">color</i>[<i class="emphasis">u</i>] <span class="unicode">&larr;</span> BLACK
</pre>
</div>
<a name="1598"></a><a name="IDX-533"></a>
<p class="para">
<a class="internaljump" href="#ch22fig03">Figure 22.3</a> illustrates the progress of BFS on a sample graph.</p>
<div class="figure">
<a name="1599"></a><a name="ch22fig03"></a><span class="figuremediaobject"><a href="images/fig555%5F01%5F0%2Ejpg" NAME="IMG_656" target="_parent"><img src="images/fig555_01.jpg" height="288" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 22.3: </span>The operation of BFS on an undirected graph. Tree edges are shown shaded as they are produced by BFS. Within each vertex <i class="emphasis">u</i> is shown <i class="emphasis">d</i>[<i class="emphasis">u</i>]. The queue <i class="emphasis">Q</i> is shown at the beginning of each iteration of the <i class="emphasis">while</i> loop of lines 10<span class="unicode">-</span>18. Vertex distances are shown next to vertices in the queue.</span>
</div>
<p class="para">The procedure BFS works as follows. Lines 1<span class="unicode">-</span>4 paint every vertex white, set <i class="emphasis">d</i>[<i class="emphasis">u</i>] to be infinity for each vertex <i class="emphasis">u</i>, and set the parent of every vertex to be NIL.Line 5 paints the source vertex <i class="emphasis">s</i> gray, since it is considered to be discovered when the procedure begins. Line 6 initializes <i class="emphasis">d</i>[<i class="emphasis">s</i>] to 0, and line 7 sets the predecessor of the source to be NIL. Lines 8<span class="unicode">-</span>9 initialize <i class="emphasis">Q</i> to the queue containing just the vertex <i class="emphasis">s</i>.<a name="1600"></a><a name="IDX-534"></a>
</p>
<p class="para">The <b class="bold">while</b> loop of lines 10<span class="unicode">-</span>18 iterates as long as there remain gray vertices, which are discovered vertices that have not yet had their adjacency lists fully examined. This <b class="bold">while</b> loop maintains the following invariant:</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">At the test in line 10, the queue <i class="emphasis">Q</i> consists of the set of gray vertices.</p>
</li>
</ul>
<p class="para">Although we won't use this loop invariant to prove correctness, it is easy to see that it holds prior to the first iteration and that each iteration of the loop maintains the invariant. Prior to the first iteration, the only gray vertex, and the only vertex in <i class="emphasis">Q</i>, is the source vertex <i class="emphasis">s</i>. Line 11 determines the gray vertex <i class="emphasis">u</i> at the head of the queue <i class="emphasis">Q</i> and removes it from <i class="emphasis">Q</i>. The <b class="bold">for</b> loop of lines 12<span class="unicode">-</span>17 considers each vertex <i class="emphasis">v</i> in the adjacency list of <i class="emphasis">u</i>. If <i class="emphasis">v</i> is white, then it has not yet been discovered, and the algorithm discovers it by executing lines 14<span class="unicode">-</span>17. It is first grayed, and its distance <i class="emphasis">d</i>[<i class="emphasis">v</i>] is set to <i class="emphasis">d</i>[<i class="emphasis">u</i>]+1. Then, <i class="emphasis">u</i> is recorded as its parent. Finally, it is placed at the tail of the queue <i class="emphasis">Q</i>. When all the vertices on <i class="emphasis">u</i>'s adjacency list have been examined, <i class="emphasis">u</i> is blackened in lines 11<span class="unicode">-</span>18. The loop invariant is maintained because whenever a vertex is painted gray (in line 14) it is also enqueued (in line 17), and whenever a vertex is dequeued (in line 11) it is also painted black (in line 18).</p>
<p class="para">The results of breadth-first search may depend upon the order in which the neighbors of a given vertex are visited in line 12: the breadth-first tree may vary, but the distances <i class="emphasis">d</i> computed by the algorithm will not. (See <a class="internaljump" href="#ch22ex18">Exercise 22.2-4</a>.)</p>
<div class="section">
<h4 class="sect4-title">
<a name="1601"></a><a name="ch22lev3sec1"></a>Analysis</h4>
<p class="first-para">Before proving the various properties of breadth-first search, we take on the somewhat easier job of analyzing its running time on an input graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>). We use aggregate analysis, as we saw in <a href="DDU0101.html#1254" target="_parent" class="chapterjump">Section 17.1.</a> After initialization, no vertex is ever whitened, and thus the test in line 13 ensures that each vertex is enqueued at most once, and hence dequeued at most once. The operations of enqueuing and dequeuing take <i class="emphasis">O</i>(1) time, so the total time devoted to queue operations is <i class="emphasis">O</i>(<i class="emphasis">V</i>). Because the adjacency list of each vertex is scanned only when the vertex is dequeued, each adjacency list is scanned at most once. Since the sum of the lengths of all the adjacency lists is <span class="unicode">&Theta;</span>(<i class="emphasis">E</i>), the total time spent in scanning adjacency lists is <i class="emphasis">O</i>(<i class="emphasis">E</i>). The overhead for initialization is <i class="emphasis">O</i>(<i class="emphasis">V</i>), and thus the total running time of BFS is <i class="emphasis">O</i>(<i class="emphasis">V</i> + <i class="emphasis">E</i>). Thus, breadth-first search runs in time linear in the size of the adjacency-list representation of <i class="emphasis">G</i>.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1602"></a><a name="ch22lev3sec2"></a>Shortest paths</h4>
<p class="first-para">At the beginning of this section, we claimed that breadth-first search finds the distance to each reachable vertex in a graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) from a given source vertex <i class="emphasis">s</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>. Define the <b class="bold"><i class="emphasis">shortest-path distance</i></b> <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) from <i class="emphasis">s</i> to <i class="emphasis">v</i> as the minimum number of edges in any path from vertex <i class="emphasis">s</i> to vertex <i class="emphasis">v</i>; if there is no path from <i class="emphasis">s</i> to <i class="emphasis">v</i>, <a name="1603"></a><a name="IDX-535"></a>then <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) = <span class="unicode">&infin;</span>. A path of length <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) from <i class="emphasis">s</i> to <i class="emphasis">v</i> is said to be a <b class="bold"><i class="emphasis">shortest path</i></b><sup>[<a name="N862" href="#ftn.N862">1</a>]</sup> from <i class="emphasis">s</i> to <i class="emphasis">v</i>. Before showing that breadth-first search actually computes shortest-path distances, we investigate an important property of shortest-path distances.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 22.1</span></span><a name="1604"></a><a name="ch22ex09"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a directed or undirected graph, and let <i class="emphasis">s</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> be an arbitrary vertex. Then, for any edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>,</p>
<p class="para">
<span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) &le; <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) + 1.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> If <i class="emphasis">u</i> is reachable from <i class="emphasis">s</i>, then so is <i class="emphasis">v</i>. In this case, the shortest path from <i class="emphasis">s</i> to <i class="emphasis">v</i> cannot be longer than the shortest path from <i class="emphasis">s</i> to <i class="emphasis">u</i> followed by the edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>), and thus the inequality holds. If <i class="emphasis">u</i> is not reachable from <i class="emphasis">s</i>, then <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) = <span class="unicode">&infin;</span>, and the inequality holds.</p>
<p class="last-para">We want to show that BFS properly computes <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) for each vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>. We first show that <i class="emphasis">d</i>[<i class="emphasis">v</i>] bounds <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) from above.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 22.2</span></span><a name="1605"></a><a name="ch22ex10"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a directed or undirected graph, and suppose that BFS is run on <i class="emphasis">G</i> from a given source vertex <i class="emphasis">s</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>. Then upon termination, for each vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, the value <i class="emphasis">d</i>[<i class="emphasis">v</i>] computed by BFS satisfies <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&ge;</span> <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>).</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> We use induction on the number of ENQUEUE operations. Our inductive hypothesis is that <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&ge;</span> <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) for all <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>.</p>
<p class="para">The basis of the induction is the situation immediately after <i class="emphasis">s</i> is enqueued in line 9 of BFS. The inductive hypothesis holds here, because <i class="emphasis">d</i>[<i class="emphasis">s</i>] = 0 = <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">s</i>) and <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <span class="unicode">&infin;</span> <span class="unicode">&ge;</span> <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) for all <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> - {<i class="emphasis">s</i>}.</p>
<p class="para">For the inductive step, consider a white vertex <i class="emphasis">v</i> that is discovered during the search from a vertex <i class="emphasis">u</i>. The inductive hypothesis implies that <i class="emphasis">d</i>[<i class="emphasis">u</i>] <span class="unicode">&ge;</span> <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">u</i>). From the assignment performed by line 15 and from <a class="internaljump" href="#ch22ex09">Lemma 22.1</a>, we obtain</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">d</i>[<i class="emphasis">v</i>]</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">d</i>[<i class="emphasis">u</i>] + 1</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&ge;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) + 1</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&ge;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>).</p>
</td>
</tr>
</tbody>
</table>
</div>
<a name="1606"></a><a name="IDX-536"></a>
<p class="last-para">Vertex <i class="emphasis">v</i> is then enqueued, and it is never enqueued again because it is also grayed and the <b class="bold">then</b> clause of lines 14<span class="unicode">-</span>17 is executed only for white vertices. Thus, the value of <i class="emphasis">d</i>[<i class="emphasis">v</i>] never changes again, and the inductive hypothesis is maintained.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">To prove that <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>), we must first show more precisely how the queue <i class="emphasis">Q</i> operates during the course of BFS. The next lemma shows that at all times, there are at most two distinct <i class="emphasis">d</i> values in the queue.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 22.3</span></span><a name="1607"></a><a name="ch22ex11"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that during the execution of BFS on a graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>), the queue <i class="emphasis">Q</i> contains the vertices <span class="unicode">&#12296;</span><i class="emphasis">v</i><sub>1</sub>, <i class="emphasis">v</i><sub>2</sub>,..., <i class="emphasis">v<sub>r</sub></i><span class="unicode">&#12297;</span>, where <i class="emphasis">v</i><sub>1</sub> is the head of <i class="emphasis">Q</i> and <i class="emphasis">v<sub>r</sub></i> is the tail. Then, <i class="emphasis">d</i>[<i class="emphasis">v<sub>r</sub></i>] <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i><sub>1</sub>] + 1 and <i class="emphasis">d</i>[<i class="emphasis">v<sub>i</sub></i> ] <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i><sub><i class="emphasis">i</i>+1</sub>] for <i class="emphasis">i</i> = 1, 2,..., <i class="emphasis">r</i> - 1.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> The proof is by induction on the number of queue operations. Initially, when the queue contains only <i class="emphasis">s</i>, the lemma certainly holds.</p>
<p class="para">For the inductive step, we must prove that the lemma holds after both dequeuing and enqueuing a vertex. If the head <i class="emphasis">v</i><sub>1</sub> of the queue is dequeued, <i class="emphasis">v</i><sub>2</sub> becomes the new head. (If the queue becomes empty, then the lemma holds vacuously.) By the inductive hypothesis, <i class="emphasis">d</i>[<i class="emphasis">v</i><sub>1</sub>] <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i><sub>2</sub>]. But then we have <i class="emphasis">d</i>[<i class="emphasis">v<sub>r</sub></i>] <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i><sub>1</sub>] + 1 <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i><sub>2</sub>] + 1, and the remaining inequalities are unaffected. Thus, the lemma follows with <i class="emphasis">v</i><sub>2</sub> as the head.</p>
<p class="last-para">Enqueuing a vertex requires closer examination of the code. When we enqueue a vertex <i class="emphasis">v</i> in line 17 of BFS, it becomes <i class="emphasis">v</i><sub><i class="emphasis">r</i>+1</sub>. At that time, we have already removed vertex <i class="emphasis">u</i>, whose adjacency list is currently being scanned, from the queue <i class="emphasis">Q</i>, and by the inductive hypothesis, the new head <i class="emphasis">v</i><sub>1</sub> has <i class="emphasis">d</i>[<i class="emphasis">v</i><sub>1</sub>] <span class="unicode">&ge;</span> <i class="emphasis">d</i>[<i class="emphasis">u</i>]. Thus, <i class="emphasis">d</i>[<i class="emphasis">v</i><sub><i class="emphasis">r</i>+1</sub>] = <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <i class="emphasis">d</i>[<i class="emphasis">u</i>] + 1 <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i><sub>1</sub>] + 1. From the inductive hypothesis, we also have <i class="emphasis">d</i>[<i class="emphasis">v<sub>r</sub></i>] <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">u</i>] + 1, and so <i class="emphasis">d</i>[<i class="emphasis">v<sub>r</sub></i>] <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">u</i>] + 1 = <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <i class="emphasis">d</i>[<i class="emphasis">v</i><sub><i class="emphasis">r</i>+1</sub>], and the remaining inequalities are unaffected. Thus, the lemma follows when <i class="emphasis">v</i> is enqueued.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">The following corollary shows that the <i class="emphasis">d</i> values at the time that vertices are enqueued are monotonically increasing over time.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Corollary 22.4</span></span><a name="1608"></a><a name="ch22ex12"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that vertices <i class="emphasis">v<sub>i</sub></i> and <i class="emphasis">v<sub>j</sub></i> are enqueued during the execution of BFS, and that <i class="emphasis">v<sub>i</sub></i> is enqueued before <i class="emphasis">v<sub>j</sub></i>. Then <i class="emphasis">d</i>[<i class="emphasis">v<sub>i</sub></i>] <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">v<sub>j</sub></i>] at the time that <i class="emphasis">v<sub>j</sub></i> is enqueued.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Immediate from <a class="internaljump" href="#ch22ex11">Lemma 22.3</a> and the property that each vertex receives a finite <i class="emphasis">d</i> value at most once during the course of BFS.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">We can now prove that breadth-first search correctly finds shortest-path distances.<a name="1609"></a><a name="IDX-537"></a>
</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 22.5: </span>(Correctness of breadth-first search)</span><a name="1610"></a><a name="ch22ex13"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a directed or undirected graph, and suppose that BFS is run on <i class="emphasis">G</i> from a given source vertex <i class="emphasis">s</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> . Then, during its execution, BFS discovers every vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> that is reachable from the source <i class="emphasis">s</i>, and upon termination, <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) for all <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> . Moreover, for any vertex <i class="emphasis">v</i> <span class="unicode">&ne;</span> <i class="emphasis">s</i> that is reachable from <i class="emphasis">s</i>, one of the shortest paths from <i class="emphasis">s</i> to <i class="emphasis">v</i> is a shortest path from <i class="emphasis">s</i> to <i class="emphasis"><span class="unicode">&pi;</span></i>[<i class="emphasis">v</i>] followed by the edge (<i class="emphasis"><span class="unicode">&pi;</span></i>[<i class="emphasis">v</i>], <i class="emphasis">v</i>).</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> Assume, for the purpose of contradiction, that some vertex receives a <i class="emphasis">d</i> value not equal to its shortest path distance. Let <i class="emphasis">v</i> be the vertex with minimum <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) that receives such an incorrect <i class="emphasis">d</i> value; clearly <i class="emphasis">v</i> <span class="unicode">&ne;</span> <i class="emphasis">s</i>. By <a class="internaljump" href="#ch22ex10">Lemma 22.2</a>, <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&ge;</span> <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>), and thus we have that <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&gt;</span> <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>). Vertex <i class="emphasis">v</i> must be reachable from <i class="emphasis">s</i>, for if it is not, then <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) = <span class="unicode">&infin;</span> <span class="unicode">&ge;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i>]. Let <i class="emphasis">u</i> be the vertex immediately preceding <i class="emphasis">v</i> on a shortest path from <i class="emphasis">s</i> to <i class="emphasis">v</i>, so that <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) = <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) + 1. Because <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) <span class="unicode">&lt;</span> <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>), and because of how we chose <i class="emphasis">v</i>, we have <i class="emphasis">d</i>[<i class="emphasis">u</i>] = <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">u</i>). Putting these properties together, we have</p>
<p class="para">
<div class="equation">
<a name="1611"></a><a name="ch22eq01"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(22.1)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig559_01.jpg" height="15" width="247" alt="" border="0"></span></td>
</tr>
</table>
</div>
</p>
<p class="para">Now consider the time when BFS chooses to dequeue vertex <i class="emphasis">u</i> from <i class="emphasis">Q</i> in line 11. At this time, vertex <i class="emphasis">v</i> is either white, gray, or black. We shall show that in each of these cases, we derive a contradiction to inequality <a class="internaljump" href="#ch22eq01">(22.1)</a>. If <i class="emphasis">v</i> is white, then line 15 sets <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <i class="emphasis">d</i>[<i class="emphasis">u</i>] + 1, contradicting inequality <a class="internaljump" href="#ch22eq01">(22.1)</a>. If <i class="emphasis">v</i> is black, then it was already removed from the queue and, by <a class="internaljump" href="#ch22ex12">Corollary 22.4</a>, we have <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">u</i>], again contradicting inequality <a class="internaljump" href="#ch22eq01">(22.1)</a>. If <i class="emphasis">v</i> is gray, then it was painted gray upon dequeuing some vertex <i class="emphasis">w</i>, which was removed from <i class="emphasis">Q</i> earlier than <i class="emphasis">u</i> and for which <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <i class="emphasis">d</i>[<i class="emphasis">w</i>] + 1. By <a class="internaljump" href="#ch22ex12">Corollary 22.4</a>, however, <i class="emphasis">d</i>[<i class="emphasis">w</i>] <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">u</i>], and so we have <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">u</i>] + 1, once again contradicting inequality <a class="internaljump" href="#ch22eq01">(22.1)</a>.</p>
<p class="last-para">Thus we conclude that <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) for all <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> . All vertices reachable from <i class="emphasis">s</i> must be discovered, for if they were not, they would have infinite <i class="emphasis">d</i> values. To conclude the proof of the theorem, observe that if <i class="emphasis"><span class="unicode">&pi;</span></i>[<i class="emphasis">v</i>] = <i class="emphasis">u</i>, then <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <i class="emphasis">d</i>[<i class="emphasis">u</i>] + 1. Thus, we can obtain a shortest path from <i class="emphasis">s</i> to <i class="emphasis">v</i> by taking a shortest path from <i class="emphasis">s</i> to <i class="emphasis"><span class="unicode">&pi;</span></i>[<i class="emphasis">v</i>] and then traversing the edge (<i class="emphasis"><span class="unicode">&pi;</span></i>[<i class="emphasis">v</i>], <i class="emphasis">v</i>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1612"></a><a name="ch22lev3sec3"></a>Breadth-first trees</h4>
<p class="first-para">The procedure BFS builds a breadth-first tree as it searches the graph, as illustrated in <a class="internaljump" href="#ch22fig03">Figure 22.3</a>. The tree is represented by the <i class="emphasis"><span class="unicode">&pi;</span></i> field in each vertex. More formally, for a graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) with source <i class="emphasis">s</i>, we define the <b class="bold"><i class="emphasis">predecessor subgraph</i></b> of <i class="emphasis">G</i> as <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> = (<i class="emphasis">V<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>, <i class="emphasis">E<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>), where</p>
<p class="para">
<i class="emphasis">V</i><sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub> = {<i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>: <i class="emphasis"><span class="unicode">&pi;</span></i>[<i class="emphasis">v</i>] <span class="unicode">&ne;</span> NIL} {<span class="unicode">&cup;</span> <i class="emphasis">s</i>}</p>
<p class="para">and</p>
<a name="1613"></a><a name="IDX-538"></a>
<p class="para">
<i class="emphasis">E</i><sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub> = {(<i class="emphasis"><span class="unicode">&pi;</span></i>[<i class="emphasis">v</i>], <i class="emphasis">v</i>) : <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i><sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub> - {<i class="emphasis">s</i>}}.</p>
<p class="para">The predecessor subgraph <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> is a <b class="bold"><i class="emphasis">breadth-first tree</i></b> if <i class="emphasis">V<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> consists of the vertices reachable from <i class="emphasis">s</i> and, for all <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> , there is a unique simple path from <i class="emphasis">s</i> to <i class="emphasis">v</i> in <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> that is also a shortest path from <i class="emphasis">s</i> to <i class="emphasis">v</i> in <i class="emphasis">G</i>. A breadth-first tree is in fact a tree, since it is connected and |<i class="emphasis">E<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>| = |<i class="emphasis">V<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>| - 1 (see <a href="DDU0251.html#3381" target="_parent" class="chapterjump">Theorem B.2</a>). The edges in <i class="emphasis">E<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> are called <b class="bold"><i class="emphasis">tree edges</i></b>.</p>
<p class="para">After BFS has been run from a source <i class="emphasis">s</i> on a graph <i class="emphasis">G</i>, the following lemma shows that the predecessor subgraph is a breadth-first tree.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 22.6</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">When applied to a directed or undirected graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>), procedure BFS constructs <i class="emphasis"><span class="unicode">&pi;</span></i> so that the predecessor subgraph <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> = (<i class="emphasis">V<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>, <i class="emphasis">E<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>) is a breadth-first tree.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Line 16 of BFS sets <i class="emphasis"><span class="unicode">&pi;</span></i>[<i class="emphasis">v</i>] = <i class="emphasis">u</i> if and only if (<i class="emphasis">u</i> <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i> and <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) <span class="unicode">&lt;</span> <span class="unicode">&infin;</span><span class="unicode">-</span> that is, if <i class="emphasis">v</i> is reachable from <i class="emphasis">s</i><span class="unicode">-</span>and thus <i class="emphasis">V<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> consists of the vertices in <i class="emphasis">V</i> reachable from <i class="emphasis">s</i>. Since <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> forms a tree, by <a href="DDU0250.html#3376" target="_parent" class="chapterjump">Theorem B.2</a>, it contains a unique path from <i class="emphasis">s</i> to each vertex in <i class="emphasis">V<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> . By applying <a class="internaljump" href="#ch22ex13">Theorem 22.5</a> inductively, we conclude that every such path is a shortest path.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">The following procedure prints out the vertices on a shortest path from <i class="emphasis">s</i> to <i class="emphasis">v</i>, assuming that BFS has already been run to compute the shortest-path tree.</p>
<div class="informalexample">
<pre class="literallayout-normal">
PRINT-PATH(<i class="emphasis">G</i>, <i class="emphasis">s</i>, <i class="emphasis">v</i>)
1  <b class="bold">if</b> <i class="emphasis">v</i> = <i class="emphasis">s</i>
2     <b class="bold">then</b> print <i class="emphasis">s</i>
3     <b class="bold">else if</b> <i class="emphasis"><span class="unicode">&pi;</span></i>[<i class="emphasis">v</i>] = NIL
4             <b class="bold">then</b> print "no path from" <i class="emphasis">s</i> "to" <i class="emphasis">v</i> "exists"
5             <b class="bold">else</b> PRINT-PATH(<i class="emphasis">G</i>, <i class="emphasis">s</i>, <i class="emphasis"><span class="unicode">&pi;</span></i>[<i class="emphasis">v]</i>)
6                  print <i class="emphasis">v</i>
</pre>
</div>
<p class="para">This procedure runs in time linear in the number of vertices in the path printed, since each recursive call is for a path one vertex shorter.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.2-1</span></span><a name="1614"></a><a name="ch22ex15"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show the <i class="emphasis">d</i> and <i class="emphasis"><span class="unicode">&pi;</span></i> values that result from running breadth-first search on the directed graph of <a href="DDU0129.html#1584" target="_parent" class="chapterjump">Figure 22.2(a)</a>, using vertex 3 as the source.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.2-2</span></span><a name="1615"></a><a name="ch22ex16"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show the <i class="emphasis">d</i> and <i class="emphasis"><span class="unicode">&pi;</span></i> values that result from running breadth-first search on the undirected graph of <a class="internaljump" href="#ch22fig03">Figure 22.3</a>, using vertex <i class="emphasis">u</i> as the source.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1616"></a><a name="IDX-539"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.2-3</span></span><a name="1617"></a><a name="ch22ex17"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">What is the running time of BFS if its input graph is represented by an adjacency matrix and the algorithm is modified to handle this form of input?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.2-4</span></span><a name="1618"></a><a name="ch22ex18"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Argue that in a breadth-first search, the value <i class="emphasis">d</i>[<i class="emphasis">u</i>] assigned to a vertex <i class="emphasis">u</i> is independent of the order in which the vertices in each adjacency list are given. Using <a class="internaljump" href="#ch22fig03">Figure 22.3</a> as an example, show that the breadth-first tree computed by BFS can depend on the ordering within adjacency lists.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.2-5</span></span><a name="1619"></a><a name="ch22ex19"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Give an example of a directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>), a source vertex <i class="emphasis">s</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> , and a set of tree edges <i class="emphasis">E<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> <span class="unicode">&sube;</span> <i class="emphasis">E</i> such that for each vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, the unique path in the graph (<i class="emphasis">V</i>, <i class="emphasis">E<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>) from <i class="emphasis">s</i> to <i class="emphasis">v</i> is a shortest path in <i class="emphasis">G</i>, yet the set of edges <i class="emphasis">E</i><sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub> cannot be produced by running BFS on <i class="emphasis">G</i>, no matter how the vertices are ordered in each adjacency list.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.2-6</span></span><a name="1620"></a><a name="ch22ex20"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">There are two types of professional wrestlers: "good guys" and "bad guys." Between any pair of professional wrestlers, there may or may not be a rivalry. Suppose we have <i class="emphasis">n</i> professional wrestlers and we have a list of <i class="emphasis">r</i> pairs of wrestlers for which there are rivalries. Give an <i class="emphasis">O</i>(<i class="emphasis">n</i> + <i class="emphasis">r</i>)-time algorithm that determines whether it is possible to designate some of the wrestlers as good guys and the remainder as bad guys such that each rivalry is between a good guy and a bad guy. If is it possible to perform such a designation, your algorithm should produce it.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.2-7: </span><span class="unicode">&#8902;</span></span><a name="1621"></a><a name="ch22ex21"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The <b class="bold"><i class="emphasis">diameter</i></b> of a tree <i class="emphasis">T</i> =(<i class="emphasis">V</i>, <i class="emphasis">E</i>) is given by</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig561_01.jpg" height="23" width="81" alt="" border="0"></span>
</div>
<p class="last-para">that is, the diameter is the largest of all shortest-path distances in the tree. Give an efficient algorithm to compute the diameter of a tree, and analyze the running time of your algorithm.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.2-8</span></span><a name="1622"></a><a name="ch22ex22"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a connected, undirected graph. Give an <i class="emphasis">O</i>(<i class="emphasis">V</i> + <i class="emphasis">E</i>)-time algorithm to compute a path in <i class="emphasis">G</i> that traverses each edge in <i class="emphasis">E</i> exactly once in each direction. Describe how you can find your way out of a maze if you are given a large supply of pennies.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
<div class="footnotes">
<div class="footnote">
<p>
<sup>[<a name="ftn.N862" href="#N862">1</a>]</sup>In <a href="DDU0139.html#1748" target="_parent" class="chapterjump">Chapters 24</a> and <a href="DDU0154.html#1876" target="_parent" class="chapterjump">25</a>, we shall generalize our study of shortest paths to weighted graphs, in which every edge has a real-valued weight and the weight of a path is the sum of the weights of its constituent edges. The graphs considered in the present chapter are unweighted or, equivalently, all edges have unit weight.</p>
</div>
</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0129.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0131.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
