<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>22.3 Depth-first search</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0130.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0132.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch22"></a>
<div class="section">
<h2 class="first-section-title">
<a name="1623"></a><a name="ch22lev1sec3"></a><span class="section-titlelabel">22.3 </span>Depth-first search</h2>
<a name="1624"></a><a name="IDX-540"></a>
<p class="para">The strategy followed by depth-first search is, as its name implies, to search "deeper" in the graph whenever possible. In depth-first search, edges are explored out of the most recently discovered vertex <i class="emphasis">v</i> that still has unexplored edges leaving it. When all of <i class="emphasis">v</i>'s edges have been explored, the search "backtracks" to explore edges leaving the vertex from which <i class="emphasis">v</i> was discovered. This process continues until we have discovered all the vertices that are reachable from the original source vertex. If any undiscovered vertices remain, then one of them is selected as a new source and the search is repeated from that source. This entire process is repeated until all vertices are discovered.</p>
<p class="para">As in breadth-first search, whenever a vertex <i class="emphasis">v</i> is discovered during a scan of the adjacency list of an already discovered vertex <i class="emphasis">u</i>, depth-first search records this event by setting <i class="emphasis">v</i>'s predecessor field <i class="emphasis"><span class="unicode">&pi;</span></i>[<i class="emphasis">v</i>] to <i class="emphasis">u</i>. Unlike breadth-first search, whose predecessor subgraph forms a tree, the predecessor subgraph produced by a depth-first search may be composed of several trees, because the search may be repeated from multiple sources.<sup>[<a name="N60" href="#ftn.N60">2</a>]</sup> The <b class="bold"><i class="emphasis">predecessor subgraph</i></b> of a depth-first search is therefore defined slightly differently from that of a breadth-first search: we let <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> = (<i class="emphasis">V</i>, <i class="emphasis">E<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>), where</p>
<p class="para">
<i class="emphasis">E<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> = {(<i class="emphasis"><span class="unicode">&pi;</span></i>[<i class="emphasis">v</i>], <i class="emphasis">v</i>) : <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> and <i class="emphasis"><span class="unicode">&pi;</span></i>[<i class="emphasis">v</i>] <span class="unicode">&ne;</span> NIL}.</p>
<p class="para">The predecessor subgraph of a depth-first search forms a <b class="bold"><i class="emphasis">depth-first forest</i></b> composed of several <b class="bold"><i class="emphasis">depth-first trees</i></b>. The edges in <i class="emphasis">E<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> are called <b class="bold"><i class="emphasis">tree edges</i></b>.</p>
<p class="para">As in breadth-first search, vertices are colored during the search to indicate their state. Each vertex is initially white, is grayed when it is <b class="bold"><i class="emphasis">discovered</i></b> in the search, and is blackened when it is <b class="bold"><i class="emphasis">finished</i></b>, that is, when its adjacency list has been examined completely. This technique guarantees that each vertex ends up in exactly one depth-first tree, so that these trees are disjoint.</p>
<p class="para">Besides creating a depth-first forest, depth-first search also <b class="bold"><i class="emphasis">timestamps</i></b> each vertex. Each vertex <i class="emphasis">v</i> has two timestamps: the first timestamp <i class="emphasis">d</i>[<i class="emphasis">v</i>] records when <i class="emphasis">v</i> is first discovered (and grayed), and the second timestamp <i class="emphasis">f</i> [<i class="emphasis">v</i>] records when the search finishes examining <i class="emphasis">v</i>'s adjacency list (and blackens <i class="emphasis">v</i>). These timestamps <a name="1625"></a><a name="IDX-541"></a>are used in many graph algorithms and are generally helpful in reasoning about the behavior of depth-first search.</p>
<p class="para">The procedure DFS below records when it discovers vertex <i class="emphasis">u</i> in the variable <i class="emphasis">d</i>[<i class="emphasis">u</i>] and when it finishes vertex <i class="emphasis">u</i> in the variable <i class="emphasis">f</i> [<i class="emphasis">u</i>]. These timestamps are integers between 1 and 2 |<i class="emphasis">V</i>|, since there is one discovery event and one finishing event for each of the |<i class="emphasis">V</i>| vertices. For every vertex <i class="emphasis">u</i>,</p>
<div class="equation">
<a name="1626"></a><a name="ch22eq02"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(22.2)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig563_01.jpg" height="16" width="82" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">Vertex <i class="emphasis">u</i> is WHITE before time <i class="emphasis">d</i>[<i class="emphasis">u</i>], GRAY between time <i class="emphasis">d</i>[<i class="emphasis">u</i>] and time <i class="emphasis">f</i> [<i class="emphasis">u</i>], and BLACK thereafter.</p>
<p class="para">The following pseudocode is the basic depth-first-search algorithm. The input graph <i class="emphasis">G</i> may be undirected or directed. The variable <i class="emphasis">time</i> is a global variable that we use for timestamping.</p>
<div class="informalexample">
<pre class="literallayout-normal">
DFS(<i class="emphasis">G</i>)
1  <b class="bold">for</b> each vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> [<i class="emphasis">G</i>]
2       <b class="bold">do</b> <i class="emphasis">color</i>[<i class="emphasis">u</i>] <span class="unicode">&larr;</span> WHITE
3          <i class="emphasis"><span class="unicode">&pi;</span></i>[<i class="emphasis">u</i>] <span class="unicode">&larr;</span> NIL
4  <i class="emphasis">time</i> <span class="unicode">&larr;</span> 0
5  <b class="bold">for</b> each vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> [<i class="emphasis">G</i>]
6       <b class="bold">do if</b> <i class="emphasis">color</i>[<i class="emphasis">u</i>] = WHITE
7             <b class="bold">then</b> DFS-VISIT(<i class="emphasis">u</i>)
</pre>
</div>
<div class="informalexample">
<pre class="literallayout-normal">
DFS-VISIT(<i class="emphasis">u</i>)
1  <i class="emphasis">color</i>[<i class="emphasis">u</i>] <span class="unicode">&larr;</span> GRAY     <span class="unicode">&#9657;</span>White vertex <i class="emphasis">u</i> has just been discovered.
2  <i class="emphasis">time</i> <span class="unicode">&larr;</span> <i class="emphasis">time</i> +1
3  <i class="emphasis">d</i>[<i class="emphasis">u</i>] <i class="emphasis">time</i>
4  <b class="bold">for</b> each <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">Adj</i>[<i class="emphasis">u</i>]  <span class="unicode">&#9657;</span>Explore edge(<i class="emphasis">u</i>, <i class="emphasis">v</i>).
5       <b class="bold">do if</b> <i class="emphasis">color</i>[<i class="emphasis">v</i>] = WHITE
6             <b class="bold">then</b> <i class="emphasis"><span class="unicode">&pi;</span></i>[<i class="emphasis">v</i>] <span class="unicode">&larr;</span> <i class="emphasis">u</i>
7                         DFS-VISIT(<i class="emphasis">v</i>)
8  <i class="emphasis">color</i>[<i class="emphasis">u</i>] BLACK      <span class="unicode">&#9657;</span> Blacken <i class="emphasis">u</i>; it is finished.
9  <i class="emphasis">f</i> [<i class="emphasis">u</i>] <span class="unicode">&#9657;</span> <i class="emphasis">time</i> <span class="unicode">&larr;</span> <i class="emphasis">time</i> +1
</pre>
</div>
<p class="para">
<a class="internaljump" href="#ch22fig04">Figure 22.4</a> illustrates the progress of DFS on the graph shown in <a href="DDU0129.html#1584" target="_parent" class="chapterjump">Figure 22.2</a>.</p>
<div class="figure">
<a name="1627"></a><a name="ch22fig04"></a><span class="figuremediaobject"><a href="images/fig564%5F01%5F0%2Ejpg" NAME="IMG_660" target="_parent"><img src="images/fig564_01.jpg" height="248" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 22.4: </span>The progress of the depth-first-search algorithm DFS on a directed graph. As edges are explored by the algorithm, they are shown as either shaded (if they are tree edges) or dashed (otherwise). Nontree edges are labeled B, C, or F according to whether they are back, cross, or forward edges. Vertices are timestamped by discovery time/finishing time.</span>
</div>
<p class="para">Procedure DFS works as follows. Lines 1<span class="unicode">-</span>3 paint all vertices white and initialize their <i class="emphasis"><span class="unicode">&pi;</span></i> fields to NIL. Line 4 resets the global time counter. Lines 5<span class="unicode">-</span>7 check each vertex in <i class="emphasis">V</i> in turn and, when a white vertex is found, visit it using DFS-VISIT. Every time DFS-VISIT(<i class="emphasis">u</i>) is called in line 7, vertex <i class="emphasis">u</i> becomes the root of a new tree in the depth-first forest. When DFS returns, every vertex <i class="emphasis">u</i> has been assigned a <b class="bold"><i class="emphasis">discovery time</i></b> <i class="emphasis">d</i>[<i class="emphasis">u</i>] and a <b class="bold"><i class="emphasis">finishing time</i></b> <i class="emphasis">f</i> [<i class="emphasis">u</i>].<a name="1628"></a><a name="IDX-542"></a>
</p>
<p class="para">In each call DFS-VISIT(<i class="emphasis">u</i>), vertex <i class="emphasis">u</i> is initially white. Line 1 paints <i class="emphasis">u</i> gray, line 2 increments the global variable <i class="emphasis">time</i>, and line 3 records the new value of <i class="emphasis">time</i> as the discovery time <i class="emphasis">d</i>[<i class="emphasis">u</i>]. Lines 4<span class="unicode">-</span>7 examine each vertex <i class="emphasis">v</i> adjacent to <i class="emphasis">u</i> and recursively visit <i class="emphasis">v</i> if it is white. As each vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">Adj</i>[<i class="emphasis">u</i>] is considered in line 4, we say that edge <i class="emphasis">(</i><i class="emphasis">u</i><i class="emphasis">, v)</i> is <b class="bold"><i class="emphasis">explored</i></b> by the depth-first search. Finally, after every edge leaving <i class="emphasis">u</i> has been explored, lines 8<span class="unicode">-</span>9 paint <i class="emphasis">u</i> black and record the finishing time in <i class="emphasis">f</i> [<i class="emphasis">u</i>].</p>
<p class="para">Note that the results of depth-first search may depend upon the order in which the vertices are examined in line 5 of DFS, and upon the order in which the neighbors of a vertex are visited in line 4 of DFS-VISIT. These different visitation orders tend not to cause problems in practice, as <i class="emphasis">any</i> depth-first search result can usually be used effectively, with essentially equivalent results.<a name="1629"></a><a name="IDX-543"></a>
</p>
<p class="para">What is the running time of DFS? The loops on lines 1<span class="unicode">-</span>3 and lines 5<span class="unicode">-</span>7 of DFS take time <span class="unicode">&Theta;</span>(<i class="emphasis">V</i>), exclusive of the time to execute the calls to DFS-VISIT. As we did for breadth-first search, we use aggregate analysis. The procedure DFS-VISIT is called exactly once for each vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> , since DFS-VISIT is invoked only on white vertices and the first thing it does is paint the vertex gray. During an execution of DFS-VISIT<i class="emphasis">(v)</i>, the loop on lines 4<span class="unicode">-</span>7 is executed |<i class="emphasis">Adj</i>[<i class="emphasis">v</i>]| times. Since</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig565_01.jpg" height="33" width="130" alt="" border="0"></span>
</div>
<p class="para">the total cost of executing lines 4<span class="unicode">-</span>7 of DFS-VISIT is <span class="unicode">&Theta;</span>(<i class="emphasis">E</i>). The running time of DFS is therefore <span class="unicode">&Theta;</span>(<i class="emphasis">V</i> + <i class="emphasis">E</i>).</p>
<div class="section">
<h4 class="sect4-title">
<a name="1630"></a><a name="ch22lev3sec4"></a>Properties of depth-first search</h4>
<p class="first-para">Depth-first search yields valuable information about the structure of a graph. Perhaps the most basic property of depth-first search is that the predecessor subgraph <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> does indeed form a forest of trees, since the structure of the depth-first trees exactly mirrors the structure of recursive calls of DFS-VISIT. That is, <i class="emphasis">u</i> = <i class="emphasis"><sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>[<i class="emphasis">v</i>] if and only if DFS-VISIT(<i class="emphasis">v</i>) was called during a search of <i class="emphasis">u</i>'s adjacency list. Additionally, vertex <i class="emphasis">v</i> is a descendant of vertex <i class="emphasis">u</i> in the depth-first forest if and only if <i class="emphasis">v</i> is discovered during the time in which <i class="emphasis">u</i> is gray.</p>
<p class="para">Another important property of depth-first search is that discovery and finishing times have <b class="bold"><i class="emphasis">parenthesis structure</i></b>. If we represent the discovery of vertex <i class="emphasis">u</i> with a left parenthesis "(<i class="emphasis">u</i>" and represent its finishing by a right parenthesis "<i class="emphasis">u</i>)", then the history of discoveries and finishings makes a well-formed expression in the sense that the parentheses are properly nested. For example, the depth-first search of <a class="internaljump" href="#ch22fig05">Figure 22.5(a)</a> corresponds to the parenthesization shown in <a class="internaljump" href="#ch22fig05">Figure 22.5(b)</a>. Another way of stating the condition of parenthesis structure is given in the following theorem.</p>
<div class="figure">
<a name="1631"></a><a name="ch22fig05"></a><span class="figuremediaobject"><a href="images/fig566%5F01%5F0%2Ejpg" NAME="IMG_662" target="_parent"><img src="images/fig566_01.jpg" height="467" width="289" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 22.5: </span>Properties of depth-first search. <i class="emphasis">(a)</i> The result of a depth-first search of a directed graph. Vertices are timestamped and edge types are indicated as in Figure 22.4. <i class="emphasis">(b)</i> Intervals for the discovery time and finishing time of each vertex correspond to the parenthesization shown. Each rectangle spans the interval given by the discovery and finishing times of the corresponding vertex. Tree edges are shown. If two intervals overlap, then one is nested within the other, and the vertex corresponding to the smaller interval is a descendant of the vertex corresponding to the larger. <i class="emphasis">(c)</i> The graph of part (a) redrawn with all tree and forward edges going down within a depth-first tree and all back edges going up from a descendant to an ancestor.</span>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 22.7: </span>(Parenthesis theorem)</span><a name="1632"></a><a name="ch22ex23"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">In any depth-first search of a (directed or undirected) graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>), for any two vertices <i class="emphasis">u</i> and <i class="emphasis">v</i>, exactly one of the following three conditions holds:</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">the intervals [<i class="emphasis">d</i>[<i class="emphasis">u</i>], <i class="emphasis">f</i>[<i class="emphasis">u</i>]] and [<i class="emphasis">d</i>[<i class="emphasis">v</i>], <i class="emphasis">f</i>[<i class="emphasis">v</i>]] are entirely disjoint, and neither <i class="emphasis">u</i> nor <i class="emphasis">v</i> is a descendant of the other in the depth-first forest,</p>
</li>
<li class="listitem">
<p class="first-para">the interval [<i class="emphasis">d</i>[<i class="emphasis">u</i>], <i class="emphasis">f</i>[<i class="emphasis">u</i>]] is contained entirely within the interval [<i class="emphasis">d</i>[<i class="emphasis">v</i>], <i class="emphasis">f</i>[<i class="emphasis">v</i>]], and <i class="emphasis">u</i> is a descendant of <i class="emphasis">v</i> in a depth-first tree, or</p>
</li>
<li class="listitem">
<p class="first-para">the interval [<i class="emphasis">d</i>[<i class="emphasis">v</i>], <i class="emphasis">f</i>[<i class="emphasis">v</i>]] is contained entirely within the interval [<i class="emphasis">d</i>[<i class="emphasis">u</i>], <i class="emphasis">f</i>[<i class="emphasis">u</i>]], and <i class="emphasis">v</i> is a descendant of <i class="emphasis">u</i> in a depth-first tree.</p>
</li>
</ul>
<a name="1633"></a><a name="IDX-544"></a><a name="1634"></a><a name="IDX-545"></a>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> We begin with the case in which <i class="emphasis">d</i>[<i class="emphasis">u</i>] <span class="unicode">&lt;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i>]. There are two subcases to consider, according to whether <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&lt;</span> <i class="emphasis">f</i>[<i class="emphasis">u</i>] or not. The first subcase occurs when <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&lt;</span> <i class="emphasis">f</i>[<i class="emphasis">u</i>], so <i class="emphasis">v</i> was discovered while <i class="emphasis">u</i> was still gray. This implies that <i class="emphasis">v</i> is a descendant of <i class="emphasis">u</i>. Moreover, since <i class="emphasis">v</i> was discovered more recently than <i class="emphasis">u</i>, all of its outgoing edges are explored, and <i class="emphasis">v</i> is finished, before the search returns to and finishes <i class="emphasis">u</i>. In this case, therefore, the interval [<i class="emphasis">d</i>[<i class="emphasis">v</i>], <i class="emphasis">f</i>[<i class="emphasis">v</i>]] is entirely contained within the interval [<i class="emphasis">d</i>[<i class="emphasis">u</i>], <i class="emphasis">f</i>[<i class="emphasis">u</i>]]. In the other subcase, <i class="emphasis">f</i>[<i class="emphasis">u</i>] <span class="unicode">&lt;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i>], and inequality <a class="internaljump" href="#ch22eq02">(22.2)</a> implies that the intervals [<i class="emphasis">d</i>[<i class="emphasis">u</i>], <i class="emphasis">f</i>[<i class="emphasis">u</i>]] and [<i class="emphasis">d</i>[<i class="emphasis">v</i>], <i class="emphasis">f</i>[<i class="emphasis">v</i>]] are disjoint. Because the intervals are disjoint, neither vertex was discovered while the other was gray, and so neither vertex is a descendant of the other.</p>
<p class="last-para">The case in which <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&lt;</span> <i class="emphasis">d</i>[<i class="emphasis">u</i>] is similar, with the roles of <i class="emphasis">u</i> and <i class="emphasis">v</i> reversed in the above argument.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Corollary 22.8: </span>(Nesting of Descendants' Intervals)</span><a name="1635"></a><a name="ch22ex24"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Vertex <i class="emphasis">v</i> is a proper descendant of vertex <i class="emphasis">u</i> in the depth-first forest for a (directed or undirected) graph <i class="emphasis">G</i> if and only if <i class="emphasis">d</i>[<i class="emphasis">u</i>] <span class="unicode">&lt;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&lt;</span> <i class="emphasis">f</i>[<i class="emphasis">v</i>] <span class="unicode">&lt;</span> <i class="emphasis">f</i>[<i class="emphasis">u</i>].</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Immediate from <a class="internaljump" href="#ch22ex23">Theorem 22.7</a>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">The next theorem gives another important characterization of when one vertex is a descendant of another in the depth-first forest.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 22.9: </span>(White-path theorem)</span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">In a depth-first forest of a (directed or undirected) graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>), vertex <i class="emphasis">v</i> is a descendant of vertex <i class="emphasis">u</i> if and only if at the time <i class="emphasis">d</i>[<i class="emphasis">u</i>] that the search discovers <i class="emphasis">u</i>, vertex <i class="emphasis">v</i> can be reached from <i class="emphasis">u</i> along a path consisting entirely of white vertices.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> <span class="unicode">&rArr;</span>: Assume that <i class="emphasis">v</i> is a descendant of <i class="emphasis">u</i>. Let <i class="emphasis">w</i> be any vertex on the path between <i class="emphasis">u</i> and <i class="emphasis">v</i> in the depth-first tree, so that <i class="emphasis">w</i> is a descendant of <i class="emphasis">u</i>. By <a class="internaljump" href="#ch22ex24">Corollary 22.8</a>, <i class="emphasis">d</i>[<i class="emphasis">u</i>] <span class="unicode">&lt;</span> <i class="emphasis">d</i>[<i class="emphasis">w</i>], and so <i class="emphasis">w</i> is white at time <i class="emphasis">d</i>[<i class="emphasis">u</i>].</p>
<p class="last-para">
<span class="unicode">&lArr;</span>: Suppose that vertex <i class="emphasis">v</i> is reachable from <i class="emphasis">u</i> along a path of white vertices at time <i class="emphasis">d</i>[<i class="emphasis">u</i>], but <i class="emphasis">v</i> does not become a descendant of <i class="emphasis">u</i> in the depth-first tree. Without loss of generality, assume that every other vertex along the path becomes a descendant of <i class="emphasis">u</i>. (Otherwise, let <i class="emphasis">v</i> be the closest vertex to <i class="emphasis">u</i> along the path that doesn't become a descendant of <i class="emphasis">u</i>.) Let <i class="emphasis">w</i> be the predecessor of <i class="emphasis">v</i> in the path, so that <i class="emphasis">w</i> is a descendant of <i class="emphasis">u</i> (<i class="emphasis">w</i> and <i class="emphasis">u</i> may in fact be the same vertex) and, by <a class="internaljump" href="#ch22ex24">Corollary 22.8</a>, <i class="emphasis">f</i>[<i class="emphasis">w</i>] <span class="unicode">&le;</span> <i class="emphasis">f</i>[<i class="emphasis">u</i>]. Note that <i class="emphasis">v</i> must be discovered after <i class="emphasis">u</i> is discovered, but before <i class="emphasis">w</i> is finished. Therefore, <i class="emphasis">d</i>[<i class="emphasis">u</i>] <span class="unicode">&lt;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&lt;</span> <i class="emphasis">f</i>[<i class="emphasis">w</i>] <span class="unicode">&le;</span> <i class="emphasis">f</i>[<i class="emphasis">u</i>]. <a class="internaljump" href="#ch22ex23">Theorem 22.7</a> then implies that the interval [<i class="emphasis">d</i>[<i class="emphasis">v</i>], <i class="emphasis">f</i>[<i class="emphasis">v</i>]] is contained entirely within the interval [<i class="emphasis">d</i>[<i class="emphasis">u</i>], <i class="emphasis">f</i>[<i class="emphasis">u</i>]]. By <a class="internaljump" href="#ch22ex24">Corollary 22.8</a>, <i class="emphasis">v</i> must after all be a descendant of <i class="emphasis">u</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1636"></a><a name="IDX-546"></a>

</div>
<div class="section">
<h3 class="sect3-title">
<a name="1637"></a><a name="ch22lev3sec5"></a>Classification of edges</h3>
<p class="first-para">Another interesting property of depth-first search is that the search can be used to classify the edges of the input graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>). This edge classification can be used to glean important information about a graph. For example, in the <a href="DDU0132.html#1654" target="_parent" class="chapterjump">next section</a>, we shall see that a directed graph is acyclic if and only if a depth-first search yields no "back" edges (<a href="DDU0132.html#1657" target="_parent" class="chapterjump">Lemma 22.11</a>).</p>
<p class="para">We can define four edge types in terms of the depth-first forest <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> produced by a depth-first search on <i class="emphasis">G</i>.</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="first-para">
<b class="bold"><i class="emphasis">Tree edges</i></b> are edges in the depth-first forest <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>. Edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is a tree edge if <i class="emphasis">v</i> was first discovered by exploring edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>).</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold"><i class="emphasis">Back edges</i></b> are those edges (<i class="emphasis">u</i>, <i class="emphasis">v</i>) connecting a vertex <i class="emphasis">u</i> to an ancestor <i class="emphasis">v</i> in a depth-first tree. Self-loops, which may occur in directed graphs, are considered to be back edges.</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold"><i class="emphasis">Forward edges</i></b> are those nontree edges (<i class="emphasis">u</i>, <i class="emphasis">v</i>) connecting a vertex <i class="emphasis">u</i> to a descendant <i class="emphasis">v</i> in a depth-first tree.</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold"><i class="emphasis">Cross edges</i></b> are all other edges. They can go between vertices in the same depth-first tree, as long as one vertex is not an ancestor of the other, or they can go between vertices in different depth-first trees.</p>
</li>
</ol>
<p class="para">In <a class="internaljump" href="#ch22fig04">Figures 22.4</a> and <a class="internaljump" href="#ch22fig05">22.5</a>, edges are labeled to indicate their type. <a class="internaljump" href="#ch22fig05">Figure 22.5(c)</a> also shows how the graph of <a class="internaljump" href="#ch22fig05">Figure 22.5(a)</a> can be redrawn so that all tree and forward edges head downward in a depth-first tree and all back edges go up. Any graph can be redrawn in this fashion.</p>
<p class="para">The DFS algorithm can be modified to classify edges as it encounters them. The key idea is that each edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) can be classified by the color of the vertex <i class="emphasis">v</i> that is reached when the edge is first explored (except that forward and cross edges are not distinguished):</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="first-para">WHITE indicates a tree edge,</p>
</li>
<li class="listitem">
<p class="first-para">GRAY indicates a back edge, and</p>
</li>
<li class="listitem">
<p class="first-para">BLACK indicates a forward or cross edge.</p>
</li>
</ol>
<p class="para">The first case is immediate from the specification of the algorithm. For the second case, observe that the gray vertices always form a linear chain of descendants corresponding to the stack of active DFS-VISIT invocations; the number of gray vertices is one more than the depth in the depth-first forest of the vertex most recently discovered. Exploration always proceeds from the deepest gray vertex, so an edge that reaches another gray vertex reaches an ancestor. The third case handles the remaining possibility; it can be shown that such an edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is a forward edge if <i class="emphasis">d</i>[<i class="emphasis">u</i>] <span class="unicode">&lt;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i>] and a cross edge if <i class="emphasis">d</i>[<i class="emphasis">u</i>] <span class="unicode">&gt;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i>]. (See <a class="internaljump" href="#ch22ex30">Exercise 22.3-4</a>.)<a name="1638"></a><a name="IDX-547"></a>
</p>
<p class="para">In an undirected graph, there may be some ambiguity in the type classification, since (<i class="emphasis">u</i>, <i class="emphasis">v</i>) and (<i class="emphasis">v</i>, <i class="emphasis">u</i>) are really the same edge. In such a case, the edge is classified as the <i class="emphasis">first</i> type in the classification list that applies. Equivalently (see <a class="internaljump" href="#ch22ex31">Exercise 22.3-5</a>), the edge is classified according to whichever of (<i class="emphasis">u</i>, <i class="emphasis">v</i>) or (<i class="emphasis">v</i>, <i class="emphasis">u</i>) is encountered first during the execution of the algorithm.</p>
<p class="para">We now show that forward and cross edges never occur in a depth-first search of an undirected graph.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 22.10</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">In a depth-first search of an undirected graph <i class="emphasis">G</i>, every edge of <i class="emphasis">G</i> is either a tree edge or a back edge.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Let (<i class="emphasis">u</i>, <i class="emphasis">v</i>) be an arbitrary edge of <i class="emphasis">G</i>, and suppose without loss of generality that <i class="emphasis">d</i>[<i class="emphasis">u</i>] <span class="unicode">&lt;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i>]. Then, <i class="emphasis">v</i> must be discovered and finished before we finish <i class="emphasis">u</i> (while <i class="emphasis">u</i> is gray), since <i class="emphasis">v</i> is on <i class="emphasis">u</i>'s adjacency list. If the edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is explored first in the direction from <i class="emphasis">u</i> to <i class="emphasis">v</i>, then <i class="emphasis">v</i> is undiscovered (white) until that time, for otherwise we would have explored this edge already in the direction from <i class="emphasis">v</i> to <i class="emphasis">u</i>. Thus, (<i class="emphasis">u</i>, <i class="emphasis">v</i>) becomes a tree edge. If (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is explored first in the direction from <i class="emphasis">v</i> to <i class="emphasis">u</i>, then (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is a back edge, since <i class="emphasis">u</i> is still gray at the time the edge is first explored.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">We shall see several applications of these theorems in the following sections.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.3-1</span></span><a name="1639"></a><a name="ch22ex27"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Make a 3-by-3 chart with row and column labels WHITE, GRAY, and BLACK. In each cell (<i class="emphasis">i</i>, <i class="emphasis">j</i>), indicate whether, at any point during a depth-first search of a directed graph, there can be an edge from a vertex of color <i class="emphasis">i</i> to a vertex of color <i class="emphasis">j</i>. For each possible edge, indicate what edge types it can be. Make a second such chart for depth-first search of an undirected graph.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.3-2</span></span><a name="1640"></a><a name="ch22ex28"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show how depth-first search works on the graph of <a class="internaljump" href="#ch22fig06">Figure 22.6</a>. Assume that the <b class="bold">for</b> loop of lines 5<span class="unicode">-</span>7 of the DFS procedure considers the vertices in alphabetical order, and assume that each adjacency list is ordered alphabetically. Show the discovery and finishing times for each vertex, and show the classification of each edge.</p>
<p class="last-para">
<div class="figure">
<a name="1641"></a><a name="ch22fig06"></a><span class="figuremediaobject"><a href="images/fig570%5F01%5F0%2Ejpg" NAME="IMG_663" target="_parent"><img src="images/fig570_01.jpg" height="116" width="310" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 22.6: </span>A directed graph for use in Exercises 22.3-2 and 22.5-2.</span>
</div>
</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.3-3</span></span><a name="1642"></a><a name="ch22ex29"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show the parenthesis structure of the depth-first search shown in <a class="internaljump" href="#ch22fig04">Figure 22.4</a>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1643"></a><a name="IDX-548"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.3-4</span></span><a name="1644"></a><a name="ch22ex30"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="first-para">a tree edge or forward edge if and only if <i class="emphasis">d</i>[<i class="emphasis">u</i>] <span class="unicode">&lt;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&lt;</span> <i class="emphasis">f</i>[<i class="emphasis">v</i>] <span class="unicode">&lt;</span> <i class="emphasis">f</i>[<i class="emphasis">u</i>],</p>
</li>
<li class="listitem">
<p class="first-para">a back edge if and only if <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&lt;</span> <i class="emphasis">d</i>[<i class="emphasis">u</i>] <span class="unicode">&lt;</span> <i class="emphasis">f</i>[<i class="emphasis">u</i>] <span class="unicode">&lt;</span> <i class="emphasis">f</i>[<i class="emphasis">v</i>], and</p>
</li>
<li class="listitem">
<p class="first-para">a cross edge if and only if <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&lt;</span> <i class="emphasis">f</i>[<i class="emphasis">v</i>] <span class="unicode">&lt;</span> <i class="emphasis">d</i>[<i class="emphasis">u</i>] <span class="unicode">&lt;</span> <i class="emphasis">f</i>[<i class="emphasis">u</i>].</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.3-5</span></span><a name="1645"></a><a name="ch22ex31"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that in an undirected graph, classifying an edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) as a tree edge or a back edge according to whether (<i class="emphasis">u</i>, <i class="emphasis">v</i>) or (<i class="emphasis">v</i>, <i class="emphasis">u</i>) is encountered first during the depth-first search is equivalent to classifying it according to the priority of types in the classification scheme.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.3-6</span></span><a name="1646"></a><a name="ch22ex32"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Rewrite the procedure DFS, using a stack to eliminate recursion.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.3-7</span></span><a name="1647"></a><a name="ch22ex33"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Give a counterexample to the conjecture that if there is a path from <i class="emphasis">u</i> to <i class="emphasis">v</i> in a directed graph <i class="emphasis">G</i>, and if <i class="emphasis">d</i>[<i class="emphasis">u</i>] <span class="unicode">&lt;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i>] in a depth-first search of <i class="emphasis">G</i>, then <i class="emphasis">v</i> is a descendant of <i class="emphasis">u</i> in the depth-first forest produced.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.3-8</span></span><a name="1648"></a><a name="ch22ex34"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Give a counterexample to the conjecture that if there is a path from <i class="emphasis">u</i> to <i class="emphasis">v</i> in a directed graph <i class="emphasis">G</i>, then any depth-first search must result in <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&le;</span> <i class="emphasis">f</i>[<i class="emphasis">u</i>].</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.3-9</span></span><a name="1649"></a><a name="ch22ex35"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Modify the pseudocode for depth-first search so that it prints out every edge in the directed graph <i class="emphasis">G</i>, together with its type. Show what modifications, if any, must be made if <i class="emphasis">G</i> is undirected.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1650"></a><a name="IDX-549"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.3-10</span></span><a name="1651"></a><a name="ch22ex36"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Explain how a vertex <i class="emphasis">u</i> of a directed graph can end up in a depth-first tree containing only <i class="emphasis">u</i>, even though <i class="emphasis">u</i> has both incoming and outgoing edges in <i class="emphasis">G</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.3-11</span></span><a name="1652"></a><a name="ch22ex37"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that a depth-first search of an undirected graph <i class="emphasis">G</i> can be used to identify the connected components of <i class="emphasis">G</i>, and that the depth-first forest contains as many trees as <i class="emphasis">G</i> has connected components. More precisely, show how to modify depth-first search so that each vertex <i class="emphasis">v</i> is assigned an integer label <i class="emphasis">cc</i>[<i class="emphasis">v</i>] between 1 and <i class="emphasis">k</i>, where <i class="emphasis">k</i> is the number of connected components of <i class="emphasis">G</i>, such that <i class="emphasis">cc</i>[<i class="emphasis">u</i>] = <i class="emphasis">cc</i>[<i class="emphasis">v</i>] if and only if <i class="emphasis">u</i> and <i class="emphasis">v</i> are in the same connected component.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.3-12: </span><span class="unicode">&#8902;</span></span><a name="1653"></a><a name="ch22ex38"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">A directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) is <b class="bold"><i class="emphasis">singly connected</i></b> if <span class="inlinemediaobject"><img src="images/fig571_01.jpg" height="12" width="45" alt="" border="0"></span> implies that there is at most one simple path from <i class="emphasis">u</i> to <i class="emphasis">v</i> for all vertices <i class="emphasis">u</i>, <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>. Give an efficient algorithm to determine whether or not a directed graph is singly connected.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
<div class="footnotes">
<div class="footnote">
<p>
<sup>[<a name="ftn.N60" href="#N60">2</a>]</sup>It may seem arbitrary that breadth-first search is limited to only one source whereas depth-first search may search from multiple sources. Although conceptually, breadth-first search could proceed from multiple sources and depth-first search could be limited to one source, our approach reflects how the results of these searches are typically used. Breadth-first search is usually employed to find shortest-path distances (and the associated predecessor subgraph) from a given source. Depth-first search is often a subroutine in another algorithm, as we shall see later in this chapter.</p>
</div>
</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0130.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0132.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
