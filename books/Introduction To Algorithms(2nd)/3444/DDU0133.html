<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>22.5 Strongly connected components</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0132.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0134.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch22"></a>
<div class="section">
<h2 class="first-section-title">
<a name="1666"></a><a name="ch22lev1sec5"></a><span class="section-titlelabel">22.5 </span>Strongly connected components</h2>
<p class="first-para">We now consider a classic application of depth-first search: decomposing a directed graph into its strongly connected components. This section shows how to do this decomposition using two depth-first searches. Many algorithms that work with directed graphs begin with such a decomposition. After decomposition, the algorithm is run separately on each strongly connected component. The solutions are then combined according to the structure of connections between components.</p>
<p class="para">Recall from <a href="DDU0247.html#3329" target="_parent" class="chapterjump">Appendix B</a> that a strongly connected component of a directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) is a maximal set of vertices <i class="emphasis">C</i> <span class="unicode">&sube;</span> <i class="emphasis">V</i> such that for every pair of vertices <i class="emphasis">u</i> and <i class="emphasis">v</i> in <i class="emphasis">C</i>, we have both <span class="inlinemediaobject"><img src="images/fig574_01.jpg" height="11" width="45" alt="" border="0"></span> and <span class="inlinemediaobject"><img src="images/fig574_02.jpg" height="12" width="45" alt="" border="0"></span>; that is, vertices <i class="emphasis">u</i> and <i class="emphasis">v</i> are reachable from each other. <a class="internaljump" href="#ch22fig09">Figure 22.9</a> shows an example.</p>
<div class="figure">
<a name="1667"></a><a name="ch22fig09"></a><span class="figuremediaobject"><a href="images/fig575%5F01%5F0%2Ejpg" NAME="IMG_669" target="_parent"><img src="images/fig575_01.jpg" height="307" width="284" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 22.9: </span><i class="emphasis">(a)</i> A directed graph <i class="emphasis">G</i>. The strongly connected components of <i class="emphasis">G</i> are shown as shaded regions. Each vertex is labeled with its discovery and finishing times. Tree edges are shaded. <i class="emphasis">(b)</i> The graph <i class="emphasis">G</i><sup>T</sup>, the transpose of <i class="emphasis">G</i>. The depth-first forest computed in line 3 of STRONGLY-CONNECTED-COMPONENTS is shown, with tree edges shaded. Each strongly connected component corresponds to one depth-first tree. Vertices <i class="emphasis">b, c, g</i>, and <i class="emphasis">h</i>, which are heavily shaded, are the roots of the depth-first trees produced by the depth-first search of <i class="emphasis">G</i><sup>T</sup>. <i class="emphasis">(c)</i> The acyclic component graph <i class="emphasis">G</i><sup>SCC</sup> obtained by contracting all edges within each strongly connected component of <i class="emphasis">G</i> so that only a single vertex remains in each component.</span>
</div>
<p class="para">Our algorithm for finding strongly connected components of a graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) uses the transpose of <i class="emphasis">G</i>, which is defined in <a href="DDU0129.html#1589" target="_parent" class="chapterjump">Exercise 22.1-3</a> to be the graph <i class="emphasis">G</i><sup>T</sup> = (<i class="emphasis">V</i>, <i class="emphasis">E</i><sup>T</sup>), where <i class="emphasis">E</i><sup>T</sup> = {(<i class="emphasis">u</i>, <i class="emphasis">v</i>) : (<i class="emphasis">v</i>, <i class="emphasis">u</i>) <i class="emphasis">E</i>}. That is, <i class="emphasis">E</i><sup>T</sup> consists of the edges of <i class="emphasis">G</i> with their directions reversed. Given an adjacency-list representation of <i class="emphasis">G</i>, the time to create <i class="emphasis">G</i><sup>T</sup> is <i class="emphasis">O</i>(<i class="emphasis">V</i> + <i class="emphasis">E</i>). It is interesting to observe that <i class="emphasis">G</i> and <i class="emphasis">G</i><sup>T</sup> have <a name="1668"></a><a name="IDX-553"></a> exactly the same strongly connected components: <i class="emphasis">u</i> and <i class="emphasis">v</i> are reachable from each other in <i class="emphasis">G</i> if and only if they are reachable from each other in <i class="emphasis">G</i><sup>T</sup>. <a class="internaljump" href="#ch22fig09">Figure 22.9(b)</a> shows the transpose of the graph in <a class="internaljump" href="#ch22fig09">Figure 22.9(a)</a>, with the strongly connected components shaded.</p>
<p class="para">The following linear-time (i.e., <span class="unicode">&Theta;</span>(<i class="emphasis">V</i> + <i class="emphasis">E</i>)-time) algorithm computes the strongly connected components of a directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) using two depth-first searches, one on <i class="emphasis">G</i> and one on <i class="emphasis">G</i><sup>T</sup>.<a name="1669"></a><a name="IDX-554"></a>
</p>
<div class="informalexample">
<pre class="literallayout-normal">
STRONGLY-CONNECTED-COMPONENTS (<i class="emphasis">G</i>)
1  call DFS (<i class="emphasis">G</i>) to compute finishing times <i class="emphasis">f</i>[<i class="emphasis">u</i>] for each vertex <i class="emphasis">u</i>
2  compute <i class="emphasis">G</i><sup>T</sup>
3  call DFS (<i class="emphasis">G</i><sup>T</sup>), but in the main loop of DFS, consider the vertices
          in order of decreasing <i class="emphasis">f</i>[<i class="emphasis">u</i>] (as computed in line 1)
4  output the vertices of each tree in the depth-first forest formed in line 3 as a
          separate strongly connected component
</pre>
</div>
<p class="para">The idea behind this algorithm comes from a key property of the <b class="bold"><i class="emphasis">component graph</i></b> <i class="emphasis">G</i><sup>SCC</sup> = (<i class="emphasis">V</i><sup>SCC</sup>, <i class="emphasis">E</i><sup>SCC</sup>), which we define as follows. Suppose that <i class="emphasis">G</i> has strongly connected components <i class="emphasis">C</i><sub>1</sub>, <i class="emphasis">C</i><sub>2</sub>,..., <i class="emphasis">C<sub>k</sub></i>. The vertex set <i class="emphasis">V</i><sup>SCC</sup> is {<i class="emphasis">v</i><sub>1</sub>, <i class="emphasis">v</i><sub>2</sub>,..., <i class="emphasis">v<sub>k</sub></i>}, and it contains a vertex <i class="emphasis">v<sub>i</sub></i> for each strongly connected component <i class="emphasis">C<sub>i</sub></i> of <i class="emphasis">G</i>. There is an edge (<i class="emphasis">v<sub>i</sub></i>, <i class="emphasis">v<sub>j</sub></i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i><sup>SCC</sup> if <i class="emphasis">G</i> contains a directed edge (<i class="emphasis">x</i>, <i class="emphasis">y</i>) for some <i class="emphasis">x</i> <span class="unicode">&isin;</span> <i class="emphasis">C<sub>i</sub></i> and some <i class="emphasis">y</i> <span class="unicode">&isin;</span> <i class="emphasis">C<sub>j</sub></i>. Looked at another way, by contracting all edges whose incident vertices are within the same strongly connected component of <i class="emphasis">G</i>, the resulting graph is <i class="emphasis">G</i><sup>SCC</sup>. <a class="internaljump" href="#ch22fig09">Figure 22.9(c)</a> shows the component graph of the graph in <a class="internaljump" href="#ch22fig09">Figure 22.9(a)</a>.</p>
<p class="para">The key property is that the component graph is a dag, which the following lemma implies.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 22.13</span></span><a name="1670"></a><a name="ch22ex46"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">C</i> and <i class="emphasis">C</i><span class="unicode">&prime;</span> be distinct strongly connected components in directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>), let <i class="emphasis">u</i>, <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">C</i>, let <i class="emphasis">u</i><span class="unicode">&prime;</span>, <i class="emphasis">v</i><span class="unicode">&prime;</span> <span class="unicode">&isin;</span> <i class="emphasis">C</i><span class="unicode">&prime;</span>, and suppose that there is a path <span class="inlinemediaobject"><img src="images/fig576_01.jpg" height="16" width="50" alt="" border="0"></span> in <i class="emphasis">G</i>. Then there cannot also be a path <span class="inlinemediaobject"><img src="images/fig576_02.jpg" height="17" width="50" alt="" border="0"></span> in <i class="emphasis">G</i>.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> If there is a path <span class="inlinemediaobject"><img src="images/fig576_03.jpg" height="17" width="55" alt="" border="0"></span> in <i class="emphasis">G</i>, then there are paths <span class="inlinemediaobject"><img src="images/fig576_04.jpg" height="14" width="85" alt="" border="0"></span> and <span class="inlinemediaobject"><img src="images/fig576_05.jpg" height="18" width="83" alt="" border="0"></span> in <i class="emphasis">G</i>. Thus, <i class="emphasis">u</i> and <i class="emphasis">v</i><span class="unicode">&prime;</span> are reachable from each other, thereby contradicting the assumption that <i class="emphasis">C</i> and <i class="emphasis">C</i><span class="unicode">&prime;</span> are distinct strongly connected components.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">We shall see that by considering vertices in the second depth-first search in decreasing order of the finishing times that were computed in the first depth-first search, we are, in essence, visiting the vertices of the component graph (each of which corresponds to a strongly connected component of <i class="emphasis">G</i>) in topologically sorted order.</p>
<p class="para">Because STRONGLY-CONNECTED-COMPONENTS performs two depth-first searches, there is the potential for ambiguity when we discuss <i class="emphasis">d</i>[<i class="emphasis">u</i>] or <i class="emphasis">f</i>[<i class="emphasis">u</i>]. In this section, these values always refer to the discovery and finishing times as computed by the first call of DFS, in line 1.</p>
<p class="para">We extend the notation for discovery and finishing times to sets of vertices. If <i class="emphasis">U</i> <span class="unicode">&sube;</span> <i class="emphasis">V</i> , then we define <i class="emphasis">d</i>(<i class="emphasis">U</i>) = min<sub><i class="emphasis">u <span class="unicode">&isin;</span> U</i></sub> {<i class="emphasis">d</i>[<i class="emphasis">u</i>]} and <i class="emphasis">f</i>(<i class="emphasis">U</i>) = max<sub><i class="emphasis">u <span class="unicode">&isin;</span> U</i></sub> {<i class="emphasis">f</i>[<i class="emphasis">u</i>]}. That is, <i class="emphasis">d</i>(<i class="emphasis">U</i>) and <i class="emphasis">f</i>(<i class="emphasis">U</i>) are the earliest discovery time and latest finishing time, respectively, of any vertex in <i class="emphasis">U</i>.<a name="1671"></a><a name="IDX-555"></a>
</p>
<p class="para">The following lemma and its corollary give a key property relating strongly connected components and finishing times in the first depth-first search.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 22.14</span></span><a name="1672"></a><a name="ch22ex47"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">C</i> and <i class="emphasis">C</i><span class="unicode">&prime;</span> be distinct strongly connected components in directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>). Suppose that there is an edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <i class="emphasis">E</i>, where <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">C</i> and <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">C</i><span class="unicode">&prime;</span>. Then <i class="emphasis">f</i> (<i class="emphasis">C</i>) <span class="unicode">&gt;</span> <i class="emphasis">f</i>(<i class="emphasis">C</i><span class="unicode">&prime;</span>).</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> There are two cases, depending on which strongly connected component, <i class="emphasis">C</i> or <i class="emphasis">C</i><span class="unicode">&prime;</span>, had the first discovered vertex during the depth-first search.</p>
<p class="para">If <i class="emphasis">d</i>(<i class="emphasis">C</i>) <span class="unicode">&lt;</span> <i class="emphasis">d</i>(<i class="emphasis">C</i><span class="unicode">&prime;</span>), let <i class="emphasis">x</i> be the first vertex discovered in <i class="emphasis">C</i>. At time <i class="emphasis">d</i>[<i class="emphasis">x</i>], all vertices in <i class="emphasis">C</i> and <i class="emphasis">C</i><span class="unicode">&prime;</span> are white. There is a path in <i class="emphasis">G</i> from <i class="emphasis">x</i> to each vertex in <i class="emphasis">C</i> consisting only of white vertices. Because (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>, for any vertex <i class="emphasis">w</i> <span class="unicode">&isin;</span> <i class="emphasis">C</i><span class="unicode">&prime;</span>, there is also a path at time <i class="emphasis">d</i>[<i class="emphasis">x</i>] from <i class="emphasis">x</i> to <i class="emphasis">w</i> in <i class="emphasis">G</i> consisting only of white vertices: <span class="inlinemediaobject"><img src="images/fig577_01.jpg" height="8" width="95" alt="" border="0"></span>. By the white-path theorem, all vertices in <i class="emphasis">C</i> and <i class="emphasis">C</i><span class="unicode">&prime;</span> become descendants of <i class="emphasis">x</i> in the depth-first tree. By <a href="DDU0131.html#1635" target="_parent" class="chapterjump">Corollary 22.8</a>, <i class="emphasis">f</i>[<i class="emphasis">x</i>] = <i class="emphasis">f</i>(<i class="emphasis">C</i>) <span class="unicode">&gt;</span> <i class="emphasis">f</i>(<i class="emphasis">C</i><span class="unicode">&prime;</span>).</p>
<p class="last-para">If instead we have <i class="emphasis">d</i>(<i class="emphasis">C</i>) <span class="unicode">&gt;</span> <i class="emphasis">d</i>(<i class="emphasis">C</i><span class="unicode">&prime;</span>), let <i class="emphasis">y</i> be the first vertex discovered in <i class="emphasis">C</i><span class="unicode">&prime;</span>. At time <i class="emphasis">d</i>[<i class="emphasis">y</i>], all vertices in <i class="emphasis">C</i><span class="unicode">&prime;</span> are white and there is a path in <i class="emphasis">G</i> from <i class="emphasis">y</i> to each vertex in <i class="emphasis">C</i><span class="unicode">&prime;</span> consisting only of white vertices. By the white-path theorem, all vertices in <i class="emphasis">C</i><span class="unicode">&prime;</span> become descendants of <i class="emphasis">y</i> in the depth-first tree, and by <a href="DDU0131.html#1635" target="_parent" class="chapterjump">Corollary 22.8</a>, <i class="emphasis">f</i>[<i class="emphasis">y</i>] = <i class="emphasis">f</i>(<i class="emphasis">C</i><span class="unicode">&prime;</span>). At time <i class="emphasis">d</i>[<i class="emphasis">y</i>], all vertices in <i class="emphasis">C</i> are white. Since there is an edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) from <i class="emphasis">C</i> to <i class="emphasis">C</i><span class="unicode">&prime;</span>, <a class="internaljump" href="#ch22ex46">Lemma 22.13</a> implies that there cannot be a path from <i class="emphasis">C</i><span class="unicode">&prime;</span> to <i class="emphasis">C</i>. Hence, no vertex in <i class="emphasis">C</i> is reachable from <i class="emphasis">y</i>. At time <i class="emphasis">f</i>[<i class="emphasis">y</i>], therefore, all vertices in <i class="emphasis">C</i> are still white. Thus, for any vertex <i class="emphasis">w</i> <span class="unicode">&isin;</span> <i class="emphasis">C</i>, we have <i class="emphasis">f</i>[<i class="emphasis">w</i>] <span class="unicode">&gt;</span> <i class="emphasis">f</i>[<i class="emphasis">y</i>], which implies that <i class="emphasis">f</i>(<i class="emphasis">C</i>) <span class="unicode">&gt;</span> <i class="emphasis">f</i>(<i class="emphasis">C</i><span class="unicode">&prime;</span>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">The following corollary tells us that each edge in <i class="emphasis">G</i><sup>T</sup> that goes between different strongly connected components goes from a component with an earlier finishing time (in the first depth-first search) to a component with a later finishing time.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Corollary 22.15</span></span><a name="1673"></a><a name="ch22ex48"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">C</i> and <i class="emphasis">C</i><span class="unicode">&prime;</span> be distinct strongly connected components in directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>). Suppose that there is an edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i><sup>T</sup>, where <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">C</i> and <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">C</i><span class="unicode">&prime;</span>. Then <i class="emphasis">f</i>(<i class="emphasis">C</i>) <span class="unicode">&lt;</span> <i class="emphasis">f</i>(<i class="emphasis">C</i><span class="unicode">&prime;</span>).</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Since (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i><sup>T</sup>, we have (<i class="emphasis">v</i>, <i class="emphasis">u</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>. Since the strongly connected components of <i class="emphasis">G</i> and <i class="emphasis">G</i><sup>T</sup> are the same, <a class="internaljump" href="#ch22ex47">Lemma 22.14</a> implies that <i class="emphasis">f</i>(<i class="emphasis">C</i>) <span class="unicode">&lt;</span> <i class="emphasis">f</i>(<i class="emphasis">C</i><span class="unicode">&prime;</span>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">
<a class="internaljump" href="#ch22ex48">Corollary 22.15</a> provides the key to understanding why the STRONGLY-CONNECTED-COMPONENTS procedure works. Let us examine what happens when we perform the second depth-first search, which is on <i class="emphasis">G</i><sup>T</sup>. We start with the strongly connected component <i class="emphasis">C</i> whose finishing time <i class="emphasis">f</i>(<i class="emphasis">C</i>) is maximum. The <a name="1674"></a><a name="IDX-556"></a>search starts from some vertex <i class="emphasis">x</i> <span class="unicode">&isin;</span> <i class="emphasis">C</i>, and it visits all vertices in <i class="emphasis">C</i>. By <a class="internaljump" href="#ch22ex48">Corollary 22.15</a>, there are no edges in <i class="emphasis">G</i><sup>T</sup> from <i class="emphasis">C</i> to any other strongly connected component, and so the search from <i class="emphasis">x</i> will not visit vertices in any other component. Thus, the tree rooted at <i class="emphasis">x</i> contains exactly the vertices of <i class="emphasis">C</i>. Having completed visiting all vertices in <i class="emphasis">C</i>, the search in line 3 selects as a root a vertex from some other strongly connected component <i class="emphasis">C</i><span class="unicode">&prime;</span> whose finishing time <i class="emphasis">f</i>(<i class="emphasis">C</i><span class="unicode">&prime;</span>) is maximum over all components other than <i class="emphasis">C</i>. Again, the search will visit all vertices in <i class="emphasis">C</i><span class="unicode">&prime;</span>, but by <a class="internaljump" href="#ch22ex48">Corollary 22.15</a>, the only edges in <i class="emphasis">G</i><sup>T</sup> from <i class="emphasis">C</i><span class="unicode">&prime;</span> to any other component must be to <i class="emphasis">C</i>, which we have already visited. In general, when the depth-first search of <i class="emphasis">G</i><sup>T</sup> in line 3 visits any strongly connected component, any edges out of that component must be to components that were already visited. Each depth-first tree, therefore, will be exactly one strongly connected component. The following theorem formalizes this argument.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 22.16</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">STRONGLY-CONNECTED-COMPONENTS (<i class="emphasis">G</i>) correctly computes the strongly connected components of a directed graph <i class="emphasis">G</i>.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> We argue by induction on the number of depth-first trees found in the depth-first search of <i class="emphasis">G</i><sup>T</sup> in line 3 that the vertices of each tree form a strongly connected component. The inductive hypothesis is that the first <i class="emphasis">k</i> trees produced in line 3 are strongly connected components. The basis for the induction, when <i class="emphasis">k</i> = 0, is trivial.</p>
<p class="last-para">In the inductive step, we assume that each of the first <i class="emphasis">k</i> depth-first trees produced in line 3 is a strongly connected component, and we consider the (<i class="emphasis">k</i> + 1)st tree produced. Let the root of this tree be vertex <i class="emphasis">u</i>, and let <i class="emphasis">u</i> be in strongly connected component <i class="emphasis">C</i>. Because of how we choose roots in the depth-first search in line 3, <i class="emphasis">f</i>[<i class="emphasis">u</i>] = <i class="emphasis">f</i>(<i class="emphasis">C</i>) <span class="unicode">&gt;</span> <i class="emphasis">f</i>(<i class="emphasis">C</i><span class="unicode">&prime;</span>) for any strongly connected component <i class="emphasis">C</i><span class="unicode">&prime;</span> other than <i class="emphasis">C</i> that has yet to be visited. By the inductive hypothesis, at the time that the search visits <i class="emphasis">u</i>, all other vertices of <i class="emphasis">C</i> are white. By the white-path theorem, therefore, all other vertices of <i class="emphasis">C</i> are descendants of <i class="emphasis">u</i> in its depth-first tree. Moreover, by the inductive hypothesis and by <a class="internaljump" href="#ch22ex48">Corollary 22.15</a>, any edges in <i class="emphasis">G</i><sup>T</sup> that leave <i class="emphasis">C</i> must be to strongly connected components that have already been visited. Thus, no vertex in any strongly connected component other than <i class="emphasis">C</i> will be a descendant of <i class="emphasis">u</i> during the depth-first search of <i class="emphasis">G</i><sup>T</sup>. Thus, the vertices of the depth-first tree in <i class="emphasis">G</i><sup>T</sup> that is rooted at <i class="emphasis">u</i> form exactly one strongly connected component, which completes the inductive step and the proof.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">Here is another way to look at how the second depth-first search operates. Consider the component graph (<i class="emphasis">G</i><sup>T</sup>)<sup>SCC</sup> of <i class="emphasis">G</i><sup>T</sup>. If we map each strongly connected component visited in the second depth-first search to a vertex of (<i class="emphasis">G</i><sup>T</sup>)<sup>SCC</sup>, the vertices of (<i class="emphasis">G</i><sup>T</sup>)<sup>SCC</sup> are visited in the reverse of a topologically sorted order. If we re<a name="1675"></a><a name="IDX-557"></a>verse the edges of (<i class="emphasis">G</i><sup>T</sup>)<sup>SCC</sup>, we get the graph ((<i class="emphasis">G</i><sup>T</sup>)<sup>SCC</sup>)<sup>T</sup>. Because ((<i class="emphasis">G</i><sup>T</sup>)<sup>SCC</sup>)<sup>T</sup> = <i class="emphasis">G</i><sup>SCC</sup> (see <a class="internaljump" href="#ch22ex53">Exercise 22.5-4</a>), the second depth-first search visits the vertices of <i class="emphasis">G</i><sup>SCC</sup> in topologically sorted order.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.5-1</span></span><a name="1676"></a><a name="ch22ex50"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">How can the number of strongly connected components of a graph change if a new edge is added?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.5-2</span></span><a name="1677"></a><a name="ch22ex51"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show how the procedure STRONGLY-CONNECTED-COMPONENTS works on the graph of <a href="DDU0131.html#1641" target="_parent" class="chapterjump">Figure 22.6</a>. Specifically, show the finishing times computed in line 1 and the forest produced in line 3. Assume that the loop of lines 5<span class="unicode">-</span>7 of DFS considers vertices in alphabetical order and that the adjacency lists are in alphabetical order.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.5-3</span></span><a name="1678"></a><a name="ch22ex52"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Professor Deaver claims that the algorithm for strongly connected components can be simplified by using the original (instead of the transpose) graph in the second depth-first search and scanning the vertices in order of <i class="emphasis">increasing</i> finishing times. Is the professor correct?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.5-4</span></span><a name="1679"></a><a name="ch22ex53"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Prove that for any directed graph <i class="emphasis">G</i>, we have ((<i class="emphasis">G</i><sup>T</sup>)<sup>SCC</sup>)<sup>T</sup> = <i class="emphasis">G</i><sup>SCC</sup>. That is, the transpose of the component graph of <i class="emphasis">G</i><sup>T</sup> is the same as the component graph of <i class="emphasis">G</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.5-5</span></span><a name="1680"></a><a name="ch22ex54"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Give an <i class="emphasis">O</i>(<i class="emphasis">V</i> + <i class="emphasis">E</i>)-time algorithm to compute the component graph of a directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>). Make sure that there is at most one edge between two vertices in the component graph your algorithm produces.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.5-6</span></span><a name="1681"></a><a name="ch22ex55"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Given a directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>), explain how to create another graph <i class="emphasis">G</i><span class="unicode">&prime;</span> = (<i class="emphasis">V</i>, <i class="emphasis">E</i><span class="unicode">&prime;</span>) such that (a) <i class="emphasis">G</i><span class="unicode">&prime;</span> has the same strongly connected components as <i class="emphasis">G</i>, (b) <i class="emphasis">G</i><span class="unicode">&prime;</span> has the same component graph as <i class="emphasis">G</i>, and (c) <i class="emphasis">E</i><span class="unicode">&prime;</span> is as small as possible. Describe a fast algorithm to compute <i class="emphasis">G</i><span class="unicode">&prime;</span>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 22.5-7</span></span><a name="1682"></a><a name="ch22ex56"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">A directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) is said to be <b class="bold"><i class="emphasis">semiconnected</i></b> if, for all pairs of vertices <i class="emphasis">u</i>, <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> , we have <span class="inlinemediaobject"><img src="images/fig579_01.jpg" height="8" width="35" alt="" border="0"></span> or <span class="inlinemediaobject"><img src="images/fig579_02.jpg" height="7" width="35" alt="" border="0"></span>. Give an efficient algorithm to determine whether or not <i class="emphasis">G</i> is semiconnected. Prove that your algorithm is correct, and analyze its running time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1683"></a><a name="IDX-558"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 22-1: </span>Classifying edges by breadth-first search</span><a name="1684"></a><a name="ch22ex57"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">A depth-first forest classifies the edges of a graph into tree, back, forward, and cross edges. A breadth-first tree can also be used to classify the edges reachable from the source of the search into the same four categories.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Prove that in a breadth-first search of an undirected graph, the following properties hold:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="first-para">There are no back edges and no forward edges.</p>
</li>
<li class="listitem">
<p class="first-para">For each tree edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>), we have <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <i class="emphasis">d</i>[<i class="emphasis">u</i>] + 1.</p>
</li>
<li class="listitem">
<p class="first-para">For each cross edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>), we have <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <i class="emphasis">d</i>[<i class="emphasis">u</i>] or <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <i class="emphasis">d</i>[<i class="emphasis">u</i>] + 1.</p>
</li>
</ol>
</li>
<li class="listitem">
<p class="first-para">Prove that in a breadth-first search of a directed graph, the following properties hold:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="first-para">There are no forward edges.</p>
</li>
<li class="listitem">
<p class="first-para">For each tree edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>), we have <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <i class="emphasis">d</i>[<i class="emphasis">u</i>] + 1.</p>
</li>
<li class="listitem">
<p class="first-para">For each cross edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>), we have <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">u</i>] + 1.</p>
</li>
<li class="listitem">
<p class="first-para">For each back edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>), we have 0 <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">u</i>].</p>
</li>
</ol>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 22-2: </span>Articulation points, bridges, and biconnected components</span><a name="1685"></a><a name="ch22ex58"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a connected, undirected graph. An <b class="bold"><i class="emphasis">articulation point</i></b> of <i class="emphasis">G</i> is a vertex whose removal disconnects <i class="emphasis">G</i>. A <b class="bold"><i class="emphasis">bridge</i></b> of <i class="emphasis">G</i> is an edge whose removal disconnects <i class="emphasis">G</i>. A <b class="bold"><i class="emphasis">biconnected component</i></b> of <i class="emphasis">G</i> is a maximal set of edges such that any two edges in the set lie on a common simple cycle. <a class="internaljump" href="#ch22fig10">Figure 22.10</a> illustrates these definitions. We can determine articulation points, bridges, and biconnected components using depth-first search. Let <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> = (<i class="emphasis">V</i>, <i class="emphasis">E<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>) be a depth-first tree of <i class="emphasis">G</i>.</p>
<p class="para">
<div class="figure">
<a name="1686"></a><a name="ch22fig10"></a><span class="figuremediaobject"><a href="images/fig581%5F01%5F0%2Ejpg" NAME="IMG_678" target="_parent"><img src="images/fig581_01.jpg" height="92" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 22.10: </span>The articulation points, bridges, and biconnected components of a connected, undirected graph for use in Problem 22-2. The articulation points are the heavily shaded vertices, the bridges are the heavily shaded edges, and the biconnected components are the edges in the shaded regions, with a <i class="emphasis">bcc</i> numbering shown.</span>
</div>
</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Prove that the root of <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> is an articulation point of <i class="emphasis">G</i> if and only if it has at least two children in <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>.</p>
</li>
<li class="listitem">
<p class="first-para">Let <i class="emphasis">v</i> be a nonroot vertex of <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>. Prove that <i class="emphasis">v</i> is an articulation point of <i class="emphasis">G</i> if and only if <i class="emphasis">v</i> has a child <i class="emphasis">s</i> such that there is no back edge from <i class="emphasis">s</i> or any descendant of <i class="emphasis">s</i> to a proper ancestor of <i class="emphasis">v</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Let</p>
<div class="informalequation">
<span class="equation-image"><a href="images/fig580%5F01%2Ejpg" NAME="IMG_679" target="_parent"><img src="images/fig580_01.jpg" height="34" width="400" alt="Click To expand" border="0"></a></span>
</div>
<a name="1687"></a><a name="IDX-559"></a>
<p class="last-para">Show how to compute <i class="emphasis">low</i>[<i class="emphasis">v</i>] for all vertices <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> in <i class="emphasis">O</i>(<i class="emphasis">E</i>) time.</p>
</li>
<li class="listitem">
<p class="first-para">Show how to compute all articulation points in <i class="emphasis">O</i>(<i class="emphasis">E</i>) time.</p>
</li>
<li class="listitem">
<p class="first-para">Prove that an edge of <i class="emphasis">G</i> is a bridge if and only if it does not lie on any simple cycle of <i class="emphasis">G</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Show how to compute all the bridges of <i class="emphasis">G</i> in <i class="emphasis">O</i>(<i class="emphasis">E</i>) time.</p>
</li>
<li class="listitem">
<p class="first-para">Prove that the biconnected components of <i class="emphasis">G</i> partition the nonbridge edges of <i class="emphasis">G</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Give an <i class="emphasis">O</i>(<i class="emphasis">E</i>)-time algorithm to label each edge <i class="emphasis">e</i> of <i class="emphasis">G</i> with a positive integer <i class="emphasis">bcc</i>[<i class="emphasis">e</i>] such that <i class="emphasis">bcc</i>[<i class="emphasis">e</i>] = <i class="emphasis">bcc</i>[<i class="emphasis">e</i><span class="unicode">&prime;</span>] if and only if <i class="emphasis">e</i> and <i class="emphasis">e</i><span class="unicode">&prime;</span> are in the same biconnected component.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 22-3: </span>Euler tour</span><a name="1688"></a><a name="ch22ex59"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">An <b class="bold"><i class="emphasis">Euler tour</i></b> of a connected, directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) is a cycle that traverses each edge of <i class="emphasis">G</i> exactly once, although it may visit a vertex more than once.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Show that <i class="emphasis">G</i> has an Euler tour if and only if in-degree (<i class="emphasis">v</i>) = out-degree (<i class="emphasis">v</i>) for each vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Describe an <i class="emphasis">O</i>(<i class="emphasis">E</i>)-time algorithm to find an Euler tour of <i class="emphasis">G</i> if one exists. (<i class="emphasis">Hint:</i> Merge edge-disjoint cycles.)</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 22-4: </span>Reachability</span><a name="1689"></a><a name="ch22ex60"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a directed graph in which each vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> is labeled with a unique integer <i class="emphasis">L</i>(<i class="emphasis">u</i>) from the set {1, 2,..., |<i class="emphasis">V</i>|}. For each vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, let <a name="1690"></a><a name="IDX-560"></a><span class="inlinemediaobject"><img src="images/fig582_01.jpg" height="10" width="100" alt="" border="0"></span> be the set of vertices that are reachable from <i class="emphasis">u</i>. Define min(<i class="emphasis">u</i>) to be the vertex in <i class="emphasis">R</i>(<i class="emphasis">u</i>) whose label is minimum, i.e., min(<i class="emphasis">u</i>) is the vertex <i class="emphasis">v</i> such that <i class="emphasis">L</i>(<i class="emphasis">v</i>) = min {<i class="emphasis">L</i>(<i class="emphasis">w</i>) : <i class="emphasis">w</i> <span class="unicode">&isin;</span> <i class="emphasis">R</i>(<i class="emphasis">u</i>)}. Give an <i class="emphasis">O</i>(<i class="emphasis">V</i> + <i class="emphasis">E</i>)-time algorithm that computes min(<i class="emphasis">u</i>) for all vertices <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0132.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0134.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
