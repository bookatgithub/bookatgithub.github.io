<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>23.2 The algorithms of Kruskal and Prim</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0136.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0138.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch23"></a>
<div class="section">
<h2 class="first-section-title">
<a name="1718"></a><a name="ch23lev1sec2"></a><span class="section-titlelabel">23.2 </span>The algorithms of Kruskal and Prim</h2>
<p class="first-para">The two minimum-spanning-tree algorithms described in this section are elaborations of the generic algorithm. They each use a specific rule to determine a safe edge in line 3 of GENERIC-MST. In Kruskal's algorithm, the set <i class="emphasis">A</i> is a forest. The safe edge added to <i class="emphasis">A</i> is always a least-weight edge in the graph that connects two distinct components. In Prim's algorithm, the set <i class="emphasis">A</i> forms a single tree. The safe edge added to <i class="emphasis">A</i> is always a least-weight edge connecting the tree to a vertex not in the tree.<a name="1719"></a><a name="IDX-568"></a>
</p>
<div class="section">
<h4 class="sect4-title">
<a name="1720"></a><a name="ch23lev3sec1"></a>Kruskal's algorithm</h4>
<p class="first-para">Kruskal's algorithm is based directly on the generic minimum-spanning-tree algorithm given in <a href="DDU0136.html#1697" target="_parent" class="chapterjump">Section 23.1</a>. It finds a safe edge to add to the growing forest by finding, of all the edges that connect any two trees in the forest, an edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) of least weight. Let <i class="emphasis">C</i><sub>1</sub> and <i class="emphasis">C</i><sub>2</sub> denote the two trees that are connected by (<i class="emphasis">u</i>, <i class="emphasis">v</i>). Since (<i class="emphasis">u</i>, <i class="emphasis">v</i>) must be a light edge connecting <i class="emphasis">C</i><sub>1</sub> to some other tree, <a href="DDU0136.html#1704" target="_parent" class="chapterjump">Corollary 23.2</a><a name="1721"></a><a name="IDX-569"></a> implies that (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is a safe edge for <i class="emphasis">C</i><sub>1</sub>. Kruskal's algorithm is a greedy algorithm, because at each step it adds to the forest an edge of least possible weight.</p>
<p class="para">Our implementation of Kruskal's algorithm is like the algorithm to compute connected components from <a href="DDU0123.html#1498" target="_parent" class="chapterjump">Section 21.1</a>. It uses a disjoint-set data structure to maintain several disjoint sets of elements. Each set contains the vertices in a tree of the current forest. The operation FIND-SET(<i class="emphasis">u</i>) returns a representative element from the set that contains <i class="emphasis">u</i>. Thus, we can determine whether two vertices <i class="emphasis">u</i> and <i class="emphasis">v</i> belong to the same tree by testing whether FIND-SET(<i class="emphasis">u</i>) equals FIND-SET(<i class="emphasis">v</i>). The combining of trees is accomplished by the UNION procedure.</p>
<div class="informalexample">
<pre class="literallayout-normal">
MST-KRUSKAL(<i class="emphasis">G</i>, <i class="emphasis">w</i>)
1  <i class="emphasis">A</i> <span class="unicode">&larr;</span> <span class="unicode">&Oslash;</span>
2  <b class="bold">for</b> each vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>[<i class="emphasis">G</i>]
3       <b class="bold">do</b> MAKE-SET(<i class="emphasis">v</i>)
4  sort the edges of <i class="emphasis">E</i> into nondecreasing order by weight <i class="emphasis">w</i>
5  <b class="bold">for</b> each edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>, taken in nondecreasing order by weight
6       <b class="bold">do if</b> FIND-SET(<i class="emphasis">u</i>) <span class="unicode">&ne;</span> FIND-SET(<i class="emphasis">v</i>)
7             <b class="bold">then</b> <i class="emphasis">A</i> <span class="unicode">&larr;</span> <i class="emphasis">A</i> <span class="unicode">&cup;</span> {(<i class="emphasis">u</i>, <i class="emphasis">v</i>)}
8                  UNION(<i class="emphasis">u</i>, <i class="emphasis">v</i>)
9  <b class="bold">return</b> <i class="emphasis">A</i>
</pre>
</div>
<a name="1722"></a><a name="IDX-570"></a>
<p class="para">Kruskal's algorithm works as shown in <a class="internaljump" href="#ch23fig04">Figure 23.4</a>. Lines 1<span class="unicode">-</span>3 initialize the set <i class="emphasis">A</i> to the empty set and create |<i class="emphasis">V</i>| trees, one containing each vertex. The edges in <i class="emphasis">E</i> are sorted into nondecreasing order by weight in line 4. The <b class="bold">for</b> loop in lines 5<span class="unicode">-</span>8 checks, for each edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>), whether the endpoints <i class="emphasis">u</i> and <i class="emphasis">v</i> belong to the same tree. If they do, then the edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) cannot be added to the forest without creating a cycle, and the edge is discarded. Otherwise, the two vertices belong to different trees. In this case, the edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is added to <i class="emphasis">A</i> in line 7, and the vertices in the two trees are merged in line 8.</p>
<div class="figure">
<a name="1723"></a><a name="ch23fig04"></a><span class="figuremediaobject"><a href="images/fig590%5F01%5F0%2Ejpg" NAME="IMG_686" target="_parent"><img src="images/fig590_01.jpg" height="295" width="350" alt="Click To expand" border="0"></a></span><span class="figurespace">&nbsp;</span><span class="figuremediaobject"><a href="images/fig591%5F01%5F0%2Ejpg" NAME="IMG_687" target="_parent"><img src="images/fig591_01.jpg" height="222" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 23.4: </span>The execution of Kruskal's algorithm on the graph from Figure 23.1. Shaded edges belong to the forest <i class="emphasis">A</i> being grown. The edges are considered by the algorithm in sorted order by weight. An arrow points to the edge under consideration at each step of the algorithm. If the edge joins two distinct trees in the forest, it is added to the forest, thereby merging the two trees.</span>
</div>
<p class="last-para">The running time of Kruskal's algorithm for a graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) depends on the implementation of the disjoint-set data structure. We shall assume the disjoint-set-forest implementation of <a href="DDU0125.html#1522" target="_parent" class="chapterjump">Section 21.3</a> with the union-by-rank and path-compression heuristics, since it is the asymptotically fastest implementation known. Initializing the set <i class="emphasis">A</i> in line 1 takes <i class="emphasis">O</i>(1) time, and the time to sort the edges in line 4 is <i class="emphasis">O</i>(<i class="emphasis">E</i> lg <i class="emphasis">E</i>). (We will account for the cost of the |<i class="emphasis">V</i>| MAKE-SET operations in the <b class="bold">for</b> loop of lines 2<span class="unicode">-</span>3 in a moment.) The <b class="bold">for</b> loop of lines 5<span class="unicode">-</span>8 performs <i class="emphasis">O</i>(<i class="emphasis">E</i>) FIND-SET and UNION operations on the disjoint-set forest. Along with the |<i class="emphasis">V</i>| MAKE-SET operations, these take a total of <i class="emphasis">O</i>((<i class="emphasis">V</i> + <i class="emphasis">E</i>) <span class="unicode">&alpha;</span>(<i class="emphasis">V</i>)) time, where <span class="unicode">&alpha;</span> is the very slowly growing function defined in <a href="DDU0126.html#1536" target="_parent" class="chapterjump">Section 21.4</a>. Because <i class="emphasis">G</i> is assumed to be connected, we have |<i class="emphasis">E</i>| <span class="unicode">&ge;</span> |<i class="emphasis">V</i>| - 1, and so the disjoint-set operations take <i class="emphasis">O</i>(<i class="emphasis">E</i> <span class="unicode">&alpha;</span>(<i class="emphasis">V</i>)) time. Moreover, since <span class="unicode">&alpha;</span>(|<i class="emphasis">V</i>|) = <i class="emphasis">O</i>(lg <i class="emphasis">V</i>) = <i class="emphasis">O</i>(lg <i class="emphasis">E</i>), the total running time of Kruskal's algorithm is <i class="emphasis">O</i>(<i class="emphasis">E</i> lg <i class="emphasis">E</i>). Observing that |<i class="emphasis">E</i>| <span class="unicode">&lt;</span> |<i class="emphasis">V</i>|<sup>2</sup>, we have lg |<i class="emphasis">E</i>| = <i class="emphasis">O</i>(lg <i class="emphasis">V</i>), and so we can restate the running time of Kruskal's algorithm as <i class="emphasis">O</i>(<i class="emphasis">E</i> lg <i class="emphasis">V</i>).</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1724"></a><a name="ch23lev3sec2"></a>Prim's algorithm</h4>
<p class="first-para">Like Kruskal's algorithm, Prim's algorithm is a special case of the generic minimum-spanning-tree algorithm from <a href="DDU0136.html#1697" target="_parent" class="chapterjump">Section 23.1</a>. Prim's algorithm operates much like Dijkstra's algorithm for finding shortest paths in a graph, which we shall see in <a href="DDU0150.html#1788" target="_parent" class="chapterjump">Section 24.3</a>. Prim's algorithm has the property that the edges in the set <i class="emphasis">A</i> always form a single tree. As is illustrated in <a class="internaljump" href="#ch23fig05">Figure 23.5</a>, the tree starts from an arbitrary root vertex <i class="emphasis">r</i> and grows until the tree spans all the vertices in <i class="emphasis">V</i>. At each step, a light edge is added to the tree <i class="emphasis">A</i> that connects <i class="emphasis">A</i> to an isolated vertex of <i class="emphasis">G<sub>A</sub></i> = (<i class="emphasis">V</i>, <i class="emphasis">A</i>). By <a href="DDU0136.html#1704" target="_parent" class="chapterjump">Corollary 23.2</a>, this rule adds only edges that are safe for <i class="emphasis">A</i>; therefore, when the algorithm terminates, the edges in <i class="emphasis">A</i> form a minimum spanning tree. This strategy is greedy since the tree is augmented at each step with an edge that contributes the minimum amount possible to the tree's weight.</p>
<div class="figure">
<a name="1725"></a><a name="ch23fig05"></a><span class="figuremediaobject"><a href="images/fig593%5F01%5F0%2Ejpg" NAME="IMG_688" target="_parent"><img src="images/fig593_01.jpg" height="372" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 23.5: </span>The execution of Prim's algorithm on the graph from Figure 23.1. The root vertex is <i class="emphasis">a</i>. Shaded edges are in the tree being grown, and the vertices in the tree are shown in black. At each step of the algorithm, the vertices in the tree determine a cut of the graph, and a light edge crossing the cut is added to the tree. In the second step, for example, the algorithm has a choice of adding either edge (<i class="emphasis">b, c</i>) or edge (<i class="emphasis">a, h</i>) to the tree since both are light edges crossing the cut.</span>
</div>
<p class="para">The key to implementing Prim's algorithm efficiently is to make it easy to select a new edge to be added to the tree formed by the edges in <i class="emphasis">A</i>. In the pseudocode below, the connected graph <i class="emphasis">G</i> and the root <i class="emphasis">r</i> of the minimum spanning tree to be grown are inputs to the algorithm. During execution of the algorithm, all vertices<a name="1726"></a><a name="IDX-571"></a><a name="1727"></a><a name="IDX-572"></a> that are <i class="emphasis">not</i> in the tree reside in a min-priority queue <i class="emphasis">Q</i> based on a <i class="emphasis">key</i> field. For each vertex <i class="emphasis">v</i>, <i class="emphasis">key</i>[<i class="emphasis">v</i>] is the minimum weight of any edge connecting <i class="emphasis">v</i> to a vertex in the tree; by convention, <i class="emphasis">key</i>[<i class="emphasis">v</i>] = <span class="unicode">&infin;</span> if there is no such edge. The field <span class="unicode">&pi;</span>[<i class="emphasis">v</i>] names the parent of <i class="emphasis">v</i> in the tree. During the algorithm, the set <i class="emphasis">A</i> from GENERIC-MST is kept implicitly as</p>
<p class="para">
<i class="emphasis">A</i> = {(<i class="emphasis">v</i>, <span class="unicode">&pi;</span>[<i class="emphasis">v</i>]) : <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> - {<i class="emphasis">r</i>} - <i class="emphasis">Q</i>}.</p>
<p class="para">When the algorithm terminates, the min-priority queue <i class="emphasis">Q</i> is empty; the minimum spanning tree <i class="emphasis">A</i> for <i class="emphasis">G</i> is thus</p>
<p class="para">
<i class="emphasis">A</i> = {(<i class="emphasis">v</i>, <span class="unicode">&pi;</span>[<i class="emphasis">v</i>]) : <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> - {<i class="emphasis">r</i>}}.</p>
<div class="informalexample">
<pre class="literallayout-normal">
MST-PRIM(<i class="emphasis">G</i>, <i class="emphasis">w</i>, <i class="emphasis">r</i>)
 1  <b class="bold">for</b> each <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> [<i class="emphasis">G</i>]
 2       <b class="bold">do</b> <i class="emphasis">key</i>[<i class="emphasis">u</i>] <span class="unicode">&larr;</span> <span class="unicode">&infin;</span>
 3          <span class="unicode">&pi;</span>[<i class="emphasis">u</i>] <span class="unicode">&larr;</span> NIL
 4  <i class="emphasis">key</i>[<i class="emphasis">r</i>] <span class="unicode">&larr;</span> 0
 5   <i class="emphasis">Q</i> <span class="unicode">&larr;</span> <i class="emphasis">V</i> [<i class="emphasis">G</i>]
 6   <b class="bold">while</b> <i class="emphasis">Q</i> <span class="unicode">&ne;</span> <span class="unicode">&Oslash;</span>
 7       <b class="bold">do</b> <i class="emphasis">u</i> <span class="unicode">&larr;</span> EXTRACT-MIN(<i class="emphasis">Q</i>)
 8          <b class="bold">for</b> each <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">Adj</i>[<i class="emphasis">u</i>]
 9              <b class="bold">do if</b> <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">Q</i> and <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&lt;</span> <i class="emphasis">key</i>[<i class="emphasis">v</i>]
10                    <b class="bold">then</b> <span class="unicode">&pi;</span>[<i class="emphasis">v</i>] <span class="unicode">&larr;</span> <i class="emphasis">u</i>
11                         <i class="emphasis">key</i>[<i class="emphasis">v</i>] <span class="unicode">&larr;</span> <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>)
</pre>
</div>
<p class="para">Prim's algorithm works as shown in <a class="internaljump" href="#ch23fig05">Figure 23.5</a>. Lines 1<span class="unicode">-</span>5 set the key of each vertex to <span class="unicode">&infin;</span> (except for the root <i class="emphasis">r</i>, whose key is set to 0 so that it will be the first vertex processed), set the parent of each vertex to NIL, and initialize the min-priority queue <i class="emphasis">Q</i> to contain all the vertices. The algorithm maintains the following three-part loop invariant:</p>
<p class="para">Prior to each iteration of the <b class="bold">while</b> loop of lines 6<span class="unicode">-</span>11,</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="first-para">
<i class="emphasis">A</i> = {(<i class="emphasis">v</i>, <span class="unicode">&pi;</span>[<i class="emphasis">v</i>]) : <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> - {<i class="emphasis">r</i>} - <i class="emphasis">Q</i>}.</p>
</li>
<li class="listitem">
<p class="first-para">The vertices already placed into the minimum spanning tree are those in <i class="emphasis">V</i> - <i class="emphasis">Q</i>.</p>
</li>
<li class="listitem">
<p class="first-para">For all vertices <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">Q</i>, if <span class="unicode">&pi;</span>[<i class="emphasis">v</i>] <span class="unicode">&ne;</span> NIL, then <i class="emphasis">key</i>[<i class="emphasis">v</i>] <span class="unicode">&lt;</span> <span class="unicode">&infin;</span> and <i class="emphasis">key</i>[<i class="emphasis">v</i>] is the weight of a light edge (<i class="emphasis">v</i>, <span class="unicode">&pi;</span>[<i class="emphasis">v</i>]) connecting <i class="emphasis">v</i> to some vertex already placed into the minimum spanning tree.</p>
</li>
</ol>
<p class="para">Line 7 identifies a vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">Q</i> incident on a light edge crossing the cut (<i class="emphasis">V</i> -<i class="emphasis">Q</i>, <i class="emphasis">Q</i>) (with the exception of the first iteration, in which <i class="emphasis">u</i> = <i class="emphasis">r</i> due to line 4). Removing <i class="emphasis">u</i> <a name="1728"></a><a name="IDX-573"></a>from the set <i class="emphasis">Q</i> adds it to the set <i class="emphasis">V</i> - <i class="emphasis">Q</i> of vertices in the tree, thus adding (<i class="emphasis">u</i>, <span class="unicode">&pi;</span>[<i class="emphasis">u</i>]) to <i class="emphasis">A</i>. The <b class="bold">for</b> loop of lines 8<span class="unicode">-</span>11 update the <i class="emphasis">key</i> and <span class="unicode">&pi;</span> fields of every vertex <i class="emphasis">v</i> adjacent to <i class="emphasis">u</i> but not in the tree. The updating maintains the third part of the loop invariant.</p>
<p class="para">The performance of Prim's algorithm depends on how we implement the min-priority queue <i class="emphasis">Q</i>. If <i class="emphasis">Q</i> is implemented as a binary min-heap (see <a href="DDU0035.html#382" target="_parent" class="chapterjump">Chapter 6</a>), we can use the BUILD-MIN-HEAP procedure to perform the initialization in lines 1<span class="unicode">-</span>5 in <i class="emphasis">O</i>(<i class="emphasis">V</i>) time. The body of the <b class="bold">while</b> loop is executed |<i class="emphasis">V</i>| times, and since each EXTRACT-MIN operation takes <i class="emphasis">O</i>(lg <i class="emphasis">V</i>) time, the total time for all calls to EXTRACT-MIN is <i class="emphasis">O</i>(<i class="emphasis">V</i> lg <i class="emphasis">V</i>). The <b class="bold">for</b> loop in lines 8<span class="unicode">-</span>11 is executed <i class="emphasis">O</i>(<i class="emphasis">E</i>) times altogether, since the sum of the lengths of all adjacency lists is 2 |<i class="emphasis">E</i>|. Within the <b class="bold">for</b> loop, the test for membership in <i class="emphasis">Q</i> in line 9 can be implemented in constant time by keeping a bit for each vertex that tells whether or not it is in <i class="emphasis">Q</i>, and updating the bit when the vertex is removed from <i class="emphasis">Q</i>. The assignment in line 11 involves an implicit DECREASE-KEY operation on the min-heap, which can be implemented in a binary min-heap in <i class="emphasis">O</i>(lg <i class="emphasis">V</i>) time. Thus, the total time for Prim's algorithm is <i class="emphasis">O</i>(<i class="emphasis">V</i> lg <i class="emphasis">V</i> + <i class="emphasis">E</i> lg <i class="emphasis">V</i>) = <i class="emphasis">O</i>(<i class="emphasis">E</i> lg <i class="emphasis">V</i>), which is asymptotically the same as for our implementation of Kruskal's algorithm.</p>
<p class="para">The asymptotic running time of Prim's algorithm can be improved, however, by using Fibonacci heaps. <a href="DDU0117.html#1439" target="_parent" class="chapterjump">Chapter 20</a> shows that if |<i class="emphasis">V</i>| elements are organized into a Fibonacci heap, we can perform an EXTRACT-MIN operation in <i class="emphasis">O</i>(lg <i class="emphasis">V</i>) amortized time and a DECREASE-KEY operation (to implement line 11) in <i class="emphasis">O</i>(1) amortized time. Therefore, if we use a Fibonacci heap to implement the min-priority queue <i class="emphasis">Q</i>, the running time of Prim's algorithm improves to <i class="emphasis">O</i>(<i class="emphasis">E</i> + <i class="emphasis">V</i> lg <i class="emphasis">V</i>).</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 23.2-1</span></span><a name="1729"></a><a name="ch23ex14"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Kruskal's algorithm can return different spanning trees for the same input graph <i class="emphasis">G</i>, depending on how ties are broken when the edges are sorted into order. Show that for each minimum spanning tree <i class="emphasis">T</i> of <i class="emphasis">G</i>, there is a way to sort the edges of <i class="emphasis">G</i> in Kruskal's algorithm so that the algorithm returns <i class="emphasis">T</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 23.2-2</span></span><a name="1730"></a><a name="ch23ex15"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that the graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) is represented as an adjacency matrix. Give a simple implementation of Prim's algorithm for this case that runs in <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>2</sup>) time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 23.2-3</span></span><a name="1731"></a><a name="ch23ex16"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Is the Fibonacci-heap implementation of Prim's algorithm asymptotically faster than the binary-heap implementation for a sparse graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>), where |<i class="emphasis">E</i>| = <span class="unicode">&Theta;</span>(<i class="emphasis">V</i>)? What about for a dense graph, where |<i class="emphasis">E</i>| = <span class="unicode">&Theta;</span>(<i class="emphasis">V</i><sup>2</sup>)? How must <a name="1732"></a><a name="IDX-574"></a>|<i class="emphasis">E</i>| and |<i class="emphasis">V</i>| be related for the Fibonacci-heap implementation to be asymptotically faster than the binary-heap implementation?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 23.2-4</span></span><a name="1733"></a><a name="ch23ex17"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that all edge weights in a graph are integers in the range from 1 to |<i class="emphasis">V</i>|. How fast can you make Kruskal's algorithm run? What if the edge weights are integers in the range from 1 to <i class="emphasis">W</i> for some constant <i class="emphasis">W</i>?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 23.2-5</span></span><a name="1734"></a><a name="ch23ex18"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that all edge weights in a graph are integers in the range from 1 to |<i class="emphasis">V</i>|. How fast can you make Prim's algorithm run? What if the edge weights are integers in the range from 1 to <i class="emphasis">W</i> for some constant <i class="emphasis">W</i>?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 23.2-6: </span><span class="unicode">&#8902;</span></span><a name="1735"></a><a name="ch23ex19"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that the edge weights in a graph are uniformly distributed over the half-open interval [0, 1). Which algorithm, Kruskal's or Prim's, can you make run faster?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 23.2-7: </span><span class="unicode">&#8902;</span></span><a name="1736"></a><a name="ch23ex20"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that a graph <i class="emphasis">G</i> has a minimum spanning tree already computed. How quickly can the minimum spanning tree be updated if a new vertex and incident edges are added to <i class="emphasis">G</i>?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 23.2-8</span></span><a name="1737"></a><a name="ch23ex21"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Professor Toole proposes a new divide-and-conquer algorithm for computing minimum spanning trees, which goes as follows. Given a graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>), partition the set <i class="emphasis">V</i> of vertices into two sets <i class="emphasis">V</i><sub>1</sub> and <i class="emphasis">V</i><sub>2</sub> such that |<i class="emphasis">V</i><sub>1</sub>| and |<i class="emphasis">V</i><sub>2</sub>| differ by at most 1. Let <i class="emphasis">E</i><sub>1</sub> be the set of edges that are incident only on vertices in <i class="emphasis">V</i><sub>1</sub>, and let <i class="emphasis">E</i><sub>2</sub> be the set of edges that are incident only on vertices in <i class="emphasis">V</i><sub>2</sub>. Recursively solve a minimum-spanning-tree problem on each of the two subgraphs <i class="emphasis">G</i><sub>1</sub> = (<i class="emphasis">V</i><sub>1</sub>, <i class="emphasis">E</i><sub>1</sub>) and <i class="emphasis">G</i><sub>2</sub> = (<i class="emphasis">V</i><sub>2</sub>, <i class="emphasis">E</i><sub>2</sub>). Finally, select the minimum-weight edge in <i class="emphasis">E</i> that crosses the cut (<i class="emphasis">V</i><sub>1</sub>, <i class="emphasis">V</i><sub>2</sub>), and use this edge to unite the resulting two minimum spanning trees into a single spanning tree.</p>
<p class="last-para">Either argue that the algorithm correctly computes a minimum spanning tree of <i class="emphasis">G</i>, or provide an example for which the algorithm fails.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1738"></a><a name="IDX-575"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 23-1: </span>Second-best minimum spanning tree</span><a name="1739"></a><a name="ch23ex22"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be an undirected, connected graph with weight function <i class="emphasis">w</i> : <i class="emphasis">E</i> <span class="unicode">&rarr;</span> <b class="bold">R</b>, and suppose that |<i class="emphasis">E</i>| <span class="unicode">&ge;</span> |<i class="emphasis">V</i>| and all edge weights are distinct.</p>
<p class="para">A second-best minimum spanning tree is defined as follows. Let <span class="inlinemediaobject"><img src="images/fig597_01.jpg" height="8" width="9" alt="" border="0"></span> be the set of all spanning trees of <i class="emphasis">G</i>, and let <i class="emphasis">T</i><span class="unicode">&prime;</span> be a minimum spanning tree of <i class="emphasis">G</i>. Then a <b class="bold"><i class="emphasis">second-best minimum spanning tree</i></b> is a spanning tree <i class="emphasis">T</i> such that <span class="inlinemediaobject"><img src="images/fig597_02.jpg" height="11" width="39" alt="" border="0"></span> <span class="inlinemediaobject"><img src="images/fig597_03.jpg" height="13" width="96" alt="" border="0"></span>.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Show that the minimum spanning tree is unique, but that the second-best minimum spanning tree need not be unique.</p>
</li>
<li class="listitem">
<p class="first-para">Let <i class="emphasis">T</i> be a minimum spanning tree of <i class="emphasis">G</i>. Prove that there exist edges (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">T</i> and (<i class="emphasis">x</i>, <i class="emphasis">y</i>) <span class="unicode">&notin;</span> <i class="emphasis">T</i> such that <i class="emphasis">T</i> - {(<i class="emphasis">u</i>, <i class="emphasis">v</i>)} <span class="unicode">&cup;</span> {(<i class="emphasis">x</i>, <i class="emphasis">y</i>)} is a second-best minimum spanning tree of <i class="emphasis">G</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Let <i class="emphasis">T</i> be a spanning tree of <i class="emphasis">G</i> and, for any two vertices <i class="emphasis">u</i>, <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, let <i class="emphasis">max</i>[<i class="emphasis">u</i>, <i class="emphasis">v</i>] be an edge of maximum weight on the unique path between <i class="emphasis">u</i> and <i class="emphasis">v</i> in <i class="emphasis">T</i>. Describe an <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>2</sup>)-time algorithm that, given <i class="emphasis">T</i>, computes <i class="emphasis">max</i>[<i class="emphasis">u</i>, <i class="emphasis">v</i>] for all <i class="emphasis">u</i>, <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Give an efficient algorithm to compute the second-best minimum spanning tree of <i class="emphasis">G</i>.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 23-2: </span>Minimum spanning tree in sparse graphs</span><a name="1740"></a><a name="ch23ex23"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">For a very sparse connected graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>), we can further improve upon the <i class="emphasis">O</i>(<i class="emphasis">E</i> + <i class="emphasis">V</i> lg <i class="emphasis">V</i>) running time of Prim's algorithm with Fibonacci heaps by "pre-processing" <i class="emphasis">G</i> to decrease the number of vertices before running Prim's algorithm. In particular, we choose, for each vertex <i class="emphasis">u</i>, the minimum-weight edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) incident on <i class="emphasis">u</i>, and we put (<i class="emphasis">u</i>, <i class="emphasis">v</i>) into the minimum spanning tree under construction. We then contract all chosen edges (see <a href="DDU0250.html#3364" target="_parent" class="chapterjump">Section B.4</a>). Rather than contracting these edges one at a time, we first identify sets of vertices that are united into the same new vertex. Then, we create the graph that would have resulted from contracting these edges one at a time, but we do so by "renaming" edges according to the sets into which their endpoints were placed. Several edges from the original graph may be renamed the same as each other. In such a case, only one edge results, and its weight is the minimum of the weights of the corresponding original edges.</p>
<p class="para">Initially, we set the minimum spanning tree <i class="emphasis">T</i> being constructed to be empty, and for each edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>, we set <i class="emphasis">orig</i>[<i class="emphasis">u</i>, <i class="emphasis">v</i>] = (<i class="emphasis">u</i>, <i class="emphasis">v</i>) and <i class="emphasis">c</i>[<i class="emphasis">u</i>, <i class="emphasis">v</i>] = <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>). We use the <i class="emphasis">orig</i> attribute to reference the edge from the initial graph that is associated with <a name="1741"></a><a name="IDX-576"></a>an edge in the contracted graph. The <i class="emphasis">c</i> attribute holds the weight of an edge, and as edges are contracted, it is updated according to the above scheme for choosing edge weights. The procedure MST-REDUCE takes inputs <i class="emphasis">G</i>, <i class="emphasis">orig</i>, <i class="emphasis">c</i>, and <i class="emphasis">T</i>, and it returns a contracted graph <i class="emphasis">G</i><span class="unicode">&prime;</span> and updated attributes <i class="emphasis">orig</i><span class="unicode">&prime;</span> and <i class="emphasis">c</i><span class="unicode">&prime;</span> for graph <i class="emphasis">G</i><span class="unicode">&prime;</span>. The procedure also accumulates edges of <i class="emphasis">G</i> into the minimum spanning tree <i class="emphasis">T</i>.</p>
<pre class="literallayout-normal">
MST-REDUCE(<i class="emphasis">G</i>, <i class="emphasis">orig</i>, <i class="emphasis">c</i>, <i class="emphasis">T</i>)
 1  <b class="bold">for</b> each <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>[<i class="emphasis">G</i>]
 2       <b class="bold">do</b> <i class="emphasis">mark</i>[<i class="emphasis">v</i>] <span class="unicode">&larr;</span> FALSE
 3          MAKE-SET(<i class="emphasis">v</i>)
 4  <b class="bold">for</b> each <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>[<i class="emphasis">G</i>]
 5       <b class="bold">do if</b> <i class="emphasis">mark</i>[<i class="emphasis">u</i>] = FALSE
 6             <b class="bold">then</b> choose <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">Adj</i>[<i class="emphasis">u</i>] such that <i class="emphasis">c</i>[<i class="emphasis">u</i>, <i class="emphasis">v</i>] is minimized
 7                  UNION(<i class="emphasis">u</i>, <i class="emphasis">v</i>)
 8                  <i class="emphasis">T</i> <span class="unicode">&larr;</span> <i class="emphasis">T</i> <span class="unicode">&cup;</span> {<i class="emphasis">orig</i>[<i class="emphasis">u</i>, <i class="emphasis">v</i>]}
 9                  <i class="emphasis">mark</i>[<i class="emphasis">u</i>] <span class="unicode">&larr;</span> <i class="emphasis">mark</i>[<i class="emphasis">v</i>] <span class="unicode">&larr;</span> TRUE
10  <i class="emphasis">V</i>[<i class="emphasis">G</i><span class="unicode">&prime;</span>] <span class="unicode">&larr;</span> {FIND-SET(<i class="emphasis">v</i>) : <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>[<i class="emphasis">G</i>]}
11  <i class="emphasis">E</i>[<i class="emphasis">G</i><span class="unicode">&prime;</span>] <span class="unicode">&Oslash;</span>
12  <b class="bold">for</b> each (<i class="emphasis">x</i>, <i class="emphasis">y</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>[<i class="emphasis">G</i>]
13      <b class="bold">do</b> <i class="emphasis">u</i> <span class="unicode">&larr;</span> FIND-SET(<i class="emphasis">x</i>)
14         <i class="emphasis">v</i> <span class="unicode">&larr;</span> FIND-SET(<i class="emphasis">y</i>)
15         <b class="bold">if</b> (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>[<i class="emphasis">G</i><span class="unicode">&prime;</span>]
16            <b class="bold">then</b> <i class="emphasis">E</i>[<i class="emphasis">G</i><span class="unicode">&prime;</span>] <span class="unicode">&larr;</span> <i class="emphasis">E</i>[<i class="emphasis">G</i><span class="unicode">&prime;</span>] <span class="unicode">&cup;</span> {(<i class="emphasis">u</i>, <i class="emphasis">v</i>)}
17                 <i class="emphasis">orig</i><span class="unicode">&prime;</span> [<i class="emphasis">u</i>, <i class="emphasis">v</i>] <span class="unicode">&larr;</span> <i class="emphasis">orig</i>[<i class="emphasis">x</i>, <i class="emphasis">y</i>]
18                 <i class="emphasis">c</i><span class="unicode">&prime;</span> [<i class="emphasis">u</i>, <i class="emphasis">v</i>] <span class="unicode">&larr;</span> <i class="emphasis">c</i>[<i class="emphasis">x</i>, <i class="emphasis">y</i>]
19            <b class="bold">else if</b> <i class="emphasis">c</i>[<i class="emphasis">x</i>, <i class="emphasis">y</i>] <span class="unicode">&lt;</span> <i class="emphasis">c</i><span class="unicode">&prime;</span> [<i class="emphasis">u</i>, <i class="emphasis">v</i>]
20                    <b class="bold">then</b> <i class="emphasis">orig</i><span class="unicode">&prime;</span> [<i class="emphasis">u</i>, <i class="emphasis">v</i>] <span class="unicode">&larr;</span> <i class="emphasis">orig</i>[<i class="emphasis">x</i>, <i class="emphasis">y</i>]
21                         <i class="emphasis">c</i><span class="unicode">&prime;</span> [<i class="emphasis">u</i>, <i class="emphasis">v</i>] <span class="unicode">&larr;</span> <i class="emphasis">c</i>[<i class="emphasis">x</i>, <i class="emphasis">y</i>]
22  construct adjacency lists <i class="emphasis">Adj</i> for <i class="emphasis">G</i><span class="unicode">&prime;</span>
23  <b class="bold">return</b> <i class="emphasis">G</i><span class="unicode">&prime;</span>, <i class="emphasis">orig</i><span class="unicode">&prime;</span>, <i class="emphasis">c</i><span class="unicode">&prime;</span>, and <i class="emphasis">T</i>
</pre>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Let <i class="emphasis">T</i> be the set of edges returned by MST-REDUCE, and let <i class="emphasis">A</i> be the minimum spanning tree of the graph <i class="emphasis">G</i><span class="unicode">&prime;</span> formed by the call MST-PRIM(<i class="emphasis">G</i><span class="unicode">&prime;</span>, <i class="emphasis">c</i><span class="unicode">&prime;</span>, <i class="emphasis">r</i>), where <i class="emphasis">r</i> is any vertex in <i class="emphasis">V</i>[<i class="emphasis">G</i><span class="unicode">&prime;</span>]. Prove that <i class="emphasis">T</i> <span class="unicode">&cup;</span> {<i class="emphasis">orig</i><span class="unicode">&prime;</span> [<i class="emphasis">x</i>, <i class="emphasis">y</i>] : (<i class="emphasis">x</i>, <i class="emphasis">y</i>) <span class="unicode">&isin;</span> <i class="emphasis">A</i>} is a minimum spanning tree of <i class="emphasis">G</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Argue that |<i class="emphasis">V</i>[<i class="emphasis">G</i><span class="unicode">&prime;</span>]| <span class="unicode">&le;</span> |<i class="emphasis">V</i>| /2.</p>
</li>
<li class="listitem">
<p class="first-para">Show how to implement MST-REDUCE so that it runs in <i class="emphasis">O</i>(<i class="emphasis">E</i>) time. (<i class="emphasis">Hint:</i> Use simple data structures.)</p>
</li>
<li class="listitem">
<p class="first-para">Suppose that we run <i class="emphasis">k</i> phases of MST-REDUCE, using the outputs <i class="emphasis">G</i><span class="unicode">&prime;</span>, <i class="emphasis">orig</i><span class="unicode">&prime;</span>, and <i class="emphasis">c</i><span class="unicode">&prime;</span> produced by one phase as the inputs <i class="emphasis">G</i>, <i class="emphasis">orig</i>, and <i class="emphasis">c</i> to the next phase and <a name="1742"></a><a name="IDX-577"></a>accumulating edges in <i class="emphasis">T</i>. Argue that the overall running time of the <i class="emphasis">k</i> phases is <i class="emphasis">O</i>(<i class="emphasis">k E</i>).</p>
</li>
<li class="listitem">
<p class="first-para">Suppose that after running <i class="emphasis">k</i> phases of MST-REDUCE, as in part (d), we run Prim's algorithm by calling MST-PRIM(<i class="emphasis">G</i><span class="unicode">&prime;</span>, <i class="emphasis">c</i><span class="unicode">&prime;</span>, <i class="emphasis">r</i>), where <i class="emphasis">G</i><span class="unicode">&prime;</span> and <i class="emphasis">c</i><span class="unicode">&prime;</span> are returned by the last phase and <i class="emphasis">r</i> is any vertex in <i class="emphasis">V</i> [<i class="emphasis">G</i><span class="unicode">&prime;</span>]. Show how to pick <i class="emphasis">k</i> so that the overall running time is <i class="emphasis">O</i>(<i class="emphasis">E</i> lg lg <i class="emphasis">V</i>). Argue that your choice of <i class="emphasis">k</i> minimizes the overall asymptotic running time.</p>
</li>
<li class="listitem">
<p class="first-para">For what values of |<i class="emphasis">E</i>| (in terms of |<i class="emphasis">V</i>|) does Prim's algorithm with preprocessing asymptotically beat Prim's algorithm without preprocessing?</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 23-3: </span>Bottleneck spanning tree</span><a name="1743"></a><a name="ch23ex24"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">A <b class="bold"><i class="emphasis">bottleneck spanning tree</i></b> <i class="emphasis">T</i> of an undirected graph <i class="emphasis">G</i> is a spanning tree of <i class="emphasis">G</i> whose largest edge weight is minimum over all spanning trees of <i class="emphasis">G</i>. We say that the value of the bottleneck spanning tree is the weight of the maximum-weight edge in <i class="emphasis">T</i>.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Argue that a minimum spanning tree is a bottleneck spanning tree.</p>
</li>
</ol>
<p class="para">Part (a) shows that finding a bottleneck spanning tree is no harder than finding a minimum spanning tree. In the remaining parts, we will show that one can be found in linear time.</p>
<ol class="orderedlist" start="2" type="a">
<li class="first-listitem">
<p class="first-para">Give a linear-time algorithm that given a graph <i class="emphasis">G</i> and an integer <i class="emphasis">b</i>, determines whether the value of the bottleneck spanning tree is at most <i class="emphasis">b</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Use your algorithm for part (b) as a subroutine in a linear-time algorithm for the bottleneck-spanning-tree problem. (<i class="emphasis">Hint:</i> You may want to use a subroutine that contracts sets of edges, as in the MST-REDUCE procedure described in <a class="internaljump" href="#ch23ex23">Problem 23-2</a>.)</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 23-4: </span>Alternative minimum-spanning-tree algorithms</span><a name="1744"></a><a name="ch23ex25"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">In this problem, we give pseudocode for three different algorithms. Each one takes a graph as input and returns a set of edges <i class="emphasis">T</i>. For each algorithm, you must either prove that <i class="emphasis">T</i> is a minimum spanning tree or prove that <i class="emphasis">T</i> is not a minimum spanning tree. Also describe the most efficient implementation of each algorithm, whether or not it computes a minimum spanning tree.<a name="1745"></a><a name="IDX-578"></a>
</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<pre class="literallayout-normal">
MAYBE-MST-A(<i class="emphasis">G</i>, <i class="emphasis">w</i>)
1  sort the edges into nonincreasing order of edge weights <i class="emphasis">w</i>
2  <i class="emphasis">T</i> <span class="unicode">&larr;</span> <i class="emphasis">E</i>
3  <b class="bold">for</b> each edge <i class="emphasis">e</i>, taken in nonincreasing order by weight
4       <b class="bold">do if</b> <i class="emphasis">T</i> - {<i class="emphasis">e</i>} is a connected graph
5             <b class="bold">then</b> <i class="emphasis">T</i> <span class="unicode">&larr;</span> <i class="emphasis">T</i> - <i class="emphasis">e</i>
6  <b class="bold">return</b> <i class="emphasis">T</i>
</pre>
</li>
<li class="listitem">
<pre class="literallayout-normal">
MAYBE-MST-B(<i class="emphasis">G</i>, <i class="emphasis">w</i>)
1  <i class="emphasis">T</i> <span class="unicode">&larr;</span> <span class="unicode">&Oslash;</span>
2  <b class="bold">for</b> each edge <i class="emphasis">e</i>, taken in arbitrary order
3      <b class="bold">do if</b> <i class="emphasis">T</i> <span class="unicode">&cup;</span> {<i class="emphasis">e</i>} has no cycles
4            <b class="bold">then</b> <i class="emphasis">T</i> <span class="unicode">&larr;</span> <i class="emphasis">T</i> <span class="unicode">&cup;</span> <i class="emphasis">e</i>
5  <b class="bold">return</b> <i class="emphasis">T</i>
</pre>
</li>
<li class="listitem">
<pre class="literallayout-normal">
MAYBE-MST-C(<i class="emphasis">G</i>, <i class="emphasis">w</i>)
1  <i class="emphasis">T</i> <span class="unicode">&larr;</span> <span class="unicode">&Oslash;</span>
2  <b class="bold">for</b> each edge <i class="emphasis">e</i>, taken in arbitrary order
3     <b class="bold">do</b> <i class="emphasis">T</i> <span class="unicode">&larr;</span> <i class="emphasis">T</i> <span class="unicode">&cup;</span> {<i class="emphasis">e</i>}
4       <b class="bold">if</b> <i class="emphasis">T</i> has a cycle <i class="emphasis">c</i>
5         <b class="bold">then</b> let <i class="emphasis">e</i><span class="unicode">&prime;</span> be the maximum-weight edge on <i class="emphasis">c</i>
6              <i class="emphasis">T</i> <span class="unicode">&larr;</span> <i class="emphasis">T</i> - {<i class="emphasis">e</i><span class="unicode">&prime;</span>}
7  <b class="bold">return</b> <i class="emphasis">T</i>
</pre>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0136.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0138.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
