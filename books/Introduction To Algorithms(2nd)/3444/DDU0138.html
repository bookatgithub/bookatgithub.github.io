<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Chapter notes</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0137.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0139.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch23"></a>
<div class="section">
<h2 class="first-section-title">
<a name="1746"></a><a name="ch23lev1sec3"></a>Chapter notes</h2>
<p class="first-para">
<a href="DDU0259.html#3847" target="_parent" class="chapterjump">Tarjan [292]</a> surveys the minimum-spanning-tree problem and provides excellent advanced material. A history of the minimum-spanning-tree problem has been written by <a href="DDU0259.html#3686" target="_parent" class="chapterjump">Graham and Hell [131]</a>.</p>
<p class="para">Tarjan attributes the first minimum-spanning-tree algorithm to a 1926 paper by O. Boruvka. Boruvka's algorithm consists of running <i class="emphasis">O</i>(lg <i class="emphasis">V</i>) iterations of the procedure MST-REDUCE described in <a href="DDU0137.html#1740" target="_parent" class="chapterjump">Problem 23-2</a>. Kruskal's algorithm was reported by <a href="DDU0259.html#3750" target="_parent" class="chapterjump">Kruskal [195]</a> in 1956. The algorithm commonly known as Prim's algorithm was indeed invented by <a href="DDU0259.html#3805" target="_parent" class="chapterjump">Prim [250]</a>, but it was also invented earlier by V. Jarn<span class="unicode">&iacute;</span>k in 1930.<a name="1747"></a><a name="IDX-579"></a>
</p>
<p class="para">The reason why greedy algorithms are effective at finding minimum spanning trees is that the set of forests of a graph forms a graphic matroid. (See <a href="DDU0097.html#1215" target="_parent" class="chapterjump">Section 16.4</a>.)</p>
<p class="para">When |<i class="emphasis">E</i>| = <span class="unicode">&#8486;</span>(<i class="emphasis">V</i> lg <i class="emphasis">V</i>), Prim's algorithm, implemented with Fibonacci heaps runs in <i class="emphasis">O</i>(<i class="emphasis">E</i>) time. For sparser graphs, using a combination of the ideas from Prim's algorithm, Kruskal's algorithm, and Boruvka's algorithm, together with advanced data structures, <a href="DDU0259.html#3653" target="_parent" class="chapterjump">Fredman and Tarjan [98]</a> give an algorithm that runs in <i class="emphasis">O</i>(<i class="emphasis">E</i> lg* <i class="emphasis">V</i>) time. <a href="DDU0259.html#3657" target="_parent" class="chapterjump">Gabow, Galil, Spencer, and Tarjan [102]</a> improved this algorithm to run in <i class="emphasis">O</i>(<i class="emphasis">E</i> lg lg* <i class="emphasis">V</i>) time. <a href="DDU0259.html#3609" target="_parent" class="chapterjump">Chazelle [53]</a> gives an algorithm that runs in <span class="inlinemediaobject"><img src="images/fig601_01.jpg" height="12" width="66" alt="" border="0"></span> time, where <span class="inlinemediaobject"><img src="images/fig601_02.jpg" height="12" width="38" alt="" border="0"></span> is the functional inverse of Ackermann's function. (See the <a href="DDU0127.html#1573" target="_parent" class="chapterjump">chapter notes for Chapter 21</a> for a brief discussion of Ackermann's function and its inverse.) Unlike previous minimum-spanning-tree algorithms, Chazelle's algorithm does not follow the greedy method.</p>
<p class="para">A related problem is <b class="bold"><i class="emphasis">spanning tree verification</i></b>, in which we are given a graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) and a tree <i class="emphasis">T</i> <span class="unicode">&sube;</span> <i class="emphasis">E</i>, and we wish to determine whether <i class="emphasis">T</i> is a minimum spanning tree of <i class="emphasis">G</i>. <a href="DDU0259.html#3732" target="_parent" class="chapterjump">King [177]</a> gives a linear-time algorithm for spanning tree verification, building on earlier work of <a href="DDU0259.html#3743" target="_parent" class="chapterjump">Koml<span class="unicode">&oacute;</span>s [188]</a> and <a href="DDU0259.html#3632" target="_parent" class="chapterjump">Dixon, Rauch, and Tarjan [77]</a>.</p>
<p class="para">The above algorithms are all deterministic and fall into the comparison-based model described in <a href="DDU0047.html#514" target="_parent" class="chapterjump">Chapter 8</a>. <a href="DDU0259.html#3724" target="_parent" class="chapterjump">Karger, Klein, and Tarjan [169]</a> give a randomized minimum-spanning-tree algorithm that runs in <i class="emphasis">O</i>(<i class="emphasis">V</i> + <i class="emphasis">E</i>) expected time. This algorithm uses recursion in a manner similar to the linear-time selection algorithm in <a href="DDU0055.html#592" target="_parent" class="chapterjump">Section 9.3</a>: a recursive call on an auxiliary problem identifies a subset of the edges <i class="emphasis">E</i><span class="unicode">&prime;</span> that cannot be in any minimum spanning tree. Another recursive call on <i class="emphasis">E</i> - <i class="emphasis">E</i><span class="unicode">&prime;</span> then finds the minimum spanning tree. The algorithm also uses ideas from Boruvka's algorithm and King's algorithm for spanning tree verification.</p>
<p class="last-para">
<a href="DDU0259.html#3655" target="_parent" class="chapterjump">Fredman and Willard [100]</a> showed how to find a minimum spanning tree in <i class="emphasis">O</i>(<i class="emphasis">V</i> + <i class="emphasis">E</i>) time using a deterministic algorithm that is not comparison based. Their algorithm assumes that the data are <i class="emphasis">b</i>-bit integers and that the computer memory consists of addressable <i class="emphasis">b</i>-bit words.</p>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0137.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0139.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
