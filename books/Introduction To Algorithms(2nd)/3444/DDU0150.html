<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>24.3 Dijkstra's algorithm</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0149.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0151.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch24"></a>
<div class="section">
<h2 class="first-section-title">
<a name="1788"></a><a name="ch24lev1sec3"></a><span class="section-titlelabel">24.3 </span>Dijkstra's algorithm</h2>
<p class="first-para">Dijkstra's algorithm solves the single-source shortest-paths problem on a weighted, directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) for the case in which all edge weights are nonnegative. In this section, therefore, we assume that <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&ge;</span> 0 for each edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>. As we shall see, with a good implementation, the running time of Dijkstra's algorithm is lower than that of the Bellman-Ford algorithm.</p>
<p class="para">Dijkstra's algorithm maintains a set <i class="emphasis">S</i> of vertices whose final shortest-path weights from the source <i class="emphasis">s</i> have already been determined. The algorithm repeatedly selects the vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> - <i class="emphasis">S</i> with the minimum shortest-path estimate, adds <i class="emphasis">u</i> to <i class="emphasis">S</i>, and relaxes all edges leaving <i class="emphasis">u</i>. In the following implementation, we use a min-priority queue <i class="emphasis">Q</i> of vertices, keyed by their <i class="emphasis">d</i> values.</p>
<div class="informalexample">
<pre class="literallayout">
DIJKSTRA(<i class="emphasis">G</i>, <i class="emphasis">w</i>, <i class="emphasis">s</i>)
1  INITIALIZE-SINGLE-SOURCE(<i class="emphasis">G</i>, <i class="emphasis">s</i>)
2  <i class="emphasis">S</i> <span class="unicode">&larr;</span> <span class="unicode">&Oslash;</span>
3  <i class="emphasis">Q</i> <span class="unicode">&larr;</span> <i class="emphasis">V</i>[<i class="emphasis">G</i>]
4  <b class="bold">while</b> <i class="emphasis">Q</i> <span class="unicode">&ne;</span> <span class="unicode">&Oslash;</span>
5      <b class="bold">do</b> <i class="emphasis">u</i> <span class="unicode">&larr;</span> EXTRACT-MIN(<i class="emphasis">Q</i>)
6         <i class="emphasis">S</i> <span class="unicode">&larr;</span> <i class="emphasis">S</i> <span class="unicode">&cup;</span>{<i class="emphasis">u</i>}
7         <b class="bold">for</b> each vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">Adj</i>[<i class="emphasis">u</i>]
8             <b class="bold">do</b> RELAX(<i class="emphasis">u</i>, <i class="emphasis">v</i>, <i class="emphasis">w</i>)
</pre>
</div>
<p class="para">Dijkstra's algorithm relaxes edges as shown in <a class="internaljump" href="#ch24fig06">Figure 24.6</a>. Line 1 performs the usual initialization of <i class="emphasis">d</i> and <span class="unicode">&pi;</span> values, and line 2 initializes the set <i class="emphasis">S</i> to the empty set. The algorithm maintains the invariant that <i class="emphasis">Q</i> = <i class="emphasis">V</i> - <i class="emphasis">S</i> at the start of each iteration of the <b class="bold">while</b> loop of lines 4<span class="unicode">-</span>8. Line 3 initializes the min-priority queue <i class="emphasis">Q</i> to contain all the vertices in <i class="emphasis">V</i> ; since <i class="emphasis">S</i> = <span class="unicode">&Oslash;</span> at that time, the invariant is true after line 3. Each time through the <b class="bold">while</b> loop of lines 4<span class="unicode">-</span>8, a vertex <i class="emphasis">u</i> is extracted from <i class="emphasis">Q</i> = <i class="emphasis">V</i> - <i class="emphasis">S</i> and added to set <i class="emphasis">S</i>, thereby maintaining the invariant. (The first time through this loop, <i class="emphasis">u</i> = <i class="emphasis">s</i>.) Vertex <i class="emphasis">u</i>, therefore, has the smallest shortest-path <a name="1789"></a><a name="IDX-596"></a>estimate of any vertex in <i class="emphasis">V</i> - <i class="emphasis">S</i>. Then, lines 7<span class="unicode">-</span>8 relax each edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) leaving <i class="emphasis">u</i>, thus updating the estimate <i class="emphasis">d</i>[<i class="emphasis">v</i>] and the predecessor <span class="unicode">&pi;</span>[<i class="emphasis">v</i>] if the shortest path to <i class="emphasis">v</i> can be improved by going through <i class="emphasis">u</i>. Observe that vertices are never inserted into <i class="emphasis">Q</i> after line 3 and that each vertex is extracted from <i class="emphasis">Q</i> and added to <i class="emphasis">S</i> exactly once, so that the <b class="bold">while</b> loop of lines 4<span class="unicode">-</span>8 iterates exactly |<i class="emphasis">V</i>| times.</p>
<div class="figure">
<a name="1790"></a><a name="ch24fig06"></a><span class="figuremediaobject"><a href="images/fig618%5F01%5F0%2Ejpg" NAME="IMG_713" target="_parent"><img src="images/fig618_01.jpg" height="172" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 24.6: </span>The execution of Dijkstra's algorithm. The source s is the leftmost vertex. The shortest-path estimates are shown within the vertices, and shaded edges indicate predecessor values. Black vertices are in the set <i class="emphasis">S</i>, and white vertices are in the min-priority queue <i class="emphasis">Q</i> = <i class="emphasis">V</i> - <i class="emphasis">S</i>. (a) The situation just before the first iteration of the while loop of lines 4<span class="unicode">-</span>8. The shaded vertex has the minimum <i class="emphasis">d</i> value and is chosen as vertex <i class="emphasis">u</i> in line 5. (b)-(f) The situation after each successive iteration of the while loop. The shaded vertex in each part is chosen as vertex <i class="emphasis">u</i> in line 5 of the next iteration. The <i class="emphasis">d</i> and <span class="unicode">&pi;</span> values shown in part (f) are the final values.</span>
</div>
<p class="para">Because Dijkstra's algorithm always chooses the "lightest" or "closest" vertex in <i class="emphasis">V</i> - <i class="emphasis">S</i> to add to set <i class="emphasis">S</i>, we say that it uses a greedy strategy. Greedy strategies are presented in detail in <a href="DDU0093.html#1143" target="_parent" class="chapterjump">Chapter 16</a>, but you need not have read that chapter to understand Dijkstra's algorithm. Greedy strategies do not always yield optimal results in general, but as the following theorem and its corollary show, Dijkstra's algorithm does indeed compute shortest paths. The key is to show that each time a vertex <i class="emphasis">u</i> is added to set <i class="emphasis">S</i>, we have <i class="emphasis">d</i>[<i class="emphasis">u</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>).<a name="1791"></a><a name="IDX-597"></a>
</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 24.6: </span>(Correctness of Dijkstra's algorithm)</span><a name="1792"></a><a name="ch24ex16"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Dijkstra's algorithm, run on a weighted, directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) with non-negative weight function <i class="emphasis">w</i> and source <i class="emphasis">s</i>, terminates with <i class="emphasis">d</i>[<i class="emphasis">u</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) for all vertices <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> We use the following loop invariant:</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">At the start of each iteration of the <b class="bold">while</b> loop of lines 4<span class="unicode">-</span>8, <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) for each vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">S</i>.</p>
</li>
</ul>
<p class="para">It suffices to show for each vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, we have <i class="emphasis">d</i>[<i class="emphasis">u</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) at the time when <i class="emphasis">u</i> is added to set <i class="emphasis">S</i>. Once we show that <i class="emphasis">d</i>[<i class="emphasis">u</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>), we rely on the upper-bound property to show that the equality holds at all times thereafter.</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">
<b class="bold">Initialization:</b> Initially, <i class="emphasis">S</i> = <span class="unicode">&Oslash;</span>, and so the invariant is trivially true.</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">Maintenance:</b> We wish to show that in each iteration, <i class="emphasis">d</i>[<i class="emphasis">u</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) for the vertex added to set <i class="emphasis">S</i>. For the purpose of contradiction, let <i class="emphasis">u</i> be the first vertex for which <i class="emphasis">d</i>[<i class="emphasis">u</i>] <span class="unicode">&ne;</span> <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) when it is added to set <i class="emphasis">S</i>. We shall focus our attention on the situation at the beginning of the iteration of the <b class="bold">while</b> loop in which <i class="emphasis">u</i> is added to <i class="emphasis">S</i> and derive the contradiction that <i class="emphasis">d</i>[<i class="emphasis">u</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) at that time by examining a shortest path from <i class="emphasis">s</i> to <i class="emphasis">u</i>. We must have <i class="emphasis">u</i> <span class="unicode">&ne;</span> <i class="emphasis">s</i> because <i class="emphasis">s</i> is the first vertex added to set <i class="emphasis">S</i> and <i class="emphasis">d</i>[<i class="emphasis">s</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">s</i>) = 0 at that time. Because <i class="emphasis">u</i> <span class="unicode">&ne;</span> <i class="emphasis">s</i>, we also have that <i class="emphasis">S</i> <span class="unicode">&ne;</span> <span class="unicode">&Oslash;</span> just before <i class="emphasis">u</i> is added to <i class="emphasis">S</i>. There must be some path from <i class="emphasis">s</i> to <i class="emphasis">u</i>, for otherwise <i class="emphasis">d</i>[<i class="emphasis">u</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) = <span class="unicode">&infin;</span> by the no-path property, which would violate our assumption that <i class="emphasis">d</i>[<i class="emphasis">u</i>] <span class="unicode">&ne;</span> <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>). Because there is at least one path, there is a shortest path <i class="emphasis">p</i> from <i class="emphasis">s</i> to <i class="emphasis">u</i>. Prior to adding <i class="emphasis">u</i> to <i class="emphasis">S</i>, path <i class="emphasis">p</i> connects a vertex in <i class="emphasis">S</i>, namely <i class="emphasis">s</i>, to a vertex in <i class="emphasis">V</i> - <i class="emphasis">S</i>, namely <i class="emphasis">u</i>. Let us consider the first vertex <i class="emphasis">y</i> along <i class="emphasis">p</i> such that <i class="emphasis">y</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> - <i class="emphasis">S</i>, and let <i class="emphasis">x</i> <span class="unicode">&isin;</span> <i class="emphasis">S</i> be <i class="emphasis">y</i>'s predecessor. Thus, as shown in <a class="internaljump" href="#ch24fig07">Figure 24.7</a>, path <i class="emphasis">p</i> can be decomposed as <span class="inlinemediaobject"><img src="images/fig619_03.jpg" height="14" width="76" alt="" border="0"></span>. (Either of paths <i class="emphasis">p</i><sub>1</sub> or <i class="emphasis">p</i><sub>2</sub> may have no edges.)</p>
<p class="figure">
<a name="1793"></a><a name="ch24fig07"></a><span class="figuremediaobject"><img src="images/fig619_02.jpg" height="151" width="315" alt="" border="0"></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 24.7: </span>The proof of Theorem 24.6. Set <i class="emphasis">S</i> is nonempty just before vertex <i class="emphasis">u</i> is added to it. A shortest path <i class="emphasis">p</i> from source <i class="emphasis">s</i> to vertex <i class="emphasis">u</i> can be decomposed into s <span class="inlinemediaobject"><img src="images/fig619_01.jpg" height="12" width="70" alt="" border="0"></span>, where <i class="emphasis">y</i> is the first vertex on the path that is not in <i class="emphasis">S</i> and <i class="emphasis">x</i> <span class="unicode">&isin;</span> <i class="emphasis">S</i> immediately precedes <i class="emphasis">y</i>. Vertices <i class="emphasis">x</i> and <i class="emphasis">y</i> are distinct, but we may have <i class="emphasis">s</i> = <i class="emphasis">x</i> or <i class="emphasis">y</i> = <i class="emphasis">u</i>. Path <i class="emphasis">p</i><sub>2</sub> may or may not reenter set <i class="emphasis">S</i>.</span>
</p>
<a name="1794"></a><a name="IDX-598"></a>
<p class="para">We claim that <i class="emphasis">d</i>[<i class="emphasis">y</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">y</i>) when <i class="emphasis">u</i> is added to <i class="emphasis">S</i>. To prove this claim, observe that <i class="emphasis">x</i> <span class="unicode">&isin;</span> <i class="emphasis">S</i>. Then, because <i class="emphasis">u</i> is chosen as the first vertex for which <i class="emphasis">d</i>[<i class="emphasis">u</i>] <span class="unicode">&ne;</span> <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) when it is added to <i class="emphasis">S</i>, we had <i class="emphasis">d</i>[<i class="emphasis">x</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">x</i>) when <i class="emphasis">x</i> was added to <i class="emphasis">S</i>. Edge (<i class="emphasis">x</i>, <i class="emphasis">y</i>) was relaxed at that time, so the claim follows from the convergence property.</p>
<p class="para">We can now obtain a contradiction to prove that <i class="emphasis">d</i>[<i class="emphasis">u</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>). Because <i class="emphasis">y</i> occurs before <i class="emphasis">u</i> on a shortest path from <i class="emphasis">s</i> to <i class="emphasis">u</i> and all edge weights are nonnegative (notably those on path <i class="emphasis">p</i><sub>2</sub>), we have <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">y</i>) <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>), and thus</p>
<div class="equation">
<a name="1795"></a><a name="ch24eq02"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(24.2)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig620_01.jpg" height="57" width="305" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">But because both vertices <i class="emphasis">u</i> and <i class="emphasis">y</i> were in <i class="emphasis">V</i> - <i class="emphasis">S</i> when <i class="emphasis">u</i> was chosen in line 5, we have <i class="emphasis">d</i>[<i class="emphasis">u</i>] <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">y</i>]. Thus, the two inequalities in (<a class="internaljump" href="#ch24eq02">24.2</a>) are in fact equalities, giving</p>
<p class="para">
<i class="emphasis">d</i>[<i class="emphasis">y</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">y</i>) = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) = <i class="emphasis">d</i>[<i class="emphasis">u</i>].</p>
<p class="last-para">Consequently, <i class="emphasis">d</i>[<i class="emphasis">u</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>), which contradicts our choice of <i class="emphasis">u</i>. We conclude that <i class="emphasis">d</i>[<i class="emphasis">u</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) when <i class="emphasis">u</i> is added to <i class="emphasis">S</i>, and that this equality is maintained at all times thereafter.</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">Termination:</b> At termination, <i class="emphasis">Q</i> = <span class="unicode">&Oslash;</span> which, along with our earlier invariant that <i class="emphasis">Q</i> = <i class="emphasis">V</i> - <i class="emphasis">S</i>, implies that <i class="emphasis">S</i> = <i class="emphasis">V</i>. Thus, <i class="emphasis">d</i>[<i class="emphasis">u</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) for all vertices <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>.</p>
</li>
</ul>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Corollary 24.7</span></span><a name="1796"></a><a name="ch24ex17"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">If we run Dijkstra's algorithm on a weighted, directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) with nonnegative weight function <i class="emphasis">w</i> and source <i class="emphasis">s</i>, then at termination, the predecessor subgraph <i class="emphasis">G</i><sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub> is a shortest-paths tree rooted at <i class="emphasis">s</i>.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Immediate from <a class="internaljump" href="#ch24ex16">Theorem 24.6</a> and the predecessor-subgraph property.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="section">
<h4 class="sect4-title">
<a name="1797"></a><a name="ch24lev3sec9"></a>Analysis</h4>
<p class="first-para">How fast is Dijkstra's algorithm? It maintains the min-priority queue <i class="emphasis">Q</i> by calling three priority-queue operations: INSERT (implicit in line 3), EXTRACT-MIN (line 5), and DECREASE-KEY (implicit in RELAX, which is called in line 8). INSERT is invoked once per vertex, as is EXTRACT-MIN. Because each vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> is added to set <i class="emphasis">S</i> exactly once, each edge in the adjacency list <i class="emphasis">Adj</i>[<i class="emphasis">v</i>] is examined in the <b class="bold">for</b> loop of lines 7<span class="unicode">-</span>8 exactly once during the course of the algorithm. Since the total number of edges in all the adjacency lists is |<i class="emphasis">E</i>|, there are a total of |<i class="emphasis">E</i>| iterations of this <b class="bold">for</b> loop, and thus a total of at most |<i class="emphasis">E</i>| DECREASE-KEY operations. (Observe once again that we are using aggregate analysis.)<a name="1798"></a><a name="IDX-599"></a>
</p>
<p class="para">The running time of Dijkstra's algorithm depends on how the min-priority queue is implemented. Consider first the case in which we maintain the min-priority queue by taking advantage of the vertices being numbered 1 to |<i class="emphasis">V</i>|. We simply store <i class="emphasis">d</i>[<i class="emphasis">v</i>] in the <i class="emphasis">v</i>th entry of an array. Each INSERT and DECREASE-KEY operation takes <i class="emphasis">O</i>(1) time, and each EXTRACT-MIN operation takes <i class="emphasis">O</i>(<i class="emphasis">V</i>) time (since we have to search through the entire array), for a total time of <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>2</sup>+<i class="emphasis">E</i>) = <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>2</sup>).</p>
<p class="para">If the graph is sufficiently sparse<span class="unicode">-</span>in particular, <i class="emphasis">E</i> = <i class="emphasis">o</i>(<i class="emphasis">V</i><sup>2</sup>/ lg <i class="emphasis">V</i>)<span class="unicode">-</span>it is practical to implement the min-priority queue with a binary min-heap. (As discussed in <a href="DDU0040.html#425" target="_parent" class="chapterjump">Section 6.5</a>, an important implementation detail is that vertices and corresponding heap elements must maintain handles to each other.) Each EXTRACT-MIN operation then takes time <i class="emphasis">O</i>(lg <i class="emphasis">V</i>). As before, there are |<i class="emphasis">V</i>| such operations. The time to build the binary min-heap is <i class="emphasis">O</i>(<i class="emphasis">V</i>). Each DECREASE-KEY operation takes time <i class="emphasis">O</i>(lg <i class="emphasis">V</i>), and there are still at most |<i class="emphasis">E</i>| such operations. The total running time is therefore <i class="emphasis">O</i>((<i class="emphasis">V</i> + <i class="emphasis">E</i>) lg <i class="emphasis">V</i>), which is <i class="emphasis">O</i>(<i class="emphasis">E</i> lg <i class="emphasis">V</i>) if all vertices are reachable from the source. This running time is an improvement over the straightforward <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>2</sup>)-time implementation if <i class="emphasis">E</i> = <i class="emphasis">o</i>(<i class="emphasis">V</i><sup>2</sup>/ lg <i class="emphasis">V</i>).</p>
<p class="para">We can in fact achieve a running time of <i class="emphasis">O</i>(<i class="emphasis">V</i> lg <i class="emphasis">V</i> + <i class="emphasis">E</i>) by implementing the min-priority queue with a Fibonacci heap (see <a href="DDU0117.html#1439" target="_parent" class="chapterjump">Chapter 20</a>). The amortized cost of each of the |<i class="emphasis">V</i>| EXTRACT-MIN operations is <i class="emphasis">O</i>(lg <i class="emphasis">V</i>), and each DECREASE-KEY call, of which there are at most |<i class="emphasis">E</i>|, takes only <i class="emphasis">O</i>(1) amortized time. Historically, the development of Fibonacci heaps was motivated by the observation that in Dijkstra's algorithm there are typically many more DECREASE-KEY calls than EXTRACT-MIN calls, so any method of reducing the amortized time of each DECREASE-KEY operation to <i class="emphasis">o</i>(lg <i class="emphasis">V</i>) without increasing the amortized time of EXTRACT-MIN would yield an asymptotically faster implementation than with binary heaps.</p>
<p class="para">Dijkstra's algorithm bears some similarity to both breadth-first search (see <a href="DDU0130.html#1596" target="_parent" class="chapterjump">Section 22.2</a>) and Prim's algorithm for computing minimum spanning trees (see <a href="DDU0137.html#1718" target="_parent" class="chapterjump">Section 23.2</a>). It is like breadth-first search in that set <i class="emphasis">S</i> corresponds to the set of black vertices in a breadth-first search; just as vertices in <i class="emphasis">S</i> have their final shortest-path weights, so do black vertices in a breadth-first search have their correct breadth-first distances. Dijkstra's algorithm is like Prim's algorithm in that both algorithms use a min-priority queue to find the "lightest" vertex outside a given set (the set <i class="emphasis">S</i> in Dijkstra's algorithm and the tree being grown in Prim's algorithm), add this vertex into the set, and adjust the weights of the remaining vertices outside the set accordingly.<a name="1799"></a><a name="IDX-600"></a>
</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 24.3-1</span></span><a name="1800"></a><a name="ch24ex18"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Run Dijkstra's algorithm on the directed graph of <a href="DDU0144.html#1762" target="_parent" class="chapterjump">Figure 24.2</a>, first using vertex <i class="emphasis">s</i> as the source and then using vertex <i class="emphasis">z</i> as the source. In the style of <a class="internaljump" href="#ch24fig06">Figure 24.6</a>, show the <i class="emphasis">d</i> and <span class="unicode">&pi;</span> values and the vertices in set <i class="emphasis">S</i> after each iteration of the <b class="bold">while</b> loop.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 24.3-2</span></span><a name="1801"></a><a name="ch24ex19"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Give a simple example of a directed graph with negative-weight edges for which Dijkstra's algorithm produces incorrect answers. Why doesn't the proof of <a class="internaljump" href="#ch24ex16">Theorem 24.6</a> go through when negative-weight edges are allowed?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 24.3-3</span></span><a name="1802"></a><a name="ch24ex20"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose we change line 4 of Dijkstra's algorithm to the following.</p>
<p class="para">4 <b class="bold">while</b> |<i class="emphasis">Q</i>| <span class="unicode">&gt;</span> 1</p>
<p class="last-para">This change causes the <b class="bold">while</b> loop to execute |<i class="emphasis">V</i> | - 1 times instead of |<i class="emphasis">V</i> | times. Is this proposed algorithm correct?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 24.3-4</span></span><a name="1803"></a><a name="ch24ex21"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">We are given a directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) on which each edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i> has an associated value <i class="emphasis">r</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>), which is a real number in the range 0 <span class="unicode">&le;</span> <i class="emphasis">r</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&le;</span> 1 that represents the reliability of a communication channel from vertex <i class="emphasis">u</i> to vertex <i class="emphasis">v</i>. We interpret <i class="emphasis">r</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) as the probability that the channel from <i class="emphasis">u</i> to <i class="emphasis">v</i> will not fail, and we assume that these probabilities are independent. Give an efficient algorithm to find the most reliable path between two given vertices.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 24.3-5</span></span><a name="1804"></a><a name="ch24ex22"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a weighted, directed graph with weight function <i class="emphasis">w</i> : <i class="emphasis">E</i> <span class="unicode">&rarr;</span> {1, 2, ..., <i class="emphasis">W</i> } for some positive integer <i class="emphasis">W</i> , and assume that no two vertices have the same shortest-path weights from source vertex <i class="emphasis">s</i>. Now suppose that we define an unweighted, directed graph <i class="emphasis">G</i>' = (<i class="emphasis">V</i> <span class="unicode">&cup;</span> <i class="emphasis">V</i>', <i class="emphasis">E</i>') by replacing each edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i> with <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) unit-weight edges in series. How many vertices does <i class="emphasis">G</i>' have? Now suppose that we run a breadth-first search on <i class="emphasis">G</i>'. Show that the order in which vertices in <i class="emphasis">V</i> are colored black in the breadth-first search of <i class="emphasis">G</i>' is the same as the order in which the vertices of <i class="emphasis">V</i> are extracted from the priority queue in line 5 of DIJKSTRA when run on <i class="emphasis">G</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 24.3-6</span></span><a name="1805"></a><a name="ch24ex23"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a weighted, directed graph with weight function <i class="emphasis">w</i> : <i class="emphasis">E</i> <span class="unicode">&rarr;</span> {0, 1, ..., <i class="emphasis">W</i> } for some nonnegative integer <i class="emphasis">W</i> . Modify Dijkstra's algorithm to compute the shortest paths from a given source vertex <i class="emphasis">s</i> in <i class="emphasis">O</i>(<i class="emphasis">W V</i> + <i class="emphasis">E</i>) time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1806"></a><a name="IDX-601"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 24.3-7</span></span><a name="1807"></a><a name="ch24ex24"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Modify your algorithm from <a class="internaljump" href="#ch24ex23">Exercise 24.3-6</a> to run in <i class="emphasis">O</i>((<i class="emphasis">V</i> + <i class="emphasis">E</i>) lg <i class="emphasis">W</i> ) time. (<i class="emphasis">Hint:</i> How many distinct shortest-path estimates can there be in <i class="emphasis">V</i> - <i class="emphasis">S</i> at any point in time?)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 24.3-8</span></span><a name="1808"></a><a name="ch24ex25"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that we are given a weighted, directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) in which edges that leave the source vertex <i class="emphasis">s</i> may have negative weights, all other edge weights are nonnegative, and there are no negative-weight cycles. Argue that Dijkstra's algorithm correctly finds shortest paths from <i class="emphasis">s</i> in this graph.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0149.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0151.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
