<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>24.5 Proofs of shortest-paths properties</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0151.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0153.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch24"></a>
<div class="section">
<h2 class="first-section-title">
<a name="1836"></a><a name="ch24lev1sec5"></a><span class="section-titlelabel">24.5 </span>Proofs of shortest-paths properties</h2>
<p class="first-para">Throughout this chapter, our correctness arguments have relied on the triangle inequality, upper-bound property, no-path property, convergence property, path-relaxation property, and predecessor-subgraph property. We stated these properties without proof at the beginning of this chapter. In this section, we prove them.</p>
<div class="section">
<h4 class="sect4-title">
<a name="1837"></a><a name="ch24lev3sec14"></a>The triangle inequality</h4>
<p class="first-para">In studying breadth-first search (<a href="DDU0130.html#1596" target="_parent" class="chapterjump">Section 22.2</a>), we proved as <a href="DDU0130.html#1604" target="_parent" class="chapterjump">Lemma 22.1</a> a simple property of shortest distances in unweighted graphs. The triangle inequality generalizes the property to weighted graphs.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 24.10: </span>(Triangle inequality)</span><a name="1838"></a><a name="ch24ex40"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a weighted, directed graph with weight function <i class="emphasis">w</i> : <i class="emphasis">E</i> <span class="unicode">&rarr;</span> <b class="bold">R</b> and source vertex <i class="emphasis">s</i>. Then, for all edges (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>, we have</p>
<p class="para">
<i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) + <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>).<a name="1839"></a><a name="IDX-608"></a>
</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> Suppose that there is a shortest path <i class="emphasis">p</i> from source <i class="emphasis">s</i> to vertex <i class="emphasis">v</i>. Then <i class="emphasis">p</i> has no more weight than any other path from <i class="emphasis">s</i> to <i class="emphasis">v</i>. Specifically, path <i class="emphasis">p</i> has no more weight than the particular path that takes a shortest path from source <i class="emphasis">s</i> to vertex <i class="emphasis">u</i> and then takes edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>).</p>
<p class="last-para">
<a class="internaljump" href="#ch24ex50">Exercise 24.5-3</a> asks you to handle the case in which there is no shortest path from <i class="emphasis">s</i> to <i class="emphasis">v</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1840"></a><a name="ch24lev3sec15"></a>Effects of relaxation on shortest-path estimates</h4>
<p class="first-para">The next group of lemmas describes how shortest-path estimates are affected when we execute a sequence of relaxation steps on the edges of a weighted, directed graph that has been initialized by INITIALIZE-SINGLE-SOURCE.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 24.11: </span>(Upper-bound property)</span><a name="1841"></a><a name="ch24ex41"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a weighted, directed graph with weight function <i class="emphasis">w</i> : <i class="emphasis">E</i> <span class="unicode">&rarr;</span> <b class="bold">R</b>. Let <i class="emphasis">s</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> be the source vertex, and let the graph be initialized by INITIALIZE-SINGLE-SOURCE(<i class="emphasis">G</i>, <i class="emphasis">s</i>). Then, <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&ge;</span> <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) for all <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> , and this invariant is maintained over any sequence of relaxation steps on the edges of <i class="emphasis">G</i>. Moreover, once <i class="emphasis">d</i>[<i class="emphasis">v</i>] achieves its lower bound <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>), it never changes.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> We prove the invariant <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&ge;</span> <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) for all vertices <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> by induction over the number of relaxation steps.</p>
<p class="para">For the basis, <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&ge;</span> <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) is certainly true after initialization, since <i class="emphasis">d</i>[<i class="emphasis">s</i>] = 0 <span class="unicode">&ge;</span> <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">s</i>) (note that <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">s</i>) is -<span class="unicode">&infin;</span> if <i class="emphasis">s</i> is on a negative-weight cycle and 0 otherwise) and <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <span class="unicode">&infin;</span> implies <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&ge;</span> <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) for all <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> - {<i class="emphasis">s</i>}.</p>
<p class="para">For the inductive step, consider the relaxation of an edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>). By the inductive hypothesis, <i class="emphasis">d</i>[<i class="emphasis">x</i>] <span class="unicode">&ge;</span> <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">x</i>) for all <i class="emphasis">x</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> prior to the relaxation. The only <i class="emphasis">d</i> value that may change is <i class="emphasis">d</i>[<i class="emphasis">v</i>]. If it changes, we have and so the invariant is maintained.</p>
<p class="para">
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">d</i>[<i class="emphasis">v</i>]</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">d</i>[<i class="emphasis">u</i>] + <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>)</p>
</td><td class="td" align="left">&nbsp;</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&ge;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) + <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>)</p>
</td><td class="td" align="left">
<p class="table-para">(by inductive hypothesis)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&ge;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>)</p>
</td><td class="td" align="left">
<p class="table-para">(by the triangle inequality).</p>
</td>
</tr>
</tbody>
</table>
</div>
</p>
<p class="last-para">To see that the value of <i class="emphasis">d</i>[<i class="emphasis">v</i>] never changes once <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>), note that having achieved its lower bound, <i class="emphasis">d</i>[<i class="emphasis">v</i>] cannot decrease because we have just shown that <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&ge;</span> <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>), and it cannot increase because relaxation steps do not increase <i class="emphasis">d</i> values.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Corollary 24.12: </span>(No-path property)</span><a name="1842"></a><a name="ch24ex42"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that in a weighted, directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) with weight function <i class="emphasis">w</i> : <i class="emphasis">E</i> <span class="unicode">&rarr;</span> <b class="bold">R</b>, no path connects a source vertex <i class="emphasis">s</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> to a given vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>. Then, after the graph is initialized by INITIALIZE-SINGLE-SOURCE(<i class="emphasis">G</i>, <i class="emphasis">s</i>), we <a name="1843"></a><a name="IDX-609"></a>have <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) = <span class="unicode">&infin;</span>, and this equality is maintained as an invariant over any sequence of relaxation steps on the edges of <i class="emphasis">G</i>.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> By the upper-bound property, we always have <span class="unicode">&infin;</span> = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i>], and thus <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <span class="unicode">&infin;</span> = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 24.13</span></span><a name="1844"></a><a name="ch24ex43"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a weighted, directed graph with weight function <i class="emphasis">w</i> : <i class="emphasis">E</i> <span class="unicode">&rarr;</span> <b class="bold">R</b>, and let (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>. Then, immediately after relaxing edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) by executing RELAX(<i class="emphasis">u</i>, <i class="emphasis">v</i>, <i class="emphasis">w</i>), we have <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">u</i>] + <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>).</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> If, just prior to relaxing edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>), we have <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&gt;</span> <i class="emphasis">d</i>[<i class="emphasis">u</i>] + <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>), then <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <i class="emphasis">d</i>[<i class="emphasis">u</i>] + <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) afterward. If, instead, <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">u</i>] + <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) just before the relaxation, then neither <i class="emphasis">d</i>[<i class="emphasis">u</i>] nor <i class="emphasis">d</i>[<i class="emphasis">v</i>] changes, and so <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">u</i>] + <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) afterward.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 24.14: </span>(Convergence property)</span><a name="1845"></a><a name="ch24ex44"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a weighted, directed graph with weight function <i class="emphasis">w</i> : <i class="emphasis">E</i> <span class="unicode">&rarr;</span> <b class="bold">R</b>, let <i class="emphasis">s</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> be a source vertex, and let <span class="inlinemediaobject"><img src="images/fig631_01.jpg" height="9" width="75" alt="" border="0"></span> be a shortest path in <i class="emphasis">G</i> for some vertices <i class="emphasis">u</i>, <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> . Suppose that <i class="emphasis">G</i> is initialized by INITIALIZE-SINGLE-SOURCE(<i class="emphasis">G</i>, <i class="emphasis">s</i>) and then a sequence of relaxation steps that includes the call RELAX(<i class="emphasis">u</i>, <i class="emphasis">v</i>, <i class="emphasis">w</i>) is executed on the edges of <i class="emphasis">G</i>. If <i class="emphasis">d</i>[<i class="emphasis">u</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) at any time prior to the call, then <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) at all times after the call.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> By the upper-bound property, if <i class="emphasis">d</i>[<i class="emphasis">u</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) at some point prior to relaxing edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>), then this equality holds thereafter. In particular, after relaxing edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>), we have</p>
<p class="para">
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">d</i>[<i class="emphasis">v</i>]</p>
</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&le;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">d</i>[<i class="emphasis">u</i>] + <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>)</p>
</td><td class="td" align="left">
<p class="table-para">(by <a class="internaljump" href="#ch24ex43">Lemma 24.13</a>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) + <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>)</p>
</td><td class="td" align="left">&nbsp;</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>)</p>
</td><td class="td" align="left">
<p class="table-para">(by <a href="DDU0141.html#1755" target="_parent" class="chapterjump">Lemma 24.1</a>).</p>
</td>
</tr>
</tbody>
</table>
</div>
</p>
<p class="last-para">By the upper-bound property, <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&ge;</span> <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>), from which we conclude that <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>), and this equality is maintained thereafter.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 24.15: </span>(Path-relaxation property)</span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a weighted, directed graph with weight function <i class="emphasis">w</i> : <i class="emphasis">E</i> <span class="unicode">&rarr;</span> <b class="bold">R</b>, and let <i class="emphasis">s</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> be a source vertex. Consider any shortest path <i class="emphasis">p</i> = <span class="unicode">&#12296;</span><i class="emphasis">v</i><sub>0</sub>, <i class="emphasis">v</i><sub>1</sub>, ..., <i class="emphasis">v<sub>k</sub></i><span class="unicode">&#12297;</span> from <i class="emphasis">s</i> = <i class="emphasis">v</i><sub>0</sub> to <i class="emphasis">v<sub>k</sub></i>. If <i class="emphasis">G</i> is initialized by INITIALIZE-SINGLE-SOURCE(<i class="emphasis">G</i>, <i class="emphasis">s</i>) and then a sequence of relaxation steps occurs that includes, in order, relaxations of edges (<i class="emphasis">v</i><sub>0</sub>, <i class="emphasis">v</i><sub>1</sub>), (<i class="emphasis">v</i><sub>1</sub>, <i class="emphasis">v</i><sub>2</sub>),..., (<i class="emphasis">v</i><sub><i class="emphasis">k</i>-1</sub>, <i class="emphasis">v<sub>k</sub></i>), then <i class="emphasis">d</i>[<i class="emphasis">v<sub>k</sub></i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v<sub>k</sub></i>) after these relaxations and at all times afterward. This property holds no matter what other edge <a name="1846"></a><a name="IDX-610"></a>relaxations occur, including relaxations that are intermixed with relaxations of the edges of <i class="emphasis">p</i>.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> We show by induction that after the <i class="emphasis">i</i>th edge of path <i class="emphasis">p</i> is relaxed, we have <i class="emphasis">d</i>[<i class="emphasis">v<sub>i</sub></i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v<sub>i</sub></i>). For the basis, <i class="emphasis">i</i> = 0, and before any edges of <i class="emphasis">p</i> have been relaxed, we have from the initialization that <i class="emphasis">d</i>[<i class="emphasis">v</i><sub>0</sub>] = <i class="emphasis">d</i>[<i class="emphasis">s</i>] = 0 = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">s</i>). By the upper-bound property, the value of <i class="emphasis">d</i>[<i class="emphasis">s</i>] never changes after initialization.</p>
<p class="last-para">For the inductive step, we assume that <i class="emphasis">d</i>[<i class="emphasis">v</i><sub><i class="emphasis">i</i>-1</sub>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i><sub><i class="emphasis">i</i>-1</sub>), and we examine the relaxation of edge (<i class="emphasis">v</i><sub><i class="emphasis">i</i>-1</sub>, <i class="emphasis">v<sub>i</sub></i>). By the convergence property, after this relaxation, we have <i class="emphasis">d</i>[<i class="emphasis">v<sub>i</sub></i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v<sub>i</sub></i>), and this equality is maintained at all times thereafter.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1847"></a><a name="ch24lev3sec16"></a>Relaxation and shortest-paths trees</h4>
<p class="first-para">We now show that once a sequence of relaxations has caused the shortest-path estimates to converge to shortest-path weights, the predecessor subgraph <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> induced by the resulting <span class="unicode">&pi;</span> values is a shortest-paths tree for <i class="emphasis">G</i>. We start with the following lemma, which shows that the predecessor subgraph always forms a rooted tree whose root is the source.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 24.16</span></span><a name="1848"></a><a name="ch24ex46"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a weighted, directed graph with weight function <i class="emphasis">w</i> : <i class="emphasis">E</i> <span class="unicode">&rarr;</span> <b class="bold">R</b>, let <i class="emphasis">s</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> be a source vertex, and assume that <i class="emphasis">G</i> contains no negative-weight cycles that are reachable from <i class="emphasis">s</i>. Then, after the graph is initialized by INITIALIZE-SINGLE-SOURCE(<i class="emphasis">G</i>, <i class="emphasis">s</i>), the predecessor subgraph <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> forms a rooted tree with root <i class="emphasis">s</i>, and any sequence of relaxation steps on edges of <i class="emphasis">G</i> maintains this property as an invariant.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> Initially, the only vertex in <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> is the source vertex, and the lemma is trivially true. Consider a predecessor subgraph <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> that arises after a sequence of relaxation steps. We shall first prove that <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> is acyclic. Suppose for the sake of contradiction that some relaxation step creates a cycle in the graph <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> . Let the cycle be <i class="emphasis">c</i> = <span class="unicode">&#12296;</span><i class="emphasis">v</i><sub>0</sub>, <i class="emphasis">v</i><sub>1</sub>,..., <i class="emphasis">v<sub>k</sub></i><span class="unicode">&#12297;</span>, where <i class="emphasis">v<sub>k</sub></i> = <i class="emphasis">v</i><sub>0</sub>. Then, <span class="unicode">&pi;</span>[<i class="emphasis">v<sub>i</sub></i>] = <i class="emphasis">v</i><sub><i class="emphasis">i</i>-1</sub> for <i class="emphasis">i</i> = 1, 2,..., <i class="emphasis">k</i> and, without loss of generality, we can assume that it was the relaxation of edge (<i class="emphasis">v</i><sub><i class="emphasis">k</i>-1</sub>, <i class="emphasis">v<sub>k</sub></i>) that created the cycle in <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>.</p>
<p class="para">We claim that all vertices on cycle <i class="emphasis">c</i> are reachable from the source <i class="emphasis">s</i>. Why? Each vertex on <i class="emphasis">c</i> has a non-NIL predecessor, and so each vertex on <i class="emphasis">c</i> was assigned a finite shortest-path estimate when it was assigned its non-NIL <span class="unicode">&pi;</span> value. By the upper-bound property, each vertex on cycle <i class="emphasis">c</i> has a finite shortest-path weight, which implies that it is reachable from <i class="emphasis">s</i>.</p>
<p class="para">We shall examine the shortest-path estimates on <i class="emphasis">c</i> just prior to the call RELAX(<i class="emphasis">v</i><sub><i class="emphasis">k</i>-1</sub>, <i class="emphasis">v<sub>k</sub></i>, <i class="emphasis">w</i>) and show that <i class="emphasis">c</i> is a negative-weight cycle, thereby contradicting the assumption that <i class="emphasis">G</i> contains no negative-weight cycles that are reachable <a name="1849"></a><a name="IDX-611"></a>from the source. Just before the call, we have <span class="unicode">&pi;</span>[<i class="emphasis">v<sub>i</sub></i>] = <i class="emphasis">v</i><sub><i class="emphasis">i</i>-1</sub> for <i class="emphasis">i</i> = 1, 2,..., <i class="emphasis">k</i> - 1. Thus, for <i class="emphasis">i</i> = 1, 2,..., <i class="emphasis">k</i> - 1, the last update to <i class="emphasis">d</i>[<i class="emphasis">v<sub>i</sub></i>] was by the assignment <i class="emphasis">d</i>[<i class="emphasis">v<sub>i</sub></i>] <span class="unicode">&larr;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i><sub><i class="emphasis">i</i>-1</sub>] + <i class="emphasis">w</i>(<i class="emphasis">v</i><sub><i class="emphasis">i</i>-1</sub>, <i class="emphasis">v<sub>i</sub></i>). If <i class="emphasis">d</i>[<i class="emphasis">v</i><sub><i class="emphasis">i</i>-1</sub>] changed since then, it decreased. Therefore, just before the call RELAX(<i class="emphasis">v</i><sub><i class="emphasis">k</i>-1</sub>, <i class="emphasis">v<sub>k</sub></i>, <i class="emphasis">w</i>), we have</p>
<p class="para">
<div class="equation">
<a name="1850"></a><a name="ch24eq12"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(24.12)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig633_01.jpg" height="16" width="364" alt="" border="0"></span></td>
</tr>
</table>
</div>
</p>
<p class="para">Because <span class="unicode">&pi;</span>[<i class="emphasis">v<sub>k</sub></i>] is changed by the call, immediately beforehand we also have the strict inequality</p>
<p class="para">
<i class="emphasis">d</i>[<i class="emphasis">v<sub>k</sub></i>] <span class="unicode">&gt;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i><sub><i class="emphasis">k</i>-1</sub>] + <i class="emphasis">w</i>(<i class="emphasis">v</i><sub><i class="emphasis">k</i>-1</sub>, <i class="emphasis">v<sub>k</sub></i>).</p>
<p class="para">Summing this strict inequality with the <i class="emphasis">k</i> - 1 inequalities (<a class="internaljump" href="#ch24eq12">24.12</a>), we obtain the sum of the shortest-path estimates around cycle <i class="emphasis">c</i>:</p>
<p class="para">
<div class="informalequation">
<span class="equation-image"><img src="images/fig633_02.jpg" height="91" width="271" alt="" border="0"></span>
</div>
</p>
<p class="para">But</p>
<p class="para">
<div class="informalequation">
<span class="equation-image"><img src="images/fig633_03.jpg" height="44" width="147" alt="" border="0"></span>
</div>
</p>
<p class="para">since each vertex in the cycle <i class="emphasis">c</i> appears exactly once in each summation. This equality implies</p>
<p class="para">
<div class="informalequation">
<span class="equation-image"><img src="images/fig633_04.jpg" height="43" width="125" alt="" border="0"></span>
</div>
</p>
<p class="para">Thus, the sum of weights around the cycle <i class="emphasis">c</i> is negative, which provides the desired contradiction.</p>
<p class="para">We have now proven that <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> is a directed, acyclic graph. To show that it forms a rooted tree with root <i class="emphasis">s</i>, it suffices (see <a href="DDU0251.html#3395" target="_parent" class="chapterjump">Exercise B.5-2</a>) to prove that for each vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>, there is a unique path from <i class="emphasis">s</i> to <i class="emphasis">v</i> in <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>.</p>
<p class="para">We first must show that a path from <i class="emphasis">s</i> exists for each vertex in <i class="emphasis">V<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>. The vertices in <i class="emphasis">V<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> are those with non-NIL <span class="unicode">&pi;</span> values, plus <i class="emphasis">s</i>. The idea here is to prove by induction that a path exists from <i class="emphasis">s</i> to all vertices in <i class="emphasis">V<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>. The details are left as <a class="internaljump" href="#ch24ex53">Exercise 24.5-6</a>.</p>
<p class="para">To complete the proof of the lemma, we must now show that for any vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>, there is at most one path from <i class="emphasis">s</i> to <i class="emphasis">v</i> in the graph <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>. Suppose otherwise. That is, suppose that there are two simple paths from <i class="emphasis">s</i> to some vertex <i class="emphasis">v</i>: <i class="emphasis">p</i><sub>1</sub>, which can be decomposed into <span class="inlinemediaobject"><img src="images/fig633_05.jpg" height="7" width="100" alt="" border="0"></span> and <i class="emphasis">p</i><sub>2</sub>, which can be decomposed <a name="1851"></a><a name="IDX-612"></a>into <span class="inlinemediaobject"><img src="images/fig634_04.jpg" height="9" width="115" alt="" border="0"></span>, where <i class="emphasis">x</i> <span class="unicode">&ne;</span> <i class="emphasis">y</i>. (See <a class="internaljump" href="#ch24fig09">Figure 24.9</a>.) But then, <span class="unicode">&pi;</span>[<i class="emphasis">z</i>] = <i class="emphasis">x</i> and <span class="unicode">&pi;</span>[<i class="emphasis">z</i>] = <i class="emphasis">y</i>, which implies the contradiction that <i class="emphasis">x</i> = <i class="emphasis">y</i>. We conclude that there exists a unique simple path in <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> from <i class="emphasis">s</i> to <i class="emphasis">v</i>, and thus <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> forms a rooted tree with root <i class="emphasis">s</i>.</p>
<p class="last-para">
<div class="figure">
<a name="1852"></a><a name="ch24fig09"></a><span class="figuremediaobject"><a href="images/fig634%5F03%5F0%2Ejpg" NAME="IMG_740" target="_parent"><img src="images/fig634_03.jpg" height="69" width="270" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 24.9: </span>Showing that a path in <i class="emphasis">G</i><sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub> from source <i class="emphasis">s</i> to vertex <i class="emphasis">v</i> is unique. If there are two paths <span class="inlinemediaobject"><a href="images/fig634%5F01%5F0%2Ejpg" NAME="IMG_738" target="_parent"><img src="images/fig634_01.jpg" height="11" width="120" alt="Click To expand" border="0"></a></span> and <span class="inlinemediaobject"><img src="images/fig634_02.jpg" height="11" width="120" alt="" border="0"></span>, where <i class="emphasis">x</i> <span class="unicode">&ne;</span> <i class="emphasis">y</i>, then <span class="unicode">&pi;</span>[<i class="emphasis">z</i>] = <i class="emphasis">x</i> and <span class="unicode">&pi;</span>[<i class="emphasis">z</i>] = <i class="emphasis">y</i>, a contradiction.</span>
</div>
</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">We can now show that if, after we have performed a sequence of relaxation steps, all vertices have been assigned their true shortest-path weights, then the predecessor subgraph <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> is a shortest-paths tree.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 24.17: </span>(Predecessor-subgraph property)</span><a name="1853"></a><a name="ch24ex47"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a weighted, directed graph with weight function <i class="emphasis">w</i> : <i class="emphasis">E</i> <span class="unicode">&rarr;</span> <b class="bold">R</b>, let <i class="emphasis">s</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> be a source vertex, and assume that <i class="emphasis">G</i> contains no negative-weight cycles that are reachable from <i class="emphasis">s</i>. Let us call INITIALIZE-SINGLE-SOURCE(<i class="emphasis">G</i>, <i class="emphasis">s</i>) and then execute any sequence of relaxation steps on edges of <i class="emphasis">G</i> that produces <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) for all <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>. Then, the predecessor subgraph <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> is a shortest-paths tree rooted at <i class="emphasis">s</i>.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> We must prove that the three properties of shortest-paths trees given on page 584 hold for <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> . To show the first property, we must show that <i class="emphasis">V<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> is the set of vertices reachable from <i class="emphasis">s</i>. By definition, a shortest-path weight <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) is finite if and only if <i class="emphasis">v</i> is reachable from <i class="emphasis">s</i>, and thus the vertices that are reachable from <i class="emphasis">s</i> are exactly those with finite <i class="emphasis">d</i> values. But a vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> - {<i class="emphasis">s</i>} has been assigned a finite value for <i class="emphasis">d</i>[<i class="emphasis">v</i>] if and only if <span class="unicode">&pi;</span>[<i class="emphasis">v</i>] <span class="unicode">&ne;</span> NIL. Thus, the vertices in <i class="emphasis">V<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> are exactly those reachable from <i class="emphasis">s</i>.</p>
<p class="para">The second property follows directly from <a class="internaljump" href="#ch24ex46">Lemma 24.16</a>.</p>
<p class="para">It remains, therefore, to prove the last property of shortest-paths trees: for each vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> , the unique simple path <span class="inlinemediaobject"><img src="images/fig634_05.jpg" height="13" width="30" alt="" border="0"></span> in <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> is a shortest path from <i class="emphasis">s</i> to <i class="emphasis">v</i> in <i class="emphasis">G</i>. Let <i class="emphasis">p</i> = <span class="unicode">&#12296;</span><i class="emphasis">v</i><sub>0</sub>, <i class="emphasis">v</i><sub>1</sub>,..., <i class="emphasis">v<sub>k</sub></i><span class="unicode">&#12297;</span>, where <i class="emphasis">v</i><sub>0</sub> = <i class="emphasis">s</i> and <i class="emphasis">v<sub>k</sub></i> = <i class="emphasis">v</i>. For <i class="emphasis">i</i> = 1, 2,..., <i class="emphasis">k</i>, we have both <i class="emphasis">d</i>[<i class="emphasis">v<sub>i</sub></i> ] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v<sub>i</sub></i>) and <i class="emphasis">d</i>[<i class="emphasis">v<sub>i</sub></i>] <span class="unicode">&ge;</span> <i class="emphasis">d</i>[<i class="emphasis">v</i><sub><i class="emphasis">i</i>-1</sub>] + <i class="emphasis">w</i>(<i class="emphasis">v</i><sub><i class="emphasis">i</i>-1</sub>, <i class="emphasis">v<sub>i</sub></i>), from which we conclude <i class="emphasis">w</i>(<i class="emphasis">v</i><sub><i class="emphasis">i</i>-1</sub>, <i class="emphasis">v<sub>i</sub></i>) <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v<sub>i</sub></i>) - <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i><sub><i class="emphasis">i</i>-1</sub>). Summing the weights along path <i class="emphasis">p</i> <a name="1854"></a><a name="IDX-613"></a>yields</p>
<div class="informalequation">
<span class="equation-image"><a href="images/fig635%5F01%2Ejpg" NAME="IMG_742" target="_parent"><img src="images/fig635_01.jpg" height="122" width="400" alt="Click To expand" border="0"></a></span>
</div>
<p class="last-para">Thus, <i class="emphasis">w</i>(<i class="emphasis">p</i>) <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v<sub>k</sub></i>). Since <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v<sub>k</sub></i>) is a lower bound on the weight of any path from <i class="emphasis">s</i> to <i class="emphasis">v<sub>k</sub></i>, we conclude that <i class="emphasis">w</i>(<i class="emphasis">p</i>) = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v<sub>k</sub></i>), and thus <i class="emphasis">p</i> is a shortest path from <i class="emphasis">s</i> to <i class="emphasis">v</i> = <i class="emphasis">v<sub>k</sub></i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 24.5-1</span></span><a name="1855"></a><a name="ch24ex48"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Give two shortest-paths trees for the directed graph of <a href="DDU0144.html#1762" target="_parent" class="chapterjump">Figure 24.2</a> other than the two shown.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 24.5-2</span></span><a name="1856"></a><a name="ch24ex49"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Give an example of a weighted, directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) with weight function <i class="emphasis">w</i> : <i class="emphasis">E</i> <span class="unicode">&rarr;</span> <b class="bold">R</b> and source <i class="emphasis">s</i> such that <i class="emphasis">G</i> satisfies the following property: For every edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>, there is a shortest-paths tree rooted at <i class="emphasis">s</i> that contains (<i class="emphasis">u</i>, <i class="emphasis">v</i>) and another shortest-paths tree rooted at <i class="emphasis">s</i> that does not contain (<i class="emphasis">u</i>, <i class="emphasis">v</i>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 24.5-3</span></span><a name="1857"></a><a name="ch24ex50"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Embellish the proof of <a class="internaljump" href="#ch24ex40">Lemma 24.10</a> to handle cases in which shortest-path weights are <span class="unicode">&infin;</span> or -<span class="unicode">&infin;</span>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 24.5-4</span></span><a name="1858"></a><a name="ch24ex51"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a weighted, directed graph with source vertex <i class="emphasis">s</i>, and let <i class="emphasis">G</i> be initialized by INITIALIZE-SINGLE-SOURCE(<i class="emphasis">G</i>, <i class="emphasis">s</i>). Prove that if a sequence of relaxation steps sets <span class="unicode">&pi;</span>[<i class="emphasis">s</i>] to a non-NIL value, then <i class="emphasis">G</i> contains a negative-weight cycle.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 24.5-5</span></span><a name="1859"></a><a name="ch24ex52"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a weighted, directed graph with no negative-weight edges. Let <i class="emphasis">s</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> be the source vertex, and suppose that we allow <span class="unicode">&pi;</span>[<i class="emphasis">v</i>] to be the predecessor of <i class="emphasis">v</i> on <i class="emphasis">any</i> shortest path to <i class="emphasis">v</i> from source <i class="emphasis">s</i> if <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> - {<i class="emphasis">s</i>} is reachable from <i class="emphasis">s</i>, and NIL otherwise. Give an example of such a graph <i class="emphasis">G</i> and an assignment of <span class="unicode">&pi;</span> values that produces a cycle in <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> . (By <a class="internaljump" href="#ch24ex46">Lemma 24.16</a>, such an assignment cannot be produced by a sequence of relaxation steps.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1860"></a><a name="IDX-614"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 24.5-6</span></span><a name="1861"></a><a name="ch24ex53"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a weighted, directed graph with weight function <i class="emphasis">w</i> : <i class="emphasis">E</i> <span class="unicode">&rarr;</span> <b class="bold">R</b> and no negative-weight cycles. Let <i class="emphasis">s</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> be the source vertex, and let <i class="emphasis">G</i> be initialized by INITIALIZE-SINGLE-SOURCE(<i class="emphasis">G</i>, <i class="emphasis">s</i>). Prove that for every vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i>, there exists a path from <i class="emphasis">s</i> to <i class="emphasis">v</i> in <i class="emphasis">G<sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub></i> and that this property is maintained as an invariant over any sequence of relaxations.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 24.5-7</span></span><a name="1862"></a><a name="ch24ex54"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a weighted, directed graph that contains no negative-weight cycles. Let <i class="emphasis">s</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> be the source vertex, and let <i class="emphasis">G</i> be initialized by INITIALIZE-SINGLE-SOURCE(<i class="emphasis">G</i>, <i class="emphasis">s</i>). Prove that there exists a sequence of |<i class="emphasis">V</i> | - 1 relaxation steps that produces <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) for all <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 24.5-8</span></span><a name="1863"></a><a name="ch24ex55"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> be an arbitrary weighted, directed graph with a negative-weight cycle reachable from the source vertex <i class="emphasis">s</i>. Show that an infinite sequence of relaxations of the edges of <i class="emphasis">G</i> can always be constructed such that every relaxation causes a shortest-path estimate to change.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 24-1: </span>Yen's improvement to Bellman-Ford</span><a name="1864"></a><a name="ch24ex56"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that we order the edge relaxations in each pass of the Bellman-Ford algorithm as follows. Before the first pass, we assign an arbitrary linear order <i class="emphasis">v</i><sub>1</sub>, <i class="emphasis">v</i><sub>2</sub>,..., <i class="emphasis">v</i><sub>|<i class="emphasis">v</i>|</sub> to the vertices of the input graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>). Then, we partition the edge set <i class="emphasis">E</i> into <i class="emphasis">E<sub>f</sub></i> <span class="unicode">&cup;</span> <i class="emphasis">E<sub>b</sub></i>, where <i class="emphasis">E<sub>f</sub></i> = {(<i class="emphasis">v<sub>i</sub></i> , <i class="emphasis">v<sub>j</sub></i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i> : <i class="emphasis">i</i> <span class="unicode">&lt;</span> <i class="emphasis">j</i>} and <i class="emphasis">E<sub>b</sub></i> = {(<i class="emphasis">v<sub>i</sub></i>, <i class="emphasis">v<sub>j</sub></i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i> : <i class="emphasis">i</i> <span class="unicode">&gt;</span> <i class="emphasis">j</i>}. (Assume that <i class="emphasis">G</i> contains no self-loops, so that every edge is in either <i class="emphasis">E<sub>f</sub></i> or <i class="emphasis">E<sub>b</sub></i>.) Define <i class="emphasis">G<sub>f</sub></i> = (<i class="emphasis">V</i>, <i class="emphasis">E<sub>f</sub></i>) and <i class="emphasis">G<sub>b</sub></i> = (<i class="emphasis">V</i>, <i class="emphasis">E<sub>b</sub></i>).</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Prove that <i class="emphasis">G<sub>f</sub></i> is acyclic with topological sort <span class="unicode">&#12296;</span><i class="emphasis">v</i><sub>1</sub>, <i class="emphasis">v</i><sub>2</sub>,..., <i class="emphasis">v</i><sub>|<i class="emphasis">V</i>|</sub><span class="unicode">&#12297;</span> and that <i class="emphasis">G<sub>b</sub></i> is acyclic with topological sort <span class="unicode">&#12296;</span><i class="emphasis">v</i><sub>|<i class="emphasis">V</i>|</sub>, <i class="emphasis">v</i><sub>|<i class="emphasis">V</i>|-1</sub>,...,<i class="emphasis">v</i><sub>1</sub><span class="unicode">&#12297;</span>.</p>
</li>
</ol>
<p class="para">Suppose that we implement each pass of the Bellman-Ford algorithm in the following way. We visit each vertex in the order <i class="emphasis">v</i><sub>1</sub>, <i class="emphasis">v</i><sub>2</sub>,..., <i class="emphasis">v</i><sub>|<i class="emphasis">V</i>|</sub>, relaxing edges of <i class="emphasis">E<sub>f</sub></i> that leave the vertex. We then visit each vertex in the order <i class="emphasis">v</i><sub>|<i class="emphasis">V</i>|</sub>, <i class="emphasis">v</i><sub>|<i class="emphasis">V</i>|-1</sub>,..., <i class="emphasis">v</i><sub>1</sub>, relaxing edges of <i class="emphasis">E<sub>b</sub></i> that leave the vertex.</p>
<ol class="orderedlist" start="2" type="a">
<li class="first-listitem">
<p class="first-para">Prove that with this scheme, if <i class="emphasis">G</i> contains no negative-weight cycles that are reachable from the source vertex <i class="emphasis">s</i>, then after only <span class="unicode">&lceil;</span>|<i class="emphasis">V</i> | /2<span class="unicode">&rceil;</span> passes over the edges, <i class="emphasis">d</i>[<i class="emphasis">v</i>] = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) for all vertices <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>.</p>
<a name="1865"></a><a name="IDX-615"></a>
</li>
<li class="listitem">
<p class="first-para">Does this scheme improve the asymptotic running time of the Bellman-Ford algorithm?</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 24-2: </span>Nesting boxes</span><a name="1866"></a><a name="ch24ex57"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">A <i class="emphasis">d</i>-dimensional box with dimensions (<i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>,..., <i class="emphasis">x<sub>d</sub></i>) <b class="bold"><i class="emphasis">nests</i></b> within another box with dimensions (<i class="emphasis">y</i><sub>1</sub>, <i class="emphasis">y</i><sub>2</sub>,..., <i class="emphasis">y<sub>d</sub></i>) if there exists a permutation <span class="unicode">&pi;</span> on {1, 2,..., <i class="emphasis">d</i>} such that <i class="emphasis">x</i><sub><i class="emphasis"><span class="unicode">&pi;</span></i>(1)</sub> <span class="unicode">&lt;</span> <i class="emphasis">y</i><sub>1</sub>, <i class="emphasis">x</i><sub><i class="emphasis"><span class="unicode">&pi;</span></i>(2)</sub> <span class="unicode">&lt;</span> <i class="emphasis">y</i><sub>2</sub>,..., <i class="emphasis">x</i><sub><i class="emphasis"><span class="unicode">&pi;</span></i>(<i class="emphasis">d</i>)</sub> <span class="unicode">&lt;</span> <i class="emphasis">y<sub>d</sub></i>.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Argue that the nesting relation is transitive.</p>
</li>
<li class="listitem">
<p class="first-para">Describe an efficient method to determine whether or not one <i class="emphasis">d</i>-dimensional box nests inside another.</p>
</li>
<li class="listitem">
<p class="first-para">Suppose that you are given a set of <i class="emphasis">n</i> <i class="emphasis">d</i>-dimensional boxes {<i class="emphasis">B</i><sub>1</sub>, <i class="emphasis">B</i><sub>2</sub>,..., <i class="emphasis">B<sub>n</sub></i>}. Describe an efficient algorithm to determine the longest sequence <span class="inlinemediaobject"><img src="images/fig637_01.jpg" height="11" width="35" alt="" border="0"></span><span class="inlinemediaobject"><img src="images/fig637_02.jpg" height="14" width="40" alt="" border="0"></span> of boxes such that <span class="inlinemediaobject"><img src="images/fig637_03.jpg" height="13" width="14" alt="" border="0"></span> nests within <span class="inlinemediaobject"><img src="images/fig637_04.jpg" height="14" width="21" alt="" border="0"></span> for <i class="emphasis">j</i> = 1, 2,..., <i class="emphasis">k</i> - 1. Express the running time of your algorithm in terms of <i class="emphasis">n</i> and <i class="emphasis">d</i>.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 24-3: </span>Arbitrage</span><a name="1867"></a><a name="ch24ex58"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">
<b class="bold"><i class="emphasis">Arbitrage</i></b> is the use of discrepancies in currency exchange rates to transform one unit of a currency into more than one unit of the same currency. For example, suppose that 1 U.S. dollar buys 46.4 Indian rupees, 1 Indian rupee buys 2.5 Japanese yen, and 1 Japanese yen buys 0.0091 U.S. dollars. Then, by converting currencies, a trader can start with 1 U.S. dollar and buy 46.4 <span class="unicode">&times;</span> 2.5 <span class="unicode">&times;</span> 0.0091 = 1.0556 U.S. dollars, thus turning a profit of 5.56 percent.</p>
<p class="para">Suppose that we are given <i class="emphasis">n</i> currencies <i class="emphasis">c</i><sub>1</sub>, <i class="emphasis">c</i><sub>2</sub>,..., <i class="emphasis">c<sub>n</sub></i> and an <i class="emphasis">n</i> <span class="unicode">&times;</span> <i class="emphasis">n</i> table <i class="emphasis">R</i> of exchange rates, such that one unit of currency <i class="emphasis">c<sub>i</sub></i> buys <i class="emphasis">R</i>[<i class="emphasis">i</i>, <i class="emphasis">j</i>] units of currency <i class="emphasis">c<sub>j</sub></i>.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Give an efficient algorithm to determine whether or not there exists a sequence of currencies <span class="inlinemediaobject"><img src="images/fig637_05.jpg" height="15" width="85" alt="" border="0"></span> such that</p>
<p class="para">R[<i class="emphasis">i</i><sub>1</sub>, <i class="emphasis">i</i><sub>2</sub>] <span class="unicode">&middot;</span> <i class="emphasis">R</i>[<i class="emphasis">i</i><sub>2</sub>, <i class="emphasis">i</i><sub>3</sub>] <i class="emphasis">R</i>[<i class="emphasis">i</i><sub><i class="emphasis">k</i>-1</sub>, <i class="emphasis">i<sub>k</sub></i>] <span class="unicode">&middot;</span> <i class="emphasis">R</i>[<i class="emphasis">i<sub>k</sub></i>, <i class="emphasis">i</i><sub>1</sub>] <span class="unicode">&gt;</span> 1.</p>
<p class="last-para">Analyze the running time of your algorithm.</p>
</li>
<li class="listitem">
<p class="first-para">Give an efficient algorithm to print out such a sequence if one exists. Analyze the running time of your algorithm.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 24-4: </span>Gabow's scaling algorithm for single-source shortest paths</span><a name="1868"></a><a name="ch24ex59"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">A <b class="bold"><i class="emphasis">scaling</i></b> algorithm solves a problem by initially considering only the highest-order bit of each relevant input value (such as an edge weight). It then refines the initial solution by looking at the two highest-order bits. It progressively looks at <a name="1869"></a><a name="IDX-616"></a>more and more high-order bits, refining the solution each time, until all bits have been considered and the correct solution has been computed.</p>
<p class="para">In this problem, we examine an algorithm for computing the shortest paths from a single source by scaling edge weights. We are given a directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) with nonnegative integer edge weights <i class="emphasis">w</i>. Let <i class="emphasis">W</i> = max<sub>(<i class="emphasis">u</i>, <i class="emphasis">v</i>)<i class="emphasis"><span class="unicode">&isin;</span></i><i class="emphasis">E</i></sub> {<i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>)}. Our goal is to develop an algorithm that runs in <i class="emphasis">O</i>(<i class="emphasis">E</i> lg <i class="emphasis">W</i>) time. We assume that all vertices are reachable from the source.</p>
<p class="para">The algorithm uncovers the bits in the binary representation of the edge weights one at a time, from the most significant bit to the least significant bit. Specifically, let <i class="emphasis">k</i> = <span class="unicode">&lceil;</span>lg(<i class="emphasis">W</i> + 1)<span class="unicode">&rceil;</span> be the number of bits in the binary representation of <i class="emphasis">W</i> , and for <i class="emphasis">i</i> = 1, 2,...,<i class="emphasis">k</i>, let <i class="emphasis">w<sub>i</sub></i> (<i class="emphasis">u</i>, <i class="emphasis">v</i>) = <span class="unicode">&lfloor;</span><i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>)/2<sup><i class="emphasis">k</i>-<i class="emphasis">i</i></sup><span class="unicode">&rfloor;</span>. That is, <i class="emphasis">w<sub>i</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) is the "scaled-down" version of <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) given by the <i class="emphasis">i</i> most significant bits of <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>). (Thus, <i class="emphasis">w<sub>k</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) for all (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>.) For example, if <i class="emphasis">k</i> = 5 and <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = 25, which has the binary representation <span class="unicode">&#12296;</span>11001<span class="unicode">&#12297;</span>, then <i class="emphasis">w</i><sub>3</sub>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = <span class="unicode">&#12296;</span>110<span class="unicode">&#12297;</span> = 6. As another example with <i class="emphasis">k</i> = 5, if <i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = <span class="unicode">&#12296;</span>00100<span class="unicode">&#12297;</span> = 4, then <i class="emphasis">w</i><sub>3</sub>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = <span class="unicode">&#12296;</span>001<span class="unicode">&#12297;</span> = 1. Let us define <i class="emphasis"><span class="unicode">&delta;</span><sub>i</sub></i> (<i class="emphasis">u</i>, <i class="emphasis">v</i>) as the shortest-path weight from vertex <i class="emphasis">u</i> to vertex <i class="emphasis">v</i> using weight function <i class="emphasis">w<sub>i</sub></i>. Thus, <i class="emphasis"><span class="unicode">&delta;</span><sub>k</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) for all <i class="emphasis">u</i>, <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>. For a given source vertex <i class="emphasis">s</i>, the scaling algorithm first computes the shortest-path weights <i class="emphasis"><span class="unicode">&delta;</span></i><sub>1</sub>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) for all <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, then computes <i class="emphasis"><span class="unicode">&delta;</span></i><sub>2</sub>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) for all <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, and so on, until it computes <i class="emphasis"><span class="unicode">&delta;</span><sub>k</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) for all <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>. We assume throughout that |<i class="emphasis">E</i>| <span class="unicode">&ge;</span> |<i class="emphasis">V</i>| - 1, and we shall see that computing <i class="emphasis"><span class="unicode">&delta;</span><sub>i</sub></i> from <span class="unicode">&delta;</span><sub><i class="emphasis">i</i>-1</sub> takes <i class="emphasis">O</i>(<i class="emphasis">E</i>) time, so that the entire algorithm takes <i class="emphasis">O</i>(<i class="emphasis">k E</i>) = <i class="emphasis">O</i>(<i class="emphasis">E</i> lg <i class="emphasis">W</i>) time.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Suppose that for all vertices <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, we have <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) <span class="unicode">&le;</span> |<i class="emphasis">E</i>|. Show that we can compute <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) for all <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> in <i class="emphasis">O</i>(<i class="emphasis">E</i>) time.</p>
</li>
<li class="listitem">
<p class="first-para">Show that we can compute <i class="emphasis"><span class="unicode">&delta;</span></i><sub>1</sub>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) for all <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> in <i class="emphasis">O</i>(<i class="emphasis">E</i>) time.</p>
</li>
</ol>
<p class="para">Let us now focus on computing <i class="emphasis"><span class="unicode">&delta;</span><sub>i</sub></i> from <i class="emphasis"><span class="unicode">&delta;</span></i><sub><i class="emphasis">i</i>-1</sub>.</p>
<ol class="orderedlist" start="3" type="a">
<li class="first-listitem">
<p class="first-para">Prove that for <i class="emphasis">i</i> = 2, 3,..., <i class="emphasis">k</i>, we have either <i class="emphasis">w<sub>i</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = 2<i class="emphasis">w</i><sub><i class="emphasis">i</i>-1</sub>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) or <i class="emphasis">w<sub>i</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = 2<i class="emphasis">w</i><sub><i class="emphasis">i</i>-1</sub>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) + 1. Then, prove that</p>
<p class="para">2<i class="emphasis"><span class="unicode">&delta;</span></i><sub><i class="emphasis">i</i>-1</sub>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&delta;</span><sub>i</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) <span class="unicode">&le;</span> 2<i class="emphasis"><span class="unicode">&delta;</span></i><sub><i class="emphasis">i</i>-1</sub>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) + |<i class="emphasis">V</i>| - 1</p>
<p class="last-para">for all <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Define for <i class="emphasis">i</i> = 2, 3,..., <i class="emphasis">k</i>, and all (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>,</p>
<p class="para">
<span class="inlinemediaobject"><img src="images/fig638_01.jpg" height="17" width="281" alt="" border="0"></span>.</p>
<p class="para">Prove that for <i class="emphasis">i</i> = 2, 3,..., <i class="emphasis">k</i> and all <i class="emphasis">u</i>, <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, the "reweighted" value <span class="inlinemediaobject"><img src="images/fig638_02.jpg" height="13" width="37" alt="" border="0"></span> edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is a nonnegative integer.</p>
<a name="1870"></a><a name="IDX-617"></a>
</li>
<li class="listitem">
<p class="first-para">Now, define <span class="inlinemediaobject"><img src="images/fig639_01.jpg" height="14" width="33" alt="" border="0"></span> as the shortest-path weight from <i class="emphasis">s</i> to <i class="emphasis">v</i> using the weight function <span class="inlinemediaobject"><img src="images/fig639_02.jpg" height="13" width="11" alt="" border="0"></span>. Prove that for <i class="emphasis">i</i> = 2, 3,..., <i class="emphasis">k</i> and all <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>,</p>
<p class="para">
<span class="inlinemediaobject"><img src="images/fig639_03.jpg" height="20" width="186" alt="" border="0"></span>
</p>
<p class="last-para">and that <span class="inlinemediaobject"><img src="images/fig639_04.jpg" height="15" width="63" alt="" border="0"></span>.</p>
</li>
<li class="listitem">
<p class="first-para">Show how to compute <i class="emphasis"><span class="unicode">&delta;</span><sub>i</sub></i> (<i class="emphasis">s</i>, <i class="emphasis">v</i>) from <span class="unicode">&delta;</span><sub><i class="emphasis">i</i>-1</sub>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) for all <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> in <i class="emphasis">O</i>(<i class="emphasis">E</i>) time, and conclude that <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) can be computed for all <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> in <i class="emphasis">O</i>(<i class="emphasis">E</i> lg <i class="emphasis">W</i>) time.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 24-5: </span>Karp's minimum mean-weight cycle algorithm</span><a name="1871"></a><a name="ch24ex60"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a directed graph with weight function <i class="emphasis">w</i> : <i class="emphasis">E</i> <span class="unicode">&rarr;</span> <b class="bold">R</b>, and let <i class="emphasis">n</i> = |<i class="emphasis">V</i> |. We define the <b class="bold"><i class="emphasis">mean weight</i></b> of a cycle <i class="emphasis">c</i> = <span class="unicode">&#12296;</span><i class="emphasis">e</i><sub>1</sub>, <i class="emphasis">e</i><sub>2</sub>,..., <i class="emphasis">e<sub>k</sub></i><span class="unicode">&#12297;</span> of edges in <i class="emphasis">E</i> to be</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig639_05.jpg" height="42" width="125" alt="" border="0"></span>
</div>
<p class="para">Let <i class="emphasis"><span class="unicode">&mu;</span></i>* = min<sub><i class="emphasis">c</i></sub> <i class="emphasis"><span class="unicode">&mu;</span></i>(<i class="emphasis">c</i>), where <i class="emphasis">c</i> ranges over all directed cycles in <i class="emphasis">G</i>. A cycle <i class="emphasis">c</i> for which <i class="emphasis"><span class="unicode">&mu;</span></i>(<i class="emphasis">c</i>) = <i class="emphasis"><span class="unicode">&mu;</span></i>* is called a <b class="bold"><i class="emphasis">minimum mean-weight cycle</i></b>. This problem investigates an efficient algorithm for computing <i class="emphasis"><span class="unicode">&mu;</span></i>*.</p>
<p class="para">Assume without loss of generality that every vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> is reachable from a source vertex <i class="emphasis">s</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> . Let <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) be the weight of a shortest path from <i class="emphasis">s</i> to <i class="emphasis">v</i>, and let <i class="emphasis"><span class="unicode">&delta;</span><sub>k</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) be the weight of a shortest path from <i class="emphasis">s</i> to <i class="emphasis">v</i> consisting of <i class="emphasis">exactly k</i> edges. If there is no path from <i class="emphasis">s</i> to <i class="emphasis">v</i> with exactly <i class="emphasis">k</i> edges, then <i class="emphasis"><span class="unicode">&delta;</span><sub>k</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) = <span class="unicode">&infin;</span>.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Show that if <i class="emphasis"><span class="unicode">&mu;</span></i>*= 0, then <i class="emphasis">G</i> contains no negative-weight cycles and <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) = min<sub>0<i class="emphasis"><span class="unicode">&le;</span></i><i class="emphasis">k</i><i class="emphasis"><span class="unicode">&le;</span></i><i class="emphasis">n</i>-1</sub> <i class="emphasis"><span class="unicode">&delta;</span><sub>k</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) for all vertices <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Show that if <i class="emphasis"><span class="unicode">&mu;</span></i>* = 0, then</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig639_06.jpg" height="33" width="185" alt="" border="0"></span>
</div>
<p class="last-para">for all vertices <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>. (<i class="emphasis">Hint:</i> Use both properties from part (a).)</p>
</li>
<li class="listitem">
<p class="first-para">Let <i class="emphasis">c</i> be a 0-weight cycle, and let <i class="emphasis">u</i> and <i class="emphasis">v</i> be any two vertices on <i class="emphasis">c</i>. Suppose that <i class="emphasis"><span class="unicode">&mu;</span></i>* = 0 and that the weight of the path from <i class="emphasis">u</i> to <i class="emphasis">v</i> along the cycle is <i class="emphasis">x</i>. Prove that <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) + <i class="emphasis">x</i>. (<i class="emphasis">Hint:</i> The weight of the path from <i class="emphasis">v</i> to <i class="emphasis">u</i> along the cycle is -<i class="emphasis">x</i>.)</p>
</li>
<li class="listitem">
<p class="first-para">Show that if <i class="emphasis"><span class="unicode">&mu;</span></i>* = 0, then on each minimum mean-weight cycle there exists a vertex <i class="emphasis">v</i> such that<a name="1872"></a><a name="IDX-618"></a>
</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig640_01.jpg" height="35" width="193" alt="" border="0"></span>
</div>
<p class="last-para">(<i class="emphasis">Hint:</i> Show that a shortest path to any vertex on a minimum mean-weight cycle can be extended along the cycle to make a shortest path to the next vertex on the cycle.)</p>
</li>
<li class="listitem">
<p class="first-para">Show that if <i class="emphasis"><span class="unicode">&mu;</span></i>* = 0, then</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig640_02.jpg" height="34" width="216" alt="" border="0"></span>
</div>
</li>
<li class="listitem">
<p class="first-para">Show that if we add a constant <i class="emphasis">t</i> to the weight of each edge of <i class="emphasis">G</i>, then <i class="emphasis"><span class="unicode">&mu;</span></i>* is increased by <i class="emphasis">t</i>. Use this fact to show that</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig640_03.jpg" height="35" width="225" alt="" border="0"></span>
</div>
</li>
<li class="listitem">
<p class="first-para">Give an <i class="emphasis">O</i>(<i class="emphasis">V E</i>)-time algorithm to compute <i class="emphasis"><span class="unicode">&mu;</span></i>*.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 24-6: </span>Bitonic shortest paths</span><a name="1873"></a><a name="ch24ex61"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">A sequence is <b class="bold"><i class="emphasis">bitonic</i></b> if it monotonically increases and then monotonically decreases, or if it can be circularly shifted to monotonically increase and then monotonically decrease. For example the sequences <span class="unicode">&#12296;</span>1, 4, 6, 8, 3, -2<span class="unicode">&#12297;</span>, <span class="unicode">&#12296;</span>9, 2, -4, -10, -5<span class="unicode">&#12297;</span>, and <span class="unicode">&#12296;</span>1, 2, 3, 4<span class="unicode">&#12297;</span> are bitonic, but <span class="unicode">&#12296;</span>1, 3, 12, 4, 2, 10<span class="unicode">&#12297;</span> is not bitonic. (See <a href="DDU0168.html#2137" target="_parent" class="chapterjump">Chapter 27</a> for a discussion of bitonic sorters, and see <a href="DDU0091.html#1129" target="_parent" class="chapterjump">Problem 15-1</a> for the bitonic euclidean traveling-salesman problem.)</p>
<p class="para">Suppose that we are given a directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) with weight function <i class="emphasis">w</i> : <i class="emphasis">E</i> <span class="unicode">&rarr;</span> <b class="bold">R</b>, and we wish to find single-source shortest paths from a source vertex <i class="emphasis">s</i>. We are given one additional piece of information: for each vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, the weights of the edges along any shortest path from <i class="emphasis">s</i> to <i class="emphasis">v</i> form a bitonic sequence.</p>
<p class="last-para">Give the most efficient algorithm you can to solve this problem, and analyze its running time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0151.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0153.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
