<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Chapter notes</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0152.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0154.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch24"></a>
<div class="section">
<h2 class="first-section-title">
<a name="1874"></a><a name="ch24lev1sec6"></a>Chapter notes</h2>
<p class="first-para">Dijkstra's algorithm [<a href="DDU0259.html#3630" target="_parent" class="chapterjump">75</a>] appeared in 1959, but it contained no mention of a priority queue. The Bellman-Ford algorithm is based on separate algorithms by <a href="DDU0259.html#3591" target="_parent" class="chapterjump">Bellman [35]</a> and <a href="DDU0259.html#3648" target="_parent" class="chapterjump">Ford [93]</a>. Bellman describes the relation of shortest paths to difference constraints. <a href="DDU0259.html#3751" target="_parent" class="chapterjump">Lawler [196]</a> describes the linear-time algorithm for shortest paths in a dag, which he considers part of the folklore.<a name="1875"></a><a name="IDX-619"></a>
</p>
<p class="para">When edge weights are relatively small nonnegative integers, more efficient algorithms can be used to solve the single-source shortest-paths problem. The sequence of values returned by the EXTRACT-MIN calls in Dijkstra's algorithm is monotonically increasing over time. As discussed in the chapter notes for <a href="DDU0035.html#382" target="_parent" class="chapterjump">Chapter 6</a>, in this case there are several data structures that can implement the various priority-queue operations more efficiently than a binary heap or a Fibonacci heap. <a href="DDU0259.html#3564" target="_parent" class="chapterjump">Ahuja, Mehlhorn, Orlin, and Tarjan [8]</a> give an algorithm that runs in <span class="inlinemediaobject"><img src="images/fig641_01.jpg" height="14" width="78" alt="" border="0"></span> time on graphs with nonnegative edge weights, where <i class="emphasis">W</i> is the largest weight of any edge in the graph. The best bounds are by <a href="DDU0259.html#3854" target="_parent" class="chapterjump">Thorup [299]</a>, who gives an algorithm that runs in <i class="emphasis">O</i>(<i class="emphasis">E</i> lg lg <i class="emphasis">V</i>) time, and by Raman, who gives an algorithm that runs in <i class="emphasis">O</i> (<i class="emphasis">E</i> + <i class="emphasis">V</i> min {(lg <i class="emphasis">V</i>) <sup>1/3+<i class="emphasis"><span class="unicode">&isin;</span></i></sup>, (lg <i class="emphasis">W</i>)<sup>1/4+<i class="emphasis"><span class="unicode">&isin;</span></i></sup>}) time. These two algorithms use an amount of space that depends on the word size of the underlying machine. Although the amount of space used can be unbounded in the size of the input, it can be reduced to be linear in the size of the input using randomized hashing.</p>
<p class="para">For undirected graphs with integer weights, <a href="DDU0259.html#3853" target="_parent" class="chapterjump">Thorup [298]</a> gives an <i class="emphasis">O</i>(<i class="emphasis">V</i> + <i class="emphasis">E</i>)-time algorithm for single-source shortest paths. In contrast to the algorithms mentioned in the previous paragraph, this algorithm is not an implementation of Dijkstra's algorithm, since the sequence of values returned by EXTRACT-MIN calls is not monotonically increasing over time.</p>
<p class="para">For graphs with negative edge weights, an algorithm due to <a href="DDU0259.html#3659" target="_parent" class="chapterjump">Gabow and Tarjan [104]</a> runs in <span class="inlinemediaobject"><img src="images/fig641_02.jpg" height="14" width="82" alt="" border="0"></span> time, and one by <a href="DDU0259.html#3673" target="_parent" class="chapterjump">Goldberg [118]</a> runs in <span class="inlinemediaobject"><img src="images/fig641_03.jpg" height="14" width="67" alt="" border="0"></span> time, where <i class="emphasis">W</i> = max<sub>(<i class="emphasis">u</i>, <i class="emphasis">v</i>)<i class="emphasis"><span class="unicode">&isin;</span></i><i class="emphasis">E</i></sub> {|<i class="emphasis">w</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>)|}.</p>
<p class="last-para">
<a href="DDU0259.html#3613" target="_parent" class="chapterjump">Cherkassky, Goldberg, and Radzik [57]</a> conducted extensive experiments comparing various shortest-path algorithms.</p>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0152.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0154.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
