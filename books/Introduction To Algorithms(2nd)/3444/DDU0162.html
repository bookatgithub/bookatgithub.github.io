<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>26.2 The Ford-Fulkerson method</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0161.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0163.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch26"></a>
<div class="section">
<h2 class="first-section-title">
<a name="1989"></a><a name="ch26lev1sec2"></a><span class="section-titlelabel">26.2 </span>The Ford-Fulkerson method</h2>
<a name="1990"></a><a name="IDX-651"></a>
<p class="para">This section presents the Ford-Fulkerson method for solving the maximum-flow problem. We call it a "method" rather than an "algorithm" because it encompasses several implementations with differing running times. The Ford-Fulkerson method depends on three important ideas that transcend the method and are relevant to many flow algorithms and problems: residual networks, augmenting paths, and cuts. These ideas are essential to the important max-flow min-cut theorem (<a class="internaljump" href="#ch26ex16">Theorem 26.7</a>), which characterizes the value of a maximum flow in terms of cuts of the flow network. We end this section by presenting one specific implementation of the Ford-Fulkerson method and analyzing its running time.</p>
<p class="para">The Ford-Fulkerson method is iterative. We start with <i class="emphasis">f</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = 0 for all <i class="emphasis">u</i>, <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, giving an initial flow of value 0. At each iteration, we increase the flow value by finding an "augmenting path," which we can think of simply as a path from the source <i class="emphasis">s</i> to the sink <i class="emphasis">t</i> along which we can send more flow, and then augmenting the flow along this path. We repeat this process until no augmenting path can be found. The max-flow min-cut theorem will show that upon termination, this process yields a maximum flow.</p>
<div class="informalexample">
<pre class="literallayout-normal">
FORD-FULKERSON-METHOD(<i class="emphasis">G</i>, <i class="emphasis">s</i>, <i class="emphasis">t</i>)
1  initialize flow <i class="emphasis">f</i> to 0
2  <b class="bold">while</b> there exists an augmenting path <i class="emphasis">p</i>
3      <b class="bold">do</b> augment flow <i class="emphasis">f</i> along <i class="emphasis">p</i>
4  <b class="bold">return</b> <i class="emphasis">f</i>
</pre>
</div>
<div class="section">
<h4 class="sect4-title">
<a name="1991"></a><a name="ch26lev3sec5"></a>Residual networks</h4>
<p class="first-para">Intuitively, given a flow network and a flow, the residual network consists of edges that can admit more flow. More formally, suppose that we have a flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) with source <i class="emphasis">s</i> and sink <i class="emphasis">t</i>. Let <i class="emphasis">f</i> be a flow in <i class="emphasis">G</i>, and consider a pair of vertices <i class="emphasis">u</i>, <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>. The amount of <i class="emphasis">additional</i> flow we can push from <i class="emphasis">u</i> to <i class="emphasis">v</i> before exceeding the capacity <i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) is the <b class="bold"><i class="emphasis">residual capacity</i></b> of (<i class="emphasis">u</i>, <i class="emphasis">v</i>), given by</p>
<div class="equation">
<a name="1992"></a><a name="ch26eq05"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(26.5)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig673_01.jpg" height="17" width="179" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">For example, if <i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = 16 and <i class="emphasis">f</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = 11, then we can increase <i class="emphasis">f</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) by <i class="emphasis">c<sub>f</sub></i> (<i class="emphasis">u</i>, <i class="emphasis">v</i>) = 5 units before we exceed the capacity constraint on edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>). When the flow <i class="emphasis">f</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) is negative, the residual capacity <i class="emphasis">c<sub>f</sub></i> (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is greater than the capacity <i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>). For example, if <i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = 16 and <i class="emphasis">f</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = -4, then the residual capacity <i class="emphasis">c<sub>f</sub></i> (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is 20. We can interpret this situation as follows. There is a flow of 4 units from <i class="emphasis">v</i> to <i class="emphasis">u</i>, which we can cancel by pushing a flow of 4 units <a name="1993"></a><a name="IDX-652"></a>from <i class="emphasis">u</i> to <i class="emphasis">v</i>. We can then push another 16 units from <i class="emphasis">u</i> to <i class="emphasis">v</i> before violating the capacity constraint on edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>). We have thus pushed an additional 20 units of flow, starting with a flow <i class="emphasis">f</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = -4, before reaching the capacity constraint.</p>
<p class="para">Given a flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) and a flow <i class="emphasis">f</i>, the <b class="bold"><i class="emphasis">residual network</i></b> of <i class="emphasis">G</i> induced by <i class="emphasis">f</i> is <i class="emphasis">G<sub>f</sub></i> = (<i class="emphasis">V</i>, <i class="emphasis">E<sub>f</sub></i>), where</p>
<p class="para">
<i class="emphasis">E<sub>f</sub></i> = {(<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">V</i> <span class="unicode">&times;</span> <i class="emphasis">V</i> : <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&gt;</span> 0}.</p>
<p class="para">That is, as promised above, each edge of the residual network, or <b class="bold"><i class="emphasis">residual edge</i></b>, can admit a flow that is greater than 0. <a class="internaljump" href="#ch26fig03">Figure 26.3(a)</a> repeats the flow network <i class="emphasis">G</i> and flow <i class="emphasis">f</i> of <a href="DDU0161.html#1966" target="_parent" class="chapterjump">Figure 26.1(b)</a>, and <a class="internaljump" href="#ch26fig03">Figure 26.3(b)</a> shows the corresponding residual network <i class="emphasis">G<sub>f</sub></i>.</p>
<div class="figure">
<a name="1994"></a><a name="ch26fig03"></a><span class="figuremediaobject"><a href="images/fig674%5F01%5F0%2Ejpg" NAME="IMG_871" target="_parent"><img src="images/fig674_01.jpg" height="177" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 26.3: </span><i class="emphasis">(a)</i> The flow network <i class="emphasis">G</i> and flow <i class="emphasis">f</i> of Figure 26.1(b). <i class="emphasis">(b)</i> The residual network <i class="emphasis">G<sub>f</sub></i> with augmenting path <i class="emphasis">p</i> shaded; its residual capacity is <i class="emphasis">c<sub>f</sub></i> (<i class="emphasis">p</i>) = <i class="emphasis">c</i>(<i class="emphasis">v</i><sub>2</sub>, <i class="emphasis">v</i><sub>3</sub>) = 4. <i class="emphasis">(c)</i> The flow in <i class="emphasis">G</i> that results from augmenting along path <i class="emphasis">p</i> by its residual capacity 4. <i class="emphasis">(d)</i> The residual network induced by the flow in (c).</span>
</div>
<p class="para">The edges in <i class="emphasis">E<sub>f</sub></i> are either edges in <i class="emphasis">E</i> or their reversals. If <i class="emphasis">f</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&lt;</span> <i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) for an edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>, then <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = <i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) - <i class="emphasis">f</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&gt;</span> 0 and (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E<sub>f</sub></i>. If <i class="emphasis">f</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&gt;</span> 0 for an edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>, then <i class="emphasis">f</i> (<i class="emphasis">v</i>, <i class="emphasis">u</i>) <span class="unicode">&lt;</span> 0. In this case, <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">v</i>, <i class="emphasis">u</i>) = <i class="emphasis">c</i>(<i class="emphasis">v</i>, <i class="emphasis">u</i>) - <i class="emphasis">f</i>(<i class="emphasis">v</i>, <i class="emphasis">u</i>) <span class="unicode">&gt;</span> 0, and so (<i class="emphasis">v</i>, <i class="emphasis">u</i>) <span class="unicode">&isin;</span> <i class="emphasis">E<sub>f</sub></i>. If neither (<i class="emphasis">u</i>, <i class="emphasis">v</i>) nor (<i class="emphasis">v</i>, <i class="emphasis">u</i>) appears in the original network, then <i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = <i class="emphasis">c</i>(<i class="emphasis">v</i>, <i class="emphasis">u</i>) = 0, <i class="emphasis">f</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>)<span class="unicode">&gt;</span> = <i class="emphasis">f</i>(<i class="emphasis">v</i>, <i class="emphasis">u</i>) = 0 (by <a href="DDU0161.html#1978" target="_parent" class="chapterjump">Exercise 26.1-1</a>), and <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">v</i>, <i class="emphasis">u</i>) = 0. We conclude that an edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) can appear in a residual network only if at least one of (<i class="emphasis">u</i>, <i class="emphasis">v</i>) and (<i class="emphasis">v</i>, <i class="emphasis">u</i>) appears in the original network, and thus</p>
<p class="para">|<i class="emphasis">E<sub>f</sub></i>| <span class="unicode">&le;</span> 2 |<i class="emphasis">E</i>|.<a name="1995"></a><a name="IDX-653"></a>
</p>
<p class="para">Observe that the residual network <i class="emphasis">G<sub>f</sub></i> is itself a flow network with capacities given by <i class="emphasis">c<sub>f</sub></i>. The following lemma shows how a flow in a residual network relates to a flow in the original flow network.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 26.2</span></span><a name="1996"></a><a name="ch26ex11"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a flow network with source <i class="emphasis">s</i> and sink <i class="emphasis">t</i>, and let <i class="emphasis">f</i> be a flow in <i class="emphasis">G</i>. Let <i class="emphasis">G<sub>f</sub></i> be the residual network of <i class="emphasis">G</i> induced by <i class="emphasis">f</i>, and let <i class="emphasis">f</i>' be a flow in <i class="emphasis">G<sub>f</sub></i>. Then the flow sum <i class="emphasis">f</i> + <i class="emphasis">f</i>' defined by equation (<a href="DDU0161.html#1985" target="_parent" class="chapterjump">26.4</a>) is a flow in <i class="emphasis">G</i> with value |<i class="emphasis">f</i> + <i class="emphasis">f</i>'| = |<i class="emphasis">f</i>| + |<i class="emphasis">f</i>'|.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> We must verify that skew symmetry, the capacity constraints, and flow conservation are obeyed. For skew symmetry, note that for all <i class="emphasis">u</i>, <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, we have</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">(<i class="emphasis">f</i> + <i class="emphasis">f</i>')(<i class="emphasis">u</i>, <i class="emphasis">v</i>)</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">f</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) + <i class="emphasis">f</i>'(<i class="emphasis">u</i>, <i class="emphasis">v</i>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">-<i class="emphasis">f</i>(<i class="emphasis">v</i>, <i class="emphasis">u</i>) - <i class="emphasis">f</i>'(<i class="emphasis">v</i>, <i class="emphasis">u</i>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">-(<i class="emphasis">f</i>(<i class="emphasis">v</i>, <i class="emphasis">u</i>) + <i class="emphasis">f</i>'(<i class="emphasis">v</i>, <i class="emphasis">u</i>))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">-(<i class="emphasis">f</i> + <i class="emphasis">f</i>')(<i class="emphasis">v</i>, <i class="emphasis">u</i>).</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">For the capacity constraints, note that <i class="emphasis">f</i>'(<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&le;</span> <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) for all <i class="emphasis">u</i>, <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>. By equation (<a class="internaljump" href="#ch26eq05">26.5</a>), therefore,</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">(<i class="emphasis">f</i> + <i class="emphasis">f</i>')(<i class="emphasis">u</i>, <i class="emphasis">v</i>)</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">f</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) + <i class="emphasis">f</i>'(<i class="emphasis">u</i>, <i class="emphasis">v</i>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&le;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">f</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) + (<i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) - <i class="emphasis">f</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>).</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">For flow conservation, note that for all <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> - {<i class="emphasis">s</i>, <i class="emphasis">t</i>}, we have</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig675_01.jpg" height="109" width="301" alt="" border="0"></span>
</div>
<p class="para">Finally, we have</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig675_02.jpg" height="129" width="240" alt="" border="0"></span>
</div>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="1997"></a><a name="IDX-654"></a>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="1998"></a><a name="ch26lev3sec6"></a>Augmenting paths</h4>
<p class="first-para">Given a flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) and a flow <i class="emphasis">f</i>, an <b class="bold"><i class="emphasis">augmenting path</i></b> <i class="emphasis">p</i> is a simple path from <i class="emphasis">s</i> to <i class="emphasis">t</i> in the residual network <i class="emphasis">G<sub>f</sub></i>. By the definition of the residual network, each edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) on an augmenting path admits some additional positive flow from <i class="emphasis">u</i> to <i class="emphasis">v</i> without violating the capacity constraint on the edge.</p>
<p class="para">The shaded path in <a class="internaljump" href="#ch26fig03">Figure 26.3(b)</a> is an augmenting path. Treating the residual network <i class="emphasis">G<sub>f</sub></i> in the figure as a flow network, we can increase the flow through each edge of this path by up to 4 units without violating a capacity constraint, since the smallest residual capacity on this path is <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">v</i><sub>2</sub>, <i class="emphasis">v</i><sub>3</sub>) = 4. We call the maximum amount by which we can increase the flow on each edge in an augmenting path <i class="emphasis">p</i> the <b class="bold"><i class="emphasis">residual capacity</i></b> of <i class="emphasis">p</i>, given by</p>
<p class="para">
<i class="emphasis">c<sub>f</sub></i> (<i class="emphasis">p</i>) = min {<i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) : (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is on <i class="emphasis">p</i>}.</p>
<p class="para">The following lemma, whose proof is left as <a class="internaljump" href="#ch26ex25">Exercise 26.2-7</a>, makes the above argument more precise.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 26.3</span></span><a name="1999"></a><a name="ch26ex12"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a flow network, let <i class="emphasis">f</i> be a flow in <i class="emphasis">G</i>, and let <i class="emphasis">p</i> be an augmenting path in <i class="emphasis">G<sub>f</sub></i>. Define a function <i class="emphasis">f<sub>p</sub></i> : <i class="emphasis">V</i> <span class="unicode">&times;</span> <i class="emphasis">V</i> <span class="unicode">&rarr;</span> <b class="bold">R</b> by</p>
<p class="para">
<div class="equation">
<a name="2000"></a><a name="ch26eq06"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(26.6)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig676_01.jpg" height="55" width="239" alt="" border="0"></span></td>
</tr>
</table>
</div>
</p>
<p class="last-para">Then, <i class="emphasis">f<sub>p</sub></i> is a flow in <i class="emphasis">G<sub>f</sub></i> with value |<i class="emphasis">f<sub>p</sub></i>| = <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">p</i>) <span class="unicode">&gt;</span> 0.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">The following corollary shows that if we add <i class="emphasis">f<sub>p</sub></i> to <i class="emphasis">f</i>, we get another flow in <i class="emphasis">G</i> whose value is closer to the maximum. <a class="internaljump" href="#ch26fig03">Figure 26.3(c)</a> shows the result of adding <i class="emphasis">f<sub>p</sub></i> in <a class="internaljump" href="#ch26fig03">Figure 26.3(b)</a> to <i class="emphasis">f</i> from <a class="internaljump" href="#ch26fig03">Figure 26.3(a)</a>.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Corollary 26.4</span></span><a name="2001"></a><a name="ch26ex13"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a flow network, let <i class="emphasis">f</i> be a flow in <i class="emphasis">G</i>, and let <i class="emphasis">p</i> be an augmenting path in <i class="emphasis">G<sub>f</sub></i>. Let <i class="emphasis">f<sub>p</sub></i> be defined as in equation (<a class="internaljump" href="#ch26eq06">26.6</a>). Define a function <i class="emphasis">f</i>' : <i class="emphasis">V</i> <span class="unicode">&times;</span> <i class="emphasis">V</i> <span class="unicode">&rarr;</span> <b class="bold">R</b> by <i class="emphasis">f</i>' = <i class="emphasis">f</i> + <i class="emphasis">f<sub>p</sub></i>. Then <i class="emphasis">f</i>' is a flow in <i class="emphasis">G</i> with value |<i class="emphasis">f</i>'| = |<i class="emphasis">f</i>| + |<i class="emphasis">f<sub>p</sub></i>| <span class="unicode">&gt;</span> |<i class="emphasis">f</i>|.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Immediate from <a class="internaljump" href="#ch26ex11">Lemmas 26.2</a> and <a class="internaljump" href="#ch26ex12">26.3</a>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="2002"></a><a name="ch26lev3sec7"></a>Cuts of flow networks</h4>
<p class="first-para">The Ford-Fulkerson method repeatedly augments the flow along augmenting paths until a maximum flow has been found. The max-flow min-cut theorem, which <a name="2003"></a><a name="IDX-655"></a>we shall prove shortly, tells us that a flow is maximum if and only if its residual network contains no augmenting path. To prove this theorem, though, we must first explore the notion of a cut of a flow network.</p>
<p class="para">A <b class="bold"><i class="emphasis">cut</i></b> (<i class="emphasis">S</i>, <i class="emphasis">T</i>) of flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) is a partition of <i class="emphasis">V</i> into <i class="emphasis">S</i> and <i class="emphasis">T</i> = <i class="emphasis">V</i> - <i class="emphasis">S</i> such that <i class="emphasis">s</i> <span class="unicode">&isin;</span> <i class="emphasis">S</i> and <i class="emphasis">t</i> <span class="unicode">&isin;</span> <i class="emphasis">T</i>. (This definition is similar to the definition of "cut" that we used for minimum spanning trees in <a href="DDU0135.html#1692" target="_parent" class="chapterjump">Chapter 23</a>, except that here we are cutting a directed graph rather than an undirected graph, and we insist that <i class="emphasis">s</i> <span class="unicode">&isin;</span> <i class="emphasis">S</i> and <i class="emphasis">t</i> <span class="unicode">&isin;</span> <i class="emphasis">T</i>.) If <i class="emphasis">f</i> is a flow, then the <b class="bold"><i class="emphasis">net flow</i></b> across the cut (<i class="emphasis">S</i>, <i class="emphasis">T</i>) is defined to be <i class="emphasis">f</i>(<i class="emphasis">S</i>, <i class="emphasis">T</i>). The <b class="bold"><i class="emphasis">capacity</i></b> of the cut (<i class="emphasis">S</i>, <i class="emphasis">T</i>) is <i class="emphasis">c</i>(<i class="emphasis">S</i>, <i class="emphasis">T</i>). A <b class="bold"><i class="emphasis">minimum cut</i></b> of a network is a cut whose capacity is minimum over all cuts of the network.</p>
<p class="para">
<a class="internaljump" href="#ch26fig04">Figure 26.4</a> shows the cut ({<i class="emphasis">s</i>, <i class="emphasis">v</i><sub>1</sub>, <i class="emphasis">v</i><sub>2</sub>}, {<i class="emphasis">v</i><sub>3</sub>, <i class="emphasis">v</i><sub>4</sub>, <i class="emphasis">t</i>}) in the flow network of <a href="DDU0161.html#1966" target="_parent" class="chapterjump">Figure 26.1(b)</a>. The net flow across this cut is</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">f</i>(<i class="emphasis">v</i><sub>1</sub>, <i class="emphasis">v</i><sub>3</sub>) + <i class="emphasis">f</i>(<i class="emphasis">v</i><sub>2</sub>, <i class="emphasis">v</i><sub>3</sub>) + <i class="emphasis">f</i>(<i class="emphasis">v</i><sub>2</sub>, <i class="emphasis">v</i><sub>4</sub>)</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">12 + (-4) + 11</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">19,</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">and its capacity is</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">c</i>(<i class="emphasis">v</i><sub>1</sub>, <i class="emphasis">v</i><sub>3</sub>) + <i class="emphasis">c</i>(<i class="emphasis">v</i><sub>2</sub>, <i class="emphasis">v</i><sub>4</sub>)</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">12 + 14</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">26.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="figure">
<a name="2004"></a><a name="ch26fig04"></a><span class="figuremediaobject"><a href="images/fig677%5F01%5F0%2Ejpg" NAME="IMG_875" target="_parent"><img src="images/fig677_01.jpg" height="118" width="222" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 26.4: </span>A cut (<i class="emphasis">S, T</i>) in the flow network of Figure 26.1(b), where <i class="emphasis">S</i> = {<i class="emphasis">s, v</i><sub>1</sub>, <i class="emphasis">v</i><sub>2</sub>} and <i class="emphasis">T</i> = {<i class="emphasis">v</i><sub>3</sub>, <i class="emphasis">v</i><sub>4</sub>, <i class="emphasis">t</i>}. The vertices in <i class="emphasis">S</i> are black, and the vertices in <i class="emphasis">T</i> are white. The net flow across (<i class="emphasis">S, T</i>) is <i class="emphasis">f</i>(<i class="emphasis">S, T</i>) = 19, and the capacity is <i class="emphasis">c</i>(<i class="emphasis">S, T</i>) = 26.</span>
</div>
<p class="para">Observe that the net flow across a cut can include negative flows between vertices, but that the capacity of a cut is composed entirely of nonnegative values. In other words, the net flow across a cut (<i class="emphasis">S</i>, <i class="emphasis">T</i>) consists of positive flows in both directions; positive flow from <i class="emphasis">S</i> to <i class="emphasis">T</i> is added while positive flow from <i class="emphasis">T</i> to <i class="emphasis">S</i> is subtracted. On the other hand, the capacity of a cut (<i class="emphasis">S</i>, <i class="emphasis">T</i>) is computed only from edges going from <i class="emphasis">S</i> to <i class="emphasis">T</i>. Edges going from <i class="emphasis">T</i> to <i class="emphasis">S</i> are not included in the computation of <i class="emphasis">c</i>(<i class="emphasis">S</i>, <i class="emphasis">T</i>).</p>
<p class="para">The following lemma shows that the net flow across any cut is the same, and it equals the value of the flow.<a name="2005"></a><a name="IDX-656"></a>
</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 26.5</span></span><a name="2006"></a><a name="ch26ex14"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">f</i> be a flow in a flow network <i class="emphasis">G</i> with source <i class="emphasis">s</i> and sink <i class="emphasis">t</i>, and let (<i class="emphasis">S</i>, <i class="emphasis">T</i>) be a cut of <i class="emphasis">G</i>. Then the net flow across (<i class="emphasis">S</i>, <i class="emphasis">T</i>) is <i class="emphasis">f</i>(<i class="emphasis">S</i>, <i class="emphasis">T</i>) = |<i class="emphasis">f</i>|.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> Noting that <i class="emphasis">f</i> (<i class="emphasis">S</i> - <i class="emphasis">s</i>, <i class="emphasis">V</i>) = 0 by flow conservation, we have</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">f</i>(<i class="emphasis">S</i>, <i class="emphasis">T</i>)</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">f</i> (<i class="emphasis">S</i>, <i class="emphasis">V</i>) - <i class="emphasis">f</i>(<i class="emphasis">S</i>, <i class="emphasis">S</i>)</p>
</td><td class="td" align="left">
<p class="table-para">(by <a href="DDU0161.html#1976" target="_parent" class="chapterjump">Lemma 26.1</a>, part (3))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">f</i>(<i class="emphasis">S</i>, <i class="emphasis">V</i>)</p>
</td><td class="td" align="left">
<p class="table-para">(by <a href="DDU0161.html#1976" target="_parent" class="chapterjump">Lemma 26.1</a>, part (1))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">f</i>(<i class="emphasis">s</i>, <i class="emphasis">V</i>) + <i class="emphasis">f</i>(<i class="emphasis">S</i> - <i class="emphasis">s</i>, <i class="emphasis">V</i>)</p>
</td><td class="td" align="left">
<p class="table-para">(by <a href="DDU0161.html#1976" target="_parent" class="chapterjump">Lemma 26.1</a>, part (3))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">f</i>(<i class="emphasis">s</i>, <i class="emphasis">V</i>)</p>
</td><td class="td" align="left">
<p class="table-para">(since <i class="emphasis">f</i>(<i class="emphasis">S</i> - <i class="emphasis">s</i>, <i class="emphasis">V</i>) = 0)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">|<i class="emphasis">f</i>|.</p>
</td><td class="td" align="left">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">An immediate corollary to <a class="internaljump" href="#ch26ex14">Lemma 26.5</a> is the result we proved earlier<span class="unicode">-</span>equation (<a href="DDU0161.html#1977" target="_parent" class="chapterjump">26.3</a>)<span class="unicode">-</span>that the value of a flow is the total flow into the sink.</p>
<p class="para">Another corollary to <a class="internaljump" href="#ch26ex14">Lemma 26.5</a> shows how cut capacities can be used to bound the value of a flow.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Corollary 26.6</span></span><a name="2007"></a><a name="ch26ex15"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The value of any flow <i class="emphasis">f</i> in a flow network <i class="emphasis">G</i> is bounded from above by the capacity of any cut of <i class="emphasis">G</i>.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> Let (<i class="emphasis">S</i>, <i class="emphasis">T</i>) be any cut of <i class="emphasis">G</i> and let <i class="emphasis">f</i> be any flow. By <a class="internaljump" href="#ch26ex14">Lemma 26.5</a> and the capacity constraints,</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig678_01.jpg" height="107" width="147" alt="" border="0"></span>
</div>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">An immediate consequence of <a class="internaljump" href="#ch26ex15">Corollary 26.6</a> is that the maximum flow in a network is bounded above by the capacity of a minimum cut of the network. The important max-flow min-cut theorem, which we now state and prove, says that the value of a maximum flow is in fact equal to the capacity of a minimum cut.<a name="2008"></a><a name="IDX-657"></a>
</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 26.7: </span>(Max-flow min-cut theorem)</span><a name="2009"></a><a name="ch26ex16"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">If <i class="emphasis">f</i> is a flow in a flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) with source <i class="emphasis">s</i> and sink <i class="emphasis">t</i>, then the following conditions are equivalent:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="first-para">
<i class="emphasis">f</i> is a maximum flow in <i class="emphasis">G</i>.</p>
</li>
<li class="listitem">
<p class="first-para">The residual network <i class="emphasis">G<sub>f</sub></i> contains no augmenting paths.</p>
</li>
<li class="listitem">
<p class="first-para">|<i class="emphasis">f</i>| = <i class="emphasis">c</i>(<i class="emphasis">S</i>, <i class="emphasis">T</i>) for some cut (<i class="emphasis">S</i>, <i class="emphasis">T</i>) of <i class="emphasis">G</i>.</p>
</li>
</ol>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> (1) <span class="unicode">&rArr;</span> (2): Suppose for the sake of contradiction that <i class="emphasis">f</i> is a maximum flow in <i class="emphasis">G</i> but that <i class="emphasis">G<sub>f</sub></i> has an augmenting path <i class="emphasis">p</i>. Then, by <a class="internaljump" href="#ch26ex13">Corollary 26.4</a>, the flow sum <i class="emphasis">f</i> + <i class="emphasis">f<sub>p</sub></i>, where <i class="emphasis">f<sub>p</sub></i> is given by equation (<a class="internaljump" href="#ch26eq06">26.6</a>), is a flow in <i class="emphasis">G</i> with value strictly greater than |<i class="emphasis">f</i>|, contradicting the assumption that <i class="emphasis">f</i> is a maximum flow.</p>
<p class="para">(2) <span class="unicode">&rArr;</span> (3): Suppose that <i class="emphasis">G<sub>f</sub></i> has no augmenting path, that is, that <i class="emphasis">G<sub>f</sub></i> contains no path from <i class="emphasis">s</i> to <i class="emphasis">t</i>. Define</p>
<p class="para">
<i class="emphasis">S</i> = {<i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> : there exists a path from <i class="emphasis">s</i> to <i class="emphasis">v</i> in <i class="emphasis">G<sub>f</sub></i>}</p>
<p class="para">and <i class="emphasis">T</i> = <i class="emphasis">V</i> - <i class="emphasis">S</i>. The partition (<i class="emphasis">S</i>, <i class="emphasis">T</i>) is a cut: we have <i class="emphasis">s</i> <span class="unicode">&isin;</span> <i class="emphasis">S</i> trivially and <i class="emphasis">t</i> <span class="unicode">&notin;</span> <i class="emphasis">S</i> be cause there is no path from <i class="emphasis">s</i> to <i class="emphasis">t</i> in <i class="emphasis">G<sub>f</sub></i>. For each pair of vertices <i class="emphasis">u</i> and <i class="emphasis">v</i> such that <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">S</i> and <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">T</i>, we have <i class="emphasis">f</i> (<i class="emphasis">u</i>, <i class="emphasis">v</i>) = <i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>), since otherwise (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E<sub>f</sub></i>, which would place <i class="emphasis">v</i> in set <i class="emphasis">S</i>. By <a class="internaljump" href="#ch26ex14">Lemma 26.5</a>, therefore, |<i class="emphasis">f</i>| = <i class="emphasis">f</i>(<i class="emphasis">S</i>, <i class="emphasis">T</i>) = <i class="emphasis">c</i>(<i class="emphasis">S</i>, <i class="emphasis">T</i>).</p>
<p class="last-para">(3) <span class="unicode">&rArr;</span> (1): By <a class="internaljump" href="#ch26ex15">Corollary 26.6</a>, |<i class="emphasis">f</i>| <span class="unicode">&le;</span> <i class="emphasis">c</i>(<i class="emphasis">S</i>, <i class="emphasis">T</i>) for all cuts (<i class="emphasis">S</i>, <i class="emphasis">T</i>). The condition |<i class="emphasis">f</i>| = <i class="emphasis">c</i>(<i class="emphasis">S</i>, <i class="emphasis">T</i>) thus implies that <i class="emphasis">f</i> is a maximum flow.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="2010"></a><a name="ch26lev3sec8"></a>The basic Ford-Fulkerson algorithm</h4>
<p class="first-para">In each iteration of the Ford-Fulkerson method, we find <i class="emphasis">some</i> augmenting path <i class="emphasis">p</i> and increase the flow <i class="emphasis">f</i> on each edge of <i class="emphasis">p</i> by the residual capacity <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">p</i>). The following implementation of the method computes the maximum flow in a graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) by updating the flow <i class="emphasis">f</i>[<i class="emphasis">u</i>, <i class="emphasis">v</i>] between each pair <i class="emphasis">u</i>, <i class="emphasis">v</i> of vertices that are connected by an edge.<sup>[<a name="N2846" href="#ftn.N2846">1</a>]</sup> If <i class="emphasis">u</i> and <i class="emphasis">v</i> are not connected by an edge in either direction, we assume implicitly that <i class="emphasis">f</i>[<i class="emphasis">u</i>, <i class="emphasis">v</i>] = 0. The capacities <i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) are assumed to be given along with the graph, and <i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = 0 if (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&notin;</span> <i class="emphasis">E</i>. The residual capacity <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) is computed in accordance with the formula (<a class="internaljump" href="#ch26eq05">26.5</a>). The expression <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">p</i>) in the code is actually just a temporary variable that stores the residual capacity of the path <i class="emphasis">p</i>.<a name="2011"></a><a name="IDX-658"></a>
</p>
<div class="informalexample">
<pre class="literallayout-normal">
FORD-FULKERSON(<i class="emphasis">G</i>, <i class="emphasis">s</i>, <i class="emphasis">t</i>)
1  <b class="bold">for</b> each edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>[<i class="emphasis">G</i>]
2       <b class="bold">do</b> <i class="emphasis">f</i>[<i class="emphasis">u</i>, <i class="emphasis">v</i>] <span class="unicode">&larr;</span> 0
3          <i class="emphasis">f</i>[<i class="emphasis">v</i>, <i class="emphasis">u</i>] <span class="unicode">&larr;</span> 0
4  <b class="bold">while</b> there exists a path <i class="emphasis">p</i> from <i class="emphasis">s</i> to <i class="emphasis">t</i> in the residual network <i class="emphasis">G<sub>f</sub></i>
5      <b class="bold">do</b> <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">p</i>) <span class="unicode">&larr;</span> min {<i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) : (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is in <i class="emphasis">p</i>}
6         <b class="bold">for</b> each edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) in <i class="emphasis">p</i>
7             <b class="bold">do</b> <i class="emphasis">f</i>[<i class="emphasis">u</i>, <i class="emphasis">v</i>] <span class="unicode">&larr;</span> <i class="emphasis">f</i>[<i class="emphasis">u</i>, <i class="emphasis">v</i>] + <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">p</i>)
8                <i class="emphasis">f</i>[<i class="emphasis">v</i>, <i class="emphasis">u</i>] <span class="unicode">&larr;</span> -<i class="emphasis">f</i>[<i class="emphasis">u</i>, <i class="emphasis">v</i>]
</pre>
</div>
<p class="para">The FORD-FULKERSON algorithm simply expands on the FORD-FULKERSON-METHOD pseudocode given earlier. <a class="internaljump" href="#ch26fig05">Figure 26.5</a> shows the result of each iteration in a sample run. Lines 1<span class="unicode">-</span>3 initialize the flow <i class="emphasis">f</i> to 0. The <b class="bold">while</b> loop of lines 4<span class="unicode">-</span>8 repeatedly finds an augmenting path <i class="emphasis">p</i> in <i class="emphasis">G<sub>f</sub></i> and augments flow <i class="emphasis">f</i> along <i class="emphasis">p</i> by the residual capacity <i class="emphasis">c<sub>f</sub></i> (<i class="emphasis">p</i>). When no augmenting paths exist, the flow <i class="emphasis">f</i> is a maximum flow.</p>
<div class="figure">
<a name="2012"></a><a name="ch26fig05"></a><span class="figuremediaobject"><a href="images/fig681%5F01%5F0%2Ejpg" NAME="IMG_877" target="_parent"><img src="images/fig681_01.jpg" height="357" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 26.5: </span>The execution of the basic Ford-Fulkerson algorithm. <i class="emphasis">(a)<span class="unicode">-</span>(d)</i> Successive iterations of the <i class="emphasis">while</i> loop. The left side of each part shows the residual network <i class="emphasis">G<sub>f</sub></i> from line 4 with a shaded augmenting path <i class="emphasis">p</i>. The right side of each part shows the new flow <i class="emphasis">f</i> that results from adding <i class="emphasis">f<sub>p</sub></i> to <i class="emphasis">f</i>. The residual network in (a) is the input network <i class="emphasis">G</i>. <i class="emphasis">(e)</i> The residual network at the last <i class="emphasis">while</i> loop test. It has no augmenting paths, and the flow <i class="emphasis">f</i> shown in (d) is therefore a maximum flow.</span>
</div>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="2013"></a><a name="ch26lev3sec9"></a>Analysis of Ford-Fulkerson</h4>
<p class="first-para">The running time of FORD-FULKERSON depends on how the augmenting path <i class="emphasis">p</i> in line 4 is determined. If it is chosen poorly, the algorithm might not even terminate: the value of the flow will increase with successive augmentations, but it need not even converge to the maximum flow value.<sup>[<a name="N3250" href="#ftn.N3250">2</a>]</sup> If the augmenting path is chosen by using a breadth-first search (which we saw in <a href="DDU0130.html#1596" target="_parent" class="chapterjump">Section 22.2</a>), however, the algorithm runs in polynomial time. Before proving this result, however, we obtain a simple bound for the case in which the augmenting path is chosen arbitrarily and all capacities are integers.</p>
<p class="para">Most often in practice, the maximum-flow problem arises with integral capacities. If the capacities are rational numbers, an appropriate scaling transformation can be used to make them all integral. Under this assumption, a straightforward implementation of FORD-FULKERSON runs in time <i class="emphasis">O</i>(<i class="emphasis">E</i> | <i class="emphasis">f</i>*|), where <i class="emphasis">f</i>* is the maximum flow found by the algorithm. The analysis is as follows. Lines 1<span class="unicode">-</span>3 take time <span class="unicode">&Theta;</span>(<i class="emphasis">E</i>). The <b class="bold">while</b> loop of lines 4<span class="unicode">-</span>8 is executed at most |<i class="emphasis">f</i>*| times, since the flow value increases by at least one unit in each iteration.</p>
<p class="para">The work done within the <b class="bold">while</b> loop can be made efficient if we efficiently manage the data structure used to implement the network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>). Let us assume that we keep a data structure corresponding to a directed graph <i class="emphasis">G</i>' = (<i class="emphasis">V</i>, <i class="emphasis">E</i>'), where <i class="emphasis">E</i>' = {(<i class="emphasis">u</i>, <i class="emphasis">v</i>) : (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i> or (<i class="emphasis">v</i>, <i class="emphasis">u</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>}. Edges in the network <i class="emphasis">G</i> are also <a name="2014"></a><a name="IDX-659"></a><a name="2015"></a><a name="IDX-660"></a>edges in <i class="emphasis">G</i>', and it is therefore a simple matter to maintain capacities and flows in this data structure. Given a flow <i class="emphasis">f</i> on <i class="emphasis">G</i>, the edges in the residual network <i class="emphasis">G<sub>f</sub></i> consist of all edges (<i class="emphasis">u</i>, <i class="emphasis">v</i>) of <i class="emphasis">G</i>' such that <i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>)- <i class="emphasis">f</i>[<i class="emphasis">u</i>, <i class="emphasis">v</i>] <span class="unicode">&ne;</span> 0. The time to find a path in a residual network is therefore <i class="emphasis">O</i>(<i class="emphasis">V</i> + <i class="emphasis">E</i>') = <i class="emphasis">O</i>(<i class="emphasis">E</i>) if we use either depth-first search or breadth-first search. Each iteration of the <b class="bold">while</b> loop thus takes <i class="emphasis">O</i>(<i class="emphasis">E</i>) time, making the total running time of FORD-FULKERSON <i class="emphasis">O</i>(<i class="emphasis">E</i> | <i class="emphasis">f</i>*|).</p>
<p class="para">When the capacities are integral and the optimal flow value | <i class="emphasis">f</i>*| is small, the running time of the Ford-Fulkerson algorithm is good. <a class="internaljump" href="#ch26fig06">Figure 26.6(a)</a> shows an example of what can happen on a simple flow network for which | <i class="emphasis">f</i>*| is large. A maximum flow in this network has value 2,000,000: 1,000,000 units of flow traverse the path <i class="emphasis">s</i> <span class="unicode">&rarr;</span> <i class="emphasis">u</i> <span class="unicode">&rarr;</span> <i class="emphasis">t</i>, and another 1,000,000 units traverse the path <i class="emphasis">s</i> <span class="unicode">&rarr;</span> <i class="emphasis">v</i> <span class="unicode">&rarr;</span> <i class="emphasis">t</i>. If the first augmenting path found by FORD-FULKERSON is <i class="emphasis">s</i> <span class="unicode">&rarr;</span> <i class="emphasis">u</i> <span class="unicode">&rarr;</span> <i class="emphasis">v</i> <span class="unicode">&rarr;</span> <i class="emphasis">t</i>, shown in <a class="internaljump" href="#ch26fig06">Figure 26.6(a)</a>, the flow has value 1 after the first iteration. The resulting residual network is shown in <a class="internaljump" href="#ch26fig06">Figure 26.6(b)</a>. If the second iteration finds the augmenting path <i class="emphasis">s</i> <span class="unicode">&rarr;</span> <i class="emphasis">v</i> <span class="unicode">&rarr;</span> <i class="emphasis">u</i> <span class="unicode">&rarr;</span> <i class="emphasis">t</i>, as shown in <a class="internaljump" href="#ch26fig06">Figure 26.6(b)</a>, the flow then has value 2. <a class="internaljump" href="#ch26fig06">Figure 26.6(c)</a> shows the resulting residual network. We can continue, choosing the augmenting path <i class="emphasis">s</i> <span class="unicode">&rarr;</span> <i class="emphasis">u</i> <span class="unicode">&rarr;</span> <i class="emphasis">v</i> <span class="unicode">&rarr;</span> <i class="emphasis">t</i> in the odd-numbered iterations and the augmenting path <i class="emphasis">s</i> <span class="unicode">&rarr;</span> <i class="emphasis">v</i> <span class="unicode">&rarr;</span> <i class="emphasis">u</i> <span class="unicode">&rarr;</span> <i class="emphasis">t</i> in the even-numbered iterations. We would perform a total of 2,000,000 augmentations, increasing the flow value by only 1 unit in each.</p>
<div class="figure">
<a name="2016"></a><a name="ch26fig06"></a><span class="figuremediaobject"><a href="images/fig682%5F01%5F0%2Ejpg" NAME="IMG_878" target="_parent"><img src="images/fig682_01.jpg" height="81" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 26.6: </span><i class="emphasis">(a)</i> A flow network for which FORD-FULKERSON can take <span class="unicode">&Theta;</span>(<i class="emphasis">E</i> |<i class="emphasis">f</i>*|) time, where <i class="emphasis">f</i>* is a maximum flow, shown here with |<i class="emphasis">f</i>*| = 2,000,000. An augmenting path with residual capacity 1 is shown. <i class="emphasis">(b)</i> The resulting residual network. Another augmenting path with residual capacity 1 is shown. <i class="emphasis">(c)</i> The resulting residual network.</span>
</div>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="2017"></a><a name="ch26lev3sec10"></a>The Edmonds-Karp algorithm</h4>
<p class="first-para">The bound on FORD-FULKERSON can be improved if we implement the computation of the augmenting path <i class="emphasis">p</i> in line 4 with a breadth-first search, that is, if the augmenting path is a <i class="emphasis">shortest</i> path from <i class="emphasis">s</i> to <i class="emphasis">t</i> in the residual network, where each edge has unit distance (weight). We call the Ford-Fulkerson method so im<a name="2018"></a><a name="IDX-661"></a>plemented the <b class="bold"><i class="emphasis">Edmonds-Karp algorithm</i></b>. We now prove that the Edmonds-Karp algorithm runs in <i class="emphasis">O</i>(<i class="emphasis">V E</i><sup>2</sup>) time.</p>
<p class="para">The analysis depends on the distances to vertices in the residual network <i class="emphasis">G<sub>f</sub></i>. The following lemma uses the notation <i class="emphasis"><span class="unicode">&delta;</span><sub>f</sub></i> (<i class="emphasis">u</i>, <i class="emphasis">v</i>) for the shortest-path distance from <i class="emphasis">u</i> to <i class="emphasis">v</i> in <i class="emphasis">G<sub>f</sub></i>, where each edge has unit distance.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 26.8</span></span><a name="2019"></a><a name="ch26ex17"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">If the Edmonds-Karp algorithm is run on a flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) with source <i class="emphasis">s</i> and sink <i class="emphasis">t</i>, then for all vertices <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> - {<i class="emphasis">s</i>, <i class="emphasis">t</i>}, the shortest-path distance <i class="emphasis"><span class="unicode">&delta;</span><sub>f</sub></i> (<i class="emphasis">s</i>, <i class="emphasis">v</i>) in the residual network <i class="emphasis">G<sub>f</sub></i> increases monotonically with each flow augmentation.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> We will suppose that for some vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> - {<i class="emphasis">s</i>, <i class="emphasis">t</i>}, there is a flow augmentation that causes the shortest-path distance from <i class="emphasis">s</i> to <i class="emphasis">v</i> to decrease, and then we will derive a contradiction. Let <i class="emphasis">f</i> be the flow just before the first augmentation that decreases some shortest-path distance, and let <i class="emphasis">f</i>' be the flow just afterward. Let <i class="emphasis">v</i> be the vertex with the minimum <i class="emphasis"><span class="unicode">&delta;</span><sub>f'</sub></i> (<i class="emphasis">s</i>, <i class="emphasis">v</i>) whose distance was decreased by the augmentation, so that <i class="emphasis"><span class="unicode">&delta;</span><sub>f'</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) <span class="unicode">&lt;</span> <i class="emphasis"><span class="unicode">&delta;</span><sub>f</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>). Let <span class="inlinemediaobject"><img src="images/fig683_01.jpg" height="11" width="77" alt="" border="0"></span> be a shortest path from <i class="emphasis">s</i> to <i class="emphasis">v</i> in <i class="emphasis">G<sub>f'</sub></i>, so that (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E<sub>f'</sub></i> and</p>
<p class="para">
<div class="equation">
<a name="2020"></a><a name="ch26eq07"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(26.7)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig683_02.jpg" height="17" width="151" alt="" border="0"></span></td>
</tr>
</table>
</div>
</p>
<p class="para">Because of how we chose <i class="emphasis">v</i>, we know that the distance label of vertex <i class="emphasis">u</i> did not decrease, i.e.,</p>
<p class="para">
<div class="equation">
<a name="2021"></a><a name="ch26eq08"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(26.8)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig683_03.jpg" height="17" width="123" alt="" border="0"></span></td>
</tr>
</table>
</div>
</p>
<p class="para">We claim that (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&notin;</span> <i class="emphasis">E<sub>f</sub></i>. Why? If we had (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E<sub>f</sub></i>, then we would also have</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&delta;</span><sub>f</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>)</p>
</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&le;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&delta;</span><sub>f</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) + 1</p>
</td><td class="td" align="left">
<p class="table-para">(by <a href="DDU0152.html#1838" target="_parent" class="chapterjump">Lemma 24.10</a>, the triangle inequality)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&le;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&delta;</span><sub>f'</sub></i> (<i class="emphasis">s</i>, <i class="emphasis">u</i>) + 1</p>
</td><td class="td" align="left">
<p class="table-para">(by inequality (<a class="internaljump" href="#ch26eq08">26.8</a>))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&delta;</span><sub>f'</sub></i> (<i class="emphasis">s</i>, <i class="emphasis">v</i>)</p>
</td><td class="td" align="left">
<p class="table-para">(by equation (<a class="internaljump" href="#ch26eq07">26.7</a>)),</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">which contradicts our assumption that <i class="emphasis"><span class="unicode">&delta;</span><sub>f'</sub></i> (<i class="emphasis">s</i>, <i class="emphasis">v</i>) <span class="unicode">&lt;</span> <i class="emphasis"><span class="unicode">&delta;</span><sub>f</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>).</p>
<p class="para">How can we have (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&notin;</span> <i class="emphasis">E<sub>f</sub></i> and (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E<sub>f'</sub></i>? The augmentation must have increased the flow from <i class="emphasis">v</i> to <i class="emphasis">u</i>. The Edmonds-Karp algorithm always augments flow along shortest paths, and therefore the shortest path from <i class="emphasis">s</i> to <i class="emphasis">u</i> in <i class="emphasis">G<sub>f</sub></i> has (<i class="emphasis">v</i>, <i class="emphasis">u</i>) as its last edge. Therefore,</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&delta;</span><sub>f</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>)</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&delta;</span><sub>f</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) - 1</p>
</td><td class="td" align="left">&nbsp;</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&le;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&delta;</span><sub>f'</sub></i> (<i class="emphasis">s</i>, <i class="emphasis">u</i>) - 2</p>
</td><td class="td" align="left">
<p class="table-para">(by inequality (<a class="internaljump" href="#ch26eq08">26.8</a>))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&delta;</span><sub>f'</sub></i> (<i class="emphasis">s</i>, <i class="emphasis">v</i>) - 2</p>
</td><td class="td" align="left">
<p class="table-para">(by equation (<a href="DDU0161.html#1984" target="_parent" class="chapterjump">26.7</a>)),</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="last-para">which contradicts our assumption that <i class="emphasis"><span class="unicode">&delta;</span><sub>f'</sub></i> (<i class="emphasis">s</i>, <i class="emphasis">v</i>) <span class="unicode">&lt;</span> <i class="emphasis"><span class="unicode">&delta;</span><sub>f</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>). We conclude that our assumption that such a vertex <i class="emphasis">v</i> exists is incorrect.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="2022"></a><a name="IDX-662"></a>
<p class="para">The next theorem bounds the number of iterations of the Edmonds-Karp algorithm.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 26.9</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">If the Edmonds-Karp algorithm is run on a flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) with source <i class="emphasis">s</i> and sink <i class="emphasis">t</i>, then the total number of flow augmentations performed by the algorithm is <i class="emphasis">O</i>(<i class="emphasis">V E</i>).</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> We say that an edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) in a residual network <i class="emphasis">G<sub>f</sub></i> is <b class="bold"><i class="emphasis">critical</i></b> on an augmenting path <i class="emphasis">p</i> if the residual capacity of <i class="emphasis">p</i> is the residual capacity of (<i class="emphasis">u</i>, <i class="emphasis">v</i>), that is, if <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">p</i>) = <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>). After we have augmented flow along an augmenting path, any critical edge on the path disappears from the residual network. Moreover, at least one edge on any augmenting path must be critical. We will show that each of the |<i class="emphasis">E</i>| edges can become critical at most |<i class="emphasis">V</i>|/2 - 1 times.</p>
<p class="para">Let <i class="emphasis">u</i> and <i class="emphasis">v</i> be vertices in <i class="emphasis">V</i> that are connected by an edge in <i class="emphasis">E</i>. Since augmenting paths are shortest paths, when (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is critical for the first time, we have</p>
<p class="para">
<i class="emphasis"><span class="unicode">&delta;</span><sub>f</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) = <i class="emphasis"><span class="unicode">&delta;</span><sub>f</sub></i> (<i class="emphasis">s</i>, <i class="emphasis">u</i>) + 1.</p>
<p class="para">Once the flow is augmented, the edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) disappears from the residual network. It cannot reappear later on another augmenting path until after the flow from <i class="emphasis">u</i> to <i class="emphasis">v</i> is decreased, which occurs only if (<i class="emphasis">v</i>, <i class="emphasis">u</i>) appears on an augmenting path. If <i class="emphasis">f</i>' is the flow in <i class="emphasis">G</i> when this event occurs, then we have</p>
<p class="para">
<i class="emphasis"><span class="unicode">&delta;</span><sub>f'</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) = <i class="emphasis"><span class="unicode">&delta;</span><sub>f'</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) + 1.</p>
<p class="para">Since <i class="emphasis"><span class="unicode">&delta;</span><sub>f</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&delta;</span><sub>f'</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) by <a class="internaljump" href="#ch26ex17">Lemma 26.8</a>, we have</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&delta;</span><sub>f'</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>)</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&delta;</span><sub>f'</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) + 1</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&ge;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&delta;</span><sub>f</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>) + 1</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&delta;</span><sub>f</sub></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) + 2.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="last-para">Consequently, from the time (<i class="emphasis">u</i>, <i class="emphasis">v</i>) becomes critical to the time when it next becomes critical, the distance of <i class="emphasis">u</i> from the source increases by at least 2. The distance of <i class="emphasis">u</i> from the source is initially at least 0. The intermediate vertices on a shortest path from <i class="emphasis">s</i> to <i class="emphasis">u</i> cannot contain <i class="emphasis">s</i>, <i class="emphasis">u</i>, or <i class="emphasis">t</i> (since (<i class="emphasis">u</i>, <i class="emphasis">v</i>) on the critical path implies that <i class="emphasis">u</i> <span class="unicode">&ne;</span> <i class="emphasis">t</i>). Therefore, until <i class="emphasis">u</i> becomes unreachable from the source, if ever, its distance is at most |<i class="emphasis">V</i>| - 2. Thus, (<i class="emphasis">u</i>, <i class="emphasis">v</i>) can become critical at most (|<i class="emphasis">V</i>|-2)/2 = |<i class="emphasis">V</i>|/2-1 times. Since there are <i class="emphasis">O</i>(<i class="emphasis">E</i>) pairs of vertices that can have an edge between them in a residual graph, the total number of critical edges during the entire execution of the Edmonds-Karp algorithm is <i class="emphasis">O</i>(<i class="emphasis">V E</i>). Each augmenting path has at least one critical edge, and hence the theorem follows.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">Since each iteration of FORD-FULKERSON can be implemented in <i class="emphasis">O</i>(<i class="emphasis">E</i>) time when the augmenting path is found by breadth-first search, the total running time <a name="2023"></a><a name="IDX-663"></a>of the Edmonds-Karp algorithm is <i class="emphasis">O</i>(<i class="emphasis">V E</i><sup>2</sup>). We shall see that push-relabel algorithms can yield even better bounds. The algorithm of <a href="DDU0164.html#2050" target="_parent" class="chapterjump">Section 26.4</a> gives a method for achieving an <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>2</sup> <i class="emphasis">E</i>) running time, which forms the basis for the <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>3</sup>)-time algorithm of <a href="DDU0165.html#2089" target="_parent" class="chapterjump">Section 26.5.</a>
</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.2-1</span></span><a name="2024"></a><a name="ch26ex19"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">In <a href="DDU0161.html#1966" target="_parent" class="chapterjump">Figure 26.1(b)</a>, what is the flow across the cut ({<i class="emphasis">s</i>, <i class="emphasis">v</i><sub>2</sub>, <i class="emphasis">v</i><sub>4</sub>}, {<i class="emphasis">v</i><sub>1</sub>, <i class="emphasis">v</i><sub>3</sub>, <i class="emphasis">t</i>})? What is the capacity of this cut?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.2-2</span></span><a name="2025"></a><a name="ch26ex20"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show the execution of the Edmonds-Karp algorithm on the flow network of <a href="DDU0161.html#1966" target="_parent" class="chapterjump">Figure 26.1(a)</a>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.2-3</span></span><a name="2026"></a><a name="ch26ex21"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">In the example of <a class="internaljump" href="#ch26fig05">Figure 26.5</a>, what is the minimum cut corresponding to the maximum flow shown? Of the augmenting paths appearing in the example, which two cancel flow?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.2-4</span></span><a name="2027"></a><a name="ch26ex22"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Prove that for any pair of vertices <i class="emphasis">u</i> and <i class="emphasis">v</i> and any capacity and flow functions <i class="emphasis">c</i> and <i class="emphasis">f</i>, we have <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) + <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">v</i>, <i class="emphasis">u</i>) = <i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) + <i class="emphasis">c</i>(<i class="emphasis">v</i>, <i class="emphasis">u</i>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.2-5</span></span><a name="2028"></a><a name="ch26ex23"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Recall that the construction in <a href="DDU0161.html#1964" target="_parent" class="chapterjump">Section 26.1</a> that converts a multisource, multisink flow network into a single-source, single-sink network adds edges with infinite capacity. Prove that any flow in the resulting network has a finite value if the edges of the original multisource, multisink network have finite capacity.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.2-6</span></span><a name="2029"></a><a name="ch26ex24"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that each source <i class="emphasis">s<sub>i</sub></i> in a multisource, multisink problem produces exactly <i class="emphasis">p<sub>i</sub></i> units of flow, so that <i class="emphasis">f</i>(<i class="emphasis">s<sub>i</sub></i>, <i class="emphasis">V</i>) = <i class="emphasis">p<sub>i</sub></i>. Suppose also that each sink <i class="emphasis">t<sub>j</sub></i> consumes exactly <i class="emphasis">q<sub>j</sub></i> units, so that <i class="emphasis">f</i>(<i class="emphasis">V</i>, <i class="emphasis">t<sub>j</sub></i>) = <i class="emphasis">q<sub>j</sub></i>, where <span class="unicode">&Sigma;</span><sub><i class="emphasis">i</i></sub> <i class="emphasis">p<sub>i</sub></i> = <span class="unicode">&Sigma;</span><sub><i class="emphasis">j</i></sub> <i class="emphasis">q<sub>j</sub></i>. Show how to convert the problem of finding a flow <i class="emphasis">f</i> that obeys these additional constraints into the problem of finding a maximum flow in a single-source, single-sink flow network.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.2-7</span></span><a name="2030"></a><a name="ch26ex25"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Prove <a class="internaljump" href="#ch26ex12">Lemma 26.3</a>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="2031"></a><a name="IDX-664"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.2-8</span></span><a name="2032"></a><a name="ch26ex26"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that a maximum flow in a network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) can always be found by a sequence of at most |<i class="emphasis">E</i>| augmenting paths. (<i class="emphasis">Hint:</i> Determine the paths <i class="emphasis">after</i> finding the maximum flow.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.2-9</span></span><a name="2033"></a><a name="ch26ex27"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The <b class="bold"><i class="emphasis">edge connectivity</i></b> of an undirected graph is the minimum number <i class="emphasis">k</i> of edges that must be removed to disconnect the graph. For example, the edge connectivity of a tree is 1, and the edge connectivity of a cyclic chain of vertices is 2. Show how the edge connectivity of an undirected graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) can be determined by running a maximum-flow algorithm on at most |<i class="emphasis">V</i>| flow networks, each having <i class="emphasis">O</i>(<i class="emphasis">V</i>) vertices and <i class="emphasis">O</i>(<i class="emphasis">E</i>) edges.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.2-10</span></span><a name="2034"></a><a name="ch26ex28"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that a flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) has symmetric edges, that is, (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i> if and only if (<i class="emphasis">v</i>, <i class="emphasis">u</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>. Show that the Edmonds-Karp algorithm terminates after at most |<i class="emphasis">V</i>| |<i class="emphasis">E</i>|/4 iterations. (<i class="emphasis">Hint:</i> For any edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>), consider how both <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>) and <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">v</i>, <i class="emphasis">t</i>) change between times at which (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is critical.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
<div class="footnotes">
<div class="footnote">
<p>
<sup>[<a name="ftn.N2846" href="#N2846">1</a>]</sup>We use square brackets when we treat an identifier<span class="unicode">-</span>such as <i class="emphasis">f</i><span class="unicode">-</span>as a mutable field, and we use parentheses when we treat it as a function.</p>
</div>
<div class="footnote">
<p>
<sup>[<a name="ftn.N3250" href="#N3250">2</a>]</sup>The Ford-Fulkerson method might fail to terminate only if edge capacities are irrational numbers. In practice, however, irrational numbers cannot be stored on finite-precision computers.</p>
</div>
</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0161.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0163.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
