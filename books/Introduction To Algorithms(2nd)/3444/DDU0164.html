<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>26.4 &#9733; Push-relabel algorithms</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0163.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0165.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch26"></a>
<div class="section">
<h2 class="first-section-title">
<a name="2050"></a><a name="ch26lev1sec4"></a><span class="section-titlelabel">26.4 </span><span class="unicode">&#9733;</span> Push-relabel algorithms</h2>
<p class="first-para">In this section, we present the "push-relabel" approach to computing maximum flows. To date, many of the asymptotically fastest maximum-flow algorithms are push-relabel algorithms, and the fastest actual implementations of maximum-flow algorithms are based on the push-relabel method. Other flow problems, such as the minimum-cost flow problem, can be solved efficiently by push-relabel methods. This section introduces Goldberg's "generic" maximum-flow algorithm, which has a simple implementation that runs in <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>2</sup> <i class="emphasis">E</i>) time, thereby improving upon the <i class="emphasis">O</i>(<i class="emphasis">V E</i><sup>2</sup>) bound of the Edmonds-Karp algorithm. <a href="DDU0165.html#2089" target="_parent" class="chapterjump">Section 26.5</a> refines the generic algorithm to obtain another push-relabel algorithm that runs in <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>3</sup>) time.</p>
<p class="para">Push-relabel algorithms work in a more localized manner than the Ford-Fulkerson method. Rather than examine the entire residual network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) to find an augmenting path, push-relabel algorithms work on one vertex at a time, looking only at the vertex's neighbors in the residual network. Furthermore, unlike the Ford-Fulkerson method, push-relabel algorithms do not maintain the flow-conservation property throughout their execution. They do, however, maintain a <b class="bold"><i class="emphasis">preflow</i></b>, which is a function <i class="emphasis">f</i> : <i class="emphasis">V</i> <span class="unicode">&times;</span> <i class="emphasis">V</i> <span class="unicode">&rarr;</span> <b class="bold">R</b> that satisfies skew symmetry, capacity constraints, and the following relaxation of flow conservation: <i class="emphasis">f</i>(<i class="emphasis">V</i>, <i class="emphasis">u</i>) <span class="unicode">&ge;</span> 0 for all vertices <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> - {<i class="emphasis">s</i>}. That is, the total net flow at each vertex other than the source is nonnegative. We call the total net flow at a vertex <i class="emphasis">u</i> the <b class="bold"><i class="emphasis">excess flow</i></b> into <i class="emphasis">u</i>, given by</p>
<div class="equation">
<a name="2051"></a><a name="ch26eq09"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(26.9)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig691_01.jpg" height="17" width="101" alt="" border="0"></span></td>
</tr>
</table>
</div>
<a name="2052"></a><a name="IDX-670"></a>
<p class="para">We say that a vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> - {<i class="emphasis">s</i>, <i class="emphasis">t</i>} is <b class="bold"><i class="emphasis">overflowing</i></b> if <i class="emphasis">e</i>(<i class="emphasis">u</i>) <span class="unicode">&gt;</span> 0.</p>
<p class="para">We shall start this section by describing the intuition behind the push-relabel method. We shall then investigate the two operations employed by the method: "pushing" preflow and "relabeling" a vertex. Finally, we shall present a generic push-relabel algorithm and analyze its correctness and running time.</p>
<div class="section">
<h4 class="sect4-title">
<a name="2053"></a><a name="ch26lev3sec13"></a>Intuition</h4>
<p class="first-para">The intuition behind the push-relabel method is probably best understood in terms of fluid flows: we consider a flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) to be a system of interconnected pipes of given capacities. Applying this analogy to the Ford-Fulkerson method, we might say that each augmenting path in the network gives rise to an additional stream of fluid, with no branch points, flowing from the source to the sink. The Ford-Fulkerson method iteratively adds more streams of flow until no more can be added.</p>
<p class="para">The generic push-relabel algorithm has a rather different intuition. As before, directed edges correspond to pipes. Vertices, which are pipe junctions, have two interesting properties. First, to accommodate excess flow, each vertex has an out-flow pipe leading to an arbitrarily large reservoir that can accumulate fluid. Second, each vertex, its reservoir, and all its pipe connections are on a platform whose height increases as the algorithm progresses.</p>
<p class="para">Vertex heights determine how flow is pushed: we only push flow downhill, that is, from a higher vertex to a lower vertex. The flow from a lower vertex to a higher vertex may be positive, but operations that push flow only push it downhill. The height of the source is fixed at |<i class="emphasis">V</i>|, and the height of the sink is fixed at 0. All other vertex heights start at 0 and increase with time. The algorithm first sends as much flow as possible downhill from the source toward the sink. The amount it sends is exactly enough to fill each outgoing pipe from the source to capacity; that is, it sends the capacity of the cut (<i class="emphasis">s</i>, <i class="emphasis">V</i> - <i class="emphasis">s</i>). When flow first enters an intermediate vertex, it collects in the vertex's reservoir. From there, it is eventually pushed downhill.</p>
<p class="para">It may eventually happen that the only pipes that leave a vertex <i class="emphasis">u</i> and are not already saturated with flow connect to vertices that are on the same level as <i class="emphasis">u</i> or are uphill from <i class="emphasis">u</i>. In this case, to rid an overflowing vertex <i class="emphasis">u</i> of its excess flow, we must increase its height<span class="unicode">-</span>an operation called "relabeling" vertex <i class="emphasis">u</i>. Its height is increased to one unit more than the height of the lowest of its neighbors to which it has an unsaturated pipe. After a vertex is relabeled, therefore, there is at least one outgoing pipe through which more flow can be pushed.</p>
<p class="last-para">Eventually, all the flow that can possibly get through to the sink has arrived there. No more can arrive, because the pipes obey the capacity constraints; the amount of flow across any cut is still limited by the capacity of the cut. To make the preflow <a name="2054"></a><a name="IDX-671"></a>a "legal" flow, the algorithm then sends the excess collected in the reservoirs of overflowing vertices back to the source by continuing to relabel vertices to above the fixed height |<i class="emphasis">V</i>| of the source. As we shall see, once all the reservoirs have been emptied, the preflow is not only a "legal" flow, it is also a maximum flow.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="2055"></a><a name="ch26lev3sec14"></a>The basic operations</h4>
<p class="first-para">From the preceding discussion, we see that there are two basic operations performed by a push-relabel algorithm: pushing flow excess from a vertex to one of its neighbors and relabeling a vertex. The applicability of these operations depends on the heights of vertices, which we now define precisely.</p>
<p class="para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a flow network with source <i class="emphasis">s</i> and sink <i class="emphasis">t</i>, and let <i class="emphasis">f</i> be a preflow in <i class="emphasis">G</i>. A function <i class="emphasis">h</i> : <i class="emphasis">V</i> <span class="unicode">&rarr;</span> <b class="bold">N</b> is a <b class="bold"><i class="emphasis">height function</i></b><sup>[<a name="N321" href="#ftn.N321">3</a>]</sup> if <i class="emphasis">h</i>(<i class="emphasis">s</i>) = |<i class="emphasis">V</i>|, <i class="emphasis">h</i>(<i class="emphasis">t</i>) = 0, and</p>
<p class="para">
<i class="emphasis">h</i>(<i class="emphasis">u</i>) <span class="unicode">&le;</span> <i class="emphasis">h</i>(<i class="emphasis">v</i>) + 1</p>
<p class="para">for every residual edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E<sub>f</sub></i>. We immediately obtain the following lemma.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 26.13</span></span><a name="2056"></a><a name="ch26ex37"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a flow network, let <i class="emphasis">f</i> be a preflow in <i class="emphasis">G</i>, and let <i class="emphasis">h</i> be a height function on <i class="emphasis">V</i>. For any two vertices <i class="emphasis">u</i>, <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, if <i class="emphasis">h</i>(<i class="emphasis">u</i>) <span class="unicode">&gt;</span> <i class="emphasis">h</i>(<i class="emphasis">v</i>) + 1, then (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is not an edge in the residual graph.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="section">
<h5 class="sect5-title">The push operation</h5>
<p class="first-para">The basic operation PUSH(<i class="emphasis">u</i>, <i class="emphasis">v</i>) can be applied if <i class="emphasis">u</i> is an overflowing vertex, <i class="emphasis">c<sub>f</sub></i> (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&gt;</span> 0, and <i class="emphasis">h</i>(<i class="emphasis">u</i>) = <i class="emphasis">h</i>(<i class="emphasis">v</i>) + 1. The pseudocode below updates the preflow <i class="emphasis">f</i> in an implied network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>). It assumes that residual capacities can also be computed in constant time given <i class="emphasis">c</i> and <i class="emphasis">f</i>. The excess flow stored at a vertex <i class="emphasis">u</i> is maintained as the attribute <i class="emphasis">e</i>[<i class="emphasis">u</i>], and the height of <i class="emphasis">u</i> is maintained as the attribute <i class="emphasis">h</i>[<i class="emphasis">u</i>]. The expression <i class="emphasis">d<sub>f</sub></i> (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is a temporary variable that stores the amount of flow that can be pushed from <i class="emphasis">u</i> to <i class="emphasis">v</i>.<a name="2057"></a><a name="IDX-672"></a>
</p>
<div class="informalexample">
<pre class="literallayout-normal">
PUSH(<i class="emphasis">u</i>, <i class="emphasis">v</i>)
1 <span class="unicode">&#9657;</span> <b class="bold">Applies when</b>: <i class="emphasis">u</i> is overflowing, <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&gt;</span> 0, and <i class="emphasis">h</i>[<i class="emphasis">u</i>] = <i class="emphasis">h</i>[<i class="emphasis">v</i>] + 1.
2 <span class="unicode">&#9657;</span> <b class="bold">Action:</b> Push <i class="emphasis">d<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = min(<i class="emphasis">e</i>[<i class="emphasis">u</i>], <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>)) units of flow from <i class="emphasis">u</i> to <i class="emphasis">v</i>.
3 <i class="emphasis">d<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&larr;</span> min(<i class="emphasis">e</i>[<i class="emphasis">u</i>], <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>))
4 <i class="emphasis">f</i>[<i class="emphasis">u</i>, <i class="emphasis">v</i>] <span class="unicode">&larr;</span> <i class="emphasis">f</i>[<i class="emphasis">u</i>, <i class="emphasis">v</i>] + <i class="emphasis">d<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>)
5 <i class="emphasis">f</i>[<i class="emphasis">v</i>, <i class="emphasis">u</i>] <span class="unicode">&larr;</span> - <i class="emphasis">f</i>[<i class="emphasis">u</i>, <i class="emphasis">v</i>]
6 <i class="emphasis">e</i>[<i class="emphasis">u</i>] <span class="unicode">&larr;</span> <i class="emphasis">e</i>[<i class="emphasis">u</i>] - <i class="emphasis">d<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>)
7 <i class="emphasis">e</i>[<i class="emphasis">v</i>] <span class="unicode">&larr;</span> <i class="emphasis">e</i>[<i class="emphasis">v</i>] + <i class="emphasis">d<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>)
</pre>
</div>
<p class="para">The code for PUSH operates as follows. Vertex <i class="emphasis">u</i> is assumed to have a positive excess <i class="emphasis">e</i>[<i class="emphasis">u</i>], and the residual capacity of (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is positive. Thus, we can we increase the flow from <i class="emphasis">u</i> to <i class="emphasis">v</i> by <i class="emphasis">d<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = min(<i class="emphasis">e</i>[<i class="emphasis">u</i>], <i class="emphasis">c<sub>f</sub></i> (<i class="emphasis">u</i>, <i class="emphasis">v</i>)) without causing <i class="emphasis">e</i>[<i class="emphasis">u</i>] to become negative or the capacity <i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) to be exceeded. Line 3 computes the value <i class="emphasis">d<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>), and we update <i class="emphasis">f</i> in lines 4<span class="unicode">-</span>5 and <i class="emphasis">e</i> in lines 6<span class="unicode">-</span>7. Thus, if <i class="emphasis">f</i> is a preflow before PUSH is called, it remains a preflow afterward.</p>
<p class="para">Observe that nothing in the code for PUSH depends on the heights of <i class="emphasis">u</i> and <i class="emphasis">v</i>, yet we prohibit it from being invoked unless <i class="emphasis">h</i>[<i class="emphasis">u</i>] = <i class="emphasis">h</i>[<i class="emphasis">v</i>] + 1. Thus, excess flow is pushed downhill only by a height differential of 1. By <a class="internaljump" href="#ch26ex37">Lemma 26.13</a>, no residual edges exist between two vertices whose heights differ by more than 1, and thus, as long as the attribute <i class="emphasis">h</i> is indeed a height function, there is nothing to be gained by allowing flow to be pushed downhill by a height differential of more than 1.</p>
<p class="para">We call the operation PUSH(<i class="emphasis">u</i>, <i class="emphasis">v</i>) a <b class="bold"><i class="emphasis">push</i></b> from <i class="emphasis">u</i> to <i class="emphasis">v</i>. If a push operation applies to some edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) leaving a vertex <i class="emphasis">u</i>, we also say that the push operation applies to <i class="emphasis">u</i>. It is a <b class="bold"><i class="emphasis">saturating push</i></b> if edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) becomes <b class="bold"><i class="emphasis">saturated</i></b> (<i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = 0 afterward); otherwise, it is a <b class="bold"><i class="emphasis">nonsaturating push</i></b>. If an edge is saturated, it does not appear in the residual network. A simple lemma characterizes one result of a nonsaturating push.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 26.14</span></span><a name="2058"></a><a name="ch26ex38"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">After a nonsaturating push from <i class="emphasis">u</i> to <i class="emphasis">v</i>, the vertex <i class="emphasis">u</i> is no longer overflowing.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Since the push was nonsaturating, the amount of flow <i class="emphasis">d<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) actually pushed must equal <i class="emphasis">e</i>[<i class="emphasis">u</i>] prior to the push. Since <i class="emphasis">e</i>[<i class="emphasis">u</i>] is reduced by this amount, it becomes 0 after the push.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>
<div class="section">
<h5 class="sect5-title">The relabel operation</h5>
<p class="first-para">The basic operation RELABEL (<i class="emphasis">u</i>) applies if <i class="emphasis">u</i> is overflowing and if <i class="emphasis">h</i>[<i class="emphasis">u</i>] <span class="unicode">&le;</span> <i class="emphasis">h</i>[<i class="emphasis">v</i>] for all edges (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E<sub>f</sub></i>. In other words, we can relabel an overflowing vertex <i class="emphasis">u</i> if for every vertex <i class="emphasis">v</i> for which there is residual capacity from <i class="emphasis">u</i> to <i class="emphasis">v</i>, flow cannot be pushed from <i class="emphasis">u</i> to <i class="emphasis">v</i> because <i class="emphasis">v</i> is not downhill from <i class="emphasis">u</i>. (Recall that by definition, <a name="2059"></a><a name="IDX-673"></a>neither the source <i class="emphasis">s</i> nor the sink <i class="emphasis">t</i> can be overflowing, so neither <i class="emphasis">s</i> nor <i class="emphasis">t</i> can be relabeled.)</p>
<div class="informalexample">
<pre class="literallayout-normal">
RELABEL(<i class="emphasis">u</i>)
1 <span class="unicode">&#9657;</span> <b class="bold">Applies when:</b> <i class="emphasis">u</i> is overflowing and for all <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> such that (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E<sub>f</sub></i>,
                    we have <i class="emphasis">h</i>[<i class="emphasis">u</i>] <span class="unicode">&le;</span> <i class="emphasis">h</i>[<i class="emphasis">v</i>].
2 <span class="unicode">&#9657;</span> <b class="bold">Action:</b> Increase the height of <i class="emphasis">u</i>.
3 <i class="emphasis">h</i>[<i class="emphasis">u</i>] <span class="unicode">&larr;</span> 1 + min {<i class="emphasis">h</i>[<i class="emphasis">v</i>] : (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E<sub>f</sub></i>}
</pre>
</div>
<p class="para">When we call the operation RELABEL(<i class="emphasis">u</i>), we say that vertex <i class="emphasis">u</i> is <b class="bold"><i class="emphasis">relabeled</i></b>. Note that when <i class="emphasis">u</i> is relabeled, <i class="emphasis">E<sub>f</sub></i> must contain at least one edge that leaves <i class="emphasis">u</i>, so that the minimization in the code is over a nonempty set. This property follows from the assumption that <i class="emphasis">u</i> is overflowing. Since <i class="emphasis">e</i>[<i class="emphasis">u</i>] <span class="unicode">&gt;</span> 0, we have <i class="emphasis">e</i>[<i class="emphasis">u</i>] = <i class="emphasis">f</i>(<i class="emphasis">V</i>, <i class="emphasis">u</i>) <span class="unicode">&gt;</span> 0, and hence there must be at least one vertex <i class="emphasis">v</i> such that <i class="emphasis">f</i>[<i class="emphasis">v</i>, <i class="emphasis">u</i>] <span class="unicode">&gt;</span> 0. But then,</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>)</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) - <i class="emphasis">f</i>[<i class="emphasis">u</i>, <i class="emphasis">v</i>]</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) + <i class="emphasis">f</i>[<i class="emphasis">v</i>, <i class="emphasis">u</i>]</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&gt;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">0,</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="last-para">which implies that (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E<sub>f</sub></i>. The operation RELABEL(<i class="emphasis">u</i>) thus gives <i class="emphasis">u</i> the greatest height allowed by the constraints on height functions.</p>

</div>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="2060"></a><a name="ch26lev3sec15"></a>The generic algorithm</h4>
<p class="first-para">The generic push-relabel algorithm uses the following subroutine to create an initial preflow in the flow network.</p>
<div class="informalexample">
<pre class="literallayout-normal">
INITIALIZE-PREFLOW(<i class="emphasis">G</i>, <i class="emphasis">s</i>)
 1  <b class="bold">for</b> each vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>[<i class="emphasis">G</i>]
 2       <b class="bold">do</b> <i class="emphasis">h</i>[<i class="emphasis">u</i>] <span class="unicode">&larr;</span> 0
 3          <i class="emphasis">e</i>[<i class="emphasis">u</i>] <span class="unicode">&larr;</span> 0
 4  <b class="bold">for</b> each edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>[<i class="emphasis">G</i>]
 5       <b class="bold">do</b> <i class="emphasis">f</i>[<i class="emphasis">u</i>, <i class="emphasis">v</i>] <span class="unicode">&larr;</span> 0
 6          <i class="emphasis">f</i>[<i class="emphasis">v</i>, <i class="emphasis">u</i>] <span class="unicode">&larr;</span> 0
 7  <i class="emphasis">h</i>[<i class="emphasis">s</i>] <span class="unicode">&larr;</span> |<i class="emphasis">V</i>[<i class="emphasis">G</i>]|
 8  <b class="bold">for</b> each vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">Adj</i>[<i class="emphasis">s</i>]
 9       <b class="bold">do</b> <i class="emphasis">f</i>[<i class="emphasis">s</i>, <i class="emphasis">u</i>] <span class="unicode">&larr;</span> <i class="emphasis">c</i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>)
10          <i class="emphasis">f</i>[<i class="emphasis">u</i>, <i class="emphasis">s</i>] <span class="unicode">&larr;</span> -<i class="emphasis">c</i>(<i class="emphasis">s</i>,  <i class="emphasis">u</i>)
11          <i class="emphasis">e</i>[<i class="emphasis">u</i>] <span class="unicode">&larr;</span> <i class="emphasis">c</i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>)
12          <i class="emphasis">e</i>[<i class="emphasis">s</i>] <span class="unicode">&larr;</span> <i class="emphasis">e</i>[<i class="emphasis">s</i>] - <i class="emphasis">c</i>(<i class="emphasis">s</i>, <i class="emphasis">u</i>)
</pre>
</div>
<p class="para">INITIALIZE-PREFLOW creates an initial preflow <i class="emphasis">f</i> defined by<a name="2061"></a><a name="IDX-674"></a>
</p>
<div class="equation">
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(26.10)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig696_01.jpg" height="58" width="205" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">That is, each edge leaving the source <i class="emphasis">s</i> is filled to capacity, and all other edges carry no flow. For each vertex <i class="emphasis">v</i> adjacent to the source, we initially have <i class="emphasis">e</i>[<i class="emphasis">v</i>] = <i class="emphasis">c</i>(<i class="emphasis">s</i>, <i class="emphasis">v</i>), and <i class="emphasis">e</i>[<i class="emphasis">s</i>] is initialized to the negative of the sum of these capacities. The generic algorithm also begins with an initial height function <i class="emphasis">h</i>, given by</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig696_02.jpg" height="38" width="154" alt="" border="0"></span>
</div>
<p class="para">This is a height function because the only edges (<i class="emphasis">u</i>, <i class="emphasis">v</i>) for which <i class="emphasis">h</i>[<i class="emphasis">u</i>] <span class="unicode">&gt;</span> <i class="emphasis">h</i>[<i class="emphasis">v</i>] + 1 are those for which <i class="emphasis">u</i> = <i class="emphasis">s</i>, and those edges are saturated, which means that they are not in the residual network.</p>
<p class="para">Initialization, followed by a sequence of push and relabel operations, executed in no particular order, yields the GENERIC-PUSH-RELABEL algorithm:</p>
<div class="informalexample">
<pre class="literallayout-normal">
GENERIC-PUSH-RELABEL(<i class="emphasis">G</i>)
1 INITIALIZE-PREFLOW(<i class="emphasis">G</i>, <i class="emphasis">s</i>)
2 <b class="bold">while</b> there exists an applicable push or relabel operation
3     <b class="bold">do</b> select an applicable push or relabel operation and perform it
</pre>
</div>
<p class="para">The following lemma tells us that as long as an overflowing vertex exists, at least one of the two basic operations applies.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 26.15: </span>(An overflowing vertex can be either pushed or relabeled)</span><a name="2062"></a><a name="ch26ex39"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a flow network with source <i class="emphasis">s</i> and sink <i class="emphasis">t</i>, let <i class="emphasis">f</i> be a preflow, and let <i class="emphasis">h</i> be any height function for <i class="emphasis">f</i>. If <i class="emphasis">u</i> is any overflowing vertex, then either a push or relabel operation applies to it.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> For any residual edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>), we have <i class="emphasis">h</i>(<i class="emphasis">u</i>) <span class="unicode">&le;</span> <i class="emphasis">h</i>(<i class="emphasis">v</i>)+1 because <i class="emphasis">h</i> is a height function. If a push operation does not apply to <i class="emphasis">u</i>, then for all residual edges (<i class="emphasis">u</i>, <i class="emphasis">v</i>), we must have <i class="emphasis">h</i>(<i class="emphasis">u</i>) <span class="unicode">&lt;</span> <i class="emphasis">h</i>(<i class="emphasis">v</i>) + 1, which implies <i class="emphasis">h</i>(<i class="emphasis">u</i>) <span class="unicode">&le;</span> <i class="emphasis">h</i>(<i class="emphasis">v</i>). Thus, a relabel operation can be applied to <i class="emphasis">u</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="2063"></a><a name="ch26lev3sec16"></a>Correctness of the push-relabel method</h4>
<p class="first-para">To show that the generic push-relabel algorithm solves the maximum-flow problem, we shall first prove that if it terminates, the preflow <i class="emphasis">f</i> is a maximum flow. We shall later prove that it terminates. We start with some observations about the height function <i class="emphasis">h</i>.<a name="2064"></a><a name="IDX-675"></a>
</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 26.16: </span>(Vertex heights never decrease)</span><a name="2065"></a><a name="ch26ex40"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">During the execution of GENERIC-PUSH-RELABEL on a flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>), for each vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, the height <i class="emphasis">h</i>[<i class="emphasis">u</i>] never decreases. Moreover, whenever a relabel operation is applied to a vertex <i class="emphasis">u</i>, its height <i class="emphasis">h</i>[<i class="emphasis">u</i>] increases by at least 1.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Because vertex heights change only during relabel operations, it suffices to prove the second statement of the lemma. If vertex <i class="emphasis">u</i> is about to be relabeled, then for all vertices <i class="emphasis">v</i> such that (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E<sub>f</sub></i>, we have <i class="emphasis">h</i>[<i class="emphasis">u</i>] <span class="unicode">&le;</span> <i class="emphasis">h</i>[<i class="emphasis">v</i>]. Thus, <i class="emphasis">h</i>[<i class="emphasis">u</i>] <span class="unicode">&lt;</span> 1 + min {<i class="emphasis">h</i>[<i class="emphasis">v</i>] : (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E<sub>f</sub></i>}, and so the operation must increase <i class="emphasis">h</i>[<i class="emphasis">u</i>].</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 26.17</span></span><a name="2066"></a><a name="ch26ex41"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a flow network with source <i class="emphasis">s</i> and sink <i class="emphasis">t</i>. During the execution of GENERIC-PUSH-RELABEL on <i class="emphasis">G</i>, the attribute <i class="emphasis">h</i> is maintained as a height function.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> The proof is by induction on the number of basic operations performed. Initially, <i class="emphasis">h</i> is a height function, as we have already observed.</p>
<p class="para">We claim that if <i class="emphasis">h</i> is a height function, then an operation RELABEL(<i class="emphasis">u</i>) leaves <i class="emphasis">h</i> a height function. If we look at a residual edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E<sub>f</sub></i> that leaves <i class="emphasis">u</i>, then the operation RELABEL(<i class="emphasis">u</i>) ensures that <i class="emphasis">h</i>[<i class="emphasis">u</i>] <span class="unicode">&le;</span> <i class="emphasis">h</i>[<i class="emphasis">v</i>] + 1 afterward. Now consider a residual edge (<i class="emphasis">w</i>, <i class="emphasis">u</i>) that enters <i class="emphasis">u</i>. By <a class="internaljump" href="#ch26ex40">Lemma 26.16</a>, <i class="emphasis">h</i>[<i class="emphasis">w</i>] <span class="unicode">&le;</span> <i class="emphasis">h</i>[<i class="emphasis">u</i>] + 1 before the operation RELABEL(<i class="emphasis">u</i>) implies <i class="emphasis">h</i>[<i class="emphasis">w</i>] <span class="unicode">&lt;</span> <i class="emphasis">h</i>[<i class="emphasis">u</i>] + 1 afterward. Thus, the operation RELABEL(<i class="emphasis">u</i>) leaves <i class="emphasis">h</i> a height function.</p>
<p class="last-para">Now, consider an operation PUSH(<i class="emphasis">u</i>, <i class="emphasis">v</i>). This operation may add the edge (<i class="emphasis">v</i>, <i class="emphasis">u</i>) to <i class="emphasis">E<sub>f</sub></i>, and it may remove (<i class="emphasis">u</i>, <i class="emphasis">v</i>) from <i class="emphasis">E<sub>f</sub></i>. In the former case, we have <i class="emphasis">h</i>[<i class="emphasis">v</i>] = <i class="emphasis">h</i>[<i class="emphasis">u</i>] - 1 <span class="unicode">&lt;</span> <i class="emphasis">h</i>[<i class="emphasis">u</i>] + 1, and so <i class="emphasis">h</i> remains a height function. In the latter case,the removal of (<i class="emphasis">u</i>, <i class="emphasis">v</i>) from the residual network removes the corresponding constraint, and <i class="emphasis">h</i> again remains a height function.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">The following lemma gives an important property of height functions.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 26.18</span></span><a name="2067"></a><a name="ch26ex42"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a flow network with source <i class="emphasis">s</i> and sink <i class="emphasis">t</i>, let <i class="emphasis">f</i> be a preflow in <i class="emphasis">G</i>, and let <i class="emphasis">h</i> be a height function on <i class="emphasis">V</i>. Then there is no path from the source <i class="emphasis">s</i> to the sink <i class="emphasis">t</i> in the residual network <i class="emphasis">G<sub>f</sub></i>.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Assume for the sake of contradiction that there is a path <i class="emphasis">p</i> = <span class="unicode">&#12296;</span><i class="emphasis">v</i><sub>0</sub>, <i class="emphasis">v</i><sub>1</sub>, . . . , <i class="emphasis">v<sub>k</sub></i><span class="unicode">&#12297;</span> from <i class="emphasis">s</i> to <i class="emphasis">t</i> in <i class="emphasis">G<sub>f</sub></i>, where <i class="emphasis">v</i><sub>0</sub> = <i class="emphasis">s</i> and <i class="emphasis">v<sub>k</sub></i> = <i class="emphasis">t</i>. Without loss of generality, <i class="emphasis">p</i> is a simple path, and so <i class="emphasis">k</i> <span class="unicode">&lt;</span> |<i class="emphasis">V</i>|. For <i class="emphasis">i</i> = 0, 1, . . . , <i class="emphasis">k</i> - 1, edge (<i class="emphasis">v<sub>i</sub></i>, <i class="emphasis">v</i><sub><i class="emphasis">i</i>+1</sub>) <span class="unicode">&isin;</span> <i class="emphasis">E<sub>f</sub></i>. Because <i class="emphasis">h</i> is a height function, <i class="emphasis">h</i>(<i class="emphasis">v<sub>i</sub></i>) <span class="unicode">&le;</span> <i class="emphasis">h</i>(<i class="emphasis">v</i><sub><i class="emphasis">i</i>+1</sub>) + 1 for <i class="emphasis">i</i> = 0, 1, . . . , <i class="emphasis">k</i> - 1. Combining these inequalities over path <i class="emphasis">p</i> yields <i class="emphasis">h</i>(<i class="emphasis">s</i>) <span class="unicode">&le;</span> <i class="emphasis">h</i>(<i class="emphasis">t</i>) + <i class="emphasis">k</i>. But because <i class="emphasis">h</i>(<i class="emphasis">t</i>) = 0, <a name="2068"></a><a name="IDX-676"></a>we have <i class="emphasis">h</i>(<i class="emphasis">s</i>) <span class="unicode">&le;</span> <i class="emphasis">k</i> <span class="unicode">&lt;</span> |<i class="emphasis">V</i>|, which contradicts the requirement that <i class="emphasis">h</i>(<i class="emphasis">s</i>) = |<i class="emphasis">V</i>| in a height function.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">We are now ready to show that if the generic push-relabel algorithm terminates, the preflow it computes is a maximum flow.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 26.19: </span>(Correctness of the generic push-relabel algorithm)</span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">If the algorithm GENERIC-PUSH-RELABEL terminates when run on a flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) with source <i class="emphasis">s</i> and sink <i class="emphasis">t</i>, then the preflow <i class="emphasis">f</i> it computes is a maximum flow for <i class="emphasis">G</i>.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> We use the following loop invariant:</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">Each time the <b class="bold">while</b> loop test in line 2 in GENERIC-PUSH-RELABEL is executed, <i class="emphasis">f</i> is a preflow.</p>
</li>
</ul>
<ul class="simple-list">
<li class="first-listitem">
<p class="para">
<b>Initialization:</b> INITIALIZE-PREFLOW makes <i class="emphasis">f</i> a preflow.</p>
</li>
<li class="listitem">
<p class="para">
<b>Maintenance:</b> The only operations within the <b class="bold">while</b> loop of lines 2<span class="unicode">-</span>3 are push and relabel. Relabel operations affect only height attributes and not the flow values; hence they do not affect whether <i class="emphasis">f</i> is a preflow. As argued on page 672, if <i class="emphasis">f</i> is a preflow prior to a push operation, it remains a preflow afterward.</p>
</li>
<li class="listitem">
<p class="para">
<b>Termination:</b> At termination, each vertex in <i class="emphasis">V</i> - {<i class="emphasis">s</i>, <i class="emphasis">t</i>} must have an excess of 0, because by <a class="internaljump" href="#ch26ex39">Lemmas 26.15</a> and <a class="internaljump" href="#ch26ex41">26.17</a> and the invariant that <i class="emphasis">f</i> is always a preflow, there are no overflowing vertices. Therefore, <i class="emphasis">f</i> is a flow. Because <i class="emphasis">h</i> is a height function, <a class="internaljump" href="#ch26ex42">Lemma 26.18</a> tells us that there is no path from <i class="emphasis">s</i> to <i class="emphasis">t</i> in the residual network <i class="emphasis">G<sub>f</sub></i>. By the max-flow min-cut theorem (<a href="DDU0162.html#2009" target="_parent" class="chapterjump">Theorem 26.7</a>), therefore, <i class="emphasis">f</i> is a maximum flow.</p>
</li>
</ul>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="2069"></a><a name="ch26lev3sec17"></a>Analysis of the push-relabel method</h4>
<p class="first-para">To show that the generic push-relabel algorithm indeed terminates, we shall bound the number of operations it performs. Each of the three types of operations<span class="unicode">-</span>relabels, saturating pushes, and nonsaturating pushes<span class="unicode">-</span>is bounded separately. With knowledge of these bounds, it is a straightforward problem to construct an algorithm that runs in <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>2</sup><i class="emphasis">E</i>) time. Before beginning the analysis, however, we prove an important lemma.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 26.20</span></span><a name="2070"></a><a name="ch26ex44"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a flow network with source <i class="emphasis">s</i> and sink <i class="emphasis">t</i>, and let <i class="emphasis">f</i> be a preflow in <i class="emphasis">G</i>. Then, for any overflowing vertex <i class="emphasis">u</i>, there is a simple path from <i class="emphasis">u</i> to <i class="emphasis">s</i> in the residual network <i class="emphasis">G<sub>f</sub></i>.<a name="2071"></a><a name="IDX-677"></a>
</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> For an overflowing vertex <i class="emphasis">u</i>, let <i class="emphasis">U</i> = {<i class="emphasis">v</i>: there exists a simple path from <i class="emphasis">u</i> to <i class="emphasis">v</i> in <i class="emphasis">G<sub>f</sub></i>}, and suppose for the sake of contradiction that <i class="emphasis">s</i> <span class="unicode">&notin;</span> <i class="emphasis">U</i>. Let <i class="emphasis"><span class="unicode">&#362;</span></i> = <i class="emphasis">V</i> - <i class="emphasis">U</i>.</p>
<p class="para">We claim for each pair of vertices <i class="emphasis">w</i> <span class="unicode">&isin;</span> <i class="emphasis"><span class="unicode">&#362;</span></i> and <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">U</i> that <i class="emphasis">f</i>(<i class="emphasis">w</i>, <i class="emphasis">v</i>) <span class="unicode">&le;</span> 0. Why? If <i class="emphasis">f</i>(<i class="emphasis">w</i>, <i class="emphasis">v</i>) <span class="unicode">&gt;</span> 0, then <i class="emphasis">f</i>(<i class="emphasis">v</i>, <i class="emphasis">w</i>) <span class="unicode">&lt;</span> 0, which in turn implies that <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">v</i>, <i class="emphasis">w</i>) = <i class="emphasis">c</i>(<i class="emphasis">v</i>, <i class="emphasis">w</i>) - <i class="emphasis">f</i>(<i class="emphasis">v</i>, <i class="emphasis">w</i>) <span class="unicode">&gt;</span> 0. Hence, there exists an edge (<i class="emphasis">v</i>, <i class="emphasis">w</i>) <span class="unicode">&isin;</span> <i class="emphasis">E<sub>f</sub></i>, and therefore a simple path of the form <span class="inlinemediaobject"><img src="images/fig699_01.jpg" height="9" width="58" alt="" border="0"></span> in <i class="emphasis">G<sub>f</sub></i>, contradicting our choice of <i class="emphasis">w</i>.</p>
<p class="para">Thus, we must have <i class="emphasis">f</i>(<i class="emphasis"><span class="unicode">&#362;</span></i>, <i class="emphasis">U</i>) <span class="unicode">&le;</span> 0, since every term in this implicit summation is nonpositive, and hence</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">e</i>(<i class="emphasis">U</i>)</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">f</i>(<i class="emphasis">V</i>, <i class="emphasis">U</i>)</p>
</td><td class="td" align="left">
<p class="table-para">(by equation (<a class="internaljump" href="#ch26eq09">26.9</a>))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">f</i>(<i class="emphasis"><span class="unicode">&#362;</span></i>, <i class="emphasis">U</i>) + <i class="emphasis">f</i>(<i class="emphasis">U</i>, <i class="emphasis">U</i>)</p>
</td><td class="td" align="left">
<p class="table-para">(by <a href="DDU0161.html#1976" target="_parent" class="chapterjump">Lemma 26.1</a>, part (3))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">f</i>(<i class="emphasis"><span class="unicode">&#362;</span></i>, <i class="emphasis">U</i>)</p>
</td><td class="td" align="left">
<p class="table-para">(by <a href="DDU0161.html#1976" target="_parent" class="chapterjump">Lemma 26.1</a>, part (1))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&le;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">0.</p>
</td><td class="td" align="left">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
<p class="last-para">Excesses are nonnegative for all vertices in <i class="emphasis">V</i> -{<i class="emphasis">s</i>}; because we have assumed that <i class="emphasis">U</i> <span class="unicode">&sube;</span> <i class="emphasis">V</i> -{<i class="emphasis">s</i>}, we must therefore have <i class="emphasis">e</i>(<i class="emphasis">v</i>) = 0 for all vertices <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">U</i>. In particular, <i class="emphasis">e</i>(<i class="emphasis">u</i>) = 0, which contradicts the assumption that <i class="emphasis">u</i> is overflowing.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">The next lemma bounds the heights of vertices, and its corollary bounds the number of relabel operations that are performed in total.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 26.21</span></span><a name="2072"></a><a name="ch26ex45"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a flow network with source <i class="emphasis">s</i> and sink <i class="emphasis">t</i>. At any time during the execution of GENERIC-PUSH-RELABEL on <i class="emphasis">G</i>, we have <i class="emphasis">h</i>[<i class="emphasis">u</i>] <span class="unicode">&le;</span> 2 |<i class="emphasis">V</i>| - 1 for all vertices <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> The heights of the source <i class="emphasis">s</i> and the sink <i class="emphasis">t</i> never change because these vertices are by definition not overflowing. Thus, we always have <i class="emphasis">h</i>[<i class="emphasis">s</i>] = |<i class="emphasis">V</i>| and <i class="emphasis">h</i>[<i class="emphasis">t</i>] = 0, both of which are no greater than 2 |<i class="emphasis">V</i> | - 1.</p>
<p class="last-para">Now consider any vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> -{<i class="emphasis">s</i>, <i class="emphasis">t</i>}. Initially, <i class="emphasis">h</i>[<i class="emphasis">u</i>] = 0 <span class="unicode">&le;</span> 2 |<i class="emphasis">V</i>|-1. We shall show that after each relabeling operation, we still have <i class="emphasis">h</i>[<i class="emphasis">u</i>] <span class="unicode">&le;</span> 2 |<i class="emphasis">V</i>|-1. When <i class="emphasis">u</i> is relabeled, it is overflowing, and <a class="internaljump" href="#ch26ex44">Lemma 26.20</a> tells us that there is a simple path <i class="emphasis">p</i> from <i class="emphasis">u</i> to <i class="emphasis">s</i> in <i class="emphasis">G<sub>f</sub></i>. Let <i class="emphasis">p</i> = <span class="unicode">&#12296;</span><i class="emphasis">v</i><sub>0</sub>, <i class="emphasis">v</i><sub>1</sub>, . . . ,<i class="emphasis">v<sub>k</sub></i><span class="unicode">&#12297;</span>, where <i class="emphasis">v</i><sub>0</sub> = <i class="emphasis">u</i>, <i class="emphasis">v<sub>k</sub></i> = <i class="emphasis">s</i>, and <i class="emphasis">k</i> <span class="unicode">&le;</span> |<i class="emphasis">V</i>|-1 because <i class="emphasis">p</i> is simple. For <i class="emphasis">i</i> = 0, 1, . . . , <i class="emphasis">k</i> - 1, we have (<i class="emphasis">v<sub>i</sub></i>, <i class="emphasis">v</i><sub><i class="emphasis">i</i>+1</sub>) <span class="unicode">&isin;</span> <i class="emphasis">E<sub>f</sub></i>, and therefore, by <a class="internaljump" href="#ch26ex41">Lemma 26.17</a>, <i class="emphasis">h</i>[<i class="emphasis">v<sub>i</sub></i>] <span class="unicode">&le;</span> <i class="emphasis">h</i>[<i class="emphasis">v</i><sub><i class="emphasis">i</i>+1</sub>] + 1. Expanding these inequalities over path <i class="emphasis">p</i> yields <i class="emphasis">h</i>[<i class="emphasis">u</i>] = <i class="emphasis">h</i>[<i class="emphasis">v</i><sub>0</sub>] <span class="unicode">&le;</span> <i class="emphasis">h</i>[<i class="emphasis">v<sub>k</sub></i>] + <i class="emphasis">k</i> <span class="unicode">&le;</span> <i class="emphasis">h</i>[<i class="emphasis">s</i>] + (|<i class="emphasis">V</i>| - 1) = 2 |<i class="emphasis">V</i>| - 1.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Corollary 26.22: </span>(Bound on relabel operations)</span><a name="2073"></a><a name="ch26ex46"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a flow network with source <i class="emphasis">s</i> and sink <i class="emphasis">t</i>. Then, during the execution of GENERIC-PUSH-RELABEL on <i class="emphasis">G</i>, the number of relabel operations is at most 2 |<i class="emphasis">V</i>| - 1 per vertex and at most (2 |<i class="emphasis">V</i>| - 1)|<i class="emphasis">V</i>| - 2) <span class="unicode">&lt;</span> 2 |<i class="emphasis">V</i>|<sup>2</sup> overall.<a name="2074"></a><a name="IDX-678"></a>
</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Only the |<i class="emphasis">V</i>|-2 vertices in <i class="emphasis">V</i> -{<i class="emphasis">s</i>, <i class="emphasis">t</i>} may be relabeled. Let <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> -{<i class="emphasis">s</i>, <i class="emphasis">t</i>}. The operation RELABEL(<i class="emphasis">u</i>) increases <i class="emphasis">h</i>[<i class="emphasis">u</i>]. The value of <i class="emphasis">h</i>[<i class="emphasis">u</i>] is initially 0 and by <a class="internaljump" href="#ch26ex45">Lemma 26.21</a> grows to at most 2 |<i class="emphasis">V</i>| - 1. Thus, each vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> - {<i class="emphasis">s</i>, <i class="emphasis">t</i>} is relabeled at most 2 |<i class="emphasis">V</i>| - 1 times, and the total number of relabel operations performed is at most (2 |<i class="emphasis">V</i>| - 1)(|<i class="emphasis">V</i>| - 2) <span class="unicode">&lt;</span> 2 |<i class="emphasis">V</i>|<sup>2</sup>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">
<a class="internaljump" href="#ch26ex45">Lemma 26.21</a> also helps us to bound the number of saturating pushes.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 26.23: </span>(Bound on saturating pushes)</span><a name="2075"></a><a name="ch26ex47"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">During the execution of GENERIC-PUSH-RELABEL on any flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>), the number of saturating pushes is less than 2 |<i class="emphasis">V</i>||<i class="emphasis">E</i>|.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> For any pair of vertices <i class="emphasis">u</i>, <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, we will count the saturating pushes from <i class="emphasis">u</i> to <i class="emphasis">v</i> and from <i class="emphasis">v</i> to <i class="emphasis">u</i> together, calling them the saturating pushes between <i class="emphasis">u</i> and <i class="emphasis">v</i>. If there are any such pushes, at least one of (<i class="emphasis">u</i>, <i class="emphasis">v</i>) and (<i class="emphasis">v</i>, <i class="emphasis">u</i>) is actually an edge in <i class="emphasis">E</i>. Now, suppose that a saturating push from <i class="emphasis">u</i> to <i class="emphasis">v</i> has occurred. At that time, <i class="emphasis">h</i>[<i class="emphasis">v</i>] = <i class="emphasis">h</i>[<i class="emphasis">u</i>] - 1. In order for another push from <i class="emphasis">u</i> to <i class="emphasis">v</i> to occur later, the algorithm must first push flow from <i class="emphasis">v</i> to <i class="emphasis">u</i>, which cannot happen until <i class="emphasis">h</i>[<i class="emphasis">v</i>] = <i class="emphasis">h</i>[<i class="emphasis">u</i>] + 1. Since <i class="emphasis">h</i>[<i class="emphasis">u</i>] never decreases, in order for <i class="emphasis">h</i>[<i class="emphasis">v</i>] = <i class="emphasis">h</i>[<i class="emphasis">u</i>] + 1, the value of <i class="emphasis">h</i>[<i class="emphasis">v</i>] must increase by at least 2. Likewise, <i class="emphasis">h</i>[<i class="emphasis">u</i>] must increase by at least 2 between saturating pushes from <i class="emphasis">v</i> to <i class="emphasis">u</i>. Heights start at 0 and, by <a class="internaljump" href="#ch26ex45">Lemma 26.21</a>, never exceed 2 |<i class="emphasis">V</i>|- 1, which implies that the number of times any vertex can have its height increase by 2 is less than |<i class="emphasis">V</i>|. Since at least one of <i class="emphasis">h</i>[<i class="emphasis">u</i>] and <i class="emphasis">h</i>[<i class="emphasis">v</i>] must increase by 2 between any two saturating pushes between <i class="emphasis">u</i> and <i class="emphasis">v</i>, there are fewer than 2 |<i class="emphasis">V</i>| saturating pushes between <i class="emphasis">u</i> and <i class="emphasis">v</i>. Multiplying by the number of edges gives a bound of less than 2 |<i class="emphasis">V</i>||<i class="emphasis">E</i>| on the total number of saturating pushes.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">The following lemma bounds the number of nonsaturating pushes in the generic push-relabel algorithm.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 26.24: </span>(Bound on nonsaturating pushes)</span><a name="2076"></a><a name="ch26ex48"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">During the execution of GENERIC-PUSH-RELABEL on any flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>), the number of nonsaturating pushes is less than 4 |<i class="emphasis">V</i>|<sup>2</sup> (|<i class="emphasis">V</i>| + |<i class="emphasis">E</i>|).</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> Define a potential function <span class="unicode">&Phi;</span> = <span class="unicode">&Sigma;</span><sub><i class="emphasis">v</i>:<i class="emphasis">e</i>(<i class="emphasis">v</i>)&gt;0</sub><i class="emphasis">h</i>[<i class="emphasis">v</i>]. Initially, <span class="unicode">&Phi;</span>= 0, and the value of <span class="unicode">&Phi;</span> may change after each relabeling, saturating push, and nonsaturating push. We will bound the amount that saturating pushes and relabelings can contribute to the increase of <span class="unicode">&Phi;</span>. Then we will show that each nonsaturating push must decrease <span class="unicode">&Phi;</span> by at least 1, and will use these bounds to derive an upper bound on the number of nonsaturating pushes.</p>
<p class="para">Let us examine the two ways in which <span class="unicode">&Phi;</span> might increase. First, relabeling a vertex <i class="emphasis">u</i> increases <span class="unicode">&Phi;</span> by less than 2 |<i class="emphasis">V</i>|, since the set over which the sum is taken is <a name="2077"></a><a name="IDX-679"></a>the same and the relabeling cannot increase <i class="emphasis">u</i>'s height by more than its maximum possible height, which, by <a class="internaljump" href="#ch26ex45">Lemma 26.21</a>, is at most 2 |<i class="emphasis">V</i>|- 1. Second, a saturating push from a vertex <i class="emphasis">u</i> to a vertex <i class="emphasis">v</i> increases <span class="unicode">&Phi;</span> by less than 2 |<i class="emphasis">V</i>|, since no heights change and only vertex <i class="emphasis">v</i>, whose height is at most 2 |<i class="emphasis">V</i>| - 1, can possibly become overflowing.</p>
<p class="para">Now we show that a nonsaturating push from <i class="emphasis">u</i> to <i class="emphasis">v</i> decreases <span class="unicode">&Phi;</span> by at least 1. Why? Before the nonsaturating push, <i class="emphasis">u</i> was overflowing, and <i class="emphasis">v</i> may or may not have been overflowing. By <a class="internaljump" href="#ch26ex38">Lemma 26.14</a>, <i class="emphasis">u</i> is no longer overflowing after the push. In addition, <i class="emphasis">v</i> must be overflowing after the push, unless it is the source. Therefore, the potential function <span class="unicode">&Phi;</span> has decreased by exactly <i class="emphasis">h</i>[<i class="emphasis">u</i>], and it has increased by either 0 or <i class="emphasis">h</i>[<i class="emphasis">v</i>]. Since <i class="emphasis">h</i>[<i class="emphasis">u</i>] - <i class="emphasis">h</i>[<i class="emphasis">v</i>] = 1, the net effect is that the potential function has decreased by at least 1.</p>
<p class="last-para">Thus, during the course of the algorithm, the total amount of increase in <span class="unicode">&Phi;</span> is due to relabelings and saturated pushes and is constrained by <a class="internaljump" href="#ch26ex46">Corollary 26.22</a> and <a class="internaljump" href="#ch26ex47">Lemma 26.23</a> to be less than (2 |<i class="emphasis">V</i>|)(2 |<i class="emphasis">V</i>|<sup>2</sup>) + (2 |<i class="emphasis">V</i>|)(2 |<i class="emphasis">V</i>||<i class="emphasis">E</i>|) = 4 |<i class="emphasis">V</i>|<sup>2</sup> (|<i class="emphasis">V</i>| + |<i class="emphasis">E</i>|). Since <span class="unicode">&Phi;</span> <span class="unicode">&ge;</span> 0, the total amount of decrease, and therefore the total number of nonsaturating pushes, is less than 4 |<i class="emphasis">V</i>|<sup>2</sup> (|<i class="emphasis">V</i>| + |<i class="emphasis">E</i>|).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">Having bounded the number of relabelings, saturating pushes, and nonsaturating push, we have set the stage for the following analysis of the GENERIC-PUSH-RELABEL procedure, and hence of any algorithm based on the push-relabel method.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 26.25</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">During the execution of GENERIC<span class="unicode">&gt;</span>-PUSH-RELABEL on any flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>), the number of basic operations is <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>2</sup><i class="emphasis">E</i>).</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Immediate from <a class="internaljump" href="#ch26ex46">Corollary 26.22</a> and <a class="internaljump" href="#ch26ex47">Lemmas 26.23</a> and <a class="internaljump" href="#ch26ex48">26.24</a>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">Thus, the algorithm terminates after <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>2</sup> <i class="emphasis">E</i>) operations. All that remains is to give an efficient method for implementing each operation and for choosing an appropriate operation to execute.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Corollary 26.26</span></span><a name="2078"></a><a name="ch26ex50"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">There is an implementation of the generic push-relabel algorithm that runs in <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>2</sup> <i class="emphasis">E</i>) time on any flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>).</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> <a class="internaljump" href="#ch26ex51">Exercise 26.4-1</a> asks you to show how to implement the generic algorithm with an overhead of <i class="emphasis">O</i>(<i class="emphasis">V</i>) per relabel operation and <i class="emphasis">O</i>(1) per push. It also asks you to design a data structure that allows you to pick an applicable operation in <i class="emphasis">O</i>(1) time. The corollary then follows.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="2079"></a><a name="IDX-680"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.4-1</span></span><a name="2080"></a><a name="ch26ex51"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show how to implement the generic push-relabel algorithm using <i class="emphasis">O</i>(<i class="emphasis">V</i>) time per relabel operation, <i class="emphasis">O</i>(1) time per push, and <i class="emphasis">O</i>(1) time to select an applicable operation, for a total time of <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>2</sup><i class="emphasis">E</i>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.4-2</span></span><a name="2081"></a><a name="ch26ex52"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Prove that the generic push-relabel algorithm spends a total of only <i class="emphasis">O</i>(<i class="emphasis">V E</i>) time in performing all the <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>2</sup>) relabel operations.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.4-3</span></span><a name="2082"></a><a name="ch26ex53"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that a maximum flow has been found in a flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) using a push-relabel algorithm. Give a fast algorithm to find a minimum cut in <i class="emphasis">G</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.4-4</span></span><a name="2083"></a><a name="ch26ex54"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Give an efficient push-relabel algorithm to find a maximum matching in a bipartite graph. Analyze your algorithm.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.4-5</span></span><a name="2084"></a><a name="ch26ex55"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that all edge capacities in a flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) are in the set {1, 2, . . . , <i class="emphasis">k</i>}. Analyze the running time of the generic push-relabel algorithm in terms of |<i class="emphasis">V</i>|, |<i class="emphasis">E</i>|, and <i class="emphasis">k</i>. (<i class="emphasis">Hint:</i> How many times can each edge support a nonsaturating push before it becomes saturated?)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.4-6</span></span><a name="2085"></a><a name="ch26ex56"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that line 7 of INITIALIZE-PREFLOW can be changed to</p>
<p class="para">7 <i class="emphasis">h</i>[<i class="emphasis">s</i>] <span class="unicode">&larr;</span> |<i class="emphasis">V</i>[<i class="emphasis">G</i>]| - 2</p>
<p class="last-para">without affecting the correctness or asymptotic performance of the generic push-relabel algorithm.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.4-7</span></span><a name="2086"></a><a name="ch26ex57"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis"><span class="unicode">&delta;</span><sub>f</sub></i> (<i class="emphasis">u</i>, <i class="emphasis">v</i>) be the distance (number of edges) from <i class="emphasis">u</i> to <i class="emphasis">v</i> in the residual network <i class="emphasis">G<sub>f</sub></i>. Show that GENERIC-PUSH-RELABEL maintains the properties that <i class="emphasis">h</i>[<i class="emphasis">u</i>] <span class="unicode">&lt;</span> |<i class="emphasis">V</i>| implies <i class="emphasis">h</i>[<i class="emphasis">u</i>] <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&delta;</span><sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">t</i>) and that <i class="emphasis">h</i>[<i class="emphasis">u</i>] <span class="unicode">&ge;</span> |<i class="emphasis">V</i>| implies <i class="emphasis">h</i>[<i class="emphasis">u</i>] -|<i class="emphasis">V</i>| <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&delta;</span><sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">s</i>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.4-8: </span><span class="unicode">&#9733;</span></span><a name="2087"></a><a name="ch26ex58"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">As in the previous exercise, let <i class="emphasis"><span class="unicode">&delta;</span><sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) be the distance from <i class="emphasis">u</i> to <i class="emphasis">v</i> in the residual network <i class="emphasis">G<sub>f</sub></i>. Show how the generic push-relabel algorithm can be modified to maintain the property that <i class="emphasis">h</i>[<i class="emphasis">u</i>] <span class="unicode">&lt;</span> |<i class="emphasis">V</i>| implies <i class="emphasis">h</i>[<i class="emphasis">u</i>] = <i class="emphasis"><span class="unicode">&delta;</span><sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">t</i>) and that <i class="emphasis">h</i>[<i class="emphasis">u</i>] <span class="unicode">&ge;</span> |<i class="emphasis">V</i>| <a name="2088"></a><a name="IDX-681"></a>implies <i class="emphasis">h</i>[<i class="emphasis">u</i>] - |<i class="emphasis">V</i>| = <i class="emphasis"><span class="unicode">&delta;</span><sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">s</i>). The total time that your implementation dedicates to maintaining this property should be <i class="emphasis">O</i>(<i class="emphasis">V E</i>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercise 26.4-9</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that the number of nonsaturating pushes executed by GENERIC-PUSH-RELABEL on a flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) is at most 4 |<i class="emphasis">V</i>|<sup>2</sup>|<i class="emphasis">E</i>| for |<i class="emphasis">V</i>| <span class="unicode">&ge;</span> 4.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
<div class="footnotes">
<div class="footnote">
<p>
<sup>[<a name="ftn.N321" href="#N321">3</a>]</sup>In the literature, a height function is typically called a "distance function," and the height of a vertex is called a "distance label." We use the term "height" because it is more suggestive of the intuition behind the algorithm. We retain the use of the term "relabel" to refer to the operation that increases the height of a vertex. The height of a vertex is related to its distance from the sink <i class="emphasis">t</i>, as would be found in a breadth-first search of the transpose <i class="emphasis">G</i><sup>T</sup>.</p>
</div>
</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0163.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0165.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
