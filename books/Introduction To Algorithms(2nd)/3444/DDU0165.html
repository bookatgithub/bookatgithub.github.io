<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>26.5 &#9733;The relabel-to-front algorithm</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0164.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0166.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch26"></a>
<div class="section">
<h2 class="first-section-title">
<a name="2089"></a><a name="ch26lev1sec5"></a><span class="section-titlelabel">26.5 </span><span class="unicode">&#9733;</span>The relabel-to-front algorithm</h2>
<p class="first-para">The push-relabel method allows us to apply the basic operations in any order at all. By choosing the order carefully and managing the network data structure efficiently, however, we can solve the maximum-flow problem faster than the <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>2</sup><i class="emphasis">E</i>) bound given by <a href="DDU0164.html#2078" target="_parent" class="chapterjump">Corollary 26.26</a>. We shall now examine the relabel-to-front algorithm, a push-relabel algorithm whose running time is <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>3</sup>), which is asymptotically at least as good as <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>2</sup><i class="emphasis">E</i>), and better for dense networks.</p>
<p class="para">The relabel-to-front algorithm maintains a list of the vertices in the network. Beginning at the front, the algorithm scans the list, repeatedly selecting an over-flowing vertex <i class="emphasis">u</i> and then "discharging" it, that is, performing push and relabel operations until <i class="emphasis">u</i> no longer has a positive excess. Whenever a vertex is relabeled, it is moved to the front of the list (hence the name "relabel-to-front") and the algorithm begins its scan anew.</p>
<p class="para">The correctness and analysis of the relabel-to-front algorithm depend on the notion of "admissible" edges: those edges in the residual network through which flow can be pushed. After proving some properties about the network of admissible edges, we shall investigate the discharge operation and then present and analyze the relabel-to-front algorithm itself.</p>
<div class="section">
<h4 class="sect4-title">
<a name="2090"></a><a name="ch26lev3sec18"></a>Admissible edges and networks</h4>
<p class="first-para">If <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) is a flow network with source <i class="emphasis">s</i> and sink <i class="emphasis">t</i>, <i class="emphasis">f</i> is a preflow in <i class="emphasis">G</i>, and <i class="emphasis">h</i> is a height function, then we say that (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is an <b class="bold"><i class="emphasis">admissible edge</i></b> if <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&gt;</span> 0 and <i class="emphasis">h</i>(<i class="emphasis">u</i>) = <i class="emphasis">h</i>(<i class="emphasis">v</i>) + 1. Otherwise, (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is <b class="bold"><i class="emphasis">inadmissible</i></b>. The <b class="bold"><i class="emphasis">admissible network</i></b> is <i class="emphasis">G</i><sub><i class="emphasis">f</i>,<i class="emphasis">h</i></sub> = (<i class="emphasis">V</i>, <i class="emphasis">E</i><sub><i class="emphasis">f</i>,<i class="emphasis">h</i></sub>), where <i class="emphasis">E</i><sub><i class="emphasis">f</i>,<i class="emphasis">h</i></sub> is the set of admissible edges.</p>
<p class="para">The admissible network consists of those edges through which flow can be pushed. The following lemma shows that this network is a directed acyclic graph (dag).</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 26.27: </span>(The admissible network is acyclic)</span><a name="2091"></a><a name="ch26ex60"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">If <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) is a flow network, <i class="emphasis">f</i> is a preflow in <i class="emphasis">G</i>, and <i class="emphasis">h</i> is a height function on <i class="emphasis">G</i>, then the admissible network <i class="emphasis">G</i><sub><i class="emphasis">f</i>,<i class="emphasis">h</i></sub> = (<i class="emphasis">V</i>, <i class="emphasis">E</i><sub><i class="emphasis">f</i>,<i class="emphasis">h</i></sub>) is acyclic.<a name="2092"></a><a name="IDX-682"></a>
</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> The proof is by contradiction. Suppose that <i class="emphasis">G</i><sub><i class="emphasis">f</i>,<i class="emphasis">h</i></sub> contains a cycle <i class="emphasis">p</i> = <span class="unicode">&#12296;</span><i class="emphasis">v</i><sub>0</sub>, <i class="emphasis">v</i><sub>1</sub> , . . . ,<i class="emphasis">v<sub>k</sub></i><span class="unicode">&#12297;</span>, where <i class="emphasis">v</i><sub>0</sub> = <i class="emphasis">v<sub>k</sub></i> and <i class="emphasis">k</i> <span class="unicode">&gt;</span> 0. Since each edge in <i class="emphasis">p</i> is admissible, we have <i class="emphasis">h</i>(<i class="emphasis">v</i><sub><i class="emphasis">i</i>-1</sub>) = <i class="emphasis">h</i>(<i class="emphasis">v<sub>i</sub></i>) + 1 for <i class="emphasis">i</i> = 1, 2, . . . ,<i class="emphasis">k</i>. Summing around the cycle gives</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig704_01.jpg" height="91" width="191" alt="" border="0"></span>
</div>
<p class="last-para">Because each vertex in cycle <i class="emphasis">p</i> appears once in each of the summations, we derive the contradiction that 0 = <i class="emphasis">k</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">The next two lemmas show how push and relabel operations change the admissible network.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 26.28</span></span><a name="2093"></a><a name="ch26ex61"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a flow network, let <i class="emphasis">f</i> be a preflow in <i class="emphasis">G</i>, and suppose that the attribute <i class="emphasis">h</i> is a height function. If a vertex <i class="emphasis">u</i> is overflowing and (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is an admissible edge, then PUSH(<i class="emphasis">u</i>, <i class="emphasis">v</i>) applies. The operation does not create any new admissible edges, but it may cause (<i class="emphasis">u</i>, <i class="emphasis">v</i>) to become inadmissible.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> By the definition of an admissible edge, flow can be pushed from <i class="emphasis">u</i> to <i class="emphasis">v</i>. Since <i class="emphasis">u</i> is overflowing, the operation PUSH(<i class="emphasis">u</i>, <i class="emphasis">v</i>) applies. The only new residual edge that can be created by pushing flow from <i class="emphasis">u</i> to <i class="emphasis">v</i> is the edge (<i class="emphasis">v</i>, <i class="emphasis">u</i>). Since <i class="emphasis">h</i>[<i class="emphasis">v</i>] = <i class="emphasis">h</i>[<i class="emphasis">u</i>] - 1, edge (<i class="emphasis">v</i>, <i class="emphasis">u</i>) cannot become admissible. If the operation is asaturating push, then <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = 0 afterward and (<i class="emphasis">u</i>, <i class="emphasis">v</i>) becomes inadmissible.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 26.29</span></span><a name="2094"></a><a name="ch26ex62"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a flow network, let <i class="emphasis">f</i> be a preflow in <i class="emphasis">G</i>, and suppose that the attribute <i class="emphasis">h</i> is a height function. If a vertex <i class="emphasis">u</i> is overflowing and there are no admissible edges leaving <i class="emphasis">u</i>, then RELABEL(<i class="emphasis">u</i>) applies. After the relabel operation, there is at least one admissible edge leaving <i class="emphasis">u</i>, but there are no admissible edges entering <i class="emphasis">u</i>.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> If <i class="emphasis">u</i> is overflowing, then by <a href="DDU0164.html#2062" target="_parent" class="chapterjump">Lemma 26.15</a>, either a push or a relabel operation applies to it. If there are no admissible edges leaving <i class="emphasis">u</i>, then no flow can be pushed from <i class="emphasis">u</i> and so RELABEL(<i class="emphasis">u</i>) applies. After the relabel operation, <i class="emphasis">h</i>[<i class="emphasis">u</i>] = 1 + min {<i class="emphasis">h</i>[<i class="emphasis">v</i>] : (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E<sub>f</sub></i>}. Thus, if <i class="emphasis">v</i> is a vertex that realizes the minimum in this set, the edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) becomes admissible. Hence, after the relabel, there is at least one admissible edge leaving <i class="emphasis">u</i>.</p>
<p class="last-para">To show that no admissible edges enter <i class="emphasis">u</i> after a relabel operation, suppose that there is a vertex <i class="emphasis">v</i> such that (<i class="emphasis">v</i>, <i class="emphasis">u</i>) is admissible. Then, <i class="emphasis">h</i>[<i class="emphasis">v</i>] = <i class="emphasis">h</i>[<i class="emphasis">u</i>] + 1 after the relabel, and so <i class="emphasis">h</i>[<i class="emphasis">v</i>] <span class="unicode">&gt;</span> <i class="emphasis">h</i>[<i class="emphasis">u</i>] + 1 just before the relabel. But by <a href="DDU0164.html#2056" target="_parent" class="chapterjump">Lemma 26.13</a>, no <a name="2095"></a><a name="IDX-683"></a>residual edges exist between vertices whose heights differ by more than 1. Moreover, relabeling a vertex does not change the residual network. Thus, (<i class="emphasis">v</i>, <i class="emphasis">u</i>) is not in the residual network, and hence it cannot be in the admissible network.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="2096"></a><a name="ch26lev3sec19"></a>Neighbor lists</h4>
<p class="first-para">Edges in the relabel-to-front algorithm are organized into "neighbor lists." Given a flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>), the <b class="bold"><i class="emphasis">neighbor list</i></b> <i class="emphasis">N</i>[<i class="emphasis">u</i>] for a vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> is a singly linked list of the neighbors of <i class="emphasis">u</i> in <i class="emphasis">G</i>. Thus, vertex <i class="emphasis">v</i> appears in the list <i class="emphasis">N</i>[<i class="emphasis">u</i>] if (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i> or (<i class="emphasis">v</i>, <i class="emphasis">u</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>. The neighbor list <i class="emphasis">N</i>[<i class="emphasis">u</i>] contains exactly those vertices <i class="emphasis">v</i> for which there may be a residual edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>). The first vertex in <i class="emphasis">N</i>[<i class="emphasis">u</i>] is pointed to by <i class="emphasis">head</i>[<i class="emphasis">N</i>[<i class="emphasis">u</i>]]. The vertex following <i class="emphasis">v</i> in a neighbor list is pointed to by <i class="emphasis">next-neighbor</i>[<i class="emphasis">v</i>]; this pointer is NIL if <i class="emphasis">v</i> is the last vertex in the neighbor list.</p>
<p class="last-para">The relabel-to-front algorithm cycles through each neighbor list in an arbitrary order that is fixed throughout the execution of the algorithm. For each vertex <i class="emphasis">u</i>, the field <i class="emphasis">current</i>[<i class="emphasis">u</i>] points to the vertex currently under consideration in <i class="emphasis">N</i>[<i class="emphasis">u</i>]. Initially, <i class="emphasis">current</i>[<i class="emphasis">u</i>] is set to <i class="emphasis">head</i>[<i class="emphasis">N</i>[<i class="emphasis">u</i>]].</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="2097"></a><a name="ch26lev3sec20"></a>Discharging an overflowing vertex</h4>
<p class="first-para">An overflowing vertex <i class="emphasis">u</i> is <b class="bold"><i class="emphasis">discharged</i></b> by pushing all of its excess flow through admissible edges to neighboring vertices, relabeling <i class="emphasis">u</i> as necessary to cause edges leaving <i class="emphasis">u</i> to become admissible. The pseudocode goes as follows.</p>
<div class="informalexample">
<pre class="literallayout-normal">
DISCHARGE(<i class="emphasis">u</i>)
1  <b class="bold">while</b> <i class="emphasis">e</i>[<i class="emphasis">u</i>] <span class="unicode">&gt;</span> 0
2      <b class="bold">do</b> <i class="emphasis">v</i> <span class="unicode">&larr;</span> <i class="emphasis">current</i>[<i class="emphasis">u</i>]
3          <b class="bold">if</b> <i class="emphasis">v</i> = NIL
4             <b class="bold">then</b> RELABEL(<i class="emphasis">u</i>)
5                  <i class="emphasis">current</i>[<i class="emphasis">u</i>] <span class="unicode">&larr;</span> <i class="emphasis">head</i>[<i class="emphasis">N</i>[<i class="emphasis">u</i>]]
6          <b class="bold">elseif</b> <i class="emphasis">c<sub>f</sub></i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&gt;</span> 0 and <i class="emphasis">h</i>[<i class="emphasis">u</i>] = <i class="emphasis">h</i>[<i class="emphasis">v</i>] + 1
7            <b class="bold">then</b> PUSH(<i class="emphasis">u</i>, <i class="emphasis">v</i>)
8          <b class="bold">else</b> <i class="emphasis">current</i>[<i class="emphasis">u</i>] <span class="unicode">&larr;</span> <i class="emphasis">next-neighbor</i>[<i class="emphasis">v</i>]
</pre>
</div>
<p class="para">
<a class="internaljump" href="#ch26fig09">Figure 26.9</a> steps through several iterations of the <b class="bold">while</b> loop of lines 1<span class="unicode">-</span>8, which executes as long as vertex <i class="emphasis">u</i> has positive excess. Each iteration performs exactly one of three actions, depending on the current vertex <i class="emphasis">v</i> in the neighbor list <i class="emphasis">N</i>[<i class="emphasis">u</i>].</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="first-para">If <i class="emphasis">v</i> is NIL, then we have run off the end of <i class="emphasis">N</i>[<i class="emphasis">u</i>]. Line 4 relabels vertex <i class="emphasis">u</i>, and then line 5 resets the current neighbor of <i class="emphasis">u</i> to be the first one in <i class="emphasis">N</i>[<i class="emphasis">u</i>]. (<a class="internaljump" href="#ch26ex63">Lemma 26.30</a> below states that the relabel operation applies in this situation.)</p>
</li>
<li class="listitem">
<p class="first-para">If <i class="emphasis">v</i> is non-NIL and (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is an admissible edge (determined by the test in line 6), then line 7 pushes some (or possibly all) of <i class="emphasis">u</i>'s excess to vertex <i class="emphasis">v</i>.</p>
<a name="2098"></a><a name="IDX-684"></a><a name="2099"></a><a name="IDX-685"></a><a name="2100"></a><a name="IDX-686"></a>
</li>
<li class="listitem">
<p class="first-para">If <i class="emphasis">v</i> is non-NIL but (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is inadmissible, then line 8 advances <i class="emphasis">current</i>[<i class="emphasis">u</i>] one position further in the neighbor list <i class="emphasis">N</i>[<i class="emphasis">u</i>].</p>
</li>
</ol>
<div class="figure">
<a name="2101"></a><a name="ch26fig09"></a><span class="figuremediaobject"><a href="images/fig706%5F01%5F0%2Ejpg" NAME="IMG_889" target="_parent"><img src="images/fig706_01.jpg" height="355" width="350" alt="Click To expand" border="0"></a></span><span class="figurespace">&nbsp;</span><span class="figuremediaobject"><a href="images/fig707%5F01%5F0%2Ejpg" NAME="IMG_890" target="_parent"><img src="images/fig707_01.jpg" height="500" width="334" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 26.9: </span>Discharging a vertex <i class="emphasis">y</i>. It takes 15 iterations of the <i class="emphasis">while</i> loop of DISCHARGE to push all the excess flow from <i class="emphasis">y</i>. Only the neighbors of <i class="emphasis">y</i> and edges entering or leaving <i class="emphasis">y</i> are shown. In each part, the number inside each vertex is its excess at the beginning of the first iteration shown in the part, and each vertex is shown at its height throughout the part. To the right is shown the neighbor list <i class="emphasis">N</i>[<i class="emphasis">y</i>] at the beginning of each iteration, with the iteration number on top. The shaded neighbor is <i class="emphasis">current</i>[<i class="emphasis">y</i>]. <i class="emphasis">(a)</i> Initially, there are 19 units of excess to push from <i class="emphasis">y</i>, and <i class="emphasis">current</i>[<i class="emphasis">y</i>] = <i class="emphasis">s</i>. Iterations 1, 2, and 3 just advance <i class="emphasis">current</i>[<i class="emphasis">y</i>], since there are no admissible edges leaving <i class="emphasis">y</i>. In iteration 4, <i class="emphasis">current</i>[<i class="emphasis">y</i>] = NIL (shown by the shading being below the neighbor list), and so <i class="emphasis">y</i> is relabeled and <i class="emphasis">current</i>[<i class="emphasis">y</i>] is reset to the head of the neighbor list. <i class="emphasis">(b)</i> After relabeling, vertex <i class="emphasis">y</i> has height 1. In iterations 5 and 6, edges (<i class="emphasis">y, s</i>) and (<i class="emphasis">y, x</i>) are found to be inadmissible, but 8 units of excess flow are pushed from <i class="emphasis">y</i> to <i class="emphasis">z</i> in iteration 7. Because of the push, <i class="emphasis">current</i>[<i class="emphasis">y</i>] is not advanced in this iteration. <i class="emphasis">(c)</i> Because the push in iteration 7 saturated edge (<i class="emphasis">y, z</i>), it is found inadmissible in iteration 8. In iteration 9, <i class="emphasis">current</i>[<i class="emphasis">y</i>] = NIL, and so vertex <i class="emphasis">y</i> is again relabeled and <i class="emphasis">current</i>[<i class="emphasis">y</i>] is reset. <i class="emphasis">(d)</i> In iteration 10, (<i class="emphasis">y, s</i>) is inadmissible, but 5 units of excess flow are pushed from <i class="emphasis">y</i> to <i class="emphasis">x</i> in iteration 11. <i class="emphasis">(e)</i> Because <i class="emphasis">current</i>[<i class="emphasis">y</i>] was not advanced in iteration 11, iteration 12 finds (<i class="emphasis">y, x</i>) to be inadmissible. Iteration 13 finds (<i class="emphasis">y, z</i>) inadmissible, and iteration 14 relabels vertex <i class="emphasis">y</i> and resets <i class="emphasis">current</i>[<i class="emphasis">y</i>]. <i class="emphasis">(f)</i> Iteration 15 pushes 6 units of excess flow from <i class="emphasis">y</i> to <i class="emphasis">s</i>. <i class="emphasis">(g)</i> Vertex <i class="emphasis">y</i> now has no excess flow, and DISCHARGE terminates. In this example, DISCHARGE both starts and finishes with the current pointer at the head of the neighbor list, but in general this need not be the case.</span>
</div>
<p class="para">Observe that if DISCHARGE is called on an overflowing vertex <i class="emphasis">u</i>, then the last action performed by DISCHARGE must be a push from <i class="emphasis">u</i>. Why? The procedure terminates only when <i class="emphasis">e</i>[<i class="emphasis">u</i>] becomes zero, and neither the relabel operation nor the advancing of the pointer <i class="emphasis">current</i>[<i class="emphasis">u</i>] affects the value of <i class="emphasis">e</i>[<i class="emphasis">u</i>].</p>
<p class="para">We must be sure that when PUSH or RELABEL is called by DISCHARGE, the operation applies. The next lemma proves this fact.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 26.30</span></span><a name="2102"></a><a name="ch26ex63"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">If DISCHARGE calls PUSH(<i class="emphasis">u</i>, <i class="emphasis">v</i>) in line 7, then a push operation applies to (<i class="emphasis">u</i>, <i class="emphasis">v</i>). If DISCHARGE calls RELABEL(<i class="emphasis">u</i>) in line 4, then a relabel operation applies to <i class="emphasis">u</i>.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> The tests in lines 1 and 6 ensure that a push operation occurs only if the operation applies, which proves the first statement in the lemma.</p>
<p class="last-para">To prove the second statement, according to the test in line 1 and <a class="internaljump" href="#ch26ex62">Lemma 26.29</a>, we need only show that all edges leaving <i class="emphasis">u</i> are inadmissible. Observe that as DISCHARGE(<i class="emphasis">u</i>) is repeatedly called, the pointer <i class="emphasis">current</i>[<i class="emphasis">u</i>] moves down the list <i class="emphasis">N</i>[<i class="emphasis">u</i>]. Each "pass" begins at the head of <i class="emphasis">N</i>[<i class="emphasis">u</i>] and finishes with <i class="emphasis">current</i>[<i class="emphasis">u</i>] = NIL, at which point <i class="emphasis">u</i> is relabeled and a new pass begins. For the <i class="emphasis">current</i>[<i class="emphasis">u</i>] pointer to advance past a vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">N</i>[<i class="emphasis">u</i>] during a pass, the edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) must be deemed inadmissible by the test in line 6. Thus, by the time the pass completes, every edge leaving <i class="emphasis">u</i> has been determined to be inadmissible at some time during the pass. The key observation is that at the end of the pass, every edge leaving <i class="emphasis">u</i> is still inadmissible. Why? By <a class="internaljump" href="#ch26ex61">Lemma 26.28</a>, pushes cannot create any admissible edges, let alone one leaving <i class="emphasis">u</i>. Thus, any admissible edge must be created by a relabel operation. But the vertex <i class="emphasis">u</i> is not relabeled during the pass, and by <a class="internaljump" href="#ch26ex62">Lemma 26.29</a>, any other vertex <i class="emphasis">v</i> that is relabeled during the pass has no entering admissible edges after relabeling. Thus, at the end of the pass, all edges leaving <i class="emphasis">u</i> remain inadmissible, and the lemma is proved.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="2103"></a><a name="ch26lev3sec21"></a>The relabel-to-front algorithm</h4>
<p class="first-para">In the relabel-to-front algorithm, we maintain a linked list <i class="emphasis">L</i> consisting of all vertices in <i class="emphasis">V</i> - {<i class="emphasis">s</i>, <i class="emphasis">t</i>}. A key property is that the vertices in <i class="emphasis">L</i> are topologically sorted according to the admissible network, as we shall see in the loop invariant below. (Recall from <a class="internaljump" href="#ch26ex60">Lemma 26.27</a> that the admissible network is a dag.)</p>
<p class="para">The pseudocode for the relabel-to-front algorithm assumes that the neighbor lists <i class="emphasis">N</i>[<i class="emphasis">u</i>] have already been created for each vertex <i class="emphasis">u</i>. It also assumes that <i class="emphasis">next</i>[<i class="emphasis">u</i>] points to the vertex that follows <i class="emphasis">u</i> in list <i class="emphasis">L</i> and that, as usual, <i class="emphasis">next</i>[<i class="emphasis">u</i>] = NIL if <i class="emphasis">u</i> is the last vertex in the list.<a name="2104"></a><a name="IDX-687"></a>
</p>
<div class="informalexample">
<pre class="literallayout-normal">
RELABEL-TO-FRONT(<i class="emphasis">G</i>, <i class="emphasis">s</i>, <i class="emphasis">t</i>)
 1  INITIALIZE-PREFLOW(<i class="emphasis">G</i>, <i class="emphasis">s</i>)
 2  <i class="emphasis">L</i> <span class="unicode">&larr;</span> <i class="emphasis">V</i>[<i class="emphasis">G</i>] - {<i class="emphasis">s</i>, <i class="emphasis">t</i>}, in any order
 3  <b class="bold">for</b> each vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>[<i class="emphasis">G</i>] - {<i class="emphasis">s</i>, <i class="emphasis">t</i>}
 4      <b class="bold">do</b> <i class="emphasis">current</i>[<i class="emphasis">u</i>] <span class="unicode">&larr;</span> <i class="emphasis">head</i>[<i class="emphasis">N</i>[<i class="emphasis">u</i>]]
 5  <i class="emphasis">u</i> <span class="unicode">&larr;</span> <i class="emphasis">head</i>[<i class="emphasis">L</i>]
 6  <b class="bold">while</b> <i class="emphasis">u</i> <span class="unicode">&ne;</span> NIL 
 7     <b class="bold">do</b> <i class="emphasis">old-height</i> <span class="unicode">&larr;</span> <i class="emphasis">h</i>[<i class="emphasis">u</i>]
 8        DISCHARGE(<i class="emphasis">u</i>)
 9        <b class="bold">if</b> <i class="emphasis">h</i>[<i class="emphasis">u</i>] <span class="unicode">&gt;</span> <i class="emphasis">old-height</i>
10           <b class="bold">then</b> move <i class="emphasis">u</i> to the front of list <i class="emphasis">L</i>
11        <i class="emphasis">u</i> <span class="unicode">&larr;</span> <i class="emphasis">next</i>[<i class="emphasis">u</i>]
</pre>
</div>
<p class="para">The relabel-to-front algorithm works as follows. Line 1 initializes the preflow and heights to the same values as in the generic push-relabel algorithm. Line 2 initializes the list <i class="emphasis">L</i> to contain all potentially overflowing vertices, in any order. Lines 3<span class="unicode">-</span>4 initialize the <i class="emphasis">current</i> pointer of each vertex <i class="emphasis">u</i> to the first vertex in <i class="emphasis">u</i>'s neighbor list.</p>
<p class="para">As shown in <a class="internaljump" href="#ch26fig10">Figure 26.10</a>, the <b class="bold">while</b> loop of lines 6<span class="unicode">-</span>11 runs through the list <i class="emphasis">L</i>, discharging vertices. Line 5 makes it start with the first vertex in the list. Each time through the loop, a vertex <i class="emphasis">u</i> is discharged in line 8. If <i class="emphasis">u</i> was relabeled by the DISCHARGE procedure, line 10 moves it to the front of list <i class="emphasis">L</i>. This determination is made by saving <i class="emphasis">u</i>'s height in the variable <i class="emphasis">old-height</i> before the discharge operation (line 7) and comparing this saved height to <i class="emphasis">u</i>'s height afterward (line 9). Line 11 makes the next iteration of the <b class="bold">while</b> loop use the vertex following <i class="emphasis">u</i> in list <i class="emphasis">L</i>. If <i class="emphasis">u</i> was moved to the front of the list, the vertex used in the next iteration is the one following <i class="emphasis">u</i> in its new position in the list.</p>
<div class="figure">
<a name="2105"></a><a name="ch26fig10"></a><span class="figuremediaobject"><a href="images/fig710%5F01%5F0%2Ejpg" NAME="IMG_891" target="_parent"><img src="images/fig710_01.jpg" height="367" width="350" alt="Click To expand" border="0"></a></span><span class="figurespace">&nbsp;</span><span class="figuremediaobject"><a href="images/fig711%5F01%5F0%2Ejpg" NAME="IMG_892" target="_parent"><img src="images/fig711_01.jpg" height="243" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 26.10: </span>The action of RELABEL-TO-FRONT. <i class="emphasis">(a)</i> A flow network just before the first iteration of the <i class="emphasis">while</i> loop. Initially, 26 units of flow leave source <i class="emphasis">s</i>. On the right is shown the initial list <i class="emphasis">L</i> = <span class="unicode">&#12297;</span><i class="emphasis">x, y, z</i><span class="unicode">&#12297;</span>, where initially <i class="emphasis">u</i> = <i class="emphasis">x</i>. Under each vertex in list <i class="emphasis">L</i> is its neighbor list, with the current neighbor shaded. Vertex <i class="emphasis">x</i> is discharged. It is relabeled to height 1, 5 units of excess flow are pushed to <i class="emphasis">y</i>, and the 7 remaining units of excess are pushed to the sink <i class="emphasis">t</i>. Because <i class="emphasis">x</i> is relabeled, it is moved to the head of <i class="emphasis">L</i>, which in this case does not change the structure of <i class="emphasis">L</i>. <i class="emphasis">(b)</i> After <i class="emphasis">x</i>, the next vertex in <i class="emphasis">L</i> that is discharged is <i class="emphasis">y</i>. Figure 26.9 shows the detailed action of discharging <i class="emphasis">y</i> in this situation. Because <i class="emphasis">y</i> is relabeled, it is moved to the head of <i class="emphasis">L</i>. <i class="emphasis">(c)</i> Vertex <i class="emphasis">x</i> now follows <i class="emphasis">y</i> in <i class="emphasis">L</i>, and so it is again discharged, pushing all 5 units of excess flow to <i class="emphasis">t</i>. Because vertex <i class="emphasis">x</i> is not relabeled in this discharge operation, it remains in place in list <i class="emphasis">L</i>. <i class="emphasis">(d)</i> Since vertex <i class="emphasis">z</i> follows vertex <i class="emphasis">x</i> in <i class="emphasis">L</i>, it is discharged. It is relabeled to height 1 and all 8 units of excess flow are pushed to <i class="emphasis">t</i>. Because <i class="emphasis">z</i> is relabeled, it is moved to the front of <i class="emphasis">L</i>. <i class="emphasis">(e)</i> Vertex <i class="emphasis">y</i> now follows vertex <i class="emphasis">z</i> in <i class="emphasis">L</i> and is therefore discharged. But because <i class="emphasis">y</i> has no excess, DISCHARGE immediately returns, and <i class="emphasis">y</i> remains in place in <i class="emphasis">L</i>. Vertex <i class="emphasis">x</i> is then discharged. Because it, too, has no excess, DISCHARGE again returns, and <i class="emphasis">x</i> remains in place in <i class="emphasis">L</i>. RELABEL-TO-FRONT has reached the end of list <i class="emphasis">L</i> and terminates. There are no overflowing vertices, and the preflow is a maximum flow.</span>
</div>
<p class="para">To show that RELABEL-TO-FRONT computes a maximum flow, we shall show that it is an implementation of the generic push-relabel algorithm. First, observe that it performs push and relabel operation only when they apply, since <a class="internaljump" href="#ch26ex63">Lemma 26.30</a> guarantees that DISCHARGE only performs them when they apply. It remains to show that when RELABEL-TO-FRONT terminates, no basic operations apply. The remainder of the correctness argument relies on the following loop invariant:</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">At each test in line 6 of RELABEL-TO-FRONT, list <i class="emphasis">L</i> is a topological sort of the vertices in the admissible network <i class="emphasis">G</i><sub><i class="emphasis">f</i>,<i class="emphasis">h</i></sub> = (<i class="emphasis">V</i>, <i class="emphasis">E</i><sub><i class="emphasis">f</i>,<i class="emphasis">h</i></sub>), and no vertex before <i class="emphasis">u</i> in the list has excess flow.</p>
</li>
</ul>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">
<b class="bold">Initialization:</b> Immediately after INITIALIZE-PREFLOW has been run, <i class="emphasis">h</i>[<i class="emphasis">s</i>] = |<i class="emphasis">V</i>| and <i class="emphasis">h</i>[<i class="emphasis">v</i>] = 0 for all <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> - {<i class="emphasis">s</i>}. Since |<i class="emphasis">V</i> | = 2 (because <i class="emphasis">V</i> contains at least <i class="emphasis">s</i> and <i class="emphasis">t</i>), no edge can be admissible. Thus, <i class="emphasis">E</i><sub><i class="emphasis">f</i>,<i class="emphasis">h</i></sub> = <span class="unicode">&oslash;</span>, and any ordering of <i class="emphasis">V</i> - {<i class="emphasis">s</i>, <i class="emphasis">t</i>} is a topological sort of <i class="emphasis">G</i><sub><i class="emphasis">f</i>,<i class="emphasis">h</i></sub>.<a name="2106"></a><a name="IDX-688"></a>
</p>
<a name="2107"></a><a name="IDX-689"></a>
<p class="last-para">Since <i class="emphasis">u</i> is initially the head of the list <i class="emphasis">L</i>, there are no vertices before it and so there are none before it with excess flow.</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">Maintenance:</b> To see that the topological sort is maintained by each iteration of the <b class="bold">while</b> loop, we start by observing that the admissible network is changed only by push and relabel operations. By <a class="internaljump" href="#ch26ex61">Lemma 26.28</a>, push operations do not cause edges to become admissible. Thus, admissible edges can be created only by relabel operations. After a vertex <i class="emphasis">u</i> is relabeled, however, <a class="internaljump" href="#ch26ex62">Lemma 26.29</a> states that there are no admissible edges entering <i class="emphasis">u</i> but there may be admissible edges leaving <i class="emphasis">u</i>. Thus, by moving <i class="emphasis">u</i> to the front of <i class="emphasis">L</i>, the algorithm ensures that any admissible edges leaving <i class="emphasis">u</i> satisfy the topological sort ordering.</p>
<p class="para">To see that no vertex preceding <i class="emphasis">u</i> in <i class="emphasis">L</i> has excess flow, we denote the vertex that will be <i class="emphasis">u</i> in the next iteration by <i class="emphasis">u</i>'. The vertices that will precede <i class="emphasis">u</i>' in the next iteration include the current <i class="emphasis">u</i> (due to line 11) and either no other vertices (if <i class="emphasis">u</i> is relabeled) or the same vertices as before (if <i class="emphasis">u</i> is not relabeled). Since <i class="emphasis">u</i> is discharged, it has no excess flow afterward. Thus, if <i class="emphasis">u</i> is relabeled during the discharge, no vertices preceding <i class="emphasis">u</i>' have excess flow. If <i class="emphasis">u</i> is not relabeled during the discharge, no vertices before it on the list acquired excess flow during this discharge, because <i class="emphasis">L</i> remained topologically sorted at all times during the discharge (as pointed out just above, admissible edges are created only by relabeling, not pushing), and so each push operation causes excess flow to move only to vertices further down the list (or to <i class="emphasis">s</i> or <i class="emphasis">t</i>). Again, no vertices preceding <i class="emphasis">u</i>' have excess flow.</p>
<a name="2108"></a><a name="IDX-690"></a>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">Termination:</b> When the loop terminates, <i class="emphasis">u</i> is just past the end of <i class="emphasis">L</i>, and so the loop invariant ensures that the excess of every vertex is 0. Thus, no basic operations apply.</p>
</li>
</ul>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="2109"></a><a name="ch26lev3sec22"></a>Analysis</h4>
<p class="first-para">We shall now show that RELABEL-TO-FRONT runs in <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>3</sup>) time on any flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>). Since the algorithm is an implementation of the generic push-relabel algorithm, we shall take advantage of <a href="DDU0164.html#2073" target="_parent" class="chapterjump">Corollary 26.22</a>, which provides an <i class="emphasis">O</i>(<i class="emphasis">V</i>) bound on the number of relabel operations executed per vertex and an <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>2</sup>) bound on the total number of relabel operations overall. In addition, <a href="DDU0164.html#2081" target="_parent" class="chapterjump">Exercise 26.4-2</a> provides an <i class="emphasis">O</i>(<i class="emphasis">VE</i>) bound on the total time spent performing relabel operations, and <a href="DDU0164.html#2075" target="_parent" class="chapterjump">Lemma 26.23</a> provides an <i class="emphasis">O</i>(<i class="emphasis">VE</i>) bound on the total number of saturating push operations.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 26.31</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The running time of RELABEL-TO-FRONT on any flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) is <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>3</sup>).</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> Let us consider a "phase" of the relabel-to-front algorithm to be the time between two consecutive relabel operations. There are <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>2</sup>) phases, since there are <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>2</sup>) relabel operations. Each phase consists of at most |<i class="emphasis">V</i>| calls to DISCHARGE, which can be seen as follows. If DISCHARGE does not perform a re-label operation, then the next call to DISCHARGE is further down the list <i class="emphasis">L</i>, and the length of <i class="emphasis">L</i> is less than |<i class="emphasis">V</i>|. If DISCHARGE does perform a relabel, the next call to DISCHARGE belongs to a different phase. Since each phase contains at most |<i class="emphasis">V</i>| calls to DISCHARGE and there are <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>2</sup>) phases, the number of times DISCHARGE is called in line 8 of RELABEL-TO-FRONT is <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>3</sup>). Thus, the total work performed by the <b class="bold">while</b> loop in RELABEL-TO-FRONT, excluding the work performed within DISCHARGE, is at most <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>3</sup>).</p>
<p class="para">We must now bound the work performed within DISCHARGE during the execution of the algorithm. Each iteration of the <b class="bold">while</b> loop within DISCHARGE performs one of three actions. We shall analyze the total amount of work involved in performing each of these actions.</p>
<p class="para">We start with relabel operations (lines 4<span class="unicode">-</span>5). <a href="DDU0164.html#2081" target="_parent" class="chapterjump">Exercise 26.4-2</a> provides an <i class="emphasis">O</i>(<i class="emphasis">VE</i>) time bound on all the <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>2</sup>) relabels that are performed.</p>
<p class="para">Now, suppose that the action updates the <i class="emphasis">current</i>[<i class="emphasis">u</i>] pointer in line 8. This action occurs <i class="emphasis">O</i>(degree(<i class="emphasis">u</i>) times each time a vertex <i class="emphasis">u</i> is relabeled, and <i class="emphasis">O</i>(<i class="emphasis">V</i> <span class="unicode">&middot;</span> degree(<i class="emphasis">u</i>)) times overall for the vertex. For all vertices, therefore, the total amount of work done in advancing pointers in neighbor lists is <i class="emphasis">O</i>(<i class="emphasis">VE</i>) by the handshaking lemma (<a href="DDU0247.html#3341" target="_parent" class="chapterjump">Exercise B.4-1</a>).<a name="2110"></a><a name="IDX-691"></a>
</p>
<p class="para">The third type of action performed by DISCHARGE is a push operation (line 7). We already know that the total number of saturating push operations is <i class="emphasis">O</i>(<i class="emphasis">VE</i>). Observe that if a nonsaturating push is executed, DISCHARGE immediately returns, since the push reduces the excess to 0. Thus, there can be at most one nonsaturating push per call to DISCHARGE. As we have observed, DISCHARGE is called <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>3</sup>) times, and thus the total time spent performing nonsaturating pushes is <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>3</sup>).</p>
<p class="last-para">The running time of RELABEL-TO-FRONT is therefore <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>3</sup> + <i class="emphasis">VE</i>), which is <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>3</sup>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.5-1</span></span><a name="2111"></a><a name="ch26ex65"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Illustrate the execution of RELABEL-TO-FRONT in the manner of <a class="internaljump" href="#ch26fig10">Figure 26.10</a> for the flow network in <a href="DDU0161.html#1966" target="_parent" class="chapterjump">Figure 26.1(a)</a>. Assume that the initial ordering of vertices in <i class="emphasis">L</i> is <span class="unicode">&#12297;</span><i class="emphasis">v</i><sub>1</sub>, <i class="emphasis">v</i><sub>2</sub>, <i class="emphasis">v</i><sub>3</sub>, <i class="emphasis">v</i><sub>4</sub><span class="unicode">&#12297;</span> and that the neighbor lists are</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">N</i>[<i class="emphasis">v</i><sub>1</sub>]</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&#12296;</span><i class="emphasis">s</i>, <i class="emphasis">v</i><sub>2</sub>, <i class="emphasis">v</i><sub>3</sub><span class="unicode">&#12297;</span> ,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">N</i>[<i class="emphasis">v</i><sub>2</sub>]</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&#12296;</span><i class="emphasis">s</i>, <i class="emphasis">v</i><sub>1</sub>, <i class="emphasis">v</i><sub>3</sub>, <i class="emphasis">v</i><sub>4</sub><span class="unicode">&#12297;</span> ,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">N</i>[<i class="emphasis">v</i><sub>3</sub>]</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&#12296;</span><i class="emphasis">v</i><sub>1</sub>, <i class="emphasis">v</i><sub>2</sub>, <i class="emphasis">v</i><sub>4</sub> <i class="emphasis">t</i><span class="unicode">&#12297;</span> ,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">N</i>[<i class="emphasis">v</i><sub>4</sub>]</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&#12296;</span><i class="emphasis">v</i><sub>2</sub>, <i class="emphasis">v</i><sub>3</sub>, <i class="emphasis">t</i><span class="unicode">&#12297;</span> .</p>
</td>
</tr>
</tbody>
</table>
</div>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.5.2: </span><span class="unicode">&#9733;</span></span><a name="2112"></a><a name="ch26ex66"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">We would like to implement a push-relabel algorithm in which we maintain a first-in, first-out queue of overflowing vertices. The algorithm repeatedly discharges the vertex at the head of the queue, and any vertices that were not overflowing before the discharge but are overflowing afterward are placed at the end of the queue. After the vertex at the head of the queue is discharged, it is removed. When the queue is empty, the algorithm terminates. Show that this algorithm can be implemented to compute a maximum flow in <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>3</sup>) time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.5-3</span></span><a name="2113"></a><a name="ch26ex67"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that the generic algorithm still works if RELABEL updates <i class="emphasis">h</i>[<i class="emphasis">u</i>] by simply computing <i class="emphasis">h</i>[<i class="emphasis">u</i>] <span class="unicode">&larr;</span> <i class="emphasis">h</i>[<i class="emphasis">u</i>] + 1. How would this change affect the analysis of RELABEL-TO-FRONT?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.5-4: </span><span class="unicode">&#9733;</span></span><a name="2114"></a><a name="ch26ex68"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that if we always discharge a highest overflowing vertex, the push-relabel method can be made to run in <i class="emphasis">O</i>(<i class="emphasis">V</i><sup>3</sup>) time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 26.5-5</span></span><a name="2115"></a><a name="ch26ex69"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that at some point in the execution of a push-relabel algorithm, there exists an integer 0 <span class="unicode">&lt;</span> <i class="emphasis">k</i> <span class="unicode">&le;</span> |<i class="emphasis">V</i>| - 1 for which no vertex has <i class="emphasis">h</i>[<i class="emphasis">v</i>] = <i class="emphasis">k</i>. Show that all <a name="2116"></a><a name="IDX-692"></a>vertices with <i class="emphasis">h</i>[<i class="emphasis">v</i>] <span class="unicode">&gt;</span> <i class="emphasis">k</i> are on the source side of a minimum cut. If such a <i class="emphasis">k</i> exists, the <b class="bold"><i class="emphasis">gap heuristic</i></b> updates every vertex <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> - <i class="emphasis">s</i> for which <i class="emphasis">h</i>[<i class="emphasis">v</i>] <span class="unicode">&gt;</span> <i class="emphasis">k</i> to set <i class="emphasis">h</i>[<i class="emphasis">v</i>] <span class="unicode">&larr;</span> max(<i class="emphasis">h</i>[<i class="emphasis">v</i>], |<i class="emphasis">V</i>|+1). Show that the resulting attribute <i class="emphasis">h</i> is a height function.(The gap heuristic is crucial in making implementations of the push-relabel method perform well in practice.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 26-1: </span>Escape problem</span><a name="2117"></a><a name="ch26ex70"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">An <i class="emphasis">n</i> <span class="unicode">&times;</span> <i class="emphasis">n</i> <b class="bold"><i class="emphasis">grid</i></b> is an undirected graph consisting of <i class="emphasis">n</i> rows and <i class="emphasis">n</i> columns of vertices, as shown in <a class="internaljump" href="#ch26fig11">Figure 26.11</a>. We denote the vertex in the <i class="emphasis">i</i>th row and the <i class="emphasis">j</i>th column by (<i class="emphasis">i</i>, <i class="emphasis">j</i>). All vertices in a grid have exactly four neighbors, except for the boundary vertices, which are the points (<i class="emphasis">i</i>, <i class="emphasis">j</i>) for which <i class="emphasis">i</i> = 1, <i class="emphasis">i</i> = <i class="emphasis">n</i>, <i class="emphasis">j</i> = 1, or <i class="emphasis">j</i> = <i class="emphasis">n</i>.</p>
<p class="para">
<div class="figure">
<a name="2118"></a><a name="ch26fig11"></a><span class="figuremediaobject"><a href="images/fig715%5F01%5F0%2Ejpg" NAME="IMG_893" target="_parent"><img src="images/fig715_01.jpg" height="147" width="326" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 26.11: </span>Grids for the escape problem. Starting points are black, and other grid vertices are white. <i class="emphasis">(a)</i> A grid with an escape, shown by shaded paths. <i class="emphasis">(b)</i> A grid with no escape.</span>
</div>
</p>
<p class="para">Given <i class="emphasis">m</i> <span class="unicode">&le;</span> <i class="emphasis">n</i><sup>2</sup> starting points (<i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">y</i><sub>1</sub>), (<i class="emphasis">x</i><sub>2</sub>, <i class="emphasis">y</i><sub>2</sub>), . . . ,(<i class="emphasis">x<sub>m</sub></i>, <i class="emphasis">y<sub>m</sub></i>) in the grid, the <b class="bold"><i class="emphasis">escape problem</i></b> is to determine whether or not there are <i class="emphasis">m</i> vertex-disjoint paths from the starting points to any <i class="emphasis">m</i> different points on the boundary. For example, the grid in <a class="internaljump" href="#ch26fig11">Figure 26.11(a)</a> has an escape, but the grid in <a class="internaljump" href="#ch26fig11">Figure 26.11(b)</a> does not.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Consider a flow network in which vertices, as well as edges, have capacities. That is, the total positive flow entering any given vertex is subject to a capacity constraint. Show that determining the maximum flow in a network with edge and vertex capacities can be reduced to an ordinary maximum-flow problem on a flow network of comparable size.</p>
</li>
<li class="listitem">
<p class="first-para">Describe an efficient algorithm to solve the escape problem, and analyze its running time.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 26-2: </span>Minimum path cover</span><a name="2119"></a><a name="ch26ex71"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">A <b class="bold"><i class="emphasis">path cover</i></b> of a directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) is a set <i class="emphasis">P</i> of vertex-disjoint paths such that every vertex in <i class="emphasis">V</i> is included in exactly one path in <i class="emphasis">P</i>. Paths may start and end anywhere, and they may be of any length, including 0. A <b class="bold"><i class="emphasis">minimum path cover</i></b> of <i class="emphasis">G</i> is a path cover containing the fewest possible paths.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Give an efficient algorithm to find a minimum path cover of a directed acyclic graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>). (<i class="emphasis">Hint:</i> Assuming that <i class="emphasis">V</i> = {1, 2, . . . ,<i class="emphasis">n</i>}, construct the graph <i class="emphasis">G</i>' = (<i class="emphasis">V</i>', <i class="emphasis">E</i>'), where</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">V</i>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">{<i class="emphasis">x</i><sub>0</sub>, <i class="emphasis">x</i><sub>1</sub>, . . . ,<i class="emphasis">x<sub>n</sub></i>} <span class="unicode">&cup;</span> {<i class="emphasis">y</i><sub>0</sub>, <i class="emphasis">y</i><sub>1</sub>, . . . ,<i class="emphasis">y<sub>n</sub></i>} ,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">E</i>'</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">{(<i class="emphasis">x</i><sub>0</sub>, <i class="emphasis">x<sub>i</sub></i>) : <i class="emphasis">i</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>} <span class="unicode">&cup;</span> {(<i class="emphasis">y<sub>i</sub></i>, <i class="emphasis">y</i><sub>0</sub>) : <i class="emphasis">i</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>} <span class="unicode">&cup;</span> {(<i class="emphasis">x<sub>i</sub></i>, <i class="emphasis">y<sub>j</sub></i>) : (<i class="emphasis">i</i>, <i class="emphasis">j</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>} ,</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="last-para">and run a maximum-flow algorithm.)<a name="2120"></a><a name="IDX-693"></a>
</p>
</li>
<li class="listitem">
<p class="first-para">Does your algorithm work for directed graphs that contain cycles? Explain.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 26-3: </span>Space shuttle experiments</span><a name="2121"></a><a name="ch26ex72"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Professor Spock is consulting for NASA, which is planning a series of space shuttle flights and must decide which commercial experiments to perform and which instruments to have on board each flight. For each flight, NASA considers a set <i class="emphasis">E</i> = {<i class="emphasis">E</i><sub>1</sub>, <i class="emphasis">E</i><sub>2</sub>, . . . ,<i class="emphasis">E<sub>m</sub></i>} of experiments, and the commercial sponsor of experiment <i class="emphasis">E<sub>j</sub></i> has agreed to pay NASA <i class="emphasis">p<sub>j</sub></i> dollars for the results of the experiment. The experiments use a set <i class="emphasis">I</i> = {<i class="emphasis">I</i><sub>1</sub>, <i class="emphasis">I</i><sub>2</sub>, . . . ,<i class="emphasis">I<sub>n</sub></i>} of instruments; each experiment <i class="emphasis">E<sub>j</sub></i> requires all the instruments in a subset <i class="emphasis">R<sub>j</sub></i> <span class="unicode">&sube;</span> <i class="emphasis">I</i>. The cost of carrying instrument <i class="emphasis">I<sub>k</sub></i> is <i class="emphasis">c<sub>k</sub></i> dollars. The professor's job is to find an efficient algorithm to determine which experiments to perform and which instruments to carry for a given flight in order to maximize the net revenue, which is the total income from experiments performed minus the total cost of all instruments carried.</p>
<p class="para">Consider the following network <i class="emphasis">G</i>. The network contains a source vertex <i class="emphasis">s</i>, vertices <i class="emphasis">I<sub>1</sub></i>, <i class="emphasis">I<sub>2</sub></i>, . . . ,<i class="emphasis">I<sub>n</sub></i>, vertices <i class="emphasis">E</i><sub>1</sub>, <i class="emphasis">E</i><sub>2</sub>, . . . ,<i class="emphasis">E<sub>m</sub></i>, and a sink vertex <i class="emphasis">t</i>. For <i class="emphasis">k</i> = 1, 2. . . ,<i class="emphasis">n</i>, there is an edge (<i class="emphasis">s</i>, <i class="emphasis">I<sub>k</sub></i>) of capacity <i class="emphasis">c<sub>k</sub></i>, and for <i class="emphasis">j</i> = 1, 2,. . . ,<i class="emphasis">m</i>, there is an edge (<i class="emphasis">E<sub>j</sub></i>, <i class="emphasis">t</i>) of capacity <i class="emphasis">p<sub>j</sub></i>. For <i class="emphasis">k</i> = 1, 2, . . . ,<i class="emphasis">n</i> and <i class="emphasis">j</i> = 1, 2, . . . ,<i class="emphasis">m</i>, if <i class="emphasis">I<sub>k</sub></i> <span class="unicode">&isin;</span> <i class="emphasis">R<sub>j</sub></i> , then there is an edge (<i class="emphasis">I<sub>k</sub></i>, <i class="emphasis">E<sub>j</sub></i>) of infinite capacity.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Show that if <i class="emphasis">E<sub>j</sub></i> <span class="unicode">&isin;</span> <i class="emphasis">T</i> for a finite-capacity cut (<i class="emphasis">S</i>, <i class="emphasis">T</i>) of <i class="emphasis">G</i>, then <i class="emphasis">I<sub>k</sub></i> <span class="unicode">&isin;</span> <i class="emphasis">T</i> for each <i class="emphasis">I<sub>k</sub></i> <span class="unicode">&isin;</span> <i class="emphasis">R<sub>j</sub></i>.</p>
</li>
<li class="listitem">
<p class="first-para">Show how to determine the maximum net revenue from the capacity of the minimum cut of <i class="emphasis">G</i> and the given <i class="emphasis">p<sub>j</sub></i> values.</p>
<a name="2122"></a><a name="IDX-694"></a>
</li>
<li class="listitem">
<p class="first-para">Give an efficient algorithm to determine which experiments to perform and which instruments to carry. Analyze the running time of your algorithm in terms of <i class="emphasis">m</i>, <i class="emphasis">n</i>, and <span class="inlinemediaobject"><img src="images/fig716_01.jpg" height="14" width="67" alt="" border="0"></span>.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problem 26-4: </span>Updating maximum flow</span><a name="2123"></a><a name="ch26ex73"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>,<i class="emphasis">E</i>) be a flow network with source <i class="emphasis">s</i>, sink <i class="emphasis">t</i>, and integer capacities. Suppose that we are given a maximum flow in <i class="emphasis">G</i>.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Suppose that the capacity of a single edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i> is increased by 1. Give an <i class="emphasis">O</i>(<i class="emphasis">V</i> + <i class="emphasis">E</i>)-time algorithm to update the maximum flow.</p>
</li>
<li class="listitem">
<p class="first-para">Suppose that the capacity of a single edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i> is decreased by 1. Give an <i class="emphasis">O</i>(<i class="emphasis">V</i> + <i class="emphasis">E</i>)-time algorithm to update the maximum flow.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problem 26-5: </span>Maximum flow by scaling</span><a name="2124"></a><a name="ch26ex74"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a flow network with source <i class="emphasis">s</i>, sink <i class="emphasis">t</i>, and an integer capacity <i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) on each edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>. Let <i class="emphasis">C</i> = max<sub>(<i class="emphasis">u</i>, <i class="emphasis">v</i>)<i class="emphasis"><span class="unicode">&isin;</span>E</i></sub><i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>).</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Argue that a minimum cut of <i class="emphasis">G</i> has capacity at most <i class="emphasis">C</i> |<i class="emphasis">E</i>|.</p>
</li>
<li class="listitem">
<p class="first-para">For a given number <i class="emphasis">K</i>, show that an augmenting path of capacity at least <i class="emphasis">K</i> can be found in <i class="emphasis">O</i>(<i class="emphasis">E</i>) time, if such a path exists.</p>
</li>
</ol>
<p class="para">The following modification of FORD-FULKERSON-METHOD can be used to compute a maximum flow in <i class="emphasis">G</i>.</p>
<div class="informalexample">
<pre class="literallayout-normal">
MAX-FLOW-BY-SCALING (<i class="emphasis">G</i>, <i class="emphasis">s</i>, <i class="emphasis">t</i>)
1  <i class="emphasis">C</i> <span class="unicode">&larr;</span>  max<sub>(<i class="emphasis">u</i>.<i class="emphasis">v</i>)<i class="emphasis"><span class="unicode">&isin;</span>E</i></sub><i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>)
2  initialize flow <i class="emphasis">f</i> to 0
3  <i class="emphasis">K</i> <span class="unicode">&larr;</span> 2<sup><span class="extended-unicode">&lfloor;</span>lg<i class="emphasis">C</i><span class="extended-unicode">&rfloor;</span></sup>
4  <b class="bold">while</b> <i class="emphasis">K</i> <span class="unicode">&ge;</span> 1
5      <b class="bold">do while</b> there exists an augmenting path <i class="emphasis">p</i> of capacity at least <i class="emphasis">K</i>
6             <b class="bold">do</b> augment flow <i class="emphasis">f</i> along <i class="emphasis">p</i>
7         <i class="emphasis">K</i> <span class="unicode">&larr;</span> <i class="emphasis">K</i>/2
8  <b class="bold">return</b> <i class="emphasis">f</i>
</pre>
</div>
<ol class="orderedlist" start="3" type="a">
<li class="first-listitem">
<p class="first-para">Argue that MAX-FLOW-BY-SCALING returns a maximum flow.</p>
</li>
<li class="listitem">
<p class="first-para">Show that the capacity of a minimum cut of the residual graph <i class="emphasis">G<sub>f</sub></i> is at most 2<i class="emphasis">K</i> |<i class="emphasis">E</i>| each time line 4 is executed.</p>
</li>
<li class="listitem">
<p class="first-para">Argue that the inner <b class="bold">while</b> loop of lines 5<span class="unicode">-</span>6 is executed <i class="emphasis">O</i>(<i class="emphasis">E</i>) times for each value of <i class="emphasis">K</i>.</p>
<a name="2125"></a><a name="IDX-695"></a>
</li>
<li class="listitem">
<p class="first-para">Conclude that MAX-FLOW-BY-SCALING can be implemented so that it runs in <i class="emphasis">O</i>(<i class="emphasis">E</i><sup>2</sup> lg <i class="emphasis">C</i>) time.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problem 26-6: </span>Maximum flow with negative capacities</span><a name="2126"></a><a name="ch26ex75"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that we allow a flow network to have negative (as well as positive) edge capacities. In such a network, a feasible flow need not exist.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Consider an edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) in a flow network <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) with <i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&lt;</span> 0. Briefly explain what such a negative capacity means in terms of the flow between <i class="emphasis">u</i> and <i class="emphasis">v</i>.</p>
</li>
</ol>
<p class="para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be a flow network with negative edge capacities, and let <i class="emphasis">s</i> and <i class="emphasis">t</i> be the source and sink of <i class="emphasis">G</i>. Construct the ordinary flow network <i class="emphasis">G</i>' = (<i class="emphasis">V</i>', <i class="emphasis">E</i>') with capacity function <i class="emphasis">c</i>', source <i class="emphasis">s</i>', and sink <i class="emphasis">t</i>', where</p>
<p class="para">
<i class="emphasis">V</i>' = <i class="emphasis">V</i> <span class="unicode">&cup;</span> {<i class="emphasis">s</i>', <i class="emphasis">t</i>'}</p>
<p class="para">and</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">E</i>'</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">E</i> <span class="unicode">&cup;</span> {(<i class="emphasis">u</i>, <i class="emphasis">v</i>) : (<i class="emphasis">v</i>, <i class="emphasis">u</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>}</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">&nbsp;</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&cup;</span> {(<i class="emphasis">s</i>', <i class="emphasis">v</i>) : <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>}</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">&nbsp;</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&cup;</span> {(<i class="emphasis">u</i>, <i class="emphasis">t</i>') : <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>}</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">&nbsp;</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&cup;</span> {(<i class="emphasis">s</i>, <i class="emphasis">t</i>), (<i class="emphasis">t</i>, <i class="emphasis">s</i>)}</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">We assign capacities to edges as follows. For each edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>, we set</p>
<p class="para">
<i class="emphasis">c</i>'(<i class="emphasis">u</i>, <i class="emphasis">v</i>) = <i class="emphasis">c</i>'(<i class="emphasis">v</i>, <i class="emphasis">u</i>) = (<i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) + <i class="emphasis">c</i>(<i class="emphasis">v</i>, <i class="emphasis">u</i>))/2 .</p>
<p class="para">For each vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, we set</p>
<p class="para">
<i class="emphasis">c</i>' (<i class="emphasis">s</i>', <i class="emphasis">u</i>) = max(0, (<i class="emphasis">c</i>(<i class="emphasis">V</i>, <i class="emphasis">u</i>) - <i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">V</i>))/2)</p>
<p class="para">and</p>
<p class="para">
<i class="emphasis">c</i>'(<i class="emphasis">u</i>, <i class="emphasis">t</i>') = max(0, (<i class="emphasis">c</i>(<i class="emphasis">u</i>, <i class="emphasis">V</i>) - <i class="emphasis">c</i>(<i class="emphasis">V</i>, <i class="emphasis">u</i>))/2) .</p>
<p class="para">We also set <i class="emphasis">c</i>'(<i class="emphasis">s</i>, <i class="emphasis">t</i>) = <i class="emphasis">c</i>'(<i class="emphasis">t</i>, <i class="emphasis">s</i>) = <span class="unicode">&infin;</span>.</p>
<ol class="orderedlist" start="2" type="a">
<li class="first-listitem">
<p class="first-para">Prove that if a feasible flow exists in <i class="emphasis">G</i>, then all capacities in <i class="emphasis">G</i>' are nonnegative and a maximum flow exists in <i class="emphasis">G</i>' such that all edges into the sink <i class="emphasis">t</i>' are saturated.</p>
</li>
<li class="listitem">
<p class="first-para">Prove the converse of part (b). Your proof should be constructive, that is, given a flow in <i class="emphasis">G</i>' that saturates all the edges into <i class="emphasis">t</i>', your proof should show how to obtain a feasible flow in <i class="emphasis">G</i>.</p>
<a name="2127"></a><a name="IDX-696"></a>
</li>
<li class="listitem">
<p class="first-para">Describe an algorithm that finds a maximum feasible flow in <i class="emphasis">G</i>. Denote by <i class="emphasis">MF</i>(|<i class="emphasis">V</i>|, |<i class="emphasis">E</i>|) the worst-case running time of an ordinary maximum flow algorithm on a graph with |<i class="emphasis">V</i>| vertices and |<i class="emphasis">E</i>| edges. Analyze your algorithm for computing the maximum flow of a flow network with negative capacities in terms of <i class="emphasis">MF</i>.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problem 26-7: </span>The Hopcroft-Karp bipartite matching algorithm</span><a name="2128"></a><a name="ch26ex76"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">In this problem, we describe a faster algorithm, due to Hopcroft and Karp, for finding a maximum matching in a bipartite graph. The algorithm runs in <span class="inlinemediaobject"><img src="images/fig718_01.jpg" height="13" width="43" alt="" border="0"></span> time. Given an undirected, bipartite graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>), where <i class="emphasis">V</i> = <i class="emphasis">L</i> <span class="unicode">&cup;</span> <i class="emphasis">R</i> and all edges have exactly one endpoint in <i class="emphasis">L</i>, let <i class="emphasis">M</i> be a matching in <i class="emphasis">G</i>. We say that a simple path <i class="emphasis">P</i> in <i class="emphasis">G</i> is an <b class="bold"><i class="emphasis">augmenting path</i></b> with respect to <i class="emphasis">M</i> if it starts at an unmatched vertex in <i class="emphasis">L</i>, ends at an unmatched vertex in <i class="emphasis">R</i>, and its edges belong alternately to <i class="emphasis">M</i> and <i class="emphasis">E</i> - <i class="emphasis">M</i>. (This definition of an augmenting path is related to, but different from, an augmenting path in a flow network.) In this problem, we treat a path as a sequence of edges, rather than as a sequence of vertices. A shortest augmenting path with respect to a matching <i class="emphasis">M</i> is an augmenting path with a minimum number of edges.</p>
<p class="para">Given two sets <i class="emphasis">A</i> and <i class="emphasis">B</i>, the <b class="bold"><i class="emphasis">symmetric difference</i></b> <i class="emphasis">A</i> <span class="unicode">&oplus;</span> <i class="emphasis">B</i> is defined as (<i class="emphasis">A</i>-<i class="emphasis">B</i>) <span class="unicode">&cup;</span> (<i class="emphasis">B</i> - <i class="emphasis">A</i>), that is, the elements that are in exactly one of the two sets.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Show that if <i class="emphasis">M</i> is a matching and <i class="emphasis">P</i> is an augmenting path with respect to <i class="emphasis">M</i>, then the symmetric difference <i class="emphasis">M</i> <span class="unicode">&oplus;</span> <i class="emphasis">P</i> is a matching and |<i class="emphasis">M</i> <span class="unicode">&oplus;</span> <i class="emphasis">P</i>| = |<i class="emphasis">M</i>| + 1. Show that if <i class="emphasis">P</i><sub>1</sub>, <i class="emphasis">P</i><sub>2</sub>, . . . ,<i class="emphasis">P<sub>k</sub></i> are vertex-disjoint augmenting paths with respect to <i class="emphasis">M</i>, then the symmetric difference <i class="emphasis">M</i> <span class="unicode">&oplus;</span> (<i class="emphasis">P</i><sub>1</sub> <span class="unicode">&cup;</span> <i class="emphasis">P</i><sub>2</sub> <span class="unicode">&cup;</span><span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&cup;</span> <i class="emphasis">P<sub>k</sub></i>) is a matching with cardinality |<i class="emphasis">M</i>| + <i class="emphasis">k</i>.</p>
</li>
</ol>
<p class="para">The general structure of our algorithm is the following:</p>
<div class="informalexample">
<pre class="literallayout-normal">
HOPCROFT-KARP (<i class="emphasis">G</i>)
1  <i class="emphasis">M</i> <span class="unicode">&larr;</span> <span class="unicode">&oslash;</span>
2  <b class="bold">repeat</b>
3         let <span class="inlinemediaobject"><img src="images/fig718_02.jpg" height="13" width="100" alt="" border="0"></span> be a maximum set of vertex-disjoint
                shortest augmenting paths with respect to <i class="emphasis">M</i>
4         <i class="emphasis">M</i> <span class="unicode">&larr;</span> <i class="emphasis">M</i> <span class="unicode">&oplus;</span> (<i class="emphasis">P</i><sub>1</sub> <span class="unicode">&cup;</span> <i class="emphasis">P</i><sub>2</sub> <span class="unicode">&cup;</span><span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&cup;</span> <i class="emphasis">P<sub>k</sub></i>)
5    <b class="bold">until</b> <span class="inlinemediaobject"><img src="images/fig718_03.jpg" height="9" width="30" alt="" border="0"></span>
6  <b class="bold">return</b> <i class="emphasis">M</i>
</pre>
</div>
<p class="para">The remainder of this problem asks you to analyze the number of iterations in the algorithm (that is, the number of iterations in the <b class="bold">repeat</b> loop) and to describe an implementation of line 3.<a name="2129"></a><a name="IDX-697"></a>
</p>
<ol class="orderedlist" start="2" type="a">
<li class="first-listitem">
<p class="first-para">Given two matchings <i class="emphasis">M</i> and <i class="emphasis">M</i>* in <i class="emphasis">G</i>, show that every vertex in the graph <i class="emphasis">G</i>' = (<i class="emphasis">V</i>, <i class="emphasis">M</i> <span class="unicode">&oplus;</span> <i class="emphasis">M</i>*) has degree at most 2. Conclude that <i class="emphasis">G</i>' is a disjoint union of simple paths or cycles. Argue that edges in each such simple path or cycle belong alternately to <i class="emphasis">M</i> or <i class="emphasis">M</i>*. Prove that if |<i class="emphasis">M</i>| <span class="unicode">&le;</span> |<i class="emphasis">M</i>*|, then <i class="emphasis">M</i> <span class="unicode">&oplus;</span> <i class="emphasis">M</i>* contains at least |<i class="emphasis">M</i>*| - |<i class="emphasis">M</i>| vertex-disjoint augmenting paths with respect to <i class="emphasis">M</i>.</p>
</li>
</ol>
<p class="para">Let <i class="emphasis">l</i> be the length of a shortest augmenting path with respect to a matching <i class="emphasis">M</i>, and let <i class="emphasis">P</i><sub>1</sub>, <i class="emphasis">P</i><sub>2</sub>, . . . ,<i class="emphasis">P<sub>k</sub></i> be a maximum set of vertex-disjoint augmenting paths of length <i class="emphasis">l</i> with respect to <i class="emphasis">M</i>. Let <i class="emphasis">M</i>' = <i class="emphasis">M</i> <span class="unicode">&oplus;</span> (<i class="emphasis">P</i><sub>1</sub> <span class="unicode">&cup;</span><span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&cup;</span> <i class="emphasis">P<sub>k</sub></i>), and suppose that <i class="emphasis">P</i> is a shortest augmenting path with respect to <i class="emphasis">M</i>'.</p>
<ol class="orderedlist" start="3" type="a">
<li class="first-listitem">
<p class="first-para">Show that if <i class="emphasis">P</i> is vertex-disjoint from <i class="emphasis">P</i><sub>1</sub>, <i class="emphasis">P</i><sub>2</sub>, . . . ,<i class="emphasis">P<sub>k</sub></i>, then <i class="emphasis">P</i> has more than <i class="emphasis">l</i> edges.</p>
</li>
<li class="listitem">
<p class="first-para">Now suppose that <i class="emphasis">P</i> is not vertex-disjoint from <i class="emphasis">P</i><sub>1</sub>, <i class="emphasis">P</i><sub>2</sub>, . . . ,<i class="emphasis">P<sub>k</sub></i>. Let <i class="emphasis">A</i> be the set of edges (<i class="emphasis">M</i> <span class="unicode">&oplus;</span> <i class="emphasis">M</i>') <span class="unicode">&oplus;</span> <i class="emphasis">P</i>. Show that <i class="emphasis">A</i> = (<i class="emphasis">P</i><sub>1</sub> <span class="unicode">&cup;</span> <i class="emphasis">P</i><sub>2</sub> <span class="unicode">&cup;</span><span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&cup;</span> <i class="emphasis">P<sub>k</sub></i>) <span class="unicode">&oplus;</span> <i class="emphasis">P</i> and that |<i class="emphasis">A</i>| <span class="unicode">&ge;</span> (<i class="emphasis">k</i> + 1)<i class="emphasis">l</i>. Conclude that <i class="emphasis">P</i> has more than <i class="emphasis">l</i> edges.</p>
</li>
<li class="listitem">
<p class="first-para">Prove that if a shortest augmenting path for <i class="emphasis">M</i> has length <i class="emphasis">l</i>, the size of the maximum matching is at most |<i class="emphasis">M</i>| + |<i class="emphasis">V</i>| /<i class="emphasis">l</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Show that the number of <b class="bold">repeat</b> loop iterations in the algorithm is at most <span class="inlinemediaobject"><img src="images/fig719_01.jpg" height="12" width="24" alt="" border="0"></span>. (<i class="emphasis">Hint:</i> By how much can <i class="emphasis">M</i> grow after iteration number <span class="inlinemediaobject"><img src="images/fig719_02.jpg" height="12" width="19" alt="" border="0"></span>?)</p>
</li>
<li class="listitem">
<p class="first-para">Give an algorithm that runs in <i class="emphasis">O</i>(<i class="emphasis">E</i>) time to find a maximum set of vertex-disjoint shortest augmenting paths <i class="emphasis">P</i><sub>1</sub>, <i class="emphasis">P</i><sub>2</sub>, . . . ,<i class="emphasis">P<sub>k</sub></i> for a given matching <i class="emphasis">M</i>. Conclude that the total running time of HOPCROFT-KARP is <span class="inlinemediaobject"><img src="images/fig719_03.jpg" height="13" width="43" alt="" border="0"></span>.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0164.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0166.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
