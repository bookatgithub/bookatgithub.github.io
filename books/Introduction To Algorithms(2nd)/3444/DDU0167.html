<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title></title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0166.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0168.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="part">
<a name="pt07"></a>
<h1 class="part-title">
<span class="chapter-titlelabel">Part VII: </span>Selected Topics</h1>
<div name="listofchapters">
<h2 class="lot-title">Chapter List</h2>
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0168.html#2137" target="_parent" class="chapterjump">Chapter 27:</a> Sorting Networks</dt>
<dt class="lotentry">
<a href="DDU0175.html#2217" target="_parent" class="chapterjump">Chapter 28:</a> Matrix Operations</dt>
<dt class="lotentry">
<a href="DDU0182.html#2359" target="_parent" class="chapterjump">Chapter 29:</a> Linear Programming</dt>
<dt class="lotentry">
<a href="DDU0193.html#2538" target="_parent" class="chapterjump">Chapter 30:</a> Polynomials and the FFT</dt>
<dt class="lotentry">
<a href="DDU0199.html#2624" target="_parent" class="chapterjump">Chapter 31:</a> Number-Theoretic Algorithms</dt>
<dt class="lotentry">
<a href="DDU0210.html#2821" target="_parent" class="chapterjump">Chapter 32:</a> String Matching</dt>
<dt class="lotentry">
<a href="DDU0217.html#2909" target="_parent" class="chapterjump">Chapter 33:</a> Computational Geometry</dt>
<dt class="lotentry">
<a href="DDU0223.html#3001" target="_parent" class="chapterjump">Chapter 34:</a> NP-Completeness</dt>
<dt class="lotentry">
<a href="DDU0234.html#3166" target="_parent" class="chapterjump">Chapter 35:</a> Approximation Algorithms</dt>
</dl>
</div>
</div>
<div class="partintro">
<h3 class="partintro-title">

</h3>
<a name="2133"></a><a name="IDX-700"></a><a name="2134"></a><a name="IDX-701"></a>
<div class="section">
<h2 class="sect2-title">Introduction</h2>
<p class="first-para">This part contains a selection of algorithmic topics that extend and complement earlier material in this book. Some chapters introduce new models of computation such as combinational circuits or parallel computers. Others cover specialized domains such as computational geometry or number theory. The last two chapters discuss some of the known limitations to the design of efficient algorithms and introduce techniques for coping with those limitations.</p>
<p class="para">
<a href="DDU0168.html#2137" target="_parent" class="chapterjump">Chapter 27</a> presents a parallel model of computation: comparison networks. Roughly speaking, a comparison network is an algorithm that allows many comparisons to be made simultaneously. This chapter shows how to build a comparison network that can sort <i class="emphasis">n</i> numbers in <i class="emphasis">O</i>(lg<sup>2</sup> <i class="emphasis">n</i>) time.</p>
<p class="para">
<a href="DDU0175.html#2217" target="_parent" class="chapterjump">Chapter 28</a> studies efficient algorithms for operating on matrices. After examining some basic matrix properties, it explores Strassen's algorithm, which can multiply two <i class="emphasis">n</i> &times; <i class="emphasis">n</i> matrices in <i class="emphasis">O</i>(<i class="emphasis">n</i><sup>2.81</sup>) time. It then presents two general methods<span class="unicode">-</span>LU decomposition and LUP decomposition<span class="unicode">-</span>for solving linear equations by Gaussian elimination in <i class="emphasis">O</i>(<i class="emphasis">n</i><sup>3</sup>) time. It also shows that matrix inversion and matrix multiplication can be performed equally fast. The chapter concludes by showing how a least-squares approximate solution can be computed when a set of linear equations has no exact solution.</p>
<p class="para">
<a href="DDU0182.html#2359" target="_parent" class="chapterjump">Chapter 29</a> studies linear programming, in which we wish to maximize or minimize an objective, given limited resources and competing constraints. Linear programming arises in a variety of practical application areas. This chapter covers the formulation and solution of linear programs. The solution method covered is the simplex algorithm, which is the oldest algorithm for linear programming. In contrast to many algorithms in this book, the simplex algorithm does not run in <a name="2135"></a><a name="IDX-702"></a>polynomial time in the worst case, but it is fairly efficient and widely used in practice.</p>
<p class="para">
<a href="DDU0193.html#2538" target="_parent" class="chapterjump">Chapter 30</a> studies operations on polynomials and shows that a well-known signal-processing technique<span class="unicode">-</span>the Fast Fourier Transform (FFT)<span class="unicode">-</span>can be used to multiply two degree-<i class="emphasis">n</i> polynomials in <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) time. It also investigates efficient implementations of the FFT, including a parallel circuit.</p>
<p class="para">
<a href="DDU0199.html#2624" target="_parent" class="chapterjump">Chapter 31</a> presents number-theoretic algorithms. After a review of elementary number theory, it presents Euclid's algorithm for computing greatest common divisors. Algorithms for solving modular linear equations and for raising one number to a power modulo another number are presented next. Then we see an important application of number-theoretic algorithms: the RSA public-key cryptosystem. This cryptosystem not only can be used to encrypt messages so that an adversary cannot read them, it also can be used to provide digital signatures. The chapter then presents the Miller-Rabin randomized primality test, which can be used to find large primes efficiently<span class="unicode">-</span>an essential requirement for the RSA system. Finally, the chapter covers Pollard's "rho" heuristic for factoring integers and discusses the state of the art of integer factorization.</p>
<p class="para">
<a href="DDU0210.html#2821" target="_parent" class="chapterjump">Chapter 32</a> studies the problem of finding all occurrences of a given pattern string in a given text string, a problem that arises frequently in text-editing programs. After examining the naive approach, the chapter presents an elegant approach due to Rabin and Karp. Then, after showing an efficient solution based on finite automata, the chapter presents the Knuth-Morris-Pratt algorithm, which achieves efficiency by cleverly preprocessing the pattern.</p>
<p class="para">Computational geometry is the topic of <a href="DDU0217.html#2909" target="_parent" class="chapterjump">Chapter 33</a>. After discussing basic primitives of computational geometry, the chapter shows how a "sweeping" method can efficiently determine whether a set of line segments contains any intersections. Two clever algorithms for finding the convex hull of a set of points<span class="unicode">-</span>Graham's scan and Jarvis's march<span class="unicode">-</span>also illustrate the power of sweeping methods. The chapter closes with an efficient algorithm for finding the closest pair from among a given set of points in the plane.</p>
<p class="para">
<a href="DDU0223.html#3001" target="_parent" class="chapterjump">Chapter 34</a> concerns NP-complete problems. Many interesting computational problems are NP-complete, but no polynomial-time algorithm is known for solving any of them. This chapter presents techniques for determining when a problem is NP-complete. Several classic problems are proved to be NP-complete: determining if a graph has a hamiltonian cycle, determining if a boolean formula is satisfiable, and determining if a given set of numbers has a subset that adds up to a given target value. The chapter also proves that the famous traveling-salesman problem is NP-complete.</p>
<p class="last-para">
<a href="DDU0234.html#3166" target="_parent" class="chapterjump">Chapter 35</a> shows how approximation algorithms can be used to find approximate solutions to NP-complete problems efficiently. For some NP-complete problems, approximate solutions that are near optimal are quite easy to produce, but <a name="2136"></a><a name="IDX-703"></a>for others even the best approximation algorithms known work progressively more poorly as the problem size increases. Then, there are some problems for which one can invest increasing amounts of computation time in return for increasingly better approximate solutions. This chapter illustrates these possibilities with the vertex-cover problem (unweighted and weighted versions), an optimization version of 3-CNF satisfiability, the traveling-salesman problem, the set-covering problem, and the subset-sum problem.</p>

</div>
</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0166.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0168.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
