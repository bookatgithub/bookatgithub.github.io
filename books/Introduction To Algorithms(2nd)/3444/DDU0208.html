<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>31.9 &#9733; Integer factorization</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0207.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0209.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch31"></a>
<div class="section">
<h2 class="first-section-title">
<a name="2799"></a><a name="ch31lev1sec9"></a><span class="section-titlelabel">31.9 </span><span class="unicode">&#9733;</span> Integer factorization</h2>
<p class="first-para">Suppose we have an integer <i class="emphasis">n</i> that we wish to <b class="bold"><i class="emphasis">factor</i></b>, that is, to decompose into a product of primes. The primality test of the preceding section would tell us that <i class="emphasis">n</i> is composite, but it usually doesn't tell us the prime factors of <i class="emphasis">n</i>. Factoring a large integer <i class="emphasis">n</i> seems to be much more difficult than simply determining whether <i class="emphasis">n</i> is prime or composite. It is infeasible with today's supercomputers and the best algorithms to date to factor an arbitrary 1024-bit number.<a name="2800"></a><a name="IDX-897"></a>
</p>
<div class="section">
<h4 class="sect4-title">
<a name="2801"></a><a name="ch31lev3sec22"></a>Pollard's rho heuristic</h4>
<p class="first-para">Trial division by all integers up to <i class="emphasis">B</i> is guaranteed to factor completely any number up to <i class="emphasis">B</i><sup>2</sup>. For the same amount of work, the following procedure will factor any number up to <i class="emphasis">B</i><sup>4</sup> (unless we're unlucky). Since the procedure is only a heuristic, neither its running time nor its success is guaranteed, although the procedure is very effective in practice. Another advantage of the POLLARD-RHO procedure is that it uses only a constant number of memory locations. (You can easily implement Pollard-Rho on a programmable pocket calculator to find factors of small numbers.)</p>
<div class="informalexample">
<pre class="literallayout-normal">
POLLARD-RHO(<i class="emphasis">n</i>)
 1  <i class="emphasis">i</i> <span class="unicode">&larr;</span> 1
 2  <i class="emphasis">x</i><sub>1</sub> <span class="unicode">&larr;</span> RANDOM(0, <i class="emphasis">n</i> - 1)
 3  <i class="emphasis">y</i> <span class="unicode">&larr;</span> <i class="emphasis">x</i><sub>1</sub>
 4  <i class="emphasis">k</i> <span class="unicode">&larr;</span> 2
 5  <b class="bold">while</b> TRUE
 6      <b class="bold">do</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> <i class="emphasis">i</i> + 1
 7         <span class="inlinemediaobject"><img src="images/fig919_01.jpg" height="19" width="98" alt="" border="0"></span> mod <i class="emphasis">n</i>
 8         <i class="emphasis">d</i> <span class="unicode">&larr;</span> gcd(<i class="emphasis">y</i> - <i class="emphasis">x<sub>i</sub></i>, <i class="emphasis">n</i>)
 9         <b class="bold">if</b> <i class="emphasis">d</i> <span class="unicode">&ne;</span> 1 and <i class="emphasis">d</i> <span class="unicode">&ne;</span> <i class="emphasis">n</i>
10            <b class="bold">then</b> print <i class="emphasis">d</i>
11         <b class="bold">if</b> <i class="emphasis">i</i> = <i class="emphasis">k</i>
12            <b class="bold">then</b> <i class="emphasis">y</i> <span class="unicode">&larr;</span> <i class="emphasis">x<sub>i</sub></i>
13                 <i class="emphasis">k</i> <span class="unicode">&larr;</span> 2<i class="emphasis">k</i>
</pre>
</div>
<p class="para">The procedure works as follows. Lines 1<span class="unicode">-</span>2 initialize <i class="emphasis">i</i> to 1 and <i class="emphasis">x</i><sub>1</sub> to a randomly chosen value in <b class="bold">Z</b><sub><i class="emphasis">n</i></sub>. The <b class="bold">while</b> loop beginning on line 5 iterates forever, searching for factors of <i class="emphasis">n</i>. During each iteration of the <b class="bold">while</b> loop, the recurrence</p>
<div class="equation">
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(31.41)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig919_02.jpg" height="20" width="141" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">is used on line 7 to produce the next value of <i class="emphasis">x<sub>i</sub></i> in the infinite sequence</p>
<div class="equation">
<a name="2802"></a><a name="ch31eq42"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(31.42)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig919_03.jpg" height="11" width="109" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">the value of <i class="emphasis">i</i> is correspondingly incremented on line 6. The code is written using subscripted variables <i class="emphasis">x<sub>i</sub></i> for clarity, but the program works the same if all of the subscripts are dropped, since only the most recent value of <i class="emphasis">x<sub>i</sub></i> need be maintained. With this modification, the procedure uses only a constant number of memory locations.</p>
<p class="para">Every so often, the program saves the most recently generated <i class="emphasis">x<sub>i</sub></i> value in the variable <i class="emphasis">y</i>. Specifically, the values that are saved are the ones whose subscripts are powers of 2:</p>
<p class="para">
<i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, <i class="emphasis">x</i><sub>4</sub>, <i class="emphasis">x</i><sub>8</sub>, <i class="emphasis">x</i><sub>16</sub>, .... .<a name="2803"></a><a name="IDX-898"></a>
</p>
<p class="para">Line 3 saves the value <i class="emphasis">x</i><sub>1</sub>, and line 12 saves <i class="emphasis">x<sub>k</sub></i> whenever <i class="emphasis">i</i> is equal to <i class="emphasis">k</i>. The variable <i class="emphasis">k</i> is initialized to 2 in line 4, and <i class="emphasis">k</i> is doubled in line 13 whenever <i class="emphasis">y</i> is updated. Therefore, <i class="emphasis">k</i> follows the sequence 1, 2, 4, 8, ... and always gives the subscript of the next value <i class="emphasis">x<sub>k</sub></i> to be saved in <i class="emphasis">y</i>.</p>
<p class="para">Lines 8<span class="unicode">-</span>10 try to find a factor of <i class="emphasis">n</i>, using the saved value of <i class="emphasis">y</i> and the current value of <i class="emphasis">x<sub>i</sub></i> . Specifically, line 8 computes the greatest common divisor <i class="emphasis">d</i> = gcd(<i class="emphasis">y</i> - <i class="emphasis">x<sub>i</sub></i>, <i class="emphasis">n</i>). If <i class="emphasis">d</i> is a nontrivial divisor of <i class="emphasis">n</i> (checked in line 9), then line 10 prints <i class="emphasis">d</i>.</p>
<p class="para">This procedure for finding a factor may seem somewhat mysterious at first. Note, however, that POLLARD-RHO never prints an incorrect answer; any number it prints is a nontrivial divisor of <i class="emphasis">n</i>. POLLARD-RHO may not print anything at all, though; there is no guarantee that it will produce any results. We shall see, however, that there is good reason to expect POLLARD-RHO to print a factor <i class="emphasis">p</i> of <i class="emphasis">n</i> after <span class="inlinemediaobject"><img src="images/fig920_01.jpg" height="13" width="33" alt="" border="0"></span> iterations of the <b class="bold">while</b> loop. Thus, if <b class="bold">n</b> is composite, we can expect this procedure to discover enough divisors to factor <i class="emphasis">n</i> completely after approximately <i class="emphasis">n</i><sup>1/4</sup> updates, since every prime factor <i class="emphasis">p</i> of <i class="emphasis">n</i> except possibly the largest one is less than <span class="inlinemediaobject"><img src="images/fig920_02.jpg" height="13" width="16" alt="" border="0"></span>.</p>
<p class="para">We begin our analysis of the behavior of this procedure by studying how long it takes a random sequence modulo <i class="emphasis">n</i> to repeat a value. Since <b class="bold">Z</b><sub><i class="emphasis">n</i></sub> is finite, and since each value in the sequence (<a class="internaljump" href="#ch31eq42">31.42</a>) depends only on the previous value, the sequence (<a class="internaljump" href="#ch31eq42">31.42</a>) eventually repeats itself. Once we reach an <i class="emphasis">x<sub>i</sub></i> such that <i class="emphasis">x<sub>i</sub></i> = <i class="emphasis">x<sub>j</sub></i> for some <i class="emphasis">j</i> <span class="unicode">&lt;</span> <i class="emphasis">i</i>, we are in a cycle, since <i class="emphasis">x</i><sub><i class="emphasis">i</i>+1</sub> = <i class="emphasis">x</i><sub><i class="emphasis">j</i>+1</sub>, <i class="emphasis">x</i><sub><i class="emphasis">i</i>+2</sub> = <i class="emphasis">x</i><sub><i class="emphasis">j</i>+2</sub>, and so on. The reason for the name "rho heuristic" is that, as <a class="internaljump" href="#ch31fig07">Figure 31.7</a> shows, the sequence <i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, ..., <i class="emphasis">x</i><sub><i class="emphasis">j</i>-1</sub> can be drawn as the "tail" of the rho, and the cycle <i class="emphasis">x<sub>j</sub></i>, <i class="emphasis">x</i><sub><i class="emphasis">j</i>+1</sub>, ..., <i class="emphasis">x<sub>i</sub></i> as the "body" of the rho.</p>
<div class="figure">
<a name="2804"></a><a name="ch31fig07"></a><span class="figuremediaobject"><a href="images/fig921%5F05%5F0%2Ejpg" NAME="IMG_1647" target="_parent"><img src="images/fig921_05.jpg" height="221" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 31.7: </span>Pollard's rho heuristic. <i class="emphasis">(a)</i> The values produced by the recurrence <span class="inlinemediaobject"><img src="images/fig921_01.jpg" height="8" width="36" alt="" border="0"></span> <span class="inlinemediaobject"><img src="images/fig921_02.jpg" height="13" width="32" alt="" border="0"></span> mod 1387, starting with <i class="emphasis">x</i><sub>1</sub> = 2. The prime factorization of 1387 is 19 <span class="unicode">&middot;</span> 73. The heavy arrows indicate the iteration steps that are executed before the factor 19 is discovered. The light arrows point to unreached values in the iteration, to illustrate the "rho" shape. The shaded values are the <i class="emphasis">y</i> values stored by POLLARD-RHO. The factor 19 is discovered upon reaching <i class="emphasis">x</i><sub>7</sub> = 177, when gcd(63 - 177, 1387) = 19 is computed. The first <i class="emphasis">x</i> value that would be repeated is 1186, but the factor 19 is discovered before this value is repeated. <i class="emphasis">(b)</i> The values produced by the same recurrence, modulo 19. Every value <i class="emphasis">x<sub>i</sub></i> given in part (a) is equivalent, modulo 19, to the value <span class="inlinemediaobject"><img src="images/fig921_03.jpg" height="12" width="8" alt="" border="0"></span> shown here. For example, both <i class="emphasis">x</i><sub>4</sub> = 63 and <i class="emphasis">x</i><sub>7</sub> = 177 are equivalent to 6, modulo 19. <i class="emphasis">(c)</i> The values produced by the same recurrence, modulo 73. Every value <i class="emphasis">x<sub>i</sub></i> given in part (a) is equivalent, modulo 73, to the value <span class="inlinemediaobject"><img src="images/fig921_04.jpg" height="12" width="10" alt="" border="0"></span> shown here. By the Chinese remainder theorem, each node in part (a) corresponds to a pair of nodes, one from part (b) and one from part (c).</span>
</div>
<p class="para">Let us consider the question of how long it takes for the sequence of <i class="emphasis">x<sub>i</sub></i> to repeat. This is not exactly what we need, but we shall then see how to modify the argument.</p>
<p class="para">For the purpose of this estimation, let us assume that the function</p>
<p class="para">
<i class="emphasis">f<sub>n</sub></i>(<i class="emphasis">x</i>) = (<i class="emphasis">x</i><sup>2</sup> - 1) mod <i class="emphasis">n</i>
</p>
<p class="para">behaves like a "random" function. Of course, it is not really random, but this assumption yields results consistent with the observed behavior of POLLARD-RHO. We can then consider each <i class="emphasis">x<sub>i</sub></i> to have been independently drawn from <b class="bold">Z</b><sub><i class="emphasis">n</i></sub> according to a uniform distribution on <b class="bold">Z</b><sub><i class="emphasis">n</i></sub>. By the birthday-paradox analysis of <a href="DDU0032.html#342" target="_parent" class="chapterjump">Section 5.4.1</a>, the expected number of steps taken before the sequence cycles is <span class="inlinemediaobject"><img src="images/fig920_03.jpg" height="12" width="32" alt="" border="0"></span>.</p>
<p class="para">Now for the required modification. Let <i class="emphasis">p</i> be a nontrivial factor of <i class="emphasis">n</i> such that gcd(<i class="emphasis">p</i>, <i class="emphasis">n</i>/<i class="emphasis">p</i>) = 1. For example, if <i class="emphasis">n</i> has the factorization <span class="inlinemediaobject"><img src="images/fig920_04.jpg" height="13" width="80" alt="" border="0"></span>, then we may take <i class="emphasis">p</i> to be <span class="inlinemediaobject"><img src="images/fig920_05.jpg" height="13" width="13" alt="" border="0"></span>. (If <i class="emphasis">e</i><sub>1</sub> = 1, then <i class="emphasis">p</i> is just the smallest prime factor of <i class="emphasis">n</i>, a good example to keep in mind.)</p>
<p class="para">The sequence <span class="unicode">&#12296;</span><i class="emphasis">x<sub>i</sub></i><span class="unicode">&#12297;</span> induces a corresponding sequence <span class="inlinemediaobject"><img src="images/fig920_06.jpg" height="13" width="15" alt="" border="0"></span> modulo <i class="emphasis">p</i>, where</p>
<p class="para">
<span class="inlinemediaobject"><img src="images/fig920_07.jpg" height="13" width="33" alt="" border="0"></span> mod <i class="emphasis">p</i>
</p>
<p class="para">for all <i class="emphasis">i</i>.<a name="2805"></a><a name="IDX-899"></a>
</p>
<p class="para">Furthermore, because <i class="emphasis">f<sub>n</sub></i> is defined using only arithmetic operations (squaring and subtraction) modulo <i class="emphasis">n</i>, we shall see that one can compute <span class="inlinemediaobject"><img src="images/fig921_06.jpg" height="14" width="18" alt="" border="0"></span> from <span class="inlinemediaobject"><img src="images/fig921_07.jpg" height="13" width="10" alt="" border="0"></span> the "modulo <i class="emphasis">p</i>" view of the sequence is a smaller version of what is happening modulo <i class="emphasis">n</i>:<a name="2806"></a><a name="IDX-900"></a>
</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<span class="inlinemediaobject"><img src="images/fig922_01.jpg" height="22" width="27" alt="" border="0"></span>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">x</i><sub><i class="emphasis">i</i>+1</sub> mod <i class="emphasis">p</i>
</p>
</td><td class="td" align="left">&nbsp;</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">f<sub>n</sub></i>(<i class="emphasis">x<sub>i</sub></i>) mod <i class="emphasis">p</i>
</p>
</td><td class="td" align="left">&nbsp;</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">(<span class="inlinemediaobject"><img src="images/fig922_02.jpg" height="20" width="50" alt="" border="0"></span> mod <i class="emphasis">n</i>) mod <i class="emphasis">p</i>
</p>
</td><td class="td" align="left">&nbsp;</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="inlinemediaobject"><img src="images/fig922_03.jpg" height="23" width="51" alt="" border="0"></span> mod <i class="emphasis">p</i>
</p>
</td><td class="td" align="left">
<p class="table-para">(by <a href="DDU0200.html#2657" target="_parent" class="chapterjump">Exercise 31.1-6</a>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">((<i class="emphasis">x<sub>i</sub></i> mod <i class="emphasis">p</i>)<sup>2</sup> - 1) mod <i class="emphasis">p</i>
</p>
</td><td class="td" align="left">&nbsp;</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="inlinemediaobject"><img src="images/fig922_04.jpg" height="24" width="67" alt="" border="0"></span> mod <i class="emphasis">p</i>
</p>
</td><td class="td" align="left">&nbsp;</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="inlinemediaobject"><img src="images/fig922_05.jpg" height="21" width="41" alt="" border="0"></span>.</p>
</td><td class="td" align="left">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
<p class="para">Thus, although we are not explicitly computing the sequence <span class="inlinemediaobject"><img src="images/fig922_06.jpg" height="14" width="15" alt="" border="0"></span>, this sequence is well defined and obeys the same recurrence as the sequence <span class="unicode">&#12296;</span><i class="emphasis">x</i><sub><i class="emphasis">i</i></sub><span class="unicode">&#12297;</span>.</p>
<p class="para">Reasoning as before, we find that the expected number of steps before the sequence <span class="inlinemediaobject"><img src="images/fig922_07.jpg" height="14" width="15" alt="" border="0"></span> repeats is <span class="inlinemediaobject"><img src="images/fig922_08.jpg" height="14" width="34" alt="" border="0"></span>. If <i class="emphasis">p</i> is small compared to <i class="emphasis">n</i>, the sequence <span class="inlinemediaobject"><img src="images/fig922_09.jpg" height="14" width="15" alt="" border="0"></span> may repeat much more quickly than the sequence <span class="unicode">&#12296;</span><i class="emphasis">x<sub>i</sub></i><span class="unicode">&#12297;</span>. Indeed, the <span class="inlinemediaobject"><img src="images/fig922_10.jpg" height="14" width="15" alt="" border="0"></span> sequence repeats as soon as two elements of the sequence <span class="unicode">&#12296;</span><i class="emphasis">x</i><sub><i class="emphasis">i</i></sub><span class="unicode">&#12297;</span> are merely equivalent modulo <i class="emphasis">p</i>, rather than equivalent modulo <i class="emphasis">n</i>. See <a class="internaljump" href="#ch31fig07">Figure 31.7</a>, parts (b) and (c), for an illustration.</p>
<p class="para">Let <i class="emphasis">t</i> denote the index of the first repeated value in the <span class="inlinemediaobject"><img src="images/fig922_11.jpg" height="14" width="15" alt="" border="0"></span> sequence, and let <i class="emphasis">u</i> <span class="unicode">&gt;</span> 0 denote the length of the cycle that has been thereby produced. That is, <i class="emphasis">t</i> and <i class="emphasis">u</i> <span class="unicode">&gt;</span> 0 are the smallest values such that <span class="inlinemediaobject"><img src="images/fig922_12.jpg" height="14" width="63" alt="" border="0"></span> for all <i class="emphasis">i</i> <span class="unicode">&ge;</span> 0. By the above arguments, the expected values of <i class="emphasis">t</i> and <i class="emphasis">u</i> are both <span class="inlinemediaobject"><img src="images/fig922_13.jpg" height="14" width="34" alt="" border="0"></span>. Note that if <span class="inlinemediaobject"><img src="images/fig922_14.jpg" height="14" width="61" alt="" border="0"></span>, then <i class="emphasis">p</i> |(<i class="emphasis">x</i><sub><i class="emphasis">t</i>+<i class="emphasis">u</i>+<i class="emphasis">i</i></sub> - <i class="emphasis">x</i><sub><i class="emphasis">t</i>+<i class="emphasis">i</i></sub>). Thus, gcd(<i class="emphasis">x</i><sub><i class="emphasis">t</i>+<i class="emphasis">u</i>+<i class="emphasis">i</i></sub> - <i class="emphasis">x</i><sub><i class="emphasis">t</i>+<i class="emphasis">i</i></sub>, <i class="emphasis">n</i>) <span class="unicode">&gt;</span> 1.</p>
<p class="para">Therefore, once POLLARD-RHO has saved as <i class="emphasis">y</i> any value <i class="emphasis">x<sub>k</sub></i> such that <i class="emphasis">k</i> <span class="unicode">&ge;</span> <i class="emphasis">t</i>, then <i class="emphasis">y</i> mod <i class="emphasis">p</i> is always on the cycle modulo <i class="emphasis">p</i>. (If a new value is saved as <i class="emphasis">y</i>, that value is also on the cycle modulo <i class="emphasis">p</i>.) Eventually, <i class="emphasis">k</i> is set to a value that is greater than <i class="emphasis">u</i>, and the procedure then makes an entire loop around the cycle modulo <i class="emphasis">p</i> without changing the value of <i class="emphasis">y</i>. A factor of <i class="emphasis">n</i> is then discovered when <i class="emphasis">x<sub>i</sub></i> "runs into" the previously stored value of <i class="emphasis">y</i>, modulo <i class="emphasis">p</i>, that is, when <i class="emphasis">x<sub>i</sub></i> <span class="unicode">&#8802;</span> <i class="emphasis">y</i> (mod <i class="emphasis">p</i>).</p>
<p class="para">Presumably, the factor found is the factor <i class="emphasis">p</i>, although it may occasionally happen that a multiple of <i class="emphasis">p</i> is discovered. Since the expected values of both <i class="emphasis">t</i> and <i class="emphasis">u</i> are <span class="inlinemediaobject"><img src="images/fig922_15.jpg" height="14" width="34" alt="" border="0"></span>, the expected number of steps required to produce the factor <i class="emphasis">p</i> is <span class="inlinemediaobject"><img src="images/fig922_16.jpg" height="14" width="34" alt="" border="0"></span>.</p>
<p class="para">There are two reasons why this algorithm may not perform quite as expected. First, the heuristic analysis of the running time is not rigorous, and it is possible that the cycle of values, modulo <i class="emphasis">p</i>, could be much larger than <span class="inlinemediaobject"><img src="images/fig922_17.jpg" height="13" width="17" alt="" border="0"></span>. In this case, the algorithm performs correctly but much more slowly than desired. In practice, this issue seems to be moot. Second, the divisors of <i class="emphasis">n</i> produced by this algorithm might always be one of the trivial factors 1 or <i class="emphasis">n</i>. For example, suppose that <i class="emphasis">n</i> = <i class="emphasis">pq</i>, where <i class="emphasis">p</i> and <i class="emphasis">q</i> are prime. It can happen that the values of <i class="emphasis">t</i> and <i class="emphasis">u</i> for <i class="emphasis">p</i> are identical with the values of <i class="emphasis">t</i> and <i class="emphasis">u</i> for <i class="emphasis">q</i>, and thus the factor <i class="emphasis">p</i> is always revealed in the same gcd operation that reveals the factor <i class="emphasis">q</i>. Since both factors are revealed at the same time, the trivial factor <i class="emphasis">pq</i> = <i class="emphasis">n</i> is revealed, which is useless. Again, this problem seems to be insignificant in practice. If necessary, the heuristic can be restarted <a name="2807"></a><a name="IDX-901"></a>with a different recurrence of the form <span class="inlinemediaobject"><img src="images/fig923_01.jpg" height="14" width="75" alt="" border="0"></span> mod <i class="emphasis">n</i>. (The values <i class="emphasis">c</i> = 0 and <i class="emphasis">c</i> = 2 should be avoided for reasons we won't go into here, but other values are fine.)</p>
<p class="para">Of course, this analysis is heuristic and not rigorous, since the recurrence is not really "random." Nonetheless, the procedure performs well in practice, and it seems to be as efficient as this heuristic analysis indicates. It is the method of choice for finding small prime factors of a large number. To factor a <i class="emphasis"><span class="unicode">&beta;</span></i>-bit composite number <i class="emphasis">n</i> completely, we only need to find all prime factors less than <span class="unicode">&lfloor;</span><i class="emphasis">n</i><sup>1/2</sup><span class="unicode">&rfloor;</span>, and so we expect POLLARD-RHO to require at most <i class="emphasis">n</i><sup>1/4</sup> = 2<sup><i class="emphasis"><span class="unicode">&beta;</span></i>/4</sup> arithmetic operations and at most <i class="emphasis">n</i><sup>1/4</sup><i class="emphasis"><span class="unicode">&beta;</span></i><sup>2</sup> = 2<sup><i class="emphasis"><span class="unicode">&beta;</span></i>/4</sup><i class="emphasis"><span class="unicode">&beta;</span></i><sup>2</sup> bit operations. POLLARD-RHO's ability to find a small factor <i class="emphasis">p</i> of <i class="emphasis">n</i> with an expected number <span class="inlinemediaobject"><img src="images/fig923_02.jpg" height="13" width="34" alt="" border="0"></span> of arithmetic operations is often its most appealing feature.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 31.9-1</span></span><a name="2808"></a><a name="ch31ex83"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Referring to the execution history shown in <a class="internaljump" href="#ch31fig07">Figure 31.7(a)</a>, when does POLLARD-RHO print the factor 73 of 1387?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 31.9-2</span></span><a name="2809"></a><a name="ch31ex84"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that we are given a function <i class="emphasis">f</i> : <b class="bold">Z</b><sub><i class="emphasis">n</i></sub> <span class="unicode">&isin;</span> <b class="bold">Z</b><sub><i class="emphasis">n</i></sub> and an initial value <i class="emphasis">x</i><sub>0</sub> <span class="unicode">&isin;</span> <b class="bold">Z</b><sub><i class="emphasis">n</i></sub>. Define <i class="emphasis">x<sub>i</sub></i> = <i class="emphasis">f</i> (<i class="emphasis">x</i><sub><i class="emphasis">i</i>-1</sub>) for <i class="emphasis">i</i> = 1, 2, .... Let <i class="emphasis">t</i> and <i class="emphasis">u</i> <span class="unicode">&gt;</span> 0 be the smallest values such that <i class="emphasis">x</i><sub><i class="emphasis">t</i>+<i class="emphasis">i</i></sub> = <i class="emphasis">x</i><sub><i class="emphasis">t</i>+<i class="emphasis">u</i>+<i class="emphasis">i</i></sub> for <i class="emphasis">i</i> = 0, 1, .... In the terminology of Pollard's rho algorithm, <i class="emphasis">t</i> is the length of the tail and <i class="emphasis">u</i> is the length of the cycle of the rho. Give an efficient algorithm to determine <i class="emphasis">t</i> and <i class="emphasis">u</i> exactly, and analyze its running time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 31.9-3</span></span><a name="2810"></a><a name="ch31ex85"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">How many steps would you expect POLLARD-RHO to require to discover a factor of the form <i class="emphasis">p<sup>e</sup></i>, where <i class="emphasis">p</i> is prime and <i class="emphasis">e</i> <span class="unicode">&gt;</span> 1?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 31.9-4: </span><span class="unicode">&#9733;</span></span><a name="2811"></a><a name="ch31ex86"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">One disadvantage of POLLARD-RHO as written is that it requires one gcd computation for each step of the recurrence. It has been suggested that we might batch the gcd computations by accumulating the product of several <i class="emphasis">x<sub>i</sub></i> values in a row and then using this product instead of <i class="emphasis">x<sub>i</sub></i> in the gcd computation. Describe carefully how you would implement this idea, why it works, and what batch size you would pick as the most effective when working on a <i class="emphasis"><span class="unicode">&beta;</span></i>-bit number <i class="emphasis">n</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="2812"></a><a name="IDX-902"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 31-1: </span>Binary gcd algorithm</span><a name="2813"></a><a name="ch31ex87"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">On most computers, the operations of subtraction, testing the parity (odd or even) of a binary integer, and halving can be performed more quickly than computing remainders. This problem investigates the <b class="bold"><i class="emphasis">binary gcd algorithm</i></b>, which avoids the remainder computations used in Euclid's algorithm.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Prove that if <i class="emphasis">a</i> and <i class="emphasis">b</i> are both even, then gcd(<i class="emphasis">a</i>, <i class="emphasis">b</i>) = 2 gcd<i class="emphasis">a</i>/2, <i class="emphasis">b</i>/2).</p>
</li>
<li class="listitem">
<p class="first-para">Prove that if <i class="emphasis">a</i> is odd and <i class="emphasis">b</i> is even, then gcd(<i class="emphasis">a</i>, <i class="emphasis">b</i>) = gcd(<i class="emphasis">a</i>, <i class="emphasis">b</i>/2).</p>
</li>
<li class="listitem">
<p class="first-para">Prove that if <i class="emphasis">a</i> and <i class="emphasis">b</i> are both odd, then gcd(<i class="emphasis">a</i>, <i class="emphasis">b</i>) = gcd((<i class="emphasis">a</i> - <i class="emphasis">b</i>)/2, <i class="emphasis">b</i>).</p>
</li>
<li class="listitem">
<p class="first-para">Design an efficient binary gcd algorithm for input integers <i class="emphasis">a</i> and <i class="emphasis">b</i>, where <i class="emphasis">a</i> <span class="unicode">&ge;</span> <i class="emphasis">b</i>, that runs in <i class="emphasis">O</i>(lg <i class="emphasis">a</i>) time. Assume that each subtraction, parity test, and halving can be performed in unit time.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 31-2: </span>Analysis of bit operations in Euclid's algorithm</span><a name="2814"></a><a name="ch31ex88"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Consider the ordinary "paper and pencil" algorithm for long division: dividing <i class="emphasis">a</i> by <i class="emphasis">b</i>, which yields a quotient <i class="emphasis">q</i> and remainder <i class="emphasis">r</i>. Show that this method requires <i class="emphasis">O</i>((1 + lg <i class="emphasis">q</i>) lg <i class="emphasis">b</i>) bit operations.</p>
</li>
<li class="listitem">
<p class="first-para">Define <i class="emphasis"><span class="unicode">&mu;</span></i>(<i class="emphasis">a</i>, <i class="emphasis">b</i>) = (1 + lg <i class="emphasis">a</i>)(1 + lg <i class="emphasis">b</i>). Show that the number of bit operations performed by EUCLID in reducing the problem of computing gcd(<i class="emphasis">a</i>, <i class="emphasis">b</i>) to that of computing gcd(<i class="emphasis">b</i>, <i class="emphasis">a</i> mod <i class="emphasis">b</i>) is at most <i class="emphasis">c</i>(<i class="emphasis"><span class="unicode">&mu;</span></i>(<i class="emphasis">a</i>, <i class="emphasis">b</i>) - <i class="emphasis"><span class="unicode">&mu;</span></i>(<i class="emphasis">b</i>, <i class="emphasis">a</i> mod <i class="emphasis">b</i>)) for some sufficiently large constant <i class="emphasis">c</i> <span class="unicode">&gt;</span> 0.</p>
</li>
<li class="listitem">
<p class="first-para">Show that EUCLID(<i class="emphasis">a</i>, <i class="emphasis">b</i>) requires <i class="emphasis">O</i>(<i class="emphasis"><span class="unicode">&mu;</span></i>(<i class="emphasis">a</i>, <i class="emphasis">b</i>)) bit operations in general and <i class="emphasis">O</i>(<i class="emphasis"><span class="unicode">&beta;</span></i><sup>2</sup>) bit operations when applied to two <i class="emphasis"><span class="unicode">&beta;</span></i>-bit inputs.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 31-3: </span>Three algorithms for Fibonacci numbers</span><a name="2815"></a><a name="ch31ex89"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">This problem compares the efficiency of three methods for computing the <i class="emphasis">n</i>th Fibonacci number <i class="emphasis">F<sub>n</sub></i>, given <i class="emphasis">n</i>. Assume that the cost of adding, subtracting, or multiplying two numbers is <i class="emphasis">O</i>(1), independent of the size of the numbers.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Show that the running time of the straightforward recursive method for computing <i class="emphasis">F<sub>n</sub></i> based on recurrence (<a href="DDU0020.html#198" target="_parent" class="chapterjump">3.21</a>) is exponential in <i class="emphasis">n</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Show how to compute <i class="emphasis">F<sub>n</sub></i> in <i class="emphasis">O</i>(<i class="emphasis">n</i>) time using memoization.</p>
<a name="2816"></a><a name="IDX-903"></a>
</li>
<li class="listitem">
<p class="first-para">Show how to compute <i class="emphasis">F<sub>n</sub></i> in <i class="emphasis">O</i>(lg <i class="emphasis">n</i>) time using only integer addition and multiplication. (<i class="emphasis">Hint:</i> Consider the matrix</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig925_01.jpg" height="39" width="54" alt="" border="0"></span>
</div>
<p class="last-para">and its powers.)</p>
</li>
<li class="listitem">
<p class="first-para">Assume now that adding two <i class="emphasis"><span class="unicode">&beta;</span></i>-bit numbers takes <span class="unicode">&Theta;</span>(<i class="emphasis"><span class="unicode">&beta;</span></i>) time and that multiplying two <i class="emphasis"><span class="unicode">&beta;</span></i>-bit numbers takes <span class="unicode">&Theta;</span>(<i class="emphasis"><span class="unicode">&beta;</span></i><sup>2</sup>) time. What is the running time of these three methods under this more reasonable cost measure for the elementary arithmetic operations?</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 31-4: </span>Quadratic residues</span><a name="2817"></a><a name="ch31ex90"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">p</i> be an odd prime. A number <span class="inlinemediaobject"><img src="images/fig925_02.jpg" height="14" width="36" alt="" border="0"></span> is a <b class="bold"><i class="emphasis">quadratic residue</i></b> if the equation <i class="emphasis">x</i><sup>2</sup> = <i class="emphasis">a</i> (mod <i class="emphasis">p</i>) has a solution for the unknown <i class="emphasis">x</i>.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Show that there are exactly (<i class="emphasis">p</i> - 1)/2 quadratic residues, modulo <i class="emphasis">p</i>.</p>
</li>
<li class="listitem">
<p class="first-para">If <i class="emphasis">p</i> is prime, we define the <b class="bold"><i class="emphasis">Legendre symbol</i></b> <span class="inlinemediaobject"><img src="images/fig925_03.jpg" height="14" width="15" alt="" border="0"></span>, for <span class="inlinemediaobject"><img src="images/fig925_04.jpg" height="14" width="33" alt="" border="0"></span>, to be 1 if <i class="emphasis">a</i> is a quadratic residue modulo <i class="emphasis">p</i> and -1 otherwise. Prove that if <span class="inlinemediaobject"><img src="images/fig925_05.jpg" height="14" width="36" alt="" border="0"></span>, then</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig925_06.jpg" height="38" width="165" alt="" border="0"></span>
</div>
<p class="last-para">Give an efficient algorithm for determining whether or not a given number <i class="emphasis">a</i> is a quadratic residue modulo <i class="emphasis">p</i>. Analyze the efficiency of your algorithm.</p>
</li>
<li class="listitem">
<p class="first-para">Prove that if <i class="emphasis">p</i> is a prime of the form 4<i class="emphasis">k</i> + 3 and <i class="emphasis">a</i> is a quadratic residue in <span class="inlinemediaobject"><img src="images/fig925_07.jpg" height="15" width="14" alt="" border="0"></span>, then <i class="emphasis">a</i><sup><i class="emphasis">k</i>+1</sup> mod <i class="emphasis">p</i> is a square root of <i class="emphasis">a</i>, modulo <i class="emphasis">p</i>. How much time is required to find the square root of a quadratic residue <i class="emphasis">a</i> modulo <i class="emphasis">p</i>?</p>
</li>
<li class="listitem">
<p class="first-para">Describe an efficient randomized algorithm for finding a nonquadratic residue, modulo an arbitrary prime <i class="emphasis">p</i>, that is, a member of <span class="inlinemediaobject"><img src="images/fig925_08.jpg" height="15" width="14" alt="" border="0"></span> that is not a quadratic residue. How many arithmetic operations does your algorithm require on average?</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0207.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0209.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
