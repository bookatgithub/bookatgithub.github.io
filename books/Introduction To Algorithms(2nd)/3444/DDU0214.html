<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>32.3 String matching with finite automata</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0213.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0215.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch32"></a>
<div class="section">
<h2 class="first-section-title">
<a name="2853"></a><a name="ch32lev1sec3"></a><span class="section-titlelabel">32.3 </span>String matching with finite automata</h2>
<p class="first-para">Many string-matching algorithms build a finite automaton that scans the text string <i class="emphasis">T</i> for all occurrences of the pattern <i class="emphasis">P</i>. This section presents a method for building such an automaton. These string-matching automata are very efficient: they examine each text character <i class="emphasis">exactly once</i>, taking constant time per text character. The matching time used<span class="unicode">-</span>after preprocessing the pattern to build the automaton<span class="unicode">-</span>is therefore <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>). The time to build the automaton, however, can be large if <span class="unicode">&Sigma;</span> is large. <a href="DDU0215.html#2878" target="_parent" class="chapterjump">Section 32.4</a> describes a clever way around this problem.</p>
<p class="para">We begin this section with the definition of a finite automaton. We then examine a special string-matching automaton and show how it can be used to find occurrences of a pattern in a text. This discussion includes details on how to simulate the behavior of a string-matching automaton on a given text. Finally, we shall show how to construct the string-matching automaton for a given input pattern.</p>
<div class="section">
<h4 class="sect4-title">
<a name="2854"></a><a name="ch32lev3sec2"></a>Finite automata</h4>
<p class="first-para">A <b class="bold"><i class="emphasis">finite automaton</i></b> <i class="emphasis">M</i> is a 5-tuple (<i class="emphasis">Q</i>, <i class="emphasis">q</i><sub>0</sub>, <i class="emphasis">A</i>, <span class="unicode">&Sigma;</span>, <i class="emphasis"><span class="unicode">&delta;</span></i>), where</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">
<i class="emphasis">Q</i> is a finite set of <b class="bold"><i class="emphasis">states</i></b>,</p>
</li>
<li class="listitem">
<p class="first-para">
<i class="emphasis">q</i><sub>0</sub> <span class="unicode">&isin;</span> <i class="emphasis">Q</i> is the <b class="bold"><i class="emphasis">start state</i></b>,</p>
</li>
<li class="listitem">
<p class="first-para">
<i class="emphasis">A</i> <span class="unicode">&sube;</span> <i class="emphasis">Q</i> is a distinguished set of <b class="bold"><i class="emphasis">accepting states</i></b>,</p>
</li>
<li class="listitem">
<p class="first-para">
<span class="unicode">&Sigma;</span> is a finite <b class="bold"><i class="emphasis">input alphabet</i></b>,</p>
</li>
<li class="listitem">
<p class="first-para">
<i class="emphasis"><span class="unicode">&delta;</span></i> is a function from <i class="emphasis">Q</i> <span class="unicode">&times;</span> <span class="unicode">&Sigma;</span> into <i class="emphasis">Q</i>, called the <b class="bold"><i class="emphasis">transition function</i></b> of <i class="emphasis">M</i>.</p>
</li>
</ul>
<p class="para">The finite automaton begins in state <i class="emphasis">q</i><sub>0</sub> and reads the characters of its input string one at a time. If the automaton is in state <i class="emphasis">q</i> and reads input character <i class="emphasis">a</i>, it moves ("makes a transition") from state <i class="emphasis">q</i> to state <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">q</i>, <i class="emphasis">a</i>). Whenever its current state <i class="emphasis">q</i> is a member of <i class="emphasis">A</i>, the machine <i class="emphasis">M</i> is said to have <b class="bold"><i class="emphasis">accepted</i></b> the string read so far. <a name="2855"></a><a name="IDX-917"></a>An input that is not accepted is said to be <b class="bold"><i class="emphasis">rejected</i></b>. <a class="internaljump" href="#ch32fig06">Figure 32.6</a> illustrates these definitions with a simple two-state automaton.</p>
<div class="figure">
<a name="2856"></a><a name="ch32fig06"></a><span class="figuremediaobject"><img src="images/fig939_01.jpg" height="144" width="350" alt="" border="0"></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 32.6: </span>A simple two-state finite automaton with state set <i class="emphasis">Q</i> = {0, 1}, start state <i class="emphasis">q</i><sub>0</sub> = 0, and input alphabet <span class="unicode">&Sigma;</span> = {<span class="fixed">a</span>, <span class="fixed">b</span>}. <i class="emphasis">(a)</i> A tabular representation of the transition function <i class="emphasis"><span class="unicode">&delta;</span></i>. <i class="emphasis">(b)</i> An equivalent state-transition diagram. State 1 is the only accepting state (shown blackened). Directed edges represent transitions. For example, the edge from state 1 to state 0 labeled <span class="fixed">b</span> indicates <i class="emphasis"><span class="unicode">&delta;</span></i>(1, <span class="fixed">b</span>) = 0. This automaton accepts those strings that end in an odd number of <span class="fixed">a</span>'s. More precisely, a string <i class="emphasis">x</i> is accepted if and only if <i class="emphasis">x</i> = <i class="emphasis">yz</i>, where <i class="emphasis">y</i> = <i class="emphasis"><span class="unicode">&epsilon;</span></i> or <i class="emphasis">y</i> ends with a <span class="fixed">b</span>, and <i class="emphasis">z</i> = <span class="fixed">a</span><sup><i class="emphasis">k</i></sup>, where <i class="emphasis">k</i> is odd. For example, the sequence of states this automaton enters for input <span class="fixed">abaaa</span> (including the start state) is <span class="unicode">&#12296;</span>0, 1, 0, 1, 0, 1<span class="unicode">&#12297;</span>, and so it accepts this input. For input <span class="fixed">abbaa</span>, the sequence of states is <span class="unicode">&#12296;</span>0, 1, 0, 0, 1, 0<span class="unicode">&#12297;</span>, and so it rejects this input.</span>
</div>
<p class="para">A finite automaton <i class="emphasis">M</i> induces a function <i class="emphasis"><span class="unicode">&phi;</span></i>, called the <b class="bold"><i class="emphasis">final-state function</i></b>, from <span class="unicode">&Sigma;</span>* to <i class="emphasis">Q</i> such that <i class="emphasis"><span class="unicode">&phi;</span></i>(<i class="emphasis">w</i>) is the state <i class="emphasis">M</i> ends up in after scanning the string <i class="emphasis">w</i>. Thus, <i class="emphasis">M</i> accepts a string <i class="emphasis">w</i> if and only if <i class="emphasis"><span class="unicode">&phi;</span></i>(<i class="emphasis">w</i>) <span class="unicode">&isin;</span> <i class="emphasis">A</i>. The function <i class="emphasis"><span class="unicode">&phi;</span></i> is defined by the recursive relation</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="right">
<p class="table-para">
<i class="emphasis"><span class="unicode">&phi;</span></i>(<i class="emphasis"><span class="unicode">&epsilon;</span></i>)</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">q</i><sub>0</sub>,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="right">
<p class="table-para">
<i class="emphasis"><span class="unicode">&phi;</span></i>(<i class="emphasis">wa</i>)</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis"><span class="unicode">&phi;</span></i>(<i class="emphasis">w</i>), <i class="emphasis">a</i>) for <i class="emphasis">w</i> <span class="unicode">&isin;</span> <span class="unicode">&Sigma;</span>*, <i class="emphasis">a</i> <span class="unicode">&isin;</span> <span class="unicode">&Sigma;</span>.</p>
</td>
</tr>
</tbody>
</table>
</div>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="2857"></a><a name="ch32lev3sec3"></a>String-matching automata</h4>
<p class="first-para">There is a string-matching automaton for every pattern <i class="emphasis">P</i>; this automaton must be constructed from the pattern in a preprocessing step before it can be used to search the text string. <a class="internaljump" href="#ch32fig07">Figure 32.7</a> illustrates this construction for the pattern <i class="emphasis">P</i> = <span class="fixed">ababaca</span>. From now on, we shall assume that <i class="emphasis">P</i> is a given fixed patternstring; for brevity, we shall not indicate the dependence upon <i class="emphasis">P</i> in our notation.</p>
<div class="figure">
<a name="2858"></a><a name="ch32fig07"></a><span class="figuremediaobject"><a href="images/fig940%5F01%5F0%2Ejpg" NAME="IMG_1695" target="_parent"><img src="images/fig940_01.jpg" height="272" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 32.7: </span><i class="emphasis">(a)</i> A state-transition diagram for the string-matching automaton that accepts all strings ending in the string <span class="fixed">ababaca</span>. State 0 is the start state, and state 7 (shown blackened) is the only accepting state. A directed edge from state <i class="emphasis">i</i> to state <i class="emphasis">j</i> labeled <i class="emphasis">a</i> represents <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">i, a</i>) = <i class="emphasis">j</i>. The right-going edges forming the "spine" of the automaton, shown heavy in the figure, correspond to successful matches between pattern and input characters. The left-going edges correspond to failing matches. Some edges corresponding to failing matches are not shown; by convention, if a state <i class="emphasis">i</i> has no outgoing edge labeled <i class="emphasis">a</i> for some <i class="emphasis">a</i> <span class="unicode">&isin;</span> <span class="unicode">&Sigma;</span>, then <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">i, a</i>) = 0. <i class="emphasis">(b)</i> The corresponding transition function <i class="emphasis"><span class="unicode">&delta;</span></i>, and the pattern string <i class="emphasis">P</i> = <span class="fixed">ababaca</span>. The entries corresponding to successful matches between pattern and input characters are shown shaded. <i class="emphasis">(c)</i> The operation of the automaton on the text <i class="emphasis">T</i> = <span class="fixed">abababacaba</span>. Under each text character <i class="emphasis">T</i> [<i class="emphasis">i</i>] is given the state <i class="emphasis"><span class="unicode">&phi;</span></i>(<i class="emphasis">T<sub>i</sub></i>) the automaton is in after processing the prefix <i class="emphasis">T<sub>i</sub></i>. One occurrence of the pattern is found, ending in position 9.</span>
</div>
<p class="para">In order to specify the string-matching automaton corresponding to a given pattern <i class="emphasis">P</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">m</i>], we first define an auxiliary function <i class="emphasis"><span class="unicode">&sigma;</span></i> , called the <b class="bold"><i class="emphasis">suffix function</i></b> corresponding to <i class="emphasis">P</i>. The function <i class="emphasis"><span class="unicode">&sigma;</span></i> is a mapping from <span class="unicode">&Sigma;</span>* to {0, 1, . . . , <i class="emphasis">m</i>} such that <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">x</i>) is the length of the longest prefix of <i class="emphasis">P</i> that is a suffix of <i class="emphasis">x</i>:</p>
<p class="para">
<i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">x</i>) = max {<i class="emphasis">k</i> : <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">x</i>}.</p>
<p class="para">The suffix function <i class="emphasis"><span class="unicode">&sigma;</span></i> is well defined since the empty string <i class="emphasis">P</i><sub>0</sub> = <i class="emphasis"><span class="unicode">&epsilon;</span></i> is a suffix of every string. As examples, for the pattern <i class="emphasis">P</i> = <span class="fixed">ab</span>, we have <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis"><span class="unicode">&epsilon;</span></i>) = 0, <i class="emphasis"><span class="unicode">&sigma;</span></i>(<span class="fixed">ccaca</span>) = 1, and <i class="emphasis"><span class="unicode">&sigma;</span></i>(<span class="fixed">ccab</span>) = 2. For a pattern <i class="emphasis">P</i> of length <i class="emphasis">m</i>, we have <a name="2859"></a><a name="IDX-918"></a><i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">x</i>) = <i class="emphasis">m</i> if and only if <i class="emphasis">P</i> <span class="unicode">&#8848;</span> <i class="emphasis">x</i>. It follows from the definition of the suffix function that if <i class="emphasis">x</i> <span class="unicode">&#8848;</span> <i class="emphasis">y</i>, then <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">x</i>) <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">y</i>).</p>
<p class="para">We define the string-matching automaton that corresponds to a given pattern <i class="emphasis">P</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">m</i>] as follows.</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">The state set <i class="emphasis">Q</i> is {0, 1, . . . , <i class="emphasis">m</i>}. The start state <i class="emphasis">q</i><sub>0</sub> is state 0, and state <i class="emphasis">m</i> is the only accepting state.</p>
</li>
<li class="listitem">
<p class="first-para">The transition function <i class="emphasis"><span class="unicode">&delta;</span></i> is defined by the following equation, for any state <i class="emphasis">q</i> and character <i class="emphasis">a</i>:</p>
<div class="equation">
<a name="2860"></a><a name="ch32eq03"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(32.3)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig940_02.jpg" height="17" width="113" alt="" border="0"></span></td>
</tr>
</table>
</div>
</li>
</ul>
<a name="2861"></a><a name="IDX-919"></a>
<p class="para">Here is an intuitive rationale for defining <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">q</i>, <i class="emphasis">a</i>) = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">P<sub>q</sub>a</i>). The machine maintains as an invariant of its operation that</p>
<div class="equation">
<a name="2862"></a><a name="ch32eq04"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(32.4)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig941_01.jpg" height="15" width="92" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">this result is proved as <a class="internaljump" href="#ch32ex12">Theorem 32.4</a> below. In words, this means that after scanning the first <i class="emphasis">i</i> characters of the text string <i class="emphasis">T</i> , the machine is in state <i class="emphasis"><span class="unicode">&phi;</span></i>(<i class="emphasis">T<sub>i</sub></i>) = <i class="emphasis">q</i>, where <i class="emphasis">q</i> = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">T<sub>i</sub></i>) is the length of the longest suffix of <i class="emphasis">T<sub>i</sub></i> that is also a prefix of the pattern <i class="emphasis">P</i>. If the next character scanned is <i class="emphasis">T</i> [<i class="emphasis">i</i> + 1] = <i class="emphasis">a</i>, then the machine should make a transition to state <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">T</i><sub><i class="emphasis">i</i>+1</sub>) = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">T<sub>i</sub>a</i>). The proof of the theorem shows that <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">T<sub>i</sub>a</i>) = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">P<sub>q</sub>a</i>). That is, to compute the length of the longest suffix of <i class="emphasis">T<sub>i</sub>a</i> that is a prefix of <i class="emphasis">P</i>, we can compute the longest suffix of <i class="emphasis">P<sub>q</sub>a</i> that is a prefix of <i class="emphasis">P</i>. At each state, the machine only needs to know the length of the longest prefix of <i class="emphasis">P</i> that is a suffix of what has been read so far. Therefore, setting <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">q</i>, <i class="emphasis">a</i>) = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">P<sub>q</sub>a</i>) maintains the desired invariant <a class="internaljump" href="#ch32eq04">(32.4)</a>. This informal argument will be made rigorous shortly.</p>
<p class="para">In the string-matching automaton of <a class="internaljump" href="#ch32fig07">Figure 32.7</a>, for example, <i class="emphasis"><span class="unicode">&delta;</span></i>(5, <span class="fixed">b</span>) = 4. We make this transition because if the automaton reads a <span class="fixed">b</span> in state <i class="emphasis">q</i> = 5, then <i class="emphasis">P<sub>q</sub></i> <span class="fixed">b</span> = <span class="fixed">ababab</span>, and the longest prefix of <i class="emphasis">P</i> that is also a suffix of <span class="fixed">ababab</span> is <i class="emphasis">P</i><sub>4</sub> = <span class="fixed">abab</span>.</p>
<p class="para">To clarify the operation of a string-matching automaton, we now give a simple, efficient program for simulating the behavior of such an automaton (represented by its transition function <i class="emphasis"><span class="unicode">&delta;</span></i>) in finding occurrences of a pattern <i class="emphasis">P</i> of length <i class="emphasis">m</i> in an input text <i class="emphasis">T</i> [1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>]. As for any string-matching automaton for a pattern of length <i class="emphasis">m</i>, the state set <i class="emphasis">Q</i> is {0, 1, . . . , <i class="emphasis">m</i>}, the start state is 0, and the only accepting state is state <i class="emphasis">m</i>.</p>
<div class="informalexample">
<pre class="literallayout-normal">
FINITE-AUTOMATON-MATCHER(<i class="emphasis">T</i>, <i class="emphasis"><span class="unicode">&delta;</span></i>, <i class="emphasis">m</i>)
1  <i class="emphasis">n</i> <span class="unicode">&larr;</span> <i class="emphasis">length</i>[<i class="emphasis">T</i>]
2  <i class="emphasis">q</i> <span class="unicode">&larr;</span> 0
3  <b class="bold">for</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">n</i>
4      <b class="bold">do</b> <i class="emphasis">q</i> <span class="unicode">&larr;</span> <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">q</i>, <i class="emphasis">T</i>[<i class="emphasis">i</i>])
5         <b class="bold">if</b> <i class="emphasis">q</i> = <i class="emphasis">m</i>
6            <b class="bold">then</b> print "Pattern occurs with shift" <i class="emphasis">i</i> - <i class="emphasis">m</i>
</pre>
</div>
<p class="para">The simple loop structure of FINITE-AUTOMATON-MATCHER implies that its matching time on a text string of length <i class="emphasis">n</i> is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>). This matching time, however, does not include the preprocessing time required to compute the transition function <i class="emphasis"><span class="unicode">&delta;</span></i>. We address this problem later, after proving that the procedure FINITE-AUTOMATON-MATCHER operates correctly.</p>
<p class="para">Consider the operation of the automaton on an input text <i class="emphasis">T</i> [1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>]. We shall prove that the automaton is in state <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">T<sub>i</sub></i>) after scanning character <i class="emphasis">T</i> [<i class="emphasis">i</i>]. Since <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">T<sub>i</sub></i>) = <i class="emphasis">m</i> if and only if <i class="emphasis">P</i> <span class="unicode">&#8848;</span> <i class="emphasis">T<sub>i</sub></i>, the machine is in the accepting state <i class="emphasis">m</i> if and <a name="2863"></a><a name="IDX-920"></a>only if the pattern <i class="emphasis">P</i> has just been scanned. To prove this result, we make use of the following two lemmas about the suffix function <i class="emphasis"><span class="unicode">&sigma;</span></i>.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 32.2: </span>(Suffix-function inequality)</span><a name="2864"></a><a name="ch32ex10"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">For any string <i class="emphasis">x</i> and character <i class="emphasis">a</i>, we have <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">xa</i>) <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">x</i>) + 1.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> Referring to <a class="internaljump" href="#ch32fig08">Figure 32.8</a>, let <i class="emphasis">r</i> = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">xa</i>). If <i class="emphasis">r</i> = 0, then the conclusion <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">xa</i>) = <i class="emphasis">r</i> <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">x</i>) + 1 is trivially satisfied, by the nonnegativity of <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">x</i>). So assume that <i class="emphasis">r</i> <span class="unicode">&gt;</span> 0. Now, <i class="emphasis">P<sub>r</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">xa</i>, by the definition of <i class="emphasis"><span class="unicode">&sigma;</span></i>. Thus, <i class="emphasis">P</i><sub><i class="emphasis">r</i>-1</sub> <span class="unicode">&#8848;</span> <i class="emphasis">x</i>, by dropping the <i class="emphasis">a</i> from the end of <i class="emphasis">P<sub>r</sub></i> and from the end of <i class="emphasis">xa</i>. Therefore, <i class="emphasis">r</i> -1 <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">x</i>), since <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">x</i>) is largest <i class="emphasis">k</i> such that <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">x</i>, and <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">xa</i>) = <i class="emphasis">r</i> <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">x</i>) + 1.</p>
<p class="last-para">
<div class="figure">
<a name="2865"></a><a name="ch32fig08"></a><span class="figuremediaobject"><a href="images/fig942%5F01%5F0%2Ejpg" NAME="IMG_1698" target="_parent"><img src="images/fig942_01.jpg" height="73" width="294" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 32.8: </span>An illustration for the proof of Lemma 32.2. The figure shows that <i class="emphasis">r</i> <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">x</i>) + 1, where <i class="emphasis">r</i> = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">xa</i>).</span>
</div>
</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 32.3: </span>(Suffix-function recursion lemma)</span><a name="2866"></a><a name="ch32ex11"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">For any string <i class="emphasis">x</i> and character <i class="emphasis">a</i>, if <i class="emphasis">q</i> = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">x</i>), then <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">xa</i>) = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">P<sub>q</sub>a</i>).</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> From the definition of <i class="emphasis"><span class="unicode">&sigma;</span></i>, we have <i class="emphasis">P<sub>q</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">x</i>. As <a class="internaljump" href="#ch32fig09">Figure 32.9</a> shows, we also have <i class="emphasis">P<sub>q</sub></i><i class="emphasis">a</i> <span class="unicode">&#8848;</span> <i class="emphasis">xa</i>. If we let <i class="emphasis">r</i> = <i class="emphasis"><span class="unicode">&sigma;</span></i> (<i class="emphasis">xa</i>), then <i class="emphasis">r</i> <span class="unicode">&le;</span> <i class="emphasis">q</i> + 1 by <a class="internaljump" href="#ch32ex10">Lemma 32.2</a>. Since <i class="emphasis">P<sub>q</sub>a</i> <span class="unicode">&#8848;</span> <i class="emphasis">xa</i>, <i class="emphasis">P<sub>r</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">xa</i>, and |<i class="emphasis">P<sub>r</sub></i>| <span class="unicode">&le;</span> |<i class="emphasis">P<sub>q</sub>a</i>|, <a href="DDU0211.html#2829" target="_parent" class="chapterjump">Lemma 32.1</a> implies that <i class="emphasis">P<sub>r</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub>a</i>. Therefore, <i class="emphasis">r</i> <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">P<sub>q</sub>a</i>), that is, <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">xa</i>) <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">P<sub>q</sub>a</i>). But we also have <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">P<sub>q</sub>a</i>) <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">xa</i>), since <i class="emphasis">P<sub>q</sub>a</i> <span class="unicode">&#8848;</span> <i class="emphasis">xa</i>. Thus, <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">xa</i>) = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">P<sub>q</sub>a</i>).</p>
<p class="last-para">
<div class="figure">
<a name="2867"></a><a name="ch32fig09"></a><span class="figuremediaobject"><a href="images/fig942%5F02%5F0%2Ejpg" NAME="IMG_1699" target="_parent"><img src="images/fig942_02.jpg" height="105" width="310" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 32.9: </span>An illustration for the proof of Lemma 32.3. The figure shows that <i class="emphasis">r</i> = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">P<sub>q</sub>a</i>), where <i class="emphasis">q</i> = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">x</i>) and <i class="emphasis">r</i> = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">xa</i>).</span>
</div>
</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="2868"></a><a name="IDX-921"></a>
<p class="para">We are now ready to prove our main theorem characterizing the behavior of a string-matching automaton on a given input text. As noted above, this theorem shows that the automaton is merely keeping track, at each step, of the longest prefix of the pattern that is a suffix of what has been read so far. In other words, the automaton maintains the invariant <a class="internaljump" href="#ch32eq04">(32.4)</a>.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 32.4</span></span><a name="2869"></a><a name="ch32ex12"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">If <i class="emphasis"><span class="unicode">&phi;</span></i> is the final-state function of a string-matching automaton for a given pattern <i class="emphasis">P</i> and <i class="emphasis">T</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>] is an input text for the automaton, then</p>
<p class="para">
<i class="emphasis"><span class="unicode">&phi;</span></i>(<i class="emphasis">T<sub>i</sub></i>) = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">T<sub>i</sub></i>)</p>
<p class="para">for <i class="emphasis">i</i> = 0, 1, . . . , <i class="emphasis">n</i>.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> The proof is by induction on <i class="emphasis">i</i>. For <i class="emphasis">i</i> = 0, the theorem is trivially true, since <i class="emphasis">T</i><sub>0</sub> = <i class="emphasis"><span class="unicode">&epsilon;</span></i>. Thus, <i class="emphasis"><span class="unicode">&phi;</span></i>(<i class="emphasis">T</i><sub>0</sub>) = 0 = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">T</i><sub>0</sub>).</p>
<p class="para">Now, we assume that <i class="emphasis"><span class="unicode">&phi;</span></i>(<i class="emphasis">T<sub>i</sub></i>) = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">T<sub>i</sub></i>) and prove that <i class="emphasis"><span class="unicode">&phi;</span></i>(<i class="emphasis">T</i><sub><i class="emphasis">i</i>+1</sub>) = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">T</i><sub><i class="emphasis">i</i>+1</sub>). Let <i class="emphasis">q</i> denote <i class="emphasis"><span class="unicode">&phi;</span></i>(<i class="emphasis">T<sub>i</sub></i>), and let <i class="emphasis">a</i> denote <i class="emphasis">T</i>[<i class="emphasis">i</i> + 1]. Then,</p>
<p class="last-para">
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&phi;</span></i>(<i class="emphasis">T</i><sub><i class="emphasis">i</i>+1</sub>)</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&phi;</span></i>(<i class="emphasis">T<sub>i</sub>a</i>)</p>
</td><td class="td" align="left">
<p class="table-para">(by the definitions of <i class="emphasis">T</i><sub><i class="emphasis">i</i>+1</sub> and <i class="emphasis">a</i>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis"><span class="unicode">&phi;</span></i>(<i class="emphasis">T<sub>i</sub></i>), <i class="emphasis">a</i>)</p>
</td><td class="td" align="left">
<p class="table-para">(by the definition of <i class="emphasis"><span class="unicode">&phi;</span></i>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">q</i>, <i class="emphasis">a</i>)</p>
</td><td class="td" align="left">
<p class="table-para">(by the definition of <i class="emphasis">q</i>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">P<sub>q</sub>a</i>)</p>
</td><td class="td" align="left">
<p class="table-para">(by the definition <a class="internaljump" href="#ch32eq03">(32.3)</a> of <i class="emphasis"><span class="unicode">&delta;</span></i>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">T<sub>i</sub>a</i>)</p>
</td><td class="td" align="left">
<p class="table-para">(by <a class="internaljump" href="#ch32ex11">Lemma 32.3</a> and induction)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">T</i><sub><i class="emphasis">i</i>+1</sub>)</p>
</td><td class="td" align="left">
<p class="table-para">(by the definition of <i class="emphasis">T</i><sub><i class="emphasis">i</i>+1</sub>).</p>
</td>
</tr>
</tbody>
</table>
</div>
</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="last-para">By <a class="internaljump" href="#ch32ex12">Theorem 32.4</a>, if the machine enters state <i class="emphasis">q</i> on line 4, then <i class="emphasis">q</i> is the largest value such that <i class="emphasis">P<sub>q</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">T<sub>i</sub></i>. Thus, we have <i class="emphasis">q</i> = <i class="emphasis">m</i> on line 5 if and only if an occurrence of the pattern <i class="emphasis">P</i> has just been scanned. We conclude that FINITE-AUTOMATON-MATCHER operates correctly.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="2870"></a><a name="ch32lev3sec4"></a>Computing the transition function</h4>
<p class="first-para">The following procedure computes the transition function <i class="emphasis"><span class="unicode">&delta;</span></i> from a given pattern <i class="emphasis">P</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">m</i>].<a name="2871"></a><a name="IDX-922"></a>
</p>
<div class="informalexample">
<pre class="literallayout-normal">
COMPUTE-TRANSITION-FUNCTION(<i class="emphasis">P</i>, <span class="unicode">&Sigma;</span>)
1 <i class="emphasis">m</i> <span class="unicode">&larr;</span> <i class="emphasis">length</i>[<i class="emphasis">P</i>]
2 <b class="bold">for</b> <i class="emphasis">q</i> <span class="unicode">&larr;</span> 0 <b class="bold">to</b> <i class="emphasis">m</i>
3     <b class="bold">do for</b> each character <i class="emphasis">a</i> <span class="unicode">&isin;</span> <span class="unicode">&Sigma;</span>
4            <b class="bold">do</b> <i class="emphasis">k</i> <span class="unicode">&larr;</span> min(<i class="emphasis">m</i> + 1, <i class="emphasis">q</i> + 2)
5               <b class="bold">repeat</b> <i class="emphasis">k</i> <span class="unicode">&larr;</span> <i class="emphasis">k</i> - 1
6                 <b class="bold">until</b> <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub>a</i>
7               <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">q</i>, <i class="emphasis">a</i>) <span class="unicode">&larr;</span> <i class="emphasis">k</i>
8 <b class="bold">return</b> <i class="emphasis"><span class="unicode">&delta;</span></i>
</pre>
</div>
<p class="para">This procedure computes <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">q</i>, <i class="emphasis">a</i>) in a straightforward manner according to its definition. The nested loops beginning on lines 2 and 3 consider all states <i class="emphasis">q</i> and characters <i class="emphasis">a</i>, and lines 4<span class="unicode">-</span>7 set <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">q</i>, <i class="emphasis">a</i>) to be the largest <i class="emphasis">k</i> such that <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub>a</i>. The code starts with the largest conceivable value of <i class="emphasis">k</i>, which is min(<i class="emphasis">m</i>, <i class="emphasis">q</i> + 1), and decreases <i class="emphasis">k</i> until <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub>a</i>.</p>
<p class="para">The running time of COMPUTE-TRANSITION-FUNCTION is <i class="emphasis">O</i>(<i class="emphasis">m</i><sup>3</sup> |<span class="unicode">&Sigma;</span>|), because the outer loops contribute a factor of <i class="emphasis">m</i> |<span class="unicode">&Sigma;</span>|, the inner <b class="bold">repeat</b> loop can run at most <i class="emphasis">m</i> + 1 times, and the test <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub>a</i> on line 6 can require comparing up to <i class="emphasis">m</i> characters. Much faster procedures exist; the time required to compute <i class="emphasis"><span class="unicode">&delta;</span></i> from <i class="emphasis">P</i> can be improved to <i class="emphasis">O</i>(<i class="emphasis">m</i> |<span class="unicode">&Sigma;</span>|) by utilizing some cleverly computed information about the pattern <i class="emphasis">P</i> (see <a href="DDU0215.html#2905" target="_parent" class="chapterjump">Exercise 32.4-6</a>). With this improved procedure for computing <i class="emphasis"><span class="unicode">&delta;</span></i>, we can find all occurrences of a length-<i class="emphasis">m</i> pattern in a length-<i class="emphasis">n</i> text over an alphabet <span class="unicode">&Sigma;</span> with <i class="emphasis">O</i>(<i class="emphasis">m</i> |<span class="unicode">&Sigma;</span>|) preprocessing time and <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) matching time.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 32.3-1</span></span><a name="2872"></a><a name="ch32ex13"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Construct the string-matching automaton for the pattern <i class="emphasis">P</i> = <span class="fixed">aabab</span> and illustrate its operation on the text string <i class="emphasis">T</i> = <span class="fixed">aaababaabaababaab</span>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 32.3-2</span></span><a name="2873"></a><a name="ch32ex14"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Draw a state-transition diagram for a string-matching automaton for the pattern <span class="fixed">ababbabbababbababbabb</span> over the alphabet <span class="unicode">&Sigma;</span> = {<span class="fixed">a</span>, <span class="fixed">b</span>}.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 32.3-3</span></span><a name="2874"></a><a name="ch32ex15"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">We call a pattern <i class="emphasis">P</i> <b class="bold"><i class="emphasis">nonoverlappable</i></b> if <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i> implies <i class="emphasis">k</i> = 0 or <i class="emphasis">k</i> = <i class="emphasis">q</i>. Describe the state-transition diagram of the string-matching automaton for a nonoverlappable pattern.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="2875"></a><a name="IDX-923"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 32.3-4: </span><span class="unicode">&#9733;</span></span><a name="2876"></a><a name="ch32ex16"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Given two patterns <i class="emphasis">P</i> and <i class="emphasis">P</i><span class="unicode">&prime;</span>, describe how to construct a finite automaton that determines all occurrences of <i class="emphasis">either</i> pattern. Try to minimize the number of states in your automaton.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 32.3-5</span></span><a name="2877"></a><a name="ch32ex17"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Given a pattern <i class="emphasis">P</i> containing gap characters (see <a href="DDU0212.html#2838" target="_parent" class="chapterjump">Exercise 32.1-4</a>), show how to build a finite automaton that can find an occurrence of <i class="emphasis">P</i> in a text <i class="emphasis">T</i> in <i class="emphasis">O</i>(<i class="emphasis">n</i>) matching time, where <i class="emphasis">n</i> = |<i class="emphasis">T</i>|.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0213.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0215.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
