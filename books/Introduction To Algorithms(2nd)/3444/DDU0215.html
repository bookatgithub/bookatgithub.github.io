<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>32.4 &#9733; The Knuth-Morris-Pratt algorithm</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0214.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0216.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch32"></a>
<div class="section">
<h2 class="first-section-title">
<a name="2878"></a><a name="ch32lev1sec4"></a><span class="section-titlelabel">32.4 </span><span class="unicode">&#9733;</span> The Knuth-Morris-Pratt algorithm</h2>
<p class="first-para">We now present a linear-time string-matching algorithm due to Knuth, Morris, and Pratt. Their algorithm avoids the computation of the transition function <i class="emphasis"><span class="unicode">&delta;</span></i> altogether, and its matching time is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) using just an auxiliary function <span class="unicode">&pi;</span>[1 <span class="unicode">&#8229;</span> <i class="emphasis">m</i>] precomputed from the pattern in time <span class="unicode">&Theta;</span>(<i class="emphasis">m</i>). The array <span class="unicode">&pi;</span> allows the transition function <i class="emphasis"><span class="unicode">&delta;</span></i> to be computed efficiently (in an amortized sense) "on the fly" as needed. Roughly speaking, for any state <i class="emphasis">q</i> = 0, 1, . . . , <i class="emphasis">m</i> and any character <i class="emphasis">a</i> <span class="unicode">&isin;</span> <span class="unicode">&Sigma;</span>, the value <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] contains the information that is independent of <i class="emphasis">a</i> and is needed to compute <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">q</i>, <i class="emphasis">a</i>). (This remark will be clarified shortly.) Since the array <span class="unicode">&pi;</span> has only <i class="emphasis">m</i> entries, whereas <i class="emphasis"><span class="unicode">&delta;</span></i> has <span class="unicode">&Theta;</span>(<i class="emphasis">m</i> |<span class="unicode">&Sigma;</span>|) entries, we save a factor of |<span class="unicode">&Sigma;</span>| in the preprocessing time by computing <span class="unicode">&pi;</span> rather than <i class="emphasis"><span class="unicode">&delta;</span></i>.</p>
<div class="section">
<h4 class="sect4-title">
<a name="2879"></a><a name="ch32lev3sec5"></a>The prefix function for a pattern</h4>
<p class="first-para">The prefix function <span class="unicode">&pi;</span> for a pattern encapsulates knowledge about how the pattern matches against shifts of itself. This information can be used to avoid testing useless shifts in the naive pattern-matching algorithm or to avoid the precomputation of <i class="emphasis"><span class="unicode">&delta;</span></i> for a string-matching automaton.</p>
<p class="para">Consider the operation of the naive string matcher. <a class="internaljump" href="#ch32fig10">Figure 32.10(a)</a> shows a particular shift <i class="emphasis">s</i> of a template containing the pattern <i class="emphasis">P</i> = <span class="fixed">ababaca</span> against a text <i class="emphasis">T</i>. For this example, <i class="emphasis">q</i> = 5 of the characters have matched successfully, but the 6th pattern character fails to match the corresponding text character. The information that <i class="emphasis">q</i> characters have matched successfully determines the corresponding text characters. Knowing these <i class="emphasis">q</i> text characters allows us to determine immediately that certain shifts are invalid. In the example of the figure, the shift <i class="emphasis">s</i> + 1 is necessarily invalid, since the first pattern character (<span class="fixed">a</span>) would be aligned with a text character that is known to match with the second pattern character (<span class="fixed">b</span>). The shift <i class="emphasis">s</i><span class="unicode">&prime;</span> = <i class="emphasis">s</i> + 2 shown in part (b) of the figure, however, aligns the first three pattern characters with three text characters that must necessarily match. In general, it is useful to know the answer to the following question:</p>
<div class="figure">
<a name="2880"></a><a name="ch32fig10"></a><span class="figuremediaobject"><a href="images/fig946%5F01%5F0%2Ejpg" NAME="IMG_1700" target="_parent"><img src="images/fig946_01.jpg" height="278" width="257" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 32.10: </span>The prefix function <span class="unicode">&pi;</span>. <i class="emphasis">(a)</i> The pattern <i class="emphasis">P</i> = <span class="fixed">ababaca</span> is aligned with a text <i class="emphasis">T</i> so that the first <i class="emphasis">q</i> = 5 characters match. Matching characters, shown shaded, are connected by vertical lines. <i class="emphasis">(b)</i> Using only our knowledge of the 5 matched characters, we can deduce that a shift of <i class="emphasis">s</i> + 1 is invalid, but that a shift of <i class="emphasis">s</i><span class="unicode">&prime;</span> = <i class="emphasis">s</i> + 2 is consistent with everything we know about the text and therefore is potentially valid. <i class="emphasis">(c)</i> The useful information for such deductions can be precomputed by comparing the pattern with itself. Here, we see that the longest prefix of <i class="emphasis">P</i> that is also a proper suffix of <i class="emphasis">P</i><sub>5</sub> is <i class="emphasis">P</i><sub>3</sub>. This information is precomputed and represented in the array <span class="unicode">&pi;</span>, so that <span class="unicode">&pi;</span>[5] = 3. Given that <i class="emphasis">q</i> characters have matched successfully at shift <i class="emphasis">s</i>, the next potentially valid shift is at <i class="emphasis">s</i><span class="unicode">&prime;</span> = <i class="emphasis">s</i> + (<i class="emphasis">q</i> - <span class="unicode">&pi;</span>[<i class="emphasis">q</i>]).</span>
</div>
<a name="2881"></a><a name="IDX-924"></a>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">Given that pattern characters <i class="emphasis">P</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">q</i>] match text characters <i class="emphasis">T</i>[<i class="emphasis">s</i> + 1 <span class="unicode">&#8229;</span> <i class="emphasis">s</i> + <i class="emphasis">q</i>], what is the least shift <i class="emphasis">s</i><span class="unicode">&prime;</span> <span class="unicode">&gt;</span> <i class="emphasis">s</i> such that</p>
<div class="equation">
<a name="2882"></a><a name="ch32eq05"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(32.5)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig946_02.jpg" height="15" width="183" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="last-para">where <i class="emphasis">s</i><span class="unicode">&prime;</span> + <i class="emphasis">k</i> = <i class="emphasis">s</i> + <i class="emphasis">q</i>?</p>
</li>
</ul>
<p class="para">Such a shift <i class="emphasis">s</i><span class="unicode">&prime;</span> is the first shift greater than <i class="emphasis">s</i> that is not necessarily invalid due to our knowledge of <i class="emphasis">T</i>[<i class="emphasis">s</i> + 1 <span class="unicode">&#8229;</span> <i class="emphasis">s</i> + <i class="emphasis">q</i>]. In the best case, we have that <i class="emphasis">s</i><span class="unicode">&prime;</span> = <i class="emphasis">s</i> + <i class="emphasis">q</i>, and shifts <i class="emphasis">s</i> + 1, <i class="emphasis">s</i> + 2, . . . , <i class="emphasis">s</i> + <i class="emphasis">q</i> - 1 are all immediately ruled out. In any case, at the new shift <i class="emphasis">s</i><span class="unicode">&prime;</span> we don't need to compare the first <i class="emphasis">k</i> characters of <i class="emphasis">P</i> with the corresponding characters of <i class="emphasis">T</i>, since we are guaranteed that they match by <a class="internaljump" href="#ch32eq05">equation (32.5)</a>.</p>
<p class="para">The necessary information can be precomputed by comparing the pattern against itself, as illustrated in <a class="internaljump" href="#ch32fig10">Figure 32.10(c)</a>. Since <i class="emphasis">T</i>[<i class="emphasis">s</i><span class="unicode">&prime;</span> + 1 <span class="unicode">&#8229;</span> <i class="emphasis">s</i><span class="unicode">&prime;</span> + <i class="emphasis">k</i>] is part of the known <a name="2883"></a><a name="IDX-925"></a>portion of the text, it is a suffix of the string <i class="emphasis">P<sub>q</sub></i>. <a class="internaljump" href="#ch32eq05">Equation (32.5)</a> can therefore be interpreted as asking for the largest <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">q</i> such that <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i>. Then, <i class="emphasis">s</i><span class="unicode">&prime;</span> = <i class="emphasis">s</i>+(<i class="emphasis">q</i> - <i class="emphasis">k</i>) is the next potentially valid shift. It turns out to be convenient to store the number <i class="emphasis">k</i> of matching characters at the new shift <i class="emphasis">s</i><span class="unicode">&prime;</span>, rather than storing, say, <i class="emphasis">s</i><span class="unicode">&prime;</span> - <i class="emphasis">s</i>. This information can be used to speed up both the naive string-matching algorithm and the finite-automaton matcher.</p>
<p class="para">We formalize the precomputation required as follows. Given a pattern <i class="emphasis">P</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">m</i>], the <b class="bold"><i class="emphasis">prefix function</i></b> for the pattern <i class="emphasis">P</i> is the function <span class="unicode">&pi;</span> : {1, 2, . . . , <i class="emphasis">m</i>} <span class="unicode">&rarr;</span> {0, 1, . . . , <i class="emphasis">m</i> - 1} such that</p>
<p class="para">
<span class="unicode">&pi;</span>[<i class="emphasis">q</i>] = max {<i class="emphasis">k</i> : <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">q</i> and <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i>}.</p>
<p class="para">That is, <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] is the length of the longest prefix of <i class="emphasis">P</i> that is a proper suffix of <i class="emphasis">P<sub>q</sub></i>. As another example, <a class="internaljump" href="#ch32fig11">Figure 32.11(a)</a> gives the complete prefix function <span class="unicode">&pi;</span> for the pattern <span class="fixed">ababababca</span>.</p>
<div class="figure">
<a name="2884"></a><a name="ch32fig11"></a><span class="figuremediaobject"><a href="images/fig947%5F01%5F0%2Ejpg" NAME="IMG_1702" target="_parent"><img src="images/fig947_01.jpg" height="253" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 32.11: </span>An illustration of Lemma 32.5 for the pattern <i class="emphasis">P</i> = <span class="fixed">ababababca</span> and <i class="emphasis">q</i> = 8. <i class="emphasis">(a)</i> The <span class="unicode">&pi;</span> function for the given pattern. Since <span class="unicode">&pi;</span>[8] = 6, <span class="unicode">&pi;</span>[6] = 4, <span class="unicode">&pi;</span>[4] = 2, and <span class="unicode">&pi;</span>[2] = 0, by iterating <span class="unicode">&pi;</span> we obtain <span class="unicode">&pi;</span>*[8] = {6, 4, 2, 0}. <i class="emphasis">(b)</i> We slide the template containing the pattern <i class="emphasis">P</i> to the right and note when some prefix <i class="emphasis">P<sub>k</sub></i> of <i class="emphasis">P</i> matches up with some proper suffix of <i class="emphasis">P</i><sub>8</sub>; this happens for <i class="emphasis">k</i> = 6, 4, 2, and 0. In the figure, the first row gives <i class="emphasis">P</i>, and the dotted vertical line is drawn just after <i class="emphasis">P</i><sub>8</sub>. Successive rows show all the shifts of <i class="emphasis">P</i> that cause some prefix <i class="emphasis">P<sub>k</sub></i> of <i class="emphasis">P</i> to match some suffix of <i class="emphasis">P</i><sub>8</sub>. Successfully matched characters are shown shaded. Vertical lines connect aligned matching characters. Thus, {<i class="emphasis">k</i> : <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">q</i> and <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i>} = {6, 4,2, 0}. The lemma claims that <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>] = {<i class="emphasis">k</i> : <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">q</i> and <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i>} for all <i class="emphasis">q</i>.</span>
</div>
<a name="2885"></a><a name="IDX-926"></a>
<p class="para">The Knuth-Morris-Pratt matching algorithm is given in pseudocode below as the procedure KMP-MATCHER. It is mostly modeled after FINITE-AUTOMATON-MATCHER, as we shall see. KMP-MATCHER calls the auxiliary procedure COMPUTE-PREFIX-FUNCTION to compute <span class="unicode">&pi;</span>.</p>
<div class="informalexample">
<pre class="literallayout-normal">
KMP-MATCHER(<i class="emphasis">T</i>, <i class="emphasis">P</i>)
 1 <i class="emphasis">n</i> <span class="unicode">&larr;</span> <i class="emphasis">length</i>[<i class="emphasis">T</i>]
 2 <i class="emphasis">m</i> <span class="unicode">&larr;</span> <i class="emphasis">length</i>[<i class="emphasis">P</i>]
 3 <span class="unicode">&pi;</span> <span class="unicode">&larr;</span> COMPUTE-PREFIX-FUNCTION(<i class="emphasis">P</i>)
 4 <i class="emphasis">q</i> <span class="unicode">&larr;</span> 0                          <span class="unicode">&#9657;</span>Number of characters matched.
 5 <b class="bold">for</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">n</i>                 <span class="unicode">&#9657;</span>Scan the text from left to right.
 6      <b class="bold">do while</b> <i class="emphasis">q</i> <span class="unicode">&gt;</span> 0 and <i class="emphasis">P</i>[<i class="emphasis">q</i> + 1] <span class="unicode">&ne;</span> <i class="emphasis">T</i>[<i class="emphasis">i</i>]
 7             <b class="bold">do</b> <i class="emphasis">q</i> <span class="unicode">&larr;</span> <span class="unicode">&pi;</span>[<i class="emphasis">q</i>]    <span class="unicode">&#9657;</span>Next character does not match.
 8         <b class="bold">if</b> <i class="emphasis">P</i>[<i class="emphasis">q</i> + 1] = <i class="emphasis">T</i>[<i class="emphasis">i</i>]
 9            <b class="bold">then</b> <i class="emphasis">q</i> <span class="unicode">&larr;</span> <i class="emphasis">q</i> + 1      <span class="unicode">&#9657;</span>Next character matches.
10         <b class="bold">if</b> <i class="emphasis">q</i> = <i class="emphasis">m</i>                    <span class="unicode">&#9657;</span>Is all of <i class="emphasis">P</i> matched?
11            <b class="bold">then</b> print "Pattern occurs with shift" <i class="emphasis">i</i> - <i class="emphasis">m</i>
12                 <i class="emphasis">q</i> <span class="unicode">&larr;</span> <span class="unicode">&pi;</span>[<i class="emphasis">q</i>]    <span class="unicode">&#9657;</span>Look for the next match.
</pre>
</div>
<div class="informalexample">
<pre class="literallayout-normal">
COMPUTE-PREFIX-FUNCTION(<i class="emphasis">P</i>)
 1 <i class="emphasis">m</i> <span class="unicode">&larr;</span> <i class="emphasis">length</i>[<i class="emphasis">P</i>]
 2 <span class="unicode">&pi;</span>[1] <span class="unicode">&larr;</span> 0
 3 <i class="emphasis">k</i> <span class="unicode">&larr;</span> 0
 4 <b class="bold">for</b> <i class="emphasis">q</i> <span class="unicode">&larr;</span> 2 <b class="bold">to</b> <i class="emphasis">m</i>
 5      <b class="bold">do while</b> <i class="emphasis">k</i> <span class="unicode">&gt;</span> 0 and <i class="emphasis">P</i>[<i class="emphasis">k</i> + 1] <span class="unicode">&ne;</span> <i class="emphasis">P</i>[<i class="emphasis">q</i>]
 6             <b class="bold">do</b> <i class="emphasis">k</i> <span class="unicode">&larr;</span> <span class="unicode">&pi;</span>[<i class="emphasis">k</i>]
 7         <b class="bold">if</b> <i class="emphasis">P</i>[<i class="emphasis">k</i> + 1] = <i class="emphasis">P</i>[<i class="emphasis">q</i>]
 8            <b class="bold">then</b> <i class="emphasis">k</i> <span class="unicode">&larr;</span> <i class="emphasis">k</i> + 1
 9         <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] <span class="unicode">&larr;</span> <i class="emphasis">k</i>
10 <b class="bold">return</b> <span class="unicode">&pi;</span>
</pre>
</div>
<p class="last-para">We begin with an analysis of the running times of these procedures. Proving these procedures correct will be more complicated.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="2886"></a><a name="ch32lev3sec6"></a>Running-time analysis</h4>
<p class="first-para">The running time of COMPUTE-PREFIX-FUNCTION is <span class="unicode">&Theta;</span>(<i class="emphasis">m</i>), using the potential method of amortized analysis (see <a href="DDU0103.html#1275" target="_parent" class="chapterjump">Section 17.3</a>). We associate a potential of <i class="emphasis">k</i> with the current state <i class="emphasis">k</i> of the algorithm. This potential has an initial value of 0, by line 3. Line 6 decreases <i class="emphasis">k</i> whenever it is executed, since <span class="unicode">&pi;</span>[<i class="emphasis">k</i>] <span class="unicode">&lt;</span> <i class="emphasis">k</i>. Since <span class="unicode">&pi;</span>[<i class="emphasis">k</i>] <span class="unicode">&ge;</span> 0 for all <i class="emphasis">k</i>, however, <i class="emphasis">k</i> can never become negative. The only other line that affects <i class="emphasis">k</i> is line 8, which increases <i class="emphasis">k</i> by at most one during each execution <a name="2887"></a><a name="IDX-927"></a>of the <b class="bold">for</b> loop body. Since <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">q</i> upon entering the <b class="bold">for</b> loop, and since <i class="emphasis">q</i> is incremented in each iteration of the <b class="bold">for</b> loop body, <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">q</i> always holds. (This justifies the claim that <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] <span class="unicode">&lt;</span> <i class="emphasis">q</i> as well, by line 9.) We can pay for each execution of the <b class="bold">while</b> loop body on line 6 with the corresponding decrease in the potential function, since <span class="unicode">&pi;</span>[<i class="emphasis">k</i>] <span class="unicode">&lt;</span> <i class="emphasis">k</i>. Line 8 increases the potential function by at most one, so that the amortized cost of the loop body on lines 5<span class="unicode">-</span>9 is <i class="emphasis">O</i>(1). Since the number of outer-loop iterations is <span class="unicode">&Theta;</span>(<i class="emphasis">m</i>), and since the final potential function is at least as great as the initial potential function, the total actual worst-case running time of COMPUTE-PREFIX-FUNCTION is <span class="unicode">&Theta;</span>(<i class="emphasis">m</i>).</p>
<p class="para">A similar amortized analysis, using the value of <i class="emphasis">q</i> as the potential function, shows that the matching time of KMP-MATCHER is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>).</p>
<p class="last-para">Compared to FINITE-AUTOMATON-MATCHER, by using <span class="unicode">&pi;</span> rather than <i class="emphasis"><span class="unicode">&delta;</span></i>, we have reduced the time for preprocessing the pattern from <i class="emphasis">O</i>(<i class="emphasis">m</i> |<span class="unicode">&Sigma;</span>|) to <span class="unicode">&Theta;</span>(<i class="emphasis">m</i>), while keeping the actual matching time bounded by <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>).</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="2888"></a><a name="ch32lev3sec7"></a>Correctness of the prefix-function computation</h4>
<p class="first-para">We start with an essential lemma showing that by iterating the prefix function <span class="unicode">&pi;</span>, we can enumerate all the prefixes <i class="emphasis">P<sub>k</sub></i> that are proper suffixes of a given prefix <i class="emphasis">P<sub>q</sub></i>. Let</p>
<p class="para">
<span class="unicode">&pi;</span>*[<i class="emphasis">q</i>] = {<span class="unicode">&pi;</span>[<i class="emphasis">q</i>], <span class="unicode">&pi;</span><sup>(2)</sup>[<i class="emphasis">q</i>], <span class="unicode">&pi;</span><sup>(3)</sup>[<i class="emphasis">q</i>], . . . , <span class="unicode">&pi;</span><sup>(<i class="emphasis">t</i>)</sup>[<i class="emphasis">q</i>]},</p>
<p class="para">where <span class="unicode">&pi;</span><sup>(<i class="emphasis">i</i>)</sup>[<i class="emphasis">q</i>] is defined in terms of functional iteration, so that <span class="unicode">&pi;</span><sup>(0)</sup>[<i class="emphasis">q</i>] = <i class="emphasis">q</i> and <span class="unicode">&pi;</span><sup>(<i class="emphasis">i</i>+1)</sup>[<i class="emphasis">q</i>] = <span class="unicode">&pi;</span>[<span class="unicode">&pi;</span><sup>(<i class="emphasis">i</i>)</sup>[<i class="emphasis">q</i>]] for <i class="emphasis">i</i> <span class="unicode">&ge;</span> 1, and where it is understood that the sequence in <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>] stops when <span class="unicode">&pi;</span><sup>(<i class="emphasis">t</i>)</sup>[<i class="emphasis">q</i>] = 0 is reached. The following lemma characterizes <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>], as <a class="internaljump" href="#ch32fig11">Figure 32.11</a> illustrates.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 32.5: </span>(Prefix-function iteration lemma)</span><a name="2889"></a><a name="ch32ex18"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">P</i> be a pattern of length <i class="emphasis">m</i> with prefix function <span class="unicode">&pi;</span>. Then, for <i class="emphasis">q</i> = 1, 2, . . . , <i class="emphasis">m</i>, we have <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>] = {<i class="emphasis">k</i> : <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">q</i> and <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i>}.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> We first prove that</p>
<p class="para">
<div class="equation">
<a name="2890"></a><a name="ch32eq06"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(32.6)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig949_01.jpg" height="17" width="163" alt="" border="0"></span></td>
</tr>
</table>
</div>
</p>
<p class="para">If <i class="emphasis">i</i> <span class="unicode">&isin;</span> <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>], then <i class="emphasis">i</i> = <span class="unicode">&pi;</span><sup>(<i class="emphasis">u</i>)</sup>[<i class="emphasis">q</i>] for some <i class="emphasis">u</i> <span class="unicode">&gt;</span> 0. We prove <a class="internaljump" href="#ch32eq06">equation (32.6)</a> by induction on <i class="emphasis">u</i>. For <i class="emphasis">u</i> = 1, we have <i class="emphasis">i</i> = <span class="unicode">&pi;</span>[<i class="emphasis">q</i>], and the claim follows since <i class="emphasis">i</i> <span class="unicode">&lt;</span> <i class="emphasis">q</i> and <i class="emphasis">P</i><sub><span class="unicode">&pi;</span>[<i class="emphasis">q</i>]</sub> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i>. Using the relations <span class="unicode">&pi;</span>[<i class="emphasis">i</i>] <span class="unicode">&lt;</span> <i class="emphasis">i</i> and <i class="emphasis">P</i><sub><span class="unicode">&pi;</span>[<i class="emphasis">i</i>]</sub> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>i</sub></i> and the transitivity of <span class="unicode">&lt;</span> and <span class="unicode">&#8848;</span> establishes the claim for all <i class="emphasis">i</i> in <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>]. Therefore, <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>] <span class="unicode">&sube;</span> {<i class="emphasis">k</i> : <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">q</i> and <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i>}.</p>
<p class="last-para">We prove that {<i class="emphasis">k</i> : <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">q</i> and <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i>} <span class="unicode">&sube;</span> <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>] by contradiction. Suppose to the contrary that there is an integer in the set {<i class="emphasis">k</i> : <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">q</i> and <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i>} - <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>], and let <i class="emphasis">j</i> be the largest such value. Because <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] is the largest value in <a name="2891"></a><a name="IDX-928"></a>{<i class="emphasis">k</i> : <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">q</i> and <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i>} and <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] <span class="unicode">&isin;</span> <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>], we must have <i class="emphasis">j</i> <span class="unicode">&lt;</span> <span class="unicode">&pi;</span>[<i class="emphasis">q</i>], and so we let <i class="emphasis">j</i><span class="unicode">&prime;</span> denote the smallest integer in <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>] that is greater than <i class="emphasis">j</i>. (We can choose <i class="emphasis">j</i><span class="unicode">&prime;</span> = <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] if there is no other number in <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>] that is greater than <i class="emphasis">j</i>.) We have <i class="emphasis">P<sub>j</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i> because <i class="emphasis">j</i> <span class="unicode">&isin;</span> {<i class="emphasis">k</i> : <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">q</i> and <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i>}, and we have <i class="emphasis">P</i><sub><i class="emphasis">j</i></sub><span class="unicode"><sub><span class="unicode">&prime;</span></sub></span> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i> because <i class="emphasis">j</i><span class="unicode">&prime;</span> <span class="unicode">&isin;</span> <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>]. Thus, <i class="emphasis">P<sub>j</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P</i><sub><i class="emphasis">j</i></sub><span class="unicode"><sub><span class="unicode">&prime;</span></sub></span> by <a href="DDU0211.html#2829" target="_parent" class="chapterjump">Lemma 32.1</a>, and <i class="emphasis">j</i> is the largest value less than <i class="emphasis">j</i><span class="unicode">&prime;</span> with this property. Therefore, we must have <span class="unicode">&pi;</span>[<i class="emphasis">j</i><span class="unicode">&prime;</span>] = <i class="emphasis">j</i> and, since <i class="emphasis">j</i><span class="unicode">&prime;</span> <span class="unicode">&isin;</span> <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>], we must have <i class="emphasis">j</i> <span class="unicode">&isin;</span> <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>] as well. This contradiction proves the lemma.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">The algorithm COMPUTE-PREFIX-FUNCTION computes <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] in order for <i class="emphasis">q</i> = 1, 2, . . . , <i class="emphasis">m</i>. The computation of <span class="unicode">&pi;</span>[1] = 0 in line 2 of COMPUTE-PREFIX-FUNCTION is certainly correct, since <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] <span class="unicode">&lt;</span> <i class="emphasis">q</i> for all <i class="emphasis">q</i>. The following lemma and its corollary will be used to prove that COMPUTE-PREFIX-FUNCTION computes <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] correctly for <i class="emphasis">q</i> <span class="unicode">&gt;</span> 1.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 32.6</span></span><a name="2892"></a><a name="ch32ex19"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">P</i> be a pattern of length <i class="emphasis">m</i>, and let <span class="unicode">&pi;</span> be the prefix function for <i class="emphasis">P</i>. For <i class="emphasis">q</i> = 1, 2, . . . , <i class="emphasis">m</i>, if <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] <span class="unicode">&gt;</span> 0, then <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] - 1 <span class="unicode">&isin;</span> <span class="unicode">&pi;</span>*[<i class="emphasis">q</i> - 1].</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> If <i class="emphasis">r</i> = <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] <span class="unicode">&gt;</span> 0, then <i class="emphasis">r</i> <span class="unicode">&lt;</span> <i class="emphasis">q</i> and <i class="emphasis">P<sub>r</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i>; thus, <i class="emphasis">r</i> - 1 <span class="unicode">&lt;</span> <i class="emphasis">q</i> - 1 and <i class="emphasis">P</i><sub><i class="emphasis">r</i>-1</sub> <span class="unicode">&#8848;</span> <i class="emphasis">P</i><sub><i class="emphasis">q</i>-1</sub> (by dropping the last character from <i class="emphasis">P<sub>r</sub></i> and <i class="emphasis">P<sub>q</sub></i>). By <a class="internaljump" href="#ch32ex18">Lemma 32.5</a>, therefore, <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] - 1 = <i class="emphasis">r</i> - 1 <span class="unicode">&isin;</span> <span class="unicode">&pi;</span>*[<i class="emphasis">q</i> - 1].</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">For <i class="emphasis">q</i> = 2, 3, . . . , <i class="emphasis">m</i>, define the subset <i class="emphasis">E</i><sub><i class="emphasis">q</i>-1</sub> <span class="unicode">&sube;</span> <span class="unicode">&pi;</span>*[<i class="emphasis">q</i> - 1] by</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">E</i><sub><i class="emphasis">q</i>-1</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">{<i class="emphasis">k</i> <span class="unicode">&isin;</span> <span class="unicode">&pi;</span>*[<i class="emphasis">q</i> - 1] : <i class="emphasis">P</i>[<i class="emphasis">k</i> + 1] = <i class="emphasis">P</i>[<i class="emphasis">q</i>]}</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">{<i class="emphasis">k</i> : <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">q</i> - 1 and <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P</i><sub><i class="emphasis">q</i>-1</sub> and <i class="emphasis">P</i>[<i class="emphasis">k</i> + 1] = <i class="emphasis">P</i>[<i class="emphasis">q</i>]} (by <a class="internaljump" href="#ch32ex18">Lemma 32.5</a>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">{<i class="emphasis">k</i> : <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">q</i> - 1 and <i class="emphasis">P</i><sub><i class="emphasis">k</i>+1</sub> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i>}.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">The set <i class="emphasis">E</i><sub><i class="emphasis">q</i>-1</sub> consists of the values <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">q</i> - 1 for which <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P</i><sub><i class="emphasis">q</i>-1</sub> and for which <i class="emphasis">P</i><sub><i class="emphasis">k</i>+1</sub> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i>, because <i class="emphasis">P</i>[<i class="emphasis">k</i> + 1] = <i class="emphasis">P</i>[<i class="emphasis">q</i>]. Thus, <i class="emphasis">E</i><sub><i class="emphasis">q</i>-1</sub> consists of those values <i class="emphasis">k</i> <span class="unicode">&isin;</span> <span class="unicode">&pi;</span>*[<i class="emphasis">q</i> - 1] such that we can extend <i class="emphasis">P<sub>k</sub></i> to <i class="emphasis">P</i><sub><i class="emphasis">k</i>+1</sub> and get a proper suffix of <i class="emphasis">P<sub>q</sub></i>.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Corollary 32.7</span></span><a name="2893"></a><a name="ch32ex20"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">P</i> be a pattern of length <i class="emphasis">m</i>, and let <span class="unicode">&pi;</span> be the prefix function for <i class="emphasis">P</i>. For <i class="emphasis">q</i> = 2, 3, . . . , <i class="emphasis">m</i>,</p>
<p class="para">
<div class="informalequation">
<span class="equation-image"><img src="images/fig950_01.jpg" height="37" width="266" alt="" border="0"></span>
</div>
</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> If <i class="emphasis">E</i><sub><i class="emphasis">q</i>-1</sub> is empty, there is no <i class="emphasis">k</i> <span class="unicode">&isin;</span> <span class="unicode">&pi;</span>*[<i class="emphasis">q</i> - 1] (including <i class="emphasis">k</i> = 0) for which we can extend <i class="emphasis">P<sub>k</sub></i> to <i class="emphasis">P</i><sub><i class="emphasis">k</i>+1</sub> and get a proper suffix of <i class="emphasis">P<sub>q</sub></i>. Therefore <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] = 0.</p>
<p class="para">If <i class="emphasis">E</i><sub><i class="emphasis">q</i>-1</sub> is nonempty, then for each <i class="emphasis">k</i> <span class="unicode">&isin;</span> <i class="emphasis">E</i><sub><i class="emphasis">q</i>-1</sub> we have <i class="emphasis">k</i> + 1 <span class="unicode">&lt;</span> <i class="emphasis">q</i> and <i class="emphasis">P</i><sub><i class="emphasis">k</i>+1</sub> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i>. Therefore, from the definition of <span class="unicode">&pi;</span>[<i class="emphasis">q</i>], we have<a name="2894"></a><a name="IDX-929"></a>
</p>
<p class="para">
<div class="equation">
<a name="2895"></a><a name="ch32eq07"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(32.7)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig951_01.jpg" height="18" width="176" alt="" border="0"></span></td>
</tr>
</table>
</div>
</p>
<p class="para">Note that <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] <span class="unicode">&gt;</span> 0. Let <i class="emphasis">r</i> = <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] - 1, so that <i class="emphasis">r</i> + 1 = <span class="unicode">&pi;</span>[<i class="emphasis">q</i>]. Since <i class="emphasis">r</i> + 1 <span class="unicode">&gt;</span> 0, we have <i class="emphasis">P</i>[<i class="emphasis">r</i> + 1] = <i class="emphasis">P</i>[<i class="emphasis">q</i>]. Furthermore, by <a class="internaljump" href="#ch32ex19">Lemma 32.6</a>, we have <i class="emphasis">r</i> <span class="unicode">&isin;</span> <span class="unicode">&pi;</span>*[<i class="emphasis">q</i> - 1]. Therefore, <i class="emphasis">r</i> <span class="unicode">&isin;</span> <i class="emphasis">E</i><sub><i class="emphasis">q</i>-1</sub>, and so <i class="emphasis">r</i> <span class="unicode">&le;</span> max {<i class="emphasis">k</i> <span class="unicode">&isin;</span> <i class="emphasis">E</i><sub><i class="emphasis">q</i>-1</sub>} or, equivalently,</p>
<p class="para">
<div class="equation">
<a name="2896"></a><a name="ch32eq08"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(32.8)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig951_02.jpg" height="18" width="177" alt="" border="0"></span></td>
</tr>
</table>
</div>
</p>
<p class="last-para">Combining <a class="internaljump" href="#ch32eq07">equations (32.7)</a> and <a class="internaljump" href="#ch32eq08">(32.8)</a> completes the proof.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="last-para">We now finish the proof that COMPUTE-PREFIX-FUNCTION computes <span class="unicode">&pi;</span> correctly. In the procedure COMPUTE-PREFIX-FUNCTION, at the start of each iteration of the <b class="bold">for</b> loop of lines 4<span class="unicode">-</span>9, we have that <i class="emphasis">k</i> = <span class="unicode">&pi;</span>[<i class="emphasis">q</i> - 1]. This condition is enforced by lines 2 and 3 when the loop is first entered, and it remains true in each successive iteration because of line 9. Lines 5<span class="unicode">-</span>8 adjust <i class="emphasis">k</i> so that it now becomes the correct value of <span class="unicode">&pi;</span>[<i class="emphasis">q</i>]. The loop on lines 5<span class="unicode">-</span>6 searches through all values <i class="emphasis">k</i> <span class="unicode">&isin;</span> <span class="unicode">&pi;</span>*[<i class="emphasis">q</i> - 1] until one is found for which <i class="emphasis">P</i>[<i class="emphasis">k</i> + 1] = <i class="emphasis">P</i>[<i class="emphasis">q</i>]; at that point, <i class="emphasis">k</i> is the largest value in the set <i class="emphasis">E</i><sub><i class="emphasis">q</i>-1</sub>, so that, by <a class="internaljump" href="#ch32ex20">Corollary 32.7</a>, we can set <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] to <i class="emphasis">k</i> + 1. If no such <i class="emphasis">k</i> is found, <i class="emphasis">k</i> = 0 in line 7. If <i class="emphasis">P</i>[1] = <i class="emphasis">P</i>[<i class="emphasis">q</i>], then we should set both <i class="emphasis">k</i> and <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] to 1; otherwise we should leave <i class="emphasis">k</i> alone and set <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] to 0. Lines 7<span class="unicode">-</span>9 set <i class="emphasis">k</i> and <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] correctly in either case. This completes our proof of the correctness of COMPUTE-PREFIX-FUNCTION.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="2897"></a><a name="ch32lev3sec8"></a>Correctness of the KMP algorithm</h4>
<p class="first-para">The procedure KMP-MATCHER can be viewed as a reimplementation of the procedure FINITE-AUTOMATON-MATCHER. Specifically, we shall prove that the code in lines 6<span class="unicode">-</span>9 of KMP-MATCHER is equivalent to line 4 of FINITE-AUTOMATON-MATCHER, which sets <i class="emphasis">q</i> to <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">q</i>, <i class="emphasis">T</i>[<i class="emphasis">i</i>]). Instead of using a stored value of <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">q</i>, <i class="emphasis">T</i>[<i class="emphasis">i</i>]), however, this value is recomputed as necessary from <i class="emphasis">p</i>. Once we have argued that KMP-MATCHER simulates the behavior of FINITE-AUTOMATON-MATCHER, the correctness of KMP-MATCHER follows from the correctness of FINITE-AUTOMATON-MATCHER (though we shall see in a moment why line 12 in KMP-MATCHER is necessary).</p>
<p class="para">The correctness of KMP-MATCHER follows from the claim that we must have either <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">q</i>, <i class="emphasis">T</i>[<i class="emphasis">i</i>]) = 0 or <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">q</i>, <i class="emphasis">T</i>[<i class="emphasis">i</i>]) - 1 <span class="unicode">&isin;</span> <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>]. To check this claim, let <i class="emphasis">k</i> = <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">q</i>, <i class="emphasis">T</i>[<i class="emphasis">i</i>]). Then, <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub>T</i>[<i class="emphasis">i</i>] by the definitions of <i class="emphasis"><span class="unicode">&delta;</span></i> and <i class="emphasis"><span class="unicode">&sigma;</span></i>. Therefore, either <i class="emphasis">k</i> = 0 or else <i class="emphasis">k</i> <span class="unicode">&ge;</span> 1 and <i class="emphasis">P</i><sub><i class="emphasis">k</i>-1</sub> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i> by dropping the last character from both <i class="emphasis">P<sub>k</sub></i> and <i class="emphasis">P<sub>q</sub>T</i>[<i class="emphasis">i</i>] (in which case <i class="emphasis">k</i> - 1 <span class="unicode">&isin;</span> <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>]). Therefore, either <i class="emphasis">k</i> = 0 or <i class="emphasis">k</i> - 1 <span class="unicode">&isin;</span> <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>], proving the claim.</p>
<p class="para">The claim is used as follows. Let <i class="emphasis">q</i><span class="unicode">&prime;</span> denote the value of <i class="emphasis">q</i> when line 6 is entered. We use the equivalence <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>] = {<i class="emphasis">k</i> : <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">q</i> and <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i>} from <a class="internaljump" href="#ch32ex18">Lemma 32.5</a> to justify the iteration <i class="emphasis">q</i> <span class="unicode">&larr;</span> <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] that enumerates the elements of {<i class="emphasis">k</i> : <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P</i><sub><i class="emphasis">q</i></sub><span class="unicode"><sub><span class="unicode">&prime;</span></sub></span>}.<a name="2898"></a><a name="IDX-930"></a>
</p>
<p class="para">Lines 6<span class="unicode">-</span>9 determine <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">q</i><span class="unicode">&prime;</span>, <i class="emphasis">T</i>[<i class="emphasis">i</i>]) by examining the elements of <span class="unicode">&pi;</span>*[<i class="emphasis">q</i><span class="unicode">&prime;</span>] in decreasing order. The code uses the claim to begin with <i class="emphasis">q</i> = <i class="emphasis"><span class="unicode">&phi;</span></i>(<i class="emphasis">T</i><sub><i class="emphasis">i</i>-1</sub>) = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">T</i><sub><i class="emphasis">i</i>-1</sub>) and perform the iteration <i class="emphasis">q</i> <span class="unicode">&larr;</span> <span class="unicode">&pi;</span>[<i class="emphasis">q</i>] until a <i class="emphasis">q</i> is found such that <i class="emphasis">q</i> = 0 or <i class="emphasis">P</i>[<i class="emphasis">q</i> + 1] = <i class="emphasis">T</i>[<i class="emphasis">i</i>]. In the former case, <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">q</i><span class="unicode">&prime;</span>, <i class="emphasis">T</i>[<i class="emphasis">i</i>]) = 0; in the latter case, <i class="emphasis">q</i> is the maximum element in <i class="emphasis">E</i><sub><i class="emphasis">q</i></sub><span class="unicode"><sub><span class="unicode">&prime;</span></sub></span>, so that <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">q</i><span class="unicode">&prime;</span>, <i class="emphasis">T</i>[<i class="emphasis">i</i>]) = <i class="emphasis">q</i> + 1 by <a class="internaljump" href="#ch32ex20">Corollary 32.7</a>.</p>
<p class="para">Line 12 is necessary in KMP-MATCHER to avoid a possible reference to <i class="emphasis">P</i>[<i class="emphasis">m</i> + 1] on line 6 after an occurrence of <i class="emphasis">P</i> has been found. (The argument that <i class="emphasis">q</i> = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">T</i><sub><i class="emphasis">i</i>-1</sub>) upon the next execution of line 6 remains valid by the hint given in <a class="internaljump" href="#ch32ex26">Exercise 32.4-6</a>: <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">m</i>, <i class="emphasis">a</i>) = <i class="emphasis"><span class="unicode">&delta;</span></i>(<span class="unicode">&pi;</span>[<i class="emphasis">m</i>], <i class="emphasis">a</i>) or, equivalently, <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">Pa</i>) = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">P</i><sub><span class="unicode">&pi;</span>[<i class="emphasis">m</i>]</sub><i class="emphasis">a</i>) for any <i class="emphasis">a</i> <span class="unicode">&isin;</span> <span class="unicode">&Sigma;</span>.) The remaining argument for the correctness of the Knuth-Morris-Pratt algorithm follows from the correctness of FINITE-AUTOMATON-MATCHER, since we now see that KMP-MATCHER simulates the behavior of FINITE-AUTOMATON-MATCHER.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 32.4-1</span></span><a name="2899"></a><a name="ch32ex21"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Compute the prefix function <span class="unicode">&pi;</span> for the pattern <span class="fixed">ababbabbabbababbabb</span> when the alphabet is <span class="unicode">&Sigma;</span> = {<span class="fixed">a</span>, <span class="fixed">b</span>}.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 32.4-2</span></span><a name="2900"></a><a name="ch32ex22"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Give an upper bound on the size of <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>] as a function of <i class="emphasis">q</i>. Give an example to show that your bound is tight.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 32.4-3</span></span><a name="2901"></a><a name="ch32ex23"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Explain how to determine the occurrences of pattern <i class="emphasis">P</i> in the text <i class="emphasis">T</i> by examining the <span class="unicode">&pi;</span> function for the string <i class="emphasis">PT</i> (the string of length <i class="emphasis">m</i> + <i class="emphasis">n</i> that is the concatenation of <i class="emphasis">P</i> and <i class="emphasis">T</i>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 32.4-4</span></span><a name="2902"></a><a name="ch32ex24"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show how to improve KMP-MATCHER by replacing the occurrence of <span class="unicode">&pi;</span> in line 7 (but not line 12) by <span class="unicode">&pi;</span><span class="unicode">&prime;</span>, where <span class="unicode">&pi;</span><span class="unicode">&prime;</span> is defined recursively for <i class="emphasis">q</i> = 1, 2, . . . , <i class="emphasis">m</i> by the equation</p>
<p class="para">
<div class="informalequation">
<span class="equation-image"><a href="images/fig952%5F01%2Ejpg" NAME="IMG_1707" target="_parent"><img src="images/fig952_01.jpg" height="56" width="400" alt="Click To expand" border="0"></a></span>
</div>
</p>
<p class="last-para">Explain why the modified algorithm is correct, and explain in what sense this modification constitutes an improvement.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 32.4-5</span></span><a name="2903"></a><a name="ch32ex25"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Give a linear-time algorithm to determine if a text <i class="emphasis">T</i> is a cyclic rotation of another string <i class="emphasis">T</i><span class="unicode">&prime;</span>. For example, <span class="fixed">arc</span> and <span class="fixed">car</span> are cyclic rotations of each other.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="2904"></a><a name="IDX-931"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 32.4-6: </span><span class="unicode">&#9733;</span></span><a name="2905"></a><a name="ch32ex26"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Give an efficient algorithm for computing the transition function <i class="emphasis"><span class="unicode">&delta;</span></i> for the string-matching automaton corresponding to a given pattern <i class="emphasis">P</i>. Your algorithm should run in time <i class="emphasis">O</i>(<i class="emphasis">m</i> |<span class="unicode">&Sigma;</span>|). (<i class="emphasis">Hint:</i> Prove that <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">q</i>, <i class="emphasis">a</i>) = <i class="emphasis"><span class="unicode">&delta;</span></i>(<span class="unicode">&pi;</span>[<i class="emphasis">q</i>], <i class="emphasis">a</i>) if <i class="emphasis">q</i> = <i class="emphasis">m</i> or <i class="emphasis">P</i>[<i class="emphasis">q</i> + 1] <span class="unicode">&ne;</span> <i class="emphasis">a</i>.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 32-1: </span>String matching based on repetition factors</span><a name="2906"></a><a name="ch32ex27"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">y<sup>i</sup></i> denote the concatenation of string <i class="emphasis">y</i> with itself <i class="emphasis">i</i> times. For example, (<span class="fixed">ab</span>)<sup>3</sup> = <span class="fixed">ababab</span>. We say that a string <i class="emphasis">x</i> <span class="unicode">&isin;</span> <span class="unicode">&Sigma;</span>* has <b class="bold"><i class="emphasis">repetition factor</i></b> <i class="emphasis">r</i> if <i class="emphasis">x</i> = <i class="emphasis">y<sup>r</sup></i> for some string <i class="emphasis">y</i> <span class="unicode">&isin;</span> <span class="unicode">&Sigma;</span>* and some <i class="emphasis">r</i> <span class="unicode">&gt;</span> 0. Let <i class="emphasis"><span class="unicode">&rho;</span></i>(<i class="emphasis">x</i>) denote the largest <i class="emphasis">r</i> such that <i class="emphasis">x</i> has repetition factor <i class="emphasis">r</i>.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Give an efficient algorithm that takes as input a pattern <i class="emphasis">P</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">m</i>] and computes the value <i class="emphasis"><span class="unicode">&rho;</span></i>(<i class="emphasis">P<sub>i</sub></i>) for <i class="emphasis">i</i> = 1, 2, . . . , <i class="emphasis">m</i>. What is the running time of your algorithm?</p>
</li>
<li class="listitem">
<p class="first-para">For any pattern <i class="emphasis">P</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">m</i>], let <i class="emphasis"><span class="unicode">&rho;</span></i>*(<i class="emphasis">P</i>) be defined as max<sub><span class="unicode">&le;</span><i class="emphasis">i</i><span class="unicode">&le;</span><i class="emphasis">m</i></sub> <i class="emphasis"><span class="unicode">&rho;</span></i>(<i class="emphasis">P<sub>i</sub></i>). Prove that if the pattern <i class="emphasis">P</i> is chosen randomly from the set of all binary strings of length <i class="emphasis">m</i>, then the expected value of <i class="emphasis"><span class="unicode">&rho;</span></i>*(<i class="emphasis">P</i>) is <i class="emphasis">O</i>(1).</p>
</li>
<li class="listitem">
<p class="first-para">Argue that the following string-matching algorithm correctly finds all occurrences of pattern <i class="emphasis">P</i> in a text <i class="emphasis">T</i>[1 <span class="unicode">&#8229;</span> <i class="emphasis">n</i>] in time <i class="emphasis">O</i>(<i class="emphasis"><span class="unicode">&rho;</span></i>*(<i class="emphasis">P</i>)<i class="emphasis">n</i> + <i class="emphasis">m</i>).</p>
<pre class="literallayout-normal">
REPETITION-MATCHER(<i class="emphasis">P</i>, <i class="emphasis">T</i>)
 1  <i class="emphasis">m</i> <span class="unicode">&larr;</span> <i class="emphasis">length</i>[<i class="emphasis">P</i>]
 2  <i class="emphasis">n</i> <span class="unicode">&larr;</span> <i class="emphasis">length</i>[<i class="emphasis">T</i>]
 3  <i class="emphasis">k</i> <span class="unicode">&larr;</span> 1 + <i class="emphasis"><span class="unicode">&rho;</span></i>*(<i class="emphasis">P</i>)
 4  <i class="emphasis">q</i> <span class="unicode">&larr;</span> 0
 5  <i class="emphasis">s</i> <span class="unicode">&larr;</span> 0
 6  <b class="bold">while</b> <i class="emphasis">s</i> <span class="unicode">&le;</span> <i class="emphasis">n</i> - <i class="emphasis">m</i>
 7      <b class="bold">do if</b> <i class="emphasis">T</i>[<i class="emphasis">s</i> + <i class="emphasis">q</i> + 1] = <i class="emphasis">P</i>[<i class="emphasis">q</i> + 1]
 8            <b class="bold">then</b> <i class="emphasis">q</i> <span class="unicode">&larr;</span> <i class="emphasis">q</i> + 1
 9                 <b class="bold">if</b> <i class="emphasis">q</i> = <i class="emphasis">m</i>
10                    <b class="bold">then</b> print "Pattern occurs with shift" <i class="emphasis">s</i>
11         <b class="bold">if</b> <i class="emphasis">q</i> = <i class="emphasis">m</i> or <i class="emphasis">T</i>[<i class="emphasis">s</i> + <i class="emphasis">q</i> + 1] <span class="unicode">&ne;</span> <i class="emphasis">P</i>[<i class="emphasis">q</i> + 1]
12            <b class="bold">then</b> <i class="emphasis">s</i> <span class="unicode">&larr;</span> <i class="emphasis">s</i> + max(1, <span class="unicode">&lceil;</span><i class="emphasis">q</i>/<i class="emphasis">k</i><span class="unicode">&rceil;</span>)
13                 <i class="emphasis">q</i> <span class="unicode">&larr;</span> 0
</pre>
<a name="2907"></a><a name="IDX-932"></a>
<p class="last-para">This algorithm is due to Galil and Seiferas. By extending these ideas greatly, they obtain a linear-time string-matching algorithm that uses only <i class="emphasis">O</i>(1) storage beyond what is required for <i class="emphasis">P</i> and <i class="emphasis">T</i>.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0214.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0216.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
