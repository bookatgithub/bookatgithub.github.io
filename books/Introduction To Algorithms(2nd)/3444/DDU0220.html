<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>33.3 Finding the convex hull</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0219.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0221.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch33"></a>
<div class="section">
<h2 class="first-section-title">
<a name="2959"></a><a name="ch33lev1sec3"></a><span class="section-titlelabel">33.3 </span>Finding the convex hull</h2>
<p class="first-para">The <b class="bold"><i class="emphasis">convex hull</i></b> of a set <i class="emphasis">Q</i> of points is the smallest convex polygon <i class="emphasis">P</i> for which each point in <i class="emphasis">Q</i> is either on the boundary of <i class="emphasis">P</i> or in its interior. (See <a href="DDU0218.html#2930" target="_parent" class="chapterjump">Exercise 33.1-5</a> for a precise definition of a convex polygon.) We denote the convex hull of <i class="emphasis">Q</i> by CH(<i class="emphasis">Q</i>). Intuitively, we can think of each point in <i class="emphasis">Q</i> as being a nail sticking out from a board. The convex hull is then the shape formed by a tight rubber band that surrounds all the nails. <a class="internaljump" href="#ch33fig06">Figure 33.6</a> shows a set of points and its convex hull.</p>
<div class="figure">
<a name="2960"></a><a name="ch33fig06"></a><span class="figuremediaobject"><a href="images/fig970%5F01%5F0%2Ejpg" NAME="IMG_1773" target="_parent"><img src="images/fig970_01.jpg" height="148" width="225" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 33.6: </span>A set of points <i class="emphasis">Q</i> = {<i class="emphasis">p</i><sub>0</sub>, <i class="emphasis">p</i><sub>1</sub>, ..., <i class="emphasis">p</i><sub>12</sub>} with its convex hull CH(<i class="emphasis">Q</i>) in gray.</span>
</div>
<p class="para">In this section, we shall present two algorithms that compute the convex hull of a set of <i class="emphasis">n</i> points. Both algorithms output the vertices of the convex hull in counterclockwise order. The first, known as Graham's scan, runs in <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) time. The second, called Jarvis's march, runs in <i class="emphasis">O</i>(<i class="emphasis">nh</i>) time, where <i class="emphasis">h</i> is the number of vertices of the convex hull. As can be seen from <a class="internaljump" href="#ch33fig06">Figure 33.6</a>, every vertex of CH(<i class="emphasis">Q</i>) is a point in <i class="emphasis">Q</i>. Both algorithms exploit this property, deciding which vertices in <i class="emphasis">Q</i> to keep as vertices of the convex hull and which vertices in <i class="emphasis">Q</i> to throw out.</p>
<p class="para">There are, in fact, several methods that compute convex hulls in <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) time. Both Graham's scan and Jarvis's march use a technique called "rotational sweep," processing vertices in the order of the polar angles they form with a reference vertex. Other methods include the following.<a name="2961"></a><a name="IDX-948"></a>
</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">In the <b class="bold"><i class="emphasis">incremental method</i></b>, the points are sorted from left to right, yielding a sequence <span class="unicode">&#12296;</span><i class="emphasis">p</i><sub>1</sub>, <i class="emphasis">p</i><sub>2</sub>, ..., <i class="emphasis">p<sub>n</sub></i><span class="unicode">&#12297;</span>. At the <i class="emphasis">i</i>th stage, the convex hull of the <i class="emphasis">i</i> - 1 leftmost points, CH({<i class="emphasis">p</i><sub>1</sub>, <i class="emphasis">p</i><sub>2</sub>, ..., <i class="emphasis">p</i><sub><i class="emphasis">i</i>-1</sub>}), is updated according to the <i class="emphasis">i</i>th point from the left, thus forming CH({<i class="emphasis">p</i><sub>1</sub>, <i class="emphasis">p</i><sub>2</sub>, ..., <i class="emphasis">p<sub>i</sub></i>}). As <a class="internaljump" href="#ch33ex24">Exercise 33.3-6</a> asks you to show, this method can be implemented to take a total of <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) time.</p>
</li>
<li class="listitem">
<p class="first-para">In the <b class="bold"><i class="emphasis">divide-and-conquer method</i></b>, in <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) time the set of <i class="emphasis">n</i> points is divided into two subsets, one containing the leftmost <span class="unicode">&lceil;</span><i class="emphasis">n</i>/2<span class="unicode">&rceil;</span> points and one containing the rightmost <span class="unicode">&lfloor;</span><i class="emphasis">n</i>/2<span class="unicode">&rfloor;</span> points, the convex hulls of the subsets are computed recursively, and then a clever method is used to combine the hulls in <i class="emphasis">O</i>(<i class="emphasis">n</i>) time. The running time is described by the familiar recurrence <i class="emphasis">T</i>(<i class="emphasis">n</i>) = 2<i class="emphasis">T</i>(<i class="emphasis">n</i>/2) + <i class="emphasis">O</i>(<i class="emphasis">n</i>), and so the divide-and-conquer method runs in <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) time.</p>
</li>
<li class="listitem">
<p class="first-para">The <b class="bold"><i class="emphasis">prune-and-search method</i></b> is similar to the worst-case linear-time median algorithm of <a href="DDU0055.html#592" target="_parent" class="chapterjump">Section 9.3</a>. It finds the upper portion (or "upper chain") of the convex hull by repeatedly throwing out a constant fraction of the remaining points until only the upper chain of the convex hull remains. It then does the same for the lower chain. This method is asymptotically the fastest: if the convex hull contains <i class="emphasis">h</i> vertices, it runs in only <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">h</i>) time.</p>
</li>
</ul>
<p class="para">Computing the convex hull of a set of points is an interesting problem in its own right. Moreover, algorithms for some other computational-geometry problems start by computing a convex hull. Consider, for example, the two-dimensional <b class="bold"><i class="emphasis">farthest-pair problem</i></b>: we are given a set of <i class="emphasis">n</i> points in the plane and wish to find the two points whose distance from each other is maximum. As <a class="internaljump" href="#ch33ex21">Exercise 33.3-3</a> asks you to prove, these two points must be vertices of the convex hull. Although we won't prove it here, the farthest pair of vertices of an <i class="emphasis">n</i>-vertex convex polygon can be found in <i class="emphasis">O</i>(<i class="emphasis">n</i>) time. Thus, by computing the convex hull of the <i class="emphasis">n</i> input points in <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) time and then finding the farthest pair of the resulting convex-polygon <a name="2962"></a><a name="IDX-949"></a>vertices, we can find the farthest pair of points in any set of <i class="emphasis">n</i> points in <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) time.</p>
<div class="section">
<h4 class="sect4-title">
<a name="2963"></a><a name="ch33lev3sec10"></a>Graham's scan</h4>
<p class="first-para">
<b class="bold"><i class="emphasis">Graham's scan</i></b> solves the convex-hull problem by maintaining a stack <i class="emphasis">S</i> of candidate points. Each point of the input set <i class="emphasis">Q</i> is pushed once onto the stack, and the points that are not vertices of CH(<i class="emphasis">Q</i>) are eventually popped from the stack. When the algorithm terminates, stack <i class="emphasis">S</i> contains exactly the vertices of CH(<i class="emphasis">Q</i>), in counterclockwise order of their appearance on the boundary.</p>
<p class="para">The procedure GRAHAM-SCAN takes as input a set <i class="emphasis">Q</i> of points, where |<i class="emphasis">Q</i>| <span class="unicode">&ge;</span> 3. It calls the functions TOP(<i class="emphasis">S</i>), which returns the point on top of stack <i class="emphasis">S</i> without changing <i class="emphasis">S</i>, and NEXT-TO-TOP(<i class="emphasis">S</i>), which returns the point one entry below the top of stack <i class="emphasis">S</i> without changing <i class="emphasis">S</i>. As we shall prove in a moment, the stack <i class="emphasis">S</i> returned by GRAHAM-SCAN contains, from bottom to top, exactly the vertices of CH(<i class="emphasis">Q</i>) in counterclockwise order.</p>
<div class="informalexample">
<pre class="literallayout-normal">
GRAHAM-SCAN(<i class="emphasis">Q</i>)
 1  let <i class="emphasis">p</i><sub>0</sub> be the point in <i class="emphasis">Q</i> with the minimum <i class="emphasis">y</i>-coordinate,
             or the leftmost such point in case of a tie
 2  let <span class="unicode">&#12296;</span><i class="emphasis">p</i><sub>1</sub>, <i class="emphasis">p</i><sub>2</sub>, ..., <i class="emphasis">p<sub>m</sub></i><span class="unicode">&#12297;</span> be the remaining points in <i class="emphasis">Q</i>,
             sorted by polar angle in counterclockwise order around <i class="emphasis">p</i><sub>0</sub>
             (if more than one point has the same angle, remove all but
             the one that is farthest from <i class="emphasis">p</i><sub>0</sub>)
 3  PUSH(<i class="emphasis">p</i><sub>0</sub>, <i class="emphasis">S</i>)
 4  PUSH(<i class="emphasis">p</i><sub>1</sub>, <i class="emphasis">S</i>)
 5  PUSH(<i class="emphasis">p</i><sub>2</sub>, <i class="emphasis">S</i>)
 6  <b class="bold">for</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> 3 <b class="bold">to</b> <i class="emphasis">m</i>
 7       <b class="bold">do while</b> the angle formed by points NEXT-TO-TOP(<i class="emphasis">S</i>), TOP(<i class="emphasis">S</i>),
                     and <i class="emphasis">p<sub>i</sub></i> makes a nonleft turn
 8              <b class="bold">do</b> POP(<i class="emphasis">S</i>)
 9          PUSH(<i class="emphasis">p<sub>i</sub>, S</i>)
10  <b class="bold">return</b> <i class="emphasis">S</i>
</pre>
</div>
<p class="para">
<a class="internaljump" href="#ch33fig07">Figure 33.7</a> illustrates the progress of GRAHAM-SCAN. Line 1 chooses point <i class="emphasis">p</i><sub>0</sub> as the point with the lowest <i class="emphasis">y</i>-coordinate, picking the leftmost such point in case of a tie. Since there is no point in <i class="emphasis">Q</i> that is below <i class="emphasis">p</i><sub>0</sub> and any other points with the same <i class="emphasis">y</i>-coordinate are to its right, <i class="emphasis">p</i><sub>0</sub> is a vertex of CH(<i class="emphasis">Q</i>). Line 2 sorts the remaining points of <i class="emphasis">Q</i> by polar angle relative to <i class="emphasis">p</i><sub>0</sub>, using the same method<span class="unicode">-</span>comparing cross products<span class="unicode">-</span>as in <a href="DDU0218.html#2928" target="_parent" class="chapterjump">Exercise 33.1-3</a>. If two or more points have the same polar angle relative to <i class="emphasis">p</i><sub>0</sub>, all but the farthest such point are convex combinations of <i class="emphasis">p</i><sub>0</sub> and the farthest point, and so we remove them entirely from consideration. <a name="2964"></a><a name="IDX-950"></a><a name="2965"></a><a name="IDX-951"></a><a name="2966"></a><a name="IDX-952"></a>We let <i class="emphasis">m</i> denote the number of points other than <i class="emphasis">p</i><sub>0</sub> that remain. The polar angle, measured in radians, of each point in <i class="emphasis">Q</i> relative to <i class="emphasis">p</i><sub>0</sub> is in the half-open interval [0, <span class="unicode">&pi;</span>). Since the points are sorted according to polar angles, they are sorted in counterclockwise order relative to <i class="emphasis">p</i><sub>0</sub>. We designate this sorted sequence of points by <span class="unicode">&#12296;</span><i class="emphasis">p</i><sub>1</sub>, <i class="emphasis">p</i><sub>2</sub>, ..., <i class="emphasis">p<sub>m</sub></i><span class="unicode">&#12297;</span>. Note that points <i class="emphasis">p</i><sub>1</sub> and <i class="emphasis">p<sub>m</sub></i> are vertices of CH(<i class="emphasis">Q</i>) (see <a class="internaljump" href="#ch33ex19">Exercise 33.3-1</a>). <a class="internaljump" href="#ch33fig07">Figure 33.7(a)</a> shows the points of <a class="internaljump" href="#ch33fig06">Figure 33.6</a> sequentially numbered in order of increasing polar angle relative to <i class="emphasis">p</i><sub>0</sub>.</p>
<div class="figure">
<a name="2967"></a><a name="ch33fig07"></a><span class="figuremediaobject"><a href="images/fig972%5F01%5F0%2Ejpg" NAME="IMG_1774" target="_parent"><img src="images/fig972_01.jpg" height="373" width="350" alt="Click To expand" border="0"></a></span><span class="figurespace">&nbsp;</span><span class="figuremediaobject"><a href="images/fig973%5F01%5F0%2Ejpg" NAME="IMG_1775" target="_parent"><img src="images/fig973_01.jpg" height="375" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 33.7: </span>The execution of GRAHAM-SCAN on the set <i class="emphasis">Q</i> of Figure 33.6. The current convex hull contained in stack <i class="emphasis">S</i> is shown in gray at each step. <i class="emphasis">(a)</i> The sequence <span class="unicode">&#12296;</span> <i class="emphasis">p</i><sub>1</sub>, <i class="emphasis">p</i><sub>2</sub>, ..., <i class="emphasis">p</i><sub>12</sub><span class="unicode">&#12297;</span> of points numbered in order of increasing polar angle relative to <i class="emphasis">p</i><sub>0</sub>, and the initial stack <i class="emphasis">S</i> containing <i class="emphasis">p</i><sub>0</sub>, <i class="emphasis">p</i><sub>1</sub>, and <i class="emphasis">p</i><sub>2</sub>. <i class="emphasis">(b)<span class="unicode">-</span>(k)</i> Stack <i class="emphasis">S</i> after each iteration of the <i class="emphasis">for</i> loop of lines 6<span class="unicode">-</span>9. Dashed lines show nonleft turns, which cause points to be popped from the stack. In part (h), for example, the right turn at angle <span class="unicode">&ang;</span><i class="emphasis">p</i><sub>7</sub><i class="emphasis">p</i><sub>8</sub><i class="emphasis">p</i><sub>9</sub> causes <i class="emphasis">p</i><sub>8</sub> to be popped, and then the right turn at angle <span class="unicode">&ang;</span><i class="emphasis">p</i><sub>6</sub><i class="emphasis">p</i><sub>7</sub><i class="emphasis">p</i><sub>9</sub> causes <i class="emphasis">p</i><sub>7</sub> to be popped. <i class="emphasis">(l)</i> The convex hull returned by the procedure, which matches that of Figure 33.6.</span>
</div>
<p class="para">The remainder of the procedure uses the stack <i class="emphasis">S</i>. Lines 3<span class="unicode">-</span>5 initialize the stack to contain, from bottom to top, the first three points <i class="emphasis">p</i><sub>0</sub>, <i class="emphasis">p</i><sub>1</sub>, and <i class="emphasis">p</i><sub>2</sub>. <a class="internaljump" href="#ch33fig07">Figure 33.7(a)</a> shows the initial stack <i class="emphasis">S</i>. The <b class="bold">for</b> loop of lines 6<span class="unicode">-</span>9 iterates once for each point in the subsequence <span class="unicode">&#12296;</span><i class="emphasis">p</i><sub>3</sub>, <i class="emphasis">p</i><sub>4</sub>, ..., <i class="emphasis">p<sub>m</sub></i><span class="unicode">&#12297;</span>. The intent is that after processing point <i class="emphasis">p<sub>i</sub></i> , stack <i class="emphasis">S</i> contains, from bottom to top, the vertices of CH({ <i class="emphasis">p</i><sub>0</sub>, <i class="emphasis">p</i><sub>1</sub>, ..., <i class="emphasis">p<sub>i</sub></i>}) in counterclockwise order. The <b class="bold">while</b> loop of lines 7<span class="unicode">-</span>8 removes points from the stack if they are found not to be vertices of the convex hull. When we traverse the convex hull counterclockwise, we should make a left turn at each vertex. Thus, each time the <b class="bold">while</b> loop finds a vertex at which we make a nonleft turn, the vertex is popped from the stack. (By checking for a nonleft turn, rather than just a right turn, this test precludes the possibility of a straight angle at a vertex of the resulting convex hull. We want no straight angles, since no vertex of a convex polygon may be a convex combination of other vertices of the polygon.) After we pop all vertices that have nonleft turns when heading toward point <i class="emphasis">p<sub>i</sub></i> , we push <i class="emphasis">p<sub>i</sub></i> onto the stack. <a class="internaljump" href="#ch33fig07">Figures 33.7(b)<span class="unicode">-</span>(k)</a> show the state of the stack <i class="emphasis">S</i> after each iteration of the <b class="bold">for</b> loop. Finally, GRAHAM-SCAN returns the stack <i class="emphasis">S</i> in line 10. <a class="internaljump" href="#ch33fig07">Figure 33.7(l)</a> shows the corresponding convex hull.</p>
<p class="para">The following theorem formally proves the correctness of GRAHAM-SCAN.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 33.1: </span>(Correctness of Graham's scan)</span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">If GRAHAM-SCAN is run on a set <i class="emphasis">Q</i> of points, where |<i class="emphasis">Q</i>| <span class="unicode">&ge;</span> 3, then at termination, the stack <i class="emphasis">S</i> consists of, from bottom to top, exactly the vertices of CH<i class="emphasis">(</i><i class="emphasis">Q</i><i class="emphasis">)</i> in counterclockwise order.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> After line 2, we have the sequence of points <span class="unicode">&#12296;</span><i class="emphasis">p</i><sub>1</sub>, <i class="emphasis">p</i><sub>2</sub>, ..., <i class="emphasis">p<sub>m</sub></i><span class="unicode">&#12297;</span>. Let us define, for <i class="emphasis">i</i> = 2, 3, ..., <i class="emphasis">m</i>, the subset of points <i class="emphasis">Q<sub>i</sub></i> = {<i class="emphasis">p</i><sub>0</sub>, <i class="emphasis">p</i><sub>1</sub>, ..., <i class="emphasis">p<sub>i</sub></i>}. The points in <i class="emphasis">Q</i> - <i class="emphasis">Q<sub>m</sub></i> are those that were removed because they had the same polar angle relative to <i class="emphasis">p</i><sub>0</sub> as some point in <i class="emphasis">Q<sub>m</sub></i>; these points are not in CH(<i class="emphasis">Q</i>), and so CH(<i class="emphasis">Q<sub>m</sub></i>) = CH(<i class="emphasis">Q</i>). Thus, it suffices to show that when GRAHAM-SCAN terminates, the stack <i class="emphasis">S</i> consists of the vertices of CH(<i class="emphasis">Q<sub>m</sub></i>) in counterclockwise order from bottom to top. Note that just as <i class="emphasis">p</i><sub>0</sub>, <i class="emphasis">p</i><sub>1</sub>, and <i class="emphasis">p<sub>m</sub></i> are vertices of CH(<i class="emphasis">Q</i>), the points <i class="emphasis">p</i><sub>0</sub>, <i class="emphasis">p</i><sub>1</sub>, and <i class="emphasis">p<sub>i</sub></i> are all vertices of CH(<i class="emphasis">Q<sub>i</sub></i>).<a name="2968"></a><a name="IDX-953"></a>
</p>
<p class="para">
</p>
<p class="para">The proof uses the following loop invariant:</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="first-para">At the start of each iteration of the <b class="bold">for</b> loop of lines 6<span class="unicode">-</span>9, stack <i class="emphasis">S</i> consists of, from bottom to top, exactly the vertices of CH(<i class="emphasis">Q</i><sub><i class="emphasis">i</i>-1</sub>) in counterclockwise order.</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">Initialization:</b> The invariant holds the first time we execute line 6, since at that time, stack <i class="emphasis">S</i> consists of exactly the vertices of <i class="emphasis">Q</i><sub>2</sub> = <i class="emphasis">Q</i><sub><i class="emphasis">i</i>-1</sub>, and this set of three vertices forms its own convex hull. Moreover, they appear in counterclockwise order from bottom to top.</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">Maintenance:</b> Entering an iteration of the <b class="bold">for</b> loop, the top point on stack <i class="emphasis">S</i> is <i class="emphasis">p</i><sub><i class="emphasis">i</i>-1</sub>, which was pushed at the end of the previous iteration (or before the first iteration, when <i class="emphasis">i</i> = 3). Let <i class="emphasis">p<sub>j</sub></i> be the top point on <i class="emphasis">S</i> after the while loop of lines 7<span class="unicode">-</span>8 is executed but before line 9 pushes <i class="emphasis">p<sub>i</sub></i>, and let <i class="emphasis">p<sub>k</sub></i> be the point just below <i class="emphasis">p<sub>j</sub></i> on <i class="emphasis">S</i>. At the moment that <i class="emphasis">p<sub>j</sub></i> is the top point on <i class="emphasis">S</i> and we have not yet pushed <i class="emphasis">p<sub>i</sub></i>, stack <i class="emphasis">S</i> contains exactly the same points it contained after iteration <i class="emphasis">j</i> of the <b class="bold">for</b> loop. By the loop invariant, therefore, <i class="emphasis">S</i> contains exactly the vertices of CH(<i class="emphasis">Q<sub>j</sub></i>) at that moment, and they appear in counterclockwise order from bottom to top.</p>
<p class="para">Let us continue to focus on this moment just before <i class="emphasis">p<sub>i</sub></i> is pushed. Referring to <a class="internaljump" href="#ch33fig08">Figure 33.8(a)</a>, because <i class="emphasis">p<sub>i</sub></i>'s polar angle relative to <i class="emphasis">p</i><sub>0</sub> is greater than <i class="emphasis">p<sub>j</sub></i>'s polar angle, and because the angle <span class="unicode">&ang;</span><i class="emphasis">p<sub>k</sub></i><i class="emphasis">p<sub>j</sub></i><i class="emphasis">p<sub>i</sub></i> makes a left turn (otherwise we would have popped <i class="emphasis">p<sub>j</sub></i> ), we see that since <i class="emphasis">S</i> contains exactly the vertices of CH(<i class="emphasis">Q<sub>j</sub></i>), <a name="2969"></a><a name="IDX-954"></a>once we push <i class="emphasis">p<sub>i</sub></i> , stack <i class="emphasis">S</i> will contain exactly the vertices of CH(<i class="emphasis">Q<sub>j</sub></i> <span class="unicode">&cup;</span> {<i class="emphasis">p<sub>i</sub></i>}), still in counterclockwise order from bottom to top.</p>
<p class="figure">
<a name="2970"></a><a name="ch33fig08"></a><span class="figuremediaobject"><a href="images/fig975%5F01%5F0%2Ejpg" NAME="IMG_1776" target="_parent"><img src="images/fig975_01.jpg" height="129" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 33.8: </span>The proof of correctness of GRAHAM-SCAN. <i class="emphasis">(a)</i> Because <i class="emphasis">p<sub>i</sub></i>'s polar angle relative to <i class="emphasis">p</i><sub>0</sub> is greater than <i class="emphasis">p<sub>j</sub></i>'s polar angle, and because the angle <span class="unicode">&ang;</span><i class="emphasis">p<sub>k</sub>p<sub>j</sub> p<sub>i</sub></i> makes a left turn, adding <i class="emphasis">p<sub>i</sub></i> to CH(<i class="emphasis">Q<sub>j</sub></i>) gives exactly the vertices of CH(<i class="emphasis">Q<sub>j</sub></i> <span class="unicode">&cup;</span>{<i class="emphasis">p<sub>i</sub></i>}). <i class="emphasis">(b)</i> If the angle <span class="unicode">&ang;</span><i class="emphasis">p<sub>r</sub>p<sub>t</sub>p<sub>i</sub></i> makes a nonleft turn, then <i class="emphasis">p<sub>t</sub></i> is either in the interior of the triangle formed by <i class="emphasis">p</i><sub>0</sub>, <i class="emphasis">p<sub>r</sub></i>, and <i class="emphasis">p<sub>i</sub></i> or on a side of the triangle, and it cannot be a vertex of CH(<i class="emphasis">Q<sub>i</sub></i>).</span>
</p>
<p class="para">We now show that CH(<i class="emphasis">Q<sub>j</sub></i> <span class="unicode">&cup;</span> {<i class="emphasis">p<sub>i</sub></i>}) is the same set of points as CH(<i class="emphasis">Q<sub>i</sub></i>). Consider any point <i class="emphasis">p<sub>t</sub></i> that was popped during iteration <i class="emphasis">i</i> of the <b class="bold">for</b> loop, and let <i class="emphasis">p<sub>r</sub></i> be the point just below <i class="emphasis">p<sub>t</sub></i> on stack <i class="emphasis">S</i> at the time <i class="emphasis">p<sub>t</sub></i> was popped (<i class="emphasis">p<sub>r</sub></i> might be <i class="emphasis">p<sub>j</sub></i> ). The angle <span class="unicode">&ang;</span><i class="emphasis">p<sub>r</sub></i><i class="emphasis">p<sub>t</sub></i><i class="emphasis">p<sub>i</sub></i> makes a nonleft turn, and the polar angle of <i class="emphasis">p<sub>t</sub></i> relative to <i class="emphasis">p</i><sub>0</sub> is greater than the polar angle of <i class="emphasis">p<sub>r</sub></i>. As <a class="internaljump" href="#ch33fig08">Figure 33.8(b)</a> shows, <i class="emphasis">p<sub>t</sub></i> must be either in the interior of the triangle formed by <i class="emphasis">p</i><sub>0</sub>, <i class="emphasis">p<sub>r</sub></i>, and <i class="emphasis">p<sub>i</sub></i> or on a side of this triangle (but it is not a vertex of the triangle). Clearly, since <i class="emphasis">p<sub>t</sub></i> is within a triangle formed by three other points of <i class="emphasis">Q<sub>i</sub></i>, it cannot be a vertex of CH(<i class="emphasis">Q<sub>i</sub></i>). Since <i class="emphasis">p<sub>t</sub></i> is not a vertex of CH(<i class="emphasis">Q<sub>i</sub></i>), we have that</p>
<div class="equation">
<a name="2971"></a><a name="ch33eq01"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(33.1)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig976_01.jpg" height="16" width="165" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">Let <i class="emphasis">P<sub>i</sub></i> be the set of points that were popped during iteration <i class="emphasis">i</i> of the <b class="bold">for</b> loop. Since the equality (<a class="internaljump" href="#ch33eq01">33.1</a>) applies for all points in <i class="emphasis">P<sub>i</sub></i>, we can apply it repeatedly to show that CH(<i class="emphasis">Q<sub>i</sub></i> - <i class="emphasis">P<sub>i</sub></i>) = CH(<i class="emphasis">Q<sub>i</sub></i>). But <i class="emphasis">Q<sub>i</sub></i> - <i class="emphasis">P<sub>i</sub></i> = <i class="emphasis">Q<sub>j</sub></i> <span class="unicode">&cup;</span> {<i class="emphasis">p<sub>i</sub></i>}, and so we conclude that CH(<i class="emphasis">Q<sub>j</sub></i> <span class="unicode">&cup;</span> {<i class="emphasis">p<sub>i</sub></i>}) = CH(<i class="emphasis">Q<sub>i</sub></i> - <i class="emphasis">P<sub>i</sub></i>) = CH(<i class="emphasis">Q<sub>i</sub></i>).</p>
<p class="last-para">We have shown that once we push <i class="emphasis">p<sub>i</sub></i> , stack <i class="emphasis">S</i> contains exactly the vertices of CH(<i class="emphasis">Q<sub>i</sub></i>) in counterclockwise order from bottom to top. Incrementing <i class="emphasis">i</i> will then cause the loop invariant to hold for the next iteration.</p>
</li>
<li class="listitem">
<p class="first-para">
<b class="bold">Termination:</b> When the loop terminates, we have <i class="emphasis">i</i> = <i class="emphasis">m</i> + 1, and so the loop invariant implies that stack <i class="emphasis">S</i> consists of exactly the vertices of CH(<i class="emphasis">Q<sub>m</sub></i>), which is CH(<i class="emphasis">Q</i>), in counterclockwise order from bottom to top. This completes the proof.</p>
</li>
</ul>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">We now show that the running time of GRAHAM-SCAN is <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>), where <i class="emphasis">n</i> = |<i class="emphasis">Q</i>|. Line 1 takes <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) time. Line 2 takes <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) time, using merge sort or heapsort to sort the polar angles and the cross-product method of <a href="DDU0218.html#2912" target="_parent" class="chapterjump">Section 33.1</a> to compare angles. (Removing all but the farthest point with the same polar angle can be done in a total of <i class="emphasis">O</i>(<i class="emphasis">n</i>) time.) Lines 3<span class="unicode">-</span>5 take <i class="emphasis">O</i>(1) time. Because <i class="emphasis">m</i> <span class="unicode">&le;</span> <i class="emphasis">n</i> - 1, the <b class="bold">for</b> loop of lines 6<span class="unicode">-</span>9 is executed at most <i class="emphasis">n</i> - 3 times. Since PUSH takes <i class="emphasis">O</i>(1) time, each iteration takes <i class="emphasis">O</i>(1) time exclusive of the time spent in the <b class="bold">while</b> loop of lines 7<span class="unicode">-</span>8, and thus overall the <b class="bold">for</b> loop takes <i class="emphasis">O</i>(<i class="emphasis">n</i>) time exclusive of the nested <b class="bold">while</b> loop.</p>
<p class="last-para">We use aggregate analysis to show that the <b class="bold">while</b> loop takes <i class="emphasis">O</i>(<i class="emphasis">n</i>) time overall. For <i class="emphasis">i</i> = 0, 1, ..., <i class="emphasis">m</i>, each point <i class="emphasis">p<sub>i</sub></i> is pushed onto stack <i class="emphasis">S</i> exactly once. As in the analysis of the MULTIPOP procedure of <a href="DDU0101.html#1254" target="_parent" class="chapterjump">Section 17.1</a>, we observe that there is at most one POP operation for each PUSH operation. At least three points<span class="unicode">-</span><i class="emphasis">p</i><sub>0</sub>, <i class="emphasis">p</i><sub>1</sub>, and <i class="emphasis">p<sub>m</sub></i><span class="unicode">-</span>are never popped from the stack, so that in fact at most <i class="emphasis">m</i> - 2 POP operations are performed in total. Each iteration of the <b class="bold">while</b> loop performs one <a name="2972"></a><a name="IDX-955"></a>POP, and so there are at most <i class="emphasis">m</i> - 2 iterations of the <b class="bold">while</b> loop altogether. Since the test in line 7 takes <i class="emphasis">O</i>(1) time, each call of POP takes <i class="emphasis">O</i>(1) time, and since <i class="emphasis">m</i> <span class="unicode">&le;</span> <i class="emphasis">n</i> - 1, the total time taken by the <b class="bold">while</b> loop is <i class="emphasis">O</i>(<i class="emphasis">n</i>). Thus, the running time of GRAHAM-SCAN is <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>).</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="2973"></a><a name="ch33lev3sec11"></a>Jarvis's march</h4>
<p class="first-para">
<b class="bold"><i class="emphasis">Jarvis's march</i></b> computes the convex hull of a set <i class="emphasis">Q</i> of points by a technique known as <b class="bold"><i class="emphasis">package wrapping</i></b> (or <b class="bold"><i class="emphasis">gift wrapping</i></b>). The algorithm runs in time <i class="emphasis">O</i>(<i class="emphasis">nh</i>), where <i class="emphasis">h</i> is the number of vertices of CH(<i class="emphasis">Q</i>). When <i class="emphasis">h</i> is <i class="emphasis">o</i>(lg <i class="emphasis">n</i>), Jarvis's march is asymptotically faster than Graham's scan.</p>
<p class="para">Intuitively, Jarvis's march simulates wrapping a taut piece of paper around the set <i class="emphasis">Q</i>. We start by taping the end of the paper to the lowest point in the set, that is, to the same point <i class="emphasis">p</i><sub>0</sub> with which we start Graham's scan. This point is a vertex of the convex hull. We pull the paper to the right to make it taut, and then we pull it higher until it touches a point. This point must also be a vertex of the convex hull. Keeping the paper taut, we continue in this way around the set of vertices until we come back to our original point <i class="emphasis">p</i><sub>0</sub>.</p>
<p class="para">More formally, Jarvis's march builds a sequence <i class="emphasis">H</i> = <span class="unicode">&#12296;</span><i class="emphasis">p</i><sub>0</sub>, <i class="emphasis">p</i><sub>1</sub>, ..., <i class="emphasis">p</i><sub><i class="emphasis">h</i>-1</sub><span class="unicode">&#12297;</span> of the vertices of CH(<i class="emphasis">Q</i>). We start with <i class="emphasis">p</i><sub>0</sub>. As <a class="internaljump" href="#ch33fig09">Figure 33.9</a> shows, the next convex hull vertex <i class="emphasis">p</i><sub>1</sub> has the smallest polar angle with respect to <i class="emphasis">p</i><sub>0</sub>. (In case of ties, we choose the point farthest from <i class="emphasis">p</i><sub>0</sub>.) Similarly, <i class="emphasis">p</i><sub>2</sub> has the smallest polar angle with respect to <i class="emphasis">p</i><sub>1</sub>, and so on. When we reach the highest vertex, say <i class="emphasis">p<sub>k</sub></i> (breaking ties by choosing the farthest such vertex), we have constructed, as <a class="internaljump" href="#ch33fig09">Figure 33.9</a> shows, the <b class="bold"><i class="emphasis">right chain</i></b> of CH(<i class="emphasis">Q</i>). To construct the <b class="bold"><i class="emphasis">left chain</i></b>, we start at <i class="emphasis">p<sub>k</sub></i> and choose <i class="emphasis">p</i><sub><i class="emphasis">k</i>+1</sub> as the point with the smallest polar angle with respect to <i class="emphasis">p<sub>k</sub></i>, but <i class="emphasis">from the negative x-axis</i>. We continue on, forming the left chain by taking polar angles from the negative <i class="emphasis">x</i>-axis, until we come back to our original vertex <i class="emphasis">p</i><sub>0</sub>.</p>
<div class="figure">
<a name="2974"></a><a name="ch33fig09"></a><span class="figuremediaobject"><a href="images/fig978%5F01%5F0%2Ejpg" NAME="IMG_1778" target="_parent"><img src="images/fig978_01.jpg" height="246" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 33.9: </span>The operation of Jarvis's march. The first vertex chosen is the lowest point <i class="emphasis">p</i><sub>0</sub>. The next vertex, <i class="emphasis">p</i><sub>1</sub>, has the smallest polar angle of any point with respect to <i class="emphasis">p</i><sub>0</sub>. Then, <i class="emphasis">p</i><sub>2</sub> has the smallest polar angle with respect to <i class="emphasis">p</i><sub>1</sub>. The right chain goes as high as the highest point <i class="emphasis">p</i><sub>3</sub>. Then, the left chain is constructed by finding smallest polar angles with respect to the negative <i class="emphasis">x</i>-axis.</span>
</div>
<p class="para">We could implement Jarvis's march in one conceptual sweep around the convex hull, that is, without separately constructing the right and left chains. Such implementations typically keep track of the angle of the last convex-hull side chosen and require the sequence of angles of hull sides to be strictly increasing (in the range of 0 to 2<span class="unicode">&pi;</span> radians). The advantage of constructing separate chains is that we need not explicitly compute angles; the techniques of <a href="DDU0218.html#2912" target="_parent" class="chapterjump">Section 33.1</a> suffice to compare angles.</p>
<p class="para">If implemented properly, Jarvis's march has a running time of <i class="emphasis">O</i>(<i class="emphasis">nh</i>). For each of the <i class="emphasis">h</i> vertices of CH(<i class="emphasis">Q</i>), we find the vertex with the minimum polar angle. Each comparison between polar angles takes <i class="emphasis">O</i>(1) time, using the techniques of <a href="DDU0218.html#2912" target="_parent" class="chapterjump">Section 33.1</a>. As <a href="DDU0053.html#577" target="_parent" class="chapterjump">Section 9.1</a> shows, we can compute the minimum of <i class="emphasis">n</i> values in <i class="emphasis">O</i>(<i class="emphasis">n</i>) time if each comparison takes <i class="emphasis">O</i>(1) time. Thus, Jarvis's march takes <i class="emphasis">O</i>(<i class="emphasis">nh</i>) time.<a name="2975"></a><a name="IDX-956"></a>
</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 33.3-1</span></span><a name="2976"></a><a name="ch33ex19"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Prove that in the procedure GRAHAM-SCAN, points <i class="emphasis">p</i><sub>1</sub> and <i class="emphasis">p<sub>m</sub></i> must be vertices of CH(<i class="emphasis">Q</i>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercise 33.3-2</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Consider a model of computation that supports addition, comparison, and multiplication and for which there is a lower bound of <span class="unicode">&#8486;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) to sort <i class="emphasis">n</i> numbers. Prove that <span class="unicode">&#8486;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) is a lower bound for computing, in order, the vertices of the convex hull of a set of <i class="emphasis">n</i> points in such a model.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercise 33.3-3</span></span><a name="2977"></a><a name="ch33ex21"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Given a set of points <i class="emphasis">Q</i>, prove that the pair of points farthest from each other must be vertices of CH(<i class="emphasis">Q</i>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercise 33.3-4</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">For a given polygon <i class="emphasis">P</i> and a point <i class="emphasis">q</i> on its boundary, the <b class="bold"><i class="emphasis">shadow</i></b> of <i class="emphasis">q</i> is the set of points <i class="emphasis">r</i> such that the segment <span class="inlinemediaobject"><img src="images/fig978_02.jpg" height="12" width="14" alt="" border="0"></span> is entirely on the boundary or in the interior of <i class="emphasis">P</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="2978"></a><a name="IDX-957"></a>
<p class="para">A polygon <i class="emphasis">P</i> is <b class="bold"><i class="emphasis">star-shaped</i></b> if there exists a point <i class="emphasis">p</i> in the interior of <i class="emphasis">P</i> that is in the shadow of every point on the boundary of <i class="emphasis">P</i>. The set of all such points <i class="emphasis">p</i> is called the <b class="bold"><i class="emphasis">kernel</i></b> of <i class="emphasis">P</i>. (See <a class="internaljump" href="#ch33fig10">Figure 33.10</a>.) Given an <i class="emphasis">n</i>-vertex, star-shaped polygon <i class="emphasis">P</i> specified by its vertices in counterclockwise order, show how to compute CH(<i class="emphasis">P</i>) in <i class="emphasis">O</i>(<i class="emphasis">n</i>) time.</p>
<div class="figure">
<a name="2979"></a><a name="ch33fig10"></a><span class="figuremediaobject"><img src="images/fig979_01.jpg" height="117" width="350" alt="" border="0"></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 33.10: </span>The definition of a star-shaped polygon, for use in Exercise 33.3-4. <i class="emphasis">(a)</i> A star-shaped polygon. The segment from point <i class="emphasis">p</i> to any point <i class="emphasis">q</i> on the boundary intersects the boundary only at <i class="emphasis">q</i>. <i class="emphasis">(b)</i> A non-star-shaped polygon. The shaded region on the left is the shadow of <i class="emphasis">q</i>, and the shaded region on the right is the shadow of <i class="emphasis">q</i><span class="unicode">&prime;</span>. Since these regions are disjoint, the kernel is empty.</span>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercise 33.3-5</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">In the <b class="bold"><i class="emphasis">on-line convex-hull problem</i></b>, we are given the set <i class="emphasis">Q</i> of <i class="emphasis">n</i> points one point at a time. After receiving each point, we are to compute the convex hull of the points seen so far. Obviously, we could run Graham's scan once for each point, with a total running time of <i class="emphasis">O</i>(<i class="emphasis">n</i><sup>2</sup> lg <i class="emphasis">n</i>). Show how to solve the on-line convex-hull problem in a total of <i class="emphasis">O</i>(<i class="emphasis">n</i><sup>2</sup>) time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercise 33.3-6: </span><span class="unicode">&#8902;</span></span><a name="2980"></a><a name="ch33ex24"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show how to implement the incremental method for computing the convex hull of <i class="emphasis">n</i> points so that it runs in <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0219.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0221.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
