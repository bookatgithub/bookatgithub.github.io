<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>33.4 Finding the closest pair of points</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0220.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0222.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch33"></a>
<div class="section">
<h2 class="first-section-title">
<a name="2981"></a><a name="ch33lev1sec4"></a><span class="section-titlelabel">33.4 </span>Finding the closest pair of points</h2>
<p class="first-para">We now consider the problem of finding the closest pair of points in a set <i class="emphasis">Q</i> of <i class="emphasis">n</i> <span class="unicode">&ge;</span> 2 points. "Closest" refers to the usual euclidean distance: the distance between points <i class="emphasis">p</i><sub>1</sub> = (<i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">y</i><sub>1</sub>) and <i class="emphasis">p</i><sub>2</sub> = (<i class="emphasis">x</i><sub>2</sub>, <i class="emphasis">y</i><sub>2</sub>) is <span class="inlinemediaobject"><img src="images/fig979_02.jpg" height="17" width="117" alt="" border="0"></span>. Two points in set <i class="emphasis">Q</i> may be coincident, in which case the distance between them is zero. This problem has applications in, for example, traffic-control systems. A system for controlling air or sea traffic might need to know which are the two closest vehicles in order to detect potential collisions.<a name="2982"></a><a name="IDX-958"></a>
</p>
<p class="para">A brute-force closest-pair algorithm simply looks at all the <span class="inlinemediaobject"><img src="images/fig980_01.jpg" height="18" width="65" alt="" border="0"></span> pairs of points. In this section, we shall describe a divide-and-conquer algorithm for this problem whose running time is described by the familiar recurrence <i class="emphasis">T</i> (<i class="emphasis">n</i>) = 2<i class="emphasis">T</i>(<i class="emphasis">n</i>/2) + <i class="emphasis">O</i>(<i class="emphasis">n</i>). Thus, this algorithm uses only <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) time.</p>
<div class="section">
<h4 class="sect4-title">
<a name="2983"></a><a name="ch33lev3sec12"></a>The divide-and-conquer algorithm</h4>
<p class="first-para">Each recursive invocation of the algorithm takes as input a subset <i class="emphasis">P</i> <span class="unicode">&sube;</span> <i class="emphasis">Q</i> and arrays <i class="emphasis">X</i> and <i class="emphasis">Y</i>, each of which contains all the points of the input subset <i class="emphasis">P</i>. The points in array <i class="emphasis">X</i> are sorted so that their <i class="emphasis">x</i>-coordinates are monotonically increasing. Similarly, array <i class="emphasis">Y</i> is sorted by monotonically increasing <i class="emphasis">y</i>-coordinate. Note that in order to attain the <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) time bound, we cannot afford to sort in each recursive call; if we did, the recurrence for the running time would be <i class="emphasis">T</i>(<i class="emphasis">n</i>) = 2<i class="emphasis">T</i>(<i class="emphasis">n</i>/2) + <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>), whose solution is <i class="emphasis">T</i>(<i class="emphasis">n</i>) = <i class="emphasis">O</i>(<i class="emphasis">n</i> lg<sup>2</sup> <i class="emphasis">n</i>). (Use the version of the master method given in <a href="DDU0027.html#278" target="_parent" class="chapterjump">Exercise 4.4-2</a>.) We shall see a little later how to use "presorting" to maintain this sorted property without actually sorting in each recursive call.</p>
<p class="para">A given recursive invocation with inputs <i class="emphasis">P, X</i>, and <i class="emphasis">Y</i> first checks whether |<i class="emphasis">P</i>| <span class="unicode">&le;</span> 3. If so, the invocation simply performs the brute-force method described above: try all <span class="inlinemediaobject"><img src="images/fig980_02.jpg" height="17" width="20" alt="" border="0"></span> pairs of points and return the closest pair. If |<i class="emphasis">P</i>| <span class="unicode">&gt;</span> 3, the recursive invocation carries out the divide-and-conquer paradigm as follows.</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="para">
<b>Divide:</b> It finds a vertical line <i class="emphasis">l</i> that bisects the point set <i class="emphasis">P</i> into two sets <i class="emphasis">P<sub>L</sub></i> and <i class="emphasis">P<sub>R</sub></i> such that |<i class="emphasis">P<sub>L</sub></i>| = <span class="unicode">&lceil;</span>|<i class="emphasis">P</i>|/2<span class="unicode">&rceil;</span>, |<i class="emphasis">P<sub>R</sub></i>| = <span class="unicode">&lfloor;</span>|<i class="emphasis">P</i>|/2<span class="unicode">&rfloor;</span>, all points in <i class="emphasis">P<sub>L</sub></i> are on or to the left of line <i class="emphasis">l</i>, and all points in <i class="emphasis">P<sub>R</sub></i> are on or to the right of <i class="emphasis">l</i>. The array <i class="emphasis">X</i> is divided into arrays <i class="emphasis">X<sub>L</sub></i> and <i class="emphasis">X<sub>R</sub></i>, which contain the points of <i class="emphasis">P<sub>L</sub></i> and <i class="emphasis">P<sub>R</sub></i> respectively, sorted by monotonically increasing <i class="emphasis">x</i>-coordinate. Similarly, the array <i class="emphasis">Y</i> is divided into arrays <i class="emphasis">Y<sub>L</sub></i> and <i class="emphasis">Y<sub>R</sub></i>, which contain the points of <i class="emphasis">P<sub>L</sub></i> and <i class="emphasis">P<sub>R</sub></i> respectively, sorted by monotonically increasing <i class="emphasis">y</i>-coordinate.</p>
</li>
<li class="listitem">
<p class="para">
<b>Conquer:</b> Having divided <i class="emphasis">P</i> into <i class="emphasis">P<sub>L</sub></i> and <i class="emphasis">P<sub>R</sub></i>, it makes two recursive calls, one to find the closest pair of points in <i class="emphasis">P<sub>L</sub></i> and the other to find the closest pair of points in <i class="emphasis">P<sub>R</sub></i>. The inputs to the first call are the subset <i class="emphasis">P<sub>L</sub></i> and arrays <i class="emphasis">X<sub>L</sub></i> and <i class="emphasis">Y<sub>L</sub></i>; the second call receives the inputs <i class="emphasis">P<sub>R</sub>, X<sub>R</sub></i>, and <i class="emphasis">Y<sub>R</sub></i>. Let the closest-pair distances returned for <i class="emphasis">P<sub>L</sub></i> and <i class="emphasis">P<sub>R</sub></i> be <i class="emphasis"><span class="unicode">&delta;</span><sub>L</sub></i> and <i class="emphasis"><span class="unicode">&delta;</span><sub>R</sub></i>, respectively, and let <i class="emphasis"><span class="unicode">&delta;</span></i> = min(<i class="emphasis"><span class="unicode">&delta;</span><sub>L</sub>, <span class="unicode">&delta;</span><sub>R</sub></i>).</p>
</li>
<li class="listitem">
<p class="para">
<b>Combine:</b> The closest pair is either the pair with distance <i class="emphasis"><span class="unicode">&delta;</span></i> found by one of the recursive calls, or it is a pair of points with one point in <i class="emphasis">P<sub>L</sub></i> and the other in <i class="emphasis">P<sub>R</sub></i>. The algorithm determines if there is such a pair whose distance is less than <i class="emphasis"><span class="unicode">&delta;</span></i>. Observe that if there is a pair of points with distance less than <i class="emphasis"><span class="unicode">&delta;</span></i>, both points of the pair must be within <i class="emphasis"><span class="unicode">&delta;</span></i> units of line <i class="emphasis">l</i>. Thus, as <a class="internaljump" href="#ch33fig11">Figure 33.11(a)</a> shows, they both must reside in the 2<i class="emphasis"><span class="unicode">&delta;</span></i>-wide vertical strip centered at line <i class="emphasis">l</i>. To find such a pair, if one exists, the algorithm does the following.</p>
<p class="figure">
<a name="2984"></a><a name="ch33fig11"></a><span class="figuremediaobject"><a href="images/fig982%5F01%5F0%2Ejpg" NAME="IMG_1784" target="_parent"><img src="images/fig982_01.jpg" height="151" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 33.11: </span>Key concepts in the proof that the closest-pair algorithm needs to check only 7 points following each point in the array Y<span class="unicode">&prime;</span>. <i class="emphasis">(a)</i> If <i class="emphasis">p<sub>L</sub></i> <span class="unicode">&isin;</span> <i class="emphasis">P<sub>L</sub></i> and <i class="emphasis">p<sub>R</sub></i> <span class="unicode">&isin;</span> <i class="emphasis">P<sub>R</sub></i> are less than <span class="unicode">&delta;</span> units apart, they must reside within a <span class="unicode">&delta;</span> <span class="unicode">&times;</span> 2<span class="unicode">&delta;</span> rectangle centered at line <i class="emphasis">l</i>. <i class="emphasis">(b)</i> How 4 points that are pairwise at least <span class="unicode">&delta;</span> units apart can all reside within a <span class="unicode">&delta;</span> <span class="unicode">&times;</span> <span class="unicode">&delta;</span> square. On the left are 4 points in <i class="emphasis">P<sub>L</sub></i>, and on the right are 4 points in <i class="emphasis">P<sub>R</sub></i>. There can be 8 points in the <span class="unicode">&delta;</span> <span class="unicode">&times;</span> 2<span class="unicode">&delta;</span> rectangle if the points shown on line l are actually pairs of coincident points with one point in <i class="emphasis">P<sub>L</sub></i> and one in <i class="emphasis">P<sub>R</sub></i>.</span>
</p>
</li>
</ul>
<a name="2985"></a><a name="IDX-959"></a>
<ol class="orderedlist">
<li class="first-listitem">
<p class="first-para">It creates an array <i class="emphasis">Y</i><span class="unicode">&prime;</span>, which is the array <i class="emphasis">Y</i> with all points not in the 2<i class="emphasis"><span class="unicode">&delta;</span></i>-wide vertical strip removed. The array <i class="emphasis">Y</i><span class="unicode">&prime;</span> is sorted by <i class="emphasis">y</i>-coordinate, just as <i class="emphasis">Y</i> is.</p>
</li>
<li class="listitem">
<p class="first-para">For each point <i class="emphasis">p</i> in the array <i class="emphasis">Y</i><span class="unicode">&prime;</span>, the algorithm tries to find points in <i class="emphasis">Y</i><span class="unicode">&prime;</span> that are within <i class="emphasis"><span class="unicode">&delta;</span></i> units of <i class="emphasis">p</i>. As we shall see shortly, only the 7 points in <i class="emphasis">Y</i><span class="unicode">&prime;</span> that follow <i class="emphasis">p</i> need be considered. The algorithm computes the distance from <i class="emphasis">p</i> to each of these 7 points and keeps track of the closest-pair distance <i class="emphasis"><span class="unicode">&delta;</span></i><span class="unicode">&prime;</span> found over all pairs of points in <i class="emphasis">Y</i><span class="unicode">&prime;</span>.</p>
</li>
<li class="listitem">
<p class="first-para">If <i class="emphasis"><span class="unicode">&delta;</span></i><span class="unicode">&prime;</span> <span class="unicode">&lt;</span> <i class="emphasis"><span class="unicode">&delta;</span></i>, then the vertical strip does indeed contain a closer pair than was found by the recursive calls. This pair and its distance <i class="emphasis"><span class="unicode">&delta;</span></i><span class="unicode">&prime;</span> are returned. Otherwise, the closest pair and its distance <i class="emphasis"><span class="unicode">&delta;</span></i> found by the recursive calls are returned.</p>
</li>
</ol>
<p class="last-para">The above description omits some implementation details that are necessary to achieve the <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) running time. After proving the correctness of the algorithm, we shall show how to implement the algorithm to achieve the desired time bound.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="2986"></a><a name="ch33lev3sec13"></a>Correctness</h4>
<p class="first-para">The correctness of this closest-pair algorithm is obvious, except for two aspects. First, by bottoming out the recursion when |<i class="emphasis">P</i>| <span class="unicode">&le;</span> 3, we ensure that we never try to solve a subproblem consisting of only one point. The second aspect is that we need only check the 7 points following each point <i class="emphasis">p</i> in array <i class="emphasis">Y</i><span class="unicode">&prime;</span>; we shall now prove this property.</p>
<p class="para">Suppose that at some level of the recursion, the closest pair of points is <i class="emphasis">p<sub>L</sub></i> <span class="unicode">&isin;</span> <i class="emphasis">P<sub>L</sub></i> and <i class="emphasis">p<sub>R</sub></i> <span class="unicode">&isin;</span> <i class="emphasis">P<sub>R</sub></i>. Thus, the distance <i class="emphasis"><span class="unicode">&delta;</span></i><span class="unicode">&prime;</span> between <i class="emphasis">p<sub>L</sub></i> and <i class="emphasis">p<sub>R</sub></i> is strictly less than <i class="emphasis"><span class="unicode">&delta;</span></i>. Point <i class="emphasis">p<sub>L</sub></i> must be on or to the left of line <i class="emphasis">l</i> and less than <i class="emphasis"><span class="unicode">&delta;</span></i> units away. Similarly, <i class="emphasis">p<sub>R</sub></i> is on or to the right of <i class="emphasis">l</i> and less than <i class="emphasis"><span class="unicode">&delta;</span></i> units away. Moreover, <i class="emphasis">p<sub>L</sub></i> and <i class="emphasis">p<sub>R</sub></i> are within <i class="emphasis"><span class="unicode">&delta;</span></i> units of each other vertically. Thus, as <a class="internaljump" href="#ch33fig11">Figure 33.11(a)</a> shows, <i class="emphasis">p<sub>L</sub></i> and <i class="emphasis">p<sub>R</sub></i> are within a <i class="emphasis"><span class="unicode">&delta;</span></i> <span class="unicode">&times;</span> 2<i class="emphasis"><span class="unicode">&delta;</span></i> rectangle centered at line <i class="emphasis">l</i>. (There may be other points within this rectangle as well.)</p>
<p class="para">We next show that at most 8 points of <i class="emphasis">P</i> can reside within this <i class="emphasis"><span class="unicode">&delta;</span></i> <span class="unicode">&times;</span> 2<i class="emphasis"><span class="unicode">&delta;</span></i> rectangle. Consider the <i class="emphasis"><span class="unicode">&delta;</span></i> <span class="unicode">&times;</span> <i class="emphasis"><span class="unicode">&delta;</span></i> square forming the left half of this rectangle. Since all points within <i class="emphasis">P<sub>L</sub></i> are at least <i class="emphasis"><span class="unicode">&delta;</span></i> units apart, at most 4 points can reside within this square; <a class="internaljump" href="#ch33fig11">Figure 33.11(b)</a> shows how. Similarly, at most 4 points in <i class="emphasis">P<sub>R</sub></i> can reside within the <i class="emphasis"><span class="unicode">&delta;</span></i> <span class="unicode">&times;</span> <i class="emphasis"><span class="unicode">&delta;</span></i> square forming the right half of the rectangle. Thus, at most 8 points of <i class="emphasis">P</i> can reside within the <i class="emphasis"><span class="unicode">&delta;</span></i> <span class="unicode">&times;</span> 2<i class="emphasis"><span class="unicode">&delta;</span></i> rectangle. (Note that since points on line <i class="emphasis">l</i> may be in either <i class="emphasis">P<sub>L</sub></i> or <i class="emphasis">P<sub>R</sub></i>, there may be up to 4 points on <i class="emphasis">l</i>. This limit is achieved if there are two pairs of coincident points such that each pair consists of one point from <i class="emphasis">P<sub>L</sub></i> and one point from <i class="emphasis">P<sub>R</sub></i>, one pair is at the intersection of <i class="emphasis">l</i> and the top of the rectangle, and the other pair is where <i class="emphasis">l</i> intersects the bottom of the rectangle.)</p>
<p class="last-para">Having shown that at most 8 points of <i class="emphasis">P</i> can reside within the rectangle, it is easy to see that we need only check the 7 points following each point in the array <i class="emphasis">Y</i><span class="unicode">&prime;</span>.<a name="2987"></a><a name="IDX-960"></a>Still assuming that the closest pair is <i class="emphasis">p<sub>L</sub></i> and <i class="emphasis">p<sub>R</sub></i>, let us assume without loss of generality that <i class="emphasis">p<sub>L</sub></i> precedes <i class="emphasis">p<sub>R</sub></i> in array <i class="emphasis">Y</i><span class="unicode">&prime;</span>. Then, even if <i class="emphasis">p<sub>L</sub></i> occurs as early as possible in <i class="emphasis">Y</i><span class="unicode">&prime;</span> and <i class="emphasis">p<sub>R</sub></i> occurs as late as possible, <i class="emphasis">p<sub>R</sub></i> is in one of the 7 positions following <i class="emphasis">p<sub>L</sub></i> . Thus, we have shown the correctness of the closest-pair algorithm.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="2988"></a><a name="ch33lev3sec14"></a>Implementation and running time</h4>
<p class="first-para">As we have noted, our goal is to have the recurrence for the running time be <i class="emphasis">T</i>(<i class="emphasis">n</i>) = 2<i class="emphasis">T</i>(<i class="emphasis">n</i>/2) + <i class="emphasis">O</i>(<i class="emphasis">n</i>), where <i class="emphasis">T</i>(<i class="emphasis">n</i>) is the running time for a set of <i class="emphasis">n</i> points. The main difficulty is in ensuring that the arrays <i class="emphasis">X<sub>L</sub>, X<sub>R</sub>, Y<sub>L</sub></i>, and <i class="emphasis">Y<sub>R</sub></i>, which are passed to recursive calls, are sorted by the proper coordinate and also that the array <i class="emphasis">Y</i><span class="unicode">&prime;</span> is sorted by <i class="emphasis">y</i>-coordinate. (Note that if the array <i class="emphasis">X</i> that is received by a recursive call is already sorted, then the division of set <i class="emphasis">P</i> into <i class="emphasis">P<sub>L</sub></i> and <i class="emphasis">P<sub>R</sub></i> is easily accomplished in linear time.)</p>
<p class="para">The key observation is that in each call, we wish to form a sorted subset of a sorted array. For example, a particular invocation is given the subset <i class="emphasis">P</i> and the array <i class="emphasis">Y</i> , sorted by <i class="emphasis">y</i>-coordinate. Having partitioned <i class="emphasis">P</i> into <i class="emphasis">P<sub>L</sub></i> and <i class="emphasis">P<sub>R</sub></i>, it needs to form the arrays <i class="emphasis">Y<sub>L</sub></i> and <i class="emphasis">Y<sub>R</sub></i>, which are sorted by <i class="emphasis">y</i>-coordinate. Moreover, these arrays must be formed in linear time. The method can be viewed as the opposite of <a name="2989"></a><a name="IDX-961"></a>the MERGE procedure from merge sort in <a href="DDU0016.html#90" target="_parent" class="chapterjump">Section 2.3.1</a>: we are splitting a sorted array into two sorted arrays. The following pseudocode gives the idea.</p>
<div class="informalexample">
<pre class="literallayout-normal">
1  <i class="emphasis">length</i>[<i class="emphasis">Y<sub>L</sub></i>] <span class="unicode">&larr;</span> <i class="emphasis">length</i>[<i class="emphasis">Y<sub>R</sub></i>] <span class="unicode">&larr;</span> 0
2  <b class="bold">for</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">length</i>[<i class="emphasis">Y</i>]
3       <b class="bold">do if</b> <i class="emphasis">Y</i>[<i class="emphasis">i</i>] <span class="unicode">&isin;</span> <i class="emphasis">P<sub>L</sub></i>
4             <b class="bold">then</b> <i class="emphasis">length</i>[<i class="emphasis">Y<sub>L</sub></i>] <span class="unicode">&larr;</span> <i class="emphasis">length</i>[<i class="emphasis">Y<sub>L</sub></i>] + 1
5                  <i class="emphasis">Y<sub>L</sub></i>[<i class="emphasis">length</i>[<i class="emphasis">Y<sub>L</sub></i>]] <span class="unicode">&larr;</span> <i class="emphasis">Y</i>[<i class="emphasis">i</i>]
6             <b class="bold">else</b> <i class="emphasis">length</i>[<i class="emphasis">Y<sub>R</sub></i>] <span class="unicode">&larr;</span> <i class="emphasis">length</i>[<i class="emphasis">Y<sub>R</sub></i>] + 1
7                  <i class="emphasis">Y<sub>R</sub></i>[<i class="emphasis">length</i>[<i class="emphasis">Y<sub>R</sub></i>]] <span class="unicode">&larr;</span> <i class="emphasis">Y</i>[<i class="emphasis">i</i>]
</pre>
</div>
<p class="para">We simply examine the points in array <i class="emphasis">Y</i> in order. If a point <i class="emphasis">Y</i>[<i class="emphasis">i</i>] is in <i class="emphasis">P<sub>L</sub></i>, we append it to the end of array <i class="emphasis">Y<sub>L</sub></i>; otherwise, we append it to the end of array <i class="emphasis">Y<sub>R</sub></i>. Similar pseudocode works for forming arrays <i class="emphasis">X<sub>L</sub>, X<sub>R</sub></i>, and <i class="emphasis">Y</i><span class="unicode">&prime;</span>.</p>
<p class="para">The only remaining question is how to get the points sorted in the first place. We do this by simply <b class="bold"><i class="emphasis">presorting</i></b> them; that is, we sort them once and for all <i class="emphasis">before</i> the first recursive call. These sorted arrays are passed into the first recursive call, and from there they are whittled down through the recursive calls as necessary. The presorting adds an additional <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) to the running time, but now each step of the recursion takes linear time exclusive of the recursive calls. Thus, if we let <i class="emphasis">T</i>(<i class="emphasis">n</i>) be the running time of each recursive step and <i class="emphasis">T</i><span class="unicode">&prime;</span>(<i class="emphasis">n</i>) be the running time of the entire algorithm, we get <i class="emphasis">T</i><span class="unicode">&prime;</span>(<i class="emphasis">n</i>) = <i class="emphasis">T</i> (<i class="emphasis">n</i>) + <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) and</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig983_01.jpg" height="59" width="346" alt="" border="0"></span>
</div>
<p class="para">Thus, <i class="emphasis">T</i>(<i class="emphasis">n</i>) = <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) and <i class="emphasis">T</i><span class="unicode">&prime;</span>(<i class="emphasis">n</i>) = <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>).</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 33.4-1</span></span><a name="2990"></a><a name="ch33ex25"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Professor Smothers comes up with a scheme that allows the closest-pair algorithm to check only 5 points following each point in array <i class="emphasis">Y</i><span class="unicode">&prime;</span>. The idea is always to place points on line <i class="emphasis">l</i> into set <i class="emphasis">P<sub>L</sub></i>. Then, there cannot be pairs of coincident points on line <i class="emphasis">l</i> with one point in <i class="emphasis">P</i><i class="emphasis">L</i> and one in <i class="emphasis">P<sub>R</sub></i>. Thus, at most 6 points can reside in the <i class="emphasis"><span class="unicode">&delta;</span></i> <span class="unicode">&times;</span> 2<i class="emphasis"><span class="unicode">&delta;</span></i> rectangle. What is the flaw in the professor's scheme?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercise 33.4-2</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Without increasing the asymptotic running time of the algorithm, show how to ensure that the set of points passed to the very first recursive call contains no coincident points. Prove that it then suffices to check the points in the 5 array positions following each point in the array <i class="emphasis">Y</i><span class="unicode">&prime;</span>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="2991"></a><a name="IDX-962"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercise 33.4-3</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The distance between two points can be defined in ways other than euclidean. In the plane, the <b class="bold"><i class="emphasis">L<sub>m</sub>-distance</i></b> between points <i class="emphasis">p</i><sub>1</sub> and <i class="emphasis">p</i><sub>2</sub> is given by the expression (|<i class="emphasis">x</i><sub>1</sub> - <i class="emphasis">x</i><sub>2</sub>|<sup><i class="emphasis">m</i></sup> + |<i class="emphasis">y</i><sub>1</sub> - <i class="emphasis">y</i><sub>2</sub>|<sup><i class="emphasis">m</i></sup>)<sup>1/<i class="emphasis">m</i></sup>. Euclidean distance, therefore, is <i class="emphasis">L</i><sub>2</sub>-distance. Modify the closest-pair algorithm to use the <i class="emphasis">L</i><sub>1</sub>-distance, which is also known as the <b class="bold"><i class="emphasis">Manhattan distance</i></b>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercise 33.4-4</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Given two points <i class="emphasis">p</i><sub>1</sub> and <i class="emphasis">p</i><sub>2</sub> in the plane, the <i class="emphasis">L</i><sub><i class="emphasis"><span class="unicode">&Yacute;</span></i></sub>-distance between them is given by max(|<i class="emphasis">x</i><sub>1</sub> - <i class="emphasis">x</i><sub>2</sub>|,|<i class="emphasis">y</i><sub>1</sub> - <i class="emphasis">y</i><sub>2</sub>|). Modify the closest-pair algorithm to use the <i class="emphasis">L</i><sub><span class="unicode">&infin;</span></sub>-distance.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercise 33.4-5</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suggest a change to the closest-pair algorithm that avoids presorting the <i class="emphasis">Y</i> array but leaves the running time as <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>). (<i class="emphasis">Hint:</i> Merge sorted arrays <i class="emphasis">Y<sub>L</sub></i> and <i class="emphasis">Y<sub>R</sub></i> to form the sorted array <i class="emphasis">Y</i>.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 33-1: </span>Convex layers</span><a name="2992"></a><a name="ch33ex30"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Given a set <i class="emphasis">Q</i> of points in the plane, we define the <b class="bold"><i class="emphasis">convex layers</i></b> of <i class="emphasis">Q</i> inductively. The first convex layer of <i class="emphasis">Q</i> consists of those points in <i class="emphasis">Q</i> that are vertices of CH(<i class="emphasis">Q</i>). For <i class="emphasis">i</i> <span class="unicode">&gt;</span> 1, define <i class="emphasis">Q<sub>i</sub></i> to consist of the points of <i class="emphasis">Q</i> with all points in convex layers 1, 2, ..., <i class="emphasis">i</i> - 1 removed. Then, the <i class="emphasis">i</i>th convex layer of <i class="emphasis">Q</i> is CH(<i class="emphasis">Q<sub>i</sub></i>) if <i class="emphasis">Q<sub>i</sub></i> <span class="unicode">&ne;</span> <span class="unicode">&Oslash;</span> and is undefined otherwise.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Give an <i class="emphasis">O</i>(<i class="emphasis">n</i><sup>2</sup>)-time algorithm to find the convex layers of a set of <i class="emphasis">n</i> points.</p>
</li>
<li class="listitem">
<p class="first-para">Prove that <span class="unicode">&#8486;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) time is required to compute the convex layers of a set of <i class="emphasis">n</i> points with any model of computation that requires <span class="unicode">&#8486;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) time to sort <i class="emphasis">n</i> real numbers.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 33-2: </span>Maximal layers</span><a name="2993"></a><a name="ch33ex31"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">Q</i> be a set of <i class="emphasis">n</i> points in the plane. We say that point (<i class="emphasis">x, y</i>) <b class="bold"><i class="emphasis">dominates</i></b> point (<i class="emphasis">x</i><span class="unicode">&prime;</span>, <i class="emphasis">y</i><span class="unicode">&prime;</span>) if <i class="emphasis">x</i> = <i class="emphasis">x</i><span class="unicode">&prime;</span> and <i class="emphasis">y</i> = <i class="emphasis">y</i><span class="unicode">&prime;</span>. A point in <i class="emphasis">Q</i> that is dominated by no other points in <i class="emphasis">Q</i> is said to be <b class="bold"><i class="emphasis">maximal</i></b>. Note that <i class="emphasis">Q</i> may contain many maximal points, which can be organized into <b class="bold"><i class="emphasis">maximal layers</i></b> as follows. The first maximal layer <i class="emphasis">L</i><sub>1</sub> is the set of maximal points of <i class="emphasis">Q</i>. For <i class="emphasis">i</i> <span class="unicode">&gt;</span> 1, the <i class="emphasis">i</i>th maximal layer <i class="emphasis">L<sub>i</sub></i> is the set of maximal points in <span class="inlinemediaobject"><img src="images/fig984_01.jpg" height="16" width="65" alt="" border="0"></span>.<a name="2994"></a><a name="IDX-963"></a>
</p>
<p class="para">Suppose that <i class="emphasis">Q</i> has <i class="emphasis">k</i> nonempty maximal layers, and let <i class="emphasis">y<sub>i</sub></i> be the <i class="emphasis">y</i>-coordinate of the leftmost point in <i class="emphasis">L<sub>i</sub></i> for <i class="emphasis">i</i> = 1, 2, ..., <i class="emphasis">k</i>. For now, assume that no two points in <i class="emphasis">Q</i> have the same <i class="emphasis">x</i>- or <i class="emphasis">y</i>-coordinate.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Show that <i class="emphasis">y</i><sub>1</sub> <span class="unicode">&gt;</span> <i class="emphasis">y</i><sub>2</sub> <span class="unicode">&gt;</span> <span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&gt;</span> <i class="emphasis">y<sub>k</sub></i>.</p>
</li>
</ol>
<p class="para">Consider a point (<i class="emphasis">x, y</i>) that is to the left of any point in <i class="emphasis">Q</i> and for which <i class="emphasis">y</i> is distinct from the <i class="emphasis">y</i>-coordinate of any point in <i class="emphasis">Q</i>. Let <i class="emphasis">Q</i><span class="unicode">&prime;</span> = <i class="emphasis">Q</i> <span class="unicode">&cup;</span> {(<i class="emphasis">x, y</i>)}.</p>
<ol class="orderedlist" start="2" type="a">
<li class="first-listitem">
<p class="first-para">Let <i class="emphasis">j</i> be the minimum index such that <i class="emphasis">y<sub>j</sub></i> <span class="unicode">&lt;</span> <i class="emphasis">y</i>, unless <i class="emphasis">y</i> <span class="unicode">&lt;</span> <i class="emphasis">y<sub>k</sub></i>, in which case we let <i class="emphasis">j</i> = <i class="emphasis">k</i> + 1. Show that the maximal layers of <i class="emphasis">Q</i><span class="unicode">&prime;</span> are as follows.</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">If <i class="emphasis">j</i> <span class="unicode">&le;</span> <i class="emphasis">k</i>, then the maximal layers of <i class="emphasis">Q</i><span class="unicode">&prime;</span> are the same as the maximal layers of <i class="emphasis">Q</i>, except that <i class="emphasis">L<sub>j</sub></i> also includes (<i class="emphasis">x, y</i>) as its new leftmost point.</p>
</li>
<li class="listitem">
<p class="first-para">If <i class="emphasis">j</i> = <i class="emphasis">k</i> + 1, then the first <i class="emphasis">k</i> maximal layers of <i class="emphasis">Q</i><span class="unicode">&prime;</span> are the same as for <i class="emphasis">Q</i>, but in addition, <i class="emphasis">Q</i><span class="unicode">&prime;</span> has a nonempty (<i class="emphasis">k</i> + 1)st maximal layer: <i class="emphasis">L</i><sub><i class="emphasis">k</i>+1</sub> = {(<i class="emphasis">x, y</i>)}.</p>
</li>
</ul>
</li>
<li class="listitem">
<p class="first-para">Describe an <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>)-time algorithm to compute the maximal layers of a set <i class="emphasis">Q</i> of <i class="emphasis">n</i> points. (<i class="emphasis">Hint:</i> Move a sweep line from right to left.)</p>
</li>
<li class="listitem">
<p class="first-para">Do any difficulties arise if we now allow input points to have the same <i class="emphasis">x</i>- or <i class="emphasis">y</i>-coordinate? Suggest a way to resolve such problems.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 33-3: </span>Ghostbusters and ghosts</span><a name="2995"></a><a name="ch33ex32"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">A group of <i class="emphasis">n</i> Ghostbusters is battling <i class="emphasis">n</i> ghosts. Each Ghostbuster is armed with a proton pack, which shoots a stream at a ghost, eradicating it. A stream goes in a straight line and terminates when it hits the ghost. The Ghostbusters decide upon the following strategy. They will pair off with the ghosts, forming <i class="emphasis">n</i> Ghostbuster-ghost pairs, and then simultaneously each Ghostbuster will shoot a stream at his chosen ghost. As we all know, it is <i class="emphasis">very</i> dangerous to let streams cross, and so the Ghostbusters must choose pairings for which no streams will cross.</p>
<p class="para">Assume that the position of each Ghostbuster and each ghost is a fixed point in the plane and that no three positions are collinear.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Argue that there exists a line passing through one Ghostbuster and one ghost such the number of Ghostbusters on one side of the line equals the number of ghosts on the same side. Describe how to find such a line in <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) time.</p>
</li>
<li class="listitem">
<p class="first-para">Give an <i class="emphasis">O</i>(<i class="emphasis">n</i><sup>2</sup> lg <i class="emphasis">n</i>)-time algorithm to pair Ghostbusters with ghosts in such a way that no streams cross.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 33-4: </span>Picking up sticks</span><a name="2996"></a><a name="ch33ex33"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Professor Charon has a set of <i class="emphasis">n</i> sticks, which are lying on top of each other in some configuration. Each stick is specified by its endpoints, and each endpoint is <a name="2997"></a><a name="IDX-964"></a>an ordered triple giving its (<i class="emphasis">x, y, z</i>) coordinates. No stick is vertical. He wishes to pick up all the sticks, one at a time, subject to the condition that he may pick up a stick only if there is no other stick on top of it.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Give a procedure that takes two sticks <i class="emphasis">a</i> and <i class="emphasis">b</i> and reports whether <i class="emphasis">a</i> is above, below, or unrelated to <i class="emphasis">b</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Describe an efficient algorithm that determines whether it is possible to pick up all the sticks, and if so, provides a legal sequence of stick pickups to do so.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 33-5: </span>Sparse-hulled distributions</span><a name="2998"></a><a name="ch33ex34"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Consider the problem of computing the convex hull of a set of points in the plane that have been drawn according to some known random distribution. Sometimes, the number of points, or size, of the convex hull of <i class="emphasis">n</i> points drawn from such a distribution has expectation <i class="emphasis">O</i>(<i class="emphasis">n</i><sup>1-<i class="emphasis"><span class="unicode">&isin;</span></i></sup>) for some constant <i class="emphasis"><span class="unicode">&isin;</span></i> <span class="unicode">&gt;</span> 0. We call such a distribution <b class="bold"><i class="emphasis">sparse-hulled</i></b>. Sparse-hulled distributions include the following:</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">Points drawn uniformly from a unit-radius disk. The convex hull has <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>1/3</sup>) expected size.</p>
</li>
<li class="listitem">
<p class="first-para">Points drawn uniformly from the interior of a convex polygon with <i class="emphasis">k</i> sides, for any constant <i class="emphasis">k</i>. The convex hull has <span class="unicode">&Theta;</span>(lg <i class="emphasis">n</i>) expected size.</p>
</li>
<li class="listitem">
<p class="first-para">Points drawn according to a two-dimensional normal distribution. The convex hull has <span class="inlinemediaobject"><img src="images/fig986_01.jpg" height="17" width="45" alt="" border="0"></span> expected size.</p>
</li>
</ul>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Given two convex polygons with <i class="emphasis">n</i><sub>1</sub> and <i class="emphasis">n</i><sub>2</sub> vertices respectively, show how to compute the convex hull of all <i class="emphasis">n</i><sub>1</sub> + <i class="emphasis">n</i><sub>2</sub> points in <i class="emphasis">O</i>(<i class="emphasis">n</i><sub>1</sub> + <i class="emphasis">n</i><sub>2</sub>) time. (The polygons may overlap.)</p>
</li>
<li class="listitem">
<p class="first-para">Show that the convex hull of a set of <i class="emphasis">n</i> points drawn independently according to a sparse-hulled distribution can be computed in <i class="emphasis">O</i>(<i class="emphasis">n</i>) expected time. (<i class="emphasis">Hint:</i> Recursively find the convex hulls of the first <i class="emphasis">n</i>/2 points and the second <i class="emphasis">n</i>/2 points, and then combine the results.)</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0220.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0222.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
