<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Decision problems vs. optimization problems</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0225.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0227.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch34"></a>
<div class="section">
<h4 class="sect4-title">
<a name="3008"></a><a name="ch34lev3sec3"></a>Decision problems vs. optimization problems</h4>
<p class="first-para">Many problems of interest are <b class="bold"><i class="emphasis">optimization problems</i></b>, in which each feasible (i.e., "legal") solution has an associated value, and we wish to find the feasible solution with the best value. For example, in a problem that we call SHORTEST-PATH, <a name="3009"></a><a name="IDX-969"></a>we are given an undirected graph <i class="emphasis">G</i> and vertices <i class="emphasis">u</i> and <i class="emphasis">v</i>, and we wish to find the path from <i class="emphasis">u</i> to <i class="emphasis">v</i> that uses the fewest edges. (In other words, SHORTEST-PATH is the single-pair shortest-path problem in an unweighted, undirected graph.) NP-completeness applies directly not to optimization problems, however, but to <b class="bold"><i class="emphasis">decision problems</i></b>, in which the answer is simply "yes" or "no" (or, more formally, "1" or "0").</p>
<p class="para">Although showing that a problem is NP-complete confines us to the realm of decision problems, there is a convenient relationship between optimization problems and decision problems. We usually can cast a given optimization problem as a related decision problem by imposing a bound on the value to be optimized. For SHORTEST-PATH, for example, a related decision problem, which we call PATH, is whether, given a directed graph <i class="emphasis">G</i>, vertices <i class="emphasis">u</i> and <i class="emphasis">v</i>, and an integer <i class="emphasis">k</i>, a path exists from <i class="emphasis">u</i> to <i class="emphasis">v</i> consisting of at most <i class="emphasis">k</i> edges.</p>
<p class="para">The relationship between an optimization problem and its related decision problem works in our favor when we try to show that the optimization problem is "hard." That is because the decision problem is in a sense "easier," or at least "no harder." As a specific example, we can solve PATH by solving SHORTEST-PATH and then comparing the number of edges in the shortest path found to the value of the decision-problem parameter <i class="emphasis">k</i>. In other words, if an optimization problem is easy, its related decision problem is easy as well. Stated in a way that has more relevance to NP-completeness, if we can provide evidence that a decision problem is hard, we also provide evidence that its related optimization problem is hard. Thus, even though it restricts attention to decision problems, the theory of NP-completeness often has implications for optimization problems as well.</p>
<div class="section">
<h5 class="sect5-title">
<a name="3010"></a><a name="ch34lev4sec1"></a>Reductions</h5>
<p class="first-para">The above notion of showing that one problem is no harder or no easier than another applies even when both problems are decision problems. We take advantage of this idea in almost every NP-completeness proof, as follows. Let us consider a decision problem, say <i class="emphasis">A</i>, which we would like to solve in polynomial time. We call the input to a particular problem an <b class="bold"><i class="emphasis">instance</i></b> of that problem; for example, in PATH, an instance would be a particular graph <i class="emphasis">G</i>, particular vertices <i class="emphasis">u</i> and <i class="emphasis">v</i> of <i class="emphasis">G</i>, and a particular integer <i class="emphasis">k</i>. Now suppose that there is a different decision problem, say <i class="emphasis">B</i>, that we already know how to solve in polynomial time. Finally, suppose that we have a procedure that transforms any instance <span class="unicode">&alpha;</span> of <i class="emphasis">A</i> into some instance <i class="emphasis"><span class="unicode">&beta;</span></i> of <i class="emphasis">B</i> with the following characteristics:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="first-para">The transformation takes polynomial time.</p>
</li>
<li class="listitem">
<p class="first-para">The answers are the same. That is, the answer for <span class="unicode">&alpha;</span> is "yes" if and only if the answer for <i class="emphasis"><span class="unicode">&beta;</span></i> is also "yes."</p>
</li>
</ol>
<a name="3011"></a><a name="IDX-970"></a>
<p class="para">We call such a procedure a polynomial-time <b class="bold"><i class="emphasis">reduction algorithm</i></b> and, as <a class="internaljump" href="#ch34fig01">Figure 34.1</a> shows, it provides us a way to solve problem <i class="emphasis">A</i> in polynomial time:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="first-para">Given an instance <span class="unicode">&alpha;</span> of problem <i class="emphasis">A</i>, use a polynomial-time reduction algorithm to transform it to an instance <i class="emphasis"><span class="unicode">&beta;</span></i> of problem <i class="emphasis">B</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Run the polynomial-time decision algorithm for <i class="emphasis">B</i> on the instance <i class="emphasis"><span class="unicode">&beta;</span></i>.</p>
</li>
<li class="listitem">
<p class="first-para">Use the answer for <i class="emphasis"><span class="unicode">&beta;</span></i> as the answer for <i class="emphasis"><span class="unicode">&alpha;</span></i>.</p>
</li>
</ol>
<div class="figure">
<a name="3012"></a><a name="ch34fig01"></a><span class="figuremediaobject"><a href="images/fig992%5F01%5F0%2Ejpg" NAME="IMG_1788" target="_parent"><img src="images/fig992_01.jpg" height="60" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 34.1: </span>Using a polynomial-time reduction algorithm to solve a decision problem <i class="emphasis">A</i> in polynomial time, given a polynomial-time decision algorithm for another problem <i class="emphasis">B</i>. In polynomial time, we transform an instance <i class="emphasis"><span class="unicode">&alpha;</span></i> of <i class="emphasis">A</i> into an instance <i class="emphasis"><span class="unicode">&beta;</span></i> of <i class="emphasis">B</i>, we solve <i class="emphasis">B</i> in polynomial time, and we use the answer for <i class="emphasis"><span class="unicode">&beta;</span></i> as the answer for <i class="emphasis"><span class="unicode">&alpha;</span></i>.</span>
</div>
<p class="para">As long as each of these steps takes polynomial time, all three together do also, and so we have a way to decide on <span class="unicode">&alpha;</span> in polynomial time. In other words, by "reducing" solving problem <i class="emphasis">A</i> to solving problem <i class="emphasis">B</i>, we use the "easiness" of <i class="emphasis">B</i> to prove the "easiness" of <i class="emphasis">A</i>.</p>
<p class="para">Recalling that NP-completeness is about showing how hard a problem is rather than how easy it is, we use polynomial-time reductions in the opposite way to show that a problem is NP-complete. Let us take the idea a step further, and show how we could use polynomial-time reductions to show that no polynomial-time algorithm can exist for a particular problem <i class="emphasis">B</i>. Suppose we have a decision problem <i class="emphasis">A</i> for which we already know that no polynomial-time algorithm can exist. (Let us not concern ourselves for now with how to find such a problem <i class="emphasis">A</i>.) Suppose further that we have a polynomial-time reduction transforming instances of <i class="emphasis">A</i> to instances of <i class="emphasis">B</i>. Now we can use a simple proof by contradiction to show that no polynomial-time algorithm can exist for <i class="emphasis">B</i>. Suppose otherwise, i.e., suppose that <i class="emphasis">B</i> has a polynomial-time algorithm. Then, using the method shown in <a class="internaljump" href="#ch34fig01">Figure 34.1</a>, we would have a way to solve problem <i class="emphasis">A</i> in polynomial time, which contradicts our assumption that there is no polynomial-time algorithm for <i class="emphasis">A</i>.</p>
<p class="para">For NP-completeness, we cannot assume that there is absolutely no polynomial-time algorithm for problem <i class="emphasis">A</i>. The proof methodology is similar, however, in that we prove that problem <i class="emphasis">B</i> is NP-complete on the assumption that problem <i class="emphasis">A</i> is also NP-complete.</p>
<a name="3013"></a><a name="IDX-971"></a>

</div>
<div class="section">
<h5 class="sect5-title">
<a name="3014"></a><a name="ch34lev4sec2"></a>A first NP-complete problem</h5>
<p class="first-para">Because the technique of reduction relies on having a problem already known to be NP-complete in order to prove a different problem NP-complete, we need a "first" NP-complete problem. The problem we shall use is the circuit-satisfiability problem, in which we are given a boolean combinational circuit composed of AND, OR, and NOT gates, and we wish to know whether there is any set of boolean inputs to this circuit that causes its output to be 1. We shall prove that this first problem is NP-complete in <a href="DDU0230.html#3057" target="_parent" class="chapterjump">Section 34.3</a>.</p>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0225.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0227.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
