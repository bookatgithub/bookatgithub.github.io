<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>34.1 Polynomial time</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0227.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0229.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch34"></a>
<div class="section">
<h2 class="first-section-title">
<a name="3016"></a><a name="ch34lev1sec1"></a><span class="section-titlelabel">34.1 </span>Polynomial time</h2>
<p class="first-para">We begin our study of NP-completeness by formalizing our notion of polynomial-time solvable problems. These problems are generally regarded as tractable, but for philosophical, not mathematical, reasons. We can offer three supporting arguments.</p>
<p class="para">First, although it is reasonable to regard a problem that requires time <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>100</sup>) as intractable, there are very few practical problems that require time on the order of such a high-degree polynomial. The polynomial-time computable problems encountered in practice typically require much less time. Experience has shown that once a polynomial-time algorithm for a problem is discovered, more efficient algorithms often follow. Even if the current best algorithm for a problem has a running time of <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>100</sup>), it is likely that an algorithm with a much better running time will soon be discovered.<a name="3017"></a><a name="IDX-972"></a>
</p>
<p class="para">Second, for many reasonable models of computation, a problem that can be solved in polynomial time in one model can be solved in polynomial time in another. For example, the class of problems solvable in polynomial time by the serial random-access machine used throughout most of this book is the same as the class of problems solvable in polynomial time on abstract Turing machines.<sup>[<a name="N46" href="#ftn.N46">1</a>]</sup> It is also the same as the class of problems solvable in polynomial time on a parallel computer when the number of processors grows polynomially with the input size.</p>
<p class="para">Third, the class of polynomial-time solvable problems has nice closure properties, since polynomials are closed under addition, multiplication, and composition. For example, if the output of one polynomial-time algorithm is fed into the input of another, the composite algorithm is polynomial. If an otherwise polynomial-time algorithm makes a constant number of calls to polynomial-time subroutines, the running time of the composite algorithm is polynomial.</p>
<div class="section">
<h4 class="sect4-title">
<a name="3018"></a><a name="ch34lev3sec5"></a>Abstract problems</h4>
<p class="first-para">To understand the class of polynomial-time solvable problems, we must first have a formal notion of what a "problem" is. We define an <b class="bold"><i class="emphasis">abstract problem</i></b> <i class="emphasis">Q</i> to be a binary relation on a set <i class="emphasis">I</i> of problem <b class="bold"><i class="emphasis">instances</i></b> and a set <i class="emphasis">S</i> of problem <b class="bold"><i class="emphasis">solutions</i></b>. For example, an instance for SHORTEST-PATH is a triple consisting of a graph and two vertices. A solution is a sequence of vertices in the graph, with perhaps the empty sequence denoting that no path exists. The problem SHORTEST-PATH itself is the relation that associates each instance of a graph and two vertices with a shortest path in the graph that connects the two vertices. Since shortest paths are not necessarily unique, a given problem instance may have more than one solution.</p>
<p class="para">This formulation of an abstract problem is more general than is required for our purposes. As we saw above, the theory of NP-completeness restricts attention to <b class="bold"><i class="emphasis">decision problems</i></b>: those having a yes/no solution. In this case, we can view an abstract decision problem as a function that maps the instance set <i class="emphasis">I</i> to the solution set {0, 1}. For example, a decision problem related to SHORTEST-PATH is the problem PATH that we saw earlier. If <i class="emphasis">i</i> = <span class="unicode">&#12296;</span><i class="emphasis">G</i>, <i class="emphasis">u</i>, <i class="emphasis">v</i>, <i class="emphasis">k</i><span class="unicode">&#12297;</span> is an instance of the decision problem PATH, then PATH(<i class="emphasis">i</i>) = 1 (yes) if a shortest path from <i class="emphasis">u</i> to <i class="emphasis">v</i> has at most <i class="emphasis">k</i> edges, and PATH(<i class="emphasis">i</i>) = 0 (no) otherwise. Many abstract problems are not decision problems, but rather <b class="bold"><i class="emphasis">optimization problems</i></b>, in which some value must be minimized or maximized. As we saw above, however, it is usually a simple matter to recast an optimization problem as a decision problem that is no harder.</p>
<a name="3019"></a><a name="IDX-973"></a>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="3020"></a><a name="ch34lev3sec6"></a>Encodings</h4>
<p class="first-para">If a computer program is to solve an abstract problem, problem instances must be represented in a way that the program understands. An <b class="bold"><i class="emphasis">encoding</i></b> of a set <i class="emphasis">S</i> of abstract objects is a mapping <i class="emphasis">e</i> from <i class="emphasis">S</i> to the set of binary strings.<sup>[<a name="N175" href="#ftn.N175">2</a>]</sup> For example, we are all familiar with encoding the natural numbers <b class="bold">N</b> = {0, 1, 2, 3, 4,...} as the strings {0, 1, 10, 11, 100,...}. Using this encoding, <i class="emphasis">e</i>(17) = 10001. Anyone who has looked at computer representations of keyboard characters is familiar with either the ASCII or EBCDIC codes. In the ASCII code, the encoding of <span class="fixed">A</span> is 1000001. Even a compound object can be encoded as a binary string by combining the representations of its constituent parts. Polygons, graphs, functions, ordered pairs, programs<span class="unicode">-</span>all can be encoded as binary strings.</p>
<p class="para">Thus, a computer algorithm that "solves" some abstract decision problem actually takes an encoding of a problem instance as input. We call a problem whose instance set is the set of binary strings a <b class="bold"><i class="emphasis">concrete problem</i></b>. We say that an algorithm <b class="bold"><i class="emphasis">solves</i></b> a concrete problem in time <i class="emphasis">O</i>(<i class="emphasis">T</i> (<i class="emphasis">n</i>)) if, when it is provided a problem instance <i class="emphasis">i</i> of length <i class="emphasis">n</i> = |<i class="emphasis">i</i>|, the algorithm can produce the solution in <i class="emphasis">O</i>(<i class="emphasis">T</i> (<i class="emphasis">n</i>)) time.<sup>[<a name="N244" href="#ftn.N244">3</a>]</sup> A concrete problem is <b class="bold"><i class="emphasis">polynomial-time solvable</i></b>, therefore, if there exists an algorithm to solve it in time <i class="emphasis">O</i>(<i class="emphasis">n<sup>k</sup></i>) for some constant <i class="emphasis">k</i>.</p>
<p class="para">We can now formally define the <b class="bold"><i class="emphasis">complexity class</i></b> <b class="bold">P</b> as the set of concrete decision problems that are polynomial-time solvable.</p>
<p class="para">We can use encodings to map abstract problems to concrete problems. Given an abstract decision problem <i class="emphasis">Q</i> mapping an instance set <i class="emphasis">I</i> to {0, 1}, an encoding <i class="emphasis">e</i> : <i class="emphasis">I</i> <span class="unicode">&rarr;</span> {0, 1}* can be used to induce a related concrete decision problem, which we denote by <i class="emphasis">e</i>(<i class="emphasis">Q</i>).<sup>[<a name="N320" href="#ftn.N320">4</a>]</sup> If the solution to an abstract-problem instance <i class="emphasis">i</i> <span class="unicode">&isin;</span> <i class="emphasis">I</i> is <i class="emphasis">Q</i>(<i class="emphasis">i</i>) <span class="unicode">&isin;</span> {0, 1}, then the solution to the concrete-problem instance <i class="emphasis">e</i>(<i class="emphasis">i</i>) <span class="unicode">&isin;</span> {0, 1}* is also <i class="emphasis">Q</i>(<i class="emphasis">i</i>). As a technicality, there may be some binary strings that represent no meaningful abstract-problem instance. For convenience, we shall assume that any such string is mapped arbitrarily to 0. Thus, the concrete problem produces the same solutions as the abstract problem on binary-string instances that represent the encodings of abstract-problem instances.</p>
<p class="para">We would like to extend the definition of polynomial-time solvability from concrete problems to abstract problems by using encodings as the bridge, but we would <a name="3021"></a><a name="IDX-974"></a>like the definition to be independent of any particular encoding. That is, the efficiency of solving a problem should not depend on how the problem is encoded. Unfortunately, it depends quite heavily on the encoding. For example, suppose that an integer <i class="emphasis">k</i> is to be provided as the sole input to an algorithm, and suppose that the running time of the algorithm is <span class="unicode">&Theta;</span>(<i class="emphasis">k</i>). If the integer <i class="emphasis">k</i> is provided in <b class="bold"><i class="emphasis">unary</i></b><span class="unicode">-</span>a string of <i class="emphasis">k</i> 1's<span class="unicode">-</span>then the running time of the algorithm is <i class="emphasis">O</i>(<i class="emphasis">n</i>) on length-<i class="emphasis">n</i> inputs, which is polynomial time. If we use the more natural binary representation of the integer <i class="emphasis">k</i>, however, then the input length is <i class="emphasis">n</i> = <span class="unicode">&lfloor;</span>lg <i class="emphasis">k</i><span class="unicode">&rfloor;</span> + 1. In this case, the running time of the algorithm is <span class="unicode">&Theta;</span> (<i class="emphasis">k</i>) = <span class="unicode">&Theta;</span>(2<sup><i class="emphasis">n</i></sup>), which is exponential in the size of the input. Thus, depending on the encoding, the algorithm runs in either polynomial or superpolynomial time.</p>
<p class="para">The encoding of an abstract problem is therefore quite important to our under-standing of polynomial time. We cannot really talk about solving an abstract problem without first specifying an encoding. Nevertheless, in practice, if we rule out "expensive" encodings such as unary ones, the actual encoding of a problem makes little difference to whether the problem can be solved in polynomial time. For example, representing integers in base 3 instead of binary has no effect on whether a problem is solvable in polynomial time, since an integer represented in base 3 can be converted to an integer represented in base 2 in polynomial time.</p>
<p class="para">We say that a function <i class="emphasis">f</i> : {0, 1}* <span class="unicode">&rarr;</span> {0,1}* is <b class="bold"><i class="emphasis">polynomial-time computable</i></b> if there exists a polynomial-time algorithm <i class="emphasis">A</i> that, given any input <i class="emphasis">x</i> <span class="unicode">&isin;</span> {0, 1}*, produces as output <i class="emphasis">f</i> (<i class="emphasis">x</i>). For some set <i class="emphasis">I</i> of problem instances, we say that two encodings <i class="emphasis">e</i><sub>1</sub> and <i class="emphasis">e</i><sub>2</sub> are <b class="bold"><i class="emphasis">polynomially related</i></b> if there exist two polynomial-time computable functions <i class="emphasis">f</i><sub>12</sub> and <i class="emphasis">f</i><sub>21</sub> such that for any <i class="emphasis">i</i> <span class="unicode">&isin;</span> <i class="emphasis">I</i> , we have <i class="emphasis">f</i><sub>12</sub>(<i class="emphasis">e</i><sub>1</sub>(<i class="emphasis">i</i>)) = <i class="emphasis">e</i><sub>2</sub>(<i class="emphasis">i</i>) and <i class="emphasis">f</i><sub>21</sub>(<i class="emphasis">e</i><sub>2</sub>(<i class="emphasis">i</i>)) = <i class="emphasis">e</i><sub>1</sub>(<i class="emphasis">i</i>).<sup>[<a name="N553" href="#ftn.N553">5</a>]</sup> That is, the encoding <i class="emphasis">e</i><sub>2</sub>(<i class="emphasis">i</i>) can be computed from the encoding <i class="emphasis">e</i><sub>1</sub>(<i class="emphasis">i</i>) by a polynomial-time algorithm, and vice versa. If two encodings <i class="emphasis">e</i><sub>1</sub> and <i class="emphasis">e</i><sub>2</sub> of an abstract problem are polynomially related, whether the problem is polynomial-time solvable or not is independent of which encoding we use, as the following lemma shows.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 34.1</span></span><a name="3022"></a><a name="ch34ex01"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">Q</i> be an abstract decision problem on an instance set <i class="emphasis">I</i> , and let <i class="emphasis">e</i><sub>1</sub> and <i class="emphasis">e</i><sub>2</sub> be polynomially related encodings on <i class="emphasis">I</i> . Then, <i class="emphasis">e</i><sub>1</sub>(<i class="emphasis">Q</i>) <span class="unicode">&isin;</span> P if and only if <i class="emphasis">e</i><sub>2</sub>(<i class="emphasis">Q</i>) <span class="unicode">&isin;</span> P.<a name="3023"></a><a name="IDX-975"></a>
</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> We need only prove the forward direction, since the backward direction is symmetric. Suppose, therefore, that <i class="emphasis">e</i><sub>1</sub>(<i class="emphasis">Q</i>) can be solved in time <i class="emphasis">O</i>(<i class="emphasis">n<sub>k</sub></i>) for some constant <i class="emphasis">k</i>. Further, suppose that for any problem instance <i class="emphasis">i</i>, the encoding <i class="emphasis">e</i><sub>1</sub>(<i class="emphasis">i</i>) can be computed from the encoding <i class="emphasis">e</i><sub>2</sub>(<i class="emphasis">i</i>) in time <i class="emphasis">O</i>(<i class="emphasis">n<sup>c</sup></i>) for some constant <i class="emphasis">c</i>, where <i class="emphasis">n</i> = |<i class="emphasis">e</i><sub>2</sub>(<i class="emphasis">i</i>)|. To solve problem <i class="emphasis">e</i><sub>2</sub>(<i class="emphasis">Q</i>), on input <i class="emphasis">e</i><sub>2</sub>(<i class="emphasis">i</i>), we first compute <i class="emphasis">e</i><sub>1</sub>(<i class="emphasis">i</i>) and then run the algorithm for <i class="emphasis">e</i><sub>1</sub>(<i class="emphasis">Q</i>) on <i class="emphasis">e</i><sub>1</sub>(<i class="emphasis">i</i>). How long does this take? The conversion of encodings takes time <i class="emphasis">O</i>(<i class="emphasis">n<sup>c</sup></i>), and therefore |<i class="emphasis">e</i><sub>1</sub>(<i class="emphasis">i</i>)| = <i class="emphasis">O</i>(<i class="emphasis">n<sup>c</sup></i>), since the output of a serial computer cannot be longer than its running time. Solving the problem on <i class="emphasis">e</i><sub>1</sub>(<i class="emphasis">i</i>) takes time <i class="emphasis">O</i>(|<i class="emphasis">e</i><sub>1</sub>(<i class="emphasis">i</i>)|<sup><i class="emphasis">k</i></sup>) = <i class="emphasis">O</i>(<i class="emphasis">n</i><sup><i class="emphasis">ck</i></sup>), which is polynomial since both <i class="emphasis">c</i> and <i class="emphasis">k</i> are constants.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">Thus, whether an abstract problem has its instances encoded in binary or base 3 does not affect its "complexity," that is, whether it is polynomial-time solvable or not, but if instances are encoded in unary, its complexity may change. In order to be able to converse in an encoding-independent fashion, we shall generally assume that problem instances are encoded in any reasonable, concise fashion, unless we specifically say otherwise. To be precise, we shall assume that the encoding of an integer is polynomially related to its binary representation, and that the encoding of a finite set is polynomially related to its encoding as a list of its elements, enclosed in braces and separated by commas. (ASCII is one such encoding scheme.) With such a "standard" encoding in hand, we can derive reasonable encodings of other mathematical objects, such as tuples, graphs, and formulas. To denote the standard encoding of an object, we shall enclose the object in angle braces. Thus, <span class="unicode">&#12296;</span><i class="emphasis">G</i><span class="unicode">&#12297;</span> denotes the standard encoding of a graph <i class="emphasis">G</i>.</p>
<p class="last-para">As long as we implicitly use an encoding that is polynomially related to this standard encoding, we can talk directly about abstract problems without reference to any particular encoding, knowing that the choice of encoding has no effect on whether the abstract problem is polynomial-time solvable. Henceforth, we shall generally assume that all problem instances are binary strings encoded using the standard encoding, unless we explicitly specify the contrary. We shall also typically neglect the distinction between abstract and concrete problems. The reader should watch out for problems that arise in practice, however, in which a standard encoding is not obvious and the encoding does make a difference.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="3024"></a><a name="ch34lev3sec7"></a>A formal-language framework</h4>
<p class="first-para">One of the convenient aspects of focusing on decision problems is that they make it easy to use the machinery of formal-language theory. It is worthwhile at this point to review some definitions from that theory. An <b class="bold"><i class="emphasis">alphabet</i></b> <span class="unicode">&Sigma;</span> is a finite set of symbols. A <b class="bold"><i class="emphasis">language</i></b> <i class="emphasis">L</i> over <span class="unicode">&Sigma;</span> is any set of strings made up of symbols from <span class="unicode">&Sigma;</span>. For example, if <span class="unicode">&Sigma;</span> = {0, 1}, the set <i class="emphasis">L</i> = {10, 11, 101, 111, 1011, 1101, 10001,...} is the language of binary representations of prime numbers. We denote the <b class="bold"><i class="emphasis">empty</i></b> <a name="3025"></a><a name="IDX-976"></a><b class="bold"><i class="emphasis">string</i></b> by <i class="emphasis"><span class="unicode">&epsilon;</span></i>, and the <b class="bold"><i class="emphasis">empty language</i></b> by <span class="unicode">&Oslash;</span>. The language of all strings over <span class="unicode">&Sigma;</span> is denoted <span class="unicode">&Sigma;</span>*. For example, if <span class="unicode">&Sigma;</span> = {0, 1}, then <span class="unicode">&Sigma;</span>* = {<i class="emphasis"><span class="unicode">&epsilon;</span></i>, 0, 1, 00, 01, 10, 11, 000,...} is the set of all binary strings. Every language <i class="emphasis">L</i> over <span class="unicode">&Sigma;</span> is a subset of <span class="unicode">&Sigma;</span>*.</p>
<p class="para">There are a variety of operations on languages. Set-theoretic operations, such as <b class="bold"><i class="emphasis">union</i></b> and <b class="bold"><i class="emphasis">intersection</i></b>, follow directly from the set-theoretic definitions. We define the <b class="bold"><i class="emphasis">complement</i></b> of <i class="emphasis">L</i> by <span class="inlinemediaobject"><img src="images/fig998_01.jpg" height="15" width="70" alt="" border="0"></span>. The <b class="bold"><i class="emphasis">concatenation</i></b> of two languages <i class="emphasis">L</i><sub>1</sub> and <i class="emphasis">L</i><sub>2</sub> is the language</p>
<p class="para">
<i class="emphasis">L</i> = {<i class="emphasis">x</i><sub>1</sub><i class="emphasis">x</i><sub>2</sub> : <i class="emphasis">x</i><sub>1</sub> <span class="unicode">&isin;</span> <i class="emphasis">L</i><sub>1</sub> and <i class="emphasis">x</i><sub>2</sub> <span class="unicode">&isin;</span> <i class="emphasis">L</i><sub>2</sub>}.</p>
<p class="para">The <b class="bold"><i class="emphasis">closure</i></b> or <b class="bold"><i class="emphasis">Kleene star</i></b> of a language <i class="emphasis">L</i> is the language</p>
<p class="para">
<i class="emphasis">L</i>*= {<i class="emphasis"><span class="unicode">&epsilon;</span></i>} <span class="unicode">&cup;</span> <i class="emphasis">L</i> <span class="unicode">&cup;</span> <i class="emphasis">L</i><sup>2</sup> <span class="unicode">&cup;</span> <i class="emphasis">L</i><sup>3</sup> <span class="unicode">&cup;</span> <span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&middot;</span>,</p>
<p class="para">where <i class="emphasis">L<sub>k</sub></i> is the language obtained by concatenating <i class="emphasis">L</i> to itself <i class="emphasis">k</i> times.</p>
<p class="para">From the point of view of language theory, the set of instances for any decision problem <i class="emphasis">Q</i> is simply the set <span class="unicode">&Sigma;</span>*, where <span class="unicode">&Sigma;</span> = {0, 1}. Since <i class="emphasis">Q</i> is entirely characterized by those problem instances that produce a 1 (yes) answer, we can view <i class="emphasis">Q</i> as a language <i class="emphasis">L</i> over <span class="unicode">&Sigma;</span> = {0, 1}, where</p>
<p class="para">
<i class="emphasis">L</i> = {<i class="emphasis">x</i> <span class="unicode">&isin;</span> <span class="unicode">&Sigma;</span>*: <i class="emphasis">Q</i>(<i class="emphasis">x</i>) = 1}.</p>
<p class="para">For example, the decision problem PATH has the corresponding language</p>
<p class="para">PATH = {<span class="unicode">&#12296;</span><i class="emphasis">G</i>, <i class="emphasis">u</i>, <i class="emphasis">v</i>, <i class="emphasis">k</i><span class="unicode">&#12297;</span> : <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) is an undirected graph, <i class="emphasis">u</i>, <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, <i class="emphasis">k</i> <span class="unicode">&ge;</span> 0 is an integer, and there exists a path from <i class="emphasis">u</i> to <i class="emphasis">v</i> in <i class="emphasis">G</i> consisting of at most <i class="emphasis">k</i> edges}.</p>
<p class="para">(Where convenient, we shall sometimes use the same name<span class="unicode">-</span>PATH in this case<span class="unicode">-</span> to refer to both a decision problem and its corresponding language.)</p>
<p class="para">The formal-language framework allows us to express the relation between decision problems and algorithms that solve them concisely. We say that an algorithm <i class="emphasis">A</i> <b class="bold"><i class="emphasis">accepts</i></b> a string <i class="emphasis">x</i> <span class="unicode">&isin;</span> {0, 1}* if, given input <i class="emphasis">x</i>, the algorithm's output <i class="emphasis">A</i>(<i class="emphasis">x</i>) is 1. The language <b class="bold"><i class="emphasis">accepted</i></b> by an algorithm <i class="emphasis">A</i> is the set of strings <i class="emphasis">L</i> = {<i class="emphasis">x</i> <span class="unicode">&isin;</span> {0, 1}*: <i class="emphasis">A</i>(<i class="emphasis">x</i>) = 1}, that is, the set of strings that the algorithm accepts. An algorithm <i class="emphasis">A</i> <b class="bold"><i class="emphasis">rejects</i></b> a string <i class="emphasis">x</i> if <i class="emphasis">A</i>(<i class="emphasis">x</i>) = 0.</p>
<p class="para">Even if language <i class="emphasis">L</i> is accepted by an algorithm <i class="emphasis">A</i>, the algorithm will not necessarily reject a string <i class="emphasis">x</i> <span class="unicode">&notin;</span> <i class="emphasis">L</i> provided as input to it. For example, the algorithm may loop forever. A language <i class="emphasis">L</i> is <b class="bold"><i class="emphasis">decided</i></b> by an algorithm <i class="emphasis">A</i> if every binary string in <i class="emphasis">L</i> is accepted by <i class="emphasis">A</i> and every binary string not in <i class="emphasis">L</i> is rejected by <i class="emphasis">A</i>. A language <i class="emphasis">L</i> is <b class="bold"><i class="emphasis">accepted in polynomial time</i></b> by an algorithm <i class="emphasis">A</i> if it is accepted by <i class="emphasis">A</i> and if in addition there is a constant <i class="emphasis">k</i> such that for any length-<i class="emphasis">n</i> string <i class="emphasis">x</i> <span class="unicode">&isin;</span> <i class="emphasis">L</i>, algorithm <i class="emphasis">A</i> accepts <i class="emphasis">x</i> in time <i class="emphasis">O</i>(<i class="emphasis">n<sup>k</sup></i>). A language <i class="emphasis">L</i> is <b class="bold"><i class="emphasis">decided in polynomial time</i></b> by an algorithm <i class="emphasis">A</i> if there is a constant <i class="emphasis">k</i> such that for any length-<i class="emphasis">n</i> string <i class="emphasis">x</i> <span class="unicode">&isin;</span> {0, 1}*, the <a name="3026"></a><a name="IDX-977"></a>algorithm correctly decides whether <i class="emphasis">x</i> <span class="unicode">&isin;</span> <i class="emphasis">L</i> in time <i class="emphasis">O</i>(<i class="emphasis">n<sup>k</sup></i>). Thus, to accept a language, an algorithm need only worry about strings in <i class="emphasis">L</i>, but to decide a language, it must correctly accept or reject every string in {0, 1}*.</p>
<p class="para">As an example, the language PATH can be accepted in polynomial time. One polynomial-time accepting algorithm verifies that <i class="emphasis">G</i> encodes an undirected graph, verifies that <i class="emphasis">u</i> and <i class="emphasis">v</i> are vertices in <i class="emphasis">G</i>, uses breadth-first search to compute the shortest path from <i class="emphasis">u</i> to <i class="emphasis">v</i> in <i class="emphasis">G</i>, and then compares the number of edges on the shortest path obtained with <i class="emphasis">k</i>. If <i class="emphasis">G</i> encodes an undirected graph and the path from <i class="emphasis">u</i> to <i class="emphasis">v</i> has at most <i class="emphasis">k</i> edges, the algorithm outputs 1 and halts. Otherwise, the algorithm runs forever. This algorithm does not decide PATH, however, since it does not explicitly output 0 for instances in which the shortest path has more than <i class="emphasis">k</i> edges. A decision algorithm for PATH must explicitly reject binary strings that do not belong to PATH. For a decision problem such as PATH, such a decision algorithm is easy to design: instead of running forever when there is not a path from <i class="emphasis">u</i> to <i class="emphasis">v</i> with at most <i class="emphasis">k</i> edges, it outputs 0 and halts. For other problems, such as Turing's Halting Problem, there exists an accepting algorithm, but no decision algorithm exists.</p>
<p class="para">We can informally define a <b class="bold"><i class="emphasis">complexity class</i></b> as a set of languages, membership in which is determined by a <b class="bold"><i class="emphasis">complexity measure</i></b>, such as running time, of an algorithm that determines whether a given string <i class="emphasis">x</i> belongs to language <i class="emphasis">L</i>. The actual definition of a complexity class is somewhat more technical<span class="unicode">-</span>the interested reader is referred to the seminal paper by <a href="DDU0259.html#3695" target="_parent" class="chapterjump">Hartmanis and Stearns [140]</a>.</p>
<p class="para">Using this language-theoretic framework, we can provide an alternative definition of the complexity class P:</p>
<p class="para">P = {<i class="emphasis">L</i> <span class="unicode">&sube;</span> {0, 1}* : there exists an algorithm <i class="emphasis">A</i> that decides <i class="emphasis">L</i> in polynomial time} .</p>
<p class="para">In fact, P is also the class of languages that can be accepted in polynomial time.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 34.2</span></span><a name="3027"></a><a name="ch34ex02"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">P = {<i class="emphasis">L</i> : <i class="emphasis">L</i> is accepted by a polynomial-time algorithm}.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Since the class of languages decided by polynomial-time algorithms is a subset of the class of languages accepted by polynomial-time algorithms, we need only show that if <i class="emphasis">L</i> is accepted by a polynomial-time algorithm, it is decided by a polynomial-time algorithm. Let <i class="emphasis">L</i> be the language accepted by some polynomial-time algorithm <i class="emphasis">A</i>. We shall use a classic "simulation" argument to construct another polynomial-time algorithm <i class="emphasis">A</i><span class="unicode">&prime;</span> that decides <i class="emphasis">L</i>. Because <i class="emphasis">A</i> accepts <i class="emphasis">L</i> in time <i class="emphasis">O</i>(<i class="emphasis">n<sup>k</sup></i>) for some constant <i class="emphasis">k</i>, there also exists a constant <i class="emphasis">c</i> such that <i class="emphasis">A</i> accepts <i class="emphasis">L</i> in at most <i class="emphasis">T</i> = <i class="emphasis">cn<sup>k</sup></i> steps. For any input string <i class="emphasis">x</i>, the algorithm <i class="emphasis">A</i><span class="unicode">&prime;</span> simulates the action of <i class="emphasis">A</i> for time <i class="emphasis">T</i>. At the end of time <i class="emphasis">T</i>, algorithm <i class="emphasis">A</i><span class="unicode">&prime;</span> inspects <a name="3028"></a><a name="IDX-978"></a>the behavior of <i class="emphasis">A</i>. If <i class="emphasis">A</i> has accepted <i class="emphasis">x</i>, then <i class="emphasis">A</i><span class="unicode">&prime;</span> accepts <i class="emphasis">x</i> by outputting a 1. If <i class="emphasis">A</i> has not accepted <i class="emphasis">x</i>, then <i class="emphasis">A</i><span class="unicode">&prime;</span> rejects <i class="emphasis">x</i> by outputting a 0. The overhead of <i class="emphasis">A</i><span class="unicode">&prime;</span> simulating <i class="emphasis">A</i> does not increase the running time by more than a polynomial factor, and thus <i class="emphasis">A</i><span class="unicode">&prime;</span> is a polynomial-time algorithm that decides <i class="emphasis">L</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">Note that the proof of <a class="internaljump" href="#ch34ex02">Theorem 34.2</a> is nonconstructive. For a given language <i class="emphasis">L</i> <span class="unicode">&isin;</span> P, we may not actually know a bound on the running time for the algorithm <i class="emphasis">A</i> that accepts <i class="emphasis">L</i>. Nevertheless, we know that such a bound exists, and therefore, that an algorithm <i class="emphasis">A</i><span class="unicode">&prime;</span> exists that can check the bound, even though we may not be able to find the algorithm <i class="emphasis">A</i><span class="unicode">&prime;</span> easily.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.1-1</span></span><a name="3029"></a><a name="ch34ex03"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Define the optimization problem LONGEST-PATH-LENGTH as the relation that associates each instance of an undirected graph and two vertices with the number of edges in the longest simple path between the two vertices. Define the decision problem LONGEST-PATH = {<span class="unicode">&#12296;</span><i class="emphasis">G</i>, <i class="emphasis">u</i>, <i class="emphasis">v</i>, <i class="emphasis">k</i><span class="unicode">&#12297;</span> : <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) is an undirected graph, <i class="emphasis">u</i>, <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> , <i class="emphasis">k</i> <span class="unicode">&ge;</span> 0 is an integer, and there exists a simple path from <i class="emphasis">u</i> to <i class="emphasis">v</i> in <i class="emphasis">G</i> consisting of at least <i class="emphasis">k</i> edges}. Show that the optimization problem LONGEST-PATH-LENGTH can be solved in polynomial time if and only if LONGEST-PATH <span class="unicode">&isin;</span> P.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.1-2</span></span><a name="3030"></a><a name="ch34ex04"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Give a formal definition for the problem of finding the longest simple cycle in an undirected graph. Give a related decision problem. Give the language corresponding to the decision problem.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.1-3</span></span><a name="3031"></a><a name="ch34ex05"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Give a formal encoding of directed graphs as binary strings using an adjacency-matrix representation. Do the same using an adjacency-list representation. Argue that the two representations are polynomially related.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.1-4</span></span><a name="3032"></a><a name="ch34ex06"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Is the dynamic-programming algorithm for the 0-1 knapsack problem that is asked for in <a href="DDU0095.html#1182" target="_parent" class="chapterjump">Exercise 16.2-2</a> a polynomial-time algorithm? Explain your answer.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.1-5</span></span><a name="3033"></a><a name="ch34ex07"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that an otherwise polynomial-time algorithm that makes at most a constant number of calls to polynomial-time subroutines runs in polynomial time, but that a polynomial number of calls to polynomial-time subroutines may result in an exponential-time algorithm.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="3034"></a><a name="IDX-979"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.1-6</span></span><a name="3035"></a><a name="ch34ex08"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that the class P, viewed as a set of languages, is closed under union, inter-section, concatenation, complement, and Kleene star. That is, if <i class="emphasis">L</i><sub>1</sub>, <i class="emphasis">L</i><sub>2</sub> <span class="unicode">&isin;</span> P, then <i class="emphasis">L</i><sub>1</sub> <span class="unicode">&cup;</span> <i class="emphasis">L</i><sub>2</sub> <span class="unicode">&isin;</span> P, etc.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
<div class="footnotes">
<div class="footnote">
<p>
<sup>[<a name="ftn.N46" href="#N46">1</a>]</sup>See <a href="DDU0259.html#3711" target="_parent" class="chapterjump">Hopcroft and Ullman [156]</a> or <a href="DDU0259.html#3759" target="_parent" class="chapterjump">Lewis and Papadimitriou [204]</a> for a thorough treatment of the Turing-machine model.</p>
</div>
<div class="footnote">
<p>
<sup>[<a name="ftn.N175" href="#N175">2</a>]</sup>The codomain of <i class="emphasis">e</i> need not be <i class="emphasis">binary</i> strings; any set of strings over a finite alphabet having at least 2 symbols will do.</p>
</div>
<div class="footnote">
<p>
<sup>[<a name="ftn.N244" href="#N244">3</a>]</sup>We assume that the algorithm's output is separate from its input. Because it takes at least one time step to produce each bit of the output and there are <i class="emphasis">O</i>(<i class="emphasis">T</i> (<i class="emphasis">n</i>)) time steps, the size of the output is <i class="emphasis">O</i>(<i class="emphasis">T</i> (<i class="emphasis">n</i>)).</p>
</div>
<div class="footnote">
<p>
<sup>[<a name="ftn.N320" href="#N320">4</a>]</sup>As we shall see shortly, {0, 1}* denotes the set of all strings composed of symbols from the set {0, 1}.</p>
</div>
<div class="footnote">
<p>
<sup>[<a name="ftn.N553" href="#N553">5</a>]</sup>Technically, we also require the functions <i class="emphasis">f</i><sub>12</sub> and <i class="emphasis">f</i><sub>21</sub> to "map noninstances to noninstances." A <b class="bold"><i class="emphasis">noninstance</i></b> of an encoding <i class="emphasis">e</i> is a string <i class="emphasis">x</i> <span class="unicode">&isin;</span> {0, 1}* such that there is no instance <i class="emphasis">i</i> for which <i class="emphasis">e</i>(<i class="emphasis">i</i>) = <i class="emphasis">x</i>. We require that <i class="emphasis">f</i><sub>12</sub>(<i class="emphasis">x</i>) = <i class="emphasis">y</i> for every noninstance <i class="emphasis">x</i> of encoding <i class="emphasis">e</i><sub>1</sub>, where <i class="emphasis">y</i> is some noninstance of <i class="emphasis">e</i><sub>2</sub>, and that <i class="emphasis">f</i><sub>21</sub>(<i class="emphasis">x</i><span class="unicode">&prime;</span>) = <i class="emphasis">y</i><span class="unicode">&prime;</span> for every noninstance <i class="emphasis">x</i><span class="unicode">&prime;</span> of <i class="emphasis">e</i><sub>2</sub>, where <i class="emphasis">y</i><span class="unicode">&prime;</span> is some noninstance of <i class="emphasis">e</i><sub>1</sub>.</p>
</div>
</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0227.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0229.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
