<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>34.3 NP-completeness and reducibility</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0229.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0231.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch34"></a>
<div class="section">
<h2 class="first-section-title">
<a name="3057"></a><a name="ch34lev1sec3"></a><span class="section-titlelabel">34.3 </span>NP-completeness and reducibility</h2>
<a name="3058"></a><a name="IDX-984"></a>
<p class="para">Perhaps the most compelling reason why theoretical computer scientists believe that P <span class="unicode">&ne;</span> NP is the existence of the class of "NP-complete" problems. This class has the surprising property that if <i class="emphasis">any</i> NP-complete problem can be solved in polynomial time, then <i class="emphasis">every</i> problem in NP has a polynomial-time solution, that is, P = NP. Despite years of study, though, no polynomial-time algorithm has ever been discovered for any NP-complete problem.</p>
<p class="para">The language HAM-CYCLE is one NP-complete problem. If we could decide HAM-CYCLE in polynomial time, then we could solve every problem in NP in polynomial time. In fact, if NP - P should turn out to be nonempty, we could say with certainty that HAM-CYCLE <span class="unicode">&isin;</span> NP - P.</p>
<p class="para">The NP-complete languages are, in a sense, the "hardest" languages in NP. In this section, we shall show how to compare the relative "hardness" of languages using a precise notion called "polynomial-time reducibility." Then we formally define the NP-complete languages, and we finish by sketching a proof that one such language, called CIRCUIT-SAT, is NP-complete. In <a href="DDU0231.html#3092" target="_parent" class="chapterjump">Sections 34.4</a> and <a href="DDU0232.html#3117" target="_parent" class="chapterjump">34.5</a>, we shall use the notion of reducibility to show that many other problems are NP-complete.</p>
<div class="section">
<h4 class="sect4-title">
<a name="3059"></a><a name="ch34lev3sec11"></a>Reducibility</h4>
<p class="first-para">Intuitively, a problem <i class="emphasis">Q</i> can be reduced to another problem <i class="emphasis">Q</i><span class="unicode">&prime;</span> if any instance of <i class="emphasis">Q</i> can be "easily rephrased" as an instance of <i class="emphasis">Q</i><span class="unicode">&prime;</span>, the solution to which provides a solution to the instance of <i class="emphasis">Q</i>. For example, the problem of solving linear equations in an indeterminate <i class="emphasis">x</i> reduces to the problem of solving quadratic equations. Given an instance <i class="emphasis">ax</i> + <i class="emphasis">b</i> = 0, we transform it to 0<i class="emphasis">x</i><sup>2</sup> + <i class="emphasis">ax</i> + <i class="emphasis">b</i> = 0, whose solution provides a solution to <i class="emphasis">ax</i> + <i class="emphasis">b</i> = 0. Thus, if a problem <i class="emphasis">Q</i> reduces to another problem <i class="emphasis">Q</i><span class="unicode">&prime;</span>, then <i class="emphasis">Q</i> is, in a sense, "no harder to solve" than <i class="emphasis">Q</i><span class="unicode">&prime;</span>.</p>
<p class="para">Returning to our formal-language framework for decision problems, we say that a language <i class="emphasis">L</i><sup>1</sup> is <b class="bold"><i class="emphasis">polynomial-time reducible</i></b> to a language <i class="emphasis">L</i><sub>2</sub>, written <i class="emphasis">L</i><sub>1</sub> <span class="unicode">&le;</span><sub>P</sub> <i class="emphasis">L</i><sub>2</sub>, if there exists a polynomial-time computable function <i class="emphasis">f</i> : {0, 1}* <span class="unicode">&rarr;</span> {0,1}* such that for all <i class="emphasis">x</i> {0<i class="emphasis">,</i> 1}*,</p>
<div class="equation">
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(34.1)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig1006_01.jpg" height="12" width="140" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">We call the function <i class="emphasis">f</i> the <b class="bold"><i class="emphasis">reduction function</i></b>, and a polynomial-time algorithm <i class="emphasis">F</i> that computes <i class="emphasis">f</i> is called a <b class="bold"><i class="emphasis">reduction algorithm</i></b>.</p>
<p class="para">
<a class="internaljump" href="#ch34fig04">Figure 34.4</a> illustrates the idea of a polynomial-time reduction from a language <i class="emphasis">L</i><sub>1</sub> to another language <i class="emphasis">L</i>2. Each language is a subset of {0, 1}*. The reduction function <i class="emphasis">f</i> provides a polynomial-time mapping such that if <i class="emphasis">x</i> <span class="unicode">&isin;</span> <i class="emphasis">L</i><sub>1</sub>, then <i class="emphasis">f</i>(<i class="emphasis">x</i>) <span class="unicode">&isin;</span> <i class="emphasis">L</i><sub>2</sub>. Moreover, if <i class="emphasis">x</i> <span class="unicode">&notin;</span> <i class="emphasis">L</i><sub>1</sub>, then <i class="emphasis">f</i> (<i class="emphasis">x</i>) <span class="unicode">&notin;</span> <i class="emphasis">L</i><sub>2</sub>. Thus, the reduction function <a name="3060"></a><a name="IDX-985"></a>maps any instance <i class="emphasis">x</i> of the decision problem represented by the language <i class="emphasis">L</i><sub>1</sub> to an instance <i class="emphasis">f</i> (<i class="emphasis">x</i>) of the problem represented by <i class="emphasis">L</i><sub>2</sub>. Providing an answer to whether <i class="emphasis">f</i>(<i class="emphasis">x</i>) <span class="unicode">&isin;</span> <i class="emphasis">L</i><sub>2</sub> directly provides the answer to whether <i class="emphasis">x</i> <span class="unicode">&isin;</span> <i class="emphasis">L</i><sub>1</sub>.</p>
<div class="figure">
<a name="3061"></a><a name="ch34fig04"></a><span class="figuremediaobject"><a href="images/fig1007%5F01%5F0%2Ejpg" NAME="IMG_1798" target="_parent"><img src="images/fig1007_01.jpg" height="139" width="261" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 34.4: </span>An illustration of a polynomial-time reduction from a language <i class="emphasis">L</i><sub>1</sub> to a language <i class="emphasis">L</i><sub>2</sub> via a reduction function <i class="emphasis">f</i>. For any input <i class="emphasis">x</i> <span class="unicode">&isin;</span> {0, 1}*, the question of whether <i class="emphasis">x</i> <span class="unicode">&isin;</span> <i class="emphasis">L</i><sub>1</sub> has the same answer as the question of whether <i class="emphasis">f</i>(<i class="emphasis">x</i>) <span class="unicode">&isin;</span> <i class="emphasis">L</i><sub>2</sub>.</span>
</div>
<p class="para">Polynomial-time reductions give us a powerful tool for proving that various languages belong to P.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 34.3</span></span><a name="3062"></a><a name="ch34ex20"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">If <i class="emphasis">L</i><sub>1</sub>, <i class="emphasis">L</i><sub>2</sub> <span class="unicode">&sube;</span> {0,1}* are languages such that <i class="emphasis">L</i><sub>1</sub> <span class="unicode">&le;</span><sub>P</sub> <i class="emphasis">L</i><sub>2</sub>, then <i class="emphasis">L</i><sub>2</sub> <span class="unicode">&isin;</span> P implies <i class="emphasis">L</i><sub>1</sub> P.</p>
<p class="para">
<b class="bold">Proof</b> Let <i class="emphasis">A</i><sub>2</sub> be a polynomial-time algorithm that decides <i class="emphasis">L</i><sub>2</sub>, and let <i class="emphasis">F</i> be a polynomial-time reduction algorithm that computes the reduction function <i class="emphasis">f</i>. We shall construct a polynomial-time algorithm <i class="emphasis">A</i><sub>1</sub> that decides <i class="emphasis">L</i><sub>1</sub>.</p>
<p class="para">
<a class="internaljump" href="#ch34fig05">Figure 34.5</a> illustrates the construction of <i class="emphasis">A</i><sub>1</sub>. For a given input <i class="emphasis">x</i> <span class="unicode">&isin;</span> {0, 1}*, the algorithm <i class="emphasis">A</i><sub>1</sub> uses <i class="emphasis">F</i> to transform <i class="emphasis">x</i> into <i class="emphasis">f</i> (<i class="emphasis">x</i>), and then it uses <i class="emphasis">A</i><sub>2</sub> to test whether <i class="emphasis">f</i>(<i class="emphasis">x</i>) <i class="emphasis">L</i><sub>2</sub>. The output of <i class="emphasis">A</i><sub>2</sub> is the value provided as the output from <i class="emphasis">A</i><sub>1</sub>.</p>
<p class="para">
<div class="figure">
<a name="3063"></a><a name="ch34fig05"></a><span class="figuremediaobject"><a href="images/fig1007%5F02%5F0%2Ejpg" NAME="IMG_1799" target="_parent"><img src="images/fig1007_02.jpg" height="71" width="329" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 34.5: </span>The proof of Lemma 34.3. The algorithm <i class="emphasis">F</i> is a reduction algorithm that computes the reduction function <i class="emphasis">f</i> from <i class="emphasis">L</i><sub>1</sub> to <i class="emphasis">L</i><sub>2</sub> in polynomial time, and <i class="emphasis">A</i><sub>2</sub> is a polynomial-time algorithm that decides <i class="emphasis">L</i><sub>2</sub>. Illustrated is an algorithm <i class="emphasis">A</i>1 that decides whether <i class="emphasis">x</i> <span class="unicode">&isin;</span> <i class="emphasis">L</i><sub>1</sub> by using F to transform any input <i class="emphasis">x</i> into <i class="emphasis">f</i> (<i class="emphasis">x</i>) and then using <i class="emphasis">A</i><sub>2</sub> to decide whether <i class="emphasis">f</i>(<i class="emphasis">x</i>) <span class="unicode">&isin;</span> <i class="emphasis">L</i><sub>2</sub>.</span>
</div>
</p>
<a name="3064"></a><a name="IDX-986"></a>
<p class="last-para">The correctness of <i class="emphasis">A</i><sub>1</sub> follows from condition (<a href="DDU0228.html#3022" target="_parent" class="chapterjump">34.1</a>). The algorithm runs in polynomial time, since both <i class="emphasis">F</i> and <i class="emphasis">A</i><sub>2</sub> run in polynomial time (see <a href="DDU0228.html#3033" target="_parent" class="chapterjump">Exercise 34.1-5</a>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="3065"></a><a name="ch34lev3sec12"></a>NP-completeness</h4>
<p class="first-para">Polynomial-time reductions provide a formal means for showing that one problem is at least as hard as another, to within a polynomial-time factor. That is, if <i class="emphasis">L</i><sub>1</sub> <span class="unicode">&le;</span><sub>P</sub> <i class="emphasis">L</i><sub>2</sub>, then <i class="emphasis">L</i><sub>1</sub> is not more than a polynomial factor harder than <i class="emphasis">L</i><sub>2</sub>, which is why the "less than or equal to" notation for reduction is mnemonic. We can now define the set of NP-complete languages, which are the hardest problems in NP.</p>
<p class="para">A language <i class="emphasis">L</i> <span class="unicode">&sube;</span> {0, 1}* is <b class="bold"><i class="emphasis">NP-complete</i></b> if</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="first-para">
<i class="emphasis">L</i> <span class="unicode">&isin;</span> NP, and</p>
</li>
<li class="listitem">
<p class="first-para">
<i class="emphasis">L</i><span class="unicode">&prime;</span> <span class="unicode">&le;</span><sub>P</sub> <i class="emphasis">L</i> for every <i class="emphasis">L</i><span class="unicode">&isin;</span> NP.</p>
</li>
</ol>
<p class="para">If a language <i class="emphasis">L</i> satisfies property 2, but not necessarily property 1, we say that <i class="emphasis">L</i> is <b class="bold"><i class="emphasis">NP-hard</i></b>. We also define NPC to be the class of NP-complete languages.</p>
<p class="para">As the following theorem shows, NP-completeness is at the crux of deciding whether P is in fact equal to NP.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 34.4</span></span><a name="3066"></a><a name="ch34ex21"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">If any NP-complete problem is polynomial-time solvable, then P = NP. Equivalently, if any problem in NP is not polynomial-time solvable, then no NP-complete problem is polynomial-time solvable.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> Suppose that <i class="emphasis">L</i> <span class="unicode">&isin;</span> P and also that <i class="emphasis">L</i> <span class="unicode">&isin;</span> NPC. For any <i class="emphasis">L</i><span class="unicode">&prime;</span> <span class="unicode">&isin;</span> NP, we have <i class="emphasis">L</i><span class="unicode">&prime;</span> <span class="unicode">&le;</span><sub>P</sub> <i class="emphasis">L</i> by property 2 of the definition of NP-completeness. Thus, by <a class="internaljump" href="#ch34ex20">Lemma 34.3</a>, we also have that <i class="emphasis">L</i><span class="unicode">&prime;</span> <span class="unicode">&isin;</span> P, which proves the first statement of the theorem.</p>
<p class="last-para">To prove the second statement, note that it is the contrapositive of the first statement.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">It is for this reason that research into the P <span class="unicode">&ne;</span> NP question centers around the NP-complete problems. Most theoretical computer scientists believe that P <span class="unicode">&ne;</span> NP, which leads to the relationships among P, NP, and NPC shown in <a class="internaljump" href="#ch34fig06">Figure 34.6</a>. But, for all we know, someone may come up with a polynomial-time algorithm for an NP-complete problem, thus proving that P = NP. Nevertheless, since no polynomial-time algorithm for any NP-complete problem has yet been discovered, a proof that a problem is NP-complete provides excellent evidence for its intractability.</p>
<div class="figure">
<a name="3067"></a><a name="ch34fig06"></a><span class="figuremediaobject"><img src="images/fig1009_01.jpg" height="153" width="206" alt="" border="0"></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 34.6: </span>How most theoretical computer scientists view the relationships among P, NP, and NPC. Both P and NPC are wholly contained within NP, and P <span class="unicode">&cap;</span> NPC = <span class="unicode">&Oslash;</span>.</span>
</div>
<a name="3068"></a><a name="IDX-987"></a>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="3069"></a><a name="ch34lev3sec13"></a>Circuit satisfiability</h4>
<p class="first-para">We have defined the notion of an NP-complete problem, but up to this point, we have not actually proved that any problem is NP-complete. Once we prove that at least one problem is NP-complete, we can use polynomial-time reducibility as a tool to prove the NP-completeness of other problems. Thus, we now focus on demonstrating the existence of an NP-complete problem: the circuit-satisfiability problem.</p>
<p class="para">Unfortunately, the formal proof that the circuit-satisfiability problem is NP-complete requires technical detail beyond the scope of this text. Instead, we shall informally describe a proof that relies on a basic understanding of boolean combinational circuits.</p>
<p class="para">Boolean combinational circuits are built from boolean combinational elements that are interconnected by wires. A <b class="bold"><i class="emphasis">boolean combinational element</i></b> is any circuit element that has a constant number of boolean inputs and outputs and that performs a well-defined function. Boolean values are drawn from the set {0, 1}, where 0 represents FALSE and 1 represents TRUE.</p>
<p class="para">The boolean combinational elements that we use in the circuit-satisfiability problem compute a simple boolean function, and they are known as <b class="bold"><i class="emphasis">logic gates</i></b>. <a class="internaljump" href="#ch34fig07">Figure 34.7</a> shows the three basic logic gates that we use in the circuit-satisfiability problem: the <b class="bold"><i class="emphasis">NOT gate</i></b> (or <b class="bold"><i class="emphasis">inverter</i></b>), the <b class="bold"><i class="emphasis">AND gate</i></b>, and the <b class="bold"><i class="emphasis">OR gate</i></b>. The NOT gate takes a single binary <b class="bold"><i class="emphasis">input</i></b> <i class="emphasis">x</i>, whose value is either 0 or 1, and produces a binary <b class="bold"><i class="emphasis">output</i></b> <i class="emphasis">z</i> whose value is opposite that of the input value. Each of the other two gates takes two binary inputs <i class="emphasis">x</i> and <i class="emphasis">y</i> and produces a single binary output <i class="emphasis">z</i>.</p>
<div class="figure">
<a name="3070"></a><a name="ch34fig07"></a><span class="figuremediaobject"><a href="images/fig1010%5F01%5F0%2Ejpg" NAME="IMG_1801" target="_parent"><img src="images/fig1010_01.jpg" height="134" width="347" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 34.7: </span>Three basic logic gates, with binary inputs and outputs. Under each gate is the truth table that describes the gate's operation. <i class="emphasis">(a)</i> The NOT gate. <i class="emphasis">(b)</i> The AND gate. <i class="emphasis">(c)</i> The OR gate.</span>
</div>
<p class="para">The operation of each gate, and of any boolean combinational element, can be described by a <b class="bold"><i class="emphasis">truth table</i></b>, shown under each gate in <a class="internaljump" href="#ch34fig07">Figure 34.7</a>. A truth table gives the outputs of the combinational element for each possible setting of the inputs. For example, the truth table for the OR gate tells us that when the inputs are <i class="emphasis">x</i> = 0 and <i class="emphasis">y</i> = 1, the output value is <i class="emphasis">z</i> = 1. We use the symbols <span class="unicode">&not;</span> to denote the NOT function, <span class="unicode">&and;</span> to denote the AND function, and <span class="unicode">&or;</span> to denote the OR function. Thus, for example, 0 <span class="unicode">&or;</span> = 1.<a name="3071"></a><a name="IDX-988"></a>
</p>
<p class="para">We can generalize AND and OR gates to take more than two inputs. An AND gate's output is 1 if all of its inputs are 1, and its output is 0 otherwise. An OR gate's output is 1 if any of its inputs are 1, and its output is 0 otherwise.</p>
<p class="para">A <b class="bold"><i class="emphasis">boolean combinational circuit</i></b> consists of one or more boolean combinational elements interconnected by <b class="bold"><i class="emphasis">wires</i></b>. A wire can connect the output of one element to the input of another, thereby providing the output value of the first element as an input value of the second. <a class="internaljump" href="#ch34fig08">Figure 34.8</a> shows two similar boolean combinational circuits; they differ in only one gate. Part (a) of the figure also shows the values on the individual wires, given the input <span class="unicode">&#12296;</span><i class="emphasis">x</i><sub>1</sub> = 1, <i class="emphasis">x</i><sub>2</sub> = 1, <i class="emphasis">x</i><sub>3</sub> = 0<span class="unicode">&#12297;</span>. Although a single wire may have no more than one combinational-element output connected to it, it can feed several element inputs. The number of element inputs fed by a wire is called the <b class="bold"><i class="emphasis">fan-out</i></b> of the wire. If no element output is connected to a wire, the wire is a <b class="bold"><i class="emphasis">circuit input</i></b>, accepting input values from an external source. If no element input is connected to a wire, the wire is a <b class="bold"><i class="emphasis">circuit output</i></b>, providing the results of the circuit's computation to the outside world. (An internal wire can also fan out to a circuit output.) For the purpose of defining the circuit-satisfiability problem, we limit the number of circuit outputs to 1, though in actual hardware design, a boolean combinational circuit may have multiple outputs.</p>
<div class="figure">
<a name="3072"></a><a name="ch34fig08"></a><span class="figuremediaobject"><a href="images/fig1011%5F01%5F0%2Ejpg" NAME="IMG_1802" target="_parent"><img src="images/fig1011_01.jpg" height="111" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 34.8: </span>Two instances of the circuit-satisfiability problem. <i class="emphasis">(a)</i> The assignment <span class="unicode">&#12296;</span><i class="emphasis">x</i><sub>1</sub> = 1, <i class="emphasis">x</i><sub>2</sub> = 1, <i class="emphasis">x</i><sub>3</sub> = 0<span class="unicode">&#12297;</span> to the inputs of this circuit causes the output of the circuit to be 1. The circuit is therefore satisfiable. <i class="emphasis">(b)</i> No assignment to the inputs of this circuit can cause the output of the circuit to be 1. The circuit is therefore unsatisfiable.</span>
</div>
<p class="para">Boolean combinational circuits contain no cycles. In other words, suppose we create a directed graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) with one vertex for each combinational element and with <i class="emphasis">k</i> directed edges for each wire whose fan-out is <i class="emphasis">k</i>; there is a directed edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) if a wire connects the output of element <i class="emphasis">u</i> to an input of element <i class="emphasis">v</i>. Then <i class="emphasis">G</i> must be acyclic.</p>
<p class="para">A <b class="bold"><i class="emphasis">truth assignment</i></b> for a boolean combinational circuit is a set of boolean input values. We say that a one-output boolean combinational circuit is <b class="bold"><i class="emphasis">satisfiable</i></b> if it has a <b class="bold"><i class="emphasis">satisfying assignment</i></b>: a truth assignment that causes the output of the circuit to be 1. For example, the circuit in <a class="internaljump" href="#ch34fig08">Figure 34.8(a)</a> has the satisfying assignment <span class="unicode">&#12296;</span><i class="emphasis">x</i><sub>1</sub> = 1, <i class="emphasis">x</i><sub>2</sub> = 1, <i class="emphasis">x</i><sub>3</sub> = 0<span class="unicode">&#12297;</span>, and so it is satisfiable. As <a class="internaljump" href="#ch34ex25">Exercise 34.3-1</a> asks you to <a name="3073"></a><a name="IDX-989"></a>show, no assignment of values to <i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, and <i class="emphasis">x</i><sub>3</sub> causes the circuit in <a class="internaljump" href="#ch34fig08">Figure 34.8(b)</a> to produce a 1 output; it always produces 0, and so it is unsatisfiable.</p>
<p class="para">The <b class="bold"><i class="emphasis">circuit-satisfiability problem</i></b> is, "Given a boolean combinational circuit composed of AND, OR, and NOT gates, is it satisfiable?" In order to pose this question formally, however, we must agree on a standard encoding for circuits. The <b class="bold"><i class="emphasis">size</i></b> of a boolean combinational circuit is the number of boolean combinational elements plus the number of wires in the circuit. One can devise a graphlike encoding that maps any given circuit <i class="emphasis">C</i> into a binary string <span class="unicode">&#12296;</span><i class="emphasis">C</i><span class="unicode">&#12297;</span> whose length is polynomial in the size of the circuit itself. As a formal language, we can therefore define</p>
<p class="para">CIRCUIT-SAT = {<span class="unicode">&#12296;</span><i class="emphasis">C</i><span class="unicode">&#12297;</span> : <i class="emphasis">C</i> is a satisfiable boolean combinational circuit}.</p>
<p class="para">The circuit-satisfiability problem arises in the area of computer-aided hardware optimization. If a subcircuit always produces 0, that subcircuit can be replaced by a simpler subcircuit that omits all logic gates and provides the constant 0 value as its output. It would be helpful to have a polynomial-time algorithm for this problem.</p>
<p class="para">Given a circuit <i class="emphasis">C</i>, we might attempt to determine whether it is satisfiable by simply checking all possible assignments to the inputs. Unfortunately, if there are <i class="emphasis">k</i> inputs, there are 2<sup><i class="emphasis">k</i></sup> possible assignments. When the size of <i class="emphasis">C</i> is polynomial in <i class="emphasis">k</i>, checking each one takes <span class="unicode">&#8486;</span>(2<sup><i class="emphasis">k</i></sup>) time, which is superpolynomial in the size of the <a name="3074"></a><a name="IDX-990"></a>circuit.<sup>[<a name="N1329" href="#ftn.N1329">7</a>]</sup> In fact, as has been claimed, there is strong evidence that no polynomial-time algorithm exists that solves the circuit-satisfiability problem because circuit satisfiability is NP-complete. We break the proof of this fact into two parts, based on the two parts of the definition of NP-completeness.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 34.5</span></span><a name="3075"></a><a name="ch34ex22"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The circuit-satisfiability problem belongs to the class NP.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> We shall provide a two-input, polynomial-time algorithm <i class="emphasis">A</i> that can verify CIRCUIT-SAT. One of the inputs to <i class="emphasis">A</i> is (a standard encoding of) a boolean combinational circuit <i class="emphasis">C</i>. The other input is a certificate corresponding to an assignment of boolean values to the wires in <i class="emphasis">C</i>. (See <a class="internaljump" href="#ch34ex28">Exercise 34.3-4</a> for a smaller certificate.)</p>
<p class="para">The algorithm <i class="emphasis">A</i> is constructed as follows. For each logic gate in the circuit, it checks that the value provided by the certificate on the output wire is correctly computed as a function of the values on the input wires. Then, if the output of the entire circuit is 1, the algorithm outputs 1, since the values assigned to the inputs of <i class="emphasis">C</i> provide a satisfying assignment. Otherwise, <i class="emphasis">A</i> outputs 0.</p>
<p class="last-para">Whenever a satisfiable circuit <i class="emphasis">C</i> is input to algorithm <i class="emphasis">A</i>, there is a certificate whose length is polynomial in the size of <i class="emphasis">C</i> and that causes <i class="emphasis">A</i> to output a 1. When-ever an unsatisfiable circuit is input, no certificate can fool <i class="emphasis">A</i> into believing that the circuit is satisfiable. Algorithm <i class="emphasis">A</i> runs in polynomial time: with a good implementation, linear time suffices. Thus, CIRCUIT-SAT can be verified in polynomial time, and CIRCUIT-SAT <span class="unicode">&isin;</span> NP.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">The second part of proving that CIRCUIT-SAT is NP-complete is to show that the language is NP-hard. That is, we must show that every language in NP is polynomial-time reducible to CIRCUIT-SAT. The actual proof of this fact is full of technical intricacies, and so we shall settle for a sketch of the proof based on some understanding of the workings of computer hardware.</p>
<p class="para">A computer program is stored in the computer memory as a sequence of instructions. A typical instruction encodes an operation to be performed, addresses of operands in memory, and an address where the result is to be stored. A special memory location, called the <b class="bold"><i class="emphasis">program counter</i></b>, keeps track of which instruction is to be executed next. The program counter is automatically incremented whenever an instruction is fetched, thereby causing the computer to execute instructions sequentially. The execution of an instruction can cause a value to be written to the <a name="3076"></a><a name="IDX-991"></a>program counter, however, and then the normal sequential execution can be altered, allowing the computer to loop and perform conditional branches.</p>
<p class="para">At any point during the execution of a program, the entire state of the computation is represented in the computer's memory. (We take the memory to include the program itself, the program counter, working storage, and any of the various bits of state that a computer maintains for bookkeeping.) We call any particular state of computer memory a <b class="bold"><i class="emphasis">configuration</i></b>. The execution of an instruction can be viewed as mapping one configuration to another. Importantly, the computer hardware that accomplishes this mapping can be implemented as a boolean combinational circuit, which we denote by <i class="emphasis">M</i> in the proof of the following lemma.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 34.6</span></span><a name="3077"></a><a name="ch34ex23"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The circuit-satisfiability problem is NP-hard.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> Let <i class="emphasis">L</i> be any language in NP. We shall describe a polynomial-time algorithm <i class="emphasis">F</i> computing a reduction function <i class="emphasis">f</i> that maps every binary string <i class="emphasis">x</i> to a circuit <i class="emphasis">C</i> = <i class="emphasis">f</i> (<i class="emphasis">x</i>) such that <i class="emphasis">x</i> <span class="unicode">&isin;</span> <i class="emphasis">L</i> if and only if <i class="emphasis">C</i> <span class="unicode">&isin;</span> CIRCUIT-SAT. Since <i class="emphasis">L</i> NP, there must exist an algorithm <i class="emphasis">A</i> that verifies <i class="emphasis">L</i> in polynomial time. The algorithm <i class="emphasis">F</i> that we shall construct will use the two-input algorithm <i class="emphasis">A</i> to compute the reduction function <i class="emphasis">f</i> .</p>
<p class="para">Let <i class="emphasis">T</i>(<i class="emphasis">n</i>) denote the worst-case running time of algorithm <i class="emphasis">A</i> on length-<i class="emphasis">n</i> input strings, and let <i class="emphasis">k</i> <span class="unicode">&ge;</span> 1 be a constant such that <i class="emphasis">T</i> (<i class="emphasis">n</i>) = <i class="emphasis">O</i>(<i class="emphasis">n<sup>k</sup></i>) and the length of the certificate is <i class="emphasis">O</i>(<i class="emphasis">n<sup>k</sup></i>). (The running time of <i class="emphasis">A</i> is actually a polynomial in the total input size, which includes both an input string and a certificate, but since the length of the certificate is polynomial in the length <i class="emphasis">n</i> of the input string, the running time is polynomial in <i class="emphasis">n</i>.)</p>
<p class="para">The basic idea of the proof is to represent the computation of <i class="emphasis">A</i> as a sequence of configurations. As shown in <a class="internaljump" href="#ch34fig09">Figure 34.9</a>, each configuration can be broken into parts consisting of the program for <i class="emphasis">A</i>, the program counter and auxiliary machine state, the input <i class="emphasis">x</i>, the certificate <i class="emphasis">y</i>, and working storage. Starting with an initial configuration <i class="emphasis">c</i><sub>0</sub>, each configuration <i class="emphasis">c<sub>i</sub></i> is mapped to a subsequent configuration <i class="emphasis">c</i><sub><i class="emphasis">i</i>+1</sub> by the combinational circuit <i class="emphasis">M</i> implementing the computer hardware. The output of the algorithm <i class="emphasis">A</i><span class="unicode">-</span>0 or 1<span class="unicode">-</span>is written to some designated location in the working storage when <i class="emphasis">A</i> finishes executing, and if we assume that thereafter <i class="emphasis">A</i> halts, the value never changes. Thus, if the algorithm runs for at most <i class="emphasis">T</i><sub>(<i class="emphasis">n</i>)</sub> steps, the output appears as one of the bits in <i class="emphasis">c</i><sub><i class="emphasis">T</i> (<i class="emphasis">n</i>)</sub>.</p>
<p class="para">
<div class="figure">
<a name="3078"></a><a name="ch34fig09"></a><span class="figuremediaobject"><a href="images/fig1014%5F01%5F0%2Ejpg" NAME="IMG_1803" target="_parent"><img src="images/fig1014_01.jpg" height="376" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 34.9: </span>The sequence of configurations produced by an algorithm A running on an input <i class="emphasis">x</i> and certificate <i class="emphasis">y</i>. Each configuration represents the state of the computer for one step of the computation and, besides <i class="emphasis">A, x</i>, and <i class="emphasis">y</i>, includes the program counter (PC), auxiliary machine state, and working storage. Except for the certificate <i class="emphasis">y</i>, the initial configuration <i class="emphasis">c</i><sub>0</sub> is constant. Each configuration is mapped to the next configuration by a boolean combinational circuit <i class="emphasis">M</i>. The output is a distinguished bit in the working storage.</span>
</div>
</p>
<p class="para">The reduction algorithm <i class="emphasis">F</i> constructs a single combinational circuit that computes all configurations produced by a given initial configuration. The idea is to paste together <i class="emphasis">T</i>(<i class="emphasis">n</i>) copies of the circuit <i class="emphasis">M</i>. The output of the <i class="emphasis">i</i>th circuit, which produces configuration <i class="emphasis">c<sub>i</sub></i>, is fed directly into the input of the (<i class="emphasis">i</i> +1)st circuit. Thus, <a name="3079"></a><a name="IDX-992"></a><a name="3080"></a><a name="IDX-993"></a>the configurations, rather than ending up in a state register, simply reside as values on the wires connecting copies of <i class="emphasis">M</i>.</p>
<p class="para">Recall what the polynomial-time reduction algorithm <i class="emphasis">F</i> must do. Given an input <i class="emphasis">x</i>, it must compute a circuit <i class="emphasis">C</i> = <i class="emphasis">f</i>(<i class="emphasis">x</i>) that is satisfiable if and only if there exists a certificate <i class="emphasis">y</i> such that <i class="emphasis">A</i>(<i class="emphasis">x</i>, <i class="emphasis">y</i>) = 1. When <i class="emphasis">F</i> obtains an input <i class="emphasis">x</i>, it first computes <i class="emphasis">n</i> = |<i class="emphasis">x</i>| and constructs a combinational circuit <i class="emphasis">C</i><span class="unicode">&prime;</span> consisting of <i class="emphasis">T</i>(<i class="emphasis">n</i>) copies of <i class="emphasis">M</i>. The input to <i class="emphasis">C</i><span class="unicode">&prime;</span> is an initial configuration corresponding to a computation on <i class="emphasis">A</i>(<i class="emphasis">x</i>, <i class="emphasis">y</i>), and the output is the configuration <i class="emphasis">c</i><sub><i class="emphasis">T</i>(<i class="emphasis">n</i>)</sub>.</p>
<p class="para">The circuit <i class="emphasis">C</i> = <i class="emphasis">f</i>(<i class="emphasis">x</i>) that <i class="emphasis">F</i> computes is obtained by modifying <i class="emphasis">C</i><span class="unicode">&prime;</span> slightly. First, the inputs to <i class="emphasis">C</i><span class="unicode">&prime;</span> corresponding to the program for <i class="emphasis">A</i>, the initial program counter, the input <i class="emphasis">x</i>, and the initial state of memory are wired directly to these known values. Thus, the only remaining inputs to the circuit correspond to the certificate <i class="emphasis">y</i>. Second, all outputs to the circuit are ignored, except the one bit of <i class="emphasis">c</i><sub><i class="emphasis">T</i>(<i class="emphasis">n</i>)</sub> corresponding to the output of <i class="emphasis">A</i>. This circuit <i class="emphasis">C</i>, so constructed, computes <i class="emphasis">C</i>(<i class="emphasis">y</i>) = <i class="emphasis">A</i>(<i class="emphasis">x</i>, <i class="emphasis">y</i>) for any input <i class="emphasis">y</i> of length <i class="emphasis">O</i>(<i class="emphasis">n<sup>k</sup></i>). The reduction algorithm <i class="emphasis">F</i>, when provided an input string <i class="emphasis">x</i>, computes such a circuit <i class="emphasis">C</i> and outputs it.</p>
<p class="para">Two properties remain to be proved. First, we must show that <i class="emphasis">F</i> correctly computes a reduction function <i class="emphasis">f</i> . That is, we must show that <i class="emphasis">C</i> is satisfiable if and only if there exists a certificate <i class="emphasis">y</i> such that <i class="emphasis">A</i>(<i class="emphasis">x</i>, <i class="emphasis">y</i>) = 1. Second, we must show that <i class="emphasis">F</i> runs in polynomial time.</p>
<p class="para">To show that <i class="emphasis">F</i> correctly computes a reduction function, let us suppose that there exists a certificate <i class="emphasis">y</i> of length <i class="emphasis">O</i>(<i class="emphasis">n<sup>k</sup></i>) such that <i class="emphasis">A</i>(<i class="emphasis">x</i>, <i class="emphasis">y</i>) = 1. Then, if we apply the bits of <i class="emphasis">y</i> to the inputs of <i class="emphasis">C</i>, the output of <i class="emphasis">C</i> is <i class="emphasis">C</i>(<i class="emphasis">y</i>) = <i class="emphasis">A</i>(<i class="emphasis">x</i>, <i class="emphasis">y</i>) = 1. Thus, if a certificate exists, then <i class="emphasis">C</i> is satisfiable. For the other direction, suppose that <i class="emphasis">C</i> is satisfiable. Hence, there exists an input <i class="emphasis">y</i> to <i class="emphasis">C</i> such that <i class="emphasis">C</i>(<i class="emphasis">y</i>) = 1, from which we conclude that <i class="emphasis">A</i>(<i class="emphasis">x</i>, <i class="emphasis">y</i>) = 1. Thus, <i class="emphasis">F</i> correctly computes a reduction function.</p>
<p class="para">To complete the proof sketch, we need only show that <i class="emphasis">F</i> runs in time polynomial in <i class="emphasis">n</i> = |<i class="emphasis">x</i>|. The first observation we make is that the number of bits required to represent a configuration is polynomial in <i class="emphasis">n</i>. The program for <i class="emphasis">A</i> itself has constant size, independent of the length of its input <i class="emphasis">x</i>. The length of the input <i class="emphasis">x</i> is <i class="emphasis">n</i>, and the length of the certificate <i class="emphasis">y</i> is <i class="emphasis">O</i>(<i class="emphasis">n<sup>k</sup></i>). Since the algorithm runs for at most <i class="emphasis">O</i>(<i class="emphasis">n<sup>k</sup></i>) steps, the amount of working storage required by <i class="emphasis">A</i> is polynomial in <i class="emphasis">n</i> as well. (We assume that this memory is contiguous; <a class="internaljump" href="#ch34ex29">Exercise 34.3-5</a> asks you to extend the argument to the situation in which the locations accessed by <i class="emphasis">A</i> are scattered across a much larger region of memory and the particular pattern of scattering can differ for each input <i class="emphasis">x</i>.)</p>
<p class="last-para">The combinational circuit <i class="emphasis">M</i> implementing the computer hardware has size polynomial in the length of a configuration, which is polynomial in <i class="emphasis">O</i>(<i class="emphasis">n<sup>k</sup></i>) and hence is polynomial in <i class="emphasis">n</i>. (Most of this circuitry implements the logic of the memory system.) The circuit <i class="emphasis">C</i> consists of at most <i class="emphasis">t</i> = <i class="emphasis">O</i>(<i class="emphasis">n<sup>k</sup></i>) copies of <i class="emphasis">M</i>, and hence it has size polynomial in <i class="emphasis">n</i>. The construction of <i class="emphasis">C</i> from <i class="emphasis">x</i> can be accomplished in <a name="3081"></a><a name="IDX-994"></a>polynomial time by the reduction algorithm <i class="emphasis">F</i>, since each step of the construction takes polynomial time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">The language CIRCUIT-SAT is therefore at least as hard as any language in NP, and since it belongs to NP, it is NP-complete.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 34.7</span></span><a name="3082"></a><a name="ch34ex24"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The circuit-satisfiability problem is NP-complete.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Immediate from <a class="internaljump" href="#ch34ex22">Lemmas 34.5</a> and <a class="internaljump" href="#ch34ex23">34.6</a> and from the definition of NP-completeness.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.3-1</span></span><a name="3083"></a><a name="ch34ex25"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Verify that the circuit in <a class="internaljump" href="#ch34fig08">Figure 34.8(b)</a> is unsatisfiable.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.3-2</span></span><a name="3084"></a><a name="ch34ex26"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that the <span class="unicode">&le;</span><sub>P</sub> relation is a transitive relation on languages. That is, show that if <i class="emphasis">L</i><sub>1</sub> <span class="unicode">&le;</span><sub>P</sub> <i class="emphasis">L</i><sub>2</sub> and <i class="emphasis">L</i><sub>2</sub> <span class="unicode">&le;</span><sub>P</sub> <i class="emphasis">L</i><sub>3</sub>, then <i class="emphasis">L</i><sub>1</sub> <span class="unicode">&le;</span><sub>P</sub> <i class="emphasis">L</i><sub>3</sub>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.3-3</span></span><a name="3085"></a><a name="ch34ex27"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Prove that <span class="inlinemediaobject"><img src="images/fig1016_01.jpg" height="13" width="34" alt="" border="0"></span> if and only if <span class="inlinemediaobject"><img src="images/fig1016_02.jpg" height="13" width="33" alt="" border="0"></span>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.3-4</span></span><a name="3086"></a><a name="ch34ex28"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that a satisfying assignment can be used as a certificate in an alternative proof of <a class="internaljump" href="#ch34ex22">Lemma 34.5</a>. Which certificate makes for an easier proof?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.3-5</span></span><a name="3087"></a><a name="ch34ex29"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The proof of <a class="internaljump" href="#ch34ex23">Lemma 34.6</a> assumes that the working storage for algorithm <i class="emphasis">A</i> occupies a contiguous region of polynomial size. Where in the proof is this assumption exploited? Argue that this assumption does not involve any loss of generality.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.3-6</span></span><a name="3088"></a><a name="ch34ex30"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">A language <i class="emphasis">L</i> is <b class="bold"><i class="emphasis">complete</i></b> for a language class <i class="emphasis">C</i> with respect to polynomial-time reductions if <i class="emphasis">L</i> <span class="unicode">&isin;</span> <i class="emphasis">C</i> and <i class="emphasis">L</i><span class="unicode">&prime;</span> <span class="unicode">&le;</span><sub>P</sub> <i class="emphasis">L</i> for all <i class="emphasis">L</i><span class="unicode">&prime;</span> <span class="unicode">&isin;</span> <i class="emphasis">C</i>. Show that <span class="unicode">&Oslash;</span> and {0<i class="emphasis">,</i>1}* are the only languages in P that are not complete for P with respect to polynomial-time reductions.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.3-7</span></span><a name="3089"></a><a name="ch34ex31"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that <i class="emphasis">L</i> is complete for NP if and only if <span class="inlinemediaobject"><img src="images/fig1016_03.jpg" height="11" width="8" alt="" border="0"></span> is complete for co-NP.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="3090"></a><a name="IDX-995"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.3-8</span></span><a name="3091"></a><a name="ch34ex32"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The reduction algorithm <i class="emphasis">F</i> in the proof of <a class="internaljump" href="#ch34ex23">Lemma 34.6</a> constructs the circuit <i class="emphasis">C</i> = <i class="emphasis">f</i>(<i class="emphasis">x</i>) based on knowledge of <i class="emphasis">x</i>, <i class="emphasis">A</i>, and <i class="emphasis">k</i>. Professor Sartre observes that the string <i class="emphasis">x</i> is input to <i class="emphasis">F</i>, but only the existence of <i class="emphasis">A</i>, <i class="emphasis">k</i>, and the constant factor implicit in the <i class="emphasis">O</i>(<i class="emphasis">n<sup>k</sup></i>) running time is known to <i class="emphasis">F</i> (since the language <i class="emphasis">L</i> belongs to NP), not their actual values. Thus, the professor concludes that <i class="emphasis">F</i> can't possibly construct the circuit <i class="emphasis">C</i> and that the language CIRCUIT-SAT is not necessarily NP-hard. Explain the flaw in the professor's reasoning.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
<div class="footnotes">
<div class="footnote">
<p>
<sup>[<a name="ftn.N1329" href="#N1329">7</a>]</sup>On the other hand, if the size of the circuit <i class="emphasis">C</i> is <span class="unicode">&Theta;</span>(2<sup><i class="emphasis">k</i></sup>), then an algorithm whose running time is <i class="emphasis">O</i>(2<sup><i class="emphasis">k</i></sup>) has a running time that is polynomial in the circuit size. Even if P <span class="unicode">&ne;</span> NP, this situation would not contradict the fact that the problem is NP-complete; the existence of a polynomial-time algorithm for a special case does not imply that there is a polynomial-time algorithm for all cases.</p>
</div>
</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0229.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0231.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
