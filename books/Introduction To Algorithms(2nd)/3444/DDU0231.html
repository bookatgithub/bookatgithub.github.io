<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>34.4 NP-completeness proofs</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0230.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0232.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch34"></a>
<div class="section">
<h2 class="first-section-title">
<a name="3092"></a><a name="ch34lev1sec4"></a><span class="section-titlelabel">34.4 </span>NP-completeness proofs</h2>
<p class="first-para">The NP-completeness of the circuit-satisfiability problem relies on a direct proof that <i class="emphasis">L</i> <span class="unicode">&le;</span><sub>P</sub> CIRCUIT-SAT for every language <i class="emphasis">L</i> <span class="unicode">&isin;</span> NP. In this section, we shall show how to prove that languages are NP-complete without directly reducing <i class="emphasis">every</i> language in NP to the given language. We shall illustrate this methodology by proving that various formula-satisfiability problems are NP-complete. <a href="DDU0232.html#3117" target="_parent" class="chapterjump">Section 34.5</a> provides many more examples of the methodology.</p>
<p class="para">The following lemma is the basis of our method for showing that a language is NP-complete.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Lemma 34.8</span></span><a name="3093"></a><a name="ch34ex33"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">If <i class="emphasis">L</i> is a language such that <i class="emphasis">L</i><span class="unicode">&prime;</span> <span class="unicode">&le;</span><sub>P</sub> <i class="emphasis">L</i> for some <i class="emphasis">L</i><span class="unicode">&prime;</span> <span class="unicode">&isin;</span> NPC, then <i class="emphasis">L</i> is NP-hard. Moreover, if <i class="emphasis">L</i> <span class="unicode">&isin;</span> NP, then <i class="emphasis">L</i> <span class="unicode">&isin;</span> NPC.</p>
<p class="last-para">
<b class="bold"><i class="emphasis">Proof</i></b> Since <i class="emphasis">L</i><span class="unicode">&prime;</span> is NP-complete, for all <i class="emphasis">L</i><span class="unicode">&prime;</span><span class="unicode">&prime;</span><span class="unicode">&isin;</span> NP, we have <i class="emphasis">L</i><span class="unicode">&prime;</span><span class="unicode">&prime;</span><span class="unicode">&le;</span><sub>P</sub> <i class="emphasis">L</i><span class="unicode">&prime;</span>. By supposition, <i class="emphasis">L</i><span class="unicode">&prime;</span> <span class="unicode">&le;</span><sub>P</sub> <i class="emphasis">L</i>, and thus by transitivity (<a href="DDU0230.html#3084" target="_parent" class="chapterjump">Exercise 34.3-2</a>), we have <i class="emphasis">L</i><span class="unicode">&prime;</span><span class="unicode">&prime;</span> <span class="unicode">&le;</span><sub>P</sub> <i class="emphasis">L</i>, which shows that <i class="emphasis">L</i> is NP-hard. If <i class="emphasis">L</i> <span class="unicode">&isin;</span> NP, we also have <i class="emphasis">L</i> <span class="unicode">&isin;</span> NPC.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">In other words, by reducing a known NP-complete language <i class="emphasis">L</i><span class="unicode">&prime;</span> to <i class="emphasis">L</i>, we implicitly reduce every language in NP to <i class="emphasis">L</i>. Thus, <a class="internaljump" href="#ch34ex33">Lemma 34.8</a> gives us a method for proving that a language <i class="emphasis">L</i> is NP-complete:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="first-para">Prove <i class="emphasis">L</i> <span class="unicode">&isin;</span> NP.</p>
</li>
<li class="listitem">
<p class="first-para">Select a known NP-complete language <i class="emphasis">L</i><span class="unicode">&prime;</span>.</p>
</li>
<li class="listitem">
<p class="first-para">Describe an algorithm that computes a function <i class="emphasis">f</i> mapping every instance <i class="emphasis">x</i> <span class="unicode">&isin;</span> {0, 1}* of <i class="emphasis">L</i><span class="unicode">&prime;</span> to an instance <i class="emphasis">f</i>(<i class="emphasis">x</i>) of <i class="emphasis">L</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Prove that the function <i class="emphasis">f</i> satisfies <i class="emphasis">x</i> <span class="unicode">&isin;</span> <i class="emphasis">L</i><span class="unicode">&prime;</span> if and only if <i class="emphasis">f</i> (<i class="emphasis">x</i>) <span class="unicode">&isin;</span> <i class="emphasis">L</i> for all <i class="emphasis">x</i> <span class="unicode">&isin;</span> {0, 1}*.</p>
</li>
<li class="listitem">
<p class="first-para">Prove that the algorithm computing <i class="emphasis">f</i> runs in polynomial time.</p>
</li>
</ol>
<a name="3094"></a><a name="IDX-996"></a>
<p class="para">(Steps 2<span class="unicode">-</span>5 show that <i class="emphasis">L</i> is NP-hard.) This methodology of reducing from a single known NP-complete language is far simpler than the more complicated process of showing directly how to reduce from every language in NP. Proving CIRCUIT-SAT <span class="unicode">&isin;</span> NPC has given us a "foot in the door." Knowing that the circuit-satisfiability problem is NP-complete now allows us to prove much more easily that other problems are NP-complete. Moreover, as we develop a catalog of known NP-complete problems, we will have more and more choices for languages from which to reduce.</p>
<div class="section">
<h4 class="sect4-title">
<a name="3095"></a><a name="ch34lev3sec14"></a>Formula satisfiability</h4>
<p class="first-para">We illustrate the reduction methodology by giving an NP-completeness proof for the problem of determining whether a boolean formula, not a circuit, is satisfiable. This problem has the historical honor of being the first problem ever shown to be NP-complete.</p>
<p class="para">We formulate the <b class="bold"><i class="emphasis">(formula) satisfiability</i></b> problem in terms of the language SAT as follows. An instance of SAT is a boolean formula <i class="emphasis"><span class="unicode">&phi;</span></i> composed of</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="first-para">
<i class="emphasis">n</i> boolean variables: <i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, ..., <i class="emphasis">x<sub>n</sub></i>;</p>
</li>
<li class="listitem">
<p class="first-para">
<i class="emphasis">m</i> boolean connectives: any boolean function with one or two inputs and one output, such as <span class="unicode">&or;</span> (AND), <span class="unicode">&and;</span> (OR), <span class="unicode">&not;</span> (NOT), <span class="unicode">&rarr;</span> (implication), <span class="unicode">&harr;</span> (if and only if); and</p>
</li>
<li class="listitem">
<p class="first-para">parentheses. (Without loss of generality, we assume that there are no redundant parentheses, i.e., there is at most one pair of parentheses per boolean connective.)</p>
</li>
</ol>
<p class="para">It is easy to encode a boolean formula <i class="emphasis"><span class="unicode">&phi;</span></i> in a length that is polynomial in <i class="emphasis">n</i> + <i class="emphasis">m</i>. As in boolean combinational circuits, a <b class="bold"><i class="emphasis">truth assignment</i></b> for a boolean formula <i class="emphasis"><span class="unicode">&phi;</span></i> is a set of values for the variables of <i class="emphasis"><span class="unicode">&phi;</span></i>, and a <b class="bold"><i class="emphasis">satisfying assignment</i></b> is a truth assignment that causes it to evaluate to 1. A formula with a satisfying assignment is a <b class="bold"><i class="emphasis">satisfiable</i></b> formula. The satisfiability problem asks whether a given boolean formula is satisfiable; in formal-language terms,</p>
<p class="para">SAT = {<span class="unicode">&#12296;</span><i class="emphasis"><span class="unicode">&phi;</span></i><span class="unicode">&#12297;</span> : <i class="emphasis"><span class="unicode">&phi;</span></i> is a satisfiable boolean formula}.</p>
<p class="para">As an example, the formula</p>
<p class="para">
<i class="emphasis"><span class="unicode">&phi;</span></i> = ((<i class="emphasis">x</i><sub>1</sub> <span class="unicode">&rarr;</span> <i class="emphasis">x</i><sub>2</sub>) <span class="unicode">&and;</span> <span class="unicode">&not;</span>((<span class="unicode">&not;</span><i class="emphasis">x</i><sub>1</sub> <span class="unicode">&harr;</span> <i class="emphasis">x</i><sub>3</sub>) <span class="unicode">&or;</span> <i class="emphasis">x</i><sub>4</sub>)) <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub>
</p>
<p class="para">has the satisfying assignment <span class="unicode">&#12296;</span><i class="emphasis">x</i><sub>1</sub> = 0, <i class="emphasis">x</i><sub>2</sub> = 0, <i class="emphasis">x</i><sub>3</sub> = 1, <i class="emphasis">x</i><sub>4</sub> = 1<span class="unicode">&#12297;</span>, since</p>
<div class="equation">
<a name="3096"></a><a name="ch34eq02"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(34.2)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig1018_01.jpg" height="79" width="264" alt="" border="0"></span></td>
</tr>
</table>
</div>
<a name="3097"></a><a name="IDX-997"></a>
<p class="para">and thus this formula <i class="emphasis"><span class="unicode">&phi;</span></i> belongs to SAT.</p>
<p class="para">The naive algorithm to determine whether an arbitrary boolean formula is satisfiable does not run in polynomial time. There are 2<sup><i class="emphasis">n</i></sup> possible assignments in a formula <i class="emphasis"><span class="unicode">&phi;</span></i> with <i class="emphasis">n</i> variables. If the length of <span class="unicode">&#12296;</span><i class="emphasis"><span class="unicode">&phi;</span></i><span class="unicode">&#12297;</span> is polynomial in <i class="emphasis">n</i>, then checking every assignment requires <span class="unicode">&#8486;</span>(2<sup><i class="emphasis">n</i></sup>) time, which is superpolynomial in the length of <span class="unicode">&#12296;</span><i class="emphasis"><span class="unicode">&phi;</span></i><span class="unicode">&#12297;</span>. As the following theorem shows, a polynomial-time algorithm is unlikely to exist.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 34.9</span></span><a name="3098"></a><a name="ch34ex34"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Satisfiability of boolean formulas is NP-complete.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> We start by arguing that SAT <span class="unicode">&isin;</span> NP. Then we prove that CIRCUIT-SAT is NP-hard by showing that CIRCUIT-SAT <span class="unicode">&le;</span><sub>P</sub> SAT; by <a class="internaljump" href="#ch34ex33">Lemma 34.8</a>, this will prove the theorem.</p>
<p class="para">To show that SAT belongs to NP, we show that a certificate consisting of a satisfying assignment for an input formula <i class="emphasis"><span class="unicode">&phi;</span></i> can be verified in polynomial time. The verifying algorithm simply replaces each variable in the formula with its corresponding value and then evaluates the expression, much as we did in <a class="internaljump" href="#ch34eq02">equation (34.2)</a> above. This task is easily done in polynomial time. If the expression evaluates to 1, the formula is satisfiable. Thus, the first condition of <a class="internaljump" href="#ch34ex33">Lemma 34.8</a> for NP-completeness holds.</p>
<p class="para">To prove that SAT is NP-hard, we show that CIRCUIT-SAT <span class="unicode">&le;</span><sub>P</sub> SAT. In other words, any instance of circuit satisfiability can be reduced in polynomial time to an instance of formula satisfiability. Induction can be used to express any boolean combinational circuit as a boolean formula. We simply look at the gate that produces the circuit output and inductively express each of the gate's inputs as formulas. The formula for the circuit is then obtained by writing an expression that applies the gate's function to its inputs' formulas.</p>
<p class="para">Unfortunately, this straightforward method does not constitute a polynomial-time reduction. As <a class="internaljump" href="#ch34ex36">Exercise 34.4-1</a> asks you to show, shared subformulas<span class="unicode">-</span>which arise from gates whose output wires have fan-out of 2 or more<span class="unicode">-</span>can cause the size of the generated formula to grow exponentially. Thus, the reduction algorithm must be somewhat more clever.</p>
<p class="para">
<a class="internaljump" href="#ch34fig10">Figure 34.10</a> illustrates the basic idea of the reduction from CIRCUIT-SAT to SAT on the circuit from <a href="DDU0230.html#3072" target="_parent" class="chapterjump">Figure 34.8(a)</a>. For each wire <i class="emphasis">x<sub>i</sub></i> in the circuit <i class="emphasis">C</i>, the formula <i class="emphasis"><span class="unicode">&phi;</span></i> has a variable <i class="emphasis">x<sub>i</sub></i> . The proper operation of a gate can now be expressed as a formula involving the variables of its incident wires. For example, the operation of the output AND gate is <i class="emphasis">x</i><sub>10</sub> <span class="unicode">&harr;</span> (<i class="emphasis">x</i><sub>7</sub> <span class="unicode">&and;</span> <i class="emphasis">x</i><sub>8</sub> <span class="unicode">&and;</span> <i class="emphasis">x</i><sub>9</sub>).</p>
<p class="para">
<div class="figure">
<a name="3099"></a><a name="ch34fig10"></a><span class="figuremediaobject"><a href="images/fig1020%5F01%5F0%2Ejpg" NAME="IMG_1808" target="_parent"><img src="images/fig1020_01.jpg" height="128" width="293" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 34.10: </span>Reducing circuit satisfiability to formula satisfiability. The formula produced by the reduction algorithm has a variable for each wire in the circuit.</span>
</div>
</p>
<p class="para">The formula <i class="emphasis"><span class="unicode">&phi;</span></i> produced by the reduction algorithm is the AND of the circuit-output variable with the conjunction of clauses describing the operation of each <a name="3100"></a><a name="IDX-998"></a>gate. For the circuit in the figure, the formula is</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&phi;</span></i>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">x</i><sub>10</sub>
</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&and;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">(<i class="emphasis">x</i><sub>4</sub> <span class="unicode">&harr;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>3</sub>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">&nbsp;</td><td class="td" align="left">&nbsp;</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&and;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">(<i class="emphasis">x</i><sub>5</sub> <span class="unicode">&harr;</span> (<i class="emphasis">x</i><sub>1</sub> <span class="unicode">&or;</span> <i class="emphasis">x</i><sub>2</sub>))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">&nbsp;</td><td class="td" align="left">&nbsp;</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&and;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">(<i class="emphasis">x</i><sub>6</sub> <span class="unicode">&harr;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>4</sub>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">&nbsp;</td><td class="td" align="left">&nbsp;</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&and;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">(<i class="emphasis">x</i><sub>7</sub> <span class="unicode">&harr;</span> (<i class="emphasis">x</i><sub>1</sub> <span class="unicode">&and;</span> <i class="emphasis">x</i><sub>2</sub> <span class="unicode">&and;</span> <i class="emphasis">x</i><sub>4</sub>))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">&nbsp;</td><td class="td" align="left">&nbsp;</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&and;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">(<i class="emphasis">x</i><sub>8</sub> <span class="unicode">&harr;</span> (<i class="emphasis">x</i><sub>5</sub> <span class="unicode">&or;</span> <i class="emphasis">x</i><sub>6</sub>))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">&nbsp;</td><td class="td" align="left">&nbsp;</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&and;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">(<i class="emphasis">x</i><sub>9</sub> <span class="unicode">&harr;</span> (<i class="emphasis">x</i><sub>6</sub> <span class="unicode">&or;</span> <i class="emphasis">x</i><sub>7</sub>))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">&nbsp;</td><td class="td" align="left">&nbsp;</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&and;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">(<i class="emphasis">x</i><sub>10</sub> (<i class="emphasis">x</i><sub>7</sub> <span class="unicode">&and;</span> <i class="emphasis">x</i><sub>8</sub> <span class="unicode">&and;</span> <i class="emphasis">x</i><sub>9</sub>)).</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">Given a circuit <i class="emphasis">C</i>, it is straightforward to produce such a formula <i class="emphasis"><span class="unicode">&phi;</span></i> in polynomial time.</p>
<p class="last-para">Why is the circuit <i class="emphasis">C</i> satisfiable exactly when the formula <i class="emphasis"><span class="unicode">&phi;</span></i> is satisfiable? If <i class="emphasis">C</i> has a satisfying assignment, each wire of the circuit has a well-defined value, and the output of the circuit is 1. Therefore, the assignment of wire values to variables in <i class="emphasis"><span class="unicode">&phi;</span></i> makes each clause of <i class="emphasis"><span class="unicode">&phi;</span></i> evaluate to 1, and thus the conjunction of all evaluates to 1. Conversely, if there is an assignment that causes <i class="emphasis"><span class="unicode">&phi;</span></i> to evaluate to 1, the circuit <i class="emphasis">C</i> is satisfiable by an analogous argument. Thus, we have shown that CIRCUIT-SAT <span class="unicode">&le;</span><sub>P</sub> SAT, which completes the proof.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="3101"></a><a name="ch34lev3sec15"></a>3-CNF satisfiability</h4>
<p class="first-para">Many problems can be proved NP-complete by reduction from formula satisfiability. The reduction algorithm must handle any input formula, though, and this requirement can lead to a huge number of cases that must be considered. It is often desirable, therefore, to reduce from a restricted language of boolean formulas, so that fewer cases need be considered. Of course, we must not restrict the language <a name="3102"></a><a name="IDX-999"></a>so much that it becomes polynomial-time solvable. One convenient language is 3-CNF satisfiability, or 3-CNF-SAT.</p>
<p class="para">We define 3-CNF satisfiability using the following terms. A <b class="bold"><i class="emphasis">literal</i></b> in a boolean formula is an occurrence of a variable or its negation. A boolean formula is in <b class="bold"><i class="emphasis">conjunctive normal form</i></b>, or <b class="bold"><i class="emphasis">CNF</i></b>, if it is expressed as an AND of <b class="bold"><i class="emphasis">clauses</i></b>, each of which is the OR of one or more literals. A boolean formula is in <b class="bold"><i class="emphasis">3-conjunctive normal form</i></b>, or <b class="bold"><i class="emphasis">3-CNF</i></b>, if each clause has exactly three distinct literals.</p>
<p class="para">For example, the boolean formula</p>
<p class="para">(<i class="emphasis">x</i><sub>1</sub> <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>1</sub> <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub>) <span class="unicode">&and;</span> (<i class="emphasis">x</i><sub>3</sub> <span class="unicode">&or;</span> <i class="emphasis">x</i><sub>2</sub> <span class="unicode">&or;</span> <i class="emphasis">x</i><sub>4</sub>) <span class="unicode">&and;</span> (<span class="unicode">&not;</span><i class="emphasis">x</i><sub>1</sub> <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>3</sub> <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>4</sub>)</p>
<p class="para">is in 3-CNF. The first of its three clauses is (<i class="emphasis">x</i><sub>1</sub> <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>1</sub> <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub>), which contains the three literals <i class="emphasis">x</i><sub>1</sub>, <span class="unicode">&not;</span><i class="emphasis">x</i><sub>1</sub>, and <span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub>.</p>
<p class="para">In 3-CNF-SAT, we are asked whether a given boolean formula <i class="emphasis"><span class="unicode">&phi;</span></i> in 3-CNF is satisfiable. The following theorem shows that a polynomial-time algorithm that can determine the satisfiability of boolean formulas is unlikely to exist, even when they are expressed in this simple normal form.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 34.10</span></span><a name="3103"></a><a name="ch34ex35"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Satisfiability of boolean formulas in 3-conjunctive normal form is NP-complete.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> The argument we used in the proof of <a class="internaljump" href="#ch34ex34">Theorem 34.9</a> to show that SAT <span class="unicode">&isin;</span> NP applies equally well here to show that 3-CNF-SAT <span class="unicode">&isin;</span> NP. Thus, by <a class="internaljump" href="#ch34ex33">Lemma 34.8</a>, we need only show that SAT <span class="unicode">&le;</span><sub>P</sub> 3-CNF-SAT.</p>
<p class="para">The reduction algorithm can be broken into three basic steps. Each step progressively transforms the input formula <i class="emphasis"><span class="unicode">&phi;</span></i> closer to the desired 3-conjunctive normal form.</p>
<p class="para">The first step is similar to the one used to prove CIRCUIT-SAT <span class="unicode">&le;</span><sub>P</sub> SAT in <a class="internaljump" href="#ch34ex34">Theorem 34.9</a>. First, we construct a binary "parse" tree for the input formula <i class="emphasis"><span class="unicode">&phi;</span></i>, with literals as leaves and connectives as internal nodes. <a class="internaljump" href="#ch34fig11">Figure 34.11</a> shows such a parse tree for the formula</p>
<p class="para">
<div class="equation">
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(34.3)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig1021_01.jpg" height="15" width="280" alt="" border="0"></span></td>
</tr>
</table>
</div>
</p>
<p class="para">
<div class="figure">
<a name="3104"></a><a name="ch34fig11"></a><span class="figuremediaobject"><a href="images/fig1022%5F01%5F0%2Ejpg" NAME="IMG_1810" target="_parent"><img src="images/fig1022_01.jpg" height="209" width="224" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 34.11: </span>The tree corresponding to the formula <i class="emphasis"><span class="unicode">&phi;</span></i> = ((<i class="emphasis">x</i><sub>1</sub> <span class="unicode">&rarr;</span> <i class="emphasis">x</i><sub>2</sub>)<span class="unicode">&or;</span><span class="unicode">&not;</span>((<span class="unicode">&not;</span><i class="emphasis">x</i><sub>1</sub> <span class="unicode">&harr;</span> <i class="emphasis">x</i><sub>3</sub>)<span class="unicode">&or;</span> <i class="emphasis">x</i><sub>4</sub>))<span class="unicode">&and;</span><span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub>.</span>
</div>
</p>
<p class="para">Should the input formula contain a clause such as the OR of several literals, associativity can be used to parenthesize the expression fully so that every internal node in the resulting tree has 1 or 2 children. The binary parse tree can now be viewed as a circuit for computing the function.</p>
<p class="para">Mimicking the reduction in the proof of <a class="internaljump" href="#ch34ex34">Theorem 34.9</a>, we introduce a variable <i class="emphasis">y<sub>i</sub></i> for the output of each internal node. Then, we rewrite the original formula <i class="emphasis"><span class="unicode">&phi;</span></i> as the AND of the root variable and a conjunction of clauses describing the operation of each node. For the formula (<a href="DDU0230.html#3062" target="_parent" class="chapterjump">34.3</a>), the resulting expression is</p>
<a name="3105"></a><a name="IDX-1000"></a>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis"><span class="unicode">&phi;'</span></i>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">y</i><sub>1</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&and;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">(<i class="emphasis">y</i><sub>1</sub> <span class="unicode">&harr;</span> (<i class="emphasis">y</i><sub>2</sub> <span class="unicode">&and;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub>))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">&nbsp;</td><td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&and;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">(<i class="emphasis">y</i><sub>2</sub> <span class="unicode">&harr;</span> (<i class="emphasis">y</i><sub>3</sub> <span class="unicode">&or;</span> <i class="emphasis">y</i><sub>4</sub>))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">&nbsp;</td><td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&and;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">(<i class="emphasis">y</i><sub>3</sub> <span class="unicode">&harr;</span> (<i class="emphasis">x</i><sub>1</sub> <span class="unicode">&rarr;</span> <i class="emphasis">x</i><sub>2</sub>))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">&nbsp;</td><td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&and;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">(<i class="emphasis">y</i><sub>4</sub> <span class="unicode">&harr;</span> <span class="unicode">&not;</span><i class="emphasis">y</i><sub>5</sub>)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">&nbsp;</td><td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&and;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">(<i class="emphasis">y</i><sub>5</sub> <span class="unicode">&harr;</span> (<i class="emphasis">y</i><sub>6</sub> <span class="unicode">&or;</span> <i class="emphasis">x</i><sub>4</sub>))</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">&nbsp;</td><td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&and;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">(<i class="emphasis">y</i><sub>6</sub> <span class="unicode">&harr;</span> (<span class="unicode">&not;</span><i class="emphasis">x</i><sub>1</sub> <span class="unicode">&rarr;</span> <i class="emphasis">x</i><sub>3</sub>))</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">Observe that the formula <i class="emphasis"><span class="unicode">&phi;</span></i>' thus obtained is a conjunction of clauses <span class="inlinemediaobject"><img src="images/fig1022_02.jpg" height="14" width="10" alt="" border="0"></span>, each of which has at most 3 literals. The only additional requirement is that each clause be an OR of literals.</p>
<p class="para">The second step of the reduction converts each clause <span class="inlinemediaobject"><img src="images/fig1022_03.jpg" height="13" width="11" alt="" border="0"></span> into conjunctive normal form. We construct a truth table for <span class="inlinemediaobject"><img src="images/fig1022_04.jpg" height="13" width="11" alt="" border="0"></span> by evaluating all possible assignments to its variables. Each row of the truth table consists of a possible assignment of the variables of the clause, together with the value of the clause under that assignment. Using the truth-table entries that evaluate to 0, we build a formula in <b class="bold"><i class="emphasis">disjunctive normal form</i></b> (or <b class="bold"><i class="emphasis">DNF</i></b>)<span class="unicode">-</span>an OR of AND's<span class="unicode">-</span>that is equivalent to <span class="inlinemediaobject"><img src="images/fig1022_05.jpg" height="13" width="18" alt="" border="0"></span>. We then convert this formula into a CNF formula <span class="inlinemediaobject"><img src="images/fig1022_06.jpg" height="13" width="12" alt="" border="0"></span> by using DeMorgan's laws (equations (<a href="DDU0247.html#3335" target="_parent" class="chapterjump">B.2</a>)) to complement all literals and change OR's into AND's and AND's into OR's.</p>
<p class="para">In our example, we convert the clause <span class="inlinemediaobject"><img src="images/fig1022_07.jpg" height="16" width="150" alt="" border="0"></span> into CNF as follows. The truth table for <span class="inlinemediaobject"><img src="images/fig1022_08.jpg" height="13" width="10" alt="" border="0"></span> is given in <a class="internaljump" href="#ch34fig12">Figure 34.12</a>. The DNF formula equivalent to <span class="inlinemediaobject"><img src="images/fig1022_09.jpg" height="12" width="17" alt="" border="0"></span> is</p>
<p class="para">(<i class="emphasis">y</i><sub>1</sub> <span class="unicode">&and;</span> <i class="emphasis">y</i><sub>2</sub> <span class="unicode">&and;</span> <i class="emphasis">x</i><sub>2</sub>) <span class="unicode">&or;</span> (<i class="emphasis">y</i><sub>1</sub> <span class="unicode">&and;</span> <span class="unicode">&not;</span><i class="emphasis">y</i><sub>2</sub> <span class="unicode">&and;</span> <i class="emphasis">x</i><sub>2</sub>) <span class="unicode">&or;</span> (<i class="emphasis">y</i><sub>1</sub> <span class="unicode">&and;</span> <span class="unicode">&not;</span><i class="emphasis">y</i><sub>2</sub> <span class="unicode">&and;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub>) <span class="unicode">&or;</span> (<span class="unicode">&not;</span><i class="emphasis">y</i><sub>1</sub> <span class="unicode">&and;</span> <i class="emphasis">y</i><sub>2</sub> <span class="unicode">&and;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub>).</p>
<p class="para">
<div class="miscfigure">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start Figure" border="0"></b></font></td>
</tr>
</table>
<a name="3106"></a><a name="ch34fig12"></a>
<div class="miscfigure-informaltable">
<table border="0">
<thead>
<tr valign="top">
<th class="th" scope="col" align="center">
<p class="table-para">
<i class="emphasis">y</i><sub>1</sub>
</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">
<i class="emphasis">y</i><sub>2</sub>
</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">
<i class="emphasis">x</i><sub>2</sub>
</p>
</th><th class="th" scope="col" align="center">
<p class="table-para">(<i class="emphasis">y</i><sub>1</sub> <span class="unicode">&harr;</span> (<i class="emphasis">y</i><sub>2</sub> <span class="unicode">&and;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub>))</p>
</th>
</tr>
<tr>
<td colspan="4">
<hr>
</td>
</tr>
</thead>
<tbody>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">1</p>
</td><td class="td" align="center">
<p class="table-para">1</p>
</td><td class="td" align="center">
<p class="table-para">1</p>
</td><td class="td" align="center">
<p class="table-para">0</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">1</p>
</td><td class="td" align="center">
<p class="table-para">1</p>
</td><td class="td" align="center">
<p class="table-para">0</p>
</td><td class="td" align="center">
<p class="table-para">1</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">1</p>
</td><td class="td" align="center">
<p class="table-para">0</p>
</td><td class="td" align="center">
<p class="table-para">1</p>
</td><td class="td" align="center">
<p class="table-para">0</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">1</p>
</td><td class="td" align="center">
<p class="table-para">0</p>
</td><td class="td" align="center">
<p class="table-para">0</p>
</td><td class="td" align="center">
<p class="table-para">0</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">0</p>
</td><td class="td" align="center">
<p class="table-para">1</p>
</td><td class="td" align="center">
<p class="table-para">1</p>
</td><td class="td" align="center">
<p class="table-para">1</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">0</p>
</td><td class="td" align="center">
<p class="table-para">1</p>
</td><td class="td" align="center">
<p class="table-para">0</p>
</td><td class="td" align="center">
<p class="table-para">0</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">0</p>
</td><td class="td" align="center">
<p class="table-para">0</p>
</td><td class="td" align="center">
<p class="table-para">1</p>
</td><td class="td" align="center">
<p class="table-para">1</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="center">
<p class="table-para">0</p>
</td><td class="td" align="center">
<p class="table-para">0</p>
</td><td class="td" align="center">
<p class="table-para">0</p>
</td><td class="td" align="center">
<p class="table-para">1</p>
</td>
</tr>
</tbody>
</table>
</div>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End Figure" border="0"></b></font></td>
</tr>
</table>
<br style="line-height: 1">
<span class="miscfigure-title"><span class="figure-titlelabel">Figure 34.12: </span>The truth table for the clause (<i class="emphasis">y</i><sub>1</sub> <span class="unicode">&harr;</span> (<i class="emphasis">y</i><sub>2</sub> <span class="unicode">&and;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub>)).</span>
</div>
</p>
<a name="3107"></a><a name="IDX-1001"></a>
<p class="para">Applying DeMorgan's laws, we get the CNF formula</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig1023_01.jpg" height="39" width="289" alt="" border="0"></span>
</div>
<p class="para">which is equivalent to the original clause <span class="inlinemediaobject"><img src="images/fig1023_02.jpg" height="13" width="11" alt="" border="0"></span>.</p>
<p class="para">Each clause <span class="inlinemediaobject"><img src="images/fig1023_03.jpg" height="13" width="10" alt="" border="0"></span> of the formula <i class="emphasis"><span class="unicode">&phi;</span></i>' has now been converted into a CNF formula <span class="inlinemediaobject"><img src="images/fig1023_04.jpg" height="13" width="12" alt="" border="0"></span>, and thus <i class="emphasis"><span class="unicode">&phi;</span></i>' is equivalent to the CNF formula <i class="emphasis"><span class="unicode">&phi;</span></i>" consisting of the conjunction of the <span class="inlinemediaobject"><img src="images/fig1023_05.jpg" height="13" width="13" alt="" border="0"></span>. Moreover, each clause of <i class="emphasis"><span class="unicode">&phi;</span></i>" has at most 3 literals.</p>
<p class="para">The third and final step of the reduction further transforms the formula so that each clause has <i class="emphasis">exactly</i> 3 distinct literals. The final 3-CNF formula <i class="emphasis"><span class="unicode">&phi;</span></i>"' is constructed from the clauses of the CNF formula <i class="emphasis"><span class="unicode">&phi;</span></i>". It also uses two auxiliary variables that we shall call <i class="emphasis">p</i> and <i class="emphasis">q</i>. For each clause <i class="emphasis">C<sub>i</sub></i> of <i class="emphasis"><span class="unicode">&phi;</span></i>", we include the following clauses in <i class="emphasis"><span class="unicode">&phi;</span></i>"':</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">If <i class="emphasis">C<sub>i</sub></i> has 3 distinct literals, then simply include <i class="emphasis">C<sub>i</sub></i> as a clause of <i class="emphasis"><span class="unicode">&phi;</span></i>"'.</p>
</li>
<li class="listitem">
<p class="first-para">If <i class="emphasis">C<sub>i</sub></i> has 2 distinct literals, that is, if <i class="emphasis">C<sub>i</sub></i> = (<i class="emphasis">l</i><sub>1</sub> <span class="unicode">&or;</span> <i class="emphasis">l</i><sub>2</sub>), where <i class="emphasis">l</i><sub>1</sub> and <i class="emphasis">l</i><sub>2</sub> are literals, then include (<i class="emphasis">l</i><sub>1</sub> <span class="unicode">&or;</span> <i class="emphasis">l</i><sub>2</sub> <span class="unicode">&or;</span> <i class="emphasis">p</i>) <span class="unicode">&and;</span> (<i class="emphasis">l</i><sub>1</sub> <span class="unicode">&or;</span> <i class="emphasis">l</i><sub>2</sub> <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">p</i>) as clauses of <i class="emphasis"><span class="unicode">&phi;</span></i>"'. The literals <i class="emphasis">p</i> and <span class="unicode">&not;</span> <i class="emphasis">p</i> merely fulfill the syntactic requirement that there be exactly 3 distinct literals per clause: (<i class="emphasis">l</i><sub>1</sub> <span class="unicode">&or;</span> <i class="emphasis">l</i><sub>2</sub> <span class="unicode">&or;</span> <i class="emphasis">p</i>) <span class="unicode">&and;</span> (<i class="emphasis">l</i><sub>1</sub> <span class="unicode">&or;</span> <i class="emphasis">l</i><sub>2</sub> <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">p</i>) is equivalent to (<i class="emphasis">l</i><sub>1</sub> <span class="unicode">&or;</span> <i class="emphasis">l</i><sub>2</sub>) whether <i class="emphasis">p</i> = 0 or <i class="emphasis">p</i> = 1.</p>
</li>
<li class="listitem">
<p class="first-para">If <i class="emphasis">C<sub>i</sub></i> has just 1 distinct literal <i class="emphasis">l</i>, then include (<i class="emphasis">l</i> <span class="unicode">&or;</span> <i class="emphasis">p</i> <span class="unicode">&or;</span> <i class="emphasis">q</i>) <span class="unicode">&and;</span> (<i class="emphasis">l</i> <span class="unicode">&or;</span> <i class="emphasis">p</i> <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">q</i>) <span class="unicode">&and;</span> (<i class="emphasis">l</i> <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">p</i> <span class="unicode">&or;</span> <i class="emphasis">q</i>) <span class="unicode">&and;</span> (<i class="emphasis">l</i> <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">p</i> <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">q</i>) as clauses of <i class="emphasis"><span class="unicode">&phi;</span></i>"'. Note that every setting of <i class="emphasis">p</i> and <i class="emphasis">q</i> causes the conjunction of these four clauses to evaluate to <i class="emphasis">l</i>.</p>
</li>
</ul>
<p class="para">We can see that the 3-CNF formula <i class="emphasis"><span class="unicode">&phi;</span></i>"' is satisfiable if and only if <i class="emphasis"><span class="unicode">&phi;</span></i> is satisfiable by inspecting each of the three steps. Like the reduction from CIRCUIT-SAT to SAT, the construction of <i class="emphasis"><span class="unicode">&phi;</span></i>' from <i class="emphasis"><span class="unicode">&phi;</span></i> in the first step preserves satisfiability. The second step produces a CNF formula <i class="emphasis"><span class="unicode">&phi;</span></i>" that is algebraically equivalent to <i class="emphasis"><span class="unicode">&phi;</span></i>'. The third step produces a 3-CNF formula <i class="emphasis"><span class="unicode">&phi;</span></i>"' that is effectively equivalent to <i class="emphasis"><span class="unicode">&phi;</span></i>", since <a name="3108"></a><a name="IDX-1002"></a>any assignment to the variables <i class="emphasis">p</i> and <i class="emphasis">q</i> produces a formula that is algebraically equivalent to <i class="emphasis"><span class="unicode">&phi;</span></i>".</p>
<p class="last-para">We must also show that the reduction can be computed in polynomial time. Constructing <i class="emphasis"><span class="unicode">&phi;</span></i>' from <i class="emphasis"><span class="unicode">&phi;</span></i> introduces at most 1 variable and 1 clause per connective in <i class="emphasis"><span class="unicode">&phi;</span></i>. Constructing <i class="emphasis"><span class="unicode">&phi;</span></i>" from <i class="emphasis"><span class="unicode">&phi;</span></i>' can introduce at most 8 clauses into <i class="emphasis"><span class="unicode">&phi;</span></i>" for each clause from <i class="emphasis"><span class="unicode">&phi;</span></i>', since each clause of <i class="emphasis"><span class="unicode">&phi;</span></i>' has at most 3 variables, and the truth table for each clause has at most 2<sup>3</sup> = 8 rows. The construction of <i class="emphasis"><span class="unicode">&phi;</span></i>"' from <span class="unicode">&phi;</span>" introduces at most 4 clauses into <i class="emphasis"><span class="unicode">&phi;</span></i>"' for each clause of <i class="emphasis"><span class="unicode">&phi;</span></i>". Thus, the size of the resulting formula <i class="emphasis"><span class="unicode">&phi;</span></i>"' is polynomial in the length of the original formula. Each of the constructions can easily be accomplished in polynomial time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.4-1</span></span><a name="3109"></a><a name="ch34ex36"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Consider the straightforward (nonpolynomial-time) reduction in the proof of <a class="internaljump" href="#ch34ex34">Theorem 34.9</a>. Describe a circuit of size <i class="emphasis">n</i> that, when converted to a formula by this method, yields a formula whose size is exponential in <i class="emphasis">n</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.4-2</span></span><a name="3110"></a><a name="ch34ex37"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show the 3-CNF formula that results when we use the method of <a class="internaljump" href="#ch34ex35">Theorem 34.10</a> on the formula (<a href="DDU0230.html#3062" target="_parent" class="chapterjump">34.3</a>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.4-3</span></span><a name="3111"></a><a name="ch34ex38"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Professor Jagger proposes to show that SAT <span class="unicode">&le;</span><sub>P</sub> 3-CNF-SAT by using only the truth-table technique in the proof of <a class="internaljump" href="#ch34ex35">Theorem 34.10</a>, and not the other steps. That is, the professor proposes to take the boolean formula <i class="emphasis"><span class="unicode">&phi;</span></i>, form a truth table for its variables, derive from the truth table a formula in 3-DNF that is equivalent to <span class="unicode">&not;</span><i class="emphasis"><span class="unicode">&phi;</span></i>, and then negate and apply DeMorgan's laws to produce a 3-CNF formula equivalent to <i class="emphasis"><span class="unicode">&phi;</span></i>. Show that this strategy does not yield a polynomial-time reduction.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.4-4</span></span><a name="3112"></a><a name="ch34ex39"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that the problem of determining whether a boolean formula is a tautology is complete for co-NP. (<i class="emphasis">Hint:</i> See <a href="DDU0230.html#3089" target="_parent" class="chapterjump">Exercise 34.3-7</a>.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.4-5</span></span><a name="3113"></a><a name="ch34ex40"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that the problem of determining the satisfiability of boolean formulas in disjunctive normal form is polynomial-time solvable.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.4-6</span></span><a name="3114"></a><a name="ch34ex41"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that someone gives you a polynomial-time algorithm to decide formula satisfiability. Describe how to use this algorithm to find satisfying assignments in polynomial time.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="3115"></a><a name="IDX-1003"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.4-7</span></span><a name="3116"></a><a name="ch34ex42"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let 2-CNF-SAT be the set of satisfiable boolean formulas in CNF with exactly 2 literals per clause. Show that 2-CNF-SAT <span class="unicode">&isin;</span> P. Make your algorithm as efficient as possible. (<i class="emphasis">Hint:</i> Observe that <i class="emphasis">x</i> <span class="unicode">&or;</span> <i class="emphasis">y</i> is equivalent to <span class="unicode">&not;</span><i class="emphasis">x</i> <span class="unicode">&rarr;</span> <i class="emphasis">y</i>. Reduce 2-CNF-SAT to a problem on a directed graph that is efficiently solvable.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0230.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0232.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
