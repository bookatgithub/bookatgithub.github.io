<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>34.5 NP-complete problems</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0231.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0233.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch34"></a>
<div class="section">
<h2 class="first-section-title">
<a name="3117"></a><a name="ch34lev1sec5"></a><span class="section-titlelabel">34.5 </span>NP-complete problems</h2>
<p class="first-para">NP-complete problems arise in diverse domains: boolean logic, graphs, arithmetic, network design, sets and partitions, storage and retrieval, sequencing and scheduling, mathematical programming, algebra and number theory, games and puzzles, automata and language theory, program optimization, biology, chemistry, physics, and more. In this section, we shall use the reduction methodology to provide NP-completeness proofs for a variety of problems drawn from graph theory and set partitioning.</p>
<p class="para">
<a class="internaljump" href="#ch34fig13">Figure 34.13</a> outlines the structure of the NP-completeness proofs in this section and <a href="DDU0231.html#3092" target="_parent" class="chapterjump">Section 34.4.</a> Each language in the figure is proved NP-complete by reduction from the language that points to it. At the root is CIRCUIT-SAT, which we proved NP-complete in <a href="DDU0230.html#3082" target="_parent" class="chapterjump">Theorem 34.7</a>.</p>
<div class="figure">
<a name="3118"></a><a name="ch34fig13"></a><span class="figuremediaobject"><a href="images/fig1026%5F01%5F0%2Ejpg" NAME="IMG_1824" target="_parent"><img src="images/fig1026_01.jpg" height="212" width="217" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 34.13: </span>The structure of NP-completeness proofs in Sections 34.4 and 34.5. All proofs ultimately follow by reduction from the NP-completeness of CIRCUIT-SAT.</span>
</div>
<div class="section">
<h3 class="sect3-title">
<a name="3119"></a><a name="ch34lev2sec1"></a><span class="section-titlelabel">34.5.1 </span>The clique problem</h3>
<p class="first-para">A <b class="bold"><i class="emphasis">clique</i></b> in an undirected graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) is a subset <i class="emphasis">V</i>' <span class="unicode">&sube;</span> <i class="emphasis">V</i> of vertices, each pair of which is connected by an edge in <i class="emphasis">E</i>. In other words, a clique is a complete subgraph of <i class="emphasis">G</i>. The <b class="bold"><i class="emphasis">size</i></b> of a clique is the number of vertices it contains. The <b class="bold"><i class="emphasis">clique problem</i></b> is the optimization problem of finding a clique of maximum size in a graph. As a decision problem, we ask simply whether a clique of a given size <i class="emphasis">k</i> exists in the graph. The formal definition is</p>
<p class="para">CLIQUE = {<span class="unicode">&#12296;</span><i class="emphasis">G</i>, <i class="emphasis">k</i><span class="unicode">&#12297;</span> : <i class="emphasis">G</i> is a graph with a clique of size <i class="emphasis">k</i>}.</p>
<p class="para">A naive algorithm for determining whether a graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) with |<i class="emphasis">V</i>| vertices has a clique of size <i class="emphasis">k</i> is to list all <i class="emphasis">k</i>-subsets of <i class="emphasis">V</i> , and check each one to see whether it forms a clique. The running time of this algorithm is <span class="inlinemediaobject"><img src="images/fig1025_01.jpg" height="18" width="50" alt="" border="0"></span>, which is polynomial if <i class="emphasis">k</i> is a constant. In general, however, <i class="emphasis">k</i> could be near |<i class="emphasis">V</i>| /2, in which case the algorithm runs in superpolynomial time. As one might suspect, an efficient algorithm for the clique problem is unlikely to exist. <i class="emphasis">k</i>
</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 34.11</span></span><a name="3120"></a><a name="ch34ex43"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The clique problem is NP-complete.</p>
<a name="3121"></a><a name="IDX-1004"></a>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> To show that CLIQUE NP, for a given graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>), we use the set <i class="emphasis">V</i>' <span class="unicode">&sube;</span> <i class="emphasis">V</i> of vertices in the clique as a certificate for <i class="emphasis">G</i>. Checking whether <i class="emphasis">V</i>' is a clique can be accomplished in polynomial time by checking whether, for each pair <i class="emphasis">u</i>, <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>', the edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) belongs to <i class="emphasis">E</i>.</p>
<p class="para">We next prove that 3-CNF-SAT <span class="unicode">&le;</span><sub>P</sub> CLIQUE, which shows that the clique problem is NP-hard. That we should be able to prove this result is somewhat surprising, since on the surface logical formulas seem to have little to do with graphs.</p>
<p class="para">The reduction algorithm begins with an instance of 3-CNF-SAT. Let <i class="emphasis"><span class="unicode">&phi;</span></i> = <i class="emphasis">C</i><sub>1</sub> <span class="unicode">&and;</span> <i class="emphasis">C</i><sub>2</sub> <span class="unicode">&and;</span> <span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&middot;</span> <span class="unicode">&and;</span> <i class="emphasis">C<sub>k</sub></i> be a boolean formula in 3-CNF with <i class="emphasis">k</i> clauses. For <i class="emphasis">r</i> = 1, 2,..., <i class="emphasis">k</i>, each clause <i class="emphasis">C<sub>r</sub></i> has exactly three distinct literals <span class="inlinemediaobject"><img src="images/fig1026_02.jpg" height="12" width="7" alt="" border="0"></span>,<span class="inlinemediaobject"><img src="images/fig1026_03.jpg" height="12" width="8" alt="" border="0"></span> and <span class="inlinemediaobject"><img src="images/fig1026_04.jpg" height="12" width="7" alt="" border="0"></span>. We shall construct a graph <i class="emphasis">G</i> such that <i class="emphasis"><span class="unicode">&phi;</span></i> is satisfiable if and only if <i class="emphasis">G</i> has a clique of size <i class="emphasis">k</i>.</p>
<p class="para">The graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) is constructed as follows. For each clause <span class="inlinemediaobject"><img src="images/fig1026_05.jpg" height="11" width="26" alt="" border="0"></span> <span class="inlinemediaobject"><img src="images/fig1026_06.jpg" height="12" width="59" alt="" border="0"></span> in <i class="emphasis"><span class="unicode">&phi;</span></i>, we place a triple of vertices <span class="inlinemediaobject"><img src="images/fig1026_07.jpg" height="12" width="9" alt="" border="0"></span>, <span class="inlinemediaobject"><img src="images/fig1026_08.jpg" height="12" width="10" alt="" border="0"></span>, and <span class="inlinemediaobject"><img src="images/fig1026_09.jpg" height="12" width="9" alt="" border="0"></span> into <i class="emphasis">V</i>. We put an edge between two vertices <span class="inlinemediaobject"><img src="images/fig1026_10.jpg" height="12" width="10" alt="" border="0"></span> and <span class="inlinemediaobject"><img src="images/fig1026_11.jpg" height="14" width="10" alt="" border="0"></span> if both of the following hold:</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">
<span class="inlinemediaobject"><img src="images/fig1026_12.jpg" height="12" width="10" alt="" border="0"></span>, and <span class="inlinemediaobject"><img src="images/fig1026_13.jpg" height="13" width="10" alt="" border="0"></span> and are in different triples, that is, <i class="emphasis">r</i> <span class="unicode">&ne;</span> <i class="emphasis">s</i>, and</p>
</li>
<li class="listitem">
<p class="first-para">their corresponding literals are <b class="bold"><i class="emphasis">consistent</i></b>, that is, <span class="inlinemediaobject"><img src="images/fig1026_14.jpg" height="12" width="7" alt="" border="0"></span> is not the negation of <span class="inlinemediaobject"><img src="images/fig1026_15.jpg" height="13" width="7" alt="" border="0"></span>.</p>
</li>
</ul>
<p class="para">This graph can easily be computed from <i class="emphasis"><span class="unicode">&phi;</span></i> in polynomial time. As an example of this construction, if we have</p>
<p class="para">
<i class="emphasis"><span class="unicode">&phi;</span></i> = (<i class="emphasis">x</i><sub>1</sub> <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub> <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>3</sub>) <span class="unicode">&and;</span> (<span class="unicode">&not;</span><i class="emphasis">x</i><sub>1</sub> <span class="unicode">&or;</span> <i class="emphasis">x</i><sub>2</sub> <span class="unicode">&or;</span> <i class="emphasis">x</i><sub>3</sub>) <span class="unicode">&and;</span> (<i class="emphasis">x</i><sub>1</sub> <span class="unicode">&or;</span> <i class="emphasis">x</i><sub>2</sub> <span class="unicode">&or;</span> <i class="emphasis">x</i><sub>3</sub>),</p>
<p class="para">then <i class="emphasis">G</i> is the graph shown in <a class="internaljump" href="#ch34fig14">Figure 34.14</a>.</p>
<p class="para">
<div class="figure">
<a name="3122"></a><a name="ch34fig14"></a><span class="figuremediaobject"><a href="images/fig1027%5F01%5F0%2Ejpg" NAME="IMG_1840" target="_parent"><img src="images/fig1027_01.jpg" height="165" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 34.14: </span>The graph <i class="emphasis">G</i> derived from the 3-CNF formula <i class="emphasis"><span class="unicode">&phi;</span></i> = <i class="emphasis">C</i><sub>1</sub> <span class="unicode">&and;</span> <i class="emphasis">C</i><sub>2</sub> <span class="unicode">&and;</span> <i class="emphasis">C</i><sub>3</sub>, where <i class="emphasis">C</i><sub>1</sub> = (<i class="emphasis">x</i><sub>1</sub> <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub> <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>3</sub>), C<sub>2</sub> = (<span class="unicode">&not;</span><i class="emphasis">x</i><sub>1</sub> <span class="unicode">&and;</span> <i class="emphasis">x</i><sub>2</sub> <span class="unicode">&and;</span> <i class="emphasis">x</i><sub>3</sub>), and <i class="emphasis">C</i><sub>3</sub> = (<i class="emphasis">x</i><sub>1</sub> <span class="unicode">&and;</span> <i class="emphasis">x</i><sub>2</sub> <span class="unicode">&and;</span> <i class="emphasis">x</i><sub>3</sub>), in reducing 3-CNF-SAT to CLIQUE. A satisfying assignment of the formula has <i class="emphasis">x</i><sub>2</sub> = 0, <i class="emphasis">x</i><sub>3</sub> = 1, and <i class="emphasis">x</i><sub>1</sub> may be either 0 or 1. This assignment satisfies <i class="emphasis">C</i><sub>1</sub> with <span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub>, and it satisfies <i class="emphasis">C</i><sub>2</sub> and <i class="emphasis">C</i><sub>3</sub> with <i class="emphasis">x</i><sub>3</sub>, corresponding to the clique with lightly shaded vertices.</span>
</div>
</p>
<a name="3123"></a><a name="IDX-1005"></a>
<p class="para">We must show that this transformation of <i class="emphasis"><span class="unicode">&phi;</span></i> into <i class="emphasis">G</i> is a reduction. First, suppose that <i class="emphasis"><span class="unicode">&phi;</span></i> has a satisfying assignment. Then each clause <i class="emphasis">C<sub>r</sub></i> contains at least one literal <span class="inlinemediaobject"><img src="images/fig1027_02.jpg" height="12" width="7" alt="" border="0"></span> that is assigned 1, and each such literal corresponds to a vertex <span class="inlinemediaobject"><img src="images/fig1027_03.jpg" height="12" width="9" alt="" border="0"></span>. Picking one such "true" literal from each clause yields a set <i class="emphasis">V</i>' of <i class="emphasis">k</i> vertices. We claim that <i class="emphasis">V</i>' is a clique. For any two vertices <span class="inlinemediaobject"><img src="images/fig1027_04.jpg" height="12" width="9" alt="" border="0"></span>,<span class="inlinemediaobject"><img src="images/fig1027_05.jpg" height="14" width="34" alt="" border="0"></span> where <i class="emphasis">r</i> <span class="unicode">&ne;</span> <i class="emphasis">s</i>, both corresponding literals <span class="inlinemediaobject"><img src="images/fig1027_06.jpg" height="12" width="7" alt="" border="0"></span> and <span class="inlinemediaobject"><img src="images/fig1027_07.jpg" height="14" width="7" alt="" border="0"></span> are mapped to 1 by the given satisfying assignment, and thus the literals cannot be complements. Thus, by the construction of <i class="emphasis">G</i>, the edge <span class="inlinemediaobject"><img src="images/fig1027_08.jpg" height="14" width="32" alt="" border="0"></span> belongs to <i class="emphasis">E</i>.</p>
<p class="last-para">Conversely, suppose that <i class="emphasis">G</i> has a clique <i class="emphasis">V</i>' of size <i class="emphasis">k</i>. No edges in <i class="emphasis">G</i> connect vertices in the same triple, and so <i class="emphasis">V</i>' contains exactly one vertex per triple. We can assign 1 to each literal <span class="inlinemediaobject"><img src="images/fig1027_09.jpg" height="12" width="8" alt="" border="0"></span> such that <span class="inlinemediaobject"><img src="images/fig1027_10.jpg" height="13" width="36" alt="" border="0"></span> without fear of assigning 1 to both a literal and its complement, since <i class="emphasis">G</i> contains no edges between inconsistent literals. Each clause is satisfied, and so <i class="emphasis"><span class="unicode">&phi;</span></i> is satisfied. (Any variables that do not correspond to a vertex in the clique may be set arbitrarily.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">In the example of <a class="internaljump" href="#ch34fig14">Figure 34.14</a>, a satisfying assignment of <i class="emphasis"><span class="unicode">&phi;</span></i> has <i class="emphasis">x</i><sub>2</sub> = 0 and <i class="emphasis">x</i><sub>3</sub> = 1. A corresponding clique of size <i class="emphasis">k</i> = 3 consists of the vertices corresponding to <span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub> from the first clause, <i class="emphasis">x</i><sub>3</sub> from the second clause, and <i class="emphasis">x</i><sub>3</sub> from the third clause. Because the clique contains no vertices corresponding to either <i class="emphasis">x</i><sub>1</sub> or <span class="unicode">&not;</span><i class="emphasis">x</i><sub>1</sub>, we can set <i class="emphasis">x</i><sub>1</sub> to either 0 or 1 in this satisfying assignment.<a name="3124"></a><a name="IDX-1006"></a>
</p>
<p class="para">Observe that in the proof of <a class="internaljump" href="#ch34ex43">Theorem 34.11</a>, we reduced an arbitrary instance of 3-CNF-SAT to an instance of CLIQUE with a particular structure. It might seem that we have shown only that CLIQUE is NP-hard in graphs in which the vertices are restricted to occur in triples and in which there are no edges between vertices in the same triple. Indeed, we have shown that CLIQUE is NP-hard only in this restricted case, but this proof suffices to show that CLIQUE is NP-hard in general graphs. Why? If we had a polynomial-time algorithm that solved CLIQUE on general graphs, it would also solve CLIQUE on restricted graphs.</p>
<p class="para">It would not have been sufficient, however, to reduce instances of 3-CNF-SAT with a special structure to general instances of CLIQUE. Why? It might have been the case that the instances of 3-CNF-SAT we chose to reduce from were "easy," and so we would not have reduced an NP-hard problem to CLIQUE.</p>
<p class="last-para">Observe also that the reduction used the instance of 3-CNF-SAT but not the solution. It would have been a mistake for the polynomial-time reduction to have been based on knowing whether the formula <i class="emphasis"><span class="unicode">&phi;</span></i> is satisfiable, since we do not know how to determine this information in polynomial time.</p>

</div>
<div class="section">
<h3 class="sect3-title">
<a name="3125"></a><a name="ch34lev2sec2"></a><span class="section-titlelabel">34.5.2 </span>The vertex-cover problem</h3>
<p class="first-para">A <b class="bold"><i class="emphasis">vertex cover</i></b> of an undirected graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) is a subset <i class="emphasis">V</i>' <span class="unicode">&sube;</span> <i class="emphasis">V</i> such that if (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>, then <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>' or <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>' (or both). That is, each vertex "covers" its incident edges, and a vertex cover for <i class="emphasis">G</i> is a set of vertices that covers all the edges in <i class="emphasis">E</i>. The <b class="bold"><i class="emphasis">size</i></b> of a vertex cover is the number of vertices in it. For example, the graph in <a class="internaljump" href="#ch34fig15">Figure 34.15(b)</a> has a vertex cover {<i class="emphasis">w</i>, <i class="emphasis">z</i>} of size 2.</p>
<p class="para">
<div class="figure">
<a name="3126"></a><a name="ch34fig15"></a><span class="figuremediaobject"><a href="images/fig1029%5F02%5F0%2Ejpg" NAME="IMG_1851" target="_parent"><img src="images/fig1029_02.jpg" height="130" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 34.15: </span>Reducing CLIQUE to VERTEX-COVER. <i class="emphasis">(a)</i> An undirected graph <i class="emphasis">G</i> = (<i class="emphasis">V, E</i>) with clique <i class="emphasis">V</i>' = {<i class="emphasis">u, v, x, y</i>}. <i class="emphasis">(b)</i> The graph <span class="inlinemediaobject"><img src="images/fig1029_01.jpg" height="10" width="9" alt="" border="0"></span> produced by the reduction algorithm that has vertex cover <i class="emphasis">V</i> - <i class="emphasis">V</i>' = {<i class="emphasis">w, z</i>}.</span>
</div>
</p>
<p class="para">The <b class="bold"><i class="emphasis">vertex-cover problem</i></b> is to find a vertex cover of minimum size in a given graph. Restating this optimization problem as a decision problem, we wish to determine whether a graph has a vertex cover of a given size <i class="emphasis">k</i>. As a language, we define</p>
<p class="para">VERTEX-COVER = {<span class="unicode">&#12296;</span><i class="emphasis">G</i>, <i class="emphasis">k</i><span class="unicode">&#12297;</span> : graph <i class="emphasis">G</i> has a vertex cover of size <i class="emphasis">k</i>}.</p>
<p class="para">The following theorem shows that this problem is NP-complete.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 34.12</span></span><a name="3127"></a><a name="ch34ex44"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The vertex-cover problem is NP-complete.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> We first show that VERTEX-COVER <span class="unicode">&isin;</span> NP. Suppose we are given a graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) and an integer <i class="emphasis">k</i>. The certificate we choose is the vertex cover <i class="emphasis">V</i>' <span class="unicode">&sube;</span> <i class="emphasis">V</i> itself. The verification algorithm affirms that |<i class="emphasis">V</i>'| = <i class="emphasis">k</i>, and then it checks, for each edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>, that <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>' or <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>'. This verification can be performed straightforwardly in polynomial time.</p>
<p class="para">We prove that the vertex-cover problem is NP-hard by showing that CLIQUE <span class="unicode">&le;</span><sub>P</sub> VERTEX-COVER. This reduction is based on the notion of the "complement" of <a name="3128"></a><a name="IDX-1007"></a>a graph. Given an undirected graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>), we define the <b class="bold"><i class="emphasis">complement</i></b> of <i class="emphasis">G</i> as <span class="inlinemediaobject"><img src="images/fig1029_03.jpg" height="13" width="57" alt="" border="0"></span>, where <span class="inlinemediaobject"><img src="images/fig1029_04.jpg" height="13" width="134" alt="" border="0"></span>, and (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&notin;</span> <i class="emphasis">E</i>}. In other words, <span class="inlinemediaobject"><img src="images/fig1029_05.jpg" height="10" width="9" alt="" border="0"></span> is the graph containing exactly those edges that are not in <i class="emphasis">G</i>. <a class="internaljump" href="#ch34fig15">Figure 34.15</a> shows a graph and its complement and illustrates the reduction from CLIQUE to VERTEX-COVER.</p>
<p class="para">The reduction algorithm takes as input an instance <span class="unicode">&#12296;</span><i class="emphasis">G</i>, <i class="emphasis">k</i><span class="unicode">&#12297;</span> of the clique problem. It computes the complement <span class="inlinemediaobject"><img src="images/fig1029_06.jpg" height="10" width="9" alt="" border="0"></span>, which is easily done in polynomial time. The output of the reduction algorithm is the instance <span class="inlinemediaobject"><img src="images/fig1029_07.jpg" height="13" width="55" alt="" border="0"></span>, of the vertex-cover problem. To complete the proof, we show that this transformation is indeed a reduction: the graph <i class="emphasis">G</i> has a clique of size <i class="emphasis">k</i> if and only if the graph <span class="inlinemediaobject"><img src="images/fig1029_08.jpg" height="10" width="9" alt="" border="0"></span> has a vertex cover of size |<i class="emphasis">V</i> | - <i class="emphasis">k</i>.</p>
<p class="para">Suppose that <i class="emphasis">G</i> has a clique <i class="emphasis">V</i>' <span class="unicode">&sube;</span> <i class="emphasis">V</i> with |<i class="emphasis">V</i>'| = <i class="emphasis">k</i>. We claim that <i class="emphasis">V</i> - <i class="emphasis">V</i>' is a vertex cover in <span class="inlinemediaobject"><img src="images/fig1029_09.jpg" height="10" width="9" alt="" border="0"></span>. Let (<i class="emphasis">u</i>, <i class="emphasis">v</i>) be any edge in <i class="emphasis"><span class="unicode">&#274;</span></i>. Then, (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&notin;</span> <i class="emphasis">E</i>, which implies that at least one of <i class="emphasis">u</i> or <i class="emphasis">v</i> does not belong to <i class="emphasis">V</i>', since every pair of vertices in <i class="emphasis">V</i>' is connected by an edge of <i class="emphasis">E</i>. Equivalently, at least one of <i class="emphasis">u</i> or <i class="emphasis">v</i> is in <i class="emphasis">V</i> - <i class="emphasis">V</i>', which means that edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is covered by <i class="emphasis">V</i> - <i class="emphasis">V</i>'. Since (<i class="emphasis">u</i>, <i class="emphasis">v</i>) was chosen arbitrarily from <i class="emphasis">&#274;</i>, every edge of <i class="emphasis">&#274;</i> is covered by a vertex in <i class="emphasis">V</i> - <i class="emphasis">V</i>'. Hence, the set <i class="emphasis">V</i> - <i class="emphasis">V</i>', which has size |<i class="emphasis">V</i> | - <i class="emphasis">k</i>, forms a vertex cover for <span class="inlinemediaobject"><img src="images/fig1029_10.jpg" height="10" width="9" alt="" border="0"></span>.</p>
<p class="last-para">Conversely, suppose that <span class="inlinemediaobject"><img src="images/fig1029_11.jpg" height="10" width="9" alt="" border="0"></span> has a vertex cover <i class="emphasis">V</i>' <span class="unicode">&sube;</span> <i class="emphasis">V</i>, where |<i class="emphasis">V</i>'| = |<i class="emphasis">V</i>| - <i class="emphasis">k</i>. Then, for all <i class="emphasis">u</i>, <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, if (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis"><span class="unicode">&#274;</span></i>, then <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>' or <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>' or both. The contrapositive of this implication is that for all <i class="emphasis">u</i>, <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, if <i class="emphasis">u</i> <span class="unicode">&notin;</span> <i class="emphasis">V</i>' and <i class="emphasis">v</i> <span class="unicode">&notin;</span> <i class="emphasis">V</i>', then (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <i class="emphasis">E</i>. In other words, <i class="emphasis">V</i> -<i class="emphasis">V</i>' is a clique, and it has size |<i class="emphasis">V</i> |-|<i class="emphasis">V</i>'| = <i class="emphasis">k</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<p class="para">Since VERTEX-COVER is NP-complete, we don't expect to find a polynomial-time algorithm for finding a minimum-size vertex cover. <a href="DDU0236.html#3173" target="_parent" class="chapterjump">Section 35.1</a> presents a polynomial-time "approximation algorithm," however, which produces "approxi<a name="3129"></a><a name="IDX-1008"></a>mate" solutions for the vertex-cover problem. The size of a vertex cover produced by the algorithm is at most twice the minimum size of a vertex cover.</p>
<p class="last-para">Thus, we shouldn't give up hope just because a problem is NP-complete. There may be a polynomial-time approximation algorithm that obtains near-optimal solutions, even though finding an optimal solution is NP-complete. <a href="DDU0234.html#3166" target="_parent" class="chapterjump">Chapter 35</a> gives several approximation algorithms for NP-complete problems.</p>

</div>
<div class="section">
<h3 class="sect3-title">
<a name="3130"></a><a name="ch34lev2sec3"></a><span class="section-titlelabel">34.5.3 </span>The hamiltonian-cycle problem</h3>
<p class="first-para">We now return to the hamiltonian-cycle problem defined in <a href="DDU0229.html#3036" target="_parent" class="chapterjump">Section 34.2.</a>
</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 34.13</span></span><a name="3131"></a><a name="ch34ex45"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The hamiltonian cycle problem is NP-complete.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> We first show that HAM-CYCLE belongs to NP. Given a graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>), our certificate is the sequence of |<i class="emphasis">V</i>| vertices that makes up the hamiltonian cycle. The verification algorithm checks that this sequence contains each vertex in <i class="emphasis">V</i> exactly once and that with the first vertex repeated at the end, it forms a cycle in <i class="emphasis">G</i>. That is, it checks that there is an edge between each pair of consecutive vertices and between the first and last vertices. This verification can be performed in polynomial time.</p>
<p class="para">We now prove that VERTEX-COVER <span class="unicode">&le;</span><sub>P</sub> HAM-CYCLE, which shows that HAM-CYCLE is NP-complete. Given an undirected graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) and an integer <i class="emphasis">k</i>, we construct an undirected graph <i class="emphasis">G</i>' = (<i class="emphasis">V</i>', <i class="emphasis">E</i>') that has a hamiltonian cycle if and only if <i class="emphasis">G</i> has a vertex cover of size <i class="emphasis">k</i>.</p>
<p class="para">Our construction is based on a <b class="bold"><i class="emphasis">widget</i></b>, which is a piece of a graph that enforces certain properties. <a class="internaljump" href="#ch34fig16">Figure 34.16(a)</a> shows the widget we use. For each edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>, the graph <i class="emphasis">G</i>' that we construct will contain one copy of this widget,which we denote by <i class="emphasis">W<sub>uv</sub></i>. We denote each vertex in <i class="emphasis">W<sub>uv</sub></i> by [<i class="emphasis">u</i>, <i class="emphasis">v</i>, <i class="emphasis">i</i>] or [<i class="emphasis">v</i>, <i class="emphasis">u</i>, <i class="emphasis">i</i>], where 1 <span class="unicode">&le;</span> <i class="emphasis">i</i> <span class="unicode">&le;</span> 6, so that each widget <i class="emphasis">W<sub>uv</sub></i> contains 12 vertices. Widget <i class="emphasis">W<sub>uv</sub></i> also contains the 14 edges shown in <a class="internaljump" href="#ch34fig16">Figure 34.16(a)</a>.</p>
<p class="para">
<div class="figure">
<a name="3132"></a><a name="ch34fig16"></a><span class="figuremediaobject"><a href="images/fig1031%5F01%5F0%2Ejpg" NAME="IMG_1861" target="_parent"><img src="images/fig1031_01.jpg" height="93" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 34.16: </span>The widget used in reducing the vertex-cover problem to the hamiltonian-cycle problem. An edge (<i class="emphasis">u, v</i>) of graph <i class="emphasis">G</i> corresponds to widget <i class="emphasis">W<sub>uv</sub></i> in the graph <i class="emphasis">G</i>' created in the reduction. <i class="emphasis">(a)</i> The widget, with individual vertices labeled. <i class="emphasis">(b)</i><span class="unicode">-</span><i class="emphasis">(d)</i> The shaded paths are the only possible ones through the widget that include all vertices, assuming that the only connections from the widget to the remainder of <i class="emphasis">G</i>' are through vertices [<i class="emphasis">u, v</i>, 1], [<i class="emphasis">u, v</i>, 6], [<i class="emphasis">v, u</i>, 1], and [<i class="emphasis">v, u</i>, 6].</span>
</div>
</p>
<p class="para">Along with the internal structure of the widget, we enforce the properties we want by limiting the connections between the widget and the remainder of the graph <i class="emphasis">G</i>' that we construct. In particular, only vertices [<i class="emphasis">u</i>, <i class="emphasis">v</i>, 1], [<i class="emphasis">u</i>, <i class="emphasis">v</i>, 6], [<i class="emphasis">v</i>, <i class="emphasis">u</i>, 1], and [<i class="emphasis">v</i>, <i class="emphasis">u</i>, 6] will have edges incident from outside <i class="emphasis">W<sub>uv</sub></i>. Any hamiltonian cycle of <i class="emphasis">G</i>' will have to traverse the edges of <i class="emphasis">W<sub>uv</sub></i> in one of the three ways shown in Figures 34.16(b)<span class="unicode">-</span>(d). If the cycle enters through vertex [<i class="emphasis">u</i>, <i class="emphasis">v</i>, 1], it must exit through vertex [<i class="emphasis">u</i>, <i class="emphasis">v</i>, 6], and it either visits all 12 of the widget's vertices (<a class="internaljump" href="#ch34fig16">Figure 34.16(b)</a>) or the six vertices [<i class="emphasis">u</i>, <i class="emphasis">v</i>, 1] through [<i class="emphasis">u</i>, <i class="emphasis">v</i>, 6] (<a class="internaljump" href="#ch34fig16">Figure 34.16(c)</a>). In the latter case, the cycle will have to reenter the widget to visit vertices [<i class="emphasis">v</i>, <i class="emphasis">u</i>, 1] through [<i class="emphasis">v,</i> <i class="emphasis">u</i>, 6]. Similarly, if the cycle enters through vertex [<i class="emphasis">v</i>, <i class="emphasis">u</i>, 1], it must exit through vertex [<i class="emphasis">v</i>, <i class="emphasis">u</i>, 6], and it either visits all 12 of the widget's vertices (<a class="internaljump" href="#ch34fig16">Figure 34.16(d)</a>) or <a name="3133"></a><a name="IDX-1009"></a>the six vertices [<i class="emphasis">v</i>, <i class="emphasis">u</i>, 1] through [<i class="emphasis">v</i>, <i class="emphasis">u</i>, 6] (<a class="internaljump" href="#ch34fig16">Figure 34.16(c)</a>). No other paths through the widget that visit all 12 vertices are possible. In particular, it is impossible to construct two vertex-disjoint paths, one of which connects [<i class="emphasis">u</i>, <i class="emphasis">v</i>, 1] to [<i class="emphasis">v</i>, <i class="emphasis">u</i>, 6] and the other of which connects [<i class="emphasis">v</i>, <i class="emphasis">u</i>, 1] to [<i class="emphasis">u</i>, <i class="emphasis">v</i>, 6], such that the union of the two paths contain all of the widget's vertices.</p>
<p class="para">The only other vertices in <i class="emphasis">V</i>' other than those of widgets are <b class="bold"><i class="emphasis">selector vertices</i></b> <i class="emphasis">s</i><sub>1</sub>, <i class="emphasis">s</i><sub>2</sub>,..., <i class="emphasis">s<sub>k</sub></i>. We use edges incident on selector vertices in <i class="emphasis">G</i>' to select the <i class="emphasis">k</i> vertices of the cover in <i class="emphasis">G</i>.</p>
<p class="para">In addition to the edges in widgets, there are two other types of edges in <i class="emphasis">E</i>', which <a class="internaljump" href="#ch34fig17">Figure 34.17</a> shows. First, for each vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, we add edges to join pairs of widgets in order to form a path containing all widgets corresponding to edges incident on <i class="emphasis">u</i> in <i class="emphasis">G</i>. We arbitrarily order the vertices adjacent to each vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> as <i class="emphasis">u</i><sup>(1)</sup>, <i class="emphasis">u</i><sup>(2)</sup>,..., <i class="emphasis">u</i><sup>(degree(<i class="emphasis">u</i>))</sup>, where degree(<i class="emphasis">u</i>) is the number of vertices adjacent to <i class="emphasis">u</i>. We create a path in <i class="emphasis">G</i>' through all the widgets corresponding to edges incident on <i class="emphasis">u</i> by adding to <i class="emphasis">E</i>' the edges {([<i class="emphasis">u</i>, <i class="emphasis">u</i><sup>(<i class="emphasis">i</i>)</sup>, 6], [<i class="emphasis">u</i>, <i class="emphasis">u</i><sup>(<i class="emphasis">i</i>+1)</sup>, 1]) : 1 <span class="unicode">&le;</span> <i class="emphasis">i</i> <span class="unicode">&le;</span> degree(<i class="emphasis">u</i>) - 1}. In <a class="internaljump" href="#ch34fig17">Figure 34.17</a>, for example, we order the vertices adjacent to <i class="emphasis">w</i> as <i class="emphasis">x</i>, <i class="emphasis">y</i>, <i class="emphasis">z</i>, and so graph <i class="emphasis">G</i>' in part (b) of the figure includes the edges ([<i class="emphasis">w</i>, <i class="emphasis">x</i>, 6], [<i class="emphasis">w</i>, <i class="emphasis">y</i>, 1]) and ([<i class="emphasis">w</i>, <i class="emphasis">y</i>, 6], [<i class="emphasis">w</i>, <i class="emphasis">z</i>, 1]). For each vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, these edges in <i class="emphasis">G</i>' fill in a path containing all widgets corresponding to edges incident on <i class="emphasis">u</i> in <i class="emphasis">G</i>.</p>
<p class="para">
<div class="figure">
<a name="3134"></a><a name="ch34fig17"></a><span class="figuremediaobject"><a href="images/fig1032%5F01%5F0%2Ejpg" NAME="IMG_1862" target="_parent"><img src="images/fig1032_01.jpg" height="232" width="350" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 34.17: </span>The reduction of an instance of the vertex-cover problem to an instance of the hamiltonian-cycle problem. <i class="emphasis">(a)</i> An undirected graph <i class="emphasis">G</i> with a vertex cover of size 2, consisting of the lightly shaded vertices <i class="emphasis">w</i> and <i class="emphasis">y</i>. <i class="emphasis">(b)</i> The undirected graph <i class="emphasis">G</i>' produced by the reduction, with the hamiltonian path corresponding to the vertex cover shaded. The vertex cover {<i class="emphasis">w, y</i>} corresponds to edges (<i class="emphasis">s</i><sub>1</sub>, [<i class="emphasis">w, x</i>, 1]) and (<i class="emphasis">s</i><sub>2</sub>, [<i class="emphasis">y, x</i>, 1]) appearing in the hamiltonian cycle.</span>
</div>
</p>
<p class="para">The intuition behind these edges is that if we choose a vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> in the vertex cover of <i class="emphasis">G</i>, we can construct a path from [<i class="emphasis">u</i>, <i class="emphasis">u</i><sup>(1)</sup>, 1] to [<i class="emphasis">u</i>, <i class="emphasis">u</i><sup>(degree(<i class="emphasis">u</i>))</sup>, 6] in <i class="emphasis">G</i>' that "covers" all widgets corresponding to edges incident on <i class="emphasis">u</i>. That is, for each of these widgets, say <span class="inlinemediaobject"><img src="images/fig1031_02.jpg" height="11" width="25" alt="" border="0"></span>, the path either includes all 12 vertices (if <i class="emphasis">u</i> is in the vertex cover but <i class="emphasis">u</i><sup>(<i class="emphasis">i</i>)</sup> is not) or just the six vertices [<i class="emphasis">u</i>, <i class="emphasis">u</i><sup>(<i class="emphasis">i</i>)</sup>, 1], [<i class="emphasis">u</i>, <i class="emphasis">u</i><sup>(<i class="emphasis">i</i>)</sup>, 2],..., [<i class="emphasis">u</i>, <i class="emphasis">u</i><sup>(<i class="emphasis">i</i>)</sup>, 6] (if both <i class="emphasis">u</i> and <i class="emphasis">u</i><sup>(<i class="emphasis">i</i>)</sup> are in the vertex cover).<a name="3135"></a><a name="IDX-1010"></a>
</p>
<p class="para">The final type of edge in <i class="emphasis">E</i>' joins the first vertex [<i class="emphasis">u</i>, <i class="emphasis">u</i><sup>(1)</sup>, 1] and the last vertex [<i class="emphasis">u</i>, <i class="emphasis">u</i><sup>(degree(<i class="emphasis">u</i>))</sup>, 6] of each of these paths to each of the selector vertices. That is, we include the edges</p>
<div class="informalexample">
<pre class="literallayout-normal">
{(<i class="emphasis">s<sub>j</sub></i>, [<i class="emphasis">u</i>, <i class="emphasis">u</i><sup>(1)</sup>, 1]) : <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> and 1 <span class="unicode">&le;</span> <i class="emphasis">j</i> <span class="unicode">&le;</span> <i class="emphasis">k</i>}
                 <span class="unicode">&cup;</span> {(<i class="emphasis">s<sub>j</sub></i>, [<i class="emphasis">u</i>, <i class="emphasis">u</i><sup>(degree(<i class="emphasis">u</i>))</sup>, 6]) : <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> and 1 <span class="unicode">&le;</span> <i class="emphasis">j</i> <span class="unicode">&le;</span> <i class="emphasis">k</i>}.
</pre>
</div>
<p class="para">Next, we show that the size of <i class="emphasis">G</i>' is polynomial in the size of <i class="emphasis">G</i>, and hence we can construct <i class="emphasis">G</i>' in time polynomial in the size of <i class="emphasis">G</i>. The vertices of <i class="emphasis">G</i>' are those in the widgets, plus the selector vertices. Each widget contains 12 vertices, and there are <i class="emphasis">k</i> <span class="unicode">&le;</span> |<i class="emphasis">V</i>| selector vertices, for a total of</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">|<i class="emphasis">V</i>'|</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">12 |<i class="emphasis">E</i>| + <i class="emphasis">k</i>
</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&le;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">12 |<i class="emphasis">E</i>| + |<i class="emphasis">V</i>|</p>
</td>
</tr>
</tbody>
</table>
</div>
<a name="3136"></a><a name="IDX-1011"></a>
<p class="para">vertices. The edges of <i class="emphasis">G</i>' are those in the widgets, those that go between widgets, and those connecting selector vertices to widgets. There are 14 edges in each widget, or 14 |<i class="emphasis">E</i>| in all widgets. For each vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, there are degree(<i class="emphasis">u</i>) - 1 edges between widgets, so that summed over all vertices in <i class="emphasis">V</i>, there are</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig1033_01.jpg" height="33" width="203" alt="" border="0"></span>
</div>
<p class="para">edges between widgets. Finally, there are two edges for each pair consisting of a selector vertex and a vertex of <i class="emphasis">V</i>, or 2<i class="emphasis">k</i> |<i class="emphasis">V</i>| such edges. The total number of edges of <i class="emphasis">G</i>' is therefore</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">|<i class="emphasis">E</i>'|</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">(14 |<i class="emphasis">E</i>|) + (2 |<i class="emphasis">E</i>| - |<i class="emphasis">V</i>|) + (2<i class="emphasis">k</i>|<i class="emphasis">V</i>|)</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">16 |<i class="emphasis">E</i>| + (2<i class="emphasis">k</i> - 1)|<i class="emphasis">V</i>|</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">&nbsp;</td><td class="td" align="center">
<p class="table-para">
<span class="unicode">&le;</span>
</p>
</td><td class="td" align="left">
<p class="table-para">16 |<i class="emphasis">E</i>| + (2 |<i class="emphasis">V</i>| - 1)|<i class="emphasis">V</i>|.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">Now we show that the transformation from graph <i class="emphasis">G</i> to <i class="emphasis">G</i>' is a reduction. That is, we must show that <i class="emphasis">G</i> has a vertex cover of size <i class="emphasis">k</i> if and only if <i class="emphasis">G</i>' has a hamiltonian cycle.</p>
<p class="para">Suppose that <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) has a vertex cover <i class="emphasis">V</i>* <span class="unicode">&sube;</span> <i class="emphasis">V</i> of size <i class="emphasis">k</i>. Let <i class="emphasis">V</i>* = {<i class="emphasis">u</i><sub>1</sub>, <i class="emphasis">u</i><sub>2</sub>,..., <i class="emphasis">u<sub>k</sub></i>}. As <a class="internaljump" href="#ch34fig17">Figure 34.17</a> shows, we form a hamiltonian cycle in <i class="emphasis">G</i> by including the following edges<sup>[<a name="N2884" href="#ftn.N2884">8</a>]</sup> for each vertex <i class="emphasis">u<sub>j</sub></i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>*. Include edges <span class="inlinemediaobject"><img src="images/fig1033_02.jpg" height="16" width="58" alt="" border="0"></span>, <span class="inlinemediaobject"><img src="images/fig1033_03.jpg" height="16" width="164" alt="" border="0"></span> degree(<i class="emphasis">u<sub>j</sub></i>), which connect all widgets corresponding to edges incident on <i class="emphasis">u<sub>j</sub></i>. We also include the edges within these widgets as <a class="internaljump" href="#ch34fig16">Figures 34.16(b)</a><span class="unicode">-</span>(d) show, depending on whether the edge is covered by one or two vertices in <i class="emphasis">V</i>*. The hamiltonian cycle also includes the edges</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig1033_04.jpg" height="73" width="358" alt="" border="0"></span>
</div>
<p class="para">By inspecting <a class="internaljump" href="#ch34fig17">Figure 34.17</a>, the reader can verify that these edges form a cycle. The cycle starts at <i class="emphasis">s</i><sub>1</sub>, visits all widgets corresponding to edges incident on <i class="emphasis">u</i><sub>1</sub>, then visits <i class="emphasis">s</i><sub>2</sub>, visits all widgets corresponding to edges incident on <i class="emphasis">u</i><sub>2</sub>, and so on, until it returns to <i class="emphasis">s</i><sub>1</sub>. Each widget is visited either once or twice, depending on whether one or two vertices of <i class="emphasis">V</i>* cover its corresponding edge. Because <i class="emphasis">V</i>* is a vertex cover for <i class="emphasis">G</i>, each edge in <i class="emphasis">E</i> is incident on some vertex in <i class="emphasis">V</i>*, and so the cycle visits each vertex in each widget of <i class="emphasis">G</i>'. Because the cycle also visits every selector vertex, it is hamiltonian.<a name="3137"></a><a name="IDX-1012"></a>
</p>
<p class="para">Conversely, suppose that <i class="emphasis">G</i>' = (<i class="emphasis">V</i>', <i class="emphasis">E</i>') has a hamiltonian cycle <i class="emphasis">C</i> <span class="unicode">&sube;</span> <i class="emphasis">E</i>'. We claim that the set</p>
<p class="para">
<div class="equation">
<a name="3138"></a><a name="ch34eq04"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(34.4)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig1034_01.jpg" height="18" width="335" alt="" border="0"></span></td>
</tr>
</table>
</div>
</p>
<p class="last-para">is a vertex cover for <i class="emphasis">G</i>. To see why, partition <i class="emphasis">C</i> into maximal paths that start at some selector vertex <i class="emphasis">s<sub>i</sub></i>, traverse an edge (<i class="emphasis">s<sub>i</sub></i>, [<i class="emphasis">u</i>, <i class="emphasis">u</i><sup>(1)</sup>, 1]) for some <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, and end at a selector vertex <i class="emphasis">s<sub>j</sub></i> without passing through any other selector vertex. Let us call each such path a "cover path." From how <i class="emphasis">G</i>' is constructed, each cover path must start at some <i class="emphasis">s<sub>i</sub></i>, take the edge (<i class="emphasis">s<sub>i</sub></i>, [<i class="emphasis">u</i>, <i class="emphasis">u</i><sup>(1)</sup>, 1]) for some vertex <i class="emphasis">u</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>, pass through all the widgets corresponding to edges in <i class="emphasis">E</i> incident on <i class="emphasis">u</i>, and then end at some selector vertex <i class="emphasis">s<sub>j</sub></i>. We refer to this cover path as <i class="emphasis">p<sub>u</sub></i>, and by equation (<a class="internaljump" href="#ch34eq04">34.4</a>), we put <i class="emphasis">u</i> into <i class="emphasis">V</i>*. Each widget visited by <i class="emphasis">p<sub>u</sub></i> must be <i class="emphasis">W<sub>uv</sub></i> or <i class="emphasis">W<sub>vu</sub></i> for some <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>. For each widget visited by <i class="emphasis">p<sub>u</sub></i>, its vertices are visited by either one or two cover paths. If they are visited by one cover path, then edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i> is covered in <i class="emphasis">G</i> by vertex <i class="emphasis">u</i>. If two cover paths visit the widget, then the other cover path must be <i class="emphasis">p<sub>v</sub></i>, which implies that <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>*, and edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i> is covered by both <i class="emphasis">u</i> and <i class="emphasis">v</i>. Because each vertex in each widget is visited by some cover path, we see that each edge in <i class="emphasis">E</i> is covered by some vertex in <i class="emphasis">V</i>*.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>
<div class="section">
<h3 class="sect3-title">
<a name="3139"></a><a name="ch34lev2sec4"></a><span class="section-titlelabel">34.5.4 </span>The traveling-salesman problem</h3>
<p class="first-para">In the <b class="bold"><i class="emphasis">traveling-salesman problem</i></b>, which is closely related to the hamiltonian-cycle problem, a salesman must visit <i class="emphasis">n</i> cities. Modeling the problem as a complete graph with <i class="emphasis">n</i> vertices, we can say that the salesman wishes to make a <b class="bold"><i class="emphasis">tour</i></b>, or hamiltonian cycle, visiting each city exactly once and finishing at the city he starts from. There is an integer cost <i class="emphasis">c</i>(<i class="emphasis">i</i>, <i class="emphasis">j</i>) to travel from city <i class="emphasis">i</i> to city <i class="emphasis">j</i>, and the salesman wishes to make the tour whose total cost is minimum, where the total cost is the sum of the individual costs along the edges of the tour. For example, in <a class="internaljump" href="#ch34fig18">Figure 34.18</a>, a minimum-cost tour is <span class="unicode">&#12296;</span><i class="emphasis">u</i>, <i class="emphasis">w</i>, <i class="emphasis">v</i>, <i class="emphasis">x</i>, <i class="emphasis">u</i><span class="unicode">&#12297;</span>, with cost 7. The formal language for the corresponding decision problem is</p>
<p class="para">TSP = {<span class="unicode">&#12296;</span><i class="emphasis">G</i>, <i class="emphasis">c</i>, <i class="emphasis">k</i><span class="unicode">&#12297;</span> : <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) is a complete graph, <i class="emphasis">c</i> is a function from <i class="emphasis">V</i> <span class="unicode">&times;</span> <i class="emphasis">V</i> <span class="unicode">&rarr;</span> <b class="bold">Z</b>, <i class="emphasis">k</i> <span class="unicode">&isin;</span> <b class="bold">Z</b>, and <i class="emphasis">G</i> has a traveling-salesman tour with cost at most <i class="emphasis">k</i>}.</p>
<p class="para">
<div class="figure">
<a name="3140"></a><a name="ch34fig18"></a><span class="figuremediaobject"><img src="images/fig1035_01.jpg" height="145" width="147" alt="" border="0"></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 34.18: </span>An instance of the traveling-salesman problem. Shaded edges represent a minimum-cost tour, with cost 7.</span>
</div>
</p>
<p class="para">The following theorem shows that a fast algorithm for the traveling-salesman problem is unlikely to exist.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 34.14</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The traveling-salesman problem is NP-complete.<a name="3141"></a><a name="IDX-1013"></a>
</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> We first show that TSP belongs to NP. Given an instance of the problem, we use as a certificate the sequence of <i class="emphasis">n</i> vertices in the tour. The verification algorithm checks that this sequence contains each vertex exactly once, sums up the edge costs, and checks whether the sum is at most <i class="emphasis">k</i>. This process can certainly be done in polynomial time.</p>
<p class="para">To prove that TSP is NP-hard, we show that HAM-CYCLE <span class="unicode">&le;</span><sub>P</sub> TSP. Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be an instance of HAM-CYCLE. We construct an instance of TSP as follows. We form the complete graph <i class="emphasis">G</i>' = (<i class="emphasis">V</i>, <i class="emphasis">E</i>'), where <i class="emphasis">E</i>' = {(<i class="emphasis">i</i>, <i class="emphasis">j</i>) : <i class="emphasis">i</i>, <i class="emphasis">j</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> and <i class="emphasis">i</i> <span class="unicode">&ne;</span> <i class="emphasis">j</i>}, and we define the cost function <i class="emphasis">c</i> by</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig1035_02.jpg" height="37" width="166" alt="" border="0"></span>
</div>
<p class="para">(Note that because <i class="emphasis">G</i> is undirected, it has no self-loops, and so <i class="emphasis">c</i>(<i class="emphasis">v</i>, <i class="emphasis">v</i>) = 1 for all vertices <i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i>.) The instance of TSP is then (<i class="emphasis">G</i>', <i class="emphasis">c</i>, 0), which is easily formed in polynomial time.</p>
<p class="last-para">We now show that graph <i class="emphasis">G</i> has a hamiltonian cycle if and only if graph <i class="emphasis">G</i>' has a tour of cost at most 0. Suppose that graph <i class="emphasis">G</i> has a hamiltonian cycle <i class="emphasis">h</i>. Each edge in <i class="emphasis">h</i> belongs to <i class="emphasis">E</i> and thus has cost 0 in <i class="emphasis">G</i>'. Thus, <i class="emphasis">h</i> is a tour in <i class="emphasis">G</i>' with cost 0. Conversely, suppose that graph <i class="emphasis">G</i>' has a tour <i class="emphasis">h</i>' of cost at most 0. Since the costs of the edges in <i class="emphasis">E</i>' are 0 and 1, the cost of tour <i class="emphasis">h</i>' is exactly 0 and each edge on the tour must have cost 0. Therefore, <i class="emphasis">h</i>' contains only edges in <i class="emphasis">E</i>. We conclude that <i class="emphasis">h</i>' is a hamiltonian cycle in graph <i class="emphasis">G</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>
<div class="section">
<h3 class="sect3-title">
<a name="3142"></a><a name="ch34lev2sec5"></a><span class="section-titlelabel">34.5.5 </span>The subset-sum problem</h3>
<p class="first-para">The next NP-complete problem we consider is an arithmetic one. In the <b class="bold"><i class="emphasis">subset-sum problem</i></b>, we are given a finite set <i class="emphasis">S</i> <span class="unicode">&sub;</span> <b class="bold">N</b> and a <b class="bold"><i class="emphasis">target</i></b> <i class="emphasis">t</i> <span class="unicode">&isin;</span> <b class="bold">N</b>. We ask whether there is a subset <i class="emphasis">S</i>' <span class="unicode">&sube;</span> <i class="emphasis">S</i> whose elements sum to <i class="emphasis">t</i>. For example, if <i class="emphasis">S</i> = {1, 2, 7, 14, 49, 98, 343, 686, 2409, 2793, 16808, 17206, 117705, 117993} and <i class="emphasis">t</i> = 138457, then the subset <i class="emphasis">S</i>' = {1, 2, 7, 98, 343, 686, 2409, 17206, 117705} is a solution.</p>
<p class="para">As usual, we define the problem as a language:<a name="3143"></a><a name="IDX-1014"></a>
</p>
<p class="para">SUBSET-SUM = {<span class="unicode">&#12296;</span><i class="emphasis">S</i>, <i class="emphasis">t</i><span class="unicode">&#12297;</span> : there exists a subset <i class="emphasis">S</i> <span class="unicode">&sube;</span> <i class="emphasis">S</i> such that <i class="emphasis">t</i> = <span class="unicode">&Sigma;</span><sub><i class="emphasis">s<span class="unicode">&isin;</span>S</i>'</sub> <i class="emphasis">S</i>}.</p>
<p class="para">As with any arithmetic problem, it is important to recall that our standard encoding assumes that the input integers are coded in binary. With this assumption in mind, we can show that the subset-sum problem is unlikely to have a fast algorithm.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 34.15</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The subset-sum problem is NP-complete.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> To show that SUBSET-SUM is in NP, for an instance <span class="unicode">&#12296;</span><i class="emphasis">S</i>, <i class="emphasis">t</i><span class="unicode">&#12297;</span> of the problem, we let the subset <i class="emphasis">S</i>' be the certificate. Checking whether <i class="emphasis">t</i> = <span class="unicode">&Sigma;</span><sub><i class="emphasis">s<span class="unicode">&isin;</span>S</i>'</sub> <i class="emphasis">S</i> can be accomplished by a verification algorithm in polynomial time.</p>
<p class="para">We now show that 3-CNF-SAT <span class="unicode">&le;</span><sub>P</sub> SUBSET-SUM. Given a 3-CNF formula <i class="emphasis"><span class="unicode">&phi;</span></i> over variables <i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>,..., <i class="emphasis">x<sub>n</sub></i> with clauses <i class="emphasis">C</i><sub>1</sub>, <i class="emphasis">C</i><sub>2</sub>,..., <i class="emphasis">C<sub>k</sub></i>, each containing exactly three distinct literals, the reduction algorithm constructs an instance <span class="unicode">&#12296;</span><i class="emphasis">S</i>, <i class="emphasis">t</i><span class="unicode">&#12297;</span> of the subset-sum problem such that <i class="emphasis"><span class="unicode">&phi;</span></i> is satisfiable if and only if there is a subset of <i class="emphasis">S</i> whose sum is exactly <i class="emphasis">t</i>. Without loss of generality, we make two simplifying assumptions about the formula <i class="emphasis"><span class="unicode">&phi;</span></i>. First, no clause contains both a variable and its negation, for such a clause is automatically satisfied by any assignment of values to the variables. Second, each variable appears in at least one clause, for otherwise it does not matter what value is assigned to the variable.</p>
<p class="para">The reduction creates two numbers in set <i class="emphasis">S</i> for each variable <i class="emphasis">x<sub>i</sub></i> and two numbers in <i class="emphasis">S</i> for each clause <i class="emphasis">C<sub>j</sub></i>. We shall create numbers in base 10, where each number contains <i class="emphasis">n</i> +<i class="emphasis">k</i> digits and each digit corresponds to either one variable or one clause. Base 10 (and other bases, as we shall see) has the property we need of preventing carries from lower digits to higher digits.</p>
<p class="para">As <a class="internaljump" href="#ch34fig19">Figure 34.19</a> shows, we construct set <i class="emphasis">S</i> and target <i class="emphasis">t</i> as follows. We label each digit position by either a variable or a clause. The least significant <i class="emphasis">k</i> digits are labeled by the clauses, and the most significant <i class="emphasis">n</i> digits are labeled by variables.</p>
<ul class="itemizedlist">
<li class="first-listitem">
<p class="first-para">The target <i class="emphasis">t</i> has a 1 in each digit labeled by a variable and a 4 in each digit labeled by a clause.</p>
</li>
<li class="listitem">
<p class="first-para">For each variable <i class="emphasis">x<sub>i</sub></i>, there are two integers, <i class="emphasis">v<sub>i</sub></i> and <span class="inlinemediaobject"><img src="images/fig1036_01.jpg" height="12" width="8" alt="" border="0"></span>, in <i class="emphasis">S</i>. Each has a 1 in the digit labeled by <i class="emphasis">x<sub>i</sub></i> and 0's in the other variable digits. If literal <i class="emphasis">x<sub>i</sub></i> appears in clause <i class="emphasis">C<sub>j</sub></i>, then the digit labeled by <i class="emphasis">C<sub>j</sub></i> in <i class="emphasis">v<sub>i</sub></i> contains a 1. If literal <span class="unicode">&not;</span><i class="emphasis">x<sub>i</sub></i> appears in clause <i class="emphasis">C<sub>j</sub></i>, then the digit labeled by <i class="emphasis">C<sub>j</sub></i> in <span class="inlinemediaobject"><img src="images/fig1036_02.jpg" height="12" width="8" alt="" border="0"></span> contains a 1. All other digits labeled by clauses in <i class="emphasis">v<sub>i</sub></i> and <span class="inlinemediaobject"><img src="images/fig1036_03.jpg" height="12" width="8" alt="" border="0"></span> are 0.</p>
<p class="last-para">All <i class="emphasis">v<sub>i</sub></i> and <span class="inlinemediaobject"><img src="images/fig1036_04.jpg" height="12" width="8" alt="" border="0"></span> values in set <i class="emphasis">S</i> are unique. Why? For <i class="emphasis">l</i> <span class="unicode">&ne;</span> <i class="emphasis">i</i>, no <i class="emphasis">v<sub>l</sub></i> or <span class="inlinemediaobject"><img src="images/fig1036_05.jpg" height="13" width="8" alt="" border="0"></span> values can equal <i class="emphasis">v<sub>i</sub></i> and <span class="inlinemediaobject"><img src="images/fig1036_06.jpg" height="12" width="8" alt="" border="0"></span> in the most significant <i class="emphasis">n</i> digits. Furthermore, by our simplifying assumptions above, no <i class="emphasis">v<sub>i</sub></i> and <span class="inlinemediaobject"><img src="images/fig1036_07.jpg" height="12" width="8" alt="" border="0"></span> can be equal in all <i class="emphasis">k</i> least significant digits. If <i class="emphasis">v<sub>i</sub></i> and <span class="inlinemediaobject"><img src="images/fig1036_08.jpg" height="12" width="8" alt="" border="0"></span> were equal, then <i class="emphasis">x<sub>i</sub></i> and <span class="unicode">&not;</span><i class="emphasis">x<sub>i</sub></i> would have to appear in exactly the same set of clauses. But we assume that no clause contains both <i class="emphasis">x<sub>i</sub></i> and <span class="unicode">&not;</span><i class="emphasis">x<sub>i</sub></i> <a name="3144"></a><a name="IDX-1015"></a>and that either <i class="emphasis">x<sub>i</sub></i> or <span class="unicode">&not;</span><i class="emphasis">x<sub>i</sub></i> appears in some clause, and so there must be some clause <i class="emphasis">C<sub>j</sub></i> for which <i class="emphasis">v<sub>i</sub></i> and <span class="inlinemediaobject"><img src="images/fig1037_06.jpg" height="18" width="13" alt="" border="0"></span> differ.</p>
</li>
<li class="listitem">
<p class="first-para">For each clause <i class="emphasis">C<sub>j</sub></i>, there are two integers, <i class="emphasis">s<sub>j</sub></i> and <span class="inlinemediaobject"><img src="images/fig1037_07.jpg" height="19" width="12" alt="" border="0"></span> in <i class="emphasis">S</i>. Each has 0's in all digits other than the one labeled by <i class="emphasis">C<sub>j</sub></i>. For <i class="emphasis">s<sub>j</sub></i>, there is a 1 in the <i class="emphasis">C<sub>j</sub></i> digit, and <span class="inlinemediaobject"><img src="images/fig1037_08.jpg" height="19" width="12" alt="" border="0"></span> has a 2 in this digit. These integers are "slack variables," which we use to get each clause-labeled digit position to add to the target value of 4.</p>
<p class="para">Simple inspection of <a class="internaljump" href="#ch34fig19">Figure 34.19</a> demonstrates that all <i class="emphasis">s<sub>j</sub></i> and <span class="inlinemediaobject"><img src="images/fig1037_09.jpg" height="19" width="12" alt="" border="0"></span> values in <i class="emphasis">S</i> are unique in set <i class="emphasis">S</i>.</p>
<p class="last-para">
<p class="figure">
<a name="3145"></a><a name="ch34fig19"></a><span class="figuremediaobject"><a href="images/fig1037%5F05%5F0%2Ejpg" NAME="IMG_1887" target="_parent"><img src="images/fig1037_05.jpg" height="268" width="214" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 34.19: </span>The reduction of 3-CNF-SAT to SUBSET-SUM. The formula in 3-CNF is <i class="emphasis"><span class="unicode">&phi;</span></i> = <i class="emphasis">C</i><sub>1</sub> <span class="unicode">&and;</span> <i class="emphasis">C</i><sub>2</sub> <span class="unicode">&and;</span> <i class="emphasis">C</i><sub>3</sub> <span class="unicode">&and;</span> <i class="emphasis">C</i><sub>4</sub>, where <i class="emphasis">C</i><sub>1</sub> = (<i class="emphasis">x</i><sub>1</sub> <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub> <span class="unicode">&or;</span><span class="unicode">&not;</span><i class="emphasis">x</i><sub>3</sub>), <i class="emphasis">C</i><sub>2</sub> = (<span class="unicode">&not;</span><i class="emphasis">x</i><sub>1</sub> <span class="unicode">&or;</span><span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub> <span class="unicode">&or;</span><span class="unicode">&not;</span><i class="emphasis">x</i><sub>3</sub>), <i class="emphasis">C</i><sub>3</sub> = (<span class="unicode">&not;</span><i class="emphasis">x</i><sub>1</sub> <span class="unicode">&or;</span><span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub> <span class="unicode">&or;</span><i class="emphasis">x</i><sub>3</sub>), and <i class="emphasis">C</i><sub>4</sub> = (<i class="emphasis">x</i><sub>1</sub> <i class="emphasis">x</i><sub>2</sub> <i class="emphasis">x</i><sub>3</sub>). A satisfying assignment of <i class="emphasis"><span class="unicode">&phi;</span></i> is <span class="unicode">&#12296;</span><i class="emphasis">x</i><sub>1</sub> = 0, <i class="emphasis">x</i><sub>2</sub> = 0, <i class="emphasis">x</i><sub>3</sub> = 1<span class="unicode">&#12297;</span>. The set S produced by the reduction consists of the base-10 numbers shown; reading from top to bottom, S = {1001001, 1000110, 100001, 101110, 10011, 11100, 1000, 2000, 100, 200, 10, 20, 1, 2}. The target t is 1114444. The subset <i class="emphasis">S</i>' <span class="unicode">&sube;</span> <i class="emphasis">S</i> is lightly shaded, and it contains <span class="inlinemediaobject"><img src="images/fig1037_01.jpg" height="18" width="30" alt="" border="0"></span>, and <span class="inlinemediaobject"><img src="images/fig1037_02.jpg" height="11" width="12" alt="" border="0"></span>, corresponding to the satisfying assignment. It also contains slack variables <span class="inlinemediaobject"><img src="images/fig1037_03.jpg" height="14" width="70" alt="" border="0"></span>, and <span class="inlinemediaobject"><img src="images/fig1037_04.jpg" height="18" width="12" alt="" border="0"></span> to achieve the target value of 4 in the digits labeled by <i class="emphasis">C</i><sub>1</sub> through <i class="emphasis">C</i><sub>4</sub>.</span>
</p>
</p>
</li>
</ul>
<p class="para">Note that the greatest sum of digits in any one digit position is 6, which occurs in the digits labeled by clauses (three 1's from the <i class="emphasis">v<sub>i</sub></i> and <span class="inlinemediaobject"><img src="images/fig1037_10.jpg" height="18" width="13" alt="" border="0"></span> values, plus 1 and 2 <a name="3146"></a><a name="IDX-1016"></a>from the <i class="emphasis">s<sub>j</sub></i> and <span class="inlinemediaobject"><img src="images/fig1038_01.jpg" height="14" width="10" alt="" border="0"></span> values). Interpreting these numbers in base 10, therefore, no carries can occur from lower digits to higher digits.<sup>[<a name="N4487" href="#ftn.N4487">9</a>]</sup>
</p>
<p class="para">The reduction can be performed in polynomial time. The set <i class="emphasis">S</i> contains 2<i class="emphasis">n</i> + 2<i class="emphasis">k</i> values, each of which has <i class="emphasis">n</i> + <i class="emphasis">k</i> digits, and the time to produce each digit is poly-nomial in <i class="emphasis">n</i> + <i class="emphasis">k</i>. The target <i class="emphasis">t</i> has <i class="emphasis">n</i> + <i class="emphasis">k</i> digits, and the reduction produces each in constant time.</p>
<p class="para">We now show that the 3-CNF formula <i class="emphasis"><span class="unicode">&phi;</span></i> is satisfiable if and only if there is a subset <i class="emphasis">S</i> <span class="unicode">&sube;</span> <i class="emphasis">S</i> whose sum is <i class="emphasis">t</i>. First, suppose that <i class="emphasis"><span class="unicode">&phi;</span></i> has a satisfying assignment. For <i class="emphasis">i</i> = 1, 2,..., <i class="emphasis">n</i>, if <i class="emphasis">x<sub>i</sub></i> = 1 in this assignment, then include <i class="emphasis">v<sub>i</sub></i> in <i class="emphasis">S</i>'. Otherwise, include <span class="inlinemediaobject"><img src="images/fig1038_02.jpg" height="13" width="9" alt="" border="0"></span>. In other words, we include in <i class="emphasis">S</i>' exactly the <i class="emphasis">v<sub>i</sub></i> and <span class="inlinemediaobject"><img src="images/fig1038_03.jpg" height="14" width="9" alt="" border="0"></span> values that correspond to literals with the value 1 in the satisfying assignment. Having included either <i class="emphasis">v<sub>i</sub></i> or <span class="inlinemediaobject"><img src="images/fig1038_04.jpg" height="14" width="9" alt="" border="0"></span>, but not both, for all <i class="emphasis">i</i>, and having put 0 in the digits labeled by variables in all <i class="emphasis">s<sub>j</sub></i> and <span class="inlinemediaobject"><img src="images/fig1038_05.jpg" height="14" width="10" alt="" border="0"></span>, we see that for each variable-labeled digit, the sum of the values of <i class="emphasis">S</i>' must be 1, which matches those digits of the target <i class="emphasis">t</i>. Because each clause is satisfied, there is some literal in the clause with the value 1. Therefore, each digit labeled by a clause has at least one 1 contributed to its sum by a <i class="emphasis">v<sub>i</sub></i> or <span class="inlinemediaobject"><img src="images/fig1038_06.jpg" height="14" width="10" alt="" border="0"></span> value in <i class="emphasis">S</i>'. In fact, 1, 2, or 3 literals may be 1 in each clause, and so each clause-labeled digit has a sum of 1, 2, or 3 from the <i class="emphasis">v<sub>i</sub></i> and <span class="inlinemediaobject"><img src="images/fig1038_07.jpg" height="13" width="8" alt="" border="0"></span> values in <i class="emphasis">S</i>'. (In <a class="internaljump" href="#ch34fig19">Figure 34.19</a> for example, literals <span class="unicode">&not;</span><i class="emphasis">x</i><sub>1</sub>, <span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub>, and <i class="emphasis">x</i><sub>3</sub> have the value 1 in a satisfying assignment. Each of clauses <i class="emphasis">C</i><sub>1</sub> and <i class="emphasis">C</i><sub>4</sub> contain exactly one of these literals, and so together <span class="inlinemediaobject"><img src="images/fig1038_08.jpg" height="18" width="30" alt="" border="0"></span>, and <i class="emphasis">v</i><sub>3</sub> contribute 1 to the sum in the digits for <i class="emphasis">C</i><sub>1</sub> and <i class="emphasis">C</i><sub>4</sub>. Clause <i class="emphasis">C</i><sub>2</sub> contains two of these literals, and <span class="inlinemediaobject"><img src="images/fig1038_09.jpg" height="18" width="30" alt="" border="0"></span>, and <i class="emphasis">v</i><sub>3</sub> contribute 2 to the sum in the digit for <i class="emphasis">C</i><sub>2</sub>. Clause <i class="emphasis">C</i><sub>3</sub> contains all three of these literals, and <span class="inlinemediaobject"><img src="images/fig1038_10.jpg" height="18" width="30" alt="" border="0"></span>, and <i class="emphasis">v</i><sub>3</sub> contribute 3 to the sum in the digit for <i class="emphasis">C</i><sub>3</sub>.) We achieve the target of 4 in each digit labeled by clause <i class="emphasis">C<sub>j</sub></i> by including in <i class="emphasis">S</i>' the appropriate nonempty subset of slack variables {<i class="emphasis">s<sub>j</sub></i> , <span class="inlinemediaobject"><img src="images/fig1038_11.jpg" height="19" width="12" alt="" border="0"></span>}. (In <a class="internaljump" href="#ch34fig19">Figure 34.19</a>, <i class="emphasis">S</i>' includes <span class="inlinemediaobject"><img src="images/fig1038_12.jpg" height="14" width="70" alt="" border="0"></span> and <span class="inlinemediaobject"><img src="images/fig1038_13.jpg" height="13" width="8" alt="" border="0"></span>.) Since we have matched the target in all digits of the sum, and no carries can occur, the values of <i class="emphasis">S</i>' sum to <i class="emphasis">t</i>.x</p>
<p class="last-para">Now, suppose that there is a subset <i class="emphasis">S</i>' <span class="unicode">&sube;</span> <i class="emphasis">S</i> that sums to <i class="emphasis">t</i>. The subset <i class="emphasis">S</i>' must include exactly one of <i class="emphasis">v<sub>i</sub></i> and <span class="inlinemediaobject"><img src="images/fig1038_14.jpg" height="13" width="10" alt="" border="0"></span> for each <i class="emphasis">i</i> = 1, 2,..., <i class="emphasis">n</i>, for otherwise the digits labeled by variables would not sum to 1. If <i class="emphasis">v<sub>i</sub></i> <span class="unicode">&isin;</span> <i class="emphasis">S</i>', we set <i class="emphasis">x<sub>i</sub></i> = 1. Otherwise, <span class="inlinemediaobject"><img src="images/fig1038_15.jpg" height="13" width="32" alt="" border="0"></span> <span class="unicode">&isin;</span> <i class="emphasis">S</i>', and we set <i class="emphasis">x<sub>i</sub></i> = 0. We claim that every clause <i class="emphasis">C<sub>j</sub></i>, for <i class="emphasis">j</i> = 1, 2,..., <i class="emphasis">k</i>, is satisfied by this assignment. To prove this claim, note that to achieve a sum of 4 in the digit labeled by <i class="emphasis">C<sub>j</sub></i>, the subset <i class="emphasis">S</i>' must include at least one <i class="emphasis">v<sub>i</sub></i> or <span class="inlinemediaobject"><img src="images/fig1038_16.jpg" height="13" width="10" alt="" border="0"></span> value that has a 1 in the digit labeled by <i class="emphasis">C<sub>j</sub></i>, since the contributions of the slack variables <i class="emphasis">s<sub>j</sub></i> and <span class="inlinemediaobject"><img src="images/fig1038_17.jpg" height="14" width="10" alt="" border="0"></span> together sum to at most 3. If <i class="emphasis">S</i>' includes a <i class="emphasis">v<sub>i</sub></i> that has a 1 in that position, then the literal <i class="emphasis">x<sub>i</sub></i> appears in clause <i class="emphasis">C<sub>j</sub></i>. Since we have set <i class="emphasis">x<sub>i</sub></i> = 1 when <i class="emphasis">v<sub>i</sub></i> <span class="unicode">&isin;</span> <i class="emphasis">S</i>', clause <i class="emphasis">C<sub>j</sub></i> is <a name="3147"></a><a name="IDX-1017"></a>satisfied. If <i class="emphasis">S</i>' includes a <span class="inlinemediaobject"><img src="images/fig1039_01.jpg" height="13" width="8" alt="" border="0"></span> that has a 1 in that position, then the literal <span class="unicode">&not;</span><i class="emphasis">x<sub>i</sub></i> appears in <i class="emphasis">C<sub>j</sub></i>. Since we have set <i class="emphasis">x<sub>i</sub></i> = 0 when <span class="inlinemediaobject"><img src="images/fig1039_02.jpg" height="12" width="32" alt="" border="0"></span> <span class="unicode">&isin;</span> <i class="emphasis">S</i>', clause <i class="emphasis">C<sub>j</sub></i> is again satisfied. Thus, all clauses of <i class="emphasis"><span class="unicode">&phi;</span></i> are satisfied, which completes the proof.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.5-1</span></span><a name="3148"></a><a name="ch34ex48"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The <b class="bold"><i class="emphasis">subgraph-isomorphism problem</i></b> takes two graphs <i class="emphasis">G</i><sub>1</sub> and <i class="emphasis">G</i><sub>2</sub> and asks whether <i class="emphasis">G</i><sub>1</sub> is isomorphic to a subgraph of <i class="emphasis">G</i><sub>2</sub>. Show that the subgraph-isomorphism problem is NP-complete.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.5-2</span></span><a name="3149"></a><a name="ch34ex49"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Given an integer <i class="emphasis">m</i>-by-<i class="emphasis">n</i> matrix <i class="emphasis">A</i> and an integer <i class="emphasis">m</i>-vector <i class="emphasis">b</i>, the <b class="bold"><i class="emphasis">0-1 integer-programming problem</i></b> asks whether there is an integer <i class="emphasis">n</i>-vector <i class="emphasis">x</i> with elements in the set {0, 1} such that <i class="emphasis">Ax</i> <span class="unicode">&le;</span> <i class="emphasis">b</i>. Prove that 0-1 integer programming is NP-complete. (<i class="emphasis">Hint:</i> Reduce from 3-CNF-SAT.)</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.5-3</span></span><a name="3150"></a><a name="ch34ex50"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The <b class="bold"><i class="emphasis">integer linear-programming problem</i></b> is like the 0-1 integer-programming problem given in <a class="internaljump" href="#ch34ex49">Exercise 34.5-2</a>, except that the values of the vector <i class="emphasis">x</i> may be any integers rather than just 0 or 1. Assuming that the 0-1 integer-programming problem is NP-hard, show that the integer linear-programming problem is NP-complete.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.5-4</span></span><a name="3151"></a><a name="ch34ex51"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that the subset-sum problem is solvable in polynomial time if the target value <i class="emphasis">t</i> is expressed in unary.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.5-5</span></span><a name="3152"></a><a name="ch34ex52"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The <b class="bold"><i class="emphasis">set-partition problem</i></b> takes as input a set <i class="emphasis">S</i> of numbers. The question is whether the numbers can be partitioned into two sets <i class="emphasis">A</i> and <i class="emphasis"><span class="unicode">&#256;</span></i> = <i class="emphasis">S</i> - <i class="emphasis">A</i> such that <span class="unicode">&Sigma;</span><sub><i class="emphasis">x<span class="unicode">&isin;</span>&#256;</i></sub><i class="emphasis">x</i>. Show that the set-partition problem is NP-complete.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.5-6</span></span><a name="3153"></a><a name="ch34ex53"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Show that the hamiltonian-path problem is NP-complete.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.5-7</span></span><a name="3154"></a><a name="ch34ex54"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">The <b class="bold"><i class="emphasis">longest-simple-cycle problem</i></b> is the problem of determining a simple cycle (no repeated vertices) of maximum length in a graph. Show that this problem is NP-complete.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="3155"></a><a name="IDX-1018"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 34.5-8</span></span><a name="3156"></a><a name="ch34ex55"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">In the <b class="bold"><i class="emphasis">half 3-CNF satisfiability</i></b> problem, we are given a 3-CNF formula <i class="emphasis"><span class="unicode">&phi;</span></i> with <i class="emphasis">n</i> variables and <i class="emphasis">m</i> clauses, where <i class="emphasis">m</i> is even. We wish to determine whether there exists a truth assignment to the variables of <i class="emphasis"><span class="unicode">&phi;</span></i> such that exactly half the clauses evaluate to 0 and exactly half the clauses evaluate to 1. Prove that the half 3-CNF satisfiability problem is NP-complete.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 34-1: </span>Independent set</span><a name="3157"></a><a name="ch34ex56"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">An <b class="bold"><i class="emphasis">independent set</i></b> of a graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) is a subset <i class="emphasis">V</i>' <span class="unicode">&supe;</span> <i class="emphasis">V</i> of vertices such that each edge in <i class="emphasis">E</i> is incident on at most one vertex in <i class="emphasis">V</i>'. The <b class="bold"><i class="emphasis">independent-set problem</i></b> is to find a maximum-size independent set in <i class="emphasis">G</i>.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Formulate a related decision problem for the independent-set problem, and prove that it is NP-complete. (<i class="emphasis">Hint:</i> Reduce from the clique problem.)</p>
</li>
<li class="listitem">
<p class="first-para">Suppose that you are given a "black-box" subroutine to solve the decision problem you defined in part (a). Give an algorithm to find an independent set of maximum size. The running time of your algorithm should be polynomial in |<i class="emphasis">V</i>| and |<i class="emphasis">E</i>|, where queries to the black box are counted as a single step.</p>
</li>
</ol>
<p class="para">Although the independent-set decision problem is NP-complete, certain special cases are polynomial-time solvable.</p>
<ol class="orderedlist" start="3" type="a">
<li class="first-listitem">
<p class="first-para">Give an efficient algorithm to solve the independent-set problem when each vertex in <i class="emphasis">G</i> has degree 2. Analyze the running time, and prove that your algorithm works correctly.</p>
</li>
<li class="listitem">
<p class="first-para">Give an efficient algorithm to solve the independent-set problem when <i class="emphasis">G</i> is bipartite. Analyze the running time, and prove that your algorithm works correctly. (<i class="emphasis">Hint:</i> Use the results of <a href="DDU0163.html#2035" target="_parent" class="chapterjump">Section 26.3.</a>)</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 34-2: </span>Bonnie and Clyde</span><a name="3158"></a><a name="ch34ex57"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Bonnie and Clyde have just robbed a bank. They have a bag of money and want to divide it up. For each of the following scenarios, either give a polynomial-time algorithm, or prove that the problem is NP-complete. The input in each case is a list of the <i class="emphasis">n</i> items in the bag, along with the value of each.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">There are <i class="emphasis">n</i> coins, but only 2 different denominations: some coins are worth <i class="emphasis">x</i> dollars, and some are worth <i class="emphasis">y</i> dollars. They wish to divide the money exactly evenly.</p>
<a name="3159"></a><a name="IDX-1019"></a>
</li>
<li class="listitem">
<p class="first-para">There are <i class="emphasis">n</i> coins, with an arbitrary number of different denominations, but each denomination is a nonnegative integer power of 2, i.e., the possible denominations are 1 dollar, 2 dollars, 4 dollars, etc. They wish to divide the money exactly evenly.</p>
</li>
<li class="listitem">
<p class="first-para">There are <i class="emphasis">n</i> checks, which are, in an amazing coincidence, made out to "Bonnie or Clyde." They wish to divide the checks so that they each get the exact same amount of money.</p>
</li>
<li class="listitem">
<p class="first-para">There are <i class="emphasis">n</i> checks as in part (c), but this time they are willing to accept a split in which the difference is no larger than 100 dollars.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 34-3: </span>Graph coloring</span><a name="3160"></a><a name="ch34ex58"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">A <b class="bold"><i class="emphasis">k-coloring</i></b> of an undirected graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) is a function <i class="emphasis">c</i> : <i class="emphasis">V</i> <span class="unicode">&rarr;</span> {1, 2,..., <i class="emphasis">k</i>} such that <i class="emphasis">c</i>(<i class="emphasis">u</i>) <span class="unicode">&ne;</span> <i class="emphasis">c</i>(<i class="emphasis">v</i>) for every edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) <span class="unicode">&isin;</span> <i class="emphasis">E</i>. In other words, the numbers 1, 2,..., <i class="emphasis">k</i> represent the <i class="emphasis">k</i> colors, and adjacent vertices must have different colors. The <b class="bold"><i class="emphasis">graph-coloring problem</i></b> is to determine the minimum number of colors needed to color a given graph.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Give an efficient algorithm to determine a 2-coloring of a graph if one exists.</p>
</li>
<li class="listitem">
<p class="first-para">Cast the graph-coloring problem as a decision problem. Show that your decision problem is solvable in polynomial time if and only if the graph-coloring problem is solvable in polynomial time.</p>
</li>
<li class="listitem">
<p class="first-para">Let the language 3-COLOR be the set of graphs that can be 3-colored. Show that if 3-COLOR is NP-complete, then your decision problem from part (b) is NP-complete.</p>
</li>
</ol>
<p class="para">To prove that 3-COLOR is NP-complete, we use a reduction from 3-CNF-SAT. Given a formula <i class="emphasis"><span class="unicode">&phi;</span></i> of <i class="emphasis">m</i> clauses on <i class="emphasis">n</i> variables <i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>,..., <i class="emphasis">x<sub>n</sub></i>, we construct a graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) as follows. The set <i class="emphasis">V</i> consists of a vertex for each variable, a vertex for the negation of each variable, 5 vertices for each clause, and 3 special vertices: TRUE, FALSE, and RED. The edges of the graph are of two types: "literal" edges that are independent of the clauses and "clause" edges that depend on the clauses. The literal edges form a triangle on the special vertices and also form a triangle on <i class="emphasis">x<sub>i</sub></i>, <span class="unicode">&not;</span><i class="emphasis">x<sub>i</sub></i>, and RED for <i class="emphasis">i</i> = 1, 2,..., <i class="emphasis">n</i>.<a name="3161"></a><a name="IDX-1020"></a>
</p>
<ol class="orderedlist" start="4" type="a">
<li class="first-listitem">
<p class="first-para">Argue that in any 3-coloring <i class="emphasis">c</i> of a graph containing the literal edges, exactly one of a variable and its negation is colored <i class="emphasis">c</i>(TRUE) and the other is colored <i class="emphasis">c</i>(FALSE). Argue that for any truth assignment for <i class="emphasis"><span class="unicode">&phi;</span></i>, there is a 3-coloring of the graph containing just the literal edges.</p>
</li>
</ol>
<p class="para">The widget shown in <a class="internaljump" href="#ch34fig20">Figure 34.20</a> is used to enforce the condition corresponding to a clause (<i class="emphasis">x</i> <span class="unicode">&or;</span> <i class="emphasis">y</i> <span class="unicode">&or;</span> <i class="emphasis">z</i>). Each clause requires a unique copy of the 5 vertices that are heavily shaded in the figure; they connect as shown to the literals of the clause and the special vertex TRUE.</p>
<ol class="orderedlist" start="5" type="a">
<li class="first-listitem">
<p class="first-para">Argue that if each of <i class="emphasis">x</i>, <i class="emphasis">y</i>, and <i class="emphasis">z</i> is colored <i class="emphasis">c</i>(TRUE) or <i class="emphasis">c</i>(FALSE), then the widget is 3-colorable if and only if at least one of <i class="emphasis">x</i>, <i class="emphasis">y</i>, or <i class="emphasis">z</i> is colored <i class="emphasis">c</i>(TRUE).</p>
</li>
<li class="listitem">
<p class="first-para">Complete the proof that 3-COLOR is NP-complete.</p>
</li>
</ol>
<p class="last-para">
<div class="figure">
<a name="3162"></a><a name="ch34fig20"></a><span class="figuremediaobject"><a href="images/fig1042%5F01%5F0%2Ejpg" NAME="IMG_1908" target="_parent"><img src="images/fig1042_01.jpg" height="115" width="237" alt="Click To expand" border="0"></a></span>
<br style="line-height: 1">
<span class="figure-title"><span class="figure-titlelabel">Figure 34.20: </span>The widget corresponding to a clause (<i class="emphasis">x</i> <span class="unicode">&or;</span> <i class="emphasis">y</i> <span class="unicode">&or;</span> <i class="emphasis">z</i>), used in Problem 34-3.</span>
</div>
</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 34-4: </span>Scheduling with profits and deadlines</span><a name="3163"></a><a name="ch34ex59"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose you have one machine and a set of <i class="emphasis">n</i> tasks <i class="emphasis">a</i><sub>1</sub>, <i class="emphasis">a</i><sub>2</sub>,..., <i class="emphasis">a<sub>n</sub></i>. Each task <i class="emphasis">a<sub>j</sub></i> has a processing time <i class="emphasis">t<sub>j</sub></i>, a profit <i class="emphasis">p<sub>j</sub></i>, and a deadline <i class="emphasis">d<sub>j</sub></i>. The machine can process only one task at a time, and task <i class="emphasis">a<sub>j</sub></i> must run uninterruptedly for <i class="emphasis">t<sub>j</sub></i> consecutive time units. If you complete task <i class="emphasis">a<sub>j</sub></i> by its deadline <i class="emphasis">d<sub>j</sub></i>, you receive a profit <i class="emphasis">p<sub>j</sub></i>, but if you complete it after its deadline, you receive no profit. As an optimization problem, you are given the processing times, profits, and deadlines for a set of <i class="emphasis">n</i> tasks, and you wish to find a schedule that completes all the tasks and returns the greatest amount of profit.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">State this problem as a decision problem.</p>
</li>
<li class="listitem">
<p class="first-para">Show that the decision problem is NP-complete.</p>
</li>
<li class="listitem">
<p class="first-para">Give a polynomial-time algorithm for the decision problem, assuming that all processing times are integers from 1 to <i class="emphasis">n</i>. (<i class="emphasis">Hint:</i> Use dynamic programming.)</p>
<a name="3164"></a><a name="IDX-1021"></a>
</li>
<li class="listitem">
<p class="first-para">Give a polyomial-time algorithm for the optimization problem, assuming that all processing times are integers from 1 to <i class="emphasis">n</i>.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
<div class="footnotes">
<div class="footnote">
<p>
<sup>[<a name="ftn.N2884" href="#N2884">8</a>]</sup>Technically, we define a cycle in terms of vertices rather than edges (see <a href="DDU0250.html#3364" target="_parent" class="chapterjump">Section B.4</a>). In the interest of clarity, we abuse notation here and define the hamiltonian cycle in terms of edges.</p>
</div>
<div class="footnote">
<p>
<sup>[<a name="ftn.N4487" href="#N4487">9</a>]</sup>In fact, any base <i class="emphasis">b</i>, where <i class="emphasis">b</i> <span class="unicode">&ge;</span> 7, would work. The instance at the beginning of this subsection is the set <i class="emphasis">S</i> and target <i class="emphasis">t</i> in <a class="internaljump" href="#ch34fig19">Figure 34.19</a> interpreted in base 7, with <i class="emphasis">S</i> listed in sorted order.</p>
</div>
</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0231.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0233.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
