<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>35.5 The subset-sum problem</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0239.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0241.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="chapter">
<a name="ch35"></a>
<div class="section">
<h2 class="first-section-title">
<a name="3241"></a><a name="ch35lev1sec5"></a><span class="section-titlelabel">35.5 </span>The subset-sum problem</h2>
<p class="first-para">An instance of the subset-sum problem is a pair (<i class="emphasis">S</i>, <i class="emphasis">t</i>), where <i class="emphasis">S</i> is a set {<i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, ..., <i class="emphasis">x<sub>n</sub></i>} of positive integers and <i class="emphasis">t</i> is a positive integer. This decision problem asks whether there exists a subset of <i class="emphasis">S</i> that adds up exactly to the target value <i class="emphasis">t</i>. This problem is NP-complete (see <a href="DDU0232.html#3142" target="_parent" class="chapterjump">Section 34.5.5</a>).<a name="3242"></a><a name="IDX-1044"></a>
</p>
<p class="para">The optimization problem associated with this decision problem arises in practical applications. In the optimization problem, we wish to find a subset of {<i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, ..., <i class="emphasis">x<sub>n</sub></i>} whose sum is as large as possible but not larger than <i class="emphasis">t</i>. For example, we may have a truck that can carry no more than <i class="emphasis">t</i> pounds, and <i class="emphasis">n</i> different boxes to ship, the <i class="emphasis">i</i>th of which weighs <i class="emphasis">x<sub>i</sub></i> pounds. We wish to fill the truck with as heavy a load as possible without exceeding the given weight limit.</p>
<p class="para">In this section, we present an exponential-time algorithm for this optimization problem and then show how to modify the algorithm so that it becomes a fully polynomial-time approximation scheme. (Recall that a fully polynomial-time approximation scheme has a running time that is polynomial in 1/<span class="unicode">&isin;</span> as well as in the size of the input.)</p>
<div class="section">
<h4 class="sect4-title">
<a name="3243"></a><a name="ch35lev3sec7"></a>An exponential-time exact algorithm</h4>
<p class="first-para">Suppose that we computed, for each subset <i class="emphasis">S</i><span class="unicode">&prime;</span> of <i class="emphasis">S</i>, the sum of the elements in <i class="emphasis">S</i><span class="unicode">&prime;</span>, and then we selected, among the subsets whose sum does not exceed <i class="emphasis">t</i>, the one whose sum was closest to <i class="emphasis">t</i>. Clearly this algorithm would return the optimal solution, but it could take exponential time. To implement this algorithm, we could use an iterative procedure that, in iteration <i class="emphasis">i</i>, computes the sums of all subsets of {<i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, ..., <i class="emphasis">x<sub>i</sub></i>}, using as a starting point the sums of all subsets of {<i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, ..., <i class="emphasis">x</i><sub><i class="emphasis">i</i>-1</sub>}. In doing so, we would realize that once a particular subset <i class="emphasis">S</i><span class="unicode">&prime;</span> had a sum exceeding <i class="emphasis">t</i>, there would be no reason to maintain it, since no superset of <i class="emphasis">S</i><span class="unicode">&prime;</span> could be the optimal solution. We now give an implementation of this strategy.</p>
<p class="para">The procedure EXACT-SUBSET-SUM takes an input set <i class="emphasis">S</i> = {<i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, ..., <i class="emphasis">x<sub>n</sub></i>} and a target value <i class="emphasis">t</i>; we'll see its pseudocode in a moment. This procedure iteratively computes <i class="emphasis">L<sub>i</sub></i>, the list of sums of all subsets of {<i class="emphasis">x</i><sub>1</sub>, ..., <i class="emphasis">x<sub>i</sub></i>} that do not exceed <i class="emphasis">t</i>, and then it returns the maximum value in <i class="emphasis">L<sub>n</sub></i>.</p>
<p class="para">If <i class="emphasis">L</i> is a list of positive integers and <i class="emphasis">x</i> is another positive integer, then we let <i class="emphasis">L</i> + <i class="emphasis">x</i> denote the list of integers derived from <i class="emphasis">L</i> by increasing each element of <i class="emphasis">L</i> by <i class="emphasis">x</i>. For example, if <i class="emphasis">L</i> = <span class="unicode">&#12296;</span>1, 2, 3, 5, 9<span class="unicode">&#12297;</span>, then <i class="emphasis">L</i> + 2 = <span class="unicode">&#12296;</span>3, 4, 5, 7, 11<span class="unicode">&#12297;</span>. We also use this notation for sets, so that</p>
<p class="para">
<i class="emphasis">S</i> + <i class="emphasis">x</i> = {<i class="emphasis">s</i> + <i class="emphasis">x</i> : <i class="emphasis">s</i> <span class="unicode">&isin;</span> <i class="emphasis">S</i>}.</p>
<p class="para">We also use an auxiliary procedure MERGE-LISTS(<i class="emphasis">L</i>, <i class="emphasis">L</i><span class="unicode">&prime;</span>) that returns the sorted list that is the merge of its two sorted input lists <i class="emphasis">L</i> and <i class="emphasis">L</i><span class="unicode">&prime;</span> with duplicate values removed. Like the MERGE procedure we used in merge sort (<a href="DDU0016.html#90" target="_parent" class="chapterjump">Section 2.3.1</a>), MERGE-LISTS runs in time <i class="emphasis">O</i>(|<i class="emphasis">L</i>| + |<i class="emphasis">L</i><span class="unicode">&prime;</span>|). (We omit giving pseudocode for MERGE-LISTS.)<a name="3244"></a><a name="IDX-1045"></a>
</p>
<div class="informalexample">
<pre class="literallayout-normal">
EXACT-SUBSET-SUM(<i class="emphasis">S</i>, <i class="emphasis">t</i>)
1  <i class="emphasis">n</i> <span class="unicode">&larr;</span> |<i class="emphasis">S</i>|
2  <i class="emphasis">L</i><sub>0</sub> <span class="unicode">&larr;</span> <span class="unicode">&#12296;</span>0<span class="unicode">&#12297;</span>
3  <b class="bold">for</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">n</i>
4      <b class="bold">do</b> <i class="emphasis">L</i><sub><i class="emphasis">i</i></sub> <span class="unicode">&larr;</span> MERGE-LISTS(<i class="emphasis">L</i><sub><i class="emphasis">i</i>-1</sub>, <i class="emphasis">L</i><sub><i class="emphasis">i</i>-1</sub> + <i class="emphasis">x</i><sub><i class="emphasis">i</i></sub>)
5         remove from <i class="emphasis">L<sub>i</sub></i> every element that is greater than <i class="emphasis">t</i>
6  <b class="bold">return</b> the largest element in <i class="emphasis">L<sub>n</sub></i>
</pre>
</div>
<p class="para">To see how EXACT-SUBSET-SUM works, let <i class="emphasis">P<sub>i</sub></i> denote the set of all values that can be obtained by selecting a (possibly empty) subset of {<i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, ..., <i class="emphasis">x<sub>i</sub></i>} and summing its members. For example, if <i class="emphasis">S</i> = {1, 4, 5}, then</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">P</i><sub>1</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">{0, 1} ,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">P</i><sub>2</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">{0, 1, 4, 5} ,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">
<i class="emphasis">P</i><sub>3</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">{0, 1, 4, 5, 6, 9, 10} .</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">Given the identity</p>
<div class="equation">
<a name="3245"></a><a name="ch35eq21"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(35.21)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig1067_01.jpg" height="15" width="150" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="last-para">we can prove by induction on <i class="emphasis">i</i> (see <a class="internaljump" href="#ch35ex28">Exercise 35.5-1</a>) that the list <i class="emphasis">L<sub>i</sub></i> is a sorted list containing every element of <i class="emphasis">P<sub>i</sub></i> whose value is not more than <i class="emphasis">t</i>. Since the length of <i class="emphasis">L<sub>i</sub></i> can be as much as 2<sup><i class="emphasis">i</i></sup>, EXACT-SUBSET-SUM is an exponential-time algorithm in general, although it is a polynomial-time algorithm in the special cases in which <i class="emphasis">t</i> is polynomial in |<i class="emphasis">S</i>| or all the numbers in <i class="emphasis">S</i> are bounded by a polynomial in |<i class="emphasis">S</i>|.</p>

</div>
<div class="section">
<h4 class="sect4-title">
<a name="3246"></a><a name="ch35lev3sec8"></a>A fully polynomial-time approximation scheme</h4>
<p class="first-para">We can derive a fully polynomial-time approximation scheme for the subset-sum problem by "trimming" each list <i class="emphasis">L<sub>i</sub></i> after it is created. The idea is that if two values in <i class="emphasis">L</i> are close to each other, then for the purpose of finding an approximate solution there is no reason to maintain both of them explicitly. More precisely, we use a trimming parameter <i class="emphasis"><span class="unicode">&delta;</span></i> such that 0 <span class="unicode">&lt;</span> <i class="emphasis"><span class="unicode">&delta;</span></i> <span class="unicode">&lt;</span> 1. To <b class="bold"><i class="emphasis">trim</i></b> a list <i class="emphasis">L</i> by <i class="emphasis"><span class="unicode">&delta;</span></i> means to remove as many elements from <i class="emphasis">L</i> as possible, in such a way that if <i class="emphasis">L</i><span class="unicode">&prime;</span> is the result of trimming <i class="emphasis">L</i>, then for every element <i class="emphasis">y</i> that was removed from <i class="emphasis">L</i>, there is an element <i class="emphasis">z</i> still in <i class="emphasis">L</i><span class="unicode">&prime;</span> that approximates <i class="emphasis">y</i>, that is,</p>
<div class="equation">
<a name="3247"></a><a name="ch35eq22"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(35.22)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig1067_02.jpg" height="30" width="95" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">We can think of such a <i class="emphasis">z</i> as "representing" <i class="emphasis">y</i> in the new list <i class="emphasis">L</i><span class="unicode">&prime;</span>. Each <i class="emphasis">y</i> is represented by a <i class="emphasis">z</i> satisfying inequality (<a class="internaljump" href="#ch35eq22">35.22</a>). For example, if <i class="emphasis"><span class="unicode">&delta;</span></i> = 0.1 and</p>
<a name="3248"></a><a name="IDX-1046"></a>
<p class="para">
<i class="emphasis">L</i> = <span class="unicode">&#12296;</span>10, 11, 12, 15, 20, 21, 22, 23, 24, 29<span class="unicode">&#12297;</span>,</p>
<p class="para">then we can trim <i class="emphasis">L</i> to obtain</p>
<p class="para">
<i class="emphasis">L</i><span class="unicode">&prime;</span> = <span class="unicode">&#12296;</span>10, 12, 15, 20, 23, 29<span class="unicode">&#12297;</span>,</p>
<p class="para">where the deleted value 11 is represented by 10, the deleted values 21 and 22 are represented by 20, and the deleted value 24 is represented by 23. Because every element of the trimmed version of the list is also an element of the original version of the list, trimming can dramatically decrease the number of elements kept while keeping a close (and slightly smaller) representative value in the list for each deleted element.</p>
<p class="para">The following procedure trims list <i class="emphasis">L</i> = <span class="unicode">&#12296;</span><i class="emphasis">y</i><sub>1</sub>, <i class="emphasis">y</i><sub>2</sub>, ..., <i class="emphasis">y<sub>m</sub></i><span class="unicode">&#12297;</span> in time <span class="unicode">&Theta;</span>(<i class="emphasis">m</i>), given <i class="emphasis">L</i> and <i class="emphasis"><span class="unicode">&delta;</span></i>, and assuming that <i class="emphasis">L</i> is sorted into monotonically increasing order. The output of the procedure is a trimmed, sorted list.</p>
<div class="informalexample">
<pre class="literallayout-normal">
TRIM(<i class="emphasis">L</i>, <i class="emphasis"><span class="unicode">&delta;</span></i>)
1  <i class="emphasis">m</i> <span class="unicode">&larr;</span> |<i class="emphasis">L</i>|
2  <i class="emphasis">L</i><span class="unicode">&prime;</span> <span class="unicode">&larr;</span> <span class="unicode">&#12296;</span><i class="emphasis">y</i><sub>1</sub><span class="unicode">&#12297;</span>
3  <i class="emphasis">last</i> <span class="unicode">&larr;</span> <i class="emphasis">y</i><sub>1</sub>
4  <b class="bold">for</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> 2 <b class="bold">to</b> <i class="emphasis">m</i>
5      <b class="bold">do if</b> <i class="emphasis">y<sub>i</sub></i> <span class="unicode">&gt;</span> <i class="emphasis">last</i> <span class="unicode">&middot;</span> (1 + <i class="emphasis"><span class="unicode">&delta;</span></i>)      <span class="unicode">&#9657;</span> <i class="emphasis">y<sub>i</sub></i> <span class="unicode">&ge;</span> <i class="emphasis">last</i> because <i class="emphasis">L</i> is sorted
6            <b class="bold">then</b> append <i class="emphasis">y<sub>i</sub></i> onto the end of <i class="emphasis">L</i><span class="unicode">&prime;</span>
7                 <i class="emphasis">last</i> <span class="unicode">&larr;</span> <i class="emphasis">y<sub>i</sub></i>
8  <b class="bold">return</b> <i class="emphasis">L</i><span class="unicode">&prime;</span>
</pre>
</div>
<p class="para">The elements of <i class="emphasis">L</i> are scanned in monotonically increasing order, and a number is put into the returned list <i class="emphasis">L</i><span class="unicode">&prime;</span> only if it is the first element of <i class="emphasis">L</i> or if it cannot be represented by the most recent number placed into <i class="emphasis">L</i><span class="unicode">&prime;</span>.</p>
<p class="para">Given the procedure TRIM, we can construct our approximation scheme as follows. This procedure takes as input a set <i class="emphasis">S</i> = {<i class="emphasis">x</i><sub>1</sub>, <i class="emphasis">x</i><sub>2</sub>, ..., <i class="emphasis">x<sub>n</sub></i>} of <i class="emphasis">n</i> integers (in arbitrary order), a target integer <i class="emphasis">t</i>, and an "approximation parameter" <span class="unicode">&isin;</span>, where</p>
<div class="equation">
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(35.23)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig1068_01.jpg" height="12" width="68" alt="" border="0"></span></td>
</tr>
</table>
</div>
<p class="para">It returns a value <i class="emphasis">z</i> whose value is within a 1 + <span class="unicode">&isin;</span> factor of the optimal solution.</p>
<div class="informalexample">
<pre class="literallayout-normal">
APPROX-SUBSET-SUM(<i class="emphasis">S</i>, <i class="emphasis">t</i>, <span class="unicode">&isin;</span>)
1  <i class="emphasis">n</i> <span class="unicode">&larr;</span> |<i class="emphasis">S</i>|
2  <i class="emphasis">L</i><sub>0</sub> <span class="unicode">&larr;</span> <span class="unicode">&#12296;</span>0<span class="unicode">&#12297;</span>
3  <b class="bold">for</b> <i class="emphasis">i</i> <span class="unicode">&larr;</span> 1 <b class="bold">to</b> <i class="emphasis">n</i>
4       <b class="bold">do</b> <i class="emphasis">L<sub>i</sub></i> <span class="unicode">&larr;</span> MERGE-LISTS(<i class="emphasis">L</i><sub><i class="emphasis">i</i>-1</sub>, <i class="emphasis">L</i><sub><i class="emphasis">i</i>-1</sub> + <i class="emphasis">x<sub>i</sub></i>)
5          <i class="emphasis">L<sub>i</sub></i> <span class="unicode">&larr;</span> TRIM(<i class="emphasis">L<sub>i</sub></i>, <span class="unicode">&isin;</span>/2<i class="emphasis">n</i>)
6          remove from <i class="emphasis">L<sub>i</sub></i> every element that is greater than <i class="emphasis">t</i>
7  let <i class="emphasis">z</i>* be the largest value in <i class="emphasis">L<sub>n</sub></i>
8  <b class="bold">return</b> <i class="emphasis">z</i>*
</pre>
</div>
<a name="3249"></a><a name="IDX-1047"></a>
<p class="para">Line 2 initializes the list <i class="emphasis">L</i><sub>0</sub> to be the list containing just the element 0. The <b class="bold">for</b> loop in lines 3<span class="unicode">-</span>6 has the effect of computing <i class="emphasis">L<sub>i</sub></i> as a sorted list containing a suitably trimmed version of the set <i class="emphasis">P<sub>i</sub></i> , with all elements larger than <i class="emphasis">t</i> removed. Since <i class="emphasis">L<sub>i</sub></i> is created from <i class="emphasis">L</i><sub><i class="emphasis">i</i>-1</sub>, we must ensure that the repeated trimming doesn't introduce too much inaccuracy. In a moment, we shall see that APPROX-SUBSET-SUM returns a correct approximation if one exists.</p>
<p class="para">As an example, suppose we have the instance</p>
<p class="para">
<i class="emphasis">S</i> = <span class="unicode">&#12296;</span>104, 102, 201, 101<span class="unicode">&#12297;</span>
</p>
<p class="para">with <i class="emphasis">t</i> = 308 and <span class="unicode">&isin;</span> = 0.40. The trimming parameter <span class="unicode">&delta;</span> is <span class="unicode">&isin;</span>/8 = 0.05. APPROX-SUBSET-SUM computes the following values on the indicated lines:</p>
<div class="informaltable">
<table border="0">
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">line 2:</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">L</i><sub>0</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&#12296;</span>0<span class="unicode">&#12297;</span>,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">line 4:</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">L</i><sub>1</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&#12296;</span>0, 104<span class="unicode">&#12297;</span>,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">line 5:</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">L</i><sub>1</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&#12296;</span>0, 104<span class="unicode">&#12297;</span>,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">line 6:</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">L</i><sub>1</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&#12296;</span>0, 104<span class="unicode">&#12297;</span>,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">line 4:</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">L</i><sub>2</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&#12296;</span>0, 102, 104, 206<span class="unicode">&#12297;</span>,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">line 5:</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">L</i><sub>2</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&#12296;</span>0, 102, 206<span class="unicode">&#12297;</span>,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">line 6:</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">L</i><sub>2</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&#12296;</span>0, 102, 206<span class="unicode">&#12297;</span>,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">line 4:</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">L</i><sub>3</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&#12296;</span>0, 102, 201, 206, 303, 407<span class="unicode">&#12297;</span>,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">line 5:</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">L</i><sub>3</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&#12296;</span>0, 102, 201, 303, 407<span class="unicode">&#12297;</span>,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">line 6:</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">L</i><sub>3</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&#12296;</span>0, 102, 201, 303<span class="unicode">&#12297;</span>,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">line 4:</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">L</i><sub>4</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&#12296;</span>0, 101, 102, 201, 203, 302, 303, 404<span class="unicode">&#12297;</span>,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">line 5:</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">L</i><sub>4</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&#12296;</span>0, 101, 201, 302, 404<span class="unicode">&#12297;</span>,</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">line 6:</p>
</td><td class="td" align="left">
<p class="table-para">
<i class="emphasis">L</i><sub>4</sub>
</p>
</td><td class="td" align="center">
<p class="table-para">=</p>
</td><td class="td" align="left">
<p class="table-para">
<span class="unicode">&#12296;</span>0, 101, 201, 302<span class="unicode">&#12297;</span>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="para">The algorithm returns <i class="emphasis">z</i>* = 302 as its answer, which is well within <i class="emphasis"><span class="unicode">&isin;</span></i> = 40% of the optimal answer 307 = 104 + 102 + 101; in fact, it is within 2%.</p>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Theorem 35.8</span></span>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">APPROX-SUBSET-SUM is a fully polynomial-time approximation scheme for the subset-sum problem.</p>
<p class="para">
<b class="bold"><i class="emphasis">Proof</i></b> The operations of trimming <i class="emphasis">L<sub>i</sub></i> in line 5 and removing from <i class="emphasis">L<sub>i</sub></i> every element that is greater than <i class="emphasis">t</i> maintain the property that every element of <i class="emphasis">L<sub>i</sub></i> is also a member of <i class="emphasis">P<sub>i</sub></i>. Therefore, the value <i class="emphasis">z</i>* returned in line 8 is indeed the sum of some subset of <i class="emphasis">S</i>. Let <i class="emphasis">y</i>* <span class="unicode">&isin;</span> <i class="emphasis">P<span class="unicode">&gt;</span><sub>n</sub></i> denote an optimal solution to the subset-sum problem.<a name="3250"></a><a name="IDX-1048"></a>
</p>
<p class="para">Then, from line 6, we know that <i class="emphasis">z</i>* <span class="unicode">&le;</span> <i class="emphasis">y</i>*. By inequality (<a href="DDU0234.html#3169" target="_parent" class="chapterjump">35.1</a>), we need to show that <i class="emphasis">y</i>*/<i class="emphasis">z</i>* <span class="unicode">&le;</span> 1 + <i class="emphasis"><span class="unicode">&isin;</span></i>. We must also show that the running time of this algorithm is polynomial in both 1/<i class="emphasis"><span class="unicode">&isin;</span></i> and the size of the input.</p>
<p class="para">By induction on <i class="emphasis">i</i>, it can be shown that for every element <i class="emphasis">y</i> in <i class="emphasis">P<sub>i</sub></i> that is at most <i class="emphasis">t</i>, there is a <i class="emphasis">z</i> <span class="unicode">&isin;</span> <i class="emphasis">L<sub>i</sub></i> such that</p>
<p class="para">
<div class="equation">
<a name="3251"></a><a name="ch35eq24"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(35.24)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig1070_01.jpg" height="33" width="125" alt="" border="0"></span></td>
</tr>
</table>
</div>
</p>
<p class="para">(see <a class="internaljump" href="#ch35ex29">Exercise 35.5-2</a>). Inequality (<a class="internaljump" href="#ch35eq24">35.24</a>) must hold for <i class="emphasis">y</i>* <span class="unicode">&isin;</span> <i class="emphasis">P<sub>n</sub></i>, and therefore there is a <i class="emphasis">z</i> <span class="unicode">&isin;</span> <i class="emphasis">L<sub>n</sub></i> such that</p>
<p class="para">
<div class="informalequation">
<span class="equation-image"><img src="images/fig1070_02.jpg" height="36" width="140" alt="" border="0"></span>
</div>
</p>
<p class="para">and thus</p>
<p class="para">
<div class="equation">
<a name="3252"></a><a name="ch35eq25"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(35.25)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig1070_03.jpg" height="33" width="111" alt="" border="0"></span></td>
</tr>
</table>
</div>
</p>
<p class="para">Since there is a <i class="emphasis">z</i> <span class="unicode">&isin;</span> <i class="emphasis">L<sub>n</sub></i> fulfilling inequality (<a class="internaljump" href="#ch35eq25">35.25</a>), the inequality must hold for <i class="emphasis">z</i>*, which is the largest value in <i class="emphasis">L<sub>n</sub></i>; that is,</p>
<p class="para">
<div class="equation">
<a name="3253"></a><a name="ch35eq26"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(35.26)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig1070_04.jpg" height="33" width="111" alt="" border="0"></span></td>
</tr>
</table>
</div>
</p>
<p class="para">It remains to show that <i class="emphasis">y</i>*/<i class="emphasis">z</i>* <span class="unicode">&le;</span> 1+<i class="emphasis"><span class="unicode">&isin;</span></i>. We do so by showing that (1 + <i class="emphasis"><span class="unicode">&isin;</span></i>/2<i class="emphasis">n</i>)<sup><i class="emphasis">n</i></sup> <span class="unicode">&le;</span> 1 + <i class="emphasis"><span class="unicode">&isin;</span></i>. By <a href="DDU0020.html#168" target="_parent" class="chapterjump">equation (3.13)</a>, we have lim<sub><i class="emphasis">n</i><i class="emphasis"><span class="unicode">&rarr;</span></i><i class="emphasis"><span class="unicode">&infin;</span></i></sub>(1 + <i class="emphasis"><span class="unicode">&isin;</span></i>/2<i class="emphasis">n</i>)<sup><i class="emphasis">n</i></sup> = <i class="emphasis">e</i><sup><i class="emphasis"><span class="unicode">&isin;</span></i>/2</sup>. Since it can be shown that</p>
<p class="para">
<div class="equation">
<a name="3254"></a><a name="ch35eq27"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(35.27)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig1070_05.jpg" height="33" width="121" alt="" border="0"></span></td>
</tr>
</table>
</div>
</p>
<p class="para">the function (1 + <i class="emphasis"><span class="unicode">&isin;</span></i>/2<i class="emphasis">n</i>)<sup><i class="emphasis">n</i></sup> increases with <i class="emphasis">n</i> as it approaches its limit of <i class="emphasis">e</i><sup><i class="emphasis"><span class="unicode">&isin;</span></i>/2</sup>, and we have</p>
<p class="para">
<div class="equation">
<a name="3255"></a><a name="ch35eq28"></a>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><span class="equation-label">(35.28)&nbsp;</span></td><td valign="top"><span class="equation-image"><img src="images/fig1070_06.jpg" height="73" width="359" alt="" border="0"></span></td>
</tr>
</table>
</div>
</p>
<p class="para">Combining inequalities (<a class="internaljump" href="#ch35eq26">35.26</a>) and (<a class="internaljump" href="#ch35eq28">35.28</a>) completes the analysis of the approximation ratio.</p>
<p class="para">To show that APPROX-SUBSET-SUM is a fully polynomial-time approximation scheme, we derive a bound on the length of <i class="emphasis">L<sub>i</sub></i>. After trimming, successive elements <i class="emphasis">z</i> and <i class="emphasis">z</i><span class="unicode">&prime;</span> of <i class="emphasis">L<sub>i</sub></i> must have the relationship <i class="emphasis">z</i><span class="unicode">&prime;</span>/<i class="emphasis">z</i> <span class="unicode">&gt;</span> 1+<i class="emphasis"><span class="unicode">&isin;</span></i>/2<i class="emphasis">n</i>. That is, they must differ by a factor of at least 1+<i class="emphasis"><span class="unicode">&isin;</span></i>/2<i class="emphasis">n</i>. Each list, therefore, contains the value 0, possibly the value 1, and up to <span class="unicode">&lfloor;</span>log<sub>1+<i class="emphasis"><span class="unicode">&isin;</span></i>/2<i class="emphasis">n</i></sub> <i class="emphasis">t</i><span class="unicode">&rfloor;</span> additional values. The number of elements <a name="3256"></a><a name="IDX-1049"></a>in each list <i class="emphasis">L<sub>i</sub></i> is at most</p>
<p class="para">
<div class="informalequation">
<span class="equation-image"><a href="images/fig1071%5F01%2Ejpg" NAME="IMG_1999" target="_parent"><img src="images/fig1071_01.jpg" height="104" width="400" alt="Click To expand" border="0"></a></span>
</div>
</p>
<p class="last-para">This bound is polynomial in the size of the input<span class="unicode">-</span>which is the number of bits lg <i class="emphasis">t</i> needed to represent <i class="emphasis">t</i> plus the number of bits needed to represent the set <i class="emphasis">S</i>, which is in turn polynomial in <i class="emphasis">n</i><span class="unicode">-</span>and in 1<i class="emphasis">/<span class="unicode">&isin;</span></i>. Since the running time of APPROX-SUBSET-SUM is polynomial in the lengths of the <i class="emphasis">L<sub>i</sub></i>, APPROX-SUBSET-SUM is a fully polynomial-time approximation scheme.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 35.5-1</span></span><a name="3257"></a><a name="ch35ex28"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Prove <a class="internaljump" href="#ch35eq21">equation (<a class="internaljump" href="#ch35eq21">35.21</a>)</a>. Then show that after executing line 5 of EXACT-SUBSET-SUM, <i class="emphasis">L<sub>i</sub></i> is a sorted list containing every element of <i class="emphasis">P<sub>i</sub></i> whose value is not more than <i class="emphasis">t</i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 35.5-2</span></span><a name="3258"></a><a name="ch35ex29"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Prove inequality (<a class="internaljump" href="#ch35eq24">35.24</a>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 35.5-3</span></span><a name="3259"></a><a name="ch35ex30"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Prove inequality (<a class="internaljump" href="#ch35eq27">35.27</a>).</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Exercises 35.5-4</span></span><a name="3260"></a><a name="ch35ex31"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">How would you modify the approximation scheme presented in this section to find a good approximation to the smallest value not less than <i class="emphasis">t</i> that is a sum of some subset of the given input list?</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 35-1: </span>Bin packing</span><a name="3261"></a><a name="ch35ex32"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that we are given a set of <i class="emphasis">n</i> objects, where the size <i class="emphasis">s<sub>i</sub></i> of the <i class="emphasis">i</i>th object satisfies 0 <span class="unicode">&lt;</span> <i class="emphasis">s<sub>i</sub></i> <span class="unicode">&lt;</span> 1. We wish to pack all the objects into the minimum number of unit-size bins. Each bin can hold any subset of the objects whose total size does not exceed 1.<a name="3262"></a><a name="IDX-1050"></a>
</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Prove that the problem of determining the minimum number of bins required is NP-hard. (<i class="emphasis">Hint:</i> Reduce from the subset-sum problem.)</p>
</li>
</ol>
<p class="para">The <b class="bold"><i class="emphasis">first-fit</i></b> heuristic takes each object in turn and places it into the first bin that can accommodate it. Let <span class="inlinemediaobject"><img src="images/fig1072_01.jpg" height="13" width="54" alt="" border="0"></span>.</p>
<ol class="orderedlist" start="2" type="a">
<li class="first-listitem">
<p class="first-para">Argue that the optimal number of bins required is at least <span class="unicode">&lceil;</span><i class="emphasis">S</i><span class="unicode">&rceil;</span>.</p>
</li>
<li class="listitem">
<p class="first-para">Argue that the first-fit heuristic leaves at most one bin less than half full.</p>
</li>
<li class="listitem">
<p class="first-para">Prove that the number of bins used by the first-fit heuristic is never more than <span class="unicode">&rceil;</span>2<i class="emphasis">S</i><span class="unicode">&rceil;</span>.</p>
</li>
<li class="listitem">
<p class="first-para">Prove an approximation ratio of 2 for the first-fit heuristic.</p>
</li>
<li class="listitem">
<p class="first-para">Give an efficient implementation of the first-fit heuristic, and analyze its running time.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 35-2: </span>Approximating the size of a maximum clique</span><a name="3263"></a><a name="ch35ex33"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Let <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>) be an undirected graph. For any <i class="emphasis">k</i> <span class="unicode">&ge;</span> 1, define <i class="emphasis">G</i><sup>(<i class="emphasis">k</i>)</sup> to be the undirected graph (<i class="emphasis">V</i><sup>(<i class="emphasis">k</i>)</sup>, <i class="emphasis">E</i><sup>(<i class="emphasis">k</i>)</sup>), where <i class="emphasis">V</i><sup>(<i class="emphasis">k</i>)</sup> is the set of all ordered <i class="emphasis">k</i>-tuples of vertices from <i class="emphasis">V</i> and <i class="emphasis">E</i><sup>(<i class="emphasis">k</i>)</sup> is defined so that (<i class="emphasis">v</i><sub>1</sub>, <i class="emphasis">v</i><sub>2</sub>, ..., <i class="emphasis">v<sub>k</sub></i>) is adjacent to (<i class="emphasis">w</i><sub>1</sub>, <i class="emphasis">w</i><sub>2</sub>, ..., <i class="emphasis">w<sub>k</sub></i>) if and only if for each <i class="emphasis">i</i>, 1 <span class="unicode">&le;</span> <i class="emphasis">i</i> <span class="unicode">&le;</span> <i class="emphasis">k</i> either vertex <i class="emphasis">v<sub>i</sub></i> is adjacent to <i class="emphasis">w<sub>i</sub></i> in <i class="emphasis">G</i>, or else <i class="emphasis">v<sub>i</sub></i> = <i class="emphasis">w<sub>i</sub></i>.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Prove that the size of the maximum clique in <i class="emphasis">G</i><sup>(<i class="emphasis">k</i>)</sup> is equal to the <i class="emphasis">k</i>th power of the size of the maximum clique in <i class="emphasis">G</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Argue that if there is an approximation algorithm that has a constant approximation ratio for finding a maximum-size clique, then there is a fully polynomial-time approximation scheme for the problem.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 35-3: </span>Weighted set-covering problem</span><a name="3264"></a><a name="ch35ex34"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Suppose that we generalize the set-covering problem so that each set <i class="emphasis">S<sub>i</sub></i> in the family <span class="inlinemediaobject"><img src="images/fig1072_02.jpg" height="14" width="15" alt="" border="0"></span> has an associated weight <i class="emphasis">w<sub>i</sub></i> and the weight of a cover <span class="inlinemediaobject"><img src="images/fig1072_03.jpg" height="13" width="10" alt="" border="0"></span> is <span class="inlinemediaobject"><img src="images/fig1072_04.jpg" height="14" width="42" alt="" border="0"></span>. We wish to determine a minimum-weight cover. (<a href="DDU0238.html#3206" target="_parent" class="chapterjump">Section 35.3</a> handles the case in which <i class="emphasis">w<sub>i</sub></i> = 1 for all <i class="emphasis">i</i>.)</p>
<p class="last-para">Show that the greedy set-covering heuristic can be generalized in a natural manner to provide an approximate solution for any instance of the weighted set-covering problem. Show that your heuristic has an approximation ratio of <i class="emphasis">H</i>(<i class="emphasis">d</i>), where <i class="emphasis">d</i> is the maximum size of any set <i class="emphasis">S<sub>i</sub></i>.</p>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<a name="3265"></a><a name="IDX-1051"></a>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 35-4: </span>Maximum matching</span><a name="3266"></a><a name="ch35ex35"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">Recall that for an undirected graph <i class="emphasis">G</i>, a matching is a set of edges such that no two edges in the set are incident on the same vertex. In <a href="DDU0163.html#2035" target="_parent" class="chapterjump">Section 26.3</a>, we saw how to find a maximum matching in a bipartite graph. In this problem, we will look at matchings in undirected graphs in general (i.e., the graphs are not required to be bipartite).</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">A <b class="bold"><i class="emphasis">maximal matching</i></b> is a matching that is not a proper subset of any other matching. Show that a maximal matching need not be a maximum matching by exhibiting an undirected graph <i class="emphasis">G</i> and a maximal matching <i class="emphasis">M</i> in <i class="emphasis">G</i> that is not a maximum matching. (There is such a graph with only four vertices.)</p>
</li>
<li class="listitem">
<p class="first-para">Consider an undirected graph <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>). Give an <i class="emphasis">O</i>(<i class="emphasis">E</i>)-time greedy algorithm to find a maximal matching in <i class="emphasis">G</i>.</p>
</li>
</ol>
<p class="para">In this problem, we will concentrate on a polynomial-time approximation algorithm for maximum matching. Whereas the fastest known algorithm for maximum matching takes superlinear (but polynomial) time, the approximation algorithm here will run in linear time. You will show that the linear-time greedy algorithm for maximal matching in part (b) is a 2-approximation algorithm for maximum matching.</p>
<ol class="orderedlist" start="3" type="a">
<li class="first-listitem">
<p class="first-para">Show that the size of a maximum matching in <i class="emphasis">G</i> is a lower bound on the size of any vertex cover for <i class="emphasis">G</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Consider a maximal matching <i class="emphasis">M</i> in <i class="emphasis">G</i> = (<i class="emphasis">V</i>, <i class="emphasis">E</i>). Let</p>
<p class="para">
<i class="emphasis">T</i> = {<i class="emphasis">v</i> <span class="unicode">&isin;</span> <i class="emphasis">V</i> : some edge in <i class="emphasis">M</i> is incident on <i class="emphasis">v</i>}.</p>
<p class="last-para">What can you say about the subgraph of <i class="emphasis">G</i> induced by the vertices of <i class="emphasis">G</i> that are not in <i class="emphasis">T</i>?</p>
</li>
<li class="listitem">
<p class="first-para">Conclude from part (d) that 2 |<i class="emphasis">M</i>| is the size of a vertex cover for <i class="emphasis">G</i>.</p>
</li>
<li class="listitem">
<p class="first-para">Using parts (c) and (e), prove that the greedy algorithm in part (b) is a 2-approximation algorithm for maximum matching.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>
<div class="example">
<span class="example-title"><span class="example-titlelabel">Problems 35-5: </span>Parallel machine scheduling</span><a name="3267"></a><a name="ch35ex36"></a>
<div class="formalbody">
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="Start example" border="0"></b></font></td>
</tr>
</table>
<p class="first-para">In the <b class="bold"><i class="emphasis">parallel-machine-scheduling problem</i></b>, we are given <i class="emphasis">n</i> jobs, <i class="emphasis">J</i><sub>1</sub>, <i class="emphasis">J</i><sub>2</sub>, ..., <i class="emphasis">J<sub>n</sub></i>, where each job <i class="emphasis">J<sub>k</sub></i> has an associated nonnegative processing time of <i class="emphasis">p<sub>k</sub></i>. We are also given <i class="emphasis">m</i> identical machines, <i class="emphasis">M</i><sub>1</sub>, <i class="emphasis">M</i><sub>2</sub>, ..., <i class="emphasis">M<sub>m</sub></i>. A <b class="bold"><i class="emphasis">schedule</i></b> specifies, for each job <i class="emphasis">J<sub>k</sub></i>, the machine on which it runs and the time period during which it runs. Each job <i class="emphasis">J<sub>k</sub></i> must run on some machine <i class="emphasis">M<sub>i</sub></i> for <i class="emphasis">p<sub>k</sub></i> consecutive time units, and during that <a name="3268"></a><a name="IDX-1052"></a>time period no other job may run on <i class="emphasis">M<sub>i</sub></i>. Let <i class="emphasis">C<sub>k</sub></i> denote the <b class="bold"><i class="emphasis">completion time</i></b> of job <i class="emphasis">J<sub>k</sub></i>, that is, the time at which job <i class="emphasis">J<sub>k</sub></i> completes processing. Given a schedule, we define <i class="emphasis">C</i><sub>max</sub> = max<sub>1<i class="emphasis"><span class="unicode">&le;</span></i><i class="emphasis">j</i><i class="emphasis"><span class="unicode">&le;</span></i><i class="emphasis">n</i></sub> <i class="emphasis">C<sub>k</sub></i> to be the <b class="bold"><i class="emphasis">makespan</i></b> of the schedule. The goal is to find a schedule whose makespan is minimum.</p>
<p class="para">For example, suppose that we have two machines <i class="emphasis">M</i><sub>1</sub> and <i class="emphasis">M</i><sub>2</sub> and that we have four jobs <i class="emphasis">J</i><sub>1</sub>, <i class="emphasis">J</i><sub>2</sub>, <i class="emphasis">J</i><sub>3</sub>, <i class="emphasis">J</i><sub>4</sub>, with <i class="emphasis">p</i><sub>1</sub> = 2, <i class="emphasis">p</i><sub>2</sub> = 12, <i class="emphasis">p</i><sub>3</sub> = 4, and <i class="emphasis">p</i><sub>4</sub> = 5. Then one possible schedule runs, on machine <i class="emphasis">M</i><sub>1</sub>, job <i class="emphasis">J</i><sub>1</sub> followed by job <i class="emphasis">J</i><sub>2</sub>, and on machine <i class="emphasis">M</i><sub>2</sub>, it runs job <i class="emphasis">J</i><sub>4</sub> followed by job <i class="emphasis">J</i><sub>3</sub>. For this schedule, <i class="emphasis">C</i><sub>1</sub> = 2, <i class="emphasis">C</i><sub>2</sub> = 14, <i class="emphasis">C</i><sub>3</sub> = 9, <i class="emphasis">C</i><sub>4</sub> = 5, and <i class="emphasis">C</i><sub>max</sub> = 14. An optimal schedule runs <i class="emphasis">J</i><sub>2</sub> on machine <i class="emphasis">M</i><sub>1</sub>, and it runs jobs <i class="emphasis">J</i><sub>1</sub>, <i class="emphasis">J</i><sub>3</sub>, and <i class="emphasis">J</i><sub>4</sub> on machine <i class="emphasis">M</i><sub>2</sub>. For this schedule, <i class="emphasis">C</i><sub>1</sub> = 2, <i class="emphasis">C</i><sub>2</sub> = 12, <i class="emphasis">C</i><sub>3</sub> = 6, <i class="emphasis">C</i><sub>4</sub> = 11, and <i class="emphasis">C</i><sub>max</sub> = 12.</p>
<p class="para">Given a parallel-machine-scheduling problem, we let <span class="inlinemediaobject"><img src="images/fig1074_01.jpg" height="12" width="22" alt="" border="0"></span> denote the makespan of an optimal schedule.</p>
<ol class="orderedlist" type="a">
<li class="first-listitem">
<p class="first-para">Show that the optimal makespan is at least as large as the greatest processing time, that is,</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig1074_02.jpg" height="24" width="103" alt="" border="0"></span>
</div>
</li>
<li class="listitem">
<p class="first-para">Show that the optimal makespan is at least as large as the average machine load, that is,</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig1074_03.jpg" height="39" width="119" alt="" border="0"></span>
</div>
</li>
</ol>
<p class="para">Suppose that we use the following greedy algorithm for parallel machine scheduling: whenever a machine is idle, schedule any job that has not yet been scheduled.</p>
<ol class="orderedlist" start="3" type="a">
<li class="first-listitem">
<p class="first-para">Write pseudocode to implement this greedy algorithm. What is the running time of your algorithm?</p>
</li>
<li class="listitem">
<p class="first-para">For the schedule returned by the greedy algorithm, show that</p>
<div class="informalequation">
<span class="equation-image"><img src="images/fig1074_04.jpg" height="39" width="185" alt="" border="0"></span>
</div>
<p class="last-para">Conclude that this algorithm is a polynomial-time 2-approximation algorithm.</p>
</li>
</ol>
<table class="BlueLine" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td bgcolor="000080" class="bluecell"><font size="2" face="Arial" color="010100"><b><img src="_.gif" width="1" height="2" alt="End example" border="0"></b></font></td>
</tr>
</table>
<table class="BlankSpace" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td height="16"></td>
</tr>
</table>
</div>
</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0239.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0241.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
