<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Chapter 2: Getting Started</title>
<link rel="STYLESHEET" type="text/css" href="images/xpolecat.css">
<link rel="STYLESHEET" type="text/css" href="images/ie.content.books24x7.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0285.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0287.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
<hr size="1">
<br>
<div class="appendix">

<h1 class="appendix-title">List of Figures</h1>
<div class="section">
<div class="section">
<h2 class="sect2-title">
<a name="4012"></a><a href="DDU0014.html#57" target="_parent" class="chapter-titlelabel">Chapter 2:</a> Getting Started</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0014.html#61" target="_parent" class="chapterjump">Figure 2.1:</a> Sorting a hand of cards using insertion sort.</dt>
<dt class="lotentry">
<a href="DDU0014.html#64" target="_parent" class="chapterjump">Figure 2.2:</a> The operation of INSERTION-SORT on the array <i class="emphasis">A</i> = <span class="unicode">&#12296;</span>5, 2, 4, 6, 1, 3<span class="unicode">&#12297;</span>. Array indices appear above the rectangles, and values stored in the array positions appear within the rectangles. <i class="emphasis">(a)<span class="unicode">&ndash;</span>(e)</i> The iterations of the <i class="emphasis">for</i> loop of lines 1<span class="unicode">&ndash;</span>8. In each iteration, the black rectangle holds the key taken from <i class="emphasis">A</i>[<i class="emphasis">j</i>], which is compared with the values in shaded rectangles to its left in the test of line 5. Shaded arrows show array values moved one position to the right in line 6, and black arrows indicate where the key is moved to in line 8. <i class="emphasis">(f)</i> The final sorted array.</dt>
<dt class="lotentry">
<a href="DDU0016.html#93" target="_parent" class="chapterjump">Figure 2.3:</a> The operation of lines 10<span class="unicode">&ndash;</span>17 in the call MERGE(<i class="emphasis">A</i>, 9, 12, 16), when the subarray <i class="emphasis">A</i>[9 <span class="unicode">&#8229;</span> 16] contains the sequence <span class="unicode">&#12296;</span>2, 4, 5, 7, 1, 2, 3, 6<span class="unicode">&#12297;</span>. After copying and inserting sentinels, the array <i class="emphasis">L</i> contains <span class="unicode">&#12296;</span>2, 4, 5, 7, <span class="unicode">&infin;</span><span class="unicode">&#12297;</span>, and the array <i class="emphasis">R</i> contains <span class="unicode">&#12296;</span>1, 2, 3, 6, <span class="unicode">&infin;</span><span class="unicode">&#12297;</span>. Lightly shaded positions in <i class="emphasis">A</i> contain their final values, and lightly shaded positions in <i class="emphasis">L</i> and <i class="emphasis">R</i> contain values that have yet to be copied back into <i class="emphasis">A</i>. Taken together, the lightly shaded positions always comprise the values originally in <i class="emphasis">A</i>[9 <span class="unicode">&#8229;</span> 16], along with the two sentinels. Heavily shaded positions in <i class="emphasis">A</i> contain values that will be copied over, and heavily shaded positions in <i class="emphasis">L</i> and <i class="emphasis">R</i> contain values that have already been copied back into <i class="emphasis">A</i>. <i class="emphasis">(a)<span class="unicode">&ndash;</span>(h)</i> The arrays <i class="emphasis">A, L</i>, and <i class="emphasis">R</i>, and their respective indices <i class="emphasis">k, i</i>, and <i class="emphasis">j</i> prior to each iteration of the loop of lines 12<span class="unicode">&ndash;</span>17. <i class="emphasis">(i)</i> The arrays and indices at termination. At this point, the subarray in <i class="emphasis">A</i>[9 <span class="unicode">&#8229;</span> 16] is sorted, and the two sentinels in <i class="emphasis">L</i> and <i class="emphasis">R</i> are the only two elements in these arrays that have not been copied into <i class="emphasis">A</i>.</dt>
<dt class="lotentry">
<a href="DDU0016.html#96" target="_parent" class="chapterjump">Figure 2.4:</a> The operation of merge sort on the array <i class="emphasis">A</i> = <span class="unicode">&#12296;</span>5, 2, 4, 7, 1, 3, 2, 6<span class="unicode">&#12297;</span>. The lengths of the sorted sequences being merged increase as the algorithm progresses from bottom to top.</dt>
<dt class="lotentry">
<a href="DDU0016.html#104" target="_parent" class="chapterjump">Figure 2.5:</a> The construction of a recursion tree for the recurrence <i class="emphasis">T</i>(<i class="emphasis">n</i>) = 2<i class="emphasis">T</i>(<i class="emphasis">n</i>/2) + <i class="emphasis">cn</i>. Part <i class="emphasis">(a)</i> shows <i class="emphasis">T</i>(<i class="emphasis">n</i>), which is progressively expanded in <i class="emphasis">(b)<span class="unicode">&ndash;</span>(d)</i> to form the recursion tree. The fully expanded tree in part (d) has lg <i class="emphasis">n</i> + 1 levels (i.e., it has height lg <i class="emphasis">n</i>, as indicated), and each level contributes a total cost of <i class="emphasis">cn</i>. The total cost, therefore, is <i class="emphasis">cn</i> lg <i class="emphasis">n</i> + <i class="emphasis">cn</i>, which is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>).</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4014"></a><a href="DDU0018.html#122" target="_parent" class="chapter-titlelabel">Chapter 3:</a> Growth of Functions</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0019.html#128" target="_parent" class="chapterjump">Figure 3.1:</a> Graphic examples of the <span class="unicode">&Theta;</span>, <i class="emphasis">O</i>, and <span class="unicode">&#8486;</span> notations. In each part, the value of <i class="emphasis">n</i><sub>0</sub> shown is the minimum possible value; any greater value would also work. (<i class="emphasis">a</i>) <span class="unicode">&Theta;</span>-notation bounds a function to within constant factors. We write <i class="emphasis">f</i>(<i class="emphasis">n</i>) = <span class="unicode">&Theta;</span>(<i class="emphasis">g</i>(<i class="emphasis">n</i>)) if there exist positive constants <i class="emphasis">n</i><sub>0</sub>, <i class="emphasis">c</i><sub>1</sub>, and <i class="emphasis">c</i><sub>2</sub> such that to the right of <i class="emphasis">n</i><sub>0</sub>, the value of <i class="emphasis">f</i>(<i class="emphasis">n</i>) always lies between <i class="emphasis">c</i><sub>1</sub><i class="emphasis">g</i>(<i class="emphasis">n</i>) and <i class="emphasis">c</i><sub>2</sub><i class="emphasis">g</i>(<i class="emphasis">n</i>) inclusive. (<i class="emphasis">b</i>) <i class="emphasis">O</i>-notation gives an upper bound for a function to within a constant factor. We write <i class="emphasis">f</i>(<i class="emphasis">n</i>) = <i class="emphasis">O</i>(<i class="emphasis">g</i>(<i class="emphasis">n</i>)) if there are positive constants <i class="emphasis">n</i><sub>0</sub> and <i class="emphasis">c</i> such that to the right of <i class="emphasis">n</i><sub>0</sub>, the value of <i class="emphasis">f</i>(<i class="emphasis">n</i>) always lies on or below <i class="emphasis">cg</i>(<i class="emphasis">n</i>). (<i class="emphasis">c</i>) <span class="unicode">&#8486;</span>-notation gives a lower bound for a function to within a constant factor. We write <i class="emphasis">f</i>(<i class="emphasis">n</i>) = <span class="unicode">&#8486;</span>(<i class="emphasis">g</i>(<i class="emphasis">n</i>)) if there are positive constants <i class="emphasis">n</i><sub>0</sub> and <i class="emphasis">c</i> such that to the right of <i class="emphasis">n</i><sub>0</sub>, the value of <i class="emphasis">f</i>(<i class="emphasis">n</i>) always lies on or above <i class="emphasis">cg</i>(<i class="emphasis">n</i>).</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4016"></a><a href="DDU0022.html#203" target="_parent" class="chapter-titlelabel">Chapter 4:</a> Recurrences</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0025.html#229" target="_parent" class="chapterjump">Figure 4.1:</a> The construction of a recursion tree for the recurrence <i class="emphasis">T</i>(<i class="emphasis">n</i>) = 3<i class="emphasis">T</i>(<i class="emphasis">n</i>/4) + <i class="emphasis">cn</i><sup>2</sup>. Part <i class="emphasis">(a)</i> shows <i class="emphasis">T</i>(<i class="emphasis">n</i>), which is progressively expanded in <i class="emphasis">(b)<span class="unicode">&ndash;</span>(d)</i> to form the recursion tree. The fully expanded tree in part (d) has height log<sub>4</sub> <i class="emphasis">n</i> (it has log<sub>4</sub> <i class="emphasis">n</i> + 1 levels).</dt>
<dt class="lotentry">
<a href="DDU0025.html#232" target="_parent" class="chapterjump">Figure 4.2:</a> A recursion tree for the recurrence <i class="emphasis">T</i>(<i class="emphasis">n</i>) = <i class="emphasis">T</i> (<i class="emphasis">n</i>/3) + <i class="emphasis">T</i> (2<i class="emphasis">n</i>/3) + <i class="emphasis">cn</i>.</dt>
<dt class="lotentry">
<a href="DDU0027.html#260" target="_parent" class="chapterjump">Figure 4.3:</a> The recursion tree generated by <i class="emphasis">T</i> (<i class="emphasis">n</i>) = <i class="emphasis">aT</i> (<i class="emphasis">n/b</i>) + <i class="emphasis">f</i> (<i class="emphasis">n</i>). The tree is a complete <i class="emphasis">a</i>-ary tree with <span class="inlinemediaobject"><img src="images/fig99_01.jpg" height="11" width="25" alt="" border="0"></span> leaves and height log<i class="emphasis"><sub>b</sub> n</i>. The cost of each level is shown at the right, and their sum is given in equation (4.6).</dt>
<dt class="lotentry">
<a href="DDU0027.html#271" target="_parent" class="chapterjump">Figure 4.4:</a> The recursion tree generated by <i class="emphasis">T</i>(<i class="emphasis">n</i>) = <i class="emphasis">aT</i>(<span class="unicode">&lceil;</span><i class="emphasis">n/b</i><span class="unicode">&rceil;</span>) + <i class="emphasis">f</i>(<i class="emphasis">n</i>). The recursive argument <i class="emphasis">n<sub>j</sub></i> is given by equation (4.12).</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4018"></a><a href="DDU0035.html#382" target="_parent" class="chapter-titlelabel">Chapter 6:</a> Heapsort</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0036.html#387" target="_parent" class="chapterjump">Figure 6.1:</a> A max-heap viewed as <i class="emphasis">(a)</i> a binary tree and <i class="emphasis">(b)</i> an array. The number within the circle at each node in the tree is the value stored at that node. The number above a node is the corresponding index in the array. Above and below the array are lines showing parent-child relationships; parents are always to the left of their children. The tree has height three; the node at index 4 (with value 8) has height one.</dt>
<dt class="lotentry">
<a href="DDU0037.html#399" target="_parent" class="chapterjump">Figure 6.2:</a> The action of MAX-HEAPIFY(<i class="emphasis">A</i>, 2), where <i class="emphasis">heap-size</i>[<i class="emphasis">A</i>] = 10. <i class="emphasis">(a)</i> The initial configuration, with <i class="emphasis">A</i>[2] at node <i class="emphasis">i</i> = 2 violating the max-heap property since it is not larger than both children. The max-heap property is restored for node 2 in <i class="emphasis">(b)</i> by exchanging <i class="emphasis">A</i>[2] with <i class="emphasis">A</i>[4], which destroys the max-heap property for node 4. The recursive call MAX-HEAPIFY(<i class="emphasis">A</i>, 4) now has <i class="emphasis">i</i> = 4. After swapping <i class="emphasis">A</i>[4] with <i class="emphasis">A</i>[9], as shown in <i class="emphasis">(c)</i>, node 4 is fixed up, and the recursive call MAX-HEAPIFY(<i class="emphasis">A</i>, 9) yields no further change to the data structure.</dt>
<dt class="lotentry">
<a href="DDU0038.html#409" target="_parent" class="chapterjump">Figure 6.3:</a> The operation of BUILD-MAX-HEAP, showing the data structure before the call to MAX-HEAPIFY in line 3 of BUILD-MAX-HEAP. <i class="emphasis">(a)</i> A 10-element input array <i class="emphasis">A</i> and the binary tree it represents. The figure shows that the loop index <i class="emphasis">i</i> refers to node 5 before the call MAX-HEAPIFY(<i class="emphasis">A, i</i>). <i class="emphasis">(b)</i> The data structure that results. The loop index <i class="emphasis">i</i> for the next iteration refers to node 4. <i class="emphasis">(c)<span class="unicode">&ndash;</span>(e)</i> Subsequent iterations of the <i class="emphasis">for</i> loop in BUILD-MAX-HEAP. Observe that whenever MAX-HEAPIFY is called on a node, the two subtrees of that node are both max-heaps. <i class="emphasis">(f)</i> The max-heap after BUILD-MAX-HEAP finishes.</dt>
<dt class="lotentry">
<a href="DDU0039.html#417" target="_parent" class="chapterjump">Figure 6.4:</a> The operation of HEAPSORT. <i class="emphasis">(a)</i> The max-heap data structure just after it has been built by BUILD-MAX-HEAP. <i class="emphasis">(b)<span class="unicode">&ndash;</span>(j)</i> The max-heap just after each call of MAX-HEAPIFY in line 5. The value of <i class="emphasis">i</i> at that time is shown. Only lightly shaded nodes remain in the heap. <i class="emphasis">(k)</i> The resulting sorted array <i class="emphasis">A</i>.</dt>
<dt class="lotentry">
<a href="DDU0040.html#428" target="_parent" class="chapterjump">Figure 6.5:</a> The operation of HEAP-INCREASE-KEY. <i class="emphasis">(a)</i> The max-heap of Figure 6.4(a) with a node whose index is <i class="emphasis">i</i> heavily shaded. <i class="emphasis">(b)</i> This node has its key increased to 15. <i class="emphasis">(c)</i> After one iteration of the <i class="emphasis">while</i> loop of lines 4<span class="unicode">&ndash;</span>6, the node and its parent have exchanged keys, and the index <i class="emphasis">i</i> moves up to the parent. <i class="emphasis">(d)</i> The max-heap after one more iteration of the <i class="emphasis">while</i> loop. At this point, <i class="emphasis">A</i>[PARENT(<i class="emphasis">i</i>)] <span class="unicode">&ge;</span> <i class="emphasis">A</i>[<i class="emphasis">i</i>]. The max-heap property now holds and the procedure terminates.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4020"></a><a href="DDU0042.html#445" target="_parent" class="chapter-titlelabel">Chapter 7:</a> Quicksort</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0042.html#450" target="_parent" class="chapterjump">Figure 7.1:</a> The operation of PARTITION on a sample array. Lightly shaded array elements are all in the first partition with values no greater than <i class="emphasis">x</i>. Heavily shaded elements are in the second partition with values greater than <i class="emphasis">x</i>. The unshaded elements have not yet been put in one of the first two partitions, and the final white element is the pivot. <i class="emphasis">(a)</i> The initial array and variable settings. None of the elements have been placed in either of the first two partitions. <i class="emphasis">(b)</i> The value 2 is "swapped with itself" and put in the partition of smaller values. <i class="emphasis">(c)<span class="unicode">&ndash;</span>(d)</i> The values 8 and 7 are added to the partition of larger values. <i class="emphasis">(e)</i> The values 1 and 8 are swapped, and the smaller partition Grows. <i class="emphasis">(f)</i> The values 3 and 8 are swapped, and the smaller partition grows. <i class="emphasis">(g)<span class="unicode">&ndash;</span>(h)</i> The larger partition grows to include 5 and 6 and the loop terminates. <i class="emphasis">(i)</i> In lines 7<span class="unicode">&ndash;</span>8, the pivot element is swapped so that it lies between the two partitions.</dt>
<dt class="lotentry">
<a href="DDU0042.html#451" target="_parent" class="chapterjump">Figure 7.2:</a> The four regions maintained by the procedure PARTITION on a subarray <i class="emphasis">A</i>[<i class="emphasis">p <span class="unicode">&#8229;</span> r</i>]. The values in <i class="emphasis">A</i>[<i class="emphasis">p <span class="unicode">&#8229;</span> i</i>] are all less than or equal to <i class="emphasis">x</i>, the values in <i class="emphasis">A</i>[<i class="emphasis">i</i> + 1 <span class="unicode">&#8229;</span> <i class="emphasis">j</i> - 1] are all greater than <i class="emphasis">x</i>, and <i class="emphasis">A</i>[<i class="emphasis">r</i>] = <i class="emphasis">x</i>. The values in <i class="emphasis">A</i>[<i class="emphasis">j <span class="unicode">&#8229;</span> r</i> - 1] can take on any values.</dt>
<dt class="lotentry">
<a href="DDU0042.html#454" target="_parent" class="chapterjump">Figure 7.3:</a> The two cases for one iteration of procedure PARTITION. <i class="emphasis">(a)</i> If <i class="emphasis">A</i>[<i class="emphasis">j</i>] <span class="unicode">&gt;</span> <i class="emphasis">x</i>, the only action is to increment <i class="emphasis">j</i>, which maintains the loop invariant. <i class="emphasis">(b)</i> If <i class="emphasis">A</i>[<i class="emphasis">j</i>] <span class="unicode">&le;</span> <i class="emphasis">x</i>, index <i class="emphasis">i</i> is incremented, <i class="emphasis">A</i>[<i class="emphasis">i</i>] and <i class="emphasis">A</i>[<i class="emphasis">j</i>] are swapped, and then <i class="emphasis">j</i> is incremented. Again, the loop invariant is maintained.</dt>
<dt class="lotentry">
<a href="DDU0043.html#466" target="_parent" class="chapterjump">Figure 7.4:</a> A recursion tree for QUICKSORT in which PARTITION always produces a 9-to-1 split, yielding a running time of <i class="emphasis">O</i>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>). Nodes show subproblem sizes, with per-level costs on the right. The per-level costs include the constant <i class="emphasis">c</i> implicit in the <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) term.</dt>
<dt class="lotentry">
<a href="DDU0043.html#469" target="_parent" class="chapterjump">Figure 7.5:</a> <i class="emphasis">(a)</i> Two levels of a recursion tree for quicksort. The partitioning at the root costs <i class="emphasis">n</i> and produces a "bad" split: two subarrays of sizes 0 and <i class="emphasis">n</i> - 1. The partitioning of the subarray of size <i class="emphasis">n</i> - 1 costs <i class="emphasis">n</i> - 1 and produces a "good" split: subarrays of size (<i class="emphasis">n</i> - 1)/2 - 1 and (<i class="emphasis">n</i> - 1)/2. <i class="emphasis">(b)</i> A single level of a recursion tree that is very well balanced. In both parts, the partitioning cost for the subproblems shown with elliptical shading is <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>). Yet the subproblems remaining to be solved in (a), shown with square shading, are no larger than the corresponding subproblems remaining to be solved in (b).</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4022"></a><a href="DDU0047.html#514" target="_parent" class="chapter-titlelabel">Chapter 8:</a> Sorting in Linear Time</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0048.html#520" target="_parent" class="chapterjump">Figure 8.1:</a> The decision tree for insertion sort operating on three elements. An internal node annotated by <i class="emphasis">i: j</i> indicates a comparison between <i class="emphasis">a<sub>i</sub></i> and <i class="emphasis">a<sub>j</sub></i>. A leaf annotated by the permutation <span class="unicode">&#12296;</span><span class="unicode">&pi;</span>(1), <span class="unicode">&pi;</span>(2), . . ., <span class="unicode">&pi;</span>(<i class="emphasis">n</i>)<span class="unicode">&#12297;</span> indicates the ordering <i class="emphasis">a</i><sub><span class="unicode">&pi;</span>(1)</sub> <span class="unicode">&le;</span> <i class="emphasis">a</i><sub><span class="unicode">&pi;</span>(2)</sub> <span class="unicode">&le;</span> <span class="unicode">&middot;</span><span class="unicode">&middot;</span><span class="unicode">&middot;</span> <i class="emphasis">a</i><sub><span class="unicode">&pi;</span>(<i class="emphasis">n</i>)</sub>. The shaded path indicates the decisions made when sorting the input sequence <span class="unicode">&#12296;</span><i class="emphasis">a</i><sub>1</sub> = 6, <i class="emphasis">a</i><sub>2</sub> = 8, <i class="emphasis">a</i><sub>3</sub> = 5<span class="unicode">&#12297;</span> the permutation <span class="unicode">&#12296;</span>3, 1, 2<span class="unicode">&#12297;</span> at the leaf indicates that the sorted ordering is <i class="emphasis">a</i><sub>3</sub> = 5 <i class="emphasis">a</i><sub>1</sub> = 6 <i class="emphasis">a</i><sub>2</sub> = 8. There are 3! = 6 possible permutations of the input elements, so the decision tree must have at least 6 leaves.</dt>
<dt class="lotentry">
<a href="DDU0049.html#532" target="_parent" class="chapterjump">Figure 8.2:</a> The operation of COUNTING-SORT on an input array <i class="emphasis">A</i>[1 <span class="unicode">&#8229;</span> 8], where each element of <i class="emphasis">A</i> is a nonnegative integer no larger than <i class="emphasis">k</i> = 5. <i class="emphasis">(a)</i> The array <i class="emphasis">A</i> and the auxiliary array <i class="emphasis">C</i> after line 4. <i class="emphasis">(b)</i> The array <i class="emphasis">C</i> after line 7. <i class="emphasis">(c)<span class="unicode">&ndash;</span>(e)</i> The output array <i class="emphasis">B</i> and the auxiliary array <i class="emphasis">C</i> after one, two, and three iterations of the loop in lines 9<span class="unicode">&ndash;</span>11, respectively. Only the lightly shaded elements of array <i class="emphasis">B</i> have been filled in. <i class="emphasis">(f)</i> The final sorted output array <i class="emphasis">B</i>.</dt>
<dt class="lotentry">
<a href="DDU0050.html#540" target="_parent" class="chapterjump">Figure 8.3:</a> The operation of radix sort on a list of seven 3-digit numbers. The leftmost column is the input. The remaining columns show the list after successive sorts on increasingly significant digit positions. Shading indicates the digit position sorted on to produce each list from the previous one.</dt>
<dt class="lotentry">
<a href="DDU0050.html#550" target="_parent" class="chapterjump">Figure 8.4:</a> The operation of BUCKET-SORT. <i class="emphasis">(a)</i> The input array <i class="emphasis">A</i>[1 <span class="unicode">&#8229;</span> 10]. <i class="emphasis">(b)</i> The array <i class="emphasis">B</i>[0 <span class="unicode">&#8229;</span> 9] of sorted lists (buckets) after line 5 of the algorithm. Bucket <i class="emphasis">i</i> holds values in the half-open interval [<i class="emphasis">i</i>/10, (<i class="emphasis">i</i> + 1)/10). The sorted output consists of a concatenation in order of the lists <i class="emphasis">B</i>[0], <i class="emphasis">B</i>[1], . . ., <i class="emphasis">B</i>[9].</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4024"></a><a href="DDU0052.html#574" target="_parent" class="chapter-titlelabel">Chapter 9:</a> Medians and Order Statistics</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0055.html#595" target="_parent" class="chapterjump">Figure 9.1:</a> Analysis of the algorithm SELECT. The <i class="emphasis">n</i> elements are represented by small circles, and each group occupies a column. The medians of the groups are whitened, and the median-of-medians <i class="emphasis">x</i> is labeled. (When finding the median of an even number of elements, we use the lower median.) Arrows are drawn from larger elements to smaller, from which it can be seen that 3 out of every full group of 5 elements to the right of <i class="emphasis">x</i> are greater than <i class="emphasis">x</i>, and 3 out of every group of 5 elements to the left of <i class="emphasis">x</i> are less than <i class="emphasis">x</i>. The elements greater than <i class="emphasis">x</i> are shown on a shaded background.</dt>
<dt class="lotentry">
<a href="DDU0055.html#608" target="_parent" class="chapterjump">Figure 9.2:</a> Professor Olay needs to determine the position of the east-west oil pipeline that minimizes the total length of the north-south spurs.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4026"></a><a href="DDU0058.html#620" target="_parent" class="chapter-titlelabel">Chapter 10:</a> Elementary Data Structures</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0058.html#624" target="_parent" class="chapterjump">Figure 10.1:</a> An array implementation of a stack <i class="emphasis">S</i>. Stack elements appear only in the lightly shaded positions. <i class="emphasis">(a)</i> Stack <i class="emphasis">S</i> has 4 elements. The top element is 9. <i class="emphasis">(b)</i> Stack <i class="emphasis">S</i> after the calls PUSH(<i class="emphasis">S</i>, 17) and PUSH(<i class="emphasis">S</i>, 3). <i class="emphasis">(c)</i> Stack <i class="emphasis">S</i> after the call POP(<i class="emphasis">S</i>) has returned the element 3, which is the one most recently pushed. Although element 3 still appears in the array, it is no longer in the stack; the top is element 17.</dt>
<dt class="lotentry">
<a href="DDU0058.html#628" target="_parent" class="chapterjump">Figure 10.2:</a> A queue implemented using an array <i class="emphasis">Q</i>[1 <span class="unicode">&#8229;</span> 12]. Queue elements appear only in the lightly shaded positions. <i class="emphasis">(a)</i> The queue has 5 elements, in locations <i class="emphasis">Q</i>[7 <span class="unicode">&#8229;</span> 11]. <i class="emphasis">(b)</i> The configuration of the queue after the calls ENQUEUE(<i class="emphasis">Q</i>, 17), ENQUEUE(<i class="emphasis">Q</i>, 3), and ENQUEUE(<i class="emphasis">Q</i>, 5). <i class="emphasis">(c)</i> The configuration of the queue after the call DEQUEUE(<i class="emphasis">Q</i>) returns the key value 15 formerly at the head of the queue. The new head has key 6.</dt>
<dt class="lotentry">
<a href="DDU0059.html#639" target="_parent" class="chapterjump">Figure 10.3:</a> <i class="emphasis">(a)</i> A doubly linked list <i class="emphasis">L</i> representing the dynamic set {1, 4, 9, 16}. Each element in the list is an object with fields for the key and pointers (shown by arrows) to the next and previous objects. The <i class="emphasis">next</i> field of the tail and the <i class="emphasis">prev</i> field of the head are NIL, indicated by a diagonal slash. The attribute <i class="emphasis">head</i>[<i class="emphasis">L</i>] points to the head. <i class="emphasis">(b)</i> Following the execution of LIST-INSERT(<i class="emphasis">L, x</i>), where <i class="emphasis">key</i>[<i class="emphasis">x</i>] = 25, the linked list has a new object with key 25 as the new head. This new object points to the old head with key 9. <i class="emphasis">(c)</i> The result of the subsequent call LIST-DELETE(<i class="emphasis">L, x</i>), where <i class="emphasis">x</i> points to the object with key 4.</dt>
<dt class="lotentry">
<a href="DDU0059.html#647" target="_parent" class="chapterjump">Figure 10.4:</a> A circular, doubly linked list with a sentinel. The sentinel <i class="emphasis">nil</i>[<i class="emphasis">L</i>] appears between the head and tail. The attribute <i class="emphasis">head</i>[<i class="emphasis">L</i>] is no longer needed, since we can access the head of the list by <i class="emphasis">next</i>[<i class="emphasis">nil</i>[<i class="emphasis">L</i>]]. <i class="emphasis">(a)</i> An empty list. <i class="emphasis">(b)</i> The linked list from Figure 10.3(a), with key 9 at the head and key 1 at the tail. <i class="emphasis">(c)</i> The list after executing LIST-INSER<span class="unicode">&prime;</span>(<i class="emphasis">L</i>, <i class="emphasis">x</i>), where <i class="emphasis">key</i>[<i class="emphasis">x</i>] = 25. The new object becomes the head of the list. <i class="emphasis">(d)</i> The list after deleting the object with key 1. The new tail is the object with key 4.</dt>
<dt class="lotentry">
<a href="DDU0060.html#660" target="_parent" class="chapterjump">Figure 10.5:</a> The linked list of Figure 10.3(a) represented by the arrays <i class="emphasis">key, next</i>, and <i class="emphasis">prev</i>. Each vertical slice of the arrays represents a single object. Stored pointers correspond to the array indices shown at the top; the arrows show how to interpret them. Lightly shaded object positions contain list elements. The variable <i class="emphasis">L</i> keeps the index of the Head.</dt>
<dt class="lotentry">
<a href="DDU0060.html#663" target="_parent" class="chapterjump">Figure 10.6:</a> The linked list of Figures 10.3(a) and 10.5 represented in a single array <i class="emphasis">A</i>. Each list element is an object that occupies a contiguous subarray of length 3 within the array. The three fields <i class="emphasis">key, next</i>, and <i class="emphasis">prev</i> correspond to the offsets 0, 1, and 2, respectively. A pointer to an object is an index of the first element of the object. Objects containing list elements are lightly shaded, and arrows show the list ordering.</dt>
<dt class="lotentry">
<a href="DDU0060.html#666" target="_parent" class="chapterjump">Figure 10.7:</a> The effect of the ALLOCATE-OBJECT and FREE-OBJECT procedures. <i class="emphasis">(a)</i> The list of Figure 10.5 (lightly shaded) and a free list (heavily shaded). Arrows show the free-list structure. <i class="emphasis">(b)</i> The result of calling ALLOCATE-OBJECT() (which returns index 4), setting <i class="emphasis">key</i>[4] to 25, and calling LIST-INSERT(<i class="emphasis">L</i>, 4). The new free-list head is object 8, which had been <i class="emphasis">next</i>[4] on the free list. <i class="emphasis">(c)</i> After executing LIST-DELETE(<i class="emphasis">L</i>, 5), we call FREE-OBJECT(5). Object 5 becomes the new free-list head, with object 8 following it on the free list.</dt>
<dt class="lotentry">
<a href="DDU0060.html#668" target="_parent" class="chapterjump">Figure 10.8:</a> Two linked lists, <i class="emphasis">L</i><sub>1</sub> (lightly shaded) and <i class="emphasis">L</i><sub>2</sub> (heavily shaded), and a free list (darkened) intertwined.</dt>
<dt class="lotentry">
<a href="DDU0061.html#678" target="_parent" class="chapterjump">Figure 10.9:</a> The representation of a binary tree <i class="emphasis">T</i>. Each node <i class="emphasis">x</i> has the fields <i class="emphasis">p</i>[<i class="emphasis">x</i>] (top), <i class="emphasis">left</i>[<i class="emphasis">x</i>] (lower left), and <i class="emphasis">right</i>[<i class="emphasis">x</i>] (lower right). The <i class="emphasis">key</i> fields are not shown.</dt>
<dt class="lotentry">
<a href="DDU0061.html#680" target="_parent" class="chapterjump">Figure 10.10:</a> The left-child, right-sibling representation of a tree <i class="emphasis">T</i> . Each node <i class="emphasis">x</i> has fields <i class="emphasis">p</i>[<i class="emphasis">x</i>] (top), <i class="emphasis">left-child</i>[<i class="emphasis">x</i>] (lower left), and <i class="emphasis">right-sibling</i>[<i class="emphasis">x</i>] (lower right). Keys are not shown.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4028"></a><a href="DDU0063.html#698" target="_parent" class="chapter-titlelabel">Chapter 11:</a> Hash Tables</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0064.html#703" target="_parent" class="chapterjump">Figure 11.1:</a> Implementing a dynamic set by a direct-address table <i class="emphasis">T</i>. Each key in the universe <i class="emphasis">U</i> = {0, 1, ..., 9} corresponds to an index in the table. The set <i class="emphasis">K</i> = {2, 3, 5, 8} of actual keys determines the slots in the table that contain pointers to elements. The other slots, heavily shaded, contain NIL.</dt>
<dt class="lotentry">
<a href="DDU0065.html#711" target="_parent" class="chapterjump">Figure 11.2:</a> Using a hash function <i class="emphasis">h</i> to map keys to hash-table slots. keys <i class="emphasis">k</i><sub>2</sub> and <i class="emphasis">k</i><sub>5</sub> map to the same slot, so they collide.</dt>
<dt class="lotentry">
<a href="DDU0065.html#714" target="_parent" class="chapterjump">Figure 11.3:</a> Collision resolution by chaining. Each hash-table slot <i class="emphasis">T</i>[<i class="emphasis">j</i>] contains a linked list of all the keys whose hash value is <i class="emphasis">j</i>. For example, <i class="emphasis">h</i>(<i class="emphasis">k</i><sub>1</sub>) = <i class="emphasis">h</i>(<i class="emphasis">k</i><sub>4</sub>) and <i class="emphasis">h</i>(<i class="emphasis">k</i><sub>5</sub>) = <i class="emphasis">h</i>(<i class="emphasis">k</i><sub>2</sub>) = <i class="emphasis">h</i>(<i class="emphasis">k</i><sub>7</sub>).</dt>
<dt class="lotentry">
<a href="DDU0066.html#732" target="_parent" class="chapterjump">Figure 11.4:</a> The multiplication method of hashing. The <i class="emphasis">w</i>-bit representation of the key <i class="emphasis">k</i> is multiplied by the <i class="emphasis">w</i>-bit value <i class="emphasis">s</i> = A <span class="unicode">&middot;</span> 2<sup><i class="emphasis">w</i></sup>. The <i class="emphasis">p</i> highest-order bits of the lower <i class="emphasis">w</i>-bit half of the product form the desired hash value <i class="emphasis">h</i>(<i class="emphasis">k</i>).</dt>
<dt class="lotentry">
<a href="DDU0067.html#758" target="_parent" class="chapterjump">Figure 11.5:</a> Insertion by double hashing. Here we have a hash table of size 13 with <i class="emphasis">h</i><sub>1</sub>(<i class="emphasis">k</i>) = <i class="emphasis">k</i> mod 13 and <i class="emphasis">h</i><sub>2</sub>(<i class="emphasis">k</i>) = 1 + (<i class="emphasis">k</i> mod 11). Since 14 <span class="unicode">&equiv;</span> 1 (mod 13) and 14 <span class="unicode">&equiv;</span> 3 (mod 11), the key 14 is inserted into empty slot 9, after slots 1 and 5 are examined and found to be occupied.</dt>
<dt class="lotentry">
<a href="DDU0068.html#774" target="_parent" class="chapterjump">Figure 11.6:</a> Using perfect hashing to store the set <i class="emphasis">K</i> = {10, 22, 37, 40, 60, 70, 75}. The outer hash function is <i class="emphasis">h</i>(<i class="emphasis">k</i>) = ((<i class="emphasis">ak</i> + <i class="emphasis">b</i>) mod <i class="emphasis">p</i>) mod <i class="emphasis">m</i>, where <i class="emphasis">a</i> = 3, <i class="emphasis">b</i> = 42, <i class="emphasis">p</i> = 101, and <i class="emphasis">m</i> = 9. For example, <i class="emphasis">h</i>(75) = 2, so key 75 hashes to slot 2 of table <i class="emphasis">T</i> . A secondary hash table <i class="emphasis">S<sub>j</sub></i> stores all keys hashing to slot <i class="emphasis">j</i> . The size of hash table <i class="emphasis">S<sub>j</sub></i> is <i class="emphasis">m<sub>j</sub></i> , and the associated hash function is <i class="emphasis">h<sub>j</sub></i> (<i class="emphasis">k</i>) = ((<i class="emphasis">a<sub>j</sub> k</i> + <i class="emphasis">b<sub>j</sub></i>) mod <i class="emphasis">p</i>) mod <i class="emphasis">m<sub>j</sub></i>. Since <i class="emphasis">h</i><sub>2</sub>(75) = 1, key 75 is stored in slot 1 of secondary hash table <i class="emphasis">S</i><sub>2</sub>. There are no collisions in any of the secondary hash tables, and so searching takes constant time in the worst case.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4030"></a><a href="DDU0070.html#793" target="_parent" class="chapter-titlelabel">Chapter 12:</a> Binary Search Trees</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0071.html#798" target="_parent" class="chapterjump">Figure 12.1:</a> Binary search trees. For any node <i class="emphasis">x</i>, the keys in the left subtree of <i class="emphasis">x</i> are at most <i class="emphasis">key</i>[<i class="emphasis">x</i>], and the keys in the right subtree of <i class="emphasis">x</i> are at least <i class="emphasis">key</i>[<i class="emphasis">x</i>]. Different binary search trees can represent the same set of values. The worst-case running time for most search-tree operations is proportional to the height of the tree. <i class="emphasis">(a)</i> A binary search tree on 6 nodes with height 2. <i class="emphasis">(b)</i> A less efficient binary search tree with height 4 that contains the same keys.</dt>
<dt class="lotentry">
<a href="DDU0072.html#809" target="_parent" class="chapterjump">Figure 12.2:</a> Queries on a binary search tree. To search for the key 13 in the tree, we follow the path 15 <span class="unicode">&rarr;</span> 6 <span class="unicode">&rarr;</span> 7 <span class="unicode">&rarr;</span> 13 from the root. The minimum key in the tree is 2, which can be found by following <i class="emphasis">left</i> pointers from the root. The maximum key 20 is found by following <i class="emphasis">right</i> pointers from the root. The successor of the node with key 15 is the node with key 17, since it is the minimum key in the right subtree of 15. The node with key 13 has no right subtree, and thus its successor is its lowest ancestor whose left child is also an ancestor. In this case, the node with key 15 is its successor.</dt>
<dt class="lotentry">
<a href="DDU0073.html#827" target="_parent" class="chapterjump">Figure 12.3:</a> Inserting an item with key 13 into a binary search tree. Lightly shaded nodes indicate the path from the root down to the position where the item is inserted. The dashed line indicates the link in the tree that is added to insert the item.</dt>
<dt class="lotentry">
<a href="DDU0073.html#830" target="_parent" class="chapterjump">Figure 12.4:</a> Deleting a node <i class="emphasis">z</i> from a binary search tree. Which node is actually removed depends on how many children <i class="emphasis">z</i> has; this node is shown lightly shaded. <i class="emphasis">(a)</i> If <i class="emphasis">z</i> has no children, we just remove it. <i class="emphasis">(b)</i> If <i class="emphasis">z</i> has only one child, we splice out <i class="emphasis">z</i>. <i class="emphasis">(c)</i> If <i class="emphasis">z</i> has two children, we splice out its successor <i class="emphasis">y</i>, which has at most one child, and then replace <i class="emphasis">z</i>'s key and satellite data with <i class="emphasis">y</i>'s key and satellite data.</dt>
<dt class="lotentry">
<a href="DDU0074.html#855" target="_parent" class="chapterjump">Figure 12.5:</a> A radix tree storing the bit strings 1011, 10, 011, 100, and 0. Each node's key can be determined by traversing the path from the root to that node. There is no need, therefore, to store the keys in the nodes; the keys are shown here for illustrative purposes only. Nodes are heavily shaded if the keys corresponding to them are not in the tree; such nodes are present only to establish a path to other nodes.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4032"></a><a href="DDU0076.html#861" target="_parent" class="chapter-titlelabel">Chapter 13:</a> Red-Black Trees</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0076.html#865" target="_parent" class="chapterjump">Figure 13.1:</a> A red-black tree with black nodes darkened and red nodes shaded. Every node in a red-black tree is either red or black, the children of a red node are both black, and every simple path from a node to a descendant leaf contains the same number of black nodes. <i class="emphasis">(a)</i> Every leaf, shown as a NIL, is black. Each non-NIL node is marked with its black-height; NIL's have black-height 0. <i class="emphasis">(b)</i> The same red-black tree but with each NIL replaced by the single sentinel <i class="emphasis">nil</i>[<i class="emphasis">T</i>], which is always black, and with black-heights omitted. The root's parent is also the sentinel. <i class="emphasis">(c)</i> The same red-black tree but with leaves and the root's parent omitted entirely. We shall use this drawing style in the remainder of this chapter.</dt>
<dt class="lotentry">
<a href="DDU0077.html#877" target="_parent" class="chapterjump">Figure 13.2:</a> The rotation operations on a binary search tree. The operation LEFT-ROTATE(<i class="emphasis">T, x</i>) transforms the configuration of the two nodes on the left into the configuration on the right by changing a constant number of pointers. The configuration on the right can be transformed into the configuration on the left by the inverse operation RIGHT-ROTATE(<i class="emphasis">T, y</i>). The letters <span class="unicode">&alpha;</span>, <span class="unicode">&beta;</span>, and <span class="unicode">&gamma;</span> represent arbitrary subtrees. A rotation operation preserves the binary-search-tree property: the keys in <span class="unicode">&alpha;</span> precede <i class="emphasis">key</i>[<i class="emphasis">x</i>], which precedes the keys in <span class="unicode">&beta;</span>, which precede <i class="emphasis">key</i>[<i class="emphasis">y</i>], which precedes the keys in <span class="unicode">&gamma;</span>.</dt>
<dt class="lotentry">
<a href="DDU0077.html#879" target="_parent" class="chapterjump">Figure 13.3:</a> An example of how the procedure LEFT-ROTATE(<i class="emphasis">T</i>, <i class="emphasis">x</i>) modifies a binary search tree. Inorder tree walks of the input tree and the modified tree produce the same listing of key values.</dt>
<dt class="lotentry">
<a href="DDU0078.html#889" target="_parent" class="chapterjump">Figure 13.4:</a> The operation of RB-INSERT-FIXUP. <i class="emphasis">(a)</i> A node <i class="emphasis">z</i> after insertion. Since <i class="emphasis">z</i> and its parent <i class="emphasis">p</i>[<i class="emphasis">z</i>] are both red, a violation of property 4 occurs. Since <i class="emphasis">z</i>'s uncle <i class="emphasis">y</i> is red, case 1 in the code can be applied. Nodes are recolored and the pointer <i class="emphasis">z</i> is moved up the tree, resulting in the tree shown in <i class="emphasis">(b)</i>. Once again, <i class="emphasis">z</i> and its parent are both red, but <i class="emphasis">z</i>'s uncle <i class="emphasis">y</i> is black. Since <i class="emphasis">z</i> is the right child of <i class="emphasis">p</i>[<i class="emphasis">z</i>], case 2 can be applied. A left rotation is performed, and the tree that results is shown in <i class="emphasis">(c)</i>. Now <i class="emphasis">z</i> is the left child of its parent, and case 3 can be applied. A right rotation yields the tree in <i class="emphasis">(d)</i>, which is a legal red-black tree.</dt>
<dt class="lotentry">
<a href="DDU0078.html#894" target="_parent" class="chapterjump">Figure 13.5:</a> Case 1 of the procedure RB-INSERT. Property 4 is violated, since <i class="emphasis">z</i> and its parent <i class="emphasis">p</i>[<i class="emphasis">z</i>] are both red. The same action is taken whether <i class="emphasis">(a)</i> <i class="emphasis">z</i> is a right child or <i class="emphasis">(b)</i> <i class="emphasis">z</i> is a left child. Each of the subtrees <span class="unicode">&alpha;</span>, <span class="unicode">&beta;</span>, <span class="unicode">&gamma;</span>, <span class="unicode">&delta;</span>, and <span class="unicode">&epsilon;</span> has a black root, and each has the same black-height. The code for case 1 changes the colors of some nodes, preserving property 5: all downward paths from a node to a leaf have the same number of blacks. The <i class="emphasis">while</i> loop continues with node <i class="emphasis">z</i>'s grandparent <i class="emphasis">p</i>[<i class="emphasis">p</i>[<i class="emphasis">z</i>]] as the new <i class="emphasis">z</i>. Any violation of property 4 can now occur only between the new <i class="emphasis">z</i>, which is red, and its parent, if it is red as well.</dt>
<dt class="lotentry">
<a href="DDU0078.html#899" target="_parent" class="chapterjump">Figure 13.6:</a> Cases 2 and 3 of the procedure RB-INSERT. As in case 1, property 4 is violated in either case 2 or case 3 because <i class="emphasis">z</i> and its parent <i class="emphasis">p</i>[<i class="emphasis">z</i>] are both red. Each of the subtrees <span class="unicode">&alpha;</span>, <span class="unicode">&beta;</span>, <span class="unicode">&gamma;</span>, and <span class="unicode">&delta;</span> has a black root (<span class="unicode">&alpha;</span>, <span class="unicode">&beta;</span>, and <span class="unicode">&gamma;</span> from property 4, and <span class="unicode">&delta;</span> because otherwise we would be in case 1), and each has the same black-height. Case 2 is transformed into case 3 by a left rotation, which preserves property 5: all downward paths from a node to a leaf have the same number of blacks. Case 3 causes some color changes and a right rotation, which also preserve property 5. The <i class="emphasis">while</i> loop then terminates, because property 4 is satisfied: there are no longer two red nodes in a row.</dt>
<dt class="lotentry">
<a href="DDU0079.html#914" target="_parent" class="chapterjump">Figure 13.7:</a> The cases in the <i class="emphasis">while</i> loop of the procedure RB-DELETE-FIXUP. Darkened nodes have <i class="emphasis">color</i> attributes BLACK, heavily shaded nodes have <i class="emphasis">color</i> attributes RED, and lightly shaded nodes have <i class="emphasis">color</i> attributes represented by <i class="emphasis">c</i> and <i class="emphasis">c<span class="unicode">&prime;</span></i>, which may be either RED or BLACK. The letters <span class="unicode">&alpha;</span>, <i class="emphasis"><span class="unicode">&beta;</span></i>, ..., <span class="unicode">&zeta;</span> represent arbitrary subtrees. In each case, the configuration on the left is transformed into the configuration on the right by changing some colors and/or performing a rotation. Any node pointed to by <i class="emphasis">x</i> has an extra black and is either doubly black or red-and-black. The only case that causes the loop to repeat is case 2. <i class="emphasis">(a)</i> Case 1 is transformed to case 2, 3, or 4 by exchanging the colors of nodes <i class="emphasis">B</i> and <i class="emphasis">D</i> and performing a left rotation. <i class="emphasis">(b)</i> In case 2, the extra black represented by the pointer <i class="emphasis">x</i> is moved up the tree by coloring node <i class="emphasis">D</i> red and setting <i class="emphasis">x</i> to point to node <i class="emphasis">B</i>. If we enter case 2 through case 1, the <i class="emphasis">while</i> loop terminates because the new node <i class="emphasis">x</i> is red-and-black, and therefore the value <i class="emphasis">c</i> of its <i class="emphasis">color</i> attribute is RED. <i class="emphasis">(c)</i> Case 3 is transformed to case 4 by exchanging the colors of nodes <i class="emphasis">C</i> and <i class="emphasis">D</i> and performing a right rotation. <i class="emphasis">(d)</i> In Case 4, the extra black represented by <i class="emphasis">x</i> can be removed by changing some colors and performing a left rotation (without violating the red-black properties), and the loop terminates.</dt>
<dt class="lotentry">
<a href="DDU0079.html#930" target="_parent" class="chapterjump">Figure 13.8:</a> <i class="emphasis">(a)</i> A binary search tree with keys 2, 3, 4, 7, 8, 10. <i class="emphasis">(b)</i> The persistent binary search tree that results from the insertion of key 5. The most recent version of the set consists of the nodes reachable from the root <i class="emphasis">r<span class="unicode">&prime;</span></i>, and the previous version consists of the nodes reachable from <i class="emphasis">r</i>. Heavily shaded nodes are added when key 5 is inserted.</dt>
<dt class="lotentry">
<a href="DDU0079.html#937" target="_parent" class="chapterjump">Figure 13.9:</a> A treap. Each node <i class="emphasis">x</i> is labeled with <i class="emphasis">key</i>[<i class="emphasis">x</i>] : <i class="emphasis">Priority</i>[<i class="emphasis">x</i>]. For example, the root has key <i class="emphasis">G</i> and priority 4.</dt>
<dt class="lotentry">
<a href="DDU0079.html#939" target="_parent" class="chapterjump">Figure 13.10:</a> The operation of TREAP-INSERT. <i class="emphasis">(a)</i> The original treap, prior to insertion. <i class="emphasis">(b)</i> The treap after inserting a node with key <i class="emphasis">C</i> and priority 25. <i class="emphasis">(c)<span class="unicode">&ndash;</span>(d)</i> Intermediate stages when inserting a node with key <i class="emphasis">D</i> and priority 9. <i class="emphasis">(e)</i> The treap after the insertion of parts (c) and (d) is done. <i class="emphasis">(f)</i> The treap after inserting a node with key <i class="emphasis">F</i> and priority 2.</dt>
<dt class="lotentry">
<a href="DDU0079.html#940" target="_parent" class="chapterjump">Figure 13.11:</a> Spines of a binary search tree. The left spine is shaded in <i class="emphasis">(a)</i>, and the right spine is shaded in <i class="emphasis">(b)</i>.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4034"></a><a href="DDU0081.html#945" target="_parent" class="chapter-titlelabel">Chapter 14:</a> Augmenting Data Structures</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0081.html#949" target="_parent" class="chapterjump">Figure 14.1:</a> An order-statistic tree, which is an augmented red-black tree. Shaded nodes are red, and darkened nodes are black. In addition to its usual fields, each node <i class="emphasis">x</i> has a field <i class="emphasis">size</i>[<i class="emphasis">x</i>], which is the number of nodes in the subtree rooted at <i class="emphasis">x</i>.</dt>
<dt class="lotentry">
<a href="DDU0081.html#956" target="_parent" class="chapterjump">Figure 14.2:</a> Updating subtree sizes during rotations. The link around which the rotation is performed is incident on the two nodes whose <i class="emphasis">size</i> fields need to be updated. The updates are local, requiring only the <i class="emphasis">size</i> information stored in <i class="emphasis">x, y</i>, and the roots of the subtrees shown as triangles.</dt>
<dt class="lotentry">
<a href="DDU0083.html#979" target="_parent" class="chapterjump">Figure 14.3:</a> The interval trichotomy for two closed intervals <i class="emphasis">i</i> and <i class="emphasis">i</i>'. <i class="emphasis">(a)</i> If <i class="emphasis">i</i> and <i class="emphasis">i</i>' overlap, there are four situations; in each, <i class="emphasis">low</i>[<i class="emphasis">i</i>] <span class="unicode">&le;</span> <i class="emphasis">high</i>[<i class="emphasis">i</i>'] and <i class="emphasis">low</i>[<i class="emphasis">i</i>'] <span class="unicode">&le;</span> <i class="emphasis">high</i>[<i class="emphasis">i</i>]. <i class="emphasis">(b)</i> The intervals do not overlap, and <i class="emphasis">high</i>[<i class="emphasis">i</i>]<span class="unicode">&lt;</span> <i class="emphasis">low</i>[<i class="emphasis">i</i>']. <i class="emphasis">(c)</i> The intervals do not overlap, and <i class="emphasis">high</i>[<i class="emphasis">i</i>']<span class="unicode">&lt;</span> <i class="emphasis">low</i>[<i class="emphasis">i</i>].</dt>
<dt class="lotentry">
<a href="DDU0083.html#981" target="_parent" class="chapterjump">Figure 14.4:</a> An interval tree. <i class="emphasis">(a)</i> A set of 10 intervals, shown sorted bottom to top by left endpoint. <i class="emphasis">(b)</i> The interval tree that represents them. An inorder tree walk of the tree lists the nodes in sorted order by left endpoint.</dt>
<dt class="lotentry">
<a href="DDU0083.html#989" target="_parent" class="chapterjump">Figure 14.5:</a> Intervals in the proof of Theorem 14.2. The value of <i class="emphasis">max</i>[<i class="emphasis">left</i>[<i class="emphasis">x</i>]] is shown in each case as a dashed line. <i class="emphasis">(a)</i> The search goes right. No interval <i class="emphasis">i</i>' in <i class="emphasis">x</i>'s left subtree can overlap <i class="emphasis">i</i>. <i class="emphasis">(b)</i> The search goes left. The left subtree of <i class="emphasis">x</i> contains an interval that overlaps <i class="emphasis">i</i> (situation not shown), or there is an interval <i class="emphasis">i</i>' in <i class="emphasis">x</i>'s left subtree such that <i class="emphasis">high</i>[<i class="emphasis">i</i>'] = <i class="emphasis">max</i>[<i class="emphasis">left</i>[<i class="emphasis">x</i>]]. Since <i class="emphasis">i</i> does not overlap <i class="emphasis">i</i>', neither does it overlap any interval <i class="emphasis">i</i>" in <i class="emphasis">x</i>'s right subtree, since <i class="emphasis">low</i>[<i class="emphasis">i</i>'] <span class="unicode">&le;</span> <i class="emphasis">low</i>[<i class="emphasis">i</i>"].</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4036"></a><a href="DDU0086.html#1007" target="_parent" class="chapter-titlelabel">Chapter 15:</a> Dynamic Programming</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0087.html#1012" target="_parent" class="chapterjump">Figure 15.1:</a> A manufacturing problem to find the fastest way through a factory. There are two assembly lines, each with <i class="emphasis">n</i> stations; the <i class="emphasis">j</i>th station on line <i class="emphasis">i</i> is denoted <i class="emphasis">S<sub>i,j</sub></i> and the assembly time at that station is <i class="emphasis">a<sub>i,j</sub></i>. An automobile chassis enters the factory, and goes onto line <i class="emphasis">i</i> (where <i class="emphasis">i</i> = 1 or 2), taking <i class="emphasis">e<sub>i</sub></i> time. After going through the <i class="emphasis">j</i>th station on a line, the chassis goes on to the (<i class="emphasis">j</i> + 1)st station on either line. There is no transfer cost if it stays on the same line, but it takes time <i class="emphasis">t<sub>i,j</sub></i> to transfer to the other line after station <i class="emphasis">S<sub>i,j</sub></i>. After exiting the <i class="emphasis">n</i>th station on a line, it takes <i class="emphasis">x<sub>i</sub></i> time for the completed auto to exit the factory. The problem is to determine which stations to choose from line 1 and which to choose from line 2 in order to minimize the total time through the factory for one auto.</dt>
<dt class="lotentry">
<a href="DDU0087.html#1014" target="_parent" class="chapterjump">Figure 15.2:</a> <i class="emphasis">(a)</i> An instance of the assembly-line problem with costs <i class="emphasis">e<sub>i</sub></i>, <i class="emphasis">a<sub>i,j</sub>, t<sub>i,j</sub></i>, and <i class="emphasis">x<sub>i</sub></i> indicated. The heavily shaded path indicates the fastest way through the factory. <i class="emphasis">(b)</i> The values of <i class="emphasis">f<sub>i</sub></i>[<i class="emphasis">j</i>], <i class="emphasis">f</i>*, <i class="emphasis">l<sub>i</sub></i>[<i class="emphasis">j</i>], and <i class="emphasis">l</i>* for the instance in part (a).</dt>
<dt class="lotentry">
<a href="DDU0088.html#1052" target="_parent" class="chapterjump">Figure 15.3:</a> The <i class="emphasis">m</i> and <i class="emphasis">s</i> tables computed by MATRIX-CHAIN-ORDER for <i class="emphasis">n</i> = 6 and the following matrix dimensions:</dt>
<dt class="lotentry">
<a href="DDU0089.html#1067" target="_parent" class="chapterjump">Figure 15.4:</a> A directed graph showing that the problem of finding a longest simple path in an unweighted directed graph does not have optimal substructure. The path <i class="emphasis">q</i> <span class="unicode">&rarr;</span> <i class="emphasis">r</i> <span class="unicode">&rarr;</span> <i class="emphasis">t</i> is a longest simple path from <i class="emphasis">q</i> to <i class="emphasis">t</i>, but the subpath <i class="emphasis">q</i> <span class="unicode">&rarr;</span> <i class="emphasis">r</i> is not a longest simple path from <i class="emphasis">q</i> to <i class="emphasis">r</i>, nor is the subpath <i class="emphasis">r</i> <span class="unicode">&rarr;</span> <i class="emphasis">t</i> a longest simple path from <i class="emphasis">r</i> to <i class="emphasis">t</i>.</dt>
<dt class="lotentry">
<a href="DDU0089.html#1072" target="_parent" class="chapterjump">Figure 15.5:</a> The recursion tree for the computation of RECURSIVE-MATRIX-CHAIN(<i class="emphasis">p</i>, 1, 4). Each node contains the parameters <i class="emphasis">i</i> and <i class="emphasis">j</i>. The computations performed in a shaded subtree are replaced by a single table lookup in MEMOIZED-MATRIX-CHAIN(<i class="emphasis">p</i>, 1, 4).</dt>
<dt class="lotentry">
<a href="DDU0090.html#1094" target="_parent" class="chapterjump">Figure 15.6:</a> The <i class="emphasis">c</i> and <i class="emphasis">b</i> tables computed by LCS-LENGTH on the sequences <i class="emphasis">X</i> = <i class="emphasis"><span class="unicode">&#12296;</span>A, B, C, B, D, A, B<span class="unicode">&#12297;</span></i> and <i class="emphasis">Y</i> = <i class="emphasis"><span class="unicode">&#12296;</span>B, D, C, A, B, A<span class="unicode">&#12297;</span></i>. The square in row <i class="emphasis">i</i> and column <i class="emphasis">j</i> contains the value of <i class="emphasis">c</i>[<i class="emphasis">i, j</i>] and the appropriate arrow for the value of <i class="emphasis">b</i>[<i class="emphasis">i, j</i>]. The entry 4 in <i class="emphasis">c</i>[7, 6]<span class="unicode">&mdash;</span>the lower right-hand corner of the table<span class="unicode">&mdash;</span>is the length of an LCS <a name="4038"></a><i class="emphasis"><span class="unicode">&#12296;</span>B, C, B, A<span class="unicode">&#12297;</span></i> of <i class="emphasis">X</i> and <i class="emphasis">Y</i> . For <i class="emphasis">i, j</i> <span class="unicode">&gt;</span> 0, entry <i class="emphasis">c</i>[<i class="emphasis">i, j</i>] depends only on whether <i class="emphasis">x<sub>i</sub></i> = <i class="emphasis">y<sub>j</sub></i> and the values in entries <i class="emphasis">c</i>[<i class="emphasis">i</i> - 1, <i class="emphasis">j</i>], <i class="emphasis">c</i>[<i class="emphasis">i, j</i> - 1], and <i class="emphasis">c</i>[<i class="emphasis">i</i> - 1, <i class="emphasis">j</i> - 1], which are computed before <i class="emphasis">c</i>[<i class="emphasis">i, j</i>]. To reconstruct the elements of an LCS, follow the <i class="emphasis">b</i>[<i class="emphasis">i, j</i>] arrows from the lower right-hand corner; the path is shaded. Each "<span class="unicode">&#8598;</span>" on the path corresponds to an entry (highlighted) for which <i class="emphasis">x<sub>i</sub></i> = <i class="emphasis">y<sub>j</sub></i> is a member of an LCS.</dt>
<dt class="lotentry">
<a href="DDU0091.html#1107" target="_parent" class="chapterjump">Figure 15.7:</a> Two Binary Search Trees for a Set of <i class="emphasis">n</i> = 5 Keys with the Following Probabilities:</dt>
<dt class="lotentry">
<a href="DDU0091.html#1122" target="_parent" class="chapterjump">Figure 15.8:</a> The tables <i class="emphasis">e</i>[<i class="emphasis">i, j</i>], w[<i class="emphasis">i, j</i>], and <i class="emphasis">root</i>[<i class="emphasis">i, j</i>] computed by OPTIMAL-BST on the key distribution shown in Figure 15.7. The tables are rotated so that the diagonals run horizontally.</dt>
<dt class="lotentry">
<a href="DDU0091.html#1130" target="_parent" class="chapterjump">Figure 15.9:</a> Seven points in the plane, shown on a unit grid. <i class="emphasis">(a)</i> The shortest closed tour, with length approximately 24.89. This tour is not bitonic. <i class="emphasis">(b)</i> The shortest bitonic tour for the same set of points. Its length is approximately 25.58.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4039"></a><a href="DDU0093.html#1143" target="_parent" class="chapter-titlelabel">Chapter 16:</a> Greedy Algorithms</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0094.html#1161" target="_parent" class="chapterjump">Figure 16.1:</a> The operation of RECURSIVE-ACTIVITY-SELECTOR on the 11 activities given earlier. Activities considered in each recursive call appear between horizontal lines. The fictitious activity <i class="emphasis">a</i><sub>0</sub> finishes at time 0, and in the initial call, RECURSIVE-ACTIVITY-SELECTOR(<i class="emphasis">s, f</i>, 0, 12), activity <i class="emphasis">a</i><sub>1</sub> is selected. In each recursive call, the activities that have already been selected are shaded, and the activity shown in white is being considered. If the starting time of an activity occurs before the finish time of the most recently added activity (the arrow between them points left), it is rejected. Otherwise (the arrow points directly up or to the right), it is selected. The last recursive call, RECURSIVE-ACTIVITY-SELECTOR(<i class="emphasis">s, f</i>, 11, 12), returns <span class="unicode">&Oslash;</span>. The resulting set of selected activities is {<i class="emphasis">a</i><sub>1</sub>, <i class="emphasis">a</i><sub>4</sub>, <i class="emphasis">a</i><sub>8</sub>, <i class="emphasis">a</i><sub>11</sub>}.</dt>
<dt class="lotentry">
<a href="DDU0095.html#1179" target="_parent" class="chapterjump">Figure 16.2:</a> The greedy strategy does not work for the 0<span class="unicode">&ndash;</span>1 knapsack problem. <i class="emphasis">(a)</i> The thief must select a subset of the three items shown whose weight must not exceed 50 pounds. <i class="emphasis">(b)</i> The optimal subset includes items 2 and 3. Any solution with item 1 is suboptimal, even though item 1 has the greatest value per pound. <i class="emphasis">(c)</i> For the fractional knapsack problem, taking the items in order of greatest value per pound yields an optimal solution.</dt>
<dt class="lotentry">
<a href="DDU0096.html#1190" target="_parent" class="chapterjump">Figure 16.3:</a> A character-coding problem. A data file of 100,000 characters contains only the characters <span class="fixed">a<span class="unicode">&ndash;</span>f</span>, with the frequencies indicated. If each character is assigned a 3-bit codeword, the file can be encoded in 300,000 bits. Using the variable-length code shown, the file can be encoded in 224,000 bits.</dt>
<dt class="lotentry">
<a href="DDU0096.html#1193" target="_parent" class="chapterjump">Figure 16.4:</a> Trees corresponding to the coding schemes in Figure 16.3. Each leaf is labeled with a character and its frequency of occurrence. Each internal node is labeled with the sum of the frequencies of the leaves in its subtree. <i class="emphasis">(a)</i> The tree corresponding to the fixed-length code <span class="fixed">a</span> = 000, ..., <span class="fixed">f</span> = 101. <i class="emphasis">(b)</i> The tree corresponding to the optimal prefix code <span class="fixed">a</span> = 0, <span class="fixed">b</span> = 101, ..., <span class="fixed">f</span> = 1100.</dt>
<dt class="lotentry">
<a href="DDU0096.html#1198" target="_parent" class="chapterjump">Figure 16.5:</a> The steps of Huffman's algorithm for the frequencies given in Figure 16.3. Each part shows the contents of the queue sorted into increasing order by frequency. At each step, the two trees with lowest frequencies are merged. Leaves are shown as rectangles containing a character and its frequency. Internal nodes are shown as circles containing the sum of the frequencies of its children. An edge connecting an internal node with its children is labeled 0 if it is an edge to a left child and 1 if it is an edge to a right child. The codeword for a letter is the sequence of labels on the edges connecting the root to the leaf for that letter. <i class="emphasis">(a)</i> The initial set of <i class="emphasis">n</i> = 6 nodes, one for each letter. <i class="emphasis">(b)</i><span class="unicode">&ndash;</span><i class="emphasis">(e)</i> Intermediate stages. <i class="emphasis">(f)</i> The final tree.</dt>
<dt class="lotentry">
<a href="DDU0096.html#1203" target="_parent" class="chapterjump">Figure 16.6:</a> An illustration of the key step in the proof of Lemma 16.2. In the optimal tree <i class="emphasis">T</i>, leaves <i class="emphasis">a</i> and <i class="emphasis">b</i> are two of the deepest leaves and are siblings. Leaves <i class="emphasis">x</i> and <i class="emphasis">y</i> are the two leaves that Huffman's algorithm merges together first; they appear in arbitrary positions in <i class="emphasis">T</i> . Leaves <i class="emphasis">a</i> and <i class="emphasis">x</i> are swapped to obtain tree <i class="emphasis">T</i><span class="unicode">&prime;</span>. Then, leaves <i class="emphasis">b</i> and <i class="emphasis">y</i> are swapped to obtain tree <i class="emphasis">T</i><span class="unicode">&Prime;</span>. Since each swap does not increase the cost, the resulting tree <i class="emphasis">T</i><span class="unicode">&Prime;</span> is also an optimal tree.</dt>
<dt class="lotentry">
<a href="DDU0098.html#1239" target="_parent" class="chapterjump">Figure 16.7:</a> An instance of the problem of scheduling unit-time tasks with deadlines and penalties for a single processor.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4041"></a><a href="DDU0100.html#1250" target="_parent" class="chapter-titlelabel">Chapter 17:</a> Amortized Analysis</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0101.html#1256" target="_parent" class="chapterjump">Figure 17.1:</a> The action of MULTIPOP on a stack <i class="emphasis">S</i>, shown initially in <i class="emphasis">(a)</i>. The top 4 objects are popped by MULTIPOP(<i class="emphasis">S</i>, 4), whose result is shown in <i class="emphasis">(b)</i>. The next operation is MULTIPOP(<i class="emphasis">S</i>, 7), which empties the stack<span class="unicode">&mdash;</span>shown in <i class="emphasis">(c)</i><span class="unicode">&mdash;</span>since there were fewer than 7 objects remaining.</dt>
<dt class="lotentry">
<a href="DDU0101.html#1260" target="_parent" class="chapterjump">Figure 17.2:</a> An 8-bit binary counter as its value goes from 0 to 16 by a sequence of 16 INCREMENT operations. Bits that flip to achieve the next value are shaded. The running cost for flipping bits is shown at the right. Notice that the total cost is never more than twice the total number of INCREMENT operations.</dt>
<dt class="lotentry">
<a href="DDU0104.html#1297" target="_parent" class="chapterjump">Figure 17.3:</a> The effect of a sequence of <i class="emphasis">n</i> TABLE-INSERT operations on the number <i class="emphasis">num<sub>i</sub></i> of items in the table, the number <i class="emphasis">size<sub>i</sub></i> of slots in the table, and the potential <span class="unicode">&Phi;</span><i class="emphasis"><sub>i</sub></i> = 2<span class="unicode">&middot;</span><i class="emphasis">num<sub>i</sub></i> - <i class="emphasis">size<sub>i</sub></i>, each being measured after the <i class="emphasis">i</i>th operation. The thin line shows <i class="emphasis">num<sub>i</sub></i>, the dashed line shows <i class="emphasis">size<sub>i</sub></i>, and the thick line shows <span class="unicode">&Phi;</span><i class="emphasis"><sub>i</sub></i>. Notice that immediately before an expansion, the potential has built up to the number of items in the table, and therefore it can pay for moving all the items to the new table. Afterwards, the potential drops to 0, but it is immediately increased by 2 when the item that caused the expansion is inserted.</dt>
<dt class="lotentry">
<a href="DDU0104.html#1302" target="_parent" class="chapterjump">Figure 17.4:</a> The effect of a sequence of <i class="emphasis">n</i> TABLE-INSERT and TABLE-DELETE operations on the number <i class="emphasis">num<sub>i</sub></i> of items in the table, the number <i class="emphasis">size<sub>i</sub></i> of slots in the table, and the potential <span class="inlinemediaobject"><img src="images/fig445_02.jpg" height="31" width="188" alt="" border="0"></span> each being measured after the <i class="emphasis">i</i>th operation. The thin line shows <i class="emphasis">num<sub>i</sub></i>, the dashed line shows <i class="emphasis">size<sub>i</sub></i>, and the thick line shows <span class="unicode">&Phi;</span><sub><i class="emphasis">i</i></sub>. Notice that immediately before an expansion, the potential has built up to the number of items in the table, and therefore it can pay for moving all the items to the new table. Likewise, immediately before a contraction, the potential has built up to the number of items in the table.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4043"></a><a href="DDU0107.html#1323" target="_parent" class="chapter-titlelabel">Chapter 18:</a> B-Trees</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0107.html#1326" target="_parent" class="chapterjump">Figure 18.1:</a> A B-tree whose keys are the consonants of English. An internal node <i class="emphasis">x</i> containing <i class="emphasis">n</i>[<i class="emphasis">x</i>] keys has <i class="emphasis">n</i>[<i class="emphasis">x</i>] + 1 children. All leaves are at the same depth in the tree. The lightly shaded nodes are examined in a search for the letter <i class="emphasis">R</i>.</dt>
<dt class="lotentry">
<a href="DDU0108.html#1329" target="_parent" class="chapterjump">Figure 18.2:</a> <i class="emphasis">(a)</i> A typical disk drive. It is composed of several platters that rotate around a spindle. Each platter is read and written with a head at the end of an arm. The arms are ganged together so that they move their heads in unison. Here, the arms rotate around a common pivot axis. A track is the surface that passes beneath the read/write head when it is stationary. <i class="emphasis">(b)</i> A cylinder consists of a set of covertical tracks.</dt>
<dt class="lotentry">
<a href="DDU0108.html#1332" target="_parent" class="chapterjump">Figure 18.3:</a> A B-tree of height 2 containing over one billion keys. Each internal node and leaf contains 1000 keys. There are 1001 nodes at depth 1 and over one million leaves at depth 2. Shown inside each node <i class="emphasis">x</i> is <i class="emphasis">n</i>[<i class="emphasis">x</i>], the number of keys in <i class="emphasis">x</i>.</dt>
<dt class="lotentry">
<a href="DDU0109.html#1338" target="_parent" class="chapterjump">Figure 18.4:</a> A B-tree of height 3 containing a minimum possible number of keys. Shown inside each node <i class="emphasis">x</i> is <i class="emphasis">n</i>[<i class="emphasis">x</i>].</dt>
<dt class="lotentry">
<a href="DDU0110.html#1351" target="_parent" class="chapterjump">Figure 18.5:</a> Splitting a node with <i class="emphasis">t</i> = 4. Node <i class="emphasis">y</i> is split into two nodes, <i class="emphasis">y</i> and <i class="emphasis">z</i>, and the median key <i class="emphasis">S</i> of <i class="emphasis">y</i> is moved up into <i class="emphasis">y</i>'s parent.</dt>
<dt class="lotentry">
<a href="DDU0110.html#1354" target="_parent" class="chapterjump">Figure 18.6:</a> Splitting the root with <i class="emphasis">t</i> = 4. Root node <i class="emphasis">r</i> is split in two, and a new root node <i class="emphasis">s</i> is created. The new root contains the median key of <i class="emphasis">r</i> and has the two halves of <i class="emphasis">r</i> as children. The B-tree grows in height by one when the root is split.</dt>
<dt class="lotentry">
<a href="DDU0110.html#1357" target="_parent" class="chapterjump">Figure 18.7:</a> Inserting keys into a B-tree. The minimum degree <i class="emphasis">t</i> for this B-tree is 3, so a node can hold at most 5 keys. Nodes that are modified by the insertion process are lightly shaded. <i class="emphasis">(a)</i> The initial tree for this example. <i class="emphasis">(b)</i> The result of inserting <i class="emphasis">B</i> into the initial tree; this is a simple insertion into a leaf node. <i class="emphasis">(c)</i> The result of inserting <i class="emphasis">Q</i> into the previous tree. The node <i class="emphasis">RSTUV</i> is split into two nodes containing <i class="emphasis">RS</i> and <i class="emphasis">UV</i>, the key <i class="emphasis">T</i> is moved up to the root, and <i class="emphasis">Q</i> is inserted in the leftmost of the two halves (the <i class="emphasis">RS</i> node). <i class="emphasis">(d)</i> The result of inserting <i class="emphasis">L</i> into the previous tree. The root is split right away, since it is full, and the B-tree grows in height by one. Then <i class="emphasis">L</i> is inserted into the leaf containing <i class="emphasis">JK</i>. <i class="emphasis">(e)</i> The result of inserting <i class="emphasis">F</i> into the previous tree. The node <i class="emphasis">ABCDE</i> is split before <i class="emphasis">F</i> is inserted into the rightmost of the two halves (the <i class="emphasis">DE</i> node).</dt>
<dt class="lotentry">
<a href="DDU0111.html#1370" target="_parent" class="chapterjump">Figure 18.8:</a> Deleting keys from a B-tree. The minimum degree for this B-tree is <i class="emphasis">t</i> = 3, so a node (other than the root) cannot have fewer than 2 keys. Nodes that are modified are lightly shaded. <i class="emphasis">(a)</i> The B-tree of Figure 18.7(e). <i class="emphasis">(b)</i> Deletion of <i class="emphasis">F</i>. This is case 1: simple deletion from a leaf. <i class="emphasis">(c)</i> Deletion of <i class="emphasis">M</i>. This is case 2a: the predecessor <i class="emphasis">L</i> of <i class="emphasis">M</i> is moved up to take <i class="emphasis">M</i>'s position. <i class="emphasis">(d)</i> Deletion of <i class="emphasis">G</i>. This is case 2c: <i class="emphasis">G</i> is pushed down to make node <i class="emphasis">DEGJK</i>, and then <i class="emphasis">G</i> is deleted from this leaf (case 1). <i class="emphasis">(e)</i> Deletion of <i class="emphasis">D</i>. This is case 3b: the recursion can't descend to node <i class="emphasis">CL</i> because it has only 2 keys, so <i class="emphasis">P</i> is pushed down and merged with <i class="emphasis">CL</i> and <i class="emphasis">TX</i> to form <i class="emphasis">CLPTX</i>; then, <i class="emphasis">D</i> is deleted from a leaf (case 1). <i class="emphasis">(e<span class="unicode">&prime;</span>)</i> After (d), the root is deleted and the tree shrinks in height by one. <i class="emphasis">(f)</i> Deletion of <i class="emphasis">B</i>. This is case 3a: <i class="emphasis">C</i> is moved to fill <i class="emphasis">B</i>'s position and <i class="emphasis">E</i> is moved to fill <i class="emphasis">C</i>'s position.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4045"></a><a href="DDU0113.html#1379" target="_parent" class="chapter-titlelabel">Chapter 19:</a> Binomial Heaps</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0113.html#1382" target="_parent" class="chapterjump">Figure 19.1:</a> Running times for operations on three implementations of mergeable heaps. The number of items in the heap(s) at the time of an operation is denoted by <i class="emphasis">n</i>.</dt>
<dt class="lotentry">
<a href="DDU0114.html#1387" target="_parent" class="chapterjump">Figure 19.2:</a> <i class="emphasis">(a)</i> The recursive definition of the binomial tree <i class="emphasis">B<sub>k</sub></i>. Triangles represent rooted subtrees. <i class="emphasis">(b)</i> The binomial trees <i class="emphasis">B</i><sub>0</sub> through <i class="emphasis">B</i><sub>4</sub>. Node depths in <i class="emphasis">B</i><sub>4</sub> are shown. <i class="emphasis">(c)</i> Another way of looking at the binomial tree <i class="emphasis">B<sub>k</sub></i>.</dt>
<dt class="lotentry">
<a href="DDU0114.html#1393" target="_parent" class="chapterjump">Figure 19.3:</a> A binomial heap <i class="emphasis">H</i> with <i class="emphasis">n</i> = 13 nodes. <i class="emphasis">(a)</i> The heap consists of binomial trees <i class="emphasis">B</i><sub>0</sub>, <i class="emphasis">B</i><sub>2</sub>, and <i class="emphasis">B</i><sub>3</sub>, which have 1, 4, and 8 nodes respectively, totaling <i class="emphasis">n</i> = 13 nodes. Since each binomial tree is min-heap-ordered, the key of any node is no less than the key of its parent. Also shown is the root list, which is a linked list of roots in order of increasing degree. <i class="emphasis">(b)</i> A more detailed representation of binomial heap <i class="emphasis">H</i> . Each binomial tree is stored in the left-child, right-sibling representation, and each node stores its degree.</dt>
<dt class="lotentry">
<a href="DDU0114.html#1399" target="_parent" class="chapterjump">Figure 19.4:</a> The binomial tree <i class="emphasis">B</i><sub>4</sub> with nodes labeled in binary by a postorder walk.</dt>
<dt class="lotentry">
<a href="DDU0115.html#1406" target="_parent" class="chapterjump">Figure 19.5:</a> The execution of BINOMIAL-HEAP-UNION. <i class="emphasis">(a)</i> Binomial heaps <i class="emphasis">H</i><sub>1</sub> and <i class="emphasis">H</i><sub>2</sub>. <i class="emphasis">(b)</i> Binomial heap <i class="emphasis">H</i> is the output of BINOMIAL-HEAP-MERGE(<i class="emphasis">H</i><sub>1</sub>, <i class="emphasis">H</i><sub>2</sub>). Initially, <i class="emphasis">x</i> is the first root on the root list of <i class="emphasis">H</i> . Because both <i class="emphasis">x</i> and <i class="emphasis">next-x</i> have degree 0 and <i class="emphasis">key</i>[<i class="emphasis">x</i>] <span class="unicode">&lt;</span> <i class="emphasis">key</i>[<i class="emphasis">next-x</i>], case 3 applies. <i class="emphasis">(c)</i> After the link occurs, <i class="emphasis">x</i> is the first of three roots with the same degree, so case 2 applies. <i class="emphasis">(d)</i> After all the pointers move down one position in the root list, case 4 applies, since <i class="emphasis">x</i> is the first of two roots of equal degree. <i class="emphasis">(e)</i> After the link occurs, case 3 applies. <i class="emphasis">(f)</i> After another link, case 1 applies, because <i class="emphasis">x</i> has degree 3 and <i class="emphasis">next-x</i> has degree 4. This iteration of the <i class="emphasis">while</i> loop is the last, because after the pointers move down one position in the root list, <i class="emphasis">next-x</i> = NIL.</dt>
<dt class="lotentry">
<a href="DDU0115.html#1410" target="_parent" class="chapterjump">Figure 19.6:</a> The four cases that occur in BINOMIAL-HEAP-UNION. Labels <i class="emphasis">a, b, c</i>, and <i class="emphasis">d</i> serve only to identify the roots involved; they do not indicate the degrees or keys of these roots. In each case, <i class="emphasis">x</i> is the root of a <i class="emphasis">B<sub>k</sub></i>-tree and <i class="emphasis">l</i> <span class="unicode">&gt;</span> <i class="emphasis">k</i>. <i class="emphasis">(a)</i> Case 1: <i class="emphasis">degree</i>[<i class="emphasis">x</i>] <span class="unicode">&ne;</span> <i class="emphasis">degree</i>[<i class="emphasis">next-x</i>]. The pointers move one position farther down the root list. <i class="emphasis">(b)</i> Case 2: <i class="emphasis">degree</i>[<i class="emphasis">x</i>] = <i class="emphasis">degree</i>[<i class="emphasis">next-x</i>] = <i class="emphasis">degree</i>[<i class="emphasis">sibling</i>[<i class="emphasis">next-x</i>]]. Again, the pointers move one position farther down the list, and the next iteration executes either case 3 or case 4. <i class="emphasis">(c)</i> Case 3: <i class="emphasis">degree</i>[<i class="emphasis">x</i>] = <i class="emphasis">degree</i>[<i class="emphasis">next-x</i>] <span class="unicode">&ne;</span> <i class="emphasis">degree</i>[<i class="emphasis">sibling</i>[<i class="emphasis">next-x</i>]] and <i class="emphasis">key</i>[<i class="emphasis">x</i>] <span class="unicode">&le;</span> <i class="emphasis">key</i>[<i class="emphasis">next-x</i>]. We remove <i class="emphasis">next-x</i> from the root list and link it to <i class="emphasis">x</i>, creating a <i class="emphasis">B</i><sub><i class="emphasis">k</i>+1</sub>-tree. <i class="emphasis">(d)</i> Case 4: <i class="emphasis">degree</i>[<i class="emphasis">x</i>] = <i class="emphasis">degree</i>[<i class="emphasis">next-x</i>] <span class="unicode">&ne;</span> <i class="emphasis">degree</i>[<i class="emphasis">sibling</i>[<i class="emphasis">next-x</i>]] and <i class="emphasis">key</i>[<i class="emphasis">next-x</i>] <span class="unicode">&le;</span> <i class="emphasis">key</i>[<i class="emphasis">x</i>]. We remove <i class="emphasis">x</i> from the root list and link it to <i class="emphasis">next-x</i>, again creating a <i class="emphasis">B</i><sub><i class="emphasis">k</i>+1</sub>-tree.</dt>
<dt class="lotentry">
<a href="DDU0115.html#1416" target="_parent" class="chapterjump">Figure 19.7:</a> The action of BINOMIAL-HEAP-EXTRACT-MIN. <i class="emphasis">(a)</i> A binomial heap <i class="emphasis">H</i>. <i class="emphasis">(b)</i> The root <i class="emphasis">x</i> with minimum key is removed from the root list of <i class="emphasis">H</i> . <i class="emphasis">(c)</i> The linked list of <i class="emphasis">x</i>'s children is reversed, giving another binomial heap <i class="emphasis">H</i><span class="unicode">&prime;</span>. <i class="emphasis">(d)</i> The result of uniting <i class="emphasis">H</i> and <i class="emphasis">H'</i>.</dt>
<dt class="lotentry">
<a href="DDU0115.html#1419" target="_parent" class="chapterjump">Figure 19.8:</a> The action of BINOMIAL-HEAP-DECREASE-KEY. <i class="emphasis">(a)</i> The situation just before line 6 of the first iteration of the <i class="emphasis">while</i> loop. Node <i class="emphasis">y</i> has had its key decreased to 7, which is less than the key of <i class="emphasis">y</i>'s parent <i class="emphasis">z</i>. <i class="emphasis">(b)</i> The keys of the two nodes are exchanged, and the situation just before line 6 of the second iteration is shown. Pointers <i class="emphasis">y</i> and <i class="emphasis">z</i> have moved up one level in the tree, but min-heap order is still violated. <i class="emphasis">(c)</i> After another exchange and moving pointers <i class="emphasis">y</i> and <i class="emphasis">z</i> up one more level, we find that min-heap order is satisfied, so the <i class="emphasis">while</i> loop terminates.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4047"></a><a href="DDU0117.html#1439" target="_parent" class="chapter-titlelabel">Chapter 20:</a> Fibonacci Heaps</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0118.html#1444" target="_parent" class="chapterjump">Figure 20.1:</a> <i class="emphasis">(a)</i> A Fibonacci heap consisting of five min-heap-ordered trees and 14 nodes. The dashed line indicates the root list. The minimum node of the heap is the node containing the key 3. The three marked nodes are blackened. The potential of this particular Fibonacci heap is 5+2<span class="unicode">&middot;</span>3 = 11. <i class="emphasis">(b)</i> A more complete representation showing pointers <i class="emphasis">p</i> (up arrows), <i class="emphasis">child</i> (down arrows), and <i class="emphasis">left</i> and <i class="emphasis">right</i> (sideways arrows). These details are omitted in the remaining figures in this chapter, since all the information shown here can be determined from what appears in part (a).</dt>
<dt class="lotentry">
<a href="DDU0119.html#1455" target="_parent" class="chapterjump">Figure 20.2:</a> Inserting a node into a Fibonacci heap. <i class="emphasis">(a)</i> A Fibonacci heap <i class="emphasis">H</i>. <i class="emphasis">(b)</i> Fibonacci heap <i class="emphasis">H</i> after the node with key 21 has been inserted. The node becomes its own min-heap-ordered tree and is then added to the root list, becoming the left sibling of the root.</dt>
<dt class="lotentry">
<a href="DDU0119.html#1461" target="_parent" class="chapterjump">Figure 20.3:</a> The action of FIB-HEAP-EXTRACT-MIN. <i class="emphasis">(a)</i> A Fibonacci heap <i class="emphasis">H</i>. <i class="emphasis">(b)</i> The situation after the minimum node <i class="emphasis">z</i> is removed from the root list and its children are added to the root list. <i class="emphasis">(c)</i><span class="unicode">&ndash;</span><i class="emphasis">(e)</i> The array <i class="emphasis">A</i> and the trees after each of the first three iterations of the <i class="emphasis">for</i> loop of lines 3<span class="unicode">&ndash;</span>13 of the procedure CONSOLIDATE. The root list is processed by starting at the node pointed to by <i class="emphasis">min</i>[<i class="emphasis">H</i> ] and following <i class="emphasis">right</i> pointers. Each part shows the values of <i class="emphasis">w</i> and <i class="emphasis">x</i> at the end of an iteration. <i class="emphasis">(f)</i><span class="unicode">&ndash;</span><i class="emphasis">(h)</i> The next iteration of the <i class="emphasis">for</i> loop, with the values of <i class="emphasis">w</i> and <i class="emphasis">x</i> shown at the end of each iteration of the <i class="emphasis">while</i> loop of lines 6<span class="unicode">&ndash;</span>12. Part (f) shows the situation after the first time through the <i class="emphasis">while</i> loop. The node with key 23 has been linked to the node with key 7, which is now pointed to by <i class="emphasis">x</i>. In part (g), the node with key 17 has been linked to the node with key 7, which is still pointed to by <i class="emphasis">x</i>. In part (h), the node with key 24 has been linked to the node with key 7. Since no node was previously pointed to by <i class="emphasis">A</i>[3], at the end of the <i class="emphasis">for</i> loop iteration, <i class="emphasis">A</i>[3] is set to point to the root of the resulting tree. <i class="emphasis">(i)</i><span class="unicode">&ndash;</span><i class="emphasis">(l)</i> The situation after each of the next four iterations of the <i class="emphasis">for</i> loop. <i class="emphasis">(m)</i> Fibonacci heap <i class="emphasis">H</i> after reconstruction of the root list from the array <i class="emphasis">A</i> and determination of the new <i class="emphasis">min</i>[<i class="emphasis">H</i>] pointer.</dt>
<dt class="lotentry">
<a href="DDU0120.html#1477" target="_parent" class="chapterjump">Figure 20.4:</a> Two calls of FIB-HEAP-DECREASE-KEY. <i class="emphasis">(a)</i> The initial Fibonacci heap. <i class="emphasis">(b)</i> The node with key 46 has its key decreased to 15. The node becomes a root, and its parent (with key 24), which had previously been unmarked, becomes marked. <i class="emphasis">(c)</i><span class="unicode">&ndash;</span><i class="emphasis">(e)</i> The node with key 35 has its key decreased to 5. In part (c), the node, now with key 5, becomes a root. Its parent, with key 26, is marked, so a cascading cut occurs. The node with key 26 is cut from its parent and made an unmarked root in (d). Another cascading cut occurs, since the node with key 24 is marked as well. This node is cut from its parent and made an unmarked root in part (e). The cascading cuts stop at this point, since the node with key 7 is a root. (Even if this node were not a root, the cascading cuts would stop, since it is unmarked.) The result of the FIB-HEAP-DECREASE-KEY operation is shown in part (e), with <i class="emphasis">min</i>[<i class="emphasis">H</i>] pointing to the new minimum node.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4049"></a><a href="DDU0123.html#1496" target="_parent" class="chapter-titlelabel">Chapter 21:</a> Data Structures for Disjoint Sets</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0123.html#1501" target="_parent" class="chapterjump">Figure 21.1:</a> <i class="emphasis">(a)</i> A graph with four connected components: {<i class="emphasis">a</i>, <i class="emphasis">b</i>, <i class="emphasis">c</i>, <i class="emphasis">d</i>}, {<i class="emphasis">e</i>, <i class="emphasis">f</i>, <i class="emphasis">g</i>}, {<i class="emphasis">h</i>, <i class="emphasis">i</i>}, and {<i class="emphasis">j</i>}.<i class="emphasis">(b)</i> The collection of disjoint sets after each edge is processed.</dt>
<dt class="lotentry">
<a href="DDU0124.html#1508" target="_parent" class="chapterjump">Figure 21.2:</a> <i class="emphasis">(a)</i> Linked-list representations of two sets. One contains objects <i class="emphasis">b</i>, <i class="emphasis">c</i>, <i class="emphasis">e</i>, and <i class="emphasis">h</i>, with <i class="emphasis">c</i> as the representative, and the other contains objects <i class="emphasis">d</i>, <i class="emphasis">f</i>, and <i class="emphasis">g</i>, with <i class="emphasis">f</i> as the representative. Each object on the list contains a set member, a pointer to the next object on the list, and a pointer back to the first object on the list, which is the representative. Each list has pointers <i class="emphasis">head</i> and <i class="emphasis">tail</i> to the first and last objects, respectively. <i class="emphasis">(b)</i> The result of UNION(<i class="emphasis">e</i>, <i class="emphasis">g</i>). The representative of the resulting set is <i class="emphasis">f</i>.</dt>
<dt class="lotentry">
<a href="DDU0124.html#1512" target="_parent" class="chapterjump">Figure 21.3:</a> A sequence of 2<i class="emphasis">n</i> - 1 operations on <i class="emphasis">n</i> objects that takes <span class="unicode">&Theta;</span>(<i class="emphasis">n</i><sup>2</sup>) time, or <span class="unicode">&Theta;</span>(<i class="emphasis">n</i>) time per operation on average, using the linked-list set representation and the simple implementation of UNION.</dt>
<dt class="lotentry">
<a href="DDU0125.html#1524" target="_parent" class="chapterjump">Figure 21.4:</a> A disjoint-set forest. <i class="emphasis">(a)</i> Two trees representing the two sets of Figure 21.2. The tree on the left represents the set {<i class="emphasis">b</i>, <i class="emphasis">c</i>, <i class="emphasis">e</i>, <i class="emphasis">h</i>}, with <i class="emphasis">c</i> as the representative, and the tree on the right represents the set {<i class="emphasis">d</i>, <i class="emphasis">f</i>, <i class="emphasis">g</i>}, with <i class="emphasis">f</i> as the representative. <i class="emphasis">(b)</i> The result of UNION(<i class="emphasis">e</i>, <i class="emphasis">g</i>).</dt>
<dt class="lotentry">
<a href="DDU0125.html#1526" target="_parent" class="chapterjump">Figure 21.5:</a> Path compression during the operation FIND-SET. Arrows and self-loops at roots are omitted. <i class="emphasis">(a)</i> A tree representing a set prior to executing FIND-SET(<i class="emphasis">a</i>). Triangles represent subtrees whose roots are the nodes shown. Each node has a pointer to its parent. <i class="emphasis">(b)</i> The same set after executing FIND-SET(<i class="emphasis">a</i>). Each node on the find path now points directly to the root.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4051"></a><a href="DDU0129.html#1579" target="_parent" class="chapter-titlelabel">Chapter 22:</a> Elementary Graph Algorithms</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0129.html#1583" target="_parent" class="chapterjump">Figure 22.1:</a> Two representations of an undirected graph. <i class="emphasis">(a)</i> An undirected graph <i class="emphasis">G</i> having five vertices and seven edges. <i class="emphasis">(b)</i> An adjacency-list representation of <i class="emphasis">G</i>. <i class="emphasis">(c)</i> The adjacency-matrix representation of <i class="emphasis">G</i>.</dt>
<dt class="lotentry">
<a href="DDU0129.html#1584" target="_parent" class="chapterjump">Figure 22.2:</a> Two representations of a directed graph. <i class="emphasis">(a)</i> A directed graph <i class="emphasis">G</i> having six vertices and eight edges. <i class="emphasis">(b)</i> An adjacency-list representation of <i class="emphasis">G</i>. <i class="emphasis">(c)</i> The adjacency-matrix representation of <i class="emphasis">G</i>.</dt>
<dt class="lotentry">
<a href="DDU0130.html#1599" target="_parent" class="chapterjump">Figure 22.3:</a> The operation of BFS on an undirected graph. Tree edges are shown shaded as they are produced by BFS. Within each vertex <i class="emphasis">u</i> is shown <i class="emphasis">d</i>[<i class="emphasis">u</i>]. The queue <i class="emphasis">Q</i> is shown at the beginning of each iteration of the <i class="emphasis">while</i> loop of lines 10<span class="unicode">&ndash;</span>18. Vertex distances are shown next to vertices in the queue.</dt>
<dt class="lotentry">
<a href="DDU0131.html#1627" target="_parent" class="chapterjump">Figure 22.4:</a> The progress of the depth-first-search algorithm DFS on a directed graph. As edges are explored by the algorithm, they are shown as either shaded (if they are tree edges) or dashed (otherwise). Nontree edges are labeled B, C, or F according to whether they are back, cross, or forward edges. Vertices are timestamped by discovery time/finishing time.</dt>
<dt class="lotentry">
<a href="DDU0131.html#1631" target="_parent" class="chapterjump">Figure 22.5:</a> Properties of depth-first search. <i class="emphasis">(a)</i> The result of a depth-first search of a directed graph. Vertices are timestamped and edge types are indicated as in Figure 22.4. <i class="emphasis">(b)</i> Intervals for the discovery time and finishing time of each vertex correspond to the parenthesization shown. Each rectangle spans the interval given by the discovery and finishing times of the corresponding vertex. Tree edges are shown. If two intervals overlap, then one is nested within the other, and the vertex corresponding to the smaller interval is a descendant of the vertex corresponding to the larger. <i class="emphasis">(c)</i> The graph of part (a) redrawn with all tree and forward edges going down within a depth-first tree and all back edges going up from a descendant to an ancestor.</dt>
<dt class="lotentry">
<a href="DDU0131.html#1641" target="_parent" class="chapterjump">Figure 22.6:</a> A directed graph for use in Exercises 22.3-2 and 22.5-2.</dt>
<dt class="lotentry">
<a href="DDU0132.html#1655" target="_parent" class="chapterjump">Figure 22.7:</a> <i class="emphasis">(a)</i> Professor Bumstead topologically sorts his clothing when getting dressed. Each directed edge (<i class="emphasis">u, v</i>) means that garment <i class="emphasis">u</i> must be put on before garment <i class="emphasis">v</i>. The discovery and finishing times from a depth-first search are shown next to each vertex. <i class="emphasis">(b)</i> The same graph shown topologically sorted. Its vertices are arranged from left to right in order of decreasing finishing time. Note that all directed edges go from left to right.</dt>
<dt class="lotentry">
<a href="DDU0132.html#1660" target="_parent" class="chapterjump">Figure 22.8:</a> A dag for topological sorting.</dt>
<dt class="lotentry">
<a href="DDU0133.html#1667" target="_parent" class="chapterjump">Figure 22.9:</a> <i class="emphasis">(a)</i> A directed graph <i class="emphasis">G</i>. The strongly connected components of <i class="emphasis">G</i> are shown as shaded regions. Each vertex is labeled with its discovery and finishing times. Tree edges are shaded. <i class="emphasis">(b)</i> The graph <i class="emphasis">G</i><sup>T</sup>, the transpose of <i class="emphasis">G</i>. The depth-first forest computed in line 3 of STRONGLY-CONNECTED-COMPONENTS is shown, with tree edges shaded. Each strongly connected component corresponds to one depth-first tree. Vertices <i class="emphasis">b, c, g</i>, and <i class="emphasis">h</i>, which are heavily shaded, are the roots of the depth-first trees produced by the depth-first search of <i class="emphasis">G</i><sup>T</sup>. <i class="emphasis">(c)</i> The acyclic component graph <i class="emphasis">G</i><sup>SCC</sup> obtained by contracting all edges within each strongly connected component of <i class="emphasis">G</i> so that only a single vertex remains in each component.</dt>
<dt class="lotentry">
<a href="DDU0133.html#1686" target="_parent" class="chapterjump">Figure 22.10:</a> The articulation points, bridges, and biconnected components of a connected, undirected graph for use in Problem 22-2. The articulation points are the heavily shaded vertices, the bridges are the heavily shaded edges, and the biconnected components are the edges in the shaded regions, with a <i class="emphasis">bcc</i> numbering shown.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4053"></a><a href="DDU0135.html#1692" target="_parent" class="chapter-titlelabel">Chapter 23:</a> Minimum Spanning Trees</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0135.html#1695" target="_parent" class="chapterjump">Figure 23.1:</a> A minimum spanning tree for a connected graph. The weights on edges are shown, and the edges in a minimum spanning tree are shaded. The total weight of the tree shown is 37. This minimum spanning tree is not unique: removing the edge (<i class="emphasis">b, c</i>) and replacing it with the edge (<i class="emphasis">a, h</i>) yields another spanning tree with weight 37.</dt>
<dt class="lotentry">
<a href="DDU0136.html#1699" target="_parent" class="chapterjump">Figure 23.2:</a> Two ways of viewing a cut (<i class="emphasis">S, V</i> - <i class="emphasis">S</i>) of the graph from Figure 23.1. <i class="emphasis">(a)</i> The vertices in the set <i class="emphasis">S</i> are shown in black, and those in <i class="emphasis">V</i> - <i class="emphasis">S</i> are shown in white. The edges crossing the cut are those connecting white vertices with black vertices. The edge (<i class="emphasis">d, c</i>) is the unique light edge crossing the cut. A subset <i class="emphasis">A</i> of the edges is shaded; note that the cut (<i class="emphasis">S, V</i> - <i class="emphasis">S</i>) respects <i class="emphasis">A</i>, since no edge of <i class="emphasis">A</i> crosses the cut. <i class="emphasis">(b)</i> The same graph with the vertices in the set <i class="emphasis">S</i> on the left and the vertices in the set <i class="emphasis">V</i> - <i class="emphasis">S</i> on the right. An edge crosses the cut if it connects a vertex on the left with a vertex on the right.</dt>
<dt class="lotentry">
<a href="DDU0136.html#1702" target="_parent" class="chapterjump">Figure 23.3:</a> The proof of Theorem 23.1. The vertices in <i class="emphasis">S</i> are black, and the vertices in <i class="emphasis">V - S</i> are white. The edges in the minimum spanning tree <i class="emphasis">T</i> are shown, but the edges in the graph <i class="emphasis">G</i> are not. The edges in <i class="emphasis">A</i> are shaded, and (<i class="emphasis">u, v</i>) is a light edge crossing the cut (<i class="emphasis">S, V - S</i>). The edge (<i class="emphasis">x, y</i>) is an edge on the unique path <i class="emphasis">p</i> from <i class="emphasis">u</i> to <i class="emphasis">v</i> in <i class="emphasis">T</i>. A minimum spanning tree <i class="emphasis">T</i><span class="unicode">&prime;</span> that contains (<i class="emphasis">u, v</i>) is formed by removing the edge (<i class="emphasis">x, y</i>) from <i class="emphasis">T</i> and adding the edge (<i class="emphasis">u, v</i>).</dt>
<dt class="lotentry">
<a href="DDU0137.html#1723" target="_parent" class="chapterjump">Figure 23.4:</a> The execution of Kruskal's algorithm on the graph from Figure 23.1. Shaded edges belong to the forest <i class="emphasis">A</i> being grown. The edges are considered by the algorithm in sorted order by weight. An arrow points to the edge under consideration at each step of the algorithm. If the edge joins two distinct trees in the forest, it is added to the forest, thereby merging the two trees.</dt>
<dt class="lotentry">
<a href="DDU0137.html#1725" target="_parent" class="chapterjump">Figure 23.5:</a> The execution of Prim's algorithm on the graph from Figure 23.1. The root vertex is <i class="emphasis">a</i>. Shaded edges are in the tree being grown, and the vertices in the tree are shown in black. At each step of the algorithm, the vertices in the tree determine a cut of the graph, and a light edge crossing the cut is added to the tree. In the second step, for example, the algorithm has a choice of adding either edge (<i class="emphasis">b, c</i>) or edge (<i class="emphasis">a, h</i>) to the tree since both are light edges crossing the cut.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4055"></a><a href="DDU0139.html#1748" target="_parent" class="chapter-titlelabel">Chapter 24:</a> Single-Source Shortest Paths</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0142.html#1757" target="_parent" class="chapterjump">Figure 24.1:</a> Negative edge weights in a directed graph. Shown within each vertex is its shortest-path weight from source <i class="emphasis">s</i>. Because vertices <i class="emphasis">e</i> and <i class="emphasis">f</i> form a negative-weight cycle reachable from <i class="emphasis">s</i>, they have shortest-path weights of -<span class="unicode">&infin;</span>. Because vertex <i class="emphasis">g</i> is reachable from a vertex whose shortest-path weight is -<span class="unicode">&infin;</span>, it, too, has a shortest-path weight of -<span class="unicode">&infin;</span>. Vertices such as <i class="emphasis">h, i</i>, and <i class="emphasis">j</i> are not reachable from <i class="emphasis">s</i>, and so their shortest-path weights are <span class="unicode">&infin;</span>, even though they lie on a negative-weight cycle.</dt>
<dt class="lotentry">
<a href="DDU0144.html#1762" target="_parent" class="chapterjump">Figure 24.2:</a> (a) A weighted, directed graph with shortest-path weights from source <i class="emphasis">s</i>. (b) The shaded edges form a shortest-paths tree rooted at the source <i class="emphasis">s</i>. (c) Another shortest-paths tree with the same root.</dt>
<dt class="lotentry">
<a href="DDU0145.html#1766" target="_parent" class="chapterjump">Figure 24.3:</a> Relaxation of an edge (<i class="emphasis">u, v</i>) with weight <i class="emphasis">w</i>(<i class="emphasis">u, v</i>) = 2. The shortest-path estimate of each vertex is shown within the vertex. (a) Because <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&gt;</span> <i class="emphasis">d</i>[<i class="emphasis">u</i>] + <i class="emphasis">w</i>(<i class="emphasis">u, v</i>) prior to relaxation, the value of <i class="emphasis">d</i>[<i class="emphasis">v</i>] decreases. (b) Here, <i class="emphasis">d</i>[<i class="emphasis">v</i>] <span class="unicode">&le;</span> <i class="emphasis">d</i>[<i class="emphasis">u</i>] + <i class="emphasis">w</i>(<i class="emphasis">u, v</i>) before the relaxation step, and so <i class="emphasis">d</i>[<i class="emphasis">v</i>] is unchanged by relaxation.</dt>
<dt class="lotentry">
<a href="DDU0148.html#1772" target="_parent" class="chapterjump">Figure 24.4:</a> The execution of the Bellman-Ford algorithm. The source is vertex <i class="emphasis">s</i>. The <i class="emphasis">d</i> values are shown within the vertices, and shaded edges indicate predecessor values: if edge (<i class="emphasis">u, v</i>) is shaded, then <span class="unicode">&pi;</span>[<i class="emphasis">v</i>] = <i class="emphasis">u</i>. In this particular example, each pass relaxes the edges in the order (<i class="emphasis">t, x</i>), (<i class="emphasis">t, y</i>), (<i class="emphasis">t, z</i>), (<i class="emphasis">x, t</i>), (<i class="emphasis">y, x</i>), (<i class="emphasis">y, z</i>), (<i class="emphasis">z, x</i>), (<i class="emphasis">z, s</i>), (<i class="emphasis">s, t</i>), (<i class="emphasis">s, y</i>). (a) The situation just before the first pass over the edges. (b)<span class="unicode">&ndash;</span>(e) The situation after each successive pass over the edges. The <i class="emphasis">d</i> and <span class="unicode">&pi;</span> values in part (e) are the final values. The Bellman-Ford algorithm returns TRUE in this example.</dt>
<dt class="lotentry">
<a href="DDU0149.html#1783" target="_parent" class="chapterjump">Figure 24.5:</a> The execution of the algorithm for shortest paths in a directed acyclic graph. The vertices are topologically sorted from left to right. The source vertex is <i class="emphasis">s</i>. The <i class="emphasis">d</i> values are shown within the vertices, and shaded edges indicate the <span class="unicode">&pi;</span> values. (a) The situation before the first iteration of the for loop of lines 3<span class="unicode">&ndash;</span>5. (b)<span class="unicode">&ndash;</span>(g) The situation after each iteration of the for loop of lines 3<span class="unicode">&ndash;</span>5. The newly blackened vertex in each iteration was used as <i class="emphasis">u</i> in that iteration. The values shown in part (g) are the final values.</dt>
<dt class="lotentry">
<a href="DDU0150.html#1790" target="_parent" class="chapterjump">Figure 24.6:</a> The execution of Dijkstra's algorithm. The source s is the leftmost vertex. The shortest-path estimates are shown within the vertices, and shaded edges indicate predecessor values. Black vertices are in the set <i class="emphasis">S</i>, and white vertices are in the min-priority queue <i class="emphasis">Q</i> = <i class="emphasis">V</i> - <i class="emphasis">S</i>. (a) The situation just before the first iteration of the while loop of lines 4<span class="unicode">&ndash;</span>8. The shaded vertex has the minimum <i class="emphasis">d</i> value and is chosen as vertex <i class="emphasis">u</i> in line 5. (b)-(f) The situation after each successive iteration of the while loop. The shaded vertex in each part is chosen as vertex <i class="emphasis">u</i> in line 5 of the next iteration. The <i class="emphasis">d</i> and <span class="unicode">&pi;</span> values shown in part (f) are the final values.</dt>
<dt class="lotentry">
<a href="DDU0150.html#1793" target="_parent" class="chapterjump">Figure 24.7:</a> The proof of Theorem 24.6. Set <i class="emphasis">S</i> is nonempty just before vertex <i class="emphasis">u</i> is added to it. A shortest path <i class="emphasis">p</i> from source <i class="emphasis">s</i> to vertex <i class="emphasis">u</i> can be decomposed into s <span class="inlinemediaobject"><img src="images/fig619_01.jpg" height="12" width="70" alt="" border="0"></span>, where <i class="emphasis">y</i> is the first vertex on the path that is not in <i class="emphasis">S</i> and <i class="emphasis">x</i> <span class="unicode">&isin;</span> <i class="emphasis">S</i> immediately precedes <i class="emphasis">y</i>. Vertices <i class="emphasis">x</i> and <i class="emphasis">y</i> are distinct, but we may have <i class="emphasis">s</i> = <i class="emphasis">x</i> or <i class="emphasis">y</i> = <i class="emphasis">u</i>. Path <i class="emphasis">p</i><sub>2</sub> may or may not reenter set <i class="emphasis">S</i>.</dt>
<dt class="lotentry">
<a href="DDU0151.html#1816" target="_parent" class="chapterjump">Figure 24.8:</a> The constraint graph corresponding to the system (24.3)<span class="unicode">&ndash;</span>(24.10) of difference constraints. The value of <span class="unicode">&delta;</span>(<i class="emphasis">v</i><sub>0</sub>, <i class="emphasis">v</i><sub><i class="emphasis">i</i></sub>) is shown in each vertex <i class="emphasis">v<sub>i</sub></i>. A feasible solution to the system is <i class="emphasis">x</i> = (-5, -3, 0, -1, -4).</dt>
<dt class="lotentry">
<a href="DDU0152.html#1852" target="_parent" class="chapterjump">Figure 24.9:</a> Showing that a path in <i class="emphasis">G</i><sub><i class="emphasis"><span class="unicode">&pi;</span></i></sub> from source <i class="emphasis">s</i> to vertex <i class="emphasis">v</i> is unique. If there are two paths <span class="inlinemediaobject"><a href="images/fig634%5F01%5F0%2Ejpg" NAME="IMG_738" target="_parent"><img src="images/fig634_01.jpg" height="11" width="120" alt="Click To expand" border="0"></a></span> and <span class="inlinemediaobject"><img src="images/fig634_02.jpg" height="11" width="120" alt="" border="0"></span>, where <i class="emphasis">x</i> <span class="unicode">&ne;</span> <i class="emphasis">y</i>, then <span class="unicode">&pi;</span>[<i class="emphasis">z</i>] = <i class="emphasis">x</i> and <span class="unicode">&pi;</span>[<i class="emphasis">z</i>] = <i class="emphasis">y</i>, a contradiction.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4058"></a><a href="DDU0154.html#1876" target="_parent" class="chapter-titlelabel">Chapter 25:</a> All-Pairs Shortest Paths</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0156.html#1893" target="_parent" class="chapterjump">Figure 25.1:</a> A directed graph and the sequence of matrices <i class="emphasis">L<sup>(m)</sup></i> computed by SLOW-ALL-PAIRS-SHORTEST-PATHS. The reader may verify that <i class="emphasis">L</i><sup>(5)</sup> = <i class="emphasis">L</i><sup>(4)</sup> <span class="unicode">&middot;</span> <i class="emphasis">W</i> is equal to <i class="emphasis">L</i><sup>(4)</sup>, and thus <i class="emphasis">L</i><sup>(m)</sup> = <i class="emphasis">L</i><sup>(4)</sup> for all <i class="emphasis">m</i> <span class="unicode">&ge;</span> 4.</dt>
<dt class="lotentry">
<a href="DDU0156.html#1898" target="_parent" class="chapterjump">Figure 25.2:</a> A weighted, directed graph for use in Exercises 25.1-1, 25.2-1, and 25.3-1.</dt>
<dt class="lotentry">
<a href="DDU0157.html#1912" target="_parent" class="chapterjump">Figure 25.3:</a> Path <i class="emphasis">p</i> is a shortest path from vertex <i class="emphasis">i</i> to vertex <i class="emphasis">j</i>, and <i class="emphasis">k</i> is the highest-numbered intermediate vertex of <i class="emphasis">p</i>. Path <i class="emphasis">p</i><sub>1</sub>, the portion of path <i class="emphasis">p</i> from vertex <i class="emphasis">i</i> to vertex <i class="emphasis">k</i>, has all intermediate vertices in the set {1, 2,..., <i class="emphasis">k</i> - 1}. The same holds for path <i class="emphasis">p</i><sub>2</sub> from vertex <i class="emphasis">k</i> to vertex <i class="emphasis">j</i>.</dt>
<dt class="lotentry">
<a href="DDU0157.html#1918" target="_parent" class="chapterjump">Figure 25.4:</a> The sequence of matrices <i class="emphasis">D</i><sup><i class="emphasis">(k)</i></sup> and <span class="unicode">&Pi;</span><sup><i class="emphasis">(k)</i></sup> computed by the Floyd-Warshall algorithm for the graph in Figure 25.1.</dt>
<dt class="lotentry">
<a href="DDU0157.html#1926" target="_parent" class="chapterjump">Figure 25.5:</a> A directed graph and the matrices <i class="emphasis">T</i><sup>(<i class="emphasis">k</i>)</sup> computed by the transitive-closure algorithm.</dt>
<dt class="lotentry">
<a href="DDU0158.html#1944" target="_parent" class="chapterjump">Figure 25.6:</a> Johnson's all-pairs shortest-paths algorithm run of the graph of Figure 25.1. <i class="emphasis">(a)</i> The graph <i class="emphasis">G</i><span class="unicode">&prime;</span> with the original weight function <i class="emphasis">w</i>. The new vertex <i class="emphasis">s</i> is black. Within each vertex <i class="emphasis">v</i> is <i class="emphasis">h</i>(<i class="emphasis">v</i>) = <span class="unicode">&delta;</span>(<i class="emphasis">s</i>, <i class="emphasis">v</i>). <i class="emphasis">(b)</i> Each edge (<i class="emphasis">u</i>, <i class="emphasis">v</i>) is reweighted with weight function <span class="inlinemediaobject"><img src="images/fig660_01.jpg" height="13" width="165" alt="" border="0"></span>. <i class="emphasis">(c)</i><span class="unicode">&ndash;</span><i class="emphasis">(g)</i> The result of running Dijkstra's algorithm on each vertex of <i class="emphasis">G</i> using weight function <span class="inlinemediaobject"><img src="images/fig660_02.jpg" height="8" width="8" alt="" border="0"></span>. In each part, the source vertex <i class="emphasis">u</i> is black, and shaded edges are in the shortest-paths tree computed by the algorithm. Within each vertex <i class="emphasis">v</i> are the values <span class="inlinemediaobject"><img src="images/fig660_03.jpg" height="12" width="26" alt="" border="0"></span> and <span class="unicode">&delta;</span>(<i class="emphasis">u</i>, <i class="emphasis">v</i>), separated by a slash. The value <i class="emphasis">d<sub>uv</sub></i> = <span class="unicode">&delta;</span>(<i class="emphasis">u</i>, <i class="emphasis">v</i>) is equal to <span class="inlinemediaobject"><a href="images/fig660%5F04%5F0%2Ejpg" NAME="IMG_844" target="_parent"><img src="images/fig660_04.jpg" height="12" width="82" alt="Click To expand" border="0"></a></span>.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4061"></a><a href="DDU0160.html#1960" target="_parent" class="chapter-titlelabel">Chapter 26:</a> Maximum Flow</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0161.html#1966" target="_parent" class="chapterjump">Figure 26.1:</a> <i class="emphasis">(a)</i> A flow network <i class="emphasis">G</i> = (<i class="emphasis">V, E</i>) for the Lucky Puck Company's trucking problem. The Vancouver factory is the source <i class="emphasis">s</i>, and the Winnipeg warehouse is the sink <i class="emphasis">t</i>. Pucks are shipped through intermediate cities, but only <i class="emphasis">c</i>(<i class="emphasis">u, v</i>) crates per day can go from city <i class="emphasis">u</i> to city <i class="emphasis">v</i>. Each edge is labeled with its capacity. <i class="emphasis">(b)</i> A flow <i class="emphasis">f</i> in <i class="emphasis">G</i> with value |<i class="emphasis">f</i>| = 19. Only positive flows are shown. If <i class="emphasis">f</i> (<i class="emphasis">u, v</i>) <span class="unicode">&gt;</span> 0, edge (<i class="emphasis">u, v</i>) is labeled by <i class="emphasis">f</i>(<i class="emphasis">u, v</i>)/<i class="emphasis">c</i>(<i class="emphasis">u, v</i>). (The slash notation is used merely to separate the flow and capacity; it does not indicate division.) If <i class="emphasis">f</i>(<i class="emphasis">u, v</i>) <span class="unicode">&le;</span> 0, edge (<i class="emphasis">u, v</i>) is labeled only by its capacity.</dt>
<dt class="lotentry">
<a href="DDU0161.html#1972" target="_parent" class="chapterjump">Figure 26.2:</a> Converting a multiple-source, multiple-sink maximum-flow problem into a problem with a single source and a single sink. <i class="emphasis">(a)</i> A flow network with five sources <i class="emphasis">S</i> = {<i class="emphasis">s</i><sub>1</sub>, <i class="emphasis">s</i><sub>2</sub>, <i class="emphasis">s</i><sub>3</sub>, <i class="emphasis">s</i><sub>4</sub>, <i class="emphasis">s</i><sub>5</sub>} and three sinks <i class="emphasis">T</i> = {<i class="emphasis">t</i><sub>1</sub>, <i class="emphasis">t</i><sub>2</sub>, <i class="emphasis">t</i><sub>3</sub>}. <i class="emphasis">(b)</i> An equivalent single-source, single-sink flow network. We add a supersource <i class="emphasis">s</i> and an edge with infinite capacity from <i class="emphasis">s</i> to each of the multiple sources. We also add a supersink <i class="emphasis">t</i> and an edge with infinite capacity from each of the multiple sinks to <i class="emphasis">t</i>.</dt>
<dt class="lotentry">
<a href="DDU0162.html#1994" target="_parent" class="chapterjump">Figure 26.3:</a> <i class="emphasis">(a)</i> The flow network <i class="emphasis">G</i> and flow <i class="emphasis">f</i> of Figure 26.1(b). <i class="emphasis">(b)</i> The residual network <i class="emphasis">G<sub>f</sub></i> with augmenting path <i class="emphasis">p</i> shaded; its residual capacity is <i class="emphasis">c<sub>f</sub></i> (<i class="emphasis">p</i>) = <i class="emphasis">c</i>(<i class="emphasis">v</i><sub>2</sub>, <i class="emphasis">v</i><sub>3</sub>) = 4. <i class="emphasis">(c)</i> The flow in <i class="emphasis">G</i> that results from augmenting along path <i class="emphasis">p</i> by its residual capacity 4. <i class="emphasis">(d)</i> The residual network induced by the flow in (c).</dt>
<dt class="lotentry">
<a href="DDU0162.html#2004" target="_parent" class="chapterjump">Figure 26.4:</a> A cut (<i class="emphasis">S, T</i>) in the flow network of Figure 26.1(b), where <i class="emphasis">S</i> = {<i class="emphasis">s, v</i><sub>1</sub>, <i class="emphasis">v</i><sub>2</sub>} and <i class="emphasis">T</i> = {<i class="emphasis">v</i><sub>3</sub>, <i class="emphasis">v</i><sub>4</sub>, <i class="emphasis">t</i>}. The vertices in <i class="emphasis">S</i> are black, and the vertices in <i class="emphasis">T</i> are white. The net flow across (<i class="emphasis">S, T</i>) is <i class="emphasis">f</i>(<i class="emphasis">S, T</i>) = 19, and the capacity is <i class="emphasis">c</i>(<i class="emphasis">S, T</i>) = 26.</dt>
<dt class="lotentry">
<a href="DDU0162.html#2012" target="_parent" class="chapterjump">Figure 26.5:</a> The execution of the basic Ford-Fulkerson algorithm. <i class="emphasis">(a)<span class="unicode">&ndash;</span>(d)</i> Successive iterations of the <i class="emphasis">while</i> loop. The left side of each part shows the residual network <i class="emphasis">G<sub>f</sub></i> from line 4 with a shaded augmenting path <i class="emphasis">p</i>. The right side of each part shows the new flow <i class="emphasis">f</i> that results from adding <i class="emphasis">f<sub>p</sub></i> to <i class="emphasis">f</i>. The residual network in (a) is the input network <i class="emphasis">G</i>. <i class="emphasis">(e)</i> The residual network at the last <i class="emphasis">while</i> loop test. It has no augmenting paths, and the flow <i class="emphasis">f</i> shown in (d) is therefore a maximum flow.</dt>
<dt class="lotentry">
<a href="DDU0162.html#2016" target="_parent" class="chapterjump">Figure 26.6:</a> <i class="emphasis">(a)</i> A flow network for which FORD-FULKERSON can take <span class="unicode">&Theta;</span>(<i class="emphasis">E</i> |<i class="emphasis">f</i>*|) time, where <i class="emphasis">f</i>* is a maximum flow, shown here with |<i class="emphasis">f</i>*| = 2,000,000. An augmenting path with residual capacity 1 is shown. <i class="emphasis">(b)</i> The resulting residual network. Another augmenting path with residual capacity 1 is shown. <i class="emphasis">(c)</i> The resulting residual network.</dt>
<dt class="lotentry">
<a href="DDU0163.html#2038" target="_parent" class="chapterjump">Figure 26.7:</a> A bibartite graph <i class="emphasis">G</i> = (<i class="emphasis">V, E</i>) with vertex partition <i class="emphasis">V</i> = <i class="emphasis">L</i><span class="unicode">&cup;</span><i class="emphasis">R</i>. <i class="emphasis">(a)</i> A matching with cardinality 2. <i class="emphasis">(b)</i> A maximum matching with cardinality 3.</dt>
<dt class="lotentry">
<a href="DDU0163.html#2040" target="_parent" class="chapterjump">Figure 26.8:</a> The flow network corresponding to a bipartite graph. <i class="emphasis">(a)</i> The bipartite graph <i class="emphasis">G</i> = (<i class="emphasis">V, E</i>) with vertex partition <i class="emphasis">V</i> = <i class="emphasis">L</i> <span class="unicode">&cup;</span> <i class="emphasis">R</i> from Figure 26.7. A maximum matching is shown by shaded edges. <i class="emphasis">(b)</i> The corresponding flow network <i class="emphasis">G</i>' with a maximum flow shown. Each edge has unit capacity. Shaded edges have a flow of 1, and all other edges carry no flow. The shaded edges from <i class="emphasis">L</i> to <i class="emphasis">R</i> correspond to those in a maximum matching of the bipartite graph.</dt>
<dt class="lotentry">
<a href="DDU0165.html#2101" target="_parent" class="chapterjump">Figure 26.9:</a> Discharging a vertex <i class="emphasis">y</i>. It takes 15 iterations of the <i class="emphasis">while</i> loop of DISCHARGE to push all the excess flow from <i class="emphasis">y</i>. Only the neighbors of <i class="emphasis">y</i> and edges entering or leaving <i class="emphasis">y</i> are shown. In each part, the number inside each vertex is its excess at the beginning of the first iteration shown in the part, and each vertex is shown at its height throughout the part. To the right is shown the neighbor list <i class="emphasis">N</i>[<i class="emphasis">y</i>] at the beginning of each iteration, with the iteration number on top. The shaded neighbor is <i class="emphasis">current</i>[<i class="emphasis">y</i>]. <i class="emphasis">(a)</i> Initially, there are 19 units of excess to push from <i class="emphasis">y</i>, and <i class="emphasis">current</i>[<i class="emphasis">y</i>] = <i class="emphasis">s</i>. Iterations 1, 2, and 3 just advance <i class="emphasis">current</i>[<i class="emphasis">y</i>], since there are no admissible edges leaving <i class="emphasis">y</i>. In iteration 4, <i class="emphasis">current</i>[<i class="emphasis">y</i>] = NIL (shown by the shading being below the neighbor list), and so <i class="emphasis">y</i> is relabeled and <i class="emphasis">current</i>[<i class="emphasis">y</i>] is reset to the head of the neighbor list. <i class="emphasis">(b)</i> After relabeling, vertex <i class="emphasis">y</i> has height 1. In iterations 5 and 6, edges (<i class="emphasis">y, s</i>) and (<i class="emphasis">y, x</i>) are found to be inadmissible, but 8 units of excess flow are pushed from <i class="emphasis">y</i> to <i class="emphasis">z</i> in iteration 7. Because of the push, <i class="emphasis">current</i>[<i class="emphasis">y</i>] is not advanced in this iteration. <i class="emphasis">(c)</i> Because the push in iteration 7 saturated edge (<i class="emphasis">y, z</i>), it is found inadmissible in iteration 8. In iteration 9, <i class="emphasis">current</i>[<i class="emphasis">y</i>] = NIL, and so vertex <i class="emphasis">y</i> is again relabeled and <i class="emphasis">current</i>[<i class="emphasis">y</i>] is reset. <i class="emphasis">(d)</i> In iteration 10, (<i class="emphasis">y, s</i>) is inadmissible, but 5 units of excess flow are pushed from <i class="emphasis">y</i> to <i class="emphasis">x</i> in iteration 11. <i class="emphasis">(e)</i> Because <i class="emphasis">current</i>[<i class="emphasis">y</i>] was not advanced in iteration 11, iteration 12 finds (<i class="emphasis">y, x</i>) to be inadmissible. Iteration 13 finds (<i class="emphasis">y, z</i>) inadmissible, and iteration 14 relabels vertex <i class="emphasis">y</i> and resets <i class="emphasis">current</i>[<i class="emphasis">y</i>]. <i class="emphasis">(f)</i> Iteration 15 pushes 6 units of excess flow from <i class="emphasis">y</i> to <i class="emphasis">s</i>. <i class="emphasis">(g)</i> Vertex <i class="emphasis">y</i> now has no excess flow, and DISCHARGE terminates. In this example, DISCHARGE both starts and finishes with the current pointer at the head of the neighbor list, but in general this need not be the case.</dt>
<dt class="lotentry">
<a href="DDU0165.html#2105" target="_parent" class="chapterjump">Figure 26.10:</a> The action of RELABEL-TO-FRONT. <i class="emphasis">(a)</i> A flow network just before the first iteration of the <i class="emphasis">while</i> loop. Initially, 26 units of flow leave source <i class="emphasis">s</i>. On the right is shown the initial list <i class="emphasis">L</i> = <span class="unicode">&#12297;</span><i class="emphasis">x, y, z</i><span class="unicode">&#12297;</span>, where initially <i class="emphasis">u</i> = <i class="emphasis">x</i>. Under each vertex in list <i class="emphasis">L</i> is its neighbor list, with the current neighbor shaded. Vertex <i class="emphasis">x</i> is discharged. It is relabeled to height 1, 5 units of excess flow are pushed to <i class="emphasis">y</i>, and the 7 remaining units of excess are pushed to the sink <i class="emphasis">t</i>. Because <i class="emphasis">x</i> is relabeled, it is moved to the head of <i class="emphasis">L</i>, which in this case does not change the structure of <i class="emphasis">L</i>. <i class="emphasis">(b)</i> After <i class="emphasis">x</i>, the next vertex in <i class="emphasis">L</i> that is discharged is <i class="emphasis">y</i>. Figure 26.9 shows the detailed action of discharging <i class="emphasis">y</i> in this situation. Because <i class="emphasis">y</i> is relabeled, it is moved to the head of <i class="emphasis">L</i>. <i class="emphasis">(c)</i> Vertex <i class="emphasis">x</i> now follows <i class="emphasis">y</i> in <i class="emphasis">L</i>, and so it is again discharged, pushing all 5 units of excess flow to <i class="emphasis">t</i>. Because vertex <i class="emphasis">x</i> is not relabeled in this discharge operation, it remains in place in list <i class="emphasis">L</i>. <i class="emphasis">(d)</i> Since vertex <i class="emphasis">z</i> follows vertex <i class="emphasis">x</i> in <i class="emphasis">L</i>, it is discharged. It is relabeled to height 1 and all 8 units of excess flow are pushed to <i class="emphasis">t</i>. Because <i class="emphasis">z</i> is relabeled, it is moved to the front of <i class="emphasis">L</i>. <i class="emphasis">(e)</i> Vertex <i class="emphasis">y</i> now follows vertex <i class="emphasis">z</i> in <i class="emphasis">L</i> and is therefore discharged. But because <i class="emphasis">y</i> has no excess, DISCHARGE immediately returns, and <i class="emphasis">y</i> remains in place in <i class="emphasis">L</i>. Vertex <i class="emphasis">x</i> is then discharged. Because it, too, has no excess, DISCHARGE again returns, and <i class="emphasis">x</i> remains in place in <i class="emphasis">L</i>. RELABEL-TO-FRONT has reached the end of list <i class="emphasis">L</i> and terminates. There are no overflowing vertices, and the preflow is a maximum flow.</dt>
<dt class="lotentry">
<a href="DDU0165.html#2118" target="_parent" class="chapterjump">Figure 26.11:</a> Grids for the escape problem. Starting points are black, and other grid vertices are white. <i class="emphasis">(a)</i> A grid with an escape, shown by shaded paths. <i class="emphasis">(b)</i> A grid with no escape.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4063"></a><a href="DDU0168.html#2137" target="_parent" class="chapter-titlelabel">Chapter 27:</a> Sorting Networks</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0169.html#2142" target="_parent" class="chapterjump">Figure 27.1:</a> <i class="emphasis">(a)</i> A comparator with inputs <i class="emphasis">x</i> and <i class="emphasis">y</i> and outputs <i class="emphasis">x</i>' and <i class="emphasis">y</i>'. <i class="emphasis">(b)</i> The same comparator, drawn as a single vertical line. Inputs <i class="emphasis">x</i> = 7, <i class="emphasis">y</i> = 3 and outputs <i class="emphasis">x</i>' = 3, <i class="emphasis">y</i>' = 7 are shown.</dt>
<dt class="lotentry">
<a href="DDU0169.html#2144" target="_parent" class="chapterjump">Figure 27.2:</a> <i class="emphasis">(a)</i> A 4-input, 4-output comparison network, which is in fact a sorting network. At time 0, the input values shown appear on the four input wires. <i class="emphasis">(b)</i> At time 1, the values shown appear on the outputs of comparators <i class="emphasis">A</i> and <i class="emphasis">B</i>, which are at depth 1. <i class="emphasis">(c)</i> At time 2, the values shown appear on the outputs of comparators <i class="emphasis">C</i> and <i class="emphasis">D</i>, at depth 2. Output wires <i class="emphasis">b</i><sub>1</sub> and <i class="emphasis">b</i><sub>4</sub> now have their final values, but output wires <i class="emphasis">b</i><sub>2</sub> and <i class="emphasis">b</i><sub>3</sub> do not. <i class="emphasis">(d)</i> At time 3, the values shown appear on the outputs of comparator <i class="emphasis">E</i>, at depth 3. Output wires <i class="emphasis">b</i><sub>2</sub> and <i class="emphasis">b</i><sub>3</sub> now have their final values.</dt>
<dt class="lotentry">
<a href="DDU0169.html#2153" target="_parent" class="chapterjump">Figure 27.3:</a> A sorting network based on insertion sort for use in Exercise 27.1-6.</dt>
<dt class="lotentry">
<a href="DDU0170.html#2160" target="_parent" class="chapterjump">Figure 27.4:</a> The operation of the comparator in the proof of Lemma 27.1. The function <i class="emphasis">f</i> is monotonically increasing.</dt>
<dt class="lotentry">
<a href="DDU0170.html#2161" target="_parent" class="chapterjump">Figure 27.5:</a> <i class="emphasis">(a)</i> The sorting network from Figure 27.2 with input sequence <span class="unicode">&#12296;</span>9, 5, 2, 6<span class="unicode">&#12297;</span>. <i class="emphasis">(b)</i> The same sorting network with the monotonically increasing function <i class="emphasis">f</i>(<i class="emphasis">x</i>) = <i class="emphasis">f</i>(<span class="unicode">&lceil;</span><i class="emphasis">x</i>/2<span class="unicode">&rceil;</span>) applied to the inputs. Each wire in this network has the value of <i class="emphasis">f</i> applied to the value on the corresponding wire in (a).</dt>
<dt class="lotentry">
<a href="DDU0170.html#2168" target="_parent" class="chapterjump">Figure 27.6:</a> A sorting network for sorting 4 numbers.</dt>
<dt class="lotentry">
<a href="DDU0171.html#2174" target="_parent" class="chapterjump">Figure 27.7:</a> The comparison network HALF-CLEANER[8]. Two different sample zero-one input and output values are shown. The input is assumed to be bitonic. A half-cleaner ensures that every output element of the top half is at least as small as every output element of the bottom half. Moreover, both halves are bitonic, and at least one half is clean.</dt>
<dt class="lotentry">
<a href="DDU0171.html#2176" target="_parent" class="chapterjump">Figure 27.8:</a> The possible comparisons in HALF-CLEANER[<i class="emphasis">n</i>]. The input sequence is assumed to be a bitonic sequence of 0's and 1's, and without loss of generality, we assume that it is of the form 00 ... 011 ... 100 ... 0. Subsequences of 0's are white, and subsequences of 1's are gray. We can think of the <i class="emphasis">n</i> inputs as being divided into two halves such that for <i class="emphasis">i</i> = 1, 2,..., <i class="emphasis">n</i>/2, inputs <i class="emphasis">i</i> and <i class="emphasis">i</i> + <i class="emphasis">n</i>/2 are compared. <i class="emphasis">(a)</i><span class="unicode">&ndash;</span><i class="emphasis">(b)</i> Cases in which the division occurs in the middle subsequence of 1's. <i class="emphasis">(c)</i><span class="unicode">&ndash;</span><i class="emphasis">(d)</i> Cases in which the division occurs in a subsequence of 0's. For all cases, every element in the top half of the output is at least as small as every element in the bottom half, both halves are bitonic, and at least one half is clean.</dt>
<dt class="lotentry">
<a href="DDU0171.html#2180" target="_parent" class="chapterjump">Figure 27.9:</a> The comparison network BITONIC-SORTER[<i class="emphasis">n</i>], shown here for <i class="emphasis">n</i> = 8. <i class="emphasis">(a)</i> The recursive construction: HALF-CLEANER[<i class="emphasis">n</i>] followed by two copies of BITONIC-SORTER[<i class="emphasis">n</i>/2] that operate in parallel. <i class="emphasis">(b)</i> The network after unrolling the recursion. Each half-cleaner is shaded. Sample zero-one values are shown on the wires.</dt>
<dt class="lotentry">
<a href="DDU0172.html#2190" target="_parent" class="chapterjump">Figure 27.10:</a> Comparing the first stage of MERGER[<i class="emphasis">n</i>] with HALF-CLEANER[<i class="emphasis">n</i>], for <i class="emphasis">n</i> = 8. <i class="emphasis">(a)</i> The first stage of MERGER[<i class="emphasis">n</i>] transforms the two monotonic input sequences <span class="unicode">&#12296;</span><i class="emphasis">a</i><sub>1</sub>, <i class="emphasis">a</i><sub>2</sub>,...,<i class="emphasis">a</i><sub><i class="emphasis">n</i>/2</sub><span class="unicode">&#12297;</span> and <span class="unicode">&#12296;</span><i class="emphasis">a</i><sub><i class="emphasis">n</i>/2+1</sub>, <i class="emphasis">a</i><sub><i class="emphasis">n</i>/2+2</sub>,...,<i class="emphasis">a<sub>n</sub></i><span class="unicode">&#12297;</span> into two bitonic sequences <span class="unicode">&#12296;</span><i class="emphasis">b</i><sub>1</sub>, <i class="emphasis">b</i><sub>2</sub>,...,<i class="emphasis">b</i><sub><i class="emphasis">n</i>/2</sub><span class="unicode">&#12297;</span> and <span class="unicode">&#12296;</span><i class="emphasis">b</i><sub><i class="emphasis">n</i>/2+1</sub>, <i class="emphasis">b</i><sub><i class="emphasis">n</i>/2+2</sub>,...,<i class="emphasis">b<sub>n</sub></i><span class="unicode">&#12297;</span>. <i class="emphasis">(b)</i> The equivalent operation for HALF-CLEANER[<i class="emphasis">n</i>]. The bitonic input sequence <span class="unicode">&#12296;</span><i class="emphasis">a</i><sub>1</sub>, <i class="emphasis">a</i><sub>2</sub>,...,<i class="emphasis">a</i><sub><i class="emphasis">n</i>/2-1</sub>, <i class="emphasis">a</i><sub><i class="emphasis">n</i>/2</sub>, <i class="emphasis">a<sub>n</sub></i>, <i class="emphasis">a</i><sub><i class="emphasis">n</i>-1</sub>,...,<i class="emphasis">a</i><sub><i class="emphasis">n</i>/2+2</sub>, <i class="emphasis">a</i><sub><i class="emphasis">n</i>/2+1</sub><span class="unicode">&#12297;</span> is transformed into the two bitonic sequences <span class="unicode">&#12296;</span><i class="emphasis">b</i><sub>1</sub>, <i class="emphasis">b</i><sub>2</sub>,...,<i class="emphasis">b</i><sub><i class="emphasis">n</i>/2</sub><span class="unicode">&#12297;</span> and <span class="unicode">&#12296;</span><i class="emphasis">b<sub>n</sub></i>, <i class="emphasis">b</i><sub><i class="emphasis">n</i>-1</sub>,...,<i class="emphasis">b</i><sub><i class="emphasis">n</i>/2+1</sub><span class="unicode">&#12297;</span>.</dt>
<dt class="lotentry">
<a href="DDU0172.html#2191" target="_parent" class="chapterjump">Figure 27.11:</a> A network that merges two sorted input sequences into one sorted output sequence. The network MERGER[<i class="emphasis">n</i>] can be viewed as BITONIC-SORTER[<i class="emphasis">n</i>] with the first half-cleaner altered to compare inputs <i class="emphasis">i</i> and <i class="emphasis">n</i> - <i class="emphasis">i</i> + 1 for <i class="emphasis">i</i> = 1, 2,..., <i class="emphasis">n</i>/2. Here, <i class="emphasis">n</i> = 8. <i class="emphasis">(a)</i> The network decomposed into the first stage followed by two parallel copies of BITONIC-SORTER[<i class="emphasis">n</i>/2]. <i class="emphasis">(b)</i> The same network with the recursion unrolled. Sample zero-one values are shown on the wires, and the stages are shaded.</dt>
<dt class="lotentry">
<a href="DDU0173.html#2200" target="_parent" class="chapterjump">Figure 27.12:</a> The sorting network SORTER[<i class="emphasis">n</i>] constructed by recursively combining merging networks. <i class="emphasis">(a)</i> The recursive construction. <i class="emphasis">(b)</i> Unrolling the recursion. <i class="emphasis">(c)</i> Replacing the MERGER boxes with the actual merging networks. The depth of each comparator is indicated, and sample zero-one values are shown on the wires.</dt>
<dt class="lotentry">
<a href="DDU0173.html#2209" target="_parent" class="chapterjump">Figure 27.13:</a> An odd-even sorting network on 8 inputs.</dt>
<dt class="lotentry">
<a href="DDU0173.html#2213" target="_parent" class="chapterjump">Figure 27.14:</a> Permutation networks. <i class="emphasis">(a)</i> The permutation network <i class="emphasis">P</i><sub>2</sub>, which consists of a single switch that can be set in either of the two ways shown. <i class="emphasis">(b)</i> The recursive construction of <i class="emphasis">P</i><sub>8</sub> from 8 switches and two <i class="emphasis">P</i><sub>4</sub>'s. The switches and <i class="emphasis">P</i><sub>4</sub>'s are set to realize the permutation <span class="unicode">&pi;</span> = <span class="unicode">&#12296;</span>4, 7,3, 5,1, 6, 8, 2<span class="unicode">&#12297;</span>.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4065"></a><a href="DDU0175.html#2217" target="_parent" class="chapter-titlelabel">Chapter 28:</a> Matrix Operations</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0178.html#2293" target="_parent" class="chapterjump">Figure 28.1:</a> The operation of LU-DECOMPOSITION. <i class="emphasis">(a)</i> The matrix <i class="emphasis">A</i>. <i class="emphasis">(b)</i> The element <i class="emphasis">a</i><sub>11</sub> = 2 in the black circle is the pivot, the shaded column is <i class="emphasis">v</i>/<i class="emphasis">a</i><sub>11</sub>, and the shaded row is <i class="emphasis">w</i><sup>T</sup>. The elements of <i class="emphasis">U</i> computed thus far are above the horizontal line, and the elements of <i class="emphasis">L</i> are to the left of the vertical line. The Schur complement matrix <i class="emphasis">A</i><span class="unicode">&prime;</span> - <i class="emphasis">vw</i><sup>T</sup>/<i class="emphasis">a</i><sub>11</sub> occupies the lower right. <i class="emphasis">(c)</i> We now operate on the Schur complement matrix produced from part (b). The element <i class="emphasis">a</i><sub>22</sub> = 4 in the black circle is the pivot, and the shaded column and row are <i class="emphasis">v</i>/<i class="emphasis">a</i><sub>22</sub> and <i class="emphasis">w</i><sup>T</sup> (in the partitioning of the Schur complement), respectively. Lines divide the matrix into the elements of <i class="emphasis">U</i> computed so far (above), the elements of <i class="emphasis">L</i> computed so far (left), and the new Schur complement (lower right). <i class="emphasis">(d)</i> The next step completes the factorization. (The element 3 in the new Schur complement becomes part of <i class="emphasis">U</i> when the recursion terminates.) <i class="emphasis">(e)</i> The factorization <i class="emphasis">A</i> = <i class="emphasis">LU</i>.</dt>
<dt class="lotentry">
<a href="DDU0178.html#2299" target="_parent" class="chapterjump">Figure 28.2:</a> The operation of LUP-DECOMPOSITION. <i class="emphasis">(a)</i> The input matrix <i class="emphasis">A</i> with the identity permutation of the rows on the left. The first step of the algorithm determines that the element 5 in the black circle in the third row is the pivot for the first column. <i class="emphasis">(b)</i> Rows 1 and 3 are swapped and the permutation is updated. The shaded column and row represent <i class="emphasis">v</i> and <i class="emphasis">w</i><sup>T</sup>. <i class="emphasis">(c)</i> The vector <i class="emphasis">v</i> is replaced by <i class="emphasis">v</i>/5, and the lower right of the matrix is updated with the Schur complement. Lines divide the matrix into three regions: elements of <i class="emphasis">U</i> (above), elements of <i class="emphasis">L</i> (left), and elements of the Schur complement (lower right). <i class="emphasis">(d)</i><span class="unicode">&ndash;</span><i class="emphasis">(f)</i> The second step. <i class="emphasis">(g)</i><span class="unicode">&ndash;</span><i class="emphasis">(i)</i> The third step. No further changes occur on the fourth, and final, step. <i class="emphasis">(j)</i> The LUP decomposition <i class="emphasis">PA</i> = <i class="emphasis">LU</i>.</dt>
<dt class="lotentry">
<a href="DDU0180.html#2343" target="_parent" class="chapterjump">Figure 28.3:</a> The least-squares fit of a quadratic polynomial to the set of five data points {(-1, 2), (1, 1), (2, 1), (3, 0), (5,3)}. The black dots are the data points, and the white dots are their estimated values predicted by the polynomial <i class="emphasis">F</i>(<i class="emphasis">x</i>) = 1.2 - 0.757<i class="emphasis">x</i> + 0.214<i class="emphasis">x</i><sup>2</sup>, the quadratic polynomial that minimizes the sum of the squared errors. The error for each data point is shown as a shaded line.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4067"></a><a href="DDU0182.html#2359" target="_parent" class="chapter-titlelabel">Chapter 29:</a> Linear Programming</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0182.html#2362" target="_parent" class="chapterjump">Figure 29.1:</a> The effects of policies on voters. Each entry describes the number of thousands of urban, suburban, or rural voters who could be won over by spending $1,000 on advertising support of a policy on a particular issue. Negative entries denote votes that would be lost.</dt>
<dt class="lotentry">
<a href="DDU0184.html#2371" target="_parent" class="chapterjump">Figure 29.2:</a> <i class="emphasis">(a)</i> The linear program given in (29.12)<span class="unicode">&ndash;</span>(29.15). Each constraint is represented by a line and a direction. The intersection of the constraints, which is the feasible region, is shaded. <i class="emphasis">(b)</i> The dotted lines show, respectively, the points for which the objective value is 0, 4, and 8. The optimal solution to the linear program is <i class="emphasis">x</i><sub>1</sub> = 2 and <i class="emphasis">x</i><sub>2</sub> = 6 with objective value 8.</dt>
<dt class="lotentry">
<a href="DDU0188.html#2416" target="_parent" class="chapterjump">Figure 29.3:</a> <i class="emphasis">(a)</i> An example of a minimum-cost-flow problem. We denote the capacities by <i class="emphasis">c</i> and the costs by <i class="emphasis">a</i>. Vertex <i class="emphasis">s</i> is the source and vertex <i class="emphasis">t</i> is the sink, and we wish to send 4 units of flow from <i class="emphasis">s</i> to <i class="emphasis">t</i>. <i class="emphasis">(b)</i> A solution to the minimum-cost flow problem in which 4 units of flow are sent from <i class="emphasis">s</i> to <i class="emphasis">t</i>. For each edge, the flow and capacity are written as flow/capacity.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4069"></a><a href="DDU0193.html#2538" target="_parent" class="chapter-titlelabel">Chapter 30:</a> Polynomials and the FFT</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0195.html#2558" target="_parent" class="chapterjump">Figure 30.1:</a> A graphical outline of an efficient polynomial-multiplication process. Representations on the top are in coefficient form, while those on the bottom are in point-value form. The arrows from left to right correspond to the multiplication operation. The <i class="emphasis">w</i><sub>2<i class="emphasis">n</i></sub> terms are complex (2<i class="emphasis">n</i>)th roots of unity.</dt>
<dt class="lotentry">
<a href="DDU0196.html#2570" target="_parent" class="chapterjump">Figure 30.2:</a> The values of <span class="inlinemediaobject"><img src="images/fig853_01.jpg" height="14" width="58" alt="" border="0"></span> in the complex plane, where <i class="emphasis">w</i><sub>8</sub> = <i class="emphasis">e</i><sup><span class="unicode">&pi;</span><i class="emphasis">i</i>/8</sup> is the principal 8th root of unity.</dt>
<dt class="lotentry">
<a href="DDU0197.html#2600" target="_parent" class="chapterjump">Figure 30.3:</a> A butterfly operation. (a) The two input values enter from the left, the twiddle factor <span class="inlinemediaobject"><a href="images/fig862%5F01%5F0%2Ejpg" NAME="IMG_1441" target="_parent"><img src="images/fig862_01.jpg" height="14" width="12" alt="Click To expand" border="0"></a></span> is multiplied by <span class="inlinemediaobject"><img src="images/fig862_02.jpg" height="15" width="15" alt="" border="0"></span>, and the sum and difference are output on the right. (b) A simplified drawing of a butterfly operation. We will use this representation in a parallel FFT circuit.</dt>
<dt class="lotentry">
<a href="DDU0197.html#2601" target="_parent" class="chapterjump">Figure 30.4:</a> The tree of input vectors to the recursive calls of the RECURSIVE-FFT procedure. The initial invocation is for <i class="emphasis">n</i> = 8.</dt>
<dt class="lotentry">
<a href="DDU0197.html#2606" target="_parent" class="chapterjump">Figure 30.5:</a> A circuit PARALLEL-FFT that computes the FFT, here shown on <i class="emphasis">n</i> = 8 inputs. Each butterfly operation takes as input the values on two wires, along with a twiddle factor, and it produces as outputs the values on two wires. The stages of butterflies are labeled to correspond to iterations of the outermost loop of the ITERATIVE-FFT procedure. Only the top and bottom wires passing through a butterfly interact with it; wires that pass through the middle of a butterfly do not affect that butterfly, nor are their values changed by that butterfly. For example, the top butterfly in stage 2 has nothing to do with wire 1 (the wire whose output is labeled <i class="emphasis">y</i><sub>1</sub>); its inputs and outputs are only on wires 0 and 2 (labeled <i class="emphasis">y</i><sub>0</sub> and <i class="emphasis">y</i><sub>2</sub>, respectively). An FFT on <i class="emphasis">n</i> inputs can be computed in <span class="unicode">&Theta;</span>(lg <i class="emphasis">n</i>) depth with <span class="unicode">&Theta;</span>(<i class="emphasis">n</i> lg <i class="emphasis">n</i>) butterfly operations.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4072"></a><a href="DDU0199.html#2624" target="_parent" class="chapter-titlelabel">Chapter 31:</a> Number-Theoretic Algorithms</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0201.html#2678" target="_parent" class="chapterjump">Figure 31.1:</a> An example of the operation of EXTENDED-EUCLID on the inputs 99 and 78. Each line shows one level of the recursion: the values of the inputs <i class="emphasis">a</i> and <i class="emphasis">b</i>, the computed value <span class="unicode">&lfloor;</span><i class="emphasis">a/b</i><span class="unicode">&rfloor;</span>, and the values <i class="emphasis">d, x</i>, and <i class="emphasis">y</i> returned. The triple (<i class="emphasis">d, x, y</i>) returned becomes the triple (<i class="emphasis">d<span class="unicode">&prime;</span>, x<span class="unicode">&prime;</span>, y<span class="unicode">&prime;</span></i>) used in the computation at the next higher level of recursion. The call EXTENDED-EUCLID(99, 78) returns (3, -11, 14), so gcd(99, 78) = 3 and gcd(99, 78) = 3 = 99 <span class="unicode">&middot;</span> (-11) + 78 <span class="unicode">&middot;</span> 14.</dt>
<dt class="lotentry">
<a href="DDU0202.html#2694" target="_parent" class="chapterjump">Figure 31.2:</a> Two finite groups. Equivalence classes are denoted by their representative elements. <i class="emphasis">(a)</i> The group (<i class="emphasis">Z</i><sub>6</sub>, +<sub>6</sub>). <i class="emphasis">(b)</i> The group (<span class="inlinemediaobject"><img src="images/fig885_01.jpg" height="12" width="30" alt="" border="0"></span>).</dt>
<dt class="lotentry">
<a href="DDU0204.html#2740" target="_parent" class="chapterjump">Figure 31.3:</a> An illustration of the Chinese remainder theorem for <i class="emphasis">n</i><sub>1</sub> = 5 and <i class="emphasis">n</i><sub>2</sub> = 13. For this example, <i class="emphasis">c</i><sub>1</sub> = 26 and <i class="emphasis">c</i><sub>2</sub> = 40. In row <i class="emphasis">i</i>, column <i class="emphasis">j</i> is shown the value of <i class="emphasis">a</i>, modulo 65, such that (<i class="emphasis">a</i> mod 5) = <i class="emphasis">i</i> and (<i class="emphasis">a</i> mod 13) = <i class="emphasis">j</i>. Note that row 0, column 0 contains a 0. Similarly, row 4,column 12 contains a 64 (equivalent to -1). Since <i class="emphasis">c</i><sub>1</sub> = 26, moving down a row increases <i class="emphasis">a</i> by 26. Similarly, <i class="emphasis">c</i><sub>2</sub> = 40 means that moving right by a column increases <i class="emphasis">a</i> by 40. Increasing <i class="emphasis">a</i> by 1 corresponds to moving diagonally downward and to the right, wrapping around from the bottom to the top and from the right to the left.</dt>
<dt class="lotentry">
<a href="DDU0205.html#2756" target="_parent" class="chapterjump">Figure 31.4:</a> The results of MODULAR-EXPONENTIATION when computing <i class="emphasis">a<sup>b</sup></i> (mod <i class="emphasis">n</i>), where <i class="emphasis">a</i> = 7, <i class="emphasis">b</i> = 560 = <span class="unicode">&#12296;</span>1000110000<span class="unicode">&#12297;</span>, and <i class="emphasis">n</i> = 561. The values are shown after each execution of the <i class="emphasis">for</i> loop. The final result is 1.</dt>
<dt class="lotentry">
<a href="DDU0206.html#2767" target="_parent" class="chapterjump">Figure 31.5:</a> Encryption in a public key system. Bob encrypts the message <i class="emphasis">M</i> using Alice's public key <i class="emphasis">P<sub>A</sub></i> and transmits the resulting ciphertext <i class="emphasis">C</i> = <i class="emphasis">P<sub>A</sub></i>(<i class="emphasis">M</i>) to Alice. An eavesdropper who captures the transmitted ciphertext gains no information about <i class="emphasis">M</i>. Alice receives <i class="emphasis">C</i> and decrypts it using her secret key to obtain the original message <i class="emphasis">M</i> = <i class="emphasis">S<sub>A</sub></i>(<i class="emphasis">C</i>).</dt>
<dt class="lotentry">
<a href="DDU0206.html#2769" target="_parent" class="chapterjump">Figure 31.6:</a> Digital signatures in a public-key system. Alice signs the message <i class="emphasis">M</i><span class="unicode">&prime;</span> by appending her digital signature <span class="unicode">&Sigma;</span> = <i class="emphasis">S<sub>A</sub></i>(<i class="emphasis">M</i><span class="unicode">&prime;</span>) to it. She transmits the message/signature pair (<i class="emphasis">M</i><span class="unicode">&prime;</span>, <span class="unicode">&Sigma;</span>) to Bob, who verifies it by checking the equation <i class="emphasis">M</i><span class="unicode">&prime;</span> = <i class="emphasis">P<sub>A</sub></i>(<span class="unicode">&Sigma;</span>). If the equation holds, he accepts (<i class="emphasis">M</i><span class="unicode">&prime;</span>, <span class="unicode">&Sigma;</span>) as a message that has been signed by Alice.</dt>
<dt class="lotentry">
<a href="DDU0208.html#2804" target="_parent" class="chapterjump">Figure 31.7:</a> Pollard's rho heuristic. <i class="emphasis">(a)</i> The values produced by the recurrence <span class="inlinemediaobject"><img src="images/fig921_01.jpg" height="8" width="36" alt="" border="0"></span> <span class="inlinemediaobject"><img src="images/fig921_02.jpg" height="13" width="32" alt="" border="0"></span> mod 1387, starting with <i class="emphasis">x</i><sub>1</sub> = 2. The prime factorization of 1387 is 19 <span class="unicode">&middot;</span> 73. The heavy arrows indicate the iteration steps that are executed before the factor 19 is discovered. The light arrows point to unreached values in the iteration, to illustrate the "rho" shape. The shaded values are the <i class="emphasis">y</i> values stored by POLLARD-RHO. The factor 19 is discovered upon reaching <i class="emphasis">x</i><sub>7</sub> = 177, when gcd(63 - 177, 1387) = 19 is computed. The first <i class="emphasis">x</i> value that would be repeated is 1186, but the factor 19 is discovered before this value is repeated. <i class="emphasis">(b)</i> The values produced by the same recurrence, modulo 19. Every value <i class="emphasis">x<sub>i</sub></i> given in part (a) is equivalent, modulo 19, to the value <span class="inlinemediaobject"><img src="images/fig921_03.jpg" height="12" width="8" alt="" border="0"></span> shown here. For example, both <i class="emphasis">x</i><sub>4</sub> = 63 and <i class="emphasis">x</i><sub>7</sub> = 177 are equivalent to 6, modulo 19. <i class="emphasis">(c)</i> The values produced by the same recurrence, modulo 73. Every value <i class="emphasis">x<sub>i</sub></i> given in part (a) is equivalent, modulo 73, to the value <span class="inlinemediaobject"><img src="images/fig921_04.jpg" height="12" width="10" alt="" border="0"></span> shown here. By the Chinese remainder theorem, each node in part (a) corresponds to a pair of nodes, one from part (b) and one from part (c).</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4074"></a><a href="DDU0210.html#2821" target="_parent" class="chapter-titlelabel">Chapter 32:</a> String Matching</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0210.html#2824" target="_parent" class="chapterjump">Figure 32.1:</a> The string-matching problem. The goal is to find all occurrences of the pattern <i class="emphasis">P</i> = <span class="fixed">abaa</span> in the text <i class="emphasis">T</i> = <span class="fixed">abcabaabcabac</span>. The pattern occurs only once in the text, at shift <i class="emphasis">s</i> = 3. The shift <i class="emphasis">s</i> = 3 is said to be a valid shift. Each character of the pattern is connected by a vertical line to the matching character in the text, and all matched characters are shown shaded.</dt>
<dt class="lotentry">
<a href="DDU0210.html#2826" target="_parent" class="chapterjump">Figure 32.2:</a> The string-matching algorithms in this chapter and their preprocessing and matching times.</dt>
<dt class="lotentry">
<a href="DDU0211.html#2830" target="_parent" class="chapterjump">Figure 32.3:</a> A graphical proof of Lemma 32.1. We suppose that <i class="emphasis">x</i> <span class="unicode">&#8848;</span> <i class="emphasis">z</i> and <i class="emphasis">y</i> <span class="unicode">&#8848;</span> <i class="emphasis">z</i>. The three parts of the figure illustrate the three cases of the lemma. Vertical lines connect matching regions (shown shaded) of the strings. <i class="emphasis">(a)</i> If |<i class="emphasis">x</i>| <span class="unicode">&le;</span> |<i class="emphasis">y</i>|, then <i class="emphasis">x</i> <span class="unicode">&#8848;</span> <i class="emphasis">y</i>. <i class="emphasis">(b)</i> If |<i class="emphasis">x</i>| <span class="unicode">&ge;</span> |<i class="emphasis">y</i>|, then <i class="emphasis">y</i> <span class="unicode">&#8848;</span> <i class="emphasis">x</i>. <i class="emphasis">(c)</i> If |<i class="emphasis">x</i>| = |<i class="emphasis">y</i>|, then <i class="emphasis">x</i> = <i class="emphasis">y</i>.</dt>
<dt class="lotentry">
<a href="DDU0212.html#2833" target="_parent" class="chapterjump">Figure 32.4:</a> The operation of the naive string matcher for the pattern <i class="emphasis">P</i> = <span class="fixed">aab</span> and the text <i class="emphasis">T</i> = <span class="fixed">acaabc</span>. We can imagine the pattern <i class="emphasis">P</i> as a "template" that we slide next to the text. <i class="emphasis">(a)</i><span class="unicode">&ndash;</span><i class="emphasis">(d)</i> The four successive alignments tried by the naive string matcher. In each part, vertical lines connect corresponding regions found to match (shown shaded), and a jagged line connects the first mismatched character found, if any. One occurrence of the pattern is found, at shift <i class="emphasis">s</i> = 2, shown in part (c).</dt>
<dt class="lotentry">
<a href="DDU0213.html#2844" target="_parent" class="chapterjump">Figure 32.5:</a> The Rabin-Karp algorithm. Each character is a decimal digit, and we compute values modulo 13. <i class="emphasis">(a)</i> A text string. A window of length 5 is shown shaded. The numerical value of the shaded number is computed modulo 13, yielding the value 7. <i class="emphasis">(b)</i> The same text string with values computed modulo 13 for each possible position of a length-5 window. Assuming the pattern <i class="emphasis">P</i> = 31415, we look for windows whose value modulo 13 is 7, since 31415 <span class="unicode">&equiv;</span> 7 (mod 13). Two such windows are found, shown shaded in the figure. The first, beginning at text position 7, is indeed an occurrence of the pattern, while the second, beginning at text position 13, is a spurious hit. <i class="emphasis">(c)</i> Computing the value for a window in constant time, given the value for the previous window. The first window has value 31415. Dropping the high-order digit 3, shifting left (multiplying by 10), and then adding in the low-order digit 2 gives us the new value 14152. All computations are performed modulo 13, however, so the value for the first window is 7, and the value computed for the new window is 8.</dt>
<dt class="lotentry">
<a href="DDU0214.html#2856" target="_parent" class="chapterjump">Figure 32.6:</a> A simple two-state finite automaton with state set <i class="emphasis">Q</i> = {0, 1}, start state <i class="emphasis">q</i><sub>0</sub> = 0, and input alphabet <span class="unicode">&Sigma;</span> = {<span class="fixed">a</span>, <span class="fixed">b</span>}. <i class="emphasis">(a)</i> A tabular representation of the transition function <i class="emphasis"><span class="unicode">&delta;</span></i>. <i class="emphasis">(b)</i> An equivalent state-transition diagram. State 1 is the only accepting state (shown blackened). Directed edges represent transitions. For example, the edge from state 1 to state 0 labeled <span class="fixed">b</span> indicates <i class="emphasis"><span class="unicode">&delta;</span></i>(1, <span class="fixed">b</span>) = 0. This automaton accepts those strings that end in an odd number of <span class="fixed">a</span>'s. More precisely, a string <i class="emphasis">x</i> is accepted if and only if <i class="emphasis">x</i> = <i class="emphasis">yz</i>, where <i class="emphasis">y</i> = <i class="emphasis"><span class="unicode">&epsilon;</span></i> or <i class="emphasis">y</i> ends with a <span class="fixed">b</span>, and <i class="emphasis">z</i> = <span class="fixed">a</span><sup><i class="emphasis">k</i></sup>, where <i class="emphasis">k</i> is odd. For example, the sequence of states this automaton enters for input <span class="fixed">abaaa</span> (including the start state) is <span class="unicode">&#12296;</span>0, 1, 0, 1, 0, 1<span class="unicode">&#12297;</span>, and so it accepts this input. For input <span class="fixed">abbaa</span>, the sequence of states is <span class="unicode">&#12296;</span>0, 1, 0, 0, 1, 0<span class="unicode">&#12297;</span>, and so it rejects this input.</dt>
<dt class="lotentry">
<a href="DDU0214.html#2858" target="_parent" class="chapterjump">Figure 32.7:</a> <i class="emphasis">(a)</i> A state-transition diagram for the string-matching automaton that accepts all strings ending in the string <span class="fixed">ababaca</span>. State 0 is the start state, and state 7 (shown blackened) is the only accepting state. A directed edge from state <i class="emphasis">i</i> to state <i class="emphasis">j</i> labeled <i class="emphasis">a</i> represents <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">i, a</i>) = <i class="emphasis">j</i>. The right-going edges forming the "spine" of the automaton, shown heavy in the figure, correspond to successful matches between pattern and input characters. The left-going edges correspond to failing matches. Some edges corresponding to failing matches are not shown; by convention, if a state <i class="emphasis">i</i> has no outgoing edge labeled <i class="emphasis">a</i> for some <i class="emphasis">a</i> <span class="unicode">&isin;</span> <span class="unicode">&Sigma;</span>, then <i class="emphasis"><span class="unicode">&delta;</span></i>(<i class="emphasis">i, a</i>) = 0. <i class="emphasis">(b)</i> The corresponding transition function <i class="emphasis"><span class="unicode">&delta;</span></i>, and the pattern string <i class="emphasis">P</i> = <span class="fixed">ababaca</span>. The entries corresponding to successful matches between pattern and input characters are shown shaded. <i class="emphasis">(c)</i> The operation of the automaton on the text <i class="emphasis">T</i> = <span class="fixed">abababacaba</span>. Under each text character <i class="emphasis">T</i> [<i class="emphasis">i</i>] is given the state <i class="emphasis"><span class="unicode">&phi;</span></i>(<i class="emphasis">T<sub>i</sub></i>) the automaton is in after processing the prefix <i class="emphasis">T<sub>i</sub></i>. One occurrence of the pattern is found, ending in position 9.</dt>
<dt class="lotentry">
<a href="DDU0214.html#2865" target="_parent" class="chapterjump">Figure 32.8:</a> An illustration for the proof of Lemma 32.2. The figure shows that <i class="emphasis">r</i> <span class="unicode">&le;</span> <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">x</i>) + 1, where <i class="emphasis">r</i> = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">xa</i>).</dt>
<dt class="lotentry">
<a href="DDU0214.html#2867" target="_parent" class="chapterjump">Figure 32.9:</a> An illustration for the proof of Lemma 32.3. The figure shows that <i class="emphasis">r</i> = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">P<sub>q</sub>a</i>), where <i class="emphasis">q</i> = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">x</i>) and <i class="emphasis">r</i> = <i class="emphasis"><span class="unicode">&sigma;</span></i>(<i class="emphasis">xa</i>).</dt>
<dt class="lotentry">
<a href="DDU0215.html#2880" target="_parent" class="chapterjump">Figure 32.10:</a> The prefix function <span class="unicode">&pi;</span>. <i class="emphasis">(a)</i> The pattern <i class="emphasis">P</i> = <span class="fixed">ababaca</span> is aligned with a text <i class="emphasis">T</i> so that the first <i class="emphasis">q</i> = 5 characters match. Matching characters, shown shaded, are connected by vertical lines. <i class="emphasis">(b)</i> Using only our knowledge of the 5 matched characters, we can deduce that a shift of <i class="emphasis">s</i> + 1 is invalid, but that a shift of <i class="emphasis">s</i><span class="unicode">&prime;</span> = <i class="emphasis">s</i> + 2 is consistent with everything we know about the text and therefore is potentially valid. <i class="emphasis">(c)</i> The useful information for such deductions can be precomputed by comparing the pattern with itself. Here, we see that the longest prefix of <i class="emphasis">P</i> that is also a proper suffix of <i class="emphasis">P</i><sub>5</sub> is <i class="emphasis">P</i><sub>3</sub>. This information is precomputed and represented in the array <span class="unicode">&pi;</span>, so that <span class="unicode">&pi;</span>[5] = 3. Given that <i class="emphasis">q</i> characters have matched successfully at shift <i class="emphasis">s</i>, the next potentially valid shift is at <i class="emphasis">s</i><span class="unicode">&prime;</span> = <i class="emphasis">s</i> + (<i class="emphasis">q</i> - <span class="unicode">&pi;</span>[<i class="emphasis">q</i>]).</dt>
<dt class="lotentry">
<a href="DDU0215.html#2884" target="_parent" class="chapterjump">Figure 32.11:</a> An illustration of Lemma 32.5 for the pattern <i class="emphasis">P</i> = <span class="fixed">ababababca</span> and <i class="emphasis">q</i> = 8. <i class="emphasis">(a)</i> The <span class="unicode">&pi;</span> function for the given pattern. Since <span class="unicode">&pi;</span>[8] = 6, <span class="unicode">&pi;</span>[6] = 4, <span class="unicode">&pi;</span>[4] = 2, and <span class="unicode">&pi;</span>[2] = 0, by iterating <span class="unicode">&pi;</span> we obtain <span class="unicode">&pi;</span>*[8] = {6, 4, 2, 0}. <i class="emphasis">(b)</i> We slide the template containing the pattern <i class="emphasis">P</i> to the right and note when some prefix <i class="emphasis">P<sub>k</sub></i> of <i class="emphasis">P</i> matches up with some proper suffix of <i class="emphasis">P</i><sub>8</sub>; this happens for <i class="emphasis">k</i> = 6, 4, 2, and 0. In the figure, the first row gives <i class="emphasis">P</i>, and the dotted vertical line is drawn just after <i class="emphasis">P</i><sub>8</sub>. Successive rows show all the shifts of <i class="emphasis">P</i> that cause some prefix <i class="emphasis">P<sub>k</sub></i> of <i class="emphasis">P</i> to match some suffix of <i class="emphasis">P</i><sub>8</sub>. Successfully matched characters are shown shaded. Vertical lines connect aligned matching characters. Thus, {<i class="emphasis">k</i> : <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">q</i> and <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i>} = {6, 4,2, 0}. The lemma claims that <span class="unicode">&pi;</span>*[<i class="emphasis">q</i>] = {<i class="emphasis">k</i> : <i class="emphasis">k</i> <span class="unicode">&lt;</span> <i class="emphasis">q</i> and <i class="emphasis">P<sub>k</sub></i> <span class="unicode">&#8848;</span> <i class="emphasis">P<sub>q</sub></i>} for all <i class="emphasis">q</i>.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4076"></a><a href="DDU0217.html#2909" target="_parent" class="chapter-titlelabel">Chapter 33:</a> Computational Geometry</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0218.html#2916" target="_parent" class="chapterjump">Figure 33.1:</a> <i class="emphasis">(a)</i> The cross product of vectors <i class="emphasis">p</i><sub>1</sub> and <i class="emphasis">p</i><sub>2</sub> is the signed area of the parallelogram. <i class="emphasis">(b)</i> The lightly shaded region contains vectors that are clockwise from <i class="emphasis">p</i>. The darkly shaded region contains vectors that are counterclockwise from <i class="emphasis">p</i>.</dt>
<dt class="lotentry">
<a href="DDU0218.html#2919" target="_parent" class="chapterjump">Figure 33.2:</a> Using the cross product to determine how consecutive line segments <span class="inlinemediaobject"><img src="images/fig958_01.jpg" height="11" width="22" alt="" border="0"></span> and <span class="inlinemediaobject"><img src="images/fig958_02.jpg" height="10" width="22" alt="" border="0"></span> turn at point <i class="emphasis">p</i><sub>1</sub>. We check whether the directed segment <span class="inlinemediaobject"><img src="images/fig958_03.jpg" height="12" width="20" alt="" border="0"></span> is clockwise or counterclockwise relative to the directed segment <span class="inlinemediaobject"><img src="images/fig958_04.jpg" height="12" width="20" alt="" border="0"></span>. <i class="emphasis">(a)</i> If counterclockwise, the points make a left turn. <i class="emphasis">(b)</i> If clockwise, they make a right turn.</dt>
<dt class="lotentry">
<a href="DDU0218.html#2922" target="_parent" class="chapterjump">Figure 33.3:</a> Cases in the procedure SEGMENTS-INTERSECT. <i class="emphasis">(a)</i> The segments <span class="inlinemediaobject"><img src="images/fig960_01.jpg" height="11" width="23" alt="" border="0"></span> and <span class="inlinemediaobject"><img src="images/fig960_02.jpg" height="10" width="23" alt="" border="0"></span> straddle each other's lines. Because <span class="inlinemediaobject"><img src="images/fig960_03.jpg" height="10" width="22" alt="" border="0"></span> straddles the line containing <span class="inlinemediaobject"><img src="images/fig960_04.jpg" height="10" width="22" alt="" border="0"></span>, the signs of the cross products (<i class="emphasis">p</i><sub>3</sub> - <i class="emphasis">p</i><sub>1</sub>) <span class="unicode">&times;</span> (<i class="emphasis">p</i><sub>2</sub> - <i class="emphasis">p</i><sub>1</sub>) and (<i class="emphasis">p</i><sub>4</sub> - <i class="emphasis">p</i><sub>1</sub>) <span class="unicode">&times;</span> (<i class="emphasis">p</i><sub>2</sub> - <i class="emphasis">p</i><sub>1</sub>) differ. Because <span class="inlinemediaobject"><img src="images/fig960_05.jpg" height="10" width="22" alt="" border="0"></span> straddles the line containing <span class="inlinemediaobject"><img src="images/fig960_06.jpg" height="9" width="22" alt="" border="0"></span>, the signs of the cross products (<i class="emphasis">p</i><sub>1</sub> - <i class="emphasis">p</i><sub>3</sub>) <span class="unicode">&times;</span> (<i class="emphasis">p</i><sub>4</sub> - <i class="emphasis">p</i><sub>3</sub>) and (<i class="emphasis">p</i><sub>2</sub> - <i class="emphasis">p</i><sub>3</sub>) <span class="unicode">&times;</span> (<i class="emphasis">p</i><sub>4</sub> - <i class="emphasis">p</i><sub>3</sub>) differ. <i class="emphasis">(b)</i> Segment <span class="inlinemediaobject"><img src="images/fig960_07.jpg" height="10" width="23" alt="" border="0"></span> straddles the line containing <span class="inlinemediaobject"><img src="images/fig960_08.jpg" height="10" width="23" alt="" border="0"></span>, but <span class="inlinemediaobject"><img src="images/fig960_09.jpg" height="10" width="22" alt="" border="0"></span> does not straddle the line containing <span class="inlinemediaobject"><img src="images/fig960_10.jpg" height="10" width="21" alt="" border="0"></span>. The signs of the cross products (<i class="emphasis">p</i><sub>1</sub> - <i class="emphasis">p</i><sub>3</sub>) <span class="unicode">&times;</span> (<i class="emphasis">p</i><sub>4</sub> - <i class="emphasis">p</i><sub>3</sub>) and (<i class="emphasis">p</i><sub>2</sub> - <i class="emphasis">p</i><sub>3</sub>) <span class="unicode">&times;</span> (<i class="emphasis">p</i><sub>4</sub> - <i class="emphasis">p</i><sub>3</sub>) are the same. <i class="emphasis">(c)</i> Point <i class="emphasis">p</i><sub>3</sub> is collinear with <span class="inlinemediaobject"><img src="images/fig960_11.jpg" height="11" width="21" alt="" border="0"></span> and is between <i class="emphasis">p</i><sub>1</sub> and <i class="emphasis">p</i><sub>2</sub>. <i class="emphasis">(d)</i> Point <i class="emphasis">p</i><sub>3</sub> is collinear with <span class="inlinemediaobject"><img src="images/fig960_12.jpg" height="11" width="21" alt="" border="0"></span>, but it is not between <i class="emphasis">p</i><sub>1</sub> and <i class="emphasis">p</i><sub>2</sub>. The segments do not intersect.</dt>
<dt class="lotentry">
<a href="DDU0219.html#2938" target="_parent" class="chapterjump">Figure 33.4:</a> The ordering among line segments at various vertical sweep lines. <i class="emphasis">(a)</i> We have <i class="emphasis">a</i> <span class="unicode">&gt;</span><i class="emphasis"><sub>r</sub> c</i>, <i class="emphasis">a</i> <span class="unicode">&gt;</span><i class="emphasis"><sub>t</sub> b, b</i> <span class="unicode">&gt;</span><i class="emphasis"><sub>t</sub> c, a</i> <span class="unicode">&gt;</span><i class="emphasis"><sub>r</sub> c</i>, and <i class="emphasis">b</i> <span class="unicode">&gt;</span><i class="emphasis"><sub>u</sub> c</i>. Segment <i class="emphasis">d</i> is comparable with no other segment shown. <i class="emphasis">(b)</i> When segments <i class="emphasis">e</i> and <i class="emphasis">f</i> intersect, their orders are reversed: we have <i class="emphasis">e</i> <span class="unicode">&gt;</span><i class="emphasis"><sub>v</sub> f</i> but <i class="emphasis">f</i> <span class="unicode">&gt;</span><i class="emphasis"><sub>w</sub> e</i>. Any sweep line (such as <i class="emphasis">z</i>) that passes through the shaded region has <i class="emphasis">e</i> and <i class="emphasis">f</i> consecutive in its total order.</dt>
<dt class="lotentry">
<a href="DDU0219.html#2943" target="_parent" class="chapterjump">Figure 33.5:</a> The execution of ANY-SEGMENTS-INTERSECT. Each dashed line is the sweep line at an event point, and the ordering of segment names below each sweep line is the total order <i class="emphasis">T</i> at the end of the <i class="emphasis">for</i> loop in which the corresponding event point is processed. The intersection of segments <i class="emphasis">d</i> and <i class="emphasis">b</i> is found when segment <i class="emphasis">c</i> is deleted.</dt>
<dt class="lotentry">
<a href="DDU0220.html#2960" target="_parent" class="chapterjump">Figure 33.6:</a> A set of points <i class="emphasis">Q</i> = {<i class="emphasis">p</i><sub>0</sub>, <i class="emphasis">p</i><sub>1</sub>, ..., <i class="emphasis">p</i><sub>12</sub>} with its convex hull CH(<i class="emphasis">Q</i>) in gray.</dt>
<dt class="lotentry">
<a href="DDU0220.html#2967" target="_parent" class="chapterjump">Figure 33.7:</a> The execution of GRAHAM-SCAN on the set <i class="emphasis">Q</i> of Figure 33.6. The current convex hull contained in stack <i class="emphasis">S</i> is shown in gray at each step. <i class="emphasis">(a)</i> The sequence <span class="unicode">&#12296;</span> <i class="emphasis">p</i><sub>1</sub>, <i class="emphasis">p</i><sub>2</sub>, ..., <i class="emphasis">p</i><sub>12</sub><span class="unicode">&#12297;</span> of points numbered in order of increasing polar angle relative to <i class="emphasis">p</i><sub>0</sub>, and the initial stack <i class="emphasis">S</i> containing <i class="emphasis">p</i><sub>0</sub>, <i class="emphasis">p</i><sub>1</sub>, and <i class="emphasis">p</i><sub>2</sub>. <i class="emphasis">(b)<span class="unicode">&ndash;</span>(k)</i> Stack <i class="emphasis">S</i> after each iteration of the <i class="emphasis">for</i> loop of lines 6<span class="unicode">&ndash;</span>9. Dashed lines show nonleft turns, which cause points to be popped from the stack. In part (h), for example, the right turn at angle <span class="unicode">&ang;</span><i class="emphasis">p</i><sub>7</sub><i class="emphasis">p</i><sub>8</sub><i class="emphasis">p</i><sub>9</sub> causes <i class="emphasis">p</i><sub>8</sub> to be popped, and then the right turn at angle <span class="unicode">&ang;</span><i class="emphasis">p</i><sub>6</sub><i class="emphasis">p</i><sub>7</sub><i class="emphasis">p</i><sub>9</sub> causes <i class="emphasis">p</i><sub>7</sub> to be popped. <i class="emphasis">(l)</i> The convex hull returned by the procedure, which matches that of Figure 33.6.</dt>
<dt class="lotentry">
<a href="DDU0220.html#2970" target="_parent" class="chapterjump">Figure 33.8:</a> The proof of correctness of GRAHAM-SCAN. <i class="emphasis">(a)</i> Because <i class="emphasis">p<sub>i</sub></i>'s polar angle relative to <i class="emphasis">p</i><sub>0</sub> is greater than <i class="emphasis">p<sub>j</sub></i>'s polar angle, and because the angle <span class="unicode">&ang;</span><i class="emphasis">p<sub>k</sub>p<sub>j</sub> p<sub>i</sub></i> makes a left turn, adding <i class="emphasis">p<sub>i</sub></i> to CH(<i class="emphasis">Q<sub>j</sub></i>) gives exactly the vertices of CH(<i class="emphasis">Q<sub>j</sub></i> <span class="unicode">&cup;</span>{<i class="emphasis">p<sub>i</sub></i>}). <i class="emphasis">(b)</i> If the angle <span class="unicode">&ang;</span><i class="emphasis">p<sub>r</sub>p<sub>t</sub>p<sub>i</sub></i> makes a nonleft turn, then <i class="emphasis">p<sub>t</sub></i> is either in the interior of the triangle formed by <i class="emphasis">p</i><sub>0</sub>, <i class="emphasis">p<sub>r</sub></i>, and <i class="emphasis">p<sub>i</sub></i> or on a side of the triangle, and it cannot be a vertex of CH(<i class="emphasis">Q<sub>i</sub></i>).</dt>
<dt class="lotentry">
<a href="DDU0220.html#2974" target="_parent" class="chapterjump">Figure 33.9:</a> The operation of Jarvis's march. The first vertex chosen is the lowest point <i class="emphasis">p</i><sub>0</sub>. The next vertex, <i class="emphasis">p</i><sub>1</sub>, has the smallest polar angle of any point with respect to <i class="emphasis">p</i><sub>0</sub>. Then, <i class="emphasis">p</i><sub>2</sub> has the smallest polar angle with respect to <i class="emphasis">p</i><sub>1</sub>. The right chain goes as high as the highest point <i class="emphasis">p</i><sub>3</sub>. Then, the left chain is constructed by finding smallest polar angles with respect to the negative <i class="emphasis">x</i>-axis.</dt>
<dt class="lotentry">
<a href="DDU0220.html#2979" target="_parent" class="chapterjump">Figure 33.10:</a> The definition of a star-shaped polygon, for use in Exercise 33.3-4. <i class="emphasis">(a)</i> A star-shaped polygon. The segment from point <i class="emphasis">p</i> to any point <i class="emphasis">q</i> on the boundary intersects the boundary only at <i class="emphasis">q</i>. <i class="emphasis">(b)</i> A non-star-shaped polygon. The shaded region on the left is the shadow of <i class="emphasis">q</i>, and the shaded region on the right is the shadow of <i class="emphasis">q</i><span class="unicode">&prime;</span>. Since these regions are disjoint, the kernel is empty.</dt>
<dt class="lotentry">
<a href="DDU0221.html#2984" target="_parent" class="chapterjump">Figure 33.11:</a> Key concepts in the proof that the closest-pair algorithm needs to check only 7 points following each point in the array Y<span class="unicode">&prime;</span>. <i class="emphasis">(a)</i> If <i class="emphasis">p<sub>L</sub></i> <span class="unicode">&isin;</span> <i class="emphasis">P<sub>L</sub></i> and <i class="emphasis">p<sub>R</sub></i> <span class="unicode">&isin;</span> <i class="emphasis">P<sub>R</sub></i> are less than <span class="unicode">&delta;</span> units apart, they must reside within a <span class="unicode">&delta;</span> <span class="unicode">&times;</span> 2<span class="unicode">&delta;</span> rectangle centered at line <i class="emphasis">l</i>. <i class="emphasis">(b)</i> How 4 points that are pairwise at least <span class="unicode">&delta;</span> units apart can all reside within a <span class="unicode">&delta;</span> <span class="unicode">&times;</span> <span class="unicode">&delta;</span> square. On the left are 4 points in <i class="emphasis">P<sub>L</sub></i>, and on the right are 4 points in <i class="emphasis">P<sub>R</sub></i>. There can be 8 points in the <span class="unicode">&delta;</span> <span class="unicode">&times;</span> 2<span class="unicode">&delta;</span> rectangle if the points shown on line l are actually pairs of coincident points with one point in <i class="emphasis">P<sub>L</sub></i> and one in <i class="emphasis">P<sub>R</sub></i>.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4078"></a><a href="DDU0223.html#3001" target="_parent" class="chapter-titlelabel">Chapter 34:</a> NP-Completeness</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0226.html#3012" target="_parent" class="chapterjump">Figure 34.1:</a> Using a polynomial-time reduction algorithm to solve a decision problem <i class="emphasis">A</i> in polynomial time, given a polynomial-time decision algorithm for another problem <i class="emphasis">B</i>. In polynomial time, we transform an instance <i class="emphasis"><span class="unicode">&alpha;</span></i> of <i class="emphasis">A</i> into an instance <i class="emphasis"><span class="unicode">&beta;</span></i> of <i class="emphasis">B</i>, we solve <i class="emphasis">B</i> in polynomial time, and we use the answer for <i class="emphasis"><span class="unicode">&beta;</span></i> as the answer for <i class="emphasis"><span class="unicode">&alpha;</span></i>.</dt>
<dt class="lotentry">
<a href="DDU0229.html#3038" target="_parent" class="chapterjump">Figure 34.2:</a> <i class="emphasis">(a)</i> A graph representing the vertices, edges, and faces of a dodecahedron, with a hamiltonian cycle shown by shaded edges. <i class="emphasis">(b)</i> A bipartite graph with an odd number of vertices. Any such graph is nonhamiltonian.</dt>
<dt class="lotentry">
<a href="DDU0229.html#3044" target="_parent" class="chapterjump">Figure 34.3:</a> Four possibilities for relationships among complexity classes. In each diagram, one region enclosing another indicates a proper-subset relation. <i class="emphasis">(a)</i> P = NP = co-NP. Most researchers regard this possibility as the most unlikely. <i class="emphasis">(b)</i> If NP is closed under complement, then NP = co-NP, but it need not be the case that P = NP. <i class="emphasis">(c)</i> P = NP <span class="unicode">&cup;</span> co-NP, but NP is not closed under complement. <i class="emphasis">(d)</i> NP <span class="unicode">&ne;</span> co-NP and P <span class="unicode">&ne;</span> NP <span class="unicode">&cup;</span> co-NP. Most researchers regard this possibility as the most likely.</dt>
<dt class="lotentry">
<a href="DDU0230.html#3061" target="_parent" class="chapterjump">Figure 34.4:</a> An illustration of a polynomial-time reduction from a language <i class="emphasis">L</i><sub>1</sub> to a language <i class="emphasis">L</i><sub>2</sub> via a reduction function <i class="emphasis">f</i>. For any input <i class="emphasis">x</i> <span class="unicode">&isin;</span> {0, 1}*, the question of whether <i class="emphasis">x</i> <span class="unicode">&isin;</span> <i class="emphasis">L</i><sub>1</sub> has the same answer as the question of whether <i class="emphasis">f</i>(<i class="emphasis">x</i>) <span class="unicode">&isin;</span> <i class="emphasis">L</i><sub>2</sub>.</dt>
<dt class="lotentry">
<a href="DDU0230.html#3063" target="_parent" class="chapterjump">Figure 34.5:</a> The proof of Lemma 34.3. The algorithm <i class="emphasis">F</i> is a reduction algorithm that computes the reduction function <i class="emphasis">f</i> from <i class="emphasis">L</i><sub>1</sub> to <i class="emphasis">L</i><sub>2</sub> in polynomial time, and <i class="emphasis">A</i><sub>2</sub> is a polynomial-time algorithm that decides <i class="emphasis">L</i><sub>2</sub>. Illustrated is an algorithm <i class="emphasis">A</i>1 that decides whether <i class="emphasis">x</i> <span class="unicode">&isin;</span> <i class="emphasis">L</i><sub>1</sub> by using F to transform any input <i class="emphasis">x</i> into <i class="emphasis">f</i> (<i class="emphasis">x</i>) and then using <i class="emphasis">A</i><sub>2</sub> to decide whether <i class="emphasis">f</i>(<i class="emphasis">x</i>) <span class="unicode">&isin;</span> <i class="emphasis">L</i><sub>2</sub>.</dt>
<dt class="lotentry">
<a href="DDU0230.html#3067" target="_parent" class="chapterjump">Figure 34.6:</a> How most theoretical computer scientists view the relationships among P, NP, and NPC. Both P and NPC are wholly contained within NP, and P <span class="unicode">&cap;</span> NPC = <span class="unicode">&Oslash;</span>.</dt>
<dt class="lotentry">
<a href="DDU0230.html#3070" target="_parent" class="chapterjump">Figure 34.7:</a> Three basic logic gates, with binary inputs and outputs. Under each gate is the truth table that describes the gate's operation. <i class="emphasis">(a)</i> The NOT gate. <i class="emphasis">(b)</i> The AND gate. <i class="emphasis">(c)</i> The OR gate.</dt>
<dt class="lotentry">
<a href="DDU0230.html#3072" target="_parent" class="chapterjump">Figure 34.8:</a> Two instances of the circuit-satisfiability problem. <i class="emphasis">(a)</i> The assignment <span class="unicode">&#12296;</span><i class="emphasis">x</i><sub>1</sub> = 1, <i class="emphasis">x</i><sub>2</sub> = 1, <i class="emphasis">x</i><sub>3</sub> = 0<span class="unicode">&#12297;</span> to the inputs of this circuit causes the output of the circuit to be 1. The circuit is therefore satisfiable. <i class="emphasis">(b)</i> No assignment to the inputs of this circuit can cause the output of the circuit to be 1. The circuit is therefore unsatisfiable.</dt>
<dt class="lotentry">
<a href="DDU0230.html#3078" target="_parent" class="chapterjump">Figure 34.9:</a> The sequence of configurations produced by an algorithm A running on an input <i class="emphasis">x</i> and certificate <i class="emphasis">y</i>. Each configuration represents the state of the computer for one step of the computation and, besides <i class="emphasis">A, x</i>, and <i class="emphasis">y</i>, includes the program counter (PC), auxiliary machine state, and working storage. Except for the certificate <i class="emphasis">y</i>, the initial configuration <i class="emphasis">c</i><sub>0</sub> is constant. Each configuration is mapped to the next configuration by a boolean combinational circuit <i class="emphasis">M</i>. The output is a distinguished bit in the working storage.</dt>
<dt class="lotentry">
<a href="DDU0231.html#3099" target="_parent" class="chapterjump">Figure 34.10:</a> Reducing circuit satisfiability to formula satisfiability. The formula produced by the reduction algorithm has a variable for each wire in the circuit.</dt>
<dt class="lotentry">
<a href="DDU0231.html#3104" target="_parent" class="chapterjump">Figure 34.11:</a> The tree corresponding to the formula <i class="emphasis"><span class="unicode">&phi;</span></i> = ((<i class="emphasis">x</i><sub>1</sub> <span class="unicode">&rarr;</span> <i class="emphasis">x</i><sub>2</sub>)<span class="unicode">&or;</span><span class="unicode">&not;</span>((<span class="unicode">&not;</span><i class="emphasis">x</i><sub>1</sub> <span class="unicode">&harr;</span> <i class="emphasis">x</i><sub>3</sub>)<span class="unicode">&or;</span> <i class="emphasis">x</i><sub>4</sub>))<span class="unicode">&and;</span><span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub>.</dt>
<dt class="lotentry">
<a href="DDU0231.html#3106" target="_parent" class="chapterjump">Figure 34.12:</a> The truth table for the clause (<i class="emphasis">y</i><sub>1</sub> <span class="unicode">&harr;</span> (<i class="emphasis">y</i><sub>2</sub> <span class="unicode">&and;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub>)).</dt>
<dt class="lotentry">
<a href="DDU0232.html#3118" target="_parent" class="chapterjump">Figure 34.13:</a> The structure of NP-completeness proofs in Sections 34.4 and 34.5. All proofs ultimately follow by reduction from the NP-completeness of CIRCUIT-SAT.</dt>
<dt class="lotentry">
<a href="DDU0232.html#3122" target="_parent" class="chapterjump">Figure 34.14:</a> The graph <i class="emphasis">G</i> derived from the 3-CNF formula <i class="emphasis"><span class="unicode">&phi;</span></i> = <i class="emphasis">C</i><sub>1</sub> <span class="unicode">&and;</span> <i class="emphasis">C</i><sub>2</sub> <span class="unicode">&and;</span> <i class="emphasis">C</i><sub>3</sub>, where <i class="emphasis">C</i><sub>1</sub> = (<i class="emphasis">x</i><sub>1</sub> <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub> <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>3</sub>), C<sub>2</sub> = (<span class="unicode">&not;</span><i class="emphasis">x</i><sub>1</sub> <span class="unicode">&and;</span> <i class="emphasis">x</i><sub>2</sub> <span class="unicode">&and;</span> <i class="emphasis">x</i><sub>3</sub>), and <i class="emphasis">C</i><sub>3</sub> = (<i class="emphasis">x</i><sub>1</sub> <span class="unicode">&and;</span> <i class="emphasis">x</i><sub>2</sub> <span class="unicode">&and;</span> <i class="emphasis">x</i><sub>3</sub>), in reducing 3-CNF-SAT to CLIQUE. A satisfying assignment of the formula has <i class="emphasis">x</i><sub>2</sub> = 0, <i class="emphasis">x</i><sub>3</sub> = 1, and <i class="emphasis">x</i><sub>1</sub> may be either 0 or 1. This assignment satisfies <i class="emphasis">C</i><sub>1</sub> with <span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub>, and it satisfies <i class="emphasis">C</i><sub>2</sub> and <i class="emphasis">C</i><sub>3</sub> with <i class="emphasis">x</i><sub>3</sub>, corresponding to the clique with lightly shaded vertices.</dt>
<dt class="lotentry">
<a href="DDU0232.html#3126" target="_parent" class="chapterjump">Figure 34.15:</a> Reducing CLIQUE to VERTEX-COVER. <i class="emphasis">(a)</i> An undirected graph <i class="emphasis">G</i> = (<i class="emphasis">V, E</i>) with clique <i class="emphasis">V</i>' = {<i class="emphasis">u, v, x, y</i>}. <i class="emphasis">(b)</i> The graph <span class="inlinemediaobject"><img src="images/fig1029_01.jpg" height="10" width="9" alt="" border="0"></span> produced by the reduction algorithm that has vertex cover <i class="emphasis">V</i> - <i class="emphasis">V</i>' = {<i class="emphasis">w, z</i>}.</dt>
<dt class="lotentry">
<a href="DDU0232.html#3132" target="_parent" class="chapterjump">Figure 34.16:</a> The widget used in reducing the vertex-cover problem to the hamiltonian-cycle problem. An edge (<i class="emphasis">u, v</i>) of graph <i class="emphasis">G</i> corresponds to widget <i class="emphasis">W<sub>uv</sub></i> in the graph <i class="emphasis">G</i>' created in the reduction. <i class="emphasis">(a)</i> The widget, with individual vertices labeled. <i class="emphasis">(b)</i><span class="unicode">&ndash;</span><i class="emphasis">(d)</i> The shaded paths are the only possible ones through the widget that include all vertices, assuming that the only connections from the widget to the remainder of <i class="emphasis">G</i>' are through vertices [<i class="emphasis">u, v</i>, 1], [<i class="emphasis">u, v</i>, 6], [<i class="emphasis">v, u</i>, 1], and [<i class="emphasis">v, u</i>, 6].</dt>
<dt class="lotentry">
<a href="DDU0232.html#3134" target="_parent" class="chapterjump">Figure 34.17:</a> The reduction of an instance of the vertex-cover problem to an instance of the hamiltonian-cycle problem. <i class="emphasis">(a)</i> An undirected graph <i class="emphasis">G</i> with a vertex cover of size 2, consisting of the lightly shaded vertices <i class="emphasis">w</i> and <i class="emphasis">y</i>. <i class="emphasis">(b)</i> The undirected graph <i class="emphasis">G</i>' produced by the reduction, with the hamiltonian path corresponding to the vertex cover shaded. The vertex cover {<i class="emphasis">w, y</i>} corresponds to edges (<i class="emphasis">s</i><sub>1</sub>, [<i class="emphasis">w, x</i>, 1]) and (<i class="emphasis">s</i><sub>2</sub>, [<i class="emphasis">y, x</i>, 1]) appearing in the hamiltonian cycle.</dt>
<dt class="lotentry">
<a href="DDU0232.html#3140" target="_parent" class="chapterjump">Figure 34.18:</a> An instance of the traveling-salesman problem. Shaded edges represent a minimum-cost tour, with cost 7.</dt>
<dt class="lotentry">
<a href="DDU0232.html#3145" target="_parent" class="chapterjump">Figure 34.19:</a> The reduction of 3-CNF-SAT to SUBSET-SUM. The formula in 3-CNF is <i class="emphasis"><span class="unicode">&phi;</span></i> = <i class="emphasis">C</i><sub>1</sub> <span class="unicode">&and;</span> <i class="emphasis">C</i><sub>2</sub> <span class="unicode">&and;</span> <i class="emphasis">C</i><sub>3</sub> <span class="unicode">&and;</span> <i class="emphasis">C</i><sub>4</sub>, where <i class="emphasis">C</i><sub>1</sub> = (<i class="emphasis">x</i><sub>1</sub> <span class="unicode">&or;</span> <span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub> <span class="unicode">&or;</span><span class="unicode">&not;</span><i class="emphasis">x</i><sub>3</sub>), <i class="emphasis">C</i><sub>2</sub> = (<span class="unicode">&not;</span><i class="emphasis">x</i><sub>1</sub> <span class="unicode">&or;</span><span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub> <span class="unicode">&or;</span><span class="unicode">&not;</span><i class="emphasis">x</i><sub>3</sub>), <i class="emphasis">C</i><sub>3</sub> = (<span class="unicode">&not;</span><i class="emphasis">x</i><sub>1</sub> <span class="unicode">&or;</span><span class="unicode">&not;</span><i class="emphasis">x</i><sub>2</sub> <span class="unicode">&or;</span><i class="emphasis">x</i><sub>3</sub>), and <i class="emphasis">C</i><sub>4</sub> = (<i class="emphasis">x</i><sub>1</sub> <i class="emphasis">x</i><sub>2</sub> <i class="emphasis">x</i><sub>3</sub>). A satisfying assignment of <i class="emphasis"><span class="unicode">&phi;</span></i> is <span class="unicode">&#12296;</span><i class="emphasis">x</i><sub>1</sub> = 0, <i class="emphasis">x</i><sub>2</sub> = 0, <i class="emphasis">x</i><sub>3</sub> = 1<span class="unicode">&#12297;</span>. The set S produced by the reduction consists of the base-10 numbers shown; reading from top to bottom, S = {1001001, 1000110, 100001, 101110, 10011, 11100, 1000, 2000, 100, 200, 10, 20, 1, 2}. The target t is 1114444. The subset <i class="emphasis">S</i>' <span class="unicode">&sube;</span> <i class="emphasis">S</i> is lightly shaded, and it contains <span class="inlinemediaobject"><img src="images/fig1037_01.jpg" height="18" width="30" alt="" border="0"></span>, and <span class="inlinemediaobject"><img src="images/fig1037_02.jpg" height="11" width="12" alt="" border="0"></span>, corresponding to the satisfying assignment. It also contains slack variables <span class="inlinemediaobject"><img src="images/fig1037_03.jpg" height="14" width="70" alt="" border="0"></span>, and <span class="inlinemediaobject"><img src="images/fig1037_04.jpg" height="18" width="12" alt="" border="0"></span> to achieve the target value of 4 in the digits labeled by <i class="emphasis">C</i><sub>1</sub> through <i class="emphasis">C</i><sub>4</sub>.</dt>
<dt class="lotentry">
<a href="DDU0232.html#3162" target="_parent" class="chapterjump">Figure 34.20:</a> The widget corresponding to a clause (<i class="emphasis">x</i> <span class="unicode">&or;</span> <i class="emphasis">y</i> <span class="unicode">&or;</span> <i class="emphasis">z</i>), used in Problem 34-3.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4080"></a><a href="DDU0234.html#3166" target="_parent" class="chapter-titlelabel">Chapter 35:</a> Approximation Algorithms</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0236.html#3176" target="_parent" class="chapterjump">Figure 35.1:</a> The operation of APPROX-VERTEX-COVER. <i class="emphasis">(a)</i> The input graph <i class="emphasis">G</i>, which has 7 vertices and 8 edges. <i class="emphasis">(b)</i> The edge (<i class="emphasis">b, c</i>), shown heavy, is the first edge chosen by APPROX-VERTEX-COVER. Vertices <i class="emphasis">b</i> and <i class="emphasis">c</i>, shown lightly shaded, are added to the set <i class="emphasis">C</i> containing the vertex cover being created. Edges (<i class="emphasis">a, b</i>), (<i class="emphasis">c, e</i>), and (<i class="emphasis">c, d</i>), shown dashed, are removed since they are now covered by some vertex in <i class="emphasis">C</i>. <i class="emphasis">(c)</i> Edge (<i class="emphasis">e, f</i>) is chosen; vertices <i class="emphasis">e</i> and <i class="emphasis">f</i> are added to <i class="emphasis">C</i>. <i class="emphasis">(d)</i> Edge (<i class="emphasis">d, g</i>) is chosen; vertices <i class="emphasis">d</i> and <i class="emphasis">g</i> are added to <i class="emphasis">C</i>. <i class="emphasis">(e)</i> The set <i class="emphasis">C</i>, which is the vertex cover produced by APPROX-VERTEX-COVER, contains the six vertices <i class="emphasis">b, c, d, e, f, g</i>. <i class="emphasis">(f)</i> The optimal vertex cover for this problem contains only three vertices: <i class="emphasis">b, d</i>, and <i class="emphasis">e</i>.</dt>
<dt class="lotentry">
<a href="DDU0237.html#3191" target="_parent" class="chapterjump">Figure 35.2:</a> The operation of APPROX-TSP-TOUR. <i class="emphasis">(a)</i> The given set of points, which lie on vertices of an integer grid. For example, <i class="emphasis">f</i> is one unit to the right and two units up from <i class="emphasis">h</i>. The ordinary euclidean distance is used as the cost function between two points. <i class="emphasis">(b)</i> A minimum spanning tree <i class="emphasis">T</i> of these points, as computed by MST-PRIM. Vertex a is the root vertex. The vertices happen to be labeled in such a way that they are added to the main tree by MST-PRIM in alphabetical order. <i class="emphasis">(c)</i> A walk of <i class="emphasis">T</i> , starting at <i class="emphasis">a</i>. A full walk of the tree visits the vertices in the order <i class="emphasis">a, b, c, b, h, b, a, d, e, f, e, g, e, d, a</i>. A preorder walk of <i class="emphasis">T</i> lists a vertex just when it is first encountered, as indicated by the dot next to each vertex, yielding the ordering <i class="emphasis">a, b, c, h, d, e, f, g. (d)</i> A tour of the vertices obtained by visiting the vertices in the order given by the preorder walk. This is the tour <i class="emphasis">H</i> returned by APPROX-TSP-TOUR. Its total cost is approximately 19.074. <i class="emphasis">(e)</i> An optimal tour <i class="emphasis">H</i>* for the given set of vertices. Its total cost is approximately 14.715.</dt>
<dt class="lotentry">
<a href="DDU0238.html#3209" target="_parent" class="chapterjump">Figure 35.3:</a> An instance (<i class="emphasis">X</i>, <span class="inlinemediaobject"><img src="images/fig1056_01.jpg" height="14" width="15" alt="" border="0"></span>) of the set-covering problem, where <i class="emphasis">X</i> consists of the 12 black points and <span class="inlinemediaobject"><img src="images/fig1056_02.jpg" height="12" width="120" alt="" border="0"></span>. A minimum-size set cover is <span class="inlinemediaobject"><img src="images/fig1056_03.jpg" height="11" width="70" alt="" border="0"></span>. The greedy algorithm produces a cover of size 4 by selecting the sets <i class="emphasis">S</i><sub>1</sub>, <i class="emphasis">S</i><sub>4</sub>, <i class="emphasis">S</i><sub>5</sub>, and <i class="emphasis">S</i><sub>3</sub> in order.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4082"></a><a href="DDU0243.html#3275" target="_parent" class="chapter-titlelabel">Appendix A:</a> Summations</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0245.html#3318" target="_parent" class="chapterjump">Figure A.1:</a> Approximation of <span class="inlinemediaobject"><img src="images/fig1090_01.jpg" height="14" width="45" alt="" border="0"></span> by integrals. The area of each rectangle is shown within the rectangle, and the total rectangle area represents the value of the summation. The integral is represented by the shaded area under the curve. By comparing areas in <i class="emphasis">(a)</i>, we get <span class="inlinemediaobject"><img src="images/fig1090_02.jpg" height="13" width="113" alt="" border="0"></span>, and then by shifting the rectangles one unit to the right, we get <span class="inlinemediaobject"><img src="images/fig1090_03.jpg" height="15" width="109" alt="" border="0"></span> in <i class="emphasis">(b)</i>.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4084"></a><a href="DDU0247.html#3329" target="_parent" class="chapter-titlelabel">Appendix B:</a> Sets, Etc.</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0247.html#3336" target="_parent" class="chapterjump">Figure B.1:</a> A Venn diagram illustrating the first of DeMorgan's laws (B.2). Each of the sets <i class="emphasis">A, B</i>, and <i class="emphasis">C</i> is represented as a circle.</dt>
<dt class="lotentry">
<a href="DDU0250.html#3365" target="_parent" class="chapterjump">Figure B.2:</a> Directed and undirected graphs. <i class="emphasis">(a)</i> A directed graph <i class="emphasis">G</i> = (<i class="emphasis">V, E</i>), where <i class="emphasis">V</i> = {1, 2,3, 4, 5,6} and <i class="emphasis">E</i> = {(1, 2), (2, 2), (2, 4), (2, 5), (4, 1), (4, 5), (5, 4), (6, 3)}. The edge (2, 2) is a self-loop. <i class="emphasis">(b)</i> An undirected graph <i class="emphasis">G</i> = (<i class="emphasis">V, E</i>), where <i class="emphasis">V</i> = {1, 2 3, 4, 5, 6} and <i class="emphasis">E</i> = {(1, 2), (1, 5), (2, 5), (3, 6)}. The vertex 4 is isolated. <i class="emphasis">(c)</i> The subgraph of the graph in part (a) induced by the vertex set {1, 2, 3, 6}.</dt>
<dt class="lotentry">
<a href="DDU0250.html#3368" target="_parent" class="chapterjump">Figure B.3:</a> <i class="emphasis">(a)</i> A pair of isomorphic graphs. The vertices of the top graph are mapped to the vertices of the bottom graph by <i class="emphasis">f</i> (1) = <i class="emphasis">u, f</i>(2) = <i class="emphasis">v, f</i> (3) = <i class="emphasis">w, f</i>(4) = <i class="emphasis">x, f</i>(5) = <i class="emphasis">y, f</i>(6) = <i class="emphasis">z. (b)</i> Two graphs that are not isomorphic, since the top graph has a vertex of degree 4 and the bottom graph does not.</dt>
<dt class="lotentry">
<a href="DDU0251.html#3380" target="_parent" class="chapterjump">Figure B.4:</a> <i class="emphasis">(a)</i> A free tree. <i class="emphasis">(b)</i> A forest. <i class="emphasis">(c)</i> A graph that contains a cycle and is therefore neither a tree nor a forest.</dt>
<dt class="lotentry">
<a href="DDU0251.html#3382" target="_parent" class="chapterjump">Figure B.5:</a> A step in the proof of Theorem B.2: if (1) <i class="emphasis">G</i> is a free tree, then (2) any two vertices in <i class="emphasis">G</i> are connected by a unique simple path. Assume for the sake of contradiction that vertices <i class="emphasis">u</i> and <i class="emphasis">v</i> are connected by two distinct simple paths <i class="emphasis">p</i><sub>1</sub> and <i class="emphasis">p</i><sub>2</sub>. These paths first diverge at vertex <i class="emphasis">w</i>, and they first reconverge at vertex <i class="emphasis">z</i>. The path <i class="emphasis">p</i>' concatenated with the reverse of the path <i class="emphasis">p</i>" forms a cycle, which yields the contradiction.</dt>
<dt class="lotentry">
<a href="DDU0251.html#3386" target="_parent" class="chapterjump">Figure B.6:</a> Rooted and ordered trees. <i class="emphasis">(a)</i> A rooted tree with height 4. The tree is drawn in a standard way: the root (node 7) is at the top, its children (nodes with depth 1) are beneath it, their children (nodes with depth 2) are beneath them, and so forth. If the tree is ordered, the relative left-to-right order of the children of a node matters; otherwise it doesn't. <i class="emphasis">(b)</i> Another rooted tree. As a rooted tree, it is identical to the tree in (a), but as an ordered tree it is different, since the children of node 3 appear in a different order.</dt>
<dt class="lotentry">
<a href="DDU0251.html#3390" target="_parent" class="chapterjump">Figure B.7:</a> Binary trees. <i class="emphasis">(a)</i> A binary tree drawn in a standard way. The left child of a node is drawn beneath the node and to the left. The right child is drawn beneath and to the right. <i class="emphasis">(b)</i> A binary tree different from the one in (a). In (a), the left child of node 7 is 5 and the right child is absent. In (b), the left child of node 7 is absent and the right child is 5. As ordered trees, these trees are the same, but as binary trees, they are distinct. <i class="emphasis">(c)</i> The binary tree in (a) represented by the internal nodes of a full binary tree: an ordered tree in which each internal node has degree 2. The leaves in the tree are shown as squares.</dt>
<dt class="lotentry">
<a href="DDU0251.html#3392" target="_parent" class="chapterjump">Figure B.8:</a> A complete binary tree of height 3 with 8 leaves and 7 internal nodes.</dt>
</dl>
</div>
</div>

</div>
<div class="section">
<h2 class="sect2-title">
<a name="4086"></a><a href="DDU0253.html#3407" target="_parent" class="chapter-titlelabel">Appendix C:</a> Counting and Probability</h2>

<div name="lot">
<div class="lot-body">
<dl>
<dt class="lotentry">
<a href="DDU0256.html#3502" target="_parent" class="chapterjump">Figure C.1:</a> A geometric distribution with probability p = 1/3 of success and a probability q = 1 - p of failure. The expectation of the distribution is 1/p = 3.</dt>
<dt class="lotentry">
<a href="DDU0256.html#3508" target="_parent" class="chapterjump">Figure C.2:</a> The binomial distribution b(k; 15, 1/3) resulting from n = 15 Bernoulli trials, each with probability p = 1/3 of success. The expectation of the distribution is np = 5.</dt>
</dl>
</div>
</div>

</div>

</div>
</div>
</div>
</div>
<br><hr size="1">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td align="left" width="30%">
<div STYLE="MARGIN-LEFT: 0.15in;">
<a href="DDU0285.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</div></td>
<td align="center" width="40%">
<a href="toc.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td align="right" width="30%">
<div STYLE="MARGIN-RIGHT: 0.15in"><a href="DDU0287.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr>
</table>
</body>
</html>
