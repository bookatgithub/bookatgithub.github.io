<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>11.3. Useful Built-in Emacs Functions</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="gnu3-CHP-11-SECT-2.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="gnu3-CHP-11-SECT-4.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="gnu3-CHP-11-SECT-3"></A>
<H3 class="docSection1Title">11.3. Useful Built-in Emacs Functions</H3>

<P class="docText">Many of the Emacs functions that
<A NAME="gnu3-CHP-11-ITERM-2782"></A><A NAME="gnu3-CHP-11-ITERM-2783"></A>exist and that you may write involve
searching and manipulating the text in a buffer. Such functions are
particularly useful in specialized modes, like the programming
language modes described in <A class="docLink" HREF="gnu3-CHP-9.html#gnu3-CHP-9">Chapter 9</A>. Many
built-in Emacs functions relate to text in strings and buffers; the
most interesting ones take advantage of Emacs's
regular expression facility, which we introduced in <A class="docLink" HREF="gnu3-CHP-3.html#gnu3-CHP-3">Chapter 3</A>.</P>

<P class="docText">We first describe the basic functions relating to buffers and strings
that don't use regular expressions. Afterwards, we
discuss regular expressions in more depth than was the case in <A class="docLink" HREF="gnu3-CHP-3.html#gnu3-CHP-3">Chapter 3</A>, concentrating on the features that are
most useful to Lisp programmers, and we describe the functions that
Emacs makes available for dealing with regular expressions.</P>

<A NAME="gnu3-CHP-11-SECT-3.1"></A>
<H4 class="docSection2Title">11.3.1 Buffers, Text, and Regions</H4>

<P class="docText"><A class="docLink" HREF="#gnu3-CHP-11-TABLE-4">Table 11-4</A> shows some basic
<A NAME="gnu3-CHP-11-ITERM-2784"></A><A NAME="gnu3-CHP-11-ITERM-2785"></A><A NAME="gnu3-CHP-11-ITERM-2786"></A><A NAME="gnu3-CHP-11-ITERM-2787"></A><A NAME="gnu3-CHP-11-ITERM-2788"></A><A NAME="gnu3-CHP-11-ITERM-2789"></A><A NAME="gnu3-CHP-11-ITERM-2790"></A><A NAME="gnu3-CHP-11-ITERM-2791"></A><A NAME="gnu3-CHP-11-ITERM-2792"></A>Emacs functions relating to buffers,
text, and strings that are only useful to Lisp programmers and thus
aren't bound to keystrokes. We already saw a couple
of them in the <span class="docEmphBold">count-words-buffer</span>
example. Notice that some of these are predicates, and their names
reflect this.</P>

<A NAME="gnu3-CHP-11-TABLE-4"></A><P><TABLE CELLSPACING="0" BORDER="1" RULES="all" CELLPADDING="4" WIDTH="100%"><CAPTION><h5 class="docTableTitle">Table 11-4. Buffer and text functions</h5></CAPTION><COLGROUP><COL><COL></COLGROUP><THEAD><TR><TH class="thead" scope="col">
<P class="docText"><span class="docEmphBold">Function</span></P>
</TH><TH class="thead" scope="col">
<P class="docText"><span class="docEmphBold">Value or action</span></P>
</TH></TR></THEAD><TR><TD class="docTableCell">
<P class="docText"><span class="docEmphBold">point</span></P>
</TD><TD class="docTableCell">
<P class="docText">Character position of point.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><span class="docEmphBold">mark</span></P>
</TD><TD class="docTableCell">
<P class="docText">Character position of mark.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><span class="docEmphBold">point-min</span></P>
</TD><TD class="docTableCell">
<P class="docText">Minimum character position (usually 1).</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><span class="docEmphBold">point-max</span></P>
</TD><TD class="docTableCell">
<P class="docText">Maximum character position (usually size of buffer).</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><span class="docEmphBold">bolp</span></P>
</TD><TD class="docTableCell">
<P class="docText">Whether point is at the beginning of the line (<span class="docEmphBold">t</span> or <TT><B>nil</B></TT>).</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><span class="docEmphBold">eolp</span></P>
</TD><TD class="docTableCell">
<P class="docText">Whether point is at the end of the line.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><span class="docEmphBold">bobp</span></P>
</TD><TD class="docTableCell">
<P class="docText">Whether point is at the beginning of the buffer.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><span class="docEmphBold">eobp</span></P>
</TD><TD class="docTableCell">
<P class="docText">Whether point is at the end of the buffer.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><span class="docEmphBold">insert</span></P>
</TD><TD class="docTableCell">
<P class="docText">Insert any number of arguments (strings or characters) into the
buffer after point.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><span class="docEmphBold">number-to-string</span></P>
</TD><TD class="docTableCell">
<P class="docText">Convert a numerical argument to a string.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><span class="docEmphBold">string-to-number</span></P>
</TD><TD class="docTableCell">
<P class="docText">Convert a string argument to a number (integer or floating point).</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><span class="docEmphBold">char-to-string</span></P>
</TD><TD class="docTableCell">
<P class="docText">Convert a character argument to a string.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><span class="docEmphBold">substring</span></P>
</TD><TD class="docTableCell">
<P class="docText">Given a string and two integer indices <span class="docEmphasis">start</span> and
<span class="docEmphasis">end</span>, return the substring starting after
<span class="docEmphasis">start</span> and ending before
<span class="docEmphasis">end</span>. Indices start at 0. For example,
<TT>(substring "appropriate" 2 5)</TT> returns
"<TT>pro</TT>".</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><span class="docEmphBold">aref</span></P>
</TD><TD class="docTableCell">
<P class="docText">Array indexing function that can be used to return individual
characters from strings; takes an integer argument and returns the
character as an integer, using the ASCII code (on most machines). For
example, <TT>(aref</TT> "<TT>appropriate" 3)</TT>
returns 114, the ASCII code for <TT>r</TT>.</P>
</TD></TR></TABLE></P><br>

<P class="docText">Many functions not included in the previous table deal with buffers
and text, including some that you should be familiar with as user
commands. Several commonly used Emacs functions use
<span class="docEmphasis">regions</span>, which are areas of text within a
buffer. When you are using Emacs, you delineate regions by setting
the mark and moving the cursor. However, region-oriented functions
(such as <span class="docEmphBold">kill-region</span>, <span class="docEmphBold">indent-region</span>, and <span class="docEmphBold">shell-command-on-region</span>—really, any
function with <span class="docEmphasis">region</span> in its name) are actually
more flexible when used within Emacs Lisp code. They typically take
two integer arguments that are used as the character positions of the
boundaries for the region on which they operate. These arguments
default to the values of point and mark when the functions are called
interactively.</P>

<P class="docText">Obviously, allowing point and mark as interactive defaults is a more
general (and thus more desirable) approach than one in which only
point and mark can be used to delineate regions. The <span class="docEmphBold">r</span> option to the <span class="docEmphBold">interactive</span> function makes it possible. For
example, if we wanted to write the function <span class="docEmphBold">translate-region-into-German</span>, here is how we
would start:</P>

<PRE>(defun translate-region-into-German (start end)
  (interactive "r")
  ...</PRE><BR>


<P class="docText">The <span class="docEmphBold">r</span> option to <span class="docEmphBold">interactive</span> fills in the two arguments
<span class="docEmphBold">start</span> and <span class="docEmphBold">end</span> when the function is called interactively,
but if it is called from other Lisp code, both arguments must be
supplied. The usual way to do this is like this:</P>

<PRE>(translate-region-into-German (point) (mark))</PRE><BR>


<P class="docText">But you need not call it in this way. If you wanted to use this
function to write another function called <span class="docEmphBold">translate-buffer-into-German</span>, you would only
need to write the following as a
"wrapper":</P>

<PRE>(defun translate-buffer-into-German ( )
  (translate-region-into-German (point-min) (point-max)))</PRE><BR>


<P class="docText">In fact, it is best to <span class="docEmphasis">avoid</span> using point and
mark within Lisp code unless doing so is really necessary; use local
variables instead. Try not to write Lisp functions as lists of
commands a user would invoke; that sort of behavior is better suited
to macros (see <A class="docLink" HREF="gnu3-CHP-6.html#gnu3-CHP-6">Chapter 6</A>).</P>


<A NAME="gnu3-CHP-11-SECT-3.2"></A>
<H4 class="docSection2Title">11.3.2 Regular Expressions</H4>

<P class="docText">Regular expressions (regexps) provide <A NAME="gnu3-CHP-11-ITERM-2793"></A><A NAME="gnu3-CHP-11-ITERM-2794"></A><A NAME="gnu3-CHP-11-ITERM-2795"></A>much more powerful ways of dealing
with text. Although most beginning Emacs users tend to avoid commands
that use regexps, like <span class="docEmphBold">replace-regexp</span> and <span class="docEmphBold">re-search-forward</span>, regular expressions are
widely used within Lisp code. Such modes as Dired and the programming
language modes would be unthinkable without them. Regular expressions
require time and patience to become comfortable with, but doing so is
well worth the effort for Lisp programmers, because they are one of
the most powerful features of Emacs, and many things are not
practical to implement in any other way.</P>

<P class="docText">One trick that can be useful when you are experimenting with regular
expressions and trying to get the hang of them is to type some text
into a scratch buffer that corresponds to what
you're trying to match, and then use <span class="docEmphBold">isearch-forward-regexp</span> (<span class="docEmphBold">C-M-s</span>) to build up the regular expression. The
interactive, immediate feedback of an incremental search can show you
the pieces of the regular expression in action in a way that is
completely unique to Emacs.</P>

<P class="docText">We introduce the various features of regular expressions by way of a
few examples of search-and-replace situations; such examples are easy
to explain without introducing lots of extraneous details. Afterward,
we describe Lisp functions that go beyond simple search-and-replace
capabilities with regular expressions. The following are examples of
searching and replacing tasks that the normal search/replace commands
can't handle or handle poorly:</P>

<UL><LI><P class="docList">You are developing code in C, and you want to combine the
functionality of the functions <TT>read</TT> and
<TT>readfile</TT> into a new function called
<TT>get</TT>. You want to replace all references to these
functions with references to the new one.</P></LI><LI><P class="docList">You are writing a <span class="docEmphasis">troff</span> document using outline
mode, as described in <A class="docLink" HREF="gnu3-CHP-7.html#gnu3-CHP-7">Chapter 7</A>. In outline
mode, headers of document sections have lines that start with one or
more asterisks. You want to write a function called <span class="docEmphBold">remove-outline-marks</span> to get rid of these
asterisks so that you can run <span class="docEmphasis">troff</span> on your
file.</P></LI><LI><P class="docList">You want to change all occurrences of <span class="docEmphasis">program</span> in
a document, including <span class="docEmphasis">programs</span> and
<span class="docEmphasis">program's</span>, to
<span class="docEmphasis">module</span>/<span class="docEmphasis">modules</span>/<span class="docEmphasis">module's</span>,
without changing <span class="docEmphasis">programming</span> to
<span class="docEmphasis">moduleming</span> or <span class="docEmphasis">programmer</span> to
<span class="docEmphasis">modulemer</span>.</P></LI><LI><P class="docList">You are working on documentation for some C software that is being
rewritten in Java. You want to change all the filenames in the
documentation from <span class="docEmphasis">&lt;filename&gt;.c</span> to
<span class="docEmphasis">&lt;filename&gt;.java</span>, since
<span class="docEmphasis">.java</span> is the extension the
<span class="docEmphasis">javac</span> compiler uses.</P></LI><LI><P class="docList">You just installed a new C++ compiler that prints error messages in
German. You want to modify the Emacs <span class="docEmphBold">compile</span> package so that it can parse the error
messages correctly (see the end of <A class="docLink" HREF="gnu3-CHP-9.html#gnu3-CHP-9">Chapter 9</A>).</P></LI></UL>
<P class="docText">We will soon show how to use regular expressions to deal with these
examples, which we refer to by number. Note that this discussion of
regular expressions, although more comprehensive than that in <A class="docLink" HREF="gnu3-CHP-3.html#gnu3-CHP-3">Chapter 3</A>, does not cover every feature; those that
it doesn't cover are redundant with other features
or relate to concepts that are beyond the scope of this book. It is
also important to note that the regular expression syntax described
here is for use with Lisp strings only; there is an important
difference between the regexp syntax for Lisp strings and the regexp
syntax for user commands (like <span class="docEmphBold">replace-regexp</span>), as we will see.</P>

<A NAME="gnu3-CHP-11-SECT-3.2.1"></A>
<H5 class="docSection3Title">11.3.2.1 Basic operators</H5>

<P class="docText">Regular expressions <A NAME="gnu3-CHP-11-ITERM-2796"></A><A NAME="gnu3-CHP-11-ITERM-2797"></A><A NAME="gnu3-CHP-11-ITERM-2798"></A>began
as an idea in theoretical computer science, but they have found their
way into many nooks and crannies of everyday, practical computing.
The syntax used to represent them may vary, but the concepts are much
the same everywhere. You probably already know a subset of regular
expression notation: the wildcard characters used by the Unix shell
or Windows command prompt to match filenames. The Emacs notation is a
bit different; it is similar to those used by the language Perl,
editors like <I>ed </I>and <I>vi</I> and
Unix software tools like <I>lex</I> and
<I>grep</I>. So let's start with the
Emacs regular expression operators that resemble Unix shell wildcard
character, which are listed in <A class="docLink" HREF="#gnu3-CHP-11-TABLE-5">Table 11-5</A>.</P>

<A NAME="gnu3-CHP-11-TABLE-5"></A><P><TABLE CELLSPACING="0" BORDER="1" RULES="all" CELLPADDING="4" WIDTH="100%"><CAPTION><h5 class="docTableTitle">Table 11-5. Basic regular expression operators</h5></CAPTION><COLGROUP><COL><COL><COL></COLGROUP><THEAD><TR><TH class="thead" scope="col">
<P class="docText">Emacs operator</P>
</TH><TH class="thead" scope="col">
<P class="docText">Equivalent</P>
</TH><TH class="thead" scope="col">
<P class="docText">Function</P>
</TH></TR></THEAD><TR><TD class="docTableCell">
<P class="docText">.</P>
</TD><TD class="docTableCell">
<P class="docText"><TT>?</TT></P>
</TD><TD class="docTableCell">
<P class="docText">Matches any character.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><TT>.*</TT></P>
</TD><TD class="docTableCell">
<P class="docText"><TT>*</TT></P>
</TD><TD class="docTableCell">
<P class="docText">Matches any string.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><TT>[abc]</TT></P>
</TD><TD class="docTableCell">
<P class="docText"><TT>[abc]</TT></P>
</TD><TD class="docTableCell">
<P class="docText">Matches <TT>a</TT>, <TT>b</TT>, or
<TT>c</TT>.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><TT>[a-z]</TT></P>
</TD><TD class="docTableCell">
<P class="docText"><TT>[a-z]</TT></P>
</TD><TD class="docTableCell">
<P class="docText">Matches any lowercase letter.</P>
</TD></TR></TABLE></P><br>

<P class="docText">For example, to match all filenames beginning with
<span class="docEmphasis">program</span> in the Unix shell, you would specify
<TT>program*</TT>. In Emacs, you would say
<TT>program.*</TT>. To match all filenames beginning with
<span class="docEmphasis">a</span> through <span class="docEmphasis">e</span> in the shell,
you would use <TT>[a-e]*</TT> or
<TT>[abcde]*</TT>; in Emacs, it's
<TT>[a-e].*</TT> or <TT>[abcde].*</TT>. In other
words, the dash within the brackets specifies a
<span class="docEmphasis">range</span> of characters.<sup class="docFootnote"><A class="docLink" HREF="#gnu3-CHP-11-FNOTE-6">[6]</A></sup> We will provide more on ranges and
bracketed character sets shortly.</P><blockquote><p class="docFootnote"><sup><A NAME="gnu3-CHP-11-FNOTE-6">[6]</A></sup> Emacs uses
ASCII codes (on most machines) to build ranges, but you
shouldn't depend on this fact; it is better to stick
to dependable things, like all-lowercase or all-uppercase alphabet
subsets or <span class="docEmphBold">[0-9]</span> for digits, and
avoid potentially nonportable items, like <span class="docEmphBold">[A-z]</span> and ranges involving punctuation
characters.</p></blockquote>

<P class="docText">To specify a character that is used as a regular expression operator,
you need to precede it with a double-backslash, as in
<TT>\\*</TT> to match an asterisk. Why a double backslash?
The reason has to do with the way Emacs Lisp reads and decodes
strings. When Emacs reads a string in a Lisp program, it decodes the
backslash-escaped characters and thus turns double backslashes into
single backslashes. If the string is being used as a regular
expression—that is, if it is being passed to a function that
expects a regular expression argument—that function uses the
single backslash as part of the regular expression syntax. For
example, given the following line of Lisp:</P>

<PRE>(replace-regexp "fred\\*" "bob*")</PRE><BR>


<P class="docText">the Lisp interpreter decodes the string <TT>fred\\*</TT> as
<TT>fred\*</TT> and passes it to the <span class="docEmphBold">replace-regexp</span> command. The <span class="docEmphBold">replace-regexp</span> command understands
<TT>fred\*</TT> to mean <TT>fred</TT> followed by
a (literal) asterisk. Notice, however, that the second argument to
<span class="docEmphBold">replace-regexp</span> is not a regular
expression, so there is no need to backslash-escape the asterisk in
<TT>bob*</TT> at all. Also notice that if you were to
invoke the this as a user command, you would not need to double the
backslash, that is, you would type <span class="docEmphBold">M-x
replace-regexp Enter</span> followed by <span class="docEmphBold">fred\*</span> and <span class="docEmphBold">bob*</span>. Emacs decodes strings read from the
minibuffer differently.</P>

<P class="docText">The <TT>*</TT> regular expression operator in Emacs (by
itself) actually means something different from the
<TT>*</TT> in the Unix shell: it means
"zero or more occurrences of whatever is before the
<TT>*</TT>." Thus, because
. matches any character, <TT>.*</TT>
means "zero or more occurrences of any
character," that is, any string at all, including
the empty string. Anything can precede a <TT>*</TT>: for
example, <TT>read*</TT> matches
"rea" followed by zero or more
d's; <TT>file[0-9]*</TT> matches
"file" followed by zero or more
digits.</P>

<P class="docText">Two operators are closely related to <TT>*</TT>. The first
is <TT>+</TT>, which matches one or more occurrences of
whatever precedes it. Thus, <TT>read+</TT> matches
"read" and
"readdddd" but not
"rea," and
<TT>file[0-9]+</TT> requires that there be at least one
digit after "file." The second is
<TT>?</TT>, which matches zero or one occurrence of
whatever precedes it (i.e., makes it optional).
<TT>html?</TT> matches
"htm" or
"html," and
<TT>file[0-9]?</TT> matches
"file" followed by one optional
digit.</P>

<P class="docText">Before we move on to other operators, a few more comments about
character sets and ranges are in order. First, you can specify more
than one range within a single character set. The set
<TT>[A-Za-z]</TT> can thus be used to specify all
alphabetic characters; this is better than the nonportable
<TT>[A-z]</TT>. Combining ranges with lists of characters
in sets is also possible; for example, <TT>[A-Za-z_]</TT>
means all alphabetic characters plus underscore, that is, all
characters allowed in the names of identifiers in C. If you give
<TT>^</TT> as the first character in a set, it acts as a
"not" operator; the set matches all
characters that aren't the characters after the
<TT>^</TT>. For example, <TT>[^A-Za-z]</TT>
matches all nonalphabetic characters.</P>

<P class="docText">A <TT>^</TT> anywhere other than first in a character set
has no special meaning; it's just the caret
character. Conversely, <TT>-</TT> has no special meaning if
it is given first in the set; the same is true for
<TT>]</TT>. However, we don't recommend
that you use this shortcut; instead, you should
double-backslash-escape these characters just to be on the safe side.
A double backslash preceding a nonspecial character usually means
just that character—but watch it! A few letters and punctuation
characters are used as regular expression operators, some of which
are covered in the following section. We list "booby
trap" characters that become operators when
double-backslash-escaped later. The <TT>^</TT> character
has a different meaning when used outside of ranges, as
we'll see soon.</P>



<A NAME="gnu3-CHP-11-SECT-3.2.2"></A>
<H5 class="docSection3Title">11.3.2.2 Grouping and alternation</H5>

<P class="docText">If you want to get <TT>*</TT>, <TT>+</TT>, or
<TT>?</TT> to <A NAME="gnu3-CHP-11-ITERM-2799"></A><A NAME="gnu3-CHP-11-ITERM-2800"></A><A NAME="gnu3-CHP-11-ITERM-2801"></A>
<A NAME="gnu3-CHP-11-ITERM-2802"></A><A NAME="gnu3-CHP-11-ITERM-2803"></A><A NAME="gnu3-CHP-11-ITERM-2804"></A>operate on more than one character,
you can use the <TT>\\(</TT> and <TT>\\)</TT>
operators for grouping. Notice that, in this case (and others to
follow), the backslashes are part of the operator. (All of the
nonbasic regular expression operators include backslashes so as to
avoid making too many characters
"special." This is the most
profound way in which Emacs regular expressions differ from those
used in other environments, like Perl, so it's
something to which you'll need to pay careful
attention.) As we saw before, these characters need to be
double-backslash-escaped so that Emacs decodes them properly. If one
of the basic operators immediately follows <TT>\\)</TT>, it
works on the entire group inside the <TT>\\(</TT> and
<TT>\\)</TT>. For example, <TT>\\(read\\)*</TT>
matches the empty string, "read,"
"readread," and so on, and
<TT>read\\(file\\)?</TT> matches
"read" or
"readfile." Now we can handle
Example 1, the first of the examples given at the beginning of this
section, with the following Lisp code:</P>

<PRE>(replace-regexp "read\\(file\\)?" "get")</PRE><BR>


<P class="docText">The alternation operator <TT>\\|</TT> is a
"one or the other" operator; it
matches either whatever precedes it or whatever comes after it.
<TT>\\|</TT> treats parenthesized groups differently from
the basic operators. Instead of requiring parenthesized groups to
work with subexpressions of more than one character, its
"power" goes out to the left and
right as far as possible, until it reaches the beginning or end of
the regexp, a <TT>\\(</TT>, a <TT>\\)</TT>, or
another <TT>\\|</TT>. Some examples should make this
clearer:</P>

<UL><LI><P class="docList"><TT>read\\|get</TT> matches
"read" or
"get"</P></LI><LI><P class="docList"><TT>readfile\\|read\\|get</TT> matches
"readfile",
"read," or
"get"</P></LI><LI><P class="docList"><TT>\\(read\\|get\\)file</TT> matches
"readfile" or
"getfile"</P></LI></UL>
<P class="docText">In the first example, the effect of the <TT>\\|</TT>
extends to both ends of the regular expression. In the second, the
effect of the first <TT>\\|</TT> extends to the beginning
of the regexp on the left and to the second <TT>\\|</TT> on
the right. In the third, it extends to the backslash-parentheses.</P>



<A NAME="gnu3-CHP-11-SECT-3.2.3"></A>
<H5 class="docSection3Title">11.3.2.3 Context</H5>

<P class="docText">Another important category of regular <A NAME="gnu3-CHP-11-ITERM-2805"></A><A NAME="gnu3-CHP-11-ITERM-2806"></A><A NAME="gnu3-CHP-11-ITERM-2807"></A><A NAME="gnu3-CHP-11-ITERM-2808"></A>expression operators has to do with
specifying the <span class="docEmphasis">context</span> of a string, that is, the
text around it. In <A class="docLink" HREF="gnu3-CHP-3.html#gnu3-CHP-3">Chapter 3</A> we saw the
<span class="docEmphBold">word-search</span> commands, which are
invoked as options within incremental search. These are special cases
of context specification; in this case, the context is
word-separation characters, for example, spaces or punctuation, on
both sides of the string.</P>

<P class="docText">The simplest context operators for regular expressions are
<TT>^</TT> and <TT>$</TT>, two more basic
operators that are used at the beginning and end of regular
expressions respectively. The <TT>^</TT> operator causes
the rest of the regular expression to match only if it is at the
beginning of a line; <TT>$</TT> causes the regular
expression preceding it to match only if it is at the end of a line.
In Example 2, we need a function that matches occurrences of one or
more asterisks at the beginning of a line; this will do it:</P>

<PRE>(defun remove-outline-marks ( )
  "Remove section header marks created in outline-mode."
  (interactive)
  (replace-regexp "^\\*+" ""))</PRE><BR>


<P class="docText">This function finds lines that begin with one or more asterisks (the
<TT>\\*</TT> is a literal asterisk and the
<TT>+</TT> means "one or
more"), and it replaces the asterisk(s) with the
empty string "", thus deleting them.</P>

<P class="docText">Note that <TT>^</TT> and <TT>$</TT>
can't be used in the middle of regular expressions
that are intended to match strings that span more than one line.
Instead, you can put <TT>\n</TT> (for Newline) in your
regular expressions to match such strings. Another such character you
may want to use is <TT>\t</TT> for Tab. When
<TT>^</TT> and <TT>$</TT> are used with regular
expression searches on strings instead of buffers, they match
beginning- and end-of-string, respectively; the function <span class="docEmphBold">string-match</span>, described later in this chapter,
can be used to do regular expression search on strings.</P>

<P class="docText">Here is a real-life example of a complex regular expression that
covers the operators we have seen so far: <span class="docEmphBold">sentence-end</span>, a variable Emacs uses to
recognize the ends of sentences for sentence motion commands like
<span class="docEmphBold">forward-sentence</span> (<span class="docEmphBold">M-e</span>). Its value is:</P>

<PRE>"[.?!][]\"')}]*\\($\\|\t\\|  \\)[ \t\n]*"</PRE><BR>


<P class="docText">Let's look at this piece by piece. The first
character set, <TT>[.?!]</TT>, matches a period, question
mark, or exclamation mark (the first two of these are regular
expression operators, but they have no special meaning within
character sets). The next part, <TT>[]\"')}]*</TT>,
consists of a character set containing right bracket, double quote,
single quote, right parenthesis, and right curly brace. A
<TT>*</TT> follows the set, meaning that zero or more
occurrences of any of the characters in the set matches. So far,
then, this regexp matches a sentence-ending punctuation mark followed
by zero or more ending quotes, parentheses, or curly braces. Next,
there is the group <TT>\\($\\|\t\\| \\)</TT>, which matches
any of the three alternatives <TT>$</TT> (end of line),
<TT>Tab</TT>, or two spaces. Finally, <TT>[
\t\n]*</TT> matches zero or more spaces, tabs, or newlines. Thus
the sentence-ending characters can be followed by end-of-line or a
combination of spaces (at least two), tabs, and newlines.</P>

<P class="docText">There are other context operators besides <TT>^</TT> and
<TT>$</TT>; two of them can be used to make regular
expression search act like word search. The operators
<TT>\\&lt;</TT> and <TT>\\&gt;</TT> match the
beginning and end of a word, respectively. With these we can go part
of the way toward solving Example 3. The regular expression
<TT>\\&lt;program\\&gt;</TT> matches
"program" but not
"programmer" or
"programming" (it also
won't match
"microprogram"). So far so good;
however, it won't match
"program's" or
"programs." For this, we need a
more complex regular expression:</P>

<PRE>\\&lt;program\\('s\\|s\\)?\\&gt;</PRE><BR>


<P class="docText">This expression means, "a word beginning with
<span class="docEmphasis">program</span> followed optionally by apostrophe s or
just s." This does the trick as far as matching the
right words goes.</P>



<A NAME="gnu3-CHP-11-SECT-3.2.4"></A>
<H5 class="docSection3Title">11.3.2.4 Retrieving portions of matches</H5>

<P class="docText">There is still one piece <A NAME="gnu3-CHP-11-ITERM-2809"></A><A NAME="gnu3-CHP-11-ITERM-2810"></A>missing: the ability to replace
"program" with
"module" while leaving any
<TT>s</TT> or '<TT>s</TT> untouched. This leads
to the final regular expression feature we will cover here: the
ability to retrieve portions of the matched string for later use. The
preceding regular expression is indeed the correct one to give as the
search string for <span class="docEmphBold">replace-regexp</span>. As
for the replace string, the answer is <TT>module\\1</TT>;
in other words, the required Lisp code is:</P>

<PRE>(replace-regexp "\\&lt;program\\('s\\|s\\)?\\&gt;" "module\\1")</PRE><BR>


<P class="docText">The <TT>\\1</TT> means, in effect,
"substitute the portion of the matched string that
matched the subexpression inside the <TT>\\(</TT> and
<TT>\\)</TT>." It is the only
regular-expression-related operator that can be used in replacements.
In this case, it means to use '<TT>s</TT> in the replace
string if the match was
"program's,"
<TT>s</TT> if the match was
"programs," or nothing if the match
was just "program." The result is
the correct substitution of
"module" for
"program,"
"modules" for
"programs," and
"module's" for
"program's."</P>

<P class="docText">Another example of this feature solves Example 4. To match filenames
<span class="docEmphasis">&lt;filename&gt;.c</span> and replace them with
<span class="docEmphasis">&lt;filename&gt;.java</span>, use the Lisp code:</P>

<PRE>(replace-regexp "\\([a-zA-Z0-9_]+\\)\\.c" "\\1.java")</PRE><BR>


<P class="docText">Remember that <TT>\\</TT>. means a literal dot
(.). Note also that the filename pattern (which
matches a series of one or more alphanumerics or underscores) was
surrounded by <TT>\\(</TT> and <TT>\\)</TT> in
the search string for the sole purpose of retrieving it later with
<TT>\\1</TT>.</P>

<P class="docText">Actually, the <TT>\\1</TT> operator is only a special case
of a more powerful facility (as you may have guessed). In general, if
you surround a portion of a regular expression with
<TT>\\(</TT> and <TT>\\)</TT>, the string
matching the parenthesized subexpression is saved. When you specify
the replace string, you can retrieve the saved substrings with
<TT>\\</TT><TT><I>n</I></TT>, where
<TT><I>n</I></TT> is the number of the parenthesized
subexpression from left to right, starting with 1. Parenthesized
expressions can be nested; their corresponding
<TT>\\</TT><TT><I>n</I></TT> numbers are
assigned in order of their <TT>\\(</TT> delimiter from left
to right.</P>

<P class="docText">Lisp code that takes full advantage of this feature tends to contain
complicated regular expressions. The best example of this in
Emacs's own Lisp code is <span class="docEmphBold">compilation-error-regexp-alist</span>, the list of
regular expressions the <span class="docEmphBold">compile</span>
package (discussed in <A class="docLink" HREF="gnu3-CHP-9.html#gnu3-CHP-9">Chapter 9</A>) uses to parse
error messages from compilers. Here is an excerpt, adapted from the
Emacs source code (it's become much too long to
reproduce in its entirety; see below for some hints on how to find
the actual file to study in its full glory):</P>

<PRE>(defvar compilation-error-regexp-alist
  '(
    ;; NOTE!  See also grep-regexp-alist, below.
 
    ;; 4.3BSD grep, cc, lint pass 1:
    ;;  /usr/src/foo/foo.c(8): warning: w may be used before set
    ;; or GNU utilities:
    ;;  foo.c:8: error message
    ;; or HP-UX 7.0 fc:
    ;;  foo.f          :16    some horrible error message
    ;; or GNU utilities with column (GNAT 1.82):
    ;;   foo.adb:2:1: Unit name does not match file name
    ;; or with column and program name:
    ;;   jade:dbcommon.dsl:133:17:E: missing argument for function call
    ;;
    ;; We'll insist that the number be followed by a colon or closing
    ;; paren, because otherwise this matches just about anything
    ;; containing a number with spaces around it.

    ;; We insist on a non-digit in the file name
    ;; so that we don't mistake the file name for a command name
    ;; and take the line number as the file name.
    ("\\([a-zA-Z][-a-zA-Z._0-9]+: ?\\)?\
\\([a-zA-Z]?:?[^:( \t\n]*[^:( \t\n0-9][^:( \t\n]*\\)[:(][ \t]*\\([0-9]+\\)\
\\([) \t]\\|:\\(\\([0-9]+:\\)\\|[0-9]*[^:0-9]\\)\\)" 2 3 6)

;; Microsoft C/C++:
    ;;  keyboard.c(537) : warning C4005: 'min' : macro redefinition
    ;;  d:\tmp\test.c(23) : error C2143: syntax error : missing ';' before 
        'if'
    ;; This used to be less selective and allow characters other than
    ;; parens around the line number, but that caused confusion for
    ;; GNU-style error messages.
    ;; This used to reject spaces and dashes in file names,
    ;; but they are valid now; so I made it more strict about the error
    ;; message that follows.
    ("\\(\\([a-zA-Z]:\\)?[^:(\t\n]+\\)(\\([0-9]+\\)) \
: \\(error\\|warning\\) C[0-9]+:" 1 3)

;; Caml compiler:
    ;;  File "foobar.ml", lines 5-8, characters 20-155: blah blah
   ("^File \"\\([^,\" \n\t]+\\)\", lines? \\([0-9]+\\)[-0-9]*, characters? \
\\([0-9]+\\)" 1 2 3)

;; Cray C compiler error messages
    ("\\(cc\\| cft\\)-[0-9]+ c\\(c\\|f77\\): ERROR \\([^,\n]+, \\)* File = \
\\([^,\n]+\\), Line = \\([0-9]+\\)" 4 5)

;; Perl -w:
    ;; syntax error at automake line 922, near "':'"
    ;; Perl debugging traces
    ;; store::odrecall('File_A', 'x2') called at store.pm line 90
    (".* at \\([^ \n]+\\) line \\([0-9]+\\)[,.\n]" 1 2)

    ;; See http://ant.apache.org/faq.html
    ;; Ant Java: works for jikes
    ("^\\s-*\\[[^]]*\\]\\s-*\\(.+\\):\\([0-9]+\\):\\([0-9]+\\):[0-9]+:[0-9]\
+:" 1 2 3)

    ;; Ant Java: works for javac
    ("^\\s-*\\[[^]]*\\]\\s-*\\(.+\\):\\([0-9]+\\):" 1 2)
)</PRE><BR>


<P class="docText">This is a list of elements that have at least three parts each: a
regular expression and two numbers. The regular expression matches
error messages in the format used by a particular compiler or tool.
The first number tells Emacs which of the matched subexpressions
contains the filename in the error message; the second number
designates which of the subexpressions contains the line number.
(There can also be additional parts at the end: a third number giving
the position of the column number of the error, if any, and any
number of format strings used to generate the true filename from the
piece found in the error message, if needed. For more details about
these, look at the actual file, as described below.)</P>

<P class="docText">For example, the element in the list dealing with Perl contains the
regular expression:</P>

<PRE>".* at \\([^ \n]+\\) line \\([0-9]+\\)[,.\n]"</PRE><BR>


<P class="docText">followed by 1 and 2, meaning that the first parenthesized
subexpression contains the filename and the second contains the line
number. So if you have Perl's warnings turned
on—you always do, of course—you might get an error
message such as this:</P>

<PRE>syntax error at monthly_orders.pl line 1822, near "$"</PRE><BR>


<P class="docText">The regular expression ignores everything up to
<span class="docEmphasis">at</span>. Then it finds
<span class="docEmphasis">monthly_orders.pl</span>, the filename, as the match to
the first subexpression "<TT>[^
\n]+</TT>" (one or more nonblank, nonnewline
characters), and it finds 1822, the line number, as the match to the
second subexpression
"<TT>[0-9]+</TT>" (one or
more digits).</P>

<P class="docText">For the most part, these regular expressions are documented pretty
well in their definitions. Understanding them in depth can still be a
challenge, and writing them even more so! Suppose we want to tackle
Example 5 by adding an element to this list for our new C++ compiler
that prints error messages in German. In particular, it prints error
messages like this:</P>

<PRE>Fehler auf Zeile <TT><I>linenum</I></TT> in <TT><I>filename</I></TT>: <TT><I>text of error message</I></TT></PRE><BR>


<P class="docText">Here is the element we would add to <span class="docEmphBold">compilation-error-regexp-alist</span>:</P>

<PRE>("Fehler auf Zeile \\([0-9]+\\) in \\([^: \t]+\\):" 2 1)</PRE><BR>


<P class="docText">In this case, the second parenthesized subexpression matches the
filename, and the first matches the line number.</P>

<P class="docText">To add this to <span class="docEmphBold">compilation-error-regexp-alist</span>, we need to put
this line in <span class="docEmphasis">.emacs</span>:</P>

<PRE>(setq compilation-error-regexp-alist
  (cons '("Fehler auf Zeile \\([0-9]+\\) in \\([^: \t]+\\):" 2 1)
    compilation-error-regexp-alist))</PRE><BR>


<P class="docText">Notice how this example resembles our example (from <A class="docLink" HREF="gnu3-CHP-9.html#gnu3-CHP-9">Chapter 9</A>) of adding support for a new language mode
to <span class="docEmphBold">auto-mode-alist</span>.</P>



<A NAME="gnu3-CHP-11-SECT-3.2.5"></A>
<H5 class="docSection3Title">11.3.2.5 Regular expression operator summary</H5>

<P class="docText"><A class="docLink" HREF="#gnu3-CHP-11-TABLE-6">Table 11-6</A> concludes <A NAME="gnu3-CHP-11-ITERM-2811"></A><A NAME="gnu3-CHP-11-ITERM-2812"></A><A NAME="gnu3-CHP-11-ITERM-2813"></A>our discussion of regular
expression operators with a reference list of all the operators
covered.</P>

<A NAME="gnu3-CHP-11-TABLE-6"></A><P><TABLE CELLSPACING="0" BORDER="1" RULES="all" CELLPADDING="4" WIDTH="100%"><CAPTION><h5 class="docTableTitle">Table 11-6. Regular expression operators</h5></CAPTION><COLGROUP><COL><COL></COLGROUP><THEAD><TR><TH class="thead" scope="col">
<P class="docText"><span class="docEmphBold">Operator</span></P>
</TH><TH class="thead" scope="col">
<P class="docText"><span class="docEmphBold">Function</span></P>
</TH></TR></THEAD><TR><TD class="docTableCell">
<P class="docText">.</P>
</TD><TD class="docTableCell">
<P class="docText">Match any character.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><TT>*</TT></P>
</TD><TD class="docTableCell">
<P class="docText">Match 0 or more occurrences of preceding char or group.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><TT>+</TT></P>
</TD><TD class="docTableCell">
<P class="docText">Match 1 or more occurrences of preceding char or group.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><TT>?</TT></P>
</TD><TD class="docTableCell">
<P class="docText">Match 0 or 1 occurrences of preceding char or group.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><TT>[...]</TT></P>
</TD><TD class="docTableCell">
<P class="docText">Set of characters; see below.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><TT>\\(</TT></P>
</TD><TD class="docTableCell">
<P class="docText">Begin a group.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><TT>\\)</TT></P>
</TD><TD class="docTableCell">
<P class="docText">End a group.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><TT>\\|</TT></P>
</TD><TD class="docTableCell">
<P class="docText">Match the subexpression before or after \\|.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><TT>^</TT></P>
</TD><TD class="docTableCell">
<P class="docText">At beginning of regexp, match beginning of line or string.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><TT>$</TT></P>
</TD><TD class="docTableCell">
<P class="docText">At end of regexp, match end of line or string.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><TT>\n</TT></P>
</TD><TD class="docTableCell">
<P class="docText">Match Newline within a regexp.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><TT>\t</TT></P>
</TD><TD class="docTableCell">
<P class="docText">Match Tab within a regexp.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><TT>\\&lt;</TT></P>
</TD><TD class="docTableCell">
<P class="docText">Match beginning of word.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><TT>\\&gt;</TT></P>
</TD><TD class="docTableCell">
<P class="docText">Match end of word.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><span class="docEmphasis">The following operators are meaningful within character
sets</span>:</P>
</TD><TD class="docTableCell">&nbsp;</TD></TR><TR><TD class="docTableCell">
<P class="docText"><TT>^</TT></P>
</TD><TD class="docTableCell">
<P class="docText">At beginning of set, treat set as chars not to match.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><TT>-</TT> <span class="docEmphasis">(dash)</span></P>
</TD><TD class="docTableCell">
<P class="docText">Specify range of characters.</P>
</TD></TR><TR><TD class="docTableCell">
<P class="docText"><span class="docEmphasis">The following is also meaningful in regexp replace
strings</span>:</P>
</TD><TD class="docTableCell">&nbsp;</TD></TR><TR><TD class="docTableCell">
<P class="docText"><TT>\\</TT><TT><I>n</I></TT></P>
</TD><TD class="docTableCell">
<P class="docText">Substitute portion of match within the <TT><I>n</I></TT>th
<TT>\\(</TT> and <TT>\\)</TT>, counting from left
<TT>\\(</TT> to right, starting with 1.</P>
</TD></TR></TABLE></P><br>

<P class="docText">Finally, the following characters are operators (not discussed here)
when double-backslash-escaped: <TT>b</TT>,
<TT>B</TT>, <TT>c</TT>, <TT>C</TT>,
<TT>w</TT>, <TT>W</TT>, <TT>s</TT>,
<TT>S</TT>, <TT>=</TT>, <TT>_</TT>,
', and <TT>`</TT>. Thus, these are
"booby traps" when
double-backslash-escaped. Some of these behave similarly to the
character class aliases you may have encountered in Perl and Java
regular expressions.</P>



<A NAME="gnu3-CHP-11-SECT-3.3"></A>
<H4 class="docSection2Title">11.3.3 A Treasure Trove of Examples</H4>

<P class="docText">As mentioned above, the full <span class="docEmphBold">auto-mode-alist</span> has a lot more entries and
documentation than fit in this book. The
<I>compile.el</I> module in which it is defined also
contains functions that use it. One of the best ways to learn how to
use Emacs Lisp (as well as discovering things you might not have even
realized you can do) is to browse through the implementations of
standard modules that are similar to what you're
trying to achieve, or that are simply interesting. But how do you
find them?</P>

<P class="docText">The manual way is to look at the value of the variable <span class="docEmphBold">load-path</span>. This is the variable Emacs consults
when it needs to load a library file itself, so any library
you're looking for must be in one of these
directories. (This variable is discussed further in the final section
of this chapter.) The problem, as you will see if you look at the
current value of the variable, is that it contains a large number of
directories for you to wade through, which would be pretty tedious
each time you're curious about a library. (An easy
way to see the variable's value is through
Help's "Describe
variable" feature, <span class="docEmphBold">C-h
v</span>.)</P>

<P class="docText">One of the authors wrote the command listed in <A class="docLink" HREF="#gnu3-CHP-11-EX-1">Example 11-1</A> to address this problem and uses it regularly
to easily snoop on the source files that make much of Emacs run. If
you don't want to type this entire function into
your <span class="docEmphasis">.emacs</span> by hand, you can download it from
this book's web <A NAME="gnu3-CHP-11-ITERM-2814"></A>site, <A class="docLink" target="_blank" HREF="http://www.oreilly.com/catalog/gnu3">http://www.oreilly.com/catalog/gnu3</A>.</P>

<A NAME="gnu3-CHP-11-EX-1"></A>
<H5 class="docExampleTitle">Example 11-1. find-library-file</H5>
<PRE>(defun find-library-file (library)
  "Takes a single argument LIBRARY, being a library file to search for.
Searches for LIBRARY directly (in case relative to current directory,
or absolute) and then searches directories in load-path in order.  It
will test LIBRARY with no added extension, then with .el, and finally
with .elc.  If a file is found in the search, it is visited.  If none
is found, an error is signaled.  Note that order of extension searching
is reversed from that of the load function."
  (interactive "sFind library file: ")
  (let ((path (cons "" load-path)) exact match elc test found)
    (while (and (not match) path)
      (setq test (concat (car path) "/" library)
            match (if (condition-case nil
                          (file-readable-p test)
                        (error nil))
                      test)
            path (cdr path)))
    (setq path (cons "" load-path))
    (or match
        (while (and (not elc) path)
          (setq test (concat (car path) "/" library ".elc")
                elc (if (condition-case nil
                            (file-readable-p test)
                          (error nil))
                        test)
                path (cdr path))))
    (setq path (cons "" load-path))
    (while (and (not match) path)
      (setq test (concat (car path) "/" library ".el")
            match (if (condition-case nil
                          (file-readable-p test)
                        (error nil))
                      test)
            path (cdr path)))
    (setq found (or match elc))
    (if found
        (progn
          (find-file found)
          (and match elc
               (message "(library file %s exists)" elc)
               (sit-for 1))
          (message "Found library file %s" found))
      (error "Library file \"%s\" not found." library))))</PRE><BR>



<P class="docText">Once this command is defined, you can visit any
library's implementation by typing <span class="docEmphBold">M-x find-library file Enter</span>
<TT><I>libraryname</I></TT> <span class="docEmphBold">Enter</span>. If you use it as often as this author
does, you too may find it worth binding to a key sequence. We
won't present a detailed discussion of how this
function works because it goes a bit deeper than this chapter, but if
you're curious about what some of the functions do,
you can put your cursor in the function name in a Lisp buffer and use
the Help system's "Describe
function" (<span class="docEmphBold">C-h f</span>)
feature to get more information about it.</P>

<P class="docText">If you find that most of the time when you ask for a library, you end
up with a file containing a lot of cryptic numeric codes and no
comments, check if the filename ends in <I>.elc</I>. If
that is usually what you end up with, it means that only the
byte-compiled versions of the libraries (see the discussion at the
end of this chapter) have been installed on your system. Ask your
system administrator if you can get the source installed;
that's an important part of being able to learn and
tweak the Emacs Lisp environment.</P>


<A NAME="gnu3-CHP-11-SECT-3.4"></A>
<H4 class="docSection2Title">11.3.4 Functions That Use Regular Expressions</H4>

<P class="docText">The functions <span class="docEmphBold">re-search-forward</span>,
<span class="docEmphBold">re-search-backward</span>, <span class="docEmphBold">replace-regexp</span>, <span class="docEmphBold">query-replace-regexp</span>, <span class="docEmphBold">highlight-regexp</span>, <span class="docEmphBold">isearch-forward-regexp</span>, and <span class="docEmphBold">isearch-backward-regexp</span> are all user
<A NAME="gnu3-CHP-11-ITERM-2815"></A><A NAME="gnu3-CHP-11-ITERM-2816"></A>commands
that use regular expressions, and they can all be used within Lisp
code (though it is hard to imagine incremental search being used
within Lisp code). The section on customizing major modes later in
this chapter contains an example function that uses <span class="docEmphBold">re-search-forward</span>. To find other commands that
use regexps you can use the
"apropos" help feature (<span class="docEmphBold">C-h a regexp Enter</span>).</P>

<P class="docText">Other such functions aren't available as user
commands. Perhaps the most widely used one is <span class="docEmphBold">looking-at</span>. This function takes a regular
expression argument and does the following: it returns
<TT>t</TT> if the text after point matches the regular
expression (<TT>nil</TT> otherwise); if there was a match,
it saves the pieces surrounded by <TT>\\(</TT> and
<TT>\\)</TT> for future use, as seen earlier. The function
<span class="docEmphBold">string-match</span> is similar: it takes
two arguments, a regexp and a string. It returns the starting index
of the portion of the string that matches the regexp, or
<TT>nil</TT> if there is no match.</P>

<P class="docText">The functions <span class="docEmphBold">match-beginning</span> and
<span class="docEmphBold">match-end</span> can be used to retrieve
the saved portions of the matched string. Each takes as an argument
the number of the matched expression (as in
<TT>\\</TT><TT><I>n</I></TT> in <span class="docEmphBold">replace-regexp</span> replace strings) and returns
the character position in the buffer that marks the beginning (for
<span class="docEmphBold">match-beginning</span>) or end (for
<span class="docEmphBold">match-end</span>) of the matched string.
With the argument <TT>0</TT>, the character position that
marks the beginning/end of the entire string matched by the regular
expression is returned.</P>

<P class="docText">Two more functions are needed to make the above useful: we need to
know how to convert the text in a buffer to a string. No problem:
<span class="docEmphBold">buffer-string</span> returns the entire
buffer as a string; <span class="docEmphBold">buffer-substring</span>
takes two integer arguments, marking the beginning and end positions
of the substring desired, and returns the substring.</P>

<P class="docText">With these functions, we can write a bit of Lisp code that returns a
string containing the portion of the buffer that matches the
<span class="docEmphasis">n</span>th parenthesized subexpression:</P>

<PRE>(buffer-substring (match-beginning <TT><I>n</I></TT> (match-end <TT><I>n</I></TT>)))</PRE><BR>


<P class="docText">In fact, this construct is used so often that Emacs has a built-in
function, <span class="docEmphBold">match-string</span>, that acts as
a shorthand; <TT>(match-string</TT>
<TT><I>n</I></TT><TT>)</TT> returns the same
result as in the previous example.</P>

<P class="docText">An example should show how this capability works. Assume you are
writing the Lisp code that parses compiler error messages, as in our
previous example. Your code goes through each element in <span class="docEmphBold">compilation-error-regexp-alist</span>, checking if
the text in a buffer matches the regular expression. If it matches,
your code needs to extract the filename and the line number, visit
the file, and go to the line number.</P>

<P class="docText">Although the code for going down each element in the list is beyond
what we have learned so far, the routine basically looks like this:</P>

<PRE><TT><I>for each element in</I></TT> compilation-error-regexp-alist
  (let ((regexp <TT><I>the regexp in the element</I></TT><span class="docEmphBold">)</span>
        (file-subexp <TT><I>the number of the filename subexpression</I></TT>)
        (line-subexp <TT><I>the number of the line number subexpression</I></TT>))
    (if (looking-at regexp)
        (let ((filename (match-string file-subexp))
              (linenum (match-string line-subexp)))
          (find-file-other-window filename)
          (goto-line linenum))
      (<TT><I>otherwise, try the next element in the list</I></TT>)))</PRE><BR>


<P class="docText">The second <span class="docEmphBold">let</span> extracts the filename
from the buffer from the beginning to the end of the match to the
<TT>file-subexp</TT>-th subexpression, and it extracts the
line number similarly from the <TT>line-subexp</TT>-th
subexpression (and converts it from a string to a number). Then the
code visits the file (in another window, not the same one as the
error message buffer) and goes to the line number where the error
occurred.</P>

<P class="docText">The code for the calculator mode later in this chapter contains a few
other examples of <span class="docEmphBold">looking-at</span>,
<span class="docEmphBold">match-beginning</span>, and <span class="docEmphBold">match-end</span>.</P>


<A NAME="gnu3-CHP-11-SECT-3.5"></A>
<H4 class="docSection2Title">11.3.5 Finding Other Built-in Functions</H4>

<P class="docText">Emacs contains <A NAME="gnu3-CHP-11-ITERM-2817"></A><A NAME="gnu3-CHP-11-ITERM-2818"></A>hundreds
of built-in functions that may be of use to you in writing Lisp code.
Yet finding which one to use for a given purpose is not so hard.</P>

<P class="docText">The first thing to realize is that you will often need to use
functions that are already accessible as keyboard commands. You can
use these by finding out what their function names are via the
<span class="docEmphBold">C-h k</span> (for <span class="docEmphBold">describe-key</span>) command (see <A class="docLink" HREF="gnu3-CHP-14.html#gnu3-CHP-14">Chapter 14</A>). This gives the
command's full documentation, as opposed to
<span class="docEmphBold">C-h c</span> (for <span class="docEmphBold">describe-key-briefly</span>), which gives only the
command's name. Be careful: in a few cases, some
common keyboard commands require an argument when used as Lisp
functions. An example is <span class="docEmphBold">forward-word</span>; to get the equivalent of typing
<span class="docEmphBold">M-f</span>, you have to use
<TT>(forward-word 1)</TT>.</P>

<P class="docText">Another powerful tool for getting the right function for the job is
the <span class="docEmphBold">command-apropos</span> (<span class="docEmphBold">C-h a</span>) help function. Given a regular
expression, this help function searches for all commands that match
it and display their key bindings (if any) and documentation in a
<TT>*Help*</TT> window. This can be a great help if you are
trying to find a command that does a certain
"basic" thing. For example, if you
want to know about commands that operate on words, type <span class="docEmphBold">C-h</span> <TT><B>a</B></TT> followed by
<TT><I>word</I></TT>, and you will see documentation on
about a dozen and a half commands having to do with words.</P>

<P class="docText">The limitation with <span class="docEmphBold">command-apropos</span>
is that it gives information only on functions that can be used as
keyboard commands. Even more powerful is <span class="docEmphBold">apropos</span>, which is not accessible via any of
the help keys (you must type <span class="docEmphBold">M-x apropos
Enter</span>). Given a regular expression, <span class="docEmphBold">apropos</span> displays all functions, variables, and
other symbols that match it. Be warned, though: <span class="docEmphBold">apropos</span> can take a long time to run and can
generate very long lists if you use it with a general enough concept
(such as <I>buffer</I>).</P>

<P class="docText">You should be able to use the <span class="docEmphBold">apropos</span> commands on a small number of
well-chosen keywords and find the function(s) you need. Because, if a
function seems general and basic enough, the chances are excellent
that Emacs has it built-in.</P>

<P class="docText">After you find the function you are interested in, you may find that
the documentation that <span class="docEmphBold">apropos</span>
prints does not give you enough information about what the function
does, its arguments, how to use it, or whatever. The best thing to do
at this point is to search Emacs's Lisp source code
for examples of the function's use.
"A Treasure Trove of Examples"
earlier in this chapter provides ways of finding out the names of
directories Emacs loads libraries from and an easy way of looking at
a library once you know its name. To search the contents of the
library files you'll need to use
<I>grep</I> or some other search facility to find
examples, then edit the files found to look at the surrounding
context. If you're ambitious you could put together
the examples and concepts we've discussed so far to
write an extension of the <span class="docEmphBold">find-library-file</span> command that searches the
<span class="docEmphasis">contents</span> of the library files in each directory
on the load path! Although most of Emacs's built-in
Lisp code is not profusely documented, the examples of function use
that it provides should be helpful—and may even give you ideas
for your own functions.</P>

<P class="docText">By now, you should have a framework of Emacs Lisp that should be
sufficient for writing many useful Emacs commands. We have covered
examples of various kinds of functions, both Lisp primitives and
built-in Emacs functions. You should be able to extrapolate many
others from the ones given in this chapter along with help techniques
such as those just provided. In other words, you are well on your way
to becoming a fluent Emacs Lisp programmer. To test yourself, start
with the code for <span class="docEmphBold">count-words-buffer</span>
and try writing the following functions:</P>

<DL class="docList"><br><p><DT><span class="docPubcolor"><span class="docEmphBold">count-lines-buffer</span></span></DT></p>
<DD>
<P class="docList">Print the number of lines in the buffer.</P>
</DD>
<br><p><DT><span class="docPubcolor"><span class="docEmphBold">count-words-region</span></span></DT></p>
<DD>
<P class="docList">Print the number of words in a region.</P>
</DD>
<br><p><DT><span class="docPubcolor"><span class="docEmphBold">what-line</span></span></DT></p>
<DD>
<P class="docList">Print the number of the line point is currently on.</P>
</DD>
</DL>



<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="gnu3-CHP-11-SECT-2.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="gnu3-CHP-11-SECT-4.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
