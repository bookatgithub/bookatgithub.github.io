<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="1.2 How to Run Python Programs"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode11.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode13.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT>
<h3>1.2
How to Run Python Programs</h3>


<p>So far, we've mostly talked about Python as a programming
language. But it's also a software package called an
<i>interpreter</I>
<A NAme="idx31"></a>. An interpreter is a kind of program
that executes other programs. When you write Python programs, the
Python interpreter reads your program, and carries out the
instructions it contains.<fONT Size="1"><sUP><A Href="#FOOTNOTE-3">[3]</a></sup></font>

In this section we explore ways to tell the
<a name="idx32"></a>Python
interpreter which programs to run.</p>


<blOcKquoTe><FOnT SiZe="1">
<P CLAss="footnote">
<suP><A NAme="FOOTNOTE-3">[3]</a></sUP>
Technically, Python
programs are first compiled (i.e., translated) to an intermediate
form—byte-code— which is then scanned by the Python
interpreter. This byte-code compilation step is hidden and automatic,
and makes Python faster than a pure interpreter.</P>
</Font></bLOCKquote>





<p>When the Python package is installed on your machine, it generates a
number of components. Depending on how you use it, the Python
interpreter may take the form of an executable program, or a set of
libraries linked into another program. In general, there are at least
five ways to run programs through the Python interpreter:</p>



<ul>
<li><p>	Interactively</p>
</li>
<li><p>	As Python module files</p>
</lI>
<lI><p>	As Unix-style script files</p>
</lI>
<lI><P>	Embedded in another system</p>
</LI>
<lI><p>	Platform-specific launching methods</P>
</LI>
</Ul>
<p>Let's look at each of these strategies in turn.</p>



<p><TABLe celLSPAcing="0" WIDTh="90%" border="1"><tr><td>
<center><h2>
Other Ways to Launch Python Programs</h2></cEnTer>


<p>
<A nAMe="idx33"></A>Caveat: to keep things simple, the description of using the
interpreter in this chapter is fairly generic and stresses
lowest-common-denominator ways to run Python programs (i.e., <A nAmE="idx34"></A>the
command line, which works the same everywhere Python runs). For
information on other ways to run Python on specific platforms, flip
ahead to <A href="lpython_cnode123.html">Appendix B</a>. For instance, Python ports for
MS-Windows and the Macintosh include graphical interfaces for editing
and running code, which may be more to your taste.</P>



<P>Depending on your platform and background, you may also be interested
in seeing a description of the new IDLE Integrated Development
Environment for Python—a graphical interface for editing,
running, and debugging Python code that runs on any platform where
Python's Tk support is installed (IDLE is a Python program that
uses the Tkinter extension we'll meet in <A href="lpython_cnode87.html">Part II</a>).You can find
this description in <A href="lpython_cnode114.html">Appendix A</a>. Emacs users can
also find support at Python's web site for launching Python
code in the Emacs environment; again, see <a href="lpython_cnode114.html">Appendix A</A> for details.</p>


</td></tr></table></p>



<h4>1.2.1
The Interactive Command Line</h4>


<p>Perhaps the simplest way to<a name="idx35"></a> <A nAme="idx36"></a> run Python programs is to type them
at Python's <A nAMe="idx37"></A>interactive command line. Assuming the
interpreter is installed as an executable program on your system,
typing <Tt ClASS="monofont">python</Tt> at your operating system's
prompt without any arguments starts the interactive interpreter. For
example:</p>



<prE CLAss="monofont">% <b>python</b>
&gt;&gt;&gt;<B> print 'Hello world!'</B>
Hello world!
&gt;&gt;&gt;<B> lumberjack = "okay"    </B>
&gt;&gt;&gt;<b>                           </b># Ctrl-D to exit (Ctrl-Z on some platforms)</prE>


<P>Here <TT class="monofont">python</tt> is typed at a Unix (or MS-DOS) prompt
to begin an interactive Python session. Python
<a name="idx38"></a>
<a name="idx39"></a>prompts for input with
<tT cLass="monofont">&gt;&gt;&gt;</Tt> when it's waiting for you to
type a new Python statement. When working interactively, the results
of statements are displayed after the <TT cLAsS="monofont">&gt;&gt;&gt;</tT>
lines. On most Unix machines, the two-key combination Ctrl-D (press
the Ctrl key, then press D while Ctrl is held down) exits the
interactive command-line and returns you to your operating
system's command line; on MS-DOS and Windows systems, you may
need to type Ctrl-Z to exit.</P>



<P>Now, we're not doing much in the previous example: we type
Python <Tt claSS="monofont">print</TT> and assignment statements, which
we'll study in detail later. But notice that the code we
entered is executed immediately by the interpreter. For instance,
after typing a <tt clASS="monofont">print</Tt> statement at the
<tt cLASS="monofont">&gt;&gt;&gt;</tt> prompt, the output (a Python string)
is echoed back right away. There's no need to run the code
through a compiler and linker first, as you'd normally do when
using a language such as C or C++.</p>



<p>Because code is executed immediately, the interactive prompt turns
out to be a handy place to experiment with the language, and
we'll use it often in this part of the book to demonstrate
small examples. In fact, this is the first rule of thumb: if
you're ever in doubt about how a piece of Python code works,
fire up the interactive command line and try it out. That's
what it's there for.</p>



<p>The <a name="idx40"></a>interactive prompt is also commonly used as
a place to test the components of larger systems. As we'll see,
the interactive command line lets us import components interactively
and test their interfaces rapidly. Partly because of this interactive
nature, Python supports an experimental and exploratory programming
style you'll find convenient when starting out.</p>



<p><table bOrDer="0" bGcOLoR="black" CeLlSPACing="0" cELLPaddiNG="1" WIdth="90%" aLIGN="center"><tr><td>
<table bgcolor="white" widtH="100%" bOrdeR="0" cELlSPaCiNG="0" CEllpaDDINg="6"><tr>
<tD WIDth="60" vaLIGN="top"><img src="FILES/tip_yellow.gif" width="50" height="54"></td>
<tD vAligN="top">


<p>A word on prompts: we won't meet compound (multiple-line)
statements until <A href="lpython_cnode31.html">Chapter 3</a>, but as a preview, you
should know that when typing lines two and beyond of a compound
statement interactively, the prompt changes to <Tt CLASs="monofont">...</tt>
instead of <tT CLAss="monofont">&gt;&gt;&gt;</tt>. At the
<TT CLass="monofont">...</tT> prompt, <A NAme="idx41"></a>a blank line (hitting the Enter key) tells
Python that you're done typing the statement. This is different
from compound statements typed into files, where blank lines are
simply ignored. You'll see why this matters in <a href="lpython_cnode31.html">Chapter 3</a>. These two prompts can also be changed (in
<a href="lpython_cnode87.html">Part II</a>, we'll see that they are attributes in the built-in
<tt claSs="monofont">sys</Tt> module), but we'll assume they
haven't been in our examples.</p>

</tD>
</tR></TaBLe></Td></TR></TAble></p><BR>






<H4>1.2.2
Running Module Files</H4>


<p>Although the interactive prompt is great for experimenting and
testing, it has one big disadvantage: programs you type there go away
as soon as the <a naME="idx42"></A>Python
interpreter executes them. The code you type interactively is never
stored in a file, so you can't run it again without retyping it
from scratch. Cut-and-paste and command recall can help some here,
but not much, especially when you start writing larger programs.</P>



<p>To save programs permanently, you need Python<i> module
files</i>
<a NAME="idx43"></a>. Module
files are simply text files containing Python statements. You can ask
the Python interpreter to execute such a file by listing its name in
a <tt class="monofont">python</tt> command. As an example, suppose we start
our favorite text editor and type two Python statements into a text
file named <i>spam.py</i>:</p>



<pre clasS="monofont">import sys
print sys.argv                  # more on this later</pRe>


<p>Again, we're ignoring the syntax of the statements in this file
for now, so don't sweat the details; the point to notice is
that we've typed code into a file, rather than at the
interactive prompt. Once we've saved our text file, we can ask
Python to run it by listing the filename as an argument on a
<tT cLAsS="monofont">python</Tt> command in the operating system shell:</P>



<pRE CLass="monofont">% <b>python spam.py -i eggs -o bacon</B>
['spam.py', '-i', 'eggs', '-o', 'bacon']</PRE>


<p>Notice that we called the module file <i>spam.py</i>;
we could also call it simply <i>spam</I>, but for
reasons we'll explain later, files of code we want to import
into a client have to end with a <I>.py</I> suffix. We
also listed four command-line arguments to be used by the Python
program (the items after <Tt claSS="monofont">python</TT>
<tt class="monofont">spam.py</tt>); these are passed to the Python program,
and are available through the name <tt class="monofont">sys.argv</tt>,
<tt ClAss="monofont"></tT>
<a NAmE="idx44"></A> <a NaME="idx45"></A>which works like the C
<Tt claSS="monofont">argv</TT> array. By the way, if you're working on
a Windows or MS-DOS platform, this example works the same, but the
system prompt is normally different:</p>



<pre CLASs="monofont">C:\book\tests&gt;<b> python spam.py -i eggs -o bacon</b>
['spam.py', '-i', 'eggs', '-o', 'bacon']</pRE>






<H4>1.2.3
Running Unix-Style Scripts</H4>


<p>So far, we've seen how to type code interactively and run files
of code created with a text editor (modules). If you're going
to use Python on a Unix, Linux, or <a name="idx46"></a>Unix-like system, you can also
turn files of Python code into executable programs, much as you would
for programs coded in a shell language such as
<i>csh</i> or <i>ksh</i>. Such files are
usually called <a name="idx47"></a>
<i>scripts</i>; in simple terms, Unix-style scripts are
just text files containing Python statements, but with two special
properties:</p>



<Dl>
<Dt>
<i><fOnT CoLOr="#990000">Their first line is special</FoNT></I></Dt>
<dd>
<p>Scripts usually start with a first line that begins with the
characters <TT CLass="monofont">#!</tT>, followed by the path to the Python
interpreter on your machine.</P>
</DD>
<dt>
<i><fONT Color="#990000">They usually have executable privileges</font></i></dt>
<dd>
<p>Script files are usually marked as executable, to tell the operating
system that they may be run as top-level programs. On Unix systems, a
command such as <tt clasS="monofont">chmod +x file.py</tT> usually does the
trick.</p>
</dd>
</Dl>


<P>Let's look at an example. Suppose we use our favorite text
editor again, to create a file of Python code called
<I>brian</i>:</P>



<PrE cLASS="monofont">#!/usr/local/bin/python
print 'The Bright Side of Life...'         # another comment here</pre>


<p>We put the special line at the top of the file to tell the system
where the Python interpreter lives. Technically, the first line is a
Python comment. All comments in Python programs start with a
<TT CLass="monofont">#</tT> and span to the end of the line; they are a
place to insert extra information for human readers of your code. But
when a comment such as the first line in this file appears,
it's special, since the operating system uses it to find an
interpreter for running the program code in the rest of the file.</P>



<P>We also called this file simply <I>brian</i>, without
the <i>.py</i> suffix we used for the module file
earlier. Adding a <i>.py</I> to the name wouldn't
hurt (and might help us remember that this is a Python program file);
but since we don't plan on letting other modules import the
code in this file, the name of the file is irrelevant. If we give our
file executable privileges with a <TT Class="monofont">chmod</tt>
<tt class="monofont">+x brian</tt> shell command, we can run it from the
operating system shell as though it were a binary program:</p>



<pre cLaSs="monofont">% <b>brian</b>
The Bright Side of Life...</PrE>


<P>A note for Windows and MS-DOS users: the method described here is a
Unix trick, and may not work on your platform. Not to worry: just use
the module file technique from the previous section. List the
file's name on an explicit <tT ClAsS="monofont">python</TT> command
line:</P>



<pre cLASS="monofont">C:\book\tests&gt; <b>python brian</b>
The Bright Side of Life...</prE>


<P>In this case, you don't need the special <TT clasS="monofont">#!</TT>
comment at the top (though Python just ignores it if it's
present), and the file doesn't need to be given executable
privileges. In fact, if you want to run files portably between Unix
and MS-Windows, your life will probably be simpler if you always use
the module file approach, not Unix-style scripts, to launch programs.</P>



<p><table border="0" bgcolor="black" cElLspaCiNG="0" cELlPaDDINg="1" widTH="90%" ALign="center"><tR><TD>
<Table BGCOlor="white" width="100%" border="0" cellspAcIng="0" cElLPaDDiNg="6"><TR>
<TD widtH="60" VALign="top"><iMG src="FILES/tip_yellow.gif" widTH="50" HEight="54"></td>
<td valign="top">
<p>On some systems, you can avoid hardcoding the path to the Python
interpreter by writing the special first-line comment like this:
<tt claSs="monofont">#!/usr/bin/env</Tt> <tt ClASs="monofont">python</TT>. When
coded this way, the <tT cLASS="monofont">env</tt> program locates the
<tt CLASs="monofont">python</tt> interpreter according to your system
search-path settings (i.e., in most Unix shells, by looking in all
directories listed in the <tT CLAss="monofont">PATH</tt> environment
variable). This <TT CLass="monofont">env</tt>-based scheme can be more
portable, since you don't need to hardcode a Python install
path in the first line of all your scripts; provided you have access
to <tt class="monofont">env</tt> everywhere, your scripts will run no matter
where <tt clasS="monofont">python</tT> lives on your system.</p>

</td>
</Tr></TAbLE></tD></tR></TABle></p><bR>






<H4>1.2.4
Embedded Code and Objects</H4>


<P>We've<a namE="idx48"></A> seen how to run code interactively,
and how to launch module files and Unix-style scripts. That covers
most of the cases we'll see in this book. But in some
specialized domains, Python code may also be run by an enclosing
system. In such cases, we say that Python programs are embedded in
(i.e., run by) another program. The Python code itself may be entered
into a text file, stored in a database, fetched from an HTML page,
and so on. But from an operational perspective, another
system—not you—may tell Python to run the code
you've created.</P>



<P>For example, it's possible to create and run strings of Python
code from a C program by calling functions in the Python runtime API
(a set of services exported by the libraries created when Python is
compiled on your machine):</p>



<pre CLASs="monofont">#include &lt;Python.h&gt;
. . .
Py_Initialize();
PyRun_SimpleString("x = brave + sir + robin");</pre>


<p>In this code snippet, a program coded in the C language
(<tt class="monofont">somefile.c</tt>) embeds the Python interpreter by
linking in its libraries and passes it a Python assignment statement
string to run. C programs may also gain access to Python objects, and
process or execute them using other Python API tools.</p>



<p>This book isn't about Python/C <a namE="idx49"></a>integration, so we won't go into
the details of what's really happening here.<Font SiZE="1"><sUP><a HrEF="#FOOTNOTE-4">[4]</A></Sup></foNT>
 But you should be aware
that, depending on how your organization plans to use Python, you may
or may not be the one who actually starts the Python programs you
create. Regardless, you can still use the interactive and file-based
launching techniques described here, to test code in isolation from
those enclosing systems that may eventually use it.</P>


<BlockQUOTe><fonT SIZe="1">
<p class="footnote">
<sup><a name="FOOTNOTE-4">[4]</a></sup>
See <i>Programming Python</I> for more details on
embedding Python in C/C++.</p>
</Font></BlOCkQUoTe>









<H4>1.2.5
Platform-Specific Startup Methods</H4>


<P>Finally, depending on which type of computer you are using, there may
be more specific ways to start Python programs than the general
techniques we outlined above. For instance, on some Windows ports of
Python, you may either run code from a Unix-like command-line
interface, or by double-clicking on Python program icons. And on
Macintosh ports, you may be able to drag Python program icons to the
interpreter's icon, to make program files execute. We'll
have more to say about platform-specific details like this in an
appendix to this book.</P>







<h4>1.2.6
What You Type and Where You Type It</h4>


<p>With all these options and commands, it's easy for beginners to
be confused about which command is entered at which prompt.
Here's a quick summary:</p>



<DL>
<DT>
<i><fonT COLor="#990000">Starting interactive Python</foNT></I></Dt>
<dd>
<p>The Python interpreter is usually started from the system's
command line:</p>
</dd>
</dl>


<pre class="monofont">% <b>python</b></pRe>


<Dl>
<dt>
<I><fONt COlOr="#990000">Entering code interactively</FONT></i></dt>
<dD>
<P>Programs may be typed at Python's interactive interpreter
command line:</P>
</Dd>
</dl>


<pRE CLass="monofont">&gt;&gt;&gt; <b>print X</B></PRE>


<dl>
<dt>
<i><font color="#990000">Entering code in files for later use</font></i></dT>
<dD>
<p>Programs may also be typed into text files, using your favorite text
editor:</p>
</dD>
</dL>


<PrE ClAsS="monofont"><B>print X</B></Pre>


<dl>
<DT>
<I><Font cOLOR="#990000">Starting script files</font></I></DT>
<Dd>
<p>Unix-style script files are started from the system shell:</p>
</dd>
</dl>


<pre class="monofont">% <b>brian</b></pre>


<Dl>
<Dt>
<i><fOnT CoLOr="#990000">Starting program (module) files</FoNT></I></Dt>
<dd>
<p>Module files are run from the system shell:</P>
</DD>
</Dl>


<pre CLASs="monofont">% <b>python spam.py</b></pRE>


<DL>
<dt>
<i><font color="#990000">Running embedded code</font></i></dt>
<dD>
<p>When Python is embedded, Python code may be entered in arbitrary ways.</P>
</dd>
</dL>


<p><TAbLE bOrDER="0" BgcolOR="black" CEllspACINg="0" celLPADding="1" width="90%" align="center"><tr><td>
<taBlE bgcOlOR="white" wIDtH="100%" bORDEr="0" celLSPAcing="0" CELLpaddING="6"><Tr>
<td width="60" valign="top"><img src="FILES/tip_yellow.gif" WiDth="50" hEiGHt="54"></TD>
<tD vALIGn="top">


<p>When typing Python programs (either interactively or into a text
file), be sure to start all your unnested statements in column 1. If
you don't, Python prints a "SyntaxError" message.
Until the middle of <a href="lpython_cnode31.html">Chapter 3</A>, all our statements
will be unnested, so this includes everything for now. We'll
explain why later—it has to do with Python's indentation
rules—but this seems to be a recurring confusion in
introductory Python classes.</p>

</td>
</tR></TABle></td></TR></TAble></p><br>

</font>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode11.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode13.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>