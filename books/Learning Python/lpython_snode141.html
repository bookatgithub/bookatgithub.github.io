<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="C.10 Chapter 10"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode140.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_cnode142.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT>
<h3>C.10
<a href="lpython_cnode103.html">Chapter 10</A></H3>


<ol tyPE="1">
<LI><p><i>Faking the Web.
</i>What you need to do is to create instances of a class that
has the fieldnames attribute and appropriate instance variables. One
possible solution is:</p>



<PRE Class="monofont">class FormData:
    def __init__(self, dict):
        for k, v in dict.items():
            setattr(self, k, v)
class FeedbackData(FormData):
    """ A FormData generated by the comment.html form. """
    fieldnames = ('name', 'address', 'email', 'type', 'text')
    def __repr__(self):
        return "%(type)s from %(name)s on %(time)s" % vars(self)

fake_entries = [
    {'name': "John Doe",
     'address': '500 Main St., SF CA 94133',
     'email': 'john@sf.org',
     'type': 'comment',
     'text': 'Great toothpaste!'},
    {'name': "Suzy Doe",
     'address': '500 Main St., SF CA 94133',
     'email': 'suzy@sf.org',
     'type': 'complaint',
     'text': "It doesn't taste good when I kiss John!"},
    ]

DIRECTORY = r'C:\complaintdir'
if __name__ == '__main__':
    import tempfile, pickle, time
    tempfile.tempdir = DIRECTORY
    for fake_entry in fake_entries:
        data = FeedbackData(fake_entry)
        filename = tempfile.mktemp()
        data.time = time.asctime(time.localtime(time.time()))
        pickle.dump(data, open(filename, 'w'))</pre>


<p>As you can see, the only thing you really had to change was the way
the constructor for <tt class="monofont">FormData</tt> works, since it has
to do the setting of attributes from a dictionary as opposed to a
<tt cLasS="monofont">FieldStorage</Tt> object.</p>
</Li>
<li><P><I>Cleaning up.
</i>There are many ways to deal with this problem. One easy
one is to modify the <i>formletter.py</I> program to
keep a list of the filenames that it has already processed (in a
pickled file, of course!). This can be done by modifying the
<TT CLass="monofont">if </tT>__<TT Class="monofont">main</TT>__<TT clasS="monofont"> ==
'</TT>__<Tt class="monofont">name</tt>__<tt class="monofont">'</tt> test to
read something like this (new lines are in bold):</p>



<prE clASs="monofont">if __name__ == '__main__':
    import os, pickle
<b>    CACHEFILE = 'C:\cache.pik'</B>
    from feedback import DIRECTORY#, FormData, FeedbackData
<b>    if os.path.exists(CACHEFILE):</b>
<b>        processed_files = pickle.load(open(CACHEFILE))</B>
<B>    else:</b>
<b>        processed_files = []</B>
    for filename in os.listdir(DIRECTORY):
<B>        if filename in processed_files: continue </B> # skip this filename
<B>        processed_files.append(filename)</B>
        data = pickle.load(open(os.path.join(DIRECTORY, filename)))
        if data.type == 'complaint':
            print "Printing letter for %(name)s." % vars(data)
            print_formletter(data)
        else:
            print "Got comment from %(name)s, skipping printing." % \
                  vars(data)
    <b>pickle.dump(processed_file, open(CACHEFILE, 'w')</b></prE>


<P>As you can tell, you simply load a list of the previous filenames if
it exists (and use an empty list otherwise) and compare the filenames
with entries in the list to determine which to skip. If you
don't skip one, it needs to be added to the list. Finally, at
program exit, pickle the new list.</P>
</Li>
<li><p><I>Adding parametric plotting
to grapher.py.</I> This exercise is quite simple, as all
that's needed is to change the drawing code in the Chart class.
Specifically, the code between <TT clasS="monofont">xmin, xmax = 0, N-1</TT>
and <Tt class="monofont">graphics.fillPolygon(...)</tt> should be placed in
an <tt class="monofont">if</tt> test, so that the new code reads:</p>



<prE clASs="monofont">if not hasattr(self.data[0], '__len__'):   # it's probably a number (1D)
       xmin, xmax = 0, N-1
                                        # code from existing program, up to
       graphics.fillPolygon(xs, ys, len(xs))
elif len(self.data[0]) == 2:               # we'll only deal with 2-D
       xmin = reduce(min, map(lambda d: d[0], self.data))
       xmax = reduce(max, map(lambda d: d[0], self.data))

       ymin = reduce(min, map(lambda d: d[1], self.data))
       ymax = reduce(max, map(lambda d: d[1], self.data))

       zero_y = y_offset - int(-ymin/(ymax-ymin)*height)
       zero_x = x_offset + int(-xmin/(xmax-xmin)*width)

       for i in range(N):
           xs[i] = x_offset + int((self.data[i][0]-xmin)/(xmax-xmin)*width)
           ys[i] = y_offset - int((self.data[i][1]-ymin)/(ymax-ymin)*height)
       graphics.color = self.color
       if self.style == "Line":
           graphics.drawPolyline(xs, ys, len(xs))
       else:
           xs.append(xs[0]); ys.append(ys[0])
           graphics.fillPolygon(xs, ys, len(xs))</pRe></li>
</OL>

</foNT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode140.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_cnode142.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>