<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="2.3 Numbers"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode20.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode22.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT>
<h3>2.3
Numbers</h3>


<p>On to the nitty-gritty. The first<a NAME="idx77"></a> object type
on our tour is Python numbers. In general, Python's number
types are fairly typical and will seem familiar if you've used
just about any other programming language in the past. Python
supports the usual numeric types (integer and
<a naME="idx78"></A>floating point), constants, and
expressions. In addition, Python provides more advanced numeric
programming support, including a complex number type, an unlimited
precision integer, and a variety of numeric tool libraries. The next
few sections give an overview of the numeric support in Python.</P>




<h4>2.3.1
Standard Numeric Types</h4>


<p>Among its basic<a NAME="idx79"></a> types,
Python supports the usual suspects: both integer and floating-point
numbers, and all their associated syntax and operations. Like C,
Python also allows you to write integers using hexadecimal and octal
constants. Unlike C, Python also has a complex number type
(introduced in Python 1.4), as well as a long integer type with
unlimited precision (it can grow to have as many digits as your
memory space allows). <a href="lpython_snode21.html#2">Table 2.2</a> shows what
Python's numeric types look like when written out in a program
(i.e., as constants).</p>



<a name="2"></a><p><table BoRder="1" CeLLsPAcInG="0" CELlpadDING="1" widtH="100%">
<CAPtion><H5>Table 2.2. Numeric Constants </H5></CAption><colgroup span="2">
<tr>
<tH>
<fOnt sIzE="2">
<P>Constant</p>
</FOnT></tH>
<TH>
<Font sIZE="2">
<P>Interpretation</p>
</fonT></TH>
</Tr>
<tr>
<tD>
<FONt size="2">
<p><tt class="monofont">1234</tt>, <tt claSs="monofont">-24</Tt>, <tt ClASs="monofont">0</TT></p>
</FoNT></TD>
<td>
<foNT SIze="2">
<p>Normal integers (C longs)</p>
</FONT></td>
</tr>
<TR>
<TD>
<font size="2">
<p><tt class="monofont">999999999999L</tt></p>
</fOnT></td>
<tD>
<fONt SIzE="2">
<p>Long integers (unlimited size)</P>
</FONt></td>
</tR>
<TR>
<Td>
<fonT SIZe="2">
<p><tt CLASs="monofont">1.23</tt>, <tt class="monofont">3.14e-10</tt>,
<tt class="monofont">4E210</tT>, <tT claSs="monofont">4.0e+210</TT></p>
</FOnT></tD>
<TD>
<Font sIZE="2">
<P>Floating-point (C doubles)</p>
</fonT></TD>
</Tr>
<tr>
<tD>
<FONt size="2">
<p><tt class="monofont">0177</tt>,  <tt claSs="monofont">0x9ff</Tt></p>
</fOnT></Td>
<TD>
<fOnT SIZe="2">
<p>Octal and hex constants</p>
</fONT></Td>
</tr>
<tR>
<TD>
<Font sIZE="2">
<P><tt class="monofont">3+4j</tt>, <tt class="monofont">3.0+4.0j</tt>,
<tt ClAss="monofont">3J</tT></p>
</FOnT></Td>
<Td>
<FONT size="2">
<P>Complex number constants</P>
</FOnt></td>
</TR>
</COlgroUP>
</TAble></p>



<p>By and large, Python's numeric types are straightforward, but a
few are worth highlighting here:</p>



<a name="idx80"></a><a name="idx81"></a><a nAmE="idx82"></a><a nAmE="idx83"></A><a NAmE="idx84"></a><DL>
<DT>
<i><fonT COLor="#990000">Integer and floating-point constants</foNT></I></Dt>
<dd>
<p>I<A NAMe="idx80"></a>ntegers are
written as a string of decimal digits. Floating-point numbers have an
embedded decimal point, and/or an optional signed exponent introduced
by an <tt class="monofont">e</tt> or <tt class="monofont">E</tt>. If you write a
number with a decimal point or exponent, Python makes it a
floating-point object and uses floating-point (not integer) math when
it's used in an expression. The rules for writing
floating-point numbers are the same as with C.</P>
</dD>
<dt>
<fOnT CoLOr="#990000">N<A nAME="idx81"></A>umeric precision</font></DT>
<DD>
<p>Plain Python integers (row 1) are implemented as C
<tt cLASS="monofont">longs</tt> internally (i.e., at least 32 bits), and
Python floating-point numbers are implemented as C
<tt CLASs="monofont">doubles</tt>; Python numbers get as much precision as
the C compiler used to build the Python interpreter gives to
<tt class="monofont">longs</tt> and <tt class="monofont">doubles</tT>. On the other
hand, if an integer constant ends with an <tT claSs="monofont">l</TT> or
<tT ClAsS="monofont">L</TT>, it becomes a Python long integer (not to be
confused with a C <Tt claSS="monofont">long</TT>) and can grow as large as
needed.</p>
</dd>
<dT>
<FONt colOR="#990000">H<A Name="idx82"></a>
<a name="idx83"></a>exadecimal and octal constants</font></dt>
<dd>
<p>The rules for writing hexadecimal (base 16) and octal (base 8)
integers are the same as in C: octal constants start with a leading
zero (<tT cLass="monofont">0</Tt>), and hexadecimals start with a leading
<TT cLAsS="monofont">0x</tT> or <TT Class="monofont">0X</TT>. Notice that this
means you can't write normal base-ten integers with a leading
zero (e.g., <TT clasS="monofont">01</TT>); Python interprets them as octal
constants, which usually don't work as you'd expect!</P>
</dd>
<dt>
<FONT color="#990000">C<a name="idx84"></a>omplex numbers</font></dt>
<dd>
<p>Python complex constants are written as <Tt ClasS="monofont">real-part</tT>
<Tt CLaSs="monofont">+</TT> <TT clasS="monofont">imaginary-part</TT>, and
terminated with a <Tt claSS="monofont">j</TT> or <tt clASS="monofont">J</Tt>.
Internally, they are implemented as a pair of floating-point numbers,
but all numeric operations perform complex math when applied to
complex numbers.</p>
</dd>
</dl>






<h4>2.3.2
Built-in Tools and Extensions</h4>


<p>Besides the built-in number types shown in <a href="lpython_snode21.html#2">Table 2.2</a>, Python provides a set of tools for processing
<a name="idx85"></A>number objects:</p>



<Dl>
<dt>
<I><fONt COlOr="#990000">Expression operators</FONT></i></dt>
<dD>
<P><TT clasS="monofont">+</TT>, <Tt claSS="monofont">*</TT>,
<tt class="monofont">&gt;&gt;</tt>, <tt class="monofont">**</tt>, etc.</p>
</dD>
<dT>
<i><foNt COlOR="#990000">Built-in mathematical functions</fOnT></I></DT>
<dd>
<p><tT CLAss="monofont">pow</tt>, <TT CLass="monofont">abs</tT>, etc.</P>
</DD>
<dt>
<i><font color="#990000">Utility modules</font></i></dt>
<dD>
<p><Tt clAsS="monofont">rand</Tt>, <TT cLaSS="monofont">math</TT>, etc.</p>
</dd>
</dL>


<P>We'll meet all of these as we go along. Finally, if you need to
do serious number-crunching, an optional extension for Python called
<I>Numeric Python</I> provides advanced numeric
programming tools, such as a matrix data type and sophisticated
computation libraries. Because it's so advanced, we won't
say more about Numeric Python in this chapter; see the examples later
in the book and <a href="lpython_cnode114.html">Appendix A</A>. Also note that, as of
this writing, Numeric Python is an optional extension; it
doesn't come with Python and must be installed separately.</P>







<H4>2.3.3
Python Expression Operators</h4>


<p>Perhaps the most fundamental tool that processes numbers is the
<i>expression</i>
<A NAMe="idx86"></a>: a combination of numbers (or other
objects) and operators that computes a value when executed by Python.
In Python, expressions are written using the usual mathematical
notation and operator symbols. For instance, to add two numbers
<tt class="monofont">X</tt> and <tt class="monofont">Y</tt>, we say
<Tt ClasS="monofont">X</tT> <Tt CLaSs="monofont">+</TT> <TT clasS="monofont">Y</TT>, which
tells Python to apply the <Tt claSS="monofont">+</TT> operator to the values
named by <tt clASS="monofont">X </Tt>and <tt class="monofont">Y</tt>. The result of
the expression is the sum of <tt class="monofont">X</tt> and
<tT cLass="monofont">Y</Tt>, another number object.</P>



<P><a href="lpython_snode21.html#5">Table 2.3</a> lists all the operator expressions
available in Python. Many are self-explanatory; for instance, the
usual mathematical operators are supported: <TT CLass="monofont">+</tT>,
<TT Class="monofont">-</TT>, <TT clasS="monofont">*</TT>, <Tt class="monofont">/</tt>, and
so on. A few will be familiar if you've used C in the past:
<tt class="monofont">%</tt> computes a division remainder,
<tt cLaSs="monofont">&lt;&lt;</tt> performs a bitwise left-shift,
<Tt CLaSS="monofont">&amp;</tT> computes a bitwise <tT CLAss="monofont">and</tt>
result, etc. Others are more Python-specific, and not all are numeric
in nature: the <TT CLass="monofont">is</tT> operator tests object identity
(i.e., address) equality, <TT Class="monofont">lambda</TT> creates unnamed
functions, and so on.</P>



<A name="5"></a><p><table border="1" celLsPaciNg="0" CElLPaDdING="1" Width="100%">
<CAPTion><h5>Table 2.3. Python Expression Operators and Precedence </H5></CAPtion><COLGroup span="2">
<tr>
<th>
<font size="2">
<P>Operators</p>
</Font></Th>
<TH>
<fONt SiZE="2">
<P>Description</P>
</font></TH>
</TR>
<tr>
<td>
<FONT size="2">
<P><TT Class="monofont">x or y,</tt>
<a name="idx87"></a> <a name="idx88"></a> <a nAmE="idx89"></a>
<a nAmE="idx90"></A>
<a NAmE="idx91"></a></P>



<P><TT clasS="monofont">lambda args: expression</TT>
<A name="idx92"></A></P>
</FOnt></td>
<TD>
<FOnt size="2">
<p>Logical <tt class="monofont">or</tt> ( <tt clAsS="monofont">y</tt> is evaluated
only if <tT cLAsS="monofont">x</Tt> is false), anonymous function</P>
</fONT></Td>
</tr>
<tR>
<TD>
<Font sIZE="2">
<P><tt clASS="monofont">x and y</Tt></p>
</font></td>
<td>
<font size="2">
<p>Logical <tT cLass="monofont">and</Tt> (<TT cLAsS="monofont">y</tT> is evaluated
only if <TT Class="monofont">x</TT> is true)</P>
</Font></tD>
</TR>
<Tr>
<td>
<fONT Size="2">
<p><tt class="monofont">not x</tt></p>
</font></td>
<Td>
<Font SiZE="2">
<p>Logical negation</P>
</FoNt></TD>
</TR>
<tr>
<td>
<FONT size="2">
<P><TT Class="monofont">in, not in</TT>
<A Name="idx93"></a> <a name="idx94"></a>
<a name="idx95"></a> <a namE="idx96"></a>
<A namE="idx97"></a> <A NaME="idx98"></a>
<A nAME="idx99"></A>
<a namE="idx100"></A> <A Name="idx101"></a> <A NAMe="idx102"></a> <a nAME="idx103"></A> <a name="idx104"></a></p>
</font></td>
<td>
<font sIzE="2">
<p>sequence membership</p>
</fOnT></Td>
</TR>
<tR>
<tD>
<FONt sizE="2">
<P><TT clasS="monofont">x | y</TT>
<A name="idx105"></A> <A NAme="idx106"></a> <a name="idx107"></a>
<a name="idx108"></a></p>
</font></Td>
<Td>
<foNt SIzE="2">
<P>Bitwise <tT cLASS="monofont">or</tt></p>
</fONT></Td>
</tr>
<tR>
<TD>
<Font sIZE="2">
<P><tt class="monofont">x ^ y</tt></p>
</font></td>
<td>
<foNt Size="2">
<P>Bitwise <tT ClASs="monofont">exclusive</Tt> <TT CLass="monofont">or</tT></P>
</FOnt></td>
</TR>
<TR>
<td>
<foNT SIze="2">
<p><tt class="monofont">x &amp; y</tt></p>
</font></td>
<tD>
<fOnt sIzE="2">
<P>Bitwise <tT ClAsS="monofont">and</TT></P>
</font></TD>
</TR>
<tr>
<td>
<FONT size="2">
<P><TT Class="monofont">x &lt;&lt; y, x &gt;&gt; y</tt>
<a name="idx109"></a>
<a name="idx110"></a> <a nAmE="idx111"></a></p>
</fOnT></Td>
<TD>
<fOnT SIZe="2">
<p>Shift <tt CLASs="monofont">x</tt> left or right by <tT CLAss="monofont">y</tt> bits</P>
</FONt></td>
</tr>
<tr>
<td>
<font size="2">
<p><tt ClAss="monofont">x + y, x - y</tT>
<a NAmE="idx112"></A>
<a NaME="idx113"></A> <A name="idx114"></A> <A NAme="idx115"></a> <a NAME="idx116"></a></p>
</foNT></TD>
<td>
<font size="2">
<p>Addition/concatenation, subtraction</p>
</font></td>
</tr>
<Tr>
<Td>
<foNt SIzE="2">
<P><tT cLASS="monofont">x * y, x / y, x % y</tt>
<a nAME="idx117"></A>
<a namE="idx118"></A> <A Name="idx119"></a>
<A NAMe="idx120"></a>
<a name="idx121"></a>
<a name="idx122"></a>
<a name="idx123"></a>
<A nAme="idx124"></a></P>
</fONt></TD>
<tD>
<fONT Size="2">
<p>Multiplication/repetition, division, remainder/format</P>
</FONt></td>
</tR>
<TR>
<Td>
<fonT SIZe="2">
<p><tt class="monofont">-x, +x, ~x</tt>
<a name="idx125"></a> <a naMe="idx126"></A>
<a naMe="idx127"></A> <A nAMe="idx128"></A></p>
</FONT></td>
<td>
<FONT size="2">
<P>Unary negation, identity, bitwise complement</P>
</FOnt></td>
</TR>
<TR>
<td>
<font size="2">
<p><tt class="monofont">x[i], x[i:j], x.y, x(...)</tt></P>
</fOnt></tD>
<tD>
<FoNT sIzE="2">
<P>Indexing, slicing, qualification, function calls</P>
</Font></tD>
</TR>
<Tr>
<td>
<fONT Size="2">
<p><TT CLass="monofont">(...), [...], {...}, `...`</tt></p>
</font></td>
<td>
<font siZe="2">
<P>Tuple, list, dictionary, conversion to string</p>
</foNt></TD>
</tR>
</CoLgROUP>
</tablE></P>



<P><A href="lpython_snode21.html#5">Table 2.3</A> is mostly included for reference; since
we'll see its operators in action later, we won't
describe every entry here. But there are a few basic points
we'd like to make about expressions before moving on.</P>




<H5>2.3.3.1
Mixed operators: Operators bind tighter lower in the table</H5>


<p>As in most languages, more complex expressions are coded by stringing
together operator expressions in the table. For instance, the sum of
two multiplications might be written as: <tt cLASS="monofont">A</tt>
<tt class="monofont">*</tt> <tt class="monofont">B</tt> <Tt ClasS="monofont">+</tT>
<Tt CLaSs="monofont">C</TT> <TT clasS="monofont">*</TT> <Tt claSS="monofont">D</TT>. So
how does Python know which operator to perform first? When you write
an expression with more than one operator, Python groups its parts
according to what are called
<i>precedence</i>
<a nAME="idx129"></A>
<a name="idx130"></a> <a name="idx131"></a> rules, and this grouping
determines the order in which expression parts are computed. In the
table, operators lower in the table have higher precedence and so
bind more tightly in mixed expressions. For example, if you write
<tt class="monofont">X</tT> <tT claSs="monofont">+</TT> <tT ClAsS="monofont">Y</TT>
<Tt claSS="monofont">*</TT> <tt clASS="monofont">Z</Tt>, Python evaluates the
multiplication first (<tt cLASS="monofont">Y</tt> <tt class="monofont">*</tt>
<tt class="monofont">Z</tt>), then adds that result to <Tt ClasS="monofont">X</tT>,
because <Tt CLaSs="monofont">*</TT> has higher precedence (is lower in the
table) than <TT clasS="monofont">+</TT>.</P>






<h5>2.3.3.2
Parentheses group subexpressions</h5>


<p>If the prior paragraph sounded confusing, relax: you can forget about
precedence completely if you're careful to group parts of
expressions with<a NAME="idx132"></a>
<a naME="idx133"></A>
parentheses. When you parenthesize subexpressions, you override
Python precedence rules; Python always evaluates parenthesized
expressions first, before using their results in enclosing
expressions. For instance, instead of <Tt class="monofont">X</tt>
<tt class="monofont">+</tt> <tt cLaSs="monofont">Y</tt> <Tt CLaSS="monofont">*</tT>
<tT CLAss="monofont">Z</tt>, write <TT CLass="monofont">(X</tT>
<TT Class="monofont">+</TT> <TT class="monofont">Y)</tt> <tt class="monofont">*</tt>
<tt clAsS="monofont">Z</tt>, or for that matter <tT cLAsS="monofont">X</Tt>
<Tt CLASs="monofont">+</tt> <tT CLAss="monofont">(Y</tt> <TT CLass="monofont">*</tT>
<TT Class="monofont">Z)</tt> to force Python to evaluate the expression in
the desired order. In the former case, <tt class="monofont">+</tt> is
applied to <tt claSs="monofont">X</Tt> and <tt ClASs="monofont">Y</TT> first; in
the latter, the <tT cLASS="monofont">*</tt> is performed first (as if there
were no parentheses at all). Generally speaking, adding parentheses
in big expressions is a great idea; it not only forces the evaluation
order you want, but it also aids readability.</p>






<h5>2.3.3.3
Mixed types: Converted up just as in C</H5>


<P>Besides<A Name="idx134"></a>
<A NAMe="idx135"></a>
<a nAME="idx136"></A>
<a name="idx137"></a>
<a name="idx138"></a> mixing operators in
expressions, you can also mix numeric types. For instance, you can
add an integer to a floating-point number, but this leads to another
dilemma: what type is the resultinteger or floating-point? The
answer is simple, especially if you've used almost any other
language before: in mixed type expressions, Python first converts
operands up to the type of the most complex operand, and then
performs the math on same-type operands. Python ranks the complexity
of numeric types like so: integers are simpler than long integers,
which are simpler than floating-point numbers, which are simpler than
complex numbers. So, when an integer is mixed with a floating-point,
the integer is converted up to a floating-point value first, and then
floating-point math yields the floating-point result. Similarly, any
mixed-type expression where one operand is a complex number results
in the other operand being converted up to a complex, and yields a
complex result.</p>






<a name="idx145"></a><h5>2.3.3.4
Preview: operator overloading</H5>


<p>Although we're focusing on built-in numbers right now, keep in
mind that all Python operators may be overloaded by Python classes
and C extension types, to work on objects you implement. For
instance, you'll see later that objects coded with classes may
be added with <Tt clAsS="monofont">+</Tt> expressions, indexed with
<TT cLaSS="monofont">[i]</TT> expressions, and so on. Furthermore, some
operators are already overloaded by Python itself: they perform
different actions depending on the type of built-in objects being
processed. For example, the <tt clASS="monofont">+</Tt> operator performs
<i>addition</i> when applied to numbers, but (as
we'll see in a moment) performs
<i>concatenation</I> when applied to sequence objects
such as strings and lists.<FONt sizE="1"><SUP><a href="#FOOTNOTE-2">[2]</a></sup></font>
</p>


<blockqUoTe><foNt SIzE="1">
<P cLaSS="footnote">
<SUp><a naME="FOOTNOTE-2">[2]</A></Sup>
This is usually called
<i>polymorphism</i>the meaning of an operation
depends on the type of objects being operated on. But we're not
quite ready for object-oriented ideas like this yet, so hold that
thought for now.</P>
</FONt></bloCKQUote>










<h4>2.3.4
Numbers in Action</h4>


<p>Perhaps the best way to understand <a name="idx139"></a>numeric objects and expressions is
to see them in action. Let's fire up the interactive command
line and type some basic, but illustrative operations.</p>




<h5>2.3.4.1
Basic operations</h5>


<p>First of all, let's exercise some basic math: addition and
division. In the following interaction, we first <i>assign two
variables</i> (<tt ClAss="monofont">a</tT> and <tT ClASs="monofont">b</Tt>)
to integers, so we can use them later in a larger expression.
We'll say more about this later, but in Python, variables are
created when first assigned; there is no need to predeclare the names
<TT CLass="monofont">a</tT> and <TT Class="monofont">b</TT> before using them. In
other words, the assignments cause these variables to spring into
existence automatically.</P>



<Pre clASS="monofont">% <B>python</b>
&gt;&gt;&gt; <b>a = 3 </b>          # name created
&gt;&gt;&gt; <b>b = 4</b></pre>


<p>We've also used a <i>comment</i> here. These were
introduced in <a href="lpython_cnode9.html">Chapter 1</a>, but as a refresher: in
Python code, text after a <tt cLaSs="monofont">#</tt> mark and continuing to
the end of the line is considered to be a comment, and is ignored by
Python (it's a place for you to write human-readable
documentation for your code; since code you type interactively is
temporary, you won't normally write comments there, but
we've added them to our examples to help explain the code).
Now, let's use our integer objects in expressions; as usual,
expression results are echoed back to us at the interactive prompt:</P>



<pRE cLAsS="monofont">&gt;&gt;&gt; <b>b / 2 + a</B>       # same as ((4 / 2) + 3)
5
&gt;&gt;&gt;<B> b / (2.0 + a)</B>   # same as (4 / (2.0 + 3))
0.8</Pre>


<p>In the first expression, there are no parentheses, so Python
automatically groups the components according to its precedence
rules; since <tT CLAss="monofont">/</tt> is lower in <A href="lpython_snode21.html#5">Table 2.3</a> than <tt CLASs="monofont">+</tt>, it binds more
tightly, and so is evaluated first. The result is as if we had
parenthesized the expression as shown in the comment to the right of
the code. Also notice that all the numbers are integers in the first
expression; because of that, Python performs integer division and
addition.</p>



<p>In the second expression, we add parentheses around the
<tt class="monofont">+</tt> part to force Python to evaluate it first (i.e.,
before the <tt clasS="monofont">/ </tT>). We also made one of the operands
floating point by adding a decimal point: <tt cLaSS="monofont">2.0</tT>.
Because of the mixed types, Python converts the integer referenced by
<Tt ClASS="monofont">a</Tt> up to a floating-point value
(<tt cLASS="monofont">3.0</tt>) before performing the <tt CLASs="monofont">+</tt>.
It also converts <tT CLAss="monofont">b</tt> up to a floating-point value
(<tt class="monofont">4.0</tt>) and performs a
<i>floating-point</i> division: <tt claSs="monofont">(4.0</Tt>
<tt ClASs="monofont">/</TT> <tT cLASS="monofont">5.0)</tt> yields a floating-point
result of <tt CLASs="monofont">0.8</tt>. If this were
<i>integer</I> division instead, the result would be a
truncated integer zero.</P>






<A Name="idx147"></a><A NAMe="idx148"></a><h5>2.3.4.2
B
itwise operations</h5>


<p>Besides the normal numeric operations (addition, subtraction, and so
on), Python supports most of the numeric expressions available in the
C language. For instance, here it's at work performing bitwise
shift and Boolean operations:</p>



<pre class="monofont">&gt;&gt;&gt;<b> x = 1      </b>  # 0001
&gt;&gt;&gt;<b> x &lt;&lt; 2      </b> # shift left 2 bits: 0100
4
&gt;&gt;&gt;<b> x | 2        </b># bitwise OR: 0011
3
&gt;&gt;&gt;<B> x &amp; 1        </b># bitwise AND: 0001
1</Pre>


<p>In the first expression, a binary 1 (in base 2,
<Tt CLaSS="monofont">0001</tT>) is shifted left two slots to create a binary
4 (<tT CLAss="monofont">0100</tt>). The last two operations perform a binary
<TT CLass="monofont">or</tT> (<TT Class="monofont">0001</TT> <TT class="monofont">|</tt>
<tt class="monofont">0010 = 0011</tt>), and a binary <tt clAsS="monofont">and</tt>
(<tT cLAsS="monofont">0001</Tt> <Tt CLASs="monofont">&amp;</tt>
<tT CLAss="monofont">0001</tt> <TT CLass="monofont">=</tT>
<TT Class="monofont">0001</tt>). We won't go into much more detail on
bit-twiddling here. It's supported if you need it, but be aware
that it's often not as important in a high-level language such
as Python as it is in a low-level language such as C. As a rule of
thumb, if you find yourself wanting to flip bits in Python, you
should think long and hard about which language you're really
using. In general, there are often better ways to encode information
in Python than bit strings.<font size="1"><sup><a hrEf="#FOOTNOTE-3">[3]</A></sup></FoNT>
</p>


<BLoCkQUOTe><fonT SIZe="1">
<p clASS="footnote">
<Sup><a nAME="FOOTNOTE-3">[3]</A></sup>
Usually. As for every
rule there are exceptions. For instance, if you interface with C
libraries that expect bit strings to be passed in, our preaching
doesn't apply.</p>
</font></blockquote>








<a nAmE="idx149"></a><a nAmE="idx150"></A><h5>2.3.4.3
L
ong integers</H5>


<P>Now for something more exotic: here's a look at long integers
in action. When an integer constant ends with an <tT cLASS="monofont">L</tt>
(or lowercase <tt CLASs="monofont">l</tt>), Python creates a long integer,
which can be arbitrarily big:<a NAME="idx140"></a> <a naME="idx141"></A></P>



<pre class="monofont">&gt;&gt;&gt;<b> 9999999999999999999999999999 + 1</b>
OverflowError: integer literal too large
&gt;&gt;&gt;<b> 9999999999999999999999999999L + 1</b>
10000000000000000000000000000L</pre>


<p>Here, the first expression fails and raises an error, because normal
integers can't accommodate such a large number. On the other
hand, the second works fine, because we tell Python to generate a
long integer object instead.</p>



<p><taBlE borDeR="0" BgCOlOr="black" CELLspacING="0" CellpADDIng="1" wiDTH="90%" Align="center"><tr><td>
<table bgcolor="white" WiDth="100%" bOrDEr="0" CElLsPACIng="0" ceLLPAddinG="6"><TR>
<Td widTH="60" VAlign="top"><img src="FILES/tip_yellow.gif" width="50" heighT="54"></tD>
<td vAlIGn="top">


<P>Long integers are a convenient tool. In fact, you can use them to
count the national debt in pennies, if you are so inclined. But
because Python must do extra work to support their extended
precision, long integer math is usually much slower than normal
integer math. If you need the precision, it's built in for you
to use. But as usual, there's no such thing as a free lunch.</P>

</tD>
</tR></TABle></td></TR></TAble></p><BR>





<H5>2.3.4.4
Complex numbers</H5>


<p>C<a naME="idx142"></A> <A name="idx143"></a> <a name="idx144"></a>omplex numbers are a recent addition to
Python. If you know what they are, you know why they are useful; if
not, consider this section optional reading.<font size="1"><sUp><A hreF="#FOOTNOTE-4">[4]</a></SUp></FOnT>
 Complex numbers are
represented as two floating-point numbersthe
<i>real</I> and <I>imaginary</I>
partsand are coded by adding a <Tt claSS="monofont">j</TT> or
<tt clASS="monofont">J</Tt> <a naME="idx145"></A>suffix to the imaginary part. We can
also write complex numbers with a nonzero real part by adding the two
parts with a <Tt class="monofont">+</tt>. For example, the complex number
with a real part of <tt class="monofont">2</tt> and an imaginary part of
<tt cLaSs="monofont">-3</tt> is written: <Tt CLaSS="monofont">2 + -3j</tT>. Some
examples of complex math at work:</p>


<BLOCkquoTE><FOnt siZE="1">
<P Class="footnote">
<SUP><A name="FOOTNOTE-4">[4]</a></sup>
One of
your authors is quick to point out that he has never had a need for
complex numbers in some 15 years of development work. The other
author isn't so lucky.</p>
</font></blockquOtE>





<pre ClASs="monofont">&gt;&gt;&gt; <B>1j * 1J</B>
(-1+0j)
&gt;&gt;&gt; <b>2 + 1j * 3</B>
(2+3j)
&gt;&gt;&gt; (<b>2+1j)*3</B>
(6+3j)</PRE>


<p>Complex numbers also allow us to extract their parts as attributes,
but since complex math is an advanced tool, check Python's
language reference manual for additional details.</p>






<h5>2.3.4.5
Other numeric tools</h5>


<P>As mentioned above, Python also provides
both<A NAme="idx146"></a> built-in functions and built-in modules
for numeric processing. Here are the built-in <tT CLAss="monofont">math</tt>
module and a few built-in functions at work; we'll meet more
built-ins in <A href="lpython_cnode89.html">Chapter 8</a>.</p>



<pre class="monofont">&gt;&gt;&gt; <b>import math</b>
&gt;&gt;&gt; <b>math.pi</b>
3.14159265359
&gt;&gt;&gt;
&gt;&gt;&gt; <b>abs(-42), 2**4, pow(2, 4)</b>
(42, 16, 16)</pre>


<P>Notice that built-in modules such as <tT claSs="monofont">math</TT> must be
imported and qualified, but built-in functions such as
<tT ClAsS="monofont">abs</TT> are always available without imports. Really,
modules are external components, but built-in functions live in an
implied namespace, which Python searches to find names used in your
program. This namespace corresponds to the module called _
_<Tt claSS="monofont">builtin</TT>__. We talk about name resolution in
<a href="lpython_cnode42.html">Chapter 4</A>; for now, when we say
"module", think "import."</P>



</Font>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode20.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode22.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>