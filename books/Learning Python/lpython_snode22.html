<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="2.4 Strings"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode21.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode23.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT>
<h3>2.4
Strings</h3>


<p>The next major built-in type is the Python
<i>string</I>
<A NAme="idx147"></a>—an
ordered collection of characters, used to store and represent
text-based information. From a functional perspective, strings can be
used to represent just about anything that can be encoded as text:
symbols and words (e.g., your name), contents of text files loaded
into memory, and so on.</p>



<P>You've probably used strings in other languages too;
Python's strings serve the same role as character arrays in
languages such as C, but Python's strings are a higher level
tool. Unlike C, there is no <TT Class="monofont">char</TT> type in Python,
only one-character strings. And strictly speaking, Python strings are
categorized as <I>immutable
sequences—</I>
<a name="idx148"></a>
<a name="idx149"></a>
<a name="idx150"></a>big
words that just mean that they respond to common sequence operations
but can't be changed in place. In fact, strings are
representative of the larger class of objects called sequences;
we'll have more to say about what this means in a moment, but
pay attention to the operations introduced here, because
they'll work the same on types we'll see later.</p>



<p><A href="lpython_snode22.html#1">Table 2.4</a> introduces common string constants and
operations. Strings support expression operations such
as<A nAMe="idx151"></A>
<I>concatenation</i> (combining strings),
<I>slicing</i>
<A NAMe="idx152"></a>
(extracting
sections),<a nAME="idx153"></A>
<i>indexing</i> (fetching by offset), and so on. Python
also provides a set of utility modules for processing strings you
import. For instance, the <tt CLASs="monofont">string</tt> module exports
most of the standard C library's string handling tools, and the
<tT CLAss="monofont">regex</tt> and <tt class="monofont">re</tt> modules add
regular expression matching for strings (all of which are discussed
in <a href="lpython_cnode89.html">Chapter 8</a>).</p>



<A nAme="1"></a><P><tABlE BoRdER="1" CEllspACINg="0" celLPADding="1" WIDTh="100%">
<caption><h5>Table 2.4. Common String Constants and Operations </h5></caption><colGrOup sPaN="2">
<Tr>
<TH>
<fOnT SIZe="2">
<p>Operation</p>
</fONT></Th>
<th>
<fONT Size="2">
<p>Interpretation</P>
</FONt></th>
</tr>
<tr>
<td>
<font size="2">
<pre ClAss="monofont">s1 = <a NaME="idx154"></a>''</PRe></FoNT></TD>
<td>
<foNT SIze="2">
<p>Empty string</p>
</FONT></td>
</tr>
<TR>
<TD>
<font size="2">
<pre class="monofont">s2 = "spam's<a namE="idx155"></a>"</Pre></fOnT></Td>
<TD>
<fOnT SIZe="2">
<p>Double quotes</p>
</fONT></Td>
</tr>
<tR>
<TD>
<Font sIZE="2">
<Pre class="monofont">block = """..."""</pre></font></td>
<td>
<foNt Size="2">
<P>Triple-quoted blocks</p>
</FOnT></Td>
</Tr>
<TR>
<TD>
<font SIZE="2">
<pre cLASS="monofont">s1 + s2, 
s2 * 3</pre></fONT></Td>
<td>
<font size="2">
<p>Concatenate,</p>



<p>repeat</p>
</font></tD>
</tR>
<tr>
<tD>
<fONt SIzE="2">
<pRE CLass="monofont">s2[i], 
s2[i:j], 
len(s2)</pRE></FOnt></td>
<TD>
<FOnt siZE="2">
<P>Index,</P>



<p>slice,</p>



<p>length</p>
</font></td>
</tr>
<tr>
<td>
<font SiZe="2">
<prE cLAsS="monofont">"a %s parrot" % 'dead'</PrE></fONT></Td>
<td>
<fONT Size="2">
<p>String formatting</P>
</FONt></td>
</tR>
<TR>
<Td>
<font size="2">
<pre class="monofont">for x in s2,
'm' in s2</pre></FoNt></td>
<Td>
<FOnT SiZe="2">
<P>Iteration,</P>



<P>membership</P>
</font></TD>
</TR>
</colgROUP>
</tablE></P>



<P>E<A name="idx156"></a>mpty strings
are written as two quotes with nothing in between. Notice that string
constants can be written enclosed in either single or double quotes;
the two forms work the same, but having both allows a quote character
to appear inside a string without escaping it with a backslash (more
on backslashes later). The third line in the table also mentions a
triple-quoted form; when strings are enclosed in three quotes, they
may span any number of lines. Python collects all the triple-quoted
text into a multiline string with embedded newline characters.</p>




<h4>2.4.1
Strings in Action</h4>


<p>Rather than getting into too many details right away, let's
interact with the Python interpreter again to illustrate the
operations in <a href="lpython_snode22.html#1">Table 2.4</a>.</p>




<a namE="idx169"></a><H5>2.4.1.1
Basic operations</h5>


<p>Strings can be concatenated using the <tT cLAsS="monofont">+</Tt> operator,
and repeated using the <Tt CLASs="monofont">*</tt> operator. Formally,
adding two string objects creates a new string object with the
contents of its operands joined; repetition is much like adding a
string to itself a number of times. In both cases, Python lets you
create arbitrarily sized strings; there's no need to predeclare
anything in Python, including the sizes of data structures.<fONT Size="1"><sUP><A Href="#FOOTNOTE-5">[5]</a></SUP></Font>

Python also provides a <tt class="monofont">len</tt>
<a name="idx157"></a> <a nAmE="idx158"></a> built-in function that returns the
length of strings (and other objects with a length):</p>


<bLoCKqUOtE><fONT Size="1">
<p CLASs="footnote">
<sup><A NAMe="FOOTNOTE-5">[5]</a></suP>
Unlike C character arrays, you don't need to allocate or
manage storage arrays when using Python strings. Simply create string
objects as needed, and let Python manage the underlying memory space.
Internally, Python reclaims unused objects' memory space
automatically, using a reference-count <I>garbage
collection</I> strategy. Each object keeps track of the number
of names, data-structures, etc. that reference it; when the count
reaches zero, Python frees the object's space. This scheme
means Python doesn't have to stop and scan all of memory to
find unused space to free; it also means that objects that reference
themselves might not be collected automatically.</P>
</font></blockquote>





<pre claSs="monofont">%<B> python</b>
&gt;&gt;&gt; <b>len('abc')         </b># length: number items 
3
&gt;&gt;&gt; <B>'abc' + 'def'      </b># concatenation: a new string
'abcdef'
&gt;&gt;&gt;<B> 'Ni!' * 4      </B>    # like "Ni!" + "Ni!" + ...
'Ni!Ni!Ni!Ni!'</pRE>


<p>Notice that operator overloading is at work here already: we're
using the same operators that were called addition and multiplication
when we looked at numbers. Python is smart enough to do the correct
operation, because it knows the types of objects being added and
multiplied. But be careful; Python doesn't allow you to mix
numbers and strings in <Tt CLASs="monofont">+</tt> and <tT CLAss="monofont">*</tt>
expressions: <TT CLass="monofont">'abc'</tT> <TT Class="monofont">+</tt>
<tt class="monofont">9</tt> raises an error, instead of automatically
<a name="idx159"></A>converting
<tT claSs="monofont">9</TT> to a string. As shown in the last line in <a href="lpython_snode22.html#1">Table 2.4</a>, you can also
<I>iterate</I>
<A Name="idx160"></a>
over strings in loops using <TT CLass="monofont">for</tT> statements and
test membership with the <TT Class="monofont">in</TT> expression operator:</P>



<Pre class="monofont">&gt;&gt;&gt; <b>myjob = "hacker"</b>
&gt;&gt;&gt; <b>for c in myjob: print c,</b>       # step though items
...
h a c k e r
&gt;&gt;&gt; <b>"k" in myjob  </b>                 # 1 means true
1</pre>


<p>But since you need to know something about statements and the meaning
of truth in Python to really understand <tt cLaSs="monofont">for</tt> and
<Tt CLaSS="monofont">in</tT>, let's defer details on these examples
until later.</p>






<H5>2.4.1.2
Indexing and slicing</H5>


<P>Because<A name="idx161"></A>
<A NAme="idx162"></a>
<a NAME="idx163"></a>
<a naME="idx164"></A> strings are defined
as an ordered collection of characters, we can access their
components by position. In Python, characters in a string are fetched
by indexing—providing the numeric offset of the desired
component in square brackets after the string. As in C, Python
offsets start at zero and end at one less than the length of the
string. Unlike C, Python also lets you fetch items from sequences
such as strings using negative offsets. Technically, negative offsets
are added to the length of a string to derive a positive offset. But
you can also think of negative offsets as counting backwards from the
end (or right, if you prefer).</P>



<pre class="monofont">&gt;&gt;&gt;<b> S = 'spam'</b>
&gt;&gt;&gt;<b> S[0], S[-2]</b>               # indexing from front or end
('s', 'a')
&gt;&gt;&gt;<b> S[1:3], S[1:], S[:-1]</b>     # slicing: extract section<a name="idx165"></a>
<A nAme="idx166"></a>
('pa', 'pam', 'spa')</PrE>


<P>In the first line, we define a four-character string and assign it
the name S. We then index it two ways: <tT ClAsS="monofont">S[0]</TT>
fetches the item at offset
from the left (the one-character string <Tt claSS="monofont">'s'</TT>), and
<tt clASS="monofont">S[-2]</Tt> gets the item at offset 2 from the end (or
equivalently, at offset (4 + -2) from the front). Offsets and slices
map to cells as shown in <a href="lpython_snode22.html#7">Figure 2.1</A>.</P>



<center>
<h5>
<a name="7"></a>Figure 2.1. Using offsets and slices</h5>

<img borDeR="0" widTh="503" HEiGHt="157" src="FILES/lpy_0201.gif" ALT="figs/lpy_0201.gif"></centER>


<P>The last line in the example above is our first look at slicing. When
we index a sequence object such as a string on a pair of offsets,
Python returns a new object containing the contiguous section
identified by the offsets pair. The left offset is taken to be the
lower bound, and the right is the upper bound; Python fetches all
items from the lower bound, up to but not including the upper bound,
and returns a new object containing the fetched items.</P>



<p>For instance, <tt cLASS="monofont">S[1:3]</tt> extracts items at offsets 1
and 2, <tt CLASs="monofont">S[1:]</tt> gets all items past the first (the
upper bound defaults to the length of the string), and
<tt class="monofont">S[:-1]</tt> gets all but the last item (the lower bound
defaults to zero). This may sound confusing on first glance, but
indexing and slicing are simple and powerful to use, once you get the
knack. Here's a summary of the details for reference; remember,
if you're unsure about what a slice means, try it out
interactively.</p>



<p><i>Indexing
</i>
<a namE="idx167"></a>
<A namE="idx168"></a>(<TT cLAsS="monofont">S[i]</tT>):</P>



<UL>
<li><p>	Fetches components at offsets (the first item is at offset zero)</p>
</LI>
<LI><p>Negative indexes mean to count from the end (added to the positive
length)</p>
</li>
<LI><P><Tt claSS="monofont">	S[0]</TT> fetches the first item</p>
</li>
<li><p><tt class="monofont"> S[-2]</tt> fetches the second from the end (it's
the same as <tt claSs="monofont">S[len(S) - 2]</Tt>)</p>
</lI>
</uL>
<P><i>Slicing</I>
<A nAmE="idx169"></A>
<A Name="idx170"></a>
(<TT CLass="monofont">S[i:j]</tT>):</P>



<UL>
<li><p>	Extracts contiguous sections of a sequence</p>
</LI>
<LI><p>	Slice boundaries default to zero and the sequence length, if omitted</p>
</li>
<li><p><tt class="monofont"> S[1:3]</tt> fetches from offsets 1 up to, but not
including, 3</p>
</li>
<lI><p><Tt clAsS="monofont"> S[1:]</Tt> fetches from offsets 1 through the end
(length)</P>
</Li>
<Li><P><TT Class="monofont"> S[:-1]</TT> fetches from offsets
up to, but not including, the last item</P>
</Li>
</ul>
<p>Later in this chapter, we'll see that the syntax used to index
by offset (the square brackets) is also used to index dictionaries by
<I>key</I>; the operations look the same, but have
different interpretations.</P>



<P><tablE CELlspacing="0" width="90%" border="1"><tR><tD>
<cenTeR><H2>
Why You Will Care: Slices</h2></CEnTeR>


<P>Throughout this part of the book, we include sidebars such as this to
give you a peek at how some of the language features being introduced
are typically used in real programs. Since we can't show much
of real use until you've seen most of the Python picture, these
sidebars necessarily contain many references to topics we
haven't introduced yet; at most, you should consider them
previews of ways you may find these abstract language concepts useful
for common programming tasks.</P>



<P>For instance, you'll see later that the argument words listed
on a command line used to launch a Python program are made available
in the <tt clASS="monofont">argv</Tt>
<a naME="idx171"></A> <A name="idx172"></A> attribute of the built-in
<TT Class="monofont">sys</tt> module:</p>


<pre class="monofont">% <b>cat echo.py</b>
import sys
print sys.argv

% <b>python echo.py -a -b -c</b>
['echo.py', '-a', '-b', '-c']</pRe>

<P>Usually, we're only interested in inspecting the arguments past
the program name. This leads to a very typical application of slices:
a single slice expression can strip off all but the first item of the
list. Here, <tt cLaSS="monofont">sys.argv[1:]</tT> returns the desired list,
<Tt ClASS="monofont">['-a',</Tt> <tt cLASS="monofont">'-b',</tt>
<tt CLASs="monofont">'-c']</tt>. You can then process without having to
accommodate the program name at the front.</p>



<P>Slices are also often used to clean up lines read from input files;
if you know that a line will have an end-of-line character at the end
(a <TT Class="monofont">'\n'</tt> newline marker), you can get rid of it
with a single expression such as <tt class="monofont">line[:-1]</tt>, which
extracts all but the last character in the line (the lower limit
defaults to 0). In both cases, slices do the job of logic that must
be explicit in a lower-level language.</p>



</td></tr></TaBle></p>






<A nAMe="idx186"></A><A nAmE="idx187"></A><H5>2.4.1.3
C
hanging and formatting</H5>


<p>Remember those big words—immutable sequence? The immutable part
means that you can't change a string in-place (e.g., by
assigning to an index). So how do we modify text information in
Python? To change a string, we just need to build and assign a new
one using tools such as concatenation and slicing:</p>



<prE CLAss="monofont">&gt;&gt;&gt;<b> S = 'spam' </b>
&gt;&gt;&gt;<B> S[0] = "x" </B>
<I> Raises an error! </I></pre>


<pRE CLass="monofont">&gt;&gt;&gt;<b> S = S + 'Spam!' </b>     # to change a string, make a new one
&gt;&gt;&gt;<b> S</b>
'spamSpam!'
&gt;&gt;&gt; <b>S = S[:4] + 'Burger' + S[-1]</b>
&gt;&gt;&gt; <b>S</b>
'spamBurger!'
&gt;&gt;&gt;<b> 'That is %d %s bird!' % (1, 'dead') </b>   # like C sprintf
That is 1 dead bird!<a name="idx173"></a>
<a NaMe="idx174"></a></pRe>


<P>Python also overloads the <Tt CLaSs="monofont">%</TT> operator to work on
strings (it means remainder-of-division for numbers). When applied to
strings, it serves the same role as C's
<TT clasS="monofont">sprintf</TT> function: it provides a simple way to
format strings. To make it go, simply provide a format string on the
left (with embedded <A name="idx175"></A> <A NAme="idx176"></a>conversion
targets—e.g., <tT CLAss="monofont">%d</tt>), along with an object (or
objects) on the right that you want Python to insert into the string
on the left, at the conversion targets. For instance, in the last
line above, the integer 1 is plugged into the string where the
<tt class="monofont">%d</tt> appears, and the string
<tt class="monofont">'dead'</Tt> is inserted at the <Tt clAsS="monofont">%s</Tt>.
String formatting is important enough to warrant a few more examples:</P>



<PrE cLASS="monofont">&gt;&gt;&gt; <b>exclamation = "Ni"</b>
&gt;&gt;&gt; <b>"The knights who say %s!" % exclamation</b>
'The knights who say Ni!'
&gt;&gt;&gt; <B>"%d %s %d you" % (1, 'spam', 4)</B>
'1 spam 4 you'
&gt;&gt;&gt; <B>"%s -- %s -- %s" % (42, 3.14159, [1, 2, 3])</B>
'42 -- 3.14159 -- [1, 2, 3]'</pre>


<p>In the first example, plug the string "<TT CLass="monofont">Ni"</tT> into
the target on the left, replacing the <TT Class="monofont">%s</tt> marker.
In the second, insert three values into the target string; when there
is more than one value being inserted, you need to group the values
on the right in parentheses (which really means they are put in a
<i>tuple</i>, as we'll see shortly).</p>



<p>Python's string <tt class="monofont">%</tt> operator always returns a
new string as its result, which you can print or not. It also
supports all the usual C <tT cLass="monofont">printf</Tt> format codes.
<A href="lpython_snode22.html#10">Table 2.5</a> lists the more common string-format
target codes. One special case worth noting is that
<Tt CLASs="monofont">%s</tt> converts <i>any</I> object to its
string representation, so it's often the only conversion code
you need to remember. For example, the last line in the previous
example converts integer, floating point, and list objects to strings
using <TT Class="monofont">%s</TT> (lists are up next). Formatting also
allows for a dictionary of values on the right, but since we
haven't told you what dictionaries are yet, we'll finesse
this extension here.</P>



<A name="10"></A><P><TAble border="1" cellspacing="0" CeLlpaDdINg="1" WIdTh="100%">
<CAPTion><h5>Table 2.5. String Formatting Codes</H5></CAPtion><COLGroup SPAN="2">
<tr>
<td>
<font size="2">
<p>%</p>
</font></td>
<Td>
<Font SiZE="2"><p>String (or any object's print format)</P>
</FoNt></TD>
<TD>
<font SIZE="2">
<p>%X</p>
</foNT></TD>
<td>
<foNT SIze="2"><p>Hex integer (uppercase)</p>
</font></td>
</tr>
<tr>
<td>
<font SiZe="2">
<p>%c</p>
</FoNT></tD>
<Td>
<FoNT SIze="2"><p>Character</p>
</FONT></td>
<td>
<FONT size="2">
<P>%e</P>
</FOnt></td>
<td>
<font size="2"><p>Floating-point format 1<font sIzE="1"><sup><A hREf="#FOOTNOTE-6">[6]</A></SuP></fONT>
</P>
</font></TD>
</TR>
<tr>
<td>
<FONT size="2">
<P>%d</P>
</FOnt></td>
<td>
<font size="2"><p>Decimal (int)</p>
</font></Td>
<Td>
<foNt SIzE="2">
<P>%E</p>
</FoNT></TD>
<td>
<foNT SIze="2"><p>Floating-point format 2</p>
</FONT></td>
</tr>
<TR>
<TD>
<font size="2">
<p>%i</p>
</font></td>
<td>
<foNt Size="2"><P>Integer</p>
</FOnT></Td>
<Td>
<FONT size="2">
<P>%f</P>
</FOnt></td>
<TD>
<FOnt siZE="2"><P>Floating-point format 3</P>
</font></td>
</tr>
<tr>
<td>
<font size="2">
<P>%u</p>
</Font></Td>
<TD>
<fONt SiZE="2"><P>Unsigned (int)</P>
</font></TD>
<TD>
<font SIZE="2">
<p>%g</p>
</foNT></TD>
<td>
<font size="2"><p>Floating-point format 4</p>
</font></td>
</tr>
<Tr>
<Td>
<foNt SIzE="2">
<P>%o</p>
</FoNT></TD>
<td>
<foNT SIze="2"><p>Octal integer</p>
</FONT></td>
<td>
<FONT size="2">
<p>%G</p>
</font></td>
<td>
<font siZe="2"><P>Floating-point format 5</p>
</foNt></TD>
</tR>
<Tr>
<Td>
<FONT size="2">
<P>%x</P>
</FOnt></td>
<TD>
<FOnt siZE="2"><P>Hex integer</P>
</font></td>
<td>
<font size="2">
<p>%%</p>
</foNt></Td>
<td>
<FoNT sIZe="2"><P>Literal %</p>
</FONT></td>
</tr>
</COLGroup>
</TABLe></p>


<blOCKQuote><font size="1">
<p class="footnote">
<suP><a Name="FOOTNOTE-6">[6]</A></sUP>
 The floating-point codes
produce alternative representations for floating-point numbers. See
<tT ClAsS="monofont">printf</TT> documentation for details; better yet, try
these formats out in the Python interactive interpreter to see how
the alternative floating-point formats look (e.g., <Tt claSS="monofont">"%e %f
%g" % (1.1, 2.2, 3.3)</TT>).</p>
</fonT></BLOckquOTE>








<A name="idx193"></a><h5>2.4.1.4
Common string tools</h5>


<p>As previously mentioned, Python provides utility modules for
processing strings. The
<tt class="monofont">string</tt>
<a naMe="idx177"></A> module is perhaps the most common and
useful. It includes tools for converting case, searching strings for
substrings, converting strings to numbers, and much more (the Python
library reference manual has an exhaustive list of string tools).</p>



<prE cLAsS="monofont">&gt;&gt;&gt;<B> import string</b>              # standard utilities module
&gt;&gt;&gt;<B> S = "spammify"</b>
&gt;&gt;&gt;<B> string.upper(S)</B>            # convert to uppercase
'SPAMMIFY'
&gt;&gt;&gt; <B>string.find(S, "mm")</B>       # return index of substring
3
&gt;&gt;&gt;<b> string.atoi("42"), `42`</b>    # convert from/to string
(42, '42')
&gt;&gt;&gt;<b> string.join(string.split(S, "mm"), "XX")</b>
'spaXXify'</PRE>


<P>The last example is more complex, and we'll defer a better
description until later in the book. But the short story is that the
<tt clASS="monofont">split</Tt> function chops up a string into a list of
substrings around a passed-in delimiter or whitespace;
<tt cLASS="monofont">join</tt> puts them back together, with a passed-in
delimiter or space between each. This may seem like a roundabout way
to replace <tt class="monofont">"mm"</tt> with <tt class="monofont">"XX"</tt>, but
it's one way to perform arbitrary global substring
replacements. We study these, and more advanced text processing
tools, later in the book.</P>



<p>Incidentally, notice the second-to-last line in the previous example:
the <Tt clAsS="monofont">atoi</Tt> function converts a string to a number,
and backquotes around any object convert that object to its string
representation (here, <TT cLaSS="monofont">`42`</TT> converts a number to a
string). Remember that you can't mix strings and numbers types
around operators such as +, but you can manually convert before that
operation if needed:</p>



<pre CLASs="monofont">&gt;&gt;&gt; <b>"spam" + 42 </b>
<i> Raises an error</I></PRE>


<pre cLASS="monofont">&gt;&gt;&gt; <b>"spam" + `42`</b>
'spam42'
&gt;&gt;&gt; <b>string.atoi("42") + 1</b>
43</pre>


<p>Later, we'll also meet a built-in function called
<tt class="monofont">eval</tt> that converts a string to
<i>any</i> kind of object;
<tT cLass="monofont">string.atoi</Tt> and its relatives convert only to
numbers, but this restriction means they are usually faster.
<A NaME="idx178"></a></P>






<a NAME="idx196"></a><h5>2.4.1.5
String constant variations</h5>


<p>Finally, we'd like to show you a few of the different ways to
write string constants; all produce the same kind of object (a
string), so the special syntax here is just for our convenience.
Earlier, we mentioned that strings can be enclosed in single or
double quotes, which allows embedded quotes of the opposite flavor.
Here's an example:</P>



<PRE clasS="monofont">&gt;&gt;&gt; <B>mixed = "Guido's"    </B>    # single in double
&gt;&gt;&gt; <B>mixed</b>
"Guido's"
&gt;&gt;&gt; <b>mixed = 'Guido"s'  </b>      # double in single
&gt;&gt;&gt; <b>mixed</B>
'Guido"s'
&gt;&gt;&gt; <B>mixed = 'Guido\'s'   </B>    # backslash escape
&gt;&gt;&gt; <B>mixed</b>
"Guido's"</pre>


<p>Notice the last two lines: you can also
<i>escape</i>
<a name="idx179"></a> a quote (to tell Python it's not
really the end of the string) by preceding it with a backslash. In
fact, you can escape all kinds of special characters inside strings,
as listed in <a href="lpython_snode22.html#13">Table 2.6</a>; Python replaces the escape
code characters with the special character they represent. In
general, the rules for escape codes in Python strings are just like
those in C strings.<fOnT sizE="1"><sUP><a HReF="#FOOTNOTE-7">[7]</a></SUP></Font>
 Also like C, Python concatenates adjacent
string constants for us:</p>


<BLOCkquoTE><FOnt siZE="1">
<P Class="footnote">
<sup><a name="FOOTNOTE-7">[7]</a></sup>
But note that you normally
don't need to terminate Python strings with a
<tt clAsS="monofont">\0</tt> null character as you would in C. Since Python
keeps track of a string's length internally, there's
usually no need to manage terminators in your programs. In fact,
Python strings can contain the null byte <tT cLAsS="monofont">\0</Tt>,
unlike typical usage in C. For instance, we'll see in a moment
that file data is represented as strings in Python programs; binary
data read from or written to files can contain nulls because strings
can too.</P>
</fONT></BlockQUOTe>





<pre CLASs="monofont">&gt;&gt;&gt; <b>split = "This" "is" "concatenated"</b>
&gt;&gt;&gt; <b>split</B>
'Thisisconcatenated'</PRE>


<p>And last but not least, here's Python's triple-quoted
string constant form in action: Python collects all the lines in such
a quoted block and concatenates them in a single multiline string,
putting an end-of-line character between each line. The end-of-line
prints as a <tt class="monofont">"\012</tt>" here (remember, this is an
octal integer); you can also call it <tt class="monofont">"\n"</tt> as in C.
For instance, a line of text with an embedded tab and a line-feed at
the end might be written in a program as
<tT cLass="monofont">python\tstuff\n</Tt> (see <A href="lpython_snode22.html#13">Table 2.6</a>).</P>



<pRE CLass="monofont">&gt;&gt;&gt; <b>big = """This is</B>
... <B>a multi-line block</B>
... <B>of text; Python puts</b>
... <b>an end-of-line marker</b>
... <b>after each line."""</B>
&gt;&gt;&gt;
&gt;&gt;&gt; <B>big</B>
'This is\012a multi-line block\012of text; Python puts\012an end-of-line 
marker\012after each line.'</Pre>


<p>Python also has a special string constant form
called<a NAME="idx180"></a>
<a name="idx181"></a>
<i>raw strings</i>, which don't treat backslashes
as potential escape codes (see <a href="lpython_snode22.html#13">Table 2.6</a>). For
instance, strings <tt claSs="monofont">r'a\b\c'</Tt> and
<tt ClASs="monofont">R"a\b\c"</TT> retain their backslashes as real
(literal) backslash characters. Since raw strings are mostly used for
writing regular expressions, we'll defer further details until
we explore regular expressions in <a href="lpython_cnode89.html">Chapter 8</A>.</P>



<a namE="13"></A><P><Table BORDer="1" ceLLSPacing="0" cellpadding="1" widtH="100%">
<cAptiOn><H5>Table 2.6. String Backslash Characters </H5></cAPtIoN><COLgrouP SPAn="4">
<tr>
<tD>
<FONt sizE="2">
<PRE class="monofont">\newline</pre></font></td>
<td>
<font SiZe="2">
<p>Ignored (a continuation)</p>
</FoNT></tD>
<Td>
<FoNT SIze="2">
<prE CLAss="monofont">\n</prE></FONt></td>
<tD>
<FONt size="2">
<p>Newline (linefeed)</p>
</font></td>
</tr>
<tr>
<td>
<fOnT sizE="2">
<pRE cLAsS="monofont">\\</pRE></FOnt></td>
<TD>
<FOnt siZE="2">
<P>Backslash (keeps one \)</P>
</font></TD>
<TD>
<font size="2">
<pre class="monofont">\v</pre></fOnT></td>
<tD>
<fONt SIzE="2">
<p>Vertical tab</P>
</FONt></td>
</tR>
<TR>
<Td>
<fonT SIZe="2">
<pre CLASs="monofont">\'</pre></font></td>
<td>
<font size="2">
<P>Single quote (keeps ')</p>
</Font></Td>
<TD>
<fONt SiZE="2">
<PRe claSS="monofont">\t</PRe></fonT></TD>
<Td>
<fonT SIZe="2">
<p>Horizontal tab</p>
</font></td>
</tr>
<tr>
<td>
<font sIzE="2">
<pre ClASs="monofont">\"</PRe></FoNT></TD>
<td>
<foNT SIze="2">
<p>Double quote (keeps ")</p>
</FONT></td>
<td>
<FONT size="2">
<pre class="monofont">\r</pre></font></tD>
<tD>
<fonT sIZe="2">
<P>Carriage return</P>
</fOnT></TD>
</Tr>
<tr>
<tD>
<FONt sizE="2">
<PRE clasS="monofont">\a</PRE></font></td>
<td>
<font size="2">
<p>Bell</p>
</foNt></Td>
<td>
<FoNT sIZe="2">
<PrE CLAss="monofont">\f</prE></FONt></td>
<tD>
<FONt sizE="2">
<P>Formfeed</P>
</Font></td>
</tr>
<tr>
<td>
<font size="2">
<pRe ClasS="monofont">\b</pRE></fONt></Td>
<TD>
<FOnt siZE="2">
<P>Backspace</P>
</font></TD>
<TD>
<font SIZE="2">
<pre class="monofont">\0XX</pre></font></td>
<td>
<fOnT sizE="2">
<p>Octal value XX</P>
</FoNT></tD>
</tR>
<TR>
<Td>
<fonT SIZe="2">
<pre CLASs="monofont">\e</pre></FONT></td>
<td>
<font size="2">
<p>Escape (usually)</p>
</font></td>
<Td>
<Font SiZE="2">
<pRE cLaSS="monofont">\xXX</PRe></fonT></TD>
<Td>
<fonT SIZe="2">
<p>Hex value XX</p>
</fONT></Td>
</tr>
<tr>
<td>
<font size="2">
<pre clAsS="monofont">\000</pre></FoNT></tD>
<Td>
<FoNT SIze="2">
<p>Null (doesn't end string)</p>
</FONT></td>
<td>
<FONT size="2">
<PRE Class="monofont">\other</pre></font></td>
<td>
<font sIzE="2">
<p>Any other char (retained)</p>
</fOnT></Td>
</TR>
</cOlGROUp>
</tabLE></P>








<H4>2.4.2
Generic Type Concepts</h4>


<p>Now that we've seen our first composite data type, let's
pause a minute to define a few general type concepts that apply to
most of our types from here on. One of the nice things about Python
is that a few general ideas usually apply to lots of situations. In
regard to built-in types, it turns out that operations work the same
for all types in a category, so we only need to define most ideas
once. We've only seen numbers and strings so far, but they are
representative of two of the three major type categories in Python,
so you already know more about other types than you think.</p>




<h5>2.4.2.1
Types share operation sets by categories</H5>


<P>When <A Name="idx182"></a>we introduced strings, we mentioned that
they are immutable sequences: they can't be changed in place
(the immutable part), and are ordered collections accessed by offsets
(the sequence bit). Now, it so happens that all the sequences seen in
this chapter respond to the same sequence operations we previously
saw at work on strings—concatenation, indexing, iteration, and
so on. In fact, there are three type (and operation) categories in
Python:</P>



<UL>
<Li><p>	Numbers support addition, multiplication, etc.</p>
</li>
<li><p>	Sequences support indexing, slicing, concatenation, etc.</p>
</li>
<li><p>	Mappings support indexing by key, etc.</p>
</li>
</ul>
<p>We haven't seen mappings yet (we'll get to dictionaries
in a few pages), but other types are going to be mostly more of the
same. For example, for any sequence objects <Tt ClasS="monofont">X</tT> and
<Tt CLaSs="monofont">Y</TT>:</P>



<Ul>
<li><p><TT CLass="monofont"> X + Y</tT> makes a new sequence object with the
contents of both operands.</P>
</LI>
<li><p><tT CLAss="monofont"> X * N</tt> makes a new sequence object with
<tt class="monofont">N</tt> copies of the sequence operand
<tt class="monofont">X.</Tt></P>
</li>
</uL>
<p>In other words, these operations work the same on any kind of
sequence. The only difference is that you get back a new result
object that is the same type as the operands <TT cLAsS="monofont">X</tT> and
<TT Class="monofont">Y</TT> (if you concatenate strings, you get back a new
string, not a list). Indexing, slicing, and other sequence operations
work the same on all sequences too; the type of the objects being
processed tells Python which flavor to perform.</P>






<A name="idx201"></A><A NAme="idx202"></a><h5>2.4.2.2
Mutable
 types can be changed in place</H5>


<P>The immutable classification might sound abstract, but it's an
important constraint to know and tends to trip up new users. If we
say an object type is immutable, you shouldn't change it
without making a copy; Python raises an error if you do. In general,
immutable types give us some degree of integrity, by guaranteeing
that an object won't be changed by another part of a program.
We'll see why this matters when we study shared object
references later in this chapter.</P>



</Font>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode21.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode23.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>