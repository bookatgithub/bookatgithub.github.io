<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="2.5 Lists"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode22.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode24.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT>
<h3>2.5
Lists</h3>


<p>Our next stop on the built-in
<a NAME="idx183"></a>
<a naME="idx184"></A>object tour is the Python
<I>list</i>. Lists are Python's most flexible
ordered collection object type. Unlike strings, lists can contain any
sort of object: numbers, strings, even other lists. Python lists do
the work of most of the collection data structures you might have to
implement manually in lower-level languages such as C. In terms of
some of their main properties, Python lists are:</p>



<dl>
<DT>
<I><Font color="#990000">Ordered collections of arbitrary objects</font></i></dt>
<dd>
<p>From a functional view, lists are just a place to collect other
objects, so you can treat them as a group. Lists also define a
left-to-right positional ordering of the items in the list.</p>
</dD>
<dT>
<i><foNt COlOR="#990000">Accessed by offset</fOnT></I></DT>
<dd>
<p>Just as with strings, you can fetch a component object out of a list
by indexing the list on the object's offset. Since lists are
ordered, you can also do such tasks as slicing and concatenation.</p>
</DD>
<DT>
<i><fonT COLor="#990000">Variable length, heterogeneous, arbitrarily nestable</foNT></I></Dt>
<dd>
<p>Unlike strings, lists can grow and shrink in place (they're
variable length), and may contain any sort of object, not just
one-character strings (they're heterogeneous). Because lists
can contain other complex objects, lists also support arbitrary
nesting; you can create lists of lists of lists, and so on.</p>
</dd>
<dt>
<i><font color="#990000">Of the category mutable sequence</fOnT></i></dt>
<Dd>
<P>In terms of our type category qualifiers, lists can be both changed
in place (they're mutable) and respond to all the sequence
operations we saw in action on strings in the last section. In fact,
sequence operations work the same on lists, so we won't have
much to say about them here. On the other hand, because lists are
mutable, they also support other operations strings don't, such
as deletion, index assignment, and methods.</P>
</dD>
<Dt>
<I><fONT Color="#990000">Arrays of object references</FONT></i></dt>
<dD>
<P>Technically, Python lists contain zero or more references to other
objects. If you've used a language such as C, lists might
remind you of arrays of pointers. Fetching an item from a Python list
is about as fast as indexing a C array; in fact, lists really are C
arrays inside the Python interpreter. Moreover, references are
something like pointers (addresses) in a language such as C, except
that you never process a reference by itself; Python always follows a
reference to an object whenever the reference is used, so your
program only deals with objects. Whenever you stuff an object into a
data structure or variable name, Python always stores a reference to
the object, not a copy of it (unless you request a copy explicitly).</P>
</Dd>
</dl>


<p><A href="lpython_snode23.html#1">Table 2.7</a> summarizes common list object operations.</p>



<a name="1"></a><p><table bordeR="1" cEllsPaCInG="0" CeLlPADDing="1" wIDTH="100%">
<captION><H5>Table 2.7. Common List Constants and Operations </h5></capTION><colgroup span="2">
<tr>
<th>
<font SiZe="2">
<p>Operation</p>
</FoNT></tH>
<Th>
<FoNT SIze="2">
<p>Interpretation</p>
</FONT></th>
</tr>
<TR>
<TD>
<font SIZE="2">
<pre class="monofont">L1 = []<a name="idx185"></a>
<a name="idx186"></a></PrE></fonT></tD>
<Td>
<FOnT sIZE="2">
<P>An empty list</p>
</fonT></TD>
</Tr>
<tr>
<tD>
<FONt sizE="2">
<PRE class="monofont">L2 = [0, 1, 2, 3]</pre></font></td>
<td>
<font SiZe="2">
<p>Four items: indexes 0.3</p>
</FoNT></tD>
</Tr>
<Tr>
<TD>
<FOnt siZE="2">
<PRe claSS="monofont">L3 = ['abc', ['def', 'ghi']]</PRe></fonT></TD>
<Td>
<font size="2">
<p>Nested sublists</p>
</font></td>
</tr>
<tR>
<tD>
<fonT sIZe="2">
<PRe ClASS="monofont">L2[i], L3[i][j]
L2[i:j], 
len(L2)</Pre></foNT></TD>
<td>
<foNT SIze="2">
<p>Index,</p>



<P>slice,</P>



<P>length</P>
</font></td>
</tr>
<tr>
<td>
<font size="2">
<PrE claSs="monofont">L1 + L2, 
L2 * 3</PRe></FOnT></tD>
<TD>
<Font sIZE="2">
<P>Concatenate,</p>



<p>repeat</p>
</fONT></Td>
</tr>
<tR>
<TD>
<Font size="2">
<pre class="monofont">for x in L2, 
3 in L2</pre></foNt></Td>
<td>
<FoNT sIZe="2">
<P>Iteration,</p>



<P>membership</P>
</FOnt></td>
</TR>
<TR>
<td>
<foNT SIze="2">
<prE CLAss="monofont">L2.append(4), 
L2.sort(), 
L2.index(1), 
L2.reverse()</pre></font></td>
<td>
<font sizE="2">
<p>Methods: grow,</P>



<p>sort,</p>



<p>search,</P>



<p>reverse, etc.</P>
</FoNT></tD>
</tR>
<TR>
<Td>
<fonT SIZe="2">
<pre CLASs="monofont">del L2[k], 
L2[i:j] = []</pre></FONT></td>
<td>
<font size="2">
<p>Shrinking<a name="idx187"></a></p>
</FoNt></td>
</Tr>
<TR>
<tD>
<FoNt SIZE="2">
<pre cLASS="monofont">L2[i] = 1, 
L2[i:j] = [4,5,6]</pre></fONT></Td>
<td>
<fONT Size="2">
<p>Index assignment,</p>



<p>slice assignment</p>
</font></td>
</tr>
<tr>
<td>
<fOnT sizE="2">
<pRE cLAsS="monofont">range(4), xrange(0, 4)</pRE></FOnt></td>
<TD>
<FOnt siZE="2">
<P>Make lists/tuples of integers</P>
</font></TD>
</TR>
</colgroup>
</table></p>



<p>Lists are written as a series of objects (really, expressions that
return objects) in square brackets, separated by commas. Nested lists
are coded as a nested square-bracketed series, and the empty list is
just a square-bracket set with nothing inside.<font sIzE="1"><sup><A hREf="#FOOTNOTE-8">[8]</A></SuP></fONT>
</P>


<blocKQUOte><foNT SIze="1">
<p cLASS="footnote">
<sup><a name="FOOTNOTE-8">[8]</a></sup>
But we
should note that in practice, you won't see many lists written
out like this in list-processing programs. It's more common to
see code that processes lists constructed dynamically (at runtime).
In fact, although constant syntax is important to master, most data
structures in Python are built by running program code at
runtime.</p>
</font></bloCkQuotE>





<p>Most of the operations in <A href="lpython_snode23.html#1">Table 2.7</a> should look
familiar, since they are the same sequence operations we put to work
on strings earlier—indexing, concatenation, iteration, and so
on. The last few table entries are new; lists also respond to
<I>method calls</i> (which provide utilities such as
sorting, reversing, adding items on the end, etc.), as well as
<I>in-place change</I> operations (deleting items,
assignment to indexes and slices, and so forth). Remember, lists get
these last two operation sets because they are a mutable object type.</P>




<H4>2.5.1
Lists in Action</h4>


<p>Perhaps the best way to understand lists is to see them at work.
Let's once again turn to some simple interpreter interactions
to illustrate the operations in <a href="lpython_snode23.html#1">Table 2.7</A>.</p>




<a naME="idx209"></A><H5>2.5.1.1
Basic operations</h5>


<p>Lists respond to the <tt CLASs="monofont">+</tt> and <tt class="monofont">*</tt>
operators as with strings; they mean
<i>concatenation</i> and
<i>repetition</i> here too, except that the result is a
new list, not a string. And as Forrest Gump was quick to say,
"that's all we have to say about that"; grouping
types into categories is intellectually frugal (and makes life easy
for authors like us).</p>



<pre ClAss="monofont">%<b> python</B>
&gt;&gt;&gt;<b> len([1, 2, 3])                   </B> # length
3
&gt;&gt;&gt;<B> [1, 2, 3] + [4, 5, 6]</b>             # concatenation
[1, 2, 3, 4, 5, 6]
&gt;&gt;&gt;<B> ['Ni!'] * 4    </B>                   # repetition
['Ni!', 'Ni!', 'Ni!', 'Ni!']
&gt;&gt;&gt; <b>for x in [1, 2, 3]: print x,</B>      # iteration
<b>...</B>
1 2 3</PRE>


<p>We talk about iteration (as well as <tt cLASS="monofont">range</tt>
built-ins) in <a href="lpython_cnode31.html">Chapter 3</A>. One exception worth
noting here: <tt clASS="monofont">+ </Tt>expects the same sort of sequence
on both sides, otherwise you get a type error when the code runs. For
instance, you can't concatenate a list and a string, unless you
first convert the list to a string using backquotes or
<tt class="monofont">%</tt> formatting (we met these in the last section).
You could also convert the string to a list; the
<tt class="monofont">list</tt> built-in function does the trick:</p>



<PrE claSs="monofont">&gt;&gt;&gt; <B>`[1, 2]` + "34"        </B> # same as "[1, 2]" + "34"
'[1, 2]34'
&gt;&gt;&gt; <b>[1, 2] + list("34")   </B>  # same as [1, 2] + ["3", "4"]
[1, 2, '3', '4']</PrE>





<a NAME="idx210"></a><a naME="idx211"></A><A name="idx212"></A><H5>2.5.1.2
In

dexing and slicing</H5>


<P>Because lists are sequences, indexing and slicing work the same here
too, but the result of indexing a list is whatever type of object
lives at the offset you specify, and slicing a list always returns a
new list:</p>



<pre CLASs="monofont">&gt;&gt;&gt;<b> L = ['spam', 'Spam', 'SPAM!']</b>
&gt;&gt;&gt;<b> L[2] </b>                              # offsets start at zero
'SPAM!'
&gt;&gt;&gt;<b> L[-2]</b>                              # negative: count from the right
'Spam'
&gt;&gt;&gt;<b> L[1:] </b>                             # slicing fetches sections
['Spam', 'SPAM!']</pre>





<a name="idx213"></a><h5>2.5.1.3
Changing lists in place</h5>


<P>Finally something new: because lists are mutable, they support
operations that change a list object in-place; that is, the
operations in this section all modify the list object directly,
without forcing you to make a new copy as you had to for strings. But
since Python only deals in object references, the distinction between
in-place changes and new objects can matter; if you change an object
in place, you might impact more than one reference to it at once.
More on that later in this chapter.</p>



<P>When using a list, you can change its contents by assigning to a
particular item (offset), or an entire section (slice):</p>



<prE cLAsS="monofont">&gt;&gt;&gt;<B> L = ['spam', 'Spam', 'SPAM!']</b>
&gt;&gt;&gt;<B> L[1] = 'eggs'         </b>         # index assignment
&gt;&gt;&gt;<B> L</B>
['spam', 'eggs', 'SPAM!']
&gt;&gt;&gt;<B> L[0:2] = ['eat', 'more']     </B>  # slice assignment: delete+insert
&gt;&gt;&gt;<b> L                             </b> # replaces items 0,1
['eat', 'more', 'SPAM!']</prE>


<P>Index assignment works much as it does in C: Python replaces the
object reference at the designated slot with a new one. Slice
assignment is best thought of as two steps: Python first deletes the
slice you specify on the left of the <TT clasS="monofont">=</TT>, and then
inserts (splices) the new items into the list at the place where the
old slice was deleted. In fact, the number of items inserted
doesn't have to match the number of items deleted; for
instance, given a list <Tt claSS="monofont">L</TT> that has the value
<tt class="monofont">[1, 2, 3]</tt>, the assignment <tt class="monofont">L[1:2] = [4,
5]</tt> sets <tt ClAss="monofont">L</tT> to the list <tT ClASs="monofont">[1, 4, 5,
3]</Tt>. Python first deletes the <TT CLass="monofont">2</tT> (a
one-item slice), then inserts items <TT Class="monofont">4</TT> and
<TT clasS="monofont">5</TT> where <Tt class="monofont">2</tt> used to be. Python
list objects also support <i>method</i> calls:</p>



<pre class="monofont">&gt;&gt;&gt;<b> L.append('please')           </B>  # append method call
&gt;&gt;&gt;<b> L</B>
['eat', 'more', 'SPAM!', 'please']
&gt;&gt;&gt;<b> L.sort()                      </b> # sort list items ('S' &lt; 'e')
&gt;&gt;&gt;<b> L</B>
['SPAM!', 'eat', 'more', 'please']<a NAmE="idx188"></A>
<a NaME="idx189"></A></Pre>


<p>Methods are like functions, except that they are associated with a
particular object. The syntax used to call methods is similar too
(they're followed by arguments in parentheses), but you
<i>qualify</I> the method name with the list object to
get to it. Qualification is coded as a period followed by the name of
the method you want; it tells Python to look up the name in the
object's <I>namespace—</I>set of
qualifiable names. Technically, names such as
<Tt claSS="monofont">append</TT> and <tt clASS="monofont">sort</Tt> are called
<i>attributes—</i>names associated with objects.
We'll see lots of objects that export attributes later in the
book.</p>



<p>The list <tt class="monofont">append</tt>
<a name="idx190"></a> method simply tacks a single item
(object reference) to the end of the list. Unlike concatenation,
<Tt ClasS="monofont">append</tT> expects us to pass in a single object, not
a list. The effect of <Tt CLaSs="monofont">L.append(X)</TT> is similar to
<TT clasS="monofont">L+[X]</TT>, but the former changes <Tt claSS="monofont">L</TT>
in place, and the latter makes a new list.<font SIZE="1"><sup><a href="#FOOTNOTE-9">[9]</a></sup></font>
 The
<tt clAsS="monofont">sort</tt>
<a NaME="idx194"></a> method orders a list in-place; by
default, it uses Python standard comparison tests (here, string
comparisons; you can also pass in a comparison function of your own,
but we'll ignore this option here).</P>


<BlOcKQUOte><foNT SIze="1">
<p cLASS="footnote">
<sup><a NAME="FOOTNOTE-9">[9]</a></sup>
Also
unlike <tt class="monofont">+</tt> concatenation, <tt class="monofont">append</Tt>
doesn't have to generate new objects, and so is usually much
faster. On the other hand, you can mimic <Tt clAsS="monofont">append</Tt>
with clever slice assignments: <TT cLaSS="monofont">L[len(L):]=[X]</TT> is
like <tt clASS="monofont">L.append(X)</Tt>, and <tt cLASS="monofont">L[:0]=[X]</tt>
is like appending at the front of a list. Both delete an empty slice
and insert X, changing L in place quickly like
<tt CLASs="monofont">append</tt>. C programmers might be interested to know
that Python lists are implemented as single heap blocks (rather than
a linked list), and <tt class="monofont">append</tt> is really a call to
<tt class="monofont">realloc</tT> behind the scenes. Provided your heap
manager is smart enough to avoid
<i></I>
<a naMe="idx191"></A>
<A nAMe="idx192"></A> <a NAME="idx193"></a>copying and re-mallocing,
<tt cLASS="monofont">append</tt> can be very fast. Concatenation, on the
other hand, must always create new list objects and copy the items in
both operands.</p>
</fONT></BlockQUOTe>





<p><table border="0" bgcolor="black" CeLlspAcINg="0" CElLpADDIng="1" wiDTH="90%" Align="center"><TR><TD>
<tablE BGColor="white" width="100%" border="0" cellsPaCing="0" CeLLpADdInG="6"><TR>
<Td widTH="60" VAlign="top"><IMG src="FILES/tip_yellow.gif" wiDTH="50" Height="54"></td>
<td valign="top">


<p>Here's another thing that seems to trip up new users:
<tt clAsS="monofont">append</tt> and <tT cLAsS="monofont">sort</Tt> change the
associated list object in-place, but don't return the list as a
result (technically, they both return a value called
<Tt CLASs="monofont">None</tt>
<a NAME="idx195"></a>, which we'll meet in a moment). If
you say something like <tt cLASS="monofont">L</tt> <tt CLASs="monofont">=
L.append(X)</tt>, you won't get the modified value of
<tt class="monofont">L</tt> (in fact, you'll lose the reference to the
list altogether); when you use attributes such as
<tt class="monofont">append</tT> and <tT claSs="monofont">sort</TT>, objects are
changed as a side effect, so there's no reason to reassign.</p>

</TD>
</tR></tABLE></td></tr></TABLe></p><br>


<P>Finally, because lists are mutable, you can also use the
<TT Class="monofont">del</TT>
<A Name="idx196"></a> statement to delete an item or
section. Since slice assignment is a deletion plus an insert, you can
also delete sections of lists by assigning an empty list to a slice
(<tt class="monofont">L[i:j] = []</tt>); Python deletes the slice named on
the left and then inserts nothing. Assigning an empty list to an
index, on the other hand, just stores a reference to the empty list
in the specified slot: <tt class="monofont">L[0] = []</Tt> sets the first
item of <Tt clAsS="monofont">L</Tt> to the object <TT cLaSS="monofont">[]</TT>,
rather than deleting it (<tt clASS="monofont">L</Tt> winds up looking like
<tt cLASS="monofont">[[],...]</tt>):</p>



<pRE CLass="monofont">&gt;&gt;&gt;<b> L</b>
['SPAM!', 'eat', 'more', 'please']
&gt;&gt;&gt;<b> del L[0]                      </b> # delete one item
&gt;&gt;&gt;<b> L</b>
['eat', 'more', 'please']
&gt;&gt;&gt;<b> del L[1:]                    </b>  # delete an entire section
&gt;&gt;&gt;<b> L                             </b> # same as L[1:] = []
['eat']</pre>


<p>Here are a few pointers before moving on. Although all the operations
above are typical, there are additional list methods and operations
we won't illustrate here (including methods for reversing and
searching). You should always consult Python's manuals or
the <i>Python Pocket Reference</i> for a comprehensive
and up-to-date list of type tools. Even if this book was complete, it
probably couldn't be up to date (new tools may be added any
time). We'd also like to remind you one more time that all the
in-place change operations above work only for mutable objects: they
won't work on strings (or tuples, discussed ahead), no matter
how hard you try.</p>



</FoNt>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode22.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode24.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>