<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="2.7 Tuples"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode24.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode26.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT>
<h3>2.7
Tuples</h3>


<p>The last collection type in our survey is the
Python<a NAME="idx209"></a>
<a naME="idx210"></A>
<I>tuple</i>. Tuples construct simple groups of
objects. They work exactly like lists, except that tuples can't
be changed in place (they're immutable) and are usually written
as a series of items in parentheses, not square brackets. Tuples
share most of their properties with lists. They are:</p>



<a nAME="idx211"></A><dl>
<dt>
<i><font color="#990000">Ordered collections of arbitrary objects</font></i></dT>
<dD>
<p>Like strings and lists, tuples are an ordered collection of objects;
like lists, they can embed any kind of object.</p>
</dD>
<dT>
<FoNT cOlOR="#990000">
<A Name="idx211"></a>Accessed by offset</FONT></dt>
<dd>
<P>Like strings and lists, items in a tuple are accessed by offset (not
key); they support all the offset-base access operations we've
already seen, such as indexing and slicing.</P>
</DD>
<dt>
<i><fONT Color="#990000">Of the category immutable sequence</font></i></dt>
<dd>
<p>Like strings, tuples are immutable; they don't support any of
the in-place change operations we saw applied to lists. Like strings
and lists, tuples are sequences; they support many of the same
operations.</p>
</dd>
<dt>
<i><FoNt coLoR="#990000">Fixed length, heterogeneous, arbitrarily nestable</FoNT></i></Dt>
<DD>
<P>Because tuples are immutable, they can't grow or shrink without
making a new tuple; on the other hand, tuples can hold other compound
objects (e.g., lists, dictionaries, other tuples) and so support
nesting.</P>
</dd>
<dt>
<I><FONt colOR="#990000">Arrays of object references</FOnt></i></dT>
<DD>
<P>Like lists, tuples are best thought of as object reference arrays;
tuples store access points to other objects (references), and
indexing a tuple is relatively quick.</p>
</dd>
</dl>


<p><a href="lpython_snode25.html#1">Table 2.9</a> highlights common tuple operations.
Tuples are written as a series of objects (really, expressions),
separated by commas, and enclosed in parentheses. An empty tuple is
just a parentheses pair with nothing inside.</p>



<a name="1"></a><p><TaBle bOrDEr="1" CElLsPACIng="0" ceLLPAddinG="1" WIDth="100%">
<caPTIOn><h5>Table 2.9. Common Tuple Constants and Operations </h5></caption><colgroup spAn="2">
<Tr>
<th>
<FoNT sIZe="2">
<P>Operation</p>
</FONT></th>
<th>
<FONT size="2">
<P>Interpretation</P>
</FOnt></th>
</TR>
<TR>
<td>
<font size="2">
<p><tt class="monofont">()</tt></P>
</fOnt></tD>
<tD>
<FoNT sIzE="2">
<P>An empty tuple</P>
</Font></tD>
</TR>
<Tr>
<td>
<fONT Size="2">
<p><TT CLass="monofont">t1 = (0,)</tt></p>
</font></td>
<td>
<font siZe="2">
<P>A one-item tuple (not an expression)</p>
</foNt></TD>
</tR>
<Tr>
<Td>
<FONT size="2">
<P><TT Class="monofont">t2 = (0, 1, 2, 3)</TT></P>
</Font></tD>
<TD>
<Font size="2">
<p>A four-item tuple</p>
</font></td>
</tr>
<tr>
<tD>
<fOnt sIzE="2">
<P><tT ClAsS="monofont">t2 = 0, 1, 2, 3</TT></P>
</font></TD>
<TD>
<font SIZE="2">
<p>Another four-item tuple (same as prior line)</p>
</foNT></TD>
</tr>
<tr>
<td>
<font size="2">
<p><tt claSs="monofont">t3 = ('abc', ('def', 'ghi'))</Tt></p>
</fOnT></Td>
<TD>
<fOnT SIZe="2">
<p>Nested tuples</p>
</fONT></Td>
</tr>
<tR>
<TD>
<Font sIZE="2">
<P><tt class="monofont">t1[i], t3[i][j]</tt></p>



<p><tt class="monofont">t1[i:j], </tt></P>



<p><Tt clAsS="monofont">len(t1)</Tt></P>
</FoNt></TD>
<TD>
<font SIZE="2">
<p>Index,</p>



<p>slice, <a NAME="idx212"></a> <a naME="idx213"></A></P>



<p>length</p>
</font></td>
</tr>
<tr>
<td>
<font siZe="2">
<P><tt cLaSS="monofont">t1 + t2</tT></P>



<p><Tt CLASs="monofont">t2 * 3</tt></p>
</FONT></td>
<td>
<FONT size="2">
<P>Concatenate,</P>



<P>repeat</P>
</font></td>
</tr>
<tr>
<td>
<font size="2">
<P><tT claSs="monofont">for x in t2,</TT></p>



<P><Tt ClASS="monofont">3 in t2</Tt></p>
</foNT></TD>
<td>
<foNT SIze="2">
<p>Iteration,</p>



<P>membership</P>
</FOnt></td>
</tr>
</colgroup>
</table></p>



<P>The second and fourth entries in <a href="lpython_snode25.html#1">Table 2.9</A> merit a
bit more explanation. Because parentheses can also enclose
expressions (see <a href="lpython_snode21.html">Section 2.3</A>), you
need to do something special to tell Python when a single object in
parentheses is a tuple object and not a simple expression. If you
really want a single-item tuple, simply add a trailing comma after
the single item and before the closing parenthesis.</p>



<P>As a special case, Python also allows us to omit the opening and
closing parentheses for a tuple, in contexts where it isn't
syntactically ambiguous to do so. For instance, in the fourth line of
the table, we simply listed four items, separated by commas; in the
context of an assignment statement, Python recognizes this as a
tuple, even though we didn't add parentheses. For beginners,
the best advice here is that it's probably easier to use
parentheses than it is to figure out when they're optional.</p>



<P>Apart from constant syntax differences, tuple operations (the last
three rows in the table) are identical to strings and lists, so we
won't show examples here. The only differences worth noting are
that the <TT Class="monofont">+</TT>, <TT clasS="monofont">*</TT>, and slicing
operations return new tuples when applied to tuples, and tuples
don't provide the methods we saw for lists and dictionaries;
generally speaking, only mutable objects export callable methods in
Python.</P>




<h4>2.7.1
Why Lists and Tuples?</h4>


<p>This seems to be the first question that always comes up when
teaching beginners about tuples: why do we need tuples if we have
lists? Some of it may be historic. But the best answer seems to be
that the immutability of tuples provides some integrity; you can be
sure a tuple won't be changed through another reference
elsewhere in a program. There's no such guarantee for lists, as
we'll discover in a moment. Some built-in operations also
require tuples, not lists; for instance, argument lists are
constructed as tuples, when calling functions dynamically with
built-ins such as <tT CLAss="monofont">apply</tt> (of course, we
haven't met <tt class="monofont">apply</tt> yet, so you'll have
to take our word for it for now). As a rule of thumb, lists are the
tool of choice for ordered collections you expect to change; tuples
handle the other cases.</p>


</font>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode24.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode26.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>