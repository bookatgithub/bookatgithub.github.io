<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="2.12 Exercises"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode29.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_cnode31.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT>
<h3>2.12
Exercises</h3>


<p>This session asks you to get your feet wet with built-in object
fundamentals. As before, a few new ideas may pop up along the way, so
be sure to flip to <a href="lpython_cnode130.html">Appendix C</a> when you're
done (and even when you're not).</p>



<ol TYPE="1">
<li><p><i>The basics</I>. Experiment interactively with the
common type operations found in this chapter's tables. To get
you started, bring up the Python interactive interpreter, type the
expressions below, and try to explain what's happening in each
case:</P>



<PRe class="monofont">2 ** 16
2 / 5, 2 / 5.0

"spam" + "eggs"
S = "ham"
"eggs " + S
S * 5
S[:0]
"green %s and %s" % ("eggs", S)

('x',)[0]
('x', 'y')[1]

L = [1,2,3] + [4,5,6]
L, L[:], L[:0], L[-2], L[-2:]
([1,2,3] + [4,5,6])[2:4]
[L[2], L[3]]
L.reverse(); L
L.sort(); L
L.index(4)

{'a':1, 'b':2}['b']
D = {'x':1, 'y':2, 'z':3}
D['w'] = 0
D['x'] + D['w']
D[(1,2,3)] = 4
D.keys(), D.values(), D.has_key((1,2,3))

[[]], ["",[],(),{},None]</pre></li>
<li><p><i>Indexing and
slicing</i>. At the interactive prompt, define a list named
<tt clAss="monofont">L</TT> that contains four strings or numbers (e.g.,
<tt ClasS="monofont">L=[0,1,2,3]</Tt>). Now, let's experiment with
some boundary cases.</p>



<OL TYPe="a">
<li><p>What happens when you try to index
out of bounds (e.g., <TT CLass="monofont">L[4]</tT>)?</P>
</LI>
<li><p>What about slicing out of bounds (e.g.,
<tT CLAss="monofont">L[-1000:100]</tt>)?</p>
</li>
<li><p>Finally,
how does Python handle it if you try to extract a sequence in
reverse—with the lower bound greater than the higher bound
(e.g., <tt class="monofont">L[3:1]</tt>)? Hint: try assigning to this slice
(<tT clASs="monofont">L[3:1] = ['?']</tT>) and see where the value is put.
Do you think this may be the same phenomenon you saw when slicing out
of bounds?</p>
</li>
</OL>
</li>
<LI><P><I>Indexing, slicing, and del</I>. Define
another list <tt clASS="monofont">L</Tt> with four items again, and assign
an empty list to one of its offsets (e.g., <tt cLASS="monofont">L[2] =
[]</tt>): what happens? Then try assigning an empty list to a
slice (<tt CLASs="monofont">L[2:3] = []</tt>): what happens now? Recall that
slice assignment deletes the slice and inserts the new value where it
used to be. The <tt class="monofont">del</tt>
<a name="idx248"></a> statement deletes offsets,
keys, attributes, and names: try using it on your list to delete an
item (e.g., <tt ClaSS="monofont">del L[0]</tt>). What happens if you
<Tt clASs="monofont">del</tT> an entire slice (<TT CLass="monofont">del
L[1:]</tT>)? What happens when you assign a nonsequence to a
slice (<TT Class="monofont">L[1:2] = 1</TT>)?</P>
</Li>
<li><p><I>Tuple assignment</I>. What do you think is
happening to <TT class="monofont">X</tt> and <tt class="monofont">Y</tt> when you
type this sequence? We'll return to this construct in <a href="lpython_cnode31.html">Chapter 3</a>, but it has something to do with the tuples
we've seen here.</p>



<PRe cLass="monofont">&gt;&gt;&gt;<B> X = 'spam'</B>
&gt;&gt;&gt;<b> Y = 'eggs'</b>
&gt;&gt;&gt; <B>X, Y = Y, X</B></PRE></li>
<li><P><I>Dictionary keys</I>.
Consider the following code fragments:</P>



<pre cLASS="monofont">&gt;&gt;&gt;<b> D = {}</b>
&gt;&gt;&gt; <b>D[1] = 'a'</b>
&gt;&gt;&gt; <B>D[2] = 'b'</B></PRe>


<p>We learned that dictionaries aren't accessed by offsets;
what's going on here? Does the following shed any light on the
subject? (Hint: strings, integers, and tuples share which type
category?)</p>



<pre class="monofont">&gt;&gt;&gt; <b>D[(1, 2, 3)] = 'c'</b>
&gt;&gt;&gt; <b>D</b>
{1: 'a', 2: 'b', (1, 2, 3): 'c'}</pre></li>
<Li><p><I>Dictionary
indexing</I>. Create a dictionary named <tt ClasS="monofont">D</Tt>
with three entries, for keys <tT CLASs="monofont">a</tt>,
<tT CLAss="monofont">b</tt>, and <TT CLass="monofont">c</tT>. What happens if you
try to index a nonexistent key <TT Class="monofont">d</tt>
(<tt class="monofont">D['d']</tt>)? What does Python do if you try to assign
to a nonexistent key <tt claSs="monofont">d</tT> (e.g., <Tt cLass="monofont">D['d'] =
'spam'</TT>)? How does this compare to out-of-bounds assignments
and references for lists? Does this sound like the rule for variable
names?</p>
</lI>
<LI><P><I>Generic
operations</i>. Run interactive tests to answer the following
questions.</p>



<ol TYPE="a">
<li><p>What happens when you try to use the
<tT CLAss="monofont">+</tt> operator on different/mixed types (e.g., string
+ list, list + tuple)?</P>
</LI>
<Li><p>Does
<tt class="monofont">+</tt> work when one of the operands is a dictionary?</p>
</li>
<li><p>Does the <tt cLasS="monofont">append</Tt> method
work for both lists and strings? How about the using the
<tT claSS="monofont">keys</tt> method on lists? (Hint: What does
<TT CLAss="monofont">append</tt> assume about its subject object?)</P>
</LI>
<Li><p>Finally, what type of object do you get back when
you slice or concatenate two lists or two strings?</p>
</lI>
</OL>
</Li>
<li><p><I>String
indexing</I>. Define a string <TT class="monofont">S</tt> of four
characters: <tt class="monofont">S</tt> <tt clAss="monofont">=</TT>
<tt ClasS="monofont">"spam"</Tt>. Then type the following expression:
<tT CLASs="monofont">S[0][0][0][0][0]</tt>. Any clues as to what's
happening this time? (Hint: recall that a string is a collection of
characters, but Python characters are one-character strings.) Does
this indexing expression still work if you apply it to a list such
as: <tT CLAss="monofont">['s', 'p', 'a', 'm']</tt>? Why?</P>
</LI>
<Li><p><i>Immutable types</i>.
Define a string <TT CLass="monofont">S</tt> of 4 characters again:
<tt class="monofont">S = "spam"</tt>. Write an assignment that changes the
string to <tt clasS="monofont">"slam"</tt>, using only slicing and
concatenation. Could you perform the same operation using just
indexing and concatenation? How about index assignment?</P>
</Li>
<lI><p><i>Nesting</i>. Write a
data-structure that represents your personal information: name
(first, middle, last), age, job, address, email ID, and phone number.
You may build the data structure with any combination of built-in
object types you like: lists, tuples, dictionaries, strings, numbers.
Then access the individual components of your data structures by
indexing. Do some structures make more sense than others for this
object?</P>
</Li>
<lI><P><I>Files</I>. Write a script that creates a new output file
called <I>myfile.txt</i> and writes the string
<tt cLASS="monofont">"Hello</tt> <tt CLASs="monofont">file</tt>
<tT CLAss="monofont">world!"</tt> in it. Then write another script that
opens <i>myfile.txt</i>, and reads and prints its
contents. Run your two scripts from the system command line. Does the
new file show up in the directory where you ran your scripts? What if
you add a different directory path to the filename passed to
<tt class="monofont">open</tt>?</p>
</li>
<li><P><i>The dir function revisited</i>. Try typing
the following expressions at the interactive prompt. Starting with
Version 1.5, the <TT clAss="monofont">dir</tT> function we met in <A href="lpython_cnode9.html">Chapter 1</A> has been generalized to list all attributes of
<I>any</I> Python object you're likely to be
interested in. If you're using an earlier version than 1.5, the
__<tt clASS="monofont">methods</Tt>__ scheme has the same effect.</p>



<prE CLAss="monofont">[].__methods__      # 1.4 or 1.5
dir([])             # 1.5 and later
dir({})</prE></LI>
</Ol>

</font>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode29.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_cnode31.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>