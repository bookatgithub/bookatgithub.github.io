<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="3.1 Assignment"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_cnode31.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode34.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT>
<h3>3.1
Assignment</h3>


<p>We've been using the Python<a NAME="idx251"></a> <a naME="idx252"></A>
assignment statement already, to assign objects to names. In its
basic form, you write a target of an assignment on the left of an
equals sign and an object to be assigned on the right. The target on
the left may be a name or object component, and the object on the
right can be an arbitrary expression that computes an object. For the
most part, assignment is straightforward to use, but here are a few
properties to keep in mind:</P>



<a namE="idx253"></A><A Name="idx254"></a><a name="idx255"></a><a name="idx256"></a><a namE="idx257"></a><A namE="idx258"></a><A NaME="idx259"></a><Dl>
<DT>
<FOnt coLOR="#990000">Assignments create <A name="idx253"></A>
<A NAme="idx254"></a>object references</fONT></Dt>
<dd>
<p>As we've already seen, Python assignment stores references to
objects in names or data structure slots. It always creates
<i>references</i>
<a name="idx255"></a>
<a name="idx256"></a> to objects, instead of copying objects.
Because of that, Python variables are much more like pointers than
data storage areas as in C.</p>
</dD>
<dT>
<i><foNt COlOR="#990000">Names are created when first assigned</fOnT></I></DT>
<dd>
<p>As we've also seen, Python creates variable
<a NAME="idx257"></a>names
the first time you assign them a value (an object reference).
There's no need to predeclare names ahead of time. Some (but
not all) data structure slots are created when assigned too (e.g.,
dictionary entries, some object attributes). Once assigned, a name is
replaced by the value it references when it appears in an expression.</p>
</dd>
<DT>
<I><Font cOLOR="#990000">Names must be assigned before being referenced</font></i></dt>
<dd>
<p>Conversely, it's an error to use a
<a name="idx258"></a>name
you haven't assigned a value to yet. Python raises an exception
if you try, rather than returning some sort of ambiguous (and hard to
notice) default value.</p>
</dd>
<dT>
<fOnt cOlOR="#990000">Implicit <a NAmE="idx259"></a>assignments: import, from, def, class, for, function arguments, etc.</FONT></dt>
<dd>
<P>In this section, we're concerned with the <TT Class="monofont">=</TT>
statement, but assignment occurs in many contexts in Python. For
instance, we'll see later that module imports, function and
class definitions, <TT clasS="monofont">for</TT> loop variables, and
function arguments are all implicit assignments. Since assignment
works the same everywhere it pops up, all these contexts simply bind
names to object references at runtime.</P>
</dd>
</dl>


<p><a href="lpython_snode33.html#3">Table 3.2</a> illustrates the different flavors of
the<a name="idx260"></a>
assignment statement in Python.</p>



<a nAmE="3"></a><p><tAbLE bORdEr="1" CELLspacING="0" CellpADDIng="1" wiDTH="100%">
<Caption><h5>Table 3.2. Assignment Statement Forms </h5></caption><colgrOuP spaN="2">
<tR>
<Th>
<FOnT sIZE="2">
<P>Operation</p>
</fonT></TH>
<Th>
<fonT SIZe="2">
<p>Interpretation</p>
</fONT></Th>
</tr>
<tr>
<td>
<font size="2">
<pre clAsS="monofont">spam = 'Spam'</pre></FoNT></tD>
<Td>
<FoNT SIze="2">
<p>Basic form</p>
</FONT></td>
</tr>
<TR>
<TD>
<font SIZE="2">
<pre class="monofont">spam, ham = 'yum', 'YUM'</pre></font></td>
<td>
<fOnT sizE="2">
<p>Tuple assignment (positional)</P>
</FoNT></tD>
</tR>
<TR>
<Td>
<fonT SIZe="2">
<pre CLASs="monofont">[spam, ham] = ['yum', 'YUM']</pre></FONT></td>
<td>
<font size="2">
<p>List assignment (positional)</p>
</font></td>
</Tr>
<Tr>
<td>
<FoNT sIZe="2">
<PrE CLAss="monofont">spam = ham = 'lunch'</prE></FONt></td>
<tD>
<FONt sizE="2">
<P>Multiple-target</P>
</Font></td>
</tr>
</colgroup>
</table></P>



<p>The first line is by far the most common: binding a single object to
a name (or data-structure slot). The other table entries represent
special forms:</P>



<a naMe="idx261"></A><A nAMe="idx262"></A><a NAME="idx263"></a><dl>
<dT>
<I><FOnt coLOR="#990000">Tuple and list unpacking assignments</Font></i></DT>
<DD>
<p>The second and third lines are related. When you use
<a name="idx261"></a>
<a name="idx262"></a>tuples
or lists on the left side of the <tt class="monofont">=</Tt>, Python pairs
objects on the right side with targets on the left and assigns them
from left to right. For example, in the second line of the table,
name <Tt clAsS="monofont">spam</Tt> is assigned the string
<TT cLaSS="monofont">'yum'</TT>, and name <tt clASS="monofont">ham</Tt> is bound to
string <tt cLASS="monofont">'YUM'</tt>. Internally, Python makes a tuple of
the items on the right first, so this is often called tuple (and
list) unpacking assignment.</p>
</dD>
<DT>
<Font color="#990000">M<a name="idx263"></a>ultiple-target assignments</font></dt>
<Dd>
<P>The last line shows the multiple-target form of assignment. In this
form, Python assigns a reference to the same object (the object
farthest to the right) to all the targets on the left. In the table,
names <tt cLaSS="monofont">spam</tT> and <Tt ClASS="monofont">ham</Tt> would both
be assigned a reference to the string <tt cLASS="monofont">'lunch'</tt>, and
so share the same object. The effect is the same as if you had coded
<tt CLASs="monofont">ham='lunch'</tt>, followed by
<tT CLAss="monofont">spam=ham</tt>, since <tt class="monofont">ham</tt> evaluates
to the original string object.</p>
</dd>
</dl>


<p>Here's a simple example of unpacking assignment in action. We
introduced the effect of the last line in a solution to the exercise
from <a href="lpython_cnode17.html">Chapter 2</a>: since Python creates a temporary
tuple that saves the items on the right, unpacking assignments are
also a way to swap two variables' values without creating a
temporary of our own.</p>



<PrE ClASs="monofont">&gt;&gt;&gt; <B>nudge = 1</b>
&gt;&gt;&gt; <B>wink  = 2</B>
&gt;&gt;&gt; <B>A, B = nudge, wink           </B>  # tuples
&gt;&gt;&gt; <b>A, B</b>
(1, 2)
&gt;&gt;&gt; <b>[C, D] = [nudge, wink]        </b> # lists
&gt;&gt;&gt; <B>C, D</B>
(1, 2)
&gt;&gt;&gt; <B>nudge, wink = wink, nudge      </B># tuples: swaps values
&gt;&gt;&gt; <b>nudge, wink                    </b># same as T=nudge; nudge=wink; wink=T
(2, 1)</prE>



<H4>3.1.1
Variable Name Rules</H4>


<P>Now that we've told you the whole story of
<a namE="idx264"></A>assignment statements, we should also
get a bit more formal in our use of <A Name="idx265"></a>
<a name="idx266"></a>variable names. In Python, names come
into existence when you assign values to them, but there are a few
rules to follow when picking names for things in our program.
Python's variable name rules are similar to C's:</p>



<a name="idx267"></a><a naMe="idx268"></A><a naMe="idx269"></A><Dl>
<DT>
<fOnT COLor="#990000">S<a nAME="idx267"></A>yntax: (underscore or letter) + (any number of letters, digits, or underscores)</font></DT>
<DD>
<p>Variable names must start with an underscore or letter, and be
followed by any number of letters, digits, or underscores.
<tt cLASS="monofont">_spam</tt>, <tt class="monofont">spam</tt>, and
<tt class="monofont">Spam_1</tt> are legal names, but
<Tt ClasS="monofont">1_Spam</tT>, <Tt CLaSs="monofont">spam$</TT>, and
<TT clasS="monofont">@#!</TT> are not.</P>
</dd>
<dt>
<FONT coloR="#990000">
<A NAme="idx268"></a>Case matters: SPAM is not the same as spam</font></dt>
<dd>
<p>Python always pays attention to case in programs, both in names you
create and in reserved words. For instance, names
<tt class="monofont">X</tT> and <tT claSs="monofont">x</TT> refer to two different
variables.</p>
</DD>
<dT>
<fONT Color="#990000">R<A NAMe="idx269"></a>eserved words are off limits</foNT></DT>
<dd>
<p>Names we define cannot be the same as words that mean special things
in the Python language. For instance, if we try to use a variable
name like <tT CLAss="monofont">class</tt>, Python will raise a syntax error,
but <tt class="monofont">klass</tt> and <tt class="monofont">Class</Tt> work fine.
The list below displays the reserved words (and hence off limits to
us) in Python.</P>
</dd>
</dL>


<p><TAbLE bOrDER="1" CellsPACIng="0" ceLLPAddinG="1" WIDth="100%">
<colgroup span="5">
<tr>
<td>
<foNt Size="2">
<P><tT ClASs="monofont">and</Tt></P>
</FONt></td>
<tD>
<FONt sizE="2">
<P><TT clasS="monofont">assert</TT></P>
</font></td>
<td>
<font size="2">
<p><tt cLaSs="monofont">break</tt></P>
</fONt></TD>
<tD>
<fONT Size="2">
<p><TT CLass="monofont">class</tT></P>
</FOnt></td>
<TD>
<FOnt size="2">
<p><tt class="monofont">continue</tt></p>
</fonT></tD>
</tr>
<tR>
<tD>
<FoNT sIzE="2">
<P><TT clasS="monofont">def</TT></P>
</font></TD>
<TD>
<font SIZE="2">
<p><tt class="monofont">del</tt></p>
</font></td>
<td>
<fOnT sizE="2">
<p><TT cLAsS="monofont">elif</tT></P>
</FOnt></td>
<TD>
<FOnt siZE="2">
<P><Tt claSS="monofont">else</TT></p>
</font></td>
<td>
<font size="2">
<p><tt ClAss="monofont">except</tT></p>
</FOnT></Td>
</Tr>
<TR>
<TD>
<font SIZE="2">
<p><tt cLASS="monofont">exec</tt></p>
</fONT></Td>
<td>
<font size="2">
<p><tt class="monofont">finally</tT></p>
</Font></Td>
<TD>
<fONt SiZE="2">
<P><Tt claSS="monofont">for</TT></p>
</fonT></TD>
<Td>
<fonT SIZe="2">
<p><tt class="monofont">from</tt></p>
</font></td>
<td>
<FoNt siZe="2">
<P><Tt CLaSs="monofont">global</TT></P>
</Font></tD>
</TR>
<Tr>
<td>
<fONT Size="2">
<p><TT CLass="monofont">if</tt></p>
</font></td>
<td>
<font siZe="2">
<P><tt cLaSS="monofont">import</tT></P>
</fOnT></TD>
<Td>
<fonT SIZe="2">
<p><tt CLASs="monofont">in</tt></p>
</FONT></td>
<td>
<font size="2">
<p><tt class="monofont">is</Tt></P>
</fonT></tD>
<Td>
<FOnT sIZE="2">
<P><tt clASS="monofont">lambda</Tt></p>
</foNT></TD>
</tr>
<tr>
<TD>
<FOnt size="2">
<p><tt class="monofont">not</tt></p>
</fonT></tD>
<td>
<fOnT SiZE="2">
<p><Tt CLASs="monofont">or</tt></p>
</FONT></td>
<td>
<FONT size="2">
<P><TT Class="monofont">pass</tt></p>
</font></td>
<td>
<font sIzE="2">
<p><tt ClASs="monofont">print</TT></p>
</FoNT></TD>
<td>
<foNT SIze="2">
<p><tT CLAss="monofont">raise</tt></P>
</FONt></td>
</tr>
<tr>
<td>
<font size="2">
<p><tt ClAss="monofont">return</tT></p>
</FOnT></Td>
<Td>
<FONT size="2">
<P><TT Class="monofont">try</TT></P>
</Font></tD>
<TD>
<Font size="2">
<p><tt class="monofont">while</tt></p>
</foNt></Td>
<td>
<FoNT sIZe="2"> </FoNT></TD>
<td>
<foNT SIze="2"> </foNT></TD>
</tr>
</coLGROup>
</table></p>


<p>Before moving on, we'd like to remind you that it's
crucial to keep Python's distinction between
<i>names</i> and <i>objects</i> clear. As
we saw in <a href="lpython_cnode17.html">Chapter 2</a>, objects have a type (e.g.,
integer, list), and may be mutable or not. Names, on the other hand,
are just references to objects. They have no notion of mutability and
have no associated type information apart from the type of the object
they happen to be bound to at a given point in time. In fact,
it's perfectly okay to assign the same name to different kinds
of objects at different times:</p>



<PrE claSs="monofont">&gt;&gt;&gt;<B> x = 0            </B># x bound to an integer object
&gt;&gt;&gt;<b> x = "Hello"      </B># now it's a string
&gt;&gt;&gt;<B> x = [1, 2, 3]    </b># and now it's a list</PrE>


<P>In later examples, we'll see that this generic nature of names
can be a decided advantage in Python<A Name="idx270"></a> <A NAMe="idx271"></a> programming.<foNT SIze="1"><suP><A HRef="#FOOTNOTE-1">[1]</a></sup></font>
</p>


<blockquotE><fOnt sIzE="1">
<P cLAsS="footnote">
<sUP><A Name="FOOTNOTE-1">[1]</a></SUP>
If
you've used C++ in the past, you may be interested to know that
there is no notion of C++'s <Tt claSS="monofont">const</TT>
declaration in Python; certain objects may be immutable, but names
can always be assigned. Or usually; as we'll see in later
chapters, Python also has ways to hide names in classes and modules,
but they're not the same as C++'s declarations.</p>
</fonT></BLOckquote>




</font>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_cnode31.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode34.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>