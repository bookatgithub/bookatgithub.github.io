<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="3.4 if Tests"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode35.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode37.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT>
<h3>3.4
if Tests</h3>


<p>The Python<a NAME="idx283"></a>
<tt cLASS="monofont">if</tt> statement selects actions to perform.
It's the primary selection tool in Python and represents much
of the logic a Python program possesses. It's also our first
<i>compound</i> statement; like all compound Python
statements, the <TT CLass="monofont">if</tt> may contain other statements,
including other <tt class="monofont">ifs</tt>. In fact, Python lets you
combine statements in a program both
<i>sequentially</i> (so that they execute one after
another), and arbitrarily <i>nested</i> (so that they
execute only under certain conditions).</p>




<h4>3.4.1
General Format</H4>


<p>The Python<A namE="idx284"></a>
<TT cLAsS="monofont">if</tT> statement is typical of most procedural
languages. It takes the form of an <TT Class="monofont">if</TT> test,
followed by one or more optional
<TT clasS="monofont">elif</TT>
<A name="idx285"></A> tests (meaning "else if"),
and ends with an optional
<TT Class="monofont">else</tt>
<a name="idx286"></a> block. Each test and the
<tt class="monofont">else</tT> have an associated block of nested statements
indented under a header line. When the statement runs, Python
executes the block of code associated with the first test that
evaluates to true, or the <tT claSs="monofont">else</TT> block if all tests
prove false. The general form of an <tT ClAsS="monofont">if</TT> looks like
this:</P>



<pre cLASS="monofont">if &lt;<tt clASS="monofont"><I>test1</i></tt>&gt;:               # if test 
    &lt;<tT CLAss="monofont"><i>statements1</i></tt>&gt;         # associated block
elif &lt;<tt class="monofont"><i>test2</i></tt>&gt;:             # optional elif's 
    &lt;<tt cLaSs="monofont"><i>statements2</i></Tt>&gt;
else:                     # optional else
    &lt;<TT cLAsS="monofont"><i>statements3</I></TT>&gt;</Pre>






<h4>3.4.2
Examples</h4>


<P>Here are two simple examples of the<A NAme="idx287"></a> <tT CLAss="monofont">if</tt> statement. All
parts are optional except the initial <TT CLass="monofont">if</tt> test and
its associated statements. Here's the first:</p>



<pre class="monofont">&gt;&gt;&gt; <b>if 1:</b>
...     <b>print 'true'</b>
...
true
&gt;&gt;&gt; <b>if not 1:</b>
...     <B>print 'true'</b>
... <B>else:</b>
...     <b>print 'false'</b>
...
false</PrE>


<P>Now, here's an example of the most complex kind of
<tT ClAsS="monofont">if</TT> statement—with all its optional parts
present. The statement extends from the <Tt claSS="monofont">if</TT> line,
through the <tt clASS="monofont">else</Tt>'s block. Python executes
the statements nested under the first test that is true, or else the
<tt cLASS="monofont">else</tt> part. In practice, both the
<tt class="monofont">elif</tt> and <tt class="monofont">else</tt> parts may be
omitted, and there may be more than one statement nested in each
section:</P>



<pRe clAsS="monofont">&gt;&gt;&gt;<B> x = 'killer rabbit'</b>
&gt;&gt;&gt;<B> if x == 'roger':</B>
...<b>     print "how's jessica?"</B>
...<b> elif x == 'bugs':</B>
... <B>    print "what's up doc?"</B>
...<B> else:</b>
... <b>    print 'Run away! Run away!'</b>
...
Run away! Run away!</pRE>


<P>If you've used languages like C or Pascal, you might be
interested to know that there is no <Tt claSS="monofont">switch</TT> (or
<tt clASS="monofont">case</Tt>) statement in Python. Instead,
<i>multiway branching</i> is coded as a series of
<tt class="monofont">if</tt>/<tt class="monofont">elif</tT> tests as done above, or
by indexing dictionaries or searching lists. Since dictionaries and
lists can be built at runtime, they're sometimes more flexible
than hardcoded logic:</p>



<Pre cLaSS="monofont">&gt;&gt;&gt;<b> choice = 'ham'</B>
&gt;&gt;&gt;<B> print {'spam':  1.25,          </b> # a dictionary-based 'switch'
... <B>       'ham':   1.99,          </b> # use has_key() test for default case
... <B>       'eggs':  0.99,</B>
... <B>       'bacon': 1.10}[choice]</B>
1.99</pre>


<p>An almost equivalent <TT CLass="monofont">if</tT> statement might look like
the following:</P>



<PRe claSS="monofont">&gt;&gt;&gt;<B> if choice == 'spam':</B>
...<b>     print 1.25</b>
...<b> elif choice == 'ham':</b>
...<b>     print 1.99</b>
...<b> elif choice == 'eggs':</b>
...<b>     print 0.99</b>
...<b> elif choice == 'bacon':</b>
...<b>     print 1.10</b>
...<b> else:</b>
...<b>     print 'Bad choice'</b>
...
1.99</prE>


<p>Dictionaries are good at associating values with keys, but what about
more complicated actions you can code in <Tt clAsS="monofont">if</Tt>
statements? We can't get into many details yet, but in <A href="lpython_cnode42.html">Chapter 4</A>, we'll see that dictionaries can also
contain <I>functions</I> to represent more complex
actions.</P>







<h4>3.4.3
Python Syntax Rules</h4>


<p>Since the <tT CLAss="monofont">if</tt>
<A NAMe="idx288"></a> <a nAME="idx289"></A>statement
is our first compound statement, we need to say a few words about
Python's syntax rules now. In general, Python has a simple,
statement-based syntax. But there are a few properties you need to
know:</p>



<a name="idx290"></a><a name="idx291"></a><a name="idx292"></a><a NaMe="idx293"></a><a NaME="idx294"></a><A NaMe="idx295"></A><A NAme="idx296"></a><a NAME="idx297"></a><a naME="idx298"></A><A name="idx299"></A><DL>
<Dt>
<font color="#990000">Statements<a name="idx290"></a> execute one after another, until you say otherwise</font></Dt>
<Dd>
<p>Python normally runs statements in a file or nested block from first
to last, but statements like the <tT cLAsS="monofont">if</Tt> (and, as
we'll see in a moment, loops) cause the interpreter to jump
around in your code. Because Python's path through a program is
called the <I>control flow</i>, things like the
<TT CLass="monofont">if</tT> that affect it are called
<A NAme="idx291"></a>control-flow statements.</p>
</DD>
<DT>
<font COLOr="#990000">B<a name="idx292"></a>lock and statement boundaries are detected automatically</font></dt>
<dd>
<p>There are no braces or begin/end delimiters around blocks of code;
instead, Python uses the indentation of statements under a header to
group the statements in a <a namE="idx293"></a>nested block. Similarly, Python
statements are not normally terminated with a semicolon as in C;
rather, the end of a line marks the end of most statements.</P>
</dd>
<dT>
<fONt COlOr="#990000">C<A NAMe="idx294"></a>ompound statements = header, `:', indented statements</foNT></DT>
<dd>
<p>All <a NAME="idx295"></a> <a naME="idx296"></A>compound statements in Python follow the
same pattern: a header line terminated with a colon, followed by one
or more nested statements indented under the header. The indented
statements are called a <I>block</i> (or sometimes, a
suite). In the <tt class="monofont">if</tt> statement, the
<tt class="monofont">elif</tt> and <tT cLass="monofont">else</Tt> clauses are part
of the <TT cLAsS="monofont">if</tT>, but are header lines in their own
right.</P>
</DD>
<dt>
<foNT COlor="#990000">S<a NAME="idx297"></a>
<a naME="idx298"></A>pa<A name="idx299"></a>ces and comments are usually ignored</font></dt>
<dd>
<p>Spaces inside statements and expressions are almost always ignored
(except in string constants and indentation). So are comments: they
start with a # character (not inside a string constant) and extend to
the end of the current line. Python also has support for something
called documentation strings associated with objects, but we'll
ignore these for the time being.</p>
</dd>
</dl>


<p>As we've seen, there are no variable type declarations in
Python; this fact alone makes for a much simpler language syntax than
what you may be used to. But for most new users, the lack of braces
and semicolons to mark blocks and statements seems to be the most
novel syntactic feature of Python, so let's explore what this
means in more detail here.<FoNt siZe="1"><SUp><A HrEf="#FOOTNOTE-2">[2]</A></SUP></font>
</P>


<BLOckquOTE><Font sIZE="1">
<P class="footnote">
<sup><a name="FOOTNOTE-2">[2]</a></sup>
It's probably more
novel if you're a C or Pascal programmer. Python's
indentation-based syntax is actually based on the results of a
usability study of nonprogrammers, conducted for the ABC language.
Python's syntax is often called the "what you see is what
you get" of languages; it enforces a consistent appearance that
tends to aid readability and avoid common C and C++ errors.</p>
</foNt></BlocKqUOtE>






<A nAmE="idx332"></A><A Name="idx333"></a><H5>3.4.3.1
B
lock delimiters</H5>


<P>As mentioned, block boundaries are detected by line indentation: all
statements indented the same distance to the right belong to the same
block of code, until that block is ended by a line less indented.
Indentation can consist of any combination of spaces and tabs; tabs
count for enough spaces to move the current column number up to a
multiple of 8 (but it's usually not a good idea to mix tabs and
spaces). Blocks of code can be nested by indenting them further than
the enclosing block. For instance, <A href="lpython_snode36.html#5">Figure 3.1</A>
sketches the block structure of this example:</P>



<CEnter>
<H5>
<A NAme="5"></a>Figure 3.1. Nested code blocks</h5>

<img border="0" width="503" heIgHt="236" src="FILES/lpy_0301.gif" aLT="figs/lpy_0301.gif"></cENtEr>


<PRE Class="monofont">x = 1
if x:
    y = 2
    if y:
        print 'block2'
    print 'block1'
print 'block0'</PRE>


<P>Notice that code in the outermost block must start in column 1, since
it's unnested; nested blocks can start in any column, but
multiples of 4 are a common indentation style. If this all sounds
complicated, just code blocks as you would in C or Pascal, and omit
the delimiters; consistently-indented code always satisfies
Python's rules.</p>






<a naME="idx334"></A><A name="idx335"></A><H5>3.4.3.2
S
tatement delimiters</H5>


<P>As also mentioned, statements normally end at the end of the line
they appear on, but when statements are too long to fit on a single
line, a few special rules may be used:</p>



<a name="idx300"></a><a name="idx301"></a><dl>
<dt>
<i><foNt ColoR="#990000">Statements may span lines if you're continuing an open syntactic pair</fONt></I></Dt>
<Dd>
<P>For statements that are too long to fit on one line, Python lets you
continue typing the statement on the next line, if you're
coding something enclosed in <TT Class="monofont">()</TT>,
<TT clasS="monofont">{}</TT>, or <Tt claSS="monofont">[]</TT> pairs. For instance,
parenthesized expressions and dictionary and list constants can span
any number of lines. Continuation lines can start at any indentation
level.</p>
</dd>
<dt>
<font color="#990000">Statements may span lines if they end in a<a name="idx300"></a>
<A nAme="idx301"></a> backslash</FoNT></dT>
<Dd>
<P>This is a somewhat outdated feature, but if a statement needs to span
multiple lines, you can also add a backslash (<tT CLAss="monofont">\</tt>)
at the end of the prior line to indicate you're continuing on
the next line (much like C <TT CLass="monofont">#define</tT> macros). But
since you can also continue by adding parentheses around long
constructs, backslashes are almost never needed.</P>
</DD>
<dt>
<i><fONT Color="#990000">Other rules</font></i></dt>
<dd>
<p>Very long string constants can span lines arbitrarily. In fact, the
triple-quoted string blocks in <a href="lpython_cnode17.html">Chapter 2</a> are
designed to do so. You can also terminate statements with a semicolon
if you like (this is more useful when more than one statement appears
on a line, as we'll see in a moment). Finally, comments can
appear anywhere.</P>
</dD>
</dl>





<h5>3.4.3.3
A few special cases</H5>


<p>Here's what a continuation line looks like, using
the<A NaME="idx302"></a> <A nAME="idx303"></A> open pairs rule; we can span delimited
constructs across any number of lines:</p>



<pre CLASs="monofont">L = ["Good", 
     "Bad", 
     "Ugly"]                    # open pairs may span lines</pre>


<P>This works for anything in parentheses too: expressions, function
arguments, functions headers (see <A href="lpython_cnode42.html">Chapter 4</a>), and
so on. If you like using backslashes to continue you can, but
it's more work, and not required:</p>



<PRE Class="monofont">if a == b and c == d and   \
   d == e and f == g:
   print 'olde'                  # backslashes allow continuations

if (a == b and c == d and
    d == e and e == f):
    print 'new'                  # but parentheses usually do too</pre>


<p>As a special case, Python allows you to write more than one simple
statement (one without nested statements in it) on the same line,
separated by semicolons. Some coders use this form to save program
file real estate:</p>



<pre class="monofont">x = 1; y = 2; print x            # more than 1 simple statement</pre>


<P>And finally, Python also lets you move a compound statement's
body up to the header line, provided the body is just a simple
statement. You'll usually see this most often used for simple
<tT claSs="monofont">if</TT> statements with a single test and action:</p>



<PRe ClASS="monofont">if 1: print 'hello'              # simple statement on header line</Pre>


<p>You can combine some of these special cases to write code that is
difficult to read, but we don't recommend it; as a rule of
thumb, try to keep each statement on a line of its own. Six months
down the road, you'll be happy you did.</p>








<H4>3.4.4
Truth Tests Revisited</H4>


<P>We introduced the notions of comparison, equality,
and<A name="idx304"></A>
<A NAme="idx305"></a> truth values in <a href="lpython_cnode17.html">Chapter 2</a>. Since <tt class="monofont">if</tt> statements are
the first statement that actually uses test results, we'll
expand on some of these ideas here. In particular, Python's
<a name="idx306"></a>Boolean
operators are a bit different from their counterparts in languages
like C. In Python:</p>



<ul>
<lI><p>	True means any nonzero number or nonempty object.</P>
</li>
<lI><p>False means not true: a zero number, empty object, or
<TT cLAsS="monofont">None</tT>.</P>
</LI>
<li><p>	Comparisons and equality tests return 1 or 0 (true or false).</p>
</LI>
<LI><p>Boolean <tt cLASS="monofont">and</tt> and <tt CLASs="monofont">or</tt> operators
return a true or false operand object.</p>
</li>
</ul>
<p>The last item here is new; in short, Boolean operators are used to
combine the results of other tests. There are three Boolean
expression operators in Python:</p>



<a name="idx307"></a><a namE="idx308"></a><A namE="idx309"></a><DL>
<dT>
<FoNt COLOr="#990000"><fonT COLor="#990000"><spAN CLass="monofont">X</sPAN></Font>
 <font color="#990000"><span clasS="monofont">and</sPan></fOnT>
 <FoNT cOlOR="#990000"><SPan clASS="monofont">Y</Span></fONT>
</Font></dT>
<DD>
<P>Is true if both <tt class="monofont">X</tt> and <tt class="monofont">Y</tt> are
true<a nAmE="idx307"></a></p>
</dD>
<dT>
<FoNT cOlOR="#990000"><FOnt coLOR="#990000"><Span cLASS="monofont">X</span></FONT>
 <font color="#990000"><span class="monofont">or</spAn></Font>
 <FoNT cOLoR="#990000"><sPAN Class="monofont">Y</SPAN></font>
</FONT></dt>
<dd>
<P>Is true if either <TT Class="monofont">X</tt> or <tt class="monofont">Y</tt> are
true<a name="idx308"></A></p>
</Dd>
<dt>
<FoNT cOLoR="#990000"><fONT Color="#990000"><SPAN clasS="monofont">not</SPAn></fonT>
 <FONt color="#990000"><span class="monofont">X</span></fOnT>
</fonT></dT>
<Dd>
<P>Is true if <Tt ClASS="monofont">X</Tt> is false (the expression returns
<tt cLASS="monofont">1</tt> or <tt CLASs="monofont">0</tt>)<a NAME="idx309"></a></p>
</dd>
</dl>


<p>Here, <tt class="monofont">X</tt> and <tt clAsS="monofont">Y</tt> may be any truth
value or an expression that returns a truth value (e.g., an equality
test, range comparison, and so on). Unlike C, Boolean operators are
typed out as words in Python (instead of C's
<tT cLAsS="monofont">&amp;&amp;</Tt>,<Tt CLASs="monofont"> ||</tt>, and
<tT CLAss="monofont">!</tt>). Also unlike C, Boolean <TT CLass="monofont">and</tT>
and <TT Class="monofont">or</tt> operators return a true or false object in
Python, not an integer 1 or 0. Let's look at a few examples to
see how this works:</p>



<pre class="monofont">&gt;&gt;&gt;<b> 2 &lt; 3, 3 &lt; 2 </b>       # less-than: return 1 or 0 
(1, 0)</pre>


<P>Magnitude comparisons like these return an integer 1 or
as their truth value result. But <tT claSs="monofont">and</TT> and
<tT ClAsS="monofont">or</TT> operators always return an object instead. For
<Tt claSS="monofont">or</TT> tests, Python evaluates the operand objects
from left to right, and returns the first one that is true. Moreover,
Python stops at the first true operand it finds; this is usually
called
<i>short-circuit</i>
<a nAME="idx310"></A> evaluation, since determining a
result short-circuits (terminates) the rest of the expression:</p>



<pre CLASs="monofont">&gt;&gt;&gt; <b>2 or 3, 3 or 2</b>      # return left operand if true
(2, 3)                  # else return right operand (whether true or false)
&gt;&gt;&gt;<b> [] or 3</b>
3
&gt;&gt;&gt; <b>[] or {}</b>
{}</pre>


<p>In the first line above, both operands are true
(<tt class="monofont">2</tt>, <Tt ClasS="monofont">3</tT>), so Python always stops
and returns the one on the left. In the other two tests, the left
operand is false, so Python evaluates and returns the object on the
right (that may have a true or false value). <Tt CLaSs="monofont">and</TT>
operations also stop as soon as the result is known; in this case,
Python evaluates operands from left to right and stops at the first
false object:</P>



<Pre clASS="monofont">&gt;&gt;&gt; <B>2 and 3, 3 and 2 </b><i>  </i>   # return left operand if false
(3, 2)                  # else return right operand (whether true or false)
&gt;&gt;&gt;<b> [] and {} </B>
[]
&gt;&gt;&gt; <B>3 and [] </B>
[]</Pre>


<p>Both operands are true in the first line, so Python evaluates both
sides and returns the object on the right. In the second test, the
left operand is false (<tT CLAss="monofont">[]</tt>), so Python stops and
returns it as the test result. In the last test, the left side is
true (<tt class="monofont">3</tt>), so Python evaluates and returns the
object on the right (that happens to be false). The end result is the
same as in C (true or false), but it's based on objects, not
integer flags.<font sizE="1"><sUp><a hReF="#FOOTNOTE-3">[3]</A></sUP></fOnT>
</P>


<BLockqUOTE><font SIZE="1">
<p claSS="footnote">
<SUp><a name="FOOTNOTE-3">[3]</a></sup>
One common way to use Python Boolean
operators is to select from one or more objects with an
<tt class="monofont">or</tt>; a statement such as <tT cLass="monofont">X</Tt>
<TT cLAsS="monofont">=</tT> <TT Class="monofont">A</TT> <TT clasS="monofont">or</TT>
<Tt claSS="monofont">B</TT> <tt class="monofont">or</tt> <tt class="monofont">C</tt> sets
<tt ClAss="monofont">X</tT> to the first nonempty (true) object among
<tT ClASs="monofont">A</Tt>, <TT CLass="monofont">B</tT>, and <TT Class="monofont">C</TT>.
Short-circuit evaluation is important to understand, because
expressions on the right of a Boolean operator might call functions
that do much work or have side effects that won't happen if the
short-circuit rule takes effect.</P>
</Font></bLOCKquote>




</font>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode35.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode37.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>