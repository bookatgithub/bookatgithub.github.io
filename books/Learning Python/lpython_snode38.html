<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="3.6 for Loops"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode37.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode39.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT>
<h3>3.6
for Loops</h3>


<p>The <tT CLAss="monofont">for</tt>
<A NAMe="idx322"></a> loop is a generic <i>sequence
iterator</i> in Python: it can step through the items in any
object that responds to the sequence indexing operation. The
<TT CLass="monofont">for</tt> works on strings, lists, tuples, and new
objects we'll create later with classes. We've already
seen the <tt class="monofont">for</tt> in action, when we mentioned the
iteration operation for sequence types in <a href="lpython_cnode17.html">Chapter 2</a>. Here, we'll fill in the details we
skipped earlier.</P>




<h4>3.6.1
General Format</H4>


<p>The Python<a nAmE="idx323"></A>
<tT ClAsS="monofont">for</TT> loop begins with a header line that specifies
an assignment target (or targets), along with an object you want to
step through. The header is followed by a block of indented
statements, which you want to repeat:</P>



<pre cLASS="monofont">for &lt;<tt clASS="monofont"><I>target</i></tt>&gt; in &lt;<tT CLAss="monofont"><i>object</i></tt>&gt;:   # assign object items to target
    &lt;<tt class="monofont"><i>statements</i></tt>&gt;            # repeated loop body: use target
else:
    &lt;<tt cLaSs="monofont"><i>statements</i></Tt>&gt;            # if we didn't hit a 'break'</PRe>


<P>When Python runs a <Tt ClASS="monofont">for</Tt> loop, it assigns items in
the sequence object to the <i>target</i>, one by one,
and executes the loop body for each.<fONT Size="1"><sUP><A Href="#FOOTNOTE-5">[5]</a></SUP></Font>
 The loop
body typically uses the assignment target to refer to the current
item in the sequence, as though it were a cursor stepping through the
sequence. Technically, the <tt class="monofont">for</tt> works by repeatedly
indexing the sequence object on successively higher indexes (starting
at zero), until an index out-of-bounds exception is raised. Because
<tt class="monofont">for</tT> loops automatically manage sequence indexing
behind the scenes, they replace most of the
<i>counter</I> style loops you may be used to coding in
languages like C.</p>


<blOcKQuOTe><FoNT SIze="1">
<p cLASS="footnote">
<sup><a NAME="FOOTNOTE-5">[5]</a></sup>
The name used as
the assignment target in a <TT CLass="monofont">for</tt> header line is
simply a (possibly new) variable in the namespace (scope) where the
<tt class="monofont">for</tt> statement is coded. There's not much
special about it; it can even be changed inside the
<tt clasS="monofont">for</tT> loop's body, but it's
automatically set to the next item in the sequence when control
returns to the top of the loop again.</p>
</foNt></BLoCKqUoTE>





<P><Tt claSS="monofont"></TT>
<a namE="idx324"></A>The <TT clasS="monofont">for</TT> also supports
an optional <Tt class="monofont">else</tt> block, which works exactly as it
does in <tt class="monofont">while</tt> loops; it's executed if the
loop exits without running into a <tt cLaSs="monofont">break</tt> statement
(i.e., if all items in the sequence were visited). The
<Tt CLaSS="monofont">break</tT> and <tT CLAss="monofont">continue</tt> statements
we introduced above work the same in the <TT CLass="monofont">for</tT> loop
as they do in the <TT Class="monofont">while</TT> too; we won't repeat
their descriptions here, but the <TT class="monofont">for</tt> loop's
complete format can be described this way:</p>



<pre class="monofont">for &lt;<tt clAsS="monofont"><i>target</i></tT>&gt; in &lt;<tT ClASs="monofont"><I>object</i></TT>&gt;:   # assign object items to target
    &lt;<TT clasS="monofont"><I>statements</I></Tt>&gt;
    if &lt;<tt cLASS="monofont"><i>test</i></tt>&gt;: break        # exit loop now, skip else
    if &lt;<TT CLass="monofont"><i>test</i></tt>&gt;: continue     # go to top of loop now
else:
    &lt;<tt class="monofont"><i>statements</i></tt>&gt;            # if we didn't hit a 'break'</prE>






<h4>3.6.2
Examples</H4>


<p>Let's type a few <tt ClASs="monofont">for</TT>
<a NaME="idx325"></A> loops
interactively. In the first example below, the name
<Tt claSS="monofont">x</TT> is assigned to each of the three items in the
list in turn, from left to right, and the <tt clASS="monofont">print</Tt>
statement is executed for each. Inside the <tt cLASS="monofont">print</tt>
statement (the loop body), the name <tt class="monofont">x</tt> refers to
the current item in the list:</p>



<pre class="monofont">&gt;&gt;&gt; <B>for x in ["spam", "eggs", "ham"]:</b>
<B>...     print x,</b>
...
spam eggs ham</prE>


<p>The next two examples compute the sum and product of all the items in
a list. In <A href="lpython_cnode89.html">Chapter 8</a>, we'll see built-ins
that apply operations like <Tt CLASs="monofont">+</tt> and
<tT CLAss="monofont">*</tt> to items in a list, but it's usually just
as easy to use a <TT CLass="monofont">for</tT>:</P>



<PRe class="monofont">&gt;&gt;&gt; <b>sum = 0</b>
&gt;&gt;&gt; <b>for x in [1, 2, 3, 4]:</b>
...<b>     sum = sum + x</b>
...
&gt;&gt;&gt; <b>sum</b>
10
&gt;&gt;&gt; <b>prod = 1</b>
&gt;&gt;&gt; <b>for item in [1, 2, 3, 4]: prod = prod * item</b>
...
&gt;&gt;&gt; <b>prod</b>
24</PrE>


<p>As mentioned, <tt ClASs="monofont">for</TT> loops work on strings and tuples
too. One thing we haven't mentioned is that, if you're
iterating through a sequence of tuples, the loop target can actually
be a <i>tuple</I> of targets. This is just another case
of tuple <i>unpacking</I> assignment at work; remember,
the <TT Class="monofont">for</TT> assigns items in the sequence to the
target, and assignment works the same everywhere:</P>



<Pre clASS="monofont">&gt;&gt;&gt; <B>S, T = "lumberjack", ("and", "I'm", "okay")</b>

&gt;&gt;&gt; <b>for x in S: print x,</b>
...
l u m b e r j a c k

&gt;&gt;&gt; <b>for x in T: print x,</B>
...
and I'm okay

&gt;&gt;&gt; <B>T = [(1, 2), (3, 4), (5, 6)]</B>
&gt;&gt;&gt; <B>for (a, b) in T:                            </b># tuple assignment at work
<b>...     print a, b</b>
...
1 2
3 4
5 6</pre>


<p>Now, let's look at something a bit more sophisticated. The next
example illustrates both the loop <tt class="monofont">else</tt> in a
<tt clAsS="monofont">for</tt> and statement nesting. Given a list of objects
(<tT cLAsS="monofont">items</Tt>) and a list of keys
(<Tt CLASs="monofont">tests</tt>), this code searches for each key in the
objects list, and reports on the search's success:</p>



<PRE Class="monofont">&gt;&gt;&gt; <B>items = ["aaa", 111, (4, 5), 2.01]       </B>   # a set of objects
&gt;&gt;&gt; <B>tests = [(4, 5), 3.14]                      </B># keys to search for
&gt;&gt;&gt;
&gt;&gt;&gt; <b>for key in tests:                       </b>    # for all keys
<b>...     for item in items:                      </b># for all items
<B>...         if item == key:                     </B># check for match
<B>...             print key, "was found"</B>
<b>...             break</b>
<b>...     else:</b>
<b>...         print key, "not found!"</b>
<b>...</b>
(4, 5) was found
3.14 not found!</pre>


<p>Since the nested <tt class="monofont">if</tT> runs a
<tT claSs="monofont">break</TT> when a match is found, the loop
<tT ClAsS="monofont">else</TT> can assume that the search has failed. Notice
the nesting here: when this code runs, there are two loops going at
the same time. The outer loop scans the keys list, and the inner loop
scans the items list for each key. The nesting of the loop
<Tt claSS="monofont">else</TT> is critical; it's indented at the same
level as the header line of the inner <tt clASS="monofont">for</Tt> loop, so
it's associated with the inner loop (not the
<tt cLASS="monofont">if</tt> or outer <tt class="monofont">for</tt>). By the way,
this example is easier to code if you employ the
<tt class="monofont">in</tt> operator from <A href="lpython_cnode17.html">Chapter 2</a>, to
test <I>membership</i> for us; since
<TT cLAsS="monofont">in</tT> implicitly scans a list looking for a match, it
replaces the inner loop:</P>



<PRe claSS="monofont">&gt;&gt;&gt; <B>for key in tests:                   </B> # for all keys
<b>...     if key in items:                 </b># let Python check for a match
<b>...         print key, "was found"</b>
<B>...     else:</B>
<B>...         print key, "not found!"</B>
<b>...</b>
(4, 5) was found
3.14 not found!</prE>


<P>In general, it's a good idea to let Python do the work like
this. The next example performs a typical data-structure task with a
<TT class="monofont">for</tt>—collecting common items in two sequences
(strings). It's roughly a simple set
<i>intersection</i> routine; after the loop runs,
<tt class="monofont">res</tt> refers to a list that contains all the items
found in both <tt ClAss="monofont">seq1</tT> and
<tT ClASs="monofont">seq2</Tt>:<FONT size="1"><SUP><A href="#FOOTNOTE-6">[6]</A></SUP></font>
</P>


<BLOckquote><font size="1">
<p clasS="footnote">
<sUp><a nAmE="FOOTNOTE-6">[6]</A></sUP>
This isn't
exactly what some folks would call set intersection (an item can
appear more than once in the result if it appears more than once in
<tT cLASS="monofont">seq1</tt>), but this isn't exactly a text on set
theory either. To avoid duplicates, say <tt CLASs="monofont">if x in seq2 and x
not in res</tt> inside the loop instead. Incidentally, this is a
great example of how lists get built up dynamically (by program
code), rather than being written out as a constant. As we mentioned
before, most data structures are built, rather than written.</p>
</FONT></blocKQUOte>





<pre class="monofont">&gt;&gt;&gt; <b>seq1 = "spam"</b>
&gt;&gt;&gt; <b>seq2 = "scam"</b>
&gt;&gt;&gt;
&gt;&gt;&gt; <b>res = []                     </b># start empty
&gt;&gt;&gt; <b>for x in seq1:             </b>  # scan first sequence
<b>...     if x in seq2:           </b> # common item?
<B>...         res.append(x)        </b># add to result end
<B>...</b>
&gt;&gt;&gt; <b>res</b>
['s', 'a', 'm']</PrE>


<P>Unfortunately, this code is equipped to work only on two specific
variables: <tT ClAsS="monofont">seq1</TT> and <Tt claSS="monofont">seq2</TT>. It
would be nice if this loop could be somehow generalized into a tool
we could use more than once. As we'll see, that simple idea
leads us to <i>functions</i>, the topic of our
<a nAME="idx326"></A>next
chapter.</p>



<p><taBLE Cellspacing="0" width="90%" bordeR="1"><tR><td>

<cEnTEr><H2>
Why You Will Care: File Scanner Loops</H2></cEnTER>


<P>In general, loops come in handy any place you need to repeat or
process something more than once. Since files contain multiple
characters and lines, they are one of the more typical uses for
loops. For example it's common to see file scanning <a namE="idx327"></A>
<A Name="idx328"></a>loops coded
with a <TT CLass="monofont">while</tT> and <TT Class="monofont">breaks</tt>,
instead of end-of-file tests at the top:</p>


<pre class="monofont">file = open("name", "r")
while 1:
    line = file.readline()     # fetch next line, if any
    if not line: break         # exit loop on end-of-file (empty string)
<pre><i>       Process line here</i></PrE></pre>


<P>The <tT ClASs="monofont">for</Tt> loop comes in handy for scanning files
too; the <TT CLass="monofont">readlines</tT> file method introduced in <A href="lpython_cnode17.html">Chapter 2</a> hands you a lines list to step through:</p>



<PRE Class="monofont">file = open("name", "r")
for line in file.readlines():     # read into a lines list
<PRE><I>    Process line here</i></pre></pre>



<p>In other cases, you might scan byte-by-byte (using
<tt class="monofont">while</tt> and <tt cLaSs="monofont">file.read(1)</tt>), or
load the file all at once (e.g., <Tt CLaSS="monofont">for char in
file.read()</tT>). We'll learn more about file processing
later in the book.</p>



</TD></TR></tablE></P>







<A Name="idx366"></a><A NAMe="idx367"></a><h4>3.6.3


range and Counter Loops</h4>


<P>The <TT Class="monofont">for</tt> loop subsumes most counter-style loops, so
it's the first tool you should reach for whenever you need to
step though a sequence. But there are also situations where you need
to iterate in a more specialized way. You can always code unique
iterations with a <tt class="monofont">while</tt> loop, but Python also
provides a way to specialize indexing in a <tt claSs="monofont">for</Tt>;
the built-in <tt ClASs="monofont">range</TT> function returns a list of
successively higher integers, which can be used as indexes in a
<tT cLASS="monofont">for</tt>.<foNT SIze="1"><suP><A HRef="#FOOTNOTE-7">[7]</a></sUP></FOnt>
</p>


<blockquote><font sizE="1">
<p ClasS="footnote">
<sUP><a NAmE="FOOTNOTE-7">[7]</a></SUP>
Python also provides a
built-in called <Tt claSS="monofont">xrange</TT> that generates indexes one
at a time instead of storing all of them in a list at once.
There's no speed advantage to <tt clASS="monofont">xrange</Tt>, but
it's useful if you have to generate a huge number of
values.</p>
</foNT></BLockquote>






<h5>3.6.3.1
Examples</h5>


<p>A few examples will make this more concrete. The
<tt class="monofont">range</tt> function is really independent of
<Tt ClasS="monofont">for</tT>
<A nAMe="idx329"></A>loops;
although it's used most often to generate indexes in a
<tT CLAss="monofont">for</tt>, you can use it anywhere you need a list of
integers:</P>



<PRE clasS="monofont">&gt;&gt;&gt; <B>range(5), range(2, 5), range(0, 10, 2)</B>
([0, 1, 2, 3, 4], [2, 3, 4], [0, 2, 4, 6, 8])</Pre>


<p>With one argument, <tT CLAss="monofont">range</tt> generates a list with
integers from zero, up to but not including the argument's
value. If you pass in two arguments, the first is taken as the
<i>lower</i> bound. An optional third argument can give
a <i>step</i>; if used, Python adds the step to each
successive node in the result (steps default to one). Now, the
easiest way to step through a sequence is with a simple
<tt class="monofont">for</tt>; Python handles most of the details for you:</p>



<prE cLass="monofont">&gt;&gt;&gt;<B> X = 'spam'</b>
&gt;&gt;&gt;<B> for item in X: print item,           </B> # simple iteration
...
s p a m
<a NAmE="idx330"></a></PRE>


<P>Internally, the <tt clASS="monofont">for</Tt> initializes an index, detects
the end of the sequence, indexes the sequence to fetch the current
item, and increments the index on each iteration. If you really need
to take over the indexing logic explicitly, you can do it with a
<tt cLASS="monofont">while</tt> loop; this form is as close to a C
<tt CLASs="monofont">for</tt> loop as you can come in Python:</p>



<pre class="monofont">&gt;&gt;&gt;<b> i = 0</b>
&gt;&gt;&gt;<b> while i &lt; len(X):                  </b>   # while iteration
... <b>    print X[i],; i = i+1</b>
...
s p a m</prE>


<p>And finally, you can still do manual indexing with a
<Tt clAsS="monofont">for</Tt>, if you use <TT cLaSS="monofont">range</TT> to
generate a list of indexes to iterate through:</p>



<pre CLASs="monofont">&gt;&gt;&gt;<b> for i in range(len(X)): print X[i],  </b> # manual indexing
...
s p a m</pRE>


<P>But unless you have a special indexing requirement, you're
always better off using the simple <Tt claSS="monofont">for</TT> loop form
in Python. One situation where <tt class="monofont">range</tt> does come in
handy is for repeating an action a specific number of times; for
example, to print three lines, use a <tt class="monofont">range </tt>to
generate the appropriate number of integers:</p>



<pRe ClasS="monofont">&gt;&gt;&gt;<b> for i in range(3): print i, 'Pythons'</B>
...
0 Pythons
1 Pythons
2 Pythons
<A nAMe="idx331"></A>
<a NAME="idx332"></a>
<a naME="idx333"></A></Pre>


</foNT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode37.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode39.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>