<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="6.1 Why Use Classes?"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_cnode63.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode66.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT>
<h3>6.1
Why Use Classes?</h3>


<p>Remember when we told you that programs do things with stuff? In
simple terms, classes are just a way to define new sorts of stuff,
which reflect real objects in your program's domain. For
instance, suppose we've decided to implement that hypothetical
pizza-making robot we used as an example in <a href="lpython_cnode42.html">Chapter 4</a>. If we implement it
using<a naME="idx472"></A> classes, we can model more of its
real-world structure and relationships:</P>



<a namE="idx473"></A><A Name="idx474"></a><dl>
<dt>
<font color="#990000">I<a naMe="idx473"></A>nheritance</fonT></dT>
<Dd>
<P>Pizza-making robots are a kind of robot, and so posses the usual
robot-y properties. In OOP terms, we say they inherit properties from
the general category of all robots. These common properties need be
implemented only once for the general case and reused by all types of
robots we may build in the future.</P>
</dD>
<dT>
<FONt colOR="#990000">C<A Name="idx474"></a>omposition</FONT></dt>
<dd>
<P>Pizza-making robots are really collections of components that work
together as a team. For instance, for our robot to be successful, it
might need arms to roll dough, motors to maneuver to the oven, and so
on. In OOP parlance, our robot is an example of composition; it
contains other objects it activates to do its bidding. Each component
might be coded as a class, which defines its own behavior and
relationships.</P>
</DD>
</dl>


<p>Of course, most of us aren't getting paid to build pizza-making
robots yet, but general OOP ideas like inheritance and composition
apply to any application that can be decomposed into a set of
objects. For example, in typical GUI systems, interfaces are written
as collections of widgets (buttons, labels, and so on), which are all
drawn when their container is (composition). Moreover, we may be able
to write our own custom widgets, which are specialized versions of
more general interface devices (inheritance).</p>



<p>From a more concrete programming perspective, classes are a Python
program unit, just like functions and modules. They are another
compartment for packaging logic and data. In fact, classes also
define a new namespace much like modules. But compared to other
program units we've already seen, classes have three critical
distinctions that make them more useful when it comes to building new
objects:</p>



<dl>
<dt>
<i><font color="#990000">Multiple instances</FoNt></i></dT>
<dD>
<P>Classes are roughly templates for generating one or more objects.
Every time we call a class, we generate a new object, with a distinct
namespace. As we'll see, each object generated from a class has
access to the class's attributes and gets a namespace of its
own for data that varies per object.</p>
</DD>
<dT>
<i><FONT coloR="#990000">Customization via inheritance</FONt></i></dt>
<DD>
<P>Classes also support the OOP notion of inheritance; they are extended
by overriding their attributes outside the class itself. More
generally, classes can build up namespace hierarchies, which define
names to be used by objects created from classes in the hierarchy.</P>
</dd>
<dt>
<I><FONt color="#990000">Operator overloading</font></i></dt>
<dd>
<p>By providing special protocol methods, classes can define objects
that respond to the sorts of operations we saw work on built-in
types. For instance, objects made with classes can be sliced,
concatenated, indexed, and so on. As we'll see, Python provides
hooks classes can use to intercept any built-in type operation.</p>
</dd>
</dL>
</fOnt>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_cnode63.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode66.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>