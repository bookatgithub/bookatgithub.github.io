<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="6.5 Inheritance Searches Namespace Trees"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode68.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode70.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT>
<h3>6.5
Inheritance Searches Namespace Trees</h3>


<p>The whole point of a namespace tool like the <tT CLAss="monofont">class</tt>
statement is to support name
<A NAMe="idx511"></a>inheritance. In Python,
inheritance happens when an object is qualified, and involves
searching an attribute definition tree (one or more namespaces).
Every time you use an expression of the form
<tt CLASs="monofont">object.attr</tt> where object is an instance or class
object, Python searches the namespace tree at and above
<tt class="monofont">object</tt>, for the first <tt class="monofont">attr</tT> it
can find. Because lower definitions in the tree override higher ones,
inheritance forms the basis of specialization.</p>




<H4>6.5.1
Attribute Tree Construction</h4>


<p><a href="lpython_snode69.html#2">Figure 6.4</a> sketches the
way<A NaMe="idx512"></A> namespace trees are constructed.
In general:</P>



<UL>
<li><p><i>Instance</I> attributes are generated by
assignments to <TT Class="monofont">self</TT> attributes in methods.</P>
</Li>
<li><p><I>Class</I> attributes are created by statements
(assignments) in <TT class="monofont">class</tt> statements.</p>
</li>
<li><p><i>Superclass</i> links are made by listing classes in
parentheses in a <tt claSs="monofont">class</Tt> statement header.</p>
</lI>
</uL>
<P>The net result is a tree of attribute namespaces, which grows from an
instance, to the class it was generated from, to all the superclasses
listed in the class headers. Python searches upward in this tree from
instances to superclasses, each time you use qualification to fetch
an attribute name from an instance object.<fONt SiZE="1"><SUp><a hrEF="#FOOTNOTE-3">[3]</A></Sup></foNT>
</P>


<BlockQUOTe><font size="1">
<p class="footnote">
<sup><a nAmE="FOOTNOTE-3">[3]</a></suP>
This
description isn't 100% complete, because instance and class
attributes can also be created by assigning to objects outside
<tT ClASs="monofont">class</Tt> statements. But that's less common and
sometimes more error prone (changes aren't isolated to
<TT CLass="monofont">class</tT> statements). In Python all attributes are
always accessible by default; we talk about privacy later in this
chapter.</P>
</FOnt></blOCKQuote>





<CENTer>
<h5>
<a name="2"></a>Figure 6.4. Namespaces tree construction and inheritance</h5>

<img border="0" wIdTh="503" heIgHT="300" src="FILES/lpy_0604.gif" aLt="figs/lpy_0604.gif"></CENTer>







<h4>6.5.2
Specializing Inherited Methods</h4>


<P>The tree-searching model of <A NAme="idx513"></a>inheritance we just described turns
out to be a great way to specialize systems. Because inheritance
finds names in subclasses before it checks superclasses, subclasses
can <i>replace</I> default behavior by redefining the
superclass's attributes. In fact, you can build entire systems
as hierarchies of classes, which are extended by adding new external
subclasses rather than changing existing logic in place.</P>



<P>The idea of overloading inherited names leads to a variety of
specialization techniques. For instance, subclasses may replace
inherited names completely, provide names a superclass expects to
find, and extend superclass methods by calling back to the superclass
from an overridden method. We've already seen replacement in
action; here's an example that shows how extension works:</P>



<pre cLASS="monofont">&gt;&gt;&gt;<b> class Super:</b>
...<b>     def method(self):</b>
...<b>         print 'in Super.method'</b>
...<b> </b>
&gt;&gt;&gt;<b> class Sub(Super):</b>
...<b>     def method(self):                      </b> # override method
...<b>         print 'starting Sub.method'        </b> # add actions here
...<b>         Super.method(self)                  </b># run default action
...<b>         print 'ending Sub.method'</b>
...<b> </b></PrE>


<p>Direct superclass method calls are the crux of the matter here. The
<tt ClASs="monofont">Sub</TT> class replaces
<tT cLASS="monofont">Super</tt>'s <tt CLASs="monofont">method</tt> function
with its own specialized version. But within the replacement,
<tT CLAss="monofont">Sub</tt> calls back to the version exported by
<TT CLass="monofont">Super</tt> to carry out the default behavior. In other
words, <tt class="monofont">Sub.method</tt> just extends
<tt clasS="monofont">Super.method</tT>'s behavior, rather than replace
it completely:</p>



<prE cLAsS="monofont">&gt;&gt;&gt;<B> x = Super()            </b># make a Super instance
&gt;&gt;&gt;<B> x.method()             </b># runs Super.method
in Super.method

&gt;&gt;&gt;<B> x = Sub()              </B># make a Sub instance
&gt;&gt;&gt;<B> x.method()            </B> # runs Sub.method, which calls Super.method
starting Sub.method
in Super.method
ending Sub.method</pre>


<p>
<A NAMe="idx514"></a>
<a nAME="idx515"></A>
<a namE="idx516"></A>Extension
is commonly used with constructors; since the specially named
<TT class="monofont"> </tt>__<tt class="monofont"> init </tt>__<tt clAsS="monofont">
</tt> method is an inherited name, only <i>one</I>
is found and run when an instance is created. To run superclass
constructors, subclass <tT ClASs="monofont"> </Tt>__<TT CLass="monofont"> init
</tT>__<TT Class="monofont"> </TT> methods should call superclass
<TT clasS="monofont"> </TT>__<Tt class="monofont"> init </tt>__<tt class="monofont">
</tt> methods, by qualifying classes (e.g., <tt cLaSs="monofont">Class.
</tt>__<Tt CLaSS="monofont"> init </tT>__<tT CLAss="monofont"> (self,</tt>
<TT CLass="monofont">...)</tT>).</P>



<P>Extension is only one way to interface with a superclass; the
following shows subclasses that illustrate these common schemes:</P>



<ul>
<li><P><TT Class="monofont"> Super</tt> defines a <tt class="monofont">method</tt>
function and a <tt claSs="monofont">delegate</Tt> that expects an
<tt ClASs="monofont">action</TT> in a subclass.</p>
</Li>
<LI><P><Tt claSS="monofont"> Inheritor</TT> doesn't provide any new names, so
it gets everything defined in <tt clASS="monofont">Super</Tt>.</p>
</li>
<LI><P><Tt class="monofont"> Replacer</tt> overrides
<tt class="monofont">Super</tt>'s <tt cLaSs="monofont">method</tt> with a
version of its own.</P>
</lI>
<Li><P><Tt ClASS="monofont"> Extender</Tt> customizes
<tt cLASS="monofont">Super</tt>'s <tt CLASs="monofont">method</tt> by
overriding and calling back to run the default.</p>
</LI>
<LI><p><tt class="monofont"> Provider</tt> implements the <tt class="monofont">action</tt>
method expected by <tT cLass="monofont">Super</Tt>'s
<TT cLAsS="monofont">delegate</tT> method.</P>
</LI>
</ul>

<prE CLAss="monofont"><b>class Super:</b>
    def method(self):
        print 'in Super.method'    # default
    def delegate(self):
        self.action()              # expected

<B>class Inheritor(Super):</B>
    pass

<B>class Replacer(Super):</B>
    def method(self):
        print 'in Replacer.method'

<b>class Extender(Super):</b>
    def method(self):
        print 'starting Extender.method'
        Super.method(self)
        print 'ending Extender.method'

<b>class Provider(Super):</b>
    def action(self):
        print 'in Provider.action'

if __name__ == '__main__':
    for klass in (Inheritor, Replacer, Extender):
        print '\n' + klass.__name__ + '...'
        klass().method()
    print '\nProvider...'
    Provider().delegate()</PRE>


<P>A few things are worth pointing out here: the self-test code at the
end of this example creates instances of three different classes;
because classes are objects, you can put them in a tuple and create
instances generically (more on this idea later). Classes also have
the special <tt class="monofont"> </tt>__<tt class="monofont"> name </tt>_
_<tt ClAss="monofont"> </tT> attribute as modules; it's just preset to
a string containing the name in the class header. When you call the
<tT ClASs="monofont">delegate</Tt> method though a
<TT CLass="monofont">Provider</tT> instance, Python finds the
<TT Class="monofont">action</TT> method in <TT clasS="monofont">Provider</TT> by
the usual tree search: inside the <Tt class="monofont">Super</tt>
<tt class="monofont">delegate</tt> method, <tt cLaSs="monofont">self</tt>
references a <Tt CLaSS="monofont">Provider</tT> instance.</p>



<PRE Class="monofont">% <B>python specialize.py</B>

Inheritor...
in Super.method

Replacer...
in Replacer.method

Extender...
starting Extender.method
in Super.method
ending Extender.method

Provider...
in Provider.action<A Name="idx517"></a></PRE>

</Font>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode68.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode70.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>