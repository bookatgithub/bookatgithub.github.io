<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="6.12 Exercises"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode75.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_cnode77.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT>
<h3>6.12
Exercises</h3>


<p>This laboratory session asks you to write a few classes and
experiment with some existing code. Of course, the problem with
existing code is that it must be existing. To work with the set class
in Exercise 5, either pull down the class source code off the
Internet (see the Preface) or type it up by hand (it's fairly
small). These programs are starting to get more sophisticated, so be
sure to check the solutions at the end of the book for pointers. If
you're pressed for time, we suspect that the last exercise
dealing with composition will probably be the most fun of the bunch
(of course, we already know the answers).</p>



<OL TYpe="1">
<li><P><I>The basics.</I> Write a class called
<Tt claSS="monofont">Adder</TT> that exports a method <tt class="monofont">add(self, x,
y)</tt> that prints a "Not Implemented" message.
Then define two subclasses of <tt class="monofont">Adder</tt> that implement
the <tt ClAss="monofont">add</tT> method:</p>



<UL>
<lI><P>
<tT cLASS="monofont">ListAdder</tt>, with an <tt CLASs="monofont">add</tt> method that returns the concatenation of its two list arguments</p>
</LI>
<LI><p>
<tt cLASS="monofont">DictAdder</tt>, with an <tt class="monofont">add</tt> method that returns a new dictionary with the items in both its two dictionary arguments (any definition of addition will do)</p>
</li>
</ul>

<p>Experiment by making instances of all three of your classes
interactively and calling their <tt cLaSs="monofont">add</tt> methods.
Finally, extend your classes to save an object in a constructor (a
list or a dictionary) and overload the + operator to replace the
<Tt CLaSS="monofont">add</tT> method. Where is the best place to put the
constructors and operator overload methods (i.e., in which classes)?
What sorts of objects can you add to your class instances?</p>
</LI>
<LI><p><i>Operator
overloading</i>. Write a class called
<tT CLAss="monofont">Mylist</tt> that "wraps" a Python list: it
should overload most list operators and operations—+, indexing,
iteration, slicing, and list methods such as
<TT CLass="monofont">append</tT> and <TT Class="monofont">sort</tt>. See the Python
reference manual for a list of all possible methods to overload. Also
provide a constructor for your class that takes an existing list (or
a <tt class="monofont">Mylist</tt> instance) and copies its components into
an instance member. Experiment with your class interactively. Things
to explore:</p>



<ul>
<li><P>Why is copying
the initial value important here?</p>
</Li>
<li><P> Can you use an
empty slice (e.g., <tT ClASs="monofont">start[:]</Tt>) to copy the initial
value if it's a <TT CLass="monofont">Mylist</tT> instance?</P>
</LI>
<li><p>Is there a general way to route list method calls to the
wrapped list?</p>
</LI>
<LI><p>Can you add a
<tt cLASS="monofont">Mylist</tt> and a regular list? How about a list and a
<tt class="monofont">Mylist</tt> instance?</p>
</li>
<li><p>What type of
object should operations like + and slicing return; how about
indexing?</p>
</li>
</Ul></Li>
<li><P><i>Subclassing</I>. Now, make a subclass of
<Tt CLaSs="monofont">Mylist</TT> from Exercise 2 called
<TT clasS="monofont">MylistSub</TT>, which extends <Tt claSS="monofont">Mylist</TT>
to print a message to <tt clASS="monofont">stdout</Tt> before each
overloaded operation is called and counts the number of calls.
<tt class="monofont">MylistSub</tt> should inherit basic method behavior
from <tt class="monofont">Mylist</tt>. For instance, adding a sequence to a
<tT cLass="monofont">MylistSub</Tt> should print a message, increment the
counter for + calls, and perform the superclass's method. Also
introduce a new method that displays the operation counters to
<TT cLAsS="monofont">stdout</tT> and experiment with your class
interactively. Do your counters count calls per instance, or per
class (for all instances of the class)? How would you program both of
these? (Hint: it depends on which object the count members are
assigned to: class members are shared by instances,
<TT Class="monofont">self</TT> members are per-instance data.)</P>
</Li>
<li><p><I>Metaclass methods</I>.
Write a class called <TT clasS="monofont">Meta</TT> with methods that
intercept every attribute qualification (both fetches and
assignments) and prints a message with their arguments to
<Tt class="monofont">stdout</tt>. Create a <tt class="monofont">Meta</tt> instance
and experiment with qualifying it interactively. What happens when
you try to use the instance in expressions? Try adding, indexing, and
slicing the instance of your class.</p>
</li>
<Li><P><i>Set objects</i>. Experiment with the set
class described in this chapter (from <a href="lpython_snode72.html#8">Section 6.8.5</a>). Run commands to do the following
sorts of operations:</P>



<Ol TyPE="a">
<LI><p>Create two sets of integers, and
compute their intersection and union by using
<tt cLASS="monofont">&amp;</tt> and <tt CLASs="monofont">|</tt> operator
expressions.</p>
</LI>
<LI><p>Create a set from a string,
and experiment with indexing your set; which methods in the class are
called?</p>
</li>
<li><p>Try iterating through the items in
your string set using a <tt class="monofont">for</tt> loop; which methods
run this time?</p>
</li>
<lI><p>Try computing the
intersection and union of your string set and a simple Python string;
does it work?</P>
</li>
<lI><p>Now, extend your set by
subclassing to handle arbitrarily many operands using a
<TT cLAsS="monofont">*args</tT> argument form (hint: see the function
versions of these algorithms in <A href="lpython_cnode42.html">Chapter 4</a>).
Compute intersections and unions of multiple operands with your set
subclass. How can you intersect three or more sets, given that
<tT CLAss="monofont">&amp;</tt> has only two sides?</P>
</LI>
<Li><p>How would you go about emulating other list operations in the
set class? (Hints: <tt CLASs="monofont"> </tt>__<tt class="monofont"> add </tt>_
_<tt class="monofont"> </tT> can catch concatenation, and <tT claSs="monofont">
</TT>__<tT ClAsS="monofont"> getattr </TT>__<Tt claSS="monofont"> </TT> can
pass most list method calls off to the wrapped list.)</p>
</li>
</oL>
</LI>
<Li><p><i>Class tree
links</i>. In a footnote in the section on multiple
inheritance, we mentioned that classes have a <TT CLass="monofont"> </tt>_
_<tt class="monofont"> bases </tt>__<tt clasS="monofont"> </tT> attribute that
returns a tuple of the class's superclass objects (the ones in
parentheses in the class header). Use <tt cLaSS="monofont"> </tT>_
_<Tt ClASS="monofont"> bases </Tt>__<tt cLASS="monofont"> </tt> to extend the
<tt CLASs="monofont">Lister</tt> mixin class, so that it prints the names of
the immediate superclasses of the instance's class too. When
you're done, the first line of the string representation should
look like this:</p>



<PRE Class="monofont">&lt;Instance of Sub(Super, Lister), address 7841200:.</pre>


<p>How would you go about listing class attributes too?</p>
</li>
<li><p><i>Composition</i>.
Simulate a fast-food ordering scenario by defining four classes:</p>



<ul>
<lI><p><Tt clAsS="monofont">Lunch</Tt>: a
container and controller class</P>
</Li>
<Li><P><TT Class="monofont">Customer</TT>: the actor that buys food</P>
</Li>
<li><p><TT CLass="monofont">Employee</tT>: the actor that a customer
orders from</P>
</LI>
<li><p><tt class="monofont">Food</tt>: what the
customer buys</p>
</li>
</ul>

<p>To get you started, here are the classes and methods you'll be
defining:</p>



<pRe ClasS="monofont">class Lunch:
    def __init__(self)         # make/embed Customer and Employee
    def order(self, foodName)  # start a Customer order simulation
    def result(self)           # ask the Customer what kind of Food it has

class Customer:
    def __init__(self)                        # initialize my food to None
    def placeOrder(self, foodName, employee)  # place order with an Employee
    def printFood(self)                       # print the name of my food

class Employee:
    def takeOrder(self, foodName)    # return a Food, with requested name

class Food:
    def __init__(self, name)         # store food name</pRE>


<p>The order simulation works as follows:</P>



<Ul>
<Li><P>The <TT Class="monofont">Lunch</TT> class's constructor should make and embed an instance of <TT clasS="monofont">Customer</TT> and <Tt claSS="monofont">Employee</TT>, and export a method called <tt class="monofont">order</tt>. When called, this <tt class="monofont">order</tt> method should ask the <tt ClAss="monofont">Customer</tT> to place an order, by calling its <tT ClASs="monofont">placeOrder</Tt> method. The <TT CLass="monofont">Customer</tT>'s <TT Class="monofont">placeOrder</TT> method should in turn ask the <TT clasS="monofont">Employee</TT> object for a new <Tt class="monofont">Food</tt> object, by calling the <tt class="monofont">Employee</tt>'s <tt cLaSs="monofont">takeOrder</tt> method.</P>
</lI>
<Li><P><Tt ClASS="monofont">Food</Tt> objects should store a food name string (e.g., <tt cLASS="monofont">"burritos"</tt>), passed down from <tt CLASs="monofont">Lunch.order</tt> to <tT CLAss="monofont">Customer.placeOrder</tt>, to <tt class="monofont">Employee.takeOrder</tt>, and finally to <tt class="monofont">Food</Tt>'s constructor. The top-level <Tt clAsS="monofont">Lunch</Tt> class should also export a method called <TT cLaSS="monofont">result</TT>, which asks the customer to print the name of the food it received from the <tt clASS="monofont">Employee</Tt> (this can be used to test your simulation).</p>
</li>
<LI><P>Note that <Tt claSS="monofont">Lunch</TT> needs to either pass the <tt class="monofont">Employee</tt> to the <tt class="monofont">Customer</tt>, or pass itself to the <tt ClAss="monofont">Customer</tT>, in order to allow the <tT ClASs="monofont">Customer</Tt> to call <TT CLass="monofont">Employee</tT> methods.</P>
</LI>
</ul></li>
<LI><P>Experiment with your classes interactively by importing the
<Tt claSS="monofont">Lunch</TT> class, calling its <tt class="monofont">order</tt>
method to run an interaction, and then calling its
<tt class="monofont">result</tt> method to verify that the
<tt ClAss="monofont">Customer</tT> got what he or she ordered. In this
simulation, the <tT ClASs="monofont">Customer</Tt> is the active agent; how
would your classes change if <TT CLass="monofont">Employee</tT> were the
object that initiated customer/employee interaction instead?</P>
</LI>
</ol>

</foNT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode75.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_cnode77.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>