<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="8.3 Library Modules"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode92.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode94.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT>
<h3>8.3
Library Modules</h3>


<p>Currently, there are more than 200 <a NAME="idx698"></a> <a naME="idx699"></A> <A name="idx700"></A>modules
in the standard distribution, covering topics such as string and text
processing, networking and web tools, system interfaces, database
interfaces, serialization, data structures and algorithms, user
interfaces, numerical computing, and others. We touch on only the
most widely used here and mention some of the more powerful and
specialized ones in <A href="lpython_cnode95.html">Chapter 9</a>, and <a href="lpython_cnode103.html">Chapter 10</a>.</p>




<h4>8.3.1
Basic String Operations: The string Module</h4>


<p>The<a name="idx701"></a>
<a NaMe="idx702"></a> <tT cLAsS="monofont">string</Tt> module is
somewhat of a historical anomaly. If Python were being designed
today, chances are many functions currently in the
<Tt CLASs="monofont">string</tt> module would be implemented instead as
methods of string objects<i>.<FONT size="1"><SUP><A href="#FOOTNOTE-4">[4]</A></SUP></font>
</i> The
<tt class="monofont">string</tt> module operates on strings. <a href="lpython_snode93.html#2">Table 8.4</a> lists the most useful functions defined in the
<Tt ClasS="monofont">string</tT> module, along with brief descriptions, just
to give you an idea as to the module's purpose. The
descriptions given here are not complete; for an exhaustive listing,
check the <I>Library Reference</i> or the
<I>Python Pocket Reference</I>. Except when otherwise
noted, each function returns a string.</p>


<BlOCKQuote><FONT size="1">
<P CLAss="footnote">
<suP><A NAme="FOOTNOTE-4">[4]</a></sup>
For a more
detailed discussion of this and of many other commonly asked
questions about Python, check out the FAQ list at <a target="_blank" href="http://www.python.org/doc/FAQ.html">http://www.python.org/doc/FAQ.html</a>. For the
question of string methods versus string functions, see Question 6.4
in that document.</p>
</fOnT></bloCkQUoTE>





<a NaME="2"></A><P><tablE BORder="1" cELLSpaciNG="0" CEllpadding="1" width="100%">
<captioN><h5>Table 8.4. String Module Functions </H5></capTiON><cOLgRoUP SPan="2">
<tr>
<TH>
<FOnt siZE="2">
<P>Function Name</P>
</font></TH>
<TH>
<font size="2">
<p>Behavior</p>
</font></th>
</tr>
<tr>
<Td>
<Font SiZE="2">
<pRE cLaSS="monofont">atof(<TT clasS="monofont"><I>string</I></Tt>)</pre></FONT></td>
<td>
<FONT size="2">
<p>Converts a string to a floating point number (see the
<tt class="monofont">float</tt> built-in):</p>



<pre clAsS="monofont">&gt;&gt;&gt; <b>string.atof("1.4")</b>
 1.4</pRe></FOnT></Td>
</Tr>
<TR>
<TD>
<font SIZE="2">
<pre cLASS="monofont">atoi(<tt clASS="monofont"><I>string</i></tt> [, <tt class="monofont"><i>base</i></tt>])</pre></fonT></tD>
<td>
<fOnT SiZE="2">
<p>Converts a string to an integer, using the base specified (base 10 by
default (see the <Tt CLASs="monofont">int</tt> built-in):</p>



<PRE Class="monofont">&gt;&gt;&gt; <B>string.atoi("365")</B>
 365</PRe></fonT></TD>
</Tr>
<tr>
<td>
<font size="2">
<pre clasS="monofont">atol(<tT claSs="monofont"><I>string</I></tT> [, <Tt ClASS="monofont"><I>base</i></tt>])</pRE></FOnt></td>
<TD>
<FOnt siZE="2">
<P>Same as <Tt class="monofont">atoi</tt>, except converts to a long integer
(see the <tt class="monofont">long</tt> built-in):</p>



<prE cLass="monofont">&gt;&gt;&gt; <B>string.atol("987654321")</b>
 987654321L</PRe></FOnT></tD>
</TR>
<Tr>
<td>
<fONT Size="2">
<pRE CLass="monofont">capitalize(<tT CLAss="monofont"><i>word</i></tt>)</pre></font></td>
<td>
<fonT sIze="2">
<p>Capitalizes the first letter of <Tt CLaSS="monofont"><i>word</I></tT>:</P>



<PRe claSS="monofont">&gt;&gt;&gt; <B>string.capitalize("tomato")</B>
 'Tomato'</pre></fONT></Td>
</tr>
<tR>
<TD>
<Font size="2">
<pre class="monofont">capwords(<tt claSs="monofont"><I>string</i></tt>)</PrE></FoNT></tD>
<tD>
<FONt sizE="2">
<P>Capitalizes each word in the <TT clasS="monofont"><I>string</I></Tt>:</p>



<prE CLAss="monofont">&gt;&gt;&gt; <b>string.capwords("now is the time")</b>
 'Now Is The Time'</pre></font></td>
</tr>
<tr>
<td>
<fOnT sizE="2">
<pRE cLAsS="monofont">expandtabs(<tT CLAss="monofont"><i> string</i></TT>, <TT clasS="monofont"><I>tabsize</I></Tt>)</pre></FONT></td>
<td>
<font size="2">
<p>Expands the tab characters in <tt class="monofont"><I>string</i></Tt>,
using the specified tab size (no default)</p>
</fOnT></Td>
</TR>
<tR>
<tD>
<FONt sizE="2">
<PRE clasS="monofont">find(<TT Class="monofont"><I>s</I></TT>, <tt class="monofont"><i>sub</i></tt> [, <tt class="monofont"><i>start</i></Tt> [, <Tt clAsS="monofont"><I>end</i></TT>]])</pRe></FONT></td>
<td>
<FONT size="2">
<P>Returns the index of the string <TT Class="monofont"><I>s</I></TT>
corresponding to the first occurrence of the substring
<tt class="monofont"><i>sub</i></tt> in <tt class="monofont"><i>s</i></Tt>, or -1
if <Tt clAsS="monofont"><I>sub</i></TT> isn't in
<tT cLASS="monofont"><i>s</i></tt>:</P>



<PRE clasS="monofont">&gt;&gt;&gt; <B>string.find("now is the time", 'is')</B>
 4</Pre></foNT></TD>
</tr>
<tr>
<td>
<font size="2">
<pre claSs="monofont">rfind(<Tt clAsS="monofont"><I>s</i></TT>, <tT cLASS="monofont"><i>sub</i></tt> [, <TT CLass="monofont"><i>start</I></TT> [, <Tt claSS="monofont"><I>end</I></tt>]])</pre></font></td>
<td>
<font sizE="2">
<p>Same as <Tt clAsS="monofont">find</Tt>, but gives the index of the last
occurrence of <TT cLaSS="monofont"><I>sub</I></tt> in
<tt CLASs="monofont"><i>s</i></tT></P>
</FOnt></td>
</TR>
<TR>
<td>
<font size="2">
<pre class="monofont">index(<tt ClAss="monofont"><i>s</I></tT>, <Tt CLaSs="monofont"><I>sub</I></TT> [, <tt clASS="monofont"><I>start</i></tt> [, <tT CLAss="monofont"><i>end</i></TT>]])</PRe></font></td>
<td>
<font size="2">
<p>Same as <tt ClAss="monofont">find</tT>, but raises a <tT ClASs="monofont">ValueError
</Tt>exception if <TT CLass="monofont"><i>sub</I></TT> isn't
found in <Tt claSS="monofont"><I>s</I></tt></p>
</fONT></Td>
</tr>
<tr>
<td>
<font size="2">
<pre clAsS="monofont">rindex(<tt cLaSS="monofont"><i>s</I></Tt>, <Tt CLASs="monofont"><i>sub</i></tT>[, <TT Class="monofont"><I>start</I></TT> [, <tt clASS="monofont"><I>end</i></tt>]])</pre></font></td>
<td>
<font siZe="2">
<P>Same as <tt cLaSS="monofont">rfind</tT>, but raises a
<Tt ClASS="monofont">ValueError</Tt> exception if
<tt cLASS="monofont"><i>sub</i></tt> is not found in
<TT CLass="monofont"><i>s</I></TT></P>
</font></td>
</tr>
<tr>
<td>
<font size="2">
<PrE claSs="monofont">count(<TT cLAsS="monofont"><i>s</I></TT>, <Tt claSS="monofont"><I>sub</I></tt>[, <tt CLASs="monofont"><i>start</i></tT> [, <TT Class="monofont"><i>end</i></tt>]])</pre></font></td>
<td>
<fOnT sizE="2">
<p>Returns the number of occurrences of <TT cLAsS="monofont"><i>sub</I></TT>
in <Tt claSS="monofont"><I>s</I></tt>:</p>



<pRE CLass="monofont">&gt;&gt;&gt; <b>string.count("now is the time", 'i')</B>
 2</PRE></font></td>
</tr>
<tr>
<td>
<font size="2">
<PrE claSs="monofont">replace(<TT cLAsS="monofont"><i>str</I></TT>, <Tt claSS="monofont"><I>old</I></tt>, new[, <tt CLASs="monofont"><i>maxsplit</i></tT>])</PRE></font></td>
<td>
<font size="2">
<p>Returns a string like <tt cLaSs="monofont"><i>str</i></Tt> except that all
(or some) occurrences of <TT cLAsS="monofont"><i>old</I></TT> have been
replaced with <Tt claSS="monofont"><I>new</I></tt>:</p>



<pRE CLass="monofont">&gt;&gt;&gt; <b>string.replace("now is the time", ' ', '_')</B>
 'now_is_the_time'</PRE></font></td>
</tr>
<tr>
<td>
<font size="2">
<PrE claSs="monofont">lower(<TT cLAsS="monofont"><i>string</I></TT>), upper(<Tt claSS="monofont"><I>string</I></tt>)</prE></FONt></td>
<tD>
<FONt size="2">
<p>Returns a lowercase (or uppercase) version of
<tt class="monofont"><i>string</i></tt></p>
</foNt></Td>
</tr>
<Tr>
<TD>
<fONt SiZE="2">
<PRe claSS="monofont">split(<TT clasS="monofont"><I>s</I></Tt> [, <tt cLASS="monofont"><i>sep</i></tt>[, <tt class="monofont"><i>maxsplit</i></tt>]])</pre></foNt></Td>
<td>
<FoNT sIZe="2">
<P>Splits the string <tT CLAss="monofont"><i>s</i></TT> at the specified
separator string <TT clasS="monofont"><I>sep</I></Tt> (whitespace by
default), and returns a list of the "split" substrings:</p>



<prE CLAss="monofont">&gt;&gt;&gt; <b>string.split("now is the time")</b>
 ['now', 'is', 'the', 'time']</pre></font></td>
</tr>
<tr>
<td>
<fOnT sizE="2">
<pRE cLAsS="monofont">join(<tT CLAss="monofont"><i>wordlist</i></TT>[, <TT clasS="monofont"><I>sep</I></Tt>[, <tt cLASS="monofont"><i>maxsplit</i></tt>]])</pre></font></td>
<td>
<font sIzE="2">
<p>Joins a sequence of strings, inserting copies of
<tt ClASs="monofont"><I>sep</I></tT> between each (a single space by
default):</p>



<PRE Class="monofont">&gt;&gt;&gt; <B>string.join(["now","is","the","time", '*'])</B>
 'now*is*the*time'
 &gt;&gt;&gt; <B>string.join("now is the time", '*')</B>
 'n*o*w* *i*s* *t*h*e* *t*i*m*e'</pre>


<p>Remember that a string is itself a sequence of one-character strings!</P>
</FONt></td>
</tR>
<TR>
<Td>
<font size="2">
<pre class="monofont">lstrip(<tt cLaSs="monofont"><i>s</i></Tt>), rstrip(<TT cLAsS="monofont"><i>s</I></TT>), strip(<Tt claSS="monofont"><I>s</I></tt>)</prE></FONt></td>
<tD>
<FONt size="2">
<p>Strips whitespace occurring at the left, right, or both ends of
<tt class="monofont"><i>s</i></tt>:</p>



<prE cLass="monofont">&gt;&gt;&gt; <B>string.strip("  before  and  after   ")</b>
 'before and after'</PRe></FOnT></tD>
</TR>
<Tr>
<td>
<fONT Size="2">
<pRE CLass="monofont">swapcase(<tT CLAss="monofont"><i>s</i></tt>)</pre></font></td>
<td>
<fonT sIze="2">
<p>Returns a version of <Tt CLaSS="monofont"><i>s</I></tT> with the lowercase
letters replaced with their uppercase equivalent and vice versa</P>
</FOnt></td>
</TR>
<TR>
<td>
<foNT SIze="2">
<prE CLAss="monofont">ljust(<tt class="monofont"><i>s</i></tt>, <tt class="monofont"><I>width</i></Tt>), rjust(<tt ClASs="monofont"><I>s</I></tT>, <tT CLAss="monofont"><i>width</i></TT>),
center(<TT clasS="monofont"><I>s</I></Tt>, <tt cLASS="monofont"><i>width</i></tt>)</pre></font></td>
<td>
<font sIzE="2">
<p>Left-pads, right-pads, or centers the string
<tt ClASs="monofont"><I>s</I></tT> with spaces so that the returned string
has <tT CLAss="monofont"><i>width</i></TT> characters</P>
</Font></tD>
</TR>
</ColgrOUP>
</Table></p>



<p>The <a name="idx703"></a>
<a name="idx704"></a>string module also defines a few
useful constants, as shown in <a href="lpython_snode93.html#3">Table 8.5</a>.</p>



<a NaME="3"></a><P><TaBlE BORder="1" cELLSpaciNG="0" CEllpaDDINg="1" width="100%">
<caption><h5>Table 8.5. String Module Constants </h5></captiOn><ColgRoUP sPAn="2">
<Tr>
<TH>
<FOnt siZE="2">
<P>Constant Name</P>
</font></TH>
<TH>
<font SIZE="2">
<p>Value</p>
</font></th>
</tr>
<tr>
<td>
<font siZe="2">
<P><tt cLaSS="monofont">digits</tT></P>
</fOnT></TD>
<Td>
<fonT SIZe="2">
<p><tt CLASs="monofont">'0123456789'</tt></p>
</FONT></td>
</tr>
<tr>
<td>
<font size="2">
<p><tt cLaSs="monofont">octdigits</tt></P>
</fONt></TD>
<tD>
<fONT Size="2">
<p><TT CLass="monofont">'01234567'</tT></P>
</FOnt></td>
</TR>
<TR>
<td>
<font size="2">
<p><tt class="monofont">hexdigits</tt></P>
</fOnt></tD>
<tD>
<FoNT sIzE="2">
<P><TT clasS="monofont">'0123456789abcdefABCDEF'</TT></P>
</font></TD>
</TR>
<tr>
<td>
<FONT size="2">
<p><tt class="monofont">lowercase</tt></p>
</font></tD>
<tD>
<fonT sIZe="2">
<P><Tt ClASS="monofont">'abcdefghijklmnopqrstuvwxyz'</Tt>
<fonT SIZe="1"><sup><A HREf="#FOOTNOTE-5">[5]</a></suP></FONt>
</p>
</font></td>
</tr>
<tr>
<td>
<font siZe="2">
<P><tt cLaSS="monofont">uppercase</tT></P>
</fOnT></TD>
<Td>
<fonT SIZe="2">
<p><tt CLASs="monofont">'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</tt></p>
</FONT></td>
</tr>
<tr>
<td>
<font size="2">
<p><tt cLaSs="monofont">letters</tt></P>
</fONt></TD>
<tD>
<fONT Size="2">
<p><TT CLass="monofont">lowercase + uppercase</tT></P>
</FOnt></td>
</TR>
<TR>
<td>
<font size="2">
<p><tt class="monofont">whitespace</tt></P>
</fOnt></tD>
<tD>
<FoNT sIzE="2">
<P><TT clasS="monofont">' \t\n\r\v' </TT>(all whitespace characters)</P>
</font></TD>
</TR>
</colgROUP>
</table></p>


<blockquote><font SiZe="1">
<p cLaSS="footnote">
<sUP><a NaME="FOOTNOTE-5">[5]</A></Sup>
On
most systems, the <tt CLASs="monofont">string.lowercase</tt>,
<tT CLAss="monofont">string.uppercase</tt>, and
<TT CLass="monofont">string.letters</tt> have the values listed above. If
one uses the <tt class="monofont">locale</tt> module to specify a different
cultural locale, they are updated. Thus for example, after doing
<tt clasS="monofont">locale.setlocale(locale.LC_ALL, 'fr')</tT>, the
<tt cLaSS="monofont">string.letters</tT> attribute will also include
accented letters and other valid French letters.</P>
</fOnT></BLOckquOTE>





<P>The constants in <a href="lpython_snode93.html#3">Table 8.5</A><A href="lpython_snode93.html#3">Table 8.5</a> generally test whether specific characters fit
a criterionfor example, <TT CLass="monofont">x in
string.whitespace</tt> returns true only if <tt class="monofont">x</tt>
is one of the whitespace characters.</p>



<p>A typical use of the <tt clAsS="monofont">string</tt> module is to clean up
user input. The following line removes all "extra"
whitespace, meaning it replaces sequences of whitespace with single
space characters, and it deletes leading and trailing spaces:</p>



<PrE ClASs="monofont">thestring = string.strip(string.join(string.split(thestring)))</PrE>






<H4>8.3.2
Advanced String Operations: The re Module</H4>


<P>The <tt clASS="monofont">string</Tt>
<a naME="idx705"></A> <A name="idx706"></A>
<A NAme="idx707"></a> module defines basic operations on
strings. It shows up in almost all programs that interact with files
or users. Because Python strings can contain null bytes, they can
also process binary datamore on this when we get to the
<tt class="monofont">struct</tt> module.</p>



<p>In addition, Python provides a specialized string-processing tool to
use with regular expressions. For a long time, Python's regular
expressions (available in the <tt clasS="monofont">regex</tT> and
<tt cLaSS="monofont">regsub</tT> modules), while adequate for some tasks,
were not up to par with those offered by competing languages, such as
Perl. As of Python 1.5, a new module called <Tt ClASS="monofont">re</Tt>
provides a completely overhauled regular expression package, which
significantly enhances Python's string-processing abilities.</p>




<h5>8.3.2.1
Regular expressions</h5>


<P>Regular expressions are strings that let you define complicated
pattern matching and replacement rules for strings. These strings are
made up of symbols that emphasize compact notation over mnemonic
value. For example, the single character <TT Class="monofont">.</TT> means
"match any single character." The character
<TT clasS="monofont">+</TT> means "one or more of what just preceded
me." <A href="lpython_snode93.html#8">Table 8.6</a> lists some of the most
commonly used regular expression symbols and their meanings in
English.</p>



<a name="8"></a><p><table boRdEr="1" ceLlSPaCInG="0" cELLPaddiNG="1" WIdth="100%">
<cAPTIon><h5>Table 8.6. Common Elements of Regular Expression Syntax </h5></CAPTion><colgroup span="2">
<tr>
<th>
<fOnT sizE="2">
<p>Special Character</P>
</FoNT></tH>
<tH>
<FONt sizE="2">
<P>Meaning</P>
</Font></tH>
</TR>
<Tr>
<td>
<fONT Size="2">
<p><tt class="monofont">.</tt></p>
</font></td>
<Td>
<Font SiZE="2">
<p>Matches any character except newline by default</P>
</FoNt></TD>
</TR>
<tr>
<td>
<FONT size="2">
<P><TT Class="monofont">^</TT></P>
</Font></td>
<td>
<font size="2">
<p>Matches the start of the string</p>
</fonT></tD>
</tr>
<tR>
<tD>
<FoNT sIzE="2">
<P><TT clasS="monofont">$</TT></P>
</font></TD>
<TD>
<font SIZE="2">
<p>Matches the end of the string</p>
</font></td>
</tr>
<tr>
<td>
<font siZe="2">
<P><tt cLaSS="monofont">*</tT></P>
</fOnT></TD>
<Td>
<fonT SIZe="2">
<p>"Any number of occurrences of what just preceded me"</p>
</fONT></Td>
</tr>
<tR>
<TD>
<Font size="2">
<p><tt class="monofont">+</tt></p>
</foNt></Td>
<td>
<FoNT sIZe="2">
<P>"One or more occurrences of what just preceded me"</p>
</FONT></td>
</tr>
<TR>
<TD>
<font SIZE="2">
<p><tt cLASS="monofont">|</tt></p>
</font></td>
<td>
<font size="2">
<p>"Either the thing before me or the thing after me"</P>
</fOnt></tD>
</tR>
<Tr>
<TD>
<fOnT SIZe="2">
<p><tt CLASs="monofont">\w</tt></p>
</FONT></td>
<td>
<FONT size="2">
<p>Matches any alphanumeric character</p>
</font></td>
</tr>
<tr>
<td>
<foNt Size="2">
<P><tT ClASs="monofont">\d</Tt></P>
</FONt></td>
<tD>
<FONt sizE="2">
<P>Matches any decimal digit</P>
</Font></tD>
</TR>
<Tr>
<td>
<font size="2">
<p><tt class="monofont">tomato</tT></p>
</Font></Td>
<TD>
<fONt SiZE="2">
<P>Matches the string <Tt claSS="monofont">tomato</TT></p>
</fonT></TD>
</Tr>
</colGROUp>
</table></p>






<a name="idx778"></a><h5>8.3.2.2
A real regular expression problem</h5>


<p>Suppose you need to write a program to replace the strings
"green pepper" and "red pepper" with
"bell pepper" if and only if they occur together in a
paragraph before the word "salad" and not if they are
followed (with no space) by the string "corn." These
kinds of requirements are surprisingly common in computing. Assume
that the file you need to process is called
<i>pepper.txt</i>. Here's a silly example of such
a file:</p>



<pRe ClasS="monofont">This is a paragraph that mentions bell peppers multiple times. For
one, here is a red pepper and dried tomato salad recipe. I don't like
to use green peppers in my salads as much because they have a harsher
flavor.

This second paragraph mentions red peppers and green peppers but not
the "s" word (s-a-l-a-d), so no bells should show up.

This third paragraph mentions red peppercorns and green peppercorns,
which aren't vegetables but spices (by the way, bell peppers really
aren't peppers, they're chilies, but would you rather have a good cook
or a good botanist prepare your salad?).</pRE>


<p>The first task is to open it and read in the text:</P>



<PrE cLASS="monofont">file = open('pepper.txt')
text = file.read()</pre>


<p>We read the entire text at once and avoid splitting it into lines,
since we will assume that paragraphs are defined by two consecutive
newline characters. This is easy to do using the
<TT CLass="monofont">split</tT> function of the <TT Class="monofont">string</TT>
module:</P>



<Pre class="monofont">import string
paragraphs = string.split(text, '\n\n')</pre>


<p>At this point we've split the text into a list of paragraph
strings, and all there is left is to do is perform the actual
replacement operation. Here's where regular expressions come
in:</p>



<pre class="monofont">import re<I> 
<pRe clAsS="monofont"><B>matchstr = re.compile(</b></PRe>
</I>
   <b> r"""\b(red|green)  </B>     # 'red' or 'green' starting new words
        <B>(\s+  </B>              # followed by whitespace
        <B> pepper  </b>           # the word 'pepper'
        <b> (?!corn)  </b>         # if not followed immediately by 'corn'
        <b> (?=.*salad))""", </B>  # and if followed at some point by 'salad'',
   <B>   re.IGNORECASE | </B>      # allow pepper, Pepper, PEPPER, etc.
     <B> re.DOTALL | </b>          # allow to match newlines as well
      <b>re.VERBOSE) </b>          # this allows the comments and the newlines above
for paragraph in paragraphs:
    fixed_paragraph = matchstr.sub(r'bell\2', paragraph)
    print fixed_paragraph+'\n'</pRE>


<P>The bold line is the hardest one; it creates a compiled regular
expression pattern, which is like a program. Such a pattern specifies
two things: which parts of the strings we're interested in and
how they should be grouped. Let's go over these in turn.</P>



<p>Defining which parts of the<a naME="idx708"></A>
string we're interested in is done by specifying a pattern of
characters that defines a match. This is done by concatenating
smaller patterns, each of which specifies a simple matching criterion
(e.g., "match the string <Tt class="monofont">'pepper'</tt>,"
"match one or more whitespace characters,"
"don't match <tt class="monofont">'corn'</tt>," etc.). As
mentioned, we're looking for the words <tt cLaSs="monofont">red</tt>
or <Tt CLaSS="monofont">green</tT>, if they're followed by the word
<tT CLAss="monofont">pepper</tt>, that is itself followed by the word
<TT CLass="monofont">salad</tT>, as long as <TT Class="monofont">pepper</TT>
isn't followed immediately by <TT class="monofont">'corn'</tt>.
Let's take each line of the <tt class="monofont">re.compile(...)</tt>
expression in turn.</p>



<p>The first thing to notice about the string in the
<tt ClAss="monofont">re.compile()</tT>
<a NAmE="idx709"></A> is that it's a
"raw" string (the quotation marks are preceded by an
<tT cLASS="monofont">r)</tt>. Prepending such an <tt CLASs="monofont">r</tt> to a
string (single- or triple-quoted) turns off the interpretation of the
backslash characters within the string.<fONT Size="1"><sUP><A Href="#FOOTNOTE-6">[6]</a></sup></font>
 We could have used a regular
string instead and used <tt class="monofont">\\b</tt> instead of
<Tt ClasS="monofont">\b</tT> and <Tt CLaSs="monofont">\\s</TT> instead of
<TT clasS="monofont">\s</TT>. In this case, it makes little difference; for
complicated regular expressions, raw strings allow much more clear
syntax than escaped backslashes.</P>


<blocKQUOte><foNT SIze="1">
<p class="footnote">
<sup><a name="FOOTNOTE-6">[6]</a></sup>
Raw strings
can't end with an odd number of backslash characters.
That's unlikely to be a problem when using raw strings for
regular expressions, however, since regular expressions can't
end with backslashes.</P>
</fOnt></bLoCKqUOtE>





<p>The first line in the pattern is <TT CLass="monofont">\b(red|green)</tT>.
<TT Class="monofont">\b</TT> stands for "the empty string, but only at
the beginning or end of a word"; using it here prevents matches
that have <TT clasS="monofont">red</TT> or <Tt class="monofont">green</tt> as the
final part of a word (as in "tired pepper"). The
<tt class="monofont">(red|green)</tt> pattern specifies an
alternation<i>:</i> either <tT cLass="monofont">'red'</Tt> or
<TT cLAsS="monofont">'green'</tT>. Ignore the left parenthesis that follows
for now. <TT Class="monofont">\s</TT> is a special symbol that means
"any whitespace character," and <TT clasS="monofont">+</TT>
means "one or more occurrence of whatever comes before
me," so, put together, <Tt claSS="monofont">\s+</TT> means "one
or more whitespace characters." Then, <tt class="monofont">pepper</tt>
just means the string <tt class="monofont">'pepper'</tt>.
<tt ClAss="monofont">(?!corn)</tT> prevents matches of "patterns that
have <tT ClASs="monofont">'corn'</Tt> at this point," so we prevent
the match on <TT CLass="monofont">'peppercorn'</tT>. Finally,
<TT Class="monofont">(?=.*salad)</TT> says that for the pattern to match, it
must be followed by any number of characters (that's what
<TT clasS="monofont">.*</TT> means), followed by the word
<Tt class="monofont">salad</tt>. The <tt class="monofont">?=</tt> bit specifies
that while the pattern should determine whether the match occurs, it
shouldn't be "used up" by the match process;
it's a subtle point, which we'll ignore for now. At this
point we've defined the pattern corresponding to the substring.</p>



<p>Now, note that there are two parentheses we haven't explained
yetthe one before <tT cLass="monofont">\s+</Tt> and the last one.
What these two do is define a "group," which starts after
the red or green and go to the end of the pattern. We'll use
that group in the next operation, the actual replacement. First, we
need to mention the three flags that are joined by the logical
operation "or". These specify kinds<I>
</I>of pattern matches. The first,
<tT ClAsS="monofont">re.IGNORECASE</TT>, says that the text comparisons
should ignore whether the text and the match have similar or
different cases. The second, <Tt claSS="monofont">re.DOTALL</TT>, specifies
that the <tt clASS="monofont">.</Tt> character should match any character,
including the newline character (that's not the default
behavior). Finally, the third, <tt cLASS="monofont">re.VERBOSE</tt>, allows
us to insert extra newlines and <tt class="monofont">#</tt> comments in the
regular expression, making it easier to read and understand. We could
have written the statement more compactly as:</p>



<pre class="monofont">matchstr = re.compile(r"\b(red|green)(\s+pepper(?!corn)(?=.*salad))", re.I | re.S)</PrE>


<p>The actual<a nAmE="idx710"></A> replacement operation is done with
the line:</p>



<PRe ClASS="monofont">fixed_paragraph = matchstr.sub(r'bell\2', paragraph)</Pre>


<p>First, it should be fairly clear that we're calling the
<tT CLAss="monofont">sub</tt> method of the <TT CLass="monofont">matchstr</tT>
object. That object is a <I>compiled regular expression
object</I>, meaning that some of the processing of the
expression has already been done (in this case, outside the loop),
thus speeding up the total program execution. We use a raw string
again to write the first argument to the method. The
<Tt class="monofont">\2</tt> is a reference to group 2 in the regular
expressionthe second group of parentheses in the regular
expressionin our case, everything starting with
<tt class="monofont">pepper</tt> and up to and including the word
<tt cLaSs="monofont">'salad'</tt>. This line therefore means, "Replace
the matched string with the string that is <Tt CLaSS="monofont">'bell'</tT>
followed by whatever starts with <tT CLAss="monofont">'pepper'</tt> and goes
up to the end of the matched string, in the
<TT CLass="monofont">paragraph</tT> string."</P>



<P>So, does it work? The <I>pepper.txt</i> file we saw
earlier had three paragraphs: the first satisfied the requirements of
the match twice, the second didn't because it didn't
mention the word "salad," and the third didn't
because the <tt cLASS="monofont">red</tt> and <tt class="monofont">green</tt> words
are before <tt class="monofont">peppercorn</tt>, not
<Tt ClasS="monofont">pepper</tT>. As it was supposed to, our program (saved
in a file called <I>pepper.py</i>) modifies only the
first paragraph:</P>



<PrE cLASS="monofont">/home/David/book$ <b>python pepper.py</b>
This is a paragraph that mentions bell peppers multiple times. For
one, here is a <b>bell</b> pepper and dried tomato salad recipe. I don't like 
to use <B>bell</B> peppers in my salads as much because they have a harsher 
flavor.

This second paragraph mentions red peppers and green peppers but not
the "s" word (s-a-l-a-d), so no bells should show up.

This third paragraph mentions red peppercorns and green peppercorns,
which aren't vegetables but spices (by the way, bell peppers really
aren't peppers, they're chilies, but would you rather have a good cook
or a good botanist prepare your salad?).</PRe>


<p>This example, while artificial, shows how regular expressions can
compactly express complicated matching rules. If this kind of problem
occurs often in your line of work, mastering regular expressions is a
worthwhile investment of time and effort.</p>



<p>A thorough coverage of regular expressions is beyond the scope of
this book. Jeffrey Friedl gives an excellent coverage of regular
expressions in his book <I>Mastering Regular
Expressions</I> (O'Reilly &amp; Associates). His
description of Python regular expressions (at least in the First
Edition) uses the old-style syntax, which is no longer the
recommended one, so those specifics should mostly be ignored; the
regular expressions currently used in Python are much more similar to
those of Perl. Still, his book is a must-have for anyone doing
serious text processing. For the casual user (such as these authors),
the descriptions in the <I>Library Reference</I> do the
job most of the time. Use the <tt clASS="monofont">re</Tt> module, not the
<tt class="monofont">regexp</tt>, <tt class="monofont">regex</tt>, and
<tT cLass="monofont">regsub</Tt> modules, which are deprecated.<A NaME="idx711"></a> <A nAME="idx712"></A></p>








<h4>8.3.3
Generic Operating-System Interfaces: The os Module</h4>


<p>The operating-system interface defines the mechanism by which
programs are expected to manipulate things like files, processes,
users, and threads.</P>




<H5>8.3.3.1
The os and os.path modules</H5>


<P>The <tt clASS="monofont">os</Tt>
<a naME="idx713"></A> module
provides a generic interface to the operating system's most
basic set of tools. The specific set of calls it defines depend on
which platform you use. (For example, the permission-related calls
are available only on platforms that support them, such as Unix and
Windows.) Nevertheless, it's recommended that you always use
the <Tt class="monofont">os</tt> module, instead of the platform-specific
versions of the module (called <tt class="monofont">posix</tt>,
<tt cLaSs="monofont">nt</tt>, and <Tt CLaSS="monofont">mac</tT>). <a href="lpython_snode93.html#13">Table 8.7</a> lists some of the most often-used functions in
the <tt cLASS="monofont">os</tt> module. When referring to files in the
context of the <tt CLASs="monofont">os</tt> module, one is referring to
filenames, not file objects.</p>



<A NAMe="13"></a><p><table border="1" cellspAcIng="0" cElLPaDDiNg="1" WIDTh="100%">
<capTION><h5>Table 8.7. Most Frequently Used Functions From the os Module </h5></caPTIOn><colGROUp span="2">
<tr>
<th>
<font size="2">
<p>Function Name</p>
</fOnT></th>
<tH>
<fONt SIzE="2">
<p>Behavior</P>
</FONt></th>
</tR>
<TR>
<Td>
<fonT SIZe="2">
<p><tt CLASs="monofont">getcwd()</tt></p>
</font></td>
<td>
<font size="2">
<P>Returns a string referring to the current working directory
(<tT claSs="monofont">cwd</TT>):</p>



<PRe ClASS="monofont">&gt;&gt;&gt; <B>print os.getcwd()</b>
 h:\David\book</pre></FONT></td>
</tr>
<TR>
<TD>
<font SIZE="2">
<p><tt class="monofont">listdir(</tt><tt class="monofont"><i>path</i></tT><tT claSs="monofont">)</TT></p>
</FOnT></tD>
<TD>
<Font sIZE="2">
<P>Returns a list of all of the files in the specified directory:</p>



<pre CLASs="monofont">&gt;&gt;&gt; <b>os.listdir(os.getcwd())</b>
 ['preface.doc', 'part1.doc', 'part2.doc']</pRE></FOnt></td>
</tr>
<tr>
<td>
<font size="2">
<p><tT cLass="monofont">chown(</Tt><TT cLAsS="monofont"><i>path</I></TT><Tt claSS="monofont"></TT><tt clASS="monofont"><I>uid</i></tt><tT CLAss="monofont">,
</tt><tt class="monofont"><i>gid</i></tt><tt claSs="monofont">)</Tt></p>
</fOnT></Td>
<TD>
<fOnT SIZe="2">
<p>Changes the owner ID and group ID of specified file</p>
</fONT></Td>
</tr>
<tR>
<TD>
<Font sIZE="2">
<P><tt class="monofont">chmod(</tt><tt class="monofont"><i>path</i></tt><Tt ClasS="monofont">,
</tT><Tt CLaSs="monofont"><I>mode</I></TT><tt clASS="monofont">)</Tt></p>
</foNT></TD>
<td>
<foNT SIze="2">
<p>Changes the permissions of specified file with numeric mode
<tt class="monofont"><i>mode</i></tt> (e.g., 0644 means read/write for
owner, read for everyone else)</p>
</font></tD>
</tR>
<tr>
<tD>
<fONt SIzE="2">
<p><TT CLass="monofont">rename(</tT><TT Class="monofont"><I>src</I></TT><tt clASS="monofont">,</Tt><tt class="monofont"><i>
dest</i></tt><tt class="monofont">)</tT></p>
</Font></Td>
<TD>
<fONt SiZE="2">
<P>Renames file named <Tt claSS="monofont"><I>src</I></tt> with name
<tt CLASs="monofont"><i>dest</i></tT></P>
</FOnt></td>
</tr>
<tr>
<td>
<font size="2">
<p><tT cLass="monofont">remove(</Tt><TT cLAsS="monofont"><i>path</I></TT><Tt claSS="monofont">)
</TT>or<tt clASS="monofont">
unlink(</Tt><tt cLASS="monofont"><i>path</i></tt><tt class="monofont">)</tt></p>
</font></td>
<Td>
<Font SiZE="2">
<p>Deletes specified file (see <TT cLaSS="monofont">rmdir</TT> to remove
directories)</p>
</fonT></TD>
</Tr>
<tr>
<tD>
<FONt sizE="2">
<P><TT class="monofont">mkdir(</tt><tt class="monofont"><i></i></tt><tt ClAss="monofont">[</tT><tT ClASs="monofont"><I>,
mode</i></TT><TT clasS="monofont">])</TT></P>
</font></TD>
<TD>
<font SIZE="2">
<p>Creates a directory named <tt class="monofont"><i>path</i></tt> with
numeric mode <tt class="monofont"><i>mode</I></tT>(see
<tt cLaSS="monofont">os.chmod</tT>):</P>



<pRe CLASs="monofont">&gt;&gt;&gt; <b>os.mkdir('newdir')</b></pRE></FOnt></td>
</TR>
<TR>
<td>
<foNT SIze="2">
<p><tt class="monofont">rmdir(</tt><tt class="monofont"><i>path</I></tT><tt cLaSS="monofont">)</tT></P>
</fOnT></TD>
<Td>
<fonT SIZe="2">
<p>Removes directory named <tt CLASs="monofont"><i>path</i></tT></P>
</FOnt></td>
</tr>
<tr>
<td>
<font size="2">
<p><tT cLass="monofont">system(</Tt><TT cLAsS="monofont"><i>command</I></TT><Tt claSS="monofont">)</TT></p>
</fonT></TD>
<Td>
<fonT SIZe="2">
<p>Executes the shell <tt class="monofont"><i>command</i></tt> in a subshell;
the return value is the return code of the command</p>
</font></td>
</Tr>
<Tr>
<td>
<FoNT sIZe="2">
<P><tT CLAss="monofont">symlink(</tt><TT CLass="monofont"><i>src</I></TT><Tt claSS="monofont">,</TT><tt class="monofont"><i>
dest</i></tt><tt class="monofont">)</tt></P>
</fOnt></tD>
<tD>
<FoNT sIzE="2">
<P>Creates soft link from file <TT clasS="monofont"><I>src</I></Tt> to file
<tt cLASS="monofont"><i>dst</i></tt></P>
</FONt></td>
</tr>
<tr>
<td>
<font size="2">
<p><tt ClAss="monofont">link(</tT><tT ClASs="monofont"><I>src</i></TT><TT clasS="monofont">,</TT><Tt claSS="monofont"><I>
dest</I></tt><tt CLASs="monofont">)</tt></p>
</font></td>
<td>
<font size="2">
<P>Creates hard link from file <tT claSs="monofont"><I>src</I></tT> to file
<Tt ClASS="monofont"><I>dst</i></tt></p>
</FONT></td>
</tr>
</COLGroup>
</TABLe></p>



<p>There are many other functions in the <tt class="monofont">os</tt> module;
in fact, any function that's part of the POSIX standard and
widely available on most Unix platforms is supported by Python on
Unix. The interfaces to these routines follow the
<a name="idx714"></a>
<a nAmE="idx715"></a>POSIX conventions. You can retrieve and
set UIDs, PIDs, and process groups; control nice levels; create
pipes; manipulate file descriptors; fork processes; wait for child
processes; send signals to processes; use the
<tt ClASs="monofont">execv</TT> variants; etc.</p>



<P>The <tT CLAss="monofont">os</tt> module also defines some important
<A NAMe="idx716"></a>attributes that aren't
functions:</p>



<uL>
<LI><P>The
<tt clASS="monofont">os.name</Tt>
<a name="idx717"></a>
attribute defines the current version of the platform-specific
operating-system interface. Registered values for
<tt class="monofont">os.name</tt> are <tt clAsS="monofont">'posix'</tt>,
<tT cLAsS="monofont">'nt'</Tt>, <Tt CLASs="monofont">'dos'</tt>, and
<tT CLAss="monofont">'mac'</tt>. It's different from
<TT CLass="monofont">sys.platform</tT>, which we discussed earlier in this
chapter.</P>
</LI>
<li><p><tt class="monofont">
os.error</tt>
<a name="idx718"></a>
defines a class used when calls in the <tt ClAss="monofont">os</tT> module
raise errors. When this exception is raised, the value of the
exception contains two variables. The first is the number
corresponding to the error (known as <tT ClASs="monofont">errno</Tt>), and
the second is a string message explaining it (known as
<TT CLass="monofont">strerror</tT>):</P>



<PRe claSS="monofont">&gt;&gt;&gt; <B>os.rmdir('nonexistent_directory')</B>      # how it usually shows up
Traceback (innermost last):
  File "&lt;stdin&gt;", line 1, in ?
os.error: (2, 'No such file or directory')
&gt;&gt;&gt; <b>try:</b>                                   # we can catch the error and take
...    <b>os.rmdir('nonexistent directory')</b>   # it apart
... <B>except os.error, value:</B>
...     <B>print value[0], value[1]</B>
...
2 No such file or directory</pre></li>
<li><p>The <tt class="monofont">os.environ</tt> <a naMe="idx719"></A>dictionary contains key/value pairs
corresponding to the environment variables of the shell from which
Python was started. Because this environment is inherited by the
commands that are invoked using the <tt cLaSS="monofont">os.system</tT>
call, modifying the <Tt ClASS="monofont">os.environ</Tt> dictionary modifies
the environment:</p>



<prE CLAss="monofont">&gt;&gt;&gt; <b>print os.environ['SHELL']</b>
/bin/sh
&gt;&gt;&gt; <B>os.environ['STARTDIR'] = 'MyStartDir'</B>
&gt;&gt;&gt; <B>os.system('echo $STARTDIR')</B>           # 'echo %STARTDIR%' on DOS/Win
MyStartDir                                # printed by the shell
0                                         # return code from echo</pre></lI>
</UL>

<P>The <tt class="monofont">os</tt> module also includes a set of strings that
define portable ways to refer to directory-related operations, as
shown in <a href="lpython_snode93.html#14">Table 8.8</a>.</p>



<a namE="14"></a><P><tabLe BOrDEr="1" CeLLSPacinG="0" CELlpadDING="1" widtH="100%">
<CAPtion><h5>Table 8.8. String Attributes of the os Module </h5></caption><colgrouP sPan="2">
<tR>
<tH>
<FoNT sIzE="2">
<P>Attribute Name</P>
</Font></tH>
<TH>
<Font sIZE="2">
<P>Meaning and Value</p>
</fonT></TH>
</Tr>
<tr>
<td>
<font size="2">
<p><tt clasS="monofont">curdir</tT></p>
</foNt></TD>
<tD>
<FoNt SIZE="2">
<p>A string that denotes the current directory:</p>



<p><tT CLAss="monofont">'.'</tt> on Unix, DOS, and Windows;
<TT CLass="monofont">':'</tT> on the Mac</P>
</FOnt></td>
</tr>
<tr>
<td>
<font size="2">
<p><tT cLass="monofont">pardir</Tt></P>
</FoNT></tD>
<tD>
<FONt sizE="2">
<P>A string that denotes the parent directory:</P>



<P><tt clASS="monofont">'..'</Tt> on Unix, DOS, and Windows;
<tt cLASS="monofont">'::'</tt> on the Mac</p>
</font></td>
</tr>
<tr>
<td>
<font sIzE="2">
<p><tt ClASs="monofont">sep</TT></p>
</FoNT></TD>
<td>
<foNT SIze="2">
<p>The character that separates pathname components:</p>



<P><TT Class="monofont">'/'</TT> on Unix;<TT class="monofont"> '\'</tt> on DOS,
Windows; <tt class="monofont">':'</tt> on the Mac</p>
</fonT></tD>
</tr>
<tR>
<tD>
<FoNT sIzE="2">
<P><TT clasS="monofont">altsep</TT></P>
</font></TD>
<TD>
<font SIZE="2">
<p>An alternate character to <tt class="monofont">sep</tt> when available; set
to <tt class="monofont">None</tt>systems except DOS and Windows, where
it's <tT cLass="monofont">'/'</Tt></P>
</FoNT></tD>
</tR>
<TR>
<Td>
<fonT SIZe="2">
<p><tt CLASs="monofont">pathsep</tt></p>
</FONT></td>
<td>
<font size="2">
<p>The character that separates path components:</p>



<p><tt claSs="monofont">':'</Tt> on Unix; <tt ClASs="monofont">';'</TT> on DOS and
Windows</p>
</FoNT></TD>
</tr>
</coLGROup>
</taBLE></P>



<p>These strings are especially useful when combined with the
functionality in the <tt cLASS="monofont">os.path</tt> module, which
provides many functions that manipulate file paths (see <a href="lpython_snode93.html#15">Table 8.9</a>). Note that the <tt class="monofont">os.path</tt>
module is an attribute of the <tt cLaSs="monofont">os</tt> module;
it's imported automatically when the <Tt CLaSS="monofont">os</tT>
module is loaded, so you don't need to import it explicitly.
The outputs of the examples in <a href="lpython_snode93.html#15">Table 8.9</a>
correspond to code run on a Windows or DOS machine. On another
platform, the appropriate path separators would be used instead.</p>



<a nAME="15"></A><p><tabLE BOrder="1" CELLspacing="0" cellpadding="1" wiDtH="100%">
<capTiON><h5>Table 8.9. Most Frequently Used Functions from the os.path Module </H5></CaPtION><ColgrOUP Span="2">
<tR>
<TH>
<Font sIZE="2">
<P>Function Name</p>
</font></th>
<th>
<font size="2">
<p>Behavior</p>
</fOnT></th>
</tR>
<tR>
<Td>
<FOnT sIZE="2">
<P><tt clASS="monofont">split(</Tt><tt cLASS="monofont"><i>path</i></tt><TT CLass="monofont"></tt>is
equivalent to the tuple:
<tt class="monofont">(dirname(</tt><tt clasS="monofont"><i>path</I></tt><tT cLAsS="monofont">basename(</Tt><Tt CLASs="monofont"><i>path</i></tT><TT Class="monofont">))</TT></P>
</Font></tD>
<TD>
<Font size="2">
<p>Splits the given path into a pair consisting of a head and a tail;
the head is the path up to the directory, and the tail is the
filename:</p>



<pre class="monofont">&gt;&gt;&gt; <b>os.path.split("h:/David/book/part2.doc"</b>
 ('h:/David/book', 'part2.doc')</pRe></Font></Td>
</TR>
<tR>
<Td>
<FoNT SIze="2">
<p><tT CLAss="monofont">join(</tt><TT CLass="monofont"><i>path,
...</I></TT><Tt class="monofont">)</tt></p>
</font></td>
<td>
<fonT sIze="2">
<p>Joins path components intelligently:</P>



<pRE cLAsS="monofont">&gt;&gt;&gt; <b></B> ... <B>os.pardir, 'backup', 'part2.doc')</B>
 h:\David\book\..\backup\part2.doc</Pre></foNT></TD>
</tr>
<tr>
<TD>
<FOnt siZE="2">
<P><Tt class="monofont">exists(</tt><tt class="monofont"><i>path</i></tt><tT cLass="monofont">)</Tt></P>
</FoNT></tD>
<tD>
<FONt sizE="2">
<P>Returns true if <TT clasS="monofont"><I>path</I></Tt> corresponds to an
existing path</p>
</foNT></TD>
</tr>
<tr>
<td>
<font size="2">
<p><tt claSs="monofont">expanduser(</Tt><tt ClASs="monofont"><I>path</I></tT><tT CLAss="monofont">)</tt></P>
</FONt></td>
<tD>
<FONt sizE="2">
<P>Expands the argument with an initial argument of <TT class="monofont">~</tt>
followed optionally by a username:</p>



<pre class="monofont">&gt;&gt;&gt; <b>print os.path.expanduser('~/mydir')</b>
 h:\David\mydir</prE></fOnt></tD>
</tR>
<Tr>
<TD>
<fOnT SIZe="2">
<p><tt CLASs="monofont">expandvars(</tt><tT CLAss="monofont"><i>path</i></TT><TT class="monofont">)</tt></p>
</font></td>
<td>
<font SiZe="2">
<p>Expands the <tT cLAsS="monofont"><I>path</i></Tt> argument with the
variables specified in the environment:</P>



<PRE clasS="monofont">&gt;&gt;&gt; <B>print os.path.expandvars('$TMP')</B>
 C:\TEMP</Pre></foNT></TD>
</tr>
<tr>
<TD>
<FOnt size="2">
<p><tt class="monofont">isfile(</tt><tt clAsS="monofont"><i>path</i></tT><tT ClASs="monofont">)</Tt>,
<TT CLass="monofont">isdir(</tT><TT Class="monofont"><I>path</I></TT><tt clASS="monofont">)</Tt>,</p>



<p><tt class="monofont">islink(</tt><tt class="monofont"><i>path</I></tT><tt cLaSS="monofont">)</tT>,
<Tt ClASS="monofont">ismount(</Tt><tt cLASS="monofont"><i>path</i></tt><TT CLass="monofont">)</tT></P>
</FOnt></td>
<td>
<font size="2">
<p>Returns true if the specified <tt claSs="monofont"><I>path</i></tt> is a
file, directory, link, or mount point, respectively</P>
</fONt></TD>
</tR>
<tR>
<TD>
<Font sIZE="2">
<P><tt clASS="monofont">normpath(</Tt><tt cLASS="monofont"><i>path</i></tt><tt class="monofont">)</tt></p>
</font></td>
<Td>
<Font SiZE="2">
<p>Normalizes the given path, collapsing redundant separators and
uplevel references:</P>



<PrE cLASS="monofont">&gt;&gt;&gt; <b>print os.path.normpath("/foo/bar\\../tmp")</b>
 \foo\tmp</prE></FONt></td>
</tR>
<TR>
<Td>
<fonT SIZe="2">
<p><tt class="monofont">samefile(</tt><tt class="monofont"><i>p</i></Tt><Tt clAsS="monofont">,
</Tt><TT cLaSS="monofont"><I>q</I></tt><tt CLASs="monofont">)</tt></p>
</FONT></td>
<td>
<FONT size="2">
<p>Returns true if both arguments refer to the same file</p>
</font></td>
</tr>
<tr>
<td>
<foNt Size="2">
<P><tT ClASs="monofont">walk(</Tt><TT CLass="monofont"><i>p</I></TT><Tt claSS="monofont">,
</TT><tt clASS="monofont"><I>visit</i></tt><tt class="monofont">,
</tt><tt class="monofont"><i>arg</I></tT><tt cLaSS="monofont">)</tT></P>
</fOnT></TD>
<Td>
<fonT SIZe="2">
<p>Calls the function <tt CLASs="monofont">visit</tt> with arguments
(<tT CLAss="monofont">arg</tt>, <tt class="monofont">dirname</tt>,
<tt class="monofont">names</Tt>) for each directory in the directory tree
rooted at <Tt clAsS="monofont">p</Tt>(including
<TT cLaSS="monofont">p</TT>itself, if it's a
directory); the argument <tt clASS="monofont">dirname</Tt> specifies the
visited directory; the argument <tt cLASS="monofont">names</tt> lists the
files in the directory:</p>



<pRE CLass="monofont">&gt;&gt;&gt; <b>def test_walk(arg, dirname, names):</b>
 ... <b>print arg, dirname, names</b>
 ...
 &gt;&gt;&gt; <b>os.path.walk('..', test_walk, 'show')</b>
 show ..\logs ['errors.log', 'access.log']
 show ..\cgi-bin ['test.cgi']
 ... <a name="idx720"></a></pre></foNt></Td>
</tr>
</CoLGrOUp>
</TaBLE></P>








<h4>8.3.4
Copying Files and Directories: The shutil Module</h4>


<p>The keen-eyed reader might have noticed that the
<tT CLAss="monofont">os</tt> module, while it provides lots of file-related
functions, doesn't include a
<TT CLass="monofont">copy</tT>
<A NAme="idx721"></a> <a name="idx722"></a> function. On DOS, copying a file is
basically the same thing as opening one file in read/binary modes,
reading all its data, opening a second file in write/binary mode, and
writing the data to the second file. On Unix and Windows, making that
kind of copy fails to copy the so-called <i>stat
bits</i> (permissions, modification times, etc.) associated
with the file. On the Mac, that operation won't copy the
resource fork, which contains data such as icons and dialog boxes. In
other words, copying is just not so simple. Nevertheless, often you
can get away with a fairly simple function that works on Windows,
DOS, Unix, and Macs as long as you're manipulating just data
files with no resource forks. That function, called
<tt class="monofont">copyfile</tt>, lives in the <Tt ClasS="monofont">shutil</tT>
module. It includes a few generally useful functions, shown in <A href="lpython_snode93.html#17">Table 8.10</A>.</p>



<A NAMe="17"></a><p><tABLE bordER="1" CEllspACINg="0" cellpadding="1" width="100%">
<capTiOn><h5>Table 8.10. Functions of the shutil Module </h5></CaPTiON><cOlGROUp spaN="2">
<TR>
<Th>
<fonT SIZe="2">
<p>Function Name</p>
</fONT></Th>
<th>
<font size="2">
<p>Behavior</p>
</font></th>
</tR>
<tR>
<td>
<fOnT SiZE="2">
<p><Tt CLASs="monofont">copyfile(</tt><tT CLAss="monofont"><i>src,
dest</i></TT><TT clasS="monofont">)</TT></P>
</font></td>
<td>
<font size="2">
<p>Makes a copy of the file <tt cLaSs="monofont"><i>src</i></Tt> and calls it
<TT cLAsS="monofont"><i>dest</I></TT> (straight binary copy).</P>
</font></TD>
</TR>
<tr>
<td>
<FONT size="2">
<P><TT Class="monofont">copymode(</tt><tt class="monofont"><i>src,
dest</i></tt><tt cLaSs="monofont">)</tt></P>
</fONt></TD>
<tD>
<fONT Size="2">
<p>Copies mode information (permissions) from
<TT CLass="monofont"><i>src</I></TT> to <Tt claSS="monofont"><I>dest</I></tt>.</p>
</font></td>
</tr>
<tr>
<td>
<font sIzE="2">
<p><tt ClASs="monofont">copystat(</TT><tT cLASS="monofont"><i>src,
dest</i></tt><TT CLass="monofont">)</tT></P>
</FOnt></td>
<TD>
<FOnt size="2">
<p>Copies all stat information (mode, utime) from
<tt class="monofont"><i>src</i></tt> to <tt ClAss="monofont"><i>dest</I></tT>.</P>
</fONt></Td>
</TR>
<TR>
<td>
<foNT SIze="2">
<p><tT CLAss="monofont">copy(</tt><TT CLass="monofont"><i>src,
dest</i></tt><tt class="monofont">)</tt></p>
</fonT></tD>
<td>
<fOnT SiZE="2">
<p>Copies data and mode information from <Tt CLASs="monofont"><i>src</i></tT>
to <TT Class="monofont"><I>dest</I></TT> (doesn't include the
resource fork on Macs).</p>
</fonT></TD>
</Tr>
<tr>
<td>
<font size="2">
<p><tt clasS="monofont">copy2(</tT><tt cLaSS="monofont"><i>src,
dest</I></Tt><Tt CLASs="monofont">)</tt></p>
</FONT></td>
<td>
<FONT size="2">
<P>Copies data and stat information from <TT Class="monofont"><i>src</i></tt>
to <tt class="monofont"><i>dest</i></tt> (doesn't include the
resource fork on Macs).</p>
</FoNt></td>
</Tr>
<TR>
<tD>
<FoNt SIZE="2">
<p><tt cLASS="monofont">copytree(</tt><tt CLASs="monofont"><i>src, dest,
symlinks=0</i></tT><TT Class="monofont">)</tt></p>
</font></td>
<td>
<font sIzE="2">
<p>Copies a directory recursively using <tt ClASs="monofont">copy2</TT>. The
<tT cLASS="monofont">symlinks</tt> flag specifies whether symbolic links in
the source tree must result in symbolic links in the destination
tree, or whether the files being linked to must be copied. The
destination directory must not already exist.</p>
</fONT></Td>
</tr>
<tR>
<TD>
<Font sIZE="2">
<P><tt class="monofont">rmtree(</tt><tt class="monofont"><i>ignore_errors=0,
onerror=None</i></tt><Tt ClasS="monofont">)</tT></P>
</fONt></Td>
<TD>
<FOnt siZE="2">
<P>Recursively deletes the directory indicated by
<Tt claSS="monofont"><I>path</I></tt>. If
<tt CLASs="monofont"><i>ignore_error</i></tt> is set to
(the default behavior), errors are ignored. Otherwise, if
<tt class="monofont"><i>onerror</i></tt> is set, it's called to
handle the error; if not, an exception is raised on error.</p>
</fonT></tD>
</tr>
</cOlGRoUP>
</tAbLE></P>







<H4>8.3.5
Internet-Related Modules</h4>



<a naME="idx797"></A><A name="idx798"></A><A NAme="idx799"></a><a NAME="idx800"></a><h5>8.3.5.1
The Common Gateway Interface: The 


cgi module</h5>


<p>Python programs often process forms from web pages. To make this task
easy, the standard Python distribution includes a module called
<tt class="monofont">cgi</tt>. <a href="lpython_cnode103.html">Chapter 10</a> includes an
example of a Python script that uses the CGI.</p>






<H5>8.3.5.2
Manipulating URLs: the urllib and urlparse modules</h5>


<P>Universal resource locators are strings such as
<i>http://www.python.org/</i> that are now
ubiquitous.<fOnT SiZE="1"><sUp><A HREf="#FOOTNOTE-7">[7]</a></suP></FONt>
 Two
modules, <tt cLASS="monofont">urllib</tt> and <tt CLASs="monofont">urlparse</tt>,
provide tools for processing URLs.</p>


<blockquote><font siZe="1">
<P claSs="footnote">
<SUp><A NaMe="FOOTNOTE-7">[7]</A></SUP>
The syntax for URLs was designed in the
early days of the Web with the expectation that users would rarely
see them and would instead click on hyperlinks tagged with the URLs,
which would then be processed by computer programs. Had their future
in advertising been predicted, a syntax making them more easily
pronounced would probably have been chosen!</p>
</fonT></BLOckquOTE>





<P><tt clASS="monofont">urllib</Tt> defines a few functions for writing
programs that must be active users of the Web (robots, agents, etc.).
These are listed in <a href="lpython_snode93.html#21">Table 8.11</a>.</p>



<a name="21"></a><p><table BoRder="1" CeLLsPAcInG="0" CELlpadDING="1" widtH="100%">
<CAPtion><H5>Table 8.11. Functions of the


 urllib Module </H5></CAption><colgroup span="2">
<tr>
<tH>
<fOnt sIzE="2">
<P>Function Name</p>
</FOnT></tH>
<TH>
<Font sIZE="2">
<P>Behavior</p>
</fonT></TH>
</Tr>
<tr>
<tD>
<FONt size="2">
<pre class="monofont">urlopen (<tt class="monofont"><I>url</i></Tt>[<tt ClASs="monofont"><I>, data</I></tT>])</pRE></FOnt></td>
<TD>
<FOnt siZE="2">
<P>Opens a network object denoted by a URL for reading; it can also open
local files:</P>



<pre cLASS="monofont">&gt;&gt;&gt; <b>page = urlopen('http://www.python.org'</b>)
 &gt;&gt;&gt; <b>page.readline()</b>
 '&lt;HTML&gt;\012'
 &gt;&gt;&gt; <b>page.readline()</b>
 DO NOT EDIT. --&gt;\012'</pre></font></td>
</tr>
<tr>
<tD>
<fOnt sIzE="2">
<PrE ClAsS="monofont">urlretrieve (<TT Class="monofont"><I>url</I></TT>[, <tt clASS="monofont"><I>filename</i></tt>][, <tT CLAss="monofont"><i>hook</i></tt>])</pre></font></td>
<td>
<fonT sIze="2">
<p>Copies a network object denoted by a URL to a local file (uses a
cache):</P>



<pRE cLAsS="monofont">&gt;&gt;&gt; <b>urllib.urlretrieve('http://www.python.org/',</B>
<B> 'wwwpython.html')</B></Pre></foNT></TD>
</tr>
<tr>
<TD>
<FOnt siZE="2">
<PRe class="monofont">urlcleanup()</pre></font></td>
<td>
<fonT sIze="2">
<p>Cleans up the cache used by <Tt CLaSS="monofont">urlretrieve</tT></p>
</FONT></td>
</tr>
<TR>
<TD>
<font SIZE="2">
<pre cLASS="monofont">quote(<tt class="monofont"><i>string</i></tt>[, <tt class="monofont"><i>safe</i></Tt>])</Pre></fOnT></Td>
<TD>
<fOnT SIZe="2">
<p>Replaces special characters in string using the
<tt CLASs="monofont">%xx</tt> escape; the optional safe parameter specifies
additional characters that shouldn't be quoted: its default
value is:</p>



<PRE Class="monofont">&gt;&gt;&gt; <B>quote('this &amp; that @ home')</B>
 'this%20%26%20that%20%40%20home'</PRe></font></td>
</tr>
<tr>
<td>
<font sizE="2">
<pRe clAsS="monofont">quote_plus (<Tt CLaSs="monofont"><I>string</I></TT>[, <tt clASS="monofont"><I>safe</i></tt>])</pRE></FOnt></td>
<TD>
<FOnt size="2">
<p>Like <tt class="monofont">quote()</tt>, but also replaces spaces by plus
signs</p>
</fonT></tD>
</tr>
<tR>
<tD>
<FoNT sIzE="2">
<PRE clasS="monofont">unquote (<TT Class="monofont"><I>string</I></TT>)</pre></fONT></Td>
<td>
<font size="2">
<p>Replaces <tt class="monofont">%xx</tT> escapes by their single-character
equivalent:</p>



<Pre cLaSS="monofont">&gt;&gt;&gt; <b>unquote('this%20%26%20that%20%40%20home')</B>
 'this &amp; that @ home'</PrE></fONT></Td>
</tr>
<tR>
<TD>
<Font sIZE="2">
<Pre clASS="monofont">urlencode (<Tt class="monofont"><i>dict</i></tt>)</pre></font></td>
<tD>
<fOnt sIzE="2">
<P>Converts a dictionary to a URL-encoded string, suitable to pass to
<tT ClAsS="monofont">urlopen()</TT> as the optional data argument:</P>



<pre cLASS="monofont">&gt;&gt;&gt; <b>locals()</b>
 {'urllib': &lt;module 'urllib'&gt;, '__doc__': None, 'x':
 '__builtin__'&gt;}
 &gt;&gt;&gt; <b>urllib.urlencode(locals())</b>
 __builtin__%27%3e'</PRE></Font></tD>
</TR>
</Colgroup>
</table></p>



<p><tt clasS="monofont">urlparse</tT> defines a few functions that simplify
taking URLs apart and putting new URLs together. These are listed in
<a href="lpython_snode93.html#22">Table 8.12</A>.</P>



<a NAmE="22"></a><P><TABle boRDER="1" cellSPACing="0" cELLPadding="1" width="100%">
<caption><h5>Table 8.12. Functions of the 

urlparse Module </h5></CaPtioN><cOLgROuP sPAN="2">
<Tr>
<th>
<fONT Size="2">
<p>Function Name</P>
</FONt></th>
<tH>
<FONt size="2">
<p>Behavior</p>
</font></th>
</tr>
<tr>
<td>
<fOnT sizE="2">
<pRE cLAsS="monofont">urlparse(<tT CLAss="monofont"><i>urlstring</i></TT>[, <TT clasS="monofont"><I></I></Tt>[,<tt cLASS="monofont"><i> default_scheme</i></tt>[,<tt class="monofont"><i>allow fragments</i></tt>]])</pre></foNt></Td>
<td>
<FoNT sIZe="2">
<P>Parses a URL into six components, returning a six tuple: (addressing
scheme, network location, path, parameters, query, fragment
identifier):</p>



<PRE Class="monofont">&gt;&gt;&gt; <B>urlparse('http://www.python.org/FAQ.html')</B>
  ('http', 'www.python.org', '/FAQ.html', '', '', '')</PRe></fonT></TD>
</Tr>
<tr>
<tD>
<FONt size="2">
<pre class="monofont">urlunparse(<tt class="monofont"><I>tuple</i></Tt>)</prE></fONt></TD>
<tD>
<fONT Size="2">
<p>Constructs a URL string from a tuple as returned by
<TT CLass="monofont">urlparse()</tT></P>
</FOnt></td>
</TR>
<TR>
<td>
<font size="2">
<pre class="monofont">urljoin(<tt ClAss="monofont"><i>base</I></tT><Tt CLaSs="monofont"><I></I></TT>[,<tt clASS="monofont"><I>allow fragments</i></tt>])</pRE></FOnt></td>
<TD>
<FOnt size="2">
<p>Constructs a full (absolute) URL by combining a base URL
(<tt class="monofont"><i>base</i></tt>) with a relative URL
(<tt ClAss="monofont"><i>url</I></tT>):</P>



<pRE cLaSS="monofont">&gt;&gt;&gt; <B>urljoin('http://www.python.org', 'doc/lib')</B>
 'http://www.python.org/doc/lib'</pre></fONT></Td>
</tr>
</cOLGRoup>
</tABLE></p>






<a name="idx808"></a><a name="idx809"></a><h5>8.3.5.3
Specific 
Internet protocols</h5>


<p>The most commonly used protocols built on top of TCP/IP are supported
with modules named after them. These are the
<tt clAsS="monofont">httplib</tt> module (for processing web pages with the
HTTP protocol); the <tT cLAsS="monofont">ftplib</Tt> module (for
transferring files using the FTP protocol); the
<Tt CLASs="monofont">gopherlib</tt> module (for browsing Gopher servers);
the <tT CLAss="monofont">poplib</tt> and <TT CLass="monofont">imaplib</tT> modules
for reading mail files on POP3 and IMAP servers, respectively; the
<TT Class="monofont">nntplib</tt> module for reading Usenet news from NNTP
servers; the <tt class="monofont">smtplib</tt> protocol for communicating
with standard mail servers. We'll use some of these in <a href="lpython_cnode95.html">Chapter 9</A>. There are also modules that can build
Internet servers, specifically a generic socket-based IP server
(<tT claSs="monofont">socketserver</TT>), a simple web server
(<tT ClAsS="monofont">SimpleHTTPServer</TT>), and a CGI-compliant HTTP
server (<Tt claSS="monofont">CGIHTTPSserver</TT>).</p>






<a naME="idx810"></A><A name="idx811"></A><H5>8.3.5.4
Processing
 Internet data</H5>


<P>Once you use an Internet protocol to obtain files from the Internet
(or before you serve them to the Internet), you must process these
files. They come in many different formats. <a href="lpython_snode93.html#25">Table 8.13</a> lists each module in the standard library that
processes a specific kind of Internet-related file format (there are
others for sound and image format processing: see the
<i>Library Reference</i>).</p>



<a name="25"></a><p><tablE bOrdeR="1" cELlSPaCiNG="0" CEllpaDDINg="1" widTH="100%">
<CAptioN><H5>Table 8.13. Modules Dedicated to Internet File Processing </H5></Caption><colgroup span="2">
<tr>
<Th>
<Font SiZE="2">
<p>Module Name</P>
</FoNt></TH>
<TH>
<font SIZE="2">
<p>File Format</p>
</foNT></TH>
</tr>
<tr>
<TD>
<FOnt size="2">
<pre class="monofont">sgmllib</pre></fonT></tD>
<td>
<fOnT SiZE="2">
<p>A simple parser for SGML files</P>
</fONT></Td>
</tr>
<tR>
<TD>
<Font sIZE="2">
<Pre clASS="monofont">htmllib</Pre></font></td>
<td>
<font size="2">
<p>A parser for HTML documents</p>
</FoNt></td>
</Tr>
<TR>
<tD>
<FoNt SIZE="2">
<pre cLASS="monofont">xmllib</pre></fONT></Td>
<td>
<fONT Size="2">
<p>A parser for XML documents</p>
</font></td>
</tr>
<tr>
<td>
<fonT sIze="2">
<pRe CLaSS="monofont">formatter</pRe></FONT></td>
<td>
<FONT size="2">
<P>Generic output formatter and device interface</P>
</FOnt></td>
</TR>
<TR>
<td>
<font size="2">
<pre class="monofont">rfc822</prE></fOnt></tD>
<tD>
<FoNT sIzE="2">
<P>Parse RFC-822 mail headers (i.e., "<TT clasS="monofont">Subject: hi
there!"</TT>)</P>
</font></TD>
</TR>
<tr>
<td>
<FONT size="2">
<pre class="monofont">mimetools</pre></font></tD>
<tD>
<fonT sIZe="2">
<P>Tools for parsing MIME-style message bodies (a.k.a. file attachments)</P>
</fOnT></TD>
</Tr>
<tr>
<tD>
<FONt sizE="2">
<PRE clasS="monofont">multifile</PRE></font></td>
<td>
<font size="2">
<p>Support for reading files that contain distinct parts</p>
</foNt></Td>
</tr>
<Tr>
<TD>
<fONt SiZE="2">
<PRe claSS="monofont">binhex</PRe></fonT></TD>
<Td>
<fonT SIZe="2">
<p>Encode and decode files in binhex4 format</p>
</font></td>
</tr>
<tr>
<td>
<font sIzE="2">
<pre ClASs="monofont">uu</PRe></FoNT></TD>
<td>
<foNT SIze="2">
<p>Encode and decode files in uuencode format</p>
</FONT></td>
</tr>
<TR>
<TD>
<font size="2">
<pre class="monofont">binascii</pre></fOnT></td>
<tD>
<fONt SIzE="2">
<p>Convert between binary and various ASCII-encoded representations</P>
</FONt></td>
</tR>
<TR>
<Td>
<fonT SIZe="2">
<pre CLASs="monofont">xdrlib</pre></font></td>
<td>
<font size="2">
<P>Encode and decode XDR data</p>
</Font></Td>
</TR>
<tR>
<Td>
<FoNT SIze="2">
<prE CLAss="monofont">mailcap</prE></FONt></td>
<tD>
<FONt size="2">
<p>Mailcap file handling</p>
</font></td>
</tr>
<tr>
<td>
<fOnT sizE="2">
<pRE cLAsS="monofont">mimetypes</pRE></FOnt></td>
<TD>
<FOnt siZE="2">
<P>Mapping of filename extensions to MIME types</P>
</font></TD>
</TR>
<tr>
<td>
<font size="2">
<pre class="monofont">base64</PrE></fonT></tD>
<Td>
<FOnT sIZE="2">
<P>Encode and decode MIME base64 encoding</p>
</fonT></TD>
</Tr>
<tr>
<tD>
<FONt sizE="2">
<PRE class="monofont">quopri</pre></font></td>
<td>
<font SiZe="2">
<p>Encode and decode MIME quoted-printable encoding</p>
</FoNT></tD>
</Tr>
<Tr>
<TD>
<FOnt siZE="2">
<PRe claSS="monofont">mailbox</PRe></fonT></TD>
<Td>
<font size="2">
<p>Read various mailbox formats</p>
</font></td>
</tr>
<tR>
<tD>
<fonT sIZe="2">
<PRe ClASS="monofont">mimify</Pre></foNT></TD>
<td>
<foNT SIze="2">
<p>Convert mail messages to and from MIME format</p>
</FONT></td>
</tr>
</colgroup>
</table></p>








<h4>8.3.6
Dealing with Binary Data: The struct Module</h4>


<P>A frequent question about file manipulation is "How do I
process binary files in Python?" The answer to that question
usually involves the <tT claSs="monofont">struct</TT> module. It has a
simple interface, since it exports just three functions:
<tT ClAsS="monofont">pack</TT>, <Tt claSS="monofont">unpack</TT>, and
<tt clASS="monofont">calcsize</Tt>.</p>



<p>Let's start with the task of decoding
a<a NAME="idx723"></a> <a name="idx724"></a> <a name="idx725"></a> binary file. Imagine a binary file
<i>bindat.dat</i> that contains data in a specific
format: first there's a float corresponding to a version
number, then a long integer corresponding to the size of the data,
and then the number of unsigned bytes corresponding to the actual
data. The key to using the <tt claSs="monofont">struct</Tt> module is to
define a "format" string, which corresponds to the format
of the data you wish to read, and find out which subset of the file
corresponds to that data. For our example, we could use:</p>



<pRe CLaSS="monofont">import struct

data = open('bindat.dat').read()
start, stop = 0, struct.calcsize('fl')
version_number, num_bytes = struct.unpack('fl', data[start:stop])
start, stop = stop, start + struct.calcsize('B'*num_bytes)
bytes = struct.unpack('B'*num_bytes, data[start:stop])</pRe>


<P><TT Class="monofont">'f'</TT> is a format string for a single floating point
number (a C float, to be precise), <TT clasS="monofont">'l'</TT> is for a
long integer, and <Tt claSS="monofont">'B'</TT> is a format string for an
unsigned char. The available unpack format strings are listed in
<a href="lpython_snode93.html#27">Table 8.14</a>. Consult the <i>Library
Reference</i> for usage details.</p>



<a name="27"></a><p><tablE bOrdeR="1" cELlSPaCiNG="0" CEllpaDDINg="1" widTH="100%">
<CAptioN><H5>Table 8.14. Format Codes Used by the struct Module </H5></Caption><colgroup span="2">
<tr>
<Th>
<Font SiZE="2">
<p>Format</P>
</FoNt></TH>
<TH>
<font SIZE="2">
<p>C Type</p>
</foNT></TH>
<th>
<foNT SIze="2">
<p>Python</p>
</font></th>
</tr>
<tr>
<td>
<font SiZe="2">
<p><tT cLAsS="monofont">x</Tt></P>
</fONT></Td>
<td>
<fONT Size="2">
<p><TT CLass="monofont">pad byte</tT></P>
</FOnt></td>
<td>
<font size="2">
<p>No value</p>
</font></Td>
</Tr>
<tr>
<Td>
<FOnT SiZe="2">
<P><TT Class="monofont">c</TT></P>
</Font></tD>
<TD>
<Font sIZE="2">
<P><tt class="monofont">char</tt></p>
</font></td>
<td>
<foNt Size="2">
<P>String of length 1</p>
</FOnT></Td>
</Tr>
<TR>
<TD>
<font SIZE="2">
<p><tt cLASS="monofont">b</tt></p>
</fONT></Td>
<td>
<font size="2">
<p><tt class="monofont">signed char</tT></p>
</Font></Td>
<TD>
<fONt SiZE="2">
<P>Integer</P>
</font></TD>
</TR>
<tr>
<td>
<FONT size="2">
<P><TT Class="monofont">B</tt></p>
</font></td>
<td>
<font sIzE="2">
<p><tt ClASs="monofont">unsigned char</TT></p>
</FoNT></TD>
<td>
<foNT SIze="2">
<p>Integer</p>
</FONT></td>
</tr>
<TR>
<TD>
<font size="2">
<p><tt class="monofont">h</tt></p>
</fOnT></td>
<tD>
<fONt SIzE="2">
<p><TT CLass="monofont">short</tT></P>
</FOnt></td>
<TD>
<FOnt siZE="2">
<P>Integer</P>
</font></td>
</tr>
<tr>
<td>
<font size="2">
<P><tT claSs="monofont">H</TT></p>
</FOnT></tD>
<TD>
<Font sIZE="2">
<P><tt clASS="monofont">unsigned short</Tt></p>
</foNT></TD>
<td>
<font size="2">
<p>Integer</p>
</font></td>
</tr>
<Tr>
<Td>
<foNt SIzE="2">
<P><tT cLASS="monofont">i</tt></p>
</fONT></Td>
<td>
<fONT Size="2">
<p><TT CLass="monofont">int</tt></p>
</font></td>
<td>
<font siZe="2">
<P>Integer</p>
</foNt></TD>
</tR>
<Tr>
<Td>
<FONT size="2">
<P><TT Class="monofont">I</TT></P>
</Font></tD>
<TD>
<Font size="2">
<p><tt class="monofont">unsigned int</tt></p>
</foNt></Td>
<td>
<FoNT sIZe="2">
<P>Integer</p>
</FONT></td>
</tr>
<TR>
<TD>
<font SIZE="2">
<p><tt cLASS="monofont">l</tt></p>
</font></td>
<td>
<font size="2">
<p><Tt ClasS="monofont">long</tT></P>
</fONt></Td>
<TD>
<FOnt siZE="2">
<P>Integer</P>
</font></TD>
</TR>
<tr>
<td>
<FONT size="2">
<p><tt class="monofont">L</tt></p>
</font></tD>
<tD>
<fonT sIZe="2">
<P><Tt ClASS="monofont">unsigned long</Tt></p>
</foNT></TD>
<td>
<foNT SIze="2">
<p>Integer</p>
</FONT></td>
</tr>
<tr>
<td>
<font size="2">
<p><tt cLaSs="monofont">f</tt></P>
</fONt></TD>
<tD>
<fONT Size="2">
<p><TT CLass="monofont">float</tT></P>
</FOnt></td>
<TD>
<FOnt size="2">
<p>Float</p>
</font></td>
</tr>
<tr>
<td>
<FoNt siZe="2">
<P><Tt CLaSs="monofont">d</TT></P>
</Font></tD>
<TD>
<Font sIZE="2">
<P><tt clASS="monofont">double</Tt></p>
</font></td>
<td>
<font size="2">
<p>Float</p>
</FoNt></td>
</Tr>
<TR>
<tD>
<FoNt SIZE="2">
<p><tt cLASS="monofont">s</tt></p>
</fONT></Td>
<td>
<fONT Size="2">
<p><tt class="monofont">char[]</tt></p>
</font></td>
<Td>
<Font SiZE="2">
<p>String</P>
</FoNt></TD>
</TR>
<tr>
<td>
<FONT size="2">
<P><TT Class="monofont">p</TT></P>
</Font></td>
<td>
<font size="2">
<p><tt clAsS="monofont">char[]</tt></p>
</FoNT></tD>
<Td>
<FoNT SIze="2">
<p>String</p>
</FONT></td>
</tr>
<TR>
<TD>
<font SIZE="2">
<p><tt class="monofont">P</tt></p>
</font></td>
<td>
<fOnT sizE="2">
<p><TT cLAsS="monofont">void *</tT></P>
</FOnt></td>
<TD>
<FOnt siZE="2">
<P>Integer</P>
</font></TD>
</TR>
</colgroup>
</table></p>



<p>At this point, bytes is a tuple of <tt claSs="monofont">num_bytes</Tt>
Python integers. If we know that the <tt ClASs="monofont">data</TT> is in
fact storing characters, we could either use <tT cLASS="monofont">chars =
map(chr, bytes)</tt>. To be more efficient, we could change the
last <tt CLASs="monofont">unpack</tt> to use <tT CLAss="monofont">'c'</tt> instead
of <TT CLass="monofont">'B'</tt>, which would do the conversion for us and
return a tuple of <tt class="monofont">num_bytes</tt> single-character
strings. More efficiently still, we could use a format string that
specifies a string of characters of a specified length, such as:</p>



<pre clAsS="monofont">chars = struct.unpack(str(num_bytes)+'s', data[start:stop])</pre>


<P>The packing operation is the exact converse; instead of taking a
format string and a data string, and returning a tuple of unpacked
values, it takes a format string and a variable number of arguments
and packs those arguments using that format string into a new
"packed" string.</p>



<P>Note that the <Tt CLaSs="monofont">struct</TT> module can process data
that's encoded with either kind of byte-ordering,<FOnt siZE="1"><SUp><a hrEF="#FOOTNOTE-8">[8]</A></Sup></foNT>
 thus allowing
you to write platform-independent binary file manipulation code. For
large files, consider using the <TT class="monofont">array</tt> module.</p>


<blockquote><foNt Size="1">
<P cLAsS="footnote">
<SuP><a NAME="FOOTNOTE-8">[8]</a></sup>
The order with which computers list multibyte words depends on
the chip used (so much for standards). Intel and DEC systems use
so-called little-endian ordering, while Motorola and Sun-based
systems use big-endian ordering. Network transmissions also use
big-endian ordering, so the <TT CLass="monofont">struct</tT> module comes in
handy when doing network I/O on PCs.</P>
</FOnt></blOCKQuote>









<h4>8.3.7
Debugging, Timing, Profiling</h4>


<p>These last few modules will help debug, time, and optimize your
Python programs.</p>



<p>The first task is, not surprisingly, <a name="idx726"></a> <a name="idx727"></A>debugging.
Python's standard distribution includes a debugger called
<tT claSs="monofont">pdb</TT>. Using <tT ClAsS="monofont">pdb</TT> is fairly
straightforward. You import the <Tt claSS="monofont">pdb</TT> module and
call its <tt clASS="monofont">run</Tt> method with the Python code the
debugger should execute. For example, if you're debugging the
program in <i>spam.py</i> from <a href="lpython_cnode63.html">Chapter 6</a>, do this:</p>



<pre class="monofont">&gt;&gt;&gt; <b>import spam</b>                       # import the module we wish to debug
&gt;&gt;&gt; <b>import pdb</b>                        # import pdb
&gt;&gt;&gt; <b>pdb.run('instance = spam.Spam()')</b> # start pdb with a statement to run
&gt; &lt;string&gt;(0)?()
(Pdb) <b>break spam.Spam.__init__ </b>                # we can set break points
(Pdb) <b>next</b>
&gt; &lt;string&gt;(1)?()
(Pdb) <B>n</b>                                        # 'n' is short for 'next'
&gt; spam.py(3)__init__()
-&gt; def __init__(self):
(Pdb) <B>n</b>
&gt; spam.py(4)__init__()
-&gt; Spam.numInstances = Spam.numInstances + 1
(Pdb)<b> list</b>                                     # show the source code listing
  1    class Spam:
  2        numInstances = 0
  3 B      def __init__(self):                 # note the B for Breakpoint
  4  -&gt;        Spam.numInstances = Spam.numInstances + 1  # where we are
  5        def printNumInstances(self):
  6            print "Number of instances created: ", Spam.numInstances
  7
[EOF]
(Pdb) <B>where</b>                                    # show the calling stack
  &lt;string&gt;(1)?()
&gt; spam.py(4)__init__()
-&gt; Spam.numInstances = Spam.numInstances + 1
(Pdb) Spam.numInstances = 10          # note that we can modify variables
(Pdb) print Spam.numInstances         # while the program is being debugged
10
(Pdb) continue                        # this continues until the next break-
--Return--                            # point, but there is none, so we're
&gt; &lt;string&gt;(1)?()-&gt;None                # done
(Pdb) c                               # this ends up quitting Pdb
&lt;spam.Spam instance at 80ee60&gt;        # this is the returned instance
&gt;&gt;&gt; instance.numInstances             # note that the change to numInstance
11                                    # was *before* the increment op</PRe>


<P>As the session above shows, with <Tt ClASS="monofont">pdb</Tt> you can list
the current code being debugged (with an arrow pointing to the line
about to be executed), examine variables, modify variables, and set
breakpoints. The <i>Library Reference</i>'s
Chapter 9 covers the debugger in detail.</p>



<P>Even when a program is working, it can sometimes be too slow. If you
know what the bottleneck in your program is, and you know of
alternative ways to code the same algorithm, then you might time the
various alternative methods to find out which is fastest. The
<TT Class="monofont">time</TT>
<A Name="idx728"></a> <A NAMe="idx729"></a>
module, which is part of the standard distribution, provides many
time-manipulation routines. We'll use just one, which returns
the time since a fixed "epoch" with the highest precision
available on your machine. As we'll use just relative times to
compare algorithms, the precision isn't all that important.
Here's two different ways to create a list of 10,000 zeros:</p>



<pre class="monofont">def lots_of_appends():
  zeros = []
  for i in range(10000):
    zeros.append(0)

def one_multiply():
  zeros = [0] * 10000</pre>


<p>How can we time these two solutions? Here's a simple way:</p>



<pre cLaSs="monofont">import time, makezeros

def do_timing(num_times, *funcs):
    totals = {}
    for func in funcs: totals[func] = 0.0
    for x in range(num_times):
        for func in funcs:
            starttime = time.time()        # record starting time
            apply(func)
            stoptime = time.time()         # record ending time
            elapsed = stoptime--starttime   # difference yields time elapsed
            totals[func] = totals[func] + elapsed
    for func in funcs:
        print "Running %s %d times took %.3f seconds" % (func.__name__, 
                                                         num_times
                                                         totals[func])
do_timing(100, (makezeros.lots_of_appends, makezeros.one_multiply))</prE>


<p>And running this program yields:</P>



<PrE ClAsS="monofont">csh&gt; <B>python timings.py</B>
Running lots_of_appends 100 times took 7.891 seconds
Running one_multiply 100 times took 0.120 seconds</Pre>


<p>As you might have suspected, a single list multiplication is much
faster than lots of <tT CLAss="monofont">append</tt>s. Note that in timings,
it's always a good idea to compare lots of runs of functions
instead of just one. Otherwise the timings are likely to be heavily
influenced by things that have nothing to do with the algorithm, such
as network traffic on the computer or GUI events.</P>



<P>What if you've written a complex program, and it's
running slower than you'd like, but you're not sure what
the problem spot is? In those cases, what you need to do is
<I>profile</I>
<a namE="idx730"></A> the
program: determine which parts of the program are the time-sinks and
see if they can be optimized, or if the program structure can be
modified to even out the bottlenecks. The Python distribution
includes just the right tool for that, the
<TT class="monofont">profile</tt>
<a name="idx731"></a> module, documented in the
<i>Library</i> <i>Reference</i>. Assuming
that you want to profile a given function in the current namespace,
do this:</p>



<prE cLass="monofont">&gt;&gt;&gt; <B>from timings import *</b>
&gt;&gt;&gt; <B>from makezeros import *</B>
&gt;&gt;&gt; <b>profile.run('do_timing(100, (lots_of_appends, one_multiply))')</B>
Running lots_of_appends 100 times took 8.773 seconds
Running one_multiply 100 times took 0.090 seconds
         203 function calls in 8.823 CPU seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
      100   8.574   0.086   8.574  0.086 makezeros.py:1(lots_of_appends)
      100   0.101   0.001   0.101  0.001 makezeros.py:6(one_multiply)
        1   0.001   0.001   8.823  8.823 profile:0(do_timing(100, 
                                            (lots_of_appends, one_multiply)))
        0   0.000           0.000        profile:0(profiler)
        1   0.000   0.000   8.821  8.821 python:0(194.C.2)
        1   0.147   0.147   8.821  8.821 timings.py:2(do_timing)</PrE>


<p>As you can see, this gives a fairly complicated listing, which
includes such things as per-call time spent in each function and the
number of calls made to each function. In complex programs, the
profiler can help find surprising inefficiencies. Optimizing Python
programs is beyond the scope of this book; if you're
interested, however, check the Python newsgroup: periodically, a user
asks for help speeding up a program and a spontaneous contest starts
up, with interesting advice from expert users.</P>


</FONt>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="lpython_snode92.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="lpython_snode94.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>