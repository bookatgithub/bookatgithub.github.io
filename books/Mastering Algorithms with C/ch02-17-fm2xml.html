<HTML><HEAD><TITLE>ch02-17-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 2.&nbsp; Pointer 
                  Manipulation</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch02-16-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=left 
                  border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch02-19-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=right 
                  border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch02-17-fm2xml></A>
                  <H3 class=docSection1Title>2.7 Questions and Answers</H3>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> One of the 
                  difficulties with pointers is that often when we misuse them, 
                  our errors are not caught by the compiler at compile time; 
                  they occur at runtime<A name=IXT-2-313279></A>. Which of the 
                  following result in compile-time errors<A 
                  name=IXT-2-313280></A>? Which of the following result in 
                  runtime errors? Why?</P><A name=ch02-18-fm2xml></A>
                  <P>
                  <TABLE cellSpacing=0 cellPadding=4 rules=all width="100%" 
                  border=1>
                    <COLGROUP span=2>
                    <THEAD></THEAD>
                    <TBODY>
                    <TR>
                      <TD class=docTableCell>
                        <P class=docText>a)</P><PRE>char *sptr = "abc",*tptr;
*tptr = sptr;</PRE></TD>
                      <TD class=docTableCell>
                        <P class=docText>b)</P><PRE>char *sptr = "abc",*tptr;
tptr = sptr;</PRE></TD></TR>
                    <TR>
                      <TD class=docTableCell>
                        <P class=docText>c)</P><PRE>char *sptr = "abc",*tptr;
*tptr = *sptr;</PRE></TD>
                      <TD class=docTableCell>
                        <P class=docText>d)</P><PRE>int *iptr = (int *)10;
*iptr = 11;</PRE></TD></TR>
                    <TR>
                      <TD class=docTableCell>
                        <P class=docText>e)</P><PRE>int *iptr = 10;
*iptr = 11;</PRE></TD>
                      <TD class=docTableCell>
                        <P class=docText>f )</P><PRE>int *iptr = (int *)10;
iptr = NULL;</PRE></TD></TR></COLGROUP></TBODY></TABLE></P>
                  <P class=docText><SPAN class=docEmphBold>A: </SPAN><A 
                  name=IXT-2-313281></A>a) A compile-time error occurs because 
                  when we dereference <TT><I>tptr</I></TT>, we get a character, 
                  whereas <TT><I>sptr</I></TT> is a pointer to a character. 
                  Thus, the code is trying to assign a character pointer to a 
                  character, which is a type conflict. b) No error occurs 
                  because both <TT><I>tptr</I></TT> and <TT><I>sptr</I></TT> are 
                  character pointers. c) A runtime error is likely to occur 
                  because no storage has been allocated for 
                  <TT><I>tptr</I></TT>. When we dereference 
                  <TT><I>tptr</I></TT>, we cannot be sure where it points. d) A 
                  runtime error is likely to occur because assigning an integer 
                  pointer a fixed address is dangerous. When dereferencing 
                  <TT><I>iptr</I></TT>, we try to write 11 at address 10, which 
                  is probably invalid. e) A compile-time error or warning occurs 
                  because the code is trying to initialize an integer pointer to 
                  an integer, which is a type conflict. f ) No error occurs 
                  because although the code first performs the dangerous step of 
                  initializing <TT><I>iptr</I></TT> to a fixed address, it is 
                  then immediately reset to NULL, which is valid.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Recall that 
                  calculations with pointers are performed using pointer 
                  arithmetic<A name=IXT-2-313282></A>. If <TT><I>p</I></TT> 
                  contains the address 0x10000000, what address does the 
                  following expression access? How many bytes are accessed at 
                  this address?</P><PRE>*(p + 5)</PRE>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> The answer 
                  to this question depends on the type of <TT><I>p</I></TT>. 
                  Recall that when we add an integer <SPAN 
                  class=docEmphasis>i</SPAN> to a pointer <TT><I>p</I></TT>, the 
                  result is not the address stored in <TT><I>p</I></TT> plus 
                  <SPAN class=docEmphasis>i</SPAN> bytes, but the address in 
                  <TT><I>p</I></TT>, plus <SPAN class=docEmphasis>i</SPAN> times 
                  the number of bytes in the datatype <TT><I>p</I></TT> 
                  references. Since the question does not state <TT><I>p 
                  </I></TT>'s type, it is not possible to determine the address 
                  accessed as a result of the expression. The type of 
                  <TT><I>p</I></TT> is also required to determine how many bytes 
                  <TT><I>p</I></TT> accesses. Therefore, it is also impossible 
                  to determine the number of bytes accessed.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> The 
                  operation <SPAN class=docEmphasis>list_rem_next</SPAN> removes 
                  an element from a linked list<A name=IXT-2-313283></A> (see <A 
                  class=docLink 
                  href="ch05-1-fm2xml.html#ch05-1-fm2xml">Chapter 
                  5</A>). If <TT><I>iptr</I></TT> is an integer pointer we would 
                  like set to an integer removed from a list, how might we call 
                  <SPAN class=docEmphasis>list_rem_next</SPAN> as an alternative 
                  to the approach presented in the chapter? A prototype for the 
                  function is shown here, where <TT><I>list</I></TT> is the 
                  list, <TT><I>element</I></TT> references the element preceding 
                  the one to remove, and upon return, <TT><I>data</I></TT> 
                  references the data removed.</P><PRE>int list_rem_next(List *list, ListElmt *element, void **data);</PRE>
                  <P class=docText><A name=IXT-2-313284></A><SPAN 
                  class=docEmphBold>A:</SPAN> An alternative way to call <SPAN 
                  class=docEmphasis>list_rem_next</SPAN> is shown here. In this 
                  approach, <TT><I>iptr</I></TT> is cast to a void pointer 
                  instead of a pointer to a void pointer. This method is 
                  acceptable because void pointers are compatible with all 
                  others. However, our original approach is clearer because it 
                  is consistent with the prototype of <SPAN 
                  class=docEmphasis>list_rem_next</SPAN>.</P><PRE>retval = list_rem_next(&amp;list, element, (void *)&amp;iptr);</PRE>                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch02-16-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=absMiddle 
                  border=0></A> &nbsp; <A accessKey=1 
                  href="ch02-19-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=absMiddle 
                  border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
