<HTML><HEAD><TITLE>ch02-8-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 2.&nbsp; Pointer 
                  Manipulation</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch02-4-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=left 
                  border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch02-13-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=right 
                  border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch02-8-fm2xml></A>
                  <H3 class=docSection1Title>2.4 Pointers as Parameters to 
                  Functions</H3>
                  <P class=docText>Pointers are an essential part of calling 
                  functions in C. Most importantly, they are used to support a 
                  type of <A name=ch02-idx-969918-1></A>parameter passing called 
                  <SPAN class=docEmphasis>call-by-reference</SPAN>. In 
                  call-by-reference parameter passing<A name=IXT-2-313253></A><A 
                  name=ch02-idx-926176-1></A>, when a function changes a 
                  parameter passed to it, the change persists after the function 
                  returns. Contrast this with <SPAN 
                  class=docEmphasis>call-by-value</SPAN> parameter passing, in 
                  which changes to parameters persist only within the function 
                  itself. Pointers are also an efficient means of passing large 
                  amounts of data in and out of functions, whether we plan to 
                  modify the data or not. This method is efficient because only 
                  a pointer is passed instead of a complete copy of the data. 
                  This technique is used in many of the examples in this 
                  book.</P><A name=ch02-9-fm2xml></A>
                  <H4 class=docSection2Title>2.4.1 Call-by-Reference Parameter 
                  Passing</H4>
                  <P class=docText>Formally, C supports only call-by-value 
                  parameter passing. In call-by-value parameter passing<A 
                  name=IXT-2-313254></A> <A name=IXT-2-313255></A><A 
                  name=IXT-2-313256></A>, private copies of a function's calling 
                  parameters are made for the function to use as it executes. 
                  However, we can simulate call-by-reference parameter passing 
                  by passing pointers to parameters instead of passing the 
                  parameters themselves. Using this approach, a function gets a 
                  private copy of a pointer to each parameter in the caller's 
                  environment.</P>
                  <P class=docText>To understand how this works, first consider 
                  <SPAN class=docEmphasis>swap1</SPAN>, which illustrates an 
                  incorrect implementation of a function to swap two integers 
                  using call-by-value parameter passing without pointers. <A 
                  class=docLink 
                  href="#ch02-47689">Figure 
                  2.4</A> illustrates why this does not work. The function <SPAN 
                  class=docEmphasis>swap2</SPAN> corrects the problem by using 
                  pointers to simulate call-by-reference parameter passing. <A 
                  class=docLink 
                  href="#ch02-58963">Figure 
                  2.5</A> illustrates how using pointers makes swapping proceed 
                  correctly.</P><A name=ch02-10-fm2xml></A>
                  <P>
                  <TABLE cellSpacing=0 cellPadding=4 rules=all width="100%" 
                  border=1>
                    <COLGROUP span=2>
                    <THEAD>
                    <TR>
                      <TH class=docTableHeader>
                        <P class=docText>Incorrect Swap</P></TH>
                      <TH class=docTableHeader>
                        <P class=docText>Correct Swap</P></TH></TR></THEAD>
                    <TBODY>
                    <TR>
                      <TD class=docTableCell><PRE>void swap1(int x, int y) {

int tmp;
tmp = x; x = y; y = tmp;

return;

}</PRE></TD>
                      <TD class=docTableCell><PRE>void swap2(int *x, int *y) {

int tmp;
tmp = *x; *x = *y; *y = tmp;

return;

}</PRE></TD></TR></COLGROUP></TBODY></TABLE></P>
                  <CENTER><A name=IXTR3-4></A>
                  <H5 class=docFigureTitle><A name=ch02-47689></A>Figure 2.4. An 
                  illustration of swap1, which uses call-by-value parameter 
                  passing and fails to swap two integers in the caller's 
                  environment</H5><IMG height=202 alt=figs/alc.0204.gif 
                  src="image/alc.0204.gif" width=502 border=0></CENTER>
                  <CENTER><A name=IXT-2-313257></A>
                  <H5 class=docFigureTitle><A name=ch02-58963></A>Figure 2.5. An 
                  illustration of swap2, which simulates call-by-reference 
                  parameter passing and successfully swaps two integers in the 
                  caller's environment</H5><IMG height=202 alt=figs/alc.0205.gif 
                  src="image/alc.0205.gif" width=502 border=0></CENTER>
                  <P class=docText>One of the nice things about C and 
                  call-by-reference parameter passing is that the language gives 
                  us complete control over exactly how parameter passing is 
                  performed. One disadvantage, however, is that this control can 
                  be cumbersome since we often end up having to dereference 
                  call-by-reference parameters numerous times in functions.</P>
                  <P class=docText><A name=IXT-2-313258></A><A 
                  name=IXT-2-313259></A>Another <A 
                  name=ch02-idx-969894-1></A>use of pointers in function calls 
                  occurs when we pass arrays to functions. Recalling that C 
                  treats all array names transparently as unmodifiable pointers, 
                  passing an array of objects of type <TT><I>T</I></TT> in a 
                  function is equivalent to passing a pointer to an object of 
                  type <TT><I>T</I></TT>. Thus, we can use the two approaches 
                  interchangeably. For example, function <SPAN 
                  class=docEmphasis>f1</SPAN> and function <SPAN 
                  class=docEmphasis>f2</SPAN> are equivalent.</P><A 
                  name=ch02-11-fm2xml></A>
                  <P>
                  <TABLE cellSpacing=0 cellPadding=4 rules=all width="100%" 
                  border=1>
                    <COLGROUP span=2>
                    <THEAD>
                    <TR>
                      <TH class=docTableHeader>
                        <P class=docText>Array Reference</P></TH>
                      <TH class=docTableHeader>
                        <P class=docText>Pointer Reference</P></TH></TR></THEAD>
                    <TBODY>
                    <TR>
                      <TD class=docTableCell><PRE>int f1(int a[]) {

a[0] = 5;

return 0;

}</PRE></TD>
                      <TD class=docTableCell><PRE>int f2(int *a) {

*a = 5;

return 0;

}</PRE></TD></TR></COLGROUP></TBODY></TABLE></P>
                  <P class=docText>Usually the approach chosen depends on a 
                  convention or on wanting to convey something about how the 
                  parameter is used in the function. When using an array 
                  parameter, bounds information is often omitted since it is not 
                  required by the compiler. However, including bounds 
                  information<A name=IXT-2-313260></A> can be a useful way to 
                  document a limit the function imposes on a parameter 
                  internally. Bounds information plays a more critical role with 
                  array parameters that are multidimensional.</P>
                  <P class=docText>When defining a function that accepts a 
                  multidimensional array, all but the first dimension must be 
                  specified so that pointer arithmetic can be performed when 
                  elements are accessed, as shown in the following code:</P><PRE>int g(int a[][2]) {

a[2][0] = 5;

return 0;

}</PRE>
                  <P class=docText><A name=IXT-2-313261></A><A 
                  name=IXT-2-313262></A><A name=IXT-2-313263></A>To understand 
                  why we must include all but the first dimension, imagine a 
                  two-dimensional array of integers with three rows and two 
                  columns. In C, elements are stored in row-major order at 
                  increasing addresses in memory. This means that the two 
                  integers in the first row are stored first, followed by the 
                  two integers in the second row, followed by the two integers 
                  of the third row. Therefore, to access an element in any row 
                  but the first, we must know exactly how many elements to skip 
                  in each row to get to elements in successive<A 
                  name=IXTR3-5></A> rows<A name=IXTR3-6></A> (see <A 
                  class=docLink 
                  href="#ch02-93629">Figure 
                  2.6</A>).</P>
                  <CENTER>
                  <H5 class=docFigureTitle><A name=ch02-93629></A>Figure 2.6. 
                  Writing 5 to row 2, column 0, in a 2 x 3 array of integers (a) 
                  conceptually and (b) as viewed in memory</H5><IMG height=161 
                  alt=figs/alc.0206.gif src="image/alc.0206.gif" width=502 
                  border=0></CENTER><A name=ch02-12-fm2xml></A>
                  <H4 class=docSection2Title>2.4.2 Pointers to Pointers as 
                  Parameters</H4>
                  <P class=docText>One situation in which pointers are used as 
                  parameters to functions a great deal in this book is when a 
                  function must modify a pointer passed into it.<A 
                  name=IXT-2-313264></A> To do this, the function is passed a 
                  <SPAN class=docEmphasis>pointer to the pointer</SPAN> to be 
                  modified. Consider the operation <SPAN 
                  class=docEmphasis>list_rem_next</SPAN>, which <A class=docLink 
                  href="ch05-1-fm2xml.html#ch05-1-fm2xml">Chapter 
                  5</A> defines for removing an element from a linked list. Upon 
                  return, <TT><I>data</I></TT> points to the data removed from 
                  the list:</P><PRE>int list_rem_next(List *list, ListElmt *element, void **data);</PRE>
                  <P class=docText>Since the operation must modify the pointer 
                  <TT><I>data</I></TT> to make it point to the data removed, we 
                  must pass the address of the pointer <TT><I>data</I></TT> in 
                  order to simulate call-by-reference parameter passing (see <A 
                  class=docLink 
                  href="#ch02-83141">Figure 
                  2.7</A>). Thus, the operation takes a pointer to a pointer as 
                  its third parameter. This is typical of how data is removed 
                  from most of the data structures presented in this book.</P>
                  <CENTER>
                  <H5 class=docFigureTitle><A name=ch02-83141></A>Figure 2.7. 
                  Using a function to modify a pointer to point to an integer 
                  removed from a linked list</H5><IMG height=214 
                  alt=figs/alc.0207.gif src="image/alc.0207.gif" width=502 
                  border=0></CENTER>
                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch02-4-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=absMiddle 
                  border=0></A> &nbsp; <A accessKey=1 
                  href="ch02-13-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=absMiddle 
                  border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
