<HTML><HEAD><TITLE>ch03-2-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 3.&nbsp; 
              Recursion</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch03-1-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=left 
                  border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch03-3-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=right 
                  border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch03-2-fm2xml></A>
                  <H3 class=docSection1Title>3.1 Basic Recursion</H3>
                  <P class=docText><A name=IXT-3-313288></A>To begin, let's 
                  consider a simple problem that normally we might not think of 
                  in a recursive way. Suppose we would like to compute the 
                  factorial<A name=IXT-3-313289></A> of a number <SPAN 
                  class=docEmphasis>n</SPAN>. The factorial of <SPAN 
                  class=docEmphasis>n</SPAN>, written <SPAN 
                  class=docEmphasis>n</SPAN>!, is the product of all numbers 
                  from <SPAN class=docEmphasis>n</SPAN> down to 1. For example, 
                  4! = (4)(3)(2)(1). One way to calculate this is to loop 
                  through each number and multiply it with the product of all 
                  preceding numbers. This is an <SPAN 
                  class=docEmphasis>iterative</SPAN> approach, which can be 
                  defined more formally as:</P>
                  <P class=docText><SPAN class=docEmphasis>n</SPAN>! = (<SPAN 
                  class=docEmphasis>n</SPAN>)(<SPAN class=docEmphasis>n</SPAN> - 
                  1)(<SPAN class=docEmphasis>n</SPAN> - 2) . . . (1)</P>
                  <P class=docText>Another way to look at this problem is to 
                  define <SPAN class=docEmphasis>n</SPAN>! as the product of 
                  smaller factorials. To do this, we define <SPAN 
                  class=docEmphasis>n</SPAN>! as <SPAN 
                  class=docEmphasis>n</SPAN> times the factorial of <SPAN 
                  class=docEmphasis>n</SPAN> - 1. Of course, solving (<SPAN 
                  class=docEmphasis>n</SPAN> - 1)! is the same problem as <SPAN 
                  class=docEmphasis>n</SPAN>!, only a little smaller. If we then 
                  think of (<SPAN class=docEmphasis>n</SPAN> - 1)! as <SPAN 
                  class=docEmphasis>n</SPAN> - 1 times (<SPAN 
                  class=docEmphasis>n</SPAN> - 2)!, (<SPAN 
                  class=docEmphasis>n</SPAN> - 2)! as <SPAN 
                  class=docEmphasis>n</SPAN> - 2 times (<SPAN 
                  class=docEmphasis>n</SPAN> - 3)!, and so forth until <SPAN 
                  class=docEmphasis>n</SPAN> = 1, we end up computing <SPAN 
                  class=docEmphasis>n</SPAN>!. This is a <SPAN 
                  class=docEmphasis>recursive</SPAN> approach, which can be 
                  defined more formally as:</P>
                  <P class=docText><IMG height=39 alt=figs/equation.0301.gif 
                  src="image/equation.0301.gif" width=197 border=0></P>
                  <P class=docText><A class=docLink 
                  href="#ch03-82243">Figure 
                  3.1</A> illustrates computing 4! using the recursive approach 
                  just described. It also delineates the two basic phases of a 
                  recursive process: <SPAN class=docEmphasis>winding</SPAN><A 
                  name=IXT-3-313290></A> and <SPAN 
                  class=docEmphasis>unwinding</SPAN><A name=IXT-3-313291></A>.<A 
                  name=IXT-3-313292></A> In the winding phase, each recursive 
                  call perpetuates the recursion by making an additional 
                  recursive call itself. The winding phase terminates when one 
                  of the calls reaches a <SPAN class=docEmphasis>terminating 
                  condition</SPAN>.<A name=IXT-3-313293></A> <A 
                  name=IXT-3-313294></A>A terminating condition defines the 
                  state at which a recursive function should return<A 
                  name=IXT-3-313295></A> instead of making another recursive 
                  call. For example, in computing the factorial of <SPAN 
                  class=docEmphasis>n</SPAN>, the terminating conditions are 
                  <SPAN class=docEmphasis>n</SPAN> = 1 and <SPAN 
                  class=docEmphasis>n</SPAN> = 0, for which the function simply 
                  returns 1. Every recursive function must have at least one 
                  terminating condition; otherwise, the winding phase never 
                  terminates. Once the winding phase is complete, the process 
                  enters the unwinding<A name=IXT-3-313296></A> phase, in which 
                  previous instances of the function are revisited in reverse 
                  order. This phase continues until the original call returns, 
                  at which point the recursive process is complete. <A 
                  name=IXT-3-313297></A></P>
                  <CENTER>
                  <H5 class=docFigureTitle><A name=ch03-82243></A>Figure 3.1. 
                  Computing 4! recursively</H5><IMG height=175 
                  alt=figs/alc.0301.gif src="image/alc.0301.gif" width=502 
                  border=0></CENTER>
                  <P class=docText><A name=ch03-idx-981956-1></A><A 
                  class=docLink 
                  href="#ch03-79866">Example 
                  3.1</A> presents a C function, <SPAN 
                  class=docEmphasis>fact</SPAN>, that accepts a number 
                  <TT><I>n</I></TT> and computes its factorial recursively. The 
                  function works as follows. If <TT><I>n</I></TT> is less than 
                  0, the function returns 0, indicating an error. If 
                  <TT><I>n</I></TT> is or 1, the function returns 1 because 0! 
                  and 1! are both defined as 1. These are the terminating 
                  conditions. Otherwise, the function returns the result of 
                  <TT><I>n</I></TT> times the factorial of <TT><I>n</I></TT> - 
                  1. The factorial of <TT><I>n</I></TT> - 1 is computed 
                  recursively by calling <SPAN class=docEmphasis>fact</SPAN> 
                  again, and so forth. Notice the similarities between this 
                  implementation and the recursive definition shown earlier.</P>
                  <H5 class=docExampleTitle><A name=ch03-79866></A>Example 3.1. 
                  Implementation of a Function for Computing Factorials 
                  Recursively </H5><PRE>/*****************************************************************************
*                                                                            *
*  -------------------------------- fact.c --------------------------------  *
*                                                                            *
*****************************************************************************/

#include "fact.h"

/*****************************************************************************
*                                                                            *
*  --------------------------------- fact ---------------------------------  *
*                                                                            *
*****************************************************************************/

int fact(int n) {

/*****************************************************************************
*                                                                            *
*  Compute a factorial recursively.                                          *
*                                                                            *
*****************************************************************************/

if (n &lt; 0)
   return 0;
else if (n == 0)
   return 1;
else if (n == 1)
   return 1;
else
   return n * fact(n - 1);

}</PRE>
                  <P class=docText>To understand how recursion really works, it 
                  helps to look at the way functions are executed in C. For 
                  this, we need to understand a little about the organization of 
                  a C program in memory<A name=IXT-3-313298></A>. Fundamentally, 
                  a C program consists of four areas as it executes: a code 
                  area, a static data area, a heap, and a stack (see <A 
                  class=docLink 
                  href="#ch03-28292">Figure 
                  3.2</A>a). The code area contains the machine instructions 
                  that are executed as the program runs. The static data area 
                  contains data that persists throughout the life of the 
                  program, such as global variables and static local variables. 
                  The heap contains dynamically allocated storage, such as 
                  memory allocated by <SPAN class=docEmphasis>malloc</SPAN>. The 
                  stack<A name=IXT-3-313299></A><A name=IXT-3-313300></A> 
                  contains information about function calls. By convention, the 
                  heap grows upward from one end of a program's memory, while 
                  the stack grows downward from the other (but this may vary in 
                  practice). Note that the term <SPAN 
                  class=docEmphasis>heap</SPAN> as it is used in this context 
                  has nothing to do with the heap data structure presented in <A 
                  class=docLink 
                  href="ch10-1-fm2xml.html#ch10-1-fm2xml">Chapter 
                  10</A>. <A name=IXT-3-313301></A></P>
                  <P class=docText>When a function is called in a C program, a 
                  block of storage is allocated on the stack to keep track of 
                  information associated with the call. Each call is referred to 
                  as an <SPAN class=docEmphasis>activation</SPAN>. <A 
                  name=IXT-3-313302></A>The block of storage placed on the stack 
                  is called an <SPAN class=docEmphasis>activation record</SPAN> 
                  or, alternatively, a <SPAN class=docEmphasis>stack 
                  frame</SPAN>. <A name=IXT-3-313303></A>An activation record<A 
                  name=IXT-3-313304></A> consists of five regions: incoming 
                  parameters, space for a return value, temporary storage used 
                  in evaluating expressions, saved state information for when 
                  the activation terminates, and outgoing parameters (see <A 
                  class=docLink 
                  href="#ch03-28292">Figure 
                  3.2</A>b). Incoming parameters are the parameters passed into 
                  the activation. Outgoing parameters are the parameters passed 
                  to functions called within the activation. The outgoing 
                  parameters of one activation record become the incoming 
                  parameters of the next one placed on the stack. The activation 
                  record for a function call remains on the stack until the call 
                  terminates.</P>
                  <P class=docText>Returning to <A class=docLink 
                  href="#ch03-79866">Example 
                  3.1</A>, consider what happens on the stack as one computes 
                  4!. The initial call to <SPAN class=docEmphasis>fact</SPAN> 
                  results in one activation record being placed on the stack 
                  with an incoming parameter of <SPAN class=docEmphasis>n</SPAN> 
                  = 4 (see <A class=docLink 
                  href="#ch03-41625">Figure 
                  3.3</A>, step 1). Since this activation does not meet any of 
                  the terminating conditions of the function, <SPAN 
                  class=docEmphasis>fact</SPAN> is recursively called with <SPAN 
                  class=docEmphasis>n</SPAN> set to 3. This places another 
                  activation of <SPAN class=docEmphasis>fact</SPAN> on the 
                  stack, but with an incoming parameter of <SPAN 
                  class=docEmphasis>n</SPAN> = 3 (see <A class=docLink 
                  href="#ch03-41625">Figure 
                  3.3</A>, step 2). Here, <SPAN class=docEmphasis>n</SPAN> = 3 
                  is also an outgoing parameter of the first activation since 
                  the first activation invoked the second. The process continues 
                  this way until <SPAN class=docEmphasis>n</SPAN> is 1, at which 
                  point a terminating condition is encountered and <SPAN 
                  class=docEmphasis>fact</SPAN> returns 1 (see <A class=docLink 
                  href="#ch03-41625">Figure 
                  3.3</A>, step<A name=IXTR3-8></A> 4).</P>
                  <CENTER><A name=IXT-3-313305></A>
                  <H5 class=docFigureTitle><A name=ch03-28292></A>Figure 3.2. 
                  The organization in memory of (a) a C program and (b) an 
                  activation record</H5><IMG height=238 alt=figs/alc.0302.gif 
                  src="image/alc.0302.gif" width=502 border=0></CENTER>
                  <CENTER><A name=IXT-3-313306></A><A name=IXT-3-313307></A>
                  <H5 class=docFigureTitle><A name=ch03-41625></A>Figure 3.3. 
                  The stack of a C program while computing 4! 
                  recursively</H5><IMG height=353 alt=figs/alc.0303.gif 
                  src="image/alc.0303.gif" width=502 border=0></CENTER>
                  <P class=docText>Once the <SPAN class=docEmphasis>n</SPAN> = 1 
                  activation terminates, the recursive expression in the <SPAN 
                  class=docEmphasis>n</SPAN> = 2 activation is evaluated as 
                  (2)(1) = 2. Thus, the <SPAN class=docEmphasis>n</SPAN> = 2 
                  activation terminates with a return value of 2 (see <A 
                  class=docLink 
                  href="#ch03-41625">Figure 
                  3.3</A>, step 5). Consequently, the recursive expression in 
                  the <SPAN class=docEmphasis>n</SPAN> = 3 activation is 
                  evaluated as (3)(2) = 6, and the <SPAN 
                  class=docEmphasis>n</SPAN> = 3 activation returns 6 (see <A 
                  class=docLink 
                  href="#ch03-41625">Figure 
                  3.3</A>, step 6). Finally, the recursive expression in the 
                  <SPAN class=docEmphasis>n</SPAN> = 4 activation is evaluated 
                  as (4)(6) = 24, and the <SPAN class=docEmphasis>n</SPAN> = 4 
                  activation terminates with a return value of 24 (see <A 
                  class=docLink 
                  href="#ch03-41625">Figure 
                  3.3</A>, step 7). At this point, the function has returned 
                  from the original call, and the recursive process is 
                  complete.</P>
                  <P class=docText>The stack is a great solution to storing 
                  information about <A name=IXT-3-313308></A>function calls 
                  because its last-in, first-out behavior (see <A class=docLink 
                  href="ch06-1-fm2xml.html#ch06-1-fm2xml">Chapter 
                  6</A>) is well suited to the order in which functions are 
                  called and terminated. However, stack usage does have a few 
                  drawbacks. Maintaining information about every function call 
                  until it returns takes a considerable amount of space, 
                  especially in programs with many recursive calls. In addition, 
                  generating and destroying activation records takes time 
                  because there is a significant amount of information that must 
                  be saved and restored. Thus, if the overhead<A 
                  name=IXT-3-313309></A> associated with these concerns becomes 
                  too great, we may need to consider an iterative approach. 
                  Fortunately, we can use a special type of recursion, called 
                  <SPAN class=docEmphasis>tail recursion</SPAN>, to avoid these 
                  concerns in some cases<A name=IXT-3-313310></A>.</P>                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch03-1-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=absMiddle 
                  border=0></A> &nbsp; <A accessKey=1 
                  href="ch03-3-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=absMiddle 
                  border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
