<HTML><HEAD><TITLE>ch03-4-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 3.&nbsp; 
              Recursion</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch03-3-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=left 
                  border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch03-5-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=right 
                  border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch03-4-fm2xml></A>
                  <H3 class=docSection1Title>3.3 Questions and Answers</H3>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> The 
                  following recursive definition has an error. What is it, and 
                  how can we fix it? For a positive integer <SPAN 
                  class=docEmphasis>n</SPAN>, the definition, in its proper 
                  form, is common in formally computing the running time of 
                  divide-and-conquer algorithms, such as merge sort (see <A 
                  class=docLink 
                  href="ch12-1-fm2xml.html#ch12-1-fm2xml">Chapter 
                  12</A>). Merge sort divides a set of data in half, then 
                  divides the halves in half, and continues this way until each 
                  division contains a single element. Then, during the unwinding 
                  phase, the divisions are merged to produce a final sorted 
                  set.</P>
                  <P class=docText><IMG height=38 alt=figs/equation.0303.gif 
                  src="image/equation.0303.gif" width=218 border=0></P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> The problem 
                  with this definition is that it never reaches the terminating 
                  condition<A name=IXT-3-313317></A>, <SPAN 
                  class=docEmphasis>n</SPAN> = 0, for any initial value of <SPAN 
                  class=docEmphasis>n</SPAN> greater than 0. To fix the problem, 
                  it needs an obtainable terminating condition. The condition 
                  <SPAN class=docEmphasis>n</SPAN> = 1 works well, which means 
                  we should also change the second condition in the function. A 
                  recursive definition with an acceptable terminating condition 
                  is presented here:</P>
                  <P class=docText><IMG height=37 alt=figs/equation.0304.gif 
                  src="image/equation.0304.gif" width=178 border=0></P>
                  <P class=docText>This happens to be the correct definition for 
                  the running time of merge sort. Such a function is called a 
                  <SPAN class=docEmphasis>recurrence</SPAN>. <A 
                  name=IXT-3-313318></A>In more formal analysis, recurrences are 
                  used frequently to describe the running times of recursive 
                  algorithms.</P>
                  <P class=docText><A name=IXT-3-313319></A><A 
                  name=IXT-3-313320></A><SPAN class=docEmphBold>Q:</SPAN> 
                  Describe a recursive approach for computing the prime factors 
                  of a number. Determine whether the approach is tail recursive, 
                  and describe why or why not.</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Recursion 
                  is a natural way to find the prime factors of a number because 
                  factoring is really just the same problem over and over again, 
                  only a little smaller, as we determine each factor. A 
                  recursive approach to this problem can be defined as 
shown:</P>
                  <P class=docText><IMG height=42 alt=figs/equation.0305.gif 
                  src="image/equation.0305.gif" width=422 border=0></P>
                  <P class=docText>This definition says that to determine the 
                  prime factors of a number <SPAN class=docEmphasis>n</SPAN> 
                  recursively, determine its smallest prime factor <SPAN 
                  class=docEmphasis>i</SPAN>, record this in a set of factors 
                  <SPAN class=docEmphasis>P</SPAN>, and repeat the process for 
                  <SPAN class=docEmphasis>n</SPAN> = <SPAN 
                  class=docEmphasis>n</SPAN> /<SPAN class=docEmphasis>i</SPAN>. 
                  Continue this way until <SPAN class=docEmphasis>n</SPAN> is 
                  found to be prime itself, which is the terminating condition. 
                  This definition is tail recursive because there is nothing 
                  that needs to be done during the unwinding phase, as <A 
                  class=docLink 
                  href="#ch03-95803">Figure 
                  3.6</A> confirms.</P>
                  <CENTER>
                  <H5 class=docFigureTitle><A name=ch03-95803></A>Figure 3.6. 
                  Computing the prime factors of 2409 in a tail-recursive 
                  manner</H5><IMG height=125 alt=figs/alc.0306.gif 
                  src="image/alc.0306.gif" width=502 border=0></CENTER>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Considering 
                  how the stack is used in executing recursive functions, what 
                  happens when the winding phase of a recursive process never 
                  terminates, perhaps as a result of a malformed terminating 
                  condition,<A name=IXT-3-313321></A> as in the first 
                  question?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> If the 
                  terminating condition of a recursive function is never 
                  reached, eventually the stack grows past an acceptable size 
                  and the program aborts <A name=IXT-3-313322></A>from a <SPAN 
                  class=docEmphasis>stack overflow</SPAN>. A special pointer, 
                  called the <SPAN class=docEmphasis>frame pointer</SPAN>, <A 
                  name=IXT-3-313323></A><A name=IXT-3-313324></A><A 
                  name=IXT-3-313325></A>keeps track of the top of the stack as a 
                  program executes. It is also used to determine when the stack 
                  has grown too large. An interrupt is raised to signal the 
                  error.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Recursive 
                  functions frequently offer simple yet concise ways to describe 
                  useful computations. Describe the computation that the 
                  following recursive definition describes:</P>
                  <P class=docText><IMG height=45 alt=figs/equation.0306.gif 
                  src="image/equation.0306.gif" width=209 border=0></P>
                  <P class=docText><A name=IXT-3-313326></A><SPAN 
                  class=docEmphBold>A:</SPAN> This recursive definition 
                  calculates a series like the following one, called the <SPAN 
                  class=docEmphasis>harmonic series</SPAN>. For positive 
                  integers <SPAN class=docEmphasis>n</SPAN>, the function 
                  calculates the <SPAN class=docEmphasis>n</SPAN> th harmonic 
                  number. (The calculation proceeds in reverse order from what 
                  is shown, but the following form is more recognizable.)</P>
                  <P class=docText><IMG height=32 alt=figs/equation.0307.gif 
                  src="image/equation.0307.gif" width=194 border=0></P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Is the 
                  function in the previous question tail recursive? If so, 
                  describe why. If not, describe why not and present a 
                  tail-recursive version.</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> The 
                  function defined in the previous question is not tail 
                  recursive because the return value of the recursive call is 
                  used in an expression. This expression becomes the return 
                  value of the current call. Therefore, each activation must 
                  remain on the stack until it gets the return value of 
                  subsequent activations. To make this function tail recursive, 
                  we can use an approach like the one presented earlier in the 
                  chapter for computing a factorial in a tail-recursive manner. 
                  We use an additional parameter <SPAN 
                  class=docEmphasis>a</SPAN> to keep a tally of the total value 
                  of the series computed thus far in the recursion. Formally, a 
                  tail-recursive version of the function in the previous 
                  question is as follows:</P>
                  <P class=docText><IMG height=39 alt=figs/equation.0308.gif 
                  src="image/equation.0308.gif" width=224 border=0></P>                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch03-3-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=absMiddle 
                  border=0></A> &nbsp; <A accessKey=1 
                  href="ch03-5-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=absMiddle 
                  border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
