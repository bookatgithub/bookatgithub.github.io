<HTML><HEAD><TITLE>ch04-4-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 4.&nbsp; Analysis of 
                  Algorithms</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch04-2-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=left 
                  border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch04-7-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=right 
                  border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch04-4-fm2xml></A>
                  <H3 class=docSection1Title>4.2 O-Notation</H3>
                  <P class=docText><SPAN class=docEmphasis>O</SPAN><A 
                  name=ch04-idx-987639-1></A> <A 
                  name=ch04-idx-987639-2></A>-notation<SPAN 
                  class=docEmphasis></SPAN><A name=IXT-4-313340></A> is the most 
                  common notation used to express an algorithm's performance in 
                  a formal manner. Formally, <SPAN class=docEmphasis>O</SPAN> 
                  -notation expresses the upper bound of a function within a 
                  constant factor. Specifically, if <SPAN 
                  class=docEmphasis>g</SPAN> (<SPAN class=docEmphasis>n</SPAN>) 
                  is an upper bound of <SPAN class=docEmphasis>f</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN>), then for some constant <SPAN 
                  class=docEmphasis>c</SPAN> it is possible to find a value of 
                  <SPAN class=docEmphasis>n</SPAN>, call it <SPAN 
                  class=docEmphasis>n</SPAN><SUB>0</SUB>, for which any value of 
                  <SPAN class=docEmphasis>n</SPAN> <IMG src="image/U2265.gif" 
                  border=0> <SPAN class=docEmphasis>n</SPAN><SUB>0</SUB> will 
                  result in <SPAN class=docEmphasis>f</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN>) <IMG src="image/U2264.gif" 
                  border=0> <SPAN class=docEmphasis>cg </SPAN>(<SPAN 
                  class=docEmphasis>n</SPAN>).</P>
                  <P class=docText><A name=IXT-4-313341></A><A 
                  name=IXT-4-313342></A><A name=IXT-4-313343></A><A 
                  name=IXT-4-313344></A>Normally we express an algorithm's 
                  performance as a function of the size of the data it 
                  processes. That is, for some data of size <SPAN 
                  class=docEmphasis>n</SPAN>, we describe its performance with 
                  some function <SPAN class=docEmphasis>f</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN>). However, while in many cases we 
                  can determine <SPAN class=docEmphasis>f</SPAN> exactly, 
                  usually it is not necessary to be this precise. Primarily we 
                  are interested only in the <SPAN class=docEmphasis>growth 
                  rate</SPAN> of <SPAN class=docEmphasis>f</SPAN>, which 
                  describes how quickly the algorithm's performance will degrade 
                  as the size of the data it processes becomes arbitrarily 
                  large. An algorithm's growth rate, or <SPAN 
                  class=docEmphasis>order of growth</SPAN>, is significant 
                  because ultimately it describes how <SPAN 
                  class=docEmphasis>efficient</SPAN> <A name=IXT-4-313345></A><A 
                  name=IXT-4-313346></A>the algorithm is for arbitrary inputs. 
                  <SPAN class=docEmphasis>O</SPAN> -notation reflects an 
                  algorithm's order of growth.</P><A name=ch04-5-fm2xml></A>
                  <H4 class=docSection2Title>4.2.1 Simple Rules for <SPAN 
                  class=docEmphasis>O</SPAN>-Notation</H4>
                  <P class=docText><SPAN class=docEmphasis></SPAN><A 
                  name=IXT-4-313347></A>When we look at some function <SPAN 
                  class=docEmphasis>f</SPAN> (<SPAN class=docEmphasis>n</SPAN>) 
                  in terms of its growth rate, a few things become apparent. 
                  First, we can ignore constant terms because as the value of 
                  <SPAN class=docEmphasis>n</SPAN> becomes larger and larger, 
                  eventually constant terms will become insignificant. For 
                  example, if <SPAN class=docEmphasis>T</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN>) = <SPAN class=docEmphasis>n 
                  </SPAN>+ 50 describes the running time of an algorithm, and 
                  <SPAN class=docEmphasis>n</SPAN>, the size of the data it 
                  processes, is only 1024, the constant term in this expression 
                  already constitutes less than 5% of the running time. Second, 
                  we can ignore constant multipliers of terms because they too 
                  will become insignificant as the value of <SPAN 
                  class=docEmphasis>n</SPAN> increases. For example, if <SPAN 
                  class=docEmphasis>T</SPAN><SUB>1</SUB>(<SPAN 
                  class=docEmphasis>n</SPAN>) =<SPAN class=docEmphasis> 
                  n</SPAN><SUP>2</SUP> and <SPAN 
                  class=docEmphasis>T</SPAN><SUB>2</SUB>(<SPAN 
                  class=docEmphasis>n</SPAN>) = 10<SPAN 
                  class=docEmphasis>n</SPAN> describe the running times of two 
                  algorithms for solving the same problem, <SPAN 
                  class=docEmphasis>n</SPAN> only has to be greater than 10 for 
                  <SPAN class=docEmphasis>T</SPAN><SUB>1</SUB> to become greater 
                  than <SPAN class=docEmphasis>T</SPAN><SUB>2</SUB>. Finally, we 
                  need only consider the highest-order term because, again, as 
                  <SPAN class=docEmphasis>n</SPAN> increases, higher-order terms 
                  quickly outweigh the lower-order ones. For example, if <SPAN 
                  class=docEmphasis>T</SPAN> (<SPAN class=docEmphasis>n</SPAN>) 
                  = <SPAN class=docEmphasis>n</SPAN><SUP>2</SUP> + <SPAN 
                  class=docEmphasis>n</SPAN> describes the running time of an 
                  algorithm, and <SPAN class=docEmphasis>n</SPAN> is 1024, the 
                  lesser-order term of this expression constitutes less than 
                  0.1% of the running time. These ideas are formalized in the 
                  following simple rules for expressing functions in <SPAN 
                  class=docEmphasis>O</SPAN> -notation.</P>
                  <UL>
                    <LI>
                    <P class=docList>Constant terms are expressed as <SPAN 
                    class=docEmphasis>O </SPAN>(1). When analyzing the running 
                    time of an algorithm, apply this rule when you have a task 
                    that you know will execute in a certain amount of time 
                    regardless of the size of the data it processes. Formally 
                    stated, for some constant <SPAN 
                    class=docEmphasis>c</SPAN>:</P>
                    <P class=docList><SPAN class=docEmphasis>O(c</SPAN>) = <SPAN 
                    class=docEmphasis>O</SPAN>(1)</P>
                    <LI>
                    <P class=docList>Multiplicative constants are omitted. When 
                    analyzing the running time of an algorithm, apply this rule 
                    when you have a number of tasks that all execute in the same 
                    amount of time. For example, if three tasks each run in time 
                    <SPAN class=docEmphasis>T</SPAN> (<SPAN 
                    class=docEmphasis>n</SPAN>) = <SPAN 
                    class=docEmphasis>n</SPAN>, the result is <SPAN 
                    class=docEmphasis>O</SPAN> (3<SPAN 
                    class=docEmphasis>n</SPAN>), which simplifies to <SPAN 
                    class=docEmphasis>O</SPAN> (<SPAN 
                    class=docEmphasis>n</SPAN>). Formally stated, for some 
                    constant <SPAN class=docEmphasis>c</SPAN>:</P>
                    <P class=docList><SPAN class=docEmphasis>O(cT) = cO(T) = 
                    O(T)</SPAN></P>
                    <LI>
                    <P class=docList>Addition is performed by taking the 
                    maximum. When analyzing the running time of an algorithm, 
                    apply this rule when one task is executed after another. For 
                    example, if <SPAN 
                    class=docEmphasis>T</SPAN><SUB>1</SUB>(<SPAN 
                    class=docEmphasis>n</SPAN>) = <SPAN 
                    class=docEmphasis>n</SPAN> and <SPAN 
                    class=docEmphasis>T</SPAN><SUB>2</SUB>(<SPAN 
                    class=docEmphasis>n</SPAN>) = <SPAN 
                    class=docEmphasis>n</SPAN><SUP>2</SUP> describe two tasks 
                    executed sequentially, the result is <SPAN 
                    class=docEmphasis>O </SPAN>(<SPAN 
                    class=docEmphasis>n</SPAN>) + <SPAN 
                    class=docEmphasis>O</SPAN> (<SPAN 
                    class=docEmphasis>n</SPAN><SUP>2</SUP>), which simplifies to 
                    <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                    class=docEmphasis>n</SPAN><SUP>2</SUP>). Formally 
stated:</P>
                    <P class=docList><SPAN 
                    class=docEmphasis>O(T</SPAN><SUB>1</SUB>)+<SPAN 
                    class=docEmphasis>O(T</SPAN><SUB>1</SUB>+<SPAN 
                    class=docEmphasis>T</SPAN><SUB>2</SUB>) = max (<SPAN 
                    class=docEmphasis>O(T</SPAN><SUB>1</SUB>), <SPAN 
                    class=docEmphasis>O(T</SPAN><SUB>2</SUB>))</P>
                    <LI>
                    <P class=docList>Multiplication is not changed but often is 
                    rewritten more compactly. When analyzing the running time of 
                    an algorithm, apply this rule when one task causes another 
                    to be executed some number of times for each iteration of 
                    itself. For example, in a nested loop whose outer iterations 
                    are described by <SPAN 
                    class=docEmphasis>T</SPAN><SUB>1</SUB> and whose inner 
                    iterations by <SPAN class=docEmphasis>T</SPAN><SUB>2</SUB>, 
                    if <SPAN class=docEmphasis>T</SPAN><SUB>1</SUB>(<SPAN 
                    class=docEmphasis>n</SPAN>) = <SPAN 
                    class=docEmphasis>n</SPAN> and <SPAN 
                    class=docEmphasis>T</SPAN><SUB>2</SUB>(<SPAN 
                    class=docEmphasis>n</SPAN>) = <SPAN 
                    class=docEmphasis>n</SPAN>, the result is <SPAN 
                    class=docEmphasis>O</SPAN> (<SPAN 
                    class=docEmphasis>n</SPAN>)<SPAN class=docEmphasis>O 
                    </SPAN>(<SPAN class=docEmphasis>n</SPAN>), or <SPAN 
                    class=docEmphasis>O</SPAN> (<SPAN 
                    class=docEmphasis>n</SPAN><SUP>2</SUP>). Formally 
stated:</P>
                    <P class=docList><SPAN 
                    class=docEmphasis>O(T</SPAN><SUB>1</SUB>)<SPAN 
                    class=docEmphasis>O(T</SPAN><SUB>2</SUB>) = <SPAN 
                    class=docEmphasis>O(T</SPAN><SUB>1</SUB> <SPAN 
                    class=docEmphasis>T</SPAN><SUB>2</SUB>)</P></LI></UL><A 
                  name=ch04-6-fm2xml></A>
                  <H4 class=docSection2Title>4.2.2 <SPAN 
                  class=docEmphasis>O</SPAN>-Notation Example and Why It 
                  Works</H4>
                  <P class=docText><SPAN class=docEmphasis></SPAN><A 
                  name=IXT-4-313348></A>The next section discusses how these 
                  rules help us in predicting an algorithm's performance. For 
                  now, let's look at a specific example demonstrating why they 
                  work so well in describing a function's growth rate. Suppose 
                  we have an algorithm whose running time is described by the 
                  function <SPAN class=docEmphasis>T</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN>) = 3<SPAN 
                  class=docEmphasis>n</SPAN><SUP>2</SUP> + 10<SPAN 
                  class=docEmphasis>n</SPAN> + 10. Using the rules of <SPAN 
                  class=docEmphasis>O</SPAN> -notation, this function can be 
                  simplified to:</P>
                  <P class=docText><SPAN class=docEmphasis>O(T(n))</SPAN> = 
                  <SPAN class=docEmphasis>O</SPAN>(3<SPAN 
                  class=docEmphasis>n</SPAN><SUP>2</SUP> + 10<SPAN 
                  class=docEmphasis>n</SPAN> + 10) = <SPAN 
                  class=docEmphasis>O</SPAN>(3<SPAN 
                  class=docEmphasis>n</SPAN><SUP>2</SUP>) = <SPAN 
                  class=docEmphasis>O(n</SPAN><SUP>2</SUP>)</P>
                  <P class=docText>This indicates that the term containing <SPAN 
                  class=docEmphasis>n</SPAN><SUP>2</SUP> will be the one that 
                  accounts for most of the running time as <SPAN 
                  class=docEmphasis>n</SPAN> grows arbitrarily large. We can 
                  verify this quantitatively by computing the percentage of the 
                  overall running time that each term accounts for as <SPAN 
                  class=docEmphasis>n</SPAN> increases. For example, when <SPAN 
                  class=docEmphasis>n</SPAN> = 10, we have the following:</P>
                  <DL class=docList>
                    <DD>Running time for 3<SPAN 
                    class=docEmphasis>n</SPAN><SUP>2</SUP>: 
                    3(10)<SUP>2</SUP>/(3(10)<SUP>2</SUP> + 10(10) + 10) = 73.2% 
                    <DD>Running time for 10<SPAN class=docEmphasis>n</SPAN>: 
                    10(10)/(3(10)<SUP>2</SUP> + 10(10) + 10) = 24.4% 
                    <DD>Running time for 10: 10/(3(10)<SUP>2</SUP> + 10(10) + 
                    10) = 2.4% </DD></DL>
                  <P class=docText>Already we see that the <SPAN 
                  class=docEmphasis>n</SPAN><SUP>2</SUP> term accounts for the 
                  majority of the overall running time. Now consider when <SPAN 
                  class=docEmphasis>n</SPAN> = 100:</P>
                  <DL class=docList>
                    <DD>Running time for 3<SPAN 
                    class=docEmphasis>n</SPAN><SUP>2</SUP>: 
                    3(100)<SUP>2</SUP>/(3(100)<SUP>2</SUP> + 10(100) + 10) = 
                    96.7% (Higher) 
                    <DD>Running time for 10<SPAN class=docEmphasis>n</SPAN>: 
                    10(100)/(3(100)<SUP>2</SUP> + 10(100) + 10) = 3.2% (Lower) 
                    <DD>Running time for 10: 10/(3(100)<SUP>2</SUP> + 10(100) + 
                    10) &lt; 0.1% (Lower) </DD></DL>
                  <P class=docText>Here we see that this term accounts for <SPAN 
                  class=docEmphasis>almost all</SPAN> of the running time, while 
                  the significance of the other terms diminishes further. 
                  Imagine how much of the running time this term would account 
                  for if <SPAN class=docEmphasis>n</SPAN> were 
                  10<SUP>6</SUP>!<SPAN class=docEmphasis></SPAN><A 
                  name=IXTR3-10></A> <A name=IXTR3-11></A></P>
                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch04-2-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=absMiddle 
                  border=0></A> &nbsp; <A accessKey=1 
                  href="ch04-7-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=absMiddle 
                  border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
