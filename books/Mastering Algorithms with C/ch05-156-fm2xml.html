<HTML><HEAD><TITLE>ch05-156-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 5.&nbsp; Linked 
              Lists</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch05-155-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=left 
                  border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch05-157-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=right 
                  border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch05-156-fm2xml></A>
                  <H3 class=docSection1Title>5.12 Questions and Answers</H3>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Some 
                  advantages of linked lists over <A 
                  name=IXT-5-313555></A>arrays have already been mentioned. 
                  However, there are occasions when arrays have advantages over 
                  linked lists. When are arrays preferable?</P>
                  <P class=docText><A name=IXT-5-313556></A><SPAN 
                  class=docEmphBold>A:</SPAN> Linked lists present advantages 
                  over arrays when we expect to insert and remove elements 
                  frequently. However, arrays themselves offer some advantages 
                  when we expect the number of random accesses to overshadow the 
                  number of insertions and deletions. Arrays are strong in this 
                  case because their elements are arranged contiguously in 
                  memory. This contiguous arrangement allows any element to be 
                  accessed in <SPAN class=docEmphasis>O</SPAN> (1) time by using 
                  its index. Recall that to access an element of a linked list, 
                  we must have a pointer to the element itself. Getting a 
                  pointer to an element can be expensive if we do not know a 
                  great deal about the pattern in which the elements will be 
                  accessed. In practice, for many applications, we end up 
                  traversing at least part of the list. Arrays are also 
                  advantageous when storage is at a premium because they do not 
                  require additional pointers to keep their elements "linked" 
                  together.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> How do the 
                  operations of linked lists for inserting, removing, and 
                  accessing elements compare with similar ones for arrays?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Recall that 
                  all of the operations presented for each of the linked list 
                  variations in this chapter had runtime complexities of <SPAN 
                  class=docEmphasis>O</SPAN> (1), with the exception of the 
                  destroy operations. Indeed, this seems tough to beat. What the 
                  analyses for linked lists do not show, however, is that for 
                  many linked list operations, retrieving a pointer to a 
                  specific element in the list can involve a significant cost. 
                  For example, if we are not careful, in the worst case we could 
                  end up traversing the entire list at a cost of <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>n</SPAN>), 
                  where <SPAN class=docEmphasis>n</SPAN> is the number of 
                  elements in the list. On the other hand, a well-suited 
                  application, such as the frame management example presented in 
                  this chapter, may have virtually no overhead for this at all. 
                  Therefore, it is important to look at the specifics of the 
                  application. With arrays, insertion and removal are both <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>n</SPAN>) 
                  operations because in the worst case of accessing position 0, 
                  all other elements must be moved one slot to adjust for the 
                  addition or deletion of the element. Accessing an element in 
                  an array is an <SPAN class=docEmphasis>O</SPAN> (1) operation, 
                  provided we know its index.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Suppose we 
                  would like to build a <SPAN 
                  class=docEmphasis>list_ins_pos</SPAN> function on top of the 
                  linked list implementation in this chapter to insert an 
                  element after a specified position, akin to an array. For 
                  example, suppose we would like to specify that an element 
                  should be inserted after the tenth element instead of 
                  providing a pointer to it. What is the runtime complexity of 
                  this function?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> This 
                  function has a runtime complexity of <SPAN class=docEmphasis>O 
                  </SPAN>(<SPAN class=docEmphasis>n</SPAN>) because generally 
                  the only means of knowing when we are at a specific position 
                  in a linked list is to start at the head and count the number 
                  of elements while moving to it. Here is an application that 
                  suffers profoundly from the access problem described in the 
                  previous question. That is, the insertion operation itself is 
                  <SPAN class=docEmphasis>O </SPAN>(1), but getting to the 
                  required position in the list is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN>).</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Recall that 
                  <SPAN class=docEmphasis>list_rem_next</SPAN> removes an 
                  element from a singly-linked list <SPAN 
                  class=docEmphasis>after</SPAN> a specified element. Why is no 
                  operation provided for singly-linked lists to remove the 
                  specified element itself, analogous to the <SPAN 
                  class=docEmphasis>dlist_remove</SPAN> operation for 
                  doubly-linked lists? (One can ask the same for the circular 
                  list implementation. )</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> In the 
                  singly-linked list<A name=IXT-5-313557></A> and circular list 
                  implementations, each element does not have a pointer to the 
                  one preceding it. Therefore, we cannot set the preceding 
                  element's <SPAN class=docEmphasis>next</SPAN> pointer to the 
                  element after the one being removed. An alternative approach 
                  to the one we selected would be to start at the head element 
                  and traverse the list, keeping track of each element preceding 
                  the next until the element to be removed is encountered. 
                  However, this solution is unattractive because the runtime 
                  complexity of removing an element from a singly-linked list or 
                  circular list degrades to <SPAN class=docEmphasis>O</SPAN> 
                  (<SPAN class=docEmphasis>n</SPAN>). Another approach would be 
                  to copy the data of the element following the specified 
                  element into the one specified and then remove the following 
                  element. However, this seemingly benign <SPAN 
                  class=docEmphasis>O</SPAN> (1) approach generates the 
                  dangerous side effect of rendering a pointer into the list 
                  invalid. This could be a surprise to a developer maintaining a 
                  pointer to the element after the one thought to be removed! 
                  The approach we selected, then, was to remove the element 
                  after the specified one. The disadvantage of this approach is 
                  its inconsistency with the <SPAN 
                  class=docEmphasis>dlist_remove</SPAN> operation of the 
                  doubly-linked list implementation. However, this is addressed 
                  by the naming convention, using <SPAN 
                  class=docEmphasis>_rem_next</SPAN> as the suffix for removing 
                  an element after the one specified, and <SPAN 
                  class=docEmphasis>_remove</SPAN> to indicate that the 
                  specified element itself will be removed. In a doubly-linked 
                  list, recall that we can remove precisely the element 
                  specified because each element has a pointer to the one that 
                  precedes it.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Recall that 
                  each of the linked list data structures presented in this 
                  chapter has a <TT><I>size</I></TT> member. The 
                  <TT><I>List</I></TT> and <TT><I>DList</I></TT> data structures 
                  also contain a <TT><I>tail</I></TT> member. Why are each of 
                  these members included?</P>
                  <P class=docText><A name=IXT-5-313558></A><SPAN 
                  class=docEmphBold>A:</SPAN> By updating these members 
                  dynamically as elements are inserted and removed, we avoid the 
                  <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN>) runtime complexity of traversing 
                  the list each time its tail element or size is requested. By 
                  maintaining these members, fetching a list's tail element or 
                  size becomes an <SPAN class=docEmphasis>O</SPAN> (1) operation 
                  without adding any complexity to the operations for inserting 
                  and removing elements.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Insertion 
                  before the head of a list using NULL for the 
                  <TT><I>element</I></TT> argument is used only in the 
                  singly-linked list implementation. Why is this not necessary 
                  for doubly-linked lists or circular lists?</P>
                  <P class=docText><A name=IXT-5-313559></A><SPAN 
                  class=docEmphBold>A:</SPAN> Insertion before the head element 
                  of a doubly-linked list is possible using the <SPAN 
                  class=docEmphasis>prev</SPAN> pointer of the head element 
                  itself. In a circular list, an element is inserted before the 
                  head by inserting the element after the last element using 
                  <SPAN class=docEmphasis>clist_ins_next</SPAN>. Remember, in a 
                  circular list, the last element points back to the first 
                  element.</P>                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch05-155-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=absMiddle 
                  border=0></A> &nbsp; <A accessKey=1 
                  href="ch05-157-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=absMiddle 
                  border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
