<HTML><HEAD><TITLE>ch06-66-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 6.&nbsp; Stacks and 
                Queues</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch06-60-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=left 
                  border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch06-67-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=right 
                  border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch06-66-fm2xml></A>
                  <H3 class=docSection1Title>6.7 Queue Example: Event 
                  Handling</H3>
                  <P class=docText><A name=ch06-idx-85390-1></A><A 
                  name=IXT-6-313655></A>One <A 
                  name=ch06-idx-973904-1></A>popular application of queues is 
                  handling events in event-driven applications. Event-driven 
                  applications execute largely under the direction of real-time 
                  occurrences called <SPAN class=docEmphasis>events</SPAN>.<A 
                  name=IXT-6-313656></A> In a graphical user interface developed 
                  in <A name=IXT-6-313657></A>Java, <A name=IXT-6-313658></A>X, 
                  or Windows, for example, the behavior of an application 
                  depends a great deal on key presses, mouse movements, and 
                  other events triggered by the user. Other examples of 
                  event-driven applications occur frequently in control systems 
                  such as those found in aircraft or factory equipment.</P>
                  <P class=docText>In nearly all event-driven applications<A 
                  name=IXT-6-313659></A>, events can occur at any moment, so 
                  queues play an important role in storing events until an 
                  application is ready to deal with them. A queue works well for 
                  this because applications handle events more or less in the 
                  same order as they occur.</P>
                  <P class=docText><A class=docLink 
                  href="#ch06-42663">Example 
                  6.5</A> presents two functions for handling events: <SPAN 
                  class=docEmphasis>receive_event</SPAN> <A 
                  name=IXT-6-313660></A>and <SPAN 
                  class=docEmphasis>process_event</SPAN><A 
                  name=IXT-6-313661></A>. Both functions operate on a queue 
                  containing events of type <TT><I>Event</I></TT>. 
                  <TT><I>Event</I></TT> is defined in <I>event.h</I>, which is 
                  not shown. An application calls <SPAN 
                  class=docEmphasis>receive_event</SPAN> to enqueue an event<A 
                  name=IXT-6-313662></A><A name=IXT-6-313663></A> it has been 
                  notified about. Exactly how an application is notified of an 
                  event varies, but notification often begins with a hardware 
                  interrupt. When the application decides it is time to process 
                  an event, it calls <SPAN 
                  class=docEmphasis>process_event</SPAN>. Inside of <SPAN 
                  class=docEmphasis>process_event</SPAN>, an event<A 
                  name=IXT-6-313664></A><A name=IXT-6-313665></A> is dequeued 
                  from the event queue and is passed to an application-specific 
                  dispatch function.<A name=IXT-6-313666></A> The dispatch 
                  function is passed to <SPAN 
                  class=docEmphasis>process_event</SPAN> as the parameter 
                  <TT><I>dispatch</I></TT>. The purpose of the dispatch function 
                  is to take the appropriate action to handle the event. There 
                  are two approaches <TT><I>dispatch</I></TT> can take to do 
                  this: it can process the event <SPAN 
                  class=docEmphasis>synchronously</SPAN>, so that no other 
                  processing is performed until handling the event is completed; 
                  or it can process the event <SPAN 
                  class=docEmphasis>asynchronously</SPAN>, in which case it 
                  starts a separate process to handle the event while the main 
                  process moves on. Asynchronous event handling usually is more 
                  efficient, but it requires particularly careful coordination 
                  between the main and subordinate processes.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>receive_event</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (1) because it simply calls the 
                  <SPAN class=docEmphasis>O</SPAN> (1) queue operation <SPAN 
                  class=docEmphasis>queue_enqueue</SPAN>. The runtime complexity 
                  of <SPAN class=docEmphasis>process_event</SPAN> depends on the 
                  dispatch function it invokes. The rest of <SPAN 
                  class=docEmphasis>process_event</SPAN> runs in a constant 
                  amount of time.</P>
                  <H5 class=docExampleTitle><A name=ch06-42663></A>Example 6.5. 
                  Implementation of Functions for Handling Events </H5><PRE>/*****************************************************************************
*                                                                            *
*  ------------------------------- events.c -------------------------------  *
*                                                                            *
*****************************************************************************/

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "event.h"
#include "events.h"
#include "queue.h"

/*****************************************************************************
*                                                                            *
*  ---------------------------- receive_event -----------------------------  *
*                                                                            *
*****************************************************************************/

int receive_event(Queue *events, const Event *event) {

Event              *new_event;

/*****************************************************************************
*                                                                            *
*  Allocate space for the event.                                             *
*                                                                            *
*****************************************************************************/

if ((new_event = (Event *)malloc(sizeof(Event))) == NULL)
   return -1;

/*****************************************************************************
*                                                                            *
*  Make a copy of the event and enqueue it.                                  *
*                                                                            *
*****************************************************************************/

memcpy(new_event, event, sizeof(Event));

if (queue_enqueue(events, new_event) != 0)
   return -1;

return 0;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- process_event -----------------------------  *
*                                                                            *
*****************************************************************************/

int process_event(Queue *events, int (*dispatch)(Event *event)) {

Event              *event;

if (queue_size(events) == 0)

   /**************************************************************************
   *                                                                         *
   *  Return that there are no events to dispatch.                           *
   *                                                                         *
   **************************************************************************/

   return -1;

else {

   if (queue_dequeue(events, (void **)&amp;event) != 0)

      /***********************************************************************
      *                                                                      *
      *  Return that an event could not be retrieved.                        *
      *                                                                      *
      ***********************************************************************/

      return -1;

   else {

      /***********************************************************************
      *                                                                      *
      *  Call a user-defined function to dispatch the event.                 *
      *                                                                      *
      ***********************************************************************/

      dispatch(event);
      free(event);

   }

}

return<A name=IXTR3-32></A> 0;

}<A name=IXTR3-33></A></PRE>
                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch06-60-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=absMiddle 
                  border=0></A> &nbsp; <A accessKey=1 
                  href="ch06-67-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=absMiddle 
                  border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
