<HTML><HEAD><TITLE>ch07-51-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 7.&nbsp; 
            Sets</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch07-6-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=left 
                  border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch07-63-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=right 
                  border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch07-51-fm2xml></A>
                  <H3 class=docSection1Title>7.3 Implementation and Analysis of 
                  Sets</H3>
                  <P class=docText><A name=ch07-idx-974104-1></A>The structure 
                  <TT><I>Set</I></TT> is the set data structure<A 
                  name=IXT-7-313737></A>. A good way to implement a set is as a 
                  linked list<A name=IXT-7-313738></A>. A simple way to do this 
                  is to typedef <TT><I>Set</I></TT> to <TT><I>List</I></TT> (see 
                  <A class=docLink 
                  href="#ch07-62177">Example 
                  7.1</A>). In addition to simplicity, using a typedef has the 
                  benefit of making the set somewhat polymorphic, just as was 
                  described for stacks and queues (see <A class=docLink 
                  href="ch06-1-fm2xml.html#ch06-1-fm2xml">Chapter 
                  6</A>). Thus, because the set is a linked list, we can use 
                  linked list operations on it when we want it to act like one. 
                  The biggest benefit of this with sets is that we can use <SPAN 
                  class=docEmphasis>list_next</SPAN> <A name=IXT-7-313739></A><A 
                  name=IXT-7-313740></A>to traverse a set, and <SPAN 
                  class=docEmphasis>list_rem_next</SPAN> to remove members 
                  without having to identify them by the data they store. Recall 
                  that <SPAN class=docEmphasis>set_remove</SPAN> only removes 
                  members keyed by their data, which can be a problem when we do 
                  not know the members a set contains.</P>
                  <P class=docText>In general, the set operations presented here 
                  are somewhat costly, primarily because many of them search for 
                  members of one set in another by traversing each member. 
                  However, we can improve the running times of these operations 
                  by using a more efficient searching technique, such as hashing 
                  (see <A class=docLink 
                  href="ch08-1-fm2xml.html#ch08-1-fm2xml">Chapter 
                  8</A>). Nevertheless, the implementation provided here is a 
                  general-purpose approach whose performance is adequate for 
                  small to medium-sized sets of data.</P>
                  <H5 class=docExampleTitle><A name=ch07-62177></A>Example 7.1. 
                  Header for the Set Abstract Datatype </H5><PRE>/*****************************************************************************
*                                                                            *
*  -------------------------------- set.h ---------------------------------  *
*                                                                            *
*****************************************************************************/

#ifndef SET_H
#define SET_H

#include &lt;stdlib.h&gt;

#include "list.h"

/*****************************************************************************
*                                                                            *
*  Implement sets as linked lists.                                           *
*                                                                            *
*****************************************************************************/

typedef List Set;

/*****************************************************************************
*                                                                            *
*  --------------------------- Public Interface ---------------------------  *
*                                                                            *
*****************************************************************************/

void set_init(Set *set, int (*match)(const void *key1, const void *key2),
   void (*destroy)(void *data));

#define set_destroy list_destroy

int set_insert(Set *set, const void *data);

int set_remove(Set *set, void **data);

int set_union(Set *setu, const Set *set1, const Set *set2);

int set_intersection(Set *seti, const Set *set1, const Set *set2);

int set_difference(Set *setd, const Set *set1, const Set *set2);

int set_is_member(const Set *set, const void *data);

int set_is_subset(const Set *set1, const Set *set2);

int set_is_equal(const Set *set1, const Set *set2);

#define set_size(set) ((set)-&gt;size)

#endif</PRE><A name=ch07-52-fm2xml></A>
                  <H4 class=docSection2Title>7.3.1 set_init</H4>
                  <P class=docText><A name=IXT-7-313741></A><A 
                  name=IXT-7-313742></A>The <SPAN 
                  class=docEmphasis>set_init</SPAN> operation initializes a set 
                  so that it can be used in other operations (see <A 
                  class=docLink 
                  href="#ch07-20227">Example 
                  7.2</A>). Since a set is a linked list, <SPAN 
                  class=docEmphasis>list_init </SPAN>is called to initialize it. 
                  The <TT><I>match</I></TT> member is set to 
                  <TT><I>match</I></TT> by hand because this member is not used 
                  by linked lists and is therefore not set by <SPAN 
                  class=docEmphasis>list_init</SPAN>.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>set_init</SPAN> is the same as <SPAN 
                  class=docEmphasis>list_init</SPAN>, or <SPAN 
                  class=docEmphasis>O</SPAN> (1).</P><A name=ch07-53-fm2xml></A>
                  <H4 class=docSection2Title>7.3.2 set_destroy</H4>
                  <P class=docText><A name=IXT-7-313743></A><A 
                  name=IXT-7-313744></A>The <SPAN 
                  class=docEmphasis>set_destroy</SPAN> operation destroys a set 
                  (see <A class=docLink 
                  href="#ch07-62177">Example 
                  7.1</A>). Since a set is a linked list and requires being 
                  destroyed in the same manner, <SPAN 
                  class=docEmphasis>set_destroy</SPAN> is defined to <SPAN 
                  class=docEmphasis>list_destroy</SPAN>.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>set_destroy</SPAN> is the same as <SPAN 
                  class=docEmphasis>list_destroy</SPAN>, or<SPAN 
                  class=docEmphasis> O</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN>), where <SPAN 
                  class=docEmphasis>n</SPAN> is the number of members in the 
                  set.</P><A name=ch07-54-fm2xml></A>
                  <H4 class=docSection2Title>7.3.3 set_insert</H4>
                  <P class=docText><A name=IXT-7-313745></A><A 
                  name=IXT-7-313746></A>The <SPAN 
                  class=docEmphasis>set_insert</SPAN> operation inserts a member 
                  into a set (see <A class=docLink 
                  href="#ch07-20227">Example 
                  7.2</A>). Since a member must not occur more than once in a 
                  set, <SPAN class=docEmphasis>set_is_member</SPAN> is called to 
                  make sure that the set does not already contain the new 
                  member. As long as the member does not already exist in the 
                  set, <SPAN class=docEmphasis>list_ins_next</SPAN> is called to 
                  insert the member.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>set_insert</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>n</SPAN>) 
                  because <SPAN class=docEmphasis>set_is_member</SPAN> runs in 
                  <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN>) time, and <SPAN 
                  class=docEmphasis>list_ins_next</SPAN> runs in <SPAN 
                  class=docEmphasis>O</SPAN> (1).</P><A name=ch07-55-fm2xml></A>
                  <H4 class=docSection2Title>7.3.4 set_remove</H4>
                  <P class=docText><A name=IXT-7-313747></A><A 
                  name=IXT-7-313748></A>The <SPAN 
                  class=docEmphasis>set_remove</SPAN> operation removes a member 
                  from a set by traversing it using <SPAN 
                  class=docEmphasis>list_next</SPAN> until <TT><I>match</I></TT> 
                  determines that the member to be removed has been found (see 
                  <A class=docLink 
                  href="#ch07-20227">Example 
                  7.2</A>). The pointer <TT><I>prev</I></TT> points just before 
                  the member to be removed since this is required by <SPAN 
                  class=docEmphasis>list_rem_next</SPAN>. The <SPAN 
                  class=docEmphasis>list_rem_next</SPAN> operation sets 
                  <TT><I>data</I></TT> to point to the data from the member 
                  removed.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>set_remove</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>n</SPAN>), 
                  where <SPAN class=docEmphasis>n</SPAN> is the number of 
                  elements in the set. This is because, in the worst case, the 
                  entire set must be traversed in order to find the member to be 
                  removed. This results in <SPAN class=docEmphasis>n</SPAN> 
                  times <SPAN class=docEmphasis>O</SPAN> (1), the cost of the 
                  statements within the loop, for a running time of <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>n</SPAN>) 
                  overall. Once the member is found, <SPAN 
                  class=docEmphasis>list_rem_next</SPAN> removes it in <SPAN 
                  class=docEmphasis>O</SPAN> (1) time.</P><A 
                  name=ch07-56-fm2xml></A>
                  <H4 class=docSection2Title>7.3.5 set_union</H4>
                  <P class=docText><A name=IXT-7-313749></A><A 
                  name=IXT-7-313750></A><A name=IXT-7-313751></A>The <SPAN 
                  class=docEmphasis>set_union</SPAN> operation builds a set, 
                  <TT><I>setu</I></TT>, which is the union of the sets 
                  <TT><I>set1</I></TT> and <TT><I>set2</I></TT> (see <A 
                  class=docLink 
                  href="#ch07-20227">Example 
                  7.2</A>). First, <TT><I>setu</I></TT> is initialized by 
                  calling <SPAN class=docEmphasis>set_init</SPAN>. Next, the 
                  members of <TT><I>set1</I></TT> are inserted into 
                  <TT><I>setu</I></TT> by calling <SPAN 
                  class=docEmphasis>list_ins_next</SPAN> repeatedly for each 
                  member of <TT><I>set1</I></TT>. Finally, the members of 
                  <TT><I>set2</I></TT> are inserted into <TT><I>setu</I></TT> in 
                  a similar manner except that <SPAN 
                  class=docEmphasis>set_is_member</SPAN> is called before each 
                  insertion to ensure that no members are duplicated in 
                  <TT><I>setu</I></TT>.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>set_union</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>mn</SPAN>), where <SPAN 
                  class=docEmphasis>m</SPAN> is the size of <TT><I>set1</I></TT> 
                  and <SPAN class=docEmphasis>n</SPAN> is the size of 
                  <TT><I>set2</I></TT>. In the first loop, each member of 
                  <TT><I>set1</I></TT> is traversed and inserted into 
                  <TT><I>setu</I></TT>, which results in a running time of <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>m</SPAN>). 
                  In the second loop, each element of <TT><I>set2</I></TT> is 
                  traversed, which results in <SPAN class=docEmphasis>n</SPAN> 
                  times the cost of the statements within this loop. This loop 
                  contains the <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>m</SPAN>) operation <SPAN 
                  class=docEmphasis>set_is_member</SPAN>. Therefore, the overall 
                  complexity of the loop is <SPAN class=docEmphasis>O</SPAN> 
                  (<SPAN class=docEmphasis>mn</SPAN>). Since the two loops are 
                  executed one after another, the complexity of <SPAN 
                  class=docEmphasis>set_union</SPAN> is the more expensive of 
                  the two, or <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>mn</SPAN>).</P><A name=ch07-57-fm2xml></A>
                  <H4 class=docSection2Title>7.3.6 set_intersection</H4>
                  <P class=docText><A name=IXT-7-313752></A><A 
                  name=IXT-7-313753></A><A name=IXT-7-313754></A>The <SPAN 
                  class=docEmphasis>set_intersection</SPAN> operation builds a 
                  set, <TT><I>seti</I></TT>, which is the intersection of the 
                  sets <TT><I>set1</I></TT> and <TT><I>set2</I></TT> (see <A 
                  class=docLink 
                  href="#ch07-20227">Example 
                  7.2</A>). First, <TT><I>seti</I></TT> is initialized by 
                  calling <SPAN class=docEmphasis>set_init</SPAN>. Next, for 
                  each member of <TT><I>set1</I></TT>, <SPAN 
                  class=docEmphasis>set_is_member</SPAN> is called to determine 
                  whether the member is in <TT><I>set2</I></TT>. If so, the 
                  member is inserted into <TT><I>seti</I></TT>.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>set_intersection</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>mn</SPAN>), where <SPAN 
                  class=docEmphasis>m</SPAN> is the size of <TT><I>set1</I></TT> 
                  and <SPAN class=docEmphasis>n</SPAN> is the size of 
                  <TT><I>set2</I></TT>. This is because for each member in 
                  <TT><I>set1</I></TT>, the <SPAN class=docEmphasis>O</SPAN> 
                  (<SPAN class=docEmphasis>n</SPAN>) operation <SPAN 
                  class=docEmphasis>set_is_member</SPAN> is called to determine 
                  whether the member is in <TT><I>set2</I></TT>.</P><A 
                  name=ch07-58-fm2xml></A>
                  <H4 class=docSection2Title>7.3.7 set_difference</H4>
                  <P class=docText><A name=IXT-7-313755></A><A 
                  name=IXT-7-313756></A>The <SPAN 
                  class=docEmphasis>set_difference</SPAN> operation builds a 
                  set, <TT><I>setd</I></TT>, which is the difference of the sets 
                  <TT><I>set1</I></TT> and <TT><I>set2</I></TT> (see <A 
                  class=docLink 
                  href="#ch07-20227">Example 
                  7.2</A>). First, <TT><I>setd</I></TT> is initialized by 
                  calling <SPAN class=docEmphasis>set_init</SPAN>. Next, for 
                  each member of <TT><I>set1</I></TT>, <SPAN 
                  class=docEmphasis>set_is_member</SPAN> is called to determine 
                  whether the member is in <TT><I>set2</I></TT>. If not, the 
                  member is inserted into <TT><I>setd</I></TT>.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>set_difference</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>mn</SPAN>), where <SPAN 
                  class=docEmphasis>m</SPAN> is the size of <TT><I>set1</I></TT> 
                  and <SPAN class=docEmphasis>n</SPAN> is the size of 
                  <TT><I>set2</I></TT>. This is because for each member in 
                  <TT><I>set1</I></TT>, the <SPAN class=docEmphasis>O</SPAN> 
                  (<SPAN class=docEmphasis>n</SPAN>) operation <SPAN 
                  class=docEmphasis>set_is_member</SPAN> is called to determine 
                  whether the member is in <TT><I>set2</I></TT>.</P><A 
                  name=ch07-59-fm2xml></A>
                  <H4 class=docSection2Title>7.3.8 set_is_member</H4>
                  <P class=docText><A name=IXT-7-313757></A><A 
                  name=IXT-7-313758></A><A name=IXT-7-313759></A>The <SPAN 
                  class=docEmphasis>set_is_member</SPAN> operation determines 
                  whether a particular member exists in a set (see <A 
                  class=docLink 
                  href="#ch07-20227">Example 
                  7.2</A>). This is accomplished by traversing the set using 
                  <SPAN class=docEmphasis>list_next</SPAN> until either a member 
                  matching <TT><I>data</I></TT> is found or all members are 
                  traversed.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>set_is_member</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>n</SPAN>), 
                  where <SPAN class=docEmphasis>n</SPAN> is the number of 
                  members in the set. This is because, in the worst case, the 
                  entire set must be traversed to find the member for which we 
                  are searching.</P><A name=ch07-60-fm2xml></A>
                  <H4 class=docSection2Title>7.3.9 set_is_subset</H4>
                  <P class=docText><A name=IXT-7-313760></A><A 
                  name=IXT-7-313761></A><A name=IXT-7-313762></A>The <SPAN 
                  class=docEmphasis>set_is_subset</SPAN> operation determines 
                  whether one set, <TT><I>set1</I></TT>, is a subset of another 
                  set, <TT><I>set2</I></TT> (see <A class=docLink 
                  href="#ch07-20227">Example 
                  7.2</A>). Since a set that is a subset of another must be the 
                  same size or smaller, we begin by comparing sizes. If this 
                  test fails, then <TT><I>set1</I></TT> is not a subset of 
                  <TT><I>set2</I></TT>. Otherwise, <TT><I>set1</I></TT> is 
                  traversed using <SPAN class=docEmphasis>list_next</SPAN> until 
                  either a member of <TT><I>set1</I></TT> that is not in 
                  <TT><I>set2</I></TT> is found or all members are traversed. If 
                  we find a member of <TT><I>set1</I></TT> not in 
                  <TT><I>set2</I></TT>, then <TT><I>set1</I></TT> is not a 
                  subset of <TT><I>set2</I></TT>. If we end up traversing all 
                  members of <TT><I>set1</I></TT>, then <TT><I>set1</I></TT> is 
                  a subset of <TT><I>set2</I></TT>.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>set_is_subset</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>mn</SPAN>), where <SPAN 
                  class=docEmphasis>m</SPAN> is the size of <TT><I>set1</I></TT> 
                  and <SPAN class=docEmphasis>n</SPAN> is the size of 
                  <TT><I>set2</I></TT>. This is because for each member in 
                  <TT><I>set1</I></TT>, the <SPAN class=docEmphasis>O</SPAN> 
                  (<SPAN class=docEmphasis>n</SPAN>) operation <SPAN 
                  class=docEmphasis>set_is_member</SPAN> is called to determine 
                  whether the member is in <TT><I>set2</I></TT>.</P><A 
                  name=ch07-61-fm2xml></A>
                  <H4 class=docSection2Title>7.3.10 set_is_equal</H4>
                  <P class=docText><A name=IXT-7-313763></A><A 
                  name=IXT-7-313764></A><A name=IXT-7-313765></A>The <SPAN 
                  class=docEmphasis>set_is_equal</SPAN> operation determines 
                  whether one set, <TT><I>set1</I></TT>, is equal to another 
                  set, <TT><I>set2</I></TT> (see <A class=docLink 
                  href="#ch07-20227">Example 
                  7.2</A>). Since two sets that are equal must be the same size, 
                  we begin by comparing sizes. If the two sets are not the same 
                  size, then they are not equal. If the two sets are the same 
                  size, we need only return the result of whether 
                  <TT><I>set1</I></TT> is a subset of <TT><I>set2</I></TT>. This 
                  is determined by calling <SPAN 
                  class=docEmphasis>set_is_subset</SPAN>.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>set_is_equal</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>mn</SPAN>), where <SPAN 
                  class=docEmphasis>m</SPAN> is the size of <TT><I>set1</I></TT> 
                  and <SPAN class=docEmphasis>n</SPAN> is the size of 
                  <TT><I>set2</I></TT>. This is because <SPAN 
                  class=docEmphasis>set_is_subset</SPAN> runs in <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>mn</SPAN>) 
                  time.</P><A name=ch07-62-fm2xml></A>
                  <H4 class=docSection2Title>7.3.11 set_size</H4>
                  <P class=docText><A name=IXT-7-313766></A><A 
                  name=IXT-7-313767></A>This macro evaluates to the size of a 
                  set (see <A class=docLink 
                  href="#ch07-62177">Example 
                  7.1</A>). It works by accessing the <TT><I>size</I></TT> 
                  member of the <TT><I>Set</I></TT> structure.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>set_size</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (1) because accessing a member of a 
                  structure is a simple task that runs in a constant amount of 
                  time.</P>
                  <H5 class=docExampleTitle><A name=ch07-20227></A>Example 7.2. 
                  Set Example: Set Covering</H5><PRE>/*****************************************************************************
*                                                                            *
*  -------------------------------- set.c ---------------------------------  *
*                                                                            *
*****************************************************************************/

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "list.h"
#include "set.h"

/*****************************************************************************
*                                                                            *
*  ------------------------------- set_init<A name=IXT-7-313768></A> -------------------------------  *
*                                                                            *
*****************************************************************************/

void set_init(Set *set, int (*match)(const void *key1, const void *key2),
   void (*destroy)(void *data)) {

/*****************************************************************************
*                                                                            *
*  Initialize the set.                                                       *
*                                                                            *
*****************************************************************************/

list_init(set, destroy);
set-&gt;match = match;

return;

}

/*****************************************************************************
*                                                                            *
*  ------------------------------ set_insert<A name=IXT-7-313769></A> ------------------------------  *
*                                                                            *
*****************************************************************************/

int set_insert(Set *set, const void *data) {

/*****************************************************************************
*                                                                            *
*  Do not allow the insertion of duplicates.                                 *
*                                                                            *
*****************************************************************************/

if (set_is_member(set, data))
   return 1;

/*****************************************************************************
*                                                                            *
*  Insert the data.                                                          *
*                                                                            *
*****************************************************************************/

return list_ins_next(set, list_tail(set), data);

}

/*****************************************************************************
*                                                                            *
*  ------------------------------ set_remove<A name=IXT-7-313770></A> ------------------------------  *
*                                                                            *
*****************************************************************************/

int set_remove(Set *set, void **data) {

ListElmt           *member,
                   *prev;

/*****************************************************************************
*                                                                            *
*  Find the member to remove.                                                *
*                                                                            *
*****************************************************************************/

prev = NULL;

for (member = list_head(set); member != NULL; member = list_next(member)) {

   if (set-&gt;match(*data, list_data(member)))
      break;

   prev = member;

}

/*****************************************************************************
*                                                                            *
*  Return if the member was not found.                                       *
*                                                                            *
*****************************************************************************/

if (member == NULL)
   return -1;

/*****************************************************************************
*                                                                            *
*  Remove the member.                                                        *
*                                                                            *
*****************************************************************************/

return list_rem_next(set, prev, data);

}

/*****************************************************************************
*                                                                            *
*  ------------------------------- set_union<A name=IXT-7-313771></A> ------------------------------  *
*                                                                            *
*****************************************************************************/

int set_union(Set *setu, const Set *set1, const Set *set2) {

ListElmt           *member;

void               *data;

/*****************************************************************************
*                                                                            *
*  Initialize the set for the union.                                         *
*                                                                            *
*****************************************************************************/

set_init(setu, set1-&gt;match, NULL);

/*****************************************************************************
*                                                                            *
*  Insert the members of the first set.                                      *
*                                                                            *
*****************************************************************************/

for (member = list_head(set1); member != NULL; member = list_next(member)) {

   data = list_data(member);

   if (list_ins_next(setu, list_tail(setu), data) != 0) {

      set_destroy(setu);
      return -1;

   }

}

/*****************************************************************************
*                                                                            *
*  Insert the members of the second set.                                     *
*                                                                            *
*****************************************************************************/

for (member = list_head(set2); member != NULL; member = list_next(member)) {

   if (set_is_member(set1, list_data(member))) {

      /***********************************************************************
      *                                                                      *
      *  Do not allow the insertion of duplicates.                           *
      *                                                                      *
      ***********************************************************************/

      continue;

      }

   else {

      data = list_data(member);

      if (list_ins_next(setu, list_tail(setu), data) != 0) {

         set_destroy(setu);
         return -1;

      }

   }

}

return 0;

}

/*****************************************************************************
*                                                                            *
*  --------------------------- set_intersection<A name=IXT-7-313772></A> ---------------------------  *
*                                                                            *
*****************************************************************************/

int set_intersection(Set *seti, const Set *set1, const Set *set2) {

ListElmt           *member;

void               *data;

/*****************************************************************************
*                                                                            *
*  Initialize the set for the intersection.                                  *
*                                                                            *
*****************************************************************************/

set_init(seti, set1-&gt;match, NULL);

/*****************************************************************************
*                                                                            *
*  Insert the members present in both sets.                                  *
*                                                                            *
*****************************************************************************/

for (member = list_head(set1); member != NULL; member = list_next(member)) {

   if (set_is_member(set2, list_data(member))) {

      data = list_data(member);

      if (list_ins_next(seti, list_tail(seti), data) != 0) {

         set_destroy(seti);
         return -1;

      }

   }

}

return 0;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- set_difference<A name=IXT-7-313773></A> ----------------------------  *
*                                                                            *
*****************************************************************************/

int set_difference(Set *setd, const Set *set1, const Set *set2) {

ListElmt           *member;

void               *data;

/*****************************************************************************
*                                                                            *
*  Initialize the set for the difference.                                    *
*                                                                            *
*****************************************************************************/

set_init(setd, set1-&gt;match, NULL);

/*****************************************************************************
*                                                                            *
*  Insert the members from set1 not in set2.                                 *
*                                                                            *
*****************************************************************************/

for (member = list_head(set1); member != NULL; member = list_next(member)) {

   if (!set_is_member(set2, list_data(member))) {

      data = list_data(member);

      if (list_ins_next(setd, list_tail(setd), data) != 0) {

         set_destroy(setd);
         return -1;

      }

   }

}

return 0;

}

/*****************************************************************************
*                                                                            *
*  ----------------------------- set_is_member<A name=IXT-7-313774></A> ----------------------------  *
*                                                                            *
*****************************************************************************/

int set_is_member(const Set *set, const void *data) {

ListElmt           *member;

/*****************************************************************************
*                                                                            *
*  Determine if the data is a member of the set.                             *
*                                                                            *
*****************************************************************************/

for (member = list_head(set); member != NULL; member = list_next(member)) {

   if (set-&gt;match(data, list_data(member)))
      return 1;

}

return 0;

}

/*****************************************************************************
*                                                                            *
*  ----------------------------- set_is_subset<A name=IXT-7-313775></A> ----------------------------  *
*                                                                            *
*****************************************************************************/

int set_is_subset(const Set *set1, const Set *set2) {

ListElmt           *member;

/*****************************************************************************
*                                                                            *
*  Do a quick test to rule out some cases.                                   *
*                                                                            *
*****************************************************************************/

if (set_size(set1) &gt; set_size(set2))
   return 0;

/*****************************************************************************
*                                                                            *
*  Determine if set1 is a subset of set2.                                    *
*                                                                            *
*****************************************************************************/

for (member = list_head(set1); member != NULL; member = list_next(member)) {

   if (!set_is_member(set2, list_data(member)))
      return 0;

}

return 1;

}

/*****************************************************************************
*                                                                            *
*  ------------------------------ set_is_equal<A name=IXT-7-313776></A> ----------------------------  *
*                                                                            *
*****************************************************************************/

int set_is_equal(const Set *set1, const Set *set2) {

/*****************************************************************************
*                                                                            *
*  Do a quick test to rule out some cases.                                   *
*                                                                            *
*****************************************************************************/

if (set_size(set1) != set_size(set2))
   return 0;

/*****************************************************************************
*                                                                            *
*  Sets of the same size are equal if they are subsets.                      *
*                                                                            *
*****************************************************************************/

return set_is_subset(set1, set2)<A name=IXTR3-37></A>;

}</PRE>
                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch07-6-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=absMiddle 
                  border=0></A> &nbsp; <A accessKey=1 
                  href="ch07-63-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=absMiddle 
                  border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
