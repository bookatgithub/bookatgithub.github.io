<HTML><HEAD><TITLE>ch07-63-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 7.&nbsp; 
            Sets</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch07-51-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=left 
                  border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch07-64-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=right 
                  border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch07-63-fm2xml></A>
                  <H3 class=docSection1Title>7.4 Set Example: Set Covering</H3>
                  <P class=docText><SPAN class=docEmphasis></SPAN><A 
                  name=ch07-idx-974320-1></A>Set covering<A 
                  name=ch07-idx-738573-1></A> is an optimization problem that 
                  nicely models many problems of combinatorics<A 
                  name=IXT-7-313777></A> and resource selection<A 
                  name=IXT-7-313778></A>. Here is the idea: given a set <SPAN 
                  class=docEmphasis>S</SPAN> and a set <SPAN 
                  class=docEmphasis>P</SPAN> of subsets <SPAN 
                  class=docEmphasis>A</SPAN><SUB>1</SUB> to <SPAN 
                  class=docEmphasis>An</SPAN> of <SPAN 
                  class=docEmphasis>S</SPAN>, set <SPAN 
                  class=docEmphasis>C</SPAN>, which is composed of one or more 
                  sets from <SPAN class=docEmphasis>P</SPAN>, is said to <SPAN 
                  class=docEmphasis>cover</SPAN> <SPAN 
                  class=docEmphasis>S</SPAN> if each member in <SPAN 
                  class=docEmphasis>S</SPAN> is contained in at least one of the 
                  subsets in <SPAN class=docEmphasis>C</SPAN>; in addition, 
                  <SPAN class=docEmphasis>C</SPAN> contains as few sets from 
                  <SPAN class=docEmphasis>P</SPAN> as possible.<A 
                  name=IXT-7-313779></A></P>
                  <P class=docText>As an example, imagine trying to form a team 
                  from a large set of candidate players, each with a certain set 
                  of skills. The goal is to form the smallest team possible 
                  possessing a certain set of skills overall. That is, for any 
                  skill required by the team as a whole, at least one player on 
                  the team must possess the skill. Let <SPAN 
                  class=docEmphasis>S</SPAN> be the skills that must be present 
                  on the team, and let <SPAN class=docEmphasis>P</SPAN> be the 
                  sets of skills possessed by various candidate players. The 
                  various player skill sets in <SPAN class=docEmphasis>P</SPAN> 
                  that are placed in set <SPAN class=docEmphasis>C</SPAN> 
                  together must cover all of the skills in set <SPAN 
                  class=docEmphasis>S</SPAN>. But remember, we must select as 
                  few players as possible.</P>
                  <P class=docText>The algorithm presented here for set covering 
                  is an approximation algorithm (see <A class=docLink 
                  href="ch01-1-fm2xml.html#ch01-1-fm2xml">Chapter 
                  1</A>). It does not always obtain the best solution, but it 
                  does come within a logarithmic bound. The algorithm works by 
                  repeatedly picking a set from <SPAN class=docEmphasis>P</SPAN> 
                  that covers the most members not yet covered in <SPAN 
                  class=docEmphasis>S</SPAN>. In other words, it tries to cover 
                  as much of <SPAN class=docEmphasis>S</SPAN> as it can as early 
                  as it can. Thus, the algorithm is greedy (see <A class=docLink 
                  href="ch01-1-fm2xml.html#ch01-1-fm2xml">Chapter 
                  1</A>). As each set is selected from <SPAN 
                  class=docEmphasis>P</SPAN>, it is removed, and its members are 
                  removed from <SPAN class=docEmphasis>S</SPAN> as well. When 
                  there are no members left to cover in <SPAN 
                  class=docEmphasis>S</SPAN>, the cover set <SPAN 
                  class=docEmphasis>C</SPAN> is complete.</P>
                  <P class=docText>Let's look at finding the optimal covering of 
                  a set of twelve skills <SPAN class=docEmphasis>S</SPAN> = {a, 
                  b, c, d, e, f, g, h, i, j, k, l} considering a set of seven 
                  candidate players <SPAN class=docEmphasis>P</SPAN> = {<SPAN 
                  class=docEmphasis>A</SPAN><SUB>1</SUB>, …, <SPAN 
                  class=docEmphasis>A</SPAN><SUB>7</SUB>}. The players in <SPAN 
                  class=docEmphasis>P</SPAN> have the following assortments of 
                  skills: <SPAN class=docEmphasis>A</SPAN><SUB>1</SUB> = {a, b, 
                  c, d}, <SPAN class=docEmphasis>A</SPAN><SUB>2</SUB> = {e, f, 
                  g, h, i}, <SPAN class=docEmphasis>A</SPAN><SUB>3</SUB> = {j, 
                  k, l}, <SPAN class=docEmphasis>A</SPAN><SUB>4</SUB> = {a, e}, 
                  <SPAN class=docEmphasis>A</SPAN><SUB>5</SUB> = {b, f, g}, 
                  <SPAN class=docEmphasis>A</SPAN><SUB>6</SUB> = {c, d, g, h, k, 
                  l}, and <SPAN class=docEmphasis>A</SPAN><SUB>7</SUB> = {l}. 
                  The optimal covering is <SPAN class=docEmphasis>C</SPAN> = 
                  {<SPAN class=docEmphasis>A</SPAN><SUB>1</SUB>, <SPAN 
                  class=docEmphasis>A</SPAN><SUB>2</SUB>, <SPAN 
                  class=docEmphasis>A</SPAN><SUB>3</SUB>}. The algorithm 
                  presented here selects the set <SPAN 
                  class=docEmphasis>C</SPAN> = {<SPAN 
                  class=docEmphasis>A</SPAN><SUB>6</SUB>, <SPAN 
                  class=docEmphasis>A</SPAN><SUB>2</SUB>, <SPAN 
                  class=docEmphasis>A</SPAN><SUB>1</SUB>, <SPAN 
                  class=docEmphasis>A</SPAN><SUB>3</SUB>} (see <A class=docLink 
                  href="#ch07-31377">Figure 
                  7.2</A>).</P>
                  <CENTER><A name=IXT-7-313780></A>
                  <H5 class=docFigureTitle><A name=ch07-31377></A>Figure 7.2. A 
                  set covering problem </H5><IMG height=382 
                  alt=figs/alc.0702.gif src="image/alc.0702.gif" width=502 
                  border=0></CENTER>
                  <P class=docText>Examples <A class=docLink 
                  href="#ch07-67536">Example 
                  7.3</A> and <A class=docLink 
                  href="#ch07-64687">Example 
                  7.4</A> present a function, <SPAN 
                  class=docEmphasis>cover</SPAN>, that determines a nearly 
                  optimal covering of <SPAN class=docEmphasis>S</SPAN> 
                  considering the subsets <SPAN 
                  class=docEmphasis>A</SPAN><SUB>1</SUB> to <SPAN 
                  class=docEmphasis>An</SPAN> in <SPAN 
                  class=docEmphasis>P</SPAN>. The function has three arguments: 
                  <TT><I>members</I></TT> is the set <SPAN 
                  class=docEmphasis>S</SPAN> to be covered, 
                  <TT><I>subsets</I></TT> is the set of subsets in <SPAN 
                  class=docEmphasis>P</SPAN>, and <TT><I>covering</I></TT> is 
                  the set <SPAN class=docEmphasis>C</SPAN> returned as the 
                  covering. The function modifies all three sets passed to it, 
                  so copies should be made before calling the function, if 
                  necessary.</P>
                  <P class=docText>To begin, <TT><I>covering</I></TT> is 
                  initialized by calling <SPAN 
                  class=docEmphasis>set_init</SPAN>. <A 
                  name=IXT-7-313781></A>The outermost loop iterates as long as 
                  there are noncovered members in <TT><I>members</I></TT> and 
                  the algorithm has not run out of subsets for the covering. 
                  Inside this loop, during each iteration, it finds the set in 
                  <TT><I>subsets</I></TT> that produces the largest intersection 
                  with <TT><I>members</I></TT>. It then adds this set to the 
                  covering and removes its members from <TT><I>members</I></TT>. 
                  Last in the loop, the selected set is removed from 
                  <TT><I>subsets</I></TT>. If the outermost loop terminates with 
                  <TT><I>members</I></TT> not empty, then a complete covering 
                  was not possible using the sets in <TT><I>subsets</I></TT>. 
                  This is also the case if during any iteration none of the sets 
                  in <TT><I>subsets</I></TT> intersects with 
                  <TT><I>members</I></TT>. The function <SPAN 
                  class=docEmphasis>cover</SPAN> returns if it finds a covering, 
                  1 if a covering is not possible, or -1 otherwise.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>cover</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>m 
                  </SPAN><SUP>3</SUP>), where <SPAN class=docEmphasis>m</SPAN> 
                  is the initial number of members in <TT><I>members</I></TT>. 
                  This occurs when there is exactly one subset in 
                  <TT><I>subsets</I></TT> for each member in 
                  <TT><I>members</I></TT>; consequently, there are <SPAN 
                  class=docEmphasis>m</SPAN> subsets. In this case, <SPAN 
                  class=docEmphasis>set-intersection</SPAN> runs in <SPAN 
                  class=docEmphasis>O </SPAN>(<SPAN class=docEmphasis>m</SPAN>) 
                  time because each subset contains only one member to traverse 
                  when computing the intersection with <TT><I>members</I></TT>. 
                  Thus, the inner loop of <SPAN class=docEmphasis>cover</SPAN> 
                  is <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>m</SPAN><SUP>2</SUP>) and this loop is 
                  executed <SPAN class=docEmphasis>m</SPAN> times.</P>
                  <H5 class=docExampleTitle><A name=ch07-67536></A>Example 7.3. 
                  Header for Set Covering </H5><PRE>/*****************************************************************************
*                                                                            *
*  -------------------------------- cover.h -------------------------------  *
*                                                                            *
*****************************************************************************/

#ifndef COVER_H
#define COVER_H

#include "set.h"

/*****************************************************************************
*                                                                            *
*  Define a structure for subsets identified by a key.                       *
*                                                                            *
*****************************************************************************/

typedef struct <A name=IXT-7-313782></A>KSet_ {

void               *key;
Set                set;

} KSet;

/*****************************************************************************
*                                                                            *
*  --------------------------- Public Interface ---------------------------  *
*                                                                            *
*****************************************************************************/

int cover(Set *members, Set *subsets, Set *covering);

#endif</PRE>
                  <H5 class=docExampleTitle><A name=ch07-64687></A>Example 7.4. 
                  Implementation of a Function for Set Covering </H5><PRE>/*****************************************************************************
*                                                                            *
*  -------------------------------- cover.c -------------------------------  *
*                                                                            *
*****************************************************************************/

#include &lt;stdlib.h&gt;

#include "cover.h"
#include "list.h"
#include "set.h"

/*****************************************************************************
*                                                                            *
*  --------------------------------- cover --------------------------------  *
*                                                                            *
*****************************************************************************/

int cover(Set *members, Set *subsets, Set *covering) {

Set                intersection;

KSet               *subset;

ListElmt           *member,
                   *max_member;

void               *data;

int                max_size;

/*****************************************************************************
*                                                                            *
*  Initialize the covering.                                                  *
*                                                                            *
*****************************************************************************/

set_init(covering, subsets-&gt;match, NULL);

/*****************************************************************************
*                                                                            *
*  Continue while there are noncovered members and candidate subsets.        *
*                                                                            *
*****************************************************************************/

while (set_size(members) &gt; 0 &amp;&amp; set_size(subsets) &gt; 0) {

   /**************************************************************************
   *                                                                         *
   *  Find the subset that covers the most members.                          *
   *                                                                         *
   **************************************************************************/

   max_size = 0;

   for (member = list_head(subsets); member != NULL; member =
      list_next(member)) {

      if (set_intersection(&amp;intersection, &amp;((KSet *)list_data(member))-&gt;set,
         members) != 0) {

         return -1;

      }

      if (set_size(&amp;intersection) &gt; max_size) {

         max_member = member;
         max_size = set_size(&amp;intersection);

      }

      set_destroy(&amp;intersection);

   }

   /**************************************************************************
   *                                                                         *
   *  A covering is not possible if there was no intersection.               *
   *                                                                         *
   **************************************************************************/

   if (max_size == 0)
      return 1;

   /**************************************************************************
   *                                                                         *
   *  Insert the selected subset into the covering.                          *
   *                                                                         *
   **************************************************************************/

   subset = (KSet *)list_data(max_member);

   if (set_insert(covering, subset) != 0) 
      return -1;

   /**************************************************************************
   *                                                                         *
   *  Remove each covered member from the set of noncovered members.         *
   *                                                                         *
   **************************************************************************/

   for (member = list_head(&amp;((KSet *)list_data(max_member))-&gt;set); member !=
      NULL; member = list_next(member)) {

      data = list_data(member);<A name=IXTR3-38></A>

      if (set_remove(members, (void**)&amp;data) == 0 &amp;&amp; members-&gt;destroy != NULL)
         members-&gt;destroy(data);

   }

   /**************************************************************************
   *                                                                         *
   *  Remove the subset from the set of candidate subsets.                   *
   *                                                                         *
   **************************************************************************/

   if (set_remove(subsets, (void **)&amp;subset) != 0)
      return -1;

}

/*****************************************************************************
*                                                                            *
*  No covering is possible if there are still noncovered members.            *
*                                                                            *
*****************************************************************************/

if (set_size(members) &gt; 0)
   return -1;

return 0;

}<A name=IXTR3-39></A></PRE>
                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch07-51-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=absMiddle 
                  border=0></A> &nbsp; <A accessKey=1 
                  href="ch07-64-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=absMiddle 
                  border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
