<HTML><HEAD><TITLE>ch07-64-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 7.&nbsp; 
            Sets</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch07-63-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=left 
                  border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch07-65-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=right 
                  border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch07-64-fm2xml></A>
                  <H3 class=docSection1Title>7.5 Questions and Answers</H3>
                  <P class=docText><A name=IXT-7-313783></A><SPAN 
                  class=docEmphBold>Q:</SPAN> Instead of implementing <SPAN 
                  class=docEmphasis>set_is_subset</SPAN> as shown, how could we 
                  use other set operations to determine if one set, <SPAN 
                  class=docEmphasis>S1</SPAN>, is a subset of another set, <SPAN 
                  class=docEmphasis>S2</SPAN>? Why is <SPAN 
                  class=docEmphasis>set_is_subset</SPAN> provided?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> In set 
                  notation, if <SPAN class=docEmphasis>S</SPAN><SUB>1</SUB> <IMG 
                  src="image/U2229.gif" border=0> <SPAN 
                  class=docEmphasis>S</SPAN><SUB>2</SUB> = <SPAN 
                  class=docEmphasis>S</SPAN><SUB>1</SUB>, then <SPAN 
                  class=docEmphasis>S</SPAN><SUB>1</SUB> <IMG 
                  src="image/U2282.gif" border=0> <SPAN 
                  class=docEmphasis>S</SPAN><SUB>2</SUB>. Therefore, we could 
                  use a combination of the <SPAN 
                  class=docEmphasis>set_intersection</SPAN> and <SPAN 
                  class=docEmphasis>set_is_equal</SPAN> operations<A 
                  name=IXT-7-313784></A><A name=IXT-7-313785></A>. Whether we 
                  implement this operation as shown or use <SPAN 
                  class=docEmphasis>set_intersection</SPAN> and <SPAN 
                  class=docEmphasis>set_is_equal</SPAN>, its runtime complexity 
                  is <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>mn</SPAN>), where <SPAN 
                  class=docEmphasis>m</SPAN> is the size of <SPAN 
                  class=docEmphasis>S</SPAN><SUB>1</SUB> and <SPAN 
                  class=docEmphasis>n</SPAN> is the size of <SPAN 
                  class=docEmphasis>S</SPAN><SUB>2</SUB>. However, in the case 
                  of calling <SPAN class=docEmphasis>set_intersection</SPAN> and 
                  <SPAN class=docEmphasis>set_is_equal</SPAN>, the running time 
                  is actually closer to <SPAN class=docEmphasis>T</SPAN> (<SPAN 
                  class=docEmphasis>m</SPAN>,<SPAN class=docEmphasis> n</SPAN>) 
                  = 2<SPAN class=docEmphasis>mn</SPAN> because both <SPAN 
                  class=docEmphasis>set_intersection</SPAN> and <SPAN 
                  class=docEmphasis>set_is_equal</SPAN> run in <SPAN 
                  class=docEmphasis>T </SPAN>(<SPAN 
                  class=docEmphasis>m</SPAN>,<SPAN class=docEmphasis> n</SPAN>) 
                  = <SPAN class=docEmphasis>mn</SPAN> times some constant. 
                  Compare this with the operation <SPAN 
                  class=docEmphasis>set_is_subset</SPAN>, which runs closer to 
                  <SPAN class=docEmphasis>T</SPAN> (<SPAN 
                  class=docEmphasis>m</SPAN>, <SPAN class=docEmphasis>n</SPAN>) 
                  = <SPAN class=docEmphasis>mn</SPAN>. Although the complexities 
                  of the two methods are the same, calling <SPAN 
                  class=docEmphasis>set_intersection</SPAN> and <SPAN 
                  class=docEmphasis>set_is_equal</SPAN> requires approximately 
                  double the time in practice.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Instead of 
                  implementing <SPAN class=docEmphasis>set_is_equal</SPAN> as 
                  shown, how could we use other set operations to determine if 
                  one set, <SPAN class=docEmphasis>S1</SPAN>, is equal to 
                  another set, <SPAN class=docEmphasis>S2</SPAN>?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> In set 
                  notation, if <SPAN class=docEmphasis>S</SPAN><SUB>1</SUB> - 
                  <SPAN class=docEmphasis>S</SPAN><SUB>2</SUB> = <IMG 
                  src="image/U2205.gif" border=0> and <SPAN 
                  class=docEmphasis>S</SPAN><SUB>2</SUB> - <SPAN 
                  class=docEmphasis>S</SPAN><SUB>1</SUB> = <IMG 
                  src="image/U2205.gif" border=0>, then <SPAN 
                  class=docEmphasis>S</SPAN><SUB>1</SUB> = <SPAN 
                  class=docEmphasis>S</SPAN><SUB>2</SUB>. Therefore, we could 
                  implement this, albeit less efficiently, using two calls to 
                  <SPAN class=docEmphasis>set_difference</SPAN> and two calls to 
                  <SPAN class=docEmphasis>set_size</SPAN>.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Instead of 
                  implementing <SPAN class=docEmphasis>set_intersection</SPAN> 
                  <A name=IXT-7-313786></A><A name=IXT-7-313787></A>as shown, 
                  how could we use the <SPAN 
                  class=docEmphasis>set_difference</SPAN> operation to compute 
                  the intersection of two sets, <SPAN 
                  class=docEmphasis>S1</SPAN> and <SPAN 
                  class=docEmphasis>S2</SPAN>?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> In set 
                  notation, <SPAN class=docEmphasis>S</SPAN><SUB>1</SUB> <IMG 
                  src="image/U2229.gif" border=0> <SPAN 
                  class=docEmphasis>S</SPAN><SUB>2</SUB> = <SPAN 
                  class=docEmphasis>S</SPAN><SUB>1</SUB> - (<SPAN 
                  class=docEmphasis>S</SPAN><SUB>1</SUB> - <SPAN 
                  class=docEmphasis>S</SPAN><SUB>2</SUB>). Therefore, we could 
                  implement this, albeit less efficiently, using two calls to 
                  <SPAN class=docEmphasis>set_difference</SPAN>.</P>
                  <P class=docText><A name=IXT-7-313788></A><SPAN 
                  class=docEmphBold>Q:</SPAN> Why was <SPAN 
                  class=docEmphasis>list_ins_next</SPAN> used instead of <SPAN 
                  class=docEmphasis>set_insert</SPAN> to insert members into the 
                  sets built within <SPAN class=docEmphasis>set_union</SPAN>, 
                  <SPAN class=docEmphasis>set_intersection</SPAN>, and <SPAN 
                  class=docEmphasis>set_difference</SPAN>?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Recall that 
                  the running time of <SPAN class=docEmphasis>set_insert</SPAN> 
                  is <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN>) because it traverses a set to 
                  ensure that the member being inserted is not duplicated. Since 
                  the <SPAN class=docEmphasis>set_union</SPAN>, <SPAN 
                  class=docEmphasis>set_intersection</SPAN>, and <SPAN 
                  class=docEmphasis>set_difference</SPAN> operations ensure this 
                  already, it is considerably more efficient to call the <SPAN 
                  class=docEmphasis>O</SPAN> (1) operation <SPAN 
                  class=docEmphasis>list_ins_next</SPAN> instead.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Suppose we 
                  have three sets, <SPAN class=docEmphasis>S1 = {1, 2, 3 
                  }</SPAN>, <SPAN class=docEmphasis>S2 = {1, 4, 5}</SPAN>, and 
                  <SPAN class=docEmphasis>S</SPAN><SUB>3</SUB> <SPAN 
                  class=docEmphasis>= {1}</SPAN>. What is the result of the set 
                  operations <SPAN class=docEmphasis>S1</SPAN> <IMG 
                  src="image/U222A.gif" border=0> <SPAN 
                  class=docEmphasis>S2</SPAN> , <SPAN 
                  class=docEmphasis>S</SPAN><SUB>1</SUB> - <SPAN 
                  class=docEmphasis>(S2</SPAN> <IMG src="image/U2229.gif" 
                  border=0> <SPAN class=docEmphasis>S</SPAN><SUB>3</SUB><SPAN 
                  class=docEmphasis>) </SPAN>, and <SPAN 
                  class=docEmphasis>(S1</SPAN> <IMG src="image/U2229.gif" 
                  border=0> <SPAN class=docEmphasis>S2)</SPAN> - <SPAN 
                  class=docEmphasis>S</SPAN><SUB>3</SUB>?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> <SPAN 
                  class=docEmphasis>S</SPAN><SUB>1</SUB> <IMG 
                  src="image/U222A.gif" border=0> <SPAN 
                  class=docEmphasis>S</SPAN><SUB>2</SUB> = {1, 2, 3, 4, 5}, 
                  <SPAN class=docEmphasis>S</SPAN><SUB>1</SUB> - (<SPAN 
                  class=docEmphasis>S</SPAN><SUB>2</SUB> <IMG 
                  src="image/U2229.gif" border=0> <SPAN 
                  class=docEmphasis>S</SPAN><SUB>3</SUB>) = {2, 3}, and (<SPAN 
                  class=docEmphasis>S</SPAN><SUB>1</SUB> <IMG 
                  src="image/U2229.gif" border=0> <SPAN 
                  class=docEmphasis>S</SPAN><SUB>2</SUB>) - <SPAN 
                  class=docEmphasis>S</SPAN><SUB>3</SUB> = <IMG 
                  src="image/U2205.gif" border=0>.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Using the 
                  properties and basic operations presented for sets, simplify 
                  <SPAN class=docEmphasis>(((S1</SPAN> <IMG 
                  src="image/U2229.gif" border=0> <SPAN 
                  class=docEmphasis>S2)</SPAN> <IMG src="image/U222A.gif" 
                  border=0> <SPAN class=docEmphasis>(S1</SPAN> <IMG 
                  src="image/U2229.gif" border=0> <SPAN 
                  class=docEmphasis>S3))</SPAN> - <SPAN 
                  class=docEmphasis>(S1</SPAN> <IMG src="image/U2229.gif" 
                  border=0> <SPAN class=docEmphasis>(S2</SPAN> <IMG 
                  src="image/U222A.gif" border=0> <SPAN 
                  class=docEmphasis>S3)))</SPAN> <IMG src="image/U222A.gif" 
                  border=0> <SPAN class=docEmphasis>(S1</SPAN> <IMG 
                  src="image/U2229.gif" border=0> <SPAN 
                  class=docEmphasis>S2)</SPAN>.</P>
                  <P class=docText><IMG height=21 alt=figs/equation.0715.gif 
                  src="image/equation.0715.gif" width=309 border=0></P>
                  <P class=docText>Applying the distributive law produces:</P>
                  <P class=docText><IMG height=24 alt=figs/equation.0716.gif 
                  src="image/equation.0716.gif" width=267 border=0></P>
                  <P class=docText>Applying set difference produces:</P>
                  <P class=docText><IMG height=19 alt=figs/equation.0717.gif 
                  src="image/equation.0717.gif" width=81 border=0></P>
                  <P class=docText>Applying the empty set law produces:</P>
                  <P class=docText><IMG height=22 alt=figs/equation.0718.gif 
                  src="image/equation.0718.gif" width=47 border=0></P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> The <SPAN 
                  class=docEmphasis>symmetric difference</SPAN> <A 
                  name=IXT-7-313789></A>of two sets consists of those members 
                  that are in either of the two sets, but not both. The notation 
                  for the symmetric difference of two sets, <SPAN 
                  class=docEmphasis>S1</SPAN> and <SPAN 
                  class=docEmphasis>S2</SPAN>, is <SPAN 
                  class=docEmphasis>S1</SPAN> <FONT face=symbol>D</FONT> <SPAN 
                  class=docEmphasis>S2</SPAN>. How could we implement a 
                  symmetric difference operation using the set operations 
                  presented in this chapter? Could this operation be implemented 
                  more efficiently some other way?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> In set 
                  notation,<SPAN class=docEmphasis> S</SPAN><SUB>1</SUB> <FONT 
                  face=symbol>D</FONT> <SPAN 
                  class=docEmphasis>S</SPAN><SUB>2</SUB> = (<SPAN 
                  class=docEmphasis>S</SPAN><SUB>1</SUB> - <SPAN 
                  class=docEmphasis>S</SPAN><SUB>2</SUB>) <IMG 
                  src="image/U222A.gif" border=0> (<SPAN 
                  class=docEmphasis>S</SPAN><SUB>2</SUB> - <SPAN 
                  class=docEmphasis>S</SPAN><SUB>1</SUB>). Therefore, we could 
                  implement this operation using two calls to <SPAN 
                  class=docEmphasis>set_difference</SPAN> followed by a call to 
                  <SPAN class=docEmphasis>set_union</SPAN>. This produces a 
                  worst-case running time of <SPAN class=docEmphasis>T</SPAN> 
                  (<SPAN class=docEmphasis>m</SPAN>, <SPAN 
                  class=docEmphasis>n</SPAN>) = 3<SPAN 
                  class=docEmphasis>mn</SPAN> times some constant, for a 
                  complexity of <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>mn</SPAN>), where <SPAN 
                  class=docEmphasis>m</SPAN> is the size of <SPAN 
                  class=docEmphasis>S</SPAN><SUB>1</SUB> and <SPAN 
                  class=docEmphasis>n</SPAN> is the size of <SPAN 
                  class=docEmphasis>S</SPAN><SUB>2</SUB>. For example, consider 
                  the sets <SPAN class=docEmphasis>S</SPAN><SUB>1</SUB> = {1, 2, 
                  3} and <SPAN class=docEmphasis>S</SPAN><SUB>2</SUB> = {4, 5, 
                  6}, which represent a worst-case scenario. To compute <SPAN 
                  class=docEmphasis>S</SPAN><SUB>1</SUB> - <SPAN 
                  class=docEmphasis>S</SPAN><SUB>2</SUB>, we must search all of 
                  <SPAN class=docEmphasis>S</SPAN><SUB>2</SUB> for each member 
                  in <SPAN class=docEmphasis>S</SPAN><SUB>1</SUB>, which results 
                  in the set {1, 2, 3}. Similarly, to compute <SPAN 
                  class=docEmphasis>S</SPAN><SUB>2</SUB> - <SPAN 
                  class=docEmphasis>S</SPAN><SUB>1</SUB>, we must search all of 
                  <SPAN class=docEmphasis>S</SPAN><SUB>1</SUB> for each member 
                  of <SPAN class=docEmphasis>S</SPAN><SUB>2</SUB>, which results 
                  in the set {4, 5, 6}. Since both sets are the same size as the 
                  original sets, sizes <SPAN class=docEmphasis>m</SPAN> and 
                  <SPAN class=docEmphasis>n</SPAN>, their union is another 
                  operation that runs in time proportionate to <SPAN 
                  class=docEmphasis>m</SPAN> times <SPAN 
                  class=docEmphasis>n</SPAN>. However, since we know that the 
                  sets produced by <SPAN class=docEmphasis>S</SPAN><SUB>1</SUB> 
                  - <SPAN class=docEmphasis>S</SPAN><SUB>2</SUB> and <SPAN 
                  class=docEmphasis>S</SPAN><SUB>2</SUB> - <SPAN 
                  class=docEmphasis>S</SPAN><SUB>1</SUB> will not generate any 
                  duplicate members between them, we could avoid the use of 
                  <SPAN class=docEmphasis>set_union</SPAN> and simply insert 
                  each member into the final set by calling the <SPAN 
                  class=docEmphasis>O</SPAN> (1) operation <SPAN 
                  class=docEmphasis>list_ins_next</SPAN> once for each member 
                  <SPAN class=docEmphasis>m</SPAN> + <SPAN 
                  class=docEmphasis>n</SPAN> times. This is a better 
                  implementation in practice, but it does not change the overall 
                  complexity.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> A <SPAN 
                  class=docEmphasis>multiset</SPAN> (see the related topics at 
                  the end of the chapter) <A name=IXT-7-313790></A><A 
                  name=IXT-7-313791></A>is a type of set that allows members to 
                  occur more than once. How would the runtime complexities of 
                  inserting and removing members with a multiset compare with 
                  the operations for inserting and removing members in this 
                  chapter?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> <A 
                  name=IXT-7-313792></A>When inserting a member into a set, in 
                  which members may not be duplicated, we must search the entire 
                  set to ensure that we do not duplicate a member. This is an 
                  <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN>) process. Removing a member from a 
                  set is <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN>) as well because we may have to 
                  search the entire set again. In a multiset, inserting a member 
                  is considerably more efficient because we do not have to 
                  traverse the members looking for duplicates. Therefore, we can 
                  insert the new member in <SPAN class=docEmphasis>O</SPAN> (1) 
                  time. In a multiset, removing a member remains an <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>n</SPAN>) 
                  process because we still must search for the member we want to 
                  remove.</P>
                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch07-63-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=absMiddle 
                  border=0></A> &nbsp; <A accessKey=1 
                  href="ch07-65-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=absMiddle 
                  border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
