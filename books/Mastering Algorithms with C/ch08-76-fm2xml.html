<HTML><HEAD><TITLE>ch08-76-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 8.&nbsp; Hash 
              Tables</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch08-69-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=left 
                  border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch08-77-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=right 
                  border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch08-76-fm2xml></A>
                  <H3 class=docSection1Title>8.8 Questions and Answers</H3>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> In the 
                  implementation of chained hash tables presented in this 
                  chapter, the actual hash code used for accessing the table is 
                  the hash code modulo the table size. Why is this?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> This 
                  transformation ensures that the hash coding does not position 
                  us past the end of the table. Although the hash function 
                  should ensure this itself, it is worthwhile for the hash table 
                  implementation to provide the guarantee as well, especially 
                  since the hash function is provided by the caller. However, 
                  this is not the same reason that the modulo is performed when 
                  double hashing a key in an open-addressed hash table. In this 
                  case, the process of double hashing may produce a hash coding 
                  that falls outside of the bounds of the table, even for two 
                  auxiliary hash functions each producing hash codings within 
                  the table. This is because the two hash codings are added 
                  together.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Why are 
                  hash tables good for random access but not sequential access? 
                  For example, in a database system in which records are to be 
                  accessed in a sequential fashion, what is the problem with 
                  hashing?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Hash tables 
                  are excellent for random access because each key hashes us 
                  precisely to where we need to be in the table to access the 
                  data, or at least within a few steps when a collision occurs. 
                  However, hash tables do not support sequential access. After 
                  hashing to some position, we have no way to determine where 
                  the next smallest or largest key resides. Compare this with a 
                  linked list containing elements that are sorted. Assuming some 
                  initial position in the list, the next key is easy to 
                  determine: we simply look at the next element in the list.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> What is the 
                  worst-case performance of searching for an element in a 
                  chained hash table? How do we ensure that this case will not 
                  occur?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> A chained 
                  hash table performs the worst when all elements hash into a 
                  single bucket. In this case, searching for an element is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>n</SPAN>), 
                  where <SPAN class=docEmphasis>n</SPAN> is the number of 
                  elements in the table. A ridiculous hash function that would 
                  result in this performance is <SPAN class=docEmphasis>h</SPAN> 
                  (<SPAN class=docEmphasis>k</SPAN>) = <SPAN 
                  class=docEmphasis>c</SPAN>, where <SPAN 
                  class=docEmphasis>c</SPAN> is some constant within the bounds 
                  of the hash table. Selecting a good hash function ensures that 
                  this case will not occur. If the hash function approximates 
                  uniform hashing well, we can expect to locate an element in 
                  constant time.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> What is the 
                  worst-case performance of searching for an element in an 
                  open-addressed hash table? How do we ensure that this case 
                  will not occur?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> The 
                  worst-case performance of searching for an element in an 
                  open-addressed hash table occurs once the hash table is 
                  completely full and the element we are searching for is not in 
                  the table. In this case, searching for an element is an <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>m</SPAN>) 
                  operation, where <SPAN class=docEmphasis>m</SPAN> is the 
                  number of positions in the table. This case can occur with any 
                  hash function. To ensure reasonable performance in an 
                  open-addressed hash table, we should not let the table become 
                  more than 80% full. If we choose a hash function that 
                  approximates uniform hashing well, we can expect performance 
                  consistent with what is presented in <A class=docLink 
                  href="ch08-40-fm2xml.html#ch08-93955">Table 
                  8.1</A>.</P>                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch08-69-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=absMiddle 
                  border=0></A> &nbsp; <A accessKey=1 
                  href="ch08-77-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=absMiddle 
                  border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
