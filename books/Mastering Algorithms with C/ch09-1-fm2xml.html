<HTML><HEAD><TITLE>ch09-1-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Part II:&nbsp; Data 
              Structures</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch08-77-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=left 
                  border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch09-2-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=right 
                  border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch09-1-fm2xml></A>
                  <H2 class=docChapterTitle>Chapter 9. Trees</H2>
                  <P class=docText><A name=IXT-9-313953></A><A 
                  name=IXT-9-313954></A><A name=IXT-9-313955></A>Picture a 
                  family tree, the draw sheet of a tournament, or the roots of a 
                  plant; these are all good examples of a tree's organization as 
                  a data structure. In computing, a tree consists of elements 
                  called<A name=IXT-9-313956></A> <SPAN 
                  class=docEmphasis>nodes</SPAN> organized in a hierarchical 
                  arrangement. The node at the top of the hierarchy is called 
                  the <SPAN class=docEmphasis>root</SPAN><A 
                  name=IXT-9-313957></A>. The nodes directly below the root are 
                  its <SPAN class=docEmphasis>children</SPAN><A 
                  name=IXT-9-313958></A>, which in turn usually have children of 
                  their own. With the exception of the root, each node in the 
                  hierarchy has exactly one <SPAN 
                  class=docEmphasis>parent</SPAN>, <A name=IXT-9-313959></A><A 
                  name=IXT-9-313960></A>which is the node directly above it. The 
                  number of children a node may parent depends on the type of 
                  tree. <A name=IXT-9-313961></A><A name=IXT-9-313962></A>This 
                  number is a tree's <SPAN class=docEmphasis>branching 
                  factor</SPAN>, which dictates how fast the tree will branch 
                  out as nodes are inserted. This chapter focuses on the <SPAN 
                  class=docEmphasis>binary tree</SPAN>, a relatively simple but 
                  powerful tree with a branching factor of 2. It also explores 
                  <SPAN class=docEmphasis>binary search trees</SPAN>, binary 
                  trees organized specifically for searching.</P>
                  <P class=docText>This chapter covers:</P><A 
                  name=IXT-9-313963></A><A name=IXT-9-313964></A><A 
                  name=IXT-9-313965></A><A name=IXT-9-313966></A><A 
                  name=IXT-9-313967></A><A name=IXT-9-313968></A>
                  <DL class=docList>
                    <DT><I><SPAN class=docPubcolor>Binary trees </SPAN></I>
                    <DD>
                    <P class=docList>Trees containing nodes with up to two 
                    children. The binary tree is a very popular type of tree 
                    utilized in a wide variety of problems. It provides the 
                    foundation for more sophisticated tree structures as 
                    well.</P>
                    <DT><I><SPAN class=docPubcolor>Traversal methods </SPAN></I>
                    <DD>
                    <P class=docList>Techniques<A name=IXT-9-313963></A><A 
                    name=IXT-9-313964></A> for visiting the nodes of a tree in a 
                    specific order. Because the nodes of a tree are organized in 
                    a hierarchical fashion, there are several options for 
                    traversing them.</P>
                    <DT><SPAN class=docPubcolor>Tree balancing <A 
                    name=IXT-9-313965></A></SPAN>
                    <DD>
                    <P class=docList>A process used to keep a tree as short as 
                    possible for a given number of nodes. This is especially 
                    important in search trees, wherein height influences the 
                    overall performance of the tree a great deal.</P>
                    <DT><SPAN class=docPubcolor>Binary search trees <A 
                    name=IXT-9-313966></A><A name=IXT-9-313967></A><A 
                    name=IXT-9-313968></A></SPAN>
                    <DD>
                    <P class=docList>Binary trees organized specifically for 
                    searching. Binary search trees are good for searching data 
                    in which we expect to perform insertions and deletions.</P>
                    <DT><I><SPAN class=docPubcolor>Rotations</SPAN></I> 
                    <DD>
                    <P class=docList>Methods for keeping binary search trees 
                    balanced. Specifically, this chapter explores AVL rotations, 
                    the rotations applied to AVL (Adel'son-Vel'skii and Landis) 
                    trees. An AVL tree is one type of balanced binary search 
                    tree.</P></DD></DL>
                  <P class=docText>Some applications of trees are<A 
                  name=IXT-9-313969></A>:</P><A name=IXT-9-313970></A><A 
                  name=IXT-9-313971></A><A name=IXT-9-313972></A><A 
                  name=IXT-9-313973></A><A name=IXT-9-313974></A><A 
                  name=IXT-9-313975></A><A name=IXT-9-313976></A><A 
                  name=IXT-9-313977></A><A name=IXT-9-313978></A><A 
                  name=IXT-9-313979></A>
                  <DL class=docList>
                    <DT><I><SPAN class=docPubcolor>Huffman coding </SPAN></I>
                    <DD>
                    <P class=docList><A name=IXT-9-313970></A>A method of data 
                    compression that uses a Huffman tree to compress a set of 
                    data (see <A class=docLink 
                    href="ch14-1-fm2xml.html#ch14-1-fm2xml">Chapter 
                    14</A>). A Huffman tree is a binary tree that determines the 
                    best way to assign codes to symbols in the data. Symbols 
                    occurring frequently are assigned short codes, whereas 
                    symbols occurring less frequently are assigned longer 
                    ones.</P>
                    <DT><SPAN class=docPubcolor>User interfaces <A 
                    name=IXT-9-313971></A></SPAN>
                    <DD>
                    <P class=docList>Examples are graphical user interfaces and 
                    interfaces to file systems. In graphical user interfaces, 
                    windows take on a hierarchical arrangement forming a tree. 
                    Every window, except the top-level window, has one parent 
                    from which it is started, and each window may have several 
                    children launched from it. Directories in hierarchical file 
                    systems have a similar organization.</P>
                    <DT><SPAN class=docPubcolor>Database systems <A 
                    name=IXT-9-313972></A></SPAN>
                    <DD>
                    <P class=docList>In particular, those that require both 
                    efficient sequential and random access while performing 
                    frequent insertions and deletions. The <A 
                    name=IXT-9-313973></A><SPAN class=docEmphasis>B-tree</SPAN>, 
                    a tree characterized generally as a balanced search tree 
                    with a large branching factor, is especially good in this 
                    situation (see the related topics at the end of the 
                    chapter). Typically the branching factor of a B-tree is 
                    optimized so that disk I/O is minimized when accessing 
                    records in the database.</P>
                    <DT><SPAN class=docPubcolor>Expression processing 
                    (illustrated in this chapter) <A 
                    name=IXT-9-313974></A></SPAN>
                    <DD>
                    <P class=docList>A task performed frequently by compilers 
                    and hand-held calculators. One intuitive way to process 
                    arithmetic expressions is with an expression tree, a binary 
                    tree containing a hierarchical arrangement of an 
                    expression's operators and operands.</P>
                    <DT><SPAN class=docPubcolor>Artificial intelligence <A 
                    name=IXT-9-313975></A></SPAN>
                    <DD>
                    <P class=docList>A<A name=IXT-9-313976></A> discipline that 
                    addresses many problems traditionally difficult for 
                    computers, such as logic-based games like chess. Many AI 
                    problems are solved using <SPAN class=docEmphasis>decision 
                    trees</SPAN><A name=IXT-9-313977></A>. A decision tree 
                    consists of nodes that represent states in a problem. Each 
                    node is a point at which a decision must be made to 
                    continue. Each branch represents a conclusion derived from a 
                    series of decisions. Using various rules of logic, branches 
                    that cannot possibly contain desired conclusions are pruned, 
                    thus decreasing the time to a solution.</P>
                    <DT><I><SPAN class=docPubcolor>Event schedulers </SPAN></I>
                    <DD>
                    <P class=docList>Applications for scheduling and triggering 
                    real-time events. Often real-time systems require looking up 
                    and retrieving the latest information associated with events 
                    as they are triggered. A binary search tree can help make 
                    looking up information efficient.</P>
                    <DT><I><SPAN class=docPubcolor>Priority queues </SPAN></I>
                    <DD>
                    <P class=docList><A name=IXT-9-313978></A><A 
                    name=IXT-9-313979></A>Data structures that use a binary tree 
                    to keep track of which element in a set has the next highest 
                    priority (see <A class=docLink 
                    href="ch10-1-fm2xml.html#ch10-1-fm2xml">Chapter 
                    10</A>). Priority queues offer a better solution than having 
                    to keep a set completely sorted.</P></DD></DL>
                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch08-77-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=absMiddle 
                  border=0></A> &nbsp; <A accessKey=1 
                  href="ch09-2-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=absMiddle 
                  border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
