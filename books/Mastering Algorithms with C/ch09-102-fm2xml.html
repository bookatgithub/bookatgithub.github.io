<HTML><HEAD><TITLE>ch09-102-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 9.&nbsp; 
            Trees</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch09-77-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=left 
                  border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch09-112-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=right 
                  border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch09-102-fm2xml></A>
                  <H3 class=docSection1Title>9.7 Implementation and Analysis of 
                  Binary Search Trees</H3>
                  <P class=docText><A name=ch09-idx-891501-1></A><A 
                  name=ch09-idx-891501-2></A>As <A 
                  name=ch09-idx-891640-1></A>described earlier, binary search 
                  trees perform well only if the tree remains balanced. 
                  Unfortunately, keeping a binary search tree balanced is a more 
                  difficult problem than it may at first appear. Nevertheless, 
                  there are a few clever approaches one can take. One of the 
                  best approaches is to implement the tree as an <SPAN 
                  class=docEmphasis>AVL tree</SPAN>.</P>
                  <P class=docText>An AVL (Adel'son-Vel'skii and Landis) tree is 
                  a special type of binary tree that stores an extra piece of 
                  information with each node: its <SPAN 
                  class=docEmphasis>balance factor</SPAN><A 
                  name=IXT-9-314089></A>. <A name=IXT-9-314090></A><A 
                  name=IXT-9-314091></A>The balance factor of a node is the 
                  height of the subtree rooted at its left child minus the 
                  height of the subtree rooted at its right child (see <A 
                  class=docLink 
                  href="#ch09-72750">Figure 
                  9.9</A>). As nodes are inserted, an AVL tree adjusts itself so 
                  that all balance factors stay +1, -1, or 0. A subtree whose 
                  root node has a balance factor of +1 is said to be <SPAN 
                  class=docEmphasis>left-heavy</SPAN>. A subtree whose root node 
                  has a balance factor of -1 is said to be <SPAN 
                  class=docEmphasis>right-heavy</SPAN>. A subtree whose root 
                  node has a balance factor of is considered balanced. By 
                  keeping its subtrees nearly balanced, an AVL tree stays <SPAN 
                  class=docEmphasis>approximately</SPAN> balanced overall.</P>
                  <CENTER>
                  <H5 class=docFigureTitle><A name=ch09-72750></A>Figure 9.9. An 
                  AVL tree, including balance factors</H5><IMG height=196 
                  alt=figs/alc.0909.gif src="image/alc.0909.gif" width=502 
                  border=0></CENTER>
                  <P class=docText>The basic means of searching and inserting 
                  nodes in an AVL tree is the same as described earlier. 
                  However, when we insert a node into an AVL tree, we have some 
                  additional work to do after the node descends to its 
                  appropriate position. First, we must account for the change in 
                  balance factors that occurs as a result of the insertion. 
                  Also, if any balance factor becomes ±2, we must rebalance the 
                  tree from that point down, which is done by performing an 
                  operation called a <SPAN 
                  class=docEmphasis>rotation</SPAN>.</P><A 
                  name=ch09-103-fm2xml></A>
                  <H4 class=docSection2Title>9.7.1 Rotations in AVL Trees</H4>
                  <P class=docText><A name=ch09-idx-376607-1></A>A rotation 
                  rebalances part of an AVL tree by rearranging nodes while 
                  preserving the relationship wherein the left is smaller than 
                  the parent and the parent is smaller than the right, which 
                  must be maintained for the tree to remain a binary search 
                  tree. After the rotation, the balance factors of all nodes in 
                  the rotated subtree are +1, -1, or 0.</P>
                  <P class=docText>There are only four types of rotations that 
                  ever have to be performed. These are the LL (<SPAN 
                  class=docEmphasis>left-left</SPAN>), LR (<SPAN 
                  class=docEmphasis>left-right</SPAN>), RR (<SPAN 
                  class=docEmphasis>right-right</SPAN>), and RL (<SPAN 
                  class=docEmphasis>right-left</SPAN>) rotations. The functions 
                  <SPAN class=docEmphasis>rotate_left</SPAN> <A 
                  name=IXT-9-314092></A><A name=IXT-9-314093></A>and <SPAN 
                  class=docEmphasis>rotate_right</SPAN>, presented later in <A 
                  class=docLink 
                  href="#ch09-63404">Example 
                  9.5</A>, implement each of these rotations. To understand when 
                  we need to apply each rotation, let <SPAN 
                  class=docEmphasis>x</SPAN> represent the node we have just 
                  inserted into its proper location in an AVL tree, and let 
                  <SPAN class=docEmphasis>A</SPAN> be the nearest ancestor of 
                  <SPAN class=docEmphasis>x</SPAN> whose balance factor has 
                  changed to ±2.</P><A name=ch09-104-fm2xml></A>
                  <H5 class=docSection3Title>9.7.1.1 LL rotation</H5>
                  <P class=docText>We perform an LL, or left-left, rotation when 
                  <SPAN class=docEmphasis>x</SPAN> lies in the <SPAN 
                  class=docEmphasis>left</SPAN> subtree of the <SPAN 
                  class=docEmphasis>left</SPAN> subtree of <SPAN 
                  class=docEmphasis>A</SPAN> (see <A class=docLink 
                  href="#ch09-71413">Figure 
                  9.10</A>). Let <SPAN class=docEmphasis>left</SPAN> be the left 
                  child of <SPAN class=docEmphasis>A</SPAN>. To perform an LL 
                  rotation, we set the left pointer of <SPAN 
                  class=docEmphasis>A</SPAN> to the right child of <SPAN 
                  class=docEmphasis>left</SPAN>, the right pointer of <SPAN 
                  class=docEmphasis>left</SPAN> to <SPAN 
                  class=docEmphasis>A</SPAN>, and the pointer referencing <SPAN 
                  class=docEmphasis>A</SPAN> to <SPAN 
                  class=docEmphasis>left</SPAN>. After the rotation, we set the 
                  balance factors of both <SPAN class=docEmphasis>A</SPAN> and 
                  <SPAN class=docEmphasis>left</SPAN> to 0. All other balance 
                  factors do not change.</P>
                  <CENTER>
                  <H5 class=docFigureTitle><A name=ch09-71413></A>Figure 9.10. 
                  An LL rotation in an AVL tree</H5><IMG height=327 
                  alt=figs/alc.0910.gif src="image/alc.0910.gif" width=502 
                  border=0></CENTER><A name=ch09-105-fm2xml></A>
                  <H5 class=docSection3Title>9.7.1.2 LR rotation</H5>
                  <P class=docText>We perform an LR, or left-right, rotation 
                  when <SPAN class=docEmphasis>x</SPAN> lies in the <SPAN 
                  class=docEmphasis>right</SPAN> subtree of the <SPAN 
                  class=docEmphasis>left</SPAN> subtree of <SPAN 
                  class=docEmphasis>A</SPAN> (see <A class=docLink 
                  href="#ch09-94892">Figure 
                  9.11</A>). Let <SPAN class=docEmphasis>left</SPAN> be the left 
                  child of <SPAN class=docEmphasis>A</SPAN> and <SPAN 
                  class=docEmphasis>grandchild</SPAN> be the right child of 
                  <SPAN class=docEmphasis>left</SPAN>. To perform an LR 
                  rotation, we set the right child of <SPAN 
                  class=docEmphasis>left</SPAN> to the left child of <SPAN 
                  class=docEmphasis>grandchild</SPAN>, the left child of <SPAN 
                  class=docEmphasis>grandchild</SPAN> to <SPAN 
                  class=docEmphasis>left</SPAN>, the left child of <SPAN 
                  class=docEmphasis>A</SPAN> to the right child of <SPAN 
                  class=docEmphasis>grandchild</SPAN>, the right child of <SPAN 
                  class=docEmphasis>grandchild</SPAN> to <SPAN 
                  class=docEmphasis>A</SPAN>, and finally the pointer 
                  referencing <SPAN class=docEmphasis>A</SPAN> to <SPAN 
                  class=docEmphasis>grandchild</SPAN>.</P>
                  <CENTER>
                  <H5 class=docFigureTitle><A name=ch09-94892></A>Figure 9.11. 
                  An LR rotation in an AVL tree</H5><IMG height=521 
                  alt=figs/alc.0911.gif src="image/alc.0911.gif" width=502 
                  border=0></CENTER>
                  <P class=docText>Adjusting the balance factors of nodes after 
                  an LR rotation depends on the original balance factor of <SPAN 
                  class=docEmphasis>grandchild</SPAN>. <A class=docLink 
                  href="#ch09-12843">Figure 
                  9.12</A> illustrates the three cases to consider. If the 
                  original balance factor of <SPAN 
                  class=docEmphasis>grandchild</SPAN> was +1, we set the balance 
                  factor of <SPAN class=docEmphasis>A</SPAN> to -1 and <SPAN 
                  class=docEmphasis>left</SPAN> to 0. If the original balance 
                  factor of <SPAN class=docEmphasis>grandchild</SPAN> was 0, we 
                  set the balance factors of both <SPAN 
                  class=docEmphasis>A</SPAN> and <SPAN 
                  class=docEmphasis>left</SPAN> to 0. If the original balance 
                  factor of <SPAN class=docEmphasis>grandchild</SPAN> was -1, we 
                  set the balance factor of <SPAN class=docEmphasis>A</SPAN> to 
                  and that of <SPAN class=docEmphasis>left</SPAN> to +1. In all 
                  cases, we set the new balance factor of <SPAN 
                  class=docEmphasis>grandchild</SPAN> to 0. All other balance 
                  factors do not change.</P>
                  <CENTER>
                  <H5 class=docFigureTitle><A name=ch09-12843></A>Figure 9.12. 
                  Updating balance factors after an LR rotation in an AVL 
                  tree</H5><IMG height=564 alt=figs/alc.0912.gif 
                  src="image/alc.0912.gif" width=502 border=0></CENTER><A 
                  name=ch09-106-fm2xml></A>
                  <H5 class=docSection3Title>9.7.1.3 RR rotation</H5>
                  <P class=docText>We perform an RR, or right-right, rotation 
                  when <SPAN class=docEmphasis>x</SPAN> lies in the <SPAN 
                  class=docEmphasis>right</SPAN> subtree of the <SPAN 
                  class=docEmphasis>right</SPAN> subtree of <SPAN 
                  class=docEmphasis>A</SPAN>. The RR rotation is symmetric to 
                  the LL rotation. Let <SPAN class=docEmphasis>right</SPAN> be 
                  the right child of <SPAN class=docEmphasis>A</SPAN>. To 
                  perform an RR rotation, we set the right pointer of <SPAN 
                  class=docEmphasis>A</SPAN> to the left child of <SPAN 
                  class=docEmphasis>right</SPAN>, the left pointer of <SPAN 
                  class=docEmphasis>right</SPAN> to <SPAN 
                  class=docEmphasis>A</SPAN>, and the pointer referencing <SPAN 
                  class=docEmphasis>A</SPAN> to <SPAN 
                  class=docEmphasis>right</SPAN>. After the rotation, we set the 
                  balance factors of both <SPAN class=docEmphasis>A</SPAN> and 
                  <SPAN class=docEmphasis>left</SPAN> to 0. All other balance 
                  factors do not change.</P><A name=ch09-107-fm2xml></A>
                  <H5 class=docSection3Title>9.7.1.4 RL rotation</H5>
                  <P class=docText>We perform an RL, or right-left, rotation 
                  when <SPAN class=docEmphasis>x</SPAN> lies in the <SPAN 
                  class=docEmphasis>left</SPAN> subtree of the <SPAN 
                  class=docEmphasis>right</SPAN> subtree of <SPAN 
                  class=docEmphasis>A</SPAN>. The RL rotation is symmetric to 
                  the LR rotation. Let <SPAN class=docEmphasis>right</SPAN> be 
                  the right child of <SPAN class=docEmphasis>A</SPAN> and <SPAN 
                  class=docEmphasis>grandchild</SPAN> be the left child of <SPAN 
                  class=docEmphasis>right</SPAN>. To perform an RL rotation, we 
                  set the left child of <SPAN class=docEmphasis>right</SPAN> to 
                  the right child of <SPAN class=docEmphasis>grandchild</SPAN>, 
                  the right child of <SPAN class=docEmphasis>grandchild</SPAN> 
                  to <SPAN class=docEmphasis>right</SPAN>, the right child of 
                  <SPAN class=docEmphasis>A</SPAN> to the left child of <SPAN 
                  class=docEmphasis>grandchild</SPAN>, the left child of <SPAN 
                  class=docEmphasis>grandchild</SPAN> to <SPAN 
                  class=docEmphasis>A</SPAN>, and finally the pointer 
                  referencing <SPAN class=docEmphasis>A</SPAN> to <SPAN 
                  class=docEmphasis>grandchild</SPAN>.</P>
                  <P class=docText>Adjusting the balance factors of nodes after 
                  an RL rotation depends on the original balance factor of <SPAN 
                  class=docEmphasis>grandchild</SPAN>. There are three cases to 
                  consider. If the original balance factor of <SPAN 
                  class=docEmphasis>grandchild</SPAN> was +1, we set the balance 
                  factor of <SPAN class=docEmphasis>A</SPAN> to and that of 
                  <SPAN class=docEmphasis>right</SPAN> to -1. If the original 
                  balance factor of <SPAN class=docEmphasis>grandchild</SPAN> 
                  was 0, we set the balance factors of both <SPAN 
                  class=docEmphasis>A</SPAN> and <SPAN 
                  class=docEmphasis>left</SPAN> to 0. If the original balance 
                  factor of <SPAN class=docEmphasis>grandchild</SPAN> was -1, we 
                  set the balance factor of <SPAN class=docEmphasis>A</SPAN> to 
                  +1 and that of <SPAN class=docEmphasis>left</SPAN> to 0. In 
                  all cases, we set the new balance factor of <SPAN 
                  class=docEmphasis>grandchild</SPAN> to 0. All other balance 
                  factors do not change. These adjustments are symmetric to 
                  those shown in <A class=docLink 
                  href="#ch09-12843">Figure 
                  9.12</A> for an LR rotation.</P>
                  <P class=docText>The structure <TT><I>BisTree</I></TT> <A 
                  name=IXT-9-314094></A>is the binary search tree data 
                  structure. A good way to implement a binary search tree is to 
                  use the binary tree abstract datatype discussed earlier. Thus, 
                  <TT><I>BisTree</I></TT> is implemented as a typedef to 
                  <TT><I>BiTree</I></TT> (see <A class=docLink 
                  href="#ch09-89310">Example 
                  9.4</A>). In addition to simplicity, using a typedef has the 
                  benefit of making the binary search tree somewhat polymorphic, 
                  just as described for stacks and queues (see <A class=docLink 
                  href="ch06-1-fm2xml.html#ch06-1-fm2xml">Chapter 
                  6</A>). This means that we can use binary tree operations on a 
                  binary search tree in addition to those operations defined 
                  specifically for binary search trees.</P>
                  <P class=docText>Since keeping a binary search tree balanced 
                  requires that each node store more than just the data placed 
                  in the tree, a structure, <TT><I>AvlNode</I></TT>, is defined 
                  for each node to contain (see <A class=docLink 
                  href="#ch09-89310">Example 
                  9.4</A>). An <TT><I>AvlNode</I></TT> <A 
                  name=IXT-9-314095></A>structure consists of three members: 
                  <TT><I>data</I></TT> is the data stored in the node, 
                  <TT><I>hidden</I></TT> is a member used to mark a node when it 
                  is removed, and <TT><I>factor</I></TT> is the node's balance 
                  factor. The implementation presented here also uses 
                  identifiers to represent the possible values for balance 
                  factors. <A class=docLink 
                  href="#ch09-89310">Example 
                  9.4</A> equates <TT><I>AVL_LEFT_HEAVY</I></TT> to 1, 
                  <TT><I>AVL_BALANCED</I></TT> to 0, and 
                  <TT><I>AVL_RGT_HEAVY</I></TT> to -1.</P>
                  <H5 class=docExampleTitle><A name=ch09-89310></A>Example 9.4. 
                  Header for the Binary Search Tree Abstract Datatype </H5><PRE>/*****************************************************************************
*                                                                            *
*  ------------------------------- bistree.h ------------------------------  *
*                                                                            *
*****************************************************************************/

#ifndef BISTREE_H
#define BISTREE_H

#include "bitree.h"

/*****************************************************************************
*                                                                            *
*  Define balance factors for AVL trees.                                     *
*                                                                            *
*****************************************************************************/

#define            AVL_LFT_HEAVY         1
#define            AVL_BALANCED          0
#define            AVL_RGT_HEAVY        -1

/*****************************************************************************
*                                                                            *
*  Define a structure for nodes in AVL trees.                                *
*                                                                            *
*****************************************************************************/

typedef struct AvlNode_ {

void               *data;
int                hidden;
int                factor;

} AvlNode;

/*****************************************************************************
*                                                                            *
*  Implement binary search trees as binary trees.                            *
*                                                                            *
*****************************************************************************/

typedef BiTree BisTree;

/*****************************************************************************
*                                                                            *
*  --------------------------- Public Interface ---------------------------  *
*                                                                            *
*****************************************************************************/

void bistree_init(BisTree *tree, int (*compare)(const void *key1, const void
   *key2), void (*destroy)(void *data));

void bistree_destroy(BisTree *tree);

int bistree_insert(BisTree *tree, const void *data);

int bistree_remove(BisTree *tree, const void *data);

int bistree_lookup(BisTree *tree, void **data);

#define bistree_size(tree) ((tree)-&gt;size)

#endif</PRE><A name=ch09-108-fm2xml></A>
                  <H4 class=docSection2Title>9.7.2 bistree_init</H4>
                  <P class=docText><A name=IXT-9-314096></A><A 
                  name=IXT-9-314097></A>The <SPAN 
                  class=docEmphasis>bistree_init</SPAN> operation initializes a 
                  binary search tree so that it can be used in other operations 
                  (see <A class=docLink 
                  href="#ch09-63404">Example 
                  9.5</A>). Since a binary search tree is a binary tree, we call 
                  <SPAN class=docEmphasis>bitree_init</SPAN> to initialize it. 
                  The <TT><I>compare</I></TT> member is set to 
                  <TT><I>compare</I></TT> by hand because this member is not 
                  used by binary trees and therefore is not set by <SPAN 
                  class=docEmphasis>bitree_init</SPAN>.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>bistree_init</SPAN> is the same as <SPAN 
                  class=docEmphasis>bitree_init</SPAN>, or <SPAN 
                  class=docEmphasis>O</SPAN> (1).</P><A 
name=ch09-109-fm2xml></A>
                  <H4 class=docSection2Title>9.7.3 bistree_destroy</H4>
                  <P class=docText><A name=IXT-9-314098></A><A 
                  name=IXT-9-314099></A>The <SPAN 
                  class=docEmphasis>bistree_destroy</SPAN> operation destroys a 
                  binary search tree (see <A class=docLink 
                  href="#ch09-63404">Example 
                  9.5</A>). To do this, we employ the support of two additional 
                  functions, <SPAN class=docEmphasis>destroy_left</SPAN> <A 
                  name=IXT-9-314100></A><A name=IXT-9-314101></A>and <SPAN 
                  class=docEmphasis>destroy_right</SPAN>, which recursively 
                  destroy the left and right subtrees beneath a node. These 
                  functions work similarly to the <SPAN 
                  class=docEmphasis>bitree_rem_left</SPAN> and <SPAN 
                  class=docEmphasis>bitree_rem_right</SPAN> functions defined 
                  previously for binary trees. Separate functions are required 
                  for binary search trees so that we can destroy the data 
                  referenced by a node's <TT><I>AvlNode</I></TT> structure as 
                  well as free the <TT><I>AvlNode</I></TT> structure itself.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>bistree_destroy</SPAN> is the same as <SPAN 
                  class=docEmphasis>bitree_destroy</SPAN>, or <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>n</SPAN>), 
                  where <SPAN class=docEmphasis>n</SPAN> is the number of nodes 
                  in the tree.</P><A name=ch09-68205></A>
                  <H4 class=docSection2Title>9.7.4 bistree_insert</H4>
                  <P class=docText><A name=IXT-9-314102></A><A 
                  name=IXT-9-314103></A>The <SPAN 
                  class=docEmphasis>bistree_insert</SPAN> operation inserts a 
                  node into a binary search tree (see <A class=docLink 
                  href="#ch09-63404">Example 
                  9.5</A>). The operation works by recursively calling <SPAN 
                  class=docEmphasis>insert</SPAN> to descend to the point at 
                  which the actual insertion should be made. Once we insert the 
                  node, we update balance factors on our way back up the tree as 
                  the recursion unwinds. If, in so doing, any balance factor 
                  reaches ±2, we perform a rotation.</P>
                  <P class=docText>We begin by checking whether we are inserting 
                  a node into an empty tree. <A name=IXT-9-314104></A>If this is 
                  the case, we simply insert the node and set its balance factor 
                  to <TT><I>AVL_BALANCED</I></TT>. Otherwise, we compare the 
                  data to be inserted with that of the current node to determine 
                  the direction in which to move. We proceed as we described 
                  earlier for inserting a node into a binary search tree. When 
                  the data we are inserting is less than that of the current 
                  node we are traversing, we make a recursive call that moves us 
                  to the left. When the data is greater, we make a recursive 
                  call that moves us to the right. Once we locate the point at 
                  which to make the insertion, we allocate an 
                  <TT><I>AvlNode</I></TT> structure and insert it into the tree 
                  as the appropriate child of the current node. If the data to 
                  be inserted matches that of a node hidden as a result of being 
                  removed, we destroy the data currently in the node, insert the 
                  new data in its place, and mark the node as no longer hidden. 
                  In this case, rebalancing is not required.</P>
                  <P class=docText>Except after replacing a previously hidden 
                  node, we next determine how the balance of the tree has been 
                  affected so that we can make repairs if necessary. Whether we 
                  have inserted the node to the left or right, we set 
                  <TT><I>balanced</I></TT> to to indicate that the insertion may 
                  have upset the balance of the tree. This causes a switch 
                  statement to be executed that adjusts the balance factor of 
                  the current node. Adjusting the balance factor of the current 
                  node may, in turn, upset the balance factors of nodes higher 
                  in the tree. Thus, as we reenter each activation of <SPAN 
                  class=docEmphasis>insert</SPAN>, we update the balance factor 
                  of the node traversed at that level, provided 
                  <TT><I>balanced</I></TT> is still 0. Once we determine that no 
                  more updates are required, we set <TT><I>balanced</I></TT> to 
                  to inform previous activations of this decision.</P>
                  <P class=docText>The switch statements that determine how to 
                  update balance factors also determine when rotations should be 
                  performed. The actual function we call to perform the 
                  rotation, either <SPAN class=docEmphasis>rotate_left</SPAN> or 
                  <SPAN class=docEmphasis>rotate_right</SPAN>, determines the 
                  type of rotation to apply: either LL or LR if we call <SPAN 
                  class=docEmphasis>rotate_left</SPAN>, or RR or RL if we call 
                  <SPAN class=docEmphasis>rotate_right</SPAN>. Since rotations 
                  change the balance factors of nodes, each rotation function 
                  also adjusts balance factors. The best way to understand the 
                  process of updating balance factors and performing rotations 
                  is to trace through the example in <A class=docLink 
                  href="#ch09-77240">Figure 
                  9.13</A>.</P>
                  <CENTER><A name=IXT-9-314105></A>
                  <H5 class=docFigureTitle><A name=ch09-77240></A>Figure 9.13. 
                  Inserting nodes into an AVL tree</H5><IMG height=488 
                  alt=figs/alc.0913.gif src="image/alc.0913.gif" width=502 
                  border=0></CENTER>
                  <P class=docText>Earlier it was mentioned that the runtime 
                  complexity of inserting a node into a perfectly balanced 
                  binary search tree is <SPAN class=docEmphasis>O</SPAN> (lg 
                  <SPAN class=docEmphasis>n</SPAN>). However, since an AVL tree 
                  keeps itself only approximately balanced, one might wonder how 
                  this affects performance. It turns out that the worst-case 
                  running time of inserting a node into an AVL tree is <SPAN 
                  class=docEmphasis>T </SPAN>(<SPAN class=docEmphasis>n</SPAN>) 
                  = 1.5<SPAN class=docEmphasis>k</SPAN> lg <SPAN 
                  class=docEmphasis>n</SPAN>, where <SPAN 
                  class=docEmphasis>k</SPAN> is some constant, <SPAN 
                  class=docEmphasis>n</SPAN> is the number of nodes in the tree, 
                  and <SPAN class=docEmphasis>T</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN>) = <SPAN class=docEmphasis>k 
                  </SPAN>lg <SPAN class=docEmphasis>n</SPAN> is the time to 
                  insert a node into a perfectly balanced binary tree. Just as 
                  with insertion into a perfectly balanced tree, this results in 
                  a runtime complexity of <SPAN class=docEmphasis>O</SPAN> (lg 
                  <SPAN class=docEmphasis>n</SPAN>). However, the constant of 
                  1.5 does influence performance somewhat in practice.<A 
                  name=IXTR3-71></A></P><A name=ch09-90712></A>
                  <H4 class=docSection2Title>9.7.5 bistree_remove</H4>
                  <P class=docText><A name=IXT-9-314106></A><A 
                  name=IXT-9-314107></A>The <SPAN 
                  class=docEmphasis>bistree_remove</SPAN> operation removes a 
                  node from a binary search tree (see <A class=docLink 
                  href="#ch09-63404">Example 
                  9.5</A>). For this operation, we apply a rather simplistic 
                  heuristic termed <SPAN class=docEmphasis>lazy removal</SPAN><A 
                  name=IXT-9-314108></A>, in which we hide nodes instead of 
                  actually removing them. To hide a node, we set the 
                  <TT><I>hidden</I></TT> member of its <TT><I>AvlNode</I></TT> 
                  structure to 1. If we insert the same data again later, we 
                  simply make the node visible again by setting its 
                  <TT><I>hidden</I></TT> member back to (see <SPAN 
                  class=docEmphasis>bistree_insert</SPAN>). In practice, this 
                  approach is acceptable if we do not expect to remove many 
                  nodes relative to the number we insert. If we plan to remove a 
                  large number of nodes, we might consider actually removing the 
                  node and adjusting the tree. To locate the node to hide, we 
                  recursively call <SPAN class=docEmphasis>hide</SPAN><A 
                  name=IXT-9-314109></A> until we reach the node we are looking 
                  for. Once we hide the node, there is no need to rebalance the 
                  tree because we did not change its structure. Thus, we set 
                  <TT><I>balanced</I></TT> to 1.</P>
                  <P class=docText>The analysis of removing a node from an AVL 
                  tree is the same as for inserting a node. Thus, the runtime 
                  complexity of <SPAN class=docEmphasis>bistree_remove</SPAN> is 
                  <SPAN class=docEmphasis>O</SPAN> (lg <SPAN 
                  class=docEmphasis>n</SPAN>).</P><A name=ch09-110-fm2xml></A>
                  <H4 class=docSection2Title>9.7.6 bistree_lookup</H4>
                  <P class=docText><A name=IXT-9-314110></A>The <SPAN 
                  class=docEmphasis>bistree_lookup</SPAN> operation searches for 
                  a node within a binary search tree and returns a pointer to 
                  the data member of its <TT><I>AvlNode</I></TT> structure (see 
                  <A class=docLink 
                  href="#ch09-63404">Example 
                  9.5</A>). The operation works by calling <SPAN 
                  class=docEmphasis>lookup</SPAN> recursively to descend through 
                  the tree until the desired node is found. At each level, we 
                  first check if we have reached the end of a branch. If we 
                  reach the end of a branch, the node we are looking for does 
                  not exist. Otherwise, we move to either the left or right in 
                  the same manner as described for <SPAN 
                  class=docEmphasis>bistree_insert</SPAN>. The recursion 
                  terminates once we encounter the desired node, at which point 
                  we return 0.</P>
                  <P class=docText>The analysis of searching an AVL tree is the 
                  same as for inserting a node. Thus, the runtime complexity of 
                  <SPAN class=docEmphasis>bistree_lookup</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (lg <SPAN 
                  class=docEmphasis>n</SPAN>).</P><A name=ch09-111-fm2xml></A>
                  <H4 class=docSection2Title>9.7.7 bistree_size</H4>
                  <P class=docText>This macro evaluates to the size of a set 
                  (see <A class=docLink 
                  href="#ch09-89310">Example 
                  9.4</A>). It works by accessing the <TT><I>size</I></TT> 
                  member of the <TT><I>BisTree</I></TT> structure.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>bistree_size</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (1) because accessing a member of a 
                  structure is a simple task that runs in a constant amount of 
                  time.</P>
                  <H5 class=docExampleTitle><A name=ch09-63404></A>Example 9.5. 
                  Implementation of the Binary Search Tree Abstract Datatype 
                  </H5><PRE>/*****************************************************************************
*                                                                            *
*  ------------------------------- bistree.c ------------------------------  *
*                                                                            *
*****************************************************************************/

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "bistree.h"
static void destroy_right(BisTree *tree, BiTreeNode *node);
/*****************************************************************************
*                                                                            *
*  ------------------------------ rotate_left<A name=IXT-9-314111></A> -----------------------------  *
*                                                                            *
*****************************************************************************/

static void rotate_left(BiTreeNode **node) {

BiTreeNode         *left,
                   *grandchild;

left = bitree_left(*node);

if (((AvlNode *)bitree_data(left))-&gt;factor == AVL_LFT_HEAVY) {

   /**************************************************************************
   *                                                                         *
   *  Perform an LL rotation.                                                *
   *                                                                         *
   **************************************************************************/

   bitree_left(*node) = bitree_right(left);
   bitree_right(left) = *node;
   ((AvlNode *)bitree_data(*node))-&gt;factor = AVL_BALANCED;
   ((AvlNode *)bitree_data(left))-&gt;factor = AVL_BALANCED;
   *node = left;

   }

else {

   /**************************************************************************
   *                                                                         *
   *  Perform an LR rotation.                                                *
   *                                                                         *
   **************************************************************************/

   grandchild = bitree_right(left);
   bitree_right(left) = bitree_left(grandchild);
   bitree_left(grandchild) = left;
   bitree_left(*node) = bitree_right(grandchild);
   bitree_right(grandchild) = *node;

   switch (((AvlNode *)bitree_data(grandchild))-&gt;factor) {

      case AVL_LFT_HEAVY:

      ((AvlNode *)bitree_data(*node))-&gt;factor = AVL_RGT_HEAVY;
      ((AvlNode *)bitree_data(left))-&gt;factor = AVL_BALANCED;
      break;

      case AVL_BALANCED:

      ((AvlNode *)bitree_data(*node))-&gt;factor = AVL_BALANCED;
      ((AvlNode *)bitree_data(left))-&gt;factor = AVL_BALANCED;
      break;

      case AVL_RGT_HEAVY:

      ((AvlNode *)bitree_data(*node))-&gt;factor = AVL_BALANCED;
      ((AvlNode *)bitree_data(left))-&gt;factor = AVL_LFT_HEAVY;
      break;

   }

   ((AvlNode *)bitree_data(grandchild))-&gt;factor = AVL_BALANCED;
   *node = grandchild;

}

return;

}

/*****************************************************************************
*                                                                            *
*  ----------------------------- rotate_right<A name=IXT-9-314112></A> -----------------------------  *
*                                                                            *
*****************************************************************************/

static void rotate_right(BiTreeNode **node) {

BiTreeNode         *right,
                   *grandchild;

right = bitree_right(*node);

if (((AvlNode *)bitree_data(right))-&gt;factor == AVL_RGT_HEAVY) {

   /**************************************************************************
   *                                                                         *
   *  Perform an RR rotation.                                                *
   *                                                                         *
   **************************************************************************/

   bitree_right(*node) = bitree_left(right);
   bitree_left(right) = *node;
   ((AvlNode *)bitree_data(*node))-&gt;factor = AVL_BALANCED;
   ((AvlNode *)bitree_data(right))-&gt;factor = AVL_BALANCED;
   *node = right;

   }

else {

   /**************************************************************************
   *                                                                         *
   *  Perform an RL rotation.                                                *
   *                                                                         *
   **************************************************************************/

   grandchild = bitree_left(right);
   bitree_left(right) = bitree_right(grandchild);
   bitree_right(grandchild) = right;
   bitree_right(*node) = bitree_left(grandchild);
   bitree_left(grandchild) = *node;

   switch (((AvlNode *)bitree_data(grandchild))-&gt;factor) {

      case AVL_LFT_HEAVY:

      ((AvlNode *)bitree_data(*node))-&gt;factor = AVL_BALANCED;
      ((AvlNode *)bitree_data(right))-&gt;factor = AVL_RGT_HEAVY;
      break;

      case AVL_BALANCED:

      ((AvlNode *)bitree_data(*node))-&gt;factor = AVL_BALANCED;
      ((AvlNode *)bitree_data(right))-&gt;factor = AVL_BALANCED;
      break;

      case AVL_RGT_HEAVY:

      ((AvlNode *)bitree_data(*node))-&gt;factor = AVL_LFT_HEAVY;
      ((AvlNode *)bitree_data(right))-&gt;factor = AVL_BALANCED;
      break;

   }

   ((AvlNode *)bitree_data(grandchild))-&gt;factor = AVL_BALANCED;
   *node = grandchild;

}

return;

}

/*****************************************************************************
*                                                                            *
*  ----------------------------- destroy_left<A name=IXT-9-314113></A> -----------------------------  *
*                                                                            *
*****************************************************************************/

static void destroy_left(BisTree *tree, BiTreeNode *node) {

BiTreeNode         **position;

/*****************************************************************************
*                                                                            *
*  Do not allow destruction of an empty tree.                                *
*                                                                            *
*****************************************************************************/

if (bitree_size(tree) == 0)
   return;

/*****************************************************************************
*                                                                            *
*  Determine where to destroy nodes.                                         * 
*                                                                            *
*****************************************************************************/

if (node == NULL)
   position = &amp;tree-&gt;root;
else
   position = &amp;node-&gt;left;

/*****************************************************************************
*                                                                            *
*  Destroy the nodes.                                                        *
*                                                                            *
*****************************************************************************/

if (*position != NULL) {

   destroy_left(tree, *position);
   destroy_right(tree, *position);

   if (tree-&gt;destroy != NULL) {

      /***********************************************************************
      *                                                                      *
      *  Call a user-defined function to free dynamically allocated data.    *
      *                                                                      *
      ***********************************************************************/

      tree-&gt;destroy(((AvlNode *)(*position)-&gt;data)-&gt;data);

   }

   /**************************************************************************
   *                                                                         *
   *  Free the AVL data in the node, then free the node itself.              *
   *                                                                         *
   **************************************************************************/

   free((*position)-&gt;data);
   free(*position);
   *position = NULL;

   /**************************************************************************
   *                                                                         *
   *  Adjust the size of the tree to account for the destroyed node.         *
   *                                                                         *
   **************************************************************************/

   tree-&gt;size--;

}

return;

}

/*****************************************************************************
*                                                                            *
*  ----------------------------- destroy_right<A name=IXT-9-314114></A> ----------------------------  *
*                                                                            *
*****************************************************************************/

static void destroy_right(BisTree *tree, BiTreeNode *node) {

BiTreeNode         **position;

/*****************************************************************************
*                                                                            *
*  Do not allow destruction of an empty tree.                                *
*                                                                            *
*****************************************************************************/

if (bitree_size(tree) == 0)
   return;

/*****************************************************************************
*                                                                            *
*  Determine where to destroy nodes.                                         *
*                                                                            *
*****************************************************************************/

if (node == NULL)
   position = &amp;tree-&gt;root;
else
   position = &amp;node-&gt;right;

/*****************************************************************************
*                                                                            *
*  Destroy the nodes.                                                        *
*                                                                            *
*****************************************************************************/

if (*position != NULL) {

   destroy_left(tree, *position);
   destroy_right(tree, *position);

   if (tree-&gt;destroy != NULL) {

      /***********************************************************************
      *                                                                      *
      *  Call a user-defined function to free dynamically allocated data.    *
      *                                                                      *
      ***********************************************************************/

      tree-&gt;destroy(((AvlNode *)(*position)-&gt;data)-&gt;data);

   }

   /**************************************************************************
   *                                                                         *
   *  Free the AVL data in the node, then free the node itself.              *
   *                                                                         *
   **************************************************************************/

   free((*position)-&gt;data);
   free(*position);
   *position = NULL;

   /**************************************************************************
   *                                                                         *
   *  Adjust the size of the tree to account for the destroyed node.         *
   *                                                                         *
   **************************************************************************/

   tree-&gt;size--;

}

return;

}

/*****************************************************************************
*                                                                            *
*  -------------------------------- insert<A name=IXT-9-314115></A> --------------------------------  *
*                                                                            *
*****************************************************************************/

static int insert(BisTree *tree, BiTreeNode **node, const void *data, int
   *balanced) {

AvlNode            *avl_data;

int                cmpval,
                   retval;

/*****************************************************************************
*                                                                            *
*  Insert the data into the tree.                                            *
*                                                                            *
*****************************************************************************/

if (bitree_is_eob(*node)) {

   /**************************************************************************
   *                                                                         *
   *  Handle insertion into an empty tree.                                   *
   *                                                                         *
   **************************************************************************/

   if ((avl_data = (AvlNode *)malloc(sizeof(AvlNode))) == NULL)
      return -1;

   avl_data-&gt;factor = AVL_BALANCED;
   avl_data-&gt;hidden = 0;
   avl_data-&gt;data = (void *)data;

   return bitree_ins_left(tree, *node, avl_data);

   }

else {

   /**************************************************************************
   *                                                                         *
   *  Handle insertion into a tree that is not empty.                        *
   *                                                                         *
   **************************************************************************/

   cmpval = tree-&gt;compare(data, ((AvlNode *)bitree_data(*node))-&gt;data);

   if (cmpval &lt; 0) {

      /***********************************************************************
      *                                                                      *
      *  Move to the left.                                                   *
      *                                                                      *
      ***********************************************************************/

      if (bitree_is_eob(bitree_left(*node))) {

         if ((avl_data = (AvlNode *)malloc(sizeof(AvlNode))) == NULL)
            return -1;

         avl_data-&gt;factor = AVL_BALANCED;
         avl_data-&gt;hidden = 0;
         avl_data-&gt;data = (void *)data;

         if (bitree_ins_left(tree, *node, avl_data) != 0)
            return -1;

         *balanced = 0;

         }

      else {

         if ((retval = insert(tree, &amp;bitree_left(*node), data, balanced))
            != 0) {

            return retval;

         }

      }

      /***********************************************************************
      *                                                                      *
      *  Ensure that the tree remains balanced.                              *
      *                                                                      *
      ***********************************************************************/

      if (!(*balanced)) {

         switch (((AvlNode *)bitree_data(*node))-&gt;factor) {

            case AVL_LFT_HEAVY:

            rotate_left(node);
            *balanced = 1;
            break;

            case AVL_BALANCED:

            ((AvlNode *)bitree_data(*node))-&gt;factor = AVL_LFT_HEAVY;
            break;

            case AVL_RGT_HEAVY:

            ((AvlNode *)bitree_data(*node))-&gt;factor = AVL_BALANCED;
            *balanced = 1;

         }

      }

      } /* if (cmpval &lt; 0) */

   else if (cmpval &gt; 0) {

      /***********************************************************************
      *                                                                      *
      *  Move to the right.                                                  *
      *                                                                      *
      ***********************************************************************/

      if (bitree_is_eob(bitree_right(*node))) {

         if ((avl_data = (AvlNode *)malloc(sizeof(AvlNode))) == NULL)
            return -1;

         avl_data-&gt;factor = AVL_BALANCED;
         avl_data-&gt;hidden = 0;
         avl_data-&gt;data = (void *)data;

         if (bitree_ins_right(tree, *node, avl_data) != 0)
            return -1;

         *balanced = 0;

         }

      else {

         if ((retval = insert(tree, &amp;bitree_right(*node), data, balanced))
            != 0) {

            return retval;

         }

      }

      /***********************************************************************
      *                                                                      *
      *  Ensure that the tree remains balanced.                              *
      *                                                                      *
      ***********************************************************************/

      if (!(*balanced)) {

         switch (((AvlNode *)bitree_data(*node))-&gt;factor) {

            case AVL_LFT_HEAVY:

            ((AvlNode *)bitree_data(*node))-&gt;factor = AVL_BALANCED;
            *balanced = 1;
            break;

            case AVL_BALANCED:

            ((AvlNode *)bitree_data(*node))-&gt;factor = AVL_RGT_HEAVY;
            break;

            case AVL_RGT_HEAVY:

            rotate_right(node);
            *balanced = 1;

         }

      }

      } /* if (cmpval &gt; 0) */

   else {

      /*************************************************************************
      *                                                                        *
      *  Handle finding a copy of the data.                                    *
      *                                                                        *
      *************************************************************************/

      if (!((AvlNode *)bitree_data(*node))-&gt;hidden) {

         /********************************************************************
         *                                                                   *
         *  Do nothing since the data is in the tree and not hidden.         *
         *                                                                   *

         return 1;

         }

      else {

         /********************************************************************
         *                                                                   * 
         *  Insert the new data and mark it as not hidden.                   *
         *                                                                   *
         ********************************************************************/

         if (tree-&gt;destroy != NULL) {

            /*****************************************************************
            *                                                                *
            *  Destroy the hidden data since it is being replaced.           *
            *                                                                *
            *****************************************************************/

            tree-&gt;destroy(((AvlNode *)bitree_data(*node))-&gt;data);

         }

         ((AvlNode *)bitree_data(*node))-&gt;data = (void *)data;
         ((AvlNode *)bitree_data(*node))-&gt;hidden = 0;

         /********************************************************************
         *                                                                   *
         *  Do not rebalance because the tree structure is unchanged.        *
         *                                                                   *
         ********************************************************************/

         *balanced = 1;

      }

   }

}

return 0;

}

/****************************************************************************
*                                                                           *
*  --------------------------------- <A name=IXT-9-314116></A>hide --------------------------------  *
*                                                                           *
****************************************************************************/

static int hide(BisTree *tree, BiTreeNode *node, const void *data) {

int                cmpval,
                   retval;

if (bitree_is_eob(node)) {

   /**************************************************************************
   *                                                                         *
   *  Return that the data was not found.                                    *
   *                                                                         *
   **************************************************************************/

   return -1;

}

cmpval = tree-&gt;compare(data, ((AvlNode *)bitree_data(node))-&gt;data);

if (cmpval &lt; 0) {

   /**************************************************************************
   *                                                                         *
   *  Move to the left.                                                      *
   *                                                                         *
   **************************************************************************/

   retval = hide(tree, bitree_left(node), data);

   }

else if (cmpval &gt; 0) {

   /**************************************************************************
   *                                                                         *
   *  Move to the right.                                                     *
   *                                                                         *
   **************************************************************************/

   retval = hide(tree, bitree_right(node), data);

   }

else {

   /**************************************************************************
   *                                                                         *
   *  Mark the node as hidden.                                               *
   *                                                                         *
   **************************************************************************/

   ((AvlNode *)bitree_data(node))-&gt;hidden = 1;
   retval = 0;

}

return retval;

}
/****************************************************************************
*                                                                           *
*  -------------------------------- lookup<A name=IXT-9-314117></A> -------------------------------  *
*                                                                           *
****************************************************************************/

static int lookup(BisTree *tree, BiTreeNode *node, void **data) {

int                cmpval,
                   retval;

if (bitree_is_eob(node)) {

   /**************************************************************************
   *                                                                         *
   *  Return that the data was not found.                                    *
   *                                                                         *
   **************************************************************************/

   return -1;

}

cmpval = tree-&gt;compare(*data, ((AvlNode *)bitree_data(node))-&gt;data);

if (cmpval &lt; 0) {

   /**************************************************************************
   *                                                                         *
   *  Move to the left.                                                      *

   retval = lookup(tree, bitree_left(node), data);

   }

else if (cmpval &gt; 0) {

   /**************************************************************************
   *                                                                         *
   *  Move to the right.                                                     *
   *                                                                         *
   **************************************************************************/

   retval = lookup(tree, bitree_right(node), data);

   }

else {

   if (!((AvlNode *)bitree_data(node))-&gt;hidden) {

      /***********************************************************************
      *                                                                      *
      *  Pass back the data from the tree.                                   *
      *                                                                      *
      ***********************************************************************/

      *data = ((AvlNode *)bitree_data(node))-&gt;data;
      retval = 0;

      }

   else {

      /***********************************************************************
      *                                                                      *
      *  Return that the data was not found.                                 *
      *                                                                      *
      ***********************************************************************/

      return -1;

   }

}

return retval;

}

/****************************************************************************
*                                                                           *
*  ----------------------------- bistree_init<A name=IXT-9-314118></A> ----------------------------  *
*                                                                           *
****************************************************************************/

void bistree_init(BisTree *tree, int (*compare)(const void *key1, const void
   *key2), void (*destroy)(void *data)) {

/****************************************************************************
*                                                                           *
*  Initialize the tree.                                                     *
*                                                                           *
****************************************************************************/

bitree_init(tree, destroy);
tree-&gt;compare = compare;

return;

}

/****************************************************************************
*                                                                           *
*  ---------------------------- bistree_destroy<A name=IXT-9-314119></A> --------------------------  *
*                                                                           *
****************************************************************************/

void bistree_destroy(BisTree *tree) {

/****************************************************************************
*                                                                           *
*  Destroy all nodes in the tree.                                           *
*                                                                           *
****************************************************************************/

destroy_left(tree, NULL);

/****************************************************************************
*                                                                           *
*  No operations are allowed now, but clear the structure as a precaution.  *
*                                                                           *
****************************************************************************/

memset(tree, 0, sizeof(BisTree));

return;

}

/****************************************************************************
*                                                                           *
*  ---------------------------- bistree_insert<A name=IXT-9-314120></A> ---------------------------  *
*                                                                           *
****************************************************************************/

int bistree_insert(BisTree *tree, const void *data) {

int                balanced = 0;

return insert(tree, &amp;bitree_root(tree), data, &amp;balanced);

}

/****************************************************************************
*                                                                           *
*  ---------------------------- bistree_remove<A name=IXT-9-314121></A> ---------------------------  *
*                                                                           *
****************************************************************************/

int bistree_remove(BisTree *tree, const void *data) {

return <A name=IXT-9-314122></A>hide(tree, bitree_root(tree), data);

}

/****************************************************************************
*                                                                           *
*  ---------------------------- bistree_lookup<A name=IXT-9-314123></A> ---------------------------  *
*                                                                           *
****************************************************************************/

int bistree_lookup(BisTree *tree, void **data) {

return lookup(tree, bitree_root(tree), data);

}</PRE><A name=IXTR3-75></A><A name=IXTR3-76></A><A 
                  name=IXTR3-77></A><A name=IXTR3-73></A><A name=IXTR3-74></A><A 
                  name=IXTR3-72></A>
                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch09-77-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=absMiddle 
                  border=0></A> &nbsp; <A accessKey=1 
                  href="ch09-112-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=absMiddle 
                  border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
