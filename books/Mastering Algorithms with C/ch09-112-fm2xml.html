<HTML><HEAD><TITLE>ch09-112-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 9.&nbsp; 
            Trees</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch09-102-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=left 
                  border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch09-113-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=right 
                  border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch09-112-fm2xml></A>
                  <H3 class=docSection1Title>9.8 Questions and Answers</H3>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Akin to 
                  doubly-linked lists, some trees maintain pointers from child 
                  nodes back to their parents in addition to the normal pointers 
                  from parents to their children. Some trees maintain pointers 
                  between <A name=IXT-9-314124></A>sibling nodes as well. Why 
                  might we do this?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> In general, 
                  maintaining additional pointers gives us greater flexibility 
                  in how we traverse a tree. For example, maintaining pointers 
                  from a parent to its children and from a child to its parent 
                  lets us move both up and down through a tree. Maintaining 
                  pointers between siblings gives us an easy way to traverse 
                  through a node's children without accessing the parent. One 
                  benefit of linked siblings is found in <SPAN 
                  class=docEmphasis>B </SPAN><A name=IXT-9-314125></A><A 
                  name=IXT-9-314126></A>+<SPAN class=docEmphasis>-trees</SPAN>, 
                  a type of balanced search tree in which pointers are used to 
                  link leaf nodes together. By linking leaf nodes, we 
                  effectively form a linked list at the bottom of the tree. This 
                  provides an efficient means of looking up a particular key and 
                  then retrieving others that either precede or follow it in a 
                  sequence. Database systems do this to support efficient random 
                  and sequential access simultaneously. Of course, the 
                  disadvantage is some overhead and complication in managing the 
                  sibling pointers as children are inserted and removed.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Recall that 
                  the example on expression processing used a linked list to 
                  return the appropriate ordering of the nodes to the caller. 
                  This example illustrates two data structures pointing to the 
                  same data. What precautions would we need to take in 
                  destroying each instance of these datatypes?</P>
                  <P class=docText><A name=IXT-9-314127></A><SPAN 
                  class=docEmphBold>A:</SPAN> All of the data structures 
                  presented in this book follow the convention that only a 
                  pointer is maintained to the data inserted into the data 
                  structure. Therefore, it is the responsibility of the caller 
                  to manage the storage associated with the data itself. In the 
                  case of a binary tree and a linked list pointing to the same 
                  physical data in memory, it is important that we pass a 
                  function to free the data only to one of the initialization 
                  operations. The other operation must set 
                  <TT><I>destroy</I></TT> to NULL. Of course, this approach 
                  assumes that the data being shared was dynamically allocated 
                  in the first place. If the data structures point to data that 
                  was not dynamically allocated, <TT><I>destroy</I></TT> should 
                  be set to NULL in both initialization operations since there 
                  is nothing to free.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> In <SPAN 
                  class=docEmphasis>bitree_rem_left</SPAN> and <SPAN 
                  class=docEmphasis>bitree_rem_right</SPAN>, why was a <A 
                  name=IXT-9-314128></A><A name=IXT-9-314129></A>postorder 
                  traversal used to remove the appropriate subtree? Could a <A 
                  name=IXT-9-314130></A><A name=IXT-9-314131></A>preorder or 
                  inorder traversal have been used instead?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> <A 
                  name=IXT-9-314132></A>It is essential to use a postorder 
                  traversal here because a subtree must be removed in its 
                  entirety before removing its parent. A preorder traversal ends 
                  up removing the parent first, thus freeing the parent and 
                  making it impossible to access its children. An inorder 
                  traversal also does not work because we still end up removing 
                  the parent before its right subtree.</P>
                  <P class=docText><A name=IXT-9-314133></A><SPAN 
                  class=docEmphBold>Q:</SPAN> How do we find the smallest node 
                  in a binary search tree? What is the runtime complexity to do 
                  this in both an unbalanced and balanced binary search tree, in 
                  the worst case? How do we find the largest node in a binary 
                  search tree? What are the runtime complexities for this?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> The 
                  smallest node in a binary search tree is the node that is the 
                  furthest to the left. To locate this node, we descend through 
                  the tree by following left pointers until reaching the end of 
                  the branch. In an unbalanced binary search tree, this requires 
                  <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN>) time in the worst case, where 
                  <SPAN class=docEmphasis>n</SPAN> is the number of nodes in the 
                  tree. This occurs when the tree consists of a single branch to 
                  the left, for example. However, if we keep the tree balanced, 
                  no branch will be longer than lg <SPAN 
                  class=docEmphasis>n</SPAN> nodes. Thus, the runtime complexity 
                  of searching for the smallest node in this case is <SPAN 
                  class=docEmphasis>O</SPAN> (lg <SPAN 
                  class=docEmphasis>n</SPAN>). Finding the largest node is a 
                  similar process, except that the largest node is the one that 
                  is the furthest to the right in the tree. The runtime 
                  complexities for this are the same as for locating the 
                  smallest node. If we are interested only in determining the 
                  smallest (or largest) element in a set of data repeatedly, we 
                  use a priority queue (see <A class=docLink 
                  href="ch10-1-fm2xml.html#ch10-1-fm2xml">Chapter 
                  10</A>).</P>
                  <P class=docText><A name=IXT-9-314134></A><A 
                  name=IXT-9-314135></A><SPAN class=docEmphBold>Q:</SPAN> When 
                  might we choose to make use of a tree with a relatively large 
                  branching factor, instead of a binary tree, for example?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Larger 
                  branching factors keep a tree shorter for a given number of 
                  nodes, provided the tree remains relatively balanced. 
                  Therefore, a large branching factor is desirable when an 
                  application is particularly sensitive to the height of the 
                  tree. Search trees are a good example, although typically the 
                  difference in performance attributed to larger branching 
                  factors is not that significant when the tree resides in 
                  memory. This is one reason that binary trees are most common 
                  for searching in memory. However, when searching in the 
                  considerably slower world of secondary storage, a larger 
                  branching factor can make a substantial difference. In this 
                  situation, typically some type of <A name=IXT-9-314136></A><A 
                  name=IXT-9-314137></A>B-tree is used (see the related topics 
                  at the end of the chapter).</P>
                  <P class=docText><A name=IXT-9-314138></A><SPAN 
                  class=docEmphBold>Q:</SPAN> In a binary search tree, the 
                  successor of some node <SPAN class=docEmphasis>x</SPAN> is the 
                  next largest node after <SPAN class=docEmphasis>x</SPAN>. For 
                  example, in a binary search tree containing the keys 24, 39, 
                  41, 55, 87, 92, the successor of 41 is 55. How do we find the 
                  successor of a node in a binary search tree? What is the 
                  runtime complexity of this operation?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> To 
                  determine the successor of some node <SPAN 
                  class=docEmphasis>x</SPAN> in a binary search tree, first we 
                  locate <SPAN class=docEmphasis>x</SPAN>. Next, we follow its 
                  right pointer, and then from this node, follow as many left 
                  pointers as possible until the end of the branch is reached. 
                  The node at the end of this branch is the successor of <SPAN 
                  class=docEmphasis>x</SPAN>. The runtime complexity of locating 
                  either <SPAN class=docEmphasis>x</SPAN> or its successor is 
                  <SPAN class=docEmphasis>O</SPAN> (lg <SPAN 
                  class=docEmphasis>n</SPAN>).</P>
                  <P class=docText><A name=IXT-9-314139></A><SPAN 
                  class=docEmphBold>Q:</SPAN> In a binary search tree, recall 
                  that to insert a node, we trace a specific path to determine 
                  the proper point at which to actually insert it. As more and 
                  more nodes are inserted into a tree, certain areas within the 
                  tree become restricted to certain values. Ultimately, this is 
                  why a tree falls out of balance and rotations are performed. 
                  In the binary search tree of <A class=docLink 
                  href="#ch09-70989">Figure 
                  9.14</A>, what are the possible values for a node inserted at 
                  <SPAN class=docEmphasis>x</SPAN>?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> In <A 
                  class=docLink 
                  href="#ch09-70989">Figure 
                  9.14</A>, any node we insert at <SPAN 
                  class=docEmphasis>x</SPAN> must contain a value greater than 
                  44 and less than 49 because any node to the left of 49 must be 
                  less than 49. On the other hand, the only way for a node to 
                  end up in the right subtree of 44 is to be greater than 
44.</P>
                  <CENTER><A name=IXT-9-314140></A>
                  <H5 class=docFigureTitle><A name=ch09-70989></A>Figure 9.14. A 
                  balanced binary search tree</H5><IMG height=184 
                  alt=figs/alc.0914.gif src="image/alc.0914.gif" width=502 
                  border=0></CENTER>
                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch09-102-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=absMiddle 
                  border=0></A> &nbsp; <A accessKey=1 
                  href="ch09-113-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=absMiddle 
                  border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
