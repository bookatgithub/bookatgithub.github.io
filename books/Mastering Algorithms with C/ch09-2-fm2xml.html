<HTML><HEAD><TITLE>ch09-2-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 9.&nbsp; 
            Trees</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch09-1-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=left 
                  border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch09-9-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=right 
                  border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch09-2-fm2xml></A>
                  <H3 class=docSection1Title>9.1 Description of Binary 
Trees</H3>
                  <P class=docText><A name=ch09-idx-891657-1></A><A 
                  name=ch09-idx-891657-2></A>A <A 
                  name=ch09-idx-891679-1></A>binary tree is a hierarchical 
                  arrangement of nodes<A name=IXT-9-313980></A><A 
                  name=IXT-9-313981></A><A name=IXT-9-313982></A><A 
                  name=IXT-9-313983></A>, each having up to two nodes 
                  immediately below it. The nodes immediately below a node are 
                  called its <SPAN class=docEmphasis>children</SPAN><A 
                  name=IXT-9-313984></A>. The node above each child is called 
                  its <SPAN class=docEmphasis>parent</SPAN><A 
                  name=IXT-9-313985></A>. Nodes can also have <SPAN 
                  class=docEmphasis>siblings</SPAN><A name=IXT-9-313986></A>, 
                  <SPAN class=docEmphasis>descendants</SPAN><A 
                  name=IXT-9-313987></A>, and <SPAN 
                  class=docEmphasis>ancestors</SPAN><A name=IXT-9-313988></A>. 
                  As you might expect, the siblings of a node are the other 
                  children of its parent. The descendants of a node are all of 
                  the nodes branching out below it. The ancestors of a node are 
                  all the nodes along the path between it and the root. The 
                  performance associated with a tree often is discussed in terms 
                  of its <SPAN class=docEmphasis>height</SPAN>, the number of 
                  levels in which nodes reside. As we will see, tree terminology 
                  is as much familial as it is arboreal (see <A class=docLink 
                  href="#ch09-77347">Figure 
                  9.1</A>).</P>
                  <P class=docText><A name=IXT-9-313989></A><A 
                  name=IXT-9-313990></A><A name=IXT-9-313991></A>Each node in a 
                  binary tree contains three parts: a data member and two 
                  pointers called the <SPAN class=docEmphasis>left</SPAN> and 
                  <SPAN class=docEmphasis>right</SPAN> pointers. Using this 
                  three-member structure, we form a binary tree by setting the 
                  <SPAN class=docEmphasis>left</SPAN> and <SPAN 
                  class=docEmphasis>right</SPAN> pointers of each node to point 
                  to its children (see <A class=docLink 
                  href="#ch09-99282">Figure 
                  9.2</A>). If a node does not have a child to its left or 
                  right, we set the appropriate pointer to NULL, a convenient 
                  sentinel that marks the end of a <SPAN 
                  class=docEmphasis>branch</SPAN><A name=IXT-9-313992></A>. A 
                  branch is a series of nodes beginning at the root and ending 
                  at a <SPAN class=docEmphasis>leaf node</SPAN><A 
                  name=IXT-9-313993></A>. Leaf nodes are the nodes along the 
                  fringe of the tree that have no children. Sometimes when 
                  working with several trees at once, the trees are said to form 
                  a <SPAN class=docEmphasis>forest</SPAN>.</P>
                  <CENTER><A name=IXT-9-313994></A>
                  <H5 class=docFigureTitle><A name=ch09-77347></A>Figure 9.1. 
                  Common tree terminology illustrated with a four-level binary 
                  tree</H5><IMG height=234 alt=figs/alc.0901.gif 
                  src="image/alc.0901.gif" width=502 border=0></CENTER>
                  <CENTER>
                  <H5 class=docFigureTitle><A name=ch09-99282></A>Figure 9.2. 
                  Nodes linked together to form a binary tree</H5><IMG 
                  height=281 alt=figs/alc.0902.gif src="image/alc.0902.gif" 
                  width=502 border=0></CENTER><A name=ch09-3-fm2xml></A>
                  <H4 class=docSection2Title>9.1.1 Traversal Methods</H4>
                  <P class=docText><A name=ch09-idx-374653-1></A><A 
                  name=ch09-idx-374653-2></A><A 
                  name=ch09-idx-374655-1></A>Traversing a binary tree means 
                  visiting its nodes one at a time in a specific order. Compared 
                  with some linked data structures, such as linked lists, how to 
                  traverse the nodes of a binary tree may not be immediately 
                  apparent. In fact, there are many ways in which we can 
                  proceed. Typically, one of four types of traversals is used: 
                  <SPAN class=docEmphasis>preorder</SPAN>, <SPAN 
                  class=docEmphasis>inorder</SPAN>, <SPAN 
                  class=docEmphasis>postorder</SPAN>, or <SPAN 
                  class=docEmphasis>level order</SPAN>. The example of 
                  expression trees later in this chapter presents recursive 
                  implementations of the preorder, inorder, and postorder 
                  traversals. For now, let's look at how each traversal 
                  works.</P>
                  <P class=docText>Traversing a tree is particularly simple if 
                  we think of the tree recursively as being composed of many 
                  smaller subtrees. <A class=docLink 
                  href="#ch09-12554">Figure 
                  9.3</A> illustrates each traversal. Although these traversals 
                  are presented in the context of binary trees, each can be 
                  generalized to other types of trees as well.</P><A 
                  name=ch09-4-fm2xml></A>
                  <H5 class=docSection3Title>9.1.1.1 Preorder traversal</H5>
                  <P class=docText>In a <A name=IXT-9-313995></A><A 
                  name=IXT-9-313996></A><A name=IXT-9-313997></A>preorder 
                  traversal for a given subtree, we first traverse its root, 
                  then to the left, and then to the right. As we explore 
                  subtrees to the left and right, we proceed in a similar manner 
                  using the left or right node as the root of the new subtree. 
                  <A name=IXT-9-313998></A>The preorder traversal is a 
                  depth-first exploration, like that presented for graphs in <A 
                  class=docLink 
                  href="ch11-1-fm2xml.html#ch11-1-fm2xml">Chapter 
                  11</A>.</P><A name=ch09-5-fm2xml></A>
                  <H5 class=docSection3Title>9.1.1.2 Inorder traversal</H5>
                  <P class=docText><A name=IXT-9-313999></A><A 
                  name=IXT-9-314000></A><A name=IXT-9-314001></A>In an inorder 
                  traversal for a given subtree, we first traverse to the left, 
                  then to the root, and then to the right. As we explore 
                  subtrees to the left and right, we proceed in a similar manner 
                  using the left or right node as the root of the new 
                  subtree.</P><A name=ch09-6-fm2xml></A>
                  <H5 class=docSection3Title>9.1.1.3 Postorder traversal</H5>
                  <P class=docText><A name=IXT-9-314002></A><A 
                  name=IXT-9-314003></A><A name=IXT-9-314004></A>In a postorder 
                  traversal for a given subtree, we first traverse to the left, 
                  then to the right, and then to the root. As we explore 
                  subtrees to the left and right, we proceed in a similar manner 
                  using the left or right node as the root of the new 
                  subtree.</P><A name=ch09-7-fm2xml></A>
                  <H5 class=docSection3Title>9.1.1.4 Level-order traversal</H5>
                  <P class=docText><A name=IXT-9-314005></A>To traverse a binary 
                  tree in a level-order fashion, visit its nodes beginning at 
                  the root and proceed downward, visiting the nodes at each 
                  level from left to right. The level-order traversal is a 
                  breadth-first exploration, like that presented for graphs in 
                  <A class=docLink 
                  href="ch11-1-fm2xml.html#ch11-1-fm2xml">Chapter 
                  11</A>. <A name=IXTR3-60></A><A name=IXTR3-61></A></P>
                  <CENTER><A name=IXT-9-314006></A><A name=IXT-9-314007></A>
                  <H5 class=docFigureTitle><A name=ch09-12554></A>Figure 9.3. 
                  Traversing a binary tree in (a) preorder, (b) inorder, (c) 
                  postorder, and (d) level order</H5><IMG height=350 
                  alt=figs/alc.0903.gif src="image/alc.0903.gif" width=502 
                  border=0></CENTER><A name=ch09-8-fm2xml></A>
                  <H4 class=docSection2Title>9.1.2 Tree Balancing</H4>
                  <P class=docText><A name=IXT-9-314008></A>Balancing a tree is 
                  the process of keeping it as short as possible for a given 
                  number of nodes. This means making sure that one level of the 
                  tree is completely full before allowing a node to exist at the 
                  next level. Formally, a tree is balanced if all leaf nodes are 
                  at the same level or, if not, all leaf nodes are in the last 
                  two levels and the second-to-last level is full. For example, 
                  the tree in <A class=docLink 
                  href="#ch09-77347">Figure 
                  9.1</A> is balanced because all leaf nodes are in the third 
                  and fourth levels, and the third level is full. On the other 
                  hand, the tree in <A class=docLink 
                  href="#ch09-12554">Figure 
                  9.3</A> is not balanced. A <A name=IXT-9-314009></A>balanced 
                  tree is <SPAN class=docEmphasis>left-balanced</SPAN><A 
                  name=IXT-9-314010></A> if all leaves occupy only the leftmost 
                  positions in the last level. The tree in <A class=docLink 
                  href="#ch09-78961">Figure 
                  9.4</A> is a left-balanced tree. We will see one important 
                  application of balanced trees when binary search trees are 
                  discussed later in this chapter. In <A class=docLink 
                  href="ch10-1-fm2xml.html#ch10-1-fm2xml">Chapter 
                  10</A> we will see how a left-balanced binary tree helps to 
                  implement a heap and priority queue.</P>
                  <CENTER><A name=IXTR3-62></A>
                  <H5 class=docFigureTitle><A name=ch09-78961></A>Figure 9.4. A 
                  left-balanced binary tree</H5><IMG height=189 
                  alt=figs/alc.0904.gif src="image/alc.0904.gif" width=502 
                  border=0></CENTER>                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch09-1-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=absMiddle 
                  border=0></A> &nbsp; <A accessKey=1 
                  href="ch09-9-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=absMiddle 
                  border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
