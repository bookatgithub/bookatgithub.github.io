<HTML><HEAD><TITLE>ch09-75-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 9.&nbsp; 
            Trees</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch09-66-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=left 
                  border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch09-76-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=right 
                  border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch09-75-fm2xml></A>
                  <H3 class=docSection1Title>9.4 Binary Tree Example: Expression 
                  Processing</H3>
                  <P class=docText><A name=ch09-idx-376113-1></A>One <A 
                  name=ch09-idx-891688-1></A>intuitive way to process arithmetic 
                  expressions with a computer is using an <SPAN 
                  class=docEmphasis>expression tree</SPAN>. An expression tree 
                  is a binary tree consisting of nodes containing two types of 
                  objects: <A name=IXT-9-314055></A><SPAN 
                  class=docEmphasis>operators</SPAN> and <SPAN 
                  class=docEmphasis>terminal values</SPAN><A 
                  name=IXT-9-314056></A>. Operators are objects that have 
                  operands; terminal values are objects that have no 
                  operands.</P>
                  <P class=docText>The idea behind an expression tree is simple: 
                  the subtrees rooted at the children of each node are the 
                  operands of the operator stored in the parent (see <A 
                  class=docLink 
                  href="#ch09-77459">Figure 
                  9.5</A>). Operands may be terminal values, or they may be 
                  other expressions themselves. Expressions are expanded in 
                  subtrees; terminal values reside in leaf nodes. One of the 
                  nice things about this idea is how easily an expression tree 
                  allows us to translate an expression into one of three common 
                  representations: <SPAN class=docEmphasis>prefix</SPAN>, <SPAN 
                  class=docEmphasis>infix</SPAN>, and <SPAN 
                  class=docEmphasis>postfix</SPAN>. To obtain these 
                  representations, we simply traverse the tree using a <A 
                  name=IXT-9-314057></A>preorder, inorder, or <A 
                  name=IXT-9-314058></A><A name=IXT-9-314059></A>postorder 
                  traversal.<A name=IXT-9-314060></A></P>
                  <P class=docText><A name=IXT-9-314061></A><A 
                  name=IXT-9-314062></A>Traversing the tree in <A class=docLink 
                  href="#ch09-77459">Figure 
                  9.5</A> in preorder, for example, yields the prefix expression 
                  x / - 74 10 32 + 23 17. To evaluate a prefix expression, we 
                  apply each operator to the two operands that immediately 
                  follow it. Thus, the prefix expression just given is evaluated 
                  as:</P>
                  <P class=docText>( x ( / ( - 74 10 ) 32 ) ( + 23 17 ) ) = 
                  80</P>
                  <P class=docText><A name=IXT-9-314063></A>Infix expressions 
                  are the expressions we are most familiar with from 
                  mathematics, but they are not well suited to processing by a 
                  computer. If we traverse the tree of <A class=docLink 
                  href="#ch09-77459">Figure 
                  9.5</A> using an <A name=IXT-9-314064></A><A 
                  name=IXT-9-314065></A>inorder traversal, we get the infix 
                  expression 74 - 10 / 32 x 23 + 17. Notice that one of the 
                  difficulties with infix expressions is that they do not 
                  inherently identify in which order operations should be 
                  performed, whereas prefix and postfix expressions do. However, 
                  we can remedy this situation in an infix expression by 
                  parenthesizing each part of the expression as we traverse it 
                  in the tree. Fully parenthesized, the previous infix 
                  expression is evaluated as:</P>
                  <P class=docText>( ( ( 74 - 10 ) / 32 ) x ( 23 + 17 ) ) = 
                  80</P>
                  <P class=docText><A name=IXT-9-314066></A>Postfix expressions 
                  are well suited to processing by a computer. If we traverse 
                  the tree of <A class=docLink 
                  href="#ch09-77459">Figure 
                  9.5</A> in postorder, we get the postfix expression 74 10 - 32 
                  / 23 17 + x. To evaluate a postfix expression, we apply each 
                  operator to the two operands immediately preceding it. Thus, 
                  the postfix expression just given is evaluated as:</P>
                  <P class=docText>( ( ( 74 10 - ) 32 /) ( 23 17 + ) x ) = 
80</P>
                  <CENTER><A name=IXT-9-314067></A>
                  <H5 class=docFigureTitle><A name=ch09-77459></A>Figure 9.5. An 
                  expression tree for the expression ((74 - 10) / 32) x (23 + 
                  17)</H5><IMG height=189 alt=figs/alc.0905.gif 
                  src="image/alc.0905.gif" width=502 border=0></CENTER>
                  <P class=docText>One reason postfix expressions are well 
                  suited to computers is that they are easy to evaluate with an 
                  <A name=IXT-9-314068></A><SPAN class=docEmphasis>abstract 
                  stack machine</SPAN>, an abstraction used by compilers and 
                  hand-held calculators. To process a postfix expression using 
                  an abstract stack machine, we proceed as follows. First, we 
                  move from left to right through the expression, pushing values 
                  onto the stack until an operator is encountered. Next, the 
                  operands required by the operator are popped, the operator is 
                  applied to them, and the result is pushed back on the stack. 
                  This procedure is repeated until the entire expression has 
                  been processed, at which point the value of the expression is 
                  the lone item remaining on the stack (see <A class=docLink 
                  href="#ch09-70386">Figure 
                  9.6</A>).</P>
                  <CENTER>
                  <H5 class=docFigureTitle><A name=ch09-70386></A>Figure 9.6. An 
                  abstract stack machine processing the postfix expression 74 10 
                  - 32 / 23 17 + x</H5><IMG height=198 alt=figs/alc.0906.gif 
                  src="image/alc.0906.gif" width=502 border=0></CENTER>
                  <P class=docText><A class=docLink 
                  href="#ch09-14347">Example 
                  9.3</A> illustrates how to produce the prefix, infix, and 
                  postfix representations of an expression stored in an 
                  expression tree. For this, three functions are provided, <SPAN 
                  class=docEmphasis>preorder</SPAN>,<A name=IXT-9-314069></A> 
                  <SPAN class=docEmphasis>inorder</SPAN><A 
                  name=IXT-9-314070></A>, and <SPAN 
                  class=docEmphasis>postorder</SPAN><A 
                  name=ch09-idx-891918-1></A>, which traverse a binary tree in 
                  preorder, inorder, and postorder, respectively. Each function 
                  accepts two arguments: <TT><I>node</I></TT> and 
                  <TT><I>list</I></TT>.</P>
                  <P class=docText>To begin a traversal, we set 
                  <TT><I>node</I></TT> to the root node of the expression tree 
                  we wish to traverse. Successive recursive calls set 
                  <TT><I>node</I></TT> to the node at the top of the subtree 
                  about to be traversed. On the initial call to each function, 
                  we also pass into <TT><I>list</I></TT> an empty linked list 
                  already initialized with <SPAN 
                  class=docEmphasis>list_init</SPAN>. For each of the 
                  traversals, nodes are placed into the list in the order they 
                  are encountered. When the initial call in the recursion 
                  returns, <TT><I>list</I></TT> contains the preorder, inorder, 
                  or postorder listing of the nodes, as appropriate. <A 
                  name=IXT-9-314071></A>Notice how a recursive implementation of 
                  these traversals nicely models the definitions presented 
                  earlier in the chapter.</P>
                  <H5 class=docExampleTitle><A name=ch09-14347></A>Example 9.3. 
                  Implementation of Functions for Traversing a Binary Tree </H5><PRE>/*****************************************************************************
*                                                                            *
*  ------------------------------ <A name=ch09-idx-892413-1></A>traverse.c ------------------------------  *
*                                                                            *
*****************************************************************************/

#include "list.h"
#include "traverse.h"

/*****************************************************************************
*                                                                            *
*  ------------------------------- preorder<A name=IXT-9-314072></A> -------------------------------  *
*                                                                            *
*****************************************************************************/

int preorder(const BiTreeNode *node, List *list) {

/*****************************************************************************
*                                                                            *
*  Load the list with a preorder listing of the tree.                        *
*                                                                            *
*****************************************************************************/

if (!bitree_is_eob(node)) {

   if (list_ins_next(list, list_tail(list), bitree_data(node)) != 0)
      return -1;

   if (!bitree_is_eob(bitree_left(node)))
      if (preorder(bitree_left(node), list) != 0)
         return -1;

   if (!bitree_is_eob(bitree_right(node)))
      if (preorder(bitree_right(node), list) != 0)
         return -1;

}

return 0;

}

/*****************************************************************************
*                                                                            *
*  -------------------------------- inorder<A name=IXT-9-314073></A> -------------------------------  *
*                                                                            *
*****************************************************************************/

int inorder(const BiTreeNode *node, List *list) {

/*****************************************************************************
*                                                                            *
*  Load the list with an inorder listing of the tree.                        *
*                                                                            *
*****************************************************************************/

if (!bitree_is_eob(node)) {

   if (!bitree_is_eob(bitree_left(node)))
      if (inorder(bitree_left(node), list) != 0)
         return -1;

   if (list_ins_next(list, list_tail(list), bitree_data(node)) != 0)
      return -1;

   if (!bitree_is_eob(bitree_right(node)))
      if (inorder(bitree_right(node), list) != 0)
         return -1;

}

return 0;

}

/*****************************************************************************
*                                                                            *
*  ------------------------------- postorder ------------------------------  *
*                                                                            *
*****************************************************************************/

int postorder(const BiTreeNode *node, List *list) {

/*****************************************************************************
*                                                                            *
*  Load the list with a postorder listing of the tree.                       *
*                                                                            *
*****************************************************************************/

if (!bitree_is_eob(node)) {

   if (!bitree_is_eob(bitree_left(node)))
      if (postorder(bitree_left(node), list) != 0)
         return -1;

   if (!bitree_is_eob(bitree_right(node)))
      if (postorder<A name=IXTR3-65></A>(bitree_right(node), list) != 0)
         return -1;

   if (list_ins_next(list, list_tail(list), bitree_data(node))<A name=IXTR3-66></A> != 0)
      return<A name=IXTR3-67></A> -1;

}

return<A name=IXTR3-68></A> 0;

}<A name=IXTR3-69></A></PRE>                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch09-66-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=absMiddle 
                  border=0></A> &nbsp; <A accessKey=1 
                  href="ch09-76-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=absMiddle 
                  border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
