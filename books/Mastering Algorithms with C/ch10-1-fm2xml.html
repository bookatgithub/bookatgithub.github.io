<HTML><HEAD><TITLE>ch10-1-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Part II:&nbsp; Data 
              Structures</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch09-113-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=left 
                  border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch10-2-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=right 
                  border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch10-1-fm2xml></A>
                  <H2 class=docChapterTitle>Chapter 10. Heaps and Priority 
                  Queues</H2>
                  <P class=docText><A name=ch10-idx-872148-1></A>Many problems 
                  rely on being able to determine quickly the largest or 
                  smallest element from a set that is undergoing frequent 
                  insertions and deletions. One way to approach this problem is 
                  to keep a set sorted. This way, the largest or smallest 
                  element, depending on whether we sort the data in ascending or 
                  descending order, is always the one at the beginning of the 
                  set. However, sorting a set over and over again is costly. In 
                  addition, because it is not our goal to keep <SPAN 
                  class=docEmphasis>every</SPAN> element in order, we end up 
                  doing more work than we really need to. To quickly determine 
                  only the largest or smallest element, we need only keep this 
                  element where we can find it. Heaps and priority queues let us 
                  do this in an efficient way.</P>
                  <P class=docText>This chapter covers:</P><A 
                  name=IXT-10-314157></A><A name=IXT-10-314158></A><A 
                  name=IXT-10-314159></A><A name=IXT-10-314160></A>
                  <DL class=docList>
                    <DT><SPAN class=docPubcolor>Heaps <A 
                    name=IXT-10-314157></A></SPAN>
                    <DD>
                    <P class=docList>Trees organized so that we can determine 
                    the node with the largest value quickly. The cost to 
                    preserve this property is less than that of keeping the data 
                    sorted. We can also organize a heap so that we can determine 
                    the smallest value just as easily.</P>
                    <DT><SPAN class=docPubcolor>Priority queues <A 
                    name=IXT-10-314158></A><A name=IXT-10-314159></A><A 
                    name=IXT-10-314160></A></SPAN>
                    <DD>
                    <P class=docList>Data structures naturally derived from 
                    heaps. In a priority queue, data is organized in a heap so 
                    that we can determine the node with the next highest 
                    priority quickly. The "priority" of an element can mean 
                    different things in different problems.</P></DD></DL>
                  <P class=docText>Some <A name=IXT-10-314161></A>applications 
                  of heaps and priority queues are:<A 
                  name=IXT-10-314162></A></P><A name=IXT-10-314163></A><A 
                  name=IXT-10-314164></A><A name=IXT-10-314165></A><A 
                  name=IXT-10-314166></A><A name=IXT-10-314167></A><A 
                  name=IXT-10-314168></A>
                  <DL class=docList>
                    <DT><SPAN class=docPubcolor>Sorting <A 
                    name=IXT-10-314163></A><A name=IXT-10-314164></A></SPAN>
                    <DD>
                    <P class=docList>Specifically, an algorithm called <SPAN 
                    class=docEmphasis>heapsort</SPAN>. In heapsort, the data to 
                    be sorted begins in a heap. Nodes are extracted from the 
                    heap one at a time and placed at the end of a sorted set. As 
                    each node is extracted, the next node for the sorted set 
                    percolates to the top of the heap. Heapsort has the same 
                    runtime complexity as quicksort (see <A class=docLink 
                    href="ch12-1-fm2xml.html#ch12-1-fm2xml">Chapter 
                    12</A> ), but a good implementation of quicksort usually 
                    beats it by a small constant factor in practice.</P>
                    <DT><SPAN class=docPubcolor>Task scheduling <A 
                    name=IXT-10-314165></A></SPAN>
                    <DD>
                    <P class=docList>For example, that performed by operating 
                    systems to determine which process is next to run on a CPU. 
                    Operating systems continually change the priorities of 
                    processes. A priority queue is an efficient way to ensure 
                    that the highest-priority process is next to get the 
CPU.</P>
                    <DT><SPAN class=docPubcolor>Parcel sorting (illustrated in 
                    this chapter) <A name=IXT-10-314166></A></SPAN>
                    <DD>
                    <P class=docList>A process used by delivery companies to 
                    prioritize the routing of parcels. As parcels are scanned, 
                    high priorities are assigned to those requiring urgent <A 
                    name=IXT-10-314167></A>delivery. Parcels that are less 
                    urgent are assigned lower priorities. A computer system 
                    might use a priority queue as an efficient means of ensuring 
                    that the highest priority parcels move through the system 
                    the fastest.</P>
                    <DT><I><SPAN class=docPubcolor>Huffman coding </SPAN></I>
                    <DD>
                    <P class=docList>A method of data compression that uses a 
                    Huffman tree to assign codes to symbols in the data (see <A 
                    class=docLink 
                    href="ch14-1-fm2xml.html#ch14-1-fm2xml">Chapter 
                    14</A>). Frequently occurring symbols are assigned short 
                    codes, whereas symbols occuring less frequently are assigned 
                    longer ones. The Huffman tree is built by merging smaller 
                    binary trees two by two. The two trees merged at each step 
                    are extracted from a priority queue because we merge the two 
                    with the smallest key values.</P>
                    <DT><SPAN class=docPubcolor>Load balancing <A 
                    name=IXT-10-314168></A></SPAN>
                    <DD>
                    <P class=docList>Often usage statistics are maintained about 
                    a number of servers handling similar tasks. As connection 
                    requests arrive, a priority queue can be used to determine 
                    which server is best able to accommodate a new 
                    request.</P></DD></DL>                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch09-113-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=absMiddle 
                  border=0></A> &nbsp; <A accessKey=1 
                  href="ch10-2-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=absMiddle 
                  border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
