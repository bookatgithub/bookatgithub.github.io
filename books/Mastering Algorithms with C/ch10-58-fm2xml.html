<HTML><HEAD><TITLE>ch10-58-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 10.&nbsp; Heaps and 
                  Priority Queues</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch10-57-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=left 
                  border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch10-59-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=right 
                  border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch10-58-fm2xml></A>
                  <H3 class=docSection1Title>10.8 Questions and Answers</H3>
                  <P class=docText><A name=IXT-10-314241></A><SPAN 
                  class=docEmphBold>Q:</SPAN> To build a heap from a set of data 
                  using the interface presented in this chapter, we call <SPAN 
                  class=docEmphasis>heap_insert</SPAN> once for each element in 
                  the set. Since <SPAN class=docEmphasis>heap_insert</SPAN> runs 
                  in <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>lg</SPAN> <SPAN class=docEmphasis>n)</SPAN> 
                  time, building a heap of <SPAN class=docEmphasis>n</SPAN> 
                  nodes requires <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>n lg</SPAN> <SPAN 
                  class=docEmphasis>n)</SPAN> time. What is an alternative to 
                  this approach that runs in <SPAN class=docEmphasis>O 
                  </SPAN>(<SPAN class=docEmphasis>n)</SPAN> time?</P>
                  <P class=docText><A name=IXT-10-314242></A><SPAN 
                  class=docEmphBold>A:</SPAN> An alternative to calling <SPAN 
                  class=docEmphasis>heap_insert</SPAN> repeatedly is to start 
                  with an array of nodes that we heapify by pushing data 
                  downward just as is done in <SPAN 
                  class=docEmphasis>heap_insert</SPAN>. In this approach, we 
                  first heapify the tree whose root is at position &#63728;<SPAN 
                  class=docEmphasis>n</SPAN>/2&#63739; - 1, then heapify the tree whose 
                  root is at position &#63728;<SPAN class=docEmphasis>n</SPAN>/2&#63739; - 2, 
                  and continue this process until we heapify the tree rooted at 
                  position 0. This approach relies on the observation that the 
                  nodes at &#63728;<SPAN class=docEmphasis>n</SPAN>/2&#63739; to <SPAN 
                  class=docEmphasis>n</SPAN> - 1 (in a zero-indexed array) are 
                  one-node heaps themselves because they are the leaf nodes. 
                  Building a heap in this way is efficient because although 
                  there are &#63728;<SPAN class=docEmphasis>n</SPAN>/2&#63739; - 1 operations 
                  that run in <SPAN class=docEmphasis>O</SPAN> (lg <SPAN 
                  class=docEmphasis>n</SPAN>) time, a tighter analysis reveals 
                  that even in the worst case only half the heapifications 
                  require comparing data at more than one level. This results in 
                  an <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN>) running time overall. On the other 
                  hand, when calling <SPAN class=docEmphasis>heap_insert</SPAN> 
                  repeatedly, half the heapifications could require traversing 
                  all lg <SPAN class=docEmphasis>n</SPAN> levels in the worst 
                  case. Thus, building a heap in this way runs in <SPAN 
                  class=docEmphasis>O </SPAN>(<SPAN class=docEmphasis>n</SPAN> 
                  lg <SPAN class=docEmphasis>n</SPAN>) time.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Why are 
                  <SPAN class=docEmphasis>heap_ parent</SPAN>, <SPAN 
                  class=docEmphasis>heap_left</SPAN><A name=IXT-10-314243></A>, 
                  and <SPAN class=docEmphasis>heap_right</SPAN><A 
                  name=IXT-10-314244></A> defined in <SPAN 
                  class=docEmphasis>heap.c</SPAN>, whereas the other heap macro, 
                  <SPAN class=docEmphasis>heap_size</SPAN>, is defined in <SPAN 
                  class=docEmphasis>heap.h</SPAN>?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> The macros 
                  <SPAN class=docEmphasis>heap_ parent</SPAN>, <SPAN 
                  class=docEmphasis>heap_left</SPAN>, and <SPAN 
                  class=docEmphasis>heap_right</SPAN> quickly determine the 
                  position of a node's parent, left child, and right child in a 
                  tree represented in an array. The reason these macros are not 
                  defined in <I>heap.h</I> is that they are not a part of the 
                  public heap interface. That is, a developer using a heap 
                  should not be permitted to traverse a heap's nodes 
                  indiscriminately. Instead, access to the heap is restricted to 
                  those operations defined by the interface published in 
                  <I>heap.h</I>.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Recall that 
                  left-balanced binary trees are particularly well-suited to 
                  arrays. Why is this not true of all binary trees?</P>
                  <P class=docText><A name=IXT-10-314245></A><SPAN 
                  class=docEmphBold>A:</SPAN> Left-balanced binary trees are 
                  particularly well-suited to arrays because no nodes go unused 
                  between positions and <SPAN class=docEmphasis>n</SPAN> - 1, 
                  where <SPAN class=docEmphasis>n</SPAN> is the number of nodes 
                  in the tree. Array representations of binary trees that are 
                  not left-balanced, on the other hand, contain gaps of unused 
                  nodes. For example, suppose a binary tree of 10 levels is 
                  completely full through 9 levels, but in the tenth level only 
                  1 node resides at the far right. In contiguous storage, the 
                  node at the far right of the tenth level resides at position 
                  2<SUP>10</SUP> - 2 = 1022 (in a zero-indexed array). The node 
                  at the far right of the ninth level resides at position 
                  2<SUP>9</SUP> - 2 = 510. This results in (1022 - 510) - 1= 511 
                  empty positions out of the total 1023 positions required to 
                  represent the tree. Thus, only 50% of the array is being 
                  used.</P>
                  <P class=docText><A name=IXT-10-314246></A><SPAN 
                  class=docEmphBold>Q:</SPAN> Suppose we are using a priority 
                  queue to prioritize the order in which tasks are scheduled by 
                  an application. If the system continually processes a large 
                  number of high-priority tasks, what problems might the system 
                  exhibit? How can we correct this?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> When 
                  high-priority elements are continually being inserted into a 
                  priority queue, lower-priority elements may never rise to the 
                  top. In a task scheduler, for example, the lower-priority 
                  tasks are said to be experiencing <SPAN 
                  class=docEmphasis>starvation</SPAN><A name=IXT-10-314247></A>. 
                  To manage this, typically a system employs some mechanism to 
                  increase a task's priority gradually as its time in the queue 
                  grows. Thus, even in a busy system flooded by high-priority 
                  tasks, a low-priority task eventually will obtain a high 
                  enough priority to rise to the top. Operating systems 
                  frequently use an approach like this to ensure that 
                  lower-priority processes are not completely starved of CPU 
                  time.</P>
                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch10-57-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=absMiddle 
                  border=0></A> &nbsp; <A accessKey=1 
                  href="ch10-59-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=absMiddle 
                  border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
