<HTML><HEAD><TITLE>ch11-1-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Part II:&nbsp; Data 
              Structures</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch10-59-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=left 
                  border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch11-2-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=right 
                  border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch11-1-fm2xml></A>
                  <H2 class=docChapterTitle>Chapter 11. Graphs</H2>
                  <P class=docText><A name=ch11-idx-572668-1></A>Graphs are some 
                  of the most flexible data structures in computing. In fact, 
                  most other data structures can be represented as graphs, 
                  although representing them in this way is usually more 
                  complicated. Generally, graphs are used to model problems 
                  defined in terms of relationships or connections between 
                  objects. Objects in a graph may be tangible entities such as 
                  nodes in a network or islands in a river, but they need not 
                  be. Often objects are less concrete, such as states in a 
                  system or transactions in a database. The same is true for 
                  connections and relationships among the objects. Nodes in a 
                  network are physically connected, but the connections between 
                  states in a system may simply indicate a decision made to get 
                  from one state to the next. Whatever the case, graphs model 
                  many useful and interesting computational problems.</P>
                  <P class=docText>This chapter covers:</P><A 
                  name=IXT-11-314252></A><A name=IXT-11-314253></A><A 
                  name=IXT-11-314254></A><A name=IXT-11-314255></A><A 
                  name=IXT-11-314256></A><A name=IXT-11-314257></A>
                  <DL class=docList>
                    <DT><I><SPAN class=docPubcolor>Graphs </SPAN></I>
                    <DD>
                    <P class=docList>Flexible data structures typically used to 
                    model problems defined in terms of relationships or 
                    connections between objects. Objects are represented by 
                    <SPAN class=docEmphasis>vertices</SPAN><A 
                    name=IXT-11-314252></A><A name=IXT-11-314253></A><A 
                    name=IXT-11-314254></A><A name=IXT-11-314255></A>, and the 
                    relationships or connections between the objects are 
                    represented by <SPAN class=docEmphasis>edges</SPAN><A 
                    name=IXT-11-314256></A> between the vertices.</P>
                    <DT><SPAN class=docPubcolor>Search methods <A 
                    name=IXT-11-314257></A></SPAN>
                    <DD>
                    <P class=docList>Techniques for visiting the vertices of a 
                    graph in a specific order. Generally, either breadth-first 
                    or depth-first searches are used. Many graph algorithms are 
                    based on these basic methods of systematically exploring a 
                    graph's vertices.</P></DD></DL>
                  <P class=docText>Some <A name=IXT-11-314258></A>applications 
                  of graphs are<A name=IXT-11-314259></A>:</P><A 
                  name=IXT-11-314260></A><A name=IXT-11-314261></A><A 
                  name=IXT-11-314262></A><A name=IXT-11-314263></A><A 
                  name=IXT-11-314264></A><A name=IXT-11-314265></A><A 
                  name=IXT-11-314266></A><A name=IXT-11-314267></A><A 
                  name=IXT-11-314268></A><A name=IXT-11-314269></A><A 
                  name=IXT-11-314270></A><A name=IXT-11-314271></A><A 
                  name=IXT-11-314272></A><A name=IXT-11-314273></A>
                  <DL class=docList>
                    <DT><SPAN class=docPubcolor>Graph algorithms <A 
                    name=IXT-11-314260></A></SPAN>
                    <DD>
                    <P class=docList>Algorithms that solve problems modeled by 
                    graphs (see <A class=docLink 
                    href="ch16-1-fm2xml.html#ch16-1-fm2xml">Chapter 
                    16</A>). Many graph algorithms solve problems related to 
                    connectivity and routing optimization. For example, <A 
                    class=docLink 
                    href="ch16-1-fm2xml.html#ch16-1-fm2xml">Chapter 
                    16</A> explores algorithms for computing minimum spanning 
                    trees, finding shortest paths, and solving the 
                    traveling-salesman problem.</P>
                    <DT><SPAN class=docPubcolor>Counting network hops 
                    (illustrated in this chapter) <A 
                    name=IXT-11-314261></A></SPAN>
                    <DD>
                    <P class=docList>Counting the smallest number of nodes that 
                    must be traversed from one node to reach other nodes in an 
                    internet. This information is useful in internets in which 
                    the most significant costs are directly related to the 
                    number of nodes traversed.</P>
                    <DT><SPAN class=docPubcolor>Topological sorting (illustrated 
                    in this chapter)<A name=IXT-11-314262></A><A 
                    name=IXT-11-314263></A> </SPAN>
                    <DD>
                    <P class=docList>A linear ordering of vertices in a <A 
                    name=IXT-11-314264></A><A name=IXT-11-314265></A><A 
                    name=IXT-11-314266></A>directed acyclic graph so that all 
                    edges go from left to right. One of the most common uses of 
                    topological sorting is in determining an acceptable order in 
                    which to carry out a number of tasks that depend on one 
                    another.</P>
                    <DT><I><SPAN class=docPubcolor>Graph coloring </SPAN></I>
                    <DD>
                    <P class=docList>A<A name=IXT-11-314267></A> <A 
                    name=IXT-11-314268></A>process in which we try to color the 
                    vertices of a graph so that no two vertices joined by an 
                    edge have the same color. Sometimes we are interested only 
                    in determining the minimum number of colors required to meet 
                    this criterion, which is called the graph's <SPAN 
                    class=docEmphasis>chromatic number</SPAN><A 
                    name=IXT-11-314269></A>.</P>
                    <DT><SPAN class=docPubcolor>Hamiltonian-cycle problems <A 
                    name=IXT-11-314270></A><A name=IXT-11-314271></A></SPAN>
                    <DD>
                    <P class=docList>Problems in which one works with <SPAN 
                    class=docEmphasis>hamiltonian cycles</SPAN>, paths that pass 
                    through every vertex in a graph exactly once before 
                    returning to the original vertex. The traveling-salesman 
                    problem (see <A class=docLink 
                    href="ch16-1-fm2xml.html#ch16-1-fm2xml">Chapter 
                    16</A>) is a special case of hamiltonian-cycle problem. In 
                    the traveling-salesman problem, we look for the hamiltonian 
                    cycle with the minimum cost.</P>
                    <DT><I><SPAN class=docPubcolor>Clique problems </SPAN></I>
                    <DD>
                    <P class=docList>Problems<A name=IXT-11-314272></A> in which 
                    one works with regions of a graph where every vertex is 
                    connected somehow to every other. Regions with this property 
                    are called <SPAN class=docEmphasis>cliques</SPAN>. Some 
                    clique problems focus on determining the largest clique that 
                    a graph contains. Other clique problems focus on determining 
                    whether a graph contains a clique of a certain size at 
                    all.</P>
                    <DT><SPAN class=docPubcolor>Conflict serializability <A 
                    name=IXT-11-314273></A></SPAN>
                    <DD>
                    <P class=docList>A significant aspect of database 
                    optimization. Rather than executing the instructions of 
                    transactions one transaction after another, database systems 
                    typically try to reorder a schedule of instructions to 
                    obtain a higher degree of concurrency. However, a serial 
                    schedule of instructions cannot be reordered arbitrarily; a 
                    database system must find a schedule that is <SPAN 
                    class=docEmphasis>conflict serializable</SPAN>. A conflict 
                    serializable schedule produces the same results as a serial 
                    schedule. To determine if a schedule is conflict 
                    serializable, a precedence graph is used to define 
                    relationships among transactions. If the graph does not 
                    contain a cycle, the schedule is conflict 
                    serializable.</P></DD></DL>                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch10-59-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 align=absMiddle 
                  border=0></A> &nbsp; <A accessKey=1 
                  href="ch11-2-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 align=absMiddle 
                  border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
