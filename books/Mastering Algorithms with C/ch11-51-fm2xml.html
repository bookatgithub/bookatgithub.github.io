<HTML><HEAD><TITLE>ch11-51-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 11.&nbsp; 
              Graphs</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch11-6-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=left border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch11-61-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=right border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch11-51-fm2xml></A>
                  <H3 class=docSection1Title>11.3 Implementation and Analysis of 
                  Graphs</H3>
                  <P class=docText><A name=ch11-idx-573127-1></A>An 
                  adjacency-list representation<A name=IXT-11-314354></A> of a 
                  graph primarily consists of a linked list of adjacency-list 
                  structures. Each structure in the list contains two members: a 
                  vertex and a list of vertices adjacent to the vertex. In the 
                  implementation presented here, an individual adjacency list is 
                  represented by the structure <TT><I>AdjList</I></TT> (see <A 
                  class=docLink 
                  href="#ch11-87705">Example 
                  11.1</A>).<A name=IXT-11-314355></A> As you would expect, this 
                  structure has two members that correspond to those just 
                  mentioned. Each adjacency list is implemented as a set (see <A 
                  class=docLink 
                  href="ch07-1-fm2xml.html#ch07-1-fm2xml">Chapter 
                  7</A>) for reasons discussed in the questions and answers at 
                  the end of the chapter. The structure <TT><I>Graph</I></TT> <A 
                  name=IXT-11-314356></A>is the graph data structure (see <A 
                  class=docLink 
                  href="#ch11-87705">Example 
                  11.1</A>). This structure consists of five members: 
                  <TT><I>vcount</I></TT> is the number of <A 
                  name=IXT-11-314357></A>vertices in the graph, 
                  <TT><I>ecount</I></TT> is the number of <A 
                  name=IXT-11-314358></A>edges, <TT><I>match</I></TT> and 
                  <TT><I>destroy</I></TT> are members used to encapsulate the 
                  functions passed to <SPAN class=docEmphasis>graph_init</SPAN>, 
                  and <TT><I>adjlists</I></TT> is the linked list of 
                  adjacency-list structures. <A class=docLink 
                  href="#ch11-87705">Example 
                  11.1</A> also defines an enumerated type for vertex colors, 
                  which are often used when working with graphs.</P>
                  <H5 class=docExampleTitle><A name=ch11-87705></A>Example 11.1. 
                  Header for the Graph Abstract Datatype </H5><PRE>/*****************************************************************************
*                                                                            *
*  -------------------------------- graph.h -------------------------------  *
*                                                                            *
*****************************************************************************/

#ifndef GRAPH_H
#define GRAPH_H

#include &lt;stdlib.h&gt;

#include "list.h"
#include "set.h"

/*****************************************************************************
*                                                                            *
*  Define a structure for adjacency lists.                                   *
*                                                                            *
*****************************************************************************/

typedef struct AdjList_ {

void               *vertex;
Set                adjacent;

} AdjList;

/*****************************************************************************
*                                                                            *
*  Define a structure for graphs.                                            *
*                                                                            *
*****************************************************************************/

typedef struct Graph_ {

int                vcount;
int                ecount;

int                (*match)(const void *key1, const void *key2);
void               (*destroy)(void *data);

List               adjlists;

} Graph;

/*****************************************************************************
*                                                                            *
*  Define colors for vertices in graphs.                                     *
*                                                                            *
*****************************************************************************/

typedef enum VertexColor_ {white, gray, black} VertexColor;

/*****************************************************************************
*                                                                            *
*  --------------------------- Public Interface ---------------------------  *
*                                                                            *
*****************************************************************************/

void graph_init(Graph *graph, int (*match)(const void *key1, const void
   *key2), void (*destroy)(void *data));

void graph_destroy(Graph *graph);

int graph_ins_vertex(Graph *graph, const void *data);

int graph_ins_edge(Graph *graph, const void *data1, const void *data2);

int graph_rem_vertex(Graph *graph, void **data);

int graph_rem_edge(Graph *graph, void *data1, void **data2);

int graph_adjlist(const Graph *graph, const void *data, AdjList **adjlist);

int graph_is_adjacent(const Graph *graph, const void *data1, const void
   *data2);

#define graph_adjlists(graph) ((graph)-&gt;adjlists)

#define graph_vcount(graph) ((graph)-&gt;vcount)

#define graph_ecount(graph) ((graph)-&gt;ecount)

#endif</PRE><A name=ch11-52-fm2xml></A>
                  <H4 class=docSection2Title>11.3.1 graph_init</H4>
                  <P class=docText><A name=IXT-11-314359></A><A 
                  name=IXT-11-314360></A>The <SPAN 
                  class=docEmphasis>graph_init</SPAN> operation initializes a 
                  graph so that it can be used in other operations (see <A 
                  class=docLink 
                  href="#ch11-12479">Example 
                  11.2</A>). Initializing a graph is a simple operation in which 
                  we set the <TT><I>vcount</I></TT> and <TT><I>ecount</I></TT> 
                  members of the graph to 0, encapsulate the 
                  <TT><I>match</I></TT> and <TT><I>destroy</I></TT> functions, 
                  and initialize the list of adjacency-list structures.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>graph_init</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (1) because all of the steps in 
                  initializing a graph run in a constant amount of time.</P><A 
                  name=ch11-53-fm2xml></A>
                  <H4 class=docSection2Title>11.3.2 graph_destroy</H4>
                  <P class=docText><A name=IXT-11-314361></A><A 
                  name=IXT-11-314362></A>The <SPAN 
                  class=docEmphasis>graph_destroy</SPAN> operation destroys a 
                  graph (see <A class=docLink 
                  href="#ch11-12479">Example 
                  11.2</A>). Primarily this means removing each adjacency-list 
                  structure, destroying the set of vertices it contains, and 
                  freeing the memory allocated to its <TT><I>vertex</I></TT> 
                  member by calling the function passed as 
                  <TT><I>destroy</I></TT> to <SPAN 
                  class=docEmphasis>graph_init</SPAN>, provided 
                  <TT><I>destroy</I></TT> was not set to NULL.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>graph_destroy</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>V</SPAN> + 
                  <SPAN class=docEmphasis>E </SPAN>), where <SPAN 
                  class=docEmphasis>V</SPAN> is the number of vertices in the 
                  graph and <SPAN class=docEmphasis>E</SPAN> is the number of 
                  edges. This is because we make <SPAN 
                  class=docEmphasis>V</SPAN> calls to the <SPAN 
                  class=docEmphasis>O</SPAN> (1) operation <SPAN 
                  class=docEmphasis>list_rem_next</SPAN>, and the total running 
                  time of all calls to <SPAN 
                  class=docEmphasis>set_destroy</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>E</SPAN> 
                  ).</P><A name=ch11-54-fm2xml></A>
                  <H4 class=docSection2Title>11.3.3 graph_ins_vertex</H4>
                  <P class=docText><A name=IXT-11-314363></A><A 
                  name=IXT-11-314364></A>The <SPAN 
                  class=docEmphasis>graph_ins_vertex</SPAN> operation inserts a 
                  vertex into a graph (see <A class=docLink 
                  href="#ch11-12479">Example 
                  11.2</A>). Specifically, the call inserts an 
                  <TT><I>AdjList</I></TT> structure into the list of 
                  adjacency-list structures and sets its <TT><I>vertex</I></TT> 
                  member to point to the data passed by the caller. We begin by 
                  ensuring that the vertex does not already exist in the list. 
                  After this, we insert the vertex by calling <SPAN 
                  class=docEmphasis>list_ins_next</SPAN> to insert the 
                  <TT><I>AdjList</I></TT> structure at the tail of the list. 
                  Last, we update the count of vertices in the graph by 
                  incrementing the <TT><I>vcount</I></TT> member of the graph 
                  data structure.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>graph_ins_vertex</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>V 
                  </SPAN>), where <SPAN class=docEmphasis>V</SPAN> is the number 
                  of vertices in the graph. This is because searching the list 
                  of vertices for a duplicate is an <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>V</SPAN> ) 
                  operation. The call to <SPAN 
                  class=docEmphasis>list_ins_next</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (1).</P><A name=ch11-55-fm2xml></A>
                  <H4 class=docSection2Title>11.3.4 graph_ins_edge</H4>
                  <P class=docText><A name=IXT-11-314365></A><A 
                  name=IXT-11-314366></A>The <SPAN 
                  class=docEmphasis>graph_ins_edge</SPAN> operation inserts an 
                  edge into a graph (see <A class=docLink 
                  href="#ch11-12479">Example 
                  11.2</A>). To insert an edge from the vertex specified by 
                  <TT><I>data1</I></TT> to the vertex specified by 
                  <TT><I>data2</I></TT>, we insert <TT><I>data2</I></TT> into 
                  the adjacency list of <TT><I>data1</I></TT>. We begin by 
                  ensuring that both vertices exist in the graph. After this, we 
                  insert the vertex specified by <TT><I>data2</I></TT> into the 
                  adjacency list of <TT><I>data1</I></TT> by calling <SPAN 
                  class=docEmphasis>set_insert</SPAN>. The call to <SPAN 
                  class=docEmphasis>set_insert</SPAN> returns an error if the 
                  edge already exists. Last, we update the count of edges in the 
                  graph by incrementing the <TT><I>ecount</I></TT> member of the 
                  graph data structure.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>graph_ins_edge</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>V 
                  </SPAN>), where <SPAN class=docEmphasis>V</SPAN> is the number 
                  of vertices in the graph. This is because searching the list 
                  of adjacency-list structures and calling <SPAN 
                  class=docEmphasis>set_insert</SPAN> are both <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>V</SPAN> ) 
                  operations.</P><A name=ch11-56-fm2xml></A>
                  <H4 class=docSection2Title>11.3.5 graph_rem_vertex</H4>
                  <P class=docText><A name=IXT-11-314367></A><A 
                  name=IXT-11-314368></A>The <SPAN 
                  class=docEmphasis>graph_rem_vertex</SPAN> operation removes a 
                  vertex from a graph (see <A class=docLink 
                  href="#ch11-12479">Example 
                  11.2</A>). Specifically, the call removes an 
                  <TT><I>AdjList</I></TT> structure from the list of 
                  adjacency-list structures. We begin by ensuring that the 
                  vertex does not exist in any adjacency list, that the vertex 
                  does exist in the list of adjacency-list structures, and that 
                  the adjacency list of the vertex is empty. After this, we 
                  remove the vertex by calling <TT><I>list_rem_next</I></TT> to 
                  remove the appropriate <TT><I>AdjList</I></TT> structure from 
                  the list. Last, we update the count of vertices in the graph 
                  by decreasing its <TT><I>vcount</I></TT> member of the graph 
                  data structure by 1.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>graph_rem_vertex</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>V</SPAN> 
                  +<SPAN class=docEmphasis> E </SPAN>), where <SPAN 
                  class=docEmphasis>V</SPAN> is the number of vertices in the 
                  graph and <SPAN class=docEmphasis>E</SPAN> is the number of 
                  edges. This is because searching every adjacency list is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>V</SPAN> + 
                  <SPAN class=docEmphasis>E</SPAN> ), searching the list of 
                  adjacency-list structures is <SPAN class=docEmphasis>O</SPAN> 
                  (<SPAN class=docEmphasis>V</SPAN> ), and calling <SPAN 
                  class=docEmphasis>list_rem_next</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (1).</P><A name=ch11-57-fm2xml></A>
                  <H4 class=docSection2Title>11.3.6 graph_rem_edge</H4>
                  <P class=docText><A name=IXT-11-314369></A><A 
                  name=IXT-11-314370></A>The <SPAN 
                  class=docEmphasis>graph_rem_edge</SPAN> operation removes an 
                  edge from a graph (see <A class=docLink 
                  href="#ch11-12479">Example 
                  11.2</A>). Specifically, the call removes the vertex specified 
                  by <TT><I>data2</I></TT> from the adjacency list of 
                  <TT><I>data1</I></TT>. We begin by ensuring that the first 
                  vertex exists in the graph. Once this has been verified, we 
                  remove the edge by calling <SPAN 
                  class=docEmphasis>set_remove</SPAN> to remove the vertex 
                  specified by <TT><I>data2</I></TT> from the adjacency list of 
                  <TT><I>data1</I></TT>. The call to <SPAN 
                  class=docEmphasis>set_remove</SPAN> returns an error if 
                  <TT><I>data2</I></TT> is not in the adjacency list of 
                  <TT><I>data1</I></TT>. Last, we update the count of edges in 
                  the graph by decreasing the <TT><I>ecount</I></TT> member of 
                  the graph data structure by 1.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>graph_rem_edge</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>V 
                  </SPAN>), where <SPAN class=docEmphasis>V</SPAN> is the number 
                  of vertices in the graph. This is because searching the list 
                  of adjacency-list structures and calling <SPAN 
                  class=docEmphasis>set_remove</SPAN> are both <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>V</SPAN> ) 
                  operations.</P><A name=ch11-58-fm2xml></A>
                  <H4 class=docSection2Title>11.3.7 graph_adjlist</H4>
                  <P class=docText><A name=IXT-11-314371></A><A 
                  name=IXT-11-314372></A>The <SPAN 
                  class=docEmphasis>graph_adjlist</SPAN> operation returns the 
                  <TT><I>AdjList</I></TT> structure containing the set of 
                  vertices adjacent to a specified vertex (see <A class=docLink 
                  href="#ch11-12479">Example 
                  11.2</A>). To do this, we search the list of adjacency-list 
                  structures until we find the one that contains the specified 
                  vertex.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>graph_adjlist</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>V 
                  </SPAN>), where <SPAN class=docEmphasis>V</SPAN> is the number 
                  of vertices in the graph. This is because searching the list 
                  of adjacency-list structures runs in <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>V</SPAN> ) 
                  time.</P><A name=ch11-59-fm2xml></A>
                  <H4 class=docSection2Title>11.3.8 graph_is_adjacent</H4>
                  <P class=docText><A name=IXT-11-314373></A>The <SPAN 
                  class=docEmphasis>graph_is_adjacent</SPAN> operation 
                  determines whether a specified vertex is adjacent to another 
                  (see <A class=docLink 
                  href="#ch11-12479">Example 
                  11.2</A>). To do this, we locate the adjacency-list structure 
                  of the vertex specified by <TT><I>data1</I></TT> and call 
                  <SPAN class=docEmphasis>set_is_member</SPAN> to <A 
                  name=IXT-11-314374></A>determine if <TT><I>data2</I></TT> is 
                  in its adjacency list.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>graph_adjlist</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>V 
                  </SPAN>), where <SPAN class=docEmphasis>V</SPAN> is the number 
                  of vertices in the graph. This is because searching the list 
                  of adjacency-list structures and calling <SPAN 
                  class=docEmphasis>set_is_member</SPAN> are both <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>V</SPAN> ) 
                  operations.</P><A name=ch11-60-fm2xml></A>
                  <H4 class=docSection2Title>11.3.9 graph_adjlists, 
                  graph_vcount, graph_ecount</H4>
                  <P class=docText>These macros implement some of the simpler 
                  graph operations (see <A class=docLink 
                  href="#ch11-87705">Example 
                  11.1</A>). Generally, they provide an interface for accessing 
                  and testing members of the <TT><I>Graph</I></TT> 
structure.</P>
                  <P class=docText>The runtime complexity of these operations is 
                  <SPAN class=docEmphasis>O</SPAN> (1) because accessing members 
                  of a structure is a simple task that runs in a constant amount 
                  of time.</P>
                  <H5 class=docExampleTitle><A name=ch11-12479></A>Example 11.2. 
                  Implementation of the Graph Abstract Datatype </H5><PRE>/*****************************************************************************
*                                                                            *
*  -------------------------------- graph.c -------------------------------  *
*                                                                            *
*****************************************************************************/

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "graph.h"
#include "list.h"
#include "set.h"

/*****************************************************************************
*                                                                            *
*  ------------------------------ graph_init<A name=IXT-11-314375></A> ------------------------------  *
*                                                                            *
*****************************************************************************/

void graph_init(Graph *graph, int (*match)(const void *key1, const void
   *key2), void (*destroy)(void *data)) {

/*****************************************************************************
*                                                                            *
*  Initialize the graph.                                                     *
*                                                                            *
*****************************************************************************/

graph-&gt;vcount = 0;
graph-&gt;ecount = 0;
graph-&gt;match = match;
graph-&gt;destroy = destroy;

/*****************************************************************************
*                                                                            *
*  Initialize the list of adjacency-list structures.                         *
*                                                                            *
*****************************************************************************/

list_init(&amp;graph-&gt;adjlists, NULL);

return;

}

/*****************************************************************************
*                                                                            *
*  ----------------------------- graph_destroy<A name=IXT-11-314376></A> ----------------------------  *
*                                                                            *
*****************************************************************************/

void graph_destroy(Graph *graph) {

AdjList            *adjlist;

/*****************************************************************************
*                                                                            *
*  Remove each adjacency-list structure and destroy its adjacency list.      *
*                                                                            *
*****************************************************************************/

while (list_size(&amp;graph-&gt;adjlists) &gt; 0) {

   if (list_rem_next(&amp;graph-&gt;adjlists, NULL, (void **)&amp;adjlist) == 0) {

      set_destroy(&amp;adjlist-&gt;adjacent);

      if (graph-&gt;destroy != NULL)
         graph-&gt;destroy(adjlist-&gt;vertex);

      free(adjlist);

   }

}

/*****************************************************************************
*                                                                            *
*  Destroy the list of adjacency-list structures, which is now empty.        *
*                                                                            *
*****************************************************************************/

list_destroy(&amp;graph-&gt;adjlists);

/*****************************************************************************
*                                                                            *
*  No operations are allowed now, but clear the structure as a precaution.   *
*                                                                            *
*****************************************************************************/

memset(graph, 0, sizeof(Graph));

return;

}

/*****************************************************************************
*                                                                            *
*  --------------------------- graph_ins_vertex<A name=IXT-11-314377></A> ---------------------------  *
*                                                                            *
*****************************************************************************/

int graph_ins_vertex(Graph *graph, const void *data) {

ListElmt           *element;

AdjList            *adjlist;

int                retval;

/*****************************************************************************
*                                                                            *
*  Do not allow the insertion of duplicate vertices.                         *
*                                                                            *
*****************************************************************************/

for (element = list_head(&amp;graph-&gt;adjlists); element != NULL; element =
   list_next(element)) {

   if (graph-&gt;match(data, ((AdjList *)list_data(element))-&gt;vertex))
      return 1;

}

/*****************************************************************************
*                                                                            *
*  Insert the vertex.                                                        *
*                                                                            *
*****************************************************************************/

if ((adjlist = (AdjList *)malloc(sizeof(AdjList))) == NULL)
   return -1;

adjlist-&gt;vertex = (void *)data;
set_init(&amp;adjlist-&gt;adjacent, graph-&gt;match, NULL);

if ((retval = list_ins_next(&amp;graph-&gt;adjlists, list_tail(&amp;graph-&gt;adjlists),
   adjlist)) != 0) {

   return retval;

}

/*****************************************************************************
*                                                                            *
*  Adjust the vertex count to account for the inserted vertex.               *
*                                                                            *
*****************************************************************************/

graph-&gt;vcount++;

return 0;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- graph_ins_edge<A name=IXT-11-314378></A> ----------------------------  *
*                                                                            *
*****************************************************************************/

int graph_ins_edge(Graph *graph, const void *data1, const void *data2) {

ListElmt           *element;

int                retval;

/*****************************************************************************
*                                                                            *
*  Do not allow insertion of an edge without both its vertices in the graph. *
*                                                                            *
*****************************************************************************/

for (element = list_head(&amp;graph-&gt;adjlists); element != NULL; element =
   list_next(element)) {

   if (graph-&gt;match(data2, ((AdjList *)list_data(element))-&gt;vertex))
      break;

}

if (element == NULL)
   return -1;

for (element = list_head(&amp;graph-&gt;adjlists); element != NULL; element =
   list_next(element)) {

   if (graph-&gt;match(data1, ((AdjList *)list_data(element))-&gt;vertex))
      break;

}

if (element == NULL)
   return -1;

/*****************************************************************************
*                                                                            *
*  Insert the second vertex into the adjacency list of the first vertex.     *
*                                                                            *
*****************************************************************************/

if ((retval = set_insert(&amp;((AdjList *)list_data(element))-&gt;adjacent, data2))
   != 0) {

   return retval;

}

/*****************************************************************************
*                                                                            *
*  Adjust the edge count to account for the inserted edge.                   *
*                                                                            *
*****************************************************************************/

graph-&gt;ecount++;

return 0;

}

/*****************************************************************************
*                                                                            *
*  --------------------------- graph_rem_vertex<A name=IXT-11-314379></A> ---------------------------  *
*                                                                            *
*****************************************************************************/

int graph_rem_vertex(Graph *graph, void **data) {

ListElmt           *element,
                   *temp,
                   *prev;

AdjList            *adjlist;

int                found;

/*****************************************************************************
*                                                                            *
*  Traverse each adjacency list and the vertices it contains.                *
*                                                                            *
*****************************************************************************/

prev = NULL;
found = 0;

for (element = list_head(&amp;graph-&gt;adjlists); element != NULL; element =
   list_next(element)) {

   /**************************************************************************
   *                                                                         *
   *  Do not allow removal of the vertex if it is in an adjacency list.      *
   *                                                                         *
   **************************************************************************/

   if (set_is_member(&amp;((AdjList *)list_data(element))-&gt;adjacent, *data))
      return -1;

   /**************************************************************************
   *                                                                         *
   *  Keep a pointer to the vertex to be removed.                            *
   *                                                                         *
   **************************************************************************/

   if (graph-&gt;match(*data, ((AdjList *)list_data(element))-&gt;vertex)) {
 
      temp = element;
      found = 1;

   }

   /**************************************************************************
   *                                                                         *
   *  Keep a pointer to the vertex before the vertex to be removed.          *
   *                                                                         *
   **************************************************************************/

   if (!found)
      prev = element;

}
 
/*****************************************************************************
*                                                                            *
*  Return if the vertex was not found.                                       *
*                                                                            *
*****************************************************************************/

if (!found)
   return -1;

/*****************************************************************************
*                                                                            *
*  Do not allow removal of the vertex if its adjacency list is not empty.    *
*                                                                            *
*****************************************************************************/

if (set_size(&amp;((AdjList *)list_data(temp))-&gt;adjacent) &gt; 0)
   return -1;

/*****************************************************************************
*                                                                            *
*  Remove the vertex.                                                        *
*                                                                            *
*****************************************************************************/

if (list_rem_next(&amp;graph-&gt;adjlists, prev, (void **)&amp;adjlist) != 0)
   return -1;

/*****************************************************************************
*                                                                            *
*  Free the storage allocated by the abstract datatype.                      *
*                                                                            *
*****************************************************************************/

*data = adjlist-&gt;vertex;
free(adjlist);

/*****************************************************************************
*                                                                            *
*  Adjust the vertex count to account for the removed vertex.                *
*                                                                            *
*****************************************************************************/

graph-&gt;vcount--;

return 0;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- graph_rem_edge<A name=IXT-11-314380></A> ----------------------------  *
*                                                                            *
*****************************************************************************/

int graph_rem_edge(Graph *graph, void *data1, void **data2) {

ListElmt           *element;

/*****************************************************************************
*                                                                            *
*  Locate the adjacency list for the first vertex.                           *
*                                                                            *
*****************************************************************************/

for (element = list_head(&amp;graph-&gt;adjlists); element != NULL; element =
   list_next(element)) {

   if (graph-&gt;match(data1, ((AdjList *)list_data(element))-&gt;vertex))
      break;

}

if (element == NULL)
   return -1;

/*****************************************************************************
*                                                                            *
*  Remove the second vertex from the adjacency list of the first vertex.     *
*                                                                            *
*****************************************************************************/

if (set_remove(&amp;((AdjList *)list_data(element))-&gt;adjacent, data2) != 0)
   return -1;

/*****************************************************************************
*                                                                            *
*  Adjust the edge count to account for the removed edge.                    *
*                                                                            *
*****************************************************************************/

graph-&gt;ecount--;

return 0;

}

/*****************************************************************************
*                                                                            *
*  ----------------------------- graph_adjlist<A name=IXT-11-314381></A> ----------------------------  *
*                                                                            *
*****************************************************************************/

int graph_adjlist(const Graph *graph, const void *data, AdjList **adjlist) {

ListElmt           *element,
                   *prev;

/*****************************************************************************
*                                                                            *
*  Locate the adjacency list for the vertex.                                 *
*                                                                            *
*****************************************************************************/

prev = NULL;

for (element = list_head(&amp;graph-&gt;adjlists); element != NULL; element =
   list_next(element)) {

   if (graph-&gt;match(data, ((AdjList *)list_data(element))-&gt;vertex))
      break;

   prev = element;

}

/*****************************************************************************
*                                                                            *
*  Return if the vertex was not found.                                       *
*                                                                            *
*****************************************************************************/

if (element == NULL)
   return -1;

/*****************************************************************************
*                                                                            *
*  Pass back the adjacency list for the vertex.                              *
*                                                                            *
*****************************************************************************/

*adjlist = list_data(element);

return 0;

}

/*****************************************************************************
*                                                                            *
*  --------------------------- graph_is_adjacent<A name=IXT-11-314382></A> --------------------------  *
*                                                                            *
*****************************************************************************/

int graph_is_adjacent(const Graph *graph, const void *data1, const void
   *data2) {

ListElmt           *element,
                   *prev;

/*****************************************************************************
*                                                                            *
*  Locate the adjacency list of the first vertex.                            *
*                                                                            *
*****************************************************************************/

prev = NULL;

for (element = list_head(&amp;graph-&gt;adjlists); element != NULL; element =
   list_next(element)) {

   if (graph-&gt;match(data1, ((AdjList *)list_data(element))-&gt;vertex))
      break;

   prev = element;

}

/*****************************************************************************
*                                                                            *
*  Return if the first vertex was not found.                                 *
*                                                                            *
*****************************************************************************/

if (element == NULL)
   return 0;

/*****************************************************************************
*                                                                            *
*  Return whether the second vertex is in the adjacency list of the first.   *
*                                                                            *
*****************************************************************************/

return set_is_member(&amp;((AdjList *)list_data(element))-&gt;adjacent, data2)<A name=IXTR3-87></A>;

}</PRE>
                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch11-6-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=absMiddle border=0></A> &nbsp; <A accessKey=1 
                  href="ch11-61-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=absMiddle border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
