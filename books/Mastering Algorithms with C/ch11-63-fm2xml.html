<HTML><HEAD><TITLE>ch11-63-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 11.&nbsp; 
              Graphs</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch11-62-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=left border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch11-64-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=right border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch11-63-fm2xml></A>
                  <H3 class=docSection1Title>11.6 Questions and Answers</H3>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> In the 
                  graph implementation presented in this chapter, why is a 
                  linked list used for the list of adjacency-list structures but 
                  sets are used for the adjacency lists?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Many 
                  adjacency-list representations of graphs consist of an array 
                  of adjacency lists, with each element in the array 
                  corresponding to one vertex in the graph. The implementation 
                  in this chapter deviates from this model. First, it uses a 
                  linked list in place of the array because the list can 
                  dynamically expand and contract as we insert and remove 
                  vertices. Second, it uses sets for the adjacency lists because 
                  the vertices they contain are not ordered, and the primary 
                  operations associated with adjacency lists (inserting and 
                  removing vertices, and testing for membership) are well-suited 
                  to the set abstract datatype presented earlier. Perhaps the 
                  list of adjacency-list structures could have been implemented 
                  using a set as well, but this was ruled out because the 
                  primary operation here is to locate the adjacency lists of 
                  specific vertices. A linked list is better suited to this than 
                  a set.</P>
                  <P class=docText><A name=IXT-11-314401></A><A 
                  name=IXT-11-314402></A><A name=IXT-11-314403></A><SPAN 
                  class=docEmphBold>Q:</SPAN> Suppose we model an internet using 
                  a graph (as shown earlier in this chapter) and we determine 
                  that the graph contains an articulation point. What are the 
                  implications of this?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Graphs have 
                  many important uses in network problems. If in a graph 
                  modeling an internet we determine that there is an 
                  articulation point, the articulation point represents a single 
                  point of failure.<A name=IXT-11-314404></A> Thus, if a system 
                  residing at an articulation point goes down, other systems are 
                  forced into different connected components and as a result 
                  will no longer be able to communicate with each other. 
                  Therefore, in designing large networks in which connectivity 
                  is required at all times, it is important that there be no 
                  articulation points. We can curb this problem by placing 
                  redundancies in the network.</P>
                  <P class=docText><A name=IXT-11-314405></A><SPAN 
                  class=docEmphBold>Q:</SPAN> Consider a graph that models a 
                  structure of airways, highways in the sky on which airplanes 
                  are often required to fly. The structure consists of two types 
                  of elements: navigational facilities, called <SPAN 
                  class=docEmphasis>navaids</SPAN> for short, and airways that 
                  connect navaids, which are typically within a hundred miles of 
                  each other. Airways may be bidirectional or one-way. At 
                  certain times some airways are not available for use. Suppose 
                  during one of these times we would like to determine whether 
                  we can still reach a particular destination. How can we 
                  determine this? What is the runtime complexity of solving this 
                  problem?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> If we 
                  perform breadth-first search from our starting point in the 
                  airway structure, we can reach any destination if we discover 
                  it during the search. Otherwise, the destination must reside 
                  in a component of the graph that became unreachable when an 
                  airway was made unavailable. The closed airway constitutes a 
                  <A name=IXT-11-314406></A>bridge in the graph. This problem 
                  can be solved in <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>V</SPAN> + <SPAN class=docEmphasis>E 
                  </SPAN>) time, where <SPAN class=docEmphasis>V</SPAN> is the 
                  number of navaids and <SPAN class=docEmphasis>E</SPAN> is the 
                  number of airways in the structure. This is the runtime 
                  complexity of breadth-first search.</P>
                  <P class=docText><A name=IXT-11-314407></A><A 
                  name=IXT-11-314408></A><SPAN class=docEmphBold>Q:</SPAN> 
                  Suppose we would like to use a computer to model states in a 
                  system. For example, imagine the various states of a 
                  traffic-light system at an intersection and the decisions the 
                  system has to make. How can we use a graph to model this?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Directed 
                  graphs are good for modeling state machines, such as the 
                  traffic-light system mentioned here. In a directed graph, we 
                  let vertices represent the various states, and edges represent 
                  the decisions made to get from one state to another. Edges in 
                  the graph are directed because a decision made to get from one 
                  state to the next does not imply that the decision can be 
                  reversed.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> When 
                  discussing <A name=IXT-11-314409></A><A 
                  name=IXT-11-314410></A>depth-first search, it was mentioned 
                  that sometimes it is useful to keep track of <A 
                  name=IXT-11-314411></A><A name=IXT-11-314412></A>discovery and 
                  finishing times for each vertex. The start time of a vertex is 
                  a sequence number recorded when the vertex is discovered for 
                  the first time and we color it gray. The finishing time of a 
                  vertex is a sequence number recorded when we are finished with 
                  the vertex and color it black. In the implementation of 
                  depth-first search presented in this chapter, these times were 
                  not recorded. How could we modify the implementation to record 
                  them?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Discovery 
                  and finishing times recorded during depth-first search are 
                  important to some algorithms. To record these times, we use a 
                  counter that increments itself each time we color a vertex 
                  either gray or black. As a vertex is colored gray, we record 
                  the current value of the counter as its discovery time. As a 
                  vertex is colored black, we record the current value of the 
                  counter as its finishing time. In the implementation presented 
                  in this chapter, we could add two members to the 
                  <TT><I>DfsVertex</I></TT> structure to keep track of these 
                  times for each vertex.</P>
                  <P class=docText><A name=IXT-11-314413></A><A 
                  name=IXT-11-314414></A><SPAN class=docEmphBold>Q:</SPAN> The 
                  transpose of a directed graph is a graph with the direction of 
                  its edges reversed. Formally, for a directed graph <SPAN 
                  class=docEmphasis>G = (V, E )</SPAN>, its transpose is 
                  indicated as <SPAN class=docEmphasis>G T</SPAN>. How could we 
                  form the transpose of a graph assuming an adjacency-list 
                  representation? What is the runtime complexity of this?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> To form the 
                  transpose <SPAN class=docEmphasis>G </SPAN><SUP>T</SUP> of a 
                  graph <SPAN class=docEmphasis>G</SPAN> = (<SPAN 
                  class=docEmphasis>V</SPAN>, <SPAN class=docEmphasis>E</SPAN> 
                  ), we traverse the adjacency list of each vertex <SPAN 
                  class=docEmphasis>u</SPAN> in <SPAN 
                  class=docEmphasis>V</SPAN>. As we traverse each list, we make 
                  sure that vertex <SPAN class=docEmphasis>v</SPAN> and <SPAN 
                  class=docEmphasis>u</SPAN> have both been inserted into <SPAN 
                  class=docEmphasis>G</SPAN> <SUP>T</SUP> by calling <SPAN 
                  class=docEmphasis>graph_ins_vertex</SPAN> for each vertex. 
                  Next, we call <SPAN class=docEmphasis>graph_ins_edge</SPAN> to 
                  insert an edge from <SPAN class=docEmphasis>v</SPAN> to <SPAN 
                  class=docEmphasis>u</SPAN> into <SPAN class=docEmphasis>G 
                  </SPAN><SUP>T</SUP>. Each call to <SPAN 
                  class=docEmphasis>graph_ins_vertex</SPAN> runs in <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>V</SPAN> 
                  <SPAN class=docEmphasis></SPAN>) time. This operation is 
                  called 2<SPAN class=docEmphasis>E</SPAN> times, where <SPAN 
                  class=docEmphasis>E</SPAN> is the number of edges in <SPAN 
                  class=docEmphasis>G</SPAN>. Of course, some of these calls 
                  will not actually insert the vertex if it was inserted 
                  previously. Each call to <SPAN 
                  class=docEmphasis>graph_ins_edge</SPAN> runs in <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>V</SPAN> ) 
                  time. This operation is called once for each edge in <SPAN 
                  class=docEmphasis>G</SPAN> as well. Thus, using this approach, 
                  the overall time to transpose a graph is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>V E</SPAN> 
                  ).</P>
                  <P class=docText><A name=IXT-11-314415></A><SPAN 
                  class=docEmphBold>Q:</SPAN> At the start of this chapter, it 
                  was mentioned that many data structures can be represented as 
                  graphs. How might we think of a binary tree as a graph?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> A binary 
                  tree is a directed acyclic graph with the following 
                  characteristics. Each node has up to two edges incident from 
                  it and one edge incident to it, except for the root node, 
                  which has only the two edges incident from it. Edges incident 
                  from a vertex connect it with its children. The edge incident 
                  to a vertex connects its parent to it. Thus, the adjacency 
                  list of each vertex contains its children.</P>
                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch11-62-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=absMiddle border=0></A> &nbsp; <A accessKey=1 
                  href="ch11-64-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=absMiddle border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
