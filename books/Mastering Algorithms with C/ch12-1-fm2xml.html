<HTML><HEAD><TITLE>ch12-1-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Part III:&nbsp; 
              Algorithms</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="part3-1-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=left border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch12-2-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=right border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch12-1-fm2xml></A>
                  <H2 class=docChapterTitle>Chapter 12. Sorting and 
                  Searching</H2>
                  <P class=docText><A name=ch12-idx-410352-1></A>Sorting means 
                  arranging a set of elements in a prescribed order. Normally a 
                  sort is thought of as either <SPAN 
                  class=docEmphasis>ascending</SPAN> or <SPAN 
                  class=docEmphasis>descending</SPAN>. An ascending sort of the 
                  integers {5, 2, 7, 1}, for example, produces {1, 2, 5, 7}, 
                  whereas a descending sort produces {7, 5, 2, 1}. In general, 
                  sorting serves to organize data so that it is more meaningful. 
                  Although the most visible application of sorting is sorting 
                  data to display it, often sorting is used to organize data in 
                  solving other problems, sometimes as a part of other formal 
                  algorithms.</P>
                  <P class=docText>In general, sorting algorithms are divided 
                  into two classes: <SPAN class=docEmphasis>comparison 
                  sorts</SPAN> and <SPAN class=docEmphasis>linear-time 
                  sorts</SPAN>.<A name=IXT-12-314421></A><A 
                  name=IXT-12-314422></A><A name=IXT-12-314423></A><A 
                  name=IXT-12-314424></A> Comparison sorts rely on comparing 
                  elements to place them in the correct order. Surprisingly, not 
                  all sorting algorithms rely on making comparisons. For those 
                  that do, it is not possible to sort faster than in <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>n</SPAN> 
                  lg <SPAN class=docEmphasis>n</SPAN>) time. Linear-time sorts 
                  get their name from sorting in a time proportional to the 
                  number of elements being sorted, or <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>n</SPAN>). 
                  Unfortunately, linear-time sorts rely on certain 
                  characteristics in the data, so we cannot always apply them. 
                  Some sorts use the same storage that contains the data to 
                  store output as the sort proceeds; these are called <SPAN 
                  class=docEmphasis>in-place sorts</SPAN><A 
                  name=IXT-12-314425></A>. Others require extra storage for the 
                  output data, although they may copy the results back over the 
                  original data at the end.</P>
                  <P class=docText>Searching is the ubiquitous task of locating 
                  an element in a set of data. The simplest approach to locating 
                  an element takes very little thought: we simply scan the set 
                  from one end to the other. This is called <SPAN 
                  class=docEmphasis>linear search</SPAN><A 
                  name=IXT-12-314426></A> <A name=IXT-12-314427></A>. Generally, 
                  it is used with data structures that do not support random 
                  access very well, such as linked lists (see <A class=docLink 
                  href="ch05-1-fm2xml.html#ch05-1-fm2xml">Chapter 
                  5</A>). An alternative approach is to use <SPAN 
                  class=docEmphasis>binary search</SPAN>, which is presented in 
                  this chapter. Other approaches rely on data structures 
                  developed specifically for searching, such as hash tables (see 
                  <A class=docLink 
                  href="ch08-1-fm2xml.html#ch08-1-fm2xml">Chapter 
                  8</A>) and binary search trees (see <A class=docLink 
                  href="ch09-1-fm2xml.html#ch09-1-fm2xml">Chapter 
                  9</A>). This chapter covers:</P><A name=IXT-12-314428></A><A 
                  name=IXT-12-314429></A><A name=IXT-12-314430></A><A 
                  name=IXT-12-314431></A><A name=IXT-12-314432></A><A 
                  name=IXT-12-314433></A><A name=IXT-12-314434></A><A 
                  name=IXT-12-314435></A><A name=IXT-12-314436></A><A 
                  name=IXT-12-314437></A><A name=IXT-12-314438></A><A 
                  name=IXT-12-314439></A>
                  <DL class=docList>
                    <DT><SPAN class=docPubcolor>Insertion sort <A 
                    name=IXT-12-314428></A><A name=IXT-12-314429></A></SPAN>
                    <DD>
                    <P class=docList>Although not the most efficient sorting 
                    algorithm, insertion sort has the virtue of simplicity and 
                    the ability to sort in place. Its best application is for 
                    incremental sorting on small sets of data.</P>
                    <DT><SPAN class=docPubcolor>Quicksort <A 
                    name=IXT-12-314430></A><A name=IXT-12-314431></A></SPAN>
                    <DD>
                    <P class=docList>An in-place sorting algorithm widely 
                    regarded as the best for sorting in the general case. Its 
                    best application is for medium to large sets of data.</P>
                    <DT><SPAN class=docPubcolor>Merge sort <A 
                    name=IXT-12-314432></A><A name=IXT-12-314433></A></SPAN>
                    <DD>
                    <P class=docList>An algorithm with essentially the same 
                    performance as quicksort, but with twice its storage 
                    requirements. Ironically, its best application is for very 
                    large sets of data because it inherently facilitates working 
                    with divisions of the original unsorted set.</P>
                    <DT><SPAN class=docPubcolor>Counting sort <A 
                    name=IXT-12-314434></A><A name=IXT-12-314435></A></SPAN>
                    <DD>
                    <P class=docList>A stable, linear-time sorting algorithm 
                    that works with integers for which we know the largest 
                    value. Its primary use is in implementing radix sort.</P>
                    <DT><SPAN class=docPubcolor>Radix sort <A 
                    name=IXT-12-314436></A><A name=IXT-12-314437></A></SPAN>
                    <DD>
                    <P class=docList>A linear-time sorting algorithm that sorts 
                    elements digit by digit. Radix sort is well suited to 
                    elements of a fixed size that can be conveniently broken 
                    into pieces, expressible as integers.</P>
                    <DT><SPAN class=docPubcolor>Binary search <A 
                    name=IXT-12-314438></A><A name=IXT-12-314439></A></SPAN>
                    <DD>
                    <P class=docList>An effective way to search sorted data in 
                    which we do not expect frequent insertions or deletions. 
                    Since resorting a set of data is expensive relative to 
                    searching it, binary search is best when the data does not 
                    change.</P></DD></DL>
                  <P class=docText>Some applications of sorting and searching 
                  algorithms are<A name=IXT-12-314440></A>:</P><A 
                  name=IXT-12-314441></A><A name=IXT-12-314442></A><A 
                  name=IXT-12-314443></A><A name=IXT-12-314444></A><A 
                  name=IXT-12-314445></A>
                  <DL class=docList>
                    <DT><SPAN class=docPubcolor>Order statistics <A 
                    name=IXT-12-314441></A></SPAN>
                    <DD>
                    <P class=docList>Finding the <SPAN 
                    class=docEmphasis>i</SPAN> th smallest element in a set. One 
                    simplistic approach is to select the <SPAN 
                    class=docEmphasis>i</SPAN> th element out of the set once it 
                    has been sorted.</P>
                    <DT><I><SPAN class=docPubcolor>Binary search </SPAN></I>
                    <DD>
                    <P class=docList>An efficient search method that relies on 
                    sorted data. Binary search works fundamentally by dividing a 
                    sorted set of data repeatedly and inspecting the element in 
                    the middle of each division.</P>
                    <DT><SPAN class=docPubcolor>Directory listings <A 
                    name=IXT-12-314442></A>(illustrated in this chapter) </SPAN>
                    <DD>
                    <P class=docList>Listings of files in a file system that 
                    have been organized into groups. Generally, an operating 
                    system will sort a directory listing in some manner before 
                    displaying it.</P>
                    <DT><SPAN class=docPubcolor>Database systems <A 
                    name=IXT-12-314443></A></SPAN>
                    <DD>
                    <P class=docList>Typically, large systems containing vast 
                    amounts of data that must be stored and retrieved quickly. 
                    The amount of data generally stored in databases makes an 
                    efficient and flexible approach to searching the data 
                    essential.</P>
                    <DT><SPAN class=docPubcolor>Spell checkers <A 
                    name=IXT-12-314444></A>(illustrated in this chapter)</SPAN> 
                    <DD>
                    <P class=docList>Programs that check the spelling of words 
                    in text. Validation is performed against words in a 
                    dictionary. Since spell checkers frequently deal with long 
                    strings of text containing many thousands of words, they 
                    must be able to search the set of acceptable words 
                    efficiently.</P>
                    <DT><SPAN class=docPubcolor>Spreadsheets <A 
                    name=IXT-12-314445></A></SPAN>
                    <DD>
                    <P class=docList>An important part of most businesses for 
                    managing inventory and financial data. Spreadsheets 
                    typically contain diverse data that is more meaningful when 
                    sorted.</P></DD></DL>                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="part3-1-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=absMiddle border=0></A> &nbsp; <A accessKey=1 
                  href="ch12-2-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=absMiddle border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
