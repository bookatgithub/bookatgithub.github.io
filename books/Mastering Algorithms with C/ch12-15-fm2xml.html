<HTML><HEAD><TITLE>ch12-15-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 12.&nbsp; Sorting and 
                  Searching</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch12-10-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=left border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch12-16-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=right border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch12-15-fm2xml></A>
                  <H3 class=docSection1Title>12.6 Implementation and Analysis of 
                  Quicksort</H3>
                  <P class=docText><A name=ch12-idx-410702-1></A>Quicksort works 
                  fundamentally by recursively <A 
                  name=IXT-12-314455></A>partitioning an unsorted set of 
                  elements until all partitions contain a single element. In the 
                  implementation presented here, <TT><I>data</I></TT> initially 
                  contains the unsorted set of <TT><I>size</I></TT> elements 
                  stored in a single block of contiguous storage. Quicksort 
                  sorts in place, so all partitioning is performed in 
                  <TT><I>data</I></TT> as well. When <SPAN 
                  class=docEmphasis>qksort</SPAN> returns, <TT><I>data</I></TT> 
                  is completely sorted.</P>
                  <P class=docText>As we have seen, an important part of 
                  quicksort is how we partition the data. This task is performed 
                  in the function <SPAN class=docEmphasis>partition</SPAN> (see 
                  <A class=docLink 
                  href="#ch12-24543">Example 
                  12.2</A>)<A name=IXT-12-314456></A> <A 
                  name=IXT-12-314457></A>. This function partitions the elements 
                  between positions <TT><I>i</I></TT> and <TT><I>k</I></TT> in 
                  <TT><I>data</I></TT>, where <TT><I>i</I></TT> is less than 
                  <TT><I>k</I></TT>.</P>
                  <P class=docText>We begin by selecting a partition value using 
                  the median-of-three method mentioned earlier. Once the 
                  partition value has been selected, we move from 
                  <TT><I>k</I></TT> to the left in <TT><I>data</I></TT> until we 
                  find an element that is less than or equal to it. This element 
                  belongs in the left partition. Next, we move from 
                  <TT><I>i</I></TT> to the right until we find an element that 
                  is greater than or equal to the partition value. This element 
                  belongs in the right partition. Once two elements are found in 
                  the wrong partition, they are swapped. We continue in this way 
                  until <TT><I>i</I></TT> and <TT><I>k</I></TT> cross. (You may 
                  want to consider how we know that if any one element is in the 
                  wrong partition, there is always one that can be swapped with 
                  it.) Once <TT><I>i</I></TT> and <TT><I>k</I></TT> cross, all 
                  elements to the left of the partition value are less than or 
                  equal to it, and all elements to the right are greater (see <A 
                  class=docLink 
                  href="#ch12-48163">Figure 
                  12.2</A>).</P>
                  <CENTER>
                  <H5 class=docFigureTitle><A name=ch12-48163></A>Figure 12.2. 
                  Partitioning around 28</H5><IMG height=246 
                  alt=figs/alc.1202.gif src="image/alc.1202.gif" width=502 
                  border=0></CENTER>
                  <P class=docText>Now we look at how the recursion proceeds in 
                  <SPAN class=docEmphasis>qksort</SPAN> (see <A class=docLink 
                  href="#ch12-24543">Example 
                  12.2</A>). On the initial call to <SPAN 
                  class=docEmphasis>qksort</SPAN>, <TT><I>i</I></TT> is set to 
                  and <TT><I>k</I></TT> is set to <TT><I>size</I></TT> - 1. We 
                  begin by calling <SPAN class=docEmphasis>partition</SPAN> to 
                  partition <TT><I>data</I></TT> between positions 
                  <TT><I>i</I></TT> and <TT><I>k</I></TT>. When <SPAN 
                  class=docEmphasis>partition</SPAN> returns, <TT><I>j</I></TT> 
                  is assigned the position of the element that defines where the 
                  elements between <TT><I>i</I></TT> and <TT><I>k</I></TT> are 
                  partitioned. Next, we call <SPAN 
                  class=docEmphasis>qksort</SPAN> recursively for the left 
                  partition, which is from position <TT><I>i</I></TT> to 
                  <TT><I>j</I></TT>. Sorting left partitions continues 
                  recursively until an activation of <SPAN 
                  class=docEmphasis>qksort</SPAN> is passed a partition 
                  containing a single element. In this activation, 
                  <TT><I>i</I></TT> will not be less than <TT><I>k</I></TT>, so 
                  the call terminates. In the previous activation of <SPAN 
                  class=docEmphasis>qksort</SPAN>, this causes an iteration to 
                  the right partition, from position <TT><I>j</I></TT> + 1 to 
                  <TT><I>k</I></TT>. Overall, we continue in this way until the 
                  first activation of <SPAN class=docEmphasis>qksort</SPAN> 
                  terminates, at which point the data is completely sorted (see 
                  <A class=docLink 
                  href="#ch12-40312">Figure 
                  12.3</A>).</P>
                  <P class=docText>The analysis of quicksort centers around its 
                  average-case performance, which is widely accepted as its 
                  metric. Even though the worst case of quicksort is no better 
                  than that of insertion sort, <SPAN class=docEmphasis>O</SPAN> 
                  (<SPAN class=docEmphasis>n</SPAN><SUP>2</SUP>), quicksort 
                  reliably performs much closer to its average-case running 
                  time, <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN> lg <SPAN 
                  class=docEmphasis>n</SPAN>), where <SPAN 
                  class=docEmphasis>n</SPAN> is the number of elements being 
                  sorted.</P>
                  <CENTER>
                  <H5 class=docFigureTitle><A name=ch12-40312></A>Figure 12.3. 
                  Sorting with quicksort assuming optimal partitioning</H5><IMG 
                  height=259 alt=figs/alc.1203.gif src="image/alc.1203.gif" 
                  width=502 border=0></CENTER>
                  <P class=docText>Determining the runtime complexity for the 
                  average case of quicksort depends on the assumption that there 
                  will be an even distribution of balanced and unbalanced 
                  partitions. This assumption is reasonable if the 
                  median-of-three method for partitioning is used. In this case, 
                  as we repeatedly partition the array, it is helpful to picture 
                  the tree shown in <A class=docLink 
                  href="#ch12-40312">Figure 
                  12.3</A>, which has a height of (lg <SPAN 
                  class=docEmphasis>n</SPAN>) + 1. Since for the top lg <SPAN 
                  class=docEmphasis>n</SPAN> levels of the tree, we must 
                  traverse all <SPAN class=docEmphasis>n</SPAN> elements in 
                  order to form the partitions of the next level, quicksort runs 
                  in time <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN> lg <SPAN 
                  class=docEmphasis>n</SPAN>). Quicksort sorts in place, so its 
                  space requirement is only that occupied by the data to be 
                  sorted.</P>
                  <H5 class=docExampleTitle><A name=ch12-24543></A>Example 12.2. 
                  Implementation of Quicksort </H5><PRE>/*****************************************************************************
*                                                                            *
*  ------------------------------- qksort.c -------------------------------  *
*                                                                            *
*****************************************************************************/

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "sort.h"

/*****************************************************************************
*                                                                            *
*  ------------------------------ <A name=IXT-12-314458></A>compare_int -----------------------------  *
*                                                                            *
*****************************************************************************/

static int compare_int(const void *int1, const void *int2) {

/*****************************************************************************
*                                                                            *
*  Compare two integers (used during median-of-three partitioning).          *
*                                                                            *
*****************************************************************************/

if (*(const int *)int1 &gt; *(const int *)int2)
   return 1;
else if (*(const int *)int1 &lt; *(const int *)int2)
   return -1;
else
   return 0;

}

/*****************************************************************************
*                                                                            *
*  ------------------------------- partition ------------------------------  *
*                                                                            *
*****************************************************************************/

static int partition(void *data, int esize, int i, int k, int (*compare)
   (const void *key1, const void *key2)) {

char               *a = data;

void               *pval,
                   *temp;

int                r[3];

/*****************************************************************************
*                                                                            *
*  Allocate storage for the partition value and swapping.                    *
*                                                                            *
*****************************************************************************/

if ((pval = malloc(esize)) == NULL)
   return -1;

if ((temp = malloc(esize)) == NULL) {

   free(pval);
   return -1;

}

/*****************************************************************************
*                                                                            *
*  Use the median-of-three method to find the partition value.               *
*                                                                            *
*****************************************************************************/

r[0] = (rand() % (k - i + 1)) + i;
r[1] = (rand() % (k - i + 1)) + i;
r[2] = (rand() % (k - i + 1)) + i;
issort(r, 3, sizeof(int), compare_int);
memcpy(pval, &amp;a[r[1] * esize], esize);

/*****************************************************************************
*                                                                            *
*  Create two partitions around the partition value.                         *
*                                                                            *
*****************************************************************************/

i--;
k++;

while (1) {

   /**************************************************************************
   *                                                                         *
   *  Move left until an element is found in the wrong partition.            *
   *                                                                         *
   **************************************************************************/

   do {

      k--;

   } while (compare(&amp;a[k * esize], pval) &gt; 0);

   /**************************************************************************
   *                                                                         *
   *  Move right until an element is found in the wrong partition.           *
   *                                                                         *
   **************************************************************************/

   do {

      i++;

   } while (compare(&amp;a[i * esize], pval) &lt; 0);

   if (i &gt;= k) {

      /***********************************************************************
      *                                                                      *
      *  Stop partitioning when the left and right counters cross.           *
      *                                                                      *
      ***********************************************************************/

      break;

      }

   else {

      /***********************************************************************
      *                                                                      *
      *  Swap the elements now under the left and right counters.            *
      *                                                                      *
      ***********************************************************************/

      memcpy(temp, &amp;a[i * esize], esize);
      memcpy(&amp;a[i * esize], &amp;a[k * esize], esize);
      memcpy(&amp;a[k * esize], temp, esize);

   }

}

/*****************************************************************************
*                                                                            *
*  Free the storage allocated for partitioning.                              *
*                                                                            *
*****************************************************************************/

free(pval);
free(temp);

/*****************************************************************************
*                                                                            *
*  Return the position dividing the two partitions.                          *
*                                                                            *
*****************************************************************************/

return k;

}

/*****************************************************************************
*                                                                            *
*  -------------------------------- qksort --------------------------------  *
*                                                                            *
*****************************************************************************/

int qksort(void *data, int size, int esize, int i, int k, int (*compare)
   (const void *key1, const void *key2)) {

int                j;

/*****************************************************************************
*                                                                            *
*  Stop the recursion when it is not possible to partition further.          *
*                                                                            *
*****************************************************************************/

while (i &lt; k) {

   /**************************************************************************
   *                                                                         *
   *  Determine where to partition the elements.                             *
   *                                                                         *
   **************************************************************************/

   if ((j = partition(data, esize, i, k, compare)) &lt; 0)
      return -1;

   /**************************************************************************
   *                                                                         *
   *  Recursively sort the left partition.                                   *
   *                                                                         *
   **************************************************************************/

   if (qksort(data, size, esize, i, j, compare) &lt; 0)
      return -1;

   /**************************************************************************
   *                                                                         *
   *  Iterate and sort the right partition.                                  *
   *                                                                         *
   **************************************************************************/

   i = j + 1<A name=IXTR3-105></A>;

}

return<A name=IXTR3-106></A> 0;

}</PRE>                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch12-10-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=absMiddle border=0></A> &nbsp; <A accessKey=1 
                  href="ch12-16-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=absMiddle border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
