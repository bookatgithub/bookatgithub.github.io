<HTML><HEAD><TITLE>ch12-23-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 12.&nbsp; Sorting and 
                  Searching</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch12-18-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=left border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch12-24-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=right border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch12-23-fm2xml></A>
                  <H3 class=docSection1Title>12.10 Implementation and Analysis 
                  of Merge Sort</H3>
                  <P class=docText><A name=ch12-idx-411531-1></A>Merge sort 
                  works fundamentally by recursively<A name=IXT-12-314466></A> 
                  dividing an unsorted set of elements into single-element 
                  divisions and merging the divisions repeatedly until a single 
                  set is reproduced. In the implementation presented here, 
                  <TT><I>data</I></TT> initially contains the unsorted set of 
                  <TT><I>size</I></TT> elements stored in a single block of 
                  contiguous storage. Since merging is not performed in place, 
                  <SPAN class=docEmphasis>mgsort </SPAN>allocates additional 
                  storage for the merges. Before <SPAN 
                  class=docEmphasis>mgsort</SPAN> returns, the final merged set 
                  is copied back into <TT><I>data</I></TT>.</P>
                  <P class=docText>As we have seen, an important part of merge 
                  sort is the process of merging two sorted sets into a single 
                  sorted one. This task is performed by the function <SPAN 
                  class=docEmphasis>merge</SPAN> (see <A class=docLink 
                  href="#ch12-66530">Example 
                  12.5</A>), which merges the sets defined from position 
                  <TT><I>i</I></TT> to <TT><I>j</I></TT> and from 
                  <TT><I>j</I></TT> + 1 to <TT><I>k</I></TT> in 
                  <TT><I>data</I></TT> into a single sorted one from 
                  <TT><I>i</I></TT> to <TT><I>k</I></TT>.</P>
                  <P class=docText>Initially, <TT><I>ipos</I></TT> and 
                  <TT><I>jpos</I></TT> point to the beginning of each sorted 
                  set. Merging continues as long as there are still elements in 
                  at least one of the sets. While this is true, we proceed as 
                  follows. If one set has no elements remaining to be merged, we 
                  place all elements remaining in the other set into the merged 
                  set. Otherwise, we look at which set contains the next element 
                  that should be placed in the merged set to keep it properly 
                  ordered, place that element in the merged set, and increment 
                  <TT><I>ipos</I></TT> or <TT><I>jpos</I></TT> to the next 
                  element depending on from which set the element came (see <A 
                  class=docLink 
                  href="#ch12-18857">Figure 
                  12.4</A>).</P>
                  <CENTER>
                  <H5 class=docFigureTitle><A name=ch12-18857></A>Figure 12.4. 
                  Merging two sorted sets</H5><IMG height=371 
                  alt=figs/alc.1204.gif src="image/alc.1204.gif" width=502 
                  border=0></CENTER>
                  <P class=docText>Now we look at how the recursion proceeds<A 
                  name=IXT-12-314467></A> in <SPAN 
                  class=docEmphasis>mgsort</SPAN> (see <A class=docLink 
                  href="#ch12-66530">Example 
                  12.5</A>). On the initial call to <SPAN 
                  class=docEmphasis>mgsort</SPAN>, <TT><I>i</I></TT> is set to 
                  and <TT><I>k</I></TT> is set to <TT><I>size</I></TT> - 1. We 
                  begin by dividing <TT><I>data</I></TT> so that 
                  <TT><I>j</I></TT> is set to the position of the middle 
                  element. Next, we call <SPAN class=docEmphasis>mgsort</SPAN> 
                  for the left division, which is from position 
                  <TT><I>i</I></TT> to <TT><I>j</I></TT>. We continue dividing 
                  left divisions recursively until an activation of <SPAN 
                  class=docEmphasis>mgsort</SPAN> is passed a division 
                  containing a single element. In this activation, 
                  <TT><I>i</I></TT> will not be less than <TT><I>k</I></TT>, so 
                  the call terminates. In the previous activation of <SPAN 
                  class=docEmphasis>mgsort</SPAN>, this causes <SPAN 
                  class=docEmphasis>mgsort</SPAN> to be invoked on the right 
                  division of the data, from position <TT><I>j</I></TT> + 1 to 
                  <TT><I>k</I></TT>. Once this call returns, we merge the two 
                  sets. Overall, we continue in this way until the last 
                  activation of <SPAN class=docEmphasis>mgsort</SPAN> performs 
                  its merge, at which point the data is completely sorted (see 
                  <A class=docLink 
                  href="#ch12-47236">Figure 
                  12.5</A>).</P>
                  <CENTER>
                  <H5 class=docFigureTitle><A name=ch12-47236></A>Figure 12.5. 
                  Sorting with merge sort</H5><IMG height=427 
                  alt=figs/alc.1205.gif src="image/alc.1205.gif" width=502 
                  border=0></CENTER>
                  <P class=docText>An analysis of merge sort is simplified when 
                  we realize that the algorithm is very predictable. If we 
                  divide a set of data repeatedly in half as shown in <A 
                  class=docLink 
                  href="#ch12-47236">Figure 
                  12.5</A>, lg <SPAN class=docEmphasis>n</SPAN> levels of 
                  divisions are required before all sets contain one element, 
                  where <SPAN class=docEmphasis>n</SPAN> is the number of 
                  elements being sorted. For two sorted sets of <SPAN 
                  class=docEmphasis>p</SPAN> and <SPAN 
                  class=docEmphasis>q</SPAN> elements, merging runs in <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>p</SPAN> + 
                  <SPAN class=docEmphasis>q</SPAN>) time because a single pass 
                  must be made through each set to produce a merged one. Since 
                  for each of the lg <SPAN class=docEmphasis>n</SPAN> levels of 
                  divisions we end up traversing all <SPAN 
                  class=docEmphasis>n</SPAN> elements to merge the sets at that 
                  level, merge sort runs in time <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>n</SPAN> 
                  lg <SPAN class=docEmphasis>n</SPAN>). Because we cannot merge 
                  elements in place, merge sort requires twice the space 
                  occupied by the data to be sorted.</P>
                  <H5 class=docExampleTitle><A name=ch12-66530></A>Example 12.5. 
                  Implementation of Merge Sort </H5><PRE>/*****************************************************************************
*                                                                            *
*  ------------------------------- mgsort.c -------------------------------  *
*                                                                            *
*****************************************************************************/

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "sort.h"

/*****************************************************************************
*                                                                            *
*  --------------------------------- merge --------------------------------  *
*                                                                            *
*****************************************************************************/

static int merge(void *data, int esize, int i, int j, int k, int (*compare)
   (const void *key1, const void *key2)) {

char               *a = data,
                   *m;

int                ipos,
                   jpos,
                   mpos;

/*****************************************************************************
*                                                                            *
*  Initialize the counters used in merging.                                  *
*                                                                            *
*****************************************************************************/

ipos = i;
jpos = j + 1;
mpos = 0;

/*****************************************************************************
*                                                                            *
*  Allocate storage for the merged elements.                                 *
*                                                                            *
*****************************************************************************/

if ((m = (char *)malloc(esize * ((k - i) + 1))) == NULL)
   return -1;

/*****************************************************************************
*                                                                            *
*  Continue while either division has elements to merge.                     *
*                                                                            *
*****************************************************************************/

while (ipos &lt;= j || jpos &lt;= k) {

   if (ipos &gt; j) {

      /***********************************************************************
      *                                                                      *
      *  The left division has no more elements to merge.                    *
      *                                                                      *
      ***********************************************************************/

      while (jpos &lt;= k) {

         memcpy(&amp;m[mpos * esize], &amp;a[jpos * esize], esize);
         jpos++;
         mpos++;

      }

      continue;

      }

   else if (jpos &gt; k) {

      /***********************************************************************
      *                                                                      *
      *  The right division has no more elements to merge.                   *
      *                                                                      *
      ***********************************************************************/

      while (ipos &lt;= j) {

         memcpy(&amp;m[mpos * esize], &amp;a[ipos * esize], esize);
         ipos++;
         mpos++;

      }

      continue;

   }

   /**************************************************************************
   *                                                                         *
   *  Append the next ordered element to the merged elements.                *
   *                                                                         *
   **************************************************************************/

   if (compare(&amp;a[ipos * esize], &amp;a[jpos * esize]) &lt; 0) {

      memcpy(&amp;m[mpos * esize], &amp;a[ipos * esize], esize);
      ipos++;
      mpos++;

      }

   else {

      memcpy(&amp;m[mpos * esize], &amp;a[jpos * esize], esize);
      jpos++;
      mpos++;

   }

}

/*****************************************************************************
*                                                                            *
*  Prepare to pass back the merged data.                                     *
*                                                                            *
*****************************************************************************/

memcpy(&amp;a[i * esize], m, esize * ((k - i) + 1));

/*****************************************************************************
*                                                                            *
*  Free the storage allocated for merging.                                   *
*                                                                            *
*****************************************************************************/

free(m);

return 0;

}

/*****************************************************************************
*                                                                            *
*  -------------------------------- mgsort --------------------------------  *
*                                                                            *
*****************************************************************************/

int mgsort(void *data, int size, int esize, int i, int k, int (*compare)
   (const void *key1, const void *key2)) {

int                j;

/*****************************************************************************
*                                                                            *
*  Stop the recursion when no more divisions can be made.                    *
*                                                                            *
*****************************************************************************/

if (i &lt; k) {

   /**************************************************************************
   *                                                                         *
   *  Determine where to divide the elements.                                *
   *                                                                         *
   **************************************************************************/

   j = (int)(((i + k - 1)) / 2);

   /**************************************************************************
   *                                                                         *
   *  Recursively sort the two divisions.                                    *
   *                                                                         *
   **************************************************************************/

   if (mgsort(data, size, esize, i, j, compare) &lt; 0)
      return -1;

   if (mgsort(data, size, esize, j + 1, k, compare) &lt; 0)
      return -1;

   /**************************************************************************
   *                                                                         *
   *  Merge the two sorted divisions into a single sorted set.               *
   *                                                                         *
   **************************************************************************/

   if (merge(data, esize, i, j, k, compare) &lt; 0)
      return -1;

}

return<A name=IXTR3-110></A>
<A name=IXTR3-111></A> 0;

}<A name=IXTR3-112></A></PRE>
                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch12-18-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=absMiddle border=0></A> &nbsp; <A accessKey=1 
                  href="ch12-24-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=absMiddle border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
