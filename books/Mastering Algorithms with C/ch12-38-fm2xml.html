<HTML><HEAD><TITLE>ch12-38-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 12.&nbsp; Sorting and 
                  Searching</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch12-37-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=left border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch12-39-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=right border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch12-38-fm2xml></A>
                  <H3 class=docSection1Title>12.17 Description of Binary 
                  Search</H3>
                  <P class=docText>Binary <A name=IXT-12-314486></A>search<A 
                  name=ch12-idx-412573-1></A> <A name=ch12-idx-412573-2></A>is a 
                  technique for searching that works similarly to how we might 
                  systematically guess numbers in a guessing game. For example, 
                  suppose someone tells us to guess a number between and 99. The 
                  consistently best approach is to begin with 49, the number in 
                  the middle of and 99. If 49 is too high, we try 24, the number 
                  in the middle of the lower half of to 99 (0 to 48). Otherwise, 
                  if 49 is too low, we try 74, the number in the middle of the 
                  upper half of to 99 (50 to 99). We repeat this process for 
                  each narrowed range until we guess right.</P>
                  <P class=docText>Binary search begins with a set of data that 
                  is sorted. To start the search, we inspect the middle element 
                  of the sorted set. If the element is greater than the one we 
                  are looking for, we let the lower half of the set be the new 
                  set to search. Otherwise, if the element is less, we let the 
                  upper half be the new set. We repeat this process on each 
                  smaller set until we either locate the element we are looking 
                  for or cannot divide the set any further.</P>
                  <P class=docText>Binary search works with any type of data 
                  provided we can establish an ordering among the elements. It 
                  is a simple algorithm, but as you might suspect, its reliance 
                  on sorted data makes it inefficient for sets in which there 
                  are frequent insertions and deletions. This is because for 
                  each insertion or deletion, we must ensure that the set stays 
                  sorted for the search to work properly. Keeping a set sorted 
                  is expensive relative to searching it. Also, elements must be 
                  in contiguous storage. Thus, binary search is best utilized 
                  when the set to be searched is relatively static.</P>                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch12-37-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=absMiddle border=0></A> &nbsp; <A accessKey=1 
                  href="ch12-39-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=absMiddle border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
