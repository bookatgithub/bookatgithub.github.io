<HTML><HEAD><TITLE>ch12-46-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 12.&nbsp; Sorting and 
                  Searching</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch12-45-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=left border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch12-47-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=right border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch12-46-fm2xml></A>
                  <H3 class=docSection1Title>12.21 Questions and Answers</H3>
                  <P class=docText><A name=IXT-12-314492></A><SPAN 
                  class=docEmphBold>Q:</SPAN> Suppose we need to sort all of the 
                  customer records for a worldwide investment firm by name. The 
                  data is so large it cannot be fit into memory all at once. 
                  Which sorting algorithm should we use?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Merge sort. 
                  Aside from running efficiently in <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>n</SPAN> 
                  lg <SPAN class=docEmphasis>n</SPAN>) time, the predictable way 
                  that merge sort divides and merges the data lets us easily 
                  manage the data ourselves to efficiently bring it in and out 
                  of secondary storage.</P>
                  <P class=docText><A name=IXT-12-314493></A><A 
                  name=IXT-12-314494></A><SPAN class=docEmphBold>Q:</SPAN> 
                  Suppose we are maintaining a list of sorted elements in a user 
                  interface. The list is relatively small and the elements are 
                  being entered by a user one at a time. Which sorting algorithm 
                  should we use?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Insertion 
                  sort. The runtime complexity of insertion sort when inserting 
                  a single element into a list that is already sorted is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN>).</P>
                  <P class=docText><A name=IXT-12-314495></A><A 
                  name=IXT-12-314496></A><SPAN class=docEmphBold>Q:</SPAN> 
                  Suppose we need to sort 10 million 80-character strings 
                  representing DNA information from a biological study. Which 
                  sorting algorithm should we use?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Radix sort. 
                  However, precisely how radix sort performs in relation to 
                  other sorting algorithms depends on the radix value we choose 
                  and our space constraints. An important consideration in 
                  selecting radix sort is that the elements in the data are a 
                  fixed size and can be broken into integer pieces.</P>
                  <P class=docText><A name=IXT-12-314497></A><SPAN 
                  class=docEmphBold>Q:</SPAN> Suppose we need to sort 10,000 C 
                  structures containing information about the flight schedule 
                  for an airline. Which sorting algorithm should we use?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Quicksort. 
                  It is the best general-case sorting algorithm and is excellent 
                  for medium to large sets of data.</P>
                  <P class=docText><A name=IXT-12-314498></A><SPAN 
                  class=docEmphBold>Q:</SPAN> Recall that the interfaces to 
                  <SPAN class=docEmphasis>qksort</SPAN> and <SPAN 
                  class=docEmphasis>mgsort</SPAN><A name=IXT-12-314499></A> 
                  require that <TT><I>i</I></TT> and <TT><I>k</I></TT> be passed 
                  by the caller. Why is this, and how could we avoid it in 
                  practice?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> The 
                  arguments <TT><I>i</I></TT> and <TT><I>k</I></TT> are 
                  necessary to define smaller and smaller subsets of the data 
                  while recursing. An alternative to the caller providing these 
                  is to place each function in a <SPAN 
                  class=docEmphasis>wrapper</SPAN><A name=IXT-12-314500></A>. 
                  Wrappers generally provide cleaner public interfaces to 
                  functions that are otherwise cumbersome to call directly. 
                  Wrapping <SPAN class=docEmphasis>qksort</SPAN>, for example, 
                  gives us the opportunity to alleviate making the caller pass 
                  <TT><I>i</I></TT> and <TT><I>k</I></TT>, since we know that 
                  initially these always should be set to and 
                  <TT><I>size</I></TT> - 1. Wrapping <SPAN 
                  class=docEmphasis>qksort</SPAN> also gives us the opportunity 
                  to encapsulate a call to <SPAN class=docEmphasis>srand</SPAN>, 
                  which seeds the random number generator and prevents certain 
                  inputs from consistently eliciting bad behavior. This is 
                  something like what the standard library function <SPAN 
                  class=docEmphasis>qsort</SPAN> actually does. A wrapper might 
                  be implemented for <SPAN class=docEmphasis>qksort</SPAN> in 
                  Unix as shown below:</P><PRE>#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

#include "sort.h"

int <A name=IXT-12-314501></A>qsrt(void *data, int size, int esize, int (*compare)(const void *key1,
   const void *key2)) {

srand(getpid());

return qksort(data, size, esize, 0, size - 1, compare);

}</PRE>
                  <P class=docText><A name=IXT-12-314502></A><SPAN 
                  class=docEmphBold>Q:</SPAN> In <SPAN 
                  class=docEmphasis>rxsort</SPAN>, recall that counting sort is 
                  implemented explicitly rather than by calling <SPAN 
                  class=docEmphasis>ctsort</SPAN>. Why might this have been 
                  done?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Because 
                  radix sort works by considering only a single digit of the 
                  elements at a time, our counting sort implementation would 
                  have had to accept additional parameters to tell it which 
                  digit to consider as well as how to obtain each digit value. 
                  Recall that modular arithmetic was used in the implementation 
                  presented in this chapter, but other techniques might be more 
                  appropriate for some data. For example, for long strings we 
                  might choose to offset two bytes at a time into the string to 
                  form digits. Accounting for these application-specific 
                  considerations in counting sort would have complicated it 
                  substantially. Therefore, a slightly modified form of counting 
                  sort was included in the radix sort implementation.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Suppose we 
                  have 2<SUP>20</SUP> 128-bit elements that we would like to 
                  sort. What would be the efficiency of sorting these using 
                  quicksort? What would be the efficiency of sorting these as 
                  radix-2<SUP>16</SUP> numbers using radix sort? Which approach 
                  would be better? Suppose we have 2<SUP>10</SUP> 128-bit 
                  elements rather than 2<SUP>20</SUP> elements. How do quicksort 
                  and radix sort compare in this case?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Sorting 
                  with quicksort requires <SPAN class=docEmphasis>O</SPAN> 
                  (<SPAN class=docEmphasis>n</SPAN> lg <SPAN 
                  class=docEmphasis>n</SPAN>) = (2<SUP>20</SUP>)(20) = 
                  (2.10)(10<SUP>7</SUP>) times some constant amount of time. 
                  Considering the elements as radix-2<SUP>16</SUP> numbers, the 
                  number of digit positions, <SPAN class=docEmphasis>p</SPAN>, 
                  is 8, and the number of possible digit values, <SPAN 
                  class=docEmphasis>k</SPAN>, is 2<SUP>16</SUP>. Therefore, 
                  sorting with radix sort requires <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>pn</SPAN> 
                  + <SPAN class=docEmphasis>pk</SPAN>) = (8)(2<SUP>20</SUP>) + 
                  (8)(2<SUP>16</SUP>) = (8.91)(10<SUP>6</SUP>) times some 
                  constant amount of time. If the space requirements of radix 
                  sort are acceptable, radix sort is more than twice as 
                  efficient as quicksort. In the second case, sorting with 
                  quicksort requires <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN> lg <SPAN 
                  class=docEmphasis>n</SPAN>) = (2<SUP>10</SUP>)(10) = 10,240 
                  times some constant amount of time. Radix sort requires <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>pn</SPAN> 
                  + <SPAN class=docEmphasis>pk</SPAN>) = (8)(2<SUP>10</SUP>) + 
                  (8)(2<SUP>16</SUP>) = 532,480 times some constant amount of 
                  time, or 50 times as much time as quicksort! Here is an 
                  example of why <SPAN class=docEmphasis>k</SPAN> is typically 
                  chosen to be close to and no more than <SPAN 
                  class=docEmphasis>n</SPAN>. Had we used a radix of 
                  2<SUP>8</SUP>, radix sort would have required <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>pn</SPAN> 
                  + <SPAN class=docEmphasis>pk</SPAN>) = (16)(2<SUP>8</SUP>) + 
                  (16)(2<SUP>8</SUP>) = 8160 times some constant amount of time, 
                  and would have been slightly better than quicksort. However, 
                  it is worth noting that the space requirement of radix sort 
                  may negate small benefits in time in many cases.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> In a sorted 
                  set, the <A name=IXT-12-314503></A>successor of some node 
                  <SPAN class=docEmphasis>x</SPAN> is the next largest node 
                  after <SPAN class=docEmphasis>x</SPAN>. For example, in a 
                  sorted set containing the keys 24, 39, 41, 55, 87, 92, the 
                  successor of 41 is 55. How do we find the successor of an 
                  element <SPAN class=docEmphasis>x</SPAN> using binary search? 
                  What is the runtime complexity of this operation?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> In a sorted 
                  set, to determine the successor of some element <SPAN 
                  class=docEmphasis>x</SPAN> using binary search, first we 
                  locate <SPAN class=docEmphasis>x</SPAN>. Next, we simply move 
                  one element to the right. The runtime complexity of locating 
                  either <SPAN class=docEmphasis>x</SPAN> or its successor is 
                  <SPAN class=docEmphasis>O</SPAN> (lg <SPAN 
                  class=docEmphasis>n</SPAN>).</P>
                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch12-45-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=absMiddle border=0></A> &nbsp; <A accessKey=1 
                  href="ch12-47-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=absMiddle border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
