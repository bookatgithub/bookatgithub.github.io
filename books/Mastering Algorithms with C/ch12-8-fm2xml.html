<HTML><HEAD><TITLE>ch12-8-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 12.&nbsp; Sorting and 
                  Searching</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch12-3-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=left border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch12-9-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=right border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch12-8-fm2xml></A>
                  <H3 class=docSection1Title>12.3 Implementation and Analysis of 
                  Insertion Sort</H3>
                  <P class=docText><A name=ch12-idx-410472-1></A>Insertion sort 
                  works fundamentally by inserting elements from an unsorted set 
                  one at a time into a sorted set. In the implementation 
                  presented here, both of these sets reside in 
                  <TT><I>data</I></TT>, a single block of contiguous storage. 
                  Initially, <TT><I>data</I></TT> contains the unsorted set 
                  consisting of <TT><I>size</I></TT> elements. As <SPAN 
                  class=docEmphasis>issort</SPAN> runs, <TT><I>data</I></TT> 
                  gradually becomes consumed by the sorted set until when <SPAN 
                  class=docEmphasis>issort</SPAN> returns, <TT><I>data</I></TT> 
                  is completely sorted. Although this implementation uses 
                  contiguous storage, insertion sort can easily be adapted to 
                  work with linked lists efficiently, something not all sorts 
                  can claim.</P>
                  <P class=docText>Insertion sort revolves around a single 
                  nested loop (see <A class=docLink 
                  href="#ch12-27196">Example 
                  12.1</A>). The outer loop, <TT><I>j</I></TT>, controls which 
                  element from the unsorted set is currently being inserted 
                  among the sorted elements. Since the element just to the right 
                  of the sorted set is always the next to be inserted, we can 
                  also think of <TT><I>j</I></TT> as the position dividing the 
                  sorted and unsorted sets in <TT><I>data</I></TT>. For each 
                  element at position <TT><I>j</I></TT>, an inner loop, 
                  <TT><I>i</I></TT>, is used to cycle backward through the set 
                  of sorted elements until the proper position for the element 
                  is found. As we move backward through the set, each element at 
                  position <TT><I>i</I></TT> is copied one position to the right 
                  to make room for the insertion. Once <TT><I>j</I></TT> reaches 
                  the end of the unsorted set, <TT><I>data</I></TT> is sorted 
                  (see <A class=docLink 
                  href="#ch12-19556">Figure 
                  12.1</A>).</P>
                  <CENTER>
                  <H5 class=docFigureTitle><A name=ch12-19556></A>Figure 12.1. 
                  Sorting with insertion sort</H5><IMG height=248 
                  alt=figs/alc.1201.gif src="image/alc.1201.gif" width=502 
                  border=0></CENTER>
                  <P class=docText>The runtime complexity of insertion sort 
                  focuses on its nested loops. With this in mind, the outer loop 
                  has a running time of <SPAN class=docEmphasis>T</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN>) = <SPAN class=docEmphasis>n</SPAN> 
                  - 1, times some constant amount of time, where <SPAN 
                  class=docEmphasis>n</SPAN> is the number of elements being 
                  sorted. Examining the inner loop in the worst case, we assume 
                  that we will have to go all the way to the left end of the 
                  array before inserting each element into the sorted set. 
                  Therefore, the inner loop could iterate once for the first 
                  element, twice for the second, and so forth until the outer 
                  loop terminates. The running time of the nested loop is 
                  represented as a summation from 1 to <SPAN 
                  class=docEmphasis>n</SPAN> - 1, which results in a running 
                  time of <SPAN class=docEmphasis>T</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN>) = (<SPAN class=docEmphasis>n 
                  </SPAN>(<SPAN class=docEmphasis>n</SPAN> + 1)/2) - <SPAN 
                  class=docEmphasis>n</SPAN>, times some constant amount of 
                  time. (This is from the well-known formula for summing a 
                  series from 1 to <SPAN class=docEmphasis>n</SPAN>.) Using the 
                  rules of <SPAN class=docEmphasis>O</SPAN>-notation, this 
                  simplifies to <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN><SUP>2</SUP>). When we use insertion 
                  sort in an incremental sort, its runtime complexity is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>n</SPAN>). 
                  Insertion sort sorts in place, so its space requirement is 
                  only that occupied by the data to be sorted.</P>
                  <H5 class=docExampleTitle><A name=ch12-27196></A>Example 12.1. 
                  Implementation of Insertion Sort </H5><PRE>/*****************************************************************************
*                                                                            *
*  ------------------------------- issort.c -------------------------------  *
*                                                                            *
*****************************************************************************/

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "sort.h"

/*****************************************************************************
*                                                                            *
*  -------------------------------- issort --------------------------------  *
*                                                                            *
*****************************************************************************/

int issort(void *data, int size, int esize, int (*compare)(const void *key1,
   const void *key2)) {

char               *a = data;

void               *key;

int                i,
                   j;

/*****************************************************************************
*                                                                            *
*  Allocate storage for the key element.                                     *
*                                                                            *
*****************************************************************************/

if ((key = (char *)malloc(esize)) == NULL)
   return -1;

/*****************************************************************************
*                                                                            *
*  Repeatedly insert a key element among the sorted elements.                *
*                                                                            *
*****************************************************************************/

for (j = 1; j &lt; size; j++) {

   memcpy(key, &amp;a[j * esize], esize);
   i = j - 1;

   /**************************************************************************
   *                                                                         *
   *  Determine the position at which to insert the key element.             *
   *                                                                         *
   **************************************************************************/

   while (i &gt;= 0 &amp;&amp; compare(&amp;a[i * esize], key) &gt; 0) {

      memcpy(&amp;a[(i + 1) * esize], &amp;a[i * esize], esize);
      i--;

   }

   memcpy(&amp;a[(i + 1) * esize], key, esize);

}

/*****************************************************************************
*                                                                            *
*  Free the storage allocated for sorting.                                   *
*                                                                            *
*****************************************************************************/

free(key)<A name=IXTR3-102></A>;

return<A name=IXTR3-103></A> 0;

}<A name=IXTR3-104></A></PRE>                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch12-3-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=absMiddle border=0></A> &nbsp; <A accessKey=1 
                  href="ch12-9-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=absMiddle border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
