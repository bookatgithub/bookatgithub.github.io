<HTML><HEAD><TITLE>ch12-9-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 12.&nbsp; Sorting and 
                  Searching</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch12-8-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=left border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch12-10-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=right border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch12-9-fm2xml></A>
                  <H3 class=docSection1Title>12.4 Description of Quicksort</H3>
                  <P class=docText><A name=IXT-12-314450></A><A 
                  name=IXT-12-314451></A><A name=ch12-idx-410651-1></A>Quicksort 
                  is a divide-and-conquer sorting algorithm (see <A 
                  class=docLink 
                  href="ch01-1-fm2xml.html#ch01-1-fm2xml">Chapter 
                  1</A>). It is widely regarded as the best for general use. 
                  Like insertion sort, it is a comparison sort that sorts in 
                  place, but its efficiency makes it a better choice for medium 
                  to large sets of data.</P>
                  <P class=docText><A name=ch12-idx-969085-1></A>Returning to 
                  the example of sorting a pile of canceled checks by hand, we 
                  begin with an unsorted pile that we partition in two. In one 
                  pile we place all checks numbered less than or equal to what 
                  we think may be the median value, and in the other pile we 
                  place the checks greater than this. Once we have the two 
                  piles, we divide each of them in the same manner, and we 
                  repeat the process until we end up with one check in every 
                  pile. At this point, the checks are sorted.</P>
                  <P class=docText>Since quicksort is a divide-and-conquer 
                  algorithm, it is helpful to consider it more formally in terms 
                  of the three steps common to all divide-and-conquer 
                  algorithms:</P><SPAN style="FONT-WEIGHT: bold">
                  <OL class=docList type=1>
                    <LI><SPAN style="FONT-WEIGHT: normal">
                    <P class=docList>Divide: partition the data into two 
                    partitions around a partition value.</P></SPAN>
                    <LI><SPAN style="FONT-WEIGHT: normal">
                    <P class=docList>Conquer: sort the two partitions by 
                    recursively applying quicksort to them.</P></SPAN>
                    <LI><SPAN style="FONT-WEIGHT: normal">
                    <P class=docList>Combine: do nothing since the partitions 
                    are sorted after the previous 
step.</P></SPAN></LI></OL></SPAN>
                  <P class=docText>Considering its popularity, it may be 
                  surprising that the worst case of quicksort is no better than 
                  the worst case of insertion sort. However, with a little care 
                  we can make the worst case of quicksort so unlikely that we 
                  can actually count on the algorithm performing to its average 
                  case, which is considerably better. The key to reliably 
                  achieving quicksort's average-case performance lies in how we 
                  choose the partition value in the divide step.</P>
                  <P class=docText>Quicksort performs badly when we choose 
                  partition values that continually force the majority of the 
                  elements into one partition. Instead, we need to partition the 
                  elements in as <SPAN class=docEmphasis>balanced</SPAN> a 
                  manner as possible. For example, partitioning around 10 in the 
                  set {15, 20, 18, 51, 36, 10, 77, 43} results in the unbalanced 
                  partitions of {10} and {20, 18, 51, 36, 15, 77, 43}. On the 
                  other hand, partitioning around 36 results in the more 
                  balanced partitions of {15, 20, 18, 10} and {36, 51, 77, 
                  43}.</P>
                  <P class=docText>One approach that works well in choosing 
                  partition values is to select them randomly. Statistically, 
                  this prevents any particular set of data from eliciting bad 
                  behavior, even if we try to bog down the algorithm 
                  intentionally. We can improve partitioning further by randomly 
                  choosing three elements and selecting their median as the 
                  partition value. This is called the <SPAN 
                  class=docEmphasis>median-of-three</SPAN> <SPAN 
                  class=docEmphasis>method</SPAN>,<A name=IXT-12-314452></A> <A 
                  name=IXT-12-314453></A>which virtually guarantees average-case 
                  performance. Because this approach to partitioning relies on 
                  the statistical properties of random numbers to help the 
                  performance of quicksort overall, quicksort is a good example 
                  of a randomized algorithm (see <A class=docLink 
                  href="ch01-1-fm2xml.html#ch01-1-fm2xml">Chapter 
                  1</A>).</P>
                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch12-8-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=absMiddle border=0></A> &nbsp; <A accessKey=1 
                  href="ch12-10-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=absMiddle border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
