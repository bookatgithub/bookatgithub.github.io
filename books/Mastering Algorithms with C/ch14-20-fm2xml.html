<HTML><HEAD><TITLE>ch14-20-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 14.&nbsp; Data 
                Compression</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch14-3-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=left border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch14-25-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=right border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch14-20-fm2xml></A>
                  <H3 class=docSection1Title>14.3 Implementation and Analysis of 
                  Bit Operations</H3>
                  <P class=docText><A name=ch14-idx-213025-1></A>Each bit 
                  operation works with a buffer of data defined as a pointer to 
                  an unsigned character. This pointer points to as many bytes as 
                  are required to represent the number of bits in the buffer. If 
                  the number of bits in the buffer is not a multiple of 8, some 
                  bits in the final byte are not used.</P><A 
                  name=ch14-21-fm2xml></A>
                  <H4 class=docSection2Title>14.3.1 bit_ get</H4>
                  <P class=docText><A name=IXT-14-314622></A><A 
                  name=IXT-14-314623></A>The <SPAN class=docEmphasis>bit_ 
                  get</SPAN> operation gets the state of a bit in a buffer (see 
                  <A class=docLink 
                  href="#ch14-11290">Example 
                  14.2</A>). To do this, we determine in which byte the desired 
                  bit resides and then use a mask to get the specific bit from 
                  that byte. The bit set to 1 in <TT><I>mask</I></TT> determines 
                  which bit will be read from the byte. We use a loop to shift 
                  this bit into the proper position. We fetch the desired bit by 
                  indexing to the appropriate byte in <TT><I>bits</I></TT> and 
                  applying the mask.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>bit_ get</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (1). This is because all of the 
                  steps in getting the state of a bit in a buffer run in a 
                  constant amount of time.</P><A name=ch14-22-fm2xml></A>
                  <H4 class=docSection2Title>14.3.2 bit_set</H4>
                  <P class=docText><A name=IXT-14-314624></A><A 
                  name=IXT-14-314625></A>The <SPAN 
                  class=docEmphasis>bit_set</SPAN> operation sets the state of a 
                  bit in a buffer (see <A class=docLink 
                  href="#ch14-11290">Example 
                  14.2</A>). This operation works similarly to <SPAN 
                  class=docEmphasis>bit_ get</SPAN>, except that it uses the 
                  mask to set the state of the specified bit rather than to get 
                  it.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>bit_set</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (1). This is because all of the 
                  steps in getting the state of a bit in a buffer run in a 
                  constant amount of time.</P><A name=ch14-23-fm2xml></A>
                  <H4 class=docSection2Title>14.3.3 bit_xor</H4>
                  <P class=docText><A name=IXT-14-314626></A><A 
                  name=IXT-14-314627></A>The <SPAN 
                  class=docEmphasis>bit_xor</SPAN> operation computes the 
                  bitwise XOR (exclusive OR) of two buffers, 
                  <TT><I>bits1</I></TT> and <TT><I>bits2</I></TT>, and places 
                  the result in another buffer, <TT><I>bitsx</I></TT> (see <A 
                  class=docLink 
                  href="#ch14-11290">Example 
                  14.2</A>). To do this, we compare the bit in position 
                  <TT><I>i</I></TT> of <TT><I>bits1</I></TT> with the bit in 
                  position <TT><I>i</I></TT> of <TT><I>bits2</I></TT>. If the 
                  bits are the same, we set the bit in position 
                  <TT><I>i</I></TT> of <TT><I>bitsx</I></TT> to 0; otherwise, we 
                  set the bit in position <TT><I>i</I></TT> of 
                  <TT><I>bitsx</I></TT> to 1. This process continues for as many 
                  bits are in each buffer, as specified by 
                  <TT><I>size</I></TT>.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>bit_xor</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<FONT face=symbol>b</FONT>), where 
                  <FONT face=symbol>b</FONT> is the number of bits in each 
                  buffer. This is because the loop in the operation iterates 
                  once for each bit.</P><A name=ch14-24-fm2xml></A>
                  <H4 class=docSection2Title>14.3.4 bit_rot_left</H4>
                  <P class=docText><A name=IXT-14-314628></A><A 
                  name=IXT-14-314629></A>The <SPAN 
                  class=docEmphasis>bit_rot_left</SPAN> operation rotates a 
                  buffer a specified number of bits to the left (see <A 
                  class=docLink 
                  href="#ch14-11290">Example 
                  14.2</A>). We begin by saving the leftmost bit of the leftmost 
                  byte and then shifting each byte one bit to the left. As we 
                  shift each byte, we set the rightmost bit of the preceding 
                  byte to the bit shifted off the left of the current byte. Once 
                  we have shifted the last byte, we set its rightmost bit to the 
                  bit shifted off the first byte. This process is repeated as 
                  many times as the number of bits to be rotated.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>bit_rot_left</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>n 
                  </SPAN><FONT face=symbol>b</FONT>), where <SPAN 
                  class=docEmphasis>n</SPAN> is the number of bits rotated to 
                  the left and <FONT face=symbol>b</FONT> is the number of bits 
                  in the buffer. This is because for each rotation, (<FONT 
                  face=symbol>b</FONT>/8) + 1 shifts are performed to the 
                  left.</P>
                  <H5 class=docExampleTitle><A name=ch14-11290></A>Example 14.2. 
                  Implementation of Bit Operations </H5><PRE>/*****************************************************************************
*                                                                            *
*  --------------------------------- bit.c --------------------------------  *
*                                                                            *
*****************************************************************************/

#include &lt;string.h&gt;

#include "bit.h"

/*****************************************************************************
*                                                                            *
*  -------------------------------- bit_get<A name=IXT-14-314630></A> -------------------------------  *
*                                                                            *
*****************************************************************************/

int bit_get(const unsigned char *bits, int pos) {

unsigned char      mask;

int                i;

/*****************************************************************************
*                                                                            *
*  Set a mask for the bit to get.                                            *
*                                                                            *
*****************************************************************************/

mask = 0x80;

for (i = 0; i &lt; (pos % 8); i++)
   mask = mask &gt;&gt; 1;

/*****************************************************************************
*                                                                            *
*  Get the bit.                                                              *
*                                                                            *
*****************************************************************************/

return (((mask &amp; bits[(int)(pos / 8)]) == mask) ? 1 : 0);

}

/*****************************************************************************
*                                                                            *
*  -------------------------------- bit_set<A name=IXT-14-314631></A> -------------------------------  *
*                                                                            *
*****************************************************************************/

void bit_set(unsigned char *bits, int pos, int state) {

unsigned char      mask;

int                i;

/*****************************************************************************
*                                                                            *
*  Set a mask for the bit to set.                                            *
*                                                                            *
*****************************************************************************/

mask = 0x80;

for (i = 0; i &lt; (pos % 8); i++)
   mask = mask &gt;&gt; 1;

/*****************************************************************************
*                                                                            *
*  Set the bit.                                                              *
*                                                                            *
*****************************************************************************/

if (state)
   bits[pos / 8] = bits[pos / 8] | mask;
else
   bits[pos / 8] = bits[pos / 8] &amp; (~mask);

return;

}

/*****************************************************************************
*                                                                            *
*  -------------------------------- bit_xor<A name=IXT-14-314632></A> -------------------------------  *
*                                                                            *
*****************************************************************************/

void bit_xor(const unsigned char *bits1, const unsigned char *bits2, unsigned
   char *bitsx, int size) {

int                i;

/*****************************************************************************
*                                                                            *
*  Compute the bitwise XOR (exclusive OR) of the two buffers.                *
*                                                                            *
*****************************************************************************/

for (i = 0; i &lt; size; i++) {

   if (bit_ get(bits1, i) != bit_  get(bits2, i))
      bit_set(bitsx, i, 1);
   else
      bit_set(bitsx, i, 0);

}

return;

}

/*****************************************************************************
*                                                                            *
*  ----------------------------- bit_rot_left<A name=IXT-14-314633></A> -----------------------------  *
*                                                                            *
*****************************************************************************/

void bit_rot_left(unsigned char *bits, int size, int count) {

int                fbit,
                   lbit,
                   i,
                   j;

/*****************************************************************************
*                                                                            *
*  Rotate the buffer to the left the specified number of bits.               *
*                                                                            *
*****************************************************************************/

if (size &gt; 0) {

   for (j = 0; j &lt; count; j++) {

      for (i = 0; i &lt;= ((size - 1) / 8); i++) {

         /********************************************************************
         *                                                                   *
         *  Get the bit about to be shifted off the current byte.            *
         *                                                                   *
         ********************************************************************/

         lbit = bit_get(&amp;bits[i], 0);

         if (i == 0) {

            /*****************************************************************
            *                                                                *
            *  Save the bit shifted off the first byte for later.            *
            *                                                                *
            *****************************************************************/

            fbit = lbit;

            }

         else {

            /*****************************************************************
            *                                                                *
            *  Set the rightmost bit of the previous byte to the leftmost    *
            *  bit about to be shifted off the current byte.                 *
            *                                                                *
            *****************************************************************/

            bit_set(&amp;bits[i - 1], 7, lbit);

         }

         /********************************************************************
         *                                                                   *
         *  Shift the current byte to the left.                              *
         *                                                                   *
         ********************************************************************/

         bits[i] = bits[i] &lt;&lt; 1;

      }

      /***********************************************************************
      *                                                                      *
      *  Set the rightmost bit of the buffer to the bit shifted off the      *
      *  first byte.                                                         *
      *                                                                      *
      ***********************************************************************/

      bit_set(bits, size - 1, fbit);

   }

}

return;

}<A name=IXTR3-133></A>
<A name=IXTR3-134></A></PRE>
                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch14-3-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=absMiddle border=0></A> &nbsp; <A accessKey=1 
                  href="ch14-25-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=absMiddle border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
