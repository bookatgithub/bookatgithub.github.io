<HTML><HEAD><TITLE>ch14-56-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 14.&nbsp; Data 
                Compression</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch14-47-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=left border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch14-59-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=right border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch14-56-fm2xml></A>
                  <H3 class=docSection1Title>14.10 Implementation and Analysis 
                  of LZ77</H3>
                  <P class=docText><A name=ch14-idx-215514-1></A>With<A 
                  name=IXT-14-314680></A> LZ77, we try to compress data by 
                  encoding phrases from a look-ahead buffer as tokens 
                  referencing phrases in a sliding window. To uncompress the 
                  data, we decode each token into the phrase or symbol it 
                  represents. To do this, we must continually update the sliding 
                  window so that at any one time it looks the same as it did 
                  during the compression process. In the implementation 
                  presented here, a symbol in the original data is one 
                  byte.</P><A name=ch14-57-fm2xml></A>
                  <H4 class=docSection2Title>14.10.1 lz77_compress</H4>
                  <P class=docText><A name=IXT-14-314681></A><A 
                  name=IXT-14-314682></A>The <SPAN 
                  class=docEmphasis>lz77_compress</SPAN> operation (see <A 
                  class=docLink 
                  href="#ch14-25750">Example 
                  14.5</A>) compresses data using LZ77. It begins by writing the 
                  number of symbols in the data to the buffer of compressed data 
                  and initializing the sliding window and look-ahead buffer. The 
                  look-ahead buffer is then loaded with symbols.</P>
                  <P class=docText>Compression takes place inside of a loop that 
                  iterates until there are no more symbols to process. We use 
                  <TT><I>ipos</I></TT> to keep track of the current byte being 
                  processed in the original data, and <TT><I>opos</I></TT> to 
                  keep track of the current bit we are writing to the buffer of 
                  compressed data. During each iteration of the loop, we call 
                  <SPAN class=docEmphasis>compare_win</SPAN> to determine the 
                  longest phrase in the look-ahead buffer that matches one in 
                  the sliding window. The <SPAN 
                  class=docEmphasis>compare_win</SPAN> function returns the 
                  length of the longest match.</P>
                  <P class=docText><A name=IXT-14-314683></A>When a match is 
                  found, <SPAN class=docEmphasis>compare_win</SPAN> sets 
                  <TT><I>offset</I></TT> to the position of the match in the 
                  sliding window and <TT><I>next</I></TT> to the symbol in the 
                  look-ahead buffer immediately after the match. In this case, 
                  we write a <A name=IXT-14-314684></A><A 
                  name=ch14-idx-1027756-2></A>phrase token to the compressed 
                  data (see <A class=docLink 
                  href="#ch14-59079">Figure 
                  14.4</A>a). Phrase tokens in the implementation presented here 
                  require 12 bits for offsets because the size of the sliding 
                  window is 4K (4096 bytes). Phrase tokens require 5 bits for 
                  lengths because no match will exceed the length of the 
                  look-ahead buffer, which is 32 bytes. If a match is not found, 
                  <SPAN class=docEmphasis>compare_win</SPAN> returns and sets 
                  <TT><I>next</I></TT> to the unmatched symbol at the start of 
                  the look-ahead buffer. In this case, we write a <A 
                  name=IXT-14-314685></A>symbol <A name=IXT-14-314686></A>token 
                  to the compressed data (see <A class=docLink 
                  href="#ch14-59079">Figure 
                  14.4</A>b). Whether we write a phrase or symbol token to the 
                  compressed data, before actually writing the token, we call 
                  the network function <SPAN class=docEmphasis>htonl</SPAN> as a 
                  convenient way to ensure that the token is in big-endian 
                  format. This is the format required when we actually store the 
                  compressed data as well as when we uncompress it.</P>
                  <CENTER><A name=IXT-14-314687></A>
                  <H5 class=docFigureTitle><A name=ch14-59079></A>Figure 14.4. 
                  The structure of (a) a phrase token and (b) a symbol token in 
                  LZ77</H5><IMG height=164 alt=figs/alc.1404.gif 
                  src="image/alc.1404.gif" width=502 border=0></CENTER>
                  <P class=docText>Once we write the appropriate token to the 
                  buffer of compressed data, we adjust the sliding window and 
                  the look-ahead buffer. To move the data through the sliding 
                  window, we shift data in from the right side of the window and 
                  out the left. We do the same for the look-ahead buffer. The 
                  number of bytes we move is equal to the number of symbols we 
                  encode in the token.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>lz77_compress</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>n</SPAN>), 
                  where <SPAN class=docEmphasis>n</SPAN> is the number of 
                  symbols in the original data. This is because for each of the 
                  <SPAN class=docEmphasis>n</SPAN>/<SPAN 
                  class=docEmphasis>c</SPAN> tokens in which the data is 
                  encoded, where 1/<SPAN class=docEmphasis>c</SPAN> is a 
                  constant factor that represents how efficiently symbols are 
                  encoded in phrase tokens, we call <SPAN 
                  class=docEmphasis>compare_win</SPAN> once. The <SPAN 
                  class=docEmphasis>compare_win</SPAN> function runs in a 
                  constant amount of time because the size of the sliding window 
                  and look-ahead buffer are both constant. However, these 
                  constants are large and contribute significantly to the 
                  overall running time of <SPAN 
                  class=docEmphasis>lz77_compress</SPAN>. Thus, the runtime 
                  complexity of <SPAN class=docEmphasis>lz77_compress</SPAN> is 
                  <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN>), but its actual running time is 
                  greatly affected by constant factors. This explains the 
                  generally slow performance of LZ77 when compressing 
                  data.</P><A name=ch14-58-fm2xml></A>
                  <H4 class=docSection2Title>14.10.2 lz77_uncompress</H4>
                  <P class=docText><A name=IXT-14-314688></A><A 
                  name=IXT-14-314689></A>The <SPAN 
                  class=docEmphasis>lz77_uncompress</SPAN> operation (see <A 
                  class=docLink 
                  href="#ch14-59079">Figure 
                  14.4</A>) uncompresses data previously compressed with <SPAN 
                  class=docEmphasis>lz77_compress</SPAN>. It begins by reading 
                  the number of symbols in the compressed data and initializing 
                  the sliding window and look-ahead buffer.</P>
                  <P class=docText>Uncompressing the data takes place inside a 
                  loop that iterates until there are no more symbols to process. 
                  We use <TT><I>ipos</I></TT> to keep track of the current bit 
                  being processed in the compressed data, and 
                  <TT><I>opos</I></TT> to keep track of the current byte we are 
                  writing to the buffer of restored data. During each iteration 
                  of the loop, we first read one bit from the compressed data to 
                  determine the type of token we are about to decode.</P>
                  <P class=docText>At the start of interpreting a token, if the 
                  first bit read is 1, we have encountered a phrase token<A 
                  name=IXT-14-314690></A>. Thus, we read each of its members, 
                  look up the phrase in the sliding window, and write the phrase 
                  to the buffer of restored data. As we look up each phrase, we 
                  call the network function <SPAN class=docEmphasis>ntohl</SPAN> 
                  to ensure that the byte ordering of its offset and length in 
                  the window are correct for the system. This step is required 
                  because both the offset and length are in big-endian format 
                  when read from the compressed data. The look-ahead buffer is 
                  used as a convenient place to temporarily store the data 
                  before copying it into the sliding window. Last, we write the 
                  unmatched symbol encoded by the token. If the first bit read 
                  for the token is 0, we have encountered a symbol token. In 
                  this case, we write the one unmatched symbol it encodes to the 
                  buffer of restored data.</P>
                  <P class=docText><A name=IXT-14-314691></A>Once we write the 
                  decoded data to the buffer of restored data, we adjust the 
                  sliding window. To move the data through the sliding window, 
                  we shift the decoded data in from the right side of the window 
                  and out the left. The number of bytes we move is equal to the 
                  number of symbols we decode from the token.</P>
                  <P class=docText>The runtime complexity of <SPAN 
                  class=docEmphasis>lz77_uncompress</SPAN> is <SPAN 
                  class=docEmphasis>O</SPAN> (<SPAN class=docEmphasis>n</SPAN>), 
                  where <SPAN class=docEmphasis>n</SPAN> is the number of 
                  symbols in the original data. This is because for each of the 
                  <SPAN class=docEmphasis>n</SPAN>/<SPAN 
                  class=docEmphasis>c</SPAN> tokens in which the data is 
                  encoded, where 1/<SPAN class=docEmphasis>c</SPAN> is a 
                  constant factor that represents how efficiently symbols are 
                  encoded in phrase tokens<A name=IXTR3-143></A>, we perform the 
                  constant-time operation of copying symbols from the sliding 
                  window to the buffer of restored data. Thus, the runtime 
                  complexity of <SPAN class=docEmphasis>lz77_uncompress</SPAN> 
                  is <SPAN class=docEmphasis>O</SPAN> (<SPAN 
                  class=docEmphasis>n</SPAN>). Its lack of significant constant 
                  factors explains its generally superior performance to <SPAN 
                  class=docEmphasis>huffman_uncompress</SPAN> and its vast 
                  improvement in actual running time over <SPAN 
                  class=docEmphasis>lz77_compress</SPAN>.</P>
                  <H5 class=docExampleTitle><A name=ch14-25750></A>Example 14.5. 
                  Implementation of LZ77 </H5><PRE>/*****************************************************************************
*                                                                            *
*  -------------------------------- lz77.c --------------------------------  *
*                                                                            *
*****************************************************************************/

#include &lt;netinet/in.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "bit.h"
#include "compress.h"

/*****************************************************************************
*                                                                            *
*  ------------------------------ <A name=IXT-14-314692></A>compare_win -----------------------------  *
*                                                                            *
*****************************************************************************/

static int compare_win(const unsigned char *window, const unsigned char
   *buffer, int *offset, unsigned char *next) {

int                match,
                   longest,
                   i,
                   j,
                   k;

/*****************************************************************************
*                                                                            *
*  Initialize the offset, although it is valid only once a match is found.   *
*                                                                            *
*****************************************************************************/

*offset = 0;

/*****************************************************************************
*                                                                            *
*  If no match is found, prepare to return 0 and the next symbol in the      *
*  look-ahead buffer.                                                        *
*                                                                            *
*****************************************************************************/

longest = 0;
*next = buffer[0];

/*****************************************************************************
*                                                                            *
*  Look for the best match in the look-ahead buffer and sliding window.      *
*                                                                            *
*****************************************************************************/

for (k = 0; k &lt; LZ77_WINDOW_SIZE; k++) {

   i = k;
   j = 0;
   match = 0;

   /**************************************************************************
   *                                                                         *
   *  Determine how many symbols match in the sliding window at offset k.    *
   *                                                                         *
   **************************************************************************/

   while (i &lt; LZ77_WINDOW_SIZE &amp;&amp; j &lt; LZ77_BUFFER_SIZE - 1) {

      if (window[i] != buffer[j])
         break;

      match++;
      i++;
      j++;

   }

   /**************************************************************************
   *                                                                         *
   *  Keep track of the offset, length, and next symbol for the best match.  *
   *                                                                         *
   **************************************************************************/

   if (match &gt; longest) {

      *offset = k;
      longest = match;
      *next = buffer[j];

   }

}

return longest;

}

/*****************************************************************************
*                                                                            *
*  ----------------------------- lz77_compress<A name=IXT-14-314693></A> ----------------------------  *
*                                                                            *
*****************************************************************************/

int lz77_compress(const unsigned char *original, unsigned char **compressed,
   int size) {

unsigned char      window[LZ77_WINDOW_SIZE],
                   buffer[LZ77_BUFFER_SIZE],
                   *comp,
                   *temp,
                   next;

int                offset,
                   length,
                   remaining,
                   hsize,
                   ipos,
                   opos,
                   tpos,
                   i;

/*****************************************************************************
*                                                                            *
*  Make the pointer to the compressed data not valid until later.            *
*                                                                            *
*****************************************************************************/

*compressed = NULL;

/*****************************************************************************
*                                                                            *
*  Write the header information.                                             *
*                                                                            *
*****************************************************************************/

hsize = sizeof(int);

if ((comp = (unsigned char *)malloc(hsize)) == NULL)
   return -1;

memcpy(comp, &amp;size, sizeof(int));

/*****************************************************************************
*                                                                            *
*  Initialize the sliding window and the look-ahead buffer.                  *
*                                                                            *
*****************************************************************************/

memset(window, 0, LZ77_WINDOW_SIZE);
memset(buffer, 0, LZ77_BUFFER_SIZE);

/*****************************************************************************
*                                                                            *
*  Load the look-ahead buffer.                                               *
*                                                                            *
*****************************************************************************/

ipos = 0;

for (i = 0; i &lt; LZ77_BUFFER_SIZE &amp;&amp; ipos &lt; size; i++) {

   buffer[i] = original[ipos];
   ipos++;

}

/*****************************************************************************
*                                                                            *
*  Compress the data.                                                        *
*                                                                            *
*****************************************************************************/

opos = hsize * 8;
remaining = size;

while (remaining &gt; 0) {

   if ((length = compare_win(window, buffer, &amp;offset, &amp;next)) != 0) {

      /***********************************************************************
      *                                                                      *
      *  Encode a phrase token<A name=IXT-14-314694></A>.                                              *
      *                                                                      *
      ***********************************************************************/

      token = 0x00000001 &lt;&lt; (LZ77_PHRASE_BITS - 1);

      /***********************************************************************
      *                                                                      *
      *  Set the offset where the match was found in the sliding window.     *
      *                                                                      *
      ***********************************************************************/

      token = token | (offset &lt;&lt; (LZ77_PHRASE_BITS - LZ77_TYPE_BITS -
         LZ77_WINOFF_BITS));

      /***********************************************************************
      *                                                                      *
      *  Set the length of the match.                                        *
      *                                                                      *
      ***********************************************************************/

      token = token | (length &lt;&lt; (LZ77_PHRASE_BITS - LZ77_TYPE_BITS -
         LZ77_WINOFF_BITS - LZ77_BUFLEN_BITS));

      /***********************************************************************
      *                                                                      *
      *  Set the next symbol in the look-ahead buffer after the match.       *
      *                                                                      *
      ***********************************************************************/

      token = token | next;

      /***********************************************************************
      *                                                                      *
      *  Set the number of bits in the token.                                *
      *                                                                      *
      ***********************************************************************/

      tbits = LZ77_PHRASE_BITS;
      
      }

   else {

      /***********************************************************************
      *                                                                      *
      *  Encode a symbol token.                                              *
      *                                                                      *
      ***********************************************************************/

      token = 0x00000000;

      /***********************************************************************
      *                                                                      *
      *  Set the unmatched symbol.                                           *
      *                                                                      *
      ***********************************************************************/

      token = token | next;

      /***********************************************************************
      *                                                                      *
      *  Set the number of bits in the token.                                *
      *                                                                      *
      ***********************************************************************/

      tbits = LZ77_SYMBOL_BITS;

   }

   /**************************************************************************
   *                                                                         *
   *  Ensure that the token is in big-endian format.                         *
   *                                                                         *
   **************************************************************************/

   token = htonl(token);

   /**************************************************************************
   *                                                                         *
   *  Write the token to the buffer of compressed data.                      *
   *                                                                         *
   **************************************************************************/

   for (i = 0; i &lt; tbits; i++) {

      if (opos % 8 == 0) {

         /********************************************************************
         *                                                                   *
         *  Allocate another byte for the buffer of compressed data.         *
         *                                                                   *
         ********************************************************************/

         if ((temp = (unsigned char *)realloc(comp,(opos / 8) + 1)) == NULL) {

            free(comp);
            return -1;

         }

         comp = temp;

      }

      tpos = (sizeof(unsigned long) * 8) - tbits + i;
      bit_set(comp, opos, bit_get((unsigned char *)&amp;token, tpos));
      opos++;

   }

   /**************************************************************************
   *                                                                         *
   *  Adjust the phrase length to account for the unmatched symbol.          *
   *                                                                         *
   **************************************************************************/

   length++;
      
   /**************************************************************************
   *                                                                         *
   *  Copy data from the look-ahead buffer to the sliding window.            *
   *                                                                         *
   **************************************************************************/

   memmove(&amp;window[0], &amp;window[length], LZ77_WINDOW_SIZE - length);
   memmove(&amp;window[LZ77_WINDOW_SIZE - length], &amp;buffer[0], length);

   /**************************************************************************
   *                                                                         *
   *  Read more data into the look-ahead buffer.                             *
   *                                                                         *
   **************************************************************************/

   memmove(&amp;buffer[0], &amp;buffer[length], LZ77_BUFFER_SIZE - length);

   for (i = LZ77_BUFFER_SIZE - length; i&lt;LZ77_BUFFER_SIZE &amp;&amp; ipos&lt;size; i++) {

      buffer[i] = original[ipos];
      ipos++;

   }

   /**************************************************************************
   *                                                                         *
   *  Adjust the total symbols remaining by the phrase length.               *
   *                                                                         *
   **************************************************************************/

   remaining = remaining - length;

}

/*****************************************************************************
*                                                                            *
*  Point to the buffer of compressed data.                                   *
*                                                                            *
*****************************************************************************/

*compressed = comp;

/*****************************************************************************
*                                                                            *
*  Return the number of bytes in the compressed data.                        *
*                                                                            *
*****************************************************************************/

return ((opos - 1) / 8) + 1;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- lz77_uncompress<A name=IXT-14-314695></A><A name=IXT-14-314696></A> ---------------------------  *
*                                                                            *
*****************************************************************************/

int lz77_uncompress(const unsigned char *compressed, unsigned char
   **original) {

unsigned char      window[LZ77_WINDOW_SIZE],
                   buffer[LZ77_BUFFER_SIZE],
                   *orig,
                   *temp,
                   next;

int                offset,
                   length,
                   remaining,
                   hsize,
                   size,
                   ipos,
                   opos,
                   tpos,
                   state,
                   i;

/*****************************************************************************
*                                                                            *
*  Make the pointer to the original data not valid until later.              *
*                                                                            *
*****************************************************************************/

*original = orig = NULL;

/*****************************************************************************
*                                                                            *
*  Get the header information.                                               *
*                                                                            *
*****************************************************************************/

hsize = sizeof(int);
memcpy(&amp;size, compressed, sizeof(int));

/*****************************************************************************
*                                                                            *
*  Initialize the sliding window and the look-ahead buffer.                  *
*                                                                            *
*****************************************************************************/

memset(window, 0, LZ77_WINDOW_SIZE);
memset(buffer, 0, LZ77_BUFFER_SIZE);

/*****************************************************************************
*                                                                            *
*  Uncompress the data.                                                      *
*                                                                            *
*****************************************************************************/

ipos = hsize * 8;
opos = 0;
remaining = size;

while (remaining &gt; 0) {

   /**************************************************************************
   *                                                                         *
   *  Get the next bit in the compressed data.                               *
   *                                                                         *
   **************************************************************************/

   state = bit_get(compressed, ipos);
   ipos++;

   if (state == 1) {

      /***********************************************************************
      *                                                                      *
      *  Handle processing a phrase token.                                   *
      *                                                                      *
      ***********************************************************************/

      memset(&amp;offset, 0, sizeof(int));

      for (i = 0; i &lt; LZ77_WINOFF_BITS; i++) {

         tpos = (sizeof(int) * 8) - LZ77_WINOFF_BITS + i;
         bit_set((unsigned char *)&amp;offset, tpos, bit_get(compressed, ipos));
         ipos++;

      }

      memset(&amp;length, 0, sizeof(int));

      for (i = 0; i &lt; LZ77_BUFLEN_BITS; i++) {

         tpos = (sizeof(int) * 8) - LZ77_BUFLEN_BITS + i;
         bit_set((unsigned char *)&amp;length, tpos, bit_get(compressed, ipos));
         ipos++;

      }

      next = 0x00;

      for (i = 0; i &lt; LZ77_NEXT_BITS; i++) {

         tpos = (sizeof(unsigned char) * 8) - LZ77_NEXT_BITS + i;
         bit_set((unsigned char *)&amp;next, tpos, bit_get(compressed, ipos));
         ipos++;

      }

      /***********************************************************************
      *                                                                      *
      *  Ensure that the offset and length have the correct byte ordering    *
      *  for the system.                                                     *
      *                                                                      *
      ***********************************************************************/

      offset = ntohl(offset);
      length = ntohl(length);

      /***********************************************************************
      *                                                                      *
      *  Write the phrase from the window to the buffer of original data.    *
      *                                                                      *
      ***********************************************************************/

      i = 0;

      if (opos &gt; 0) {

         if ((temp = (unsigned char *)realloc(orig, opos+length+1)) == NULL) {

            free(orig);
            return -1;

         }

         orig = temp;

         }

      else {


         if ((orig = (unsigned char *)malloc(length + 1)) == NULL)
            return -1;

      }

      while (i &lt; length &amp;&amp; remaining &gt; 0) {

         orig[opos] = window[offset + i];
         opos++;

         /********************************************************************
         *                                                                   *
         *  Record each symbol in the look-ahead buffer until ready to       *
         *  update the sliding window.                                       *
         *                                                                   *
         ********************************************************************/

         buffer[i] = window[offset + i];
         i++;

         /********************************************************************
         *                                                                   *
         *  Adjust the total symbols remaining to account for each symbol    *
         *  consumed.                                                        *
         *                                                                   *
         ********************************************************************/

         remaining--;

      }

      /***********************************************************************
      *                                                                      *
      *  Write the unmatched symbol to the buffer of original data.          *
      *                                                                      *
      ***********************************************************************/

      if (remaining &gt; 0) {

         orig[opos] = next;
         opos++;

         /********************************************************************
         *                                                                   *
         *  Also record this symbol in the look-ahead buffer.                *
         *                                                                   *
         ********************************************************************/

         buffer[i] = next;

         /********************************************************************
         *                                                                   *
         *  Adjust the total symbols remaining to account for the unmatched  *
         *  symbol.                                                          *
         *                                                                   *
         ********************************************************************/

         remaining--;

      }

      /***********************************************************************
      *                                                                      *
      *  Adjust the phrase length to account for the unmatched symbol.       *
      *                                                                      *
      ***********************************************************************/

      length++;

      }

   else {

      /***********************************************************************
      *                                                                      *
      *  Handle processing a symbol token.                                   *
      *                                                                      *
      ***********************************************************************/

      next = 0x00;

      for (i = 0; i &lt; LZ77_NEXT_BITS; i++) {

         tpos = (sizeof(unsigned char) * 8) - LZ77_NEXT_BITS + i;
         bit_set((unsigned char *)&amp;next, tpos, bit_get(compressed, ipos));
         ipos++;

      }

      /***********************************************************************
      *                                                                      *
      *  Write the symbol to the buffer of original data.                    *
      *                                                                      *
      ***********************************************************************/

      if (opos &gt; 0) {

         if ((temp = (unsigned char *)realloc(orig, opos + 1)) == NULL) {

            free(orig);
            return -1;

         }

         orig = temp;

         }

      else {

         if ((orig = (unsigned char *)malloc(1)) == NULL)
            return -1;

      }

      orig[opos] = next;
      opos++;

      /***********************************************************************
      *                                                                      *
      *  Record the symbol in the look-ahead buffer until ready to update    *
      *  the sliding window.                                                 *
      *                                                                      *
      ***********************************************************************/

      if (remaining &gt; 0)
         buffer[0] = next;

      /***********************************************************************
      *                                                                      *
      *  Adjust the total symbols remaining to account for the unmatched     *
      *  symbol.                                                             *
      *                                                                      *
      ***********************************************************************/

      remaining--;

      /***********************************************************************
      *                                                                      *
      *  Set the phrase length to account for the unmatched symbol.          *
      *                                                                      *
      ***********************************************************************/

      length = 1;

   }

   /**************************************************************************
   *                                                                         *
   *  Copy the look-ahead buffer into the sliding window.                    *
   *                                                                         *
   **************************************************************************/

   memmove(&amp;window[0], &amp;window[length], LZ77_WINDOW_SIZE - length);
   memmove(&amp;window[LZ77_WINDOW_SIZE - length], &amp;buffer[0], length);

}

/*****************************************************************************
*                                                                            *
*  Point to the buffer of original data.                                     *
*                                                                            *
*****************************************************************************/

*original = orig;

/*****************************************************************************
*                                                                            *
*  Return the number of bytes in the original<A name=IXTR3-144></A>
<A name=IXTR3-145></A> data<A name=IXTR3-146></A>.                          *
*                                                                            *
*****************************************************************************/

return<A name=IXTR3-147></A>
<A name=IXTR3-148></A> opos;

}</PRE>                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch14-47-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=absMiddle border=0></A> &nbsp; <A accessKey=1 
                  href="ch14-59-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=absMiddle border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
