<HTML><HEAD><TITLE>ch15-33-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 15.&nbsp; Data 
              Encryption</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch15-30-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=left border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch15-34-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=right border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch15-33-fm2xml></A>
                  <H3 class=docSection1Title>15.8 Questions and Answers</H3>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Suppose we 
                  would like to encrypt a file containing flags that enable or 
                  disable certain attributes in an application based on the 
                  features a customer has paid for. Which method of encryption 
                  presented in this chapter would be best suited to this 
                  scenario?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Since in 
                  this scenario only one party, the application itself, needs to 
                  read the file, it makes sense to use a symmetric cipher such 
                  as DES. Before installing the file, we encipher it with a key 
                  that only the application knows about. Whenever the 
                  application needs to read the file, it deciphers it using the 
                  same key.</P>
                  <P class=docText><A name=IXT-15-314970></A><A 
                  name=IXT-15-314971></A><SPAN class=docEmphBold>Q:</SPAN> 
                  Suppose a party <SPAN class=docEmphasis>A</SPAN> is making 
                  sensitive requests for data across the Internet to another 
                  party <SPAN class=docEmphasis>B.</SPAN> <SPAN 
                  class=docEmphasis>B</SPAN> is the only one who should be able 
                  to decipher the data enciphered by <SPAN 
                  class=docEmphasis>A</SPAN>, and <SPAN 
                  class=docEmphasis>A</SPAN> is the only one who should be able 
                  to decipher data enciphered by <SPAN 
                  class=docEmphasis>B</SPAN> specifically for<SPAN 
                  class=docEmphasis> A. B</SPAN> also receives requests from 
                  several other parties, all of whom should not be able to hear 
                  what each other is saying. Which method of encryption from 
                  this chapter would be best in this scenario?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Since all 
                  parties must be able to communicate with <SPAN 
                  class=docEmphasis>B</SPAN> but without anyone else being able 
                  to decipher the communications, we should use a public-key 
                  cipher such as RSA. Consider the case of <SPAN 
                  class=docEmphasis>A</SPAN> making a request to <SPAN 
                  class=docEmphasis>B</SPAN>. <SPAN class=docEmphasis>A</SPAN> 
                  makes his request to <SPAN class=docEmphasis>B</SPAN> by 
                  enciphering the request with <SPAN class=docEmphasis>B</SPAN> 
                  's public key. When <SPAN class=docEmphasis>B</SPAN> receives 
                  the request, <SPAN class=docEmphasis>B</SPAN> deciphers it 
                  using her own private key. Once <SPAN 
                  class=docEmphasis>B</SPAN> has validated that <SPAN 
                  class=docEmphasis>A</SPAN> sent the request (perhaps using a 
                  digital signature), she enciphers a reply using <SPAN 
                  class=docEmphasis>A</SPAN>'s public key. Once <SPAN 
                  class=docEmphasis>A</SPAN> receives the reply from <SPAN 
                  class=docEmphasis>B</SPAN>, <SPAN class=docEmphasis>A</SPAN> 
                  deciphers the message using his own private key.</P>
                  <P class=docText><A name=IXT-15-314972></A><A 
                  name=IXT-15-314973></A><SPAN class=docEmphBold>Q:</SPAN> With 
                  DES, we encipher and decipher data by performing a series of 
                  permutations and substitutions. Exactly how these permutations 
                  and substitutions affect the data is essentially a function of 
                  16 subkeys, derived from an initial key that we provide. In 
                  general, the security of DES is greatest when most of the 
                  subkeys differ from one another. Unfortunately, certain 
                  initial keys lead to situations in which all subkeys are 
                  identical. These initial keys are called <SPAN 
                  class=docEmphasis>weak keys</SPAN>. DES has four weak keys. 
                  What are they?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> To generate 
                  subkeys in DES, we first transform the key from 64 bits to 56 
                  bits. Once the key has been transformed, we divide it into two 
                  28-bit blocks and perform a number of other operations that 
                  are repeated during each round. If either of the two 28-bit 
                  blocks contains bits that are all the same, these operations 
                  have no effect. Thus, we end up with subkeys that are 
                  identical for every round, and the initial key is considered 
                  weak. The four weak keys of DES and what they become are shown 
                  in <A class=docLink 
                  href="#ch15-11125">Table 
                  15.9</A>.</P><A name=ch15-11125></A>
                  <P>
                  <TABLE cellSpacing=0 cellPadding=4 rules=all width="100%" 
                  border=1>
                    <CAPTION>
                    <H5 class=docTableTitle>Table 15.9. Weak Keys in DES Before 
                    and After the Key Transformation </H5></CAPTION>
                    <COLGROUP span=2>
                    <THEAD>
                    <TR>
                      <TH class=docTableHeader>
                        <P class=docText>Key</P></TH>
                      <TH class=docTableHeader>
                        <P class=docText>Becomes</P></TH></TR></THEAD>
                    <TBODY>
                    <TR>
                      <TD class=docTableCell>
                        <P class=docText>0101 0101 0101 0101</P></TD>
                      <TD class=docTableCell>
                        <P class=docText>0000000 0000000</P></TD></TR>
                    <TR>
                      <TD class=docTableCell>
                        <P class=docText>1F1F 1F1F 1F1F 1F1F</P></TD>
                      <TD class=docTableCell>
                        <P class=docText>0000000 FFFFFFF</P></TD></TR>
                    <TR>
                      <TD class=docTableCell>
                        <P class=docText>E0E0 E0E0 F1F1 F1F1</P></TD>
                      <TD class=docTableCell>
                        <P class=docText>FFFFFFF 0000000</P></TD></TR>
                    <TR>
                      <TD class=docTableCell>
                        <P class=docText>FEFE FEFE FEFE FEFE</P></TD>
                      <TD class=docTableCell>
                        <P class=docText>FFFFFFF 
                    FFFFFFF</P></TD></TR></COLGROUP></TBODY></TABLE></P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Avoiding 
                  weak keys is one security issue in DES. Another issue is 
                  avoiding<A name=IXT-15-314974></A> <A 
                  name=IXT-15-314975></A><SPAN class=docEmphasis>semiweak 
                  keys</SPAN>. Semiweak keys come in pairs. Two keys form a 
                  <SPAN class=docEmphasis>semiweak key pair</SPAN> if the 
                  subkeys they produce are in the opposite order. This means 
                  that if we use one key from the pair to re-encipher the 
                  ciphertext generated using the other key, we effectively get 
                  the same result as deciphering the ciphertext with the 
                  original key. DES has six semiweak key pairs. What are they? 
                  Why are semiweak keys a problem?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> The problem 
                  with semiweak key pairs in DES is that by re-enciphering the 
                  ciphertext with one key in the pair we essentially end up 
                  performing the same operation as deciphering the ciphertext 
                  with the other key. Thus, effectively we have two keys that 
                  can decipher the data, which makes semiweak keys undesirable. 
                  The six semiweak key pairs of DES are shown in <A 
                  class=docLink 
                  href="#ch15-86926">Table 
                  15.10</A>.</P><A name=ch15-86926></A>
                  <P>
                  <TABLE cellSpacing=0 cellPadding=4 rules=all width="100%" 
                  border=1>
                    <CAPTION>
                    <H5 class=docTableTitle>Table 15.10. Semiweak Key Pairs in 
                    DES </H5></CAPTION>
                    <COLGROUP span=2>
                    <THEAD>
                    <TR>
                      <TH class=docTableHeader>
                        <P class=docText>Key 1</P></TH>
                      <TH class=docTableHeader>
                        <P class=docText>Key 2</P></TH></TR></THEAD>
                    <TBODY>
                    <TR>
                      <TD class=docTableCell>
                        <P class=docText>01FE 01FE 01FE 01FE</P></TD>
                      <TD class=docTableCell>
                        <P class=docText>FE01 FE01 FE01 FE01</P></TD></TR>
                    <TR>
                      <TD class=docTableCell>
                        <P class=docText>1FE0 1FE0 0EF1 0EF1</P></TD>
                      <TD class=docTableCell>
                        <P class=docText>E01F E01F F10E F10E</P></TD></TR>
                    <TR>
                      <TD class=docTableCell>
                        <P class=docText>01E0 01E0 01F1 01F1</P></TD>
                      <TD class=docTableCell>
                        <P class=docText>E001 E001 F101 F101</P></TD></TR>
                    <TR>
                      <TD class=docTableCell>
                        <P class=docText>1EFE 1EFE 0EFE 0EFE</P></TD>
                      <TD class=docTableCell>
                        <P class=docText>FE1F FE1F FE0E FE0E</P></TD></TR>
                    <TR>
                      <TD class=docTableCell>
                        <P class=docText>011F 011F 010E 010E</P></TD>
                      <TD class=docTableCell>
                        <P class=docText>1F01 1F01 0E01 0E01</P></TD></TR>
                    <TR>
                      <TD class=docTableCell>
                        <P class=docText>E0FE E0FE F1FE F1FE</P></TD>
                      <TD class=docTableCell>
                        <P class=docText>FEE0 FEE0 FEF1 
                    FEF1</P></TD></TR></COLGROUP></TBODY></TABLE></P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Some 
                  applications of DES use keys that are generated randomly. In 
                  applications like this, what precautions might we take against 
                  the use of weak and semiweak keys, if any?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Considering 
                  the number of keys listed in Tables <A class=docLink 
                  href="#ch15-11125">Table 
                  15.9</A> and <A class=docLink 
                  href="#ch15-86926">Table 
                  15.10</A> combined, it's evident that out of 2<SUP>56</SUP> 
                  possible keys in DES, weak and semiweak keys are rare. 
                  Nevertheless, applications that use randomly generated keys 
                  often check to make sure a candidate key is not weak or 
                  semiweak before using it. On the other hand, since checking 
                  every key is somewhat wasteful considering how infrequent weak 
                  and semiweak keys are, many applications simply don't worry 
                  about them.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> RSA is a 
                  block cipher, which means that it processes data one block at 
                  a time. Whereas DES always uses a block size of 64 bits, the 
                  block size of RSA varies depending on the value of <SPAN 
                  class=docEmphasis>n</SPAN>, where <SPAN class=docEmphasis>n = 
                  pq.</SPAN> What happens if we mistakenly choose the block size 
                  so that some blocks of plaintext contain values greater than 
                  or equal to <SPAN class=docEmphasis>n</SPAN>?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> The problem 
                  with a block of plaintext containing a value greater than or 
                  equal to <SPAN class=docEmphasis>n</SPAN> is that when we 
                  encipher and decipher blocks, the modular exponentiation 
                  operation is modulo <SPAN class=docEmphasis>n</SPAN>. This 
                  means that all blocks generated as either ciphertext or 
                  plaintext contain values less than <SPAN 
                  class=docEmphasis>n</SPAN>. Therefore, if the original block 
                  of plaintext contains a value greater than or equal to <SPAN 
                  class=docEmphasis>n</SPAN>, after enciphering and deciphering 
                  the block, we will not end up with the plaintext we started 
                  with.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> This 
                  chapter discussed two common block cipher modes, ECB and CBC. 
                  What are some of the advantages each offers? What are some of 
                  the drawbacks?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> ECB and CBC 
                  both have advantages and disadvantages. ECB is simple, but its 
                  lack of feedback makes it considerably less secure than CBC. 
                  However, by not using feedback, ECB has some flexibilities. 
                  For example, with ECB, since no block depends on any other 
                  block having been processed before it, we can process blocks 
                  out of sequence or in parallel. The most significant advantage 
                  of CBC is that it conceals patterns in the plaintext well. 
                  However, its use of feedback means that we must encipher 
                  blocks in order. On the other hand, deciphering data in CBC 
                  mode does not have this restriction. To decipher data, we 
                  require feedback only from the ciphertext itself, not any of 
                  the blocks deciphered previously.</P>
                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch15-30-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=absMiddle border=0></A> &nbsp; <A accessKey=1 
                  href="ch15-34-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=absMiddle border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
