<HTML><HEAD><TITLE>ch16-1-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Part III:&nbsp; 
              Algorithms</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch15-34-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=left border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch16-2-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=right border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch16-1-fm2xml></A>
                  <H2 class=docChapterTitle>Chapter 16. Graph Algorithms</H2>
                  <P class=docText><A name=IXT-16-314723></A><A 
                  name=IXT-16-314724></A><A name=ch16-idx-709544-3></A>Graphs 
                  are flexible data structures that model problems defined in 
                  terms of relationships or connections between objects (see <A 
                  class=docLink 
                  href="ch11-1-fm2xml.html#ch11-1-fm2xml">Chapter 
                  11</A>). This chapter presents algorithms that work with 
                  graphs. As we will see, many graph algorithms resemble the 
                  fundamental ones for breadth-first and depth-first search 
                  introduced in <A class=docLink 
                  href="ch11-1-fm2xml.html#ch11-1-fm2xml">Chapter 
                  11</A>. Breadth-first and depth-first search are important to 
                  many other graph algorithms because they offer good ways of 
                  exploring the structure of a graph in a systematic manner.</P>
                  <P class=docText>One significant difference between the 
                  algorithms of <A class=docLink 
                  href="ch11-1-fm2xml.html#ch11-1-fm2xml">Chapter 
                  11</A> and the ones in this chapter, however, is that the 
                  algorithms here work with <SPAN class=docEmphasis>weighted 
                  graphs</SPAN>. In a weighted graph<A name=IXT-16-314725></A><A 
                  name=IXT-16-314726></A> <A name=IXT-16-314727></A>, each edge 
                  is assigned a value, or <SPAN class=docEmphasis>weight</SPAN>, 
                  which is represented pictorially as a small number beside the 
                  edge. Although weights can mean many things, in general they 
                  represent a cost associated with traversing an edge. Weighted 
                  graphs and their algorithms have an enormous capacity to model 
                  real problems. <A class=docLink 
                  href="#ch16-93494">Example 
                  16.1</A> is a header for the graph algorithms presented in 
                  this chapter.</P>
                  <P class=docText>This chapter covers:</P><A 
                  name=IXT-16-314728></A><A name=IXT-16-314729></A><A 
                  name=IXT-16-314730></A><A name=IXT-16-314731></A><A 
                  name=IXT-16-314732></A>
                  <DL class=docList>
                    <DT><SPAN class=docPubcolor>Minimum spanning trees <A 
                    name=IXT-16-314728></A><A name=IXT-16-314729></A></SPAN>
                    <DD>
                    <P class=docList>Trees that serve as abstractions of many 
                    connectivity problems. A minimum spanning tree is a tree 
                    that connects all vertices in an undirected, weighted graph 
                    at a minimum cost.</P>
                    <DT><SPAN class=docPubcolor>Shortest paths <A 
                    name=IXT-16-314730></A><A name=IXT-16-314731></A></SPAN>
                    <DD>
                    <P class=docList>The result of solving various types of 
                    shortest-path problems. A shortest path is a path that 
                    connects one vertex to another in a directed, weighted graph 
                    at a minimum cost.</P>
                    <DT><SPAN class=docPubcolor>Traveling-salesman problem <A 
                    name=IXT-16-314732></A></SPAN>
                    <DD>
                    <P class=docList>A surprisingly difficult problem in which 
                    we look for the shortest tour that visits every vertex in a 
                    complete, undirected, weighted graph exactly once before 
                    returning to the first vertex.</P></DD></DL>
                  <P class=docText>Some applications of graph algorithms are<A 
                  name=IXT-16-314733></A>:</P><A name=IXT-16-314734></A><A 
                  name=IXT-16-314735></A><A name=IXT-16-314736></A><A 
                  name=IXT-16-314737></A><A name=IXT-16-314738></A><A 
                  name=IXT-16-314739></A><A name=IXT-16-314740></A><A 
                  name=IXT-16-314741></A><A name=IXT-16-314742></A>
                  <DL class=docList>
                    <DT><SPAN class=docPubcolor>Efficient pipelines <A 
                    name=IXT-16-314734></A></SPAN>
                    <DD>
                    <P class=docList>A practical concern in transporting water, 
                    oil, and other liquids. If distribution points for the 
                    pipeline are represented as vertices in a graph, and 
                    candidate connections between the points as edges are 
                    weighted by the cost to connect the points, a minimum 
                    spanning tree gives us the best way to lay a pipeline that 
                    connects all of the distribution points.</P>
                    <DT><SPAN class=docPubcolor>Routing tables (illustrated in 
                    this chapter)<A name=IXT-16-314735></A> </SPAN>
                    <DD>
                    <P class=docList>Tables used by routers to help direct data 
                    through an internet. The purpose of a router is to move data 
                    closer to its final destination. In one type of routing, 
                    routers periodically compute shortest paths to one another 
                    so each knows the best next step for sending data to certain 
                    destinations.</P>
                    <DT><SPAN class=docPubcolor>Delivery services<A 
                    name=IXT-16-314736></A> </SPAN>
                    <DD>
                    <P class=docList>Services that typically visit numerous 
                    locations to pick up and deliver packages. Solving the 
                    traveling-salesman problem can indicate the most efficient 
                    way for a vehicle operated by a service to visit every 
                    location exactly once before returning to its starting 
                    point.</P>
                    <DT><SPAN class=docPubcolor>Communication networks <A 
                    name=IXT-16-314737></A></SPAN>
                    <DD>
                    <P class=docList>Networks containing many different types of 
                    equipment including telephone lines, relay stations, and 
                    satellite systems, all of which must be located in an 
                    optimal manner. An optimal arrangement can be determined by 
                    computing a minimum spanning tree for the weighted graph 
                    that models the network.</P>
                    <DT><SPAN class=docPubcolor>Routing airplanes <A 
                    name=IXT-16-314738></A></SPAN>
                    <DD>
                    <P class=docList>An optimization problem particularly 
                    important to airlines and air traffic control agencies. 
                    Often airplanes cannot fly directly from one point to 
                    another. Instead, they weave their way through airway 
                    structures, or highways in the sky, considering winds, 
                    monetary charges for traversing airspace, and air traffic 
                    control restrictions. The best route between two points is 
                    the path with the minimum weight defined in terms of factors 
                    like these.</P>
                    <DT><SPAN class=docPubcolor><A name=IXT-16-314739></A>Closed 
                    transport systems </SPAN>
                    <DD>
                    <P class=docList>Systems in which railroad cars or conveyor 
                    carts repeatedly tour several points. Systems like these 
                    might be used to deliver parts in a factory or to move 
                    inventory in and out of a warehouse. Solving the 
                    traveling-salesman problem<A name=IXT-16-314740></A> can 
                    indicate the best way to construct the system.</P>
                    <DT><SPAN class=docPubcolor><A name=IXT-16-314741></A>Wiring 
                    circuit boards </SPAN>
                    <DD>
                    <P class=docList>An optimization problem in electronics 
                    manufacturing. Often it is necessary to make the pins of 
                    several components on a circuit board electrically 
                    equivalent by establishing a connection between them. If 
                    each pin is represented as a vertex in a graph, and 
                    candidate connections as edges weighted by the amount of 
                    wire required for the connection, a minimum spanning tree 
                    gives us the best way to connect the pins.</P>
                    <DT><SPAN class=docPubcolor><A 
                    name=IXT-16-314742></A>Traffic monitoring </SPAN>
                    <DD>
                    <P class=docList>The process of watching changes in traffic 
                    flow to determine the best route between two points in a 
                    city. To avoid excessive traffic delays, we can use a 
                    weighted graph to model the flow of traffic along roadways 
                    and look for the path from intersection to intersection with 
                    the minimum traffic.</P></DD></DL>
                  <H5 class=docExampleTitle><A name=ch16-93494></A>Example 16.1. 
                  Header for Graph Algorithms </H5><PRE>/*****************************************************************************
*                                                                            *
*  ------------------------------ graphalg.h ------------------------------  *
*                                                                            *
*****************************************************************************/

#ifndef GRAPHALG_H
#define GRAPHALG_H

#include "graph.h"
#include "list.h"

/*****************************************************************************
*                                                                            *
*  Define a structure for vertices in minimum spanning trees.                *
*                                                                            *
*****************************************************************************/

typedef struct MstVertex_ {

void               *data;
double             weight;

VertexColor        color;
double             key;

struct MstVertex_  *parent;

} MstVertex;

/*****************************************************************************
*                                                                            *
*  Define a structure for vertices in shortest-path problems.                *
*                                                                            *
*****************************************************************************/

typedef struct PathVertex_ {

void               *data;
double             weight;

VertexColor        color;
double             d;

struct PathVertex_ *parent;

} PathVertex;

/*****************************************************************************
*                                                                            *
*  Define a structure for vertices in traveling-salesman problems.           *
*                                                                            *
*****************************************************************************/

typedef struct TspVertex_ {

void               *data;

double             x,
                   y;

VertexColor        color;

} TspVertex;

/*****************************************************************************
*                                                                            *
*  --------------------------- Public Interface ---------------------------  *
*                                                                            *
*****************************************************************************/

int mst(Graph *graph, const MstVertex *start, List *span, int (*match)(const
   void *key1, const void *key2));

int shortest(Graph *graph, const PathVertex *start, List *paths, int (*match)
   (const void *key1, const void *key2));

int tsp(List *vertices, const <A name=IXT-16-314743></A>TspVertex *start, List *tour, int (*match)
   (const void *key1, const void *key2));

#endif<A name=IXTR3-169></A></PRE>
                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch15-34-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=absMiddle border=0></A> &nbsp; <A accessKey=1 
                  href="ch16-2-fm2xml.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=absMiddle border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
