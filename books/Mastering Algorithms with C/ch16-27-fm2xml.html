<HTML><HEAD><TITLE>ch16-27-fm2xml</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="image/style.css" type=text/css rel=STYLESHEET><LINK 
href="image/docsafari.css" type=text/css rel=STYLESHEET>

<META content="MSHTML 6.00.2800.1141" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=0 marginheight="0" marginwidth="0"><A 
name=toppage></A><SPAN class=v2></SPAN>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR vAlign=top>
    <TD align=middle>
      <TABLE width="95%">
        <TBODY>
        <TR>
          <TD class=v2 align=left>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top width=76 rowSpan=4><A 
                  ><IMG 
                  height=100 src="image/masteralgoc_xs.gif" width=76 
                  border=0></A></TD>
                <TD class=v2 vAlign=top><A class=t1 
                  >Mastering 
                  Algorithms with C</A><BR>By Kyle&nbsp;Loudon<BR>Slots : 
                1<BR></TD></TR>
              <TR>
                <TD class=v1><A class=v1 
                  href="table.html">Table 
                  of Contents</A></TD></TR>
              <TR>
                <TD></TD></TR>
              <TR>
                <TD class=t1 vAlign=bottom>Chapter 16.&nbsp; Graph 
                Algorithms</TD></TR></TBODY></TABLE>
            <HR SIZE=1>
            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=center>&nbsp; <A accessKey=2 
                  href="ch16-26-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=left border=0></A> &nbsp; <A  
href="table.html" align=center> Content </A>	<A accessKey=1                  href="ch16-48963.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=right border=0></A></TD></TR></TBODY></TABLE>
            <BR>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top><A name=ch16-27-fm2xml></A>
                  <H3 class=docSection1Title>16.11 Questions and Answers</H3>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> In the 
                  implementations presented for computing minimum spanning trees 
                  and shortest paths, weighted graphs are represented by storing 
                  the weights of edges in the graphs themselves. What is an 
                  alternative to this?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> For graphs 
                  containing edges weighted by factors that do not change 
                  frequently, the approach used in this chapter works well. 
                  However, a more general way to think of an edge's weight is as 
                  a function <SPAN class=docEmphasis>w</SPAN> (<SPAN 
                  class=docEmphasis>u</SPAN>, <SPAN class=docEmphasis>v</SPAN>), 
                  where <SPAN class=docEmphasis>u</SPAN> and <SPAN 
                  class=docEmphasis>v</SPAN> are the vertices that define the 
                  edge to which the weight function applies. To determine the 
                  weight of an edge, we simply call the function as needed. An 
                  advantage to this approach is that it lets us compute weights 
                  dynamically in applications where we expect weights to change 
                  frequently. On the other hand, a disadvantage is that if the 
                  weight function is complicated, it may be inefficient to 
                  compute over and over again.</P>
                  <P class=docText><A name=IXT-16-314796></A><SPAN 
                  class=docEmphBold>Q:</SPAN> When solving the 
                  traveling-salesman problem, we saw that computing an optimal 
                  tour is intractable except when the tour contains very few 
                  points. Thus, an approximation algorithm based on the 
                  nearest-neighbor heuristic was used. What is another way to 
                  approximate a traveling-salesman tour? What is the running 
                  time of the approach? How close does the approach come to an 
                  optimal tour?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Another 
                  approach to solving the traveling-salesman problem using an 
                  approximation algorithm is to compute a minimum spanning tree, 
                  then traverse the tree using a preorder traversal (see <A 
                  class=docLink 
                  href="ch09-1-fm2xml.html#ch09-1-fm2xml">Chapter 
                  9</A>). The running time of this approach is <SPAN 
                  class=docEmphasis>O (EV </SPAN><SUP>2</SUP>), assuming we use 
                  the <SPAN class=docEmphasis>mst</SPAN> operation provided in 
                  this chapter. As with the nearest-neighbor heuristic, this 
                  approach always produces a tour that has a length within a 
                  factor of 2 of the optimal tour length. To verify this, let 
                  <SPAN class=docEmphasis>TMST</SPAN> be the length of the 
                  minimum spanning tree, <SPAN class=docEmphasis>TAPP</SPAN> be 
                  the length of any approximate tour we compute, and <SPAN 
                  class=docEmphasis>TOPT</SPAN> be the length of the optimal 
                  tour. Since both the minimum spanning tree and the optimal 
                  tour span all vertices in the tree, and no span is shorter 
                  than the minimum spanning tree, <SPAN 
                  class=docEmphasis>TMST</SPAN> <IMG src="image/U2264.gif" 
                  border=0> <SPAN class=docEmphasis>TOPT</SPAN> . Also, <SPAN 
                  class=docEmphasis>TAPP</SPAN> <IMG src="image/U2264.gif" 
                  border=0> 2<SPAN class=docEmphasis>TMST</SPAN> because only in 
                  the worst case does an approximate tour trace every edge of 
                  the minimum spanning tree twice. Therefore, <SPAN 
                  class=docEmphasis>TAPP</SPAN> <IMG src="image/U2264.gif" 
                  border=0> 2<SPAN class=docEmphasis>TOPT</SPAN> . This is 
                  summarized as follows:</P>
                  <P class=docText><IMG height=21 alt=figs/equation.1602.gif 
                  src="image/equation.1602.gif" width=262 border=0></P>
                  <P class=docText><A name=IXT-16-314797></A><SPAN 
                  class=docEmphBold>Q:</SPAN> When computing a minimum spanning 
                  tree using Prim's algorithm, if we start the algorithm at a 
                  different vertex, is it possible to obtain a different tree 
                  for the same graph?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Especially 
                  in large graphs, as Prim's algorithm runs, it is not uncommon 
                  to find several white vertices with the same key value when 
                  looking for the one that is the smallest. In this case, we can 
                  select any of the choices since all are equally small. 
                  Depending on the vertex we select, we end up exploring a 
                  different set of edges incident from the vertex. Thus, we can 
                  get different edges in the minimum spanning tree. However, 
                  although the edges in the minimum spanning tree may vary, the 
                  total weight of the tree is always the same, which is the 
                  minimum for the graph.</P>
                  <P class=docText><A name=IXT-16-314798></A><A 
                  name=IXT-16-314799></A><SPAN class=docEmphBold>Q:</SPAN> 
                  Recall that when we solve the traveling-salesman problem, we 
                  use a graph whose structure is inspected for the hamiltonian 
                  cycle with the shortest length. Do all graphs contain 
                  hamiltonian cycles?</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Not all 
                  graphs contain hamiltonian cycles. This is easy to verify in a 
                  simple graph that is not connected, or in a directed acyclic 
                  graph. However, we never have to worry about this with 
                  complete graphs. Complete graphs contain many hamiltonian 
                  cycles. Determining whether a graph contains a hamiltonian 
                  cycle is another problem that, like the traveling-salesman 
                  problem, is NP-complete. In fact, many graph problems fall 
                  into this class of difficult problems.</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> The 
                  implementation of Prim's algorithm<A name=IXT-16-314800></A> 
                  presented in this chapter runs in <SPAN 
                  class=docEmphasis>O</SPAN>(<SPAN 
                  class=docEmphasis>EV</SPAN><SUP>2</SUP>) time. However, a 
                  better implementation runs in <SPAN 
                  class=docEmphasis>O</SPAN>(<SPAN class=docEmphasis>E</SPAN> 
                  <SPAN class=docEmphasis>lg</SPAN> <SPAN 
                  class=docEmphasis>V</SPAN>). How could we improve the 
                  implementation presented here to achieve this?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> The 
                  implementation of Prim's algorithm in this chapter runs in 
                  <SPAN class=docEmphasis>O (EV</SPAN> 2) time because for each 
                  vertex in the graph, we scan the list of vertices to determine 
                  which is white and has the minimum key value. We can improve 
                  this part of the algorithm dramatically by using a priority 
                  queue (see <A class=docLink 
                  href="ch10-1-fm2xml.html#ch10-1-fm2xml">Chapter 
                  10</A>). Recall that extracting the minimum value from a 
                  priority queue is an <SPAN class=docEmphasis>O (</SPAN>1) 
                  operation, and maintaining the heap property of the priority 
                  queue is <SPAN class=docEmphasis>O (</SPAN> lg <SPAN 
                  class=docEmphasis>n</SPAN>), where <SPAN 
                  class=docEmphasis>n</SPAN> is the number of elements. This 
                  results in a runtime complexity of <SPAN class=docEmphasis>O 
                  (E</SPAN> lg<SPAN class=docEmphasis> V</SPAN> ) for Prim's 
                  algorithm overall. However, the priority queue must support 
                  operations for decreasing values already in the queue and for 
                  locating a particular value efficiently so that it can be 
                  modified. Since the priority queue presented in <A 
                  class=docLink 
                  href="ch10-1-fm2xml.html#ch10-1-fm2xml">Chapter 
                  10</A> does not support these operations, Prim's algorithm was 
                  implemented here without this improvement.</P>
                  <P class=docText><SPAN class=docEmphBold>Q:</SPAN> Normally 
                  when we compute a minimum spanning tree, we do so for a 
                  connected graph. What happens if we try computing a minimum 
                  spanning tree for a graph that is not connected?</P>
                  <P class=docText><SPAN class=docEmphBold>A:</SPAN> Recall that 
                  a graph is connected if every vertex is reachable from each 
                  other by following some path. If we try to compute a minimum 
                  spanning tree for a graph that is not connected, we simply get 
                  a minimum spanning tree for the connected component in which 
                  the start vertex lies.</P>                  <UL></UL></TD></TR></TBODY></TABLE>
            <HR SIZE=1>

            <TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
              <TBODY>
              <TR>
              <TR>
                <TD class=v2 vAlign=top align=right>&nbsp; <A accessKey=2 
                  href="ch16-26-fm2xml.html"><IMG 
                  height=16 src="image/btn_prev.gif" width=56 
                  align=absMiddle border=0></A> &nbsp; <A accessKey=1 
                  href="ch16-48963.html"><IMG 
                  height=16 src="image/btn_next.gif" width=41 
                  align=absMiddle border=0></A></TD></TR></TBODY></TABLE>
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD vAlign=top align=right><A class=v1 
                  href="#toppage">Top</A></TD></TR></TBODY></TABLE>
            </TD></TR></TBODY></TABLE></TD>
</BODY></HTML>
