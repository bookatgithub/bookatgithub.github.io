<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 10.3.&nbsp; The Preg Functions</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-10-SECT-2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-10-SECT-4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="regex3-CHP-10-SECT-3"></a>
<H3 id="686700-979" class="docSection1Title">10.3. The Preg Functions</H3>
<p class="docText">This section covers each function in detail, starting with the most basic "does this regex match within this text?" function: <tt>preg_match</tt>.<a name="IDX-CHP-10-3451"></a> 
</P>
<dl class="docList">
<dt><BR><p><span class="docPubcolor"><span class="docEmphStrong">Usage</span></span></P></dt>
<dd>
<pre>
    preg_match( <span class="docEmphasis">pattern, subject[, matches[, flags[, offset]]]</span>)
</pre><br>

</dd>

<dt><br><P><span class="docPubcolor"><span class="docEmphStrong">Argument Summary</span></span></P></dt>
<dd>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><TR><TD class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">pattern</span></span></p></td><td class="docTableCell" align="left"><p class="docText">The pattern argument: a regex in delimiters, with optional modifiers (&#9758; 444).</P></TD></tr><tr><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">subject</span></span></p></TD><td class="docTableCell" align="left"><p class="docText">Target string in which to search.</p></TD></tr><tr><TD class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">matches</span></span></p></TD><td class="docTableCell" align="left"><p class="docText">Optional variable to receive match data.</p></td></tr><tr><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">flags</span></span></p></td><td class="docTableCell" align="left"><p class="docText">Optional flags that influence overall function behavior. There is only one flag allowed, PREG_OFFSET_CAPTURE (&#9758; 452).</p></td></tr><TR><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis">offset</span></P></td><td class="docTableCell" align="left"><p class="docText">Optional zero-based offset into <span class="docEmphasis">subject</span> at which the match attempt will begin (&#9758;453).</P></TD></TR></table></P><br>
</dd>

<dt><BR><p><span class="docPubcolor"><span class="docEmphStrong">Return Value</span></span></p></dt>
<dd><p class="docList">A true value is returned if a match is found, a false value if not.</P></dd>

<dt><BR><p><span class="docPubcolor"><span class="docEmphStrong">Discussion</span></span></P></dt>
<dd><p class="docList">At its simplest,</P>
<pre>
    preg_match($pattern, $subject)
</pre><br>

<p class="docList">returns true if <tt>$pattern</tt> can match anywhere within <tt>$subject</tt>. Here are some simple examples:</p>
<pre>
    if (preg_match('/\.(jpe?g|png|gif|bmp)$/i', $url)) {
    /* <span class="docEmphasis">URL seems to be of an image</span> */
    }

    -----------------------------------
    if (preg_match('{^https?://}', $uri)) {
    /* <span class="docEmphasis">URI is http or https</span> */
    }
    -----------------------------------
    if (preg_match('/\b MSIE \b/x', $_SERVER['HTTP_USER_AGENT'])) {
      /* <span class="docEmphasis">Browser is IE</span> */
    }
</pre><br>

</dd>
</dl>
<a name="regex3-CHP-10-SECT-3.1"></a>
<H4 id="title-IDA4E5HE" class="docSection2Title">10.3.1. </H4>
<a name="regex3-CHP-10-SECT-3.1.1"></a>
<h5 id="title-IDAEF5HE" class="docSection3Title">10.3.1.1. Capturing match data</h5>
<a name="IDX-CHP-10-3452"></a> 
<a name="IDX-CHP-10-3453"></a> 
<a name="IDX-CHP-10-3454"></a> 
<a name="IDX-CHP-10-3455"></a> 
<a name="IDX-CHP-10-3456"></a> 
<a name="IDX-CHP-10-3457"></a> 
<a name="IDX-CHP-10-3458"></a> 

<p class="docText">An optional third argument to <tt>preg_match</tt> is a variable to receive the resulting information about what matched where. You can use any variable you like, but the name <tt>$matches</tt><a name="IDX-CHP-10-3459"></a> 
<a name="IDX-CHP-10-3460"></a> 
 seems to be commonly used. In this book, when I discuss "<tt>$matches</tt>" outside the context of a specific example, I'm really talking about "whatever variable you put as the third argument to <tt>preg_match</tt>."</p>
<p class="docText">After a successful match, <tt>preg_match</tt> returns true and <tt>$matches</tt> is set as follows:</p>
<blockquote>
<p class="docText"><tt>$matches[0]</tt> is the entire text matched by the regex</P>
<p class="docText"><tt>$matches[1]</tt> is the text matched by the first set of capturing parentheses</p>
<p class="docText"><tt>$matches[2]</tt> is the text matched by the second set of capturing parentheses</p>
<p class="docText"><img src=images/U22EE.jpg border=0></P>
</blockquote>
<p class="docText">If you've used named captures, corresponding elements are included as well (there's an example of this in the next section).</p>
<p class="docText">Here's a simple example seen in <a class="docLink" href="regex3-CHP-5.html#regex3-CHP-5">Chapter 5</a> (&#9758;191):</p>
<pre>
    /* <span class="docEmphasis">Given a full path, isolate the filename</span> */
    if (preg_match('{ / ([^/]+) $}x', $WholePath, $matches))
    $FileName = $matches[1];
</pre><BR>

<p class="docText">It's safe to use <tt>$matches</tt> (or whatever variable you use for the captured data) only after <tt>preg_match</tt> returns a true value. False is returned if matching is not successful, or upon error (bad pattern or function flags, for example). While some errors do leave <tt>$matches</tt> cleared out to an empty array, some errors actually leave it with whatever value it had before, so you can't assume that <tt>$matches</tt> is valid after a call to <tt>preg_match</tt> simply because it's not empty.</p>
<p class="docText">Here's a somewhat more involved example with three sets of capturing parentheses:</P>
<pre>
    /* <span class="docEmphasis">Pluck the protocol, hostname,<a name="IDX-CHP-10-3461"></a> 
 and port number from a
 URL</span><a name="IDX-CHP-10-3462"></a> 
<a name="IDX-CHP-10-3463"></a> 
<a name="IDX-CHP-10-3464"></a> 
 */
    if (preg_match('{^(https?):// ([^/:]+) (?: :(\d+) )? }x', $url, $matches))
    {
       $proto = $matches[1];
       $host = $matches[2];
       $port = $matches[3] ? $matches[3] : ($proto == "http" ? 80 :443);

       print "Protocol: $proto\n";
       print "Host : $host\n";
       print "Port : $port\n";
    }
</pre><br>


<a name="regex3-CHP-10-SECT-3.1.2"></a>
<h5 id="title-IDAUJ5HE" class="docSection3Title">10.3.1.2. Trailing "non-participatory" elements stripped</h5>
<p class="docText">A set of parentheses that doesn't participate in the final match yields an empty string<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-10-FN-2">[<img src=images/U2020.jpg border=0>]</a></sup>in the corresponding <tt>$matches</tt> element. One caveat is that elements for <span class="docEmphasis">trailing non-participating captures</span> are not even included in <tt>$matches</tt>. In the previous example, if the <img src=images/U2308.jpg border=0><tt>(\d+)</tt><img src=images/U230B.jpg border=0> participated in the match, <tt>$matches[3]</tt> gets a number. If it didn't participate, <tt>$matches[3]</tt> doesn't even exist in the array.</p><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-10-FN-2">[<img src=images/U2020.jpg border=0>]</a></sup> If you expect a NULL value instead of an empty string, see the sidebar on page 454.</p></blockquote>

<a name="regex3-CHP-10-SECT-3.1.3"></a>
<h5 id="title-IDAPK5HE" class="docSection3Title">10.3.1.3. Named capture</h5>
<a name="IDX-CHP-10-3465"></a> 
<a name="IDX-CHP-10-3466"></a> 
<a name="IDX-CHP-10-3467"></a> 

<p class="docText">Let's look at the previous example rewritten using named capture (&#9758;138). It makes the regex a bit longer, but also makes the code more self-documenting:</p>
<pre>
    /* <span class="docEmphasis">Pluck the protocol, hostname, and port number from a URL</span>* /
    if (preg_match('{^(?P&lt;proto&gt; https? ) ://
                      (?P&lt;host&gt; [^/:]+ )
                  (?: : (?P&lt;port&gt; \d+ ) )? }x', $url, $matches))
    {
       $proto = $matches['proto'];
       $host = $matches['host'];
       $port = $matches['port'] ? $matches['port'] : ($proto== "http" ?80 : 443);
       print "Protocol: $proto\n";
       print "Host : $host\n";
       print "Port : $port\n";
    }
</pre><br>

<p class="docText">The clarity that named capture brings can obviate the need to copy out of <tt>$matches</tt> into separate variables. In such a case, it may make sense to use a variable name other than <tt>$matches</tt>, such as in this rewritten version:</p>
<pre>
    /* <span class="docEmphasis">Pluck the protocol, hostname, and port number from a URL</span> * /
    if (preg_match('{^(?P&lt;proto&gt; https? )://
                      (?P&lt;host&gt; [^/:]+ )
                (?: : (?P&lt;port&gt; \d+ ) )? }x', $url, $UrlInfo))
    {
      if (! $UrlInfo['port'])
         $UrlInfo['port'] = ($UrlInfo['proto'] == "http" ? 80 : 443);

      echo "Protocol: ", $UrlInfo['proto'], "\n";
      echo "Host : ", $UrlInfo['host'], "\n";
      echo "Port : ", $UrlInfo['port'], "\n";
    }
</pre><br>

<p class="docText">When using named capture, numbered captures are still inserted into $matches. For example, after matching against a <tt>$url</tt> of '<a class="docLink" target="_blank" href="http://regex.info/">http://regex.info/</a>',<a name="IDX-CHP-10-3468"></a> 
 the previous example's <tt>$UrlInfo</tt> contains:</p>
<pre>
    array
    (
        0       =&gt; 'http://regex.info',
        'proto' =&gt; 'http',
        1       =&gt; 'http',
        'host'  =&gt; 'regex.info',
        2       =&gt; 'regex.info'
    )
</pre><BR>

<p class="docText">This repetition is somewhat wasteful, but that's the price the current implementation makes you pay for the convenience and clarity of named captures. For clarity, I would not recommend using both named and numeric references to elements of <tt>$matches</tt>, except for <tt>$matches[0]</tt> as the overall match.</p>
<p class="docText">Note that the <tt>3</tt> and '<tt>port</tt>' enTRies in this example are not included because that set of capturing parentheses didn't participate in the match and was trailing (so the entries were stripped &#9758; 450).</p>
<p class="docText">By the way, although it's not currently an error to use a numeric name, e.g., <img src=images/U2308.jpg border=0><tt>(?P&lt;2&gt;&#8943;)</tt><img src=images/U230B.jpg border=0>, it's not at all recommended. PHP 4 and PHP 5 differ in how they treat this odd situation, neither of which being what anyone might expect. It's best to avoid numeric named-capture names altogether.</p>

<a name="regex3-CHP-10-SECT-3.1.4"></a>
<H5 id="title-IDA4M5HE" class="docSection3Title">10.3.1.4. Getting more details on the match: PREG_OFFSET_CAPTURE</H5>
<a name="IDX-CHP-10-3469"></a> 

<a name="IDX-CHP-10-3470"></a> 
<a name="IDX-CHP-10-3471"></a> 

<p class="docText">If <tt>preg_match's</tt> fourth argument, <span class="docEmphasis">flags</span>, is provided and contains PREG_OFFSET_CAPTURE (which is the only flag value allowed with <tt>preg_match</tt>) the values placed in <tt>$matches</tt> change from simple strings to subarrays of two elements each. The first element of each subarray is the matched text, while the second element is the offset from the start of the string where the matched text was actually matched (or <tt>-1</tt> if the parentheses didn't participate in the match).</P>
<p class="docText">The offsets reported are zero-based counts relative to the start of the string, even if a fifth-argument <tt>$offset</tt> is provided to have <tt>preg_match</tt> begin its match attempt from somewhere within the string. They are always reported in <span class="docEmphasis">bytes</span>, even when the <span class="docEmphStrong">u</span><a name="IDX-CHP-10-3472"></a> 
 pattern modifier was used (&#9758; 447).</P>
<p class="docText">As an example, consider plucking the HREF<a name="IDX-CHP-10-3473"></a> 
 attribute from an anchor tag. An HTML's attribute value may be presented within double quotes, single quotes, or without quotes entirely; such values are captured in the following regex's first, second, and third set of capturing parentheses, respectively:</p>
<pre>
    preg_match('/href \s*=\s*(?: "([^"]*)" |\'([^\']*)\' |([^\s\'"&gt;]+) )/ix',
            $tag,
            $matches,
            RPEG_OFFSET_CAPTURE);
</pre><BR>

<p class="docText">If <tt>$tag</tt> contains</p>
<pre>
    &lt;a name=bloglink href='http://regex.info/blog/' rel="nofollow"&gt;
</pre><br>

<p class="docText">the match succeeds and <tt>$matches</tt> is left containing:</P>
<pre>
    array
    (
        /* <span class="docEmphasis">Data for the overall match</span> */
        0 =&gt; array ( 0 =&gt; "href='http://regex.info/blog/'",
                        1 =&gt; 17 ),

        /* <span class="docEmphasis">Data for the first set of parentheses</span> */
        1 =&gt; array ( 0 =&gt; "",
                        1 =&gt; -1 ),
        /* <span class="docEmphasis">Data for the second set of parentheses</span> */
        2 =&gt; array ( 0 =&gt; "http://regex.info/blog/",
                        1 =&gt; 23 )
    )
</pre><BR>

<p class="docText"><tt>$matches[0][0]</tt> is the overall text matched by the regex, with <tt>$matches[0][1]</tt> being the byte offset into the subject string where that text begins.</p>
<p class="docText">For illustration, another way to get the same string as <tt>$matches[0][0]</tt> is:</P>
<pre>
    substr($tag, $matches[0][1], strlen($matches[0][0]));
</pre><BR>

<p class="docText"><tt>$matches[1][1]</tt> is <tt>-1</tt>, reflecting that the first set of capturing parentheses didn't participate in the match. The third set didn't either, but as mentioned earlier (&#9758; 450), data on trailing non-participating sets is not included in <tt>$matches</tt>.</p>

<a name="regex3-CHP-10-SECT-3.1.5"></a>
<h5 id="title-IDAGQ5HE" class="docSection3Title">10.3.1.5. The offset argument</h5>
<a name="IDX-CHP-10-3474"></a> 

<a name="IDX-CHP-10-3475"></a> 
<a name="IDX-CHP-10-3476"></a> 
<a name="IDX-CHP-10-3477"></a> 

<p class="docText">If an <span class="docEmphasis">offset</span> argument is given to <tt>preg_match</tt>, the engine starts the match attempt that many <span class="docEmphasis">bytes</span> into the subject (or, if the offset is negative, starts checking that far from the <span class="docEmphasis">end</span> of the subject). The default is equivalent to an offset of zero (that is, the match attempt starts at the beginning of the subject string).</P>
<p class="docText">Note that the offset must be given in bytes even if the <tt><span class="docEmphStrong">u</span></tt> pattern modifier is used. Using an incorrect offset (one that starts the engine "inside" a multibyte character) causes the match to silently fail.</P>
<p class="docText">Starting at a non-zero <span class="docEmphasis">offset</span> doesn't make that position the <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0>-matching "start of the string" to the regex engine  it's simply where, in the overall string, the regex engine begins its match attempt. Lookbehind, for example, can look to the left of the starting offset.</p>
<a name="IDX-CHP-10-3478"></a><dl class="docList">
<dt><br><p><span class="docPubcolor"><span class="docEmphStrong">Usage</span></span></p></dt>
<dd>
<pre>
    preg_match_all( <span class="docEmphasis">pattern, subject, matches [, flags [, offset</span> ]])
</pre><BR>

</dd>

<dt><br><p><span class="docPubcolor"><span class="docEmphStrong">Argument Summary</span></span></P></dt>
<dd>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><tr><TD class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">pattern</span></span></p></TD><td class="docTableCell" align="left"><p class="docText">The pattern argument: a regex in delimiters, with optional modifiers (&#9758; 444).</p></td></tr><tr><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">subject</span></span></p></td><td class="docTableCell" align="left"><p class="docText">Target string in which to search.</p></td></tr><TR><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">matches</span></span></P></td><td class="docTableCell" align="left"><p class="docText">Variable to receive match data (<span class="docEmphasis">required</span>).</P></TD></TR><TR><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">flags</span></span></P></td><td class="docTableCell" align="left"><p class="docText">Optional flags that influence overall function behavior:</P>
<pre>
   PREG_OFFSET_CAPTURE (&#9758; 456)
</pre><BR>

<p class="docText">and/or one of:</p>
<pre>
   PREG_PATTERN_ORDER (&#9758; 455)
   PREG_SET_ORDER (&#9758; 456)
</pre><BR>

</TD></tr><tr><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">offset</span></span></P></TD><td class="docTableCell" align="left"><p class="docText">Optional zero-based offset into <span class="docEmphasis">subject</span> at which the match attempt will begin (the same as <tt>preg_match's</tt> <span class="docEmphasis">offset</span> argument &#9758; 453).</p></td></tr></table></P><br>
</dd>

<dt><br><P><span class="docPubcolor"><span class="docEmphStrong">Return Value</span></span></p></dt>
<dd><p class="docList"><tt>preg_match_all</tt> returns the number of matches found.</p></dd>
</dl>
<a name="regex3-CHP-10-SIDEBAR-2"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">A Match of Nothing versus A Non-Match</h2>
<p class="docText"><tt>preg_match</tt> returns in <tt>$matches</tt> an empty string for sets of parentheses that don't participate in the match (with the ever-present caveat that <span class="docEmphasis">trailing</span> non-participatory sets don't show up in <tt>matches</tt> at all). Because the empty string is the same value that is returned for a successful match of nothing,<a name="IDX-CHP-10-3479"></a> 
 I'd prefer the value for non-participatory sets to be NULL.<a name="IDX-CHP-10-3480"></a> 
</p>
<p class="docText">With that in mind, here's a version of <tt>preg_match</tt> (I've called it <tt>reg_match</tt>)<a name="IDX-CHP-10-3481"></a> 
 that first uses the PREG_OFFSET_CAPTURE<a name="IDX-CHP-10-3482"></a> 
 flag to get detailed information about all parenthesized-subexpression results, and then uses that information to populate a <tt>$matches</tt> with NULL in appropriate spots:</p>
<pre>
    function reg_match($regex, $subject, &amp;$matches, $offset = 0)
    {
        $result = preg_match($regex, $subject, $matches,
                              PREG_OFFSET_CAPTURE, $offset);
        if ($result) {
            $f = create_function('&amp;$X', '$X = $X[1] &lt; 0 ? NULL : $X[0];');

            array_walk($matches, $f);
        }
        return $result;
    }
</pre><br>

<p class="docText">The result of this <tt>reg_match</tt> is exactly the same as a flagless call to the real <tt>preg_match</tt> except that elements that would be empty strings <span class="docEmphasis">because of nonparticipation in the match</span> with <tt>preg_match</tt> are NULL with <tt>reg_match</tt>.</p>
</td></tr></table></p><br>

<a name="regex3-CHP-10-SECT-3.1.6"></a>
<h5 id="title-IDAUY5HE" class="docSection3Title">10.3.1.6. Discussion</h5>
<a name="IDX-CHP-10-3483"></a> 
<a name="IDX-CHP-10-3484"></a> 

<p class="docText"><tt>preg_match_all</tt> is similar to <tt>preg_match</tt>, except that after finding the first match in a string, it continues along the string to find subsequent matches. Each match creates an array's worth of match data, so in the end, the <span class="docEmphasis">matches</span> variable is filled with an array of arrays, each inner array representing one match.</P>
<p class="docText">Here's a simple example:</p>
<pre>
    if (preg_match_all('/&lt;title&gt;/i', $html, $all_matches) &gt; 1)
      print "whoa, document has more than one &lt;title&gt;!\n";
</pre><BR>

<p class="docText">The third argument (the variable to be assigned the accumulated information about successful matches) is required by <tt>preg_match_all</tt>; it's not optional as it is with <tt>preg_match</tt>. That's why, even though it is otherwise unused in this example, it appears in the <tt>preg_match_all</tt> call.</p>

<a name="regex3-CHP-10-SECT-3.1.7"></a>
<h5 id="title-IDA1Z5HE" class="docSection3Title">10.3.1.7. Collecting match data</H5>
<a name="IDX-CHP-10-3485"></a> 

<p class="docText">Another differencethe primary differencefrom <tt>preg_match</tt> is the data placed in that third-argument variable. <tt>preg_match</tt> performs at most one match, so it places one match's worth of data into its <tt>matches</tt> variable. On the other hand, <tt>preg_match_all</tt> can match many times, so it may place the data from many such matches into its third-argument variable. To highlight the difference, I use <tt>$all_matches</tt><a name="IDX-CHP-10-3486"></a> 
<a name="IDX-CHP-10-3487"></a> 
 as the name of the variable with <tt>preg_match_all</tt>, rather than the <tt>$matches</tt> name commonly used with <tt>preg_match</tt>.</P>
<p class="docText">You can have <tt>preg_match_all</tt> arrange the data it places in <tt>$all_matches</tt> in one of two ways, selected by one of these mutually-exclusive fourth-argument flags: PREG_PATTERN_ORDER<a name="IDX-CHP-10-3488"></a> 
 or PREG_SET_ORDER.</P>
<p class="docText"><span class="docEmphasis"><span class="docEmphStrong">The default PREG_PATTERN_ORDER arrangement</span></span> Here's an example showing the PREG_PATTERN_ORDER arrangement (which I call "collated"more<a name="IDX-CHP-10-3489"></a> 
 on that in a bit). This is also the default arrangement if neither flag is specified, which is the case in this example:</P>
<pre>
    $subject = "
    Jack A. Smith
    Mary B. Miller";

    /* <span class="docEmphasis">No order-related flag implies PREG_PATTERN_ORDER</span> */
    preg_match_all ('/^(\w+) (\w\.) (\w+)$/m', $subject, $all_matches);
</pre><br>

<p class="docText">This leaves <tt>$all_matches</tt> with:</P>
<pre>
    array
    (
       /* <span class="docEmphasis">$all_matches[0] is an array of full matches</span> */
       0 =&gt; array ( 0 =&gt; "Jack A. Smith", /* <span class="docEmphasis">full text from first match</span> */
                       1 =&gt; "Mary B. Miller" /* <span class="docEmphasis">full text from second match</span> */ ),

       /* <span class="docEmphasis">$all_matches[1] is an array of strings captured by 1st set of parens</span> */
       1 =&gt; array ( 0 =&gt; "Jack", /* <span class="docEmphasis">first match's 1st capturing parens</span> */
                       1 =&gt; "Mary" /* <span class="docEmphasis">second match's 1st capturing parens</span> */ ),

       /* <span class="docEmphasis">$all_matches[2] is an array of strings captured by 2nd set of parens</span>*/
       2 =&gt; array ( 0 =&gt; "A.", /* <span class="docEmphasis">first match's 2nd capturing parens</span> */
                       1 =&gt; "B." /* <span class="docEmphasis">second match's 2nd capturing parens</span> */ ),

       /* <span class="docEmphasis">$all_matches[3] is an array of strings captured by 3rd set of parens</span>*/
       3 =&gt; array ( 0 =&gt; "Smith", /* <span class="docEmphasis">first match's 3rd capturing parens</span> */
                       1 =&gt; "Miller" /* <span class="docEmphasis">second match's 3rd capturing parens</span> */ )
    )
</pre><br>

<p class="docText">There were two matches, each of which resulted in one "overall match" string, and three substrings via capturing parentheses. I call this "collated" because all of the overall matches are grouped together in one array (in <tt>$all_matches[0]</tt>), all the strings captured by the first set of parentheses are grouped together in another array (<tt>$all_matches[1]</tt>), and so on.</p>
<p class="docText">By default, elements in <tt>$all_matches</tt> are collated, but you can change this with the PREG_SET_ORDER flag.</P>
<p class="docText"><span class="docEmphasis"><span class="docEmphStrong">The PREG_SET_ORDER<a name="IDX-CHP-10-3490"></a> 
 arrangement</span></span> The alternative data arrangement is "stacked,"<a name="IDX-CHP-10-3491"></a> 
 selected with the PREG_SET_ORDER flag. It keeps all the data from the first match in <tt>$all_matches[0]</tt>, all the data from the second match in <tt>$all_matches[1]</tt>, etc. It's exactly what you'd get if you walked the string yourself, pushing the <tt>$matches</tt> from each successful <tt>preg_match</tt> onto a <tt>$all_matches</tt> array.</P>
<p class="docText">Here's the PREG_SET_ORDER version of the previous example:</p>
<pre>
    $subject = "
    Jack A. Smith
    Mary B. Miller";

    preg_match_all('/^(\w+) (\w\.) (\w+)$/m', $subject, $all_matches, PREG_SET_ORDER);
</pre><BR>

<p class="docText">It leaves <tt>$all_matches</tt> with:</P>
<pre>
    array
    (
       /* <span class="docEmphasis">$all_matches[0] is just like a preg_match's entire $matches</span> */
       0 =&gt; array ( 0 =&gt; "Jack A. Smith",    /* <span class="docEmphasis">first match's full match</span> */
                       1 =&gt; "Jack",             /* <span class="docEmphasis">first match's 1st capturing
 parens */</span>
                       2 =&gt; "A.",               /* <span class="docEmphasis">first match's 2nd capturing
 parens</span> */
                       3 =&gt; "Smith"             /* <span class="docEmphasis">first match's 3rd capturing
 parens</span> */ ),
       /* <span class="docEmphasis">$all_matches[1] is also just like a preg_match's entire $matches</span> */
       1 =&gt; array ( 0 =&gt; "Mary B. Miller",   /* <span class="docEmphasis">second match's full match</span>*/
                       1 =&gt; "Mary",             /* <span class="docEmphasis">second match's 1st capturing
 parens</span> */
                       2 =&gt; "B.",               /* <span class="docEmphasis">second match's 2nd capturing
 parens</span> */
                       3 =&gt; "Miller"            /* <span class="docEmphasis">second match's 3rd capturing
 parens</span> */ ),
    )
</pre><br>

<p class="docText">Here's a short summary of the two arrangements:</p>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="3"><col><col><col></colgroup><thead><TR><th class="thead" scope="col" align="center"><p class="docText"><span class="docEmphStrong">Type</span></P></th><th class="thead" scope="col" align="center"><p class="docText"><span class="docEmphStrong">Flag</span></p></th><th class="thead" scope="col" align="center"><p class="docText"><span class="docEmphStrong">Description and Example</span></p></th></tr></thead><tr><TD class="docTableCell" align="left"><p class="docText">Collated</p></td><TD class="docTableCell" align="center"><p class="docText">PREG_PATTERN_ORDER</p></td><TD class="docTableCell" align="center"><p class="docText">Comparable parts from each match grouped. <tt>$all_matches[$paren_num][<span class="docEmphStrong">$match_num</span>]</tt></p></TD></tr><tr><td class="docTableCell" align="left"><p class="docText">Stacked</p></td><td class="docTableCell" align="center"><p class="docText">PREG_SET_ORDER</p></td><td class="docTableCell" align="center"><p class="docText">All per-match data kept together. <tt>$all_matches[<span class="docEmphStrong">$match_num</span>][$paren_num]</tt></p></td></tr></table></P><br>

<a name="regex3-CHP-10-SECT-3.1.8"></a>
<H5 id="title-IDAMCAIE" class="docSection3Title">10.3.1.8. <span class="docEmphasis"><tt>preg_match_all</tt> <span class="docEmphStrong">and the PREG_OFFSET_CAPTURE flag</span></span></h5>
<a name="IDX-CHP-10-3492"></a> 

<a name="IDX-CHP-10-3493"></a> 
<a name="IDX-CHP-10-3494"></a> 

<p class="docText">You can use PREG_OFFSET_CAPTURE with <tt>preg_match_all</tt> just as you can with <tt>preg_match</tt>, turning each leaf element of <tt>$all_matches</tt> into a two-element array (matched text plus byte offset). This means that <tt>$all_matches</tt> becomes an array of arrays of arrays, which is quite a mouthful. If you wish to use both PREG_OFFSET_CAPTURE and PREG_SET_ORDER, use a binary "or" operator to combine them:</p>
<pre>
    preg_match_all($pattern, $subject, $all_matches,
                   PREG_OFFSET_CAPTURE | PREG_SET_ORDER);
</pre><BR>


<a name="regex3-CHP-10-SECT-3.1.9"></a>
<H5 id="title-IDASDAIE" class="docSection3Title">10.3.1.9. <tt>preg_match_all</tt> <span class="docEmphStrong">with named capture</span></H5>
<a name="IDX-CHP-10-3495"></a> 

<a name="IDX-CHP-10-3496"></a> 
<a name="IDX-CHP-10-3497"></a> 
<a name="IDX-CHP-10-3498"></a> 
<a name="IDX-CHP-10-3499"></a> 
<a name="IDX-CHP-10-3500"></a> 
<a name="IDX-CHP-10-3501"></a> 

<p class="docText">If named captures are used, additional elements are added to <tt>$all_matches</tt> based on the names (just as with <tt>preg_match</tt> &#9758; 451). After</P>
<pre>
    $subject = "
    Jack A. Smith
    Mary B. Miller";

    /* <span class="docEmphasis">No order-related flag implies PREG_PATTERN_ORDER</span> */
    preg_match_all('/^(?P&lt;Given&gt;\w+) (?P&lt;Middle&gt;\w\.) (?P&lt;Family&gt;\w+)$/m',
                   $subject, $all_matches);
</pre><br>

<p class="docText"><tt>$all_matches</tt> is left with:</P>
<pre>
    array
    (
        0        =&gt; array ( 0 =&gt; "Jack A. Smith", 1 =&gt; "Mary B. Miller" ),
        "Given"  =&gt; array ( 0 =&gt; "Jack",  1 =&gt; <span class="docEmphStrong">"Mary"</span>   ),
        1        =&gt; array ( 0 =&gt; "Jack",  1 =&gt; <span class="docEmphStrong">"Mary"</span>   ),
        "Middle" =&gt; array ( 0 =&gt; "A.",    1 =&gt; <span class="docEmphStrong">"B."</span>  ),
        2        =&gt; array ( 0 =&gt; "A.",    1 =&gt; <span class="docEmphStrong">"B."</span>  ),
        "Family" =&gt; array ( 0 =&gt; "Smith", 1 =&gt; <span class="docEmphStrong">"Miller"</span> ),
        3        =&gt; array ( 0 =&gt; "Smith", 1 =&gt; <span class="docEmphStrong">"Miller"</span> )
    )
</pre><br>

<p class="docText">The same example with PREG_SET_ORDER:</p>
<pre>
    $subject = "
    Jack A. Smith
    Mary B. Miller";

    preg_match_all('/^(?P&lt;Given&gt;\w+) (?P&lt;Middle&gt;\w\.) (?P&lt;Family&gt;\w+)$/m',
                   $subject, $all_matches, <span class="docEmphStrong">PREG_SET_ORDER</span>);
</pre><BR>

<p class="docText">leaves <tt>$all_matches</tt> with:</P>
<pre>
    array
    (
        0 =&gt; array ( 0       =&gt; "Jack A. Smith",
                        Given   =&gt; "Jack",
                        1       =&gt; "Jack",
                        Middle  =&gt; "A.",
                        2       =&gt; "A.",
                        Family  =&gt; "Smith",
                        3       =&gt; "Smith" ),
        1 =&gt; array ( 0       =&gt; "Mary B. Miller",
                        Given   =&gt; "Mary",
                        1       =&gt; "Mary",
                        Middle  =&gt; "B.",
                        2       =&gt; "B.",
                        Family  =&gt; "Miller",
                        3       =&gt; "Miller" )
    )
</pre><br>

<p class="docText">Personally, I would prefer that the numerical keys be omitted when named capture is used because it would keep things cleaner and more efficient, but since they retained, you can simply ignore them if you don't need them.</P>
<a name="IDX-CHP-10-3502"></a><a name="IDX-CHP-10-3503"></a><a name="IDX-CHP-10-3504"></a><a name="IDX-CHP-10-3505"></a><a name="IDX-CHP-10-3506"></a><a name="IDX-CHP-10-3507"></a><a name="IDX-CHP-10-3508"></a><dl class="docList">
<dt><BR><p><span class="docPubcolor"><span class="docEmphStrong">Usage</span></span></p></dt>
<dd>
<pre>
    preg_eplace(<span class="docEmphasis">pattern, replacement, subject [, limit [, count</span> ]])
</pre><br>

</dd>

<dt><BR><P><span class="docPubcolor"><span class="docEmphStrong">Argument Summary</span></span></p></dt>
<dd>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><tr><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">pattern</span></span></P></td><td class="docTableCell" align="left"><p class="docText">The pattern argument: a regex in delimiters, with optional modifiers. <span class="docEmphasis">Pattern</span> may also be an array of pattern-argument strings.</P></td></tr><TR><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">replacement</span></span></P></td><td class="docTableCell" align="left"><p class="docText">The replacement string, or, if <span class="docEmphasis">pattern</span> is an array, <span class="docEmphasis">replacement</span> may be an array of replacement strings. The string (or strings) are interpreted as PHP<a name="IDX-CHP-10-3503"></a> 
<a name="IDX-CHP-10-3504"></a> 
 code if the <span class="docEmphStrong">e</span> pattern-modifier is used (&#9758; 459).</p></td></tr><tr><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">subject</span></span></p></td><td class="docTableCell" align="left"><p class="docText">Target string in which to search. It may also be an array of strings (each processed in turn).</p></td></TR><tr><TD class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">limit</span></span></p></td><TD class="docTableCell" align="left"><p class="docText">Optional integer to limit the number of replacements (&#9758; 460).</P></TD></TR><tr><TD class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">count</span></span></p></td><TD class="docTableCell" align="left"><p class="docText">Optional variable to receive the count of replacements actually done (PHP 5 only &#9758; 460).</P></td></TR></table></P><br>
</dd>

<dt><br><p><span class="docPubcolor"><span class="docEmphStrong">Return Value</span></span></P></dt>
<dd><p class="docList">If <span class="docEmphasis">subject</span> is a single string, the return value is also a string (a possibly changed copy of <span class="docEmphasis">subject</span>). If <span class="docEmphasis">subject</span> is an array of strings, the return value is also an array (which contains possibly changed elements of <span class="docEmphasis">subject</span>).</P></dd>

<dt><br><p><span class="docPubcolor"><span class="docEmphStrong">Discussion</span></span></p></dt>
<dd><p class="docList">PHP offers a number of ways to search and replace<a name="IDX-CHP-10-3505"></a> 
 on text. If the search part can be described as simple strings, <tt>str_replace</tt><a name="IDX-CHP-10-3506"></a> 
<a name="IDX-CHP-10-3507"></a> 
 or <tt>str_ireplace</tt> are the most appropriate, but if the content to be searched is more complicated, <tt>preg_replace</tt>is the right tool.</p>
<p class="docList">As a simple example, let's visit a common web experience: entering a credit card or phone number in a form. How many times have you seen "no spaces or dashes" instructions in this situation? Doesn't it seem lazy to place such a silly (but admittedly small) burden on the user when it would be so easy for the programmer to allow the user to enter the information naturally, <span class="docEmphasis">with</span> spaces, dashes, or other punctuation?<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-10-FN-3">[<img src=images/U2020.jpg border=0>]</a></sup><a name="IDX-CHP-10-3508"></a> 
 After all, it's trivial to "clean up" such input:</P><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-10-FN-3">[<img src=images/U2020.jpg border=0>]</a></sup> Apparently, the web is full of lazy programmers, as my brother's <span class="docEmphasis">"No Dashes Or Spaces" Hall of Shame</span> sadly attests to. You can see it at <a class="docLink" target="_blank" href="http://www.unixwiz.net/ndos-shame.html">http://www.unixwiz.net/ndos-shame.html</a>.</p></blockquote>
<pre>
    $card_number = preg_replace('/\D+/', '', $card_number);
    /* <span class="docEmphasis">$card_number now has only digits, or is empty</span> */
</pre><br>

<p class="docList">This uses <tt>preg_replace</tt> to remove nondigits. Described more literally, it uses <tt>preg_replace</tt> to make a copy of <tt>$card_number</tt>, replacing any sequences of non-digits with nothingness (an empty string), and assign that possibly changed copy back into <tt>$card_number</tt>.</P></dd>
</dl>

<a name="regex3-CHP-10-SECT-3.1.10"></a>
<h5 id="title-IDAQOAIE" class="docSection3Title">10.3.1.10. Basic one-string, one-pattern, one-replacement <tt>preg_replace</tt></h5>
<a name="IDX-CHP-10-3509"></a> 

<p class="docText">The first three arguments (<span class="docEmphasis">pattern, replacement</span>, and <span class="docEmphasis">subject</span>) can be either strings or arrays of strings. In the common case where all three are simply strings, <tt>preg_replace</tt> makes a copy of the subject, finds the first match of the pattern within it, replaces the text matched with a copy of the replacement, and then continues along doing the same with subsequent matches in the subject until it reaches the end of the string.</P>
<p class="docText">Within the replacement string, '<tt>$0</tt>' refers to the full text of the match at hand, '<tt>$1</tt>' refers to the text matched within the first set of capturing parentheses, '<tt>$2</tt>' the second set, and so on. Note that these dollar-sign/number sequences are not references to variables as they are in some languages, but simply sequences that <tt>preg_replace</tt> recognizes for special treatment. You can also use a form with braces around the number, as with '<tt>${0}</tt>'<a name="IDX-CHP-10-3510"></a> 
 and '<tt>${1}</tt>', which is necessary to disambiguate the reference when a number immediately follows it.</p>
<p class="docText">Here's a simple example that wraps HTML<a name="IDX-CHP-10-3511"></a> 
 bold tags around words in all caps:</P>
<pre>
    $html = preg_replace('/\b[A-Z]{2,}\b/', '&lt;b&gt;$0&lt;/b&gt;', $html);
</pre><br>

<p class="docText">If the <span class="docEmphStrong">e</span><a name="IDX-CHP-10-3512"></a> 
 pattern modifier is used (it is allowed only with <tt>preg_replace</tt>), the replacement string is taken as PHP<a name="IDX-CHP-10-3513"></a> 
<a name="IDX-CHP-10-3514"></a> 
<a name="IDX-CHP-10-3515"></a> 
 code and executed after each match, the result of which is used as the replacement string. Here's an extension of the previous example that lowercases the word being wrapped in bold tags:</p>
<pre>
    $html = preg_replace('/\b[A-Z]{2,}\b/e',
                         'strtolower("&lt;b&gt;$0&lt;/b&gt;")',
                         $html);
</pre><br>

<p class="docText">If, for example, the text matched by the regex is '<tt>HEY</tt>', that word is substituted in the replacement string for the '$0' capture reference. This results in the string '<tt>strtolower("&lt;b&gt;HEY&lt;/b&gt;")</tt>', which is then executed as PHP code, yielding, finally, '<tt>&lt;b&gt;hey&lt;/b&gt;</tt>' as the replacement text.</p>
<p class="docText">With the <span class="docEmphStrong">e</span> pattern modifier, capture references in the replacement string are interpolated in a special manner: quotation marks (single or double) within interpolated values are escaped. Without this special processing, a quote within the interpolated value could render the resulting string invalid as PHP code.</p>
<p class="docText">If using the <span class="docEmphStrong">e</span> pattern modifier and making references to external variables in the replacement string, it's best to use singlequotes for the replacement string literal so the variables are note interpolated at the wrong time.</p>
<p class="docText">This example is similar to PHP's built in <tt>htmlspecialchars()</tt> function:</p>
<pre>
    $replacement = array ('&amp;' =&gt; '&amp;amp;',
                          '&lt;'  =&gt; '&amp;lt;',
                          '&gt;'  =&gt; '&amp;gt;',
                          '"'     =&gt; '&amp;quot;');

    $new_subject = preg_replace('/[&amp;&lt;"&gt;]/eS', '$replacement["$0"]', $subject);
</pre><br>

<p class="docText">It's important in this example for <span class="docEmphasis">replacement</span> to be a single-quoted string, to hide the <tt>$replacement</tt> variable interpolation until it is processed by <tt>preg_replace</tt> as PHP code. Were it a double-quoted string, it would be processed by PHP <span class="docEmphasis">before</span> being passed to <tt>preg_replace</tt>.</p>
<p class="docText">The <span class="docEmphStrong">S</span><a name="IDX-CHP-10-3516"></a> 
 pattern modifier is used for extra efficiency (&#9758; 478).</p>
<p class="docText">If a fourth argument, <span class="docEmphasis">limit</span>, is passed to <tt>preg_replace</tt>, it dictates the maximum number of replacements that will be made (on a per-regex, per-string basis; see the next section). The default is <tt>-1</tt>, which means "no limit."</p>
<p class="docText">If a fifth argument, <span class="docEmphasis">count</span>, is passed (not allowed with PHP 4), it's a variable into which <tt>preg_replace</tt> writes the number of replacements actually done. If you want to know only whether replacements were done, you can compare the original subject with the result, but it's much more efficient to check the <span class="docEmphasis">count</span> argument.</p>

<a name="regex3-CHP-10-SECT-3.1.11"></a>
<H5 id="title-IDAMTAIE" class="docSection3Title">10.3.1.11. Multiple subjects, patterns, and replacements</h5>
<a name="IDX-CHP-10-3517"></a> 
<a name="IDX-CHP-10-3518"></a> 
<a name="IDX-CHP-10-3519"></a> 
<a name="IDX-CHP-10-3520"></a> 
<a name="IDX-CHP-10-3521"></a> 
<a name="IDX-CHP-10-3522"></a> 

<p class="docText">As mentioned in the previous section, the <span class="docEmphasis">subject</span> argument is often just a simple string, which is what we've seen in all the examples so far. However, the subject may also be an array of strings, in which case the search and replace is conducted on each string in turn. The return value is then the array of resulting strings.</P>
<p class="docText">Independent of whether the subject is a string or an array of strings, the <span class="docEmphasis">pattern</span> and <span class="docEmphasis">replacement</span> arguments may also be arrays of strings. Here are the pairings and their meanings:</p>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="3"><col><col><col></colgroup><thead><TR><th class="thead" scope="col" align="center"><p class="docText"><span class="docEmphasis">Pattern</span></P></th><th class="thead" scope="col" align="center"><p class="docText"><span class="docEmphasis">Replacement</span></P></th><th class="thead" scope="col" align="center"><p class="docText"><span class="docEmphasis">Action</span></P></th></tr></thead><TR><td class="docTableCell" align="center"><p class="docText">string</p></TD><TD class="docTableCell" align="center"><p class="docText">string</p></TD><TD class="docTableCell" align="left"><p class="docText">Apply pattern, replacing each match with replacement</p></td></tr><TR><TD class="docTableCell" align="center"><p class="docText">array</p></td><td class="docTableCell" align="center"><p class="docText">string</p></TD><td class="docTableCell" align="left"><p class="docText">Apply each pattern in turn, replacing each match with the replacement</p></TD></tr><tr><TD class="docTableCell" align="center"><p class="docText">array</p></TD><td class="docTableCell" align="center"><p class="docText">array</p></td><td class="docTableCell" align="left"><p class="docText">Apply each pattern in turn, replacing matches with the pattern's corresponding replacement</p></td></tr><tr><td class="docTableCell" align="center"><p class="docText">string</p></td><td class="docTableCell" align="center"><p class="docText">array</P></td><TD class="docTableCell" align="left"><p class="docText">(not allowed)</p></td></TR></table></P><BR>
<p class="docText">Again, if the <span class="docEmphasis">subject</span> argument is an array, the action is performed on each subject element in turn, and the return value is an array of strings as well.</P>
<p class="docText">Note that the <span class="docEmphasis">limit</span>argument is per pattern, per subject. It's not an overall limit across patterns or subject strings. The <tt>$count</tt> that is returned, however, <span class="docEmphasis">is</span> the overall total for all patterns and subject strings.</p>
<p class="docText">Here's an example of <tt>preg_replace</tt> where both the <span class="docEmphasis">pattern</span> and the <span class="docEmphasis">replacement</span> are arrays. Its result is similar to PHP's built-in <tt>htmlspecialchars()</tt><a name="IDX-CHP-10-3523"></a> 
 function, which "cooks" text so that it's safe to use within HTML:<a name="IDX-CHP-10-3524"></a> 
</P>
<pre>
    $cooked = preg_replace(
       /* <span class="docEmphasis">Match with these</span>... */ array('/&amp;/', '/&lt;/', '/&gt;/', '/"/' ),
       /* <span class="docEmphasis">Replace with these</span>... */ array('&amp;amp;', '&amp;lt;', '&amp;gt;', '&amp;quot;'),
       /* ...<span class="docEmphasis">in a copy of this</span> */ $text
    );
</pre><br>

<p class="docText">When this snippet is given <tt>$text</tt> such as:</p>
<pre>
    AT&amp;T --&gt; "baby Bells"
</pre><BR>

<p class="docText">it sets <tt>$cooked</tt> to:</P>
<pre>
    AT&amp;amp;T --&amp;gt; &amp;quot;baby Bells&amp;quot;
</pre><br>

<p class="docText">You can, of course, build the argument arrays ahead of time; this version works identically (and produces identical results):</P>
<pre>
    $patterns = array('/&amp;/', '/&lt;/', '/&gt;/', '/"/' );
    $replacements = array('&amp;amp;', '&amp;lt;', '&amp;gt;', '&amp;quot;');

    $cooked = preg_replace($patterns, $replacements, $text);
</pre><BR>

<p class="docText">It's convenient that <tt>preg_replace</tt> accepts array arguments (it saves you from having to write loops to iterate through patterns and subject strings yourself), but it doesn't actually add any extra functionality. Patterns are not processed "in parallel," for example. However, the built-in processing is more efficient than writing the loops yourself in PHP-level code, and is likely more readable as well.</p>
<p class="docText">To illustrate, consider an example in which all arguments are arrays:</p>
<pre>
    $result_array = preg_replace($regex_array, $replace_array, $subject_array);
</pre><br>

<p class="docText">This is comparable to:</P>
<pre>
    $result_array = array();
    foreach ($subject_array as $subject)
    {
       reset($regex_array); // <span class="docEmphasis">Prepare to walk through these two arrays</span>
       reset($replace_array); // <span class="docEmphasis">in their internal array orders</span>.
       while (list(,$regex) = each($regex_array))
       {
           list(,$replacement) = each($replace_array);
           // <span class="docEmphasis">The regex and replacemnet are ready, so apply to the subject</span> ...
           $subject = preg_replace($regex, $replacement, $subject);
       }
       // <span class="docEmphasis">Having now been processed by all the regexes, we're done with this
 subject</span>...
       $result_array[] = $subject; // ...<span class="docEmphasis">so append to the results array</span>.
    }
</pre><BR>

<p class="docText"><span class="docEmphasis"><span class="docEmphStrong">Ordering of array arguments</span></span> When <span class="docEmphasis">pattern</span> and <span class="docEmphasis">replacement</span> are both arrays, they are paired via the arrays' internal order, which is generally the order the elements were added to the arrays (the first element added to the <span class="docEmphasis">pattern</span> array is paired with the first element added to the <span class="docEmphasis">replacement</span> array, and so forth). This means that the ordering works properly with "literal arrays" created and populated with <tt>array()</tt>, as with this example:</p>
<pre>
    $subject = "this has 7 words and 31 letters";

    $result = preg_replace(array('/[a-z]+/', '/\d+/'),
                           array('word&lt;$0&gt;', 'num&lt;$0&gt;'),
                           $subject);
    print "result: $result\n";
</pre><br>

<p class="docText">The <img src=images/U2308.jpg border=0><tt>[a-z]+</tt><img src=images/U230B.jpg border=0> is paired with '<tt>word&lt;$0&gt;</tt>', and then <img src=images/U2308.jpg border=0><tt>\d+</tt><img src=images/U230B.jpg border=0> is paired with '<tt>num&lt;$0&gt;</tt>', all of which results in:</p>
<pre>
    result: word&lt;this&gt; word&lt;has&gt; num&lt;7&gt; word&lt;words&gt; word&lt;and&gt; num&lt;31&gt; word&lt;letters&gt;
</pre><br>

<p class="docText">On the other hand, if the <span class="docEmphasis">pattern</span> or <span class="docEmphasis">replacement</span> arrays are built piecemeal over time, the arrays' internal order may become different from the apparent order of the keys (that is, from the ordering implied by the numeric value of the keys). That's why the snippet on the previous page that mimics <tt>preg_replace</tt> with array arguments is careful to use <tt>each</tt> to walk the arrays in the internal array order,<a name="IDX-CHP-10-3525"></a> 
<a name="IDX-CHP-10-3526"></a> 
 whatever their keys might be.</P>
<p class="docText">If your <span class="docEmphasis">pattern</span> or <span class="docEmphasis">replacement</span> arrays might have internal ordering different from the apparent ordering by which you want to pair them, you may want to use the <tt>ksort()</tt> function to ensure that each array's actual and apparent orderings are the same.</p>
<p class="docText">When both <span class="docEmphasis">pattern</span> and <span class="docEmphasis">replacement</span> are arrays, but there are more pattern elements than replacement elements, an empty string is used as the replacement string for patterns without a corresponding element in the replacement array.</p>
<p class="docText">The order in which the elements of <span class="docEmphasis">pattern</span> are arranged can matter significantly, because they are processed in the order found in the array. What, for example, would be the result if the element order of this example's <span class="docEmphasis">pattern</span> (and, in conjunction, its <span class="docEmphasis">replacement</span> array) was reversed? That is, what's the result of the following?</P>
<pre>
    $subject = "this has 7 words and 31 letters";
    $result = preg_replace(array('/\d+/', '/[a-z]+/'),
                           array('num&lt;\0&gt;', 'word&lt;\0&gt;'),
                           $subject);
    print "result: $result\n";
</pre><br>

<p class="docText"><a class="docLink" href="#regex3-CHP-10-SIDEBAR-3">&#10070;</a> Flip the page to check your answer.</p>
<a name="IDX-CHP-10-3527"></a><a name="IDX-CHP-10-3528"></a><a name="IDX-CHP-10-3529"></a><dl class="docList">
<dt><BR><p><span class="docPubcolor"><span class="docEmphStrong">Usage</span></span></P></dt>
<dd>
<pre>
    preg_replace_callback(<span class="docEmphasis">pattern, callback,<a name="IDX-CHP-10-3528"></a> 
 subject [, limit [,
 count</span> ]])
</pre><br>

</dd>

<dt><br><p><span class="docPubcolor"><span class="docEmphStrong">Argument Summary</span></span></p></dt>
<dd>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><tr><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">pattern</span></span></p></td><td class="docTableCell" align="left"><p class="docText">The pattern argument: a regex in delimiters, with optional modifiers .(&#9758; 444). It may also be an array of such strings.</p></td></TR><tr><TD class="docTableCell" align="left"><p class="docText"><span class="docEmphasis">callback</span></p></td><TD class="docTableCell" align="left"><p class="docText">A PHP callback, to be invoked upon each successful match to generate the replacement text.</P></TD></TR><tr><TD class="docTableCell" align="left"><p class="docText"><span class="docEmphasis">subject</span></p></td><TD class="docTableCell" align="left"><p class="docText">Target string in which to search. It may also be an array of strings (each processed in turn).</P></td></TR><TR><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis">limit</span></p></td><TD class="docTableCell" align="left"><p class="docText">Optional limit on number of replacements (&#9758; 460).</P></td></tr><tr><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis">count</span></P></td><td class="docTableCell" align="left"><p class="docText">Optional variable to receive the count of replacements actually done (since PHP 5.1.0 only &#9758; 460).</P></td></tr></table></P><br>
</dd>

<dt><BR><p><span class="docPubcolor"><span class="docEmphStrong">Return Value</span></span></p></dt>
<dd><p class="docList">If <span class="docEmphasis">subject</span> is a single string, the return value is a string (a possibly changed copy of <span class="docEmphasis">subject</span>). If <span class="docEmphasis">subject</span> is an array of strings, the return value is an array (of possibly changed elements of <span class="docEmphasis">subject</span>).</p></dd>

<dt><br><p><span class="docPubcolor"><span class="docEmphStrong">Discussion</span></span></p></dt>
<dd><p class="docList"><tt>preg_replace_callback</tt> is similar to <tt>preg_replace</tt>, except that the replacement argument is a PHP callback rather than a string or array of strings. It's similar to <tt>preg_replace</tt> with the <tt><span class="docEmphStrong">e</span></tt> pattern modifier (&#9758; 459), but more efficient (and likely easier to read, for that matter, when the replacement expression is complicated).</p>
<p class="docList">See the PHP documentation for more on <span class="docEmphasis">callbacks</span>, but in short, a PHP callback refers (in one of several ways) to a function that is invoked in a predetermined situation, with predetermined arguments, to produce a value for a predetermined use. In the case of <tt>preg_replace_callback</tt>, the invocation happens with each successful regex match, with one predetermined argument (the match's <tt>$matches</tt> array). The function's return value is used by <tt>preg_replace_callback</tt> as the replacement text.</p>
<p class="docList">A callback can refer to its function in one of three ways. In one, the callback is simply a string containing the name of a function to be called. In another, the callback is an anonymous function produced by PHP's <tt>create_function</tt><a name="IDX-CHP-10-3529"></a> 
 builtin. We'll see examples using both these callback forms soon. The third callback form, which is not otherwise mentioned in this book, is designed for object-oriented programming, and consists of a two-element array (a class name and a method within it to invoke).</p></dd>
</dl>
<a name="regex3-CHP-10-SIDEBAR-3"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Quiz Answer</h2>
<p class="docText">&#10070; <span class="docEmphasis">Answer to the question on page 462</span>.</P>
<p class="docText">The code in question (on page 462) produces the following (broken across two lines to fit the page):</p>
<pre>
    result: word&lt;this&gt; word&lt;has&gt; <span class="docEmphStrong">word&lt;num&gt;&lt;7&gt;</span> word&lt;words&gt;
    word&lt;and&gt; <span class="docEmphStrong">word&lt;num&gt;&lt;31&gt;</span> word&lt;letters&gt;
</pre><br>

<p class="docText">If the two bold sections are a surprise, remember that a <tt>preg_replace</tt> with multiple regexes (one with a <span class="docEmphasis">pattern</span> array) does not process the patterns "in parallel," but rather, each in turn.</P>
<p class="docText">In this example, the first <span class="docEmphasis">pattern/replacement</span> combination adds two <tt>num&lt;&#8943;&gt;</tt> sequences to the subject textthose '<tt>num</tt>' then being picked up by the next <span class="docEmphasis">pattern</span> in the sequence. Each '<tt>num</tt>' then becomes '<tt>word&lt;num&gt;</tt>', resulting in the perhaps unexpected output shown above.</P>
<p class="docText">The moral of this story is to be particularly careful with the ordering of a multiple-<span class="docEmphasis">pattern</span> <tt>preg_replace</tt>.</P>
</TD></tr></table></P><br>
<p class="docText">Here's the example from page 460 rewritten using <tt>preg_replace_callback</tt> and a support function. The callback is a string containing the support function's name:</p>
<pre>
    $replacement = array ('&amp;' =&gt; '&amp;amp;',
                          '&lt;' =&gt; '&amp;lt;',
                          '&gt;' =&gt; '&amp;gt;',
                          '"' =&gt; '&amp;quot;');
    /*
     * <span class="docEmphasis">Given a $matches from a successful match in which $matches[0] is the text
 character in need of</span>
     * <span class="docEmphasis">conversion to HTML,<a name="IDX-CHP-10-3530"></a> 
 return the appropriate HTML string.
 Because this function is used under only</span>
     * <span class="docEmphasis">carefully controlled conditions, we feel safe blindly using the arguments</span>.
    */
    function text2html_callback($matches)
    {
        global $replacement;
        return $replacement[$matches[0]];
    }
    $new_subject = preg_replace_callback('/[&amp;&lt;"&gt;]/S', /* <span class="docEmphasis">pattern</span> */
                                         "text2html_callback", /* <span class="docEmphasis">callback</span> */
                                         $subject);
</pre><BR>

<p class="docText">When called with a <tt>$subject</tt> of, say,</P>
<pre>
    "AT&amp;T" sounds like "ATNT"
</pre><br>

<p class="docText">the variable <tt>$new_subject</tt> is left with:</P>
<pre>
    &amp;quot;AT&amp;amp;T&amp;quot; sounds like &amp;quot;ATNT&amp;quot;
</pre><BR>

<p class="docText">This example's <tt>text2html_callback</tt> is a normal PHP function designed to be used as a callback for <tt>preg_replace_callback</tt>, which calls its callback with one argument, the <tt>$matches</tt> array (which, of course, you're free to name as you like when creating the function, but I follow convention by using <tt>$matches</tt>).</p>
<p class="docText">For completeness, I'd like to show this example using an anonymous function (created with PHP's<a name="IDX-CHP-10-3531"></a> 
 built-in <tt>create_function</tt><a name="IDX-CHP-10-3532"></a> 
 function). This version assumes the same <tt>$replacement</tt> variable as above. The function's content is exactly the same, but this time it's not a <span class="docEmphasis">named</span> function, and it can be called only from within <tt>preg_replace_callback</tt>:</p>
<pre>
    $new_subject = preg_replace_callback('/[&amp;&lt;"&gt;]/S',
                     create_function('$matches',
                                     'global $replacement;
                                     return $replacement[$matches[0]];'),
                     $subject);
</pre><br>


<a name="regex3-CHP-10-SECT-3.1.12"></a>
<H5 id="title-IDAEHBIE" class="docSection3Title">10.3.1.12. A callback versus the e pattern modifier</H5>
<a name="IDX-CHP-10-3533"></a> 

<a name="IDX-CHP-10-3534"></a> 

<a name="IDX-CHP-10-3535"></a> 

<p class="docText">For simple tasks, a <span class="docEmphStrong">e</span> pattern modifier with <tt>preg_replace</tt> may be more readable than <tt>preg_replace_callback</tt>. However, when efficiency is important, remember that the <span class="docEmphStrong">e</span> pattern modifier causes the replacement argument to be reinterpreted as PHP code, from scratch, upon each successful match. That could create a lot of overhead that <tt>preg_replace_callback</tt> does not entail (with a callback, the PHP code is evaluated only once).</p>
<a name="IDX-CHP-10-3536"></a><dl class="docList">
<dt><br><p><span class="docPubcolor"><span class="docEmphStrong">Usage</span></span></p></dt>
<dd>
<pre>
    preg_split( <span class="docEmphasis">pattern, subject [, limit, [ flags</span> ]])
</pre><BR>

</dd>

<dt><br><p><span class="docPubcolor"><span class="docEmphStrong">Argument Summary</span></span></P></dt>
<dd>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><tr><TD class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">pattern</span></span></p></TD><td class="docTableCell" align="left"><p class="docText">The pattern argument: a regex in delimiters, with optional modifiers .(&#9758; 444).</p></td></tr><tr><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">subject</span></span></p></td><td class="docTableCell" align="left"><p class="docText">Target string to partition.</p></td></tr><TR><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">limit</span></span></P></td><td class="docTableCell" align="left"><p class="docText">Optional integral value used to limit the number of elements the <span class="docEmphasis">subject</span> is split into.</P></TD></TR><TR><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">flags</span></span></P></td><td class="docTableCell" align="left"><p class="docText">Optional flags that influence overall behavior; any combination of:</P>
<pre>
   PREG_SPLIT_NO_EMPTY
   PREG_SPLIT_DELIM_CAPTURE
   PREG_SPLIT_OFFSET_CAPTURE
</pre><BR>

<p class="docText">These are discussed starting on page 468. Combine multiple flags with a binary "or" operator (as in the example on page 456)</p></TD></TR></table></p><br>
</dd>

<dt><br><P><span class="docPubcolor"><span class="docEmphStrong">Return Value</span></span></P></dt>
<dd><p class="docList">An array of strings is returned.</p></dd>

<dt><br><p><span class="docPubcolor"><span class="docEmphStrong">Discussion</span></span></p></dt>
<dd><p class="docList"><tt>preg_split</tt> splits a copy of a string into multiple parts, returning them in an array. The optional <span class="docEmphasis">limit</span> argument allows the number of parts to be capped at the given maximum (with the last part becoming an "everything else" part, if needed). With the various flags, you can adjust which parts are returned, and how.</P></dd>
</dl>
<p class="docText">In one sense, <tt>preg_split</tt><a name="IDX-CHP-10-3537"></a> 
 is the opposite of <tt>preg_match_all</tt> in that <tt>preg_split</tt> isolates parts of a string that <span class="docEmphasis">don't</span> match a regular expression. Described more traditionally, <tt>preg_split</tt> returns parts of a string that remain after the regexmatched sections are removed. <tt>preg_split</tt> is the more powerful regular-expression equivalent of PHP's<a name="IDX-CHP-10-3538"></a> 
<a name="IDX-CHP-10-3539"></a> 
<a name="IDX-CHP-10-3540"></a> 
 simple <tt>explode</tt> built-in function.</p>
<p class="docText">As a simple example, consider a financial site's search form accepting a space-separated list of stock tickers. To isolate the tickers, you could use <tt>explode</tt>:</p>
<pre>
    $tickers = explode(' ', $input);
</pre><BR>

<p class="docText">but this does not allow for sloppy typists who may add more than one space between stock tickers. A better approach is to use <img src=images/U2308.jpg border=0><tt>\s+</tt><img src=images/U230B.jpg border=0> as a <tt>preg_split</tt> separator:</p>
<pre>
    $tickers = preg_split('/\s+/', $input);
</pre><br>

<p class="docText">Yet, despite having clear "separated by spaces" instructions, users often intuitively separate multiple items with commas (or commas and spaces), entering something such as '<tt>YHOO, MSFT, GOOG</tt>'. You can easily allow for these situations with:</P>
<pre>
    $tickers = preg_split('/[\s,]+/', $input);
</pre><br>

<p class="docText">With our example input, this leaves <tt>$tickers</tt> with an array of three elements: '<tt>YHOO</tt>', '<tt>MSFT</tt>', and '<tt>GOOG</tt>'.</P>
<p class="docText">Along different lines, if the input is comma-separated "tags" (&agrave; la "Web 2.0," such as photo tagging), you might want to use <img src=images/U2308.jpg border=0><tt>\s*,\s*</tt><img src=images/U230B.jpg border=0> to allow for spacing around the commas:</p>
<pre>
    $tags = p_eg_split('/\s*,\s*/', $input);
</pre><br>

<p class="docText">It's illustrative to compare <img src=images/U2308.jpg border=0><tt>\s*,\s*</tt><img src=images/U230B.jpg border=0> with <img src=images/U2308.jpg border=0><tt>[\s,]+</tt><img src=images/U230B.jpg border=0> in these examples. The former splits on commas (a comma is required for the split), but also removes any whitespace that may be on either side of the comma. With <tt>$input</tt> of '<tt>123,,,456</tt>', it matches three times (one comma each), returning four elements: '<tt>123</tt>', two empty elements, and '<tt>456</tt>'.</p>
<p class="docText">On the other hand, <img src=images/U2308.jpg border=0><tt>[\s,]+</tt><img src=images/U230B.jpg border=0> splits on any comma, sequence of commas, whitespace, or combination thereof. With our example of '<tt>123,,,456</tt>', it matches the three commas together, returning just two elements: '<tt>123</tt>' and '<tt>456</tt>'.</p>

<a name="regex3-CHP-10-SECT-3.1.13"></a>
<h5 id="title-IDAMQBIE" class="docSection3Title">10.3.1.13. <tt>preg_split</tt>'s limit argument</h5>
<a name="IDX-CHP-10-3541"></a> 

<a name="IDX-CHP-10-3542"></a> 

<p class="docText">The <span class="docEmphasis">limit</span>argument tells <tt>preg_split</tt> that it shouldn't split the input string into more than a certain number of parts. If the <span class="docEmphasis">limit</span> number of parts is reached before the end of the string is reached, whatever remains is put into the final element.</p>
<p class="docText">As an example, consider parsing an HTTP response<a name="IDX-CHP-10-3543"></a> 
 from a server by hand. The standard indicates that the header is separated from the body by the four-character sequence '<tt>\r\n\r\n</tt>', but unfortunately, in practice some servers use only '<tt>\n\n</tt>' to separate the two. Luckily, <tt>preg_split</tt> makes it easy to handle either situation. Assuming that the entire HTTP response is in <tt>$response</tt>,</p>
<pre>
    $parts = preg_split('/\r? \n \r? \n/x', $response, 2);
</pre><br>

<p class="docText">leaves the header in <tt>$parts[0]</tt> and the body in <tt>$parts[1]</tt>. (The <span class="docEmphStrong">S</span><a name="IDX-CHP-10-3544"></a> 
 pattern modifier is used for efficiency &#9758; 478.)</p>
<p class="docText">That third argument, <tt>2</tt>, is the limit, meaning that the subject string is to be split into no more than two parts. If a match is indeed found, the part before the match (what we know to be the header) becomes the first element of the return value. Since "the rest of the string" would make the second element, thereby reaching the limit, it (what we know to be the body) is left unsearched and intact as the final, limit-reaching second element of the return value.</p>
<p class="docText">Without a limit (or with a limit of <tt>-1</tt>, which means the same thing), <tt>preg_split</tt> splits the subject as many times as it can, which would likely break the body into many parts. Setting a limit does not guarantee that the result array will have that many entries, but merely guarantees that it will not have <span class="docEmphasis">more</span> than that number (although see the section on <tt>PREG_SPLIT_DELIM_CAPTURE</tt> below for situation where even this is not necessarily true).</p>
<p class="docText">There are two situations where it makes sense to set an artificial limit. We've already seen the first situation: when you want the final element to be an "all the rest" element. In the previous example, once the first part (the header) was isolated, we didn't want the rest (the body) to be split further. Thus, our use of a <tt>2</tt> limit kept the body intact.</P>
<p class="docText">A limit is also efficient in situations where you know you won't use all the elements that an unlimited split would create. For example, if you had a <tt>$data</tt> string with many fields separated by <img src=images/U2308.jpg border=0><tt>\s*,\s*</tt><img src=images/U230B.jpg border=0> (say, "name" and "address" and "age," etc.) and you needed only the first two, you could use a <span class="docEmphasis">limit</span> of <tt>3</tt> to let <tt>preg_split</tt> stop working once the first two items have been isolated:</p>
<pre>
    $fields = preg_split('/ \s*, \s*/x', $data, 3);
</pre><BR>

<p class="docText">This leaves everything else in the final, third array element, which you could then remove with <tt>array_pop</tt> or simply ignore.</p>
<p class="docText">If you wish to use any of the <tt>preg_split</tt> flags (discussed in the next section) in the default "no limit" mode, you must provide a placeholder <span class="docEmphasis">limit</span> argument of <tt>-1</tt>, which indeed means "no limit." On the other hand, a <span class="docEmphasis">limit</span> value of <tt>1</tt> effectively means "don't split," so it is not very useful. The meaning of zero and negative values other than <tt>-1</tt> are explicitly undefined, so don't use them.</p>

<a name="regex3-CHP-10-SECT-3.1.14"></a>
<H5 id="title-IDAAUBIE" class="docSection3Title">10.3.1.14. <tt>preg_split</tt>'s flag arguments</H5>
<a name="IDX-CHP-10-3545"></a> 
<a name="IDX-CHP-10-3546"></a> 
<a name="IDX-CHP-10-3547"></a> 
<a name="IDX-CHP-10-3548"></a> 

<p class="docText"><tt>preg_split</tt> supports three flags that influence how it works. They can be used individually or combined with the binary "or" operator (see the example on page 456).</P>
<p class="docText"><tt><span class="docEmphasis"><span class="docEmphStrong">PREG_SPLIT_OFFSET_CAPTURE</span></span></tt><a name="IDX-CHP-10-3549"></a> 
 As with the <tt>PREG_OFFSET_CAPTURE</tt> flag used with <tt>preg_match</tt> and <tt>preg_match_all</tt>, this flag changes the result array such that each element is itself a string-and-offset array.</P>
<p class="docText"><tt><span class="docEmphasis"><span class="docEmphStrong">PREG_SPLIT_NO_EMPTY</span></span></tt><a name="IDX-CHP-10-3550"></a> 
 This flag causes <tt>preg_split</tt> to internally ignore empty strings, not returning them in the result array and not counting them toward the split limit. Empty strings are the result of the regex matching at the very beginning or very end of the subject string, or matching consecutively in a row with nothing in between.</p>
<p class="docText">Revisiting the "Web 2.0" tags example from earlier (&#9758; 466), if the variable <tt>$input</tt> contains the string '<tt>party,,fun</tt>' then</P>
<pre>
    $tags = preg_split('/ \s*, \s*/x', $input);
</pre><br>

<p class="docText">leaves <tt>$tags</tt> with three strings: '<tt>party</tt>', an empty string, and '<tt>fun</tt>'. The empty string is the "nothingness" between the two matches of the commas.</p>
<p class="docText">If we repeat the same example with the <tt>PREG_SPLIT_NO_EMPTY</tt> flag,</P>
<pre>
    $tags = preg_split('/ \s*, \s*/x', $input, -1, PREG_SPLIT_NO_EMPTY);
</pre><BR>

<p class="docText">only '<tt>party</tt>' and '<tt>fun</tt>' are returned.</p>
<p class="docText"><tt><span class="docEmphasis"><span class="docEmphStrong">PREG_SPLIT_DELIM_CAPTURE</span></span></tt><a name="IDX-CHP-10-3551"></a> 
 This flag includes in the result the text matched within capturing parentheses of the regular expression doing the split. As a simple example, let's say you want to parse a set of search terms where '<tt>and</tt>' and '<tt>or</tt>' are used to link terms, such as:</P>
<pre>
    DLSR camera <span class="docEmphStrong">and</span> Nikon D200 <span class="docEmphStrong">or</span> Canon EOS 30D
</pre><BR>

<p class="docText">Without <tt>PREG_SPLIT_DELIM_CAPTURE</tt>, the code</p>
<pre>
    $parts = preg_split('/ \s+ (and;or) \s+ /x', $input);
</pre><br>

<p class="docText">results in <tt>$parts</tt> being assigned this array:</p>
<pre>
    array ('DLSR camera', 'Nikon D200', 'Canon EOS 30D')
</pre><BR>

<p class="docText">Everything matched as the separator has been removed. However, with the addition of the <tt>PREG_SPLIT_DELIM_CAPTURE</tt> flag (and a <tt>-1</tt> placeholder <span class="docEmphasis">limit</span> argument):</P>
<pre>
    $parts = preg_split('/ \s+ (and|or) \s+ /x', $input, -1,
    PREG_SPLIT_DELIM_CAPTURE);
</pre><br>

<p class="docText"><tt>$parts</tt> includes sections of the separator matched within capturing parentheses:</p>
<pre>
    array ('DLSR camera', 'and', 'Nikon D200', 'or', 'Canon EOS 30D')
</pre><br>

<p class="docText">In this case, one element per split is added to the result array, as there's one set of capturing parentheses in the regular expression. Your processing can then walk the elements of <tt>$parts</tt>, recognizing the '<tt>and</tt>' and '<tt>or</tt>' elements for special treatment.</p>
<p class="docText">It's important to note that if non-capturing parentheses had been used (a pattern argument of '<tt>/\s+(?:and|or)\s+/</tt>') the <tt>PREG_SPLIT_DELIM_CAPTURE</tt> flag would have made no difference because it works only with capturing parentheses.</P>
<p class="docText">As another example, recall the earlier stock-ticker example from page 466:</p>
<pre>
    $tickers = preg_split('/[\s,]+/', $input);
</pre><br>

<p class="docText">If we add capturing parentheses and <tt>PREG_SPLIT_DELIM_CAPTURE,</tt></P>
<pre>
    $tickers = preg_split('/([\s,]+)/', $input, -1, PREG_SPLIT_DELIM_CAPTURE);
</pre><br>

<p class="docText">the result is that nothing from <tt>$input</tt> is thrown away; it's merely partitioned into the elements of <tt>$tickers</tt>. When you process the <tt>$tickers</tt> array, you know that every odd-numbered element was matched by <img src=images/U2308.jpg border=0><tt>([\s,]+)</tt><img src=images/U230B.jpg border=0>. This might be useful, for example, if in the process of displaying an error message to the user, you want to do some processing on the various parts, then stitch them back together to end up with a post-processed version of the original input string.</p>
<p class="docText">By the way, elements added to the result array via <tt>PREG_SPLIT_DELIM_CAPTURE</tt> do not impact the split limit.<a name="IDX-CHP-10-3552"></a> 
 This is the only case where the resulting array can have more elements than the split limit (many more elements if there are many sets of capturing parentheses in the regex).</P>
<p class="docText">Trailing non-participatory capturing parentheses do not contribute to the result array. This mouthful means that pairs of capturing parentheses that do not participate in the final match (see page 450) may or may not add an empty string to the result array. They do if a higher-numbered set of parentheses <span class="docEmphasis">is</span> part of the final match, and don't otherwise. Note that the addition of the <tt>PREG_SPLIT_NO_EMPTY</tt> flag renders this issue moot, because it elides empty strings regardless.</p>
<a name="IDX-CHP-10-3553"></a><a name="IDX-CHP-10-3554"></a><dl class="docList">
<dt><BR><p><span class="docPubcolor"><span class="docEmphStrong">Usage</span></span></p></dt>
<dd>
<pre>
    preg_grep( <span class="docEmphasis">pattern, input[, flags]</span>)
</pre><br>

</dd>

<dt><br><p><span class="docPubcolor"><span class="docEmphStrong">Argument Summary</span></span></p></dt>
<dd>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><tr><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">pattern</span></span></p></td><td class="docTableCell" align="left"><p class="docText">The pattern argument: a regex in delimiters, with optional modifiers.</P></td></TR><tr><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">input</span></span></P></TD><TD class="docTableCell" align="left"><p class="docText">An array whose values are copied to the return-value array if they match <span class="docEmphasis">pattern</span>.</P></td></TR><tr><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">flags</span></span></P></TD><td class="docTableCell" align="left"><p class="docText">An optional value, <tt>PREG_GREP_INVERT</tt> or zero.</P></TD></tr></table></p><br>
</dd>

<dt><BR><P><span class="docPubcolor"><span class="docEmphStrong">Return Value</span></span></p></dt>
<dd><p class="docList">An array containing values from <span class="docEmphasis">input</span> that match <span class="docEmphasis">pattern</span> (or, conversely, values that do <span class="docEmphStrong">not</span> match <span class="docEmphasis">pattern</span> if the <tt>PREG_GREP_INVERT</tt><a name="IDX-CHP-10-3554"></a> 
 flag has been used).</p></dd>

<dt><br><p><span class="docPubcolor"><span class="docEmphStrong">Discussion</span></span></P></dt>
<dd><p class="docList"><tt>preg_grep</tt> is used to make a copy of an array, <span class="docEmphasis">input</span>, keeping only elements whose value matches (or, with the <tt>PREG_GREP_INVERT</tt> flag, doesn't match) the <span class="docEmphasis">pattern</span>. The original key associated with the value is kept.</p>
<p class="docList">As a simple example, consider</p>
<pre>
    preg_grep('/\s/', $input);
</pre><BR>

<p class="docList">which returns an array populated with elements in the <tt>$input</tt> array whose value has whitespace. The opposite is:</p>
<pre>
    preg_grep('/\s/', $input, PREG_GREP_INVERT);
</pre><br>

<p class="docList">which populates the return array with elements whose value does not contain whitespace. Note that this second example is different from:</P>
<pre>
    preg_grep('/^\S+$/', $input);
</pre><br>

<p class="docList">in that the latter does not include elements with empty (zero-length) values.</P></dd>
</dl>
<a name="IDX-CHP-10-3555"></a><dl class="docList">
<dt><br><p><span class="docPubcolor"><span class="docEmphStrong">Usage</span></span></p></dt>
<dd>
<pre>
    preg_quote( <span class="docEmphasis">input[, delimiter</span>])
</pre><br>

</dd>

<dt><br><p><span class="docPubcolor"><span class="docEmphStrong">Argument Summary</span></span></p></dt>
<dd>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><tr><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">input</span></span></p></td><TD class="docTableCell" align="left"><p class="docText">A string you'd like to use literally within a preg pattern argument (&#9758; 444).</p></TD></tr><tr><TD class="docTableCell" align="left"><p class="docText"><span class="docEmphasis"><span class="docEmphStrong">delimiter</span></span></P></TD><TD class="docTableCell" align="left"><p class="docText">Optional one-character string indicating the delimiter you intend to use in the construction of the pattern argument.</p></TD></tr></table></p><BR>
</dd>

<dt><BR><p><span class="docPubcolor"><span class="docEmphStrong">Return Value</span></span></P></dt>
<dd><p class="docList"><tt>preg_quote</tt> returns a string, a copy of <span class="docEmphasis">input</span> with regex metacharacters escaped. If <span class="docEmphasis">delimiter</span> has been specified, instances of it are also escaped.</P></dd>

<dt><br><p><span class="docPubcolor"><span class="docEmphStrong">Discussion</span></span></p></dt>
<dd><p class="docList">If you have a string that you'd like to use as literal text within a regex, you can pass the string through the built-in <tt>preg_quote</tt> function to escape any regex metacharacter it may contain. Optionally, you can also specify the delimiter you intend to use when using the result to create a pattern, and occurrences of it will also be escaped.</P></dd>
</dl>
<p class="docText"><tt>preg_quote</tt> is a highly specialized function that isn't useful in many situations, but here's an example:</P>
<pre>
    /* <span class="docEmphasis">Given $MailSubject, find if $MailMessage is about that subject</span> */
$pattern = '/^Subject:\s+(Re:\s*)*' . preg_quote($MailSubject, '/') . '/mi';
</pre><br>

<p class="docText">If <tt>$MailSubject</tt> contains a string such as</p>
<pre>
    **Super Deal** (Act Now!)
</pre><br>

<p class="docText"><tt>$pattern</tt> winds up with:</p>
<pre>
    /^Subject:\s+(Re:\s*)*\*\*Super Deal\*\* \(Act Now\!\)/mi
</pre><BR>

<p class="docText">which is suitable for use as a pattern argument with the preg functions.</p>
<p class="docText">Specifying '<tt>{</tt>' or any of the other paired delimiters does not cause the opposing character (e.g., '<tt>}</tt>') to be escaped, so be sure to stick with the non-paired delimiters.</p>
<p class="docText">Also, whitespace and '<tt>#</tt>' are not escaped, so the result is likely not appropriate for use with the <span class="docEmphStrong">x</span><a name="IDX-CHP-10-3556"></a> 
 modifier.</P>
<p class="docText">When it comes down to it, <tt>preg_quote</tt> is only a partial solution for representing arbitrary text as a PHP regular expression. It solves only the "text to regex" part of the problem, but does not follow through with the "regex to pattern argument" step needed to actually use it with any of the preg functions. A solution to that step is covered in the next section.</p>



</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-10-SECT-2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-10-SECT-4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>