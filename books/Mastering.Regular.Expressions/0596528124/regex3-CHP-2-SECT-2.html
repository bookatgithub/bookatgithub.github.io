<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 2.2.&nbsp; Matching Text with Regular Expressions</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-2-SECT-1.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-2-SECT-3.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="regex3-CHP-2-SECT-2"></a>
<H3 id="title-IDAIV0LT" class="docSection1Title">2.2. Matching Text with Regular Expressions</H3>
<a name="IDX-CHP-2-0219"></a> 
<a name="IDX-CHP-2-0220"></a> 
<a name="IDX-CHP-2-0221"></a> 

<p class="docText">Perl uses regular expressions in many ways, the simplest being to check if a regex matches text (or some part thereof) held in a variable. This snippet checks the string held in variable <tt>$reply</tt> and reports whether it contains only digits:</P>
<pre>
    if ($reply =~ m/^<span class="docEmphStrong">[0-9]+$</span>/) {
        print "only digits\n";
    } else {
        print "not only digits\n";
    }
</pre><BR>

<p class="docText">The mechanics of the first line might seem a bit strange: the regular expression is <img src=images/U2308.jpg border=0><tt>^[0-9]+$</tt><img src=images/U230B.jpg border=0>, while the surrounding <tt><span class="docEmphStrong">m/&#8943;/</span></tt> tells Perl what to do with it. The <tt><span class="docEmphStrong">m</span></tt> means to attempt a <span class="docEmphasis">regular expression match</span>, while the slashes delimit the regex itself.<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-2-FN-2">[<img src=images/U2020.jpg border=0>]</a></sup> The preceding <tt><span class="docEmphStrong">=~</span></tt> links <tt>m/&#8943;/</tt> with the string to be searched, in this case the contents of the variable <tt>$reply</tt>.</p><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-2-FN-2">[<img src=images/U2020.jpg border=0>]</a></sup> In many situations, the <tt>m</tt> is optional. This example can also appear as <tt><span class="docEmphStrong">$reply =~ /^[0-9]+$/</span></tt>, which some readers with past Perl experience may find to be more natural. Personally, I feel the <tt>m</tt> is descriptive, so I tend to use it.</P></blockquote>
<p class="docText">Don't confuse <tt><span class="docEmphStrong">=~</span></tt> with <tt><span class="docEmphStrong">=</span></tt> or <tt><span class="docEmphStrong">==</span></tt>. The operator <tt><span class="docEmphStrong">==</span></tt> tests whether two numbers are the same. (The operator <tt><span class="docEmphStrong">eq</span></tt>, as we will soon see, is used to test whether two <span class="docEmphasis">strings</span> are the same.) The <tt><span class="docEmphStrong">=</span></tt> operator is used to assign a value to a variable, as with <tt><span class="docEmphStrong">$celsius = 20</span></tt>. Finally,<span class="docEmphStrong">=~</span> links a regex search with the target string to be searched. In the example, the search is <tt>m/^[0-9]+$/</tt> and the target is <tt>$reply</tt>. Other languages approach this differently, and we'll see examples in the next chapter.</p>
<p class="docText">It might be convenient to read <tt><span class="docEmphStrong">=~</span></tt> as "matches," such that</p>
<pre>
    if ($reply =~ m/^[0-9]+$/)
</pre><BR>

<p class="docText">becomes:</P>
<pre>
    if the text contained in the variable $reply <span class="docEmphasis">matches</span> the regex <img src=images/U2308.jpg border=0>^[0-9]+$<img src=images/U230B.jpg border=0>,
    then ...
</pre><br>

<p class="docText">The whole result of <tt><span class="docEmphStrong">$reply =~ m/^[0-9]+$/</span></tt> is a <span class="docEmphasis">true</span> value if the <img src=images/U2308.jpg border=0><tt>^[0-9]+$</tt><img src=images/U230B.jpg border=0> matches the string held in <tt>$reply</tt>, a <span class="docEmphasis">false</span> value otherwise. The <tt>if</tt> uses this true or false value to decide which message to print.</p>
<p class="docText">Note that a test such as <tt><span class="docEmphStrong">$reply =~ m/[0-9]+/</span></tt> (the same as before except the wrapping caret and dollar have been removed) would be true if <tt>$reply</tt> contained at least one digit <span class="docEmphasis">anywhere</span>. The surrounding <img src=images/U2308.jpg border=0><tt>^&#8943;$</tt><img src=images/U230B.jpg border=0> ensures that the entire <tt>$reply</tt> contains <span class="docEmphasis">only</span> digits.</P>
<p class="docText">Let's combine the last two examples. We'll prompt the user to enter a value, accept that value, and then verify it with a regular expression to make sure it's a number. If it is, we calculate and display the Fahrenheit equivalent. Otherwise, we issue a warning message:</P>
<pre>
    print "Enter a temperature in Celsius:\n";
    $celsius = &lt;STDIN&gt;; # <span class="docEmphasis">this reads one line from the user</span>
    chomp($celsius);          # <span class="docEmphasis">this removes the ending newline from $celsius</span>

    if <span class="docEmphStrong">(</span> $celsius =~ m/^[0-9]+$/<span class="docEmphStrong">) {</span>
        $fahrenheit = ($celsius * 9 / 5) + 32; # <span class="docEmphasis">calculate Fahrenheit</span>
        print "$celsius C is $fahrenheit F\n";
    <span class="docEmphStrong">}</span> else <span class="docEmphStrong">{</span>
        print "Expecting a number, so I don't understand \"$celsius\".\n";
    <span class="docEmphStrong">}</span>
</pre><BR>

<p class="docText">Notice in the last <tt>print</tt> how we escaped the quotes to be printed, to distinguish them from the quotes that delimit the string? As with literal strings in most languages, there are occasions to escape some items, and this is very similar to escaping a metacharacter in a regex. The relationship between a string and a regex isn't quite as important with Perl, but is extremely important with languages like Java, Python, and the like. The section "<a class="docLink" href="#regex3-CHP-2-SECT-2.3.1">A short asidemetacharacters galore</a>" (&#9758; 44) discusses this in a bit more detail. (One notable exception is VB.NET, which requires '<tt>""</tt>' rather than '<tt>\"</tt>' to get a double quote into a string literal.)</p>
<p class="docText">If we put this program into the file <span class="docEmphasis">c2f</span>, we might run it and see:</P>
<pre>
    % <span class="docEmphStrong">perl -w c2f</span>
    Enter a temperature in Celsius:
    <span class="docEmphStrong">22</span>
    22 C is 71.599999999999994316 F
</pre><BR>

<p class="docText">Oops. As it turns out (at least on some systems), Perl's simple <tt>print</tt> is not always so good when it comes to floating-point numbers.</p>
<p class="docText">I don't want to get bogged down describing all the details of Perl<a name="IDX-CHP-2-0222"></a> 
 in this chapter, so I'll just say without further comment that you can use <tt>printf</tt><a name="IDX-CHP-2-0223"></a> 
 ("print formatted") to make this look better:</p>
<pre>
    printf "%.2f C is %.2f F\n", $celsius, $fahrenheit;
</pre><br>

<p class="docText">The <tt>printf</tt> function is similar to the C language's <tt>printf</tt>, or the <tt>format</tt> of Pascal, Tcl, <span class="docEmphasis">elisp</span>, and Python. It doesn't change the values of the variables, but merely how they are displayed. The result is now much nicer:</p>
<pre>
    Enter a temperature in Celsius:
    <span class="docEmphStrong">22</span>
    22.00 C is 71.60 F
</pre><BR>

<a name="regex3-CHP-2-SECT-2.1"></a>
<h4 id="title-IDA430LT" class="docSection2Title">2.2.1. Toward a More Real-World Example</h4>
<p class="docText">Let's extend this example to allow negative and fractional temperature values. The math part of the program is fine  Perl normally makes no distinction between integers and floating-point numbers. We do, however, need to modify the regex to let negative and floating-point values pass. We can insert a leading <img src=images/U2308.jpg border=0><tt>-?</tt><img src=images/U230B.jpg border=0> to allow a leading minus sign. In fact, we may as well make that <img src=images/U2308.jpg border=0><tt>[-+]?</tt><img src=images/U230B.jpg border=0> to allow a leading plus sign, too.</P>
<p class="docText">To allow an optional decimal part, we add <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(\.[0-9]*)?</span></tt><img src=images/U230B.jpg border=0>. The escaped dot matches a literal period, so <img src=images/U2308.jpg border=0><tt>\.[0-9]*</tt><img src=images/U230B.jpg border=0> is used to match a period followed by any number of optional digits. Since <img src=images/U2308.jpg border=0><tt>\.[0-9]*</tt><img src=images/U230B.jpg border=0> is enclosed by <img src=images/U2308.jpg border=0><tt>(&#8943;)?</tt><img src=images/U230B.jpg border=0>, the whole subexpression becomes optional. (Realize that this is very different from <img src=images/U2308.jpg border=0><tt>\.<img border="0" alt="" id="195131084202" width="7" height="12" SRC="images/regex3_u0201.jpg">[0-9]*</tt><img src=images/U230B.jpg border=0>, which incorrectly allows additional digits to match even if <img src=images/U2308.jpg border=0><tt>\.</tt><img src=images/U230B.jpg border=0> does not match.)</p>
<p class="docText">Putting this all together, we get</p>
<pre>
    <div><img border="0" alt="" id="195131084202" width="336" height="12" SRC="images/regex3_u0202.jpg"></div>
</pre><br>

<p class="docText">as our check line. It allows numbers such as <tt>32, -3.723,</tt> and <tt>+98.6.</tt> It is actually not quite perfect: it doesn't allow a number that begins with a decimal point (such as <tt>.357</tt>). Of course, the user can just add a leading zero to allow it to match (e.g., <tt>0.357</tt>), so I don't consider it a major shortcoming. This floating-point problem can have some interesting twists, and I look at it in detail in <a class="docLink" href="regex3-CHP-5.html#regex3-CHP-5">Chapter 5</a>(&#9758; 194).</p>

<a name="regex3-CHP-2-SECT-2.2"></a>
<h4 id="title-IDACA1LT" class="docSection2Title">2.2.2. Side Effects of a Successful Match</h4>
<a name="IDX-CHP-2-0224"></a> 
<a name="IDX-CHP-2-0225"></a> 

<p class="docText">Let's extend the example further to allow someone to enter a value in either Fahrenheit or Celsius. We'll have the user append a <tt>C</tt> or <tt>F</tt> to the temperature entered. To let this pass our regular expression, we can simply add <img src=images/U2308.jpg border=0><tt>[CF]</tt><img src=images/U230B.jpg border=0> after the expression to match a number, but we still need to change the rest of the program to recognize which kind of temperature was entered, and to compute the other.</p>
<p class="docText">In <a class="docLink" href="regex3-CHP-1.html#regex3-CHP-1">Chapter 1</a>, we saw how some versions of <span class="docEmphasis">egrep</span> support <img src=images/U2308.jpg border=0><tt>\1</tt><img src=images/U230B.jpg border=0>, <img src=images/U2308.jpg border=0><tt>\2</tt><img src=images/U230B.jpg border=0>, <img src=images/U2308.jpg border=0><tt>\3</tt><img src=images/U230B.jpg border=0>, etc. as metacharacters to refer to the text matched by parenthesized subexpressions earlier within the regex (&#9758; 21). Perl<a name="IDX-CHP-2-0226"></a> 
<a name="IDX-CHP-2-0227"></a> 
<a name="IDX-CHP-2-0228"></a> 
 and most other modern regex-endowed languages support these as well, but also provide a way to refer to the text matched by parenthesized subexpressions from code <span class="docEmphasis">outside</span> of the regular expression, after a match has been successfully completed.</p>
<p class="docText">We'll see examples of how other languages do this in the next chapter (&#9758; 137), but Perl provides the access via the variables <tt>$1, $2, $3</tt>, etc., which refer to the text matched by the first, second, third, etc., parenthesized subexpression. As odd as it might seem, these <span class="docEmphasis">are</span> variables. The variable names just happen to be numbers. Perl sets them every time the application of a regex is successful.</p>
<p class="docText">To summarize, use the metacharacter <img src=images/U2308.jpg border=0><tt>\1</tt><img src=images/U230B.jpg border=0> within the regular expression to refer to some text matched earlier during the same match attempt, and use the variable <tt>$1</tt> in subsequent code to refer to that same text after the match has been successfully completed.</p>
<p class="docText">To keep the example uncluttered and focus on what's new, I'll remove the fractional-value part of the regex for now, but we'll return to it again soon. So, to see <tt>$1</tt> in action, compare:</p>
<pre>
    <div><img border="0" alt="" id="195131084202" width="262" height="26" SRC="images/regex3_u0203.jpg"></div>
</pre><br>

<p class="docText">Do the added parentheses change the meaning of the expression? Well, to answer that, we need to know whether they provide grouping for star or other quantifiers, or provide an enclosure for <img src=images/U2308.jpg border=0><tt>|</tt><img src=images/U230B.jpg border=0>. The answer is no on both counts, so what matches remains unchanged. However, they do enclose two subexpressions that match "interesting" parts of the string we are checking. As <a class="docLink" href="#regex3-CHP-2-FIG-1">Figure 2-1</a> illustrates, <tt>$1</tt> will receive the number entered, and <tt>$2</tt> will receive the <tt>C</tt> or <tt>F</tt> entered. Referring to the flowchart in <a class="docLink" href="#regex3-CHP-2-FIG-2">Figure 2-2</a> on the next page, we see that this allows us to easily decide how to proceed after the match.</p>
<a name="regex3-CHP-2-FIG-1"></a><p><center>
<h5 class="docFigureTitle">Figure 2-1. Capturing parentheses</h5><img border="0" alt="" id="195131084202" width="397" height="174" SRC="images/regex3_0201.jpg">
</center></p><BR>
<a name="regex3-CHP-2-FIG-2"></a><p><center>
<H5 class="docFigureTitle">Figure 2-2. Temperature-conversion program's logic flow</h5><img border="0" alt="" id="195131084202" width="498" height="300" SRC="images/regex3_0202.jpg">
</center></p><BR>
<a name="regex3-CHP-2-SECT-2.2.1"></a>
<H5 id="title-IDAGE1LT" class="docSection3Title">2.2.2.1. Temperature-conversion program</H5>
<pre>
    print "Enter a temperature (e.g., 32F, 100C):\n";
    $input = &lt;STDIN&gt;; # <span class="docEmphasis">This reads one line from the user</span>.
    chomp($input);          # <span class="docEmphasis">This removes the ending newline from $input</span>.
    if ($input =~ m/^([-+]?[0-9]+)([CF])$/)
    {
        # <span class="docEmphasis">If we get in here, we had a match. $1 is the number, $2 is "C" or "F"</span>.
        $InputNum = $1; # <span class="docEmphasis">Save to named variables to make the</span> ...
        $type = $2; # <span class="docEmphasis">... rest of the program easier to read</span>.

        if ($type eq "C") { # <span class="docEmphasis">'eq' tests if two strings are equal</span>
            # <span class="docEmphasis">The input was Celsius, so calculate Fahrenheit</span>
            $celsius = $InputNum;
            $fahrenheit = ($celsius * 9 / 5) + 32;
        } else {
            # <span class="docEmphasis">If not "C", it must be an "F", so calculate Celsius</span>
            $fahrenheit = $InputNum;
            $celsius = ($fahrenheit - 32) * 5 / 9;
        }
        # <span class="docEmphasis">At this point we have both temperatures, so display the results:</span>
        printf "%.2f C is %.2f F\n", $celsius, $fahrenheit;
    } else {
        # <span class="docEmphasis">The initial regex did not match, so issue a warning</span>.
        print "Expecting a number followed by \"C\" or \"F\",\n";
        print "so I don't understand \"$input\".\n";
    }
</pre><BR>

<p class="docText">If the program shown on the facing page is named <span class="docEmphasis">convert</span>, we can use it like this:</p>
<pre>
    % <span class="docEmphStrong">perl -w convert</span>
    Enter a temperature (e.g., 32F, 100C):
    <span class="docEmphStrong">39F</span>
    3.89 C is 39.00 F
    % <span class="docEmphStrong">perl -w convert</span>
    Enter a temperature (e.g., 32F, 100C):
    <span class="docEmphStrong">39C</span>
    39.00 C is 102.20 F
    % <span class="docEmphStrong">perl -w convert</span>
    Enter a temperature (e.g., 32F, 100C):
    <span class="docEmphStrong">oops</span>
    Expecting a number followed by "C" or "F",
    so I don't understand "oops".
</pre><BR>



<a name="regex3-CHP-2-SECT-2.3"></a>
<h4 id="title-IDAFG1LT" class="docSection2Title">2.2.3. Intertwined Regular Expressions</h4>
<p class="docText">With advanced programming languages like Perl, regex use can become quite intertwined<a name="IDX-CHP-2-0229"></a> 
 with the logic of the rest of the program. For example, let's make three useful changes to our program: allow floating-point numbers as we did earlier, allow for the <tt>f</tt> or <tt>c</tt> entered to be lowercase, and allow spaces between the number and letter. Once all these changes are done, input such as '<tt>98.6&#8226;f</tt>' will be allowed.</P>
<p class="docText">Earlier, we saw how we can allow floating-point numbers by adding <img src=images/U2308.jpg border=0><tt>(\.[0-9]*)?</tt><img src=images/U230B.jpg border=0> to the expression:</P>
<pre>
    <div><img border="0" alt="" id="195131084202" width="359" height="12" SRC="images/regex3_u0204.jpg"></div>
</pre><br>

<p class="docText">Notice that it is added <span class="docEmphasis">inside</span> the first set of parentheses. Since we use that first set to capture the number to compute, we want to make sure that they capture the fractional portion as well. However, the added set of parentheses, even though ostensibly used only to group for the question mark, also has the side effect of capturing into a variable. Since the opening parenthesis of the pair is the second (from the left), it captures into <tt>$2</tt>. This is illustrated in <a class="docLink" href="#regex3-CHP-2-FIG-3">Figure 2-3</a>.</p>
<a name="regex3-CHP-2-FIG-3"></a><P><center>
<H5 class="docFigureTitle">Figure 2-3. Nesting parentheses</H5><img border="0" alt="" id="195131084202" width="497" height="135" SRC="images/regex3_0203.jpg">
</center></p><BR>
<p class="docText"><a class="docLink" href="#regex3-CHP-2-FIG-3">Figure 2-3</a> illustrates how closing parentheses nest with opening ones. Adding a set of parentheses earlier in the expression doesn't influence the meaning of <img src=images/U2308.jpg border=0><tt>[CF]</tt><img src=images/U230B.jpg border=0> directly, but it does so indirectly because the parentheses surrounding it have now become the third pair. Becoming the third pair means that we need to change the assignment to <tt>$type</tt> to refer to <tt>$3</tt> instead of <tt>$2</tt> (but see the sidebar on the facing page for an alternative approach).</P>
<p class="docText">Next, allowing spaces between the number and letter is easier. We know that an unadorned space in a regex requires exactly one space in the matched text, so <img src=images/U2308.jpg border=0><tt>&#8226;*</tt><img src=images/U230B.jpg border=0> can be used to allow any number of spaces (but still not require any):</p>
<pre>
    if ($input =~ m/^([-+]?[0-9]+(\.[0-9]*)?) <div><img border="0" alt="" id="195131084202" width="13" height="9" SRC="images/regex3_u0205.jpg"></div>([CF])$/)
</pre><br>

<p class="docText">This does give a limited amount of flexibility to the user of our program, but since we are trying to make something useful in the real world, let's construct the regex to also allow for other kinds of <span class="docEmphasis">whitespace</span> as well. Tabs, for instance, are quite common. Writing <img src=images/U2308.jpg border=0><tt><img border="0" alt="" id="195131084202" width="12" height="16" SRC="images/regex3_u0206.jpg">*</tt><img src=images/U230B.jpg border=0>, of course, doesn't allow for spaces, so we need to construct a character class to match either one: <img src=images/U2308.jpg border=0><tt>[&#8226;<img border="0" alt="" id="195131084202" width="12" height="16" SRC="images/regex3_u0206.jpg">]*</tt><img src=images/U230B.jpg border=0>.</p>
<p class="docText">Compare that with <img src=images/U2308.jpg border=0><tt>(&#8226;*|<img border="0" alt="" id="195131084202" width="12" height="16" SRC="images/regex3_u0206.jpg">*)</tt><img src=images/U230B.jpg border=0> and see if you can recognize how they are fundamentally different? <a class="docLink" href="#regex3-CHP-2-SIDEBAR-2">&#10070;</a> After considering this, turn the page to check your thoughts.</p>
<p class="docText">In this book, spaces and tabs are easy to notice because of the &#8226; and <img border="0" alt="" id="195131084202" width="12" height="16" SRC="images/regex3_u0206.jpg"> typesetting conventions I've used. Unfortunately, it is not so on-screen. If you see something like <tt>[ ]*</tt>, you can guess that it is probably a space and a tab, but you can't be sure until you check. For convenience, Perl regular expressions provide the <img src=images/U2308.jpg border=0><tt>\t</tt><img src=images/U230B.jpg border=0> metacharacter. It simply matches a tabits only benefit over a literal tab is that it is visually apparent, so I use it in my expressions. Thus, <img src=images/U2308.jpg border=0><tt>[&#8226;<img border="0" alt="" id="195131084202" width="12" height="16" SRC="images/regex3_u0206.jpg">]*</tt><img src=images/U230B.jpg border=0> becomes <img src=images/U2308.jpg border=0><tt>[&#8226;\t]*</tt><img src=images/U230B.jpg border=0>.</P>
<p class="docText">Some other Perl convenience metacharacters<a name="IDX-CHP-2-0230"></a> 
 are <img src=images/U2308.jpg border=0><tt>\n</tt><img src=images/U230B.jpg border=0> (newline), <img src=images/U2308.jpg border=0><tt>\f</tt><img src=images/U230B.jpg border=0> (ASCII formfeed), and <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0> (backspace). Well, actually, <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0> is a backspace in some situations, but in others, it matches a word boundary. How can it be both? The next section tells us.</p>
<a name="regex3-CHP-2-SECT-2.3.1"></a>
<h5 id="title-IDAHL1LT" class="docSection3Title">2.2.3.1. A short asidemetacharacters galore</H5>
<a name="IDX-CHP-2-0231"></a> 
<a name="IDX-CHP-2-0232"></a> 
<a name="IDX-CHP-2-0233"></a> 
<a name="IDX-CHP-2-0234"></a> 
<a name="IDX-CHP-2-0235"></a> 
<a name="IDX-CHP-2-0236"></a> 
<a name="IDX-CHP-2-0237"></a> 
<a name="IDX-CHP-2-0238"></a> 
<a name="IDX-CHP-2-0239"></a> 
<a name="IDX-CHP-2-0240"></a> 
<a name="IDX-CHP-2-0241"></a> 
<a name="IDX-CHP-2-0242"></a> 
<a name="IDX-CHP-2-0243"></a> 
<a name="IDX-CHP-2-0244"></a> 

<p class="docText">We saw <tt>\n</tt> in earlier examples, but in those cases, it was in a string, not a regular expression. Like most languages, Perl <span class="docEmphasis">strings</span> have metacharacters of their own, and these are completely distinct from <span class="docEmphasis">regular expression</span> metacharacters. It is a common mistake for new programmers to get them confused. (VB.NET is a notable language that has very few string metacharacters.) Some of these string metacharacters conveniently look exactly the same as some comparable regex metacharacters. You can use the string metacharacter <tt>\t</tt> to get a tab into your string, while you can use the regex metacharacter <img src=images/U2308.jpg border=0><tt>\t</tt><img src=images/U230B.jpg border=0> to insert a tab-matching element into your regex.</p>
<a name="regex3-CHP-2-SIDEBAR-1"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Non-Capturing Parentheses: <img src=images/U2308.jpg border=0><tt>(?:&#8943;)</tt><img src=images/U230B.jpg border=0></h2>
<p class="docText">In <a class="docLink" href="#regex3-CHP-2-FIG-3">Figure 2-3</a>, we use the parentheses of the <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(</span>\.[0-9]*<span class="docEmphStrong">)</span>?</tt><img src=images/U230B.jpg border=0> part for their grouping property, so we could apply a question mark to the whole of <img src=images/U2308.jpg border=0><tt>\.[0-9]*</tt><img src=images/U230B.jpg border=0> and make it optional. Still, as a side effect, text matched within these parentheses is captured and saved to <tt>$2</tt>, which we don't use. Wouldn't it be better if there were a type of parentheses that we could use for grouping which didn't involve the overhead (and possible confusion) of capturing and saving text to a variable that we never intend to use?</p>
<p class="docText">Perl, and recently some other regex flavors, do provide a way to do this. Rather than using <img src=images/U2308.jpg border=0><tt>(&#8943;)</tt><img src=images/U230B.jpg border=0>, which group and capture, you can use the special notation <img src=images/U2308.jpg border=0><tt>(?:&#8943;)</tt><img src=images/U230B.jpg border=0>, which group <span class="docEmphasis">but do not capture</span>. With this notation, the "opening parentheses" is the three-character sequence <tt>(?:</tt>, which certainly looks odd. This use of '<tt>?</tt>' has no relation to the "optional" <img src=images/U2308.jpg border=0><tt>?</tt><img src=images/U230B.jpg border=0> metacharacter. (Peek ahead to page 90 for a note about why this odd notation was chosen.)</p>
<p class="docText">So, the whole expression becomes:</p>
<pre>
    if ($input =~ m/^([-+]?[0-9]+ <span class="docEmphStrong">(?:</span>\.[0-9]*<span class="docEmphStrong">)</span>?)([CF])$/)
</pre><br>

<p class="docText">Now, even though the parentheses surrounding <img src=images/U2308.jpg border=0><tt>[CF]</tt><img src=images/U230B.jpg border=0> are ostensibly the third set, the text they match goes to <tt>$2</tt> since, for counting purposes, the <img src=images/U2308.jpg border=0><tt>(?:&#8943;)</tt><img src=images/U230B.jpg border=0> set doesn't, well, count.</p>
<p class="docText">The benefits of this are twofold. One is that by avoiding the unnecessary capturing, the match process is more efficient (efficiency is something we'll look at in great detail in <a class="docLink" href="regex3-CHP-6.html#regex3-CHP-6">Chapter 6</a>). Another is that, overall, using exactly the type of parentheses needed for each situation may be less confusing later to someone reading the code who might otherwise be left wondering about the exact nature of each set of parentheses.</p>
<p class="docText">On the other hand, the <img src=images/U2308.jpg border=0><tt>(?:&#8943;)</tt><img src=images/U230B.jpg border=0> notation <span class="docEmphasis">is</span> somewhat unsightly, and perhaps makes the expression more difficult to grasp at a glance. Are the benefits worth it? Well, personally, I tend to use exactly the kind of parentheses I need, but in this particular case, it's probably not worth the confusion. For example, efficiency isn't really an issue since the match is done just once (as opposed to being done repeatedly in a loop).</p>
<p class="docText">Throughout this chapter, I'll tend to use <img src=images/U2308.jpg border=0><tt>(&#8943;)</tt><img src=images/U230B.jpg border=0> even when I don't need their capturing, just for their visual clarity.</p>
</td></tr></table></p><BR>
<p class="docText">The similarity is convenient, but I can't stress enough how important it is to maintain the distinction between the different types of metacharacters. It may not seem important for such a simple example as <tt>\t</tt>, but as we'll later see when looking at numerous different languages and tools, knowing which metacharacters are being used in each situation is extremely important.</p>
<a name="regex3-CHP-2-SIDEBAR-2"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Quiz Answer</H2>
<p class="docText">&#10070; <span class="docEmphasis">Answer to the question on page 44</span></P>
<p class="docText"><span class="docEmphStrong">How do <img src=images/U2308.jpg border=0><tt>[&#8226;<img border="0" alt="" id="195131084202" width="12" height="16" SRC="images/regex3_u0206.jpg">]*</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>&#8226;*|<img border="0" alt="" id="195131084202" width="12" height="16" SRC="images/regex3_u0206.jpg">*</tt><img src=images/U230B.jpg border=0> compare?</span></P>
<p class="docText"><img src=images/U2308.jpg border=0><tt>(&#8226;*|<img border="0" alt="" id="195131084202" width="12" height="16" SRC="images/regex3_u0206.jpg">*)</tt><img src=images/U230B.jpg border=0> allows either <img src=images/U2308.jpg border=0><tt>&#8226;*</tt><img src=images/U230B.jpg border=0> or <img src=images/U2308.jpg border=0><tt><img border="0" alt="" id="195131084202" width="12" height="16" SRC="images/regex3_u0206.jpg">*</tt><img src=images/U230B.jpg border=0> to match, which allows either some spaces (or nothing) or some tabs (or nothing). It doesn't, however, allow a <span class="docEmphasis">combination</span> of spaces and tabs.</p>
<p class="docText">On the other hand, <img src=images/U2308.jpg border=0><tt>[&#8226;<img border="0" alt="" id="195131084202" width="12" height="16" SRC="images/regex3_u0206.jpg">]*</tt><img src=images/U230B.jpg border=0> matches <img src=images/U2308.jpg border=0><tt>[&#8226;<img border="0" alt="" id="195131084202" width="12" height="16" SRC="images/regex3_u0206.jpg">]</tt><img src=images/U230B.jpg border=0> any number of times. With a string such as '<img border="0" alt="" id="195131084202" width="12" height="16" SRC="images/regex3_u0206.jpg">&#8226;&#8226;' it matches three times, a tab the first time and spaces the rest.</P>
<p class="docText"><img src=images/U2308.jpg border=0><tt>[&#8226;<img border="0" alt="" id="195131084202" width="12" height="16" SRC="images/regex3_u0206.jpg">]*</tt><img src=images/U230B.jpg border=0> is logically equivalent to <img src=images/U2308.jpg border=0><tt>(&#8226;|<img border="0" alt="" id="195131084202" width="12" height="16" SRC="images/regex3_u0206.jpg">)*</tt><img src=images/U230B.jpg border=0>, although for reasons shown in <a class="docLink" href="regex3-CHP-4.html#regex3-CHP-4">Chapter 4</a>, a character class is often much more efficient.</p>
</td></TR></table></P><br>
<p class="docText">We have already seen multiple sets of metacharacters conflict. In <a class="docLink" href="regex3-CHP-1.html#regex3-CHP-1">Chapter 1</a>, while working with <span class="docEmphasis">egrep</span>, we generally wrapped our regular expressions in single quotes. The whole <span class="docEmphasis">egrep</span> command line is written at the command-shell prompt, and the shell recognizes several of its own metacharacters. For example, to the shell, the space is a metacharacter that separates the command from the arguments and the arguments from each other. With many shells, single quotes are metacharacters that tell the shell to not recognize other shell metacharacters in the text between the quotes. (DOS uses double quotes.)</p>
<p class="docText">Using the quotes for the shell allows us to use spaces in our regular expression. Without the quotes, the shell would interpret the spaces in its own way instead of passing them through to <span class="docEmphasis">egrep</span> to interpret in <span class="docEmphasis">its</span> way. Many shells also recognize metacharacters such as <tt>$, *, ?</tt>, and so oncharacters that we are likely to want to use in a regex.</P>
<p class="docText">Now, all this talk about other shell metacharacters and Perl's string metacharacters has nothing to do with regular expressions themselves, but it has everything to do with <span class="docEmphasis">using</span> regular expressions in real situations. As we move through this book, we'll see numerous (sometimes complex) situations where we need to take advantage of multiple levels of simultaneously interacting metacharacters.</P>
<p class="docText">And what about this <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0> business? This <span class="docEmphasis">is</span> a regex thing: in Perl regular expressions, <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0> normally matches a word boundary, but within a character class, it matches a backspace. A word boundary would make no sense as part of a class, so Perl is free to let it mean something else. The warnings in the first chapter about how a character class's "sub language" is different from the main regex language certainly apply to Perl (and every other regex flavor as well).</P>

<a name="regex3-CHP-2-SECT-2.3.2"></a>
<h5 id="title-IDAKV1LT" class="docSection3Title">2.2.3.2. Generic "whitespace" with <tt>\s</tt></H5>
<a name="IDX-CHP-2-0245"></a> 
<a name="IDX-CHP-2-0246"></a> 
<a name="IDX-CHP-2-0247"></a> 
<a name="IDX-CHP-2-0248"></a> 

<p class="docText">While discussing whitespace, we left off with <img src=images/U2308.jpg border=0><tt>[&#8226;\t]</tt><img src=images/U230B.jpg border=0>. This is fine, but many regex flavors provide a useful shorthand: <img src=images/U2308.jpg border=0><tt>\s</tt><img src=images/U230B.jpg border=0>. While it looks similar to something like <img src=images/U2308.jpg border=0><tt>\t</tt><img src=images/U230B.jpg border=0> which simply represents a literal tab, the metacharacter <img src=images/U2308.jpg border=0><tt>\s</tt><img src=images/U230B.jpg border=0> is a shorthand for a whole character class that matches any "whitespace character." This includes (among others) space, tab, newline, and carriage return. With our example, the newline and carriage return don't really matter one way or the other, but typing <img src=images/U2308.jpg border=0><tt>\s*</tt><img src=images/U230B.jpg border=0> is easier than <img src=images/U2308.jpg border=0><tt>[&#8226;\t]*</tt><img src=images/U230B.jpg border=0>. After a while, you get used to seeing it, and <img src=images/U2308.jpg border=0><tt>\s*</tt><img src=images/U230B.jpg border=0> becomes easy to read even in complex regular expressions.</P>
<p class="docText">Our test now looks like:</p>
<pre>
    $input =~ <span class="docEmphStrong">m/</span>^([-+]?[0-9]+(\.[0-9]*)?)<div><img border="0" alt="" id="195131084202" width="21" height="12" SRC="images/regex3_u0207.jpg"></div>([CF])$<span class="docEmphStrong">/</span>
</pre><br>

<p class="docText">Lastly, we want to allow a lowercase letter as well as uppercase. This is as easy as adding the lowercase letters to the class: <img src=images/U2308.jpg border=0><tt>[CFcf]</tt><img src=images/U230B.jpg border=0>. However, I'd like to show another way as well:</p>
<pre>
    $input =~ <span class="docEmphStrong">m/</span>^([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$<span class="docEmphStrong">/</span><div><img border="0" alt="" id="195131084202" width="9" height="12" SRC="images/regex3_u0208.jpg"></div>
</pre><br>

<p class="docText">The added <tt>i</tt> is called a <span class="docEmphasis">modifier</span>, and placing it after the <tt>m/&#8943;/</tt> instructs Perl to do the match in a case-insensitive manner. It's not actually part of the regex, but part of the <tt>m/&#8943;/</tt> syntactic packaging that tells Perl what you want to do (apply a regex), and which regex to do it with (the one between the slashes). We've seen this type of thing before, with <span class="docEmphasis">egrep</span>'s <tt>-i</tt> option (&#9758; 15).</P>
<p class="docText">It's a bit too cumbersome to say "the <tt>i</tt> modifier" all the time, so normally "<tt>/i</tt>"<a name="IDX-CHP-2-0249"></a> 
<a name="IDX-CHP-2-0250"></a> 
 is used even though you don't add an extra <tt>/</tt> when actually using it. This <tt>/i</tt> notation is one way to specify modifiers in Perlin the next chapter, we'll see other ways to do it in Perl, and also how other languages allow for the same functionality. We'll also see other modifiers as we move along, including <tt>/g</tt> ("global match") and <tt>/x</tt> ("free-form expressions") later in this chapter.</p>
<p class="docText">Well, we've made a lot of changes. Let's try the new program:</p>
<pre>
    % <span class="docEmphStrong">perl -w convert</span>
    Enter a temperature (e.g., 32F, 100C):
    <span class="docEmphStrong">32 f</span>
    0.00 C is 32.00 F
    % <span class="docEmphStrong">perl -w convert</span>
    Enter a temperature (e.g., 32F, 100C):
    <span class="docEmphStrong">50 c</span>
    10.00 C is 50.00 F
</pre><BR>

<p class="docText">Oops! Did you notice that in the second try we thought we were entering 50&#176; Celsius, yet it was interpreted as 50&#176; Fahrenheit? Looking at the program's logic, do you see why?</p>
<p class="docText">Let's look at that part of the program again:</p>
<pre>
    if ($input =~ m/^([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$/i)
    {
         <img src=images/U22EE.jpg border=0>
        $type = $3; # <span class="docEmphasis">save to a named variable to make rest of program more readable</span>
        if ($type eq "C") { # <span class="docEmphasis">'eq' tests if two strings are equal</span>
            <img src=images/U22EE.jpg border=0>
        } else {
            <img src=images/U22EE.jpg border=0>
</pre><br>

<p class="docText">Although we modified the regex to allow a lowercase <tt>f</tt>, we neglected to update the rest of the program appropriately. As it is now, if <tt>$type</tt> isn't exactly '<tt>C</tt>', we assume the user entered Fahrenheit. Since we now also allow '<tt>c</tt>' to mean Celsius, we need to update the <tt>$type</tt> test:</p>
<pre>
    if ($type eq "C" <span class="docEmphStrong">or</span> $type eq "c"<span class="docEmphStrong">)</span> {
</pre><br>

<p class="docText">Actually, since this is a book on regular expressions, perhaps I should use:</p>
<pre>
    if ($type =~ m/c/i) {
</pre><br>

<p class="docText">In either case, it now works as we want. The final program is shown below. These examples show how the use of regular expressions can become intertwined with the rest of the program.</p>

<a name="regex3-CHP-2-SECT-2.3.3"></a>
<h5 id="title-IDAHD2LT" class="docSection3Title">2.2.3.3. Temperature-conversion program  final listing</h5>
<pre>
    print "Enter a temperature (e.g., 32F, 100C):\n";
    $input = &lt;STDIN&gt;;     # <span class="docEmphasis">This reads one line from the user</span>.
    chomp($input);              # <span class="docEmphasis">This removes the ending newline from $input</span>.

    if ($input =~ m/^([-+]?[0-9]+(\.[0-9]+)?)\s*([CF])$/i)
    {
        # <span class="docEmphasis">If we get in here, we had a match. $1 is the number, $3 is "C" or "F"</span>.
        $InputNum = $1;    # <span class="docEmphasis">Save to named variables to make the</span> ...
        $type = $3;        # <span class="docEmphasis">... rest of the program easier to read</span>.
        if ($type =~ m/c/i) {     # <span class="docEmphasis">Is it "c" or "C"?</span>
            # <span class="docEmphasis">The input was Celsius, so calculate Fahrenheit</span>
            $celsius = $InputNum;
            $fahrenheit = ($celsius * 9 / 5) + 32;
        } else {
            # <span class="docEmphasis">If not "C", it must be an "F", so calculate Celsius</span>
            $fahrenheit = $InputNum;
            $celsius = ($fahrenheit - 32) * 5 / 9;
        }
        # <span class="docEmphasis">At this point we have both temperatures, so display the results:</span>
        printf "%.2f C is %.2f F\n", $celsius, $fahrenheit;
    } else {
        # <span class="docEmphasis">The initial regex did not match, so issue a warning</span>.
        print "Expecting a number followed by \"C\" or \"F\",\n";
        print "so I don't understand \"$input\".\n";
    }
</pre><br>



<a name="regex3-CHP-2-SECT-2.4"></a>
<h4 id="title-IDAGE2LT" class="docSection2Title">2.2.4. Intermission</h4>
<p class="docText">Although we have spent much of this chapter coming up to speed with Perl, we've encountered a lot of new information about regexes:</p>
<ul><li><p class="docList"><span class="docEmphasis">1</span>. Most tools have their own particular flavor of regular expressions. Perl's appear to be of the same general type as <span class="docEmphasis">egrep</span>'s, but has a richer set of metacharacters. Many other languages, such as Java, Python, the .NET languages, and Tcl, have flavors similar to Perl's.</p></LI><li><p class="docList"><span class="docEmphasis">2</span>. Perl can check a string in a variable against a regex using the construct <tt><span class="docEmphStrong">$variable =~ m/regex/</span></tt>. The <tt>m</tt> indicates that a <span class="docEmphasis">match</span> is requested, while the slashes delimit (and are not part of) the regular expression. The whole test, as a unit, is either true or false.</P></li><li><p class="docList"><span class="docEmphasis">3</span>. The concept of metacharacterscharacters with special interpretationsis not unique to regular expressions. As discussed earlier about shells and double-quoted strings, multiple contexts often vie for interpretation. Knowing the various contexts (shell, regex, and string, among others), their metacharacters, and how they can interact becomes more important as you learn and use Perl, PHP, Java, Tcl, GNU Emacs, awk, Python, or other advanced languages. (And of course, within regular expressions, character classes have their own mini language with a distinct set of metacharacters.)</P></LI><LI><p class="docList"><span class="docEmphasis">4</span>. Among the more useful shorthands that Perl and many other flavors of regex provide (some of which we haven't seen yet) are:</P><pre>
    \t<a name="IDX-CHP-2-0251"></a> 
<a name="IDX-CHP-2-0252"></a> 
 a tab character
    \n<a name="IDX-CHP-2-0253"></a> 
<a name="IDX-CHP-2-0254"></a> 
 a newline character
    \r<a name="IDX-CHP-2-0255"></a> 
<a name="IDX-CHP-2-0256"></a> 
 a carriage-return character
    \s<a name="IDX-CHP-2-0257"></a> 
<a name="IDX-CHP-2-0258"></a> 
 matches any "whitespace" character (space, tab, newline, formfeed,
 and such)
    \S<a name="IDX-CHP-2-0259"></a> 
<a name="IDX-CHP-2-0260"></a> 
 anything not <img src=images/U2308.jpg border=0>\s<img src=images/U230B.jpg border=0>
    \w<a name="IDX-CHP-2-0261"></a> 
<a name="IDX-CHP-2-0262"></a> 
 <img src=images/U2308.jpg border=0>[a-zA-Z0-9_]<img src=images/U230B.jpg border=0> (useful as in <img src=images/U2308.jpg border=0>\w+<img src=images/U230B.jpg border=0>, ostensibly to match a word)
    \W<a name="IDX-CHP-2-0263"></a> 
<a name="IDX-CHP-2-0264"></a> 
 anything not <img src=images/U2308.jpg border=0>\w<img src=images/U230B.jpg border=0>, i.e., <img src=images/U2308.jpg border=0>[^a-zA-Z0-9_]<img src=images/U230B.jpg border=0>
    \d<a name="IDX-CHP-2-0265"></a> 
<a name="IDX-CHP-2-0266"></a> 
 <img src=images/U2308.jpg border=0>[0-9]<img src=images/U230B.jpg border=0>, i.e., a digit
    \D<a name="IDX-CHP-2-0267"></a> 
<a name="IDX-CHP-2-0268"></a> 
 anything not <img src=images/U2308.jpg border=0>\d<img src=images/U230B.jpg border=0>, i.e., <img src=images/U2308.jpg border=0>[^0-9]<img src=images/U230B.jpg border=0>
</pre><br>
</LI><li><p class="docList"><span class="docEmphasis">5</span>. The <tt>/i</tt> modifier makes the test case-insensitive. Although written in prose as "<tt>/i</tt>", only "<tt>i</tt>" is actually appended after the match operator's closing delimiter.</p></LI><LI><p class="docList"><span class="docEmphasis">6</span>. The somewhat unsightly <img src=images/U2308.jpg border=0><tt>(?:&#8943;)</tt><img src=images/U230B.jpg border=0> non-capturing parentheses can be used for grouping without capturing.</p></li><LI><p class="docList"><span class="docEmphasis">7</span>. After a successful match, Perl provides the variables <tt>$1, $2, $3</tt>, etc., which hold the text matched by their respective <img src=images/U2308.jpg border=0><tt>(&#8943;)</tt><img src=images/U230B.jpg border=0> parenthesized subexpressions in the regex. In concert with these variables, you can use a regex to pluck information from a string. (Other languages provide the same type of information in other ways; we'll see many examples in the next chapter.)</P><p class="docList">Subexpressions are numbered by counting open parentheses from the left, starting with one. Subexpressions can be nested, as in <img src=images/U2308.jpg border=0><tt>(Washington(&#8226;DC)?)</tt><img src=images/U230B.jpg border=0> Raw <img src=images/U2308.jpg border=0><tt>(&#8943;)</tt><img src=images/U230B.jpg border=0> parentheses can be intended for grouping only, but as a byproduct, they still capture into one of the special variables.</P></li></UL>


</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-2-SECT-1.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-2-SECT-3.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>