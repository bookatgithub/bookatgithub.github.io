<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 2.3.&nbsp; Modifying Text with Regular Expressions</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-2-SECT-2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-3.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="regex3-CHP-2-SECT-3"></a>
<H3 id="title-IDARFMNF" class="docSection1Title">2.3. Modifying Text with Regular Expressions</H3>
<a name="IDX-CHP-2-0269"></a> 
<a name="IDX-CHP-2-0270"></a> 
<a name="IDX-CHP-2-0271"></a> 

<p class="docText">So far, the examples have centered on finding, and at times, "plucking out" information from a string. Now we look at <span class="docEmphasis">substitution</span> (also called <span class="docEmphasis">search and replace</span>), a regex feature that Perl and many tools offer.</P>
<p class="docText">As we have seen, <tt><span class="docEmphStrong">$var =~ m/<span class="docEmphasis">regex</span>/</span></tt> attempts to match the given regular expression to the text in the given variable, and returns true or false appropriately. The similar construct <tt><span class="docEmphStrong">$var =~ s/</span><span class="docEmphasis">regex/replacement<span class="docEmphStrong">/</span></span></tt> takes it a step further: if the regex is able to match somewhere in the string held by <tt>$var</tt>, the text actually matched is replaced by <span class="docEmphasis">replacement</span>. The regex is the same as with <tt>m/&#8943;/</tt>, but the replacement (between the middle and final slash) is treated as a double-quoted string. This means that you can include references to variables, including <tt>$1, $2</tt>, and so on to refer to parts of what was just matched.</P>
<p class="docText">Thus, with <tt><span class="docEmphStrong">$var =~ s/&#8943;/&#8943;/</span></tt><a name="IDX-CHP-2-0272"></a> 
<a name="IDX-CHP-2-0273"></a> 
 the value of the variable is actually changed. (If there is no match to begin with, no replacement is made and the variable is left unchanged.) For example, if <tt>$var</tt> contained <tt>Jeff&#8226;Friedl</tt> and we ran</p>
<pre>
    $var =~ <span class="docEmphStrong">s/</span>Jeff/Jeffrey/;
</pre><BR>

<p class="docText"><tt>$var</tt> would end up with <tt>Jeffrey&#8226;Friedl</tt>. And if we did that again, it would end up with <tt>Jeffreyrey</tt>&#8226;<tt>Friedl</tt>. To avoid that, perhaps we should use a word-boundary metacharacter. As mentioned in the first chapter, some versions of <span class="docEmphasis">egrep</span> support <img src=images/U2308.jpg border=0><tt>\&lt;</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>\&gt;</tt><img src=images/U230B.jpg border=0> for their <span class="docEmphasis">start-of-word</span> and <span class="docEmphasis">end-of-word</span> metacharacters. Perl, however, provides the catch-all <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0>, which matches either:</p>
<pre>
    $var =~ s/<span class="docEmphStrong">\b</span>Jeff<span class="docEmphStrong">\b</span>/Jeffrey/;
</pre><br>

<p class="docText">Here's a slightly tricky quiz: like <tt>m/&#8943;/</tt>, the <tt>s/&#8943;/&#8943;/</tt> operation can use modifiers, such as the <tt>/i</tt> from page 47. (The modifier goes after the replacement.) Practically speaking, what does</P>
<pre>
    $var =~ s/\bJeff\b/Jeff/<span class="docEmphStrong">i</span>;
</pre><BR>

<p class="docText">accomplish? <a class="docLink" href="regex3-CHP-2-SECT-2.html#regex3-CHP-2-SIDEBAR-2">&#10070;</a> Flip the page to check your answer.</p>
<a name="regex3-CHP-2-SECT-3.1"></a>
<h4 id="title-IDA5JMNF" class="docSection2Title">2.3.1. Example: Form Letter</H4>
<p class="docText">Let's look at a rather humorous example that shows the use of a variable in the replacement string. I can imagine a form-letter system that might use a letter template with markers for the parts that must be customized for each letter.</P>
<p class="docText">Here's an example:</P>
<pre>
    Dear =FIRST=,
    You have been chosen to win a brand new =TRINKET=! Free!
    Could you use another =TRINKET= in the =FAMILY= household?
    Yes =SUCKER=, I bet you could! Just respond by.....
</pre><br>

<p class="docText">To process this for a particular recipient, you might have the program load:</P>
<pre>
    $given = "Tom";
    $family = "Cruise";
    $wunderprize = "100% genuine faux diamond";
</pre><BR>

<p class="docText">Once prepared, you could then "fill out the form" with:</p>
<pre>
    $letter =~ s/=FIRST=/$given/g;
    $letter =~ s/=FAMILY=/$family/g;
    $letter =~ s/=SUCKER=/$given $family/g;
    $letter =~ s/=TRINKET=/fabulous $wunderprize/g;
</pre><br>

<p class="docText">Each substitution's regex looks for a simple marker, and when found, replaces it with the text wanted in the final message. The replacement part is actually a Perl string in its own right, so it can reference variables, as each of these do. For example, the marked portion of <img border="0" alt="" width="287" height="14" SRC="images/regex3_u0209.jpg"> is interpreted just like the string "<tt>fabulous $wunderprize</tt>". If you just had the one letter to generate, you could forego using variables in the replacement string altogether, and just put the desired text directly. But, using this method makes automation possible, such as when reading names from a list.</p>
<p class="docText">We haven't seen the <tt>/g</tt><a name="IDX-CHP-2-0274"></a> 
 "global replacement" modifier yet. It instructs the <tt>s/&#8943;/&#8943;/</tt> to continue trying to find more matches, and make more replacements, after (and from where) the first substitution completes. This is needed if each string we check could contain multiple instances of the text to be replaced, and we want each substitution to replace them all, not just one.</p>
<p class="docText">The results are predictable, but rather humorous:</P>
<blockquote>
<p class="docText">Dear Tom,</p>
<p class="docText">You have been chosen to win a brand new fabulous 100% genuine faux diamond! Free! Could you use another fabulous 100% genuine faux diamond in the Cruise household? Yes Tom Cruise, I bet you could! Just respond by.....</p>
</blockquote>

<a name="regex3-CHP-2-SECT-3.2"></a>
<H4 id="title-IDASLMNF" class="docSection2Title">2.3.2. Example: Prettifying a Stock Price</h4>
<a name="IDX-CHP-2-0275"></a> 
<a name="IDX-CHP-2-0276"></a> 
<a name="IDX-CHP-2-0277"></a> 
<a name="IDX-CHP-2-0278"></a> 
<a name="IDX-CHP-2-0279"></a> 
<a name="IDX-CHP-2-0280"></a> 
<a name="IDX-CHP-2-0281"></a> 
<a name="IDX-CHP-2-0282"></a> 
<a name="IDX-CHP-2-0283"></a> 

<p class="docText">As another example, consider a problem I faced while working on some stock-pricing software with Perl. I was getting prices that looked like "9.0500000037272". The price was obviously 9.05, but because of how a computer represents the number internally, Perl sometimes prints them this way unless special formatting is used. Normally, I would just use <tt>printf</tt> to display the price with exactly two decimal digits as I did in the temperature-conversion example, but that was not appropriate in this case. At the time, stock prices were still given as fractions, and a price that ended with, say, <font size="-1">1/8</font>, should be shown with three decimals (".125"), not two.</p>
<a name="regex3-CHP-2-SIDEBAR-3"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Quiz Answer</h2>
<p class="docText">&#10070; <span class="docEmphasis">Answer to the question on page 50</span></p>
<p class="docText"><span class="docEmphStrong">Just what does <tt>$var =~ s/\bJeff\b/Jeff/i do?</tt></span></p>
<p class="docText">It might be tricky because of the way I posed it. Had I used <img src=images/U2308.jpg border=0><tt>\bJEFF\b</tt><img src=images/U230B.jpg border=0> or <img src=images/U2308.jpg border=0><tt>\bjeff\b</tt><img src=images/U230B.jpg border=0> or perhaps <img src=images/U2308.jpg border=0><tt>\bjEfF\b</tt><img src=images/U230B.jpg border=0> as the regex, the intent might have been more obvious. Because of <tt>/i</tt>, the word "Jeff" will be found without regard to capitalization. It will then be replaced by '<tt>Jeff</tt>', which has exactly the capitalization you see. (<tt>/i</tt> has no effect on the replacement text, although there are other modifiers examined in <a class="docLink" href="regex3-CHP-7.html#regex3-CHP-7">Chapter 7</a> that do.)</p>
<p class="docText">The end result is that "<tt>jeff</tt>", in any capitalization, is replaced by exactly '<tt>Jeff</tt>'.</p>
</td></tr></table></p><br>
<p class="docText">I boiled down my needs to "always take the first two digits after the decimal point, and take the third digit only if it is not zero. Then, remove any other digits." The result is that <img border="0" alt="" width="128" height="13" SRC="images/regex3_u0210.jpg"> or the already correct <img border="0" alt="" width="48" height="13" SRC="images/regex3_u0211.jpg"> is returned as "12.375", yet <img border="0" alt="" width="47" height="13" SRC="images/regex3_u0212.jpg"> is reduced to "37.50". Just what I wanted.</p>
<p class="docText">So, how would we implement this? The variable <tt>$price</tt> contains the string in question, so let's use:</p>
<pre>
    $price =~ s/(\.\d\d[1-9]?)\d*/$1/
</pre><BR>

<p class="docText">(Reminder: <img src=images/U2308.jpg border=0><tt>\d</tt><img src=images/U230B.jpg border=0> was introduced on page 49, and matches a digit.)</p>
<p class="docText">The initial <img src=images/U2308.jpg border=0><tt>\.</tt><img src=images/U230B.jpg border=0> causes the match to start at the decimal point. The subsequent <img src=images/U2308.jpg border=0><tt>\d\d</tt><img src=images/U230B.jpg border=0> then matches the first two digits that follow. The <img src=images/U2308.jpg border=0><tt>[1-9]?</tt><img src=images/U230B.jpg border=0> matches an additional non-zero digit if that's what follows the first two. Anything matched so far is what we want to <span class="docEmphasis">keep</span>, so we wrap it in parentheses to capture to <tt>$1</tt>. We can then use <tt>$1</tt> in the replacement string. If this is the only thing that matches, we replace exactly what was matched with itself  not very useful. However, we go on to match other items outside the <tt>$1</tt> parentheses. They don't find their way to the replacement string, so the effect is that they're removed. In this case, the "to be removed" text is any extra digits, the <img src=images/U2308.jpg border=0><tt>\d*</tt><img src=images/U230B.jpg border=0> at the end of the regex.</P>
<p class="docText">Keep this example in mind, as we'll come back to it in <a class="docLink" href="regex3-CHP-4.html#regex3-CHP-4">Chapter 4</a> when looking at the important mechanics of just what goes on behind the scenes during a match. Some very interesting lessons can be learned by playing with this example.</p>

<a name="regex3-CHP-2-SECT-3.3"></a>
<h4 id="title-IDAQYMNF" class="docSection2Title">2.3.3. Automated Editing</H4>
<a name="IDX-CHP-2-0284"></a> 
<a name="IDX-CHP-2-0285"></a> 

<p class="docText">I encountered another simple yet real-world example while working on this chapter. I was logged in to a machine across the Pacific, but the network was particularly slow. Just getting a response from hitting RETURN took more than a minute, but I needed to make a few small changes to a file to get an important program going. In fact, all I wanted to do was change every occurrence of <tt>sysread</tt> to <tt>read</tt>. There were only a few such changes to make, but with the slow response, the idea of starting up a full-screen editor was impractical.</P>
<p class="docText">Here's all I did to make all the changes I needed:</P>
<pre>
    % <span class="docEmphStrong">perl -p<a name="IDX-CHP-2-0286"></a> 
<a name="IDX-CHP-2-0287"></a> 
 -i<a name="IDX-CHP-2-0288"></a> 
<a name="IDX-CHP-2-0289"></a> 

 -e<a name="IDX-CHP-2-0290"></a> 
<a name="IDX-CHP-2-0291"></a> 
 <span class="docEmphasis">'s/sysread/read/g' file</span></span>
</pre><BR>

<p class="docText">This runs the Perl program <tt><span class="docEmphStrong">s/sysread/read/g</span></tt>. (Yes, that's the whole programthe <tt>-e</tt> flag indicates that the entire program follows right there on the command line.) The <tt>-p</tt> flag results in the substitution being done for every line of the named file, and the <tt>-i</tt> flag causes any changes to be written back to the file when done.</p>
<p class="docText">Note that there is no explicit target string for the substitute command to work on (that is, no <tt><span class="docEmphStrong">$var =~</span> &#8943;</tt>) because conveniently, the <tt>-p</tt> flag implicitly applies the program, in turn, to each line of the file. Also, because I used the <tt>/g</tt> modifier, I'm sure to replace multiple occurrences that might be in a line.</P>
<p class="docText">Although I applied this to only one file, I could have easily listed multiple files on the command line and Perl would have applied my substitution to each line of each file. This way, I can do mass editing across a huge set of files, all with one simple command. The particular mechanics with which this was done are unique to Perl, but the moral of the story is that regular expressions as part of a scripting language can be very powerful, even in small doses.</p>

<a name="regex3-CHP-2-SECT-3.4"></a>
<h4 id="title-IDAP1MNF" class="docSection2Title">2.3.4. A Small Mail Utility</H4>
<a name="IDX-CHP-2-0292"></a> 
<a name="IDX-CHP-2-0293"></a> 
<a name="IDX-CHP-2-0294"></a> 
<a name="IDX-CHP-2-0295"></a> 
<a name="IDX-CHP-2-0296"></a> 
<a name="IDX-CHP-2-0297"></a> 

<p class="docText">Let's work on another example tool. Let's say we have an email message in a file, and we want to prepare a file for a reply. During the preparation, we want to quote the original message so we can easily insert our own reply to each part. We also want to remove unwanted lines from the header of the original message, as well as prepare the header of our own reply.</P>
<p class="docText">The sidebar shows an example. The header has interesting fields  date, subject, and so onbut also much that we are not interested in that we'll want to remove. If the script we're about to write is called <span class="docEmphasis">mkreply</span>, and the original message is in the file <span class="docEmphasis">king.in</span>, we would make the reply template with:</p>
<pre>
    % <span class="docEmphStrong">perl -w mkreply king.in &gt; king.out</span>
</pre><br>

<p class="docText">(In case you've forgotten, the <tt>-w</tt> option enables extra Perl warnings &#9758; 38.)</P>
<a name="regex3-CHP-2-SIDEBAR-4"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<H2 class="docSidebarTitle">A Sample Email Message</H2>
<p class="docText"><tt>From elvis Thu Feb 29 11:15 2007</tt></p>
<p class="docText"><tt>Received: from elvis@localhost by tabloid.org (8.11.3) id KA8CMY</tt></p>
<p class="docText"><tt>Received: from tabloid.org by gateway.net (8.12.5/2) id N8XBK</tt></p>
<p class="docText"><tt>To: jfriedl@regex.info (Jeffrey Friedl)</tt></p>
<p class="docText"><tt>From: elvis@tabloid.org (The King)</tt></P>
<p class="docText"><tt>Date: Thu, Feb 29 2007 11:15</tt></p>
<p class="docText"><tt>Message-Id: &lt;2007022939939.KA8CMY@tabloid.org&gt;</tt></p>
<p class="docText"><tt>Subject: Be seein' ya around</tt></P>
<p class="docText"><tt>Reply-To: elvis@hh.tabloid.org</tt></p>
<p class="docText"><tt>X-Mailer: Madam Zelda's Psychic Orb [version 3.7 PL92]</tt></p>
<p class="docText"><tt>Sorry I haven't been around lately. A few years back I checked into that ole heartbreak hotel in the sky, ifyaknowwhatImean. The Duke says "hi". Elvis</tt></p>
</td></tr></table></p><br>
<p class="docText">We want the resulting file, <span class="docEmphasis">king.out</span>, to contain something like:</p>
<dl class="docList"><dd><tt>To: elvis@hh.tabloid.org (The King)</tt></dd><dd><tt>From: jfriedl@regex.info (Jeffrey Friedl)</tt></dd><dd><tt>Subject: Re: Be seein' ya around</tt></dd><dd><tt>On Thu, Feb 29 2007 11:15 The King wrote:</tt></dd><dd><tt>|&gt; Sorry I haven't been around lately. A few years back I checked</tt></dd><dd><tt>|&gt; into that ole heartbreak hotel in the sky, ifyaknowwhatImean.</tt></dd><dd><tt>|&gt; The Duke says "hi".</tt></dd><dd><tt>|&gt; Elvis</tt></dd></dl>
<p class="docText">Let's analyze this. To print out our new header, we need to know the destination address (in this case <tt>elvis@hh.tabloid.org</tt>, derived from the <tt>Reply-To</tt> field of the original), the recipient's real name (<tt>The King</tt>), our own address and name, as well as the subject. Additionally, to print out the introductory line for the message body, we need to know the message date.</p>
<p class="docText">The work can be split into three phases:</p>
<ul><li><p class="docList"><span class="docEmphasis">1</span>. Extract information from the message header.</p></li><li><p class="docList"><span class="docEmphasis">2</span>. Print out the reply header.</p></li><LI><p class="docList"><span class="docEmphasis">3</span>. Print out the original message, indented by '<tt>|&gt;&#8226;</tt>'.</p></LI></ul>
<p class="docText">I'm getting a bit ahead of myselfwe can't worry about processing the data until we determine how to read the data into the program. Fortunately, Perl makes this a breeze with the magic "<tt>&lt;&gt;</tt>" operator. This funny-looking construct gives you the next line of input when you assign from it to a normal <tt>$variable</tt>, as with "<tt>$variable = &lt;&gt;</tt>". The input comes from files listed after the Perl script on the command line (from <span class="docEmphasis">king.in</span> in the previous example).</p>
<p class="docText">Don't confuse the two-character operator <tt>&lt;&gt;</tt> with the shell's "<tt>&gt;</tt> <span class="docEmphasis">filename</span>" redirection or Perl's greater-than/less-than operators. It is just Perl's funny way to express a kind of a <tt>getline ()</tt> function.</P>
<p class="docText">Once all the input has been read, <tt>&lt;&gt;</tt> conveniently returns an undefined value (which is interpreted as a Boolean false), so an entire file can be processed with:</P>
<pre>
    while (<span class="docEmphStrong">$line = &lt; &gt;</span>) {
        ... <span class="docEmphasis">work with $line here</span> ...
    }
</pre><BR>

<p class="docText">We'll use something similar for our email processing, but the nature of email means we need to process the header specially. The header includes everything before the first blank line; the body of the message follows. To read only the header, we might use:</P>
<pre>
    # <span class="docEmphasis">Process the header</span>
    while ($line = &lt; &gt;) {
       if <span class="docEmphStrong">($line =~ m/^\s*$/)</span> {
           last; # <span class="docEmphasis">stop processing within this while loop, continue below</span>
       }
       ... <span class="docEmphasis">process header line here</span> ...
    }
    ... <span class="docEmphasis">processing for the rest of the message follows</span> ...
           <img src=images/U22EE.jpg border=0>
</pre><br>

<p class="docText">We check for the header-ending blank line with the expression <img src=images/U2308.jpg border=0><tt>^\s*$</tt><img src=images/U230B.jpg border=0>. It checks to see whether the target string has a beginning (as all do), followed by any number of whitespace characters (although we aren't really expecting any except the newline character that ends each line), followed by the end of the string.<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-2-FN-3">[<img src=images/U2020.jpg border=0>]</a></sup> The keyword <tt>last</tt> breaks out of the enclosing <span class="docEmphStrong">while</span> loop, stopping the header-line processing.</P><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-2-FN-3">[<img src=images/U2020.jpg border=0>]</a></sup> I use the word "string" instead of "line" because, although it's not really an issue with this particular example, regular expressions can be applied to a string that contains a multiline chunk of text. The caret and dollar anchors (normally) match only at the start and end of the string as a whole (we'll see a counter example later in this chapter). In any case, the distinction is not vital here because, due to the nature of our algorithm, we <span class="docEmphasis">know</span> that <tt>$line</tt> never has more than one logical line.</p></blockquote>
<p class="docText">So, inside the loop, after the blank-line check, we can do whatever work we like with each header line. In this case, we need to extract information, such as the subject and date of the message.</p>
<p class="docText">To pull out the subject, we can employ a popular technique we'll use often:</P>
<pre>
    if (<span class="docEmphStrong">$line =~ m/^Subject: (.*)/i)</span> {
        $subject = $1;
    }
</pre><BR>

<p class="docText">This attempts to match a string beginning with '<tt>Subject: &#8226;</tt>', having any capitalization. Once that much of the regex matches, the subsequent <img src=images/U2308.jpg border=0> <tt>.*</tt><img src=images/U230B.jpg border=0> matches whatever else is on the rest of the line. Since the <img src=images/U2308.jpg border=0> <tt>.*</tt><img src=images/U230B.jpg border=0> is within parentheses, we can later use <tt>$1</tt> to access the text of the subject. In our case, we just save it to the variable <tt>$subject</tt>. Of course, if the regex doesn't match the string (as it won't with most), the result for the <tt>if</tt> is false and <tt>$subject</tt> isn't set for that line.</p>
<a name="regex3-CHP-2-SIDEBAR-5"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">A Warning About <img src=images/U2308.jpg border=0><tt>.*</tt><img src=images/U230B.jpg border=0></h2>
<p class="docText">The expression <img src=images/U2308.jpg border=0><tt>.*</tt><img src=images/U230B.jpg border=0> is often used to mean "a bunch of anything," since dot can match anything (with some tools, anything except newlines) and star means that any amount is allowed, but none required. This can be quite useful.</P>
<p class="docText">However, some hidden "gotchas" can bite the user who doesn't fully understand the implications of how it works when used as part of a larger expression. We've already seen one example (&#9758; 26), and will see many more in <a class="docLink" href="regex3-CHP-4.html#regex3-CHP-4">Chapter 4</a> when this topic is discussed in depth (&#9758; 164).</P>
</td></tr></table></p><br>
<p class="docText">Similarly, we can look for the <tt>Date</tt> and <tt>Reply-To</tt> fields:</P>
<pre>
    if (<span class="docEmphStrong">$line =~ m/^Date: (.*)/i</span>) {
       $date = $1;
    }
    if (<span class="docEmphStrong">$line =~ m/^Reply-To: (.*)/i</span>) {
       $reply_address = $1;
    }
</pre><br>

<p class="docText">The <tt>From</tt>: line involves a bit more work. First, we want the one that begins with '<tt>From</tt><img border="0" alt="" width="7" height="10" SRC="images/regex3_u0213.jpg">', not the more cryptic first line that begins with '<tt>From</tt><img border="0" alt="" width="6" height="9" SRC="images/regex3_u0214.jpg">'. We want:</p>
<pre>
    From: elvis@tabloid.org (The King)
</pre><BR>

<p class="docText">It has the originating address, as well as the name of the sender in parentheses; our goal is to extract the name.</p>
<p class="docText">To match up through the address, we can use <img src=images/U2308.jpg border=0><tt>^From:&#8226;(\S+)</tt><img src=images/U230B.jpg border=0>.<a name="IDX-CHP-2-0298"></a> 
<a name="IDX-CHP-2-0299"></a> 
 As you might guess, <img src=images/U2308.jpg border=0><tt>\S</tt><img src=images/U230B.jpg border=0> matches anything that's <span class="docEmphasis">not</span> whitespace (&#9758; 49), so <img src=images/U2308.jpg border=0><tt>\s+</tt><img src=images/U230B.jpg border=0> matches up until the first whitespace (or until the end of the target text). In this case, that's the originating address. Once that's matched, we want to match whatever is in parentheses. Of course, we also need to match the parentheses themselves. This is done using <img src=images/U2308.jpg border=0><tt>\(</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>\)</tt><img src=images/U230B.jpg border=0>, escaping the parentheses to remove their special metacharacter meaning. Inside the parentheses, we want to match anythinganything except another parenthesis! That's accomplished with <img src=images/U2308.jpg border=0><tt>[^()]*</tt><img src=images/U230B.jpg border=0>. Remember, the character-class metacharacters are different from the "normal" regex metacharacters; inside a character class, parentheses are not special and do not need to be escaped.</p>
<p class="docText">So, putting this all together we get:</p>
<pre>
    <img src=images/U2308.jpg border=0>^From: &#8226;(\s+)&#8226; \(([^()]*)\)<img src=images/U230B.jpg border=0>
</pre><br>

<p class="docText">At first it might be a tad confusing with all those parentheses, so <a class="docLink" href="#regex3-CHP-2-FIG-4">Figure 2-4</a> on the facing page shows it more clearly.</p>
<a name="regex3-CHP-2-FIG-4"></a><p><center>
<h5 class="docFigureTitle">Figure 2-4. Nested parentheses; $1, and $2</h5><img border="0" alt="" width="278" height="134" SRC="images/regex3_0204.jpg">
</center></p><br>
<p class="docText">When the regex from <a class="docLink" href="#regex3-CHP-2-FIG-4">Figure 2-4</a> matches, we can access the sender's name as <tt>$2</tt>, and also have <tt>$1</tt> as a possible return address:</p>
<pre>
    if (<span class="docEmphStrong">$line =~ m/^From: (\s+) \(([^()]*)\)/i</span>) {
        $reply_address = $1;
        $from_name = $2;
    }
</pre><br>

<p class="docText">Since not all email messages come with a <tt>Reply-To</tt> header line, we use <tt>$1</tt> as a provisional return address. If there turns out to be a <tt>Reply-To</tt> field later in the header, we'll overwrite <tt>$reply_address</tt> at that point. Putting this all together, we end up with:</p>
<pre>
    while (<span class="docEmphStrong">$line = &lt; &gt;</span>)
    {
        if ($line =~ m/^\s*$/ ) { # <span class="docEmphasis">If we have an empty line</span>...
            last; # <span class="docEmphasis">this immediately ends the 'while' loop</span>.
    }
        if (<span class="docEmphStrong">$line =~ m/^Subject: (.*)/i</span>) {
            $subject = $1;
    }
        if (<span class="docEmphStrong">$line =~ m/^Date: (.*)/i</span>) {
            $date = $1;
    }
        if (<span class="docEmphStrong">$line =~ m/^Reply-To: (\s+)/i</span>) {
            $reply_address = $1;
    }
        if (<span class="docEmphStrong">$line =~ m/^From: (\s+) \(([^()]*)\)/i</span>) {
            $reply_address = $1;
            $from_name = $2;
        }
    }
</pre><br>

<p class="docText">Each line of the header is checked against all the regular expressions, and if it matches one, some appropriate variable is set. Many header lines won't be matched by any of the regular expressions, and so end up being ignored.</p>
<p class="docText">Once the <tt>while</tt> loop is done, we are ready to print out the reply header:<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-2-FN-4">[<img src=images/U2020.jpg border=0>]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-2-FN-4">[<img src=images/U2020.jpg border=0>]</a></sup> In Perl regular expressions and double-quoted strings, most '<tt>@</tt>' must be escaped (&#9758; 77).</p></blockquote>
<pre>
    print "To: $reply_address ($from_name)\n";
    print "From: jfriedl\@regex.info (Jeffrey Friedl)\n";
    print "Subject: Re: $subject\n";
    print "\n" ; # <span class="docEmphasis">blank line to separate the header from message body</span>.
</pre><BR>

<p class="docText">Notice how we add the <tt>Re</tt>: to the subject to informally indicate that it is a reply. Finally, after the header, we can introduce the body of the reply with:</p>
<pre>
    print "On $date $from_name wrote:\n";
</pre><BR>

<p class="docText">Now, for the rest of the input (the body of the message), we want to print each line with '<tt>|&gt;&#8226;</tt>' prepended:</p>
<pre>
    while ($line = &lt; &gt;) {
        print "|&gt; $line";
    }
</pre><br>

<p class="docText">Here, we don't need to provide a newline because we know that <tt>$line</tt> contains one from the input.</P>
<p class="docText">It is interesting to see that we can rewrite the code to prepend the quoting marker using a regex construct:</P>
<pre>
    $line =~ <span class="docEmphStrong">s/^/</span>|&gt; <span class="docEmphStrong">/</span>;
    print $line;
</pre><BR>

<p class="docText">The substitute searches for <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0>, which of course immediately matches at the beginning of the string. It doesn't actually match any characters, though, so the substitute "replaces" the "nothingness" at the beginning of the string with '<tt>|&gt;&#8226;</tt>'. In effect, it inserts '<tt>|&gt;&#8226;</tt>' at the beginning of the string. It's a novel use of a regular expression that is gross overkill in this particular case, but we'll see similar (but much more useful) examples later in this chapter.</P>
<a name="regex3-CHP-2-SECT-3.4.1"></a>
<h5 id="title-IDA4KNNF" class="docSection3Title">2.3.4.1. Real-world problems, real-world solutions</H5>
<p class="docText">It's hard to present a real-world example without pointing out its real-world short-comings. First, as I have commented, the goal of these examples is to show regular expressions in action, and the use of Perl is simply a vehicle to do so. The Perl code I've used here is not necessarily the most efficient or even the best approach, but, hopefully, it clearly shows the regular expressions at work.</p>
<p class="docText">Also, real-world email messages are far more complex than indicated by the simple problem addressed here. A <tt>From:</tt> line can appear in various different formats, only one of which our program can handle. If it doesn't match our pattern exactly, the <tt>$from_name</tt> variable never gets set, and so remains undefined (which is a kind of "no value" value) when we attempt to use it. The ideal fix would be to update the regex to handle all the different address/name formats, but as a first step, after checking the original message (and before printing the reply template), we can put:</p>
<pre>
    if (    not defined($reply_address)
         or not defined($from_name)
         or not defined($subject)
         or not defined($date) )
    {
         die "couldn't glean the required information!";
    }
</pre><BR>

<p class="docText">Perl's <tt>defined</tt> function indicates whether the variable has a value, while the <tt>die</tt> function issues an error message and exits the program.</P>
<p class="docText">Another consideration is that our program assumes that the <tt>From:</tt> line appears before any <tt>Reply-To:</tt> line. If the <tt>From:</tt> line comes later, it overwrites the <tt>$reply_address</tt> we took from the <tt>Reply-To:</tt> line.</p>

<a name="regex3-CHP-2-SECT-3.4.2"></a>
<h5 id="title-IDAEMNNF" class="docSection3Title">2.3.4.2. The "real" real world</H5>
<a name="IDX-CHP-2-0300"></a> 
<a name="IDX-CHP-2-0301"></a> 
<a name="IDX-CHP-2-0302"></a> 
<a name="IDX-CHP-2-0303"></a> 

<p class="docText">Email is produced by many different types of programs, each following their own idea of what they think the standard is, so email can be tricky to handle. As I discovered once while attempting to write some code in Pascal,<a name="IDX-CHP-2-0304"></a> 
 it can be <span class="docEmphasis">extremely</span> difficult without regular expressions. So much so, in fact, that I found it easier to write a Perl-like regex package in Pascal than attempt to do everything in raw Pascal! I had taken the power and flexibility of regular expressions for granted until I entered a world without them. I certainly didn't want to stay in that world long.</P>


<a name="regex3-CHP-2-SECT-3.5"></a>
<H4 id="title-IDAJNNNF" class="docSection2Title">2.3.5. Adding Commas to a Number with Lookaround</h4>
<p class="docText">Presenting large numbers with commas often makes reports more readable. Something like</P>
<pre>
    print "The US population<a name="IDX-CHP-2-0305"></a> 
 is $pop\n";
</pre><BR>

<p class="docText">might print out "The US population is 298444215," but it would look more natural to most English speakers to use "298,444,215" instead. How might we use a regular expression to help?</p>
<p class="docText">Well, when we insert commas mentally, we count sets of digits by threes from the right, and insert commas at each point where there are still digits to the left. It'd be nice if we could apply this natural process directly with a regular expression, but regular expressions generally work left-to-right. However, if we distill the idea of where commas should be inserted as "locations having digits on the right in exact sets of three, and at least some digits on the left," we can solve this problem easily using a set of relatively new regex features collectively called <span class="docEmphasis">lookaround</span>.</p>
<p class="docText">Lookaround constructs are similar to word-boundary metacharacters like <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0> or the anchors <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0> in that they don't match text, but rather match <span class="docEmphasis">positions</span> within the text. But, lookaround is a much more general construct than the special-case word boundary and anchors.</p>
<p class="docText">One type of lookaround, called <span class="docEmphasis">lookahead</span>, peeks forward in the text (toward the right) to see if its subexpression can match, and is successful as a regex component if it can. Positive lookahead is specified with the special sequence <img src=images/U2308.jpg border=0><tt>(?=&#8943;)</tt><img src=images/U230B.jpg border=0>, such as with <img src=images/U2308.jpg border=0><tt>(?=<span class="docEmphStrong">\d</span>)</tt><img src=images/U230B.jpg border=0>, which is successful at positions where a digit comes next. Another type of lookaround is <span class="docEmphasis">lookbehind</span>, which looks back (toward the left). It's given with the special sequence <img src=images/U2308.jpg border=0><tt>(?&lt;=&#8943;)</tt><img src=images/U230B.jpg border=0>, such as <img src=images/U2308.jpg border=0><tt>(?&lt;=\d)</tt><img src=images/U230B.jpg border=0>, which is successful at positions with a digit to the left (i.e., at positions after a digit).</p>
<a name="regex3-CHP-2-SECT-3.5.1"></a>
<H5 id="title-IDA5ONNF" class="docSection3Title">2.3.5.1. Lookaround doesn't "consume" text</h5>
<a name="IDX-CHP-2-0306"></a> 
<a name="IDX-CHP-2-0307"></a> 

<p class="docText">An important thing to understand about lookahead and other lookaround constructs is that although they go through the motions to see if their subexpression is able to match, they don't actually "consume" any text. That may be a bit confusing, so let me give an example. The regex <img src=images/U2308.jpg border=0><tt>Jeffrey</tt><img src=images/U230B.jpg border=0> matches</p>
<pre>
    &#8943;by <div><img border="0" alt="" width="60" height="14" SRC="images/regex3_u0215.jpg"></div> Friedl.
</pre><BR>

<p class="docText">but the same regex within lookahead, <img src=images/U2308.jpg border=0><tt>(?=Jeffrey)</tt><img src=images/U230B.jpg border=0>, matches only the marked location in:</p>
<pre>
    &#8943;by <sub><img src=images/U22CF.jpg border=0></sub>Jeffrey Friedl.
</pre><br>

<p class="docText">Lookahead uses its subexpression to check the text, but only to find a <span class="docEmphasis">location</span> in the text at which it can be matched, not the actual <span class="docEmphasis">text</span> it matches. But, combining it with something that does match text, such as <img src=images/U2308.jpg border=0><tt>Jeff</tt><img src=images/U230B.jpg border=0>, allows us to be more specific than <img src=images/U2308.jpg border=0><tt>Jeff</tt><img src=images/U230B.jpg border=0> alone. The combined expression, <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(?=Jeffrey)</span>Jeff</tt><img src=images/U230B.jpg border=0>, illustrated in the figure on the facing page, effectively matches "Jeff" only if it is part of "Jeffrey." It does match:</p>
<pre>
    &#8943;by <div><img border="0" alt="" width="30" height="12" SRC="images/regex3_u0216.jpg"></div>rey Friedl.
</pre><br>

<p class="docText">just like <img src=images/U2308.jpg border=0><tt>Jeff</tt><img src=images/U230B.jpg border=0> alone would, but it <span class="docEmphasis">doesn't</span> match on this line:</p>
<pre>
    &#8943; by Thomas Jefferson
</pre><br>

<p class="docText">By itself, <img src=images/U2308.jpg border=0><tt>Jeff</tt><img src=images/U230B.jpg border=0> would easily match this line as well, but since there's no position at which <img src=images/U2308.jpg border=0><tt>(?=Jeffrey)</tt><img src=images/U230B.jpg border=0> can match, they fail as a pair. Don't worry too much if the benefit of this doesn't seem obvious at this point. Concentrate now on the mechanics of what lookahead meanswe'll soon see realistic examples that illustrate their benefit more clearly.</p>
<p class="docText">It might be insightful to realize that <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(?=Jeffrey)</span>Jeff</tt><img src=images/U230B.jpg border=0> is effectively the same as <img src=images/U2308.jpg border=0><tt>Jeff<span class="docEmphStrong">(?=rey)</span></tt><img src=images/U230B.jpg border=0>. Both match "Jeff" only if it is part of "Jeffrey."</p>
<p class="docText">It's also interesting to realize that the order in which they're combined is very important. <img src=images/U2308.jpg border=0><tt>Jeff<span class="docEmphStrong">(?=Jeffrey)</span></tt><img src=images/U230B.jpg border=0> doesn't match any of these examples, but rather matches "Jeff" only if followed immediately by "Jeffrey."</p>
<a name="regex3-CHP-2-FIG-5"></a><p><center>
<h5 class="docFigureTitle">Figure 2-5. How<img src=images/U2308.jpg border=0><tt>(?=Jeffery)Jeff</tt><img src=images/U230B.jpg border=0> is applied</h5><img border="0" alt="" width="344" height="151" SRC="images/regex3_0205.jpg">
</center></p><br>
<p class="docText">Another important thing to realize about lookaround constructs concerns their somewhat ungainly notation. Like the non-capturing parentheses "<tt>(?:&#8943;)</tt>" introduced on page 45, these constructs use special sequences of characters as their "open parenthesis." There are a number of such special "open parenthesis" sequences, but they all begin with the two-character sequence "<span class="docEmphStrong">(?</span>". The character following the question mark tells what special function they perform. We've already seen the group-but-don't-capture "<tt>(?<span class="docEmphStrong">:</span>&#8943;)</tt>", lookahead<a name="IDX-CHP-2-0308"></a> 
 "<tt>(?<span class="docEmphStrong">=</span>&#8943;)</tt>", and lookbehind "<tt>(?<span class="docEmphStrong">&lt;=</span>&#8943;)</tt>" constructs, and we will see more as we go along.</p>

<a name="regex3-CHP-2-SECT-3.5.2"></a>
<h5 id="title-IDA2TNNF" class="docSection3Title">2.3.5.2. A few more lookahead examples</h5>
<a name="IDX-CHP-2-0309"></a> 
<a name="IDX-CHP-2-0310"></a> 

<p class="docText">We'll get to adding commas to numbers soon, but first let's see a few more examples of lookaround. We'll start by making occurrences of "Jeffs"<a name="IDX-CHP-2-0311"></a> 
 possessive by replacing them with "Jeff's". This is easy to solve without any kind of lookaround, with <tt><span class="docEmphStrong">s/</span>Jeffs<span class="docEmphStrong">/</span>Jeff's<span class="docEmphStrong">/g</span></tt>.<a name="IDX-CHP-2-0312"></a> 
<a name="IDX-CHP-2-0313"></a> 
 (Remember, the <tt>/g</tt> is for "global replacement" &#9758; 51.) Better yet, we can add word-boundary anchors: <tt><span class="docEmphStrong">s/</span>\bJeffs\b<span class="docEmphStrong">/</span>Jeff's<span class="docEmphStrong">/g</span></tt>.</P>
<p class="docText">We might even use something fancy like <tt><span class="docEmphStrong">s/</span>\b(Jeff)(s)\b<span class="docEmphStrong">/</span>$1'$2<span class="docEmphStrong">/g</span></tt>, but this seems gratuitously complex for such a simple task, so for the moment we'll stick with <tt><span class="docEmphStrong">s/</span>\bJeffs\b<span class="docEmphStrong">/</span>Jeff's<span class="docEmphStrong">/g</span></tt>. Now, compare this with:</p>
<pre>
    s/\bJeff(<span class="docEmphStrong">?=</span>s\b)/Jeff'/g
</pre><BR>

<p class="docText">The only change to the regular expression is that the trailing <img src=images/U2308.jpg border=0><tt>s\b</tt><img src=images/U230B.jpg border=0> is now within lookahead. <a class="docLink" href="#regex3-CHP-2-FIG-6">Figure 2-6</a> on the next page illustrates how this regex matches. Corresponding to the change in the regex, the '<tt>s</tt>' has been removed from the replacement string.</p>
<a name="regex3-CHP-2-FIG-6"></a><p><center>
<H5 class="docFigureTitle">Figure 2-6. How <img src=images/U2308.jpg border=0><tt>\b Jeff(?=s\b)</tt><img src=images/U230B.jpg border=0> is applied</H5><img border="0" alt="" width="410" height="149" SRC="images/regex3_0206.jpg">
</center></P><BR>
<p class="docText">After <img src=images/U2308.jpg border=0><tt>Jeff</tt><img src=images/U230B.jpg border=0> matches, the lookahead is attempted. It is successful only if <img src=images/U2308.jpg border=0><tt>s\b</tt><img src=images/U230B.jpg border=0> can match at that point (i.e., if '<tt>s</tt>' and a word boundary is what follows '<tt>Jeff</tt>'). But, because the <img src=images/U2308.jpg border=0><tt>s\b</tt><img src=images/U230B.jpg border=0> is part of a lookahead subexpression, the '<tt>s</tt>' it matches isn't actually considered part of the final match. Remember, while <img src=images/U2308.jpg border=0><tt>Jeff</tt><img src=images/U230B.jpg border=0> selects text, the lookahead part merely "selects" a position. The only benefit, then, to having the lookahead in this situation is that it can cause the whole regex to fail in some cases where it otherwise wouldn't. Or, another way to look at it, it allows us to check the entire <img src=images/U2308.jpg border=0><tt>Jeffs</tt><img src=images/U230B.jpg border=0> while pretending to match only <img src=images/U2308.jpg border=0><tt>Jeff</tt><img src=images/U230B.jpg border=0>.</p>
<p class="docText">Why would we want to pretend to match less than we really did? In many cases, it's because we want to recheck that same text by some later part of the regex, or by some later application of the regex. We see this in action in a few pages when we finally get to the number commafication example. The current example has a different reason: we want to check the whole of <img src=images/U2308.jpg border=0><tt>Jeffs</tt><img src=images/U230B.jpg border=0> because that's the situation where we want to add an apostrophe, but if we actually match only '<tt>Jeff</tt>', that allows the replacement string to be smaller. Since the '<tt>s</tt>' is no longer part of the match, it no longer needs to be part of what is replaced. That's why it's been removed from the replacement string.</P>
<p class="docText">So, while both the regular expressions and the replacement string of each example are different, in the end their results are the same. So far, these regex acrobatics may seem a bit academic, but I'm working toward a goal. Let's take the next step.</p>
<p class="docText">When moving from the first example to the second, the trailing <img src=images/U2308.jpg border=0><tt>s</tt><img src=images/U230B.jpg border=0> was moved from the "main" regex to lookahead. What if we did something similar with the leading <img src=images/U2308.jpg border=0><tt>Jeff</tt><img src=images/U230B.jpg border=0>, putting it into look<span class="docEmphasis">behind</span>? That would be <img src=images/U2308.jpg border=0><tt>(?&lt;=\bJeff)(?=s\b)</tt><img src=images/U230B.jpg border=0>, which reads as "find a spot where we can look behind to find '<tt>Jeff</tt>', and also look ahead to find '<tt>s</tt>'." It exactly describes where we want to insert the apostrophe. So, using this in our substitution gives:</p>
<pre>
    <span class="docEmphStrong">s/</span>(?&lt;=\bJeff)(?=s\b)/'<span class="docEmphStrong">/g</span>
</pre><BR>

<p class="docText">Well, this is getting interesting. The regex doesn't actually match any text, but rather matches <span class="docEmphasis">at a position</span> where we wish to insert an apostrophe. At such locations, we then "replace" the nothingness we just matched with an apostrophe. <a class="docLink" href="#regex3-CHP-2-FIG-7">Figure 2-7</a> illustrates this. We saw this exact type of thing just a few pages ago with the <span class="docEmphStrong">s/^/</span><tt>|&gt;&#8226;<span class="docEmphStrong">/</span></tt> used to prepend '<tt>|&gt;&#8226;</tt>' to the line.</P>
<a name="regex3-CHP-2-FIG-7"></a><p><center>
<h5 class="docFigureTitle">Figure 2-7. How <img src=images/U2308.jpg border=0><tt>(?&lt;=\bJeff)(?=s\b)</tt><img src=images/U230B.jpg border=0> is applied</H5><img border="0" alt="" width="452" height="147" SRC="images/regex3_0207.jpg">
</center></P><BR>
<p class="docText">Would the meaning of the expression change if the order of the two lookaround constructs was switched? That is, what does <tt><span class="docEmphStrong">s/</span>(?=s\b)(?&lt;=\bJeff)<span class="docEmphStrong">/'/g</span></tt> do? <a class="docLink" href="#regex3-CHP-2-SIDEBAR-6">&#10070;</a> Turn the page to check your answer.</p>
<p class="docText"><span class="docEmphStrong"><span class="docEmphasis">"Jeffs" summary</span></span> <a class="docLink" href="#regex3-CHP-2-TABLE-1">Table 2-1</a> summarizes the various approaches we've seen to replacing <tt>Jeffs</tt> with <tt>Jeff's</tt>.</P>
<a name="regex3-CHP-2-TABLE-1"></a><P><table cellspacing="0" FRAME="hsides" RULES="all" cellpadding="4" width="100%"><caption><h5 class="docTableTitle">Table 2-1. Approaches to the "Jeffs" Problem</h5></caption><colgroup span="2"><col><col></colgroup><thead><tr><th class="thead" scope="col" align="center"><p class="docText">Solution</p></th><th class="thead" scope="col" align="center"><p class="docText">Comments</P></th></tr></thead><tr><TD class="docTableCell" align="left"><p class="docText"><tt><span class="docEmphStrong">s/</span>\bJeffs\b<span class="docEmphStrong">/</span>Jeff's<span class="docEmphStrong">/g</span></tt></p></td><td class="docTableCell" align="left"><p class="docText">The simplest, most straightforward, and efficient solution; the one I'd use if I weren't trying to show other interesting ways to approach the same problem. Without lookaround, the regex "consumes" the entire '<tt>Jeffs</tt>'.</p></td></tr><tr><td class="docTableCell" align="left"><p class="docText"><tt><span class="docEmphStrong">s/</span>\b(Jeff)(s)\b<span class="docEmphStrong">/</span>$1'$2<span class="docEmphStrong">/g</span></tt></p></td><td class="docTableCell" align="left"><p class="docText">Complex without benefit. Still consumes entire'<tt>Jeffs</tt>'.</p></td></tr><tr><td class="docTableCell" align="left"><p class="docText"><tt><span class="docEmphStrong">s/</span>\bJeff(?=s\b)<span class="docEmphStrong">/</span>Jeff'<span class="docEmphStrong">/g</span></tt></p></TD><td class="docTableCell" align="left"><p class="docText">Doesn't actually consume the '<tt>s</tt>', but this not of much practical value here except to illustrate lookahead.</P></td></tr><TR><TD class="docTableCell" align="left"><p class="docText"><tt><span class="docEmphStrong">s/</span>(?&lt;=\bJeff)(?=s\b)<span class="docEmphStrong">/'/g</span></tt></P></TD><td class="docTableCell" align="left"><p class="docText">This regex doesn't actually "consume" any text. It uses both lookahead and lookbehind to match <span class="docEmphasis">positions</span> of interest, at which an apostrophe is inserted. Very useful to illustrate lookaround.</P></td></tr><TR><TD class="docTableCell" align="left"><p class="docText"><tt><span class="docEmphStrong">s/</span>(?=s\b)(?&lt;=\bJeff)<span class="docEmphStrong">/'/g</span></tt></p></td><TD class="docTableCell" align="left"><p class="docText">This is exactly the same as the one above, but the two lookaround tests are reversed. Because the tests don't consume text, the order in which they're applied makes no difference to whether there's a match.</P></TD></tr></table></P><BR>
<p class="docText">Before moving back to the adding-commas-to-numbers example, let me ask one question about these expressions. If I wanted to find "Jeffs" in a case-insensitive manner, but preserve the original case after the conversion, which of the expressions could I add <tt>/i</tt> to and have it work properly? I'll give you a hint: it won't work properly with two of them.<a class="docLink" href="#regex3-CHP-2-SIDEBAR-7">&#10070;</a> Think about which oneswould work, and why, and then turn the page to check your answer.</p>
<a name="regex3-CHP-2-SIDEBAR-6"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Quiz Answer</h2>
<p class="docText">&#10070; <span class="docEmphasis">Answer to the question on page 63</span></p>
<p class="docText"><span class="docEmphStrong">What does <tt>s/(?=s\b)(?&lt;=\bJeff)/'/g</tt> do?</span></P>
<p class="docText">In this case, it doesn't matter which order <img src=images/U2308.jpg border=0><tt>(?=s\b)</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>(?&lt;=\bJeff)</tt><img src=images/U230B.jpg border=0> are arranged. Whether "checking on the right, then the left" or the other way around, the key is that both checks must succeed at the same position for the combination of the two checks to succeed. For example, in the string '<tt>Thoma<sub><img src=images/U22CF.jpg border=0></sub>s&#8226;Jeff<sub><img src=images/U22CF.jpg border=0></sub>erson</tt>', both <img src=images/U2308.jpg border=0><tt>(?=s\b)</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>(?&lt;=\bJeff)</tt><img src=images/U230B.jpg border=0> can match (at the two locations marked), but since there is no one position where both can be successful, the combination of the two cannot match.</p>
<p class="docText">It's fine for now to use the somewhat vague phrase "combination of the two" to talk about this, as the meaning is fairly intuitive in this case. There are times, however, when exactly <span class="docEmphasis">how</span> a regex engine goes about applying a regex may not necessarily be quite so intuitive. Since how it works has immediate practical effects on what our regular expressions really mean, <a class="docLink" href="regex3-CHP-4.html#regex3-CHP-4">Chapter 4</a> discusses this in explicit detail.</p>
</td></tr></table></p><br>

<a name="regex3-CHP-2-SECT-3.5.3"></a>
<h5 id="title-IDAOCONF" class="docSection3Title">2.3.5.3. Back to the comma example ...</h5>
<a name="IDX-CHP-2-0314"></a> 
<a name="IDX-CHP-2-0315"></a> 

<p class="docText">You've probably already realized that the connection between the "Jeffs" example and the comma example lies in our wanting to insert something at a <span class="docEmphasis">location</span> that we can describe with a regular expression.</p>
<p class="docText">Earlier, we realized that we wanted to insert commas at "locations having digits on the right in exact sets of three, and at least some digits on the left." The second requirement is simple enough with lookbehind. One digit on the left is enough to fulfill the "some digits on the left" requirement, and that's <img src=images/U2308.jpg border=0><tt>(?&lt;=<span class="docEmphStrong">\d</span>)</tt><img src=images/U230B.jpg border=0>.</p>
<p class="docText">Now for "locations having digits on the right in exact sets of three." An exact set of three digits is <img src=images/U2308.jpg border=0><tt>\d\d\d</tt><img src=images/U230B.jpg border=0>, of course. We can wrap it with <img src=images/U2308.jpg border=0><tt>(&#8943;)+</tt><img src=images/U230B.jpg border=0> to allow more than one (the "sets" of our requirement), and append <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0> to ensure that nothing follows (the "exact" of our requirement). Alone, <img src=images/U2308.jpg border=0><tt>(\d\d\d)+$</tt><img src=images/U230B.jpg border=0> matches sets of triple digits to the end of the string, but when inserted into the <img src=images/U2308.jpg border=0><tt>(?=&#8943;)</tt><img src=images/U230B.jpg border=0> lookahead construct, it matches at <span class="docEmphasis">locations</span> that are even sets of triple digits from the end of the string, such as at the marked locations in '<sub><img src=images/U22CF.jpg border=0></sub>123<sub><img src=images/U22CF.jpg border=0></sub>456<sub><img src=images/U22CF.jpg border=0></sub>789'. That's actually more than we want we don't want to put a comma before the first digitso we add <img src=images/U2308.jpg border=0><tt>(?&lt;=<span class="docEmphStrong">\d</span>)</tt><img src=images/U230B.jpg border=0> to further limit the match locations.</p>
<p class="docText">This snippet:</p>
<pre>
    $pop =~ s/<span class="docEmphStrong">(?&lt;=\d)(?=(\d\d\d)+$)</span>/,/g;
    print "The US population is $pop\n";
</pre><br>

<p class="docText">indeed prints "The US population is 298,444,215" as we desire. It might, however, seem a bit odd that the parentheses surrounding <img src=images/U2308.jpg border=0><tt>\d\d\d</tt><img src=images/U230B.jpg border=0> are capturing parentheses. Here, we use them only for grouping, to apply the plus to the set of three digits, and so don't need their capture-to-<tt>$1</tt> functionality.</p>
<p class="docText">I could have used <img src=images/U2308.jpg border=0><tt>(?:&#8943;)</tt><img src=images/U230B.jpg border=0>, the non-capturing parentheses introduced in the sidebar on page 45. This would leave the regex as <img src=images/U2308.jpg border=0><tt>(?&lt;=\d)(?=<span class="docEmphStrong">(?:</span>\d\d\d)+$)</tt><img src=images/U230B.jpg border=0>. This is "better" in that it's more specificsomeone reading this later won't have to wonder if or where the <tt>$1</tt> associated with capturing parentheses might be used. It's also just a bit more efficient, since the engine doesn't have to bother remembering the captured text. On the other hand, even with <img src=images/U2308.jpg border=0><tt>(&#8943;)</tt><img src=images/U230B.jpg border=0> the expression can be a bit confusing to read, and with <img src=images/U2308.jpg border=0><tt>(?:&#8943;)</tt><img src=images/U230B.jpg border=0> even more so, so I chose the clearer presentation this time. These are common tradeoffs one faces when writing regular expressions. Personally, I like to use <img src=images/U2308.jpg border=0><tt>(?:&#8943;)</tt><img src=images/U230B.jpg border=0> everywhere it naturally applies (such as this example), but opt for clarity when trying to illustrate other points (as is usually the case in this book).</p>

<a name="regex3-CHP-2-SECT-3.5.4"></a>
<h5 id="title-IDANFONF" class="docSection3Title">2.3.5.4. Word boundaries and negative lookaround</h5>
<a name="IDX-CHP-2-0316"></a> 
<a name="IDX-CHP-2-0317"></a> 
<a name="IDX-CHP-2-0318"></a> 
<a name="IDX-CHP-2-0319"></a> 

<p class="docText">Let's say that we wanted to extend the use of this expression to commafying numbers that might be included within a larger string. For example:</P>
<pre>
    $text = "The population of 298444215 is growing";
       <img src=images/U22EE.jpg border=0>
    $text =~ s/<span class="docEmphStrong">(?&lt;=\d)(?=(\d\d\d)+$)</span>/,/g;
    print "$text\n";
</pre><br>

<p class="docText">As it stands, this doesn't work because the <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0> requires that the sets of three digits line up with the end of the string. We can't just remove it, since that would have it insert a comma everywhere that there was a digit on the left, and at least three digits on the rightwe'd end up with " ... of 2,9,8,4,4,4,215 is ..."!</P>
<p class="docText">It might seem odd at first, but we could replace <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0> with something to match a word boundary, <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0>.<a name="IDX-CHP-2-0320"></a> 
<a name="IDX-CHP-2-0321"></a> 
 Even though we're dealing with numbers only, Perl's concept of "words" helps us out. As indicated by <img src=images/U2308.jpg border=0><tt>\w</tt><img src=images/U230B.jpg border=0><a name="IDX-CHP-2-0322"></a> 
<a name="IDX-CHP-2-0323"></a> 
 (&#9758; 49), Perl and most other programs consider alphanumerics and underscore to be part of a word. Thus, any location with those on one side (such as our number) and not those on the other side (e.g., the end of the line, or the space after a number) is a word boundary.</p>
<p class="docText">This "such-and-such on one side, and this-and-that on the other" certainly sounds familiar, doesn't it? It's exactly what we did in the "Jeffs" example. One difference here is that one side must <span class="docEmphasis">not</span> match something. It turns out that what we've so far been calling lookahead and lookbehind should really be called <span class="docEmphasis">positive lookahead</span> and <span class="docEmphasis">positive lookbehind</span>, since they are successful at positions where their subexpression <span class="docEmphStrong">is</span> able to match. As <a class="docLink" href="#regex3-CHP-2-TABLE-2">Table 2-2</a> shows, their converse, <span class="docEmphasis">negative lookahead</span> and <span class="docEmphasis">negative lookbehind</span>, are also available. As their name implies, they are successful as positions where their subexpression <span class="docEmphStrong">is not</span> able to match.</p>
<a name="regex3-CHP-2-SIDEBAR-7"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<H2 class="docSidebarTitle">Quiz Answer</h2>
<p class="docText">&#10070; <span class="docEmphasis">Answer to the question on page 64</span></P>
<p class="docText"><span class="docEmphStrong">Which "Jeffs" solutions would preserve case when applied with <tt>/i</tt>?</span></p>
<p class="docText">To preserve case, you've got to either replace the exact characters consumed (rather than just always inserting <tt>'Jeff's'</tt>), or not consume any letters. The second solution listed in <a class="docLink" href="#regex3-CHP-2-TABLE-1">Table 2-1</a> takes the first approach, capturing what is consumed and using <tt>$1</tt> and <tt>$2</tt> to put it back. The last two solutions in the table take the "don't consume anything" approach. Since they don't consume text, they have nothing to preserve.</p>
<p class="docText">The first and third solutions hard-code the replacement string. If applied with <tt>/i</tt>, they don't preserve case. They end up incorrectly replacing <tt>JEFFS</tt> with <tt>Jeff's</tt> and <tt>Jeff'S</tt>, respectively.</P>
</TD></tr></table></p><BR>
<a name="regex3-CHP-2-TABLE-2"></a><P><table cellspacing="0" FRAME="hsides" RULES="all" cellpadding="4" width="100%"><caption><H5 class="docTableTitle">Table 2-2. Four Types of Lookaround</h5></caption><colgroup span="3"><col><col><col></colgroup><thead><TR><th class="thead" scope="col" align="left"><p class="docText">Type</P></th><th class="thead" scope="col" align="left"><p class="docText">Regex</p></th><th class="thead" scope="col" align="left"><p class="docText">Successful if the enclosed subexpression ...</p></th></tr></thead><tr><TD class="docTableCell" align="left"><p class="docText">Positive Lookbehind</p></td><TD class="docTableCell" align="left"><p class="docText">(<tt>?&lt;=......</tt>)</p></td><td class="docTableCell" align="left"><p class="docText">successful if <span class="docEmphasis">can</span> match to the <span class="docEmphasis">left</span></p></td></tr><tr><td class="docTableCell" align="left"><p class="docText">Negative Lookbehind</p></td><td class="docTableCell" align="left"><p class="docText">(<tt>?&lt;!......</tt>)</p></td><td class="docTableCell" align="left"><p class="docText">successful if <span class="docEmphasis">can</span> not match to the <span class="docEmphasis">left</span></p></td></tr><TR><td class="docTableCell" align="left"><p class="docText">Positive Lookahead</P></td><td class="docTableCell" align="left"><p class="docText">(<tt>?=......</tt>)</P></TD><TD class="docTableCell" align="left"><p class="docText">successful if <span class="docEmphasis">can</span> match to the <span class="docEmphasis">right</span></P></td></TR><tr><td class="docTableCell" align="left"><p class="docText">Negative Lookahead</P></TD><td class="docTableCell" align="left"><p class="docText">(<tt>?!......</tt>)</p></TD><TD class="docTableCell" align="left"><p class="docText">successful if <span class="docEmphasis">can</span> not match to the <span class="docEmphasis">right</span></P></td></TR></table></P><br>
<p class="docText">So, if a word boundary is a position with <img src=images/U2308.jpg border=0><tt>\w</tt><img src=images/U230B.jpg border=0> on one side and not <img src=images/U2308.jpg border=0><tt>\w</tt><img src=images/U230B.jpg border=0> on the other, we can use <img src=images/U2308.jpg border=0><tt>(?&lt;<span class="docEmphStrong">!</span>\w)(?<span class="docEmphStrong">=</span>\w)</tt><img src=images/U230B.jpg border=0> as a start-of-word boundary, and its complement <img src=images/U2308.jpg border=0><tt>(?&lt;=\w)(?<span class="docEmphStrong">!</span>\w)</tt><img src=images/U230B.jpg border=0> as an end-of-word boundary. Putting them together, we could use <img src=images/U2308.jpg border=0><tt>(?&lt;!\w)(?=\w)<span class="docEmphStrong">|</span>(?&lt;=\w)(?!\w)</tt><img src=images/U230B.jpg border=0> as a replacement for <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0>. In practice, it would be silly to do this for languages that natively support <tt>\b</tt> (<tt>\b</tt> is much more direct and efficient), but the individual alternatives may indeed be useful (&#9758; 134).</p>
<p class="docText">For our comma problem, though, we really need only <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(?!</span>\d<span class="docEmphStrong">)</span></tt><img src=images/U230B.jpg border=0> to cap our sets of three digits. We use that instead of <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0> or <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0>, which leaves us with:</p>
<pre>
    $text =~ s/(?&lt;=\d)<span class="docEmphStrong">(?=</span>(\d\d\d)+<div><img border="0" alt="" width="42" height="12" SRC="images/regex3_u0217.jpg"></div><span class="docEmphStrong">)</span>/,/g;
</pre><br>

<p class="docText">This now works on text like " ... tone of 12345Hz," which is good, but unfortunately it also matches the year in " ... the 1970s ..." Actually, any of these match " ... in 1970 ...," which is not good. There's no substitute for knowing the data you intend to apply a regex to, and knowing when that application is appropriate (and if your data has year numbers, this regex is probably not appropriate).</P>
<p class="docText">Throughout this discussion of boundaries and what we don't want to match, we used negative lookahead, <img src=images/U2308.jpg border=0><tt>(?!\w)</tt><img src=images/U230B.jpg border=0> or <img src=images/U2308.jpg border=0><tt>(?!\d)</tt><img src=images/U230B.jpg border=0>. You might remember the "something not a digit" metacharacter <img src=images/U2308.jpg border=0><tt>\D</tt><img src=images/U230B.jpg border=0> from page 49 and think that perhaps this could be used instead of <img src=images/U2308.jpg border=0><tt>(?!\d)</tt><img src=images/U230B.jpg border=0>. That would be a mistake. Remember, in <img src=images/U2308.jpg border=0><tt>!\D</tt><img src=images/U230B.jpg border=0>'s meaning of "something not a digit," <span class="docEmphasis">something</span> is required, just something that's not a digit. If there's <span class="docEmphasis">nothing</span> in the text being searched after the digit, <img src=images/U2308.jpg border=0><tt>\D</tt><img src=images/U230B.jpg border=0> can't match. (We saw something similar to this back in the sidebar on page 12.)</p>

<a name="regex3-CHP-2-SECT-3.5.5"></a>
<h5 id="title-IDA0QONF" class="docSection3Title">2.3.5.5. Commafication without lookbehind</H5>
<a name="IDX-CHP-2-0324"></a> 

<a name="IDX-CHP-2-0325"></a> 

<a name="IDX-CHP-2-0326"></a> 
<a name="IDX-CHP-2-0327"></a> 
<a name="IDX-CHP-2-0328"></a> 
<a name="IDX-CHP-2-0329"></a> 

<p class="docText">Lookbehind is not as widely supported (nor as widely used) as lookahead. Lookahead support was introduced to the world of regular expressions years before lookbehind, and though Perl now has both, this is not yet true for many languages. Therefore, it might be instructive to consider how to solve the commafication problem without lookbehind. Consider:</p>
<pre>
    $text =~ s/<span class="docEmphStrong">(</span><div><img border="0" alt="" width="15" height="12" SRC="images/regex3_u0218.jpg"></div><span class="docEmphStrong">)</span>(?=(\d\d\d)+(?!\d))/<div><img border="0" alt="" width="15" height="13" SRC="images/regex3_u0219.jpg"></div>,/g;
</pre><br>

<p class="docText">The change from the previous example is that the positive lookbehind that had been wrapped around the leading <img src=images/U2308.jpg border=0><tt>\d</tt><img src=images/U230B.jpg border=0> has been replaced by capturing parentheses, and the corresponding <tt>$1</tt> has been inserted into the replacement string, just before the comma.</p>
<p class="docText">What about if we don't have lookahead either? We can put the <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0> back for the <img src=images/U2308.jpg border=0><tt>(?!\d)</tt><img src=images/U230B.jpg border=0>, but does the technique used to eliminate the lookbehind also work for the remaining lookahead? That is, does the following work?</p>
<pre>
    $text =~ <span class="docEmphStrong">s/</span>(\d)((\d\d\d)+\b)/$1,$2<span class="docEmphStrong">/g</span>;
</pre><br>

<p class="docText"><a class="docLink" href="#regex3-CHP-2-SIDEBAR-8">&#10070;</a> Turn the page to check your answer.</p>


<a name="regex3-CHP-2-SECT-3.6"></a>
<h4 id="title-IDAWTONF" class="docSection2Title">2.3.6. Text-to-HTML Conversion</h4>
<p class="docText">Let's write a little tool to convert plain text to HTML. It's difficult to write a general tool that's useful for every situation, so for this section we'll just write a simple tool whose main goal is to be a teaching vehicle.</p>
<p class="docText">In all our examples to this point, we've applied regular expressions to variables containing exactly one line of text. For this project, it is easier (and more interesting) if we have the entire text we wish to convert available as one big string. In Perl, we can easily do this with:</p>
<pre>
    undef $/; # <span class="docEmphasis">Enter "file-slurp" mode</span>.
    $text = &lt;&gt;; # <span class="docEmphasis">Slurp up the first file given on the command line</span>.
</pre><br>

<a name="regex3-CHP-2-SIDEBAR-8"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Quiz Answer</h2>
<p class="docText">&#10070; <span class="docEmphasis">Answer to the question on page 67</span></p>
<p class="docText"><span class="docEmphStrong">Does <tt>$text =~ s/(\d)((\d\d\d)+\b)/$1,$2/g</tt> "commafy" a number?</span></P>
<p class="docText">This won't work the way we want. It leaves results such as "281,421906." This is because the digits matched by <img src=images/U2308.jpg border=0><tt>(\d\d\d)+</tt><img src=images/U230B.jpg border=0> are now actually part of the final match, and so are not left "unmatched" and available to the next iteration of the regex via the <tt>/g</tt>.</p>
<p class="docText">When one iteration ends, the next picks up the inspection of the text at the point where the previous match ended. We'd like that to be the point where the comma was inserted so we can go ahead and check to see whether additional commas need to be inserted later in the same number. But, in this case, that restarting point is at the end of all the digits. The whole point of using lookahead was to get the positional check without actually having the inspected text check count toward the final "string that matched."</P>
<p class="docText">Actually, this expression can still be used to solve this problem. If the expression is applied repeatedly by the host language, such as via a while loop, the newly-modified text is completely revisited each time. With each such application, one more comma is added (to each number in the target string, due to the <tt>/g</tt> modifier). Here's an example:</p>
<pre>
    while ( $text =~ s/(\d)((\d\d\d)+\b)/$1,$2/g ) {
       # <span class="docEmphasis">Nothing to do inside the body of the while -- we merely want to reapply the
 regex until it fails</span>
    }
</pre><br>

</TD></TR></table></P><BR>
<p class="docText">If our sample file contains the three short lines</p>
<pre>
    This is a sample file.
    It has three lines.
    That's all
</pre><BR>

<p class="docText">the variable <tt>$text</tt> will then contain</p>
<pre>
    This is a sample file.<div><img border="0" alt="" width="12" height="16" SRC="images/regex3_u0221.jpg"></div> It has three lines.<div><img border="0" alt="" width="12" height="16" SRC="images/regex3_u0221.jpg"></div> That's all<div><img border="0" alt="" width="12" height="16" SRC="images/regex3_u0221.jpg"></div>
</pre><br>

<p class="docText">although depending on the system, it could instead be</P>
<pre>
    This is a sample file. <div><img border="0" alt="" width="25" height="16" SRC="images/regex3_u0240.jpg"></div>It has three lines. <div><img border="0" alt="" width="25" height="16" SRC="images/regex3_u0240.jpg"></div> That's all<div><img border="0" alt="" width="25" height="16" SRC="images/regex3_u0240.jpg"></div>
</pre><BR>

<p class="docText">since most systems use a newline to end lines, but some (most notably Windows)use a carriage-return/newline combination. We'll be sure that our simple tool works with either.</p>
<a name="regex3-CHP-2-SECT-3.6.1"></a>
<h5 id="title-IDA2WONF" class="docSection3Title">2.3.6.1. Cooking special characters</H5>
<a name="IDX-CHP-2-0330"></a> 
<a name="IDX-CHP-2-0331"></a> 
<a name="IDX-CHP-2-0332"></a> 
<a name="IDX-CHP-2-0333"></a> 

<p class="docText">Our first step is to make any '<tt>&amp;</tt>', '<tt>&lt;</tt>', and '<tt>&gt;</tt>' characters in the original text "safe" by converting them to their proper HTML encodings, '<tt>&amp;</tt>', '<tt>&lt;</tt>', and '<tt>&gt;</tt>' respectively. Those characters are special to HTML, and not encoding them properly can cause display problems. I call this simple conversion "cooking the text for HTML," and it's fairly simple:</P>
<pre>
    $text =~ <span class="docEmphStrong">s/</span>&amp;/&amp;amp;<span class="docEmphStrong">/g;</span> # <span class="docEmphasis">Make the basic HTML</span> ...
    $text =~ <span class="docEmphStrong">s/</span>&lt;/&amp;lt;<span class="docEmphStrong">/g;</span> # <span class="docEmphasis">... characters &amp;, &lt;, and &gt;</span> ...
    $text =~ <span class="docEmphStrong">s/</span>&gt;/&amp;gt;<span class="docEmphStrong">/g;</span> # <span class="docEmphasis">... HTML safe</span>.
</pre><BR>

<p class="docText">Here again, we're using <tt>/g</tt> so that all of target characters will be converted (as opposed to just the first of each in the string if we didn't use <tt>/g</tt>). It's important to convert <span class="docEmphStrong">&amp;</span> first, since all three have '<tt>&amp;</tt>' in the replacement.</p>

<a name="regex3-CHP-2-SECT-3.6.2"></a>
<H5 id="title-IDAXZONF" class="docSection3Title">2.3.6.2. Separating paragraphs</H5>
<a name="IDX-CHP-2-0334"></a> 
<a name="IDX-CHP-2-0335"></a> 

<p class="docText">Next, we'll mark paragraphs by separating them with the <tt>&lt;p&gt;</tt> paragraph-separator HTML tag. An easy way to identify paragraphs is to consider them separated by blank lines. There are a number of ways that we might try to identify a blank line.</p>
<p class="docText">At first you might be tempted to use</p>
<pre>
    $text =~ <span class="docEmphStrong">s/</span>^$/&lt;p&gt;<span class="docEmphStrong">/g;</span>
</pre><br>

<p class="docText">to match a "start-of-line position followed immediately by an end-of-line position. "Indeed, as we saw in the answer on page 10, this would work in a tool like <span class="docEmphasis">egrep</span> where the text being searched is always considered in chunks containing a single logical line. It would also work in Perl in the context of the earlier email example where we knew that each string contained exactly one logical line.</p>
<p class="docText">But, as I mentioned in the footnote on page 55, <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0> normally refer not to logical <span class="docEmphasis">line</span> positions, but to the absolute start- and end-of-<span class="docEmphasis">string</span> positions.<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-2-FN-5">[<img src=images/U2020.jpg border=0>]</a></sup> So, now that we have multiple logical lines embedded within our target string, we need to do something different.</P><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-2-FN-5">[<img src=images/U2020.jpg border=0>]</a></sup> Actually, <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0> is often a bit more complex than simply "end of string," although that's not important to us for this example. For details, see the discussion of end-of-line anchors on page 129.</p></blockquote>
<p class="docText">Luckily, most regex-endowed languages give us an easy solution, an <span class="docEmphasis">enhanced line anchor</span> match mode in which the meaning of <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0> to change from <span class="docEmphasis">string</span> related to the <span class="docEmphasis">logical-line</span> related meaning we need for this example. With Perl, this mode is specified with the <tt>/m</tt> modifier:</p>
<pre>
    $text =~ <span class="docEmphStrong">s/</span>^$/&lt;p&gt;<span class="docEmphStrong">/mg;</span>
</pre><BR>

<p class="docText">Notice how <tt>/m</tt> and <tt>/g</tt> have been combined. (When using multiple modifiers, you can combine them in any order.) We'll see how other languages handle modifiers in the next chapter.</p>
<p class="docText">Thus, if we start with '&#8943;<tt>chapter</tt>.<img border="0" alt="" width="12" height="16" SRC="images/regex3_u0220.jpg"><img border="0" alt="" width="12" height="16" SRC="images/regex3_u0220.jpg"><tt>Thus</tt>&#8943;' in <tt>$text</tt>, we will end up with '&#8943;<tt>chapter</tt>. <img border="0" alt="" width="12" height="16" SRC="images/regex3_u0220.jpg"><span class="docEmphStrong">&lt;p&gt;</span> <img border="0" alt="" width="12" height="16" SRC="images/regex3_u0220.jpg"> <tt>Thus</tt>&#8943;' as we want.</p>
<p class="docText">It won't work, however, if there are spaces or other whitespace on the "blank" line. To allow for spaces, we can use <img src=images/U2308.jpg border=0><tt>^<img border="0" alt="" width="16" height="12" SRC="images/regex3_u0222.jpg">$</tt><img src=images/U230B.jpg border=0>, or perhaps <img src=images/U2308.jpg border=0><tt>^<img border="0" alt="" width="70" height="14" SRC="images/regex3_u0223.jpg">$</tt><img src=images/U230B.jpg border=0> to allow for spaces, tabs, and the carriage return that some systems have before the line-ending newline. These are fundamentally different from <img src=images/U2308.jpg border=0><tt>^$</tt><img src=images/U230B.jpg border=0> alone in that these now match actual <span class="docEmphasis">characters</span>, while <img src=images/U2308.jpg border=0><tt>^$</tt><img src=images/U230B.jpg border=0> matches only a <span class="docEmphasis">position</span>. But, since we don't need those spaces, tabs, and carriage returns in this case, it's fine to match them (and then replace them with our paragraph tag).</p>
<p class="docText">If you remember <img src=images/U2308.jpg border=0><tt>\s</tt><img src=images/U230B.jpg border=0> from page 47, you might be inclined to use <img src=images/U2308.jpg border=0><tt><img border="0" alt="" width="30" height="13" SRC="images/regex3_u0224.jpg">$</tt><img src=images/U230B.jpg border=0>, just as we did in the email example on page 55. If we use <img src=images/U2308.jpg border=0><tt>\s</tt><img src=images/U230B.jpg border=0> instead of <img src=images/U2308.jpg border=0><tt>[&#8226;\t\r]</tt><img src=images/U230B.jpg border=0>, the fact that <img src=images/U2308.jpg border=0><tt>\s</tt><img src=images/U230B.jpg border=0> can match a newline means that the overall meaning changes from "find <span class="docEmphasis">lines</span> that are blank except for whitespace" to "find <span class="docEmphasis">spans of lines</span> that are blank except for whitespace." This means that if we have several blank lines in a row, <img src=images/U2308.jpg border=0><tt>^\s*$</tt><img src=images/U230B.jpg border=0> is able to match them all in one shot. The fortunate result is that the replacement leaves just one <tt>&lt;p&gt;</tt> instead of the several in a row we would otherwise end up with.</p>
<p class="docText">Therefore, if we have the string</p>
<pre>
    &#8943; with.<div><img border="0" alt="" width="12" height="16" SRC="images/regex3_u0220.jpg"></div><div><img border="0" alt="" width="12" height="16" SRC="images/regex3_u0220.jpg"></div><div><img border="0" alt="" width="12" height="16" SRC="images/regex3_u0220.jpg"></div><div><img border="0" alt="" width="12" height="16" SRC="images/regex3_u0206.jpg"></div> &#8226; <div><img border="0" alt="" width="12" height="16" SRC="images/regex3_u0220.jpg"></div> Therefore &#8943;
</pre><br>

<p class="docText">in the variable <tt>$text</tt>, and we use</p>
<pre>
    $text =~ <span class="docEmphStrong">s/</span>^<div><img border="0" alt="" width="57" height="13" SRC="images/regex3_u0225.jpg"></div>*$/&lt;p&gt;<span class="docEmphStrong">/mg;</span>
</pre><br>

<p class="docText">we'll end up with:</p>
<pre>
    &#8943; with. <div><img border="0" alt="" width="12" height="16" SRC="images/regex3_u0220.jpg"></div><div><img border="0" alt="" width="110" height="14" SRC="images/regex3_u0226.jpg"></div><div><img border="0" alt="" width="12" height="16" SRC="images/regex3_u0220.jpg"></div> Therefore ...
</pre><br>

<p class="docText">But, if we use</p>
<pre>
    $text =~ <span class="docEmphStrong">s/</span>^<div><img border="0" alt="" width="15" height="13" SRC="images/regex3_u0227.jpg"></div>*$/&lt;p&gt;<span class="docEmphStrong">/mg;</span>
</pre><br>

<p class="docText">we'll end up instead with the more desirable:</p>
<pre>
    &#8943; with.<div><img border="0" alt="" width="12" height="16" SRC="images/regex3_u0220.jpg"></div><div><img border="0" alt="" width="27" height="12" SRC="images/regex3_u0228.jpg"></div><div><img border="0" alt="" width="12" height="16" SRC="images/regex3_u0220.jpg"></div> Therefore &#8943;
</pre><br>

<p class="docText">So, we'll stick with <img src=images/U2308.jpg border=0><tt>^\s*$</tt><img src=images/U230B.jpg border=0> in our final program.</p>

<a name="regex3-CHP-2-SECT-3.6.3"></a>
<h5 id="title-IDAYCPNF" class="docSection3Title">2.3.6.3. "Linkizing" an email address</h5>
<a name="IDX-CHP-2-0336"></a> 

<a name="IDX-CHP-2-0337"></a> 

<p class="docText">The next step in our text-to-HTML converter is to recognize an email address, and turn it into a "mailto" link. This would convert something like "<a class="docLink" href="mailto:jfriedl@oreilly.com">jfriedl@oreilly.com</a>" to <tt>&lt;a &#8226; href="mailto:jfriedl@oreilly.com"&gt;jfriedl@oreilly.com&lt;/a&gt;.</tt></P>
<p class="docText">It's a common desire to match or validate an email address with a regular expression. The official address specification is quite complex, so to do it exactly is difficult, but we can use something less complex that works for most email addresses we might run into. The basic form of an email address is "<span class="docEmphasis">username@hostname</span>". Before looking at just what regular expression to use for each of those parts, let's look at the context we'll use them in:</p>
<pre>
    $text =~ <span class="docEmphStrong">s/</span>\b(username regex\@hostname regex)\b/&lt;a href="mailto:$1"&gt;$1&lt;\/a&gt;<span class="docEmphStrong">/g;</span>
</pre><BR>

<p class="docText">The first things to notice are the two marked backslash characters, one in the regex ('<tt>\@</tt>') and one toward the end of the replacement string. Each is there for a different reason. I'll defer the discussion of <tt>\@</tt> until a bit later (&#9758; 77), for the moment merely saying that Perl requires <tt>@</tt> symbols to be escaped when used in a regex literal.</p>
<p class="docText">The backslash before the '<tt>/</tt>' in the replacement string is a bit more useful to talk about at the moment. We've seen that the basic form of a Perl search and replace is <tt>s</tt><span class="docEmphStrong">/</span><span class="docEmphasis">regex<span class="docEmphStrong">/</span>replacement<span class="docEmphStrong">/</span>modifiers</span>, with the forward slashes delimiting the parts. Now, if we wish to include a forward slash within one of the parts, Perl requires us to escape it to indicate that it should not be taken as a delimiter, but rather included as part of the regex or replacement string. This means that we would need to use <tt>&lt;<img border="0" alt="" width="7" height="13" SRC="images/regex3_u0229.jpg">/a&gt;</tt> if we wish to get <tt>&lt;/a&gt;</tt> into the replacement string, which is just what we did here.</p>
<p class="docText">This works, but it's a little ugly, so Perl allows us to pick our own delimiters. For instance, <tt>s</tt><span class="docEmphStrong">!</span><span class="docEmphasis">regex</span><span class="docEmphStrong">!</span><span class="docEmphasis">string</span><span class="docEmphStrong">!</span><span class="docEmphasis">modifiers</span> or <tt>s</tt><span class="docEmphStrong">{</span><span class="docEmphasis">regex</span><span class="docEmphStrong">}{</span><span class="docEmphasis">string</span><span class="docEmphStrong">}</span><span class="docEmphasis">modifiers</span>. With either, since the slash in the replacement string no longer conflicts with the delimiter, it no longer needs to be escaped. The delimiters for the regex and string parts pair up nicely in the second example, so I'll use that form from now on.</P>
<p class="docText">Returning to the code snippet, notice how the entire address part is wrapped in <img src=images/U2308.jpg border=0><tt>\b&#8943;\b</tt><img src=images/U230B.jpg border=0>. Adding these word boundaries help to avoid an embedded match like in '<img border="0" alt="" width="150" height="13" SRC="images/regex3_u0230.jpg"><tt>piler</tt>'. Although running into a nonsensical string like that is probably rare, it's simple enough to use the word boundaries to guard against matching it when we do, so I use them. Notice also that the entire address part is wrapped in parentheses. These are to capture the matched address, making it available to the replacement string '<tt>&lt;a&#8226;href="mailto:<span class="docEmphStrong">$1</span>"&gt;<span class="docEmphStrong">$1</span>&lt;/a&gt;</tt>'.</P>

<a name="regex3-CHP-2-SECT-3.6.4"></a>
<H5 id="title-IDA0GPNF" class="docSection3Title">2.3.6.4. Matching the username and hostname</H5>
<a name="IDX-CHP-2-0338"></a> 
<a name="IDX-CHP-2-0339"></a> 
<a name="IDX-CHP-2-0340"></a> 
<a name="IDX-CHP-2-0341"></a> 
<a name="IDX-CHP-2-0342"></a> 
<a name="IDX-CHP-2-0343"></a> 

<p class="docText">Now we turn our attention to actually matching an email address by building those <span class="docEmphasis">username</span> and <span class="docEmphasis">hostname</span> regular expressions. Hostnames, like <tt>regex.info</tt> and <tt><a class="docLink" target="_blank" href="http://www.oreilly.com">www.oreilly.com</a></tt>, consist of dot-separated parts ending with <tt>'com', 'edu', 'info', 'uk'</tt>, or other selected sequences. A simplistic approach to matching an email address could be <img src=images/U2308.jpg border=0><tt>\w+<span class="docEmphStrong">\@</span>\w+(\.\w+)+</tt><img src=images/U230B.jpg border=0>, which allows <img src=images/U2308.jpg border=0><tt>\w+</tt><img src=images/U230B.jpg border=0> for the username and the same for each part of the hostname. In practice, though, you'll need something a little more specific. For usernames, you'll run into some with periods and dashes in them (although rarely does a username start with one of these). So, rather than <img src=images/U2308.jpg border=0><tt>\w+</tt><img src=images/U230B.jpg border=0>, we'll try <img src=images/U2308.jpg border=0><tt>\w[-.\w]*</tt><img src=images/U230B.jpg border=0>. This requires the name to start with a <img src=images/U2308.jpg border=0><tt>\w</tt><img src=images/U230B.jpg border=0> character, but then allows periods and dashes as well. (Notice how we are sure to put the dash first in the class, to ensure that it's taken as a literal dash, and not the part of an <tt>a-z</tt> type of range? With many flavors, a range like <tt>.-\w</tt> is almost certainly wrong, yielding a fairly random set of letters, numbers, and punctuation that's dependent on the program and the computer's native character encoding. Perl handles <tt>.-\w</tt> in a class just fine, but being careful with dash in a class is a good habit to get into.)</p>
<p class="docText">The hostname part is a bit more complex in that the dots are strictly separators, which means that there must be something in between for them to separate. This is why even in the simplistic version earlier, the hostname part uses <img src=images/U2308.jpg border=0><tt>\w+(\.\w+)+</tt><img src=images/U230B.jpg border=0> instead of <img src=images/U2308.jpg border=0><tt>[\w.]+</tt><img src=images/U230B.jpg border=0>. The latter incorrectly matches '..<tt>x</tt>..'. But, even the former matches in '<tt>Artichokes</tt> <img border="0" alt="" width="47" height="13" SRC="images/regex3_u0231.jpg">', so we still need to be more specific.</P>
<p class="docText">One approach is to specifically list what the last component can be, along the lines of <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">\w+(\.\w+)*\.(com|edu|info)</span></tt><img src=images/U230B.jpg border=0>. (That list of alternatives really should be <tt><span class="docEmphStrong">com|edu|gov|int|mil|net|org|biz|info|name|museum|coop|aero|[a-z][a-z]</span></tt>, but I'll use the shorter list to keep the example uncluttered.) This allows a leading <img src=images/U2308.jpg border=0><tt>\w+</tt><img src=images/U230B.jpg border=0> part, along with optional additional <img src=images/U2308.jpg border=0><tt>\.\w+</tt><img src=images/U230B.jpg border=0> parts, finally followed by one of the specific ending parts we've listed.</p>
<p class="docText">Actually, <img src=images/U2308.jpg border=0><tt>\w</tt><img src=images/U230B.jpg border=0> is not quite appropriate. It allows ASCII letters and digits, which is good, but with some systems may allow non-ASCII letters such as <tt>&aacute;, &ccedil;, &#926;, &AElig;</tt>, and with most flavors, an underscore as well. None of these extra characters are allowed in a hostname. So, we probably should use <img src=images/U2308.jpg border=0><tt>[a-zA-Z0-9]</tt><img src=images/U230B.jpg border=0>, or perhaps <img src=images/U2308.jpg border=0><tt>[a-z0-9]</tt><img src=images/U230B.jpg border=0> with the <tt>/i</tt> modifier (for a case-insensitive match). Hostnames can also have a dash as well, so we'll use <img src=images/U2308.jpg border=0><tt>[-a-z0-9]</tt><img src=images/U230B.jpg border=0> (again, being careful to put the dash first). This leaves us with <img src=images/U2308.jpg border=0><tt>[-a-z0-9]+(\.[-a-z0-9]+)*\.(com|edu|info)</tt><img src=images/U230B.jpg border=0> for the hostname part.</p>
<p class="docText">As with all regex examples, it's important to remember the context in which they will be used. By itself, <img src=images/U2308.jpg border=0><tt>[-a-z0-9]+(\.[-a-z0-9]+)*\.(com|edu|info)</tt><img src=images/U230B.jpg border=0> could match, say '<tt>run C:\\<img border="0" alt="" width="121" height="13" SRC="images/regex3_u0232.jpg"> at startup</tt>', but once we drop it into the context of our program, we'll be sure that it matches where we want, and not where we don't. In fact, I'd like to drop it right into the</P>
<pre>
    $text =~ <span class="docEmphStrong">s{</span>\b(<span class="docEmphasis">username regex</span>\@<span class="docEmphasis">hostname regex)</span>\b<span class="docEmphStrong">}{</span>&lt;a href="mailto:$1"&gt;$1
&lt;/a&gt;<span class="docEmphStrong">}gi;</span>
</pre><BR>

<p class="docText">form mentioned earlier (updated here with the <tt><span class="docEmphStrong">s{&#8943;}{&#8943;}</span></tt> delimiters, and the <tt>/i</tt> modifier), but there's no way I could get it to fit onto the page. Perl, of course, doesn't care if it fits nicely or looks pretty, but I do. That's why I'll now introduce the <tt>/x</tt> modifier, which allows us to rewrite that regex as:</p>
<pre>
    $text =~ <span class="docEmphStrong">s{</span>
       \b
       # <span class="docEmphasis">Capture the address to $1</span> ...
       (
         <span class="docEmphasis">username regex</span>
         \@
         <span class="docEmphasis">hostname regex</span>
       )
       \b
    <span class="docEmphStrong">}{</span>&lt;a href="mailto:$1"&gt;$1&lt;/a&gt;<span class="docEmphStrong">}gi<div><img border="0" alt="" width="8" height="9" SRC="images/regex3_u0233.jpg"></div>;</span>
</pre><br>

<p class="docText">Wow, that's different! The <tt>/x</tt> modifier appears at the end of that snippet (along with the <tt>/g</tt> and <tt>/i</tt> modifiers), and does two simple but powerful things for the regular expression. First, it causes most whitespace to be ignored, so you can "free-format" the expression for readability. Secondly, it allows comments with a leading <tt>#</tt>.</P>
<p class="docText">Specifically, <tt>/x</tt> turns most whitespace into an "ignore me" metacharacter, and <tt>#</tt> into an "ignore me, and everything else up to the next newline" metacharacter (&#9758; 111). They aren't taken as metacharacters within a character class (which means that classes are <span class="docEmphasis">not</span> free-format, even with <tt>/x</tt>), and as with other metacharacters, you can escape whitespace and <tt>#</tt> that you want to be taken literally. Of course, you can always use <img src=images/U2308.jpg border=0><tt>\s</tt><img src=images/U230B.jpg border=0> to match whitespace, as in <tt><span class="docEmphStrong">m</span>/&lt;a \s+ href=&#8943;&gt;<span class="docEmphStrong">/x</span></tt>.</P>
<p class="docText">Realize that <tt>/x</tt> applies only to the regular expression, and not to the replacement string. Also, even though we've now switched to using the <tt>s{&#8943;}{&#8943;}</tt> form, where the modifiers come after the final '<tt>}</tt>' (e.g., '<tt>}x</tt>'), in conversation we still refer to "the <tt>x</tt> modifier" as "<tt>/x</tt>".</P>

<a name="regex3-CHP-2-SECT-3.6.5"></a>
<h5 id="title-IDATOPNF" class="docSection3Title">2.3.6.5. Putting it together</H5>
<a name="IDX-CHP-2-0344"></a> 
<a name="IDX-CHP-2-0345"></a> 

<p class="docText">Well, now we can drop in our username<a name="IDX-CHP-2-0346"></a> 
 and hostname<a name="IDX-CHP-2-0347"></a> 
 parts, combined with what we developed earlier, to leave us with the program so far:</P>
<pre>
    undef $/;             # <span class="docEmphasis">Enter "file-slurp" mode</span>.
    $text =&lt;&gt;;      # <span class="docEmphasis">Slurp up the first file given on the command line</span>.
    $text =~ <span class="docEmphStrong">s/</span>&amp;/&amp;amp;<span class="docEmphStrong">/g;</span>            # <span class="docEmphasis">Make the basic HTML</span> ...
    $text =~ <span class="docEmphStrong">s/</span>&lt;/&amp;lt;<span class="docEmphStrong">/g;</span>              # <span class="docEmphasis">... characters &amp;, &lt;, and &gt;</span> ...
    $text =~ <span class="docEmphStrong">s/</span>&gt;/&amp;gt;<span class="docEmphStrong">/g;</span>              # ... <span class="docEmphasis">HTML safe</span>.
    $text =~ <span class="docEmphStrong">s/</span>^\s*$/&lt;p&gt;<span class="docEmphStrong">/mg;</span>           # <span class="docEmphasis">Separate paragraphs</span>.
    # <span class="docEmphasis">Turn email addresses into links</span> ...
    $text =~ <span class="docEmphStrong">s{</span>
       \b
       # <span class="docEmphasis">Capture the address to $1</span> ...
       (
         \w[-.\w]*                                 # <span class="docEmphasis">username</span>
         \@
         [-a-z0-9]+(\.[-a-z0-9]+)+\.(com;edu;info) # <span class="docEmphasis">hostname</span>
       )
       \b
    <span class="docEmphStrong">}{</span>&lt;a href="mailto:$1"&gt;$1&lt;/a&gt;}<span class="docEmphStrong">gix;</span>
    print $text; # <span class="docEmphasis">Finally, display the HTML-ized text</span>.
</pre><br>

<p class="docText">All the regular expressions work with the same multiline string, but notice that only the expression to separate paragraphs requires the <tt>/m</tt> modifier, since only that expression has <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0> or <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0>. Using <tt>/m</tt> on the others wouldn't hurt (well, except to make the reader wonder why it was there).</p>

<a name="regex3-CHP-2-SECT-3.6.6"></a>
<h5 id="title-IDACSPNF" class="docSection3Title">2.3.6.6. "Linkizing" an HTTP URL</h5>
<a name="IDX-CHP-2-0348"></a> 

<a name="IDX-CHP-2-0349"></a> 

<a name="IDX-CHP-2-0350"></a> 

<a name="IDX-CHP-2-0351"></a> 
<a name="IDX-CHP-2-0352"></a> 
<a name="IDX-CHP-2-0353"></a> 
<a name="IDX-CHP-2-0354"></a> 
<a name="IDX-CHP-2-0355"></a> 
<a name="IDX-CHP-2-0356"></a> 
<a name="IDX-CHP-2-0357"></a> 

<p class="docText">Finally, let's turn our attention to recognizing a normal HTTP URL, turning it into a link to itself. This would convert something like "<a class="docLink" target="_blank" href="http://www.yahoo.com/">http://www.yahoo.com/</a>" to</P>
<pre>
    &lt;a&#8226;href="http://www.yahoo.com/"&gt;http://www.yahoo.com/&lt;/a&gt;.
</pre><br>

<p class="docText">The basic form of an HTTP URL is "<tt>http</tt>://<span class="docEmphasis">hostname/path</span>", where the <span class="docEmphasis">/path</span> part is optional. This gives us a form of:</p>
<pre>
    $text =~ <span class="docEmphStrong">s{</span>
      \b
      # <span class="docEmphasis">Capture the URL to $1</span> ...
      (
        http:// <span class="docEmphasis">hostname</span>
        (
           / <span class="docEmphasis">path</span>
        )?
      )
    <span class="docEmphStrong">}{</span>&lt;a href="$1"&gt;$1&lt;/a&gt;<span class="docEmphStrong">}gix;</span>
</pre><BR>

<p class="docText">For the hostname part, we can use the same subexpression we used for the email address. The path part of a URL can consist of a variety of characters, and in the previous chapter we used <img src=images/U2308.jpg border=0><tt>[-a-z0-9_:@&amp;?=+,.!/~*'%$]*</tt><img src=images/U230B.jpg border=0> (&#9758;25), which is most ASCII characters except whitespace, control characters, and things like <tt>&lt;&gt; (){}</tt>.</p>
<p class="docText">There's one other thing we must do before using it with Perl, and that's escape the <tt>@</tt> and <tt>$</tt> characters. Again, I'll defer on the explanation until a bit later (&#9758; 77).</p>
<p class="docText">Now, let's plug in our hostname and path parts:</p>
<pre>
    $text =~ <span class="docEmphStrong">s{</span>
       \b
       # <span class="docEmphasis">Capture the URL to $1</span> ...
       (
          http:// [-a-z0-9]+(\.[-a-z0-9]+)*\.(com|edu|info) \b # <span class="docEmphasis">hostname</span>
          (
             / [-a-z0-9_:\@&amp;?=+,.!/~*'%\$]* # <span class="docEmphasis">optional path</span>
          )?
       )
    <span class="docEmphStrong">}{</span>&lt;a href="$1"&gt;$1&lt;/a&gt;<span class="docEmphStrong">}gix;</span>
</pre><br>

<p class="docText">You'll notice that there's no <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0> after the path, since it's perfectly allowable for a URL to end with punctuation, such as the URL for O'Reilly's page on this book:</p>
<pre>
    <span class="docEmphasis">http://www.oreilly.com/catalog/regex3/</span>
</pre><br>

<p class="docText">Using <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0> at the end would disallow a URL ending this way.</p>
<p class="docText">That being said, in practice we probably want to put some artificial restrictions on what the URL can end with. Consider the following text:</p>
<pre>
    Read "odd" news at <div><img border="0" alt="" width="250" height="13" SRC="images/regex3_u0234.jpg"></div> and
    maybe some tech stuff at <div><img border="0" alt="" width="200" height="13" SRC="images/regex3_u0235.jpg"></div>!
</pre><br>

<p class="docText">Our current regex matches the marked text, although it's obvious that the trailing punctuation in each really shouldn't be part of the URL. When trying to match URLs embedded in English text, it seems to make sense to not include an ending <img src=images/U2308.jpg border=0><tt>[.,?!]</tt><img src=images/U230B.jpg border=0> as part of the URL. (This isn't part of any standard, but just a heuristic I've come up with that seems to work most of the time.) Well, that's as easy as adding a "can't be any of <img src=images/U2308.jpg border=0><tt>[.,?!]"</tt><img src=images/U230B.jpg border=0> negative lookbehind, <img src=images/U2308.jpg border=0><tt>(?&lt;!<span class="docEmphStrong">[.,?!]</span>)</tt><img src=images/U230B.jpg border=0>, to the end of the path part. The effect is that after we've matched what we intend to take as the URL, the lookbehind peeks back to ensure that the last character is appropriate. If not, the engine must reevaluate what's taken as the URL so that this final condition is fulfilled. That means it's forced to leave off the offending punctuation so the final lookbehind can match. (We'll see a different way to solve this problem in <a class="docLink" href="regex3-CHP-5.html#regex3-CHP-5">Chapter 5</a> &#9758; 206.)</p>
<p class="docText">Inserting this, we can now try the full program:</p>
<pre>
    undef $/;          # <span class="docEmphasis">Enter "file-slurp" mode</span>
    $text = &lt;&gt;;  # <span class="docEmphasis">Slurp up the first file given on the command line</span>.

    $text =~ s/&amp;/&amp;amp;/g;      # <span class="docEmphasis">Make the basic HTML</span> ...
    $text =~ s/&lt;/&amp;lt;/g;        # ... <span class="docEmphasis">characters &amp;, &lt;, and &gt;</span> ...
    $text =~ s/&gt;/&amp;gt;/g;        # ... <span class="docEmphasis">HTML safe</span>.

    $text =~ s/^\s*$/&lt;p&gt;/mg;     # <span class="docEmphasis">Separate paragraphs</span>.
    # <span class="docEmphasis">Turn email addresses into links</span> ...
    $text =~ s{
       \b
       # <span class="docEmphasis">Capture the address to $1</span> ...
       (
         \w[-.\w]* # <span class="docEmphasis">username</span>
         \@
         [-a-z0-9]+(\.[-a-z0-9]+)*\.(com;edu;info) # <span class="docEmphasis">hostname</span>
       )
       \b
    }{&lt;a href="mailto:$1"&gt;$1&lt;/a&gt;}gix;
    # <span class="docEmphasis">Turn HTTP URLs into links</span> ...
    $text =~ s{
       \b
       # <span class="docEmphasis">Capture the URL to $1</span> ...
       (
         http:// [-a-z0-9]+(\.[-a-z0-9]+)*\.(com|edu|info) \b # <span class="docEmphasis">hostname</span>
         (
            / [-a-z0-9_:\@&amp;?=+,.!/~*'%\$]* # <span class="docEmphasis">Optional path</span>
              (?&lt;![.,?!])                   # <span class="docEmphasis">Not allowed to end with [.,?!]</span>
         )?
       )
    }{&lt;a href="$1"&gt;$1&lt;/a&gt;}gix;
    print $text; # <span class="docEmphasis">Finally, display the HTML-ized text</span>.
</pre><br>


<a name="regex3-CHP-2-SECT-3.6.7"></a>
<h5 id="title-IDABZPNF" class="docSection3Title">2.3.6.7. Building a regex library</h5>
<a name="IDX-CHP-2-0358"></a> 

<a name="IDX-CHP-2-0359"></a> 
<a name="IDX-CHP-2-0360"></a> 
<a name="IDX-CHP-2-0361"></a> 

<p class="docText">Note that the same expression is used for each of the two hostnames, which means that if we ever update one, we have to be sure to update the other. Rather than keeping that potential source of confusion, consider the three instances of <tt>$HostnameRegex</tt><a name="IDX-CHP-2-0362"></a> 
<a name="IDX-CHP-2-0363"></a> 
 in this modified snippet from our program:</p>
<pre>
    <span class="docEmphStrong">$HostnameRegex</span> = qr/[-a-z0-9]+(\.[-a-z0-9]+)*\.(com|edu|info)/i;

    # <span class="docEmphasis">Turn email addresses into links</span> ...
    $text =~ s{
       \b
       # <span class="docEmphasis">Capture the address to $1</span> ...
       (
         \w[-.\w]*                                         # <span class="docEmphasis">username</span><a name="IDX-CHP-2-0364"></a> 

         \@
         <span class="docEmphStrong">$HostnameRegex</span> # <span class="docEmphasis">hostname</span><a name="IDX-CHP-2-0365"></a> 

       )
       \b
    }{&lt;a href="mailto:$1"&gt;$1&lt;/a&gt;}gix;

    # <span class="docEmphasis">Turn HTTP URLs into links</span> ...
    $text =~ s{
       \b
       # <span class="docEmphasis">Capture the URL to $1</span> ...
       (
         http:// <span class="docEmphStrong">$HostnameRegex</span> \b             # <span class="docEmphasis">hostname</span>
         (
            / [-a-z0-9_:\@&amp;?=+,.!/~*'%\$]*
                                   # <span class="docEmphasis">Optional path</span>
              (?&lt;![.,?!])                                                      # <span class="docEmphasis">not
 allowed to end with [.,?!]</span>
         )?
       )
    }{&lt;a href="$1"&gt;$1&lt;/a&gt;}gix;
</pre><br>

<p class="docText">The first line introduces Perl's <tt>qr</tt> operator. It's similar to the <tt>m</tt> and <tt>s</tt> operators in that it takes a regular expression (i.e., used as <tt>qr/&#8943;/</tt>, just like <tt>m/&#8943;/</tt> and <tt>s/&#8943;/&#8943;/</tt>), but rather than immediately applying it to some text in search of a match, it converts the regex provided into a <span class="docEmphasis">regex object</span>, which you can save to a variable. Later, you can use that object in place of a regular expression, or even as a subexpression of some other regex (as we've done here, using the regex object assigned to <tt>$HostnameRegex</tt> as part of the regex of the two substitutions). This is very convenient because it makes things clearer. As a bonus, we then need only one "master source" to specify the regex to match a hostname, which we can then use as often as we like. There are additional examples of building this type of "regex library" in <a class="docLink" href="regex3-CHP-6.html#regex3-CHP-6">Chapter 6</a> (&#9758; 277), and a detailed discussion in <a class="docLink" href="regex3-CHP-7.html#regex3-CHP-7">Chapter 7</a> (&#9758; 303).</p>
<p class="docText">Other languages offer ways to create their own regex objects; several languages are explored briefly in the next chapter, with Java and .NET discussed in detail in <a class="docLink" href="regex3-CHP-8.html#regex3-CHP-8">Chapter 8</a> and <a class="docLink" href="regex3-CHP-9.html#regex3-CHP-9">Chapter 9</a>.</P>

<a name="regex3-CHP-2-SECT-3.6.8"></a>
<h5 id="title-IDAC3PNF" class="docSection3Title">2.3.6.8. Why '<tt>$</tt>' and '<tt>@</tt>' sometimes need to be escaped</H5>
<a name="IDX-CHP-2-0366"></a> 
<a name="IDX-CHP-2-0367"></a> 
<a name="IDX-CHP-2-0368"></a> 

<p class="docText">You'll notice that the same '<tt>$</tt>' is used as both the end-of-string metacharacter, and to request interpolation (inclusion) of a variable. Normally, there's no ambiguity to what '<tt>$</tt>' means, but within a character class it getsa bit tricky. Since it can't possibly mean end-of-string within a class, in that situation Perl<a name="IDX-CHP-2-0369"></a> 
<a name="IDX-CHP-2-0370"></a> 
 considers it a request to interpolate (include from) a variable, unless it's escaped. If escaped, the '<tt>$</tt>' is just included as a member of the class. That's what we want this time, so that's why we have to escape the dollar sign in the path part of the URL-matching regex.</p>
<p class="docText">It's somewhat similar for <tt>@</tt>. Perl uses <tt>@</tt> at the beginning of array names, and Perl string or regex literals allow arrays to be interpolated. If we wish a literal <tt>@</tt> to be part of a regex, we must escape it so that it's not taken as an array interpolation.</p>
<p class="docText">Some languages don't allow variable interpolation (Java, VB.NET, C, C#, Emacs, and awk, for instance). Some do allow variable interpolation (including Perl, PHP, Python, Ruby, and Tcl), but each has their own way to do it. This is discussed further in the next chapter (&#9758; 101).</P>


<a name="regex3-CHP-2-SECT-3.7"></a>
<H4 id="title-IDA44PNF" class="docSection2Title">2.3.7. That Doubled-Word Thing</H4>
<p class="docText">The doubled-word problem in <a class="docLink" href="regex3-CHP-1.html#regex3-CHP-1">Chapter 1</a> hopefully whetted your appetite for the power of regular expressions. I teased you at the start of this chapter with a cryptic bunch of symbols I called a solution:</P>
<pre>
    $/ = ".\n";
    while (&lt;&gt;) {
      next if !s/<span class="docEmphStrong">\b([a-z]+)((?:\s&lt;&lt;[^&gt;]+&gt;)+)(\1\b)</span>/\e[7m$1\e[m$2\e[7m$3\e[m/ig;
      s/^<span class="docEmphStrong">(?:[^\e]*\n)+</span>//mg;   # <span class="docEmphasis">Remove any unmarked lines</span>.
      s/^<span class="docEmphStrong">/$ARGV:</span> /mg;         # <span class="docEmphasis">Ensure lines begin with filename</span>.
      print;
    }
</pre><br>

<p class="docText">Now that you've seen a bit of Perl, you hopefully understand at least the general formthe <tt>&lt;&gt;</tt>, the three <tt>s/&#8943;/&#8943;/</tt>, and the <tt>print</tt>. Still, it's rather heady stuff! If this chapter has been your only exposure to Perl (and these chapters your only exposure to regular expressions), this example is probably a bit beyond what you want to be getting into at this point.</P>
<p class="docText">However, when it comes down to it, I don't think the regex is really so difficult. Before looking at the program again, it might be good to review the specification found on page 1, and to see a sample run:</p>
<pre>
    % <span class="docEmphStrong">perl -w FindDbl ch01.txt</span>
    ch01.txt: check for doubled words (such as <div><img border="0" alt="" width="32" height="14" SRC="images/regex3_u0236.jpg"></div> <div><img border="0" alt="" width="32" height="14" SRC="images/regex3_u0236.jpg"></div> ), a common problem with
    ch01.txt: * Find doubled words despite capitalization differences, such as with '<div><img border="0" alt="" width="25" height="14" SRC="images/regex3_u0237.jpg"></div>
    ch01.txt: <div><img border="0" alt="" width="26" height="14" SRC="images/regex3_u0238.jpg"></div>&#8943;', as well as allow differing amounts of whitespace (space, tabs,
    ch01.txt: /\&lt;(1,000,000|million|<div><img border="0" alt="" width="60" height="14" SRC="images/regex3_u0239.jpg"></div> <div><img border="0" alt="" width="60" height="14" SRC="images/regex3_u0239.jpg"></div>)/. But alternation can't be
    ch01.txt: of this chapter. If you knew <div><img border="0" alt="" width="26" height="14" SRC="images/regex3_u0238.jpg"></div> <div><img border="0" alt="" width="26" height="14" SRC="images/regex3_u0238.jpg"></div> specific doubled word to find (such
    <img src=images/U22EE.jpg border=0>
</pre><br>

<p class="docText">Let's look at the program now, first in Perl. We'll then briefly look at a solution in Java to see a different approach for working with regular expressions. This time, the listing below uses the <span class="docEmphasis">s<span class="docEmphStrong">{</span><span class="docEmphasis">regex</span><span class="docEmphStrong">}{</span><span class="docEmphasis">replacement</span><span class="docEmphStrong">}</span><span class="docEmphasis">modifiers</span></span> form of the substitution. It also uses the <tt>/x</tt> modifier to make the listing clearer (and with the extra room, now uses the more readable '<tt>next unless</tt>' instead of '<tt>next if !</tt>'). Otherwise, it is identical to the short version at the start of this chapter.</P>
<a name="regex3-CHP-2-SECT-3.7.1"></a>
<H5 id="title-IDAVKINF" class="docSection3Title">2.3.7.1. Double-word example in Perl</h5>
<a name="IDX-CHP-2-0371"></a> 
<a name="IDX-CHP-2-0372"></a> 
<a name="IDX-CHP-2-0373"></a> 
<a name="IDX-CHP-2-0374"></a> 

<pre>
    $/<a name="IDX-CHP-2-0375"></a> 
 = ".\n"; &#10102;# <span class="docEmphasis">Sets a special "chunk-mode"; chunks end with a
 period-newline combination</span>
    while (&lt; &gt;) &#10103;
    {
       next unless <span class="docEmphStrong">s{</span>&#10104;# <span class="docEmphasis">(regex starts here)</span>
             ### <span class="docEmphasis">Need to match one word:</span>
             \b              # <span class="docEmphasis">Start of word</span> ... .
             ( [a-z]+ )      # <span class="docEmphasis">Grab word, filling $1 (and \1)</span>.

             ### <span class="docEmphasis">Now need to allow any number of spaces and/or &lt;TAGS&gt;</span>
             (               #<span class="docEmphasis">Save what intervenes to $2</span>.
                 (?:         # <span class="docEmphasis">(Non-capturing parens for grouping the alternation)</span>
                    \s               # <span class="docEmphasis">Whitespace (includes newline, which is good)</span>.
                   |                 # <span class="docEmphasis">-or-</span>
                    &lt;[^&gt;]+&gt; # <span class="docEmphasis">Item like &lt;TAG&gt;</span>.
                 )+          # <span class="docEmphasis">Need at least one of the above, but allow more</span>.
             )
             ### <span class="docEmphasis">Now match the first word again</span>:
             (\1\b)          # <span class="docEmphasis">\b ensures not embedded. This copy saved to $3</span>.
         #<span class="docEmphasis">(regex ends here)</span>
       }
       # <span class="docEmphasis">Above is the regex. The replacement string is below, followed
by the modifiers, /i, /g, and /x</span>
       {\e[7m<span class="docEmphStrong">$1</span>\e[m<span class="docEmphStrong">$2</span>\e[7m<span class="docEmphStrong">$3</span>\e[m<span class="docEmphStrong">}igx</span>; &#10105;
       <span class="docEmphStrong">s/</span>^(?:[^\e]+\n)+<span class="docEmphStrong">//mg</span>;   &#10106; # <span class="docEmphasis">Remove any unmarked lines</span>.
       <span class="docEmphStrong">s/</span>^/$ARGV: <span class="docEmphStrong">/mg</span>;         &#10107; # <span class="docEmphasis">Ensure lines begin with filename</span>.
       print;
    }
</pre><br>

<p class="docText">This short program does use a fair number of things we haven't seen yet. Let me briefly explain it and some of the logic behind it, but I direct you to the Perl man page for details (or, if regex-related, to <a class="docLink" href="regex3-CHP-7.html#regex3-CHP-7">Chapter 7</a>). In the description that follows, "magic" means "because of a feature of Perl that you may not be familiar with yet."</P>
<UL><LI><p class="docList">&#10102; Because the doubled-word problem must work even when the doubled words are split across lines, I can't use the normal line-by-line processing I used with the mail utility example. Setting the special variable <tt>$/</tt> (yes, that's a variable) as shown puts the subsequent <tt>&lt;&gt;</tt> into a magic mode such that it returns not single lines, but more-or-less paragraph-sized chunks. The value returned is just one string, but a string that could potentially contain many of what we would consider to be logical lines.</p></LI><LI><p class="docList">&#10103; Did you notice that I don't assign the value from <tt>&lt;&gt;</tt> to anything? When used as the conditional of a <tt>while</tt> like this, <tt>&lt;&gt;</tt> magically assigns the string to a special default variable.<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-2-FN-6">[<img src=images/U2020.jpg border=0>]</a></sup> That same variable holds the default string that <tt>s/&#8943;/&#8943;/</tt> works on, and that <tt>print</tt> displays. Using these defaults makes the program less cluttered, but also less understandable to someone new to the language, so I recommend using explicit operands until you're comfortable.</p><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-2-FN-6">[<img src=images/U2020.jpg border=0>]</a></sup> The default variable is <tt>$_</tt><a name="IDX-CHP-2-0376"></a> 
 (yes, that's a variable too). It's used as the default operand for many functions and operators.</p></blockquote></li><li><p class="docList">&#10104; The <tt><span class="docEmphStrong">next unless</span></tt> before the substitute command has Perl abort processing on the current string (to continue with the next) if the substitution doesn't actually do anything. There's no need to continue workingon a string in which no doubled words are found.</P></li><li><p class="docList">&#10105; The replacement string is really just "<tt>$1 $2 $3</tt>" with intervening ANSI escape sequences<a name="IDX-CHP-2-0377"></a> 
 that provide highlighting to the two doubled words, but not to whatever separates them. These escape sequences are <tt>\e[7m</tt><a name="IDX-CHP-2-0378"></a> 
<a name="IDX-CHP-2-0379"></a> 
 to begin highlighting, and <tt>\e[m</tt> to end it. (<tt>\e</tt> is Perl's regex and string shorthand for the ASCII escape character, which begins these ANSI escape sequences.)</P><p class="docList">Looking at how the parentheses in the regex are laid out, you'll realize that "<tt>$1$2$3</tt>" represents exactly what was matched in the first place. So, other than adding in the escape sequences, this whole substitute command is essentially a (slow) no-op.</p><p class="docList">We know that <tt>$1</tt> and <tt>$3</tt> represent matches of the same word (the whole point of the program!), so I could probably get by with using just one or the other in the replacement. However, since they might differ in capitalization, I use both variables explicitly.</p></li><li><p class="docList">&#10106; The string may contain many logical lines, but once the substitution has marked all the doubled words, we want to keep only logical lines that have an escape character. Removing those that don't leaves only the lines of interest in the string. Since we used the enhanced line anchor match mode (the <tt>/m</tt> modifier) with this substitution, the regex <img src=images/U2308.jpg border=0><tt>^([^\e]*\n)+</tt><img src=images/U230B.jpg border=0> can find logical lines of non-escapes. Use of this regex in the substitute causes those sequences to be removed. The result is that only logical lines that have an escape remain, which means that only logical lines that have doubled words in them remain.<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-2-FN-7">[<img src=images/U2021.jpg border=0>]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-2-FN-7">[<img src=images/U2021.jpg border=0>]</a></sup> This logic assumes that the input file doesn't have an ASCII escape character itself. If it did, this program could report lines in error.</p></blockquote></li><li><p class="docList">&#10107; The variable <tt>$ARGV</tt><a name="IDX-CHP-2-0380"></a> 
<a name="IDX-CHP-2-0381"></a> 
 magically provides the name of the input file. Combined with <tt>/m</tt> and <tt>/g</tt>, this substitution tacks the input filename to the beginning of each logical line remaining in the string. Cool!</p></li></ul>
<p class="docText">Finally, the <tt>print</tt> spits out what's left of the string, escapes and all. The <tt>while</tt> loop repeats the same processing for all the strings (paragraph-sized chunks of text) that are read from the input.</p>

<a name="regex3-CHP-2-SECT-3.7.2"></a>
<h5 id="title-IDABSINF" class="docSection3Title">2.3.7.2. Moving bits around: operators, functions, and objects</h5>
<p class="docText">As I emphasized earlier, I use Perl in this chapter as a tool to show the concepts. It happens to be a very useful tool, but I again want to stress that this problem can be easily solved with regular expressions in many other languages.</p>
<p class="docText">Still, showing the concepts is made a bit easier due to a Perl feature unique among advanced languages, which is that regular expressions are a "first class," low-level feature of the language. This means that there are basic operators that work with regular expressions in the same way that <tt>+</tt> and <tt>-</tt> work with numbers. This reduces the amount of "syntactic baggage" needed to wield regular expressions.</p>
<p class="docText">Most languages do not provide this. For reasons that are discussed in <a class="docLink" href="regex3-CHP-3.html#regex3-CHP-3">Chapter 3</a> (&#9758; 93), many modern languages instead provide functions or objects for manipulating and applying regular expressions. There might be a function, for example, that accepts a string to be interpreted as a regular expression, as well as text to be searched, and returns a true or false depending on whether the regular expression matches the text. More commonly, though, these two tasks (first, interpreting a string as a regular expression, and second, applying the regular expression to text) are broken up into two or more separate functions, as seen in the Java listing on the facing page. The code uses the <tt>java.util.regex</tt> package that comes standard as of Java 1.4.</p>
<p class="docText">You can see near the top the same three regular expressions we used in the Perl example, passed as strings to the three <tt>Pattern.compile</tt> routines. A direct comparison shows that the Java version has a few extra backslashes, but that's just a side effect of Java's requirement that regular expressions be provided as strings. Backslashes intended for the regular expression must be escaped to prevent Java's string parser from interpreting the backslashes in its own way (&#9758; 44).</P>
<p class="docText">You'll also notice that the regular expressions are located not in the main text-processing part of the program, but at the start, in the initialization section. The <tt>Pattern.compile</tt> function merely analyzes the string as a regular expression, and builds an internal "compiled version" that is assigned to a <tt>Pattern</tt> variable (<tt>regex1</tt>, etc.). Then, in the main text-processing part of the program, that compiled version is applied to text with <tt>regex1.matcher(text)</tt>, the result of which is used to do the replacement. Again, we'll get into the details in the next chapter, but the point here is that when learning any regex-enabled language, there are two parts to the story: the regex flavor itself, and how the language lets you wield the regular expressions.</p>

<a name="regex3-CHP-2-SECT-3.7.3"></a>
<H5 id="title-IDAMTINF" class="docSection3Title">2.3.7.3. Double-word example in Java</h5>
<a name="IDX-CHP-2-0382"></a> 

<a name="IDX-CHP-2-0383"></a> 

<a name="IDX-CHP-2-0384"></a> 

<a name="IDX-CHP-2-0385"></a> 
<a name="IDX-CHP-2-0386"></a> 
<a name="IDX-CHP-2-0387"></a> 
<a name="IDX-CHP-2-0388"></a> 

<pre>
    import java.io.*;
    import java.util.regex.Pattern;
    import java.util.regex.Matcher;
    public class TwoWord
    {
     public static void main(String [] args)
     {
       Pattern regex1 = Pattern.compile(
           <span class="docEmphStrong">"\\b([a-z]+)((?:\\s&lt;\\&lt;[^&gt;]+\\&gt;)+)(\\1\\b)",</span>
           Pattern.CASE_INSENSITIVE);
     String replace1 = "\033[7m$1\033[m$2\033[7m$3\033[m";
     Pattern regex2 = Pattern.compile("^<span class="docEmphStrong">(?:[^\\e]*\\n)+</span>", Pattern.MULTILINE);<a name="IDX-CHP-2-0389"></a> 

     Pattern regex3 = Pattern.compile("^<span class="docEmphStrong">([^\\n]+)</span>", Pattern.MULTILINE);
     // For each command-line argument....
     for (int i = 0; i &lt; args.length; i++)
     {
       try {
         BufferedReader in = new BufferedReader(new FileReader(args[i]));
         String text;
         // For each paragraph of each file.....
         while ((text = getPara(in)) != null)
         {
             // Apply the three substitutions
             text = regex1.matcher(text).replaceAll(replace1);
             text = regex2.matcher(text).replaceAll("");
             text = regex3.matcher(text).replaceAll(args[i] + ": $1");

             // Display results
             System.out.print(text);
         }
       } catch (IOException<a name="IDX-CHP-2-0390"></a> 
<a name="IDX-CHP-2-0391"></a> 
 e) {
         System.err.println("can't read ["+args[i]+"]: " + e.getMessage());
       }
      }
    }
    // Routine to read next "paragraph" and return as a string
    static String getPara(BufferedReader in) throws java.io.IOException
    {
      StringBuffer buf = new StringBuffer();
      String line;
      while ((line = in.readLine()) != null &amp;&amp;
             (buf.length() == 0 ;; line.length() != 0))
    {
         buf.append(line + "\n");
    }
    return buf.length() == 0 ? null : buf.toString();
 }
}
</pre><br>




<a href="7041536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-2-SECT-2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-3.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>