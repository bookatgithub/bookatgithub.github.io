<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 3.4.&nbsp; Strings, Character Encodings, and Modes</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-3-SECT-3.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-3-SECT-5.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="regex3-CHP-3-SECT-4"></a>
<H3 id="686695-991" class="docSection1Title">3.4. Strings, Character Encodings, and Modes</H3>
<p class="docText">Before getting into the various type of metacharacters generally available, there are a number of global issues to understand: regular expressions as strings, character encodings, and match modes.</P>
<p class="docText">These are simple concepts, in theory, and in practice, some indeed are. With most, though, the small details, subtleties, and inconsistencies among the various implementations sometimes makes it hard to pin down exactly how they work in practice. The next sections cover some of the common and sometimes complex issues you'll face.</P>
<a name="regex3-CHP-3-SECT-4.1"></a>
<h4 id="title-IDAIHPHI" class="docSection2Title">3.4.1. Strings as Regular Expressions</H4>
<p class="docText">The concept is simple: in most languages except Perl, <span class="docEmphasis">awk</span>, and <span class="docEmphasis">sed</span>, the regex engine accepts regular expressions as normal strings  strings that are often provided as string literals like <tt>"^From:(.*)"</tt>. What confuses many, especially early on, is the need to deal with the language's own string-literal metacharacters when composing a string to be used as a regular expression.</p>
<p class="docText">Each language's string literals have their own set of metacharacters, and some languages even have more than one type of string literal, so there's no one rule that works everywhere, but the concepts are all the same. Many languages' string literals recognize escape sequences like <tt>\t</tt>, <tt>\\</tt>, and <tt>\x2A</tt>, which are interpreted while the string's value is being composed. The most common regex-related aspect of this is that each backslash in a regex requires two backslashes in the corresponding string literal. For example, <tt>"\\n"</tt> is required to get the regex <img src=images/U2308.jpg border=0><tt>\n</tt><img src=images/U230B.jpg border=0>.</p>
<p class="docText">If you forget the extra backslash for the string literal and use <tt>"\n"</tt>, with many languages you'd then get <img src=images/U2308.jpg border=0><tt><img border="0" alt="" id="195131084199" width="12" height="16" SRC="images/regex3_u0220.jpg"></tt><img src=images/U230B.jpg border=0>, which just happens to do exactly the same thing as <img src=images/U2308.jpg border=0><tt>\n</tt><img src=images/U230B.jpg border=0>. Well, actually, if the regex is in an <tt>/x</tt> type of free-spacing mode, <img src=images/U2308.jpg border=0><tt><img border="0" alt="" id="195131084199" width="12" height="16" SRC="images/regex3_u0220.jpg"></tt><img src=images/U230B.jpg border=0> becomes empty, while <img src=images/U2308.jpg border=0><tt>\n</tt><img src=images/U230B.jpg border=0> remains a regex to match a newline. So, you can get bitten if you forget. <a class="docLink" href="#regex3-CHP-3-TABLE-4">Table 3-4</a> below shows a few examples involving <tt>\t</tt> and <tt>\x2A</tt> (<tt>2A</tt> is the ASCII code for '<tt>*</tt>'.) The second pair of examples in the table show the unintended results when the string-literal metacharacters aren't taken into account.</P>
<a name="regex3-CHP-3-TABLE-4"></a><P><table cellspacing="0" FRAME="hsides" RULES="all" cellpadding="4" width="100%"><caption><h5 class="docTableTitle">Table 3-4. A Few String-Literal Examples</h5></caption><colgroup span="5"><col><col><col><col><col></colgroup><thead><TR><th class="thead" scope="col" align="left"><p class="docText">String literal</P></th><th class="thead" scope="col" align="left"><p class="docText"><tt><span class="docEmphStrong">"[\t\x2A]"</span></tt></P></th><th class="thead" scope="col" align="left"><p class="docText"><tt><span class="docEmphStrong">"[\\t\\x2A]"</span></tt></p></th><th class="thead" scope="col" align="left"><p class="docText"><tt><span class="docEmphStrong">"\t\x2A"</span></tt></P></th><th class="thead" scope="col" align="left"><p class="docText"><tt><span class="docEmphStrong">"\\t\\x2A"</span></tt></P></th></tr></thead><tr><td class="docTableCell" align="left"><p class="docText">String value</p></TD><td class="docTableCell" align="left"><p class="docText">'[<img border="0" alt="" id="195131084199" width="12" height="16" SRC="images/regex3_u0206.jpg">*]'</p></TD><td class="docTableCell" align="left"><p class="docText">'<tt>[\t\x2A]</tt>'</p></td><td class="docTableCell" align="left"><p class="docText">'<img border="0" alt="" id="195131084199" width="12" height="16" SRC="images/regex3_u0206.jpg">*'</p></td><td class="docTableCell" align="left"><p class="docText">'<tt>\t\x2A</tt>'</p></td></tr><tr><td class="docTableCell" align="left"><p class="docText">As regex</p></td><td class="docTableCell" align="left"><p class="docText"><img src=images/U2308.jpg border=0><tt>[<img border="0" alt="" id="195131084199" width="12" height="16" SRC="images/regex3_u0206.jpg">*]</tt><img src=images/U230B.jpg border=0></p></td><TD class="docTableCell" align="left"><p class="docText"><img src=images/U2308.jpg border=0><tt>[\t\x2A]</tt><img src=images/U230B.jpg border=0></p></TD><td class="docTableCell" align="left"><p class="docText"><img src=images/U2308.jpg border=0><tt><img border="0" alt="" id="195131084199" width="12" height="16" SRC="images/regex3_u0206.jpg">*</tt><img src=images/U230B.jpg border=0></p></TD><TD class="docTableCell" align="left"><p class="docText"><img src=images/U2308.jpg border=0><tt>\t\x2A</tt><img src=images/U230B.jpg border=0></P></TD></tr><TR><td class="docTableCell" align="left"><p class="docText">Matches</p></TD><TD class="docTableCell" align="left"><p class="docText">tab or star</p></td><TD class="docTableCell" align="left"><p class="docText">tab or star</P></TD><td class="docTableCell" align="left"><p class="docText">any number tabs</P></TD><td class="docTableCell" align="left"><p class="docText">tab followed by star</p></td></tr><TR><td class="docTableCell" align="left"><p class="docText">In <tt>/x</tt> mode</p></TD><td class="docTableCell" align="left"><p class="docText">tab or star</p></td><td class="docTableCell" align="left"><p class="docText">tab or star</p></td><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis">error</span></p></td><td class="docTableCell" align="left"><p class="docText">tab followed by star</p></td></tr></table></p><br>
<p class="docText">Every language's string literals are different, but some are quite different in that '<tt>\</tt>' is not a metacharacter. For example. VB.NET's string literals have only one metacharacter, a double quote. The next sections look at the details of several common languages' string literals. Whatever the individual string-literal rules, the question on your mind when using them should be "what will the regular expression engine see after the language's string processing is done?"</p>
<a name="regex3-CHP-3-SECT-4.1.1"></a>
<h5 id="title-IDALQPHI" class="docSection3Title">3.4.1.1. Strings in Java</H5>
<a name="IDX-CHP-3-0588"></a> 

<p class="docText">Java string literals are like those presented in the introduction, in that they are delimited by double quotes, and backslash is a metacharacter. Common combinations such as <tt>'\t'</tt> (tab), <tt>'\n'</tt> (newline), '<tt>\\</tt>' (literal backslash), etc. are supported. Using a backslash in a sequence not explicitly supported by literal strings<a name="IDX-CHP-3-0589"></a> 
 results in an error.</p>

<a name="regex3-CHP-3-SECT-4.1.2"></a>
<H5 id="title-IDAFRPHI" class="docSection3Title">3.4.1.2. Strings in VB.NET</h5>
<p class="docText">String literals in VB.NET<a name="IDX-CHP-3-0590"></a> 
 are also delimited by double quotes, but otherwise are quite different from Java's. VB.NET strings<a name="IDX-CHP-3-0591"></a> 
<a name="IDX-CHP-3-0592"></a> 
<a name="IDX-CHP-3-0593"></a> 
 recognize only one metasequence: a pair of double quotes in the string literal add one double quote into the string's value. For example, <tt>"he said ""hi""\."</tt> results in <img src=images/U2308.jpg border=0><tt>he said "hi"\.</tt><img src=images/U230B.jpg border=0></p>

<a name="regex3-CHP-3-SECT-4.1.3"></a>
<H5 id="title-IDAHSPHI" class="docSection3Title">3.4.1.3. Strings in C#</H5>
<a name="IDX-CHP-3-0594"></a> 

<p class="docText">Although all the languages of Microsoft's .NET Framework share the same regular expression engine internally, each has its own rules about the strings used to create the regular-expression arguments. We just saw Visual Basic's simple string literals. In contrast, Microsoft's C<span class="docEmphasis">#</span> language has two types of string literals.</P>
<p class="docText">C<span class="docEmphasis">#</span> supports the common double-quoted string similar to the kind discussed in this section's introduction, except that "" rather than <tt>\</tt>" adds a double quote into the string's value. However, C<span class="docEmphasis">#</span> also supports "verbatim strings,"<a name="IDX-CHP-3-0595"></a> 
 which look like <tt>@"&#8943;"</tt>.<a name="IDX-CHP-3-0596"></a> 
 Verbatim strings recognize no backslash sequences, but instead, just one special sequence: a pair of double quotes inserts one double quote into the target value. This means that you can use <tt>"\\t\\x2A"</tt> or <tt>@"\t\x2A"</tt> to create the <img src=images/U2308.jpg border=0><tt>\t\x2A</tt><img src=images/U230B.jpg border=0> example. Because of this simpler interface, one would tend to use these <tt>@"&#8943;"</tt> verbatim strings for most regular expressions.</P>

<a name="regex3-CHP-3-SECT-4.1.4"></a>
<h5 id="title-IDATTPHI" class="docSection3Title">3.4.1.4. Strings in PHP</H5>
<a name="IDX-CHP-3-0597"></a> 

<a name="IDX-CHP-3-0598"></a> 

<p class="docText">PHP also offers two types of strings, yet both differ from either of C<span class="docEmphasis">#</span>'s types. With PHP's double-quoted strings, you get the common backslash sequences like '<tt>\n</tt>', but you also get variable interpolation as we've seen with Perl (&#9758;77), and also the special sequence {&#8943;} which inserts into the string the result of executing the code between the braces.</p>
<p class="docText">These extra features of PHP double-quoted strings mean that you'll tend to insert extra backslashes into regular expressions, but there's one additional feature that helps mitigate that need. With Java and C<span class="docEmphasis">#</span> string literals, a backslash sequence that isn't explicitly recognized as special within strings results in an error, but with PHP double-quoted strings, such sequences are simply passed through to the string's value. PHP strings recognize <tt>\t</tt>, so you still need <tt>"\\t"</tt> to get <img src=images/U2308.jpg border=0><tt>\t</tt><img src=images/U230B.jpg border=0>, but if you use <tt>"\w"</tt>, you'll get <img src=images/U2308.jpg border=0><tt>\w</tt><img src=images/U230B.jpg border=0> because <tt>\w</tt> is not among the sequences that PHP double-quoted strings recognize. This extra feature, while handy at times, does add yet another level of complexity to PHP double-quoted strings, so PHP also offers its simpler single-quoted strings.</p>
<p class="docText">PHP single-quoted strings offer uncluttered strings on the order of VB.NET's strings, or C<span class="docEmphasis">#</span>'s <tt>@"&#8943;"</tt> strings, but in a slightly different way. Within a PHP single-quoted string, the sequence <tt>\</tt>' includes one single quote in the target value, and <tt>\\</tt> includes a backslash. Any other character (including any other backslash) is not considered special, and is copied to the target value verbatim. This means that <tt>'\t\x2A'</tt> creates <img src=images/U2308.jpg border=0><tt>\t\x2A</tt><img src=images/U230B.jpg border=0>. Because of this simplicity, single-quoted strings<a name="IDX-CHP-3-0599"></a> 
<a name="IDX-CHP-3-0600"></a> 
 are the most convenient for PHP regular expressions.</P>
<p class="docText">PHP single-quoted strings are discussed further in <a class="docLink" href="regex3-CHP-10.html#regex3-CHP-10">Chapter 10</a> (&#9758;445).</P>

<a name="regex3-CHP-3-SECT-4.1.5"></a>
<h5 id="title-IDA4VPHI" class="docSection3Title">3.4.1.5. Strings in Python</h5>
<a name="IDX-CHP-3-0601"></a> 

<a name="IDX-CHP-3-0602"></a> 

<p class="docText">Python offers a number of string-literal types. You can use either single quotes or double quotes to create strings, but unlike PHP, there is no difference between the two. Python also offers "triple-quoted" strings of the form '''&#8943;''' and """&#8943;""", which are different in that they may contain unescaped newlines. All four types offer the common backslash sequences such as <tt>\n</tt>, but have the same twist that PHP has in that unrecognized sequences are left in the string verbatim. Contrast this with Java and C<span class="docEmphasis">#</span> strings, for which unrecognized sequences cause an error.</P>
<p class="docText">Like PHP and C<span class="docEmphasis">#</span>, Python offers a more literal type of string, its "raw string." Similar to C<span class="docEmphasis">#</span>'s @"&#8943;" notation, Python uses an '<tt>r</tt>' before the opening quote of any of the four quote types. For example, <tt><span class="docEmphStrong">r</span>"\t\x2A"</tt> yields <img src=images/U2308.jpg border=0><tt>\t\x2A</tt><img src=images/U230B.jpg border=0>. Unlike the other languages, though, with Python's raw strings, <span class="docEmphasis">all</span> backslashes are kept in the string, including those that escape a double quote (so that the double quote can be included within the string): <tt><span class="docEmphStrong">r"</span>he said \"hi\"\."</tt> results in <img src=images/U2308.jpg border=0><tt>he said \"hi\"\.</tt><img src=images/U230B.jpg border=0>. This isn't really a problem when using strings for regular expressions, since Python's regex flavor treats <img src=images/U2308.jpg border=0><tt>\"</tt><img src=images/U230B.jpg border=0> as <img src=images/U2308.jpg border=0><tt>"</tt><img src=images/U230B.jpg border=0>, but if you like, you can bypass the issue by using one of the other types of raw quoting: <tt><span class="docEmphStrong">r'</span>he said "hi"\</tt>.'</P>

<a name="regex3-CHP-3-SECT-4.1.6"></a>
<H5 id="title-IDA0XPHI" class="docSection3Title">3.4.1.6. Strings in Tcl</h5>
<a name="IDX-CHP-3-0603"></a> 

<p class="docText">Tcl is different from anything else in that it doesn't really have string literals at all. Rather, command lines are broken into "words," which Tcl commands can then consider as strings, variable names, regular expressions, or anything else as appropriate to the command. While a line is being parsed into words, common backslash sequences like <tt>\n</tt> are recognized and converted, and backslashes in unknown combinations are simply dropped. You can put double quotes around the word if you like, but they aren't required unless the word has whitespace in it.</P>
<p class="docText">Tcl also has a raw literal type of quoting similar to Python's raw strings, but Tcl uses braces, {&#8943;}, instead of <tt>r'&#8943;'</tt>. Within the braces, everything except a backslash-newline combination is kept as-is, so you can use <tt>{\t\x2A}</tt> to get <img src=images/U2308.jpg border=0><tt>\t\x2A</tt><img src=images/U230B.jpg border=0>.</P>
<p class="docText">Within the braces, you can have additional sets of braces so long as they nest. Those that don't nest must be escaped with a backslash, although the backslash <span class="docEmphasis">does</span> remain in the string's value.</p>

<a name="regex3-CHP-3-SECT-4.1.7"></a>
<h5 id="title-IDA2YPHI" class="docSection3Title">3.4.1.7. Regex literals in Perl</h5>
<a name="IDX-CHP-3-0604"></a> 
<a name="IDX-CHP-3-0605"></a> 

<p class="docText">In the Perl examples we've seen so far in this book, regular expressions have been provided as literals ("regular-expression literals"). As it turns out, you can also provide them as strings. For example:</p>
<pre>
    $str =~ m/(\w+)/;
</pre><BR>

<p class="docText">can also be written as:</p>
<pre>
    $regex = '(\w+)';
    $str =~ $regex;
</pre><br>

<p class="docText">or perhaps:</P>
<pre>
    $regex = "(\\w+)";
    $str =~ $regex;
</pre><br>

<p class="docText">(Note that using a string can be much less efficient &#9758;242, 348.)</p>
<p class="docText">When a regex is provided as a literal, Perl provides extra features that the regular-expression engine itself does not, including:</p>
<ul><li><p class="docList">The interpolation of variables (incorporating the contents of a variable as part of the regular expression).</p></li><li><p class="docList">Support for a literal-text mode via <img src=images/U2308.jpg border=0><tt>\Q&#8943;\E</tt><img src=images/U230B.jpg border=0> (&#9758;113).</p></li><li><p class="docList">Optional support for a <tt>\N</tt>{<span class="docEmphasis">name</span>} construct, which allows you to specify characters via their official Unicode names. For example, you can match '<tt>&#161;Hola!</tt>' with <img src=images/U2308.jpg border=0><tt>\N{INVERTED EXCLAMATION MARK}Hola!</tt><img src=images/U230B.jpg border=0>.</p></li></ul>
<p class="docText">In Perl, a regex literal is parsed like a very special kind of string. In fact, these features are also available with Perl double-quoted strings. The point to be aware of is that these features are <span class="docEmphasis">not</span> provided by the regular-expression engine. Since the vast majority of regular expressions used within Perl are as regex literals, most think that <img src=images/U2308.jpg border=0><tt>\Q&#8943;\E</tt><img src=images/U230B.jpg border=0> is part of Perl's regex language, but if you ever use regular expressions read from a configuration file (or from the command line, etc.), it's important to know exactly what features are provided by which aspect of the language.</p>
<p class="docText">More details are available in <a class="docLink" href="regex3-CHP-7.html#regex3-CHP-7">Chapter 7</a>, starting on page 288.</p>


<a name="regex3-CHP-3-SECT-4.2"></a>
<h4 id="title-IDAG1PHI" class="docSection2Title">3.4.2. Character-Encoding Issues</H4>
<p class="docText">A character encoding is merely an explicit agreement on how bytes with various values should be interpreted. A byte with the decimal value 110 is interpreted as the character '<tt>n</tt>' with the ASCII encoding, but as '<tt>&gt;</tt>' with EBCDIC. Why? Because that's what someone decided  there's nothing intrinsic about those values and characters that makes one encoding better than the other. The byte is the same; only the interpretation changes.</p>
<p class="docText">ASCII<a name="IDX-CHP-3-0606"></a> 
 defines characters for only half the values that a byte can hold. The ISO-8859-1 encoding<a name="IDX-CHP-3-0607"></a> 
<a name="IDX-CHP-3-0608"></a> 
 (commonly called "Latin-1")<a name="IDX-CHP-3-0609"></a> 
 fills in the blank spots with accented characters and special symbols, making an encoding usable by a larger set of languages. With this encoding, a byte with a decimal value of 234 is to be interpreted as <tt>&ecirc;</tt>, instead of being undefined as it is with ASCII.</P>
<p class="docText">The important question for us is: when we <span class="docEmphasis">intend</span> for a certain set of bytes to be <span class="docEmphasis">considered</span> in the light of a particular encoding, does the program actually do so? For example, if we have four bytes with the values 234, 116, 101, and 115 that we intend to be considered as Latin-1 (representing the French word "&ecirc;tes"), we'd like the regex <img src=images/U2308.jpg border=0><tt>^\w+$</tt><img src=images/U230B.jpg border=0> or <img src=images/U2308.jpg border=0><tt>^\b</tt><img src=images/U230B.jpg border=0> to match. This happens if the program's <tt>\w</tt> and <tt>\b</tt> know to treat those bytes as Latin-1 characters, and probably doesn't happen otherwise.</p>
<a name="regex3-CHP-3-SECT-4.2.1"></a>
<h5 id="title-IDAZ2PHI" class="docSection3Title">3.4.2.1. Richness of encoding-related support</H5>
<a name="IDX-CHP-3-0610"></a> 
<a name="IDX-CHP-3-0611"></a> 
<a name="IDX-CHP-3-0612"></a> 

<p class="docText">There are many encodings. When you're concerned with a particular one, important questions you should ask include:</P>
<UL><LI><p class="docList">Does the program understand this encoding?</p></LI><li><p class="docList">How does it know to treat this data as being of that encoding?</p></LI><LI><p class="docList">How rich is the regex support for this encoding?</p></li></UL>
<p class="docText">The richness of an encoding's support has several important issues, including:</P>
<UL><li><p class="docList">Are characters that are encoded with multiple bytes recognized as such? Do expressions like dot and <tt>[^x]</tt> match single <span class="docEmphasis">characters</span>, or single <span class="docEmphasis">bytes</span>?</P></LI><li><p class="docList">Do <tt>\w, \d, \s, \b,</tt> etc., properly understand all the characters in the encoding? For example, even if <tt>&ecirc;</tt> is known to be a letter, do <tt>\w</tt> and <tt>\b</tt> treat it as such?</p></li><LI><p class="docList">Does the program try to extend the interpretation of class ranges? Is <tt>&ecirc;</tt> matched by <tt>[a-z]</tt>?</p></li><LI><p class="docList">Does case-insensitive matching work properly with all the characters? For example, are <tt>&ecirc;</tt> and <tt>&Ecirc;</tt> treated as being equal?</p></li></ul>
<p class="docText">Sometimes things are not as simple as they might seem. For example, the <tt>\b</tt> of Sun's <tt>java.util.regex</tt> package properly understands all the word-related characters of Unicode, but its <tt>\w</tt> does not (it understands only basic ASCII). We'll see more examples of this later in the chapter.</p>


<a name="regex3-CHP-3-SECT-4.3"></a>
<h4 id="title-IDAS5PHI" class="docSection2Title">3.4.3. Unicode</h4>
<p class="docText">There seems to be a lot of misunderstanding about just what "Unicode" is. At the most basic level, Unicode is a <span class="docEmphasis">character set</span> or a <span class="docEmphasis">conceptual encoding</span>  a logical mapping between a number and a character. For example, the Korean character &#49333; is mapped to the number 49,333. The number, called a <span class="docEmphasis">code point</span>, is normally shown in hexadecimal, with "<tt>U+</tt>" prepended. 49,333 in hex is <tt>C0B5</tt>, so &#49333; is referred to as <tt>U+C0B5</tt>.<a name="IDX-CHP-3-0613"></a> 
 Included as part of the Unicode concept is a set of attributes for many characters, such as "3 is a digit" and "<tt>&Eacute;</tt> is an uppercase letter whose lowercase equivalent is <tt>&eacute;</tt>."</p>
<p class="docText">At this level, nothing is yet said about just how these numbers are actually encoded as data on a computer. There are a variety of ways to do so, including the UCS-2<a name="IDX-CHP-3-0614"></a> 
 encoding (all characters encoded with two bytes), the UCS-4<a name="IDX-CHP-3-0615"></a> 
 encoding (all characters encoded with four bytes), UTF-16<a name="IDX-CHP-3-0616"></a> 
 (most characters encoded with two bytes, but some with four), and the UTF-8<a name="IDX-CHP-3-0617"></a> 
 encoding (characters encoded with one to six bytes). Exactly which (if any) of these encodings a particular program uses internally is usually not a concern to the user of the program. The user's concern is usually limited to how to convert external data (such as data read from a file) from a known encoding (ASCII, Latin-1, UTF-8, etc.) to whatever the program uses. Programs that work with Unicode usually supply various encoding and decoding routines for doing the conversion.</p>
<p class="docText">Regular expressions for programs that work with Unicode often support a <tt>\u</tt><span class="docEmphasis">num</span> metasequence that can be used to match a specific Unicode character (&#9758;117). The number is usually given as a four-digit hexadecimal number, so <tt>\uC0B5</tt> matches <tt>&#49333;</tt>. It's important to realize that <tt>\uC0B5</tt> is saying "match the Unicode character <tt>U+C0B5</tt>," and says nothing about what actual bytes are to be compared, which is dependent on the particular encoding used internally to represent Unicode code points. If the program happens to use UTF-8 internally, that character happens to be represented with three bytes. But you, as someone using the Unicode-enabled program, don't normally need to care. (Sometimes you do, as with PHP's preg suite and its <span class="docEmphStrong">u</span> pattern modifier; &#9758;447).</p>
<p class="docText">There are a few related issues that you may need to be aware of...</p>
<a name="regex3-CHP-3-SECT-4.3.1"></a>
<h5 id="title-IDA3RQHI" class="docSection3Title">3.4.3.1. Characters versus combining-character sequences</h5>
<a name="IDX-CHP-3-0618"></a> 

<a name="IDX-CHP-3-0619"></a> 

<a name="IDX-CHP-3-0620"></a> 
<a name="IDX-CHP-3-0621"></a> 
<a name="IDX-CHP-3-0622"></a> 
<a name="IDX-CHP-3-0623"></a> 
<a name="IDX-CHP-3-0624"></a> 
<a name="IDX-CHP-3-0625"></a> 
<a name="IDX-CHP-3-0626"></a> 
<a name="IDX-CHP-3-0627"></a> 
<a name="IDX-CHP-3-0628"></a> 

<p class="docText">What a person considers a "character" doesn't always agree with what Unicode or a Unicode-enabled program (or regex engine) considers to be a character. For example, most would consider <tt>&agrave;</tt> to be a single character, but in Unicode, it can be composed of two code points, <tt>U+0061 (a)</tt> combined with the grave accent U<tt>+0300</tt> ('). Unicode offers a number of <span class="docEmphasis">combining characters</span> that are intended to follow (and be combined with) a base character.<a name="IDX-CHP-3-0629"></a> 
 This makes things a bit more complex for the regular-expression engine  for example, should dot match just one code point, or the entire <tt>U+0061</tt> plus <tt>U+0300</tt> combination?</p>
<p class="docText">In practice, it seems that many programs treat "character" and "code point" as synonymous, which means that dot matches each code point individually, whether it is base character or one of the combining characters. Thus, <tt>&agrave;</tt> (<tt>U+0061</tt> plus <tt>U+0300</tt>) is matched by <img src=images/U2308.jpg border=0><tt>^..$</tt><img src=images/U230B.jpg border=0>, and not by <img src=images/U2308.jpg border=0><tt>^.$</tt><img src=images/U230B.jpg border=0>.</p>
<p class="docText">Perl and PCRE (and by extension, PHP's preg suite) support the <tt>\X</tt><a name="IDX-CHP-3-0630"></a> 
<a name="IDX-CHP-3-0631"></a> 
 metasequence, which fulfills what many might expect from dot ("match one <span class="docEmphasis">character</span>") in that it matches a base character followed by any number of combining characters. See more on page 120.</p>
<p class="docText">It's important to keep combining characters in mind when using a Unicode-enabled editor to input Unicode characters directly into regular-expressions. If an accented character, say &Aring;, ends up in a regular expression as 'A' plus '&#8226;,' it likely can't match a string containing the single code point version of &Aring; (single code point versions are discussed in the next section). Also, it appears as two distinct characters to the regular-expression engine itself, so specifying <img src=images/U2308.jpg border=0><tt>[&#8943;&Aring;&#8943;]</tt><img src=images/U230B.jpg border=0> adds the two characters to the class, just as the explicit <img src=images/U2308.jpg border=0><tt>[&#8943;A &#176;&#8943;]</tt><img src=images/U230B.jpg border=0> does.</p>
<p class="docText">In a similar vein, if a two-code-point character like &Aring; is followed by a quantifier, the quantifier actually applies only to the second code point, just as with an explicit <img src=images/U2308.jpg border=0> <tt>A &#176;+</tt><img src=images/U230B.jpg border=0>.</P>

<a name="regex3-CHP-3-SECT-4.3.2"></a>
<h5 id="title-IDASVQHI" class="docSection3Title">3.4.3.2. Multiple code points for the same character</H5>
<a name="IDX-CHP-3-0632"></a> 
<a name="IDX-CHP-3-0633"></a> 
<a name="IDX-CHP-3-0634"></a> 
<a name="IDX-CHP-3-0635"></a> 

<p class="docText">In theory, Unicode is supposed to be a one-to-one mapping between code points and characters, but there are many situations where one character can have multiple<a name="IDX-CHP-3-0636"></a> 
<a name="IDX-CHP-3-0637"></a> 
 representations. The previous section notes that <tt>&agrave;</tt> is <tt>U+0061</tt> followed by <tt>U+0300</tt>. It is, however, <span class="docEmphasis">also</span> encoded separately as the single code point <tt>U+00E0</tt>. Why is it encoded twice? To maintain easier conversion between Unicode and Latin-1.<a name="IDX-CHP-3-0638"></a> 
 If you have Latin-1 text that you convert to Unicode, <tt>&agrave;</tt> will likely be converted to <tt>U+00E0</tt>. But, it could well be converted to a <tt>U+0061, U+0300</tt> combination. Often, there's nothing you can do to automatically allow for these different ways of expressing characters, but Sun's <tt>java.util.regex</tt> package provides a special match option, <tt>CANON_EQ</tt>,<a name="IDX-CHP-3-0639"></a> 
 which causes characters that are "canonically equivalent" to match the same, even if their representations in Unicode differ (&#9758;368).</p>
<p class="docText">Somewhat related is that different characters can look virtually the same, which could account for some confusion at times among those creating the text you're tasked to check. For example, the Roman letter I (<tt>U+0049</tt>) could be confused with I, the Greek letter Iota (<tt>U+0399</tt>). Add <span class="docEmphasis">dialytika</span><a name="IDX-CHP-3-0640"></a> 
 to that to get &Iuml; or &Iuml; and it can be encoded four different ways (<tt>U+00CF</tt>; <tt>U+03AA</tt>; <tt>U+0049 U+0308</tt>; <tt>U+0399 U+0308</tt>). This means that you might have to manually allow for these four possibilities when constructing a regular expression to match <tt>&Iuml;</tt>. There are many examples like this.</p>
<p class="docText">Also plentiful are single characters that appear to be more than one character. For example, Unicode defines a character called "SQUARE HZ" (<tt>U+3390</tt>), which appears as <tt>Hz</tt>.<a name="IDX-CHP-3-0641"></a> 
<a name="IDX-CHP-3-0642"></a> 
 This looks very similar to the two normal characters Hz (<tt>U+0048 U+007A</tt>).</P>
<p class="docText">Although the use of special characters like <tt>Hz</tt> is minimal now, their adoption over the coming years will increase the complexity of programs that scan text, so those working with Unicode would do well to keep these issues in the back of their mind. Along those lines, one might already expect, for example, the need to allow for both normal spaces (<tt>U+0020</tt>) and no-break spaces (<tt>U+00A0</tt>), and perhaps also any of the dozen or so other types of spaces that Unicode defines.</P>

<a name="regex3-CHP-3-SECT-4.3.3"></a>
<H5 id="title-IDAJZQHI" class="docSection3Title">3.4.3.3. Unicode 3.1+ and code points beyond U+FFFF</H5>
<a name="IDX-CHP-3-0643"></a> 

<a name="IDX-CHP-3-0644"></a> 

<a name="IDX-CHP-3-0645"></a> 
<a name="IDX-CHP-3-0646"></a> 
<a name="IDX-CHP-3-0647"></a> 

<p class="docText">With the release of Unicode Version 3.1 in mid 2001, characters with code points beyond <tt>U+FFFF</tt> were added. (Previous versions of Unicode had built in a way to allow for characters at those code points, but until Version 3.1, none were actually defined.) For example, there is a character for musical symbol C Clef defined at <tt>U+1D121</tt>. Older programs built to handle only code points <tt>U+FFFF</tt> and below won't be able to handle this. Most programs' <tt>\<span class="docEmphasis">unum</span></tt> indeed allow only a four-digit hexadecimal number.</p>
<p class="docText">Programs that can handle characters at these new code points generally offer the <tt>\x</tt>{<span class="docEmphasis">num</span>} sequence, where <span class="docEmphasis">num</span> can be any number of digits. (This is offered instead of, or in addition to, the four-digit <tt>\u</tt><span class="docEmphasis">num</span> notation.) You can then use <tt>\x{1D121}</tt> to match the C Clef character.</P>

<a name="regex3-CHP-3-SECT-4.3.4"></a>
<h5 id="title-IDAC1QHI" class="docSection3Title">3.4.3.4. Unicode line terminator</h5>
<p class="docText">Unicode defines a number of characters (and one sequence of two characters) that are to be considered <span class="docEmphasis">line terminators</span>,<a name="IDX-CHP-3-0648"></a> 
<a name="IDX-CHP-3-0649"></a> 
 shown in <a class="docLink" href="#regex3-CHP-3-TABLE-5">Table 3-5</a>.</P>
<a name="regex3-CHP-3-TABLE-5"></a><P><table cellspacing="0" FRAME="hsides" RULES="all" cellpadding="4" width="100%"><caption><h5 class="docTableTitle">Table 3-5. Unicode Line Terminators</h5></caption><colgroup span="3"><col><col><col></colgroup><thead><TR><th class="thead" scope="col" align="left" colspan="2"><p class="docText">Characters</P></th><th class="thead" scope="col" align="left"><p class="docText">Description</P></th></tr></thead><TR><TD class="docTableCell" align="left"><p class="docText">LF<a name="IDX-CHP-3-0650"></a> 
</p></td><td class="docTableCell" align="left"><p class="docText"><tt>U+000A</tt></p></TD><td class="docTableCell" align="left"><p class="docText">ASCII Line Feed</p></TD></tr><tr><td class="docTableCell" align="left"><p class="docText">VT<a name="IDX-CHP-3-0651"></a> 
</p></td><td class="docTableCell" align="left"><p class="docText"><tt>U+000B</tt></p></td><td class="docTableCell" align="left"><p class="docText">ASCII Vertical Tab</p></td></tr><tr><td class="docTableCell" align="left"><p class="docText">FF<a name="IDX-CHP-3-0652"></a> 
</p></td><td class="docTableCell" align="left"><p class="docText"><tt>U+000C</tt></P></td><TD class="docTableCell" align="left"><p class="docText">ASCII Form Feed</p></td></TR><TR><TD class="docTableCell" align="left"><p class="docText">CR<a name="IDX-CHP-3-0653"></a> 
</P></td><TD class="docTableCell" align="left"><p class="docText"><tt>U+000D</tt></p></td><TD class="docTableCell" align="left"><p class="docText">ASCII Carriage Return</P></td></tr><TR><TD class="docTableCell" align="left"><p class="docText">CR/LF</P></td><TD class="docTableCell" align="left"><p class="docText"><tt>U+000D U+000A</tt></P></td><td class="docTableCell" align="left"><p class="docText">ASCII Carriage Return / Line Feed sequence</p></td></TR><tr><td class="docTableCell" align="left"><p class="docText">NEL<a name="IDX-CHP-3-0654"></a> 
</P></td><td class="docTableCell" align="left"><p class="docText"><tt>U+0085</tt></p></td><td class="docTableCell" align="left"><p class="docText">Unicode NEXT LINE<a name="IDX-CHP-3-0655"></a> 
</p></td></tr><tr><td class="docTableCell" align="left"><p class="docText">LS<a name="IDX-CHP-3-0656"></a> 
</p></td><td class="docTableCell" align="left"><p class="docText"><tt>U+2028</tt></p></td><td class="docTableCell" align="left"><p class="docText">Unicode LINE SEPARATOR<a name="IDX-CHP-3-0657"></a> 
</p></TD></tr><TR><td class="docTableCell" align="left"><p class="docText">PS<a name="IDX-CHP-3-0658"></a> 
</p></TD><TD class="docTableCell" align="left"><p class="docText"><tt>U+2029</tt></P></TD><td class="docTableCell" align="left"><p class="docText">Unicode PARAGRAPH SEPARATOR<a name="IDX-CHP-3-0659"></a> 
</P></td></tr></table></P><BR>
<p class="docText">When fully supported, line terminators influence how lines are read from a file (including, in scripting languages, the file the program is being read from). With regular expressions, they can influence both what dot matches (&#9758;111), and where <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0>, <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0>, and <img src=images/U2308.jpg border=0><tt>\Z</tt><img src=images/U230B.jpg border=0> match (&#9758;112).</p>


<a name="regex3-CHP-3-SECT-4.4"></a>
<h4 id="title-IDAIDRHI" class="docSection2Title">3.4.4. Regex Modes and Match Modes</H4>
<a name="IDX-CHP-3-0660"></a> 
<a name="IDX-CHP-3-0661"></a> 
<a name="IDX-CHP-3-0662"></a> 
<a name="IDX-CHP-3-0663"></a> 

<p class="docText">Most regex engines support a number of different modes<a name="IDX-CHP-3-0664"></a> 
 for how a regular expression is interpreted or applied. We've seen an example of each with Perl's<a name="IDX-CHP-3-0665"></a> 
 <tt>/x</tt> modifier (regex mode that allows free whitespace and comments &#9758;72) and <tt>/i</tt> modifier (match mode for case-insensitive matching &#9758;47).</P>
<p class="docText">Modes can generally be applied globally to the whole regex, or in many modern flavors, partially, to specific subexpressions of the regex. The global application is achieved through modifiers or options, such as Perl's <tt>/i</tt>, PHP's <span class="docEmphStrong">i</span> pattern modifier (&#9758;446), or <tt>java.util.regex</tt>'s <tt>Pattern.CASE_INSENSITIVE</tt><a name="IDX-CHP-3-0666"></a> 
 flag (&#9758;99). If supported, the partial application of a mode is achieved with a regex construct that looks like <img src=images/U2308.jpg border=0><tt>(?i)</tt><img src=images/U230B.jpg border=0> to turn on case-insensitive matching, or <img src=images/U2308.jpg border=0><tt>(?-i)</tt><img src=images/U230B.jpg border=0> to turn it off. Some flavors also support <img src=images/U2308.jpg border=0><tt>(?i:&#8943;)</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>(?-i:&#8943;)</tt><img src=images/U230B.jpg border=0>, which turn on and off case-insensitive matching for the subexpression enclosed.</P>
<p class="docText">How these modes are invoked within a regex is discussed later in this chapter (&#9758;135). In this section, we'll merely review some of the modes commonly available in most systems.</p>
<a name="regex3-CHP-3-SECT-4.4.1"></a>
<H5 id="title-IDAMFRHI" class="docSection3Title">3.4.4.1. Case-insensitive match mode</H5>
<p class="docText">The almost ubiquitous case-insensitive match mode ignores letter case during matching, so that <img src=images/U2308.jpg border=0><tt>b</tt><img src=images/U230B.jpg border=0> matches both '<tt>b</tt>' and '<tt>B</tt>'. This feature relies upon proper character encoding support, so all the cautions mentioned earlier apply.</p>
<p class="docText">Historically, case-insensitive matching support has been surprisingly fraught with bugs, but most have been fixed over the years. Still, Ruby's<a name="IDX-CHP-3-0667"></a> 
 case-insensitive matching doesn't apply to octal and hex escapes.</p>
<p class="docText">There are special Unicode-related issues with case-insensitive matching (which Unicode calls "loose matching"). For starters, not all alphabets have the concept of upper and lower case, and some have an additional <span class="docEmphasis">title case</span><a name="IDX-CHP-3-0668"></a> 
 used only at the start of a word. Sometimes there's not a straight one-to-one mapping between upper and lower case. A common example is that a Greek Sigma, &#931;,<a name="IDX-CHP-3-0669"></a> 
 has two lowercase versions, <img src=images/U03C2.jpg border=0> and &#963;;<a name="IDX-CHP-3-0670"></a> 
 all three should mutually match in case-insensitive mode.<a name="IDX-CHP-3-0671"></a> 
 Of the systems I've tested, only Perl and Java's<a name="IDX-CHP-3-0672"></a> 
 <tt>java.util.regex</tt> handle this correctly.</p>
<p class="docText">Another issue is that sometimes a single character maps to a sequence of multiple characters. One well known example is that the uppercase version of &szlig;<a name="IDX-CHP-3-0673"></a> 
<a name="IDX-CHP-3-0674"></a> 
 is the two-character combination "SS". Only Perl handles this properly.</p>
<p class="docText">There are also Unicode-manufactured problems. One example is that while there's a single character j&#774; (<tt>U+01F0</tt>), it has no single-character uppercase version. Rather, J&#774; requires a combining sequence (&#9758;107), <tt>U+004A</tt> and <tt>U+030C</tt>. Yet, &#774;j and &#774;J should match in a case-insensitive mode. There are even examples like this that involve one-to-three mappings. Luckily, most of these do not involve commonly used characters.</P>

<a name="regex3-CHP-3-SECT-4.4.2"></a>
<h5 id="title-IDAUHRHI" class="docSection3Title">3.4.4.2. Free-spacing and comments regex mode</h5>
<a name="IDX-CHP-3-0675"></a> 
<a name="IDX-CHP-3-0676"></a> 
<a name="IDX-CHP-3-0677"></a> 
<a name="IDX-CHP-3-0678"></a> 
<a name="IDX-CHP-3-0679"></a> 
<a name="IDX-CHP-3-0680"></a> 

<p class="docText">In this mode, whitespace outside of character classes is mostly ignored. Whitespace within a character class still counts (except in <tt>java.util.regex</tt>), and comments are allowed between <tt>#</tt> and a newline. We've already seen examples of this for Perl (&#9758;72), Java (&#9758;98), and VB.NET (&#9758;99).</P>
<p class="docText">Except for <tt>java.util.regex</tt>, it's not quite true that <span class="docEmphasis">all</span> whitespace outside of classes is ignored, but that it's turned into a do-nothing metacharacter. The distinction is important with something like <img src=images/U2308.jpg border=0><tt>\12 &#8226; 3</tt><img src=images/U230B.jpg border=0>, which in this mode is taken as <img src=images/U2308.jpg border=0><tt>\12</tt><img src=images/U230B.jpg border=0> followed by <img src=images/U2308.jpg border=0><tt>3</tt><img src=images/U230B.jpg border=0>, and not <img src=images/U2308.jpg border=0><tt>\123</tt><img src=images/U230B.jpg border=0>, as some might expect.</p>
<p class="docText">Of course, just what is and isn't "whitespace" is subject to the character encoding in effect, and its fullness of support. Most programs recognize only ASCII whitespace.</p>

<a name="regex3-CHP-3-SECT-4.4.3"></a>
<h5 id="title-IDAQJRHI" class="docSection3Title">3.4.4.3. Dot-matches-all match mode (a.k.a., "single-line mode")</h5>
<p class="docText">Usually, dot<a name="IDX-CHP-3-0681"></a> 
<a name="IDX-CHP-3-0682"></a> 
<a name="IDX-CHP-3-0683"></a> 
 does not match a newline. The original Unix regex tools worked on a line-by-line basis, so the thought of matching a newline wasn't an issue until the advent of <span class="docEmphasis">sed</span> and <span class="docEmphasis">lex</span>. By that time, <img src=images/U2308.jpg border=0><tt>.*</tt><img src=images/U230B.jpg border=0> had become a common idiom to match "the rest of the line," so the new languages disallowed it from crossing line boundaries in order to keep it familiar.<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-3-FN-9">[<img src=images/U2020.jpg border=0>]</a></sup> Thus, tools that could work with multiple lines (such as a text editor) generally disallow dot from matching a newline.</p><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-3-FN-9">[<img src=images/U2020.jpg border=0>]</a></sup> As Ken Thompson (<span class="docEmphasis">ed</span>'s author) explained it to me, it kept <img src=images/U2308.jpg border=0> <tt>.*</tt><img src=images/U230B.jpg border=0> from becoming "too unwieldy."</p></blockquote>
<p class="docText">For modern programming languages, a mode in which dot matches a newline can be as useful as one where dot doesn't. Which of these is most convenient for a particular situation depends on, well, the situation. Many programs now offer ways for the mode to be selected on a per-regex basis.</p>
<p class="docText">There are a few exceptions to the common standard. Unicode-enabled systems, such as Sun's Java regex package, may expand what dot normally does not match to include any of the single-character Unicode line terminators (&#9758;109). Tcl's normal state is that its dot matches everything, but in its special "newline-sensitive" and "partial newline-sensitive" matching modes, both dot <span class="docEmphasis">and</span> a negated character class are prohibited from matching a newline.</p>
<p class="docText"><span class="docEmphStrong">An unfortunate name</span>. When first introduced by Perl with its <tt>/s</tt> modifier, this mode was called "<a class="docLink" href="#regex3-CHP-3-SECT-4.4.3">single-line mode</a>."<a name="IDX-CHP-3-0684"></a> 
 This unfortunate name continues to cause no end of confusion because it has nothing whatsoever to do with <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0><a name="IDX-CHP-3-0685"></a> 
 and <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0>,<a name="IDX-CHP-3-0686"></a> 
<a name="IDX-CHP-3-0687"></a> 
 which are influenced by the "<a class="docLink" href="#regex3-CHP-3-SECT-4.4.4">multiline mode</a>" discussed in the next section. "<a class="docLink" href="#regex3-CHP-3-SECT-4.4.3">Single-line mode</a>" merely means that dot has no restrictions and can match any character.</p>

<a name="regex3-CHP-3-SECT-4.4.4"></a>
<h5 id="title-IDANMRHI" class="docSection3Title">3.4.4.4. Enhanced line-anchor match mode (a.k.a., "multiline mode")</h5>
<a name="IDX-CHP-3-0688"></a> 
<a name="IDX-CHP-3-0689"></a> 
<a name="IDX-CHP-3-0690"></a> 
<a name="IDX-CHP-3-0691"></a> 
<a name="IDX-CHP-3-0692"></a> 
<a name="IDX-CHP-3-0693"></a> 

<p class="docText">An enhanced line-anchor match mode influences where the line anchors, <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0>, match. The anchor <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0> normally does not match at embedded newlines, but rather only at the start of the string that the regex is being applied to. However, in enhanced mode, it can also match after an embedded newline, effectively having <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0> treat the string as multiple logical lines if the string contains newlines in the middle. We saw this in action in the previous chapter (&#9758;69) while developing a Perl program to converting text to HTML. The entire text document was within a single string, so we could use the search-and-replace <tt><span class="docEmphStrong">s</span>/^$/&lt;p&gt;<span class="docEmphStrong">/mg</span></tt> to convert "... tags.<img border="0" alt="" id="195131084199" width="12" height="16" SRC="images/regex3_u0220.jpg"><img border="0" alt="" id="195131084199" width="12" height="16" SRC="images/regex3_u0220.jpg">It's ..." to " ... tags. <img border="0" alt="" id="195131084199" width="12" height="16" SRC="images/regex3_u0220.jpg"> <tt><span class="docEmphStrong">&lt;p&gt;</span></tt> <img border="0" alt="" id="195131084199" width="12" height="16" SRC="images/regex3_u0220.jpg"> It's ..." The substitution replaces empty "lines" with paragraph tags.</p>
<p class="docText">It's much the same for <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0>, although the basic rules about when <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0> can normally match can be a bit more complex to begin with (&#9758;129). However, as far as this section is concerned, enhanced mode simply includes locations before an embedded newline as one of the places that <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0> can match.</p>
<p class="docText">Programs that offer this mode often offer <img src=images/U2308.jpg border=0><tt>\A</tt><img src=images/U230B.jpg border=0><a name="IDX-CHP-3-0694"></a> 
<a name="IDX-CHP-3-0695"></a> 
 and <img src=images/U2308.jpg border=0><tt>\Z</tt><img src=images/U230B.jpg border=0>,<a name="IDX-CHP-3-0696"></a> 
<a name="IDX-CHP-3-0697"></a> 
<a name="IDX-CHP-3-0698"></a> 
 which normally behave the same as <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0> except they are <span class="docEmphasis">not</span> modified by this mode. This means that <img src=images/U2308.jpg border=0><tt>\A</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>\Z</tt><img src=images/U230B.jpg border=0> never match at embedded newlines. Some implementations also allow <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>\Z</tt><img src=images/U230B.jpg border=0> to match before a string-ending newline. Such implementations often offer <img src=images/U2308.jpg border=0><tt>\z</tt><img src=images/U230B.jpg border=0>,<a name="IDX-CHP-3-0699"></a> 
<a name="IDX-CHP-3-0700"></a> 
 which disregards all newlines and matches <span class="docEmphasis">only</span> at the very end of the string. See page 129 for details.</p>
<p class="docText">As with dot, there are exceptions to the common standard. A text editor like GNU Emacs normally lets the line anchors match at embedded newlines, since that makes the most sense for an editor. On the other hand, <span class="docEmphasis">lex</span> has its <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0> match only before a newline (while its <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0> maintains the common meaning.)</p>
<p class="docText">Unicode-enabled systems, such as Sun's <tt>java.util.regex</tt>, may allow the line anchors in this mode to match at any line terminator (&#9758;109). Ruby's line anchors normally <span class="docEmphasis">do</span> match at any embedded newline, and Python's <img src=images/U2308.jpg border=0><tt>\Z</tt><img src=images/U230B.jpg border=0> behaves like its <img src=images/U2308.jpg border=0><tt>\z</tt><img src=images/U230B.jpg border=0>, rather than its normal <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0>.</p>
<p class="docText">Traditionally, this mode has been called "multiline mode." Although it is unrelated to "<a class="docLink" href="#regex3-CHP-3-SECT-4.4.3">single-line mode</a>," the names confusingly imply a relation. One simply modifies how dot<a name="IDX-CHP-3-0701"></a> 
 matches, while the other modifies how <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0> match. Another problem is that they approach newlines from different views. The first changes the concept of how dot treats a newline from "special" to "not special," while the other does the opposite and changes the concept of how <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0> treat newlines from "not special" to "special." <sup class="docFootnote"><a class="docLink" href="#regex3-CHP-3-FN-10">[<img src=images/U2020.jpg border=0>]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-3-FN-10">[<img src=images/U2020.jpg border=0>]</a></sup> Tcl<a name="IDX-CHP-3-0702"></a> 
 normally lets its dot match everything, so in one sense it's more straightforward than other languages. In Tcl regular expressions, newlines are not normally treated specially in any way (neither to dot nor to the line anchors),<a name="IDX-CHP-3-0703"></a> 
 but by using match modes, they become special. However, since other systems have always done it another way, Tcl could be considered confusing to those used to those other ways.</P></blockquote>

<a name="regex3-CHP-3-SECT-4.4.5"></a>
<h5 id="title-IDAZSRHI" class="docSection3Title">3.4.4.5. Literal-text regex mode</H5>
<p class="docText">A "literal text" mode is one that doesn't recognize most or all regex metacharacters. For example, a literal-text mode<a name="IDX-CHP-3-0704"></a> 
 version of <img src=images/U2308.jpg border=0><tt>[a-z]*</tt><img src=images/U230B.jpg border=0> matches the string '<tt><span class="docEmphStrong">[a-z]*</span></tt>'. A fully literal search is the same as a simple string search ("find this string" as opposed to "find a match for this regex"), and programs that offer regex support also tend to offer separate support for simple string searches. A regex literal-text mode becomes more interesting when it can be applied to just part of a regular expression. For example, PCRE (and hence PHP) regexes and Perl regex literals offer the special sequence <tt>\Q&#8943;\E</tt>, the contents of which have all metacharacters ignored (except the <tt>\E</tt> itself, of course).</p>



</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-3-SECT-3.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-3-SECT-5.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>