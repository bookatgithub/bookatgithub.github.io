<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 4.4.&nbsp; Backtracking</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-4-SECT-3.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-4-SECT-5.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="regex3-CHP-4-SECT-4"></a>
<H3 id="title-IDAAROEQ" class="docSection1Title">4.4. Backtracking</H3>
<a name="IDX-CHP-4-1484"></a> 

<p class="docText">The essence of an NFA engine is this: it considers each subexpression or component in turn, and whenever it needs to decide between two equally viable options, it selects one and remembers the other to return to later if need be.</P>
<p class="docText">Situations where it has to decide among courses of action include anything with a quantifier (decide whether to try another match), and alternation (decide which alternative to try, and which to leave for later).</P>
<p class="docText">Whichever course of action is attempted, if it's successful and the rest of the regex is also successful, the match is finished. If anything in the rest of the regex eventually causes failure, the regex engine knows it can <span class="docEmphasis">backtrack</span> to where it chose the first option, and can continue with the match by trying the other option. This way, it eventually tries all possible permutations of the regex (or at least as many as needed until a match is found).</p>
<a name="regex3-CHP-4-SECT-4.1"></a>
<H4 id="title-IDAUROEQ" class="docSection2Title">4.4.1. A Really Crummy Analogy</h4>
<a name="IDX-CHP-4-1485"></a> 
<a name="IDX-CHP-4-1486"></a> 

<p class="docText">Backtracking is like leaving a pile of bread crumbs<a name="IDX-CHP-4-1487"></a> 
 at every fork in the road. If the path you choose turns out to be a dead end, you can retrace your steps, giving up ground until you come across a pile of crumbs that indicates an untried path. Should that path, too, turn out to be a dead end, you can backtrack further, retracing your steps to the next pile of crumbs, and so on, until you eventually find a path that leads to your goal, or until you run out of untried paths.</p>
<p class="docText">There are various situations when the regex engine needs to choose between two (or more) optionsthe alternation we saw earlier is only one example. Another example is that upon reaching <img src=images/U2308.jpg border=0><tt>&#8943;x?&#8943;</tt><img src=images/U230B.jpg border=0>, the engine must decide whether it should attempt <img src=images/U2308.jpg border=0><tt>x</tt><img src=images/U230B.jpg border=0>. Upon reaching <img src=images/U2308.jpg border=0><tt>&#8943;x+&#8943;</tt><img src=images/U230B.jpg border=0>, however, there is no question about trying to match <img src=images/U2308.jpg border=0><tt>x</tt><img src=images/U230B.jpg border=0> at least oncethe plus requires at least one match, and that's non-negotiable. Once the first <img src=images/U2308.jpg border=0><tt>x</tt><img src=images/U230B.jpg border=0> has been matched, though, the <span class="docEmphasis">requirement</span> is lifted and it then must decide to match another <img src=images/U2308.jpg border=0><tt>x</tt><img src=images/U230B.jpg border=0>. If it decides to match, it must decide if it will then attempt to match yet another... and another... and so on. At each of these many decision points, a virtual "pile of crumbs" is left behind as a reminder that another option (to match or not to match, whichever wasn't chosen at each point) remains viable at that point.</P>
<a name="regex3-CHP-4-SECT-4.1.1"></a>
<H5 id="title-IDA2SOEQ" class="docSection3Title">4.4.1.1. A crummy little example</h5>
<p class="docText">Let's look at a full example using our earlier <img src=images/U2308.jpg border=0><tt>to(nite|knight|night)</tt><img src=images/U230B.jpg border=0> regex on the string '<tt>hot&#8226;tonic&#8226;tonight!</tt>' (silly, yes, but a good example). The first component, <img src=images/U2308.jpg border=0><tt>t</tt><img src=images/U230B.jpg border=0>, is attempted at the start of the string. It fails to match <tt>h</tt>, so the entire regex fails at that point. The engine's transmission then bumps along to retry the regex from the second position (which also fails), and again at the third. This time the <img src=images/U2308.jpg border=0><tt>t</tt><img src=images/U230B.jpg border=0> matches, but the subsequent <img src=images/U2308.jpg border=0><tt>o</tt><img src=images/U230B.jpg border=0> fails to match because the text we're at is now a space. So, again, the whole attempt fails.</p>
<p class="docText">The attempt that eventually starts at &#8943;<sub><img src=images/U22CF.jpg border=0></sub><tt>tonic</tt>&#8943; is more interesting. Once the <tt>to</tt> has been matched, the three alternatives become three available options. The regex engine picks one to try, remembering the others ("leaving some bread crumbs") in case the first fails. For the purposes of discussion, let's say that the engine first chooses <img src=images/U2308.jpg border=0><tt>nite</tt><img src=images/U230B.jpg border=0>. That expression breaks down to "<img src=images/U2308.jpg border=0><tt>n</tt><img src=images/U230B.jpg border=0> <tt>+</tt> <img src=images/U2308.jpg border=0><tt>i</tt><img src=images/U230B.jpg border=0> <tt>+</tt> <img src=images/U2308.jpg border=0><tt>t</tt><img src=images/U230B.jpg border=0>...," which gets to <tt>&#8943;to</tt><img border="0" alt="" width="18" height="16" SRC="images/regex3_u0410.jpg"><sub><img src=images/U22CF.jpg border=0></sub><tt>c</tt>&#8943; before failing. Unlike the earlier failures, this failure doesn't mean the end of the overall attempt because other optionsthe as-of-yet untried alternativesstill remain. (In our analogy, we still have piles of breadcrumbs we can return to.) The engine chooses one, we'll say <img src=images/U2308.jpg border=0><tt>knight</tt><img src=images/U230B.jpg border=0>, but it fails right away because <img src=images/U2308.jpg border=0><tt>k</tt><img src=images/U230B.jpg border=0> doesn't match '<tt>n</tt>'. That leaves one final option, <img src=images/U2308.jpg border=0><tt>night</tt><img src=images/U230B.jpg border=0>, but it too eventually fails. Since that was the final untried option, its failure means the failure of the entire attempt starting at &#8943;<sub><img src=images/U22CF.jpg border=0></sub><tt>tonic</tt>&#8943;, so the transmission kicks in again.</P>
<p class="docText">Once the engine works its way to attempt the match starting at &#8943;<sub><img src=images/U22CF.jpg border=0></sub><tt>tonight!</tt>, it gets interesting again. This time, the <img src=images/U2308.jpg border=0><tt>night</tt><img src=images/U230B.jpg border=0> alternative successfully matches to the end (which means an overall match, so the engine can report success at that point).</P>


<a name="regex3-CHP-4-SECT-4.2"></a>
<H4 id="title-IDACVOEQ" class="docSection2Title">4.4.2. Two Important Points on Backtracking</h4>
<a name="IDX-CHP-4-1488"></a> 
<a name="IDX-CHP-4-1489"></a> 
<a name="IDX-CHP-4-1490"></a> 
<a name="IDX-CHP-4-1491"></a> 
<a name="IDX-CHP-4-1492"></a> 
<a name="IDX-CHP-4-1493"></a> 

<p class="docText">The general idea of how backtracking works is fairly simple, but some of the details are quite important for real-world use. Specifically, when faced with multiple choices, which choice should be tried first? Secondly, when forced to backtrack, which saved choice should the engine use? The answer to that first question is this important principle:</P>
<blockquote><p class="docText">In situations where the decision is between "make an attempt" and "skip an attempt," as with items governed by quantifiers, the engine always chooses to first <span class="docEmphasis">make</span> the attempt for <span class="docEmphasis">greedy</span>quantifiers, and to first <span class="docEmphasis">skip</span> the attempt for <span class="docEmphasis">lazy</span> (non-greedy) ones.</P></blockquote>
<p class="docText">This has far-reaching repercussions. For starters, it helps explain why the greedy quantifiers are greedy, but it doesn't explain it completely. To complete the picture, we need to know which (among possibly many) saved options to use when we backtrack. Simply put:</p>
<blockquote><p class="docText">The most recently saved option is the one returned to when a local failure forces backtracking. They're used LIFO<a name="IDX-CHP-4-1494"></a> 
 (last in first out).</p></blockquote>
<p class="docText">This is easily understood in the crummy analogyif your path becomes blocked, you simply retrace your steps until you come back across a pile of bread crumbs. The first you'll return to is the one most recently laid. The traditional analogy for describing LIFO also holds: like stacking and unstacking dishes, the most-recently stacked will be the first unstacked.</p>

<a name="regex3-CHP-4-SECT-4.3"></a>
<h4 id="title-IDABXOEQ" class="docSection2Title">4.4.3. Saved States</H4>
<p class="docText">In NFA regular expression nomenclature, the piles of bread crumbs are known as saved <span class="docEmphasis">states</span>. A state indicates where matching can restart from, if need be. It reflects both the position in the regex and the point in the string where an untried option begins. Because this is the basis for NFA matching, let me show the implications of what I've already said with some simple but verbose examples. If you're comfortable with the discussion so far, feel free to skip ahead.</p>
<a name="regex3-CHP-4-SECT-4.3.1"></a>
<h5 id="title-IDAMXOEQ" class="docSection3Title">4.4.3.1. A match without backtracking</H5>
<a name="IDX-CHP-4-1495"></a> 

<a name="IDX-CHP-4-1496"></a> 

<a name="IDX-CHP-4-1497"></a> 
<a name="IDX-CHP-4-1498"></a> 
<a name="IDX-CHP-4-1499"></a> 

<p class="docText">Let's look at a simple example,<a name="IDX-CHP-4-1500"></a> 
 matching <img src=images/U2308.jpg border=0><tt>ab?c</tt><img src=images/U230B.jpg border=0> against <tt>abc</tt>. Once the <img src=images/U2308.jpg border=0><tt>a</tt><img src=images/U230B.jpg border=0> has matched, the <span class="docEmphasis">current state</span> of the match is reflected by:</p>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><tr><td class="docTableCell" align="center"><p class="docText">at '<tt>a<sub><img src=images/U22CF.jpg border=0></sub>bc</tt>'</p></td><td class="docTableCell" align="center"><p class="docText">matching <img src=images/U2308.jpg border=0><tt>a<sub><img src=images/U22CF.jpg border=0></sub>b?c</tt><img src=images/U230B.jpg border=0></p></td></tr></table></p><br>
<p class="docText">However, now that <img src=images/U2308.jpg border=0><tt>b?</tt><img src=images/U230B.jpg border=0> is up to match, the regex engine has a decision to make: should it attempt the <img src=images/U2308.jpg border=0><tt>b</tt><img src=images/U230B.jpg border=0>, or skip it?. Well, since ? is greedy, it attempts the match. But, so that it can recover if that attempt fails or eventually leads to failure, it adds</p>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><tr><td class="docTableCell" align="center"><p class="docText">at '<tt>a<sub><img src=images/U22CF.jpg border=0></sub>bc</tt>'</p></TD><td class="docTableCell" align="center"><p class="docText">matching <img src=images/U2308.jpg border=0><tt>ab?<sub><img src=images/U22CF.jpg border=0></sub>c</tt><img src=images/U230B.jpg border=0></P></td></tr></table></P><BR>
<p class="docText">to its otherwise empty list of saved states. This indicates that the engine can later pick up the match in the regex just <span class="docEmphasis">after</span> the <img src=images/U2308.jpg border=0><tt>b?</tt><img src=images/U230B.jpg border=0>, picking up in the text from just before the <tt>b</tt> (that is, where it is now). Thus, in effect, skipping the <img src=images/U2308.jpg border=0><tt>b</tt><img src=images/U230B.jpg border=0> as the question mark allows.</P>
<p class="docText">Once the engine carefully places that pile of crumbs, it goes ahead and checks the <img src=images/U2308.jpg border=0><tt>b</tt><img src=images/U230B.jpg border=0>. With the example text, it matches, so the new current state becomes:</P>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><TR><td class="docTableCell" align="center"><p class="docText">at '<tt>ab<sub><img src=images/U22CF.jpg border=0></sub>c</tt>'</p></TD><TD class="docTableCell" align="center"><p class="docText">matching <img src=images/U2308.jpg border=0><tt>ab?<sub><img src=images/U22CF.jpg border=0></sub>c</tt><img src=images/U230B.jpg border=0></p></td></TR></table></P><BR>
<p class="docText">The final <img src=images/U2308.jpg border=0><tt>c</tt><img src=images/U230B.jpg border=0> matches as well, so we have an overall match. The one saved state is no longer needed, so it is simply forgotten.</p>

<a name="regex3-CHP-4-SECT-4.3.2"></a>
<H5 id="title-IDAX3OEQ" class="docSection3Title">4.4.3.2. A match after backtracking</H5>
<p class="docText">Now, if '<tt>ac</tt>' had been the text to match, everything would have been the same until the <img src=images/U2308.jpg border=0><tt>b</tt><img src=images/U230B.jpg border=0> attempt was made. Of course, this time it wouldn't match. This means that the path that resulted from actually attempting the <img src=images/U2308.jpg border=0> <tt>&#8943;?</tt><img src=images/U230B.jpg border=0> failed. Since there is a saved state available to return to, this "local failure" does not mean overall failure. The engine backtracks, meaning that it takes the most recently saved state as its new current state. In this case, that would be the</p>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><tr><td class="docTableCell" align="center"><p class="docText">at '<tt>a<sub><img src=images/U22CF.jpg border=0></sub>c</tt>'</P></td><td class="docTableCell" align="center"><p class="docText">matching <img src=images/U2308.jpg border=0><tt>ab?<sub><img src=images/U22CF.jpg border=0></sub>c</tt><img src=images/U230B.jpg border=0></P></td></tr></table></p><br>
<p class="docText">state that had been saved as the untried option before the <img src=images/U2308.jpg border=0><tt>b</tt><img src=images/U230B.jpg border=0> had been attempted. This time, the <img src=images/U2308.jpg border=0><tt>c</tt><img src=images/U230B.jpg border=0> and <tt>c</tt> match up, so the overall match is achieved.</p>

<a name="regex3-CHP-4-SECT-4.3.3"></a>
<h5 id="title-IDAZ5OEQ" class="docSection3Title">4.4.3.3. A non-match</h5>
<p class="docText">Now let's look at the same expression, but against '<tt>abX</tt>'. Before the <img src=images/U2308.jpg border=0><tt>b</tt><img src=images/U230B.jpg border=0> is attempted, the question mark causes this state to be saved:</p>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><tr><td class="docTableCell" align="center"><p class="docText">at '<tt>a<sub><img src=images/U22CF.jpg border=0></sub>bX</tt>'</p></td><td class="docTableCell" align="center"><p class="docText">matching <img src=images/U2308.jpg border=0><tt>ab?<sub><img src=images/U22CF.jpg border=0></sub>c</tt><img src=images/U230B.jpg border=0></p></td></tr></table></P><br>
<p class="docText">The <img src=images/U2308.jpg border=0><tt>b</tt><img src=images/U230B.jpg border=0> matches, but that avenue later turns out to be a dead end because the <img src=images/U2308.jpg border=0><tt>c</tt><img src=images/U230B.jpg border=0> fails to match <tt>X</tt>. The failure results in a backtrack to the saved state. The engine next tests <img src=images/U2308.jpg border=0><tt>c</tt><img src=images/U230B.jpg border=0> against the <tt>b</tt> that the backtrack effectively "unmatched." Obviously, this test fails, too. If there were other saved states, another backtrack would occur, but since there aren't any, the overall match at the current starting position is deemed a failure.</P>
<p class="docText">Are we done? Nope. The engine's transmission still does its "bump along the string and retry the regex," which might be thought of as a pseudo-backtrack. The match restarts at:</p>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><TR><TD class="docTableCell" align="center"><p class="docText">at '<tt>a<sub><img src=images/U22CF.jpg border=0></sub>bX</tt>'</P></TD><td class="docTableCell" align="center"><p class="docText">matching <img src=images/U2308.jpg border=0><tt><sub><img src=images/U22CF.jpg border=0></sub>ab?c</tt><img src=images/U230B.jpg border=0></P></td></tr></table></P><BR>
<p class="docText">The whole match is attempted again from the new spot, and like before, all paths lead to failure. After the next two attempts (from <tt>ab</tt><sub><img src=images/U22CF.jpg border=0></sub><tt>X</tt> and <tt>abX</tt><sub><img src=images/U22CF.jpg border=0></sub> similarly fail, overall failure is finally reported.</p>

<a name="regex3-CHP-4-SECT-4.3.4"></a>
<h5 id="title-IDAUDPEQ" class="docSection3Title">4.4.3.4. A lazy match</H5>
<a name="IDX-CHP-4-1501"></a> 
<a name="IDX-CHP-4-1502"></a> 
<a name="IDX-CHP-4-1503"></a> 

<p class="docText">Let's look at the original example, but with a lazy quantifier, matching <img src=images/U2308.jpg border=0><tt>a<span class="docEmphStrong">b??</span>c</tt><img src=images/U230B.jpg border=0> against '<tt>abc</tt>'. Once the <img src=images/U2308.jpg border=0><tt>a</tt><img src=images/U230B.jpg border=0> has matched, the state of the match is reflected by:</P>
<P><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><tr><TD class="docTableCell" align="center"><p class="docText">at '<tt>a<sub><img src=images/U22CF.jpg border=0></sub>bc</tt>'</P></td><td class="docTableCell" align="center"><p class="docText">matching <img src=images/U2308.jpg border=0><tt>a<sub><img src=images/U22CF.jpg border=0></sub><span class="docEmphStrong">b??</span>c</tt><img src=images/U230B.jpg border=0></p></td></TR></table></p><br>
<p class="docText">Now that <img src=images/U2308.jpg border=0><tt>b??</tt><img src=images/U230B.jpg border=0> is next to be applied, the regex engine has a decision to make: attempt the <img src=images/U2308.jpg border=0><tt>b</tt><img src=images/U230B.jpg border=0> or skip it? Well, since <tt>??</tt> is lazy, it specifically chooses to first skip the attempt, but, so that it can recover if that attempt fails or eventually leads to failure, it adds</P>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><tr><td class="docTableCell" align="center"><p class="docText">at '<tt>a<sub><img src=images/U22CF.jpg border=0></sub>bc</tt>'</p></td><td class="docTableCell" align="center"><p class="docText">matching <img src=images/U2308.jpg border=0><tt>a<sub><img src=images/U22CF.jpg border=0></sub><span class="docEmphStrong">b</span>c</tt><img src=images/U230B.jpg border=0></p></td></tr></table></p><br>
<p class="docText">to its otherwise empty list of saved states. This indicates that the engine can later pick up the match by making the attempt of <img src=images/U2308.jpg border=0><tt>b</tt><img src=images/U230B.jpg border=0>, in the text from just before the <tt>b</tt>. (We know it will match, but the regex engine doesn't yet know that, or even know if it will ever need to get as far as making the attempt.) Once the state has been saved, it goes ahead and continues from after its skip-the-attempt decision:</p>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><tr><td class="docTableCell" align="center"><p class="docText">at '<tt>a<sub><img src=images/U22CF.jpg border=0></sub>bc</tt></p></td><TD class="docTableCell" align="center"><p class="docText">matching <img src=images/U2308.jpg border=0><tt>a<span class="docEmphStrong">b??</span><sub><img src=images/U22CF.jpg border=0></sub>c</tt><img src=images/U230B.jpg border=0></p></TD></tr></table></p><BR>
<p class="docText">The <img src=images/U2308.jpg border=0><tt>c</tt><img src=images/U230B.jpg border=0> fails to match '<tt>b</tt>', so indeed the engine must backtrack to its one saved state:</P>
<P><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><TR><td class="docTableCell" align="center"><p class="docText">at '<tt>a<sub><img src=images/U22CF.jpg border=0></sub>bc</tt></P></td><td class="docTableCell" align="center"><p class="docText">matching <img src=images/U2308.jpg border=0><tt>a<sub><img src=images/U22CF.jpg border=0></sub><span class="docEmphStrong">b</span>c</tt><img src=images/U230B.jpg border=0></P></TD></tr></table></p><BR>
<p class="docText">Of course, it matches this time, and the subsequent <img src=images/U2308.jpg border=0><tt>c</tt><img src=images/U230B.jpg border=0> matches '<tt>c</tt>'. The same final match we got with the greedy <img src=images/U2308.jpg border=0><tt>a<span class="docEmphStrong">b?</span>c</tt><img src=images/U230B.jpg border=0> is achieved, although via a different path.</P>


<a name="regex3-CHP-4-SECT-4.4"></a>
<H4 id="title-IDAOLPEQ" class="docSection2Title">4.4.4. Backtracking and Greediness</h4>
<a name="IDX-CHP-4-1504"></a> 
<a name="IDX-CHP-4-1505"></a> 
<a name="IDX-CHP-4-1506"></a> 
<a name="IDX-CHP-4-1507"></a> 
<a name="IDX-CHP-4-1508"></a> 

<p class="docText">For tools that use this NFA regex-directed backtracking<a name="IDX-CHP-4-1509"></a> 
<a name="IDX-CHP-4-1510"></a> 
 engine, understanding how backtracking works with your regular expression is the key to writing expressions that accomplish what you want, and accomplish it quickly. We've seen how <img src=images/U2308.jpg border=0><tt>?</tt><img src=images/U230B.jpg border=0> greediness and <img src=images/U2308.jpg border=0><tt>??</tt><img src=images/U230B.jpg border=0> laziness works, so now let's look at star and plus.</P>
<a name="regex3-CHP-4-SECT-4.4.1"></a>
<H5 id="title-IDA4MPEQ" class="docSection3Title">4.4.4.1. Star, plus, and their backtracking</h5>
<p class="docText">If you consider <img src=images/U2308.jpg border=0><tt>x*</tt><img src=images/U230B.jpg border=0> to be more or less the same as <img src=images/U2308.jpg border=0><tt>x?x?x?x?x?x?&#8943;</tt><img src=images/U230B.jpg border=0> (or, more appropriately, <img src=images/U2308.jpg border=0><tt>(x(x(x(x&#8943;?)?)?)?)?</tt><img src=images/U230B.jpg border=0>),<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-4-FN-6">[<img src=images/U2020.jpg border=0>]</a></sup> it's not too different from what we have already seen. Before checking the item quantified by the star, the engine saves a state indicating that if the check fails (or leads to failure), the match can pick up after the star. This is done repeatedly, until an attempt via the star actually does fail.</p><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-4-FN-6">[<img src=images/U2020.jpg border=0>]</a></sup> Just for comparison, remember that a DFA doesn't care much about the form you use to express which matches are possible; the three examples <span class="docEmphasis">are</span> identical to a DFA.</p></blockquote>
<p class="docText">Thus, when matching <img src=images/U2308.jpg border=0><tt>[0-9]+</tt><img src=images/U230B.jpg border=0> against '<tt>a&#8226;1234&#8226;num</tt>', once <img src=images/U2308.jpg border=0><tt>[0-9]</tt><img src=images/U230B.jpg border=0> fails to match the space after the <tt>4</tt>, there are four saved states corresponding to locations to which the plus can backtrack:</p>
<pre>
    a 1<sub><img src=images/U22CF.jpg border=0></sub>234 num
    a 12<sub><img src=images/U22CF.jpg border=0></sub>34 num
    a 123<sub><img src=images/U22CF.jpg border=0></sub>4 num
    a 1234<sub><img src=images/U22CF.jpg border=0></sub> num
</pre><BR>

<p class="docText">These represent the fact that the attempt of <img src=images/U2308.jpg border=0><tt>[0-9]</tt><img src=images/U230B.jpg border=0> had been optional at each of these positions. When <img src=images/U2308.jpg border=0><tt>[0-9]</tt><img src=images/U230B.jpg border=0> fails to match the space, the engine backtracks to the most recently saved state (the last one listed), picking up at '<tt>a</tt>&#8226;<tt>1234</tt><sub><img src=images/U22CF.jpg border=0></sub>&#8226;<tt>num</tt>' in the text and at <img src=images/U2308.jpg border=0><tt>[0-9]+<sub><img src=images/U22CF.jpg border=0></sub></tt><img src=images/U230B.jpg border=0> in the regex. Well, that's at the end of the regex. Now that we're actually there and notice it, we realize that we have an overall match.</p>
<p class="docText">Note that '<tt>a</tt>&#8226;<sub><img src=images/U22CF.jpg border=0></sub><tt>1234</tt>&#8226;<tt>num</tt>' is not in the list of positions, because the first match using the plus quantifier is required, not optional. Would it have been in the list had the regex been <img src=images/U2308.jpg border=0><tt>[0-9]<img border="0" alt="" width="7" height="10" SRC="images/regex3_u0408.jpg"></tt><img src=images/U230B.jpg border=0>? <span class="docEmphasis">(hint: it's a trick question)</span> <a class="docLink" href="regex3-CHP-4-SECT-5.html#regex3-CHP-4-SIDEBAR-3">&#10070;</a> Turn the page to check your answer.</p>

<a name="regex3-CHP-4-SECT-4.4.2"></a>
<H5 id="title-IDAXPPEQ" class="docSection3Title">4.4.4.2. Revisiting a fuller example</h5>
<p class="docText">With our more detailed understanding, let's revisit the <img src=images/U2308.jpg border=0><tt>^.*([0-9][0-9])</tt><img src=images/U230B.jpg border=0> example from page 152. This time, instead of just pointing to "greediness" to explain why the match turns out as it does, we can use our knowledge of NFA mechanics to explain why in precise terms.</p>
<p class="docText">I'll use '<tt>CA</tt>&#8226;<tt>95472</tt>,&#8226;<tt>USA</tt>' as an example. Once the <img src=images/U2308.jpg border=0> <tt>.*</tt><img src=images/U230B.jpg border=0> has successfully matched to the end of the string, there are a baker's dozen saved states accumulated from the star-governed dot matching <tt>13</tt> things that are (if need be) optional. These states note that the match can pick up in the regex at <img src=images/U2308.jpg border=0><tt>^.*<sub><img src=images/U22CF.jpg border=0></sub>([0-9][0-9])</tt><img src=images/U230B.jpg border=0>, and in the string at each point where a state was created.</p>
<p class="docText">Now that we've reached the end of the string and pass control to the first <img src=images/U2308.jpg border=0><tt>[0-9]</tt><img src=images/U230B.jpg border=0>, the match obviously fails. No problem: we have a saved state to try (a baker's dozen of them, actually). We backtrack, resetting the current state to the one most recently saved, to just before where <img src=images/U2308.jpg border=0> <tt>.*</tt><img src=images/U230B.jpg border=0> matched the final <tt>A</tt>. Skipping that match (or "unmatching" it, if you like) gives us the opportunity to try that <tt>A</tt> against the first <img src=images/U2308.jpg border=0><tt>[0-9]</tt><img src=images/U230B.jpg border=0>. But, it fails.</p>
<p class="docText">This backtrack-and-test cycle continues until the engine effectively unmatches the <tt>2</tt>, at which point the first <img src=images/U2308.jpg border=0><tt>[0-9]</tt><img src=images/U230B.jpg border=0> can match. The second can't, however, so we must continue to backtrack. It's now irrelevant that the first <img src=images/U2308.jpg border=0><tt>[0-9]</tt><img src=images/U230B.jpg border=0> matched during the previous attempt; the backtrack resets the current state to before the first <img src=images/U2308.jpg border=0><tt>[0-9]</tt><img src=images/U230B.jpg border=0>. As it turns out, the same backtrack resets the string position to just before the <tt>7</tt>, so the first <img src=images/U2308.jpg border=0><tt>[0-9]</tt><img src=images/U230B.jpg border=0> can match again. This time, so can the second (matching the <tt>2</tt>). Thus, we have a match: '<img border="0" alt="" width="62" height="12" SRC="images/regex3_u0411.jpg">, &#8226;<tt>USA</tt>', with <tt>$1</tt> getting '<tt>72</tt>'.</p>
<p class="docText">A few observations: first, backtracking<a name="IDX-CHP-4-1511"></a> 
 entails not only recalculating our position within the regex and the text, but also maintaining the status of the text being matched by the subexpression within parentheses. Each backtrack caused the match to be picked up before the parentheses, at <img src=images/U2308.jpg border=0><tt>^.*<sub><img src=images/U22CF.jpg border=0></sub>([0-9][0-9])</tt><img src=images/U230B.jpg border=0>. As far as the simple match attempt is concerned, this is the same as <img src=images/U2308.jpg border=0><tt>^.*<sub><img src=images/U22CF.jpg border=0></sub>[0-9][0-9]</tt><img src=images/U230B.jpg border=0>, so I used phrases such as "picks up before the first <img src=images/U2308.jpg border=0><tt>[0-9]</tt><img src=images/U230B.jpg border=0>." However, moving in and out of the parentheses involves updating the status of what <tt>$1</tt> should be, which also has an impact on efficiency.</p>
<p class="docText">One final observation that may already be clear to you: something governed by star (or any of the greedy quantifiers) first matches as much as it can <span class="docEmphasis">without regard to what might follow in the regex</span>. In our example, the <img src=images/U2308.jpg border=0> <tt>.*</tt><img src=images/U230B.jpg border=0> does not magically know to stop at the first digit, or the second to the last digit, or any other place until what's governed by the greedy quantifierthe dotfinally fails. We saw this earlier when looking at how <img src=images/U2308.jpg border=0><tt>^.*([0-9]+)</tt><img src=images/U230B.jpg border=0> would never have more than a single digit matched by the <img src=images/U2308.jpg border=0><tt>[0-9]+</tt><img src=images/U230B.jpg border=0> part (&#9758; 153).</p>



<a href="7041536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-4-SECT-3.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-4-SECT-5.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>