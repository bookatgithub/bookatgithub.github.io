<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 4.5.&nbsp; More About Greediness and Backtracking</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-4-SECT-4.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-4-SECT-6.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="regex3-CHP-4-SECT-5"></a>
<H3 id="title-IDAJJ4HE" class="docSection1Title">4.5. More About Greediness and Backtracking</H3>
<a name="IDX-CHP-4-1512"></a> 

<p class="docText">Many concerns (and benefits) of greediness are shared by both an NFA and a DFA. (A DFA doesn't support laziness, which is why we've concentrated on greediness up to this point.) I'd like to look at some ramifications of greediness for both, but with examples explained in terms of an NFA. The lessons apply to a DFA just as well, but not for the same reasons. A DFA is greedy, period, and there's not much more to say after that. It's very easy to use, but pretty boring to talk about. An NFA, however, is interesting because of the creative outlet its regex-directed nature provides. Besides lazy quantifiers, there are a variety of extra features an NFA can support, including lookaround, conditionals, backreferences, and atomic grouping. And on top of these, an NFA affords the regex author direct control over how a match is carried out, which can be a benefit when used properly, but it does create some efficiency-related pitfalls (discussed in <a class="docLink" href="regex3-CHP-6.html#regex3-CHP-6">Chapter 6</a>.)</P>
<a name="regex3-CHP-4-SIDEBAR-3"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Quiz Answer</h2>
<p class="docText">&#10070; <span class="docEmphasis">Answer to the question on page 162</span>.</P>
<p class="docText"><span class="docEmphStrong">When matching <img src=images/U2308.jpg border=0><tt>[0-9]<img border="0" alt="" width="7" height="10" SRC="images/regex3_u0408.jpg"></tt><img src=images/U230B.jpg border=0> against 'a&#8226;1234&#8226;num', would 'a&#8226;<sub><img src=images/U22CF.jpg border=0></sub>1234&#8226;num' be part of a saved state?</span></P>
<p class="docText">The answer is "no." I posed this question because the mistake is commonly made. Remember, a component that has star applied can <span class="docEmphasis">always</span> match. If that's the entire regex, it can always match anywhere. This certainly includes the attempt when the transmission applies the engine the first time, at the start of the string. In this case, the regex matches at '<sub><img src=images/U22CF.jpg border=0></sub><tt>a</tt>&#8226;<tt>1234</tt>&#8226;<tt>num</tt>' and that's the end of itit never even gets as far the digits.</p>
<p class="docText">In case you missed this, there's still a chance for partial credit. Had there been something in the regex after the <img src=images/U2308.jpg border=0><tt>[0-9]*</tt><img src=images/U230B.jpg border=0> that kept an overall match from happening before the engine got to:</p>
<P><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="90%"><colgroup span="2"><col><col></colgroup><thead></thead><TR><TD class="docTableCell" align="center"><p class="docText">at '<tt>a</tt>&#8226;<sub><img src=images/U22CF.jpg border=0></sub><tt>1234</tt>&#8943;'</p></TD><TD class="docTableCell" align="center"><p class="docText">matching <img src=images/U2308.jpg border=0><tt><sub><img src=images/U22CF.jpg border=0></sub>[0-9]*&#8943;</tt><img src=images/U230B.jpg border=0></p></td></tr></table></p><BR>
<p class="docText">then indeed, the attempt of the '<tt>1</tt>' also creates the state:</p>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="90%"><colgroup span="2"><col><col></colgroup><thead></thead><TR><td class="docTableCell" align="center"><p class="docText">at '<tt>a</tt>&#8226;<sub><img src=images/U22CF.jpg border=0></sub><tt>1234</tt>&#8943;'</p></td><td class="docTableCell" align="center"><p class="docText">matching <img src=images/U2308.jpg border=0><tt>[0-9]*<sub><img src=images/U22CF.jpg border=0></sub>&#8943;</tt><img src=images/U230B.jpg border=0></p></td></tr></table></p><br>
</td></tr></table></p><br>
<p class="docText">Despite these differences, the match results are often similar. For the next few pages, I'll talk of both engine types, but describe effects in terms of the regex-directed NFA. By the end of this chapter, you'll have a firm grasp of just when the results might differ, as well as exactly why.</p>
<a name="regex3-CHP-4-SECT-5.1"></a>
<h4 id="title-IDA4N4HE" class="docSection2Title">4.5.1. Problems of Greediness</h4>
<p class="docText">As we saw with the last example, <img src=images/U2308.jpg border=0> <tt>.*</tt><img src=images/U230B.jpg border=0> always marches to the end of the line.<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-4-FN-7">[<img src=images/U2020.jpg border=0>]</a></sup> This is because <img src=images/U2308.jpg border=0> <tt>.*</tt><img src=images/U230B.jpg border=0> just thinks of itself and grabs what it can, only later giving up something if it is required to achieve an overall match.</p><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-4-FN-7">[<img src=images/U2020.jpg border=0>]</a></sup> With a tool or mode where a dot can match a newline, <img src=images/U2308.jpg border=0> <tt>.*</tt><img src=images/U230B.jpg border=0> applied to strings that contain multiline data matches through all the logical lines to the end of the whole string.</P></blockquote>
<p class="docText">Sometimes this can be a real pain. Consider a regex to match text wrapped in double quotes. At first, you might want to write <img src=images/U2308.jpg border=0><tt>".*"</tt><img src=images/U230B.jpg border=0>,<a name="IDX-CHP-4-1513"></a> 
 but knowing what we know about <img src=images/U2308.jpg border=0> <tt>.*</tt><img src=images/U230B.jpg border=0>, guess where it matches in:</p>
<pre>
    The name "McDonald's" is said "makudonarudo"<a name="IDX-CHP-4-1514"></a> 
<a name="IDX-CHP-4-1515"></a> 
<a name="IDX-CHP-4-1516"></a> 
 in Japanese
</pre><BR>

<p class="docText">Actually, since we understand the mechanics of matching, we don't need to guess, because we <span class="docEmphasis">know</span>. Once the initial quote matches, <img src=images/U2308.jpg border=0> <tt>.*</tt><img src=images/U230B.jpg border=0> is free to match, and immediately does so all the way to the end of the string. It backs off (or, perhaps more appropriately, <span class="docEmphasis">is backed off</span> by the regex engine) only as much as is needed until the final quote can match. In the end, it matches</p>
<pre>
    The name <div><img border="0" alt="" width="338" height="15" SRC="images/regex3_u0412.jpg"></div> in Japanese
</pre><br>

<p class="docText">which is obviously not the double-quoted string that was intended. This is one reason why I caution against the overuse of <img src=images/U2308.jpg border=0> <tt>.*</tt><img src=images/U230B.jpg border=0>, as it can often lead to surprising results if you don't pay careful attention to greediness.</P>
<p class="docText">So, how can we have it match "<tt>McDonald's</tt>" only? The key is to realize that we don't want "anything" between the quotes, but rather "anything except a quote." If we use <img src=images/U2308.jpg border=0><tt>[^"]*</tt><img src=images/U230B.jpg border=0> rather than <img src=images/U2308.jpg border=0> <tt>.*</tt><img src=images/U230B.jpg border=0>, it won't overshoot the closing quote.</P>
<p class="docText">The regex engine's basic approach with <img src=images/U2308.jpg border=0><tt>"[^"]*"</tt><img src=images/U230B.jpg border=0> is exactly the same as before. Once the initial double quote matches, <img src=images/U2308.jpg border=0><tt>[^"]*</tt><img src=images/U230B.jpg border=0> gets a shot at matching as much as it can. In this case, that's up to the double quote after <tt>McDonald's</tt>, at which point it finally stops because <img src=images/U2308.jpg border=0><tt>[^"]</tt><img src=images/U230B.jpg border=0> can't match the quote. At that point, control moves to the closing <img src=images/U2308.jpg border=0><tt>"</tt><img src=images/U230B.jpg border=0>. It happily matches, resulting in overall success:</P>
<pre>
    The name <div><img border="0" alt="" width="113" height="14" SRC="images/regex3_u0413.jpg"></div> is said "makudonarudo" in Japanese
</pre><BR>

<p class="docText">Actually, there could be one unexpected change, and that's because in most flavors, <img src=images/U2308.jpg border=0><tt>[^"]</tt><img src=images/U230B.jpg border=0> can match a newline, while dot doesn't. If you want to keep the regex from crossing lines, use <img src=images/U2308.jpg border=0><tt>[^"<span class="docEmphStrong">\n</span>]</tt><img src=images/U230B.jpg border=0>.</p>

<a name="regex3-CHP-4-SECT-5.2"></a>
<H4 id="title-IDAXR4HE" class="docSection2Title">4.5.2. Multi-Character "Quotes"</h4>
<a name="IDX-CHP-4-1517"></a> 
<a name="IDX-CHP-4-1518"></a> 
<a name="IDX-CHP-4-1519"></a> 
<a name="IDX-CHP-4-1520"></a> 
<a name="IDX-CHP-4-1521"></a> 
<a name="IDX-CHP-4-1522"></a>
<a name="IDX-CHP-4-1523"></a>

<p class="docText">In the first chapter, I talked a bit about matching HTML tags, such as the sequence &lt;<tt>B</tt>&gt;<tt>very</tt>&lt;<tt>/B</tt>&gt; that renders the "very" in bold if the browser can do so. Attempting to match a &lt;<tt>B</tt>&gt;&#8943;&lt;<tt>/B</tt>&gt; sequence seems similar to matching a quoted string, except the "quotes" in this case are the multi-character sequences &lt;<tt>B</tt>&gt; and &lt;<tt>/B</tt>&gt;. Like the quoted string example, multiple sets of "quotes" cause problems if we use <img src=images/U2308.jpg border=0> <tt>.*</tt><img src=images/U230B.jpg border=0>:</p>
<pre>
    &#8943;<div><img border="0" alt="" width="300" height="14" SRC="images/regex3_u0414.jpg"></div> of suns&#8943;
</pre><BR>

<p class="docText">With <img src=images/U2308.jpg border=0><tt>&lt;B&gt; .*&lt;/B&gt;</tt><img src=images/U230B.jpg border=0>, the greedy <img src=images/U2308.jpg border=0> <tt>.*</tt><img src=images/U230B.jpg border=0> causes the match in progress to zip to the end of the line, backtracking only far enough to allow the <img src=images/U2308.jpg border=0><tt>&lt;/B&gt;</tt><img src=images/U230B.jpg border=0> to match, matching the last &lt;<tt>/B</tt>&gt; on the line instead of the one corresponding to the opening <img src=images/U2308.jpg border=0><tt>&lt;B&gt;</tt><img src=images/U230B.jpg border=0> at the start of the match.</P>
<p class="docText">Unfortunately, since the closing delimiter is more than one character, we can't solve the problem with a negated class as we did with double-quoted strings. We can't expect something like <img src=images/U2308.jpg border=0><tt>&lt;B&gt;<span class="docEmphStrong">[^&lt;/B&gt;]</span>*&lt;/B&gt;</tt><img src=images/U230B.jpg border=0> to work. A character class represents only one character and not the full &lt;<tt>/B</tt>&gt; sequence that we want. Don't let the apparent structure of <img src=images/U2308.jpg border=0><tt>[^&lt;/B&gt;]</tt><img src=images/U230B.jpg border=0> fool you. It is just a class to match one characterany one except <tt>&lt;, &gt;, /,</tt> and <tt>B</tt>. It is the same as, say <img src=images/U2308.jpg border=0><tt>[^/&lt;&gt;B]</tt><img src=images/U230B.jpg border=0>, and certainly doesn't work as an "anything not &lt;<tt>/B</tt>&gt;" construct. (With lookahead, you can insist that <img src=images/U2308.jpg border=0><tt>&lt;/B&gt;</tt><img src=images/U230B.jpg border=0> not match at a particular point; we'll see this in action in the next section.)</p>

<a name="regex3-CHP-4-SECT-5.3"></a>
<h4 id="title-IDA3U4HE" class="docSection2Title">4.5.3. Using Lazy Quantifiers</H4>
<p class="docText">These problems arise because the standard quantifiers are greedy. Some NFAs support lazy<a name="IDX-CHP-4-1524"></a> 
 quantifiers (&#9758; 141), with <tt>*?</tt> being the lazy version of <tt>*</tt>. With that in mind, let's apply <img src=images/U2308.jpg border=0><tt>&lt;B&gt;<span class="docEmphStrong">.*?</span>&lt;/B&gt;</tt><img src=images/U230B.jpg border=0> to:</P>
<pre>
    &#8943;&lt;B&gt;Billions&lt;/B&gt; and &lt;B&gt;Zillions&lt;/B&gt; of suns&#8943;
</pre><BR>

<p class="docText">After the initial <img src=images/U2308.jpg border=0><tt>&lt;B&gt;</tt><img src=images/U230B.jpg border=0> has matched, <img src=images/U2308.jpg border=0> <tt>.*?</tt><img src=images/U230B.jpg border=0> immediately decides that since it doesn't require any matches, it lazily doesn't bother trying to perform any. So, it immediately passes control to the following <img src=images/U2308.jpg border=0><tt>&lt;</tt><img src=images/U230B.jpg border=0>:</p>
<P><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><TR><td class="docTableCell" align="center"><p class="docText">at '&#8943;&lt;<tt>B</tt>&gt;<sub><img src=images/U22CF.jpg border=0></sub><tt>Billions</tt>&#8943;'</p></td><td class="docTableCell" align="center"><p class="docText">matching <img src=images/U2308.jpg border=0><tt>&lt;B&gt;.*?<sub><img src=images/U22CF.jpg border=0></sub>&lt;/B&gt;</tt><img src=images/U230B.jpg border=0></P></td></tr></table></P><br>
<p class="docText">The <img src=images/U2308.jpg border=0><tt>&lt;</tt><img src=images/U230B.jpg border=0> doesn't match at that point, so control returns back to <img src=images/U2308.jpg border=0> <tt>.*?</tt><img src=images/U230B.jpg border=0> where it still has its untried option to attempt a match (to attempt multiple matches, actually). It begrudgingly does so, with the dot matching the underlined <tt>B</tt> in &#8943;&lt;<tt>B</tt>&gt;<img border="0" alt="" width="8" height="12" SRC="images/regex3_u0415.jpg"><tt>illions&#8943;</tt>. Again, the <tt>*?</tt> has the option to match more, or to stop. It's lazy, so it first tries stopping. The subsequent <img src=images/U2308.jpg border=0><tt>&lt;</tt><img src=images/U230B.jpg border=0> still fails, so <img src=images/U2308.jpg border=0> <tt>.*?</tt><img src=images/U230B.jpg border=0> has to again exercise its untried match option. After eight cycles, <img src=images/U2308.jpg border=0> <tt>.*?</tt><img src=images/U230B.jpg border=0> eventually matches <tt>Billions</tt>, at which point the subsequent <img src=images/U2308.jpg border=0><tt>&lt;</tt><img src=images/U230B.jpg border=0> (and the whole <img src=images/U2308.jpg border=0><tt>&lt;/B&gt;</tt><img src=images/U230B.jpg border=0> subexpression) is finally able to match:</p>
<pre>
    &#8943;<div><img border="0" alt="" width="128" height="14" SRC="images/regex3_u0416.jpg"></div> and &lt;B&gt;Zillions&lt;/B&gt; of suns&#8943;
</pre><br>

<p class="docText">So, as we've seen, the greediness of star and friends can be a real boon at times, while troublesome at others. Having non-greedy, lazy versions is wonderful, as they allow you to do things that are otherwise very difficult (or even impossible). Still, I've often seen inexperienced programmers use lazy quantifiers in inappropriate situations. In fact, what we've just done may not be appropriate. Consider applying <img src=images/U2308.jpg border=0><tt>&lt;B&gt;.*?&lt;/B&gt;</tt><img src=images/U230B.jpg border=0> to:</p>
<pre>
   &#8943;<div><img border="0" alt="" width="300" height="14" SRC="images/regex3_u0414.jpg"></div> of suns&#8943;
</pre><br>

<p class="docText">It matches as shown, and while I suppose it depends on the exact needs of the situation, I would think that in this case that match is not desired. However, there's nothing about <img src=images/U2308.jpg border=0> <tt>.*?</tt><img src=images/U230B.jpg border=0> to stop it from marching right past the Zillion's &lt;<tt>B</tt>&gt; to its &lt;<tt>/B</tt>&gt;.</p>
<p class="docText">This is an excellent example of why a lazy quantifier is often not a good replacement for a negated class. In the <img src=images/U2308.jpg border=0><tt>".*"</tt><img src=images/U230B.jpg border=0> example, using <img src=images/U2308.jpg border=0><tt>[^"]</tt><img src=images/U230B.jpg border=0> as a replacement for the dot specifically disallows it from marching past a delimitera quality we wish our current regex had.</p>
<p class="docText">However, if <span class="docEmphasis">negative lookahead</span> (&#9758; 133) is supported, you can use it to create something comparable to a negated class. Alone, <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(?!</span>&lt;B&gt;<span class="docEmphStrong">)</span></tt><img src=images/U230B.jpg border=0> is a test that is successful if <tt>&lt;B&gt;</tt> is not at the current location in the string. Those are the locations that we want the dot of <img src=images/U2308.jpg border=0><tt>&lt;B&gt;.*?&lt;/B&gt;</tt><img src=images/U230B.jpg border=0> to match, so changing that dot to <img src=images/U2308.jpg border=0><tt>(<span class="docEmphStrong">(?!&lt;B&gt;)</span>.)</tt><img src=images/U230B.jpg border=0> creates a regex that matches where we want it, but doesn't match where we don't. Assembled all together, the whole thing can become quite confusing, so I'll show it here in a free-spacing mode (&#9758; 111) with comments:</p>
<pre>
    &lt;B&gt;         # <span class="docEmphasis">Match the opening &lt;B&gt;</span>
    (                 # <span class="docEmphasis">Now, only as many of the following as needed</span> ...
      (?! &lt;B&gt; ) #     <span class="docEmphasis">If not &lt;B&gt;</span> ...
      .               #                      <span class="docEmphasis">... any character is okay</span>
    )*?               #
    &lt;/B&gt;        # <span class="docEmphasis">... until the closing delimiter can match</span>
</pre><br>

<p class="docText">With one adjustment to the lookahead, we can put the quantifier back to a normal greedy one, which may be less confusing to some:</p>
<pre>
    &lt;B&gt;            # <span class="docEmphasis">Match the opening &lt;B&gt;</span>
    (                    # <span class="docEmphasis">Now, as many of the following as possible</span> ...
      (?! &lt; /?B&gt; ) #    <span class="docEmphasis">If not &lt;B&gt;, and not &lt;/B&gt;</span> ...
    .                    #          <span class="docEmphasis">... any character is okay</span>
    )*                   # <span class="docEmphasis">(now greedy)</span>
    &lt;/B&gt; <span class="docEmphasis"># &lt;ANNO&gt; ... until the closing delimiter can match</span>.
</pre><br>

<p class="docText">Now, the lookahead prohibits the main body to match beyond &lt;<tt>/B</tt>&gt; as well as &lt;<tt>B</tt>&gt;, which eliminates the problem we tried to solve with laziness, so the laziness can be removed. This expression can still be improved; we'll see it again during the discussion on efficiency in <a class="docLink" href="regex3-CHP-6.html#regex3-CHP-6">Chapter 6</a> (&#9758; 270).</p>

<a name="regex3-CHP-4-SECT-5.4"></a>
<h4 id="title-IDAVD5HE" class="docSection2Title">4.5.4. Greediness and Laziness Always Favor a Match</h4>
<a name="IDX-CHP-4-1525"></a> 
<a name="IDX-CHP-4-1526"></a> 
<a name="IDX-CHP-4-1527"></a> 
<a name="IDX-CHP-4-1528"></a> 
<a name="IDX-CHP-4-1529"></a> 
<a name="IDX-CHP-4-1530"></a> 
<a name="IDX-CHP-4-1531"></a> 
<a name="IDX-CHP-4-1532"></a> 
<a name="IDX-CHP-4-1533"></a> 
<a name="IDX-CHP-4-1534"></a> 

<p class="docText">Recall the price display example from <a class="docLink" href="regex3-CHP-2.html#regex3-CHP-2">Chapter 2</a> (&#9758; 51). We'll examine this example in detail at a number of points during this chapter, so I'll recap the basic issue: due to floating-point representation problems, values that should have been "1.625" or "3.00" were sometimes coming out like "1.62500000002828" and "3.00000000028822". To fix this, I used</p>
<pre>
    $price =~ s/(\.\d\d[1-9]?)\d*/$1/;
</pre><br>

<p class="docText">to lop off all but the first two or three decimal digits from the value stored in the variable <tt>$price</tt>. The <img src=images/U2308.jpg border=0><tt>\.\d\d</tt><img src=images/U230B.jpg border=0> matches the first two decimal digits regardless, while the <img src=images/U2308.jpg border=0><tt>[1-9]?</tt><img src=images/U230B.jpg border=0> matches the third digit only if it is non-zero.</p>
<p class="docText">I then noted:</P>
<blockquote><p class="docText">Anything matched so far is what we want to <span class="docEmphasis">keep</span>, so we wrap it in parentheses to capture to <tt>$1</tt>. We can then use <tt>$1</tt> in the replacement string. If this is the only thing that matches, we replace exactly what was matched with itselfnot very useful. However, we go on to match other items outside the <tt>$1</tt> parentheses. They don't find their way to the replacement string, so the effect is that they're removed. In this case, the "to be removed" text is any extra digits, the <img src=images/U2308.jpg border=0><tt>\d*</tt><img src=images/U230B.jpg border=0> at the end of the regex.</p></blockquote>
<p class="docText">So far so good, but let's consider what happens when the contents of the variable <tt>$price</tt> is already well formed. When it is <tt>27.625</tt>, the <img src=images/U2308.jpg border=0><tt>(\.\d\d[1-9]?)</tt><img src=images/U230B.jpg border=0> part matches the entire decimal part. Since the trailing <img src=images/U2308.jpg border=0><tt>\d*</tt><img src=images/U230B.jpg border=0> doesn't match anything, the substitution replaces the '<tt>.625</tt>' with '<tt>.625</tt>'an effective no-op.</P>
<p class="docText">This is the desired result, but wouldn't it be just a bit more efficient to do the replacement only when it would have some real effect (that is, do the replacement only when <img src=images/U2308.jpg border=0><tt>\d*</tt><img src=images/U230B.jpg border=0> actually matches something)? Well, we know how to write "at least one digit"! Simply replace <img src=images/U2308.jpg border=0><tt>\d<span class="docEmphStrong">*</span></tt><img src=images/U230B.jpg border=0> with <img src=images/U2308.jpg border=0><tt>\d<span class="docEmphStrong">+</span></tt><img src=images/U230B.jpg border=0>:</p>
<pre>
    $price =~ s/(\.\d\d[1-9]?)\d<div><img border="0" alt="" width="8" height="13" SRC="images/regex3_u0417.jpg"></div>/$1/
</pre><br>

<p class="docText">With crazy numbers like "1.62500000002828", it still works as before, but with something such as "9.43", the trailing <img src=images/U2308.jpg border=0><tt>\d+</tt><img src=images/U230B.jpg border=0> isn't able to match, so rightly, no substitution occurs. So, this is a great modification, yes? <span class="docEmphasis">No!</span> What happens with a three-digit decimal value like <tt>27.625</tt>? We want this value to be left alone, but that's not what happens. Stop for a moment to work through the match of <tt>27.625</tt> yourself, with particular attention to how the '<tt>5</tt>' interacts with the regex.</P>
<p class="docText">In hindsight, the problem is really fairly simple. Picking up in the action once <img src=images/U2308.jpg border=0><tt><img border="0" alt="" width="126" height="14" SRC="images/regex3_u0418.jpg">\d+</tt><img src=images/U230B.jpg border=0> has matched <tt>27</tt><img border="0" alt="" width="30" height="12" SRC="images/regex3_u0419.jpg">, we find that <img src=images/U2308.jpg border=0><tt>\d+</tt><img src=images/U230B.jpg border=0> can't match. That's no problem for the overall match, though, since as far as the regex is concerned, the match of '<tt>5</tt>' by <img src=images/U2308.jpg border=0><tt>[1-9]</tt><img src=images/U230B.jpg border=0> was <span class="docEmphasis">optional</span> and there is still a saved state to try. This state allows <img src=images/U2308.jpg border=0><tt>[1-9]?</tt><img src=images/U230B.jpg border=0> to match nothing, leaving the <tt>5</tt> to fulfill the must-match-one requirement of <img src=images/U2308.jpg border=0><tt>\d+</tt><img src=images/U230B.jpg border=0>. Thus, we get the match, but not the right match: <tt>.625</tt> is replaced by <tt>.62</tt>, and the value becomes incorrect.</P>
<p class="docText">What if <img src=images/U2308.jpg border=0><tt>[1-9]<span class="docEmphStrong">?</span></tt><img src=images/U230B.jpg border=0> were lazy instead? We'd get the same match, but without the intervening "match the <tt>5</tt> but then give it back" steps, since the lazy <img src=images/U2308.jpg border=0><tt>[1-9]<span class="docEmphStrong">??</span></tt><img src=images/U230B.jpg border=0> first skips the match attempt. So, laziness is not a solution to this problem.</P>

<a name="regex3-CHP-4-SECT-5.5"></a>
<H4 id="title-IDA4J5HE" class="docSection2Title">4.5.5. The Essence of Greediness, Laziness, and Backtracking</h4>
<a name="IDX-CHP-4-1535"></a> 
<a name="IDX-CHP-4-1536"></a> 
<a name="IDX-CHP-4-1537"></a> 
<a name="IDX-CHP-4-1538"></a> 

<p class="docText">The lesson of the preceding section is that it makes no difference whether there are greedy or lazy components to a regex; an overall match takes precedence over an overall non-match. This includes taking from what had been greedy (or giving to what had been lazy) if that's what is required to achieve a match, because when a "local failure" is hit, the engine keeps going back to the saved states (retracing steps to the piles of bread crumbs), trying the untested paths. Whether greedily or lazily, <span class="docEmphasis">every possible path is tested before the engine admits failure</span>.</P>
<p class="docText">The order that the paths are tested is different between greedy and lazy quantifiers (after all, that's the whole point of having the two!), but in the end, if no match is to be found, it's known only after testing every possible path.</p>
<p class="docText">If, on the other hand, there exists just <span class="docEmphasis">one</span> plausible match, both a regex with a greedy quantifier and one with a lazy quantifier find that match, although the series of paths they take to get there may be wildly different. In these cases, selecting greedy or lazy doesn't influence what is matched, but merely how long or short a path the engine takes to get there (which is an efficiency issue, the subject of <a class="docLink" href="regex3-CHP-6.html#regex3-CHP-6">Chapter 6</a>).</p>
<p class="docText">Finally, if there is more than one plausible match, understanding greediness, laziness, and backtracking allows you to know which is selected. The <img src=images/U2308.jpg border=0><tt>".*"</tt><img src=images/U230B.jpg border=0> example has three plausible matches:</P>
<pre>
    The name <div><img border="0" alt="" width="300" height="18" SRC="images/regex3_u0420.jpg"></div> in Japanese
</pre><BR>

<p class="docText">We know that <img src=images/U2308.jpg border=0><tt>".*"</tt><img src=images/U230B.jpg border=0>, with the greedy star, selects the longest one, and that <img src=images/U2308.jpg border=0><tt>".*?"</tt><img src=images/U230B.jpg border=0>, with the lazy star, selects the shortest.</p>

<a name="regex3-CHP-4-SECT-5.6"></a>
<h4 id="title-IDA5L5HE" class="docSection2Title">4.5.6. Possessive Quantifiers and Atomic Grouping</H4>
<a name="IDX-CHP-4-1539"></a> 
<a name="IDX-CHP-4-1540"></a> 
<a name="IDX-CHP-4-1541"></a> 
<a name="IDX-CHP-4-1542"></a> 
<a name="IDX-CHP-4-1543"></a> 
<a name="IDX-CHP-4-1544"></a> 
<a name="IDX-CHP-4-1545"></a> 
<a name="IDX-CHP-4-1546"></a> 
<a name="IDX-CHP-4-1547"></a> 

<p class="docText">The '<tt>.625</tt>' example on the facing page shows important insights about NFA matching as we know it, and how with that particular example our na&iuml;ve intents were thwarted. Some flavors do provide tools to help us here, but before looking at them, it's absolutely essential to fully understand the preceding section, "<a class="docLink" href="#regex3-CHP-4-SECT-5.5">The Essence of Greediness, Laziness, and Backtracking</a>." Be sure to review it if you have any doubts.</P>
<p class="docText">So, continuing with the '<tt>.625</tt>' example and recalling what we really want to happen, we know that if the matching can successfully get to the marked position in <img src=images/U2308.jpg border=0><tt>(\.\d\d[1-9]?)<sub><img src=images/U22CF.jpg border=0></sub>\d+"</tt><img src=images/U230B.jpg border=0>, we never want it to go back. That is, we want <img src=images/U2308.jpg border=0><tt>[1-9]</tt><img src=images/U230B.jpg border=0>" to match if possible, but if it does, we don't want that match to be given up. Saying it more forcefully, we would rather have the entire match attempt fail, if need be, before giving up something matched by the <img src=images/U2308.jpg border=0><tt>[1-9]</tt><img src=images/U230B.jpg border=0>. (As you'll recall, the problem before when this regex was applied to '<tt>.625</tt>' was that it indeed <span class="docEmphasis">didn't</span> fail, but instead went back to try the remaining skip-me alternative.)</P>
<p class="docText">Well, what if we could somehow eliminate that skip-me alternative (eliminate the state that <img src=images/U2308.jpg border=0><tt>?</tt><img src=images/U230B.jpg border=0> saves before it makes the attempt to match <img src=images/U2308.jpg border=0><tt>[1-9]</tt><img src=images/U230B.jpg border=0>? If there was no state to go back to, a match of <img src=images/U2308.jpg border=0><tt>[1-9]</tt><img src=images/U230B.jpg border=0> wouldn't be given up. That's what we want! Ah, but if there was no skip-me state to go back to, what would happen if we applied the regex to <tt>'.5000'?</tt> The <img src=images/U2308.jpg border=0><tt>[1-9]</tt><img src=images/U230B.jpg border=0> couldn't match, and in this case, we <span class="docEmphasis">do</span> want it to go back and skip the <img src=images/U2308.jpg border=0><tt>[1-9]</tt><img src=images/U230B.jpg border=0> so that the subsequent <img src=images/U2308.jpg border=0><tt>\d+</tt><img src=images/U230B.jpg border=0> can match digits to be removed.</p>
<p class="docText">It sounds like we have two conflicting desires, but thinking about it, what we really want is to eliminate the skip-me alternative only if the match-me alternative succeeds. That is, if <img src=images/U2308.jpg border=0><tt>[1-9]</tt><img src=images/U230B.jpg border=0> is indeed able to match, we'd like to get rid of the skip-me saved state so that it is never given up. This <span class="docEmphasis">is</span> possible, with regex flavors that support <img src=images/U2308.jpg border=0><tt>(?&gt;&#8943;)</tt><img src=images/U230B.jpg border=0> atomic grouping<a name="IDX-CHP-4-1548"></a> 
 (&#9758; 139), or possessive quantifiers like <img src=images/U2308.jpg border=0><tt>[1-9]<span class="docEmphStrong">?+</span></tt><img src=images/U230B.jpg border=0> (&#9758; 142). We'll look at atomic grouping first.</P>
<a name="regex3-CHP-4-SECT-5.6.1"></a>
<H5 id="title-IDAWP5HE" class="docSection3Title">4.5.6.1. Atomic grouping with <img src=images/U2308.jpg border=0><tt>(?&gt;&#8943;)</tt><img src=images/U230B.jpg border=0></h5>
<a name="IDX-CHP-4-1549"></a> 
<a name="IDX-CHP-4-1550"></a> 
<a name="IDX-CHP-4-1551"></a> 
<a name="IDX-CHP-4-1552"></a> 

<p class="docText">In essence,<a name="IDX-CHP-4-1553"></a> 
 matching within <img src=images/U2308.jpg border=0><tt>(?&gt;&#8943;)</tt><img src=images/U230B.jpg border=0> carries on normally, but if and when matching is able to exit the construct (that is, get past its closing parenthesis), all states that had been saved while within it are thrown away. In practice, this means that once the atomic grouping has been exited, whatever text was matched within it is now one unchangeable unit, to be kept or given back only as a whole. All saved states representing untried options within the parentheses are eliminated, so backtracking can never undo any of the decisions made within (at least not once they're "locked in" when the construct is exited).</p>
<p class="docText">So, let's consider <img src=images/U2308.jpg border=0><tt>(\.\d\d<span class="docEmphStrong">(?&gt;</span>[1-9]?<span class="docEmphStrong">)</span>)\d+</tt><img src=images/U230B.jpg border=0>. Quantifiers work normally within atomic grouping, so if <img src=images/U2308.jpg border=0><tt>[1-9]</tt><img src=images/U230B.jpg border=0> is not able to match, the regex returns to the skip-me saved state the <img src=images/U2308.jpg border=0><tt>?</tt><img src=images/U230B.jpg border=0> had left. That allows matching to leave the atomic grouping and continue on to the <img src=images/U2308.jpg border=0><tt>\d+</tt><img src=images/U230B.jpg border=0>. In this case, there are no saved states to flush when control leaves the atomic grouping (that is, there are no saved states remaining that had been created within it).</p>
<p class="docText">However, when <img src=images/U2308.jpg border=0><tt>[1-9]</tt><img src=images/U230B.jpg border=0> <span class="docEmphasis">is</span> able to match, matching can exit the atomic grouping, but this time, the skip-me state is still there. Since it had been created within the atomic grouping we're now exiting, it is thrown away. This would happen when matching against both '<tt>.625</tt>', and, say, '<tt>.625000</tt>'. In the latter case, having eliminated the state turns out not to matter, since the <img src=images/U2308.jpg border=0><tt>\d+</tt><img src=images/U230B.jpg border=0> has the '<tt>.625</tt><img border="0" alt="" width="22" height="12" SRC="images/regex3_u0421.jpg">' to match, after which that regex is done. With '<tt>.625</tt>' alone, the inability of <img src=images/U2308.jpg border=0><tt>\d+</tt><img src=images/U230B.jpg border=0> to match has the regex engine wanting to backtrack, but it can't since that skip-me alternative was thrown away. The lack of any state to backtrack to results in the overall match attempt failing, and '<tt>.625</tt>' is left undisturbed as we wish.</p>

<a name="regex3-CHP-4-SECT-5.6.2"></a>
<H5 id="title-IDAPS5HE" class="docSection3Title">4.5.6.2. The essence of atomic grouping</h5>
<a name="IDX-CHP-4-1554"></a> 
<a name="IDX-CHP-4-1555"></a> 

<p class="docText">The section "<a class="docLink" href="#regex3-CHP-4-SECT-5.5">The Essence of Greediness, Laziness, and Backtracking</a>," starting on page 168, makes the important point that neither greediness nor laziness influence <span class="docEmphasis">which</span> paths can be checked, but merely the <span class="docEmphasis">order</span> in which they are checked. If no match is found, whether by a greedy or a lazy ordering, in the end, every possible path will have been checked.</p>
<p class="docText">Atomic grouping, on the other hand, is fundamentally different because it actually <span class="docEmphasis">eliminates possible paths</span>. Eliminating states can have a number of different consequences, depending on the situation:</P>
<ul><li><p class="docList"><span class="docEmphStrong">No Effect</span> If a match is reached before one of the eliminated states would have been called upon, there is no effect on the match. We saw this a moment ago with the '<tt>.625000</tt>' example. A match was found before the eliminated state would have come into play.</p></li><li><p class="docList"><span class="docEmphStrong">Prohibit Match</span> The elimination of states can mean that a match that would have otherwise been possible now becomes impossible. We saw this with the'<tt>.625</tt>' example.</p></li><li><p class="docList"><span class="docEmphStrong">Different Match</span> In some cases, it's possible to get a <span class="docEmphasis">different</span> match due to the elimination of states.</p></li><li><p class="docList"><span class="docEmphStrong">Faster Failure</span> It's possible for the elimination of states to do nothing more than allow the regex engine, when no match is to be found, report that fact more quickly. This is discussed right after the quiz.</p></li></ul>
<p class="docText">Here's a little quiz: what does the construct <img src=images/U2308.jpg border=0><tt>(?&gt;<span class="docEmphStrong">.*?</span>)</tt><img src=images/U230B.jpg border=0> do? What kind of things do you expect it can match? <a class="docLink" href="#regex3-CHP-4-SIDEBAR-4">&#10070;</a> Turn the page to check your answer.</p>
<p class="docText"><span class="docEmphStrong">Some states may remain</span>. When the engine exits atomic grouping<a name="IDX-CHP-4-1556"></a> 
<a name="IDX-CHP-4-1557"></a> 
 during a match, only states that had been created <span class="docEmphasis">while inside the atomic grouping</span> are eliminated. States that might have been there before still remain after, so the entire text matched by the atomic subexpression may be unmatched, as a whole, if backtracking later reverts to one of those previous states.</p>
<p class="docText"><span class="docEmphStrong">Faster failures with atomic grouping</span>. Consider <img src=images/U2308.jpg border=0><tt>^\w+:</tt><img src=images/U230B.jpg border=0> applied to '<tt>Subject</tt>'. We can see, just by looking at it, that it will fail because the text doesn't have a colon in it, but the regex engine won't reach that conclusion until it actually goes through the motions of checking.</p>
<p class="docText">So, by the time <img src=images/U2308.jpg border=0><tt>:</tt><img src=images/U230B.jpg border=0> is first checked, the <img src=images/U2308.jpg border=0><tt>\w+</tt><img src=images/U230B.jpg border=0> will have marched to the end of the string. This results in a lot of statesone "skip me" state for each match of <img src=images/U2308.jpg border=0><tt>\w</tt><img src=images/U230B.jpg border=0> by the plus (except the first, since plus requires one match). When then checked at the end of the string, <img src=images/U2308.jpg border=0><tt>:</tt><img src=images/U230B.jpg border=0> fails, so the regex engine backtracks to the most recently saved state:</P>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><TR><td class="docTableCell" align="center"><p class="docText">at '<tt>subjec</tt><sub><img src=images/U22CF.jpg border=0></sub><tt>t</tt>'</p></TD><TD class="docTableCell" align="center"><p class="docText">matching <img src=images/U2308.jpg border=0><tt>^\w+<sub><img src=images/U22CF.jpg border=0></sub>:</tt><img src=images/U230B.jpg border=0></P></TD></tr></table></P><br>
<p class="docText">at which point the <img src=images/U2308.jpg border=0><tt>:</tt><img src=images/U230B.jpg border=0> fails again, this time trying to match '<tt>t</tt>'. This backtrack-test-fail cycle happens all the way back to the oldest state:</p>
<P><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><TR><td class="docTableCell" align="center"><p class="docText">at '<tt>S</tt><sub><img src=images/U22CF.jpg border=0></sub><tt>ubject</tt>'</p></TD><TD class="docTableCell" align="center"><p class="docText">matching <img src=images/U2308.jpg border=0><tt>^\w+<sub><img src=images/U22CF.jpg border=0></sub>:</tt><img src=images/U230B.jpg border=0></P></td></TR></table></P><br>
<p class="docText">After the attempt from the final state fails, overall failure can finally be announced.</p>
<a name="regex3-CHP-4-SIDEBAR-4"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Quiz Answer</h2>
<p class="docText">&#10070; <span class="docEmphasis">Answer to the question on page 171</span>.</P>
<p class="docText"><span class="docEmphStrong">What does</span> <img src=images/U2308.jpg border=0><tt>(?&gt;<span class="docEmphStrong">.*?</span>)</tt><img src=images/U230B.jpg border=0> <span class="docEmphStrong">match?</span></p>
<p class="docText">It can never match, anything. At best, it's a fairly complex way to accomplish nothing! <img src=images/U2308.jpg border=0><tt>*?</tt><img src=images/U230B.jpg border=0> is the lazy <img src=images/U2308.jpg border=0><tt>*</tt><img src=images/U230B.jpg border=0>, and governs a dot, so the first path it attempts is the skip-the-dot path, saving the try-the-dot state for later, if required. But the moment that state has been saved, it's thrown away because matching exits the atomic grouping, so the skip-the-dot path is the only one ever taken. If something is always skipped, it's as if it's not there at all.</p>
</td></tr></table></p><br>
<p class="docText">All that backtracking is a lot of work that after just a glance we know to be unnecessary. If the colon can't match after the last letter, it certainly can't match one of the letters the <img src=images/U2308.jpg border=0><tt>+</tt><img src=images/U230B.jpg border=0> is forced to give up!</p>
<p class="docText">So, knowing that none of the states left by <img src=images/U2308.jpg border=0><tt>\w+</tt><img src=images/U230B.jpg border=0>, once it's finished, could possibly lead to a match, we can save the regex engine the trouble of checking them: <img src=images/U2308.jpg border=0><tt>^<span class="docEmphStrong">(?&gt;</span>\w+<span class="docEmphStrong">)</span>:</tt><img src=images/U230B.jpg border=0> By adding the atomic grouping, we use our global knowledge of the regex to enhance the local working of <img src=images/U2308.jpg border=0><tt>\w+</tt><img src=images/U230B.jpg border=0> by having its saved states (which we know to be useless) thrown away. If there <span class="docEmphasis">is</span> a match, the atomic grouping won't have mattered, but if there's not to be a match, having thrown away the useless states lets the regex come to that conclusion more quickly. (An advanced implementation may be able to apply this optimization for you automatically &#9758; 251.)</p>
<p class="docText">As we'll see in the <a class="docLink" href="regex3-CHP-6.html#regex3-CHP-6">Chapter 6</a> (&#9758; 269), this technique shows a very valuable use of atomic grouping, and I suspect it will become the most common use as well.</p>


<a name="regex3-CHP-4-SECT-5.7"></a>
<h4 id="title-IDAO15HE" class="docSection2Title">4.5.7. Possessive Quantifiers, <tt>?+, *+, ++,</tt> and <tt>{m,n}+</tt></h4>
<p class="docText">Possessive quantifiers are much like greedy quantifiers, but they never give up a partial amount of what they've been able to match. Once a plus, for example, finishes its run, it has created quite a few saved states, as we saw with the <img src=images/U2308.jpg border=0><tt>^\w+</tt><img src=images/U230B.jpg border=0> example. A <span class="docEmphasis">possessive</span> plus simply throws those states away (or, more likely, doesn't bother creating them in the first place).</p>
<p class="docText">As you might guess, possessive quantifiers<a name="IDX-CHP-4-1558"></a> 
<a name="IDX-CHP-4-1559"></a> 
 are closely related to atomic grouping. Something possessive like <img src=images/U2308.jpg border=0><tt>\w++</tt><img src=images/U230B.jpg border=0> appears to match in the same way as <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(?&gt;</span>\w+<span class="docEmphStrong">)</span></tt><img src=images/U230B.jpg border=0>; one is just a notational convenience for the other.<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-4-FN-8">[<img src=images/U2020.jpg border=0>]</a></sup> With possessive quantifiers, <img src=images/U2308.jpg border=0><tt>^<span class="docEmphStrong">(?&gt;</span>\w+<span class="docEmphStrong">)</span>:</tt><img src=images/U230B.jpg border=0> can be rewritten as <img src=images/U2308.jpg border=0><tt>^\w++:</tt><img src=images/U230B.jpg border=0>, and <img src=images/U2308.jpg border=0><tt>(\.\d\d<span class="docEmphStrong">(?&gt;</span>[1-9]?<span class="docEmphStrong">)</span>)\d+</tt><img src=images/U230B.jpg border=0> can be rewritten as <img src=images/U2308.jpg border=0><tt>(\.\d\d[1-9]?<span class="docEmphStrong">+</span>)\d+</tt><img src=images/U230B.jpg border=0>.</p><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-4-FN-8">[<img src=images/U2020.jpg border=0>]</a></sup> A smart implementation may be able to make the possessive version a bit more efficient than its atomic-grouping counterpart (&#9758; 250).</p></blockquote>
<p class="docText">Be sure to understand the difference between <img src=images/U2308.jpg border=0><tt>(?&gt;M)+</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>(?&gt;M+)</tt><img src=images/U230B.jpg border=0>. The first one throws away unused states created by <img src=images/U2308.jpg border=0><tt>M</tt><img src=images/U230B.jpg border=0>, which is not very useful since <img src=images/U2308.jpg border=0><tt>M</tt><img src=images/U230B.jpg border=0> doesn't create any states. The second one throws away unused states created by <img src=images/U2308.jpg border=0><tt>M+</tt><img src=images/U230B.jpg border=0>, which certainly can be useful.</p>
<p class="docText">When phrased as a comparison between <img src=images/U2308.jpg border=0><tt>(?&gt;M)+</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>(?&gt;M+)</tt><img src=images/U230B.jpg border=0>, it's perhaps clear that the second one is the one comparable to <img src=images/U2308.jpg border=0><tt>M++</tt><img src=images/U230B.jpg border=0>, but when converting something more complex like <img src=images/U2308.jpg border=0><tt>(\\"|[^"])*+</tt><img src=images/U230B.jpg border=0> from possessive quantifiers to atomic grouping, it's tempting to just add <tt>'?&gt;'</tt> to the parentheses that are already there: <img src=images/U2308.jpg border=0><tt>(<span class="docEmphStrong">?&gt;</span>\\"|[^"])*</tt><img src=images/U230B.jpg border=0>. The new expression might happen to achieve your goal, but be clear that is <span class="docEmphasis">not</span> comparable to the original possessive-quantifier version; it's like changing <img src=images/U2308.jpg border=0><tt>M++</tt><img src=images/U230B.jpg border=0> to <img src=images/U2308.jpg border=0><tt>(<span class="docEmphStrong">?&gt;</span>M)+</tt><img src=images/U230B.jpg border=0>. Rather, to be comparable, remove the possessive plus, and then wrap what remains in atomic grouping: <img src=images/U2308.jpg border=0><tt>(<span class="docEmphStrong">?&gt;</span>(\\"|[^"])*<span class="docEmphStrong">)</span></tt><img src=images/U230B.jpg border=0></p>

<a name="regex3-CHP-4-SECT-5.8"></a>
<h4 id="title-IDAR55HE" class="docSection2Title">4.5.8. The Backtracking of Lookaround</H4>
<p class="docText">It might not be apparent at first, but lookaround (introduced in <a class="docLink" href="regex3-CHP-2.html#regex3-CHP-2">Chapter 2</a> &#9758; 59) is closely related to atomic grouping and possessive quantifiers. There are four types of lookaround:<a name="IDX-CHP-4-1560"></a> 
 positive and negative flavors of lookahead and lookbehind. They simply test whether their subexpression can and can't match starting at the current location (lookahead), or ending at the current location (lookbehind).</p>
<p class="docText">Looking a bit deeper, how does lookaround work in our NFA world of saved states and backtracking?<a name="IDX-CHP-4-1561"></a> 
 As a subexpression within one of the lookaround constructs is being tested, it's as if it's in its own little world. It saves states as needed, and backtracks as necessary. If the entire subexpression is able to match successfully, what happens? With <span class="docEmphasis">positive</span> lookaround, the construct, as a whole, is considered a success, and with <span class="docEmphasis">negative</span> lookaround, it's considered a failure. In either case, since the only concern is whether there's a match (and we just found out that, yes, there's a match), the "little world" of the match attempt, including any saved state that might have been left over from that attempt, is thrown away.</P>
<p class="docText">What about when the subexpression within the lookaround can't match? Since it's being applied in its "own little world," only states created within the current lookaround construct are available. That is, if the regex finds that it needs to backtrack further, beyond where the lookaround construct started, it's found that the current subexpression can not match. For positive lookahead, this means failure, while for negative lookahead, it means success. In either case, there are no saved states left over (had there been, the subexpression match would not have finished), so there's no "little world" left to throw away.</p>
<p class="docText">So, we've seen that in all cases, once the lookaround construct has finished, there are no saved states left over from its application. Any states that might have been left over, such as in the case of successful positive lookahead, are thrown away.</p>
<p class="docText">Well, where else have we seen states being thrown away? With atomic grouping<a name="IDX-CHP-4-1562"></a> 
 and possessive quantifiers, of course.</P>
<a name="regex3-CHP-4-SECT-5.8.1"></a>
<H5 id="title-IDAABAIE" class="docSection3Title">4.5.8.1. Mimicking atomic grouping with positive lookahead</H5>
<a name="IDX-CHP-4-1563"></a> 

<p class="docText">It's perhaps mostly academic for flavors that support atomic grouping, but can be quite useful for those that don't: <span class="docEmphasis">if</span> you have positive lookahead, and <span class="docEmphasis">if</span> it supports capturing parentheses within the lookahead (most flavors do, but Tcl's lookahead, for example, does not), you can mimic atomic grouping<a name="IDX-CHP-4-1564"></a> 
 and possessive quantifiers. <img src=images/U2308.jpg border=0><tt>(?&gt;<span class="docEmphasis">regex</span>)</tt><img src=images/U230B.jpg border=0> can be mimicked with <img src=images/U2308.jpg border=0><tt>(?=<span class="docEmphStrong">(</span><span class="docEmphasis">regex</span><span class="docEmphStrong">)</span>)<span class="docEmphStrong">\1</span>"</tt><img src=images/U230B.jpg border=0>. For example, compare <img src=images/U2308.jpg border=0><tt>^(?&gt;\w+):</tt><img src=images/U230B.jpg border=0> with <img src=images/U2308.jpg border=0><tt>^(?=(\w+))\1:</tt><img src=images/U230B.jpg border=0>.</P>
<p class="docText">The lookahead version has <img src=images/U2308.jpg border=0><tt>\w+</tt><img src=images/U230B.jpg border=0> greedily match as much as it can, capturing an entire word. Because it's within lookahead, the intermediate states are thrown away when it's finished (just as if, incidentally, it had been within atomic grouping). Unlike atomic grouping, the matched word is not included as part of the match (that's the whole point of lookahead), but the word does remain captured. That's a key point because it means that when <img src=images/U2308.jpg border=0><tt>\1</tt><img src=images/U230B.jpg border=0> is applied, it's actually being applied to the very text that filled it, and it's certain to succeed. This extra step of applying <img src=images/U2308.jpg border=0><tt>\1</tt><img src=images/U230B.jpg border=0> is simply to move the regex past the matched word.</p>
<p class="docText">This technique is a bit less efficient than real atomic grouping because of the extra time required to rematch the text via <img src=images/U2308.jpg border=0><tt>\1</tt><img src=images/U230B.jpg border=0>. But, since states are thrown away, it fails more quickly than a raw <img src=images/U2308.jpg border=0><tt>\w+:</tt><img src=images/U230B.jpg border=0>" when the <img src=images/U2308.jpg border=0><tt>:</tt><img src=images/U230B.jpg border=0> can't match.</P>


<a name="regex3-CHP-4-SECT-5.9"></a>
<h4 id="title-IDADDAIE" class="docSection2Title">4.5.9. Is Alternation Greedy?</h4>
<p class="docText">How alternation<a name="IDX-CHP-4-1565"></a> 
 works is an important point because it can work in fundamentally different ways with different regex engines. When alternation is reached, any number of the alternatives might be able to match at that point, but which will? Put another way, if more than one can match, which will? If it's always the one that matches the most text, one might say that alternation is greedy.<a name="IDX-CHP-4-1566"></a> 
 If it's always the shortest amount of text, one might say it's lazy? Which (if either) is it?</P>
<p class="docText">Let's look at the Traditional NFA engine used in Perl, PHP, Java, .NET languages, and many others (&#9758; 145). When faced with alternation, each alternative is checked in the left-to-right order given in the expression. With the example regex of <img src=images/U2308.jpg border=0><tt>^(Subject|Date):&#8226;</tt><img src=images/U230B.jpg border=0>, when the <img src=images/U2308.jpg border=0><tt>Subject|Date</tt><img src=images/U230B.jpg border=0> alternation is reached, the first alternative, <img src=images/U2308.jpg border=0><tt>Subject</tt><img src=images/U230B.jpg border=0>, is attempted. If it matches, the rest of the regex (the subsequent <img src=images/U2308.jpg border=0><tt>: &#8226;</tt><img src=images/U230B.jpg border=0>) is given a chance. If it turns out that it can't match, and if other alternatives remain (in this case, <img src=images/U2308.jpg border=0><tt>Date</tt><img src=images/U230B.jpg border=0>), the regex engine backtracks to try them. <span class="docEmphasis">This is just another case of the regex engine backtracking to a point where untried options are still available</span>. This continues until an overall match is achieved, or until all options (in this case, all alternatives) are exhausted.</P>
<p class="docText">So, with that common Traditional NFA engine, what text is actually matched by <img src=images/U2308.jpg border=0><tt>tour|to|tournament</tt><img src=images/U230B.jpg border=0> when applied to the string '<tt>three&#8226;tournaments&#8226;won</tt>' ? All the alternatives are attempted (and fail) during attempts starting at each character position until the transmission starts the attempt at '<tt>three</tt>&#8226;<sub><img src=images/U22CF.jpg border=0></sub><tt>tournaments</tt>&#8226;<tt>won</tt>'. This time, the first alternative, <img src=images/U2308.jpg border=0><tt>tour</tt><img src=images/U230B.jpg border=0>, matches. Since the alternation is the last thing in the regex, the moment the <img src=images/U2308.jpg border=0><tt>tour</tt><img src=images/U230B.jpg border=0> matches, the whole regex is done. The other alternatives are not even tried again.</P>
<p class="docText">So, we see that alternation is neither greedy nor lazy, but <span class="docEmphasis">ordered</span>, at least for a Traditional NFA. This is more powerful than greedy alternation because it allows more control over just how a match is attemptedit allows the regex author to express "try this, then that, and finally try that, until you get a match."</P>
<p class="docText">Not all flavors have ordered alternation.<a name="IDX-CHP-4-1567"></a> 
 DFAs and POSIX NFAs do have greedy alternation, always matching with the alternative that matches the most text (<img src=images/U2308.jpg border=0><tt>tournament</tt><img src=images/U230B.jpg border=0> in this case). But, if you're using Perl, PHP, a .NET language, <tt>java.util.regex</tt>, or any other system with a Traditional NFA engine (list &#9758; 145), your alternation is <span class="docEmphasis">ordered</span>.</P>

<a name="regex3-CHP-4-SECT-5.10"></a>
<h4 id="title-IDAKFAIE" class="docSection2Title">4.5.10. Taking Advantage of Ordered Alternation</H4>
<a name="IDX-CHP-4-1568"></a> 
<a name="IDX-CHP-4-1569"></a> 
<a name="IDX-CHP-4-1570"></a> 
<a name="IDX-CHP-4-1571"></a> 
<a name="IDX-CHP-4-1572"></a> 
<a name="IDX-CHP-4-1573"></a> 

<p class="docText">Let's revisit the <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(</span>\.\d\d[1-9]?<span class="docEmphStrong">)</span>\d*</tt><img src=images/U230B.jpg border=0> example from page 167. If we realize that <img src=images/U2308.jpg border=0><tt>\.\d\d[1-9]?</tt><img src=images/U230B.jpg border=0>, in effect, says "allow either <img src=images/U2308.jpg border=0><tt>\.\d\d</tt><img src=images/U230B.jpg border=0> or <img src=images/U2308.jpg border=0><tt>\.\d\d[1-9]</tt><img src=images/U230B.jpg border=0>", we can rewrite the entire expression as <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(</span>\.\d\d<span class="docEmphStrong">|</span>\.\d\d[1-9]<span class="docEmphStrong">)</span>\d*</tt><img src=images/U230B.jpg border=0>. (There is no compelling reason to make this changeit's merely a handy example.) Is this <span class="docEmphasis">really</span> the same as the original? If alternation is truly greedy, then it is, but the two are quite different with ordered alternation.</P>
<p class="docText">Let's consider it as ordered for the moment. The first alternative is selected and tested, and if it matches, control passes to the <img src=images/U2308.jpg border=0><tt>\d*</tt><img src=images/U230B.jpg border=0> that follows the alternation. If there are digits remaining, the <img src=images/U2308.jpg border=0><tt>\d*</tt><img src=images/U230B.jpg border=0> matches them, including any initial non-zero digit that was the root of the original example's problem (if you'll recall the original problem, that's a digit we want to match only within the parentheses, not by the <img src=images/U2308.jpg border=0><tt>\d*</tt><img src=images/U230B.jpg border=0> after the parentheses). Also, realize that if the first alternative can't match, the second alternative will certainly not be able to, as it begins with a copy of the entire first alternative. If the first alternative doesn't match, though, the regex engine nevertheless expends the effort for the futile attempt of the second.</p>
<p class="docText">Interestingly, if we swap the alternatives and use <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(</span>\.\d\d[1-9]<span class="docEmphStrong">|</span>\.\d\d<span class="docEmphStrong">)</span>\d*</tt><img src=images/U230B.jpg border=0>, we do effectively get a replica of the original greedy <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(</span>\.\d\d[1-9]?<span class="docEmphStrong">)</span>\d*</tt><img src=images/U230B.jpg border=0>. The alternation has meaning in this case because if the first alternative fails due to the trailing <img src=images/U2308.jpg border=0><tt>[1-9]</tt><img src=images/U230B.jpg border=0>, the second alternative still stands a chance. It's still ordered alternation, but now we've selected the order to result in a greedy-type match.</p>
<p class="docText">When first distributing the <img src=images/U2308.jpg border=0><tt>[1-9]?</tt><img src=images/U230B.jpg border=0> to two alternatives, in placing the shorter one first, we fashioned a non-greedy <img src=images/U2308.jpg border=0><tt>?</tt><img src=images/U230B.jpg border=0> of sorts. It ends up being meaningless in this particular example because there is nothing that could ever allow the second alternative to match if the first fails. I see this kind of faux-alternation often, and it is invariably a mistake when used with a Traditional NFA. In one book I've read, <img src=images/U2308.jpg border=0><tt>a*<span class="docEmphStrong">(</span>(ab)*<span class="docEmphStrong">|</span>b*<span class="docEmphStrong">)</span></tt><img src=images/U230B.jpg border=0> is used as an example in explaining something about Traditional NFA regex parentheses. It's a pointless example because the first alternative, <img src=images/U2308.jpg border=0><tt>(ab)*</tt><img src=images/U230B.jpg border=0>, can never fail, so any other alternatives are utterly meaningless. You could add</p>
<pre>
    <img src=images/U2308.jpg border=0>a*((ab)*|b*<div><img border="0" alt="" width="300" height="14" SRC="images/regex3_u0422.jpg"></div>)<img src=images/U230B.jpg border=0>
</pre><br>

<p class="docText">and it wouldn't change the meaning a bit. The moral is that with ordered alternation, when more than one alternative can potentially match the same text, care must be taken when selecting the order of the alternatives.</P>
<a name="regex3-CHP-4-SECT-5.10.1"></a>
<h5 id="title-IDA1JAIE" class="docSection3Title">4.5.10.1. Ordered alternation pitfalls</h5>
<a name="IDX-CHP-4-1574"></a> 

<a name="IDX-CHP-4-1575"></a> 
<a name="IDX-CHP-4-1576"></a> 

<p class="docText">Ordered alternation can be put to your advantage by allowing you to craft just the match you want, but it can also lead to unexpected pitfalls for the unaware. Consider matching a January date of the form '<tt>Jan 31</tt>'. We need something more sophisticated than, say, <img src=images/U2308.jpg border=0><tt>Jan&#8226;[0123][0-9]</tt><img src=images/U230B.jpg border=0>, as that allows "dates" such as 'Jan&#8226;00', '<tt>Jan&#8226;39</tt>', and disallows, '<tt>Jan&#8226;7</tt>'.</P>
<p class="docText">One way to match the date part is to attack it in sections. To match from the first through the ninth, using <img src=images/U2308.jpg border=0><tt>0?[1-9]</tt><img src=images/U230B.jpg border=0> allows a leading zero. Adding <img src=images/U2308.jpg border=0><tt>[12][0-9]</tt><img src=images/U230B.jpg border=0> allows for the tenth through the 29<sup>th</sup>, and <img src=images/U2308.jpg border=0><tt>3[01]</tt><img src=images/U230B.jpg border=0> rounds it out. Putting it all together, we get <img src=images/U2308.jpg border=0><tt>Jan&#8226;<span class="docEmphStrong">(</span>0?[1-9]<span class="docEmphStrong">|</span>[12][0-9]<span class="docEmphStrong">|</span>3[01]<span class="docEmphStrong">)</span></tt><img src=images/U230B.jpg border=0>.</p>
<p class="docText">Where do you think this matches in '<tt>Jan 31 is Dad's birthday</tt>'? We want it to match '<tt>Jan 31</tt>', of course, but ordered alternation actually matches only '<tt>Jan 3</tt>'. Surprised? During the match of the first alternative, <img src=images/U2308.jpg border=0><tt>0?[1-9]</tt><img src=images/U230B.jpg border=0>, the leading <img src=images/U2308.jpg border=0><tt>0?</tt><img src=images/U230B.jpg border=0> fails, but the alternative matches because the subsequent <img src=images/U2308.jpg border=0><tt>[1-9]</tt><img src=images/U230B.jpg border=0> has no trouble matching the <tt>3</tt>. Since that's the end of the expression, the match is complete.</p>
<p class="docText">When the order of the alternatives is adjusted so that the alternative that can potentially match a shorter amount of text is placed last, the problem goes away. This works: <img src=images/U2308.jpg border=0><tt>Jan&#8226;<span class="docEmphStrong">(</span>[12][0-9]<span class="docEmphStrong">|</span>3[01]<span class="docEmphStrong">|</span>0?[1-9]<span class="docEmphStrong">)</span></tt><img src=images/U230B.jpg border=0>.</p>
<p class="docText">Another approach is <img src=images/U2308.jpg border=0><tt>Jan&#8226;<span class="docEmphStrong">(</span>31<span class="docEmphStrong">|</span>[123]0<span class="docEmphStrong">|</span>[012]?[1-9]<span class="docEmphStrong">)</span></tt><img src=images/U230B.jpg border=0>. Like the first solution, this requires careful arrangement of the alternatives to avoid the problem. Yet, a third approach is <img src=images/U2308.jpg border=0><tt>Jan&#8226;<span class="docEmphStrong">(</span>0[1-9]<span class="docEmphStrong">|</span>[12][0-9]?<span class="docEmphStrong">|</span>3[01]?<span class="docEmphStrong">|</span>[4-9]<span class="docEmphStrong">)</span></tt><img src=images/U230B.jpg border=0>, which works properly regardless of the ordering. Comparing and contrasting these three expressions can prove quite interesting (an exercise I'll leave for your free time, although the sidebar on the facing page should be helpful).</p>
<a name="regex3-CHP-4-SIDEBAR-5"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">A Few Ways to Slice and Dice a Date</h2>
<p class="docText">A few approaches to the date-matching problem posed on page 176. The calendar associated with each regex shows what can be matched by each alternative color-coded within the regex.</p><img border="0" alt="" width="496" height="297" SRC="images/regex3_u0423.jpg">
</td></tr></table></p><br>



<a href="7041536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-4-SECT-4.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-4-SECT-6.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>