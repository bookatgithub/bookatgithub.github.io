<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 5.2.&nbsp; A Few Short Examples</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-5-SECT-1.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-5-SECT-3.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="regex3-CHP-5-SECT-2"></a>
<H3 id="title-IDAW0MLF" class="docSection1Title">5.2. A Few Short Examples</H3>
<a name="regex3-CHP-5-SECT-2.1"></a>
<H4 id="title-IDA20MLF" class="docSection2Title">5.2.1. Continuing with Continuation Lines</H4>
<p class="docText">With the continuation-line example from the previous chapter (&#9758;178), we found that <img src=images/U2308.jpg border=0><tt>^\w+= .*<span class="docEmphStrong">(\\\n.*)*</span></tt><img src=images/U230B.jpg border=0> applied with a Traditional NFA doesn't properly match both lines of:</p>
<pre>
    SRC=array.c builtin.c eval.c field.c gawkmisc.c io.c main.c \
            missing.c msg.c node.c re.c version.c
</pre><BR>

<p class="docText">The problem is that the first <img src=images/U2308.jpg border=0><tt>.*</tt><img src=images/U230B.jpg border=0> matches past the backslash, pulling it out from under the <img src=images/U2308.jpg border=0><tt>(<img border="0" alt="" id="195131084202" width="15" height="13" SRC="images/regex3_u0501.jpg">\n.*)*</tt><img src=images/U230B.jpg border=0> that we want it to be matched by. Well, here's the first lesson of the chapter: if we don't want to match past the backslash, we should say that in the regex. We can do this by changing each dot to <img src=images/U2308.jpg border=0><tt>[^\n\\]</tt><img src=images/U230B.jpg border=0>. (Notice how I've made sure to include <tt>\n</tt> in the negated class? You'll remember that one of the assumptions of the original regex was that dot didn't match a newline, and we don't want its replacement to match a newline either &#9758;119.)</p>
<p class="docText">Making that change, we get:</p>
<pre>
    <img src=images/U2308.jpg border=0>^\w+ =<div><img border="0" alt="" id="195131084202" width="60" height="14" SRC="images/regex3_u0502.jpg"></div>* (\\\n<div><img border="0" alt="" id="195131084202" width="60" height="14" SRC="images/regex3_u0502.jpg"></div>*)*<img src=images/U230B.jpg border=0>
</pre><BR>

<p class="docText">This now works, properly matching continuation lines, but in solving one problem, we have perhaps introduced another: we've now disallowed backslashes other than those at the end of lines. This is a problem if the data to which it will be applied could possibly have other backslashes. We'll assume it could, so we need to accommodate the regex to handle them.</P>
<p class="docText">So far, our approaches have been along the lines of "match the line, then try to match a continuation line if there." Let's change that approach to one that I find often works in general: concentrate on what is really allowed to match at any particular point. As we match the line, we want either normal (non-backslash, non-newline) characters, or a backslash-anything combination. If we use <img src=images/U2308.jpg border=0><tt>\\.</tt><img src=images/U230B.jpg border=0> for the backslash-anything combination, and apply it in a dot-matches-all mode, it also can match the backslash-newline combination.</p>
<p class="docText">So, the expression becomes <img src=images/U2308.jpg border=0><tt>^\w+=<span class="docEmphStrong">(</span>[^\n\\]|\\.<span class="docEmphStrong">)*</span></tt><img src=images/U230B.jpg border=0> in a dot-matches-all mode. Due to the leading <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0>, an enhanced line anchor match mode (&#9758;112) may be useful as well, depending on how this expression is used.</p>
<p class="docText">But, we're not quite done with this example yetwe'll pick it up again in the next chapter where we work on its efficiency (&#9758;270).</P>

<a name="regex3-CHP-5-SECT-2.2"></a>
<H4 id="title-IDAG3MLF" class="docSection2Title">5.2.2. Matching an IP Address</H4>
<a name="IDX-CHP-5-1649"></a> 

<a name="IDX-CHP-5-1650"></a> 

<p class="docText">As another example that we'll take much further, let's match an IP (Internet Protocol) address: four numbers separated by periods, such as <tt>1.2.3.4.</tt> Often, the numbers are padded to three digits, as in <tt>001.002.003.004</tt>. If you want to check a string for one of these, you could use <img src=images/U2308.jpg border=0><tt>[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*</tt><img src=images/U230B.jpg border=0>, but that's so vague that it even matches '<tt>and then <img border="0" alt="" id="195131084202" width="34" height="6" SRC="images/regex3_u0503.jpg">..?</tt>'. Look at the regex: it doesn't even <span class="docEmphasis">require</span> any numbersits only requirements are three periods (with nothing but digits, <span class="docEmphasis">if anything</span>, between).</p>
<p class="docText">To fix this regex, we first change the star to a plus, since we know that each number must have at least one digit. To ensure that the entire string is only the IP address, we wrap the regex with <img src=images/U2308.jpg border=0><tt>^&#8943;$</tt><img src=images/U230B.jpg border=0>. This gives us:</P>
<pre>
    <img src=images/U2308.jpg border=0>^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$<img src=images/U230B.jpg border=0>
</pre><BR>

<p class="docText">Using <img src=images/U2308.jpg border=0><tt>\d</tt><img src=images/U230B.jpg border=0> instead of <img src=images/U2308.jpg border=0><tt>[0-9]</tt><img src=images/U230B.jpg border=0>, it becomes <img src=images/U2308.jpg border=0><tt>^\d+\.\d+\.\d+\.\d+$</tt><img src=images/U230B.jpg border=0>, which you may find to be more easily readable, <sup class="docFootnote"><a class="docLink" href="#regex3-CHP-5-FN1">[<img src=images/U2020.jpg border=0>]</a></sup>but it still matches things that aren't IP addresses, like '<tt>1234.5678.9101112.131415</tt>'. (IP addresses have each number in the range of 0255.) As a start, you can enforce that each number be three digits long, with <img src=images/U2308.jpg border=0><tt>^\d\d\d\.\d\d\d\.\d\d\d\.\d\d\d$</tt><img src=images/U230B.jpg border=0>. but now we are <span class="docEmphasis">too</span> specific. We still need to allow one- and two-digit numbers (as in <tt>1.234.5.67</tt>). If the flavor supports <tt>{<span class="docEmphasis">min,max</span>}</tt>, you can use <img src=images/U2308.jpg border=0><tt>^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$</tt><img src=images/U230B.jpg border=0>. If not, you can always use <img src=images/U2308.jpg border=0><tt>\d\d?\d?</tt><img src=images/U230B.jpg border=0> or <img src=images/U2308.jpg border=0><tt>\d(\d\d?)?</tt><img src=images/U230B.jpg border=0> for each part. These allow one to three digits, each in a slightly different way.</p><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-5-FN1">[<img src=images/U2020.jpg border=0>]</a></sup> Or maybe not  it depends on what you are used to. In a complex regex, I find <img src=images/U2308.jpg border=0><tt>\d</tt><img src=images/U230B.jpg border=0> more readable than <img src=images/U2308.jpg border=0><tt>[0-9]</tt><img src=images/U230B.jpg border=0>, but note that on some systems, the two might not be exactly the same. Systems that support Unicode, for example, may have their <img src=images/U2308.jpg border=0><tt>\d</tt><img src=images/U230B.jpg border=0> match non-ASCII digits as well (&#9758;120).</p></blockquote>
<p class="docText">Depending on your needs, you might be happy with some of the various degrees of vagueness in the expressions so far. If you really want to be strict, you have to worry that <img src=images/U2308.jpg border=0><tt>\d{1,3}</tt><img src=images/U230B.jpg border=0> can match <tt>999</tt>, which is above 255, and thus an invalid component of an IP address.</p>
<p class="docText">Several approaches would ensure that only numbers from 0 to 255 appear. One silly approach is <img src=images/U2308.jpg border=0><tt>0|1|2|3|&#8943;253|254|255</tt><img src=images/U230B.jpg border=0>. Actually, this doesn't allow the zeropadding that is allowed, so you really need <img src=images/U2308.jpg border=0><tt>0|00|000|1|01|001|&#8943;</tt><img src=images/U230B.jpg border=0>, whose length becomes even more ridiculous. For a DFA engine, it is ridiculous only in that it's so long and verbose  it still matches just as fast as any regex describing the same text. For an NFA, however, all the alternation kills efficiency.</p>
<p class="docText">A realistic approach concentrates on which digits are allowed in a number, and where. If a number is only one or two digits long, there is no worry as to whether the value is within range, so <img src=images/U2308.jpg border=0><tt>\d|\d\d</tt><img src=images/U230B.jpg border=0> takes care of it. There's also no worry about the value for a three-digit number beginning with a <tt>0</tt> or <tt>1</tt>, since such a number is in the range 000199 and is perfectly valid. This lets us add <img src=images/U2308.jpg border=0><tt>[01]\d\d</tt><img src=images/U230B.jpg border=0>, leaving us with <img src=images/U2308.jpg border=0><tt>\d|\d\d|[01]\d\d</tt><img src=images/U230B.jpg border=0>. You might recognize this as being similar to the time example in <a class="docLink" href="regex3-CHP-1.html#regex3-CHP-1">Chapter 1</a> (&#9758;28), and date example of the previous chapter (&#9758;177).</P>
<p class="docText">Continuing with our regular expression, a three-digit number beginning with a <tt>2</tt> is allowed if the number is 255 or less, so a second digit less than <tt>5</tt> means the number is valid. If the second digit <span class="docEmphasis">is</span> <tt>5</tt>, the third must be less than <tt>6</tt>. This can all be expressed as <img src=images/U2308.jpg border=0><tt>2[0-4]\d|25[0-5]</tt><img src=images/U230B.jpg border=0>.</p>
<p class="docText">This may seem confusing at first, but the approach should make sense upon reflection. The result is <img src=images/U2308.jpg border=0><tt>\d|\d\d|[01]\d\d|2[0-4]\d|25[0-5]</tt><img src=images/U230B.jpg border=0>. Actually, we can combine the first three alternatives to yield <img src=images/U2308.jpg border=0><tt><img border="0" alt="" id="195131084202" width="82" height="13" SRC="images/regex3_u0504.jpg">|2[0-4]\d|25[0-5]</tt><img src=images/U230B.jpg border=0>. Doing so is more efficient for an NFA, since any alternative that fails results in a backtrack. Note that using <img src=images/U2308.jpg border=0><tt>\d\d<span class="docEmphStrong">?</span></tt><img src=images/U230B.jpg border=0> in the first alternative, rather than <img src=images/U2308.jpg border=0><tt>\d<span class="docEmphStrong">?</span>\d</tt><img src=images/U230B.jpg border=0>, allows an NFA to fail just a bit more quickly when there is no digit at all. I'll leave the analysis to youwalking through a simple test case with both should illustrate the difference. We could do other things to make this part of the expression more efficient, but I'll leave that for the next chapter.</p>
<p class="docText">Now that we have a subexpression to match a single number from 0 through 255, we can wrap it in parentheses and insert it in place of each <img src=images/U2308.jpg border=0><tt>\d{1,3}</tt><img src=images/U230B.jpg border=0> in the earlier regex. This gives us (broken across lines to fit the width of the page):</P>
<pre>
    <img src=images/U2308.jpg border=0>^<span class="docEmphStrong">(</span>[01]?\d\d?<span class="docEmphStrong">|</span>2[0-4]\d<span class="docEmphStrong">|</span>25[0-5]<span class="docEmphStrong">)</span>\.<span class="docEmphStrong">(</span>[01]?\d\d?<span class="docEmphStrong">|</span>2[0-4]\d<span class="docEmphStrong">|</span>25[0-5]<span class="docEmphStrong">)</span>\.
        <span class="docEmphStrong">(</span>[01]?\d\d?<span class="docEmphStrong">|</span>2[0-4]\d<span class="docEmphStrong">|</span>25[0-5]<span class="docEmphStrong">)</span>\.<span class="docEmphStrong">(</span>[01]?\d\d?<span class="docEmphStrong">|</span>2[0-4]\d<span class="docEmphStrong">|</span>25[0-5]<span class="docEmphStrong">)</span>$<img src=images/U230B.jpg border=0>
</pre><br>

<p class="docText">Quite a mouthful! Was it worth the trouble? You have to decide for yourself based upon your own needs. It matches only syntactically correct IP addresses, but it can still match <span class="docEmphasis">semantically</span> incorrect ones, such as <tt>0.0.0.0</tt> (invalid because all the digits are zero). With lookahead (&#9758;133), you can disallow that specific case by putting <img src=images/U2308.jpg border=0><tt>(?!0+\.0+\.0+\.0+$)</tt><img src=images/U230B.jpg border=0> after <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0>, but at some point, you have to decide when being too specific causes the cost/benefit ratio to suffer from diminishing returns. Sometimes it's better to take some of the work out of the regex. For example, if you go back to <img src=images/U2308.jpg border=0><tt>^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$</tt><img src=images/U230B.jpg border=0> and wrap each component in parentheses to stuff the numbers into the program's version of <tt>$1, $2, $3</tt>, and <tt>$4</tt>, you can then validate them by other programming constructs.</p>
<a name="regex3-CHP-5-SECT-2.2.1"></a>
<h5 id="title-IDA4ENLF" class="docSection3Title">5.2.2.1. Know your context</h5>
<a name="IDX-CHP-5-1651"></a> 
<a name="IDX-CHP-5-1652"></a> 

<p class="docText">It's important to realize that the two anchors, <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0>, are required to make this regex work. Without them, it can match <tt>ip=72</tt><img border="0" alt="" id="195131084202" width="82" height="12" SRC="images/regex3_u0505.jpg"><tt>3</tt>, or for a Traditional NFA, even <tt>ip=</tt><img border="0" alt="" id="195131084202" width="100" height="14" SRC="images/regex3_u0506.jpg"><tt>3</tt>.</p>
<p class="docText">In that second case, the expression does not even fully match the final <tt>223</tt> that should have been allowed. Well, it is <span class="docEmphasis">allowed</span>, but there's nothing (such as a separating period, or the trailing anchor) to force that match. The final group's first alternative, <img src=images/U2308.jpg border=0><tt>[01]?\d\d?</tt><img src=images/U230B.jpg border=0>, matched the first two digits, and without the trailing <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0>, that's the end of the regex. As with the date-matching problem in the previous chapter (&#9758;176), we can arrange the order of the alternatives to achieve the desired result. In this case, we would put the alternatives matching three digits first, so any proper three-digit number is matched in full before the two-digit-okay alternative is given a chance. (DFAs and POSIX NFAs don't require the reordering, of course, since they choose the longest match, regardless.)</p>
<p class="docText">Rearranged or not, that first mistaken match is still a problem. "Ah!" you might think, "I can use word boundary anchors to solve this problem." Unfortunately, that's probably not enough, since such a regex could still match <img border="0" alt="" id="195131084202" width="62" height="14" SRC="images/regex3_u0507.jpg"><tt>.5.6.</tt> To disallow embedded matches, you must ensure that the surrounding context has at least no alphanumerics or periods. If you have lookaround, you can wrap the regex in <img src=images/U2308.jpg border=0><tt>(?&lt;!<span class="docEmphStrong">[\w.]</span>)&#8943;(?!<span class="docEmphStrong">[\w.]</span>)</tt><img src=images/U230B.jpg border=0> to disallow matches that follow just after (or end just before) where <img src=images/U2308.jpg border=0><tt>[\w.]</tt><img src=images/U230B.jpg border=0> can match. If you don't have lookaround, simply wrapping it in <img src=images/U2308.jpg border=0><tt>(^| &#8226;)&#8943;(&#8226; |$)</tt><img src=images/U230B.jpg border=0> might be satisfactory for some situations.</p>


<a name="regex3-CHP-5-SECT-2.3"></a>
<h4 id="title-IDAJHNLF" class="docSection2Title">5.2.3. Working with Filenames</h4>
<a name="IDX-CHP-5-1653"></a> 
<a name="IDX-CHP-5-1654"></a> 
<a name="IDX-CHP-5-1655"></a> 
<a name="IDX-CHP-5-1656"></a> 

<p class="docText">Working with file and path names, like <tt>/usr/local/bin/perl</tt> on Unix, or perhaps something like <tt>\Program Files\Yahoo!\Messenger</tt><a name="IDX-CHP-5-1657"></a> 
 on Windows, can provide many good regular-expression examples. Since "using" is more interesting than "reading," I'll sprinkle in a few examples coded in Perl, PHP (preg routines), Java, and VB.NET. If you're not interested in these particular languages, feel free to skip the code snippetsit's the regex concepts used in them that are important.</p>
<a name="regex3-CHP-5-SECT-2.3.1"></a>
<h5 id="title-IDANINLF" class="docSection3Title">5.2.3.1. Removing the leading path from a filename</h5>
<a name="IDX-CHP-5-1658"></a> 

<p class="docText">As a first example, let's remove the leading path from a filename, turning <tt>/usr/local/bin/gcc</tt>, for instance, into <tt>gcc</tt>. Stating problems in a way that makes solutions amenable is half of the battle. In this case, we want to remove anything up to (and including) the final slash (backslash for Windows pathnames). If there is no slash, it's fine as is, and nothing needs to be done. I've said a number of times that <img src=images/U2308.jpg border=0><tt>.*</tt><img src=images/U230B.jpg border=0> is often overused, but its greediness is desired here. With <img src=images/U2308.jpg border=0><tt>^.*/</tt><img src=images/U230B.jpg border=0>, the <img src=images/U2308.jpg border=0><tt>.*</tt><img src=images/U230B.jpg border=0> consumes the whole line, but then backs off (that is, backtracks) to the last slash to achieve the match.</p>
<p class="docText">Here's code to do it in our four test languages, ensuring that a filename in the variable <tt>f</tt> has no leading path. First, for Unix filenames:</p>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead><tr><th class="thead" scope="col" align="right"><p class="docText">Language</p></th><th class="thead" scope="col" align="left"><p class="docText">Code Snippet</P></th></tr></thead><TR><td class="docTableCell" align="left"><p class="docText">Perl</p></TD><TD class="docTableCell" align="left"><p class="docText">$f <span class="docEmphStrong">=~ s{</span><img border="0" alt="" id="195131084202" width="25" height="11" SRC="images/regex3_u0508.jpg"><span class="docEmphStrong">}{}</span>;</P></TD></tr><TR><td class="docTableCell" align="left"><p class="docText">PHP</p></TD><TD class="docTableCell" align="left"><p class="docText">$f = <span class="docEmphStrong">preg_replace(</span>'{<img border="0" alt="" id="195131084202" width="25" height="11" SRC="images/regex3_u0508.jpg">}', '', $f<span class="docEmphStrong">)</span>;</p></td></TR><TR><TD class="docTableCell" align="left"><p class="docText">java.util.regex</p></TD><TD class="docTableCell" align="left"><p class="docText">f = f.<span class="docEmphStrong">replaceFirst</span>("<img border="0" alt="" id="195131084202" width="25" height="11" SRC="images/regex3_u0508.jpg">", "");</p></td></tr><tr><TD class="docTableCell" align="left"><p class="docText">VB.NET</p></td><TD class="docTableCell" align="left"><p class="docText">f = <span class="docEmphStrong">Regex.Replace</span>(f, "<img border="0" alt="" id="195131084202" width="25" height="11" SRC="images/regex3_u0508.jpg">", "")</p></td></tr></table></p><br>
<p class="docText">The regular expression (or string to be interpreted as a regular expression) is underlined, and regex components are bold.</p>
<p class="docText">For comparison, here are versions for Windows filenames, which use a backward slash rather than a forward slash, making the regex <img src=images/U2308.jpg border=0><tt>^.*\\</tt><img src=images/U230B.jpg border=0>. The need to double the backward slash in the regex to match a single backward-slash character in the target is a regular-expression issue, but as the middle two examples show, some languages require additional string-related backslashes as well:</p>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead><tr><th class="thead" scope="col" align="right"><p class="docText">Language</p></th><th class="thead" scope="col" align="left"><p class="docText">Code Snippet</p></th></tr></thead><tr><td class="docTableCell" align="left"><p class="docText">Perl</p></td><td class="docTableCell" align="left"><p class="docText">$f <span class="docEmphStrong">=~ s/</span><img border="0" alt="" id="195131084202" width="40" height="13" SRC="images/regex3_u0509.jpg"><span class="docEmphStrong">//</span>;</P></td></TR><tr><td class="docTableCell" align="left"><p class="docText">PHP</P></TD><TD class="docTableCell" align="left"><p class="docText">$f = <span class="docEmphStrong">preg_replace(</span>'/<img border="0" alt="" id="195131084202" width="44" height="12" SRC="images/regex3_u0510.jpg">/', '', $f<span class="docEmphStrong">)</span>;</P></td></TR><tr><td class="docTableCell" align="left"><p class="docText">java.util.regex</P></TD><td class="docTableCell" align="left"><p class="docText">f = f.<span class="docEmphStrong">replaceFirst</span>("<img border="0" alt="" id="195131084202" width="55" height="12" SRC="images/regex3_u0511.jpg">", "");</p></TD></TR><TR><td class="docTableCell" align="left"><p class="docText">VB.NET</P></TD><td class="docTableCell" align="left"><p class="docText">f = <span class="docEmphStrong">Regex.Replace</span>(f, "<img border="0" alt="" id="195131084202" width="40" height="13" SRC="images/regex3_u0509.jpg">", "")</p></td></tr></table></P><br>
<p class="docText">It's interesting to compare each language's difference between the examples, particularly the quadruple backslashes needed in Java (&#9758;101).</p>
<p class="docText">Please keep in mind this key point: always consider what will happen when there is no match. In this case, no match means no slash in the string, so no substitution and the string is left unchanged. That's just what we want, in this case.</P>
<p class="docText">For efficiency's sake, it's important to remember how an NFA-based regex engine goes about its work. Let's consider what happens if we omit the leading caret (something that's easy to forget) and match against a string that doesn't happen to have a slash. As always, the regex engine starts the search at the beginning of the string. The <img src=images/U2308.jpg border=0><tt>.*</tt><img src=images/U230B.jpg border=0> races to the end of the string, but must back off to find a match for the slash or backslash. It eventually backs off everything that <img src=images/U2308.jpg border=0><tt>.*</tt><img src=images/U230B.jpg border=0> had gobbled up, yet there's still no match. So, the regex engine decides that there is no possible match <span class="docEmphasis">when starting from the beginning of the string</span>, but it's not done yet!</p>
<p class="docText">The transmission kicks in and retries the whole regex from the second character position. In fact, it needs (in theory) to go through the whole scan-and-backtrack routine for each possible starting position in the string. Filenames tend to be short, so it's probably not such a big deal in this case, but the principle applies to many situations. Were the string long, there's a potential for a lot of backtracking. (A DFA has no such problem, of course.)</p>
<p class="docText">In practice, a reasonably optimized transmission realizes that almost any regex starting with <img src=images/U2308.jpg border=0><tt>.*</tt><img src=images/U230B.jpg border=0> that fails at the beginning of the string can never match when started from anywhere else, so it can shift gears and attempt the regex only the one time, at the start of the string (&#9758;246). Still, it's smarter to write that into our regex in the first place, as we originally did.</p>

<a name="regex3-CHP-5-SECT-2.3.2"></a>
<h5 id="title-IDA3RNLF" class="docSection3Title">5.2.3.2. Accessing the filename from a path</h5>
<a name="IDX-CHP-5-1659"></a> 

<p class="docText">Another approach is to bypass the path and simply match the trailing filename part without the path. The final filename is everything at the end that's not a slash: <img src=images/U2308.jpg border=0><tt>[^/]*$</tt><img src=images/U230B.jpg border=0>. This time, the anchor is not just an optimization; we really do need dollar at the end. We can now do something like this, shown with Perl:</p>
<pre>
    $WholePath =~ m{([^/]*)$}; # <span class="docEmphasis">Check variable $WholePath with regex</span>.
        $FileName = $1;   # <span class="docEmphasis">Note text matched</span>
</pre><br>

<p class="docText">You'll notice that I don't check to see whether the regex actually matches, because I <span class="docEmphasis">know</span> it matches every time. The only <span class="docEmphasis">requirement</span> of that expression is that the string has an end to match dollar, and even an empty string has an end. Thus, when I use <tt>$1</tt> to reference the text matched within the parenthetical subexpression, I'm assured it will have some value (although that value will be empty when the filename ends with a slash).</p>
<p class="docText">Another comment on efficiency: with an NFA, <img src=images/U2308.jpg border=0><tt>[^/]*$</tt><img src=images/U230B.jpg border=0> is very inefficient. Carefully run through how the NFA engine attempts the match and you see that it can involve a lot of backtracking. Even the short sample '<tt>/usr/local/bin/perl</tt>' backtracks over 40 times before finally matching. Consider the attempt that starts at <tt>&#8943;<sub><img src=images/U22CF.jpg border=0></sub><tt>local/</tt>&#8943;</tt>. Once <img src=images/U2308.jpg border=0><tt>[^/]*</tt><img src=images/U230B.jpg border=0> matches through to the second <tt>l</tt> and fails on the slash, the <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0> is tried (and fails) for each <tt>l</tt>, <tt>a</tt>, <tt>c</tt>, <tt>o</tt>, <tt>l</tt> saved state. If that's not enough, most of it is repeated with the attempt that starts at <tt>&#8943;<tt>l</tt><sub><img src=images/U22CF.jpg border=0></sub><tt>ocal/</tt>&#8943;</tt>, and then again <tt>&#8943;<tt>lo</tt><sub><img src=images/U22CF.jpg border=0></sub><tt>cal/</tt>&#8943;</tt>, and so on.</p>
<p class="docText">It shouldn't concern us too much with this particular example, as filenames tend to be short. (And 40 backtracks is nothing  40 million is when they really matter!) Again, it's important to be aware of the issues so the general lessons here can be applied to your specific needs.</p>
<p class="docText">This is a good time to point out that even in a book about regular expressions, regular expressions aren't always The Best Answer. For example, most programming languages provide non-regex routines for dealing with filenames. But, for the sake of discussion, I'll forge ahead.</p>

<a name="regex3-CHP-5-SECT-2.3.3"></a>
<h5 id="title-IDANUNLF" class="docSection3Title">5.2.3.3. Both leading path and filename</h5>
<p class="docText">The next logical step is to pick apart a full path into both its leading path and filename component. There are many ways to do this, depending on what we want. Initially, you might want to use <img src=images/U2308.jpg border=0><tt>^(.*)/(.*)$</tt><img src=images/U230B.jpg border=0> to fill <tt>$1</tt> and <tt>$2</tt> with the requisite parts. It looks like a nicely balanced regular expression, but knowing how greediness works, we are guaranteed that the first <img src=images/U2308.jpg border=0><tt>.*</tt><img src=images/U230B.jpg border=0> does what we want, never leaving anything with a slash for <tt>$2</tt>. The only reason the first <img src=images/U2308.jpg border=0><tt>.*</tt><img src=images/U230B.jpg border=0> leaves anything at all is due to the backtracking done in trying to match the slash that follows. This leaves only that "backtracked" part for the later <img src=images/U2308.jpg border=0><tt>.*</tt><img src=images/U230B.jpg border=0>. Thus, <tt>$1</tt> is the full leading path and <tt>$2</tt> the trailing filename.</p>
<p class="docText">One thing to note: we are relying on the initial <img src=images/U2308.jpg border=0><tt>(.*)/</tt><img src=images/U230B.jpg border=0> to ensure that the second <img src=images/U2308.jpg border=0><tt>(.*)</tt><img src=images/U230B.jpg border=0> does not capture any slash. We understand greediness, so this is OK. Still I like to be specific when I can, so I'd rather use <img src=images/U2308.jpg border=0><tt>[^/]*</tt><img src=images/U230B.jpg border=0> for the filename part. That gives us <img src=images/U2308.jpg border=0><tt>^(.*)/<span class="docEmphStrong">(</span>[^/]*<span class="docEmphStrong">)</span>$</tt><img src=images/U230B.jpg border=0>. Since it shows exactly what we want, it acts as documentation as well.</p>
<p class="docText">One big problem is that this regex requires at least one slash in the string, so if we try it on something like <tt>file.txt</tt>, there's no match, and thus no information. This can be a feature if we deal with it properly:</p>
<pre>
    if ( $WholePath =~ m!^(.*)/([^/]*)$! ) {
       # <span class="docEmphasis">Have a match -- $1 and $2 are valid</span>
       $LeadingPath = $1;
       $FileName = $2;
    } else {
       # <span class="docEmphasis">No match, so there's no '/' in the filename</span>
       $LeadingPath = "."; # <span class="docEmphasis">so "file.txt" looks like ". / file.txt" ("." is the
 current directory)</span>
       $FileName = $WholePath;
        }
</pre><br>



<a name="regex3-CHP-5-SECT-2.4"></a>
<H4 id="title-IDAMWNLF" class="docSection2Title">5.2.4. Matching Balanced Sets of Parentheses</h4>
<p class="docText">Matching balanced sets of parentheses, brackets, and the like presents a special difficulty.<a name="IDX-CHP-5-1660"></a> 
 Wanting to match balanced parentheses is quite common when parsing many kinds of configuration files, programs, and such. Imagine, for example, that you want to do some processing on all of a function's arguments when parsing a language like C. Function arguments are wrapped in parentheses following the function name, and may themselves contain parentheses resulting from nested function calls or math grouping. At first, ignoring that they may be nested, you might be tempted to use <img src=images/U2308.jpg border=0><tt>\bfoo\(<img border="0" alt="" id="195131084202" width="35" height="11" SRC="images/regex3_u0512.jpg">\)</tt><img src=images/U230B.jpg border=0>, but it won't work.</P>
<p class="docText">In hallowed C tradition, I use <tt>foo</tt> as the example function name. The marked part of the expression is ostensibly meant to match the function's arguments. With examples such as <tt>foo</tt><img border="0" alt="" id="195131084202" width="75" height="15" SRC="images/regex3_u0513.jpg"> and <tt>foo</tt><img border="0" alt="" id="195131084202" width="110" height="12" SRC="images/regex3_u0514.jpg">, it works as expected. Unfortunately, it also matches <tt>foo</tt><img border="0" alt="" id="195131084202" width="122" height="15" SRC="images/regex3_u0515.jpg">,<tt>&#8226; 3.7</tt>), which is not as we want. This calls for something a bit "smarter" than <img src=images/U2308.jpg border=0><tt>[^)]*</tt><img src=images/U230B.jpg border=0>.</p>
<p class="docText">To match the parenthesized expression part, you might consider the following regular expressions, among others:</p>
<UL><LI><p class="docList"><span class="docEmphasis">1</span>. <tt>\(.*\)</tt> literal parentheses with anything in between</P></LI><li><p class="docList"><span class="docEmphasis">2</span>. <tt>\(<span class="docEmphStrong">[</span>^)<span class="docEmphStrong">]</span>*\)</tt> from an opening parenthesis to the next closing parenthesis</P></li><li><p class="docList"><span class="docEmphasis">3</span>. <tt>\(<span class="docEmphStrong">[</span>^()<span class="docEmphStrong">]</span>*\)</tt> from an opening parenthesis to the next closing parenthesis, but no other opening parentheses allowed in between</P></LI></ul>
<p class="docText"><a class="docLink" href="#regex3-CHP-5-FIG-1">Figure 5-1</a> illustrates where these match against a sample line of code.</p>
<a name="regex3-CHP-5-FIG-1"></a><P><center>
<H5 class="docFigureTitle">Figure 5-1. Match locations of our sample regexes</H5><img border="0" alt="" id="195131084202" width="470" height="152" SRC="images/regex3_0501.jpg">
</center></p><BR>
<p class="docText">We see that regex <tt>#1</tt> matches too much, <sup class="docFootnote"><a class="docLink" href="#regex3-CHP-5-FN2">[<img src=images/U2020.jpg border=0>]</a></sup>and regex <tt>#2</tt> matches too little. Regex <tt>#3</tt> doesn't even match successfully. In isolation, <tt>#3</tt> would match '(<tt>this</tt>)', but because it must come immediately after the <tt>foo</tt>, it fails. So, none of these work.</P><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-5-FN2">[<img src=images/U2020.jpg border=0>]</a></sup> The use of <img src=images/U2308.jpg border=0><tt>.*</tt><img src=images/U230B.jpg border=0> should set off warning alarms. Always pay particular attention to decide whether dot is really what you want to apply star to. Sometimes that is exactly what you need, but <img src=images/U2308.jpg border=0><tt>.*</tt><img src=images/U230B.jpg border=0> is often used inappropriately.</p></blockquote>
<p class="docText">The real problem is that on the vast majority of systems, <span class="docEmphasis">you simply can't match arbitrarily nested constructs with regular expressions</span>. For a long time, this was universally true, but now Perl, .NET, and PCRE/PHP all offer constructs that make it possible. (See pages 328, 436, and 475, respectively.) But, even without these special constructs, you can still build a regex to match things nested <span class="docEmphasis">to a certain depth</span>, but not to an <span class="docEmphasis">arbitrary level</span> of nesting. Just one level of nesting requires</p>
<pre>
    <img src=images/U2308.jpg border=0>\([^()]*<span class="docEmphStrong">(</span>\([^()]*\)[^()]*<span class="docEmphStrong">)*</span>\)<img src=images/U230B.jpg border=0>
</pre><br>

<p class="docText">so the thought of having to worry about further levels of nesting is frightening. But, here's a little Perl snippet that, given a <tt>$depth</tt>, creates a regex to match up to that many levels of parentheses beyond the first. It uses Perl's "<span class="docEmphasis">string x count</span>" operator, which replicates <span class="docEmphasis">string</span> by <span class="docEmphasis">count</span> times:</p>
<pre>
    $regex = '\(' . '(?:[^()]|\(' x $depth . '[^()]*' . '\))*' x $depth . '\)';
</pre><BR>

<p class="docText">I'll leave the analysis for your free time.</p>

<a name="regex3-CHP-5-SECT-2.5"></a>
<h4 id="title-IDA21NLF" class="docSection2Title">5.2.5. Watching Out for Unwanted Matches</H4>
<a name="IDX-CHP-5-1661"></a> 
<a name="IDX-CHP-5-1662"></a> 
<a name="IDX-CHP-5-1663"></a> 
<a name="IDX-CHP-5-1664"></a> 
<a name="IDX-CHP-5-1665"></a> 
<a name="IDX-CHP-5-1666"></a> 
<a name="IDX-CHP-5-1667"></a> 
<a name="IDX-CHP-5-1668"></a> 

<p class="docText">It's easy to forget what happens if the text is not formed just as you expect. Let's say you are writing a filter to convert a text file to HTML, and you want to replace a line of hyphens by <tt>&lt;HR&gt;</tt>, which represent a horizontal rule (a line across the page). If you used a <tt>s/-*/&lt;HR&gt;/</tt> search-and-replace command, it would replace the sequences you wanted, but only when they're at the beginning of the line. Surprised? In fact, <tt>s/-*/&lt;HR&gt;/</tt> adds <tt>&lt;HR&gt;</tt> to the beginning of <span class="docEmphasis">every</span> line, whether they begin with a sequence of hyphens or not!</p>
<p class="docText">Remember, anything that isn't required is always considered successful. The first time <img src=images/U2308.jpg border=0><tt>-*</tt><img src=images/U230B.jpg border=0> is attempted at the start of the string, it matches any hyphens that might be there. However, if there aren't any, it is still happy to successfully match nothing. That's what star is all about.</p>
<p class="docText">Let's look at a similar example I once saw in a book by a respected author, in which he describes a regular expression to match a number, either integer or floating-point. As his expression is constructed, such a number has an optional leading minus sign, any number of digits, an optional decimal point, and any number of digits that follow. His regex is <img src=images/U2308.jpg border=0><tt>-?[0-9]*\.?[0-9]*</tt><img src=images/U230B.jpg border=0>.</p>
<p class="docText">Indeed, this matches such examples as <tt>1, -272.37, 129238843., .191919</tt>, and even something like <tt>-.0</tt>. This is all good, and as expected.</p>
<p class="docText">However, how do you think it matches in a string like '<tt>this&#8226;has&#8226;no&#8226;number</tt>', '<tt>nothing&#8226;here</tt>', or even an empty string? Look at the regex closely<span class="docEmphasis">everything</span> is optional. <span class="docEmphasis">If</span> a number is there, and <span class="docEmphasis">if</span> it is at the beginning of the string, it is matched, but <span class="docEmphasis">nothing is required</span>. This regex can match all three non-number examples, matching the nothingness at the beginning of the string each time. In fact, it even matches nothingness at the beginning of an example like '<tt>num&#8226;123</tt>', since that nothingness matches earlier than the number would.</p>
<p class="docText">So, it's important to say what you really mean. A floating-point number <span class="docEmphasis">must</span> have at least one digit in it, or it's not a number(!). To construct our regex, let's first assume there is at least one digit before the decimal point. (We'll remove this requirement later.) If so, we need to use plus for those digits: <img src=images/U2308.jpg border=0><tt>-?[0-9]+</tt><img src=images/U230B.jpg border=0>.</p>
<p class="docText">Writing the subexpression to match an optional decimal point (and subsequent digits) hinges on the realization that any numbers after the decimal point are contingent upon there being a decimal point in the first place. If we use something na&iuml;ve like <img src=images/U2308.jpg border=0><tt>\.?[0-9]*</tt><img src=images/U230B.jpg border=0>, the <img src=images/U2308.jpg border=0><tt>[0-9]*</tt><img src=images/U230B.jpg border=0> gets a chance to match regardless of the decimal point's presence.</p>
<p class="docText">The solution is, again, to say what we mean. A decimal point (and subsequent digits, if any) is optional: <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(</span>\.[0-9]*<span class="docEmphStrong">)</span>?</tt><img src=images/U230B.jpg border=0>. Here, the question mark no longer quantifies (that is, governs or controls) only the decimal point, but instead the entire combination of the decimal point plus any following digits. <span class="docEmphasis">Within</span> that combination, the decimal point is required; if it is not there, <img src=images/U2308.jpg border=0><tt>[0-9]*</tt><img src=images/U230B.jpg border=0> is not even reached.</p>
<p class="docText">Putting this all together, we have <img src=images/U2308.jpg border=0><tt>-?[0-9]+<span class="docEmphStrong">(</span>\.[0-9]*<span class="docEmphStrong">)</span>?</tt><img src=images/U230B.jpg border=0>. This still doesn't allow something like '<tt>.007</tt>', since our regex requires at least one digit before the decimal point. If we change that part to allow zero digits, we have to change the other so it doesn't, since we can't allow <span class="docEmphasis">all</span> digits to be optional (the problem we are trying to correct in the first place).</p>
<p class="docText">The solution is to add an alternative that allows for the uncovered situation: <img src=images/U2308.jpg border=0><tt>-?[0-9]+(\.[0-9]*)?<span class="docEmphStrong">|</span><img border="0" alt="" id="195131084202" width="80" height="12" SRC="images/regex3_u0516.jpg"></tt><img src=images/U230B.jpg border=0>. This now also allows just a decimal point followed by (this time not optional) digits. Details, details. Did you notice that I allowed for the optional leading minus in the second alternative as well? That's easy to forget. Of course, you could instead bring the <img src=images/U2308.jpg border=0><tt>-?</tt><img src=images/U230B.jpg border=0> out of the alternation, as in <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">-?(</span>[0-9]+(\.[0-9]*)?<span class="docEmphStrong">|</span>\.[0-9]+ <span class="docEmphStrong">)</span></tt><img src=images/U230B.jpg border=0>.</p>
<p class="docText">Although this is an improvement on the original, it's still more than happy to match at '<img border="0" alt="" id="195131084202" width="60" height="14" SRC="images/regex3_u0517.jpg"><tt>.12</tt>'. Knowing the context in which a regex is intended to be used is an important part of striking the balance between matching what you want, and not matching what you don't want. Our regex for floating-point numbers requires that it be constrained somehow by being part of a larger regex, such as being wrapped by <img src=images/U2308.jpg border=0><tt>^&#8943;$</tt><img src=images/U230B.jpg border=0>, or perhaps <img src=images/U2308.jpg border=0><tt>num\s*=\s*&#8943;$</tt><img src=images/U230B.jpg border=0>.</p>

<a name="regex3-CHP-5-SECT-2.6"></a>
<h4 id="title-IDAVBOLF" class="docSection2Title">5.2.6. Matching Delimited Text</h4>
<a name="IDX-CHP-5-1669"></a> 
<a name="IDX-CHP-5-1670"></a> 
<a name="IDX-CHP-5-1671"></a> 
<a name="IDX-CHP-5-1672"></a> 
<a name="IDX-CHP-5-1673"></a> 
<a name="IDX-CHP-5-1674"></a> 

<p class="docText">Matching a double-quoted string and matching an IP address are just two examples of a whole class of matching problem that often arises: the desire to match text delimited (or perhaps separated) by some other text. Other examples include:</p>
<ul><li><p class="docList">Matching a C comment, which is surrounded by '<tt>/*</tt>' and '<tt>*/</tt>'.</p></LI><li><p class="docList">Matching an HTML tag, which is text wrapped by <tt>&lt;&#8943;&gt;</tt>, such as <tt>&lt;CODE&gt;</tt>.</P></li><li><p class="docList">Extracting items <span class="docEmphasis">between</span> HTML tags, such as the '<tt>super exciting</tt>' of the HTML '<tt>a &lt;I&gt;super exciting&lt;/I&gt; offer!</tt>'</P></LI><LI><p class="docList">Matching a line in a <span class="docEmphasis">.mailrc</span> file. This file gives email aliases, where each line is in the form of</P><pre>
    alias  <span class="docEmphasis">shorthand  full-address</span>
</pre><br>
<p class="docList">such as '<tt>alias jeff jfriedl@regex.info</tt>'. (Here, the delimiters are the whitespace between each item, as well as the ends of the line.)</P></li><li><p class="docList">Matching a quoted string, but allowing it to contain quotes if they are escaped, as in <tt>'a passport needs a</tt> <img border="0" alt="" id="195131084202" width="150" height="14" SRC="images/regex3_u0518.jpg"> <tt>of the holder</tt>.'</P></LI><li><p class="docList">Parsing CSV (comma-separated values) files.</p></LI></UL>
<p class="docText">In general, the requirements for such tasks can be phrased along the lines of:</P>
<ul><LI><p class="docList"><span class="docEmphasis">1</span>. Match the opening delimiter.</P></li><li><p class="docList"><span class="docEmphasis">2</span>. Match the main text (which is really "match anything that is not the closing delimiter").</p></li><LI><p class="docList"><span class="docEmphasis">3</span>. Match the closing delimiter.</p></li></UL>
<p class="docText">As I mentioned earlier, satisfying these requirements can become complicated when the closing delimiter has more than one character, or when it may appear within the main text.</p>
<a name="regex3-CHP-5-SECT-2.6.1"></a>
<h5 id="title-IDAOFOLF" class="docSection3Title">5.2.6.1. Allowing escaped quotes in double-quoted strings</h5>
<a name="IDX-CHP-5-1675"></a> 

<p class="docText">Let's look at the <span class="docEmphStrong">2\"x3\"</span> example, where the closing delimiter is a quote, yet can appear within the main part if escaped. It's easy enough to match the opening and closing quotes; the trick is to match the main text without overshooting the closing quote.</p>
<p class="docText">Thinking carefully about which items are allowed in the main text, we know that if a character is not a double quote, that is, if it matches <img src=images/U2308.jpg border=0><tt>[^"]</tt><img src=images/U230B.jpg border=0>, it's certainly OK. However, if it <span class="docEmphasis">is</span> a double quote, it is OK if preceded by a backslash. Translating that literally, using lookbehind (&#9758;133) for the "if preceded" part, it becomes <img src=images/U2308.jpg border=0><tt>"<span class="docEmphStrong">(</span>[^"]<span class="docEmphStrong">|</span>(?&lt;=\\)"<span class="docEmphStrong">)</span>*"</tt><img src=images/U230B.jpg border=0>, which indeed properly matches our <span class="docEmphStrong">2\"x3\"</span> example.</p>
<p class="docText">This is a perfect example to show how unintended matches can sneak into a seemingly proper regex, because as much as it seems to be correct, it doesn't always work. We want it to match the marked part of this silly example:</p>
<pre>
    Darth<a name="IDX-CHP-5-1676"></a> 
 Symbol: <div><img border="0" alt="" id="195131084202" width="75" height="15" SRC="images/regex3_u0519.jpg"></div> or "[^-^]"
</pre><br>

<p class="docText">but it actually matches:</p>
<pre>
    Darth Symbol: <div><img border="0" alt="" id="195131084202" width="111" height="13" SRC="images/regex3_u0520.jpg"></div>[^-^]"
</pre><br>

<p class="docText">This is because the final quote of the first string indeed has a backslash before it. That backslash is itself escaped, so it <span class="docEmphasis">doesn't</span> escape the quote that follows (which means the quote that follows <span class="docEmphasis">does</span> end the string). Our lookbehind doesn't recognize that the preceding backslash has been itself escaped, and considering that there may be any number of preceding '\\' sequences, it's a can of worms to try to solve this with lookbehind. The real problem is that a backslash that escapes a quote is not being recognized as an escaping backslash when we first process it, so let's try a different approach that tackles it from that angle.</p>
<p class="docText">Concentrating again at what kinds of things we want to match between the opening and closing delimiter, we know that something escaped is OK (<img src=images/U2308.jpg border=0><tt>\\.</tt><img src=images/U230B.jpg border=0>), as well as anything else other than the closing quote (<img src=images/U2308.jpg border=0><tt>[^"]</tt><img src=images/U230B.jpg border=0>). This yields <img src=images/U2308.jpg border=0><tt>"<span class="docEmphStrong">(</span>\\.<span class="docEmphStrong">|</span>[^"]<span class="docEmphStrong">)</span>*"</tt><img src=images/U230B.jpg border=0>. Wonderful, we've solved the problem! Unfortunately, not yet. Unwanted matches can still creep in, such as with this example for which we expect no match because the closing quote has been forgotten:</p>
<pre>
    <div><img border="0" alt="" id="195131084202" width="150" height="13" SRC="images/regex3_u0521.jpg"></div> photo.
</pre><br>

<p class="docText">Why does it match? Recall the lessons from "<a class="docLink" href="regex3-CHP-4-SECT-5.html#regex3-CHP-4-SECT-5.4">Greediness and Laziness Always Favor a Match</a>" (&#9758;167). Even though our regex initially matches past that last quote, as we want, it still backtracks after it finds that there is no ending quote, to:</p>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="2"><col><col></colgroup><thead></thead><tr><td class="docTableCell" align="left"><p class="docText">at '<tt>&#8943;2x\"3<sub><img src=images/U22CF.jpg border=0></sub>\"&#8226;&#8943;</tt>'</p></TD><td class="docTableCell" align="center"><p class="docText">matching <img src=images/U2308.jpg border=0><tt>(\\.|<sub><img src=images/U22CF.jpg border=0></sub>[^"])</tt><img src=images/U230B.jpg border=0></P></td></tr></table></P><BR>
<p class="docText">From that point, the <img src=images/U2308.jpg border=0><tt>[^"]</tt><img src=images/U230B.jpg border=0> matches the backslash, leaving us at what the regex can consider an ending quote.</P>
<p class="docText">An important lesson to take from this example is:</P>
<blockquote>
<p class="docText">When backtracking can cause undesired matches in relation to alternation, it's likely a sign that any success is just a happenstance due to the ordering of the alternatives.</p>
</blockquote>
<p class="docText">In fact, had our original regex had its alternatives reversed, it would match incorrectly in <span class="docEmphasis">every</span> string containing an escaped double quote. The problem is that one alternative can match something that is supposed to be handled by the other.</P>
<p class="docText">So, how can we fix it? Well, just as in the continuation-lines example on page 186, we must make sure that there's no other way for that backslash to be matched, which means changing <img src=images/U2308.jpg border=0><tt>[^"]</tt><img src=images/U230B.jpg border=0>, to <img src=images/U2308.jpg border=0><tt>[^\\"]</tt><img src=images/U230B.jpg border=0>,. This recognizes that both a double quote and a backslash are "special" in this context, and must be handled accordingly. The result is <img src=images/U2308.jpg border=0><tt>"<span class="docEmphStrong">(</span>\\.<span class="docEmphStrong">|</span>[^\\"]<span class="docEmphStrong">)</span>*"</tt><img src=images/U230B.jpg border=0>, which works just fine. (Although this regex now works, it can still be improved so that it is much more efficient for NFA engines; we'll see this example quite a bit in the next chapter &#9758;222.)</p>
<p class="docText">This example shows a particularly important moral:</p>
<blockquote>
<p class="docText">Always consider the "odd" cases in which you <span class="docEmphasis">don't</span> want a regex to match, such as with "bad" data.</P>
</blockquote>
<p class="docText">Our fix is the right one, but it's interesting to note that if you have possessive quantifiers<a name="IDX-CHP-5-1677"></a> 
 (&#9758;142) or atomic grouping<a name="IDX-CHP-5-1678"></a> 
 (&#9758;139), this regex can be written as <img src=images/U2308.jpg border=0><tt>"<span class="docEmphStrong">(</span>\\.<span class="docEmphStrong">|</span>[^"]<span class="docEmphStrong">)*+</span>"</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>"<span class="docEmphStrong">(?&gt;</span>(\\.<span class="docEmphStrong">|</span>[^"])*<span class="docEmphStrong">)</span>"</tt><img src=images/U230B.jpg border=0> respectively. They don't really fix the problem so much as hide it, disallowing the engine from backtracking back to where the problem could show itself. Either way, they get the job done well.</P>
<p class="docText">Understanding how possessive quantifiers and atomic grouping help in this situation is extremely valuable, but I would still go ahead and make the previous fix anyway, as it is more descriptive to the reader. Actually, in this case, I would want to use possessive quantifiers or atomic grouping <span class="docEmphasis">as well</span>not to solve the previous problem, but for efficiency, so that a failure fails more quickly.</p>


<a name="regex3-CHP-5-SECT-2.7"></a>
<h4 id="title-IDAQNOLF" class="docSection2Title">5.2.7. Knowing Your Data and Making Assumptions</H4>
<a name="IDX-CHP-5-1679"></a> 
<a name="IDX-CHP-5-1680"></a> 

<p class="docText">This is an opportune time to highlight a general point about constructing and using regular expressions that I've briefly mentioned a few times. It is important to be aware of the assumptions made about the kind of data with which, and situations in which, a regular expression will be used. Even something as simple as <img src=images/U2308.jpg border=0><tt>a</tt><img src=images/U230B.jpg border=0> assumes that the target data is in the same character encoding (&#9758;105) as the author intends. This is pretty much common sense, which is why I haven't been too picky about saying these things.</P>
<p class="docText">However, many assumptions that might seem obvious to one person are not necessarily obvious to another. For example, the solution in the previous section assumes that escaped newlines shouldn't be matched, or that it will be applied in a dot-matches-all mode (&#9758;111). If we really want to ensure that dot can match a newline, we should write that by using <img src=images/U2308.jpg border=0><tt>(?s:.)</tt><img src=images/U230B.jpg border=0>, if supported by the flavor.</P>
<p class="docText">Another assumption made in the previous section is the type of data to which the regex will be applied, as it makes no provisions for any other uses of double quotes in the data. If you apply it to source code from almost any programming language, for example, you'll find that it breaks because there can be double quotes within comments.</p>
<p class="docText">There is nothing wrong with making assumptions about your data, or how you intend a regex to be used. The problems, if any, usually lie in overly optimistic assumptions and in misunderstandings between the author's intentions and how the regex is eventually used. Documenting the assumptions can help.</P>

<a name="regex3-CHP-5-SECT-2.8"></a>
<H4 id="title-IDANOOLF" class="docSection2Title">5.2.8. Stripping Leading and Trailing Whitespace</h4>
<a name="IDX-CHP-5-1681"></a> 
<a name="IDX-CHP-5-1682"></a> 
<a name="IDX-CHP-5-1683"></a> 

<p class="docText">Removing leading and trailing whitespace from a line is not a challenging problem, but it's one that seems to come up often. By far the best all-around solution is the simple use of two substitutions:</p>
<pre>
    s/^\s+//;
    s/\s+$//;
</pre><br>

<p class="docText">As a measure of efficiency, these use <img src=images/U2308.jpg border=0><tt>+</tt><img src=images/U230B.jpg border=0> instead of <img src=images/U2308.jpg border=0><tt>*</tt><img src=images/U230B.jpg border=0>, since there's no benefit to doing the substitution unless there is actually whitespace to remove.</p>
<p class="docText">For some reason, it seems to be popular to try to find a way to do it all in one expression, so I'll offer a few methods for comparison. I don't recommend them, but it's educational to understand why they work, and why they're not desirable.</P>
<dl class="docList">
<dt><br><p><span class="docPubcolor">
<span class="docPubcolor"><span class="docMonofont">s/\s*(.*?)\s*$/$1/s</span></span></span></P></dt>
<dd><p class="docList">This used to be given as a great example of lazy quantifiers, but not any more, because people now realize that it's so much slower than the simple approach. (In Perl, it's about 5x slower). The lack of speed is due to the need to check <img src=images/U2308.jpg border=0><tt>\s*$</tt><img src=images/U230B.jpg border=0> before <span class="docEmphasis">each</span> application of the lazy-quantified dot. That requires a lot of backtracking.</p></dd>

<dt><br><p><span class="docPubcolor">
<span class="docPubcolor"><span class="docMonofont">s/^\s*<span class="docEmphStrong">(</span>(?:.*\S)?<span class="docEmphStrong">)</span>\s*$/$1/s</span></span></span></p></dt>
<dd><p class="docList">This one looks more complex than the previous example, but its matching is more straightforward, and is only twice as slow as the simple approach. After the initial <img src=images/U2308.jpg border=0><tt>^\s*</tt><img src=images/U230B.jpg border=0> has bypassed any leading whitespace, the <img src=images/U2308.jpg border=0><tt>.*</tt><img src=images/U230B.jpg border=0> in the middle matches all the way to the end of the text. The <img src=images/U2308.jpg border=0><tt>\S</tt><img src=images/U230B.jpg border=0> that follows forces it to backtrack to the last non-whitespace in the text, thereby leaving the trailing whitespace matched by the final <img src=images/U2308.jpg border=0><tt>\s*$</tt><img src=images/U230B.jpg border=0>, outside of the capturing parentheses.</p>
<p class="docList">The question mark is needed so that this expression works properly on a line that has only whitespace. Without it, it would fail to match, leaving the whitespace-filled line unchanged.</p></dd>

<dt><br><p><span class="docPubcolor">
<span class="docPubcolor"><span class="docMonofont">s/^\s+|\s+$//g</span></span></span></p></dt>
<dd><p class="docList">This is a commonly thought-up solution that, while not incorrect (none of these are incorrect), it has top-level alternation that removes many optimizations (covered in the next chapter) that might otherwise be possible.</p>
<p class="docList">The <tt>/g</tt> modifier is required to allow each alternative to match, to remove both leading <span class="docEmphasis">and</span> trailing whitespace. It seems a waste to use <tt>/g</tt> when we know we intend at most two matches, and each with a different subexpression. This is about 4x slower than the simple approach.</p></dd>
</dl>
<p class="docText">I've mentioned the relative speeds as I tested them, but in practice, the actual relative speeds are dependent upon the tool and the data. For example, if the target text is very, very long, but has relatively little whitespace on either end, the middle approach can be somewhat faster than the simple approach. Still, in my programs, I use the language's equivalent of</p>
<pre>
    s/^\s+//;
    s/\s+$//;
</pre><br>

<p class="docText">because it's almost always fastest, and is certainly the easiest to understand.</p>


</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-5-SECT-1.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-5-SECT-3.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>