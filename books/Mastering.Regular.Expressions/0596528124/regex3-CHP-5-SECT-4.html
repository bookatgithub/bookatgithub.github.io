<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 5.4.&nbsp; Extended Examples</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-5-SECT-3.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-6.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="regex3-CHP-5-SECT-4"></a>
<H3 id="title-IDAITEDF" class="docSection1Title">5.4. Extended Examples</H3>
<a name="IDX-CHP-5-1728"></a> 

<p class="docText">The next few examples illustrate some important techniques about regular expressions. The discussions are longer, and show more of the thought processes and mistaken paths that eventually lead to a working conclusion.</P>
<a name="regex3-CHP-5-SIDEBAR-2"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>
<h2 class="docSidebarTitle">Building Up a Regex Through Variables in Java</h2>
<a name="IDX-CHP-5-1729"></a> 

<a name="IDX-CHP-5-1730"></a> 

<a name="IDX-CHP-5-1731"></a> 

<a name="IDX-CHP-5-1732"></a> 

<a name="IDX-CHP-5-1733"></a> 

<a name="IDX-CHP-5-1734"></a> 

<pre>
    String SubDomain  = "(?i:[a-z0-9]|[a-z0-9][-a-z0-9]*[a-z0-9])";
    String TopDomains = "(?x-i:com\\b        \n" +
                        "     |edu\\b        \n" +
                        "     |biz\\b        \n" +
                        "     |in(?:t|fo)\\b \n" +
                        "     |mil\\b        \n" +
                        "     |net\\b        \n" +
                        "     |org\\b        \n" +
                        "     |[a-z][a-z]\\b \n" + // <span class="docEmphasis">country codes</span>
                        ")                   \n";
    String Hostname = "(?:" + SubDomain + "\\.)+" + TopDomains;

    String NOT_IN   = ";\"'&lt;&gt;()\\[\\]{}\\s\\x7F-\\xFF";
    String NOT_END  = "!.,?";
    String ANYWHERE = "[^" + NOT_IN + NOT_END + "]";
    String EMBEDDED = "[" + NOT_END + "]";
    String UrlPath = "/"+ANYWHERE + "*("+EMBEDDED+"+"+ANYWHERE+"+)*";
    String Url =
      "(?x:                                                \n"+
      "  \\b                                               \n"+
      "  ## match the hostname part                        \n"+
      "  (                                                 \n"+
      "    (?: ftp | http s? ): // [-\\w]+(\\.\\w[-\\w]*)+ \n"+
      "   |                                                \n"+
      "    " + Hostname + "                                \n"+
      "  )                                                 \n"+
      "  # allow optional port                             \n"+
      "  (?: :\\d+ )?                                      \n"+
      "                                                    \n"+
      "  # rest of url is optional, and begins with /      \n"+
      "  (?: " + UrlPath + ")?                             \n"+
      " )";
   // <span class="docEmphasis">Now convert string we've built up into a real regex object</span>
   Pattern UrlRegex = Pattern.compile(Url);
   // <span class="docEmphasis">Now ready to apply to raw text to find urls</span> ...
   <img src=images/U22EE.jpg border=0>
</pre><BR>

</TD></tr></table></p><BR>
<a name="regex3-CHP-5-SECT-4.1"></a>
<H4 id="title-IDAEVEDF" class="docSection2Title">5.4.1. Keeping in Sync with Your Data</H4>
<a name="IDX-CHP-5-1735"></a> 
<a name="IDX-CHP-5-1736"></a> 
<a name="IDX-CHP-5-1737"></a> 
<a name="IDX-CHP-5-1738"></a> 
<a name="IDX-CHP-5-1739"></a> 
<a name="IDX-CHP-5-1740"></a> 

<p class="docText">Let's look at a lengthy example that might seem a bit contrived, but which illustrates some excellent points on why it's important to keep in sync with what you're trying to match (and provides some methods to do so).</p>
<p class="docText">Let's say that your data is a series of five-digit US postal codes (ZIP codes) that are run together, and that you need to retrieve all that begin with, say, <tt>44</tt>. Here is a sample line of data, with the codes we want to retrieve in bold:</P>
<pre>
    03824531449411615213<span class="docEmphStrong">44182</span>95035<span class="docEmphStrong">44272</span>752010217443235
</pre><BR>

<p class="docText">As a starting point, consider that <img src=images/U2308.jpg border=0><tt>\d\d\d\d\d</tt><img src=images/U230B.jpg border=0> can be used repeatedly to match all the ZIP codes. In Perl, this is as simple as <span class="docEmphStrong">@zips = m/\d\d\d\d\d/g;</span> to create a list with one ZIP code per element. (To keep these examples less cluttered, they assume the text to be matched is in Perl's default target variable <span class="docEmphStrong">$_</span> &#9758;79.) With other languages, it's usually a simple matter to call the regex "find" method in a loop. I'd like to concentrate on the regular expression rather than that mechanics particular to each language, so will continue to use Perl to show the examples.</p>
<p class="docText">Back to <img src=images/U2308.jpg border=0><tt>\d\d\d\d\d</tt><img src=images/U230B.jpg border=0>. Here's a point whose importance will soon become apparent: the regex never fails until the entire list has been parsedthere are absolutely no bump-and-retries by the transmission. (I'm assuming we'll have only proper data, an assumption that is very situation specific.)</p>
<p class="docText">So, it should be apparent that changing <img src=images/U2308.jpg border=0><tt>\d\d\d\d\d</tt><img src=images/U230B.jpg border=0> to <img src=images/U2308.jpg border=0><tt>44\d\d\d</tt><img src=images/U230B.jpg border=0> in an attempt to find only ZIP codes starting with <tt>44</tt> is sillyonce a match attempt fails, the transmission bumps along one character, thus putting the match for the <img src=images/U2308.jpg border=0><tt>44&#8943;</tt><img src=images/U230B.jpg border=0> out of sync with the start of each ZIP code. Using <img src=images/U2308.jpg border=0><tt>44\d\d\d</tt><img src=images/U230B.jpg border=0> incorrectly finds a match at '&#8943;<tt>531</tt><span class="docEmphStrong">44941</span><tt>16</tt>&#8943;'.</p>
<p class="docText">You could, of course, put a caret or <img src=images/U2308.jpg border=0><tt>\A</tt><img src=images/U230B.jpg border=0> at the head of the regex, but they allow a target ZIP code to match only if it's the first in the string. We need to keep the regex engine in sync manually by writing our regex to pass over undesired ZIP codes as needed. The key here is that it must pass over full ZIP codes, not single characters as with the automatic bump-along.</p>
<a name="regex3-CHP-5-SECT-4.1.1"></a>
<H5 id="title-IDAFYEDF" class="docSection3Title">5.4.1.1. Keeping the match in sync with expectations</h5>
<a name="IDX-CHP-5-1741"></a> 
<a name="IDX-CHP-5-1742"></a> 

<p class="docText">The following are a few ways to pass over undesired ZIP codes. Inserting them before what we want (<img src=images/U2308.jpg border=0><tt>(44\d\d\d)</tt><img src=images/U230B.jpg border=0>) achieves the desired effect. Non-capturing <img src=images/U2308.jpg border=0><tt>(?:&#8943;)</tt><img src=images/U230B.jpg border=0> parentheses are used to match undesired ZIP codes, effectively allowing us to pass them over on the way toward matching a desired ZIP code within the <tt>$1</tt> capturing parentheses:</p>
<dl class="docList">
<dt><BR><p><span class="docPubcolor"><img src=images/U2308.jpg border=0><span class="docPubcolor"><span class="docMonofont"><span class="docEmphStrong">(?:</span>[^4]\d\d\d\d|\d[^4]\d\d\d<span class="docEmphStrong"><span class="docEmphStrong">)</span>*</span>&#8943;</span></span><img src=images/U230B.jpg border=0></span></p></dt>
<dd><p class="docList">This brute-force method actively skips ZIP codes that start with something other than <tt>44</tt>. (Well, it's probably better to use <img src=images/U2308.jpg border=0><tt>[1235-9]</tt><img src=images/U230B.jpg border=0> instead of <img src=images/U2308.jpg border=0><tt>[^4]</tt><img src=images/U230B.jpg border=0>, but as I said earlier, I am assuming properly formatted data.) By the way, we can't use <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(?:</span>[^4][^4]\d\d\d<span class="docEmphStrong">)</span>*</tt><img src=images/U230B.jpg border=0>, as it does not match (and thus does not pass over) undesired ZIP codes like <tt>43210</tt>.</p></dd>

<dt><br><p><span class="docPubcolor">
<img src=images/U2308.jpg border=0><span class="docPubcolor"><span class="docMonofont"><span class="docEmphStrong">(?:</span>(?!44)\d\d\d\d\d<span class="docEmphStrong">)*</span>&#8943;</span></span><img src=images/U230B.jpg border=0></span></p></dt>
<dd><p class="docList">This method skips ZIP codes that do not start with <tt>44</tt>. This might sound virtually identical to the previous one, but when rendered into a regular expression looks quite different. Compare the two descriptions and related expressions. In this case, a desired ZIP code (beginning with <tt>44</tt>) causes the negative-lookahead <img src=images/U2308.jpg border=0><tt>(?!44)</tt><img src=images/U230B.jpg border=0> to fail, thus causing the skipping to stop.</p></dd>

<dt><br><p><span class="docPubcolor">
<img src=images/U2308.jpg border=0><span class="docPubcolor"><span class="docMonofont"><span class="docEmphStrong">(?:</span>\d\d\d\d\d<span class="docEmphStrong">)*?</span>&#8943;</span></span><img src=images/U230B.jpg border=0></span></p></dt>
<dd><p class="docList">This method uses a lazy quantifier to skip ZIP codes only when needed. We use it before a subexpression matching what we <span class="docEmphasis">do</span> want, so that if that subexpression fails, this one matches a ZIP. It's the laziness of <img src=images/U2308.jpg border=0><tt>(&#8943;)*?</tt><img src=images/U230B.jpg border=0> that allows this to happen. Because of the lazy quantifier, <img src=images/U2308.jpg border=0><tt>(?:\d\d\d\d\d)</tt><img src=images/U230B.jpg border=0> is not even attempted until whatever follows has failed. The star assures that it is repeatedly attempted until whatever follows finally does match, thus effectively skipping only what we want to skip.</p></dd>
</dl>
<p class="docText">Combining this last method with <img src=images/U2308.jpg border=0><tt>(44\d\d\d)</tt><img src=images/U230B.jpg border=0> gives us</p>
<pre>
    @zips = m/<div><img border="0" alt="" width="150" height="14" SRC="images/regex3_u0525.jpg"></div>(44\d\d\d)/g;
</pre><br>

<p class="docText">and picks out the desired '<tt>44<span class="docEmphasis">xxx</span></tt>' codes, actively skipping undesired ones that intervene. (In this "<span class="docEmphStrong">@array = m/ &#8943; /g</span>" situation, Perl fills the array with what's matched by capturing parentheses during each match attempt &#9758;311.) This regex can work repeatedly on the string because we know each match always leaves the "current match position" at the start of the next ZIP code, thereby priming the next match to start at the beginning of a ZIP code as the regex expects.</p>

<a name="regex3-CHP-5-SECT-4.1.2"></a>
<h5 id="title-IDAW2EDF" class="docSection3Title">5.4.1.2. Maintaining sync after a non-match as well</h5>
<p class="docText">Have we <span class="docEmphasis">really</span> ensured that the regex is always applied only at the start of a ZIP code? <span class="docEmphasis">No!</span> We have manually skipped <span class="docEmphasis">intervening</span> undesired ZIP codes, but once there are no more desired ones, the regex finally fails. As always, the bump-along and-retry happens, thereby starting the match from a position <span class="docEmphasis">within</span> a ZIP codesomething our approach relies on never happening.</p>
<p class="docText">Let's look at our sample data again:</P>
<pre>
<div><img border="0" alt="" width="200" height="16" SRC="images/regex3_u0526.jpg"></div><span class="docEmphStrong">44182</span><div><img border="0" alt="" width="50" height="15" SRC="images/regex3_u0527.jpg"></div><span class="docEmphStrong">44272</span><sub><img src=images/U22CF.jpg border=0></sub>7<sub><img src=images/U22CF.jpg border=0></sub>5<sub><img src=images/U22CF.jpg border=0></sub>2<sub><img src=images/U22CF.jpg border=0></sub>0<div><img border="0" alt="" width="50" height="15" SRC="images/regex3_u0528.jpg"></div><span class="docEmphStrong">44323</span>5
</pre><br>

<p class="docText">Here, the matched codes are bold (the third of which is undesired), the codes we actively skipped are underlined, and characters skipped via bump-along-and-retry are marked. After the match of <tt>44272</tt>, no more target codes are able to be matched, so the subsequent attempt fails. Does the whole match attempt end? Of course not. The transmission bumps along to apply the regex at the next character, putting us out of sync with the real ZIP codes. After the fourth such bump-along, the regex skips <tt>10217</tt> as it matches <tt>44323</tt>, reporting it falsely as a desired code.</P>
<p class="docText">Any of our three expressions work smoothly so long as they are applied at the start of a ZIP code, but the transmission's bump-along defeats them. This can be solved by ensuring that the transmission doesn't bump along, or that a bump along doesn't cause problems.</p>
<p class="docText">One way to ensure that the transmission doesn't bump along, at least for the first two methods, is to make <img src=images/U2308.jpg border=0><tt>(44\d\d\d)</tt><img src=images/U230B.jpg border=0> greedily optional by appending <img src=images/U2308.jpg border=0><tt>?</tt><img src=images/U230B.jpg border=0>. This plays off the knowledge that the prepended <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(?:</span>(?!44)\d\d\d\d\d<span class="docEmphStrong">)*</span>&#8943;</tt><img src=images/U230B.jpg border=0> or <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(?:</span>[^4]\d\d\d\d|\d[^4]\d\d\d<span class="docEmphStrong">)*</span>&#8943;</tt><img src=images/U230B.jpg border=0> finish only when at a desired code, or when there are no more codes (which is why it can't be used for the third, non-greedy method.) Thus, <img src=images/U2308.jpg border=0><tt>(44\d\d\d)?</tt><img src=images/U230B.jpg border=0> matches the desired ZIP code if it's there, but doesn't force a backtrack if it's not.</p>
<p class="docText">There are some problems with this solution. One is that because we can now have a regex match even when we don't have a target ZIP code, the handling code must be a bit more complex. However, to its benefit, it is fast, since it doesn't involve much backtracking, nor any bump-alongs by the transmission.</P>

<a name="regex3-CHP-5-SECT-4.1.3"></a>
<H5 id="title-IDAV5EDF" class="docSection3Title">5.4.1.3. Maintaining sync with \G</H5>
<a name="IDX-CHP-5-1743"></a> 

<a name="IDX-CHP-5-1744"></a> 

<p class="docText">A more general approach is to simply prepend <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">\G</span></tt><img src=images/U230B.jpg border=0> (&#9758;130) to any of the three methods' expressions. Because we crafted each to explicitly end on a ZIP code boundary, we're assured that any subsequent match that has had no intervening bump-along begins on that same ZIP boundary. And if there <span class="docEmphasis">has</span> been a bump-along, the leading <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">\G</span></tt><img src=images/U230B.jpg border=0> fails immediately, because with most flavors, it's successful only when there's been no intervening bump-along. (This is not true for Ruby and other flavors whose <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">\G</span></tt><img src=images/U230B.jpg border=0> means "start of the current match" instead of "end of the previous match" &#9758;131.)</P>
<p class="docText">So, using the second expression, we end up with</p>
<pre>
    @zips = m/<div><img border="0" alt="" width="18" height="15" SRC="images/regex3_u0529.jpg"></div><span class="docEmphStrong">(?:</span>(?!44)\d\d\d\d\d<span class="docEmphStrong">)</span>*<span class="docEmphStrong">(</span>44\d\d\d<span class="docEmphStrong">)</span>/g;
</pre><BR>

<p class="docText">without the need for any special after-match checking.</p>

<a name="regex3-CHP-5-SECT-4.1.4"></a>
<h5 id="title-IDAWBFDF" class="docSection3Title">5.4.1.4. This example in perspective</H5>
<p class="docText">I'll be the first to admit that this example is contrived, but nevertheless, it shows a number of valuable lessons about how to keep a regex in sync with the data. Still, were I really to need to do this in real life, I would probably not try to solve it completely with regular expressions. I would simply use <img src=images/U2308.jpg border=0><tt>\d\d\d\d\d</tt><img src=images/U230B.jpg border=0> to grab each ZIP code, then discard it if it doesn't begin with '<tt>44</tt>'. In Perl, this looks like:</P>
<pre>
    @zips = ( ); # <span class="docEmphasis">Ensure the array is empty</span>

   while (m/(\d\d\d\d\d)/g) {
      $zip = $1;
      if (substr($zip, 0, 2) eq "44") {
          push @zips, $zip;
      }
   }
</pre><br>

<p class="docText">Also, see the sidebar on page 132 for a particularly interesting use of <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">\G</span></tt><img src=images/U230B.jpg border=0>, although one available at the time of this writing only in Perl.</p>


<a name="regex3-CHP-5-SECT-4.2"></a>
<H4 id="title-IDASCFDF" class="docSection2Title">5.4.2. Parsing CSV Files</H4>
<a name="IDX-CHP-5-1745"></a> 
<a name="IDX-CHP-5-1746"></a> 
<a name="IDX-CHP-5-1747"></a> 

<p class="docText">Parsing a CSV (Comma Separated Values) file can be a bit tricky, as it seems every program producing a CSV file has its own CSV format. We'll first look at how to parse the kind of CSV file that Microsoft Excel generates, and then look at some other format permutations.<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-5-FN3">[<img src=images/U2020.jpg border=0>]</a></sup> Luckily, the Microsoft format is one of the simplest. The values, separated by commas, are either "raw" (just sitting there between the commas), or within double quotes (and within the double quotes, a double quote itself is represented by a pair of double quotes in a row).</P><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-5-FN3">[<img src=images/U2020.jpg border=0>]</a></sup> The final code for processing the Microsoft style CSV files is presented in <a class="docLink" href="regex3-CHP-6.html#regex3-CHP-6">Chapter 6</a> (&#9758;271) after the efficiency issues discussed in that chapter are taken into consideration.</p></blockquote>
<p class="docText">Here's an example:</P>
<pre>
    Ten Thousand,10000, 2710 ,,"10,000","It's ""10 Grand"", baby",10K
</pre><BR>

<p class="docText">This row represents seven fields:</p>
<pre>
    Ten&#8226;Thousand
    10000
    &#8226;2710&#8226;
    <span class="docEmphasis">an empty field</span>
    10,000
    It's&#8226;"10&#8226;Grand",&#8226;baby
    10K
</pre><br>

<p class="docText">So, to parse out the fields from a line, we need an expression to cover each of two field types. The non-quoted ones are easythey contain anything except commas and quotes, so they are matched by <img src=images/U2308.jpg border=0><tt>[^",]+</tt><img src=images/U230B.jpg border=0>.</p>
<p class="docText">A double-quoted field can contain commas, spaces, and in fact anything except a double quote. It can also contain the two quotes in a row that represent one quote in the final value. So, a double-quoted field is matched by any number of <img src=images/U2308.jpg border=0><tt>[^"]|""</tt><img src=images/U230B.jpg border=0> between <img src=images/U2308.jpg border=0><tt>"&#8943;"</tt><img src=images/U230B.jpg border=0>, which gives us <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">"(?:[^"]|"")*"</span></tt><img src=images/U230B.jpg border=0>. (Actually, for efficiency, I can use atomic grouping,<a name="IDX-CHP-5-1748"></a> 
 <img src=images/U2308.jpg border=0><tt>(?&gt;&#8943;)</tt><img src=images/U230B.jpg border=0> instead of <img src=images/U2308.jpg border=0><tt>(?:&#8943;)</tt><img src=images/U230B.jpg border=0>, but I'll leave that discussion until the next chapter; &#9758;259.)</p>
<p class="docText">Putting this all together results in <img src=images/U2308.jpg border=0><tt>[^",]+<span class="docEmphStrong">|"</span>(?:[^"]|"")*<span class="docEmphStrong">"</span></tt><img src=images/U230B.jpg border=0> to match a single field. That might be getting a bit hard to read, so I'll rewrite it in a free-spacing mode (&#9758;111):</P>
<pre>
    # <span class="docEmphasis">Either some non-quote/non-comma text</span> ...
    [^",]+
    # ... <span class="docEmphasis">or</span> ...
      |
    # ... <span class="docEmphasis">a double-quoted field (inside, paired double quotes are allowed)</span>
    "   #<span class="docEmphasis">field's opening quote</span>
       (?: [^"] | "" )*
    " #<span class="docEmphasis">field's closing quote</span>
</pre><br>

<p class="docText">Now, to use this in practice, we can apply it repeatedly to a string containing a CSV row, but if we want to actually do anything productive with the results of the match, we should know which alternative matched. If it's the double-quoted field, we need to remove the outer quotes and replace internal paired double quotes with one double quote to yield the original data.</p>
<p class="docText">I can think of two approaches to this. One is to just look at the text matched and see whether the first character is a double quote. If so, we know that we must strip the first and last characters (the double quotes) and replace any internal '<tt>""</tt>' by '<tt>"</tt>'. That's simple enough, but it's even simpler if we are clever with capturing parentheses. If we put capturing parentheses around each of the subexpressions that match actual field data, we can inspect them after the match to see which group has a value:</P>
<pre>
    # <span class="docEmphasis">Either some non-quote/non-comma text</span> ...
    ( [^",]+ )
    # ... <span class="docEmphasis">or</span> ...
      |
    # . .. <span class="docEmphasis">a double-quoted field (inside, paired double quotes are allowed)</span>
    " #<span class="docEmphasis">field's opening quote</span>
     ( (?: [^"] | "" )* )
    " #<span class="docEmphasis">field's closing quote</span>
</pre><br>

<p class="docText">Now, if we see that the first group captured, we can just use the value as is. If the second group captured, we merely need to replace any '<tt>""</tt>' with '<tt>"</tt>' and we can use the value.</p>
<p class="docText">I'll show the example now in Perl, and a bit later (after we flush out some bugs) in Java and VB.NET (it's also shown in PHP in <a class="docLink" href="regex3-CHP-10.html#regex3-CHP-10">Chapter 10</a>&#9758;480). Here's the snippet in Perl, assuming our line is in <tt>$line</tt> and has already had any newline removed from the end (we don't want the newline to be part of the last field!):</p>
<pre>
    while ($line =~ m{
               # <span class="docEmphasis">Either some non-quote/non-comma text</span> ...
               ( [^",]+ )
               # ... <span class="docEmphasis">or</span> ...
                 |
               # ... <span class="docEmphasis">a double-quoted field ("" allowed inside)</span>
               "   # <span class="docEmphasis">field's opening quote</span>
                  (     (?: [^"] | "" )* )
               "   # <span class="docEmphasis">field's closing quote</span>
            }gx)
   {
      if (defined $1) {
          $field = $1;
      } else {
          $field = $2;
          $field =~ s/""/"/g;
      }
      print "[$field]"; # <span class="docEmphasis">print the field, for debugging</span>
      <span class="docEmphasis">Can work with $field now</span> ...
   }
</pre><br>

<p class="docText">Applying this against our test data, the output is:</p>
<pre>
    [Ten&#8226;Thousand][10000][&#8226;2710&#8226;][10,000][It's&#8226;"10&#8226;Grand",&#8226;baby][10K]
</pre><br>

<p class="docText">This looks mostly good, but unfortunately doesn't give us anything for that empty fourth field. If the program's "work with <tt>$field</tt>" is to save the field value to an array, once we're all done, we'd want access to the fifth element of the array to yield the fifth field ("<tt>10,000</tt>"). That won't work if we don't fill an element of the array with an empty value for each empty field.</p>
<p class="docText">The first idea that might come to mind for matching an empty field is to change <img src=images/U2308.jpg border=0><tt>[^",]<span class="docEmphStrong">+</span></tt><img src=images/U230B.jpg border=0> to <img src=images/U2308.jpg border=0><tt>[^",]<span class="docEmphStrong">*</span></tt><img src=images/U230B.jpg border=0>. Well, that may seem obvious, but does it really work?</p>
<p class="docText">Let's test it. Here's the output:</p>
<pre>
    [Ten&#8226;Thousand][][10000][][&#8226;2710&#8226;][][][][10,000][][][It's&#8226;"10&#8226;Grand", ...
</pre><br>

<p class="docText">Oops, we somehow got a bunch of extra fields! Well, in retrospect, we shouldn't be surprised. By using <img src=images/U2308.jpg border=0><tt>(&#8943;)*</tt><img src=images/U230B.jpg border=0> to match a field, we don't actually require anything to match. That works to our advantage when we have an empty field, but consider after having matched the first field, the next application of the regex starts at '<tt>Ten&#8226;Thousand<sub><img src=images/U22CF.jpg border=0></sub>,10000</tt>&#8943;'. If nothing in the regex can match that raw comma (as is the case), yet an empty match is considered successful, the empty match will indeed be successful <span class="docEmphasis">at that point</span>. In fact, it could be successful an infinite number of times at that point if the regex engine doesn't realize, as modern ones do, that it's in such a situation and force a bump-along so that two zero-width matches don't happen in a row (&#9758;131). That's why there's one empty match between each valid match, and one more empty match before each quoted field (and although not shown, there's an empty match at the end).</p>
<a name="regex3-CHP-5-SECT-4.2.1"></a>
<h5 id="title-IDA1IFDF" class="docSection3Title">5.4.2.1. Distrusting the bump-along</h5>
<a name="IDX-CHP-5-1749"></a> 
<a name="IDX-CHP-5-1750"></a> 

<p class="docText">The problem here stems from us having relied on the transmission's bump-along to get us past the separating commas. To solve it, we need to take that control into our own hands. Two approaches come to mind:</p>
<ul><li><p class="docList"><span class="docEmphasis">1</span>. We could try to match the commas ourselves. If we take this approach, we must be sure to match a comma as part of matching a regular field, using it to "pace ourselves" through the string.</p></LI><li><p class="docList"><span class="docEmphasis">2</span>. We could check to be sure that each match start is consistent with locations that we know can start a field. A field starts either at the beginning of the line, or after a comma.</P></li></ul>
<p class="docText">Perhaps even better, we can combine the two. Starting with the first approach (matching the commas ourselves), we can simply require a comma before each field except the first. Alternatively, we can require a comma after each field except the last. We can do this by prepending <img src=images/U2308.jpg border=0><tt>^|,</tt><img src=images/U230B.jpg border=0> or appending <img src=images/U2308.jpg border=0><tt>$|,</tt><img src=images/U230B.jpg border=0> to our regex, with appropriate parentheses to control the scope.</P>
<p class="docText">Let's try prepending <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">^|</span></tt><img src=images/U230B.jpg border=0>, which gives us:</P>
<pre>
    <span class="docEmphStrong">(?:^|,)
    (?:</span>
        # Either some non-quote/non-comma text....
        <span class="docEmphStrong">( [^",]* )</span>
      # ... or...
      |
        # ... a double-quoted field (inside, paired double quotes are allowed)
        " # field's opening quote
         ( (?: [^"] | "" )* )
        " # field's closing quote
    )
</pre><BR>

<p class="docText">This really sounds like it should work, but plugging it into our test program, the result is disappointing:</P>
<pre>
    [Ten&#8226;Thousand][10000][&#8226;2710&#8226;][][][000][][&#8226;baby][10K]
</pre><br>

<p class="docText">Remember, we're expecting:</P>
<pre>
 [Ten&#8226;Thousand][10000][&#8226;2710&#8226;][][10,000][It's&#8226;"10&#8226;Grand",&#8226;baby][10K]
</pre><br>

<p class="docText">Why didn't this one work? It seems that the double-quoted fields didn't come out right, so the problem must be with the part that matches a double-quoted field, right? No, the problem is before that. Perhaps the moral from page 176 can help: <span class="docEmphasis">when more than one alternative can potentially match from the same point, care must be taken when selecting the order of the alternatives</span>. Since the first alternative, <img src=images/U2308.jpg border=0><tt>[^",]*</tt><img src=images/U230B.jpg border=0>, requires nothing to be successful, the second alternative never gets a chance to match unless forced by something that must match later in the regex. Our regex doesn't have anything after these alternatives, so as it's written, the second alternative is never even reached. Doh!</p>
<p class="docText">Wow, you've really got to keep your wits about you. OK, let's swap the alternatives and try again:</P>
<pre>
    (?:^|,)
    (?: # <span class="docEmphasis">Now, match either a double-quoted field (inside, paired double
quotes are allowed)</span> ...
            " # <span class="docEmphasis">(double-quoted field's opening quote)</span>
             ( (?: [^"] | "" )* )
            " # <span class="docEmphasis">(double-quoted field's closing quote)</span>
      |
        # ... <span class="docEmphasis">or, some non-quote/non-comma text</span> ...
              ( [^",]* )
    )
</pre><BR>

<p class="docText">Now, it works! Well, at least for our test data. Could it fail with other data? This section is named "Distrusting the bump-along," and while nothing takes the place of some thought backed up with good testing, we can use <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">\G</span></tt><img src=images/U230B.jpg border=0> to ensure that each match begins exactly at the point that the previous match ended. We believe that should be true already because of how we've constructed and apply our regex. If we start out the regex with <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">\G</span></tt><img src=images/U230B.jpg border=0>, we disallow any match after the engine's transmission is forced to bump along. We hope it will never matter, but doing so may make an error more apparent. Had we done this with our previously-failing regex that had given us</p>
<pre>
    [Ten&#8226;Thousand][10000][&#8226;2710&#8226;][][][000][][&#8226;baby][10K]
</pre><br>

<p class="docText">we would have gotten</P>
<pre>
    [Ten&#8226;Thousand][10000][&#8226;2710&#8226;][][]
</pre><BR>

<p class="docText">instead. This perhaps would have made the error more apparent, had we missed it the first time.</P>
<a name="regex3-CHP-5-SIDEBAR-3"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<h2 class="docSidebarTitle">CSV Processing in Java</h2>
<a name="IDX-CHP-5-1751"></a> 

<a name="IDX-CHP-5-1752"></a> 

<a name="IDX-CHP-5-1753"></a> 

<p class="docText">Here's the CSV example with Sun's <tt>java.util.regex</tt>. This is designed to be clear and simplea more efficient version is given in <a class="docLink" href="regex3-CHP-8.html#regex3-CHP-8">Chapter 8</a> (&#9758;401).</p>
<pre>
    import java.util.regex.*;
    <img src=images/U22EE.jpg border=0>
    String regex = // <span class="docEmphasis">Puts a doublequoted field into group(1), an
unquoted field into group(2)</span>
       "\\G(?:^|,)                                                \n"+
       "(?:                                                       \n"+
       "   # <span class="docEmphasis">Either a double-quoted field</span> ...                   \n"+
       "   \" # <span class="docEmphasis">field's opening quote</span>                             \n"+
       "    (  (?: [^\"]++ | \"\" )*+ )                           \n"+
       "   \" # <span class="docEmphasis">field's closing quote</span>                             \n"+
       " |# ... <span class="docEmphasis">or</span> ...                                        \n"+
       "      # <span class="docEmphasis">some non-quote/non-comma text</span> ...               \n"+
       "   ( [^\",]*)                                             \n"+
       " )                                                        \n";
    // <span class="docEmphasis">Create a matcher, using the regex above, with dummy text for the time being</span>.
    Matcher mMain = Pattern.compile( regex, Pattern.COMMENTS).matcher("");
    // <span class="docEmphasis">Create a matcher for <img src=images/U2308.jpg border=0>""<img src=images/U230B.jpg border=0>, with dummy text for the time being</span>
    Matcher mQuote = Pattern.compile("\"\"").matcher("");
    <img src=images/U22EE.jpg border=0>
    // <span class="docEmphasis">Above is the preparation; the code below is executed on a per-line basis</span>
    mMain.reset( line); // <span class="docEmphasis">Use this line of CSV text in the processing below</span>
    while ( mMain.find())
    {
        String field;
        if ( mMain.start(2) &gt;= 0)
             field = mMain.group(2); // <span class="docEmphasis">The field is unquoted, so we can use it as
 is</span>
        else
             // <span class="docEmphasis">The field is quoted, so we must replace paired doublequotes with
 one double quote</span>
             field = mQuote.reset(mMain.group(1)).replaceAll("\"");
        // <span class="docEmphasis">We can now work with field</span> ...
        System.out.println("Field [" + field + "]");
    }
</pre><br>

</TD></tr></table></p><BR>
<p class="docText"><tt><i>Another approach.</i></tt> The beginning of this section noted two approaches to ensuring we stay properly aligned with the fields. The other is to be sure that a match begins only where a field is allowed. On the surface, this is similar to prepending <img src=images/U2308.jpg border=0><tt>^|,</tt><img src=images/U230B.jpg border=0>, except using lookbehind as with <img src=images/U2308.jpg border=0><tt>(?&lt;=^|,)</tt><img src=images/U230B.jpg border=0>.</p>
<p class="docText">Unfortunately, as the section in <a class="docLink" href="regex3-CHP-3.html#regex3-CHP-3">Chapter 3</a> explains (&#9758;133), even if lookbehind is supported, variable-length lookbehind sometimes isn't, so this approach may not work. If the variable length is the issue, we could replace <img src=images/U2308.jpg border=0><tt>(?&lt;=^|<span class="docEmphStrong">,</span>)</tt><img src=images/U230B.jpg border=0> with <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(?:</span>^|(?&lt;=,)<span class="docEmphStrong">)</span></tt><img src=images/U230B.jpg border=0>, but this seems overly complex considering that we already have the first approach working. Also, it reverts to relying on the transmission's bump-along to bypass the commas, so if we've made a mistake elsewhere, it could allow a match to begin at a location like '<tt>&#8943;"10,<sub><img src=images/U22CF.jpg border=0></sub>000"&#8943;</tt>'. All in all, it just seems safer to use the first approach.</p>
<p class="docText">However, we can use a twist on this approachrequiring a match to <span class="docEmphasis">end</span> before a comma (or before the end of the line). Adding <img src=images/U2308.jpg border=0><tt>(?=$|,)</tt><img src=images/U230B.jpg border=0> to the end of our regex adds yet another assurance that it won't match where we don't want it to. In practice, would I do add this? Well, frankly, I feel pretty comfortable with what we came up with before, so I'd probably not add it in this exact situation, but it's a good technique to have on hand when you need it.</p>

<a name="regex3-CHP-5-SECT-4.2.2"></a>
<h5 id="title-IDARPFDF" class="docSection3Title">5.4.2.2. One change for the sake of efficiency</h5>
<p class="docText">Although I don't concentrate on efficiency until the next chapter, I'd like to make one efficiency-related change now, for systems that support atomic grouping (&#9758;139). If supported, I'd change the part that matches the values of double-quoted fields from <img src=images/U2308.jpg border=0><tt>(?:[^"]|"")*</tt><img src=images/U230B.jpg border=0> to <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(?&gt;</span>[^"]<span class="docEmphStrong">+</span>|"")*</tt><img src=images/U230B.jpg border=0>. The VB.NET example in the sidebar on the facing page shows this.</p>
<p class="docText">If possessive quantifiers (&#9758;142) are supported, as they are with Sun's Java regex package, they can be used instead. The sidebar with the Java CSV code shows this.</p>
<p class="docText">The reasoning behind these changes is discussed in the next chapter, and eventually we end up with a particularly efficient version, shown on page 271.</p>

<a name="regex3-CHP-5-SECT-4.2.3"></a>
<h5 id="title-IDAOQFDF" class="docSection3Title">5.4.2.3. Other CSV formats</h5>
<a name="IDX-CHP-5-1754"></a> 
<a name="IDX-CHP-5-1755"></a> 
<a name="IDX-CHP-5-1756"></a> 
<a name="IDX-CHP-5-1757"></a> 
<a name="IDX-CHP-5-1758"></a> 
<a name="IDX-CHP-5-1759"></a> 

<p class="docText">Microsoft's CSV format is popular because it's Microsoft's CSV format, but it's not necessarily what other programs use. Here are some twists I've seen:</p>
<ul><li><p class="docList">Using another character, such as '<tt>;</tt>' or a tab, as the separator (which makes one wonder why the format is still called "<span class="docEmphasis">comma</span>-separated values").</p></li><LI><p class="docList">Allowing spaces after the separators, but not counting them as part of the value.</p></LI><li><p class="docList">Using backslashes to escape quotes (e.g., using '<tt>\"</tt>' rather than '<tt>""</tt>' to include a quote within the value). This usually means that a backslash is allowed (and ignored) before any character.</p></LI></UL>
<p class="docText">These changes are easily accommodated. Do the first by replacing each comma in the regex with the desired separator; the second by adding <img src=images/U2308.jpg border=0><tt>\s*</tt><img src=images/U230B.jpg border=0> after the first separator, e.g., starting out with <img src=images/U2308.jpg border=0><tt>(?:^|,<span class="docEmphStrong">\s*)</span></tt><img src=images/U230B.jpg border=0>.</P>
<p class="docText">For the third, we can use what we developed earlier (&#9758;198), replacing <img src=images/U2308.jpg border=0><tt>[^"]+|""</tt><img src=images/U230B.jpg border=0> with <img src=images/U2308.jpg border=0><tt>[^\\"]+|\\.</tt><img src=images/U230B.jpg border=0>. Of course, we'd also have to change the subsequent <span class="docEmphStrong">s/""/"/g</span> to the more general <span class="docEmphStrong">s/\\(.)/$1/g</span>, or our target language's equivalent.</P>
<a name="regex3-CHP-5-SIDEBAR-4"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<h2 class="docSidebarTitle">CSV Processing in VB.NET</H2>
<a name="IDX-CHP-5-1760"></a> 

<a name="IDX-CHP-5-1761"></a> 

<pre>
    Imports System.Text.RegularExpressions
       <img src=images/U22EE.jpg border=0>
    Dim FieldRegex as Regex = New Regex( _
           "(?:^|,)                                             " &amp; _
           "(?:                                                 " &amp; _
           "   (?# Either a doublequoted field ...)             " &amp; _
           "   ""  (?# field's opening quote )                  " &amp; _
           "    (   (?&gt; [^""]+ | """" )* )                   " &amp; _
           "   ""  (?# field's closing quote )                  " &amp; _
           " (?# ... or ...)                                    " &amp; _
           " |                                                  " &amp; _
           "   (?# ... some non-quote/non-comma text ...)       " &amp; _
           "   ( [^"",]*)                                       " &amp; _
           " )", RegexOptions.IgnorePatternWhitespace)
    Dim QuotesRegex as Regex = New Regex(" "" "" ") '<span class="docEmphasis">A string with two double quotes</span>
        <img src=images/U22EE.jpg border=0>
    Dim FieldMatch as Match = FieldRegex.Match(Line)
    While FieldMatch.Success
       Dim Field as String
       If FieldMatch.Groups(1).Success
         Field = QuotesRegex.Replace(FieldMatch.Groups(1).Value, """")
       Else
         Field = FieldMatch.Groups(2).Value
       End If

       Console.WriteLine("[" &amp; Field &amp; "]")
       ' Can now work with 'Field'.&#8943;

       FieldMatch = FieldMatch.NextMatch
    End While
</pre><BR>

</td></tr></table></P><BR>



</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-5-SECT-3.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-6.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>