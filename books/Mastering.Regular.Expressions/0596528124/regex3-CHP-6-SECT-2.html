<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 6.2.&nbsp; A Sobering Example</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-6-SECT-1.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-6-SECT-3.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="regex3-CHP-6-SECT-2"></a>
<H3 id="title-IDAEE1GK" class="docSection1Title">6.2. A Sobering Example</H3>
<p class="docText">Let's start with an example that really shows how important a concern backtracking and efficiency can be. On page 198, we came up with <img src=images/U2308.jpg border=0><tt>"\\.|[^\\"])*")*"</tt><img src=images/U230B.jpg border=0> to match a quoted string, with internal quotes allowed if escaped. This regex works, but if it's used with an NFA engine, the alternation applied at each character is very inefficient. With every "normal" (non-escape, non-quote) character in the string, the engine has to test <img src=images/U2308.jpg border=0><tt>\\.</tt><img src=images/U230B.jpg border=0>, fail, and backtrack to finally match with <img src=images/U2308.jpg border=0><tt>[^\\"]</tt><img src=images/U230B.jpg border=0>. If used where efficiency matters, we would certainly like to be able to speed this regex up a bit.</P>
<a name="regex3-CHP-6-SECT-2.1"></a>
<H4 id="title-IDATE1GK" class="docSection2Title">6.2.1. A Simple ChangePlacing Your Best Foot Forward</h4>
<a name="IDX-CHP-6-1769"></a> 

<p class="docText">Since the average double-quoted string has more normal characters than escaped ones, one simple change is to swap the order of<a name="IDX-CHP-6-1770"></a> 
 the alternatives, putting <img src=images/U2308.jpg border=0><tt>[^\\"]</tt><img src=images/U230B.jpg border=0> first and <img src=images/U2308.jpg border=0><tt>\\.</tt><img src=images/U230B.jpg border=0> second. By placing <img src=images/U2308.jpg border=0><tt>[^\\"]</tt><img src=images/U230B.jpg border=0> first, alternation backtracking need be done only when there actually is an escaped item in the string (and once for when the star fails, of course, since all alternatives must fail for the alternation as a whole to stop). <a class="docLink" href="#regex3-CHP-6-FIG-1">Figure 6-1</a> illustrates this difference visually. The reduction of arrows in the bottom half represents the increased number of times when the first alternative matches. That means less backtracking.</P>
<a name="regex3-CHP-6-FIG-1"></a><p><center>
<h5 class="docFigureTitle">Figure 6-1. Effects of alternative order (Traditional NFA)</H5><img border="0" alt="" width="509" height="154" SRC="images/regex3_0601.jpg"></center></P><br>
<p class="docText">In evaluating this change, consider:</p>
<UL><LI><p class="docList">Does this change benefit a Traditional NFA, POSIX NFA, or both?</P></li><LI><p class="docList">Does this change offer the most benefit when the text matches, when the match fails, or at all times?</P></li></ul>
<p class="docText"><a class="docLink" href="#regex3-CHP-6-SIDEBAR-1">&#10070;</a> Consider these questions and flip the page to check your answers. Make sure that you have a good grasp of the answers (and reasons) before continuing on to the next section.</p>

<a name="regex3-CHP-6-SECT-2.2"></a>
<h4 id="title-IDAOG1GK" class="docSection2Title">6.2.2. Efficiency Versus Correctness</H4>
<a name="IDX-CHP-6-1771"></a> 
<a name="IDX-CHP-6-1772"></a> 
<a name="IDX-CHP-6-1773"></a> 
<a name="IDX-CHP-6-1774"></a> 

<p class="docText">The most important question to ask when making any change for efficiency's sake is whether the change affects the correctness<a name="IDX-CHP-6-1775"></a> 
 of a match. Reordering alternatives, as we did earlier, is OK only if the ordering is not relevant to the success of a match. Consider <img src=images/U2308.jpg border=0><tt>"(\\.|[^"])*"</tt><img src=images/U230B.jpg border=0>, which is an earlier (&#9758; 197) but flawed version of the regex in the previous section. It's missing the backslash in the negated character class, and so can match data that should not be matched. If the regex is only ever applied to valid data that <span class="docEmphasis">should</span> be matched, you'd never know of the problem. Thinking that the regex is good and reordering alternatives now to gain more efficiency, we'd be in real trouble. Swapping the alternatives so that <img src=images/U2308.jpg border=0><tt>[^"]</tt><img src=images/U230B.jpg border=0> is first actually ensures that it matches incorrectly every time the target has an escaped quote:</p>
<a name="regex3-CHP-6-SIDEBAR-1"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<h2 class="docSidebarTitle">Effects of a Simple Change</h2>
<p class="docText">&#10070; <span class="docEmphasis">Answers to the questions on page 223</span>.</p>
<p class="docText"><span class="docEmphStrong">Effect for which type of engine?</span> The change has virtually no effect whatsoever for a POSIX NFA engine. Since it must eventually try every permutation of the regex anyway, the order in which the alternatives are tried is irrelevant. For a Traditional NFA, however, ordering the alternatives in such a way that quickly leads to a match is a benefit because the engine stops once the first match is found.</p>
<p class="docText"><span class="docEmphStrong">Effect during which kind of result?</span> The change results in a faster match only when there <span class="docEmphasis">is</span> a match. An NFA can fail only after trying all possible permutations of the match (and again, the POSIX NFA tries them all anyway). So if indeed it ends up failing, every permutation must have been attempted, so the order does not matter.</p>
<p class="docText">The following table shows the number of tests ("tests") and backtracks ("b.t.") for several cases (smaller numbers are better):</p>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="90%"><colgroup span="7"><col><col><col><col><col><col><col></colgroup><thead><tr><th class="thead" scope="col" align="left" valign="bottom" rowspan="4"><p class="docText">Sample String</p></th><th class="thead" scope="col" align="center" valign="bottom" colspan="4"><p class="docText">Traditional NFA</p></th><th class="thead" scope="col" align="center" valign="bottom" colspan="2"><p class="docText">POSIX NFA</p></th></tr><tr><th class="thead" scope="col" align="center" valign="bottom" colspan="2"><p class="docText"><img src=images/U2308.jpg border=0><tt>"([^\\.|[^\\")*"</tt><img src=images/U230B.jpg border=0></p></th><th class="thead" scope="col" align="center" valign="bottom" colspan="2"><p class="docText"><img src=images/U2308.jpg border=0><tt>"([^\\"]|\\.)*"</tt><img src=images/U230B.jpg border=0></p></th><th class="thead" scope="col" align="center" valign="bottom" colspan="2"><p class="docText"><span class="docEmphasis">either</span></p></th></TR><tr><th class="thead" scope="col" align="center"><p class="docText">tests</P></th><th class="thead" scope="col" align="center"><p class="docText">b.t.</p></th><th class="thead" scope="col" align="center"><p class="docText">tests</p></th><th class="thead" scope="col" align="center"><p class="docText">b.t.</P></th><th class="thead" scope="col" align="center"><p class="docText">tests</P></th><th class="thead" scope="col" align="center"><p class="docText">b.t.</P></th></TR></thead><tr><TD class="docTableCell" align="left"><p class="docText"><tt>"2\"x3\" likeness"</tt></p></td><TD class="docTableCell" align="center"><p class="docText">32</P></td><td class="docTableCell" align="center"><p class="docText">14</P></TD><TD class="docTableCell" align="center"><p class="docText">22</p></TD><TD class="docTableCell" align="center"><p class="docText">4</p></td><td class="docTableCell" align="center"><p class="docText">48</p></TD><td class="docTableCell" align="center"><p class="docText">30</p></TD></tr><tr><td class="docTableCell" align="left"><p class="docText"><tt>"makudonarudo"</tt></p></td><td class="docTableCell" align="center"><p class="docText">28</p></td><td class="docTableCell" align="center"><p class="docText">14</p></td><td class="docTableCell" align="center"><p class="docText">16</p></td><td class="docTableCell" align="center"><p class="docText">2</p></td><TD class="docTableCell" align="center"><p class="docText">40</p></TD><td class="docTableCell" align="center"><p class="docText">26</p></TD></TR><TR><TD class="docTableCell" align="left"><p class="docText"><tt>"very...<span class="docEmphasis">99 more chars</span>...long"</tt></p></TD><td class="docTableCell" align="center"><p class="docText">218</p></TD><TD class="docTableCell" align="center"><p class="docText">109</p></td><TD class="docTableCell" align="center"><p class="docText">111</P></TD><td class="docTableCell" align="center"><p class="docText">2</P></TD><td class="docTableCell" align="center"><p class="docText">325</p></td><td class="docTableCell" align="center"><p class="docText">216</P></td></tr><TR><td class="docTableCell" align="left"><p class="docText"><tt>"No \"match\" here</tt></p></td><td class="docTableCell" align="center"><p class="docText">124</p></td><td class="docTableCell" align="center"><p class="docText">86</p></td><td class="docTableCell" align="center"><p class="docText">124</p></td><td class="docTableCell" align="center"><p class="docText">86</p></td><td class="docTableCell" align="center"><p class="docText">124</p></TD><td class="docTableCell" align="center"><p class="docText">86</P></td></tr></table></P><BR>
<p class="docText">As you can see, the POSIX NFA results are the same with both expressions, while the Traditional NFA's performance increases (backtracks decrease) with the new expression. Indeed, in a non-match situation (the last example in the table), since both engine types must evaluate all possible permutations, all results are the same.</P>
</TD></tr></table></P><br>
<pre>
<div><img border="0" alt="" width="185" height="12" SRC="images/regex3_u0601.jpg"></div>
</pre><br>

<p class="docText">So, be sure that you're comfortable with the correctness of a match before you worry too much about efficiency.</P>

<a name="regex3-CHP-6-SECT-2.3"></a>
<H4 id="title-IDACR1GK" class="docSection2Title">6.2.3. Advancing FurtherLocalizing the Greediness</h4>
<a name="IDX-CHP-6-1776"></a> 

<p class="docText"><a class="docLink" href="#regex3-CHP-6-FIG-1">Figure 6-1</a> makes it clear that in either expression, the star must iterate (or cycle, if you like) for each normal character, entering and leaving the alternation (and the parentheses) over and over. These actions involve overhead, which means extra workextra work that we'd like to eliminate if possible.</p>
<p class="docText">Once while working on a similar expression, I realized that I could optimize it by taking into account that since <img src=images/U2308.jpg border=0><tt>[^\\"]</tt><img src=images/U230B.jpg border=0> matches the "normal" (non-quote, non-backslash) case, using <img src=images/U2308.jpg border=0><tt>[^\\"]+</tt><img src=images/U230B.jpg border=0> instead allows one iteration of <tt>(&#8943;)*</tt> to read as many normal characters as there are in a row. For strings without any escapes, this would be the entire string. This allows a match with almost no backtracking, and also reduces the star iteration to a bare minimum. I was very pleased with myself for making this discovery.</P>
<p class="docText">We'll look at this example in more depth later in this chapter, but a quick look at some statistics clearly shows the benefit. <a class="docLink" href="#regex3-CHP-6-FIG-2">Figure 6-2</a> looks at this example for a Traditional NFA. In comparison to the original <img src=images/U2308.jpg border=0><tt>"(\\.|[^\\"])*"</tt><img src=images/U230B.jpg border=0> (the top of the upper pair of <a class="docLink" href="#regex3-CHP-6-FIG-2">Figure 6-2</a>), alternation-related backtracks and star iterations are both reduced. The lower pair in <a class="docLink" href="#regex3-CHP-6-FIG-2">Figure 6-2</a> illustrates that performance is enhanced even further when this change is combined with our previous reordering.</P>
<a name="regex3-CHP-6-FIG-2"></a><P><center>
<h5 class="docFigureTitle">Figure 6-2. Effects of an added plus (Traditional NFA)</H5><img border="0" alt="" width="511" height="274" SRC="images/regex3_0602.jpg"></center></P><br>
<p class="docText">The big gain with the addition of plus is the resulting reduction in the number of alternation backtracks, and, in turn, the number of iterations by the star. The star quantifies a parenthesized subexpression, and each iteration entails some amount of overhead as the parentheses are entered and exited, because the engine needs to keep tabs on what text is matched by the enclosed subexpression. (This is discussed in depth later in this chapter.)</p>
<p class="docText"><a class="docLink" href="#regex3-CHP-6-TABLE-1">Table 6-1</a> is similar to the one in the answer block on page 224, but with different expressions and has information about the number of iterations required by star. In each case, the number of individual tests and backtracks increases ever so slightly, but the number of cycles is drastically reduced. This is big savings.</p>
<a name="regex3-CHP-6-TABLE-1"></a><p><table cellspacing="0" FRAME="hsides" RULES="all" cellpadding="4" width="100%"><caption><H5 class="docTableTitle">Table 6-1. Match Efficiency for a Traditional NFA</h5></caption><colgroup span="7"><col><col><col><col><col><col><col></colgroup><thead><tr><th class="thead" scope="col" align="left" valign="bottom" rowspan="3"><p class="docText">Sample String</P></th><th class="thead" scope="col" align="center" valign="bottom" colspan="3"><p class="docText"><img src=images/U2308.jpg border=0><tt>"([^\\"]|\\.)*"</tt><img src=images/U230B.jpg border=0></p></th><th class="thead" scope="col" align="center" valign="bottom" colspan="3"><p class="docText"><img src=images/U2308.jpg border=0><tt>"([^\\"]<img border="0" alt="" width="6" height="10" SRC="images/regex3_u0602.jpg">|\\.)*"</tt><img src=images/U230B.jpg border=0></p></th></tr><tr><th class="thead" scope="col" align="center"><p class="docText">tests</p></th><th class="thead" scope="col" align="center"><p class="docText">b.t.</p></th><th class="thead" scope="col" align="center"><p class="docText">*-cycles</p></th><th class="thead" scope="col" align="center"><p class="docText">tests</p></th><th class="thead" scope="col" align="center"><p class="docText">b.t.</p></th><th class="thead" scope="col" align="center"><p class="docText">*-cycles</p></th></tr></thead><tr><td class="docTableCell" align="left"><p class="docText"><tt>"makudonarudo"</tt></p></td><td class="docTableCell" align="center"><p class="docText">16</p></TD><td class="docTableCell" align="center"><p class="docText">2</P></td><td class="docTableCell" align="center"><p class="docText">13</P></TD><TD class="docTableCell" align="center"><p class="docText">17</P></td><TD class="docTableCell" align="center"><p class="docText">3</p></td><TD class="docTableCell" align="center"><p class="docText">2</P></td></tr><TR><TD class="docTableCell" align="left"><p class="docText"><tt>"2\"x3\" likeness"</tt></P></td><TD class="docTableCell" align="center"><p class="docText">22</P></td><td class="docTableCell" align="center"><p class="docText">4</p></td><TD class="docTableCell" align="center"><p class="docText">15</p></td><TD class="docTableCell" align="center"><p class="docText">25</p></td><td class="docTableCell" align="center"><p class="docText">7</p></td><td class="docTableCell" align="center"><p class="docText">6</p></td></tr><tr><td class="docTableCell" align="left"><p class="docText"><tt>"very...<span class="docEmphasis">99 more chars</span>...long"</tt></p></td><td class="docTableCell" align="center"><p class="docText">111</p></td><td class="docTableCell" align="center"><p class="docText">2</P></td><TD class="docTableCell" align="center"><p class="docText">108</p></td><TD class="docTableCell" align="center"><p class="docText">112</P></TD><TD class="docTableCell" align="center"><p class="docText">3</p></TD><td class="docTableCell" align="center"><p class="docText">2</p></TD></TR></table></p><br>

<a name="regex3-CHP-6-SECT-2.4"></a>
<H4 id="title-IDAZB2GK" class="docSection2Title">6.2.4. Reality Check</H4>
<a name="IDX-CHP-6-1777"></a> 
<a name="IDX-CHP-6-1778"></a> 
<a name="IDX-CHP-6-1779"></a> 
<a name="IDX-CHP-6-1780"></a> 
<a name="IDX-CHP-6-1781"></a> 
<a name="IDX-CHP-6-1782"></a> 

<p class="docText">Yes, I was quite pleased with myself for this discovery.<a name="IDX-CHP-6-1783"></a> 
<a name="IDX-CHP-6-1784"></a> 
<a name="IDX-CHP-6-1785"></a> 
 However, as wonderful as this "enhancement" might seem, it is really a disaster waiting to happen. You'll notice that when extolling its virtues, I didn't give statistics for a POSIX NFA engine. If I had, you might have been surprised to find the "<tt>very</tt>&#8226;&#8943;&#8226;<tt>long</tt>" example requires over <span class="docEmphasis">three hundred thousand million billion trillion</span> backtracks (for the record, the actual count would be 324,518,553,658,426,726,783,156,020,576,256, or about 325 nonillion).<a name="IDX-CHP-6-1786"></a> 
 Putting it mildly, that is a LOT of work. This would take well over 50 <span class="docEmphasis">quintillion</span> years, take or leave a few hundred trillion millennia.<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-6-FN-1">[<img src=images/U2020.jpg border=0>]</a></sup></P><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-6-FN-1">[<img src=images/U2020.jpg border=0>]</a></sup> The reported time is an estimation based on other benchmarks; I did not actually run the test that long.</p></blockquote>
<p class="docText">Quite surprising indeed! So, why does this happen? Briefly, it's because somethingin the regex is subject to both an immediate plus and an enclosing star, with nothing to differentiate which is in control of any particular target character. The resulting nondeterminism is the killer. The next section explains a bit more.</P>
<a name="regex3-CHP-6-SECT-2.4.1"></a>
<H5 id="title-IDACE2GK" class="docSection3Title">6.2.4.1. "Exponential" matches</h5>
<a name="IDX-CHP-6-1787"></a> 
<a name="IDX-CHP-6-1788"></a> 
<a name="IDX-CHP-6-1789"></a> 
<a name="IDX-CHP-6-1790"></a> 

<p class="docText">Before adding the plus, <img src=images/U2308.jpg border=0><tt>[^\\"]</tt><img src=images/U230B.jpg border=0> was subject to only the star, and the number of possible ways for the effective <img src=images/U2308.jpg border=0><tt>([^\\"])*</tt><img src=images/U230B.jpg border=0> to divvy up the line was limited. It matched one character, then another, and so forth, until each character in the target text had been matched at most one time. It may not have matched everything in the target, but at worst, the number of characters matched was directly proportional to the length of the target string. The possible amount of work rose in step with the length of the target string.</p>
<p class="docText">With the new regex's effective <img src=images/U2308.jpg border=0><tt>([^\\"]+)*</tt><img src=images/U230B.jpg border=0>, the number of ways that the plus and star might divvy up the string explodes exponentially. If the target string is <tt>makudonarudo</tt>, should it be considered 12 iterations of the star, where each internal <img src=images/U2308.jpg border=0><tt>[^\\"]+</tt><img src=images/U230B.jpg border=0> matches just one character (as might be shown by '<img border="0" alt="" width="97" height="13" SRC="images/regex3_u0603.jpg">')? Or perhaps one iteration of the star, where the internal <img src=images/U2308.jpg border=0><tt>[^\\"]+</tt><img src=images/U230B.jpg border=0> matches everything ('<img border="0" alt="" width="97" height="13" SRC="images/regex3_u0604.jpg">')? Or, perhaps 3 iterations of the star, where the internal <img src=images/U2308.jpg border=0><tt>[^\\"]+</tt><img src=images/U230B.jpg border=0> matches 5, 3, and 4 characters respectively ('<img border="0" alt="" width="97" height="13" SRC="images/regex3_u0605.jpg">'). Or perhaps 2, 2, 5, and 3 characters respectively ('<img border="0" alt="" width="98" height="13" SRC="images/regex3_u0653.jpg">'). Or, perhaps...</p>
<p class="docText">Well, you get the idea  there are a lot of possibilities (4,096 in this 12-character example). For each extra character in the string, the number of possible combinations doubles, and the POSIX NFA must try them all before returning its answer. That's why these are called "exponential matches." Another appealing phrase I've heard for these types of matches is <span class="docEmphasis">super-linear</span>.</p>
<p class="docText">However called, it means backtracking, and lots of it!<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-6-FN-2">[<img src=images/U2020.jpg border=0>]</a></sup> Twelve characters' 4,096 combinations doesn't take long, but 20 characters' million-plus combinations take more than a few seconds. By 30 characters, the billion-plus combinations take hours, and by 40, it's well over a year. Obviously, this is not good.</P><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-6-FN-2">[<img src=images/U2020.jpg border=0>]</a></sup> For readers into such things, the number of backtracks done on a string of length <span class="docEmphasis">n</span> is 2<sup><span class="docEmphasis">n+1</span></sup>. The number of individual tests is 2<sup><span class="docEmphasis">n+1</span></sup>+2<sup><span class="docEmphasis">n</span></sup>.</p></blockquote>
<p class="docText">"Ah," you might think, "but a POSIX NFA is not all that common. I know my tool uses a Traditional NFA, so I'm OK." Well, the major difference between a POSIX and Traditional NFA is that the latter stops at the first full match. If there is no full match to be had, even a Traditional NFA must test every possible combination before it finds that out. Even in the short "<tt>No&#8226;\"match\"&#8226;here</tt> example from the previous answer block, 8,192 combinations must be tested before the failure can be reported.</p>
<p class="docText">When the regex engine crunches away on one of these neverending matches, the tool just seems to "lock up." The first time I experienced this, I thought I'd discovered a bug in the tool, but now that I understand it, this kind of expression is part of my regular-expression benchmark suite, used to indicate the type of engine a tool implements:</P>
<ul><li><p class="docList">If one of these regexes is fast even with a non-match, it's likely a DFA.</p></li><li><p class="docList">If it's fast only when there's a match, it's a Traditional NFA.</p></li><li><p class="docList">If it's slow all the time, it's a POSIX NFA.</p></li></ul>
<p class="docText">I used "likely" in the first bullet point because NFAs with advanced optimizations can detect and avoid these exponentially-painful neverending matches. (More on this later in this chapter &#9758; 250.) Also, we'll see a number of ways to augment or rewrite this expression such that it's fast for both matches and failures alike.</p>
<p class="docText">As the previous list indicates, at least in the absence of certain advanced optimizations, the relative performance of a regex like this can tell you about the type of regex engine. That's why a form of this regex is used in the "<a class="docLink" href="regex3-CHP-4-SECT-1.html#regex3-CHP-4-SECT-1.5">Testing the Engine Type</a>" section in <a class="docLink" href="regex3-CHP-4.html#regex3-CHP-4">Chapter 4</a> (&#9758; 146).</p>
<p class="docText">Certainly, not every little change has the disastrous effects we've seen with this example, but unless you know the work going on behind an expression, you will simply never know until you run into the problem. Toward that end, this chapter looks at the efficiency concerns and ramifications of a variety of examples. As with most things, a firm grasp of the underlying basic concepts is essential to an understanding of more advanced ideas, so before looking at ways to get around exponential matches, I'd like to review backtracking in explicit detail.</p>



<a href="7041536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-6-SECT-1.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-6-SECT-3.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>