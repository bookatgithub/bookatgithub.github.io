<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 7.2.&nbsp; Perl's Regex Flavor</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-7-SECT-1.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-7-SECT-3.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="regex3-CHP-7-SECT-2"></a>
<H3 id="title-IDA4WPJ" class="docSection1Title">7.2. Perl's Regex Flavor</H3>
<a name="IDX-CHP-7-2105"></a> 

<p class="docText"><a class="docLink" href="#regex3-CHP-7-TABLE-2">Table 7-2</a> on the facing page summarizes Perl's regex flavor. It used to be that Perl had many metacharacters that no other system supported, but over the years, other systems have adopted many of Perl's innovations. These common features are covered by the overview in <a class="docLink" href="regex3-CHP-3.html#regex3-CHP-3">Chapter 3</a>, but there are a few Perl-specific items discussed later in this chapter. (<a class="docLink" href="#regex3-CHP-7-TABLE-2">Table 7-2</a> has references to where each item is discussed.)</P>
<p class="docText">The following notes supplement the table:</P>
<ul><LI><p class="docList">&#10112;<tt>\b</tt> is a character shorthand for backspace only within a character class. Outside of a character class, <tt>\b</tt> matches a word boundary (&#9758;133).</p><p class="docList">Octal escapes accept two- and three-digit numbers.</p><p class="docList">The <img src=images/U2308.jpg border=0><tt>\x<span class="docEmphasis">num</span></tt><img src=images/U230B.jpg border=0> hex escape accepts two-digit numbers (and one-digit numbers, but with a warning if warnings are turned on). The <img src=images/U2308.jpg border=0><tt>\x{<span class="docEmphasis">num</span>}</tt><img src=images/U230B.jpg border=0> syntax accepts a hexadecimal number of any length.</P><a name="regex3-CHP-7-TABLE-2"></a><P><table cellspacing="0" FRAME="hsides" RULES="all" cellpadding="4" width="90%"><caption><h5 class="docTableTitle">Table 7-2. Overview of Perl's Regular-Expression Flavor</H5></caption><colgroup span="2"><col><col></colgroup><thead><TR><th class="thead" scope="col" align="left" colspan="2">
<p class="docText"><span class="docEmphStrong">Character Shorthands &#10112;</span></p></th></tr></thead><tr><TD class="docTableCell" align="left"><p class="docText">&#9758;115 (c)</P></td><td class="docTableCell" align="left"><p class="docText"><tt><span class="docEmphStrong">\a [\b] \e \f \n \r \t \</span></tt><span class="docEmphasis">octal</span> <tt><span class="docEmphStrong">\x</span></tt><span class="docEmphasis">hex</span> <tt><span class="docEmphStrong">\x{</span></tt><span class="docEmphasis">hex</span><tt><span class="docEmphStrong">} \c</span></tt><span class="docEmphasis">char</span></p></td></TR><tr><td class="docTableCell" align="left" colspan="2">
<p class="docText"><span class="docEmphStrong">Character Classes and Class-Like Constructs</span></P></td></tr><TR><td class="docTableCell" align="left"><p class="docText">&#9758;118</P></td><td class="docTableCell" align="left"><p class="docText">Classes: <span class="docEmphStrong">[</span>&#8943;<span class="docEmphStrong">] [^</span>&#8943;<span class="docEmphStrong">]</span> (may contain POSIX-like <tt><span class="docEmphStrong">[:alpha:]</span></tt> notation;&#9758;127)</p></td></tr><tr><td class="docTableCell" align="left"><p class="docText">&#9758;119</p></td><td class="docTableCell" align="left"><p class="docText">Any character except newline: <span class="docEmphasis">dot</span> (with <tt>/s</tt>, any character at all)</p></td></TR><tr><TD class="docTableCell" align="left"><p class="docText">&#9758;120</p></td><TD class="docTableCell" align="left"><p class="docText">Unicode combining sequence: <tt><span class="docEmphStrong">\X</span></tt></P></TD></TR><tr><TD class="docTableCell" align="left"><p class="docText">&#9758;120</p></td><TD class="docTableCell" align="left"><p class="docText">Exactly one byte (can be dangerous): <tt><span class="docEmphStrong">\C</span></tt></P></td></TR><TR><td class="docTableCell" align="left"><p class="docText">&#9758;120 (c)</p></td><TD class="docTableCell" align="left"><p class="docText">Class shorthands: &#10113; <tt><span class="docEmphStrong">\w \d \s \W \D \S</span></tt></P></td></tr><tr><td class="docTableCell" align="left"><p class="docText">&#9758;121 (c)</P></td><td class="docTableCell" align="left"><p class="docText">Unicode properties, scripts, and blocks: &#10114; <tt><span class="docEmphStrong">\p {</span></tt><span class="docEmphasis">Prop</span><tt><span class="docEmphStrong">} \P{</span></tt><span class="docEmphasis">Prop</span><tt><span class="docEmphStrong">}</span></tt></P></td></tr><TR><td class="docTableCell" align="left" colspan="2">
<p class="docText"><span class="docEmphStrong">Anchors and Other Zero-Width Tests</span></P></td></tr><tr><td class="docTableCell" align="left"><p class="docText">&#9758;129</p></td><td class="docTableCell" align="left"><p class="docText">Start of line/string: <tt>^ <span class="docEmphStrong">\A</span></tt></p></td></tr><tr><td class="docTableCell" align="left"><p class="docText">&#9758;129</P></td><TD class="docTableCell" align="left"><p class="docText">End of line/string: <tt><span class="docEmphStrong">$ \z \Z</span></tt></p></td></TR><TR><TD class="docTableCell" align="left"><p class="docText">&#9758;315</P></td><TD class="docTableCell" align="left"><p class="docText">End of previous match: <tt><span class="docEmphStrong">\G</span></tt></p></td></TR><TR><td class="docTableCell" align="left"><p class="docText">&#9758;133</P></TD><td class="docTableCell" align="left"><p class="docText">Word boundary:&#10115; <tt><span class="docEmphStrong">\b \B</span></tt></p></td></TR><TR><td class="docTableCell" align="left"><p class="docText">&#9758;133</p></td><td class="docTableCell" align="left"><p class="docText">Lookaround: &#10116; <tt><span class="docEmphStrong">(?= &#8943;) (?! &#8943;) (?&lt; =&#8943;) (?&lt; !&#8943;)</span></tt></P></td></tr><TR><td class="docTableCell" align="left" colspan="2">
<p class="docText"><span class="docEmphStrong">Comments and Mode Modifiers</span></p></TD></tr><TR><td class="docTableCell" align="left"><p class="docText">&#9758;135</p></td><td class="docTableCell" align="left"><p class="docText">Mode modifiers: &#10117; <tt><span class="docEmphStrong">(?</span></tt><span class="docEmphasis">mods-mods</span><tt><span class="docEmphStrong">)</span></tt> Modifiers allowed: <tt><span class="docEmphStrong">x s m i</span></tt> (&#9758;292)</p></td></tr><tr><td class="docTableCell" align="left"><p class="docText">&#9758;135</p></td><td class="docTableCell" align="left"><p class="docText">Mode-modified spans: <tt><span class="docEmphStrong">(?</span></tt><span class="docEmphasis">mods-mods</span><span class="docEmphStrong">:</span>&#8943;<tt><span class="docEmphStrong">)</span></tt></P></td></TR><tr><td class="docTableCell" align="left"><p class="docText">&#9758;136</P></TD><TD class="docTableCell" align="left"><p class="docText">Comments: <tt><span class="docEmphStrong">(?#</span></tt>&#8943;<tt><span class="docEmphStrong">) # &#8943;</span></tt> (with <tt>/x</tt>, also from '#' until newline or end of regex)</P></td></TR><tr><td class="docTableCell" align="left" colspan="2">
<p class="docText"><span class="docEmphStrong">Grouping, Capturing, Conditional, and Control</span></P></TD></tr><TR><TD class="docTableCell" align="left"><p class="docText">&#9758;137</p></td><td class="docTableCell" align="left"><p class="docText">Capturing parentheses: <tt><span class="docEmphStrong">(</span>&#8943;<span class="docEmphStrong">) \1 \2</span></tt> ...</P></TD></tr><tr><td class="docTableCell" align="left"><p class="docText">&#9758;137</p></TD><td class="docTableCell" align="left"><p class="docText">Grouping-only parentheses: <tt><span class="docEmphStrong">(?:</span>&#8943;)</tt></p></TD></tr><tr><TD class="docTableCell" align="left"><p class="docText">&#9758;139</p></TD><td class="docTableCell" align="left"><p class="docText">Atomic grouping: <tt><span class="docEmphStrong">(?&gt;&#8943;)</span></tt></p></td></tr><tr><td class="docTableCell" align="left"><p class="docText">&#9758;139</p></td><td class="docTableCell" align="left"><p class="docText">Alternation: |</p></td></tr><TR><td class="docTableCell" align="left"><p class="docText">&#9758;140</P></td><td class="docTableCell" align="left"><p class="docText">Conditional: <tt><span class="docEmphStrong">(?</span></tt> <span class="docEmphasis">if then</span> | <span class="docEmphasis">else</span><span class="docEmphStrong">)</span>  "if" can be embedded code, lookaround, or (<span class="docEmphasis">num</span>)</P></TD></TR><TR><td class="docTableCell" align="left"><p class="docText">&#9758;141</P></td><td class="docTableCell" align="left"><p class="docText">Greedy quantifiers: <tt><span class="docEmphStrong">* + ? {n} {n,} {x,y}</span></tt></P></TD></tr><TR><TD class="docTableCell" align="left"><p class="docText">&#9758;141</p></td><td class="docTableCell" align="left"><p class="docText">Lazy quantifiers: <tt><span class="docEmphStrong">*? +? ?? {n}? {n,}? {x,y}?</span></tt></P></TD></tr><tr><td class="docTableCell" align="left"><p class="docText">&#9758;327</p></TD><td class="docTableCell" align="left"><p class="docText">Embedded code: <tt><span class="docEmphStrong">(?{</span> &#8943;<span class="docEmphStrong">})</span></tt></p></TD></tr><tr><TD class="docTableCell" align="left"><p class="docText">&#9758;327</p></TD><td class="docTableCell" align="left"><p class="docText">Dynamic regex: <tt><span class="docEmphStrong">(??</span> {&#8943;<span class="docEmphStrong">})</span></tt></p></td></tr><tr><td class="docTableCell" align="left" colspan="2">
<p class="docText"><span class="docEmphStrong">In Regex Literals Only</span></p></td></tr><tr><td class="docTableCell" align="left"><p class="docText">&#9758;289 (c)</p></TD><td class="docTableCell" align="left"><p class="docText">Variable interpolation: <tt><span class="docEmphStrong">$</span></tt><span class="docEmphasis">name</span> <tt><span class="docEmphStrong">@</span></tt><span class="docEmphasis">name</span></P></td></tr><TR><TD class="docTableCell" align="left"><p class="docText">&#9758;290 (c)</P></TD><td class="docTableCell" align="left"><p class="docText">Fold next character's case: <tt><span class="docEmphStrong">\l \u</span></tt></P></td></tr><TR><TD class="docTableCell" align="left"><p class="docText">&#9758;290 (c)</p></TD><TD class="docTableCell" align="left"><p class="docText">Case-folding span: <tt><span class="docEmphStrong">\U \L</span></tt> ... <tt><span class="docEmphStrong">\E</span></tt></p></td></tr><TR><TD class="docTableCell" align="left"><p class="docText">&#9758;290 (c)</p></td><td class="docTableCell" align="left"><p class="docText">Literal-text span: <tt><span class="docEmphStrong">\Q</span></tt> ... <tt><span class="docEmphStrong">\E</span></tt></p></TD></tr><tr><TD class="docTableCell" align="left"><p class="docText">&#9758;290 (c)</p></td><TD class="docTableCell" align="left"><p class="docText">Named Unicode character: <tt><span class="docEmphStrong">\N{</span></tt><span class="docEmphasis">name</span><tt><span class="docEmphStrong">}</span></tt> optional; see page 290</p></TD></tr><tr><td class="docTableCell" align="left" colspan="2">
<p class="docText">(c)  may also be used within a character class &#10112;&#183;&#10117; see text</p></td></tr></table></p><br></li><li><p class="docList">&#10113;\<tt>w</tt>, <tt>\d</tt>, <tt>\s</tt>, etc., fully support Unicode.<a name="IDX-CHP-7-2107"></a> 
</p><p class="docList">Perl's<a name="IDX-CHP-7-2108"></a> 
<a name="IDX-CHP-7-2109"></a> 
<a name="IDX-CHP-7-2110"></a> 
<a name="IDX-CHP-7-2111"></a> 
<a name="IDX-CHP-7-2112"></a> 
<a name="IDX-CHP-7-2113"></a> 
<a name="IDX-CHP-7-2114"></a> 
<a name="IDX-CHP-7-2115"></a> 
<a name="IDX-CHP-7-2116"></a> 
<a name="IDX-CHP-7-2117"></a> 
<a name="IDX-CHP-7-2118"></a> 
<a name="IDX-CHP-7-2119"></a> 
<a name="IDX-CHP-7-2120"></a> 
<a name="IDX-CHP-7-2121"></a> 
<a name="IDX-CHP-7-2122"></a> 
<a name="IDX-CHP-7-2123"></a> 
<a name="IDX-CHP-7-2124"></a> 
<a name="IDX-CHP-7-2125"></a> 
<a name="IDX-CHP-7-2126"></a> 
<a name="IDX-CHP-7-2127"></a> 
<a name="IDX-CHP-7-2128"></a> 
<a name="IDX-CHP-7-2129"></a> 
<a name="IDX-CHP-7-2130"></a> 
<a name="IDX-CHP-7-2131"></a> 
<a name="IDX-CHP-7-2132"></a> 
<a name="IDX-CHP-7-2133"></a> 
<a name="IDX-CHP-7-2134"></a> 
<a name="IDX-CHP-7-2135"></a> 
<a name="IDX-CHP-7-2136"></a> 
 <tt>\s</tt> does not match an ASCII vertical tab character (&#9758;115).</p></LI><li><p class="docList">&#10114;Perl's Unicode support is for Unicode Version 4.1.0.</P><p class="docList">Unicode Scripts are supported. Script and property names may have the '<tt>Is</tt>' prefix, but they don't require it (&#9758;125). Block names may have the '<tt>In</tt>' prefix, but require it only when a block name conflicts with a script name.</p><p class="docList">The <img src=images/U2308.jpg border=0><tt>\p{L&amp;}</tt><img src=images/U230B.jpg border=0> pseudo-property is supported, as well as <img src=images/U2308.jpg border=0><tt>\p{Any}</tt><img src=images/U230B.jpg border=0>,<a name="IDX-CHP-7-2137"></a> 
 <img src=images/U2308.jpg border=0><tt>\p{All}</tt><img src=images/U230B.jpg border=0>,<a name="IDX-CHP-7-2138"></a> 
 <img src=images/U2308.jpg border=0><tt>\p{Assigned}</tt><img src=images/U230B.jpg border=0>,<a name="IDX-CHP-7-2139"></a> 
 and <img src=images/U2308.jpg border=0><tt>\p{Unassigned}</tt><img src=images/U230B.jpg border=0>.<a name="IDX-CHP-7-2140"></a> 
</p><p class="docList">The long property names like <img src=images/U2308.jpg border=0><tt>\p{Letter}</tt><img src=images/U230B.jpg border=0><a name="IDX-CHP-7-2141"></a> 
<a name="IDX-CHP-7-2142"></a> 
<a name="IDX-CHP-7-2143"></a> 
 are supported. Names may have a space, underscore, or nothing between the word parts of a name (for example <img src=images/U2308.jpg border=0><tt>\p{Lowercase_Letter}</tt><img src=images/U230B.jpg border=0> may also be written as <img src=images/U2308.jpg border=0><tt>\p{LowercaseLetter}</tt><img src=images/U230B.jpg border=0> or <img src=images/U2308.jpg border=0><tt>\p{Lowercase grey.g Letter}</tt><img src=images/U230B.jpg border=0>.) For consistency, I recommend using the long names as shown in the table on page 123.</P><p class="docList"><img src=images/U2308.jpg border=0><tt>\p{^&#8943; }</tt><img src=images/U230B.jpg border=0> is the same as <img src=images/U2308.jpg border=0><tt>\P{&#8943;}</tt><img src=images/U230B.jpg border=0>.</P></LI><LI><p class="docList">&#10115;Word boundaries fully support Unicode.</p></LI><li><p class="docList">&#10116;Lookaround may have capturing parentheses.</p><p class="docList">Lookbehind is limited to subexpressions that always match fixed-width text.</P></LI><li><p class="docList">&#10117;The <tt>/x</tt><a name="IDX-CHP-7-2144"></a> 
<a name="IDX-CHP-7-2145"></a> 
 modifier recognizes only ASCII whitespace. The <tt>/m</tt> modifier affects only newlines, and not the full list of Unicode line terminators.</P><p class="docList">The <tt>/i</tt> modifier works properly with Unicode.</P></li></ul>
<p class="docText">Not all metacharacters are created equal. Some "regex metacharacters" are not even supported by the regex engine, but by the preprocessing Perl gives to regex literals.</p>
<a name="regex3-CHP-7-SECT-2.1"></a>
<H4 id="title-IDAVYEGL" class="docSection2Title">7.2.1. Regex Operands and Regex Literals</H4>
<a name="IDX-CHP-7-2146"></a> 
<a name="IDX-CHP-7-2147"></a> 
<a name="IDX-CHP-7-2148"></a> 
<a name="IDX-CHP-7-2149"></a> 
<a name="IDX-CHP-7-2150"></a> 
<a name="IDX-CHP-7-2151"></a> 
<a name="IDX-CHP-7-2152"></a> 
<a name="IDX-CHP-7-2153"></a> 
<a name="IDX-CHP-7-2154"></a> 

<p class="docText">The final items in <a class="docLink" href="#regex3-CHP-7-TABLE-2">Table 7-2</a> are marked "regex literals only." <span class="docEmphasis">A regex literal</span><a name="IDX-CHP-7-2155"></a> 
 is the "<span class="docEmphasis">regex</span>" part of <span class="docEmphStrong"><tt>m/</tt><span class="docEmphasis">regex/</span></span>, and while casual conversation refers to that as "the regular expression," the part between the '<tt>/</tt>' delimiters is actually parsed using its own unique rules. In Perl jargon, a regex literal is treated as a "regex-aware doublequoted string," and it's the result of that processing that's passed to the regex engine. This regex-literal processing offers special functionality in building the regular expression.</p>
<p class="docText">For example, a regex literal offers <span class="docEmphasis">variable interpolation</span>.<a name="IDX-CHP-7-2156"></a> 
 If the variable <tt>$num</tt> contains 20, the code <tt>m/:.{$num}:/</tt> produces the regex <img src=images/U2308.jpg border=0><tt>:.{20}:</tt><img src=images/U230B.jpg border=0>. This way, you can build regular expressions on the fly. Another service given to regex literals is automatic case folding, as with <tt>\U&#8943;\E</tt> to ensure letters are uppercased. As a silly example, <tt>m/abc\Uxyz\E/</tt> creates the regex <img src=images/U2308.jpg border=0><tt>abcXYZ</tt><img src=images/U230B.jpg border=0>. This example is silly because if someone wanted <img src=images/U2308.jpg border=0><tt>abcXYZ</tt><img src=images/U230B.jpg border=0> they could just type <tt>m/abcXYZ/</tt> directly, but its value becomes apparent when combined with variable interpolation: if the variable <tt>$tag</tt> contains the string "<tt>title</tt>", the code <tt>m{ &lt;/</tt><img border="0" alt="" width="80" height="16" SRC="images/regex3_u0701.jpg"><tt>&gt;}</tt> produces <img src=images/U2308.jpg border=0><tt>&lt;/<img border="0" alt="" width="50" height="14" SRC="images/regex3_u0702.jpg">&gt;</tt><img src=images/U230B.jpg border=0></p>
<p class="docText">What's the opposite of a regex literal? You can also use a string (or any expression) as a regex operand. For example:</p>
<pre>
    $MatchField = "^Subject:"; # <span class="docEmphasis">Normal string assignment</span>
      <img src=images/U22EE.jpg border=0>
    if ($text =~ $MatchField) {
         <img src=images/U22EE.jpg border=0>
</pre><br>

<p class="docText">When <tt>$MatchField</tt> is used as an operand of <span class="docEmphStrong">=~</span>, its contents are interpreted as a regular expression. That "interpretation" is as a plain vanilla regex, so variable interpolation and things like <tt>\Q&#8943;\E</tt> are not supported as they would be for a regex literal.</P>
<p class="docText">Here's something interesting: if you replace</p>
<pre>
    $text =~ $MatchField
</pre><br>

<p class="docText">with</P>
<pre>
    $text =~ <span class="docEmphStrong">m</span>/$MatchField/
</pre><br>

<p class="docText">the result is exactly the same. In this case, there's a regex literal, but it's composed of just one thingthe interpolation of the variable <tt>$MatchField</tt>. The <span class="docEmphasis">contents</span> of a variable interpolated by a regex literal are <span class="docEmphasis">not</span> treated as a regex literal, and so things like <tt><span class="docEmphStrong">\U&#8943;\E</span></tt> and <span class="docEmphasis">$var</span> within the value interpolated are <span class="docEmphasis">not</span> recognized. (Details on exactly how regex literals are processed are covered on page 292.)</p>
<p class="docText">If used more than once during the execution of a program, there are important efficiency issues with regex operands that are raw strings, or that use variable interpolation. These are discussed starting on page 348.</P>
<a name="regex3-CHP-7-SECT-2.1.1"></a>
<h5 id="title-IDAX3EGL" class="docSection3Title">7.2.1.1. Features supported by regex literals</H5>
<a name="IDX-CHP-7-2157"></a> 
<a name="IDX-CHP-7-2158"></a> 
<a name="IDX-CHP-7-2159"></a> 
<a name="IDX-CHP-7-2160"></a> 
<a name="IDX-CHP-7-2161"></a> 
<a name="IDX-CHP-7-2162"></a> 
<a name="IDX-CHP-7-2163"></a> 
<a name="IDX-CHP-7-2164"></a> 
<a name="IDX-CHP-7-2165"></a> 
<a name="IDX-CHP-7-2166"></a> 
<a name="IDX-CHP-7-2167"></a> 
<a name="IDX-CHP-7-2168"></a> 
<a name="IDX-CHP-7-2169"></a> 
<a name="IDX-CHP-7-2170"></a> 

<p class="docText">The following features are offered by regex literals:</p>
<ul><li><p class="docList"><span class="docEmphStrong">Variable Interpolation</span> Variable references beginning with <tt><span class="docEmphStrong">$</span></tt> and <tt><span class="docEmphStrong">@</span></tt> are interpolated into the value to use for the regex. Those beginning with <tt>$</tt> insert a simple scalar value. Those beginning with <tt>@</tt> insert an array or array slice into the value, with elements separated by spaces (actually, by the contents of the <tt><span class="docEmphStrong">$"</span></tt> variable, which defaults to a space).</p><p class="docList">In Perl, '<tt>%</tt>' introduces a hash variable, but inserting a hash into a string doesn't make much sense, so interpolation via <tt>%</tt> is not supported.</p></li><li><p class="docList"><span class="docEmphStrong">Named Unicode Characters</span> If you have "<tt><span class="docEmphStrong">use charnames<a name="IDX-CHP-7-2171"></a> 
<a name="IDX-CHP-7-2172"></a> 
 ':full';</span></tt>" in the program, you can refer to Unicode characters by name using the <tt>\N{</tt><span class="docEmphasis">name</span><tt>}</tt> sequence. For instance, <tt>\N{LATIN SMALL LETTER SHARP S}</tt><a name="IDX-CHP-7-2173"></a> 
<a name="IDX-CHP-7-2174"></a> 
 matches "<tt>&szlig;</tt>".<a name="IDX-CHP-7-2175"></a> 
<a name="IDX-CHP-7-2176"></a> 
 The list of Unicode characters that Perl understands can be found in Perl's <span class="docEmphasis">unicore</span><a name="IDX-CHP-7-2177"></a> 
 directory, in the file <span class="docEmphasis">UnicodeData.txt</span>.<a name="IDX-CHP-7-2178"></a> 
 This snippet shows the file's location:</p><pre>
    use Config;<a name="IDX-CHP-7-2179"></a> 

    print "$Config{privlib}/unicore/UnicodeData.txt\n";
</pre><br>
<p class="docList">It's easy to forget "<tt><span class="docEmphStrong">use charnames ':full';</span></tt>", or the colon before '<tt>full</tt>', but if you do, <tt>\N{&#8943;}</tt> won't work. Also, <tt>\N{&#8943;}</tt> doesn't work if you use regex overloading, described later in this list.</p></li><li><p class="docList"><span class="docEmphStrong">Case-Folding Prefix</span> The special sequences <tt><span class="docEmphStrong">\l</span></tt><a name="IDX-CHP-7-2180"></a> 
<a name="IDX-CHP-7-2181"></a> 
 and <tt><span class="docEmphStrong">\u</span></tt><a name="IDX-CHP-7-2182"></a> 
<a name="IDX-CHP-7-2183"></a> 
 cause the character that follows to be made lowercase and uppercase, respectively. This is usually used just before variable interpolation to force the case on the first character brought in from the variable. For example, if the variable <tt>$title</tt> contains "<tt>mr.</tt>", the code <tt>m/&#8943; \u$title&#8943;/</tt> creates the regex <img src=images/U2308.jpg border=0><tt>&#8943;Mr.&#8943;</tt><img src=images/U230B.jpg border=0>. The same functionality is provided by the Perl functions <tt>lcfirst()</tt><a name="IDX-CHP-7-2184"></a> 
 and <tt>ucfirst()</tt>.<a name="IDX-CHP-7-2185"></a> 
</P></li><LI><p class="docList"><span class="docEmphStrong">Case-Folding Span</span> The special sequences <tt><span class="docEmphStrong">\L</span></tt> and <tt><span class="docEmphStrong">\U</span></tt> cause characters that follow to be made lowercase and uppercase, respectively, until the end of the regex literal, or until the special sequence <tt><span class="docEmphStrong">\E</span></tt>.<a name="IDX-CHP-7-2186"></a> 
<a name="IDX-CHP-7-2187"></a> 
 For example, with the same <tt>$title</tt> as before, the code <tt>m/&#8943;\ U$title\E&#8943;/</tt> creates the regex <img src=images/U2308.jpg border=0><tt>&#8943;MR.&#8943;</tt><img src=images/U230B.jpg border=0>. The same functionality is provided by the Perl functions <tt>lc()</tt><a name="IDX-CHP-7-2188"></a> 
 and <tt>uc()</tt>.<a name="IDX-CHP-7-2189"></a> 
</p><p class="docList">You can combine a case-folding prefix with a case-folding span: the code <tt>m/&#8943;\L\u $title\E&#8943;/</tt> ensures <img src=images/U2308.jpg border=0><tt>&#8943;Mr.&#8943;</tt><img src=images/U230B.jpg border=0> regardless of the original capitalization.</p></LI><LI><p class="docList"><span class="docEmphStrong">Literal-Text Span</span> The sequence <tt>\Q</tt> "quotes" <span class="docEmphasis">regex</span> metacharacters (i.e., puts a backslash in front of them) until the end of the string, or until a <tt><span class="docEmphStrong">\E</span></tt> sequence. It quotes <span class="docEmphasis">regex</span> metacharacters, but not quote <span class="docEmphasis">regex-literal</span> items like variable interpolation, <tt><span class="docEmphStrong">\U</span></tt>, and, of course, the <tt><span class="docEmphStrong">\E</span></tt> itself. Oddly, it also does not quote backslashes that are part of an unknown sequence, such as in <tt>\F</tt> or <tt>\H</tt>. Even with <tt>\Q&#8943;\E</tt>,<a name="IDX-CHP-7-2190"></a> 
<a name="IDX-CHP-7-2191"></a> 
 such sequences still produce "unrecognized escape" warnings.</P><p class="docList">In practice, these restrictions are not that big a drawback, as <tt>\Q&#8943; \E</tt> is normally used to quote interpolated text, where it properly quotes <span class="docEmphasis">all</span> metacharacters. For example, if <tt>$title</tt> contains "<tt>Mr.</tt>", the code <tt>m/&#8943;\Q$title\E&#8943;/</tt> creates the regex <img src=images/U2308.jpg border=0><tt>&#8943;Mr\.&#8943;</tt><img src=images/U230B.jpg border=0>, which is what you'd want if you wanted to match the <span class="docEmphasis">text</span> in <tt>$title</tt>, rather than the <span class="docEmphasis">regex</span> in <tt>$title</tt>.</P><p class="docList">This is particularly useful if you want to incorporate user input into a regex. For example, <tt>m/\Q$UserInput\E/i</tt> does a case-insensitive search for the characters (as a string, not a regex) in <tt>$UserInput</tt>.</p><p class="docList">The <tt>\Q&#8943;\E</tt> functionality is also provided by the Perl function <tt>quotemeta()</tt>.</P></li><li><p class="docList"><span class="docEmphStrong">Overloading</span> You can pre-process the literal parts of a regex literal in any way you like with <span class="docEmphasis">overloading</span>.<a name="IDX-CHP-7-2192"></a> 
 It's an interesting concept, but one with severe limitations as currently implemented. Overloading is covered in detail, starting on page 341.</P></LI></ul>

<a name="regex3-CHP-7-SECT-2.1.2"></a>
<H5 id="title-IDACKFGL" class="docSection3Title">7.2.1.2. Picking your own regex delimiters</H5>
<a name="IDX-CHP-7-2193"></a> 

<p class="docText">One of the most bizarre (yet, most useful) aspects of Perl's syntax is that you can pick your own delimiters for regex literals. The traditional delimiter is a forward slash, as with <tt>m/&#8943;/</tt>, <tt>s/&#8943;/&#8943;/</tt>, and <tt>qr/ &#8943;/</tt>, but you can actually pick any nonalphanumeric, non-whitespace character. Some commonly used examples include:</p>
<pre>
    m!&#8943;!             m{&#8943;}
    m,&#8943;,             m&lt;&#8943;&gt;
    s|&#8943;|&#8943;|    m[&#8943;]
    qr#&#8943;#            m(&#8943;)
</pre><br>

<p class="docText">The four on the right are among the special-case delimiters:</p>
<UL><LI><p class="docList">The four examples on the right side of the list above have different opening and closing delimiters, and may be nested (that is, may contain copies of the delimiters so long as the opens and closes pair up properly). Because parentheses and square brackets are so prevalent in regular expressions, <tt>m(&#8943;)</tt> and <tt>m[&#8943;]</tt> are probably not as appealing as the others. In particular, with the <tt>/x</tt> modifier, something such as the following becomes possible:</p><pre>
    m{
       <span class="docEmphasis">regex</span>  # comments
       <span class="docEmphasis">here</span>  # here
    }x;
</pre><br>
<p class="docList">If one of these pairs is used for the regex part of a substitute, another pair (the same as the first, or, if you like, different) is used for the replacement string. Examples include:</p><pre>
    s{&#8943;}{&#8943;}
    s{&#8943;}!&#8943;!
    s&lt;&#8943;&gt;(&#8943;)
    s[&#8943;]/&#8943;/
</pre><br>
<p class="docList">If this is done, you can put whitespace and comments between the two pairs of delimiters. More on the substitution operator's replacement string operand can be found on page 319.</P></li><li><p class="docList">For the match operator only, a question mark as a delimiter has a little-used special meaning (suppress additional matches) discussed in the section on the match operator (&#9758;308).</P></li><li><p class="docList">As mentioned on page 288, a regex literal is parsed like a "regex-aware double-quoted string." If a single quote is used as the delimiter, however, those features are inhibited. With <tt>m'&#8943;'</tt>, variables are <span class="docEmphasis">not</span> interpolated, and the constructs that modify text on the fly <tt>(e.g., \ Q&#8943;\E)</tt> do not work, nor does the <tt>\N{&#8943;}</tt> construct. <tt>m'&#8943;'</tt> might be convenient for a regex that has many <tt>@</tt>, to save having to escape them.</P></li></UL>
<p class="docText">For the match operator only, the <tt>m</tt> may be omitted if the delimiter is a slash or a question mark. That is,</p>
<pre>
    $text =~ m/&#8943;/;
    $text =~  /&#8943;/;
</pre><br>

<p class="docText">are the same. My preference is to always explicitly use the <tt>m</tt>.</p>


<a name="regex3-CHP-7-SECT-2.2"></a>
<h4 id="title-IDAWMFGL" class="docSection2Title">7.2.2. How Regex Literals Are Parsed</h4>
<a name="IDX-CHP-7-2194"></a> 
<a name="IDX-CHP-7-2195"></a> 
<a name="IDX-CHP-7-2196"></a> 
<a name="IDX-CHP-7-2197"></a> 
<a name="IDX-CHP-7-2198"></a> 
<a name="IDX-CHP-7-2199"></a> 
<a name="IDX-CHP-7-2200"></a> 
<a name="IDX-CHP-7-2201"></a> 
<a name="IDX-CHP-7-2202"></a> 
<a name="IDX-CHP-7-2203"></a> 
<a name="IDX-CHP-7-2204"></a> 
<a name="IDX-CHP-7-2205"></a> 
<a name="IDX-CHP-7-2206"></a> 
<a name="IDX-CHP-7-2207"></a> 
<a name="IDX-CHP-7-2208"></a> 
<a name="IDX-CHP-7-2209"></a> 

<p class="docText">For the most part, one "just uses" the regex-literal features just discussed, without the need to understand the exact details of how Perl<a name="IDX-CHP-7-2210"></a> 
 converts them to a raw regular expression. Perl is very good at being intuitive in this respect, but there are times when a more detailed understanding can help. The following lists the order in which processing appears to happen:</p>
<ul><li><p class="docList"><span class="docEmphasis">1</span>. The closing delimiter is found, and the modifiers<a name="IDX-CHP-7-2211"></a> 
 (such as <tt>/i</tt>, etc.) are read. The rest of the processing then knows if it's in <tt>/x</tt> mode.</p></li><li><p class="docList"><span class="docEmphasis">2</span>. Variables are interpolated.</p></LI><li><p class="docList"><span class="docEmphasis">3</span>. If regex overloading<a name="IDX-CHP-7-2212"></a> 
 is in effect, each part of the literal is given to the overload routine for processing. Parts are separated by interpolated variables; the values interpolated are not made available to overloading.</P><p class="docList">If regex overloading is not in effect, <tt>\N{&#8943;}</tt> sequences are processed.</p></li><LI><p class="docList"><span class="docEmphasis">4</span>. Case-folding constructs (e.g., <tt>\Q&#8943;\E</tt>) are applied.</P></LI><LI><p class="docList"><span class="docEmphasis">5</span>. The result is presented to the regex engine.</p></LI></ul>
<p class="docText">This describes how the processing appears to the programmer, but in reality, the internal processing done by Perl is quite complicated. Even step #2 must understand the regular-expression metacharacters, so as not to, for example, treat the underlined portion of <img src=images/U2308.jpg border=0><tt>this<img border="0" alt="" width="16" height="14" SRC="images/regex3_u0703.jpg">that$</tt><img src=images/U230B.jpg border=0> as a variable reference.</p>

<a name="regex3-CHP-7-SECT-2.3"></a>
<H4 id="title-IDAWRFGL" class="docSection2Title">7.2.3. Regex Modifiers</H4>
<p class="docText">Perl's regex operators allow <span class="docEmphasis">regex modifiers</span>, placed after the closing delimiter of the regex literal (like the <tt>i</tt> in <tt>m/&#8943;/<span class="docEmphStrong">i</span>, s/&#8943;/&#8943;/<span class="docEmphStrong">i</span></tt>, <tt>or qr/&#8943;/<span class="docEmphStrong">i</span></tt>). There are five core modifiers that all regex operators support, shown in <a class="docLink" href="#regex3-CHP-7-TABLE-3">Table 7-3</a>.</p>
<p class="docText">The first four, described in <a class="docLink" href="regex3-CHP-3.html#regex3-CHP-3">Chapter 3</a>, can also be used within a regex itself as a mode-modifier (&#9758;135) or mode-modified span (&#9758;135). When used both within</P>
<a name="regex3-CHP-7-TABLE-3"></a><P><table cellspacing="0" FRAME="hsides" RULES="all" cellpadding="4" width="100%"><caption><h5 class="docTableTitle">Table 7-3. The Core Modifiers Available to All Regex Operators</h5></caption><colgroup span="3"><col><col><col></colgroup><thead></thead><tr><TD class="docTableCell" align="left"><p class="docText"><tt>/i</tt></P></td><td class="docTableCell" align="left"><p class="docText">&#9758;110</p></td><TD class="docTableCell" align="left"><p class="docText">Ignore letter case during match</p></td></TR><tr><td class="docTableCell" align="left"><p class="docText"><tt>/x</tt></P></td><TD class="docTableCell" align="left"><p class="docText">&#9758;111</p></td><td class="docTableCell" align="left"><p class="docText">Free-spacing and comments regex mode</p></td></tr><tr><td class="docTableCell" align="left"><p class="docText"><tt>/s</tt></p></td><td class="docTableCell" align="left"><p class="docText">&#9758;111</p></TD><td class="docTableCell" align="left"><p class="docText">Dot-matches-all match mode</P></td></tr><TR><TD class="docTableCell" align="left"><p class="docText"><tt>/m</tt></P></TD><td class="docTableCell" align="left"><p class="docText">&#9758;112</P></td><td class="docTableCell" align="left"><p class="docText">Enhanced line anchor match mode</P></TD></tr><TR><TD class="docTableCell" align="left"><p class="docText"><tt>/o</tt></p></td><td class="docTableCell" align="left"><p class="docText">&#9758;348</P></TD><td class="docTableCell" align="left"><p class="docText">Compile only once</p></td></tr></table></P><br>
<p class="docText">the regex, and as part of one of the match operators, the in-regex versions take precedence for the part of the regex they control. (Another way to look at it is that once a modifier has been applied to some part of a regex, nothing can "unmodify" that part of a regex.)</p>
<p class="docText">The fifth core modifier, <tt>/o</tt>, has mostly to do with efficiency. It is discussed later in this chapter, starting on page 348.</P>
<p class="docText">If you need more than one modifier, group the letters together and place them in any order after the closing delimiter, whatever it might be. <sup class="docFootnote"><a class="docLink" href="#regex3-CHP-7-FN-3">[<img src=images/U2020.jpg border=0>]</a></sup> Keep in mind that the slash is not part of the modifieryou can write <tt><span class="docEmphStrong">m/</span>&lt;title&gt;<span class="docEmphStrong">/i</span></tt> as <tt><span class="docEmphStrong">m|</span>&lt;title&gt;<span class="docEmphStrong">|i</span></tt>, or perhaps <tt><span class="docEmphStrong">m{</span>&lt;title&gt;<span class="docEmphStrong">}i</span></tt>, or even <tt><span class="docEmphStrong">m&lt;</span>&lt;title&gt;<span class="docEmphStrong">&gt;i</span></tt>. Nevertheless, when discussing modifiers, it's common to always write them with a slash, e.g., "the <tt>/i</tt> modifier."</p><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-7-FN-3">[<img src=images/U2020.jpg border=0>]</a></sup> Because modifiers can appear in any order, a large portion of a programmer's time is spent adjusting the order to achieve maximum cuteness. For example, <tt>learn/by/osmosis</tt><a name="IDX-CHP-7-2213"></a> 
 is valid code (assuming you have a function called <tt>learn</tt>). The <tt>osmosis</tt> are the modifiers. Repeating modifiers is allowed, but meaningless (except for the substitution-operator's <tt>/e</tt> modifier, discussed later).</p></blockquote>


<a href="7041536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-7-SECT-1.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-7-SECT-3.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>