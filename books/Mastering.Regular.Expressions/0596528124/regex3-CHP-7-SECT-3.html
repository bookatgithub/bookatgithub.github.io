<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 7.3.&nbsp; Regex-Related Perlisms</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-7-SECT-2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-7-SECT-4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="regex3-CHP-7-SECT-3"></a>
<H3 id="title-IDAHXOEQ" class="docSection1Title">7.3. Regex-Related Perlisms</H3>
<a name="IDX-CHP-7-2214"></a> 
<a name="IDX-CHP-7-2215"></a> 
<a name="IDX-CHP-7-2216"></a> 

<p class="docText">A variety of general Perl concepts pertain to our study of regular expressions. The next few sections discuss:</P>
<UL><li><p class="docList"><span class="docEmphStrong">Context</span> An important concept in Perl is that many functions and operators respond to the <span class="docEmphasis">context</span> they're used in. For example, Perl expects a scalar value as the conditional of a <tt>while</tt> loop, but a list of values as the arguments to a <tt>print</tt> statement. Since Perl allows expressions to "respond" to the context in which they're in, identical expressions in each case might produce wildly different results.</P></li><li><p class="docList"><span class="docEmphStrong">Dynamic Scope</span> Most programming languages support the concept of local and global variables, but Perl provides an additional twist with something known as <span class="docEmphasis">dynamic scoping</span>. Dynamic scoping temporarily "protects" a global variable by saving a copy of its value and automatically restoring it later. It's an intriguing concept that's important for us because it affects <tt>$1</tt> and other match-related variables.</P></LI></ul>
<a name="regex3-CHP-7-SECT-3.1"></a>
<H4 id="title-IDA5YOEQ" class="docSection2Title">7.3.1. Expression Context</H4>
<a name="IDX-CHP-7-2217"></a> 
<a name="IDX-CHP-7-2218"></a> 
<a name="IDX-CHP-7-2219"></a> 
<a name="IDX-CHP-7-2220"></a> 
<a name="IDX-CHP-7-2221"></a> 
<a name="IDX-CHP-7-2222"></a> 
<a name="IDX-CHP-7-2223"></a> 

<p class="docText">The notion of <span class="docEmphasis">context</span><a name="IDX-CHP-7-2224"></a> 
<a name="IDX-CHP-7-2225"></a> 
 is important throughout Perl,<a name="IDX-CHP-7-2226"></a> 
 and in particular, to the match operator. An expression might find itself in one of three contexts, <span class="docEmphasis">list</span>,<a name="IDX-CHP-7-2227"></a> 
 <span class="docEmphasis">scalar</span>,<a name="IDX-CHP-7-2228"></a> 
 or <span class="docEmphasis">void</span>, indicating the type of value expected from the expression. Not surprisingly, a <span class="docEmphasis">list context</span><a name="IDX-CHP-7-2229"></a> 
 is one where a list of values is expected of an expression. A <span class="docEmphasis">scalar context</span><a name="IDX-CHP-7-2230"></a> 
 is one where a single value is expected. These two are very common and of great interest to our use of regular expressions. <span class="docEmphasis">Void context</span> is one in which no value is expected.</p>
<p class="docText">Consider the two assignments:</p>
<pre>
    $s = expression one;
    @a = expression two;
</pre><br>

<p class="docText">Because <tt>$s</tt> is a simple scalar variable (it holds a single value, not a list), it expects a simple scalar value, so the first expression, whatever it may be, finds itself in a scalar context. Similarly, because <tt>@a</tt> is an array variable and expects a list of values, the second expression finds itself in a list context. Even though the two expressions might be exactly the same, they might return completely different values, and cause completely different side effects while they're at it. Exactly what happens depends on each expression.</P>
<p class="docText">For example, the <tt>localtime</tt><a name="IDX-CHP-7-2231"></a> 
 function, if used in a list context, returns a list of values representing the current year, month, date, hour, etc. But if used in a scalar context, it returns a textual version of the current time along the lines of '<tt>Mon Jan 20 22:05:15 2003</tt>'.</P>
<p class="docText">As another example, an <tt>I/O</tt> operator such as <tt>&lt;MYDATA&gt;</tt> returns the next line of the file in a scalar context, but returns a list of all (remaining) lines in a list context.</p>
<p class="docText">Like <tt>localtime</tt> and the I/O operator, many Perl constructs respond to their context. The regex operators do as well  the match operator <tt>m/&#8943;/</tt>, for example, sometimes returns a simple true/false value, and sometimes a list of certain match results. All the details are found later in this chapter.</p>
<a name="regex3-CHP-7-SECT-3.1.1"></a>
<h5 id="title-IDAZ2OEQ" class="docSection3Title">7.3.1.1. Contorting an expression</h5>
<p class="docText">Not all expressions are natively context-sensitive, so Perl has rules about what happens when a general expression is used in a context that doesn't exactly match the type of value the expression normally returns. To make the square peg fit into a round hole, Perl "contorts" the value to make it fit. If a scalar value is returned in a list context, Perl makes a list containing the single value on the fly. Thus, <tt><span class="docEmphStrong">@a = 42</span></tt> is the same as <tt><span class="docEmphStrong">@a = (42)</span></tt>.</P>
<p class="docText">On the other hand, there's no general rule for converting a list to a scalar. If a literal list is given, such as with</p>
<pre>
    $var = ($this, &amp;is, 0xA, 'list');
</pre><br>

<p class="docText">the comma-operator returns the last element, '<tt>list</tt>', for <tt>$var</tt>. If an array is given, as with <tt><span class="docEmphStrong">$var = @array</span></tt>, the length of the array is returned.</P>
<p class="docText">Some words used to describe how other languages deal with this issue are <span class="docEmphasis">cast</span>, <span class="docEmphasis">promote</span>, <span class="docEmphasis">coerce</span>, and <span class="docEmphasis">convert</span>, but I feel they are a bit too consistent (boring?) to describe Perl's attitude in this respect, so I use "contort."</p>


<a name="regex3-CHP-7-SECT-3.2"></a>
<h4 id="title-IDAJ4OEQ" class="docSection2Title">7.3.2. Dynamic Scope and Regex Match Effects</H4>
<a name="IDX-CHP-7-2232"></a> 
<a name="IDX-CHP-7-2233"></a> 
<a name="IDX-CHP-7-2234"></a> 
<a name="IDX-CHP-7-2235"></a> 

<p class="docText">Perl's two types of storage (global and private variables) and its concept of <span class="docEmphasis">dynamic scoping</span> are important to understand in their own right, but are of particular interest to our<a name="IDX-CHP-7-2236"></a> 
 study of regular expressions because of how after-match information is made available to the rest of the program. The next sections describe these concepts, and their relation to regular expressions.</p>
<a name="regex3-CHP-7-SECT-3.2.1"></a>
<H5 id="title-IDAI5OEQ" class="docSection3Title">7.3.2.1. Global and private variables</h5>
<p class="docText">On a broad scale, Perl offers two types of variables: global and private. Private variables are declared using <tt>my(&#8943;)</tt>. Global variables are not declared, but just pop into existence when you use them. Global variables are always visible from anywhere and everywhere within the program, while private variables are visible, lexically, only to the end of their enclosing block. That is, the only Perl code that can directly access the private variable is the code that falls between the <span class="docEmphStrong"><tt>my</tt></span> declaration and the end of the block of code that encloses the <tt>my</tt>.</p>
<p class="docText">The use of global variables is normally discouraged, except for special cases, such as the myriad of special variables like <tt>$1</tt>, <tt>$_</tt>, and <tt>@ARGV</tt>. Regular user variables are global unless declared with <tt>my</tt>, even if they might "look" private. Perl allows the names of global variables to be partitioned into groups called <span class="docEmphasis">packages</span>, but the variables are still global. A global variable <tt>$Debug</tt> within the package <tt>Acme::Widget</tt> has a <span class="docEmphasis">fully qualified<a name="IDX-CHP-7-2237"></a> 
 name</span><a name="IDX-CHP-7-2238"></a> 
 of <tt>$Acme::Widget::Debug</tt>, but no matter how it's referenced, it's still the same global variable. If you <tt><span class="docEmphStrong">use strict;</span></tt>,<a name="IDX-CHP-7-2239"></a> 
<a name="IDX-CHP-7-2240"></a> 
 all (non-special) globals must either be referenced via fully-qualified names, or via a name declared with <tt>our</tt> (<tt>our</tt> declares a <span class="docEmphasis">name</span>, not a new variablesee the Perl documentation for details).</p>

<a name="regex3-CHP-7-SECT-3.2.2"></a>
<h5 id="title-IDAPBPEQ" class="docSection3Title">7.3.2.2. Dynamically scoped values</h5>
<a name="IDX-CHP-7-2241"></a> 
<a name="IDX-CHP-7-2242"></a> 
<a name="IDX-CHP-7-2243"></a> 
<a name="IDX-CHP-7-2244"></a> 
<a name="IDX-CHP-7-2245"></a> 
<a name="IDX-CHP-7-2246"></a> 

<p class="docText">Dynamic scoping is an interesting concept that few programming languages provide. We'll see the relevance to regular expressions soon, but in a nutshell, you can have Perl save a copy of the value of a global variable that you intend to modify within a block, and restore the original copy automatically at the time when the block ends. Saving a copy is called <span class="docEmphasis">creating a new dynamic scope</span>, or <span class="docEmphasis">localizing</span>.<a name="IDX-CHP-7-2247"></a> 
</p>
<p class="docText">One reason that you might want to do this is to temporarily update some kind of global state that's maintained in a global variable. Let's say that you're using a package, <tt>Acme::Widget</tt>, and it provides a debugging flag via the global variable <tt>$Acme ::Widget::Debug</tt>. You can temporarily ensure that debugging is turned on with code like:</p>
<pre>
     <img src=images/U22EE.jpg border=0>

    {
      local($Acme::Widget::Debug)<a name="IDX-CHP-7-2248"></a> 
 = 1; #  <span class="docEmphasis">Ensure it's turned on</span>
      # <span class="docEmphasis">work with</span> Acme::Widget <span class="docEmphasis">while debugging is on</span>
         <img src=images/U22EE.jpg border=0>

    }
      # $Acme::Widget::Debug <span class="docEmphasis">is now back to whatever it had been before</span>
        <img src=images/U22EE.jpg border=0>
</pre><br>

<p class="docText">It's that extremely ill-named function <tt><span class="docEmphasis">local</span></tt> that creates a new dynamic scope. Let me say up front that <span class="docEmphasis">the call to</span> <tt>local</tt> <span class="docEmphasis">does not create a new variable</span>. <tt>local</tt> is an action, not a declaration. Given a global variable, <tt>local</tt> does three things:</p>
<ul><li><p class="docList"><span class="docEmphasis">1</span>. Saves an internal copy of the variable's value</p></LI><li><p class="docList"><span class="docEmphasis">2</span>. Copies a new value into the variable (either <tt>undef</tt>, or a value assigned to the <tt>local</tt>)</P></li><li><p class="docList"><span class="docEmphasis">3</span>. Slates the variable to have its original value restored when execution runs off the end of the block enclosing the <tt>local</tt></P></LI></UL>
<p class="docText">This means that "local" refers only to how long any changes to the variable will last. The localized value lasts as long as the enclosing block is executing. Even if a subroutine is called from within that block, the localized value is seen. (After all, the variable is still a global variable.) The only difference from a non-localized global variable is that when execution of the enclosing block finally ends, the previous value is automatically restored.</P>
<p class="docText">An automatic save and restore of a global variable's value is pretty much all there is to <tt>local</tt>. For all the misunderstanding that has accompanied <tt>local</tt>, it's no more complex than the snippet on the right of <a class="docLink" href="#regex3-CHP-7-TABLE-4">Table 7-4</a> illustrates.</p>
<p class="docText">As a matter of convenience, you can assign a value to <tt>local ($SomeVar)</tt>, which is exactly the same as assigning to <tt>$SomeVar</tt> in place of the <tt>undef</tt> assignment. Also, the parentheses can be omitted to force a scalar context.</P>
<p class="docText">As a practical example, consider having to call a function in a poorly written library that generates a lot of "Use of uninitialized value" warnings.<a name="IDX-CHP-7-2249"></a> 
 You use Perl's <tt>-w</tt><a name="IDX-CHP-7-2250"></a> 
<a name="IDX-CHP-7-2251"></a> 
 option, as all good Perl programmers should, but the library author apparently didn't. You are exceedingly annoyed by the warnings, but if you can't change the</p>
<a name="regex3-CHP-7-TABLE-4"></a><p><table cellspacing="0" FRAME="hsides" RULES="all" cellpadding="4" width="100%"><caption><H5 class="docTableTitle">Table 7-4. The Meaning of local</H5></caption><colgroup span="2"><col><col></colgroup><thead><tr><th class="thead" scope="col" align="left"><p class="docText">Normal Perl<a name="IDX-CHP-7-2252"></a> 
</P></th><th class="thead" scope="col" align="left"><p class="docText">Equivalent Meaning</P></th></tr></thead><tr><td class="docTableCell" align="left">
<pre>
    {
        local($SomeVar); # <span class="docEmphasis">save copy</span>

        $SomeVar = 'My Value';

              &#8226;
              &#8226;
              &#8226;
              &#8226;
     }
     # <span class="docEmphasis">Value automatically restored</span>
</pre><BR>

</TD><td class="docTableCell" align="left">
<pre>
    }
      my $TempCopy = $SomeVar;
      $SomeVar = undef;

      $SomeVar = 'My Value';
            &#8226;
            &#8226;
            &#8226;
      $SomeVar = $TempCopy;
    }
</pre><br>

</td></tr></table></P><br>
<p class="docText">library, what can you do short of stop using <tt>-w</tt> altogether? Well, you could set a <tt>local</tt> value of <tt>$ ^W</tt>, the in-code debugging flag (the variable name <tt>^W</tt> can be either the two characters, caret and '<tt>W</tt>', or an actual control-<tt>W</tt> character):</p>
<pre>
    {
        local $^W = 0; # <span class="docEmphasis">Ensure warnings are off</span>.
        UnrulyFunction(&#8943;);
    }
    # <span class="docEmphasis">Exiting the block restores the original value of $^W</span>.
</pre><BR>

<p class="docText">The call to <tt>local</tt> saves an internal copy of the value of the global variable <tt>$^W</tt>, whatever it might be. Then that same <tt>$^W</tt> receives the new value of zero that we immediately scribble in. When <tt>UnrulyFunction</tt> is executing, Perl checks <tt>$^W</tt> and sees the zero we wrote, so doesn't issue warnings. When the function returns, our value of zero is still in effect.</p>
<p class="docText">So far, everything appears to work just as if <tt>local</tt> isn't used. However, when the block is exited right after the subroutine returns, the original value of <tt>$^W</tt> is restored. Your change of the value was local, in <span class="docEmphasis">time</span>, to the life of the block. You'd get the same effect by making and restoring a copy yourself, as in <a class="docLink" href="#regex3-CHP-7-TABLE-4">Table 7-4</a>, but <tt>local</tt> conveniently takes care of it for you.</p>
<p class="docText">For completeness, let's consider what happens if I use <tt>my</tt> instead of <tt>local</tt>.<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-7-FN-4">[<img src=images/U2020.jpg border=0>]</a></sup> Using <tt>my</tt> creates a <span class="docEmphasis">new variable</span> with an initially undefined value. It is visible only within the lexical block it is declared in (that is, visible only by the code written between the <tt>my</tt> and the end of the enclosing block). It does not change, modify, or in any other way refer to or affect other variables, including any global variable of the same name that might exist. The newly created variable is not visible elsewhere in the program, including from within <tt>UnrulyFunction</tt>. In our example snippet, the new <tt>$^W</tt> is immediately set to zero but is never again used or referenced, so it's pretty much a waste of effort. (While executing <tt>UnrulyFunction</tt> and deciding whether to issue warnings, Perl checks the unrelated global variable <tt>$^W</tt>.)</P><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-7-FN-4">[<img src=images/U2020.jpg border=0>]</a></sup> Perl doesn't allow the use of <tt>my</tt> with this special variable name, so the comparison is only academic.</p></blockquote>

<a name="regex3-CHP-7-SECT-3.2.3"></a>
<H5 id="title-IDA0KPEQ" class="docSection3Title">7.3.2.3. A better analogy: clear transparencies</h5>
<a name="IDX-CHP-7-2253"></a> 

<p class="docText">A useful analogy for local is that it provides a clear transparency (like used with an overhead projector) over a variable on which you scribble your own changes. You (and anyone else that happens to look, such as subroutines and signal handlers) will see the new values. They shadow the previous value until the point in time that the block is finally exited. At that point, the transparency is automatically removed, in effect, removing any changes that might have been made since the <tt>local</tt>.</p>
<p class="docText">This analogy is actually much closer to reality than saying "an internal copy is made." Using <tt>local</tt> doesn't actually make a copy, but instead puts your new value earlier in the list of those checked whenever a variable's value is accessed (that is, it shadows the original). Exiting a block removes any shadowing values added since the block started. Values are added manually, with <tt>local</tt>, but here's the whole reason we've been looking localization: <span class="docEmphStrong">regex side-effect variables have their values dynamically scoped automatically</span>.</p>

<a name="regex3-CHP-7-SECT-3.2.4"></a>
<h5 id="title-IDAWLPEQ" class="docSection3Title">7.3.2.4. Regex side effects and dynamic scoping</h5>
<p class="docText">What does dynamic scoping have to do with regular expressions? A lot. A number of variables like <tt>$&amp;</tt> (refers to the text matched) and <tt>$1</tt> (refers to the text matched by the first parenthesized subexpression) are automatically set as a side effect of a successful match. They are discussed in detail in the next section. These variables have their value dynamically scoped <span class="docEmphasis">automatically</span> upon entry to every block.</p>
<p class="docText">To see the benefit of this design choice, realize that each call to a subroutine involves starting a new block, which means a new dynamic scope is created for these variables. Because the values before the block are restored when the block exits (that is, when the subroutine returns), the subroutine can't change the values that the caller sees.</p>
<p class="docText">As an example, consider:</p>
<pre>
    if ( m/(&#8943;)/ )
    {
         DoSomeOtherStuff();
         print "the matched text was $1.\n";
    }
</pre><br>

<p class="docText">Because the value of <tt>$1</tt> is dynamically scoped automatically upon entering each block, this code snippet neither cares, nor needs to care, whether the function <tt>DoSomeOtherStuff</tt> changes the value of <tt>$1</tt> or not. Any changes to <tt>$1</tt> by the function are contained within the block that the function defines, or perhaps within a sub-block of the function. Therefore, they can't affect the value this snippet sees with the print after the function returns.</p>
<p class="docText">The automatic dynamic scoping is helpful even when not so apparent:</p>
<pre>
    if ($result =~ m/ERROR= ( .*)/) {
       warn "Hey, tell $Config{perladmin}<a name="IDX-CHP-7-2254"></a> 
 about $1!\n";
    }
</pre><br>

<p class="docText">The standard library module <tt>Config</tt> defines an associative array <tt>%Config</tt>, of which the member <tt>$Config{perladmin}</tt> holds the email address of the local Perlmaster. This code could be very surprising if <tt>$1</tt> were not automatically dynamically scoped, because <tt>%Config</tt> is actually a <span class="docEmphasis">tied</span><a name="IDX-CHP-7-2255"></a> 
 variable. That means any reference to it involves a behind-the-scenes subroutine call, and the subroutine within <tt>Config</tt> that fetches the appropriate value when <tt>$Config{&#8943;}</tt> is used invokes a regex match. That match lies between your match and your use of <tt>$1</tt>, so if <tt>$1</tt> were not dynamically scoped, it would be destroyed before you used it. As it is, any changes in <tt>$1</tt> during the <tt>$Config{&#8943;}</tt> processing are safely hidden by dynamic scoping.</P>

<a name="regex3-CHP-7-SECT-3.2.5"></a>
<h5 id="title-IDA5NPEQ" class="docSection3Title">7.3.2.5. Dynamic scoping versus lexical scoping</H5>
<a name="IDX-CHP-7-2256"></a> 
<a name="IDX-CHP-7-2257"></a> 
<a name="IDX-CHP-7-2258"></a> 
<a name="IDX-CHP-7-2259"></a> 
<a name="IDX-CHP-7-2260"></a> 
<a name="IDX-CHP-7-2261"></a> 

<p class="docText">Dynamic scoping provides many rewards if used effectively, but haphazard dynamic scoping with <tt>local</tt> can create a maintenance nightmare, as readers of a program find it difficult to understand the increasingly complex interactions among the lexically disperse <tt>local</tt>, subroutine calls, and references to localized variables.</p>
<p class="docText">As I mentioned, the <tt>my(&#8943;)</tt> declaration creates a private variable with <span class="docEmphasis">lexical scope</span>.<a name="IDX-CHP-7-2262"></a> 
 A private variable's lexical scope is the opposite of a global variable's global scope, but it has little to do with dynamic scoping (except that you can't <tt>local</tt> the value of a <tt>my</tt> variable). Remember, <tt>local</tt> is just an <span class="docEmphasis">action</span>, while <tt>my</tt> is both an action <span class="docEmphasis">and</span>, importantly, a declaration.</p>


<a name="regex3-CHP-7-SECT-3.3"></a>
<H4 id="title-IDACQPEQ" class="docSection2Title">7.3.3. Special Variables Modified by a Match</H4>
<a name="IDX-CHP-7-2263"></a> 
<a name="IDX-CHP-7-2264"></a> 

<p class="docText">A successful match or substitution sets a variety of global, read-only variables that are always automatically dynamically scoped. These values <span class="docEmphasis">never</span> change if a match attempt is unsuccessful, and are <span class="docEmphasis">always</span> set when a match is successful. When appropriate, they are set to the empty string (a string with no characters in it), or undefined (a "no value" value, similar to, yet testably distinct from, an empty string). <a class="docLink" href="#regex3-CHP-7-TABLE-5">Table 7-5</a> shows examples.</P>
<p class="docText">In more detail, here are the variables set after a match:</P>
<a name="IDX-CHP-7-2265"></a><dl class="docList">
<dt><br><P><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont"><span class="docEmphStrong">$&amp;</span></span></span></span></p></dt>
<a name="IDX-CHP-7-2265"></a> 

<dd><p class="docList">A copy of the text successfully matched by the regex. This variable (along with <tt>$'</tt> and <tt>$'</tt>, described next) is best avoided for performance reasons. (See the discussion on page 356.) <tt>$&amp;</tt> is never undefined after a successful match, although it can be an empty string.</p></dd>
</dl>
<a name="regex3-CHP-7-TABLE-5"></a><P><table cellspacing="0" FRAME="hsides" RULES="all" cellpadding="4" width="100%"><caption><H5 class="docTableTitle">Table 7-5. Example Showing After-Match Special Variables</h5></caption><colgroup span="3"><col><col><col></colgroup><thead><TR><th class="thead" scope="col" align="left" valign="bottom" colspan="3">
<p class="docText">After the match of</P>
<pre>
                                   12               2 3   <span class="docEmphasis">4</span>     <span class="docEmphasis">4 31</span>
    "Pi is 3.14159, roughly" =~ m/\b((tasty|fattening)|(\d+(\.\d*)?))\b/;
</pre><br>

<p class="docText">the following special variables are given the values shown.</p></th></tr><TR><th class="thead" scope="col" align="center" valign="bottom"><p class="docText">Variable</P></th><th class="thead" scope="col" align="left" valign="bottom"><p class="docText">Meaning</p></th><th class="thead" scope="col" align="left" valign="bottom"><p class="docText">Value</p></th></tr></thead><tr><TD class="docTableCell" align="left" valign="bottom"><p class="docText"><tt>$</tt>'</p></td><TD class="docTableCell" align="left" valign="bottom"><p class="docText">Text before match</p></td><TD class="docTableCell" align="left" valign="bottom"><p class="docText">Pi&#8226;is&#8226;</p></TD></tr><tr><td class="docTableCell" align="left" valign="bottom"><p class="docText"><tt>$&amp;</tt></p></td><td class="docTableCell" align="left" valign="bottom"><p class="docText">Text matched</p></td><td class="docTableCell" align="left" valign="bottom"><p class="docText">3.14159</p></td></tr><TR><td class="docTableCell" align="left" valign="bottom"><p class="docText"><tt>$</tt>'</P></td><td class="docTableCell" align="left" valign="bottom"><p class="docText">Text after match</P></TD><TD class="docTableCell" align="left" valign="bottom"><p class="docText">, &#8226;roughly</P></td></TR><tr><td class="docTableCell" align="left" valign="bottom"><p class="docText"><tt>$1</tt><a name="IDX-CHP-7-2266"></a> 
<a name="IDX-CHP-7-2267"></a> 
</P></TD><td class="docTableCell" align="left" valign="bottom"><p class="docText">Text matched within 1<sup>st</sup> set of parentheses</P></TD><td class="docTableCell" align="left" valign="bottom"><p class="docText">3.14159</p></td></TR><TR><td class="docTableCell" align="left" valign="bottom"><p class="docText"><tt>$2</tt></p></td><td class="docTableCell" align="left" valign="bottom"><p class="docText">Text matched within 2<sup>nd</sup> set of parentheses</P></td><td class="docTableCell" align="left" valign="bottom"><p class="docText"><span class="docEmphasis">undef</span></P></td></tr><TR><td class="docTableCell" align="left" valign="bottom"><p class="docText"><tt>$3</tt></P></td><td class="docTableCell" align="left" valign="bottom"><p class="docText">Text matched within 3<sup>rd</sup> set of parentheses</p></td><td class="docTableCell" align="left" valign="bottom"><p class="docText">3.14159</p></td></tr><tr><td class="docTableCell" align="left" valign="bottom"><p class="docText"><tt>$4</tt></p></td><TD class="docTableCell" align="left" valign="bottom"><p class="docText">Text matched within 4<sup>th</sup> set of parentheses</p></TD><td class="docTableCell" align="left" valign="bottom"><p class="docText">.14159</p></TD></TR><TR><TD class="docTableCell" align="left" valign="bottom"><p class="docText"><tt>$+</tt><a name="IDX-CHP-7-2268"></a> 
</p></TD><td class="docTableCell" align="left" valign="bottom"><p class="docText">Text from highest-numbered $1, $2, etc.</p></TD><TD class="docTableCell" align="left" valign="bottom"><p class="docText">.14159</p></TD></TR><tr><td class="docTableCell" align="left" valign="bottom"><p class="docText"><tt>$^N</tt><a name="IDX-CHP-7-2269"></a> 
<a name="IDX-CHP-7-2270"></a> 
</p></TD><TD class="docTableCell" align="left" valign="bottom"><p class="docText">Text from most recently closed <tt>$1</tt>, <tt>$2</tt>, etc.</p></td><td class="docTableCell" align="left" valign="bottom"><p class="docText">3.14159</p></TD></tr><tr><TD class="docTableCell" align="left" valign="bottom"><p class="docText"><tt>@-</tt><a name="IDX-CHP-7-2271"></a> 
</p></td><TD class="docTableCell" align="left" valign="bottom"><p class="docText">Array of match-start indices into target text</p></TD><td class="docTableCell" align="left" valign="bottom"><p class="docText">(6, 6, <tt>undef</tt>, 6, 7)</p></td></tr><tr><td class="docTableCell" align="left" valign="bottom"><p class="docText"><tt>@+</tt><a name="IDX-CHP-7-2272"></a> 
</p></td><td class="docTableCell" align="left" valign="bottom"><p class="docText">Array of match-end indices into target text</p></td><td class="docTableCell" align="left" valign="bottom"><p class="docText">(13, 13, <tt>undef</tt>, 13, 13)</P></td></TR></table></p><br>
<a name="IDX-CHP-7-2273"></a><a name="IDX-CHP-7-2274"></a><a name="IDX-CHP-7-2275"></a><a name="IDX-CHP-7-2276"></a><a name="IDX-CHP-7-2277"></a><a name="IDX-CHP-7-2278"></a><a name="IDX-CHP-7-2279"></a><a name="IDX-CHP-7-2280"></a><a name="IDX-CHP-7-2281"></a><a name="IDX-CHP-7-2282"></a><a name="IDX-CHP-7-2283"></a><a name="IDX-CHP-7-2284"></a><dl class="docList">
<dt><BR><P><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont"><span class="docEmphStrong">$'</span></span></span></span></P></dt>
<dd><p class="docList">A copy of the target text in front of (to the left of) the match's start. When used in conjunction with the <tt>/g</tt> modifier, you might wish <tt>$'</tt> to be the text from start of the <span class="docEmphasis">match attempt</span>, but it's the text from the start of the whole string, each time. <tt>$'</tt> is never undefined after a successful match.</P></dd>

<dt><br><P><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont"><span class="docEmphStrong">$'</span></span></span></span></p></dt>
<a name="IDX-CHP-7-2273"></a> 
<a name="IDX-CHP-7-2274"></a> 

<dd><p class="docList">A copy of the target text after (to the right of) the successfully matched text. <tt>$'</tt> is never undefined after a successful match. After a successful match, the string <tt>"$'$&amp;$'"</tt> is always a copy of the original target text.<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-7-FN-5">[<img src=images/U2020.jpg border=0>]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-7-FN-5">[<img src=images/U2020.jpg border=0>]</a></sup> <img src=images/U2020.jpg border=0> Actually, if the original target is undefined, but the match successful (unlikely, but possible), <tt>"$'$&amp;$'"</tt> would be an empty string, not undefined. This is the only situation where the two differ.</P></blockquote></dd>

<dt><BR><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont"><span class="docEmphStrong">$1, $2, $3</span></span></span>, etc.</span></P></dt>
<dd><p class="docList">The text matched by the 1<sup>st</sup>, 2<sup>nd</sup>, 3<sup>rd</sup>, etc., set of capturing<a name="IDX-CHP-7-2275"></a> 
 parentheses. (Note that <tt>$0</tt><a name="IDX-CHP-7-2276"></a> 
<a name="IDX-CHP-7-2277"></a> 
 is not included hereit is a copy of the script name and not related to regular expressions.) These are guaranteed to be undefined if they refer to a set of parentheses that doesn't exist in the regex, or to a set that wasn't actually involved in the match.</P>
<p class="docList">These variables are available after a match, including in the replacement operand of <tt>s/&#8943;/&#8943;/</tt>. They can also be used within the <span class="docEmphasis">code</span> parts of an embedded-code or dynamic-regex construct (&#9758;327). Otherwise, it makes little sense to use them within the regex itself. (That's what <img src=images/U2308.jpg border=0><tt>\1</tt><img src=images/U230B.jpg border=0><a name="IDX-CHP-7-2278"></a> 
<a name="IDX-CHP-7-2279"></a> 
 and friends are for.) See "Using <tt>$1</tt> Within a Regex?" on page 303.</p>
<p class="docList">The difference between <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(\ w+)</span></tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(\w)+</span></tt><img src=images/U230B.jpg border=0> can be seen in how <tt>$1</tt> is set. Both regexes match exactly the same text, but they differ in what subexpression falls within the parentheses. Matching against the string '<tt>tubby</tt>', the first one results in <tt>$1</tt> having the full '<tt>tubby</tt>', while the latter one results in it having only '<tt>y</tt>': with <img src=images/U2308.jpg border=0><tt>(\w)+</tt><img src=images/U230B.jpg border=0>, the plus is outside the parentheses, so each iteration causes them to start capturing anew, leaving only the last character in <tt>$1</tt>.</p>
<p class="docList">Also, note the difference between <img src=images/U2308.jpg border=0><tt>(x)?</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>(x?)</tt><img src=images/U230B.jpg border=0>. With the former, the parentheses and what they enclose are optional, so <tt>$1</tt> would be either '<tt>x</tt>' or undefined. But with <img src=images/U2308.jpg border=0><tt>(x?)</tt><img src=images/U230B.jpg border=0>, the parentheses enclose a match  what is optional are the contents. If the overall regex matches, the contents matches something, although that something might be the nothingness <img src=images/U2308.jpg border=0><tt>x?</tt><img src=images/U230B.jpg border=0> allows. Thus, with <img src=images/U2308.jpg border=0><tt>(x?)</tt><img src=images/U230B.jpg border=0> the possible values of <tt>$1</tt> are '<tt>x</tt>' and an empty string. The following table shows some examples:</p>
<P><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="4"><col><col><col><col></colgroup><thead><TR><th class="thead" scope="col" align="left" valign="bottom"><p class="docText"><tt>Sample Match</tt></p></th><th class="thead" scope="col" align="left" valign="bottom"><p class="docText"><tt>Resulting $1</tt></p></th><th class="thead" scope="col" align="left" valign="bottom"><p class="docText"><tt>Sample Match</tt></p></th><th class="thead" scope="col" align="left" valign="bottom"><p class="docText"><tt>Resulting $1</tt></p></th></TR></thead><tr><td class="docTableCell" align="right"><p class="docText"><tt>"::" =~ m/:(A?):/</tt></P></td><td class="docTableCell" align="center"><p class="docText"><tt>empty string</tt></P></td><TD class="docTableCell" align="right"><p class="docText"><tt>"::" =~ m/:(\w*):/</tt></p></td><td class="docTableCell" align="center"><p class="docText"><tt>empty string</tt></p></td></tr><tr><td class="docTableCell" align="right"><p class="docText"><tt>"::" =~ m/:(A)?:/</tt></p></td><td class="docTableCell" align="center"><p class="docText"><tt>undefined</tt></p></TD><td class="docTableCell" align="right"><p class="docText"><tt>"::" =~ m/:(\w)*:/</tt></P></td><td class="docTableCell" align="center"><p class="docText"><tt>undefined</tt></P></TD></TR><TR><td class="docTableCell" align="right"><p class="docText"><tt>":A:" =~ m/:(A?):/</tt></P></td><td class="docTableCell" align="center"><p class="docText"><tt>A</tt></P></TD><td class="docTableCell" align="right"><p class="docText"><tt>":Word:" =~ m/:(\w*):/</tt></P></TD><td class="docTableCell" align="center"><p class="docText"><tt>Word</tt></p></td></TR><TR><td class="docTableCell" align="right"><p class="docText"><tt>":A:" =~ m/:(A)?:/</tt></p></td><td class="docTableCell" align="center"><p class="docText"><tt>A</tt></P></td><td class="docTableCell" align="right"><p class="docText"><tt>":Word:" =~ m/:(\w)*:/</tt></P></td><td class="docTableCell" align="center"><p class="docText"><tt>d</tt></P></td></TR></table></p><br>
<p class="docList">When adding parentheses just for capturing, as was done here, the decision of which to use is dependent only upon the semantics you want. In these examples, since the added parentheses have no affect on the overall match (they all match the same text), the only differences among them is in the side effect of how <tt>$1</tt> is set.</p></dd>

<dt><br><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont"><span class="docEmphStrong">$+</span></span></span></span></p></dt>
<dd><p class="docList">This is a copy of the highest numbered <tt>$1, $2</tt>, etc. explicitly set during the match. This might be useful after something like</p>
<pre>
    $url =~ m{
       href \ s* = \ s* # <span class="docEmphasis">Match the "href = " part, then the value</span> ...
       (?: " ([^"]*) " # <span class="docEmphasis">a double-quoted value, or</span> ...
         | ' ( [^'] * ) ' # <span class="docEmphasis">a single-quoted value, or</span> ...
         | ( [^'"&lt;&gt;]+ ) ) # <span class="docEmphasis">an unquoted value</span>.
    }ix;
</pre><br>

<p class="docList">to access the value of the href. Without <tt>$+</tt>, you would have to check each of <tt>$1, $2</tt>, and <tt>$3</tt> and use the one that's not undefined.</p>
<p class="docList">If there are no capturing parentheses in the regex (or none are used during the match), it becomes undefined.</p></dd>

<dt><br><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont"><span class="docEmphStrong">$^N</span></span></span></span></P></dt>
<dd><p class="docList">A copy of the most-recently-closed <tt>$1, $2, etc.</tt> explicitly set during the match (i.e., the <tt>$1, $2, etc.</tt>, associated with the final closing parenthesis). If there are no capturing parentheses in the regex (or none used during the match), it becomes undefined. A good example of its use is given starting on page 344.</p></dd>

<dt><BR><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont"><span class="docEmphStrong">@-</span> and <span class="docEmphStrong">@+</span></span></span></span></p></dt>
<a name="IDX-CHP-7-2280"></a> 

<a name="IDX-CHP-7-2281"></a> 

<dd><p class="docList">These are arrays of starting and ending offsets (string indices) into the target text. They might be a bit confusing to work with, due to their odd names. The first element of each refers to the overall match. That is, the first element of <tt>@-</tt>, accessed with <tt>$-[0]</tt>, is the offset from the beginning of the target string to where the match started. Thus, after</P>
<pre>
    $text = "Version 6 coming soon?";
       <img src=images/U22EE.jpg border=0>
    $text =~ m/\d+/;
</pre><BR>

<p class="docList">the value of <tt>$-[0]</tt> is <tt>8</tt>, indicating that the match started eight characters into the target string. (In Perl, indices are counted started at zero.)</P>
<p class="docList">The first element of <tt>@+</tt>, accessed with <tt>$+[0]</tt>, is the offset to the end of the match. With this example, it contains <tt>9</tt>, indicating that the overall match ended nine characters from the start of the string. So, using them together, <tt><span class="docEmphStrong">substr($text, $-[0], $+[0] - $-[0])</span></tt> is the same as <tt>$&amp;</tt><a name="IDX-CHP-7-2282"></a> 
 if <tt>$text</tt> has not been modified, but doesn't have the performance penalty that <tt>$&amp;</tt> has (&#9758;356). Here's an example showing a simple use of <tt>@-</tt>:</P>
<pre>
    1 while $line =~ s/\t/' ' x (8 - <span class="docEmphStrong">$-[0] %</span> 8)/e;
</pre><br>

<p class="docList">Given a line of text, it replaces tabs with the appropriate number of spaces.<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-7-FN-6">[<img src=images/U2020.jpg border=0>]</a></sup></P><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-7-FN-6">[<img src=images/U2020.jpg border=0>]</a></sup> This tab-replacement snippet has the limitation that it works only with "traditional" western text. It doesn't produce correct results with wide characters like <img border="0" alt="" width="12" height="12" SRC="images/regex3_u0704.jpg">, which is one character but takes up two spaces, nor some Unicode renditions of accented characters like &agrave; (&#9758;107).</p></blockquote>
<p class="docList">Subsequent elements of each array are the starting and ending offsets for captured groups. The pair <tt>$-[1]</tt> and <tt>$+[1]</tt> are the offsets into the target text where <tt>$1</tt> was taken, <tt>$-[2]</tt> and <tt>$+[2]</tt> for <tt>$2</tt>, and so on.</p></dd>

<dt><BR><P><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont"><span class="docEmphStrong">$^R</span></span></span></span></p></dt>
<a name="IDX-CHP-7-2283"></a> 
<a name="IDX-CHP-7-2284"></a> 

<dd><p class="docList">This variable holds the resulting value of the most recently executed embedded-code construct, except that an embedded-code construct used as the <span class="docEmphasis">if</span> of a <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(? if then | else)</span></tt><img src=images/U230B.jpg border=0> conditional (&#9758;140) does not set <tt>$^R</tt>. When used within a regex (within the <span class="docEmphasis">code</span> parts of embedded-code and dynamic-regex constructs; &#9758;327), it is automatically localized to each part of the match, so values of <tt>$^R</tt> set by code that gets "unmatched" due to backtracking are properly forgotten. Put another way, it has the "most recent" value with respect to the match path that got the engine to the current location.</P></dd>
</dl>
<p class="docText">When a regex is applied repeatedly with the <tt>/g</tt> modifier, each iteration sets these variables afresh. That's why, for instance, you can use <tt>$1</tt> within the replacement operand of <tt>s/&#8943;/&#8943;/g</tt> and have it represent a new slice of text with each match.</P>
<a name="regex3-CHP-7-SECT-3.3.1"></a>
<h5 id="title-IDAKMQEQ" class="docSection3Title">7.3.3.1. Using $1 within a regex?</h5>
<a name="IDX-CHP-7-2285"></a> 

<a name="IDX-CHP-7-2286"></a> 

<a name="IDX-CHP-7-2287"></a> 
<a name="IDX-CHP-7-2288"></a> 
<a name="IDX-CHP-7-2289"></a> 
<a name="IDX-CHP-7-2290"></a> 
<a name="IDX-CHP-7-2291"></a> 
<a name="IDX-CHP-7-2292"></a> 
<a name="IDX-CHP-7-2293"></a> 

<p class="docText">The Perl man page makes a concerted effort to point out that <img src=images/U2308.jpg border=0><tt>\1</tt><img src=images/U230B.jpg border=0><a name="IDX-CHP-7-2294"></a> 
<a name="IDX-CHP-7-2295"></a> 
 is not available as a backreference outside of a regex. (Use the variable $1 instead.) The variable <tt>$1</tt> refers to a string of static text matched during some previously completed successful match. On the other hand, <img src=images/U2308.jpg border=0><tt>\1</tt><img src=images/U230B.jpg border=0> is a true regex metacharacter that matches text similar to that matched within the first parenthesized subexpression <span class="docEmphasis">at the time that the regex-directed NFA reaches the</span> <img src=images/U2308.jpg border=0><tt>\1</tt><img src=images/U230B.jpg border=0>. What it matches might change over the course of an attempt as the NFA tracks and backtracks in search of a match.</p>
<p class="docText">The opposite question is whether <tt>$1</tt> and other after-match variables are available within a regex operand. They are commonly used within the <span class="docEmphasis">code</span> parts of embedded-code and dynamic-regex constructs (&#9758;327), but otherwise make little sense within a regex. A <tt>$1</tt> appearing in the "regex part" of a regex operand is treated exactly like any other variable: its value is interpolated before the match or substitution operation even begins. Thus, as far as the regex is concerned, the value of <tt>$1</tt> has nothing to do with the current match, but rather is left over from some previous match.</P>



<a href="7041536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-7-SECT-2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-7-SECT-4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>