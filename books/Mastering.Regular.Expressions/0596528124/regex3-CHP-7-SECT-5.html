<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 7.5.&nbsp; The Match Operator</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-7-SECT-4.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-7-SECT-6.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="regex3-CHP-7-SECT-5"></a>
<H3 id="title-IDAZXUHJ" class="docSection1Title">7.5. The Match Operator</H3>
<p class="docText">The basic match<a name="IDX-CHP-7-2315"></a> 
</P>
<pre>
    $text =~ m/<span class="docEmphasis">regex/</span>
</pre><BR>

<p class="docText">is the core of Perl regular-expression use. In Perl, a regular-expression match is an <span class="docEmphasis">operator</span> that takes two <span class="docEmphasis">operands</span>, a target string operand and a regex operand, and returns a value.</p>
<p class="docText">How the match is carried out, and what kind of value is returned, depend on the context the match is used in (&#9758;294), and other factors. The match operator is quite flexibleit can be used to test a regular expression against a string, to pluck data from a string, and even to parse a string part by part in conjunction with other match operators. While powerful, this flexibility can make mastering it more complex. Some areas of concern include:</P>
<ul><li><p class="docList">How to specify the regex operand</P></LI><li><p class="docList">How to specify match modifiers, and what they mean</P></LI><li><p class="docList">How to specify the target string to match against</p></li><LI><p class="docList">A match's side effects</P></li><li><p class="docList">The value returned by a match</p></li><LI><p class="docList">Outside influences that affect the match</p></li></UL>
<p class="docText">The general form of a match is:</p>
<pre>
    <span class="docEmphasis">StringOperand</span> =~ <span class="docEmphasis">RegexOperand</span>
</pre><br>

<p class="docText">There are various shorthand forms, and it's interesting to note that each part is optional in one shorthand form or another. We'll see examples of all forms throughout this section.</P>
<a name="regex3-CHP-7-SECT-5.1"></a>
<h4 id="title-IDAYZUHJ" class="docSection2Title">7.5.1. Match's Regex Operand</H4>
<p class="docText">The regex operand can be a regex literal<a name="IDX-CHP-7-2316"></a> 
 or a regex object. (Actually, it can be a string or any arbitrary expression, but there is little benefit to that.) If a regex literal is used, match modifiers may also be specified.</p>
<a name="regex3-CHP-7-SECT-5.1.1"></a>
<h5 id="title-IDAF0UHJ" class="docSection3Title">7.5.1.1. Using a regex literal</h5>
<p class="docText">The regex operand is most often a regex literal within <tt>m/&#8943;/</tt> or just <tt>/&#8943;/</tt>. The leading <tt>m</tt> is optional if the delimiters for the regex literal are forward slashes or question marks (delimiters of question marks are special, discussed in a bit). For consistency, I prefer to always use the <tt>m</tt>, even when it's not required. As described earlier, you can choose your own delimiters if the <tt>m</tt> is present (&#9758;291).</p>
<p class="docText">When using a regex literal, you can use any of the core modifiers described on page 292. The match operator also supports two additional modifiers, <tt>/g</tt><a name="IDX-CHP-7-2317"></a> 
<a name="IDX-CHP-7-2318"></a> 
 and <tt>/c</tt>, discussed in a bit.</p>

<a name="regex3-CHP-7-SECT-5.1.2"></a>
<h5 id="title-IDAH1UHJ" class="docSection3Title">7.5.1.2. Using a regex object</h5>
<p class="docText">The regex operand can also be a regex object, created with <tt>qr/&#8943;/</tt>. For example:</p>
<pre>
    my <span class="docEmphStrong">$regex</span> = qr/<span class="docEmphasis">regex/</span>;
      <img src=images/U22EE.jpg border=0>
    if ($text =~ <span class="docEmphStrong">$regex)</span> {
         <img src=images/U22EE.jpg border=0>
</pre><br>

<p class="docText">You can use <tt>m/&#8943;/</tt> with a regex object. As a special case, if the <span class="docEmphasis">only</span> thing within the "regex literal" is the interpolation of a regex object, it's exactly the same as using the regex object alone. This example's <tt>if</tt> can be written as:</p>
<pre>
    if ($text =~ <span class="docEmphStrong">m</span>/$regex/) {
         <img src=images/U22EE.jpg border=0>
</pre><br>

<p class="docText">This is convenient because it perhaps looks more familiar, and also allows you to use the <tt>/g</tt> modifier with a regex object. (You can use the other modifiers that <tt>m/&#8943;/</tt> supports as well, but they're meaningless in this case because they can never override the modes locked in a regex object &#9758;304.)</p>

<a name="regex3-CHP-7-SECT-5.1.3"></a>
<H5 id="title-IDAX2UHJ" class="docSection3Title">7.5.1.3. The default regex</h5>
<a name="IDX-CHP-7-2319"></a> 

<a name="IDX-CHP-7-2320"></a> 

<a name="IDX-CHP-7-2321"></a> 
<a name="IDX-CHP-7-2322"></a> 

<p class="docText">If no regex is given, such as with <tt>m//</tt> (or with <tt>m/$SomeVar/</tt> where the variable <tt>$SomeVar</tt> is empty or undefined), Perl<a name="IDX-CHP-7-2323"></a> 
 reuses the regular expression <span class="docEmphasis">most recently used successfully within the enclosing dynamic scope</span>. This used to be useful for efficiency reasons, but is now obsolete with the advent of regex objects (&#9758;303).</P>

<a name="regex3-CHP-7-SECT-5.1.4"></a>
<h5 id="title-IDAA4UHJ" class="docSection3Title">7.5.1.4. Special match-once ?&#8943;?</h5>
<a name="IDX-CHP-7-2324"></a> 

<p class="docText">In addition to the special cases for the regex-literal delimiters described earlier, the match operator treats the question mark as a special delimiter. The use of a question mark as the delimiter (as with <tt>m?&#8943;?</tt>) enables a rather esoteric feature such that after the successfully <tt>m?&#8943;?</tt> matches once, it cannot match again until the function <tt>reset</tt> is called in the same package. Quoting from the Perl Version 1 manual page, this features was "a useful optimization when you only want to see the first occurrence of something in each of a set of files," but for whatever reason, <span class="docEmphStrong">I</span> have never seen it used in modern Perl.</P>
<p class="docText">The question mark delimiters are a special case like the forward slash delimiters, in that the <tt>m</tt> is optional: <tt>?&#8943;?</tt> by itself is treated as <tt>m?&#8943;?</tt>.</P>


<a name="regex3-CHP-7-SECT-5.2"></a>
<H4 id="title-IDAC5UHJ" class="docSection2Title">7.5.2. Specifying the Match Target Operand</H4>
<p class="docText">The normal way to indicate "this is the string to search" is using <tt><span class="docEmphStrong">=</span>~</tt>, as with <tt><span class="docEmphStrong">$text =~ m/&#8943;/</span></tt>. Remember that <tt><span class="docEmphStrong">=</span>~</tt> is <span class="docEmphasis">not</span> an assignment operator, nor is it a comparison operator. It is merely a funny-looking way of linking the match operator with one of its operands. (The notation was adapted from awk.)</p>
<p class="docText">Since the whole "<tt><span class="docEmphStrong">expr</span> =~ <span class="docEmphStrong">m/&#8943;/"</span></tt> is an expression itself, you can use it wherever an expression is allowed. Some examples (each separated by a wavy line):</P>
<pre>
     $text =~ m/&#8943;/; # <span class="docEmphasis">Just do it, presumably, for the side effects</span>.
    -----------------------------------
      if ($text =~ m/&#8943;/) {
        # <span class="docEmphasis">Do code if match is successful</span>
          <img src=images/U22EE.jpg border=0>
    -----------------------------------
      $result = ( $text =~ m/&#8943;/ ); # <span class="docEmphasis">Set $result to result of match against $text</span>
      $result = $text =~ m/&#8943;/ ; # <span class="docEmphasis">Same thing; =~ has higher precedence than</span> =
    -----------------------------------
      $copy = $text; # <span class="docEmphasis">Copy $text to $copy</span>...
      $copy =~ m/&#8943;/; # ... <span class="docEmphasis">and perform match on $copy</span>
    ( $copy = $text ) =~ m/&#8943;/; # <span class="docEmphasis">Same thing in one expression</span>
</pre><br>

<a name="regex3-CHP-7-SECT-5.2.1"></a>
<h5 id="title-IDA4AVHJ" class="docSection3Title">7.5.2.1. The default target</H5>
<p class="docText">If the target string is the variable <tt>$_</tt>,<a name="IDX-CHP-7-2325"></a> 
 you can omit the "<tt><span class="docEmphStrong">$_ =</span>~</tt>" parts altogether. In other words, the default target operand is <tt>$_</tt>.</P>
<p class="docText">Something like</p>
<pre>
    $text =~ m/<span class="docEmphasis">regex/</span>;
</pre><BR>

<p class="docText">means "Apply <span class="docEmphasis">regex</span> to the text in <tt>$text</tt>, ignoring the return value but doing the side effects." If you forget the '~', the resulting</P>
<pre>
    $text = m/<span class="docEmphasis">regex/</span>;
</pre><br>

<p class="docText">becomes "Apply <span class="docEmphasis">regex</span> to the text in <tt>$_</tt>, do the side effects, and return a true or false value that is then assigned to <tt>$text</tt>." In other words, the following are the same:</p>
<pre>
    $text = m/<span class="docEmphasis">regex/</span>;
    $text = ($_ =~ m/<span class="docEmphasis">regex/</span>);
</pre><br>

<p class="docText">Using the default target string can be convenient when combined with other constructs that have the same default (as many do). For example, this is a common idiom:</P>
<pre>
    while (&lt;&gt;)
    {
       if (m/&#8943;/) {
         <img src=images/U22EE.jpg border=0>
       } elsif (m/&#8943;/) {
       <img src=images/U22EE.jpg border=0>
</pre><BR>

<p class="docText">In general, though, relying on default operands can make your code less approachable by less experienced programmers.</p>

<a name="regex3-CHP-7-SECT-5.2.2"></a>
<h5 id="title-IDA5CVHJ" class="docSection3Title">7.5.2.2. Negating the sense of the match</h5>
<a name="IDX-CHP-7-2326"></a> 
<a name="IDX-CHP-7-2327"></a> 

<p class="docText">You can also use <tt>!~</tt> instead of <tt>=~</tt> to logically negate the sense of the return value. (Return values and side effects are discussed soon, but with <tt>!~</tt>, the return value is always a simple true or false value.) The following are identical:</p>
<pre>
    if ($text !~ m/&#8943;/)
    if (not $text =~ m/&#8943;/)
    unless ($text =~ m/&#8943;/)
</pre><BR>

<p class="docText">Personally, I prefer the middle form. With any of them, the normal side effects, such as the setting of <tt>$1</tt> and the like, still happen. <tt><span class="docEmphStrong">!</span>~</tt> is merely a convenience in an "if this doesn't match" situation.</p>


<a name="regex3-CHP-7-SECT-5.3"></a>
<h4 id="title-IDAGEVHJ" class="docSection2Title">7.5.3. Different Uses of the Match Operator</H4>
<p class="docText">You can always use the match operator as if it returns a simple true/false indicating the success of the match, but there are ways you can get additional information about a successful match, and to work in conjunction with other match operators. How the match operator works depends primarily on the <span class="docEmphasis">context</span><a name="IDX-CHP-7-2328"></a> 
 in which it's used (&#9758;294), and whether the <tt>/g</tt> modifier has been applied.</p>
<a name="regex3-CHP-7-SECT-5.3.1"></a>
<h5 id="title-IDAXEVHJ" class="docSection3Title">7.5.3.1. Normal "does this match?"scalar context without /g</H5>
<a name="IDX-CHP-7-2329"></a> 

<a name="IDX-CHP-7-2330"></a> 
<a name="IDX-CHP-7-2331"></a> 
<a name="IDX-CHP-7-2332"></a> 

<p class="docText">In a scalar context, such as the test of an <tt>if</tt>, the match operator returns a simple true or false:</p>
<pre>
    if ($target =~  m/&#8943;/) {
        #  ... <span class="docEmphasis">processing after successful match</span> ...
         <img src=images/U22EE.jpg border=0>
    } else {
        #  ... <span class="docEmphasis">processing after unsuccessful match</span> ...
         <img src=images/U22EE.jpg border=0>
    }
</pre><BR>

<p class="docText">You can also assign the result to a scalar for inspection later:</p>
<pre>
    my $success = $target =~  m/&#8943;/;
      <img src=images/U22EE.jpg border=0>
    if ($success) {
      <img src=images/U22EE.jpg border=0>
    }
</pre><br>


<a name="regex3-CHP-7-SECT-5.3.2"></a>
<h5 id="title-IDADGVHJ" class="docSection3Title">7.5.3.2. Normal "pluck data from a string"list context, without /g</h5>
<a name="IDX-CHP-7-2333"></a> 

<p class="docText">A list context without <tt>/g</tt> is the normal way to pluck information from a string. The return value is a list with an element for each set of capturing parentheses in the regex. A simple example is processing a date of the form <tt>69/8/31</tt>, using:</p>
<pre>
    my ($year, $month, $day) = $date =~  <span class="docEmphStrong">m{</span> ^ (\d+) / (\d+) / (\d+)  $ <span class="docEmphStrong">}x</span>;
</pre><br>

<p class="docText">The three matched numbers are then available in the three variables (and <tt>$1</tt>, <tt>$2</tt>, and <tt>$3</tt> as well). There is one element in the return-value list for each set of capturing parentheses, or an empty list upon failure.</p>
<p class="docText">It is possible for a set of capturing parentheses to not participate in the final success of a match. For example, one of the sets in <tt><span class="docEmphStrong">m/</span>(this)|(that)<span class="docEmphStrong">/</span></tt> is guaranteed not to be part of the match. Such sets return the undefined value <tt>undef</tt>. If there are no sets of capturing parentheses to begin with, a successful list-context match without <tt>/g</tt> returns the list <tt>(1)</tt>.</p>
<p class="docText">A list context can be provided in a number of ways, including assigning the result to an array, as with:</p>
<pre>
    my @parts = $text =~ m/^(\d+)-(\d+)-(\d+)$/;
</pre><br>

<p class="docText">If you're assigning to just one scalar variable, take care to provide a list context to the match if you want the captured parts instead of just a Boolean indicating the success. Compare the following tests:</p>
<pre>
    my ($wo rd)  = $text =~ m/(\w+)/;
    my $success = $text =~ m/(\w+)/;
</pre><br>

<p class="docText">The parentheses around the variable in the first example cause its <tt>my</tt> to provide a list context to the assignment (in this case, to the match). The lack of parentheses in the second example provides a scalar context to the match, so <tt>$success</tt> merely gets a true/false result.</P>
<p class="docText">This example shows a convenient idiom:</p>
<pre>
    if ( <span class="docEmphStrong">my</span>  ($year, $month, $day) = $date =~ <span class="docEmphStrong">m {</span> ^ (\d+) / (\d+) / (\d+) $<span class="docEmphStrong">}x</span>
  ) {
        # <span class="docEmphasis">Process for when we have a match: $year and such are available</span>
    } else {
        # <span class="docEmphasis">here if no match</span> ...
    }
</pre><BR>

<p class="docText">The match is in a list context (provided by the "<span class="docEmphStrong"><tt>my</tt> (</span>&#8943;<span class="docEmphStrong">) =</span>"), so the list of variables is assigned their respective <tt>$1</tt>, <tt>$2</tt>, etc., if the match is successful. However, once that's done, since the whole combination is in the scalar context provided by the <tt>if</tt> conditional, Perl must contort the list to a scalar. To do that, it takes the number of items in the list, which is conveniently zero if the match wasn't successful, and non-zero (i.e., true) if it was.</p>

<a name="regex3-CHP-7-SECT-5.3.3"></a>
<h5 id="title-IDAWJVHJ" class="docSection3Title">7.5.3.3. "Pluck all matches"list context, with the /g modifier</H5>
<a name="IDX-CHP-7-2334"></a> 

<a name="IDX-CHP-7-2335"></a> 

<a name="IDX-CHP-7-2336"></a> 

<p class="docText">This useful construct returns a list of all text matched within capturing parentheses (or if there are no capturing parentheses, the text matched by the whole expression), not only for one match, as in the previous section, but for all matches in the string.</P>
<p class="docText">A simple example is the following, to fetch all integers in a string:</P>
<pre>
    my @nums = $text =~ m/\d+/g;
</pre><BR>

<p class="docText">If <tt>$text</tt> contains an IP<a name="IDX-CHP-7-2337"></a> 
 address like '<tt>64.156.215.24 0</tt>', <tt>@nums</tt> then receives four elements, '<tt>64</tt>', '<tt>156</tt>', '<tt>215</tt>', and '<tt>240</tt>'. Combined with other constructs, here's an easy way to turn an IP address into an eight-digit hexadecimal number such as '<tt>409cd7f0</tt>', which might be convenient for creating compact log files:</p>
<pre>
    my $hex_ip = join '', map {  sprintf("%02x", $_)<a name="IDX-CHP-7-2338"></a> 
 }  $ip =~ m/\d+/g;
</pre><BR>

<p class="docText">You can convert it back with a similar technique:</p>
<pre>
    my $ip = join '.', map { hex($_) } $he x Rip =~ m/../g
</pre><br>

<p class="docText">As another example, to match all floating-point numbers on a line, you might use:</P>
<pre>
    my @nums = $text =~ m/\d+(?:\.\d+)?;\.\d+/g;
</pre><BR>

<p class="docText">The use of non-capturing parentheses here is very important, since adding capturing ones changes what is returned. Here's an example showing how one set of capturing parentheses can be useful:</p>
<pre>
    my @Tags = $Html =~ m/&lt;(\w+)/g;
</pre><BR>

<p class="docText">This sets <tt>@Tags</tt> to the list of HTML tags, in order, found in <tt>$Html</tt>, assuming it contains no stray '&lt;' characters.</P>
<p class="docText">Here's an example with multiple sets of capturing parentheses: consider having the entire text of a Unix mailbox alias file in a single string, where logical lines look like:</p>
<pre>
    alias Jeff      jfriedl@regex.info
    alias Perlbug   perl5-porters@perl.org
    alias Prez      president@whitehouse.gov
</pre><br>

<p class="docText">To pluck an alias and full address from one of the logical lines, you can use <tt><span class="docEmphStrong">m/^alias\s+(\S+)\s+(.+)/m</span></tt> (without <tt>/g</tt>). In a list context, this returns a list of two elements, such as ('<tt>Jeff', 'jfriedl@regex.info</tt>'). Now, to match all such sets, add <tt>/g</tt>. This returns a list like:</p>
<pre>
    ( 'Jeff', 'jfriedl@regex.info', 'Perlbug',
      'perl5-porters@perl.org', 'Prez', 'president@whitehouse.gov' )
</pre><BR>

<p class="docText">If the list happens to fit a key/value pair pattern as in this example, you can actually assign it directly to an associative array. After running</P>
<pre>
    my %alias = $text =~ m/^alias\s+(\S+)\s+(.+)/mg;
</pre><br>

<p class="docText">you can access the full address of '<tt>Jeff</tt>' with <tt>$alias{Jeff}</tt>.</p>


<a name="regex3-CHP-7-SECT-5.4"></a>
<h4 id="title-IDABNVHJ" class="docSection2Title">7.5.4. Iterative Matching: Scalar Context, with /g</h4>
<p class="docText">A scalar-context<a name="IDX-CHP-7-2339"></a> 
 <tt>m/&#8943;/g</tt> is a special construct quite different from the others. Like a normal <tt>m/&#8943;/</tt>, it does just one match, but like a list-context <tt>m /&#8943;/g</tt>, it pays attention to where previous matches occurred. Each time a scalar-context <tt>m/&#8943;/g</tt> is reached, such as in a loop, it finds the "next" match. If it fails, it resets the "current position," causing the next application to start again at the beginning of the string.</P>
<p class="docText">Here's a simple example:</p>
<pre>
    $text = "WOW! This is a SILLY test.";

    $text =~ m/\b([ a -z]+\b)<span class="docEmphStrong">/g;</span>
    print "The first all-lowercase word: $1\n";
    $text =~ m/\b([A-Z]+\b)<span class="docEmphStrong">/g;</span>
    print "The subsequent all-uppercase word: $1\n";
</pre><br>

<p class="docText">With both scalar matches using the <tt>/g</tt> modifier, it results in:</P>
<pre>
    The first all-lowercase word: is
    The subsequent all-uppercase word: SILLY
</pre><br>

<p class="docText">The two scalar-<tt>/g</tt> matches work together: the first sets the "current position" to just after the matched lowercase word, and the second picks up from there to find the first uppercase word <span class="docEmphasis">that follows</span>. The <tt>/g</tt> is required for either match to pay attention to the "current position," so if <span class="docEmphasis">either</span> didn't have <tt>/g</tt>, the second line would refer to '<tt>WOW</tt>'.</p>
<p class="docText">A scalar context <tt>/g</tt> match is quite convenient as the conditional of a <tt>while</tt> loop. Consider:</P>
<pre>
    while <span class="docEmphStrong">($ConfigData =~ m/ ^(\w+)=(.,)/mg) {</span>
        my($key, $value) = ($1, $2);
          <img src=images/U22EE.jpg border=0>

    }
</pre><br>

<p class="docText">All matches are eventually found, but the body of the <tt>while</tt> loop is executed between the matches (well, <span class="docEmphasis">after</span> each match). Once an attempt fails, the result is false and the <tt>while</tt> loop finishes. Also, upon failure, the <tt>/g</tt> state is reset, which means that the next <tt>/g</tt> match starts over at the start of the string.</P>
<p class="docText">Compare</p>
<pre>
    while ($text =~ m/(\d+)/) { # <span class="docEmphasis">dangerous!</span>
       print "found: $1\n";
    }
</pre><br>

<p class="docText">and:</p>
<pre>
    while ($text =~ m /(\d+)/<span class="docEmphStrong">g</span>) {
        print "found: $1\n";
    }
</pre><br>

<p class="docText">The only difference is <tt>/g</tt>, but it's a huge difference. If <tt>$text</tt> contained, say, our earlier IP example, the second prints what we want:</p>
<pre>
    found: 64
    found: 156
    found: 215
    found: 240
</pre><br>

<p class="docText">The first, however, prints "<tt>found: 64</tt>" over and over, forever. Without the <tt>/g</tt>, the match is simply "find the first <img src=images/U2308.jpg border=0><tt>(\d+)</tt><img src=images/U230B.jpg border=0> in <tt>$text</tt>," which is '<tt>64</tt>' no matter how many times it's checked. Adding the <tt>/g</tt> to the scalar-context match turns it into "find the <span class="docEmphasis">next</span> <img src=images/U2308.jpg border=0><tt>(\d+)</tt><img src=images/U230B.jpg border=0> in <tt>$text,</tt>" which finds each number in turn.</p>
<a name="regex3-CHP-7-SECT-5.4.1"></a>
<h5 id="title-IDAHRVHJ" class="docSection3Title">7.5.4.1. The "current match location" and the <tt>pos()</tt> function</h5>
<a name="IDX-CHP-7-2340"></a> 

<p class="docText">Every string in Perl has associated with it a "current match location" at which the transmission first attempts the match. It's a property of the string, and not associated with any particular regular expression. When a string is created or modified, the "current match location" starts out at the beginning of the string, but when a <tt>/g</tt> match is successful, it's left at the location where the match ended. The next time a <tt>/g</tt> match is applied to the string, the match begins inspecting the string at that same "current match location."</p>
<p class="docText">You have access to the target string's "current match location" via the <tt>pos (&#8943;)</tt> function. For example:</p>
<pre>
    my $ip = "64.156.215.240";
    while ($ip =~ m/(\d+)/g) {
        printf "found '$1' ending at location %d\n", pos($ip);
    }
</pre><br>

<p class="docText">This produces:</P>
<pre>
    found '64' ending at location 2
    found '156' ending at location 6
    found '215' ending at location 10
    found '240' ending at location 14
</pre><br>

<p class="docText">(Remember, string indices are zero-based, so "location 2" is just before the 3rd character into the string.) After a successful <tt>/g</tt> match, <tt>$+[0]</tt> (the first element of <tt>@+</tt><a name="IDX-CHP-7-2341"></a> 
 &#9758;302) is the same as the <tt>pos</tt> of the target string.</P>
<p class="docText">The default argument to the <tt>pos()</tt> function is the same default argument for the match operator: the <tt>$_</tt><a name="IDX-CHP-7-2342"></a> 
 variable.</p>

<a name="regex3-CHP-7-SECT-5.4.2"></a>
<h5 id="title-IDA5SVHJ" class="docSection3Title">7.5.4.2. Pre-setting a string's <tt>pos</tt></H5>
<a name="IDX-CHP-7-2343"></a> 
<a name="IDX-CHP-7-2344"></a> 

<p class="docText">The real power of <tt>pos()</tt> is that you can write to it, to tell the regex engine where to start the next match (if that next match uses <tt>/g</tt>, of course). For example, the web server logs I worked with at Yahoo!<a name="IDX-CHP-7-2345"></a> 
 were in a custom format containing 32 bytes of fixed-width data, followed by the page being requested, followed by other information. One way to pick out the page is to use <img src=images/U2308.jpg border=0><tt>^. {32}</tt><img src=images/U230B.jpg border=0> to skip over the fixed-width data:</P>
<pre>
    if ($logline =~ m/^.{32}(\S+)/) {
        $RequestedPage = $1;
    }
</pre><BR>

<p class="docText">This brute-force method isn't elegant, and forces the regex engine to work to skip the first 32 bytes. That's less efficient and less clear than doing it explicitly ourself:</P>
<pre>
    <span class="docEmphStrong">pos</span>($logline) = 32; # <span class="docEmphasis">The page starts at the 32nd character, so start the
 next match there</span> ...
    if ($logline =~ m/(\S+)/<span class="docEmphStrong">g</span>) {
        $RequestedPage = $1;
    }
</pre><br>

<p class="docText">This is better, but isn't quite the same. It has the regex <span class="docEmphasis">start</span> where we want it to start, but doesn't require a match <span class="docEmphasis">at that position</span> the way the original does. If for some reason the 32<sup>nd</sup> character can't be matched by <img src=images/U2308.jpg border=0><tt>\S</tt><img src=images/U230B.jpg border=0>, the original version correctly fails, but the new version, without anything to anchor it to a particular position in the string, is subject to the transmission's bump-along. Thus, it could return, in error, a match of <img src=images/U2308.jpg border=0><tt>\S+</tt><img src=images/U230B.jpg border=0> from later in the string. Luckily, the next section shows that this is an easy problem to fix.</P>

<a name="regex3-CHP-7-SECT-5.4.3"></a>
<h5 id="title-IDA2UVHJ" class="docSection3Title">7.5.4.3. Using \G</h5>
<a name="IDX-CHP-7-2346"></a> 

<a name="IDX-CHP-7-2347"></a> 

<a name="IDX-CHP-7-2348"></a> 
<a name="IDX-CHP-7-2349"></a> 
<a name="IDX-CHP-7-2350"></a> 
<a name="IDX-CHP-7-2351"></a> 
<a name="IDX-CHP-7-2352"></a> 

<p class="docText"><img src=images/U2308.jpg border=0><tt>\G</tt><img src=images/U230B.jpg border=0> is the "anchor to where the previous match ended" metacharacter. It's exactly what we need to solve the problem in the previous section:</P>
<pre>
    pos($logline) = 32; # The page starts at the 32nd character, so start the next
 match there...
    if ($logline =~ m/<span class="docEmphStrong">\G</span>(\S+)/g)<a name="IDX-CHP-7-2353"></a> 
<a name="IDX-CHP-7-2354"></a> 
 {
        $RequestedPage = $1;
    }
</pre><BR>

<p class="docText"><img src=images/U2308.jpg border=0><tt>\G</tt><img src=images/U230B.jpg border=0> tells the transmission "don't bump-along with this regex  if you can't match successfully right away, fail."</p>
<p class="docText">There are discussions of <img src=images/U2308.jpg border=0><tt>\G</tt><img src=images/U230B.jpg border=0> in previous chapters: see the general discussion in <a class="docLink" href="regex3-CHP-3.html#regex3-CHP-3">Chapter 3</a> (&#9758;130), and the extended example in <a class="docLink" href="regex3-CHP-5.html#regex3-CHP-5">Chapter 5</a> (&#9758;212).</P>
<p class="docText">Note that Perl's <img src=images/U2308.jpg border=0><tt>\G</tt><img src=images/U230B.jpg border=0> is restricted in that it works predictably only when it is the first thing in the regex, and there is no top-level alternation. For example, in <a class="docLink" href="regex3-CHP-6.html#regex3-CHP-6">Chapter 6</a> when the CSV example is being optimized (&#9758;271), the regex begins with <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">\G(? :^|,)</span>&#8943;</tt><img src=images/U230B.jpg border=0>. Because there's no need to check for <img src=images/U2308.jpg border=0><tt>\G</tt><img src=images/U230B.jpg border=0> if the more restrictive <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0> matches, you might be tempted to change this to <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(?:^|\G</span>,)&#8943;</tt><img src=images/U230B.jpg border=0>. Unfortunately, this doesn't work in Perl; the results are unpredictable.<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-7-FN-7">[<img src=images/U2020.jpg border=0>]</a></sup></P><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-7-FN-7">[<img src=images/U2020.jpg border=0>]</a></sup> This <span class="docEmphasis">would</span> work with most other flavors that support <img src=images/U2308.jpg border=0><tt>\G</tt><img src=images/U230B.jpg border=0>, but even so, I would generally not recommend using it, as the optimization gains by having <img src=images/U2308.jpg border=0><tt>\G</tt><img src=images/U230B.jpg border=0> at the start of the regex usually outweigh the small gain by not testing <img src=images/U2308.jpg border=0><tt>\G</tt><img src=images/U230B.jpg border=0> an extra time (&#9758;246).</p></blockquote>

<a name="regex3-CHP-7-SECT-5.4.4"></a>
<h5 id="title-IDAZYVHJ" class="docSection3Title">7.5.4.4. "Tag-team" matching with /gc</h5>
<p class="docText">Normally, a failing <tt>m/&#8943;/g</tt> match attempt resets the target string's <tt>pos</tt> to the start of the string, but adding the <tt>/c</tt><a name="IDX-CHP-7-2355"></a> 
<a name="IDX-CHP-7-2356"></a> 
 modifier to <tt>/g</tt> introduces a special twist, causing a failing match to <span class="docEmphasis">not</span> reset the target's <tt>pos</tt>. (<tt>/c</tt> is never used without <tt>/g</tt>, so I tend to refer to it as <tt>/gc</tt>.)</P>
<p class="docText"><tt>m/&#8943;/gc</tt> is most commonly used in conjunction with <img src=images/U2308.jpg border=0><tt>\G</tt><img src=images/U230B.jpg border=0> to create a "lexer" that tokenizes a string into its component parts. Here's a simple example to tokenize the HTML in variable <tt>$html</tt>:</P>
<pre>
    while (not $html =~ m/\G\z/gc) # <span class="docEmphasis">While we haven't worked to the end</span>...
    {
      if ($html =~ m/\G( <span class="docEmphStrong">&lt;[^&gt;]+&gt;</span>  )/xgc) { print "TAG: $1\n" }
      elsif ($html =~ m/\G( <span class="docEmphStrong">&amp;\w+;</span>  )/xgc) { print "NAMED ENTITY: $1\n" }
      elsif ($html =~ m/\G( <span class="docEmphStrong">&amp;\#\d+;</span>  )/xgc) { print "NUMERIC ENTITY: $1\n" }
      elsif ($html =~ m/\G( <span class="docEmphStrong">[^&lt;&gt;&amp;\n]+</span>  )/xgc) { print "TEXT: $1\n" }
      elsif ($html =~ m/\G <span class="docEmphStrong">\n</span>  /xgc) { print "NEWLINE\n" }
      elsif ($html =~ m/\G( .  )/xgc) { print "ILLEGAL CHAR: $1\n" }
      else {
        die "$0: oops, this shouldn't happen!";
      }
    }
</pre><br>

<p class="docText">The bold part of each regex matches one type of HTML construct. Each is checked in turn starting from the current position (due to <tt>/gc</tt>), but can match <span class="docEmphasis">only</span> at the current position (due to <img src=images/U2308.jpg border=0><tt>\G</tt><img src=images/U230B.jpg border=0>). The regexes are checked in order until the construct at that current position has been found and reported. This leaves <tt>$html</tt>'s <tt>pos</tt><a name="IDX-CHP-7-2357"></a> 
 at the start of the next token, which is found during the next iteration of the loop.</p>
<p class="docText">The loop ends when <tt>m/\G\z/gc</tt> is able to match, which is when the current position (<img src=images/U2308.jpg border=0><tt>\G</tt><img src=images/U230B.jpg border=0>) has worked its way to the very end of the string (<img src=images/U2308.jpg border=0><tt>\z</tt><img src=images/U230B.jpg border=0>).<a name="IDX-CHP-7-2358"></a> 
<a name="IDX-CHP-7-2359"></a> 
</p>
<p class="docText">An important aspect of this approach is that one of the tests <span class="docEmphasis">must</span> match each time through the loop. If one doesn't (and if we don't abort), there would be an infinite loop, since nothing would be advancing or resetting <tt>$html</tt>'s <tt>pos</tt>. This example has a final <span class="docEmphasis">else</span> clause that will never be invoked as the program stands now, but if we were to edit the program (as we will soon), we could perhaps introduce a mistake, so keeping the <span class="docEmphasis">else</span> clause is prudent. As it is now, if the data contains a sequence we haven't planned for (such as '<tt>&lt;&gt;</tt>'), it generates one warning message per unexpected character.</p>
<p class="docText">Another important aspect of this approach is the ordering of the checks, such as the placement of <img src=images/U2308.jpg border=0><tt>\G(.)</tt><img src=images/U230B.jpg border=0> as the last check. Or, consider extending this application to recognize <tt>&lt;script&gt;</tt> blocks with:</P>
<pre>
    $html =~ m/\G (  <span class="docEmphStrong">&lt;script[^&gt;]*&gt;.*?&lt;/script&gt;</span>)/xgcsi
</pre><br>

<p class="docText">(Wow, we've used five modifiers!)<a name="IDX-CHP-7-2360"></a> 
 To work properly, this must be inserted into the program <span class="docEmphasis">before</span> the currently-first <img src=images/U2308.jpg border=0><tt>&lt;[^&gt;]+ &gt;</tt><img src=images/U230B.jpg border=0>. Otherwise, <img src=images/U2308.jpg border=0><tt>&lt;[^&gt;]+ &gt;</tt><img src=images/U230B.jpg border=0> would match the opening <tt>&lt;script&gt;</tt> tag "out from under" us.</p>
<p class="docText">There's a somewhat more advanced example of <tt>/gc</tt> in <a class="docLink" href="regex3-CHP-3.html#regex3-CHP-3">Chapter 3</a> (&#9758;132).</P>

<a name="regex3-CHP-7-SECT-5.4.5"></a>
<h5 id="title-IDAW3VHJ" class="docSection3Title">7.5.4.5. Pos-related summary</h5>
<a name="IDX-CHP-7-2361"></a> 
<a name="IDX-CHP-7-2362"></a> 

<p class="docText">Here's a summary of how the match operator interacts with the target string's <tt>pos</tt>:</P>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="4"><col><col><col><col></colgroup><thead><TR><th class="thead" scope="col" align="left"><p class="docText">Type of match</p></th><th class="thead" scope="col" align="left"><p class="docText">Where match starts</p></th><th class="thead" scope="col" align="left"><p class="docText"><tt>pos</tt> upon success</p></th><th class="thead" scope="col" align="left"><p class="docText"><tt>pos</tt> upon failure</p></th></tr></thead><tr><td class="docTableCell" align="left"><p class="docText"><tt>m/&#8943;/</tt></p></td><td class="docTableCell" align="left"><p class="docText">start of string (<tt>pos</tt> ignored)</p></td><TD class="docTableCell" align="left"><p class="docText">reset to <tt>undef</tt></p></TD><td class="docTableCell" align="left"><p class="docText">reset to <tt>undef</tt></p></TD></TR><TR><TD class="docTableCell" align="left"><p class="docText"><tt>m/&#8943;/g</tt></p></TD><td class="docTableCell" align="left"><p class="docText">starts at target's <tt>pos</tt></p></TD><TD class="docTableCell" align="left"><p class="docText">set to end of match</p></TD><TD class="docTableCell" align="left"><p class="docText">reset to <tt>undef</tt></p></td></tr><TR><TD class="docTableCell" align="left"><p class="docText"><tt>m/&#8943;/gc</tt></p></td><td class="docTableCell" align="left"><p class="docText">starts at target's <tt>pos</tt></p></TD><td class="docTableCell" align="left"><p class="docText">set to end of match</p></TD><td class="docTableCell" align="left"><p class="docText">left unchanged</p></TD></tr></table></P><br>
<p class="docText">Also, modifying a string in any way causes its <tt>pos</tt> to be reset to <tt>undef</tt> (which is the initial value, meaning the start of the string).</p>


<a name="regex3-CHP-7-SECT-5.5"></a>
<h4 id="title-IDATCWHJ" class="docSection2Title">7.5.5. The Match Operator's Environmental Relations</h4>
<p class="docText">The following sections summarize what we've seen about how the match operator influences the Perl environment, and vice versa.</p>
<a name="regex3-CHP-7-SECT-5.5.1"></a>
<h5 id="title-IDA1CWHJ" class="docSection3Title">7.5.5.1. The match operator's side effects</h5>
<a name="IDX-CHP-7-2363"></a> 

<p class="docText">Often, the side effects of a successful match are more important than the actual return value. In fact, it is quite common to use the match operator in a void context (i.e., in such a way that the return value isn't even inspected), just to obtain the side effects. (In such a case, it acts as if given a scalar context.) The following summarizes the side effects of a <tt><span class="docEmphasis">successful</span></tt> match attempt:</p>
<ul><li><p class="docList">After-match variables like <tt>$1</tt> and <tt>@+</tt> are set for the remainder of the current scope (&#9758;299).</p></li><LI><p class="docList">The <tt><span class="docEmphasis">default regex</span></tt> is set for the remainder of the current scope (&#9758;308).</p></LI><li><p class="docList">If <tt>m?&#8943;?</tt> matches, it (the specific <tt>m?&#8943;?</tt> operator) is marked as unmatchable, at least until the next call of <tt>reset</tt> in the same package (&#9758;308).</p></LI></UL>
<p class="docText">Again, these side effects occur only with a match that is successfulan unsuccessful match attempt has no influence on them. However, the following side effects happen with <span class="docEmphasis">any</span> match attempt:</P>
<UL><li><p class="docList"><tt>pos</tt> is set or reset for the target string (&#9758;313).</P></li><li><p class="docList">If <tt>/o</tt> is used, the regex is "fused" to the operator so that re-evaluation does not occur (&#9758;352).</P></LI></ul>

<a name="regex3-CHP-7-SECT-5.5.2"></a>
<H5 id="title-IDA4EWHJ" class="docSection3Title">7.5.5.2. Outside influences on the match operator</H5>
<p class="docText">What a match operator does is influenced by more than just its operands and modifiers. This list summarizes the outside influences on the match operator:</p>
<dl class="docList">
<dt><br><p><span class="docPubcolor"><span class="docEmphStrong">context</span></span></P></dt>
<dd><p class="docList">The context that a match operator is applied in (scalar, array, or void) has a large influence on how the match is performed, as well as on its return value and side effects.</P></dd>

<dt><br><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont"><span class="docEmphStrong">pos (&#8943;)</span></span></span></span></p></dt>
<dd><p class="docList">The <tt>pos</tt> of the target string (set explicitly or implicitly by a previous match) indicates where in the string the next <tt><span class="docEmphStrong">/g</span></tt>-governed match should begin. It is also where <img src=images/U2308.jpg border=0><tt>\G</tt><img src=images/U230B.jpg border=0> matches.</p></dd>

<dt><BR><p><span class="docPubcolor"><span class="docEmphStrong">default regex</span></span></p></dt>
<dd><p class="docList">The default regex is used if the provided regex is empty (&#9758;308).</P></dd>

<dt><br><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont"><span class="docEmphStrong">study</span></span></span></span></P></dt>
<dd><p class="docList">It has no effect on what is matched or returned, but if the target string has been studied, the match might be faster (or slower). See "<a class="docLink" href="regex3-CHP-7-SECT-8.html#regex3-CHP-7-SECT-8.3">The Study Function</a>" (&#9758;359).</p></dd>

<dt><BR><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont"><span class="docEmphStrong">m?&#8943;?</span> and <span class="docEmphStrong">reset</span></span></span></span></p></dt>
<dd><p class="docList">The invisible "has/hasn't matched" status of <tt>m?&#8943;?</tt> operators is set when <tt>m?&#8943;?</tt> matches or <tt>reset</tt> is called (&#9758;308).</p></dd>
</dl>

<a name="regex3-CHP-7-SECT-5.5.3"></a>
<h5 id="title-IDADIWHJ" class="docSection3Title">7.5.5.3. Keeping your mind in context (and context in mind)</h5>
<a name="IDX-CHP-7-2364"></a> 
<a name="IDX-CHP-7-2365"></a> 
<a name="IDX-CHP-7-2366"></a> 
<a name="IDX-CHP-7-2367"></a> 

<p class="docText">Before leaving the match operator, I'll put a question to you. Particularly when changing among the <tt>while</tt>, <tt>if</tt>, and <tt>foreach</tt> control constructs, you really need to keep your wits about you. What do you expect the following to print?</p>
<pre>
    <span class="docEmphStrong">while</span>  ("Larry Curly Moe" =~ m/\w+/g) {
       print "WHILE stooge is $&amp;.\n";
    }
    print "\n";
    <span class="docEmphStrong">if</span> ("Larry Curly Moe" =~ m/\w+/g) {
       print "IF stooge is $&amp;.\n";
    }
    print "\n";
    <span class="docEmphStrong">foreach</span> ("Larry Curly Moe" =~ m/\w+/g) {
    print "FOREACH stooge is $&amp;.\n";
   }
</pre><br>

<p class="docText">It's a bit tricky. <a class="docLink" href="#regex3-CHP-7-SIDEBAR-1">&#10070;</a> Turn the page to check your answer.</p>


<a name="regex3-CHP-7-SECT-5.6"></a>
<h4 id="title-IDA3JWHJ" class="docSection2Title">7.5.6. The Substitution Operator</h4>
<p class="docText">Perl's<a name="IDX-CHP-7-2368"></a> 
 substitution operator <tt><span class="docEmphStrong">s/</span>&#8943;<span class="docEmphStrong">/</span>&#8943;<span class="docEmphStrong">/</span></tt> extends a match to a full match-and-replace. The general form is:</p>
<pre>
$text =~ <span class="docEmphasis">s/regex/replacement/modifiers</span>
</pre><br>

<p class="docText">In short, the text first matched by the regex operand is replaced by the value of the replacement operand. If the <tt>/g</tt> modifier is used, the regex is repeatedly applied to the text following the match, with additional matched text replaced as well.</P>
<p class="docText">As with the match operator, the target text operand and the connecting <tt>=~</tt> are optional if the target is the variable <tt>$_</tt>.<a name="IDX-CHP-7-2369"></a> 
 But unlike the match operator's <tt>m</tt>, the substitution's <tt>s</tt> is never optional.</p>
<p class="docText">We've seen that the match operator is fairly complexhow it works, and what it returns, is dependent upon the context it's called in, the target string's <tt>pos</tt>, and the modifiers used. In contrast, the substitution operator is simple: it always returns the same information (an indication of the number of substitutions done), and the modifiers that influence how it works are easy to understand.</P>
<p class="docText">You can use any of the core modifiers described on page 292, but the substitution operator also supports two additional modifiers: <tt>/g</tt> and, described in a bit, <tt>/e</tt>.</p>

<a name="regex3-CHP-7-SECT-5.7"></a>
<h4 id="title-IDA4LWHJ" class="docSection2Title">7.5.7. The Replacement Operand</H4>
<p class="docText">With the normal <tt>s/&#8943;/&#8943;/</tt>, the replacement operand immediately follows the regex operand, using a total of three instances of the delimiter<a name="IDX-CHP-7-2370"></a> 
 rather than the two of <tt>m/&#8943;/</tt>. If the regex uses balanced delimiters (such as &lt;&#8943;&gt;), the replacement operand then has its own independent pair of delimiters (yielding a total of four). For example, <tt>s{&#8943;}{&#8943;}</tt> and <tt>s[&#8943;]/&#8943;/</tt> and <tt>s&lt;&#8943;&gt;'&#8943;</tt>' are all valid. In such cases, the two sets may be separated by whitespace, and if so, by comments as well. Balanced delimiters are commonly used with <tt>/x</tt> or <tt>/e</tt>:<a name="IDX-CHP-7-2371"></a> 
<a name="IDX-CHP-7-2372"></a> 
</P>
<pre>
    $text =~  <span class="docEmphStrong">s{</span>
        <span class="docEmphasis">...some big regex here, with lots of comments and such</span>...
    <span class="docEmphStrong">} {</span>
        <span class="docEmphasis">...a Perl code snippet to be evaluated to produce the replacement text</span>...
    <span class="docEmphStrong">}ex;</span>
</pre><BR>

<p class="docText">Take care to separate in your mind the regex and replacement operands. The regex operand is parsed in a special regex-specific way, with its own set of special delimiters (&#9758;291). The replacement operand is parsed and evaluated as a normal double-quoted string. The evaluation happens after the match (and with <tt>/g</tt>,<a name="IDX-CHP-7-2373"></a> 
<a name="IDX-CHP-7-2374"></a> 
 after each match), so <tt>$1</tt> and the like are available to refer to the proper match slice.</P>
<p class="docText">There are two situations where the replacement operand is not parsed as a double-quoted string:</p>
<UL><li><p class="docList">When the replacement operand's delimiters are single quotes, it is parsed as a single-quoted string, which means that no variable interpolation is done.</p></LI><LI><p class="docList">If the <tt>/e</tt> modifier (discussed in the next section) is used, the replacement operand is parsed like a little Perl script instead of like a double-quoted string. The little Perl script is executed after each match, with its result being used as the replacement.</p></LI></UL>

<a name="regex3-CHP-7-SECT-5.8"></a>
<h4 id="title-IDAUOWHJ" class="docSection2Title">7.5.8. The /e Modifier</h4>
<a name="IDX-CHP-7-2375"></a> 
<a name="IDX-CHP-7-2376"></a> 

<p class="docText">The <tt>/e</tt> modifier causes the replacement operand to be evaluated as a Perl code snippet, as if with <tt><span class="docEmphStrong">eval<a name="IDX-CHP-7-2377"></a> 
 {&#8943;}</span></tt>. The code snippet's syntax is checked to ensure it's valid Perl when the script is loaded, but the code is evaluated afresh after each match. After each match, the replacement operand is evaluated in a scalar context, and the result of the code is used as the replacement. Here's a simple example:</p>
<pre>
    $text =~  <span class="docEmphStrong">s/</span>-time-/localtime<span class="docEmphStrong">/ge;</span><a name="IDX-CHP-7-2378"></a> 

</pre><BR>

<p class="docText">This replaces occurrences of <img src=images/U2308.jpg border=0><tt>-time-</tt><img src=images/U230B.jpg border=0> with the results of calling Perl's <tt>localtime</tt> function in a scalar context (which returns a textual representation of the current time, such as " <tt>Mon Sep 25 18:36:51 2006</tt>").</P>
<p class="docText">Since the evaluation is done after each match, you can refer to the text just matched with the after-match variables like <tt>$1</tt>. For example, special characters that might not otherwise be allowed in a <tt>URL</tt><a name="IDX-CHP-7-2379"></a> 
 can be encoded using <tt>%</tt> followed by their two-digit hexadecimal representation. To encode all non-alphanumerics this way, you can use</p>
<a name="regex3-CHP-7-SIDEBAR-1"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Quiz Answer</h2>
<p class="docText">&#10070; <span class="docEmphasis">Answer to the question on page 318</span>.</p>
<p class="docText">The question snippets on page 318 produce:</P>
<dl class="docList"><dd><tt>WHILE stooge is Larry.</tt></dd><dd><tt>WHILE stooge is Curly.</tt></dd><dd><tt>WHILE stooge is Moe.</tt></dd><dd><tt>IF stooge is Larry.</tt></dd><dd><tt>FOREACH stooge is Moe.</tt></dd><dd><tt>FOREACH stooge is Moe.</tt></dd><dd><tt>FOREACH stooge is Moe.</tt></dd></dl>
<p class="docText">Note that if the <tt>print</tt> within the <tt>foreach</tt> loop had referred to <tt>$_</tt> rather than <tt>$&amp;</tt>, its results would have been the same as the <tt>while</tt>'s. In this <tt>foreach</tt> case, however, the result returned by the <tt>m/&#8943;/g</tt>, ('<tt>Larry</tt>', '<tt>Curly</tt>', '<tt>Moe</tt>'), goes unused. Rather, the side effect <tt>$&amp;</tt> is used, which almost certainly indicates a programming mistake, as the side effects of a listcontext <tt>m/&#8943;/g</tt> are not often useful.</p>
</td></TR></table></p><BR>
<pre>
    $url =~ s/([^a-zA- Z0-9])/<span class="docEmphStrong">sprintf('%%%02x',  ord($1))</span>/ge;
</pre><br>

<p class="docText">and to decode back to the original, you can use:</p>
<pre>
    $url =~ s/%([0-9a-f][0- 9a-f])/<span class="docEmphStrong">pack("C", hex($1)</span>)/ige;
</pre><br>

<p class="docText">In short, <tt><span class="docEmphStrong">sprintf('%%%02x</span></tt>', <span class="docEmphStrong">ord(<span class="docEmphasis">character</span>))</span> converts characters to their numeric URL representation, while <tt><span class="docEmphStrong">pack("C"</span></tt>, <span class="docEmphStrong"><span class="docEmphasis">value</span>)</span> does the opposite; consult your favorite Perl documentation for more information.</p>
<a name="regex3-CHP-7-SECT-5.8.1"></a>
<h5 id="title-IDAAUWHJ" class="docSection3Title">7.5.8.1. Multiple uses of /e</h5>
<a name="IDX-CHP-7-2380"></a> 
<a name="IDX-CHP-7-2381"></a> 
<a name="IDX-CHP-7-2382"></a> 
<a name="IDX-CHP-7-2383"></a> 
<a name="IDX-CHP-7-2384"></a> 
<a name="IDX-CHP-7-2385"></a> 
<a name="IDX-CHP-7-2386"></a> 
<a name="IDX-CHP-7-2387"></a> 

<p class="docText">Normally, repeating a modifier with an operator doesn't hurt (except perhaps to confuse the reader), but repeating the <tt>/e</tt> modifier actually changes how the replacement is done. Normally, the replacement operand is evaluated once, but if more than one '<tt>e</tt>' is given, the results of the evaluation are themselves evaluated as Perl, over and over, for as many extra '<tt>e</tt>' as are provided. This is perhaps useful mostly for an Obfuscated Perl Contest.<a name="IDX-CHP-7-2388"></a> 
</p>
<p class="docText">Still, it can be useful. Consider interpolating variables into a string manually (such as if the string is read from a configuration file). That is, you have a string that looks like '&#8943; <tt>$var</tt> &#8943;' and you want to replace the substring '<tt>$var</tt>' with the value of the variable <tt>$var</tt>.</p>
<p class="docText">A simple approach uses:</p>
<pre>
    $data =~ s/(\$[a-zA-ZR]\w+)/$1/eeg;
</pre><br>

<p class="docText">Without any <tt>/e</tt>, this would simply replace the matched '<tt>$var</tt>' with itself, which is not very useful. With one <tt>/e</tt>, it evaluates the code <tt>$1</tt>, yielding '<tt>$var</tt>', which again, effectively replaces the matched text with itself (which is again, not very useful). But with two <tt>/e</tt>, that '<tt>$var</tt>' is itself evaluated, yielding its contents. Thus, this mimics the interpolation of variables.</p>

<a name="regex3-CHP-7-SECT-5.8.2"></a>
<h5 id="title-IDAVWWHJ" class="docSection3Title">7.5.8.2. Context and Return Value</H5>
<a name="IDX-CHP-7-2389"></a> 
<a name="IDX-CHP-7-2390"></a> 
<a name="IDX-CHP-7-2391"></a> 
<a name="IDX-CHP-7-2392"></a> 
<a name="IDX-CHP-7-2393"></a> 

<p class="docText">Recall that the match operator returns different values based upon the particular combination of context and <tt>/g</tt>. The substitution operator, however, has none of these complexitiesit always returns either the number of substitutions performed or, if none were done, an empty string.</p>
<p class="docText">Conveniently, when interpreted as a Boolean (such as for the conditional of an <tt>if</tt>), the return value is taken as true if any substitutions are done, false if not.</P>


<a name="regex3-CHP-7-SECT-5.9"></a>
<h4 id="title-IDAEYWHJ" class="docSection2Title">7.5.9. The Split Operator</h4>
<p class="docText">The multifaceted <tt>split</tt> operator (often called a <span class="docEmphasis">function</span> in casual conversation) is commonly used as the converse of a list-context <tt>m/&#8943;/g</tt> (&#9758;311). The latter returns text matched by the regex, while a <tt>split</tt> with the same regex returns text <span class="docEmphasis">separated</span> by matches. The normal match <span class="docEmphStrong">$text =~ m/:/g</span> applied against a <tt>$text</tt> of '<tt><span class="docEmphStrong">IO.SYS:225558:95-10-03:-a-sh:optional</span></tt>', returns the four-element list</P>
<pre>
    (':',  ':',  ':',  ':' )
</pre><BR>

<p class="docText">which doesn't seem useful. On the other hand, <tt><span class="docEmphStrong">split(/:/, $text)</span></tt> returns the five-element list:</P>
<pre>
    ('IO.SYS',  '225558',  '95-10-03',  '-a-sh',  'optional' )
</pre><BR>

<p class="docText">Both examples reflect that <img src=images/U2308.jpg border=0><tt>:</tt><img src=images/U230B.jpg border=0> matches four times. With <tt>split</tt>, those four matches partition a copy of the target into five chunks, which are returned as a list of five strings.</p>
<p class="docText">That example splits the target string on a single character, but you can split on any arbitrary regular expression. For example,</P>
<pre>
    @Paragraphs = split(m/\s*&lt;p&gt;\s*/i, $html);
</pre><br>

<p class="docText">splits the HTML in <tt>$html</tt> into chunks, at &lt;<tt>p</tt>&gt; or &lt;<tt>P</tt>&gt;, surrounded by optional whitespace. You can even split on locations, as with</p>
<pre>
    @Lines = split(m/^/m, $lines);
</pre><BR>

<p class="docText">to break a string into its logical lines.</P>
<p class="docText">In its most simple form with simple data like this, <tt>split</tt> is as easy to understand as it is useful. However, there are many options, special cases, and special situations that complicate things. Before getting into the details, let me show two particularly useful special cases:</p>
<UL><LI><p class="docList">The special match operand <span class="docEmphStrong">//</span><a name="IDX-CHP-7-2394"></a> 
 causes the target string to be split into its component characters. Thus, <tt><span class="docEmphStrong">split(//, "short test"</span></tt>) returns a list of ten elements: <tt><span class="docEmphStrong">("s", "h", "o", ..., "s", "t")</span></tt>.</p></li><li><p class="docList">The special match operand <span class="docEmphStrong">"&#8226;"</span> (a normal string with a single space) causes the target string to be split on whitespace, similar to using <tt>m/\s+/</tt> as the operand, except that any leading and trailing whitespace are ignored. Thus, <tt><span class="docEmphStrong">split("&#8226;", "&#8226;&#8226;&#8226;a&#8226;short&#8226;&#8226;&#8226;test&#8226;&#8226;&#8226;")</span></tt> returns the strings '<tt>a</tt>', '<tt>short</tt>', and '<tt>test</tt>'.</P></LI></ul>
<p class="docText">These and other special cases are discussed a bit later, but first, the next sections go over the basics.</p>

<a name="regex3-CHP-7-SECT-5.10"></a>
<h4 id="title-IDA21WHJ" class="docSection2Title">7.5.10. Basic Split</h4>
<a name="IDX-CHP-7-2395"></a> 
<a name="IDX-CHP-7-2396"></a> 

<p class="docText"><tt>split</tt> is an operator that looks like a function, and takes up to three operands:</P>
<pre>
split(<span class="docEmphasis">match operand, target string, chunk-limit operand</span>)
</pre><br>

<p class="docText">The parentheses are optional. Default values (discussed later in this section) are provided for operands left off the end.</p>
<p class="docText"><tt>split</tt> is always used in a list context. Common usage patterns include:</P>
<pre>
     (<span class="docEmphasis">$var1</span>, <span class="docEmphasis">$var2</span>, <span class="docEmphasis">$var3</span>,  &#8943;) =  split(&#8943;);
    -----------------------------------
      @array  =  split(&#8943;);
    -----------------------------------
      for my $item  (split(&#8943;)) {
         <img src=images/U22EE.jpg border=0>
      }
</pre><br>

<a name="regex3-CHP-7-SECT-5.10.1"></a>
<h5 id="title-IDAE3WHJ" class="docSection3Title">7.5.10.1. Basic match operand</H5>
<p class="docText">The match operand has several special-case situations, but it is normally the same as the regex operand of the match operator. That means that you can use /&#8943;/ and <tt>m{&#8943;}</tt> and the like, a regex object, or any expression that can evaluate to a string. Only the core modifiers described on page 292 are supported.</p>
<p class="docText">If you need parentheses for grouping, be sure to use the <img src=images/U2308.jpg border=0><tt>(?:&#8943;)</tt><img src=images/U230B.jpg border=0> non-capturing kind. As we'll see in a few pages, the use of capturing parentheses with <tt>split</tt> turns on a very special feature.</P>

<a name="regex3-CHP-7-SECT-5.10.2"></a>
<h5 id="title-IDAX3WHJ" class="docSection3Title">7.5.10.2. Target string operand</h5>
<p class="docText">The target string is inspected, but is never modified by <tt>split</tt>. The content of <tt>$_</tt><a name="IDX-CHP-7-2397"></a> 
 is the default if no target string is provided.</p>

<a name="regex3-CHP-7-SECT-5.10.3"></a>
<h5 id="title-IDAI4WHJ" class="docSection3Title">7.5.10.3. Basic chunk-limit operand</h5>
<p class="docText">In its primary role, the chunk-limit operand specifies a limit to the number of chunks that <tt>split</tt> partitions the string into. With the sample data from the first example, <tt><span class="docEmphStrong">split(/:/, $text, 3)</span></tt> returns:</p>
<pre>
    ( 'IO. SYS',  '225558', '95-10-03:-a-sh:optional' )
</pre><br>

<p class="docText">This shows that <tt>split</tt> stopped after <tt>/:/</tt> matched twice, resulting in the requested three-chunk partition. It could have matched additional times, but that's irrelevant because of this example's chunk limit. The limit is an upper bound, so no more than that many elements will ever be returned (unless the regex has capturing parentheses, which is covered in a later section). You may still get fewer elements than the chunk limit; if the data can't be partitioned enough to begin with, nothing extra is produced to "fill the count." With our example data, <tt><span class="docEmphStrong">split(/:/, $text</span></tt>, <img border="0" alt="" width="14" height="12" SRC="images/regex3_u0705.jpg">) still returns only a five-element list. However, there is an important difference between <tt><span class="docEmphStrong">split(/:/, $text)</span></tt> and <tt><span class="docEmphStrong">split(/:/, $text</span></tt>,<img border="0" alt="" width="14" height="12" SRC="images/regex3_u0705.jpg">) which does not manifest itself with this example  keep this in mind when the details are discussed later.</p>
<p class="docText">Remember that the <span class="docEmphasis">chunk</span>-limit operand refers to the <span class="docEmphasis">chunks</span> between the matches, not to the number of matches themselves. If the limit were to refer to the matches themselves, the previous example with a limit of three would produce</p>
<pre>
    ('IO.SYS',  '225558 ',  '95-10-03',  '-a-sh:optional' )
</pre><br>

<p class="docText">which is not what actually happens.</p>
<p class="docText">One comment on efficiency: let's say you intended to fetch only the first few fields, such as with:</p>
<pre>
    ($filename, $size, $date) = split(/:/, $text);
</pre><BR>

<p class="docText">As a performance enhancement, Perl<a name="IDX-CHP-7-2398"></a> 
<a name="IDX-CHP-7-2399"></a> 
<a name="IDX-CHP-7-2400"></a> 
 stops splitting after the fields you've requested have been filled. It does this by automatically providing a chunk limit of one more than the number of items in the list.</p>

<a name="regex3-CHP-7-SECT-5.10.4"></a>
<H5 id="title-IDABBXHJ" class="docSection3Title">7.5.10.4. Advanced split</h5>
<p class="docText"><tt>split</tt> can be simple to use, as with the examples we've seen so far, but it has three special issues that can make it somewhat complex in practice:</p>
<UL><LI><p class="docList">Returning empty elements</P></LI><li><p class="docList">Special regex operands</P></li><li><p class="docList">A regex with capturing parentheses</P></LI></ul>
<p class="docText">The next sections cover these in detail.</P>


<a name="regex3-CHP-7-SECT-5.11"></a>
<H4 id="title-IDA2BXHJ" class="docSection2Title">7.5.11. Returning Empty Elements</h4>
<a name="IDX-CHP-7-2401"></a> 

<p class="docText">The basic premise of <tt>split</tt> is that it returns the text separated by matches, but there are times when that returned text is an empty string (a string of length zero, e.g., ""). For example, consider</p>
<pre>
    <div><img border="0" alt="" width="235" height="12" SRC="images/regex3_u0706.jpg"></div>
</pre><br>

<p class="docText">This returns</P>
<pre>
   ("12", "34", "", "78")
</pre><BR>

<p class="docText">The regex <img src=images/U2308.jpg border=0><tt>:</tt><img src=images/U230B.jpg border=0> matches three times, so four elements are returned. The empty third element reflects that the regex matched twice in a row, with no text in between.</p>
<a name="regex3-CHP-7-SECT-5.11.1"></a>
<h5 id="title-IDA2CXHJ" class="docSection3Title">7.5.11.1. Trailing empty elements</h5>
<p class="docText">Normally, trailing empty elements are <span class="docEmphasis">not</span> returned. For example,</p>
<pre>
    <div><img border="0" alt="" width="256" height="12" SRC="images/regex3_u0707.jpg"></div>
</pre><BR>

<p class="docText">sets <tt>@nums</tt> to the same four elements</p>
<pre>
    ("12", "34", "", "78")
</pre><br>

<p class="docText">as the previous example, even though the regex was able to match a few extra times at the end of the string. By default, <tt>split</tt> does not return empty elements at the end of the list. However, you can have <tt>split</tt> return all trailing elements by using an appropriate chunk-limit operand ...</P>

<a name="regex3-CHP-7-SECT-5.11.2"></a>
<h5 id="title-IDA4DXHJ" class="docSection3Title">7.5.11.2. The chunk-limit operand's second job</h5>
<p class="docText">In addition to possibly limiting the number of chunks, any non-zero chunk-limit operand also preserves trailing empty items.<a name="IDX-CHP-7-2402"></a> 
 (A chunk limit given as zero is exactly the same as if no chunk limit is given at all.) If you don't want to limit the number of chunks returned, but do want to leave trailing empty elements intact, simply choose a very large limit. Or, better yet, use <tt>-1</tt>, because a negative chunk limit is taken as an arbitrarily large limit: <tt><span class="docEmphStrong">split(/:/, $text, -1)</span></tt> returns all elements, including any trailing empty ones.</P>
<p class="docText">At the other extreme, if you want to remove <span class="docEmphasis">all</span> empty items, you could put <tt><span class="docEmphStrong">grep {length}</span></tt>before the <tt>split</tt>. This use of <tt>grep</tt> lets pass only list elements with non-zero lengths (in other words, elements that aren't empty):</p>
<pre>
    my @NonEmpty = grep { length } split(/:/, $text);
</pre><BR>


<a name="regex3-CHP-7-SECT-5.11.3"></a>
<h5 id="title-IDAEFXHJ" class="docSection3Title">7.5.11.3. Special matches at the ends of the string</h5>
<p class="docText">A match at the very beginning normally produces an empty element:</p>
<pre>
    <div><img border="0" alt="" width="235" height="12" SRC="images/regex3_u0706.jpg"></div>
</pre><br>

<p class="docText">That sets <tt>@nums</tt> to:</p>
<pre>
    ("", "12", "34", "", "78")
</pre><br>

<p class="docText">The initial empty element reflects the fact that the regex matched at the beginning of the string. However, as a special case, if the regex doesn't actually match any text when it matches at the start or end of the string, leading and/or trailing empty elements are <span class="docEmphasis">not</span> produced. A simple example is <tt><span class="docEmphStrong">split(/\b/, "a simple test")</span></tt>, which can match at the six marked locations in '<sub><img src=images/U22CF.jpg border=0></sub><tt>a</tt><sub><img src=images/U22CF.jpg border=0></sub>&#8226;<sub><img src=images/U22CF.jpg border=0></sub><tt>simple</tt><sub><img src=images/U22CF.jpg border=0></sub>&#8226;<sub><img src=images/U22CF.jpg border=0></sub> <tt>test</tt><sub><img src=images/U22CF.jpg border=0></sub>'. Even though it matches six times, it doesn't return seven elements, but rather only the five elements: <tt><span class="docEmphStrong">("a", "&#8226;", "simple", "&#8226;", "test")</span></tt>. Actually, we've already seen this special case, with the <tt><span class="docEmphStrong">@Lines = split(m/^/m, $lines)</span></tt> example on page 321.</p>


<a name="regex3-CHP-7-SECT-5.12"></a>
<h4 id="title-IDA4GXHJ" class="docSection2Title">7.5.12. Split's Special Regex Operands</h4>
<p class="docText"><tt>split's</tt> match operand is normally a regex literal or a regex object, as with the match operator, but there are some special cases:</p>
<ul><li><p class="docList">An empty regex for <tt>split</tt> does not mean "Use the current default regex," but to split the target string into a list of characters. We saw this before at the start of the <tt>split</tt> discussion, noting that <tt><span class="docEmphStrong">split(//, "short test")</span></tt> returns a list of ten elements: <tt><span class="docEmphStrong">("s", "h", "o", &#8943;, "s", "t")</span></tt>.</P></li><LI><p class="docList">A match operand that is a <span class="docEmphasis">string</span> (<span class="docEmphStrong">not</span> a regex) consisting of exactly one space is a special case. It's almost the same as <tt>/\s+/</tt>, except that leading whitespace<a name="IDX-CHP-7-2403"></a> 
 is skipped. This is all meant to simulate the default input-record-separator splitting that awk does with its input, although it can certainly be quite useful for general use.</p><p class="docList">If you'd like to keep leading whitespace, just use <tt>m/\s+/</tt> directly. If you'd like to keep trailing whitespace, use <tt>-1</tt> as the chunk-limit operand.</p></LI><LI><p class="docList">If no regex operand is given, a string consisting of one space (the special case in the previous point) is used as the default. Thus, a raw <tt>split</tt> without any operands is the same as <tt><span class="docEmphStrong">split('&#8226;', $_, 0)</span></tt>.</P></LI><li><p class="docList">If the regex <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0> is used, the <tt>/m</tt> modifier (for the enhanced line-anchor match mode) is automatically supplied for you. (For some reason, this does not happen for <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0>".) Since it's so easy to just use <tt>m/^<span class="docEmphStrong">/m</span></tt> explicitly, I would recommend doing so, for clarity. Splitting on <tt>m/^/m</tt> is an easy way to break a multiline string into individual lines.</P></li></ul>
<a name="regex3-CHP-7-SECT-5.12.1"></a>
<H5 id="title-IDAVJXHJ" class="docSection3Title">7.5.12.1. Split has no side effects</H5>
<p class="docText">Note that a <tt>split</tt> match operand often <span class="docEmphasis">looks</span> like a match operator, but it has none of the side effects of one. The use of a regex with <tt>split</tt> doesn't affect the default regex for later match or substitution operators. The variables <tt>$&amp;</tt>, <tt>$'</tt>, <tt>$1</tt>, and so on are not set or otherwise affected by a <tt>split</tt>. A <tt>split</tt> is completely isolated from the rest of the program with respect to side effects.<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-7-FN-8">[<img src=images/U2020.jpg border=0>]</a></sup>
</p><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-7-FN-8">[<img src=images/U2020.jpg border=0>]</a></sup> Actually, there is one side effect remaining from a feature that has been deprecated for many years, but has not actually been removed from the language yet. If <tt>split</tt> is used in a scalar or void context, it writes its results to the <tt>@_</tt> variable (which is also the variable used to pass function arguments, so be careful not to use split in these contexts by accident). <span class="docEmphStrong">use warnings</span><a name="IDX-CHP-7-2404"></a> 
<a name="IDX-CHP-7-2405"></a> 
<a name="IDX-CHP-7-2406"></a> 
 or the <tt>-w</tt><a name="IDX-CHP-7-2407"></a> 
<a name="IDX-CHP-7-2408"></a> 
 command-line argument warns you if split is used in either context.</P></blockquote>


<a name="regex3-CHP-7-SECT-5.13"></a>
<H4 id="title-IDAYLXHJ" class="docSection2Title">7.5.13. Split's Match Operand with Capturing Parentheses</h4>
<a name="IDX-CHP-7-2409"></a> 
<a name="IDX-CHP-7-2410"></a> 
<a name="IDX-CHP-7-2411"></a> 

<p class="docText">Capturing parentheses change the whole face of <tt>split</tt>. When they are used, the returned list has additional, independent elements interjected for the item(s) captured by the parentheses. This means that some or all text normally <span class="docEmphasis">not</span> returned by <tt>split</tt> is now included in the returned list.</p>
<p class="docText">For example, as part of HTML processing, <tt>split<span class="docEmphStrong">(</span>/(&lt;[^&gt;]*&gt;<span class="docEmphStrong">)</span>/)</tt> turns</p>
<pre>
    &#8943;&#8226;<span class="docEmphStrong">and</span>&#8226; &lt;B&gt;<span class="docEmphStrong">very</span>&#8226; &lt;FONT&#8226;color=red&gt;<span class="docEmphStrong">very</span>&lt;/FONT&gt;&#8226;<span class="docEmphStrong">much</span>&lt;/B&gt;&#8226;<span class="docEmphStrong">effort</span>&#8943;
</pre><BR>

<p class="docText">into:</P>
<pre>
    ( '...&#8226;and&#8226;', '&lt;B&gt;','very&#8226;', '&lt;FONT&#8226;color=red&gt;',
'very', '&lt;/FONT&gt;', '&#8226;much', '&lt;/B&gt;', '&#8226;effort...' )
</pre><br>

<p class="docText">With the capturing parentheses removed, <tt>split(/&lt;[^&gt;]*&gt;/)</tt> returns:</p>
<pre>
    ( '...&#8226;and&#8226; ', 'very&#8226;', 'very', '&#8226;much', '&#8226;effort...' )
</pre><br>

<p class="docText">The added elements do not count against a chunk limit. (The chunk limit limits the chunks that the original string is partitioned into, not the number of elements returned.)</p>
<p class="docText">If there are multiple sets of capturing parentheses, multiple items are added to the list with each match. If there are sets of capturing parentheses that don't contribute to a match, <tt>undef</tt> elements are inserted for them.</P>


<a href="7041536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-7-SECT-4.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-7-SECT-6.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>