<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 7.6.&nbsp; Fun with Perl Enhancements</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-7-SECT-5.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-7-SECT-7.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="regex3-CHP-7-SECT-6"></a>
<H3 id="title-IDAFY15D" class="docSection1Title">7.6. Fun with Perl Enhancements</H3>
<a name="IDX-CHP-7-2412"></a> 

<a name="IDX-CHP-7-2413"></a> 

<a name="IDX-CHP-7-2414"></a> 

<a name="IDX-CHP-7-2415"></a> 

<p class="docText">Many regular-expression concepts that are now available in other languages were first made available only in Perl. Examples include non-capturing parentheses, lookahead, (and later, lookbehind), free-spacing mode, (most modes, actually  and with them comes <img src=images/U2308.jpg border=0><tt>\A</tt><img src=images/U230B.jpg border=0>, <img src=images/U2308.jpg border=0><tt>\z</tt><img src=images/U230B.jpg border=0>, and <img src=images/U2308.jpg border=0><tt>\Z</tt><img src=images/U230B.jpg border=0>), atomic grouping, <img src=images/U2308.jpg border=0><tt>\G</tt><img src=images/U230B.jpg border=0>, and the conditional construct. However, these are no longer Perl specific, so they are all covered in the main chapters of this book.</P>
<p class="docText">Still, Perl developers remain innovative, so there are some major concepts available at this time only in Perl. One of the most interesting is the ability to execute arbitrary code <span class="docEmphasis">during the match attempt</span>. Perl has long featured strong integration of regular expressions into code, but this brings integration to a whole new level.</P>
<p class="docText">We'll continue with a short overview about this and other innovations available currently only in Perl, followed by the details.</p>
<a name="IDX-CHP-7-2416"></a><a name="IDX-CHP-7-2417"></a><a name="IDX-CHP-7-2418"></a><a name="IDX-CHP-7-2419"></a><a name="IDX-CHP-7-2420"></a><a name="IDX-CHP-7-2421"></a><dl class="docList">
<dt><BR><p><span class="docPubcolor"><span class="docEmphStrong">The <span class="docEmphasis">dynamic regex</span></span> <span class="docEmphStrong">construct</span> <img src=images/U2308.jpg border=0><span class="docPubcolor"><span class="docMonofont"><span class="docEmphStrong">(??{</span> perl code <span class="docEmphStrong">})</span></span></span><img src=images/U230B.jpg border=0></span></p></dt>
<a name="IDX-CHP-7-2416"></a> 

<dd><p class="docList">Each time this construct is reached during the application of the regex in which it's found, the <span class="docEmphasis">perl code</span> is executed. The result of that execution (either a regex object or a string that's then interpreted as a regex) is applied right then, as part of the current match.</P>
<p class="docList">This simple example <img src=images/U2308.jpg border=0><tt>^(\d+)<img border="0" alt="" width="113" height="13" SRC="images/regex3_u0708.jpg">$</tt><img src=images/U230B.jpg border=0> is shown with the dynamic regex construct<a name="IDX-CHP-7-2417"></a> 
 underlined. Overall, this regex matches a number at the beginning of the line, followed by exactly that many '<tt>X</tt>' until the end of the line.</P>
<p class="docList">It matches '<tt>3XXX</tt>' and '<tt>12XXXXXXXXXXXX</tt>', for example, but not '<tt>3X</tt>' or '<tt>7XXXX</tt>'.</p>
<p class="docList">If we trace though the '<tt>3XXX</tt>' example, the leading <img src=images/U2308.jpg border=0><tt>(\d+)</tt><img src=images/U230B.jpg border=0> part matches '<img border="0" alt="" width="7" height="13" SRC="images/regex3_u0709.jpg"><tt>XXX</tt>', setting <tt>$1</tt> to '3'. The regex engine then reaches the dynamic regex construct, which executes the code "<tt>X{$1}</tt>", resulting in the value '<tt>X{3}</tt>'. This is then interpreted as <img src=images/U2308.jpg border=0><tt>X{3}</tt><img src=images/U230B.jpg border=0>, and applied as part of the current regex (matching the '<tt>3</tt><img border="0" alt="" width="24" height="12" SRC="images/regex3_u0710.jpg">'). Once that's done, the trailing <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0> then matches at '<tt>3XXX</tt><sub><img src=images/U22CF.jpg border=0></sub>', resulting in an overall match.</P>
<p class="docList">As we'll see in the examples that follow, a dynamic regex is particularly useful for matching arbitrarily nested constructs.</P>
</dd>

<dt><br><p><span class="docPubcolor"><span class="docEmphStrong">The <span class="docEmphasis">embedded-code</span></span> <span class="docEmphStrong">construct</span> <img src=images/U2308.jpg border=0><span class="docPubcolor"><span class="docMonofont"><span class="docEmphStrong">(?{</span> arbitrary perl code <span class="docEmphStrong">})</span></span></span><img src=images/U230B.jpg border=0></span></p></dt>
<dd><p class="docList">Like the dynamic regex construct, this construct also executes the Perl code each time it's reached during the application of a regex, but this construct is more general in that the code doesn't need to return any specific result. Usually, the return value is not even used. (But in case it is needed later in the same regex, the return value is available in the <tt>$^R</tt><a name="IDX-CHP-7-2418"></a> 
<a name="IDX-CHP-7-2419"></a> 
 variable &#9758;302).</P>
<p class="docList">There's one case where the value produced by the code is used: when an embedded-code construct is used as the <span class="docEmphasis">if</span> of an <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(?</span> if then <span class="docEmphStrong">|</span> else<span class="docEmphStrong">)</span></tt><img src=images/U230B.jpg border=0> conditional (&#9758;140). In this case, the result is interpreted as a Boolean value, upon which either the <span class="docEmphasis">then</span> or <span class="docEmphasis">else</span> part will be applied.</P>
<p class="docList">Embedded code can be used for many things, but it's particularly useful for debugging. Here's a simple example that displays a message every time the regex is actually applied, with the embedded-code construct underlined:</p>
<pre>
    <div><img border="0" alt="" width="250" height="57" SRC="images/regex3_u0711.jpg"></div>
</pre><br>

<p class="docList">The regex matches fully just once in this test, but the message is shown six times, reflecting that the regex was at least partially applied by the transmission at the five character positions prior to the sixth time, at which point it matches fully.</p>
</dd>

<dt><br><P><span class="docPubcolor"><span class="docEmphStrong">Regex-literal overloading</span></span></p></dt>
<a name="IDX-CHP-7-2420"></a> 

<dd><p class="docList">Regex-literal overloading lets you add your own custom pre-processing of regex literals, before they're given to the regex engine. You can use this to effectively add features to Perl's<a name="IDX-CHP-7-2421"></a> 
 regex flavor. For example, Perl doesn't have separate start-of-word and end-of-word metacharacters (it has a catch-all <tt>\b</tt> word boundary), but you might want to have it recognize <tt>\&lt;</tt> and <tt>\&gt;</tt>, converting these constructs behind the scenes to ones Perl does know.</p>
<p class="docList">Regex overloading has some important limitations that severely restrict its usefulness. We'll look at this, as well as examples like the <tt>\&lt;</tt> and <tt>\&gt;</tt> idea, later in this section.</P>
</dd>
</dl>
<p class="docText">When working with Perl code embedded within a regex (either in a dynamic regex construct or an embedded-code construct), it's best to use only global variables until you understand the important issue related to <tt>my</tt> variables discussed starting on page 338.</p>
<a name="regex3-CHP-7-SECT-6.1"></a>
<h4 id="title-IDALA25D" class="docSection2Title">7.6.1. Using a Dynamic Regex to Match Nested Pairs</H4>
<a name="IDX-CHP-7-2422"></a> 
<a name="IDX-CHP-7-2423"></a> 
<a name="IDX-CHP-7-2424"></a> 
<a name="IDX-CHP-7-2425"></a> 
<a name="IDX-CHP-7-2426"></a> 

<p class="docText">A dynamic regex's main use is to allow a regex to match arbitrarily nested<a name="IDX-CHP-7-2427"></a> 
 constructs (something long thought to be impossible with regular expressions). Its quintessential example is to match content with arbitrarily nested parentheses. To see how a dynamic regex is useful for this, let's first look at why it's not possible with traditional constructs.</p>
<p class="docText">This simple regex matches a parenthesized run of text: <img src=images/U2308.jpg border=0><tt>\(<span class="docEmphStrong">([^()])*</span>\)</tt><img src=images/U230B.jpg border=0>. It doesn't allow parentheses within the outer parentheses, so it doesn't allow any nesting (that is, it supports zero levels of nesting). We can put it into a regex object and use it like this:</P>
<pre>
    my $Level0 = qr/ \( ( [^()] )* \) /x; # <span class="docEmphasis">Parenthesized text</span>
      .
      .
      .
    if ($text =~ m/\b( \w+$Level0 )/x) {
       print "found function call: $1\n";
    }
</pre><br>

<p class="docText">This would match "<tt>substr($str, 0, 3)</tt>, but not "<tt>substr($str, 0, (3+2))</tt>" because it has nested parentheses. Let's expand our regex to handle it. That means accommodating one level of nesting.</p>
<p class="docText">Allowing one level of nesting means allowing parenthesized text within the outer parentheses. So, we need to expand on the subexpression that matches between them, which is currently <img src=images/U2308.jpg border=0><tt>[^()]</tt><img src=images/U230B.jpg border=0>, by adding a subexpression that matches parenthesized text. Well, we just created that: <tt>$Level0</tt> holds such a regex. Using it, we can create the next level:</p>
<pre>
    my $Level0 = qr/ \( ( [^()]       )* \) /x; # <span class="docEmphasis">Parenthesized text</span>
    my $Level1 = qr/ \( ( [^()]| <b>$Level0</b> )* \) /x; # <span class="docEmphasis">One level of nesting</span>
</pre><br>

<p class="docText">The <tt>$Level0</tt> here is the same as before; what's new is its use in building <tt>$Level1</tt>, which matches its own set of parentheses, <span class="docEmphasis">plus</span> those of <tt>$Level0</tt>. That's one level of nesting.</p>
<p class="docText">To match another level, we can use the same approach, creating a <tt>$Level2</tt> that uses <tt>$Level1</tt> (which still uses <tt>$Level0</tt>):</p>
<pre>
    my $Level0 = qr/ \( ( [^()]           )* \) /x; # <span class="docEmphasis">Parenthesized text</span>
    my $Level1 = qr/ \( ( [^()] | $Level0 )* \) /x; # <span class="docEmphasis">One level of nesting</span>
    my $Level2 = qr/ \( ( [^()] | $Level1 )* \) /x; # <span class="docEmphasis">Two levels of nesting</span>
</pre><br>

<p class="docText">We can continue this indefinitely:</p>
<pre>
    my $Level3 = qr/ \( ( [^()] ; $Level2 )* \) /x; # <span class="docEmphasis">Three levels of nesting</span>
    my $Level4 = qr/ \( ( [^()] ; $Level3 )* \) /x; # <span class="docEmphasis">Four levels of nesting</span>
    my $Level5 = qr/ \( ( [^()] ; $Level4 )* \) /x; # <span class="docEmphasis">Five levels of nesting</span>
    <img src=images/U22EE.jpg border=0>
</pre><br>

<p class="docText"><a class="docLink" href="#regex3-CHP-7-FIG-1">Figure 7-1</a> shows the first few levels graphically.</p>
<a name="regex3-CHP-7-FIG-1"></a><p><center>
<H5 class="docFigureTitle">Figure 7-1. Matching a few levels of parentheses</h5><img border="0" alt="" width="376" height="206" SRC="images/regex3_0701.jpg">
</center></P><br>
<p class="docText">It's interesting to see the result of all those levels. Here's what <tt>$Level3</tt> boils down to:</p>
<pre>
    \(([^()]|\(([^()]|\(([^()]|\(([^()])*\))*\))*\))*\)
</pre><BR>

<p class="docText">Wow, that's ugly.</P>
<p class="docText">Luckily, we don't have to interpret it directly (that's the regex engine's job). The approach with the <tt>Level</tt> variables is easy enough to work with, but its drawback is that nesting is limited to however many <tt>$Level</tt> variables we build. This approach doesn't allow us to match to an <span class="docEmphasis">arbitrary level</span>. (Murphy's Law being what it is, if we happen to pick <span class="docEmphasis">X</span> levels to support, we'll run into data with <span class="docEmphasis">X+1</span> levels of nesting.)</P>
<p class="docText">Luckily, we can use a dynamic regex to handle nesting to an arbitrary level. To get there, realize that each of the <tt>$Level</tt> variables beyond the first is constructed identically: when it needs to match an additional level of nesting, it includes the <tt>$Level</tt> variable below it. But if the <tt>$Level</tt> variables are all the same, it could just as well include the <tt>$Level</tt> above it. In fact, if they're all the same, it could just include <span class="docEmphasis">itself</span>. If it could somehow include itself when it wanted to match another level of nesting, it would recursively handle <span class="docEmphasis">any</span> level of nesting.</P>
<p class="docText">And that's just what we can do with a dynamic regex. If we create a regex object comparable to one of the <tt>$Level</tt> variables, we can refer to it from within a dynamic regex. (A dynamic-regex construct can contain arbitrary Perl code, so long as its results can be interpreted as a regular expression; Perl code that merely returns a pre-existing regex object certainly fits the bill.) If we put our <tt>$Level</tt>-like regex object into <tt>$LevelN</tt>,<a name="IDX-CHP-7-2428"></a> 
<a name="IDX-CHP-7-2429"></a> 
 we can refer to it with <img src=images/U2308.jpg border=0><tt>(??{ $LevelN })</tt><img src=images/U230B.jpg border=0>, like this:</p>
<pre>
    my $LevelN; # <span class="docEmphasis">This must be predeclared because it's used in its own definition</span>.
    $LevelN = qr/ \(( [^()] | <B>(??{ $LevelN })</b> )* \) /x;
</pre><br>

<p class="docText">This matches arbitrarily nested parenthesized text, and can be used just like <tt>$Level0</tt> was used earlier:</p>
<pre>
    if ($text =~ m/\b( \w+$LevelN )/x) {
       print "found function call: $1\n";
    }
</pre><BR>

<p class="docText">Phew! It's not necessarily easy to wrap one's brain around this, but once it "clicks," it's a valuable tool.</P>
<p class="docText">Now that we have the basic approach worked out, I'd like to make a few tweaks for efficiency's sake. I'll replace the capturing parentheses with atomic grouping<a name="IDX-CHP-7-2430"></a> 
 (there's no need to capture, nor to backtrack), and once that's done, I can change <img src=images/U2308.jpg border=0><tt>[^()]</tt><img src=images/U230B.jpg border=0> to <img src=images/U2308.jpg border=0><tt>[^()]+</tt><img src=images/U230B.jpg border=0> for added efficiency. (Don't make this change without using atomic grouping, or you'll set yourself up for a neverending<a name="IDX-CHP-7-2431"></a> 
 match &#9758; 226.)</p>
<p class="docText">Finally, I'd like to move the <img src=images/U2308.jpg border=0><tt>\(</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>\)</tt><img src=images/U230B.jpg border=0> so that they directly surround the dynamic regex. This way, the dynamic regex construct isn't invoked by the engine until it's sure that there's something for it to match. Here's the revised version:</P>
<pre>
    $LevelN = qr/ (?&gt; [^()]+ | \( (??{ $LevelN }) \) )* /x;
</pre><BR>

<p class="docText">Since this no longer has outer <img src=images/U2308.jpg border=0><tt>\(&#183;&#183;&#183;\)</tt><img src=images/U230B.jpg border=0>, we need to include them ourselves when invoking <tt>$LevelN</tt>.</p>
<p class="docText">As a side effect of that, we have the flexibility to apply it where there <span class="docEmphasis">may</span> be sets of parentheses, not just where there <span class="docEmphasis">are</span> sets of parentheses:</p>
<pre>
     if ($text =~ m/\b( \w+ \( $LevelN \) )/x) {
         print "found function call: $1\n";
      }
      -----------------------------------
      if (not $text =~ m/^ $LevelN $/x) {
         print "mismatched parentheses!\n";
      }
</pre><br>

<p class="docText">You can see another example of <tt>$LevelN</tt> in action on page 343.</P>

<a name="regex3-CHP-7-SECT-6.2"></a>
<H4 id="title-IDANI25D" class="docSection2Title">7.6.2. Using the Embedded-Code Construct</h4>
<a name="IDX-CHP-7-2432"></a> 
<a name="IDX-CHP-7-2433"></a> 
<a name="IDX-CHP-7-2434"></a> 
<a name="IDX-CHP-7-2435"></a> 
<a name="IDX-CHP-7-2436"></a> 
<a name="IDX-CHP-7-2437"></a> 
<a name="IDX-CHP-7-2438"></a> 
<a name="IDX-CHP-7-2439"></a> 

<p class="docText">The embedded-code construct is particularly useful for regex debugging, and for accumulating information about a match while it's happening. The next few pages walk through a series of examples that eventually lead to a method for mimicking POSIX match semantics. The journey there is perhaps more interesting than the actual destination (unless you need POSIX match semantics, of course) because of the useful techniques and insight we gain along the way.</p>
<p class="docText">We'll start with some simple regex debugging techniques.</p>
<a name="regex3-CHP-7-SECT-6.2.1"></a>
<h5 id="title-IDA4J25D" class="docSection3Title">7.6.2.1. Using embedded code to display match-time information</H5>
<p class="docText">This code:</p>
<pre>
    "abcdefgh" =~ m{
      <span class="docEmphStrong">(?{</span> print "starting match at [$'|$']\n" <span class="docEmphStrong">})</span>
      (?:d|e|f)
    }x;
</pre><br>

<p class="docText">produces:</P>
<pre>
    starting match at [|abcdefgh]
    starting match at [a|bcdefgh]
    starting match at [ab|cdefgh]
    starting match at [abc|defgh]
</pre><br>

<p class="docText">The embedded-code construct is the first thing in the regex, and so executes</p>
<pre>
    print "starting match at [$'|$']\n"
</pre><BR>

<p class="docText">whenever the regex starts a new match attempt. The displayed string uses the <tt>$'</tt> and <tt>$'</tt> variables (&#9758; 300)<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-7-FN-9">[<img src=images/U2020.jpg border=0>]</a></sup> to print the target text being matched, with '<tt>|</tt>' inserted to mark the current location in the match (which in this case is where the match attempt is starting). From the result, you can tell that the regex was applied four times by the transmission (&#9758; 148) before it was successful.</p><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-7-FN-9">[<img src=images/U2020.jpg border=0>]</a></sup> Normally, I recommend against using the special match variables <tt>$</tt>', <tt>$&amp;</tt>, and <tt>$</tt>', as they can inflict a major efficiency penalty on the entire program (&#9758; 356), but they're fine for temporary debugging.</P></blockquote>
<p class="docText">In fact, if we were to add</p>
<pre>
    (?{ print "matched at [$'&lt;$&amp;&gt;$']\n" })
</pre><br>

<p class="docText">just before the end of the regex, it would show the match:</p>
<pre>
    matched at [abc&lt;d&gt;efgh]
</pre><br>

<p class="docText">Now, compare the first example with the following, which is identical except that the "main" regex is now <img src=images/U2308.jpg border=0><tt>[def]</tt><img src=images/U230B.jpg border=0> rather than <img src=images/U2308.jpg border=0><tt>(?:d|e|f)</tt><img src=images/U230B.jpg border=0>:</p>
<pre>
    "abcdefgh" =~ m{
      <span class="docEmphStrong">(?{</span> print "starting match at [$'|$']\n" <span class="docEmphStrong">})</span>
      [def]
    }x;
</pre><br>

<p class="docText">In theory, the results should be identical, yet this produces only:</p>
<pre>
    starting match at [abc|defgh]
</pre><br>

<p class="docText">Why the difference? Perl is smart enough to apply the <span class="docEmphasis">initial class discrimination</span><a name="IDX-CHP-7-2440"></a> 
<a name="IDX-CHP-7-2441"></a> 
 optimization (&#9758; 247) to the regex with <img src=images/U2308.jpg border=0><tt>[def]</tt><img src=images/U230B.jpg border=0>, thereby allowing the transmission to bypass attempts it felt were obviously destined to fail. As it turns out, it was able to bypass all attempts except the one that resulted in a match, and the embedded-code construct allows us to see that happen.</p>
<a name="regex3-CHP-7-SIDEBAR-2"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">panic: top_env</h2>
<a name="IDX-CHP-7-2442"></a> 

<p class="docText">If you're working with embedded code or a dynamic regex, and your program suddenly ends with an unceremonial</P>
<pre>
    panic: top_env
</pre><br>

<p class="docText">it is likely due to a syntax error in the code part of the regex. Perl currently doesn't handle certain kinds of broken syntax well, and the panic is the result. The solution, of course, is to correct the syntax.</p>
</TD></TR></table></P><BR>

<a name="regex3-CHP-7-SECT-6.2.2"></a>
<h5 id="title-IDAMN25D" class="docSection3Title">7.6.2.2. Using embedded code to see all matches</H5>
<a name="IDX-CHP-7-2443"></a> 
<a name="IDX-CHP-7-2444"></a> 
<a name="IDX-CHP-7-2445"></a> 
<a name="IDX-CHP-7-2446"></a> 
<a name="IDX-CHP-7-2447"></a> 
<a name="IDX-CHP-7-2448"></a> 
<a name="IDX-CHP-7-2449"></a> 
<a name="IDX-CHP-7-2450"></a> 
<a name="IDX-CHP-7-2451"></a> 
<a name="IDX-CHP-7-2452"></a> 
<a name="IDX-CHP-7-2453"></a> 
<a name="IDX-CHP-7-2454"></a> 
<a name="IDX-CHP-7-2455"></a> 

<p class="docText">Perl has a Traditional NFA engine, so it stops the moment a match is found, even though there may be additional possible matches. With the clever use of embedded code, we can trick Perl into showing us <span class="docEmphasis">all</span> possible matches. To see how, let's revisit the silly '<tt>oneself</tt>' example from page 177:</p>
<pre>
    "oneselfsufficient" =~ m{
        one(self)?(selfsufficient)?
    (?{ print "matched at [$'&lt;$&amp;&gt;$']\n" })
    }x;
</pre><br>

<p class="docText">As might be expected, this displays</P>
<pre>
    matched at [&lt;oneself&gt;sufficient]
</pre><BR>

<p class="docText">indicating that '<img border="0" alt="" width="137" height="13" SRC="images/regex3_u0712.jpg">' had been matched at that point in the regex.</p>
<p class="docText">It's important to realize that despite the "<tt>matched</tt>" in the message, the print is not actually showing "the match," but rather the match <span class="docEmphasis">to that point</span>. The distinction is academic with this example because the embedded-code construct is the last thing in the regex. We know that the regex does indeed finish the moment the embedded-code construct has finished, reporting that same result as the actual match.</P>
<p class="docText">What if we added <img src=images/U2308.jpg border=0><tt>(?!)</tt><img src=images/U230B.jpg border=0><a name="IDX-CHP-7-2456"></a> 
 just after the embedded-code construct? <img src=images/U2308.jpg border=0><tt>(?!)</tt><img src=images/U230B.jpg border=0> is a negative lookahead that always fails. When it fails just after the embedded code is processed (just after a "matched" message is printed), it forces the engine to backtrack in search of a (new) match. The failure is forced after every "match" is printed, so we end up exploring every path to a match, and thus see all possible matches:</P>
<pre>
    matched at [&lt;oneself&gt;sufficient]
    matched at [&lt;oneselfsufficient&gt;]
    matched at [&lt;one&gt;selfsufficient]
</pre><br>

<p class="docText">What we've done ensures that the overall match attempt actually fails, but in doing so we've got the regex engine to report all the possible matches. Without the <img src=images/U2308.jpg border=0><tt>(?!)</tt><img src=images/U230B.jpg border=0>, Perl returns the first match found, but with it, we can see the remaining permutations.</p>
<p class="docText">With that in mind, what do you think the following prints?</p>
<pre>
    "123" =~ m{
       \d+
      (?{ print "matched at [$'&lt;$&amp;&gt;$']\n" })
      <span class="docEmphStrong">(?!)</span>
    }x;
</pre><BR>

<p class="docText">It displays:</P>
<pre>
    matched at [&lt;123&gt;]
    matched at [&lt;12&gt;3]
    matched at [&lt;1&gt;23]
    matched at [1&lt;23&gt;]
    matched at [1&lt;2&gt;3]
    matched at [12&lt;3&gt;]
</pre><br>

<p class="docText">Hopefully at least the first three were expected, but the rest might be unexpected if you're not on your toes. The <tt>(?!)</tt> forces backtracking and the eventual appearance of the 2<sup>nd</sup> and 3<sup>rd</sup> lines. When the attempt at the start of the line fails, the transmission reapplies the regex again starting just before the 2<sup>nd</sup> character. (<a class="docLink" href="regex3-CHP-4.html#regex3-CHP-4">Chapter 4</a> explains this in great detail.) The 4<sup>th</sup> and 5<sup>th</sup> lines shown are from that second attempt, and the last line shown is from the third attempt.</p>
<p class="docText">So, adding the <tt>(?!)</tt> really does cause it to show <span class="docEmphasis">all</span> possible matches, not just all of them from a particular starting point. It may be useful to see only the possible matches from a particular starting point; we'll look into that in a bit.</p>

<a name="regex3-CHP-7-SECT-6.2.3"></a>
<h5 id="title-IDAJS25D" class="docSection3Title">7.6.2.3. Finding the longest match</H5>
<a name="IDX-CHP-7-2457"></a> 

<a name="IDX-CHP-7-2458"></a> 

<p class="docText">Now, instead of showing all the matches, let's find and save the longest match. We can do this by using a variable to keep track of the longest match seen so far and comparing each new "almost match" against it. Here is the solution with the '<tt>oneself</tt>' example:</p>
<pre>
    $longest_match = undef; # <span class="docEmphasis">We'll keep track of the longest match here</span>

    "oneselfsufficient" =~ m{
       one(self)?(selfsufficient)?
       <span class="docEmphStrong">(?{</span>
         # <span class="docEmphasis">Check to see if the current match ($&amp;) is the longest so far</span>
         if (not defined($longest_match)
            or
            length($&amp;) &gt; length($longest_match))
         {
            $longest_match = $&amp;;
         }
      <span class="docEmphStrong">})</span>
     (?!) # <span class="docEmphasis">Force failure so we'll backtrack to find further "matches"</span>
    }x;
    # <span class="docEmphasis">Now report the accumulated result, if any</span>
    if (defined($longest_match)) {
       print "longest match=[$longest_match]\n";
    } else {
       print "no match\n";
    }
</pre><br>

<p class="docText">Not surprisingly, this shows '<tt>longest match=[oneselfsufficient]</tt>'. That bit of embedded code is pretty long, and something we'll likely use in the future, so let's encapsulate it and the <img src=images/U2308.jpg border=0><tt>(?!)</tt><img src=images/U230B.jpg border=0> into their own regex object:</P>
<pre>
    my $RecordPossibleMatch = qr{
       <span class="docEmphStrong">(?{</span>
          # <span class="docEmphasis">Check to see if the current match ($&amp;) is the longest so far</span>
          if (not defined($longest_match)
              or
              length($&amp;) &gt; length($longest_match))
          {
              $longest_match = $&amp;;
          }
    })
    (?!) # <span class="docEmphasis">Force failure so we'll backtrack to find further "matches"</span>
    }x;
</pre><br>

<p class="docText">Here's a simple example that finds '<tt>9938</tt>', the longest match <span class="docEmphasis">overall</span>:</p>
<pre>
    $longest_match = undef; # <span class="docEmphasis">We'll keep track of the longest match here</span>
    "800-998-9938" =~ m{ \d+ $RecordPossibleMatch }x;
    # <span class="docEmphasis">Now report the accumulated result, if any</span>
    if (defined($longest_match)) {
        print "longest match=[$longest_match]\n";
    } else {
       print "no match\n";
    }
</pre><BR>


<a name="regex3-CHP-7-SECT-6.2.4"></a>
<h5 id="title-IDARU25D" class="docSection3Title">7.6.2.4. Finding the longest-leftmost match</H5>
<a name="IDX-CHP-7-2459"></a> 
<a name="IDX-CHP-7-2460"></a> 
<a name="IDX-CHP-7-2461"></a> 
<a name="IDX-CHP-7-2462"></a> 
<a name="IDX-CHP-7-2463"></a> 
<a name="IDX-CHP-7-2464"></a> 

<p class="docText">Now that we know how to find the longest match overall, let's restrict it to finding the longest-<span class="docEmphasis">leftmost</span> match. That just happens to be the match that a POSIX NFA would find (&#9758; 177). To accomplish this, we need to disable the transmission's bump-ahead <span class="docEmphasis">if</span> we've seen a match so far. That way, once we find the first match, normal backtracking still brings us to any other matches available from the same starting location (allowing us to keep track of the longest match), but the disabled bump-ahead inhibits the finding of matches that start later in the string.</p>
<p class="docText">Perl<a name="IDX-CHP-7-2465"></a> 
 doesn't give us direct hooks into the transmission, so we can't disable the bump-ahead directly, but we can get the same effect by not allowing the regex to proceed past the start if <tt>$longest_match</tt> is already defined. The test for that is <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(?{</span> defined $longest_match<span class="docEmphStrong">})</span></tt><img src=images/U230B.jpg border=0>, but that alone not enough, since it's just a test. The key to using the results of the test lies in a <span class="docEmphasis">conditional</span>.</p>

<a name="regex3-CHP-7-SECT-6.2.5"></a>
<h5 id="title-IDASW25D" class="docSection3Title">7.6.2.5. Using embedded code in a conditional</h5>
<p class="docText">To have the regex engine respond to the results of our test, we use the test as the <span class="docEmphasis">if</span> of an <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(?</span> if then <span class="docEmphStrong">|</span> else<span class="docEmphStrong">)</span></tt><img src=images/U230B.jpg border=0> conditional (&#9758; 140). Since we want the regex to stop if the test is true, we use a fail-now <tt>(?!)</tt><a name="IDX-CHP-7-2466"></a> 
 as the <span class="docEmphasis">then</span> part. (We don't need an <span class="docEmphasis">else</span> part, so we just omit it.) Here's a regex object that encapsulates the conditional:</p>
<pre>
<div><img border="0" alt="" width="437" height="12" SRC="images/regex3_u0713.jpg"></div>
</pre><br>

<p class="docText">The <span class="docEmphasis">if</span> part is underlined, and the <span class="docEmphasis">then</span> part is shown in bold. Here it is in action, combined with the <tt>$RecordPossibleMatch</tt> defined on the facing page:</p>
<pre>
    "800-998-9938" =~ m{ $BailIfAnyMatch <span class="docEmphStrong">\d+</span> $RecordPossibleMatch }x;
</pre><br>

<p class="docText">This finds '<tt>800</tt>', the POSIX "longest of all leftmost matches" match.</p>


<a name="regex3-CHP-7-SECT-6.3"></a>
<h4 id="title-IDAVY25D" class="docSection2Title">7.6.3. Using <tt>local</tt> in an Embedded-Code Construct</h4>
<a name="IDX-CHP-7-2467"></a> 
<a name="IDX-CHP-7-2468"></a> 
<a name="IDX-CHP-7-2469"></a> 
<a name="IDX-CHP-7-2470"></a> 

<p class="docText">The use of <tt>local</tt> within an embedded-code construct takes on special meaning. Understanding it requires a good understanding of <span class="docEmphasis">dynamic scoping</span> (&#9758; 295) and of the "crummy analogy" from the <a class="docLink" href="regex3-CHP-4.html#regex3-CHP-4">Chapter 4</a>'s discussion of how a regex-directed NFA engine goes about its work (&#9758; 158). The following contrived (and, as we'll see, flawed) example helps to illustrate why, without a lot of extraneous clutter. It checks to see if a line is composed of only <img src=images/U2308.jpg border=0><tt>\w+</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>\s+</tt><img src=images/U230B.jpg border=0>, but counts how many of the <img src=images/U2308.jpg border=0><tt>\w+</tt><img src=images/U230B.jpg border=0> are really <img src=images/U2308.jpg border=0><tt>\d+\b</tt><img src=images/U230B.jpg border=0>:</p>
<pre>
    my $Count = 0;

    $text =~ m{
       ^ <span class="docEmphStrong">(?&gt;</span> \d+ <div><img border="0" alt="" width="107" height="12" SRC="images/regex3_u0714.jpg"></div> \b | \w+ | \s+ <span class="docEmphStrong">)</span>*$
    }x;
</pre><BR>

<p class="docText">When this is matched against a string like '<tt>123&#8226;abc&#8226;73&#8226;9271&#8226;xyz</tt>', the <tt>$Count</tt> variable is left with a value of three. However, when applied to '<tt>123&#8226;&#8226;abc&#8226;73xyz</tt>' it's left with a value of two, even though it should be left with a value of just one. The problem is that <tt>$Count</tt> is updated after matching '<tt>73</tt>', something that is matched by <img src=images/U2308.jpg border=0><tt>\d+</tt><img src=images/U230B.jpg border=0> but later "<tt>unmatched</tt>" via backtracking because the subsequent <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0> can't match. The problem arises because the code executed via the embeddedcode construct is not somehow "unexecuted" when its part of the regex is "unmatched" via backtracking.</p>
<p class="docText">In case you have any confusion with the use of <img src=images/U2308.jpg border=0><tt>(?&gt;&#8943;)</tt><img src=images/U230B.jpg border=0> atomic grouping (&#9758; 139) and the backtracking going on here, I'll mention that the atomic grouping is used to prevent a neverending-match (&#9758; 269), and does not affect backtracking <span class="docEmphasis">within</span> the construct, only backtracking <span class="docEmphasis">back into</span> the construct after it's been exited. So the <img src=images/U2308.jpg border=0><tt>\d+</tt><img src=images/U230B.jpg border=0> is free to be "unmatched" if the subsequent <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0> cannot match.</P>
<p class="docText">The easy solution for this contrived example is to put the <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0> before incrementing <tt>$Count</tt>, to ensure that it is incremented only when it won't be undone. However, I'd like to show a solution using <tt>local</tt>,<a name="IDX-CHP-7-2471"></a> 
 to illustrate its effect within Perl executed during the application of a regex. With that in mind, consider this new version:</p>
<pre>
    our<a name="IDX-CHP-7-2472"></a> 
 $Count = 0;
    $text =~ m{
     ^ <span class="docEmphStrong">(?&gt;</span> \d+ (?{ local($Count) = $Count + 1 }) \b | \w+ | \s+ )* $
    }x;
</pre><br>

<p class="docText">The first change to notice is that <tt>$Count</tt> changed from a <tt>my</tt> variable to a global one (if you <tt><span class="docEmphStrong">use strict</span></tt>,<a name="IDX-CHP-7-2473"></a> 
<a name="IDX-CHP-7-2474"></a> 
 as I always recommend, you can't use an unqualified global variable unless you "declare" it with Perl's our declarator).</P>
<p class="docText">The other change is that the increment of <tt>$Count</tt> has been localized. Here's the key behavior: <span class="docEmphasis">when a variable is localized within a regex, the original value is replaced (the new value is lost) if the code with the</span> <tt>local</tt> <span class="docEmphasis">is "unmatched" because of backtracking</span>. So, even though <tt>local($Count) = $Count + 1</tt> is executed after '73' is matched by <img src=images/U2308.jpg border=0><tt>\d+</tt><img src=images/U230B.jpg border=0>, changing <tt>$Count</tt> from one to two, that change is "localized to the success of the path" that the regex is on when <tt>local</tt> is called. When the <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0> fails, the regex engine logically backtracks to before the <tt>local</tt>, and <tt>$Count</tt> reverts to its original value of one. And that's the value it ends up having when the end of the regex is eventually reached.</P>
<a name="regex3-CHP-7-SIDEBAR-3"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>
<H2 class="docSidebarTitle">Interpolating Embedded Perl</h2>
<p class="docText">As a security measure, Perl doesn't normally allow an embedded-code construct <img src=images/U2308.jpg border=0><tt>(?{&#8943;})</tt><img src=images/U230B.jpg border=0> or a dynamic-subexpression construct <img src=images/U2308.jpg border=0><tt>(??{&#8943;})</tt><img src=images/U230B.jpg border=0> to be interpolated into the regex from a string variable. (They are allowed, though, from a regex object, as with <tt>$RecordPossibleMatch</tt> on page 334.) That is,</p>
<pre>
    m{ (?{ print "starting\n" }) some regex&#8943; }x;
</pre><BR>

<p class="docText">is allowed, but</P>
<pre>
    my <b>$ShowStart</b> = '(?{ print "starting\n" })';
        <img src=images/U22EE.jpg border=0>
    m{ <B>$ShowStart</b> <span class="docEmphasis">some regex</span>&#8943; }x;
</pre><BR>

<p class="docText">is not. This limitation is imposed because it has long been common to include user input as part of a regex, and the introduction of these constructs suddenly allowing such a regex to run arbitrary code creates a huge security hole. So, the default is that it's disallowed.</p>
<p class="docText">If you'd like to allow this kind of interpolation, the declaration:</p>
<pre>
    use re 'eval';<a name="IDX-CHP-7-2475"></a> 

</pre><br>

<p class="docText">lifts the restriction. (With different arguments, the <tt>use re</tt> pragma can also be used for debugging; &#9758;361.)</P>
<p class="docText"><span class="docEmphStrong"><span class="docEmphasis">Sanitizing user input for interpolation</span></span></P>
<p class="docText">If you use this and do allow user input to be interpolated, be sure that it has no embedded-Perl or dynamic-regex constructs. You can do this by checking against <img src=images/U2308.jpg border=0><tt>\(\s*\?+[p{]</tt><img src=images/U230B.jpg border=0>. If this matches the input, it's not safe to use in a regex. The <img src=images/U2308.jpg border=0><tt>\s*</tt><img src=images/U230B.jpg border=0> is needed because the <tt>/x</tt> modifier allows spaces after the opening parentheses. (I'd think that they shouldn't be allowed there, but they are.) The plus quantifies <img src=images/U2308.jpg border=0><tt>\?</tt><img src=images/U230B.jpg border=0> so that both constructs are recognized. Finally, the <tt>p</tt> is included to catch the now-deprecated <img src=images/U2308.jpg border=0><tt>(?p{&#8943;})</tt><img src=images/U230B.jpg border=0> construct, the forerunner of <img src=images/U2308.jpg border=0><tt>(??{&#8943;})</tt><img src=images/U230B.jpg border=0>.</p>
<p class="docText">I think it would be useful if Perl supported a modifier of some sort that allowed or prohibited embedded code on a per-regex or subexpression basis, but until one is introduced, you'll have to check for it yourself, as described above.</p>
</td></tr></table></P><br>
<p class="docText">So, <tt>local</tt> is required to keep <tt>$Count</tt> consistent until the end of the regex. If we were to put <img src=images/U2308.jpg border=0><tt>(?{ print "Final count is $Count.\n" })</tt><img src=images/U230B.jpg border=0> at the end of the regex, it would report the proper count. Since we want to use <tt>$Count</tt> after the match, we need to save it to a non-localized variable at some point before the match officially ends. This is because all values that had been localized during the match are lost when the match finishes.</p>
<p class="docText">Here's an example:</P>
<pre>
    my<a name="IDX-CHP-7-2476"></a> 
 $Count = undef;
    our $TmpCount = 0;
    $text =~ m{
     ^ <span class="docEmphStrong">(?&gt;</span> \d+ (?{ local($TmpCount) = $TmpCount + 1 }) \b | \w+ | \s+ <span class="docEmphStrong">)</span>+ $
     (?{ $Count = $TmpCount }) # <span class="docEmphasis">Save the "ending" $Count to a non-localized
 variable</span>
    }x;
    if (defined $Count) {
        print "Count is $Count.\n";
    } else {
        print "no match\n";
    }
</pre><br>

<p class="docText">This seems like a lot of work for something so simple, but again, this is a contrived example designed just to show the mechanics of localized variables within a regex. We'll see practical use in "<a class="docLink" href="#regex3-CHP-7-SECT-6.8">Mimicking Named Capture</a>" on page 344.</p>

<a name="regex3-CHP-7-SECT-6.4"></a>
<H4 id="title-IDAMB35D" class="docSection2Title">7.6.4. A Warning About Embedded Code and <tt>my</tt> Variables</h4>
<a name="IDX-CHP-7-2477"></a> 
<a name="IDX-CHP-7-2478"></a> 
<a name="IDX-CHP-7-2479"></a> 
<a name="IDX-CHP-7-2480"></a> 

<p class="docText">If you have a <tt>my</tt> variable declared <span class="docEmphasis">outside</span> a regex, but refer to it from <span class="docEmphasis">inside</span> regex embedded code, you must be very careful about a subtle issue with Perl's variable binding that has a very unsubtle impact. Before describing the issue, I'll note up front that if you use only global variables within regex embedded code, you don't have to worry about this issue, and you can safely skip this section. Warning: this section is not light reading.</P>
<p class="docText">This contrived example illustrates the problem:</p>
<pre>
    sub CheckOptimizer
    {
        my $text = shift;  # <span class="docEmphasis">The first argument is the text to check</span>.
        my <b>$start</b> = undef; # <span class="docEmphasis">We'll note here where the regex is first applied</span>.
        my $match = $text =~ m{
          (?{ <b>$start</b> = $-[0] if not defined <b>$start</b>}) # <span class="docEmphasis">Save the first starting
 position</span>
          \d # <span class="docEmphasis">This is the regex being tested</span>
        }x;
        if (not defined <b>$start</b>) {
            print "The whole match was optimized away.\n";
            if ($match) {
                # <span class="docEmphasis">This can't possibly happen!</span>
                print "Whoa, but it matched! How can this happen!?\n";
            }
        } elsif (<b>$start</b> == 0) {
            print "The match start was not optimized.\n";
        } else {
            print "The optimizer started the match at character <b>$start</b>.\n"
        }
    }
</pre><br>

<p class="docText">This code has three <tt>my</tt> variables, but only one, <tt>$start</tt>, is related to this issue (the others are not referenced from within embedded code, so are not at issue). It works by first setting <tt>$start</tt> to the undefined value, then applying a match in which the leading component is an embedded-code construct that sets <tt>$start</tt> to the starting location of the attempt, but only if it hasn't already been set. The "starting location of the attempt" is derived from <tt>$-[0]</tt> (the first element of <tt>@-</tt><a name="IDX-CHP-7-2481"></a> 
 &#9758; 302).</p>
<p class="docText">So, when this function is called with</p>
<pre>
    CheckOptimizer("test 123");
</pre><br>

<p class="docText">the result is:</p>
<pre>
    The optimizer started the match at character 5.
</pre><BR>

<p class="docText">That's OK, but if we invoke the exact same call again, the second time shows:</p>
<pre>
    The whole match was optimized away.
    Whoa, but it matched! How can this happen!?
</pre><BR>

<p class="docText">Even though the text checked by the regex is the same (as is the regex itself, for that matter), the result is different, and seems to be wrong. Why? The problem is that the second time through, the <tt>$start</tt> that the embedded code is updating is the one that existed the first time through, when the regex was compiled. The <tt>$start</tt> that the rest of the function uses is actually a new variable created afresh when the <tt>my</tt> is executed at the start of each function call.</p>
<p class="docText">The key to this issue is that <tt>my</tt> variables in embedded code are "locked in" (<span class="docEmphasis">bound</span>, in programming terminology) to <span class="docEmphasis">the specific instance</span> of the <tt>my</tt> variable that is active <span class="docEmphasis">at the time</span> the regex is compiled. (Regex compilation is discussed in detail starting on page 348.) Each time <tt>CheckOptimizer</tt> is called, a <span class="docEmphasis">new instance</span> of <tt>$start</tt> is created, but for esoteric reasons, the <tt>$start</tt> inside the embedded code still refers to the first instance that is now longone. Thus, the instance of <tt>$start</tt> that the rest of the function uses doesn't receive the value ostensibly written to it within the regex.</p>
<p class="docText">This type of instance binding<a name="IDX-CHP-7-2482"></a> 
<a name="IDX-CHP-7-2483"></a> 
 is called a <span class="docEmphasis">closure</span>, and books like <span class="docEmphasis">Programming Perl</span><a name="IDX-CHP-7-2484"></a> 
<a name="IDX-CHP-7-2485"></a> 
 and <span class="docEmphasis">Object Oriented Perl</span><a name="IDX-CHP-7-2486"></a> 
<a name="IDX-CHP-7-2487"></a> 
 discuss why it's a valuable feature of the language. There is debate in the Perl community, however, as to just how much of a "feature" it is in this case. To most people, it's very unintuitive.</P>
<p class="docText">The solution is to not refer to <tt>my</tt> variables from within a regex unless you know that the regex literal will be compiled at least as often as the <tt>my</tt> instances are refreshed. For example, the <tt>my</tt> variable <tt>$NestedStuffRegex</tt><a name="IDX-CHP-7-2488"></a> 
<a name="IDX-CHP-7-2489"></a> 
 is used within the <tt>SimpleConvert</tt> subroutine in the listing on page 345, but we know this is not a problem because there's only ever one instance of <tt>$NestedStuffRegex</tt>. Its <tt>my</tt> is not in a function or a loop, so it's created just once when the script is loaded, with that same instance existing until the program ends.</P>

<a name="regex3-CHP-7-SECT-6.5"></a>
<H4 id="title-IDAJH35D" class="docSection2Title">7.6.5. Matching Nested Constructs with Embedded Code</H4>
<a name="IDX-CHP-7-2490"></a> 
<a name="IDX-CHP-7-2491"></a> 
<a name="IDX-CHP-7-2492"></a> 
<a name="IDX-CHP-7-2493"></a> 
<a name="IDX-CHP-7-2494"></a> 
<a name="IDX-CHP-7-2495"></a> 
<a name="IDX-CHP-7-2496"></a> 
<a name="IDX-CHP-7-2497"></a> 

<p class="docText">The example on page 328 shows how to match arbitrarily nested<a name="IDX-CHP-7-2498"></a> 
 pairs using a dynamic regex. That's generally the easiest way to do it, but it's instructive to see a method using only embedded-code constructs, so I'd like to show it to you here.</p>
<p class="docText">The approach is simply this: keep a count of how many open parentheses we've seen that have not yet been closed, and allow a closing parenthesis only if there are outstanding opens. We'll use embedded code to keep track of the count as we match through the text, but before looking at that, let's look at a (not yet working) skeleton of the expression:</P>
<pre>
    my $NestedGuts = qr{
      (?&gt;
         (?:
           # <span class="docEmphasis">Stuff not parenthesis</span>
             [^()]+
           # <span class="docEmphasis">An opening parenthesis</span>
           | \(
           # <span class="docEmphasis">A closing parenthesis</span>
           | \)
       )*
     )
   }x;
</pre><br>

<p class="docText">The atomic grouping<a name="IDX-CHP-7-2499"></a> 
 is required for efficiency, to keep the <img src=images/U2308.jpg border=0><tt>( [&#8943;]+ |&#8943;)*</tt><img src=images/U230B.jpg border=0> from becoming a neverending<a name="IDX-CHP-7-2500"></a> 
 match (&#9758; 226) if <tt>$NestedGuts</tt> is used as part of some larger expression that could cause backtracking. For example, if we used it as part of <tt>m/^\( $NestedGuts \)$/x</tt> and applied it to '<tt>(this&#8226;is&#8226;missing&#8226;the&#8226;close</tt>', it would track and backtrack for a long time if atomic grouping didn't prune the redundant states.</p>
<p class="docText">To incorporate the counting, we need these four steps:</P>
<UL><li><p class="docList">&#10102; Before beginning, the count must be initialized to zero:</P><pre>
    (?{ local $OpenParens = 0 })
</pre><BR>
</li><li><p class="docList">&#10103; When an open parenthesis is seen, we increment the count to indicate that one more set of parentheses has yet to balance.</p><pre>
    (?{ $OpenParens++ })
</pre><BR>
</LI><li><p class="docList">&#10104; When a close parenthesis is seen, we check the count, and if it's currently positive, we decrement the count to recognize that one less set remains unbalanced. On the other hand, if the count is zero, we can't allow the match to continue (because the close parenthesis does not balance with an open), so we apply <img src=images/U2308.jpg border=0><tt>(?!)</tt><img src=images/U230B.jpg border=0><a name="IDX-CHP-7-2501"></a> 
 to force failure:</p><pre>
    (?(?{ $OpenParens }) (?{ $OpenParens-- }) | (?!) )
</pre><br>
<p class="docList">This uses an <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(? if then</span> | <span class="docEmphasis">else</span><span class="docEmphStrong">)</span></tt><img src=images/U230B.jpg border=0> conditional (&#9758; 140), with an embedded-code construct checking the count as the <span class="docEmphasis">if</span>.</p></LI><li><p class="docList">&#10105; Finally, once matching has completed, we check the count to be sure it's zero. If it's not, there weren't enough close parentheses to balance the opens, so we should fail:</p><pre>
    (?(?{ $OpenParens != 0 })(?!))
</pre><BR>
</li></ul>
<p class="docText">Adding these items to the skeleton expression gives us:</P>
<pre>
    my $NestedGuts = qr{
       (?{ local<a name="IDX-CHP-7-2502"></a> 
 $OpenParens = 0 }) # &#10102; <span class="docEmphasis">Counts the number of nested opens
 waiting to close</span>.
       (?&gt; # <span class="docEmphasis">atomic-grouping for efficiency</span>
             (?:
              # <span class="docEmphasis">Stuff not parenthesis</span>
                [^()]+
              # &#10103; <span class="docEmphasis">An opening parenthesis</span>
              | \( (?{ $OpenParens++ })
              # &#10104; <span class="docEmphasis">Allow a closing parenthesis, if we're expecting any</span>
              | \) (?(?{ $OpenParens != 0 }) (?{ $OpenParens-- }) | (?!) )
           )*
       )
      (?(?{ $OpenParens != 0 })(?!)) # &#10105; <span class="docEmphasis">If there are any open parens left, don't
 finish</span>
    }x;
</pre><br>

<p class="docText">This can now be used just like <tt>$LevelN</tt> on page 330.</P>
<p class="docText">The <tt>local</tt> is used as a precaution to isolate this regex's use of <tt>$OpenParens</tt> from any other use the global variable might have within the program. Unlike <tt>local</tt>'s use in the previous section, it's not needed for backtracking protection because the atomic grouping in the regex ensures that once an alternative has been matched, it can't ever be "unmatched." In this case, the atomic grouping is used for both efficiency and to absolutely ensure that the text matched near one of the embedded-code constructs can't be unmatched by backtracking (which would break the sync between the value of <tt>$OpenParens</tt> and the number of parentheses actually matched).</p>

<a name="regex3-CHP-7-SECT-6.6"></a>
<h4 id="title-IDAWM35D" class="docSection2Title">7.6.6. Overloading Regex Literals</h4>
<a name="IDX-CHP-7-2503"></a> 
<a name="IDX-CHP-7-2504"></a> 
<a name="IDX-CHP-7-2505"></a> 
<a name="IDX-CHP-7-2506"></a> 
<a name="IDX-CHP-7-2507"></a> 

<p class="docText">You can pre-process the literal parts of a regex literal in any way you like with <span class="docEmphasis">overloading</span>. The next sections show examples.</p>
<a name="regex3-CHP-7-SECT-6.6.1"></a>
<h5 id="title-IDAZN35D" class="docSection3Title">7.6.6.1. Adding start- and end-of-word metacharacters</h5>
<a name="IDX-CHP-7-2508"></a> 

<p class="docText">Perl doesn't support <img src=images/U2308.jpg border=0><tt>\&lt;</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>\&gt;</tt><img src=images/U230B.jpg border=0> as start- and end-of-word metacharacters, and that's probably because it's rare that <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0> doesn't suffice. However, if we wish to have them, we can support them ourselves using overloading to replace '<tt>\&lt;</tt>' and '<tt>\&gt;</tt>' in a regex by <img src=images/U2308.jpg border=0><tt>(?&lt;!\w)(?=\w)</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>(?&lt;=\w)(?!\w)</tt><img src=images/U230B.jpg border=0>, respectively.</p>
<p class="docText">First, we'll create a function, say, <tt>MungeRegexLiteral</tt>,<a name="IDX-CHP-7-2509"></a> 
 that does the desired preprocessing:</p>
<pre>
    sub MungeRegexLiteral($)
    {
        my ($RegexLiteral) = @_; # <span class="docEmphasis">Argument is a string</span>
        $RegexLiteral =~ <b>s/</b>\\&lt;/(?&lt;!\\w)(?=\\w)<b>/g;</b># <span class="docEmphasis">Mimic \&lt; as start-of-word
 boundary</span>
        $RegexLiteral =~ <b>s/</b>\\&gt;/(?&lt;=\\w)(?!\\w)<b>/g;</b># <span class="docEmphasis">Mimic \&gt; as end-of-word
 boundary</span>
        return $RegexLiteral; # <span class="docEmphasis">Return possibly-modified string</span>
    }
</pre><BR>

<p class="docText">When this function is passed a string like '<tt>&#8943;\&lt;&#8943;</tt>', it converts it and returns the string '&#8943;<tt>(?&lt;!\w)(?=\w)</tt>&#8943;'. Remember, because the replacement part of a substitution is like a double-quoted string, it needs '<tt>\\w</tt>' to get '<tt>\w</tt>' into the value.</p>
<p class="docText">Now, to install this so that it gets called automatically on each literal part of a regex literal, we put it into a file, say <span class="docEmphasis">MyRegexStuff.pm</span>, with the Perl mechanics for overloading:</P>
<pre>
    package MyRegexStuff; # <span class="docEmphasis">Best to call the package something unique</span>
    use strict;   # <span class="docEmphasis">Good practice to always use this</span>
    use warnings; # <span class="docEmphasis">Good practice to always use this</span>
    use overload;<a name="IDX-CHP-7-2510"></a> 
<a name="IDX-CHP-7-2511"></a> 
 # <span class="docEmphasis">Allows us to invoke Perl's
 overloading mechanism</span>
    # <span class="docEmphasis">Have our regex handler installed when we're use'd</span> ....
    sub import { overload::constant qr =&gt; \&amp;MungeRegexLiteral }

    sub MungeRegexLiteral($)
    {
      my ($RegexLiteral) = @_; # <span class="docEmphasis">Argument is a string</span>
      $RegexLiteral =~ s/\\&lt;/(?&lt;!\\w)(?=\\w)/g; # <span class="docEmphasis">Mimic \&lt; as start-of-word boundary</span>
      $RegexLiteral =~ s/\\&gt;/(?&lt;=\\w)(?!\\w)/g; # <span class="docEmphasis">Mimic \&gt; as end-of-word boundary</span>
      return $RegexLiteral; # <span class="docEmphasis">Return possibly-modified string</span>
    }
    1; # <span class="docEmphasis">Standard idiom so that a 'use' of this file returns something true</span>
</pre><br>

<p class="docText">If we place <span class="docEmphasis">MyRegexStuff.pm</span> in the Perl library path (see PERLLIB in the Perl documentation), we can then invoke it from Perl script files in which we want the new features made available. For testing, though, we can just leave it in the same directory as the test script, invoking it with:</p>
<pre>
    use lib '.';      # <span class="docEmphasis">Look for library files in the current directory</span>
    use MyRegexStuff; # <span class="docEmphasis">We now have our new functionality available!</span>
       <img src=images/U22EE.jpg border=0>
    $text =~ s/\s+\&lt;/ /g; # <span class="docEmphasis">Normalize any type of whitespace <span class="docEmphStrong"><span class="docEmphasis">before a word</span></span>  to
 a single space</span>
       <img src=images/U22EE.jpg border=0>
</pre><BR>

<p class="docText">We must use <tt>MyRegexStuff</tt> in any file in which we want this added support for regex literals, but the hard work of building <span class="docEmphasis">MyRegexStuff.pm</span> need be done only once. (The new support isn't available in <span class="docEmphasis">MyRegexStuff.pm</span> itself because it doesn't <tt><span class="docEmphStrong">use MyRegexStuff</span></tt>  something you wouldn't want to do.)</P>

<a name="regex3-CHP-7-SECT-6.6.2"></a>
<H5 id="title-IDAFS35D" class="docSection3Title">7.6.6.2. Adding support for possessive quantifiers</H5>
<a name="IDX-CHP-7-2512"></a> 

<a name="IDX-CHP-7-2513"></a> 

<p class="docText">Let's extend <span class="docEmphasis">MyRegexStuff.pm</span> to add support for possessive quantifiers like <img src=images/U2308.jpg border=0><tt>x++</tt><img src=images/U230B.jpg border=0> (&#9758; 142). Possessive quantifiers work like normal greedy quantifiers, except they never give up (never "unmatch") what they've matched. They can be mimicked with atomic grouping by simply removing the final '<tt>+</tt>' and wrapping everything in atomic quotes, e.g., by changing <img src=images/U2308.jpg border=0><tt><span class="docEmphasis">regex</span>*+</tt><img src=images/U230B.jpg border=0> to <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(?&gt;</span><span class="docEmphasis">regex</span>*)</tt><img src=images/U230B.jpg border=0> (&#9758; 173).</p>
<p class="docText">The <span class="docEmphasis">regex</span> part can be a parenthesized expression, a metasequence like <img src=images/U2308.jpg border=0><tt>\w</tt><img src=images/U230B.jpg border=0> or <img src=images/U2308.jpg border=0><tt>\x{1234}</tt><img src=images/U230B.jpg border=0>, or even just a normal character. Handling all possible cases is difficult, so to keep the example simple for the moment, let's concentrate on <tt>?+</tt>, <tt>*+</tt>, or <tt>++</tt> quantifying only a parenthesized expression. Using <tt>$LevelN</tt><a name="IDX-CHP-7-2514"></a> 
<a name="IDX-CHP-7-2515"></a> 
 from page 330, we can add</P>
<pre>
    $RegexLiteral =~ s/( \( $LevelN \)[*+?] )\+/(?&gt;$1)<b>/gx;</b>
</pre><br>

<p class="docText">to the <tt>MungeRegexLiteral</tt> function.</P>
<p class="docText">That's it. Now, with it part of our overloaded package, we can use a regex literal with possessive quantifiers, like this example from page 198:</P>
<pre>
    $text =~ s/"(\\.|[^"])*+"//; # <span class="docEmphasis">Remove double-quoted strings</span>
</pre><br>

<p class="docText">Extending this beyond just parenthesized expressions is tricky because of the variety of things that can be in a regular expression. Here's one attempt:</P>
<pre>
    $RegexLiteral =~ s{
    (
      # <span class="docEmphasis">Match something that can be quantified</span> ...
     (?: \\[\\abCdDefnrsStwWX] # \n, \w, etc.
       | \\c. # \cA
       | \\x[\da-fA-F]{1,2}      # \xFF
       | \\x\{[\da-fA-F]*\}      # \x{1234}
       | \\[pP]\{[^{}]+\}        # \p{Letter}
       | \[\]?[^]]+\]            # "poor man's" class
       | \\\W                    # \*
       | \( $LevelN \)           # (&#8943;)
       | [^()*+?\\]              # almost anything else
    )
    # ...<span class="docEmphasis">and is quantified</span>...
    (?: [*+?] ; \{\d+(?:,\d*)?\} )
   )
   \+ # ...<span class="docEmphasis">and has an extra '+' after the quantifier</span>.
   }{(?&gt;$1)}gx;
</pre><BR>

<p class="docText">The general form of this regex is the same as before: match something quantified possessively, remove the '<tt>+</tt>', and wrap the result in <img src=images/U2308.jpg border=0><tt>(?&gt;&#8943;)</tt><img src=images/U230B.jpg border=0>. It's only a half-hearted attempt to recognize the complex syntax of Perl regular expressions. The part to match a class is particularly needy, in that it doesn't recognize escapes within the class. Even worse, the basic approach is flawed because it doesn't understand every aspect of Perl regular expressions. For example, if faced with '<tt>\(blah\)++</tt>', it doesn't properly ignore the opening literal parenthesis, so it thinks the <img src=images/U2308.jpg border=0><tt>++</tt><img src=images/U230B.jpg border=0> is applied to more than just <img src=images/U2308.jpg border=0><tt>\)</tt><img src=images/U230B.jpg border=0>.</p>
<p class="docText">These problems<a name="IDX-CHP-7-2516"></a> 
 can be overcome with great effort, perhaps using a technique that carefully walks through the regex from start to finish (similar to the approach shown in the sidebar on page 132). I'd like to enhance the part that matches a character class, but in the end, I don't feel it's worth it to address the other issues, for two reasons. The first is that the situations in which it doesn't already work well are fairly contrived, so just fixing the character class part is probably enough to make it acceptable in practice. But in the end, Perl's regex overloading currently has a fatal flaw, discussed in the next section, which renders it much less useful than it might otherwise be.</p>


<a name="regex3-CHP-7-SECT-6.7"></a>
<h4 id="title-IDAZV35D" class="docSection2Title">7.6.7. Problems with Regex-Literal Overloading</H4>
<a name="IDX-CHP-7-2517"></a> 

<p class="docText">Regex-literal overloading can be extremely powerful, at least in theory, but unfortunately, it's not very useful in practice. The problem is that it applies to only the literal part of a regex literal, and not the parts that are interpolated. For example, with the code <tt><span class="docEmphStrong">m/($MyStuff)*+/</span></tt> our <tt>MungeRegexLiteral</tt> function is called twice, once with the literal part of the regex before the variable interpolation<a name="IDX-CHP-7-2518"></a> 
 ("<span class="docEmphStrong">(</span>"), and once with the part after ("<tt><span class="docEmphStrong">)*+</span></tt>"). (It's never even given the contents of <tt>$MyStuff</tt>.) Since our function requires both parts at the same time, variable interpolation effectively disables it.</P>
<p class="docText">This is less of an issue with the support for <tt>\&lt;</tt> and <tt>\&gt;</tt> we added earlier, since they're not likely to be broken up by variable interpolation. But since overloading doesn't affect the contents of an interpolated variable, a string or regex object containing '<tt>\&lt;</tt>' or '<tt>\&gt;</tt>' would not be processed by overloading. Also, as the previous section touched on, when a regex literal is processed by overloading, it's not easy to be complete and accurate every time. Even something as simple as our support for <tt>\&gt;</tt> gets in the way when given '<tt>\\&gt;</tt>', ostensibly to match a '<tt>\</tt>' followed by '<tt>&gt;</tt>'.</p>
<p class="docText">Another problem is that there's no way for the overload processing to know about the modifiers that the regex was applied with. In particular, it may be crucial to know whether <tt>/x</tt> was specified, but there's currently no way to know that.</p>
<p class="docText">Finally, be warned that using overloading disables the ability to include characters by their Unicode name (<img src=images/U2308.jpg border=0><tt>\N{<span class="docEmphasis">name</span>}</tt><img src=images/U230B.jpg border=0> &#9758; 290).</p>

<a name="regex3-CHP-7-SECT-6.8"></a>
<h4 id="title-IDACY35D" class="docSection2Title">7.6.8. Mimicking Named Capture</H4>
<a name="IDX-CHP-7-2519"></a> 
<a name="IDX-CHP-7-2520"></a> 
<a name="IDX-CHP-7-2521"></a> 
<a name="IDX-CHP-7-2522"></a> 
<a name="IDX-CHP-7-2523"></a> 
<a name="IDX-CHP-7-2524"></a> 

<p class="docText">Despite the shortcomings of overloading, I think it's instructive to see a complex example bringing together many special constructs. Perl doesn't offer named capture<a name="IDX-CHP-7-2525"></a> 
<a name="IDX-CHP-7-2526"></a> 
 (&#9758; 138), but it can be mimicked with capturing parentheses and the <tt>$^N</tt><a name="IDX-CHP-7-2527"></a> 
<a name="IDX-CHP-7-2528"></a> 
 variable (&#9758; 301), which references the text matched by the most-recently-closed set of capturing parentheses. (I put on the hat of a Perl developer and added <tt>$^N</tt> support to Perl expressly to allow named-capture to be mimicked.)</p>
<p class="docText">As a simple example, consider:</p>
<pre>
    <img src=images/U2308.jpg border=0>href\s*=\s*($HttpUrl)<div><img border="0" alt="" width="137" height="13" SRC="images/regex3_u0715.jpg"></div><img src=images/U230B.jpg border=0><a name="IDX-CHP-7-2529"></a> 
<a name="IDX-CHP-7-2530"></a> 

</pre><BR>

<p class="docText">This uses the <tt>$HttpUrl</tt> regex object developed on page 303. The underlined part is an embedded-code construct that saves the text matched by <tt>$HttpUrl</tt> to the variable <tt>$url</tt>. In this simple situation, it seems overkill to use <tt>$^N</tt> instead of <tt>$1</tt>, or to even use the embedded-code construct in the first place, since it seems so easy to just use <tt>$1</tt> after the match. But consider encapsulating part of that into a regex object, and then using it multiple times:</p>
<pre>
    my <b>$SaveUrl</b> = qr{
       ($HttpUrl)         # <span class="docEmphasis">Match an HTTP URL</span>...
       (?{ $url = $^N })  # ...<span class="docEmphasis">and save to $url</span>
    }x;
    $text =~ m{
       http \s*=\s* <B>($SaveUr)</b>
      | src \s*=\s* <b>($SaveUrl)</b>
    }xi;
</pre><BR>

<p class="docText">Regardless of which matches, <tt>$url</tt> is set to the URL that matched. Again, in this particular use, you could use other means (such as the <tt>$+</tt><a name="IDX-CHP-7-2531"></a> 
 variable &#9758; 301), but as <tt>$SaveUrl</tt> is used in more complex situations, the other solutions become more difficult to maintain, so saving to a named variable can be much more convenient.</p>
<p class="docText">One problem with this example is that values written to <tt>$url</tt> are not "unwritten" when the construct that wrote to them is unmatched via backtracking. So, we need to modify a localized temporary variable during the initial match, writing to the "real" variable only after an overall match has been confirmed, just as we did in the example on page 338.</p>
<p class="docText">The listing below shows one way to solve this. From the user's point of view, after using <img src=images/U2308.jpg border=0><tt>(?&lt;Num&gt;<span class="docEmphStrong">\d+</span>)</tt><img src=images/U230B.jpg border=0>, the number matched by <img src=images/U2308.jpg border=0><tt>\d+</tt><img src=images/U230B.jpg border=0> is available in the global hash <tt>%^N</tt>, as <tt>$^N</tt>{<span class="docEmphStrong">Num</span>}. Although future versions of Perl could decide to turn <tt>%^N</tt> into a special system variable of some sort, it's not currently special, so we're free to use it.</p>
<p class="docText">I could have chosen a name like <tt>%NamedCapture</tt>, but instead chose <tt>%^N</tt> for a few reasons. One is that it's similar to <tt>$^N</tt>. Another is that it's not required to be predeclared with our when used under use <tt>strict</tt>.<a name="IDX-CHP-7-2532"></a> 
 Finally, it's my hope that Perl will eventually add named capture natively, and I think adding it via <tt>%^N</tt> would be a fine idea. If that happens, <tt>%^N</tt> would likely be automatically dynamically scoped like the rest of the regex-related special variables (&#9758; 299). But as of now, it's a normal global variable, so is not dynamically scoped automatically.</p>
<p class="docText">Again, even this more-involved approach suffers from the same problems as anything using regex-literal overloading, such as an incompatibility with interpolated variables.</p>
<a name="regex3-CHP-7-SIDEBAR-4"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<h2 class="docSidebarTitle">Mimicking Named Capture</h2>
<pre>
    package MyRegexStuff;
    use strict;
    use warnings;
    use overload;
    sub import { overload::constant('qr' =&gt; \&amp;MungeRegexLiteral)<a name="IDX-CHP-7-2533"></a> 
 }

    my $NestedStuffRegex;<a name="IDX-CHP-7-2534"></a> 
<a name="IDX-CHP-7-2535"></a> 
 # <span class="docEmphasis">This
 should be predeclared, because it's used in its own definition</span>.
    $NestedStuffRegex = qr{
     (?&gt;
        (?:     # <span class="docEmphasis">Stuff not parens, not '#', and not an escape</span>...
                [^()\#\\]+
                # <span class="docEmphasis">Escaped stuff</span>...
           | (?s: \\. )
                # <span class="docEmphasis">Regex comment</span>...
           | \#.*\n
             # <span class="docEmphasis">Matching parens, with more nested stuff inside</span>...
           | \( (??{ $NestedStuffRegex }) \)
      )*
    )
    }x;
    sub SimpleConvert($); # <span class="docEmphasis">This must be predeclared, as it's used recursively</span>
    sub SimpleConvert($)
    {
      my $re = shift; # <span class="docEmphasis">Regex to mangle</span>
      $re =~ s{
          \(\? # "(?"
            &lt; ( (?&gt;\w+) ) &gt; # &lt;$1 &gt; <span class="docEmphasis">$1 is an identifier</span>
          ( $NestedStuffRegex ) # $2 - <span class="docEmphasis">possibly-nested stuff</span>
          \) # ")"
      }{
        my $id = $1;
        my $guts = SimpleConvert($2);
        # <span class="docEmphasis">We change</span>
        # (?&lt;id&gt;guts)
        # to
        # (?: (guts) # <span class="docEmphasis">match the guts</span>
        # (?{
        # local($^N{$id}) = $guts # <span class="docEmphasis">Save to a localized element of %^T</span>
        # })
        # )
        "(?:($guts)(?{ local(\$^T{'$id'}) = \$^N }))"
      }xeog;
      return $re; # <span class="docEmphasis">Return mangled regex</span>
    }
    sub MungeRegexLiteral($)
    {
      my ($RegexLiteral) = @_; # <span class="docEmphasis">Argument is a string</span>
      # print "BEFORE: $RegexLiteral\n"; # <span class="docEmphasis">Uncomment this for debugging</span>
      my $new = SimpleConvert($RegexLiteral);
      if ($new ne $RegexLiteral)
      {
         my $before = q/(?{ local(%^T) = () })/; # <span class="docEmphasis">Localize temporary hash</span>
         my $after = q/(?{ %^N = %^T })/;        # <span class="docEmphasis">Copy temp to "real" hash</span>
         $RegexLiteral = "$before(?:$new)$after";
      }
      # print "AFTER: $RegexLiteral\n"; # <span class="docEmphasis">Uncomment this for debugging</span>
      return $RegexLiteral;
      }
      1;
</pre><br>

</td></TR></table></p><BR>


<a href="7041536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-7-SECT-5.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-7-SECT-7.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>