<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 8.4.&nbsp; The Matcher Object</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-8-SECT-3.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-8-SECT-5.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="regex3-CHP-8-SECT-4"></a>
<H3 id="title-IDANKNLT" class="docSection1Title">8.4. The Matcher Object</H3>
<a name="IDX-CHP-8-2823"></a> 
<a name="IDX-CHP-8-2824"></a> 

<p class="docText">Once you've associated a regular expression with a target string by creating a matcher, you can instruct it to apply the regex to the target in various ways, and query the results of that application. For example, given a matcher <tt><span class="docEmphasis">m</span></tt>, the call <tt><span class="docEmphasis">m</span></tt>.<tt>find()</tt> actually applies <tt><span class="docEmphasis">m</span></tt>'s regex to its string, returning a Boolean indicating whether a match is found. If a match is found, the call <tt><span class="docEmphasis">m</span></tt>.<tt>group()</tt> returns a string representing the text actually matched.</P>
<p class="docText">Before looking in detail at a matcher's various methods, it's useful to have an overview of what information it maintains. To serve as a better reference, the following lists are sprinkled with page references to details about each item. Items in the first list are those that the programmer can set or modify, while items in the second list are read-only.</P>
<p class="docText">Items that the programmer can set or update:</p>
<UL><li><p class="docList">The <tt>Pattern</tt> object provided by the programmer when the matcher is created. It can be changed by the programmer with the <tt>usePattern()</tt> method (&#9758; 393). The current pattern can be retrieved with the <tt>pattern()</tt> method.</p></LI><LI><p class="docList">The target-text string (or other <tt>CharSequence</tt>) provided by the programmer when the matcher is created. It can be changed by the programmer with the <tt>reset</tt>(<span class="docEmphasis">text</span>) method (&#9758; 392).</p></LI><LI><p class="docList">The <span class="docEmphasis">region</span> of the target text (&#9758; 384). The region defaults to the whole of the target text, but can be changed by the programmer to delimit some smaller subset of the target text via the <tt>region</tt> method. This constrains some (but not all) of the match methods to looking for a match only within the region.</p><p class="docList">The current region start and end character offsets are available via the <tt>regionStart</tt> and <tt>regionEnd</tt> methods (&#9758; 386). The <tt>reset</tt> method (&#9758; 392) resets the region to the full-text default, as do any of the methods that call <tt>reset</tt> internally (&#9758; 392).</p></li><LI><p class="docList">An <span class="docEmphasis">anchoring bounds</span> flag. If the region is set to something other than the full text, you can control whether the moved edges of the region are considered "start of text" and "end of text" with respect to the line-boundary metacharacters <tt>(\A ^ $ \z \Z)</tt>.</P><p class="docList">This flag defaults to true, but the value can be changed and inspected with the <tt>useAnchoringBounds</tt> (&#9758; 388) and <tt>hasAnchoringBounds</tt> methods, respectively. The <tt>reset</tt> method does not change this flag.</p></li><li><p class="docList">A <span class="docEmphasis">transparent bounds</span> flag. When the region is a subset of the full target text, turning on "transparent bounds" allows the characters beyond the edge of the range to be inspected by "looking" constructs (lookahead, lookbehind, and word boundaries), despite being outside the current range.</p><p class="docList">This flag defaults to false, but the value can be changed and inspected with the <tt>useTransparentBounds</tt> (&#9758; 387) and <tt>hasTransparentBounds</tt> methods, respectively. The <tt>reset</tt> method does not change this flag.</P></li></ul>
<p class="docText">The following are the read-only data maintained by the matcher:</P>
<ul><li><p class="docList">The number of sets of capturing parentheses in the current pattern. This value is reported via the <tt>groupCount</tt> method (&#9758; 377).</P></li><LI><p class="docList">A <span class="docEmphasis">match pointer</span><a name="IDX-CHP-8-2825"></a> 
 or <span class="docEmphasis">current location</span> in the target text, used to support a "find next match" operation (via the <tt>find</tt> method &#9758; 375).</p></li><li><p class="docList">An <span class="docEmphasis">append pointer</span> location in the target text, used to support the copying of unmatched regions of text during a search-and-replace operation (&#9758; 380).</p></li><li><p class="docList">A flag indicating whether the previous match attempt hit the end of the target string on its way to its eventual success or failure. The value of the flag is reported by the <tt>hitEnd</tt> method (&#9758; 390).</p></li><li><p class="docList">The <span class="docEmphasis">match result</span>. If the most recent match attempt was successful, various data about the match is collectively called the match result (&#9758; 376). It includes the span of text matched (via the <tt>group()</tt> method), the indices within the target text of that span's start and end (via the <tt>start()</tt> and <tt>end()</tt> methods), and information regarding what was matched by each set of capturing parentheses (via the <tt>group</tt>(<span class="docEmphasis">num</span>), <tt>start</tt>(<span class="docEmphasis">num</span>), and <tt>end</tt>(<span class="docEmphasis">num</span>) methods).</p><p class="docList">The encapsulated match-result data is available via its own <tt>MatchResult</tt> object, returned via the <tt>toMatchResult</tt> method. A <tt>MatchResult</tt> object has its own <tt>group</tt>, <tt>start</tt>, and <tt>end</tt> methods comparable to those of a matcher (&#9758; 377).</p></li><LI><p class="docList">A flag indicating whether longer target text could have rendered the match unsuccessful (also available only after a successful match). The flag is true for any match where a boundary metacharacter plays a part in the conclusion of the match. The value of the flag is available via the <tt>requireEnd</tt> method (&#9758; 390).</p></LI></ul>
<p class="docText">These lists are a lot to absorb, but they are easier to grasp when discussing the methods grouped by functionality. The next few sections do so. Also, the list of methods at the start of the chapter (&#9758; 366) will help you to find<a name="IDX-CHP-8-2826"></a> 
 your way around when using this chapter as a reference.</p>
<a name="regex3-CHP-8-SECT-4.1"></a>
<H4 id="title-IDA1YNLT" class="docSection2Title">8.4.1. Applying the Regex</H4>
<a name="IDX-CHP-8-2827"></a> 
<a name="IDX-CHP-8-2828"></a> 
<a name="IDX-CHP-8-2829"></a> 

<p class="docText">Here are the main <tt>Matcher</tt> methods for actually applying the matcher's regex to its target text:</P>
<a name="IDX-CHP-8-2830"></a><a name="IDX-CHP-8-2831"></a><a name="IDX-CHP-8-2832"></a><a name="IDX-CHP-8-2833"></a><a name="IDX-CHP-8-2834"></a><a name="IDX-CHP-8-2835"></a><dl class="docList">
<dt><BR><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">boolean <span class="docEmphStrong">find()</span></span></span></span></P></dt>
<dd><p class="docList">This method applies the matcher's regex to the current region (&#9758; 384) of the matcher's target text, returning a Boolean indicating whether a match is found. If called multiple times, the next match is returned each time. This no-argument form of <tt>find</tt> respects the current region (&#9758; 384).</p>
<p class="docList">Here's a simple example:</p>
<pre>
    String <span class="docEmphasis">regex</span> = "\\w+"; // <img src=images/U2308.jpg border=0>\<span class="docEmphasis">w+</span><img src=images/U230B.jpg border=0>
    String <span class="docEmphasis">text</span>  = "Mastering Regular Expressions";
    Matcher <span class="docEmphasis">m</span> = Pattern.compile(<span class="docEmphasis">regex</span>).matcher(<span class="docEmphasis">text</span>);
    if (<span class="docEmphasis">m</span>.<span class="docEmphStrong">find()</span>)
       System.out.println("match [" + <span class="docEmphasis">m</span>.group() + "]");
</pre><BR>

<p class="docList">It produces:</P>
<pre>
    match [Mastering]
</pre><br>

<p class="docList">If, however, the if control construct is changed to <tt>while</tt>, as in</P>
<pre>
    while (<span class="docEmphasis">m</span>.<span class="docEmphStrong">find()</span>)
       System.out.println("match [" + <span class="docEmphasis">m</span>.group() + "]");
</pre><BR>

<p class="docList">it then walks through the string reporting all matches:</p>
<pre>
    match [Mastering]
    match [Regular]
    match [Expressions]
</pre><br>

</dd>

<dt><br><P><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">boolean <span class="docEmphStrong">find(</span>int <span class="docEmphasis">offset</span>)</span></span></span></P></dt>
<dd><p class="docList">If <tt>find</tt> is given an integer argument, the match attempt starts at that <span class="docEmphasis">offset</span> number of characters from the beginning of the matcher's target text. It throws <tt>IndexOutOfBoundsException</tt><a name="IDX-CHP-8-2830"></a> 
<a name="IDX-CHP-8-2831"></a> 
 if the <span class="docEmphasis">offset</span> is negative or larger than the length of the target text.</p>
<p class="docList">This form of the <tt>find</tt> method does not respect the current region, going so far as to first reset the region to its "whole text" default (when it internally invokes the <tt>reset</tt> method &#9758; 392).</p>
<p class="docList">An excellent example of this form of <tt>find</tt> in action can be found in the sidebar on page 400 (which itself is the answer to a question posed on page 399).</p></dd>

<dt><br><P><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">boolean <span class="docEmphStrong">matches()</span></span></span></span></p></dt>
<a name="IDX-CHP-8-2832"></a> 

<a name="IDX-CHP-8-2833"></a> 

<dd><p class="docList">This method returns a Boolean indicating whether the matcher's regex <tt><span class="docEmphasis">exactly</span></tt> matches the current region of the target text (&#9758; 384). That is, a match must start at the beginning of the region and finish at the end of the region (which defaults to cover the entire target). When the region is set at its "all text" default, <tt>matches</tt> provides little advantage over simply using <img src=images/U2308.jpg border=0><tt>\A(?:&#8943;)\z</tt><img src=images/U230B.jpg border=0> around the regex, other than perhaps a measure of simplicity or convenience.</p>
<p class="docList">However, when the region is set to something other than the default (&#9758; 384), <tt>matches</tt> allows you to check for a full-region match without having to rely on the state of the anchoring-bounds flag (&#9758; 388).</P>
<p class="docList">For example, imagine using a <tt>CharBuffer</tt><a name="IDX-CHP-8-2834"></a> 
 to hold text being edited by the user within your application, with the region set to whatever the user has selected with the mouse. If the user then clicks on the selection, you might use <tt><span class="docEmphasis">m</span>.usePattern(<span class="docEmphasis">urlPattern</span>)</tt>.<tt>matches()</tt> to see whether the selected text is a URL (and if so, then perform some URL-related action appropriate to the application).</p>
<p class="docList"><tt>String</tt> objects also support a <tt>matches</tt> method:</p>
<pre>
    "1234".matches("\\d+"); // <span class="docEmphasis">true</span>
    "123!".matches("\\d+"); // <span class="docEmphasis">false</span>
</pre><BR>

</dd>

<dt><br><P><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">boolean <span class="docEmphStrong">lookingAt()</span></span></span></span></p></dt>
<a name="IDX-CHP-8-2835"></a> 

<dd><p class="docList">This method returns a Boolean indicating whether the matcher's regex matches within the current region of the target text, starting from the beginning of the region. This is similar to the <tt>matches</tt> method except that the entire region doesn't need to be matched, just the beginning.</p></dd>
</dl>

<a name="regex3-CHP-8-SECT-4.2"></a>
<h4 id="title-IDA45NLT" class="docSection2Title">8.4.2. Querying Match Results</h4>
<a name="IDX-CHP-8-2836"></a> 
<a name="IDX-CHP-8-2837"></a> 
<a name="IDX-CHP-8-2838"></a> 
<a name="IDX-CHP-8-2839"></a> 
<a name="IDX-CHP-8-2840"></a> 
<a name="IDX-CHP-8-2841"></a> 
<a name="IDX-CHP-8-2842"></a> 
<a name="IDX-CHP-8-2843"></a> 
<a name="IDX-CHP-8-2844"></a> 

<p class="docText">The matcher methods in the following list return information about a successful match. They throw <tt>IllegalStateException</tt><a name="IDX-CHP-8-2845"></a> 
<a name="IDX-CHP-8-2846"></a> 
 if the matcher's regex hasn't yet been applied to its target text, or if the previous application was not successful. The methods that accept a <span class="docEmphasis">num</span> argument (referring to a set of capturing parentheses) throw <tt>IndexOutOfBoundsException</tt> when an invalid <span class="docEmphasis">num</span> is given.</p>
<p class="docText">Note that the <tt>start</tt><a name="IDX-CHP-8-2847"></a> 
 and <tt>end</tt><a name="IDX-CHP-8-2848"></a> 
 methods, which return character offsets, do so without regard to the regiontheir return values are offsets from the start of the <span class="docEmphasis">text</span>, not necessarily from the start of the <span class="docEmphasis">region</span>.</p>
<p class="docText">Following this list of methods is an example illustrating many of them in action.</p>
<a name="IDX-CHP-8-2849"></a><a name="IDX-CHP-8-2850"></a><a name="IDX-CHP-8-2851"></a><dl class="docList">
<dt><br><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">String <span class="docEmphStrong">group()</span></span></span></span></p></dt>
<a name="IDX-CHP-8-2849"></a> 

<dd><p class="docList">Returns the text matched by the previous regex application.</p></dd>

<dt><br><P><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int <span class="docEmphStrong">groupCount()</span></span></span></span></p></dt>
<a name="IDX-CHP-8-2850"></a> 

<dd><p class="docList">Returns the number of sets of capturing parentheses in the <tt>regex</tt> associated with the matcher. Numbers up to this value can be used as the <span class="docEmphasis">num</span> argument to the <tt>group</tt>, <tt>start</tt>, and <tt>end</tt> methods, described next.<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-8-FN-4">[<img src=images/U2020.jpg border=0>]</a></sup></P><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-8-FN-4">[<img src=images/U2020.jpg border=0>]</a></sup> The <tt>groupCount</tt> method can be called at any time, unlike the others in this section, which can be called only after a successful match attempt.</p></blockquote></dd>

<dt><br><P><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">String <span class="docEmphStrong">group</span>(int <span class="docEmphasis">num</span>)</span></span></span></P></dt>
<dd><p class="docList">Returns the text matched by the <span class="docEmphasis">num</span><sup>th</sup> set of capturing parentheses, or <tt>null</tt> if that set didn't participate in the match. A <span class="docEmphasis">num</span> of zero indicates the entire match, so <tt>group(0)</tt> is the same as <tt>group()</tt>.</P></dd>

<dt><BR><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int <span class="docEmphStrong">start</span>(int <span class="docEmphasis">num</span>)</span></span></span></P></dt>
<dd><p class="docList">This method returns the absolute offset, in characters, from the start of the string to the start of where the <span class="docEmphasis">num</span><sup>th</sup> set of capturing parentheses matched. Returns <tt>-1</tt> if the set didn't participate in the match.</p></dd>

<dt><br><P><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int <span class="docEmphStrong">start()</span></span></span></span></P></dt>
<dd><p class="docList">This method returns the absolute offset to the start of the overall match. <tt>start()</tt> is the same as <tt>start(0)</tt>.</p></dd>

<dt><BR><P><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int <span class="docEmphStrong">end</span>(int <span class="docEmphasis">num</span>)</span></span></span></p></dt>
<dd><p class="docList">This method returns the absolute offset, in characters, from the start of the string to the end of where the <span class="docEmphasis">num</span><sup>th</sup> set of capturing parentheses matched. Returns <tt>-1</tt> if the set didn't participate in the match.</p></dd>

<dt><br><P><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int <span class="docEmphStrong">end()</span></span></span></span></P></dt>
<dd><p class="docList">This method returns the absolute offset to the end of the overall match. <tt>end()</tt> is the same as <tt>end(0)</tt>.</p></dd>

<dt><br><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">MatchResult <span class="docEmphStrong">toMatchResult()</span></span></span></span></p></dt>
<a name="IDX-CHP-8-2851"></a> 

<dd><p class="docList">Added in Java 1.5.0, this method returns a <tt>MatchResult</tt> object encapsulating data about the most recent match. It has the same <tt>group</tt>, <tt>start</tt>, <tt>end</tt>, and <tt>groupCount</tt> methods, listed above, as the <tt>Matcher</tt> class.</P>
<p class="docList">A call to <tt>toMatchResult</tt> throws <tt>IllegalStateException</tt> if the matcher hasn't attempted a match yet, or if the previous match attempt was not successful.</p></dd>
</dl>
<a name="regex3-CHP-8-SECT-4.2.1"></a>
<H5 id="title-IDABZPIS" class="docSection3Title">8.4.2.1. Match-result example</h5>
<a name="IDX-CHP-8-2852"></a> 
<a name="IDX-CHP-8-2853"></a> 
<a name="IDX-CHP-8-2854"></a> 
<a name="IDX-CHP-8-2855"></a> 

<p class="docText">Here's an example that demonstrates many of these match-result methods. Given a URL in a string, the code identifies and reports on the URL's protocol ('<tt>http</tt>' or '<tt>https</tt>'), hostname, and optional port number:</p>
<pre>
    String <span class="docEmphasis">url</span>   = "http://regex.info/blog";
    String <span class="docEmphasis">regex</span> = "(?x) ^(https?):// ([^/:]+) (?:(\\d+))?";
    Matcher <span class="docEmphasis">m</span> = Pattern.compile(<span class="docEmphasis">regex</span>).matcher(<span class="docEmphasis">url</span>);

    if (<span class="docEmphasis">m</span>.find())
    {
      System.out.print(
          "Overall  [" + <span class="docEmphasis">m</span>.group()  + "]" +
          " (from "    + <span class="docEmphasis">m</span>.start()  + " to " + <span class="docEmphasis">m</span>.end()  + ")\n" +
          "Protocol [" + <span class="docEmphasis">m</span>.group(1) + "]" +
          " (from "    + <span class="docEmphasis">m</span>.start(1) + " to " + <span class="docEmphasis">m</span>.end(1) + ")\n" +
          "Hostname [" + <span class="docEmphasis">m</span>.group(2) + "]" +
          " (from "    + <span class="docEmphasis">m</span>.start(2) + " to " + <span class="docEmphasis">m</span>.end(2) + ")\n"
      );
      // <span class="docEmphasis">Group #3 might not have participated, so we must be careful here</span>
      if (<span class="docEmphasis">m</span>.group(3) == null)
         System.out.println("No port; default of '80' is assumed");
      else  {
         System.out.print("Port is [" + <span class="docEmphasis">m</span>.group(3) + "] " +
                          "(from " + <span class="docEmphasis">m</span>.start(3) + " to " + <span class="docEmphasis">m</span>.end(3) + ")\n");
      }
    }
</pre><BR>

<p class="docText">When executed, it produces:</p>
<pre>
    Overall  [http://regex.info] (from 0 to 17)
    Protocol [http] (from 0 to 4)
    Hostname [regex.info] (from 7 to 17)
    No port; default of '80' is assumed
</pre><BR>



<a name="regex3-CHP-8-SECT-4.3"></a>
<h4 id="title-IDAS1PIS" class="docSection2Title">8.4.3. Simple Search and Replace</h4>
<p class="docText">You can implement search-and-replace operations using just the methods mentioned so far, if you don't mind doing a lot of housekeeping work yourself, but a matcher offers convenient methods to do simple search and replace<a name="IDX-CHP-8-2856"></a> 
 for you:</p>
<a name="IDX-CHP-8-2857"></a><a name="IDX-CHP-8-2858"></a><a name="IDX-CHP-8-2859"></a><a name="IDX-CHP-8-2860"></a><a name="IDX-CHP-8-2861"></a><dl class="docList">
<dt><br><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">String <span class="docEmphStrong">replaceAll</span>(String<span class="docEmphasis">replacement</span>)</span></span></span></p></dt>
<a name="IDX-CHP-8-2857"></a> 

<a name="IDX-CHP-8-2858"></a> 

<dd><p class="docList">Returns a copy of the matcher's string with spans of text matched by its regex replaced by <span class="docEmphasis">replacement</span>, as per the special processing discussed on page 380.</p>
<p class="docList">This method does not respect the region (it invokes <tt>reset</tt> internally), although page 382 describes a homemade version that does.</p>
<p class="docList">This functionality is available via the <tt>String</tt> class <tt>replaceAll</tt> method, so</p>
<pre>
    <span class="docEmphasis">string</span>.replaceAll(<span class="docEmphasis">regex</span>, <span class="docEmphasis">replacement</span>)
</pre><br>

<p class="docList">is equivalent to:</p>
<pre>
    Pattern.compile(<span class="docEmphasis">regex</span>).matcher(<span class="docEmphasis">string</span>).replaceAll(<span class="docEmphasis">replacement</span>)
</pre><br>

</dd>

<dt><BR><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">String <span class="docEmphStrong">replaceFirst</span>(String <span class="docEmphasis">replacement</span>)</span></span></span></P></dt>
<a name="IDX-CHP-8-2859"></a> 

<a name="IDX-CHP-8-2860"></a> 

<dd><p class="docList">This method is similar to <tt>replaceAll</tt>, but only the first match (if any) is replaced.</p>
<p class="docList">This functionality is available via the <tt>String</tt> class <tt>replaceFirst</tt> method.</p></dd>

<dt><BR><P><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">static String <span class="docEmphStrong">quoteReplacement(</span>String <span class="docEmphasis">text</span><span class="docEmphStrong">)</span></span></span></span></P></dt>
<a name="IDX-CHP-8-2861"></a> 

<dd><p class="docList">This static method, available since Java 1.5, returns a string for use as a <span class="docEmphasis">replacement</span> argument such that the literal value of <span class="docEmphasis">text</span> is used as the replacement. It does this by adding escapes to a copy of <span class="docEmphasis">text</span> that defeat the special processing discussed in the section on the next page. (That section also includes an example of <tt>Matcher.quoteReplacement</tt>, as well.)</P></dd>
</dl>
<a name="regex3-CHP-8-SECT-4.3.1"></a>
<h5 id="title-IDAIYTTR" class="docSection3Title">8.4.3.1. Simple search and replace examples</H5>
<a name="IDX-CHP-8-2862"></a> 
<a name="IDX-CHP-8-2863"></a> 

<p class="docText">This simple example replaces every occurrence of "Java 1.5" with "Java 5.0," to convert the nomenclature from engineering to marketing:</p>
<pre>
    String <span class="docEmphasis">text</span> = "Before Java 1.5 was Java 1.4.2. After Java 1.5 is Java 1.6";
    String <span class="docEmphasis">regex</span> = "\\bJava\\s*1\\.5\\b";
    Matcher <span class="docEmphasis">m</span> = Pattern.compile(<span class="docEmphasis">regex</span>).matcher(<span class="docEmphasis">text</span>);
    String <span class="docEmphasis">result</span> = <span class="docEmphasis">m</span>.<span class="docEmphStrong">replaceAll</span>("Java 5.0");
    System.out.println(<span class="docEmphasis">result</span>);
</pre><br>

<p class="docText">It produces:</P>
<pre>
    Before Java 5.0 was Java 1.4.2. After Java 5.0 is Java 1.6
</pre><BR>

<p class="docText">If you won't need the pattern and matcher further, you can chain everything together, setting <tt>result</tt> to:</p>
<pre>
    Pattern.compile("\\bJava\\s*1\\.5\\b").matcher(<span class="docEmphasis">text</span>).replaceAll("Java 5.0")
</pre><BR>

<p class="docText">(If the regex is used many times within the same thread, it's most efficient to precompile the <tt>Pattern</tt> object &#9758; 372.)</P>
<p class="docText">You can convert "Java 1.6" to "Java 6.0" as well, by making a small adjustment to the regex (and a corresponding adjustment to the replacement string, as per the discussion on the next page).</p>
<pre>
    Pattern.compile("\\bJava\\s*1\\.<span class="docEmphStrong">([56])</span>\\b").matcher(<span class="docEmphasis">text</span>).replaceAll
("Java <span class="docEmphStrong">$1</span>.0")
</pre><br>

<p class="docText">which, when given the same text as earlier, produces:</p>
<pre>
    Before Java 5.0 was Java 1.4.2. After Java 5.0 is Java 6.0
</pre><BR>

<p class="docText">You can use <tt>replaceFirst</tt> instead of <tt>replaceAll</tt> with any of these examples to replace only the first match. You should use <tt>replaceFirst</tt> when you want to forcibly limit the matcher to only one replacement, of course, but it also makes sense from an efficiency standpoint to use it when you know that only one match is possible. (You might know this because of your knowledge of the regex or the data, for example.)</P>

<a name="regex3-CHP-8-SECT-4.3.2"></a>
<h5 id="title-IDA50TTR" class="docSection3Title">8.4.3.2. The replacement argument</h5>
<a name="IDX-CHP-8-2864"></a> 

<a name="IDX-CHP-8-2865"></a> 

<p class="docText">The <span class="docEmphasis">replacement</span> argument to the <tt>replaceAll</tt> and <tt>replaceFirst</tt> methods (and to the next section's <tt>appendReplacement</tt><a name="IDX-CHP-8-2866"></a> 
 method, for that matter) receives special treatment prior to being inserted in place of a match, on a per-match basis:</p>
<ul><LI><p class="docList">Instances of '<tt>$1</tt>', '<tt>$2</tt>', etc., within the replacement string are replaced by the text matched by the associated set of capturing parentheses. (<tt>$0</tt> is replaced by the entire text matched.)</p><p class="docList"><tt>IllegalArgumentException</tt><a name="IDX-CHP-8-2867"></a> 
<a name="IDX-CHP-8-2868"></a> 
 is thrown if the character following the '<tt>$</tt>' is not an <tt>ASCII</tt> digit.</p><p class="docList">Only as many digits after the '<tt>$</tt>' as "make sense" are used. For example, if there are three capturing parentheses, '<tt>$25</tt>' in the replacement string is interpreted as <tt>$2</tt> followed by the character '<tt>5</tt>'. However, in the same situation, '<tt>$6</tt>' in the replacement string throws <tt>IndexOutOfBoundsException</tt>.<a name="IDX-CHP-8-2869"></a> 
</P></li><li><p class="docList">A backslash escapes the character that follows, so use '<tt>\$</tt>' in the replacement string to include a dollar sign in it. By the same token, use '<tt>\\</tt>' to get a backslash into the replacement value. (And if you're providing the replacement string as a Java<a name="IDX-CHP-8-2870"></a> 
<a name="IDX-CHP-8-2871"></a> 
<a name="IDX-CHP-8-2872"></a> 
<a name="IDX-CHP-8-2873"></a> 
<a name="IDX-CHP-8-2874"></a> 
 string literal, that means you need "<tt>\\\\</tt>"<a name="IDX-CHP-8-2875"></a> 
 to get a backslash into the replacement value.) Also, if there are, say, 12 sets of capturing parentheses and you'd like to include the text matched by the first set, followed by '<tt>2</tt>', you can use a replacement value of '<tt>$1\2</tt>'.</P></li></UL>
<p class="docText">If you have a string of unknown content that you intend to use as the replacement text, it's best to use <tt>Matcher.quoteReplacement</tt> to ensure that any replacement metacharacters it might contain are rendered inert. Given a user's regex in <tt><span class="docEmphasis">uRegex</span></tt> and replacement text in <tt><span class="docEmphasis">uRepl</span></tt>, this snippet ensures that the replaced text is exactly that given:</p>
<pre>
    Pattern.compile(<span class="docEmphasis">uRegex</span>).matcher(<span class="docEmphasis">text</span>).replaceAll(Matcher.quoteReplacement(
<span class="docEmphasis">uRepl</span>))
</pre><br>



<a name="regex3-CHP-8-SECT-4.4"></a>
<h4 id="title-IDAQ5TTR" class="docSection2Title">8.4.4. Advanced Search and Replace</h4>
<p class="docText">Two methods provide raw access to a matcher's search-and-replace mechanics. Together, they build a result in a <tt>StringBuffer</tt><a name="IDX-CHP-8-2876"></a> 
 that you provide. The first, called after each match, fills the result with the replacement string and the text between the matches. The second, called after all matches have been found, tacks on whatever text remains after the final match.</p>
<a name="IDX-CHP-8-2877"></a><dl class="docList">
<dt><br><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">Matcher <span class="docEmphStrong">appendReplacement(</span>StringBuffer <span class="docEmphasis">result</span>, String <span class="docEmphasis">replacement</span><span class="docEmphStrong">)</span></span></span></span></p></dt>
<dd><p class="docList">Called immediately after a regex has been successfully applied (usually with <tt>find</tt>), this method appends two strings to the given <span class="docEmphasis">result</span>: first, it copies in the text of the original target string prior to the match. Then, it appends the <span class="docEmphasis">replacement</span> string, as per the special processing described in the previous section.</p>
<p class="docList">For example, let's say we have a matcher <tt><span class="docEmphasis">m</span></tt> that associates the regex <img src=images/U2308.jpg border=0><tt>\w+</tt><img src=images/U230B.jpg border=0> with the string '--&gt;<tt>one+test</tt>&lt;--'. The first time through this <tt>while</tt> loop,</p>
<pre>
    while (<span class="docEmphasis">m</span>.find())
        <span class="docEmphasis">m</span>.appendReplacement(<span class="docEmphasis">sb</span>, "XXX")
</pre><br>

<p class="docList">the <tt>find</tt> matches the underlined portion of '<img border="0" alt="" width="112" height="15" SRC="images/regex3_u0803.jpg">'.</p>
<p class="docList">The first call, then, to <tt>appendReplacement</tt> fills the <span class="docEmphasis">result</span> string buffer <tt>sb</tt> with the text before the match, '--&gt;', then bypasses whatever matched, instead appending the replacement string, 'XXX', to <tt>sb</tt>.</P>
<p class="docList">The second time through the loop, <tt>find</tt> matches '<img border="0" alt="" width="112" height="15" SRC="images/regex3_u0804.jpg">'. The call to <tt>appendReplacement</tt> appends the text before the match, '+', then again appends the replacement string, 'XXX'.</p>
<p class="docList">This leaves <tt>sb</tt> with '--&gt;XXX+XXX', and the original target string within the <tt>m</tt> object marked at '--&gt;<tt>one+test</tt><sub><img src=images/U22CF.jpg border=0></sub>&lt;--'.</P>
<p class="docList">We're now in a position to use the <tt>appendTail</tt><a name="IDX-CHP-8-2877"></a> 
 method, presented next.</p></dd>

<dt><br><P><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">StringBuffer <span class="docEmphStrong">appendTail(</span>StringBuffer <span class="docEmphasis">result</span><span class="docEmphStrong">)</span></span></span></span></P></dt>
<dd><p class="docList">Called after all matches have been found (or, at least, after the desired matches have been found  you can stop early if you like), this method appends the remaining text from the matcher's target text to the provided stringbuffer.</P>
<p class="docList">Continuing the previous example,</P>
<pre>
    <span class="docEmphasis">m</span>.appendTail(<span class="docEmphasis">sb</span>)
</pre><br>

<p class="docList">appends '&lt;--' to <tt>sb</tt>. This leaves it with '--&gt;<tt>XXX+XXX</tt>&lt;--', completing the search and replace.</P></dd>
</dl>
<a name="regex3-CHP-8-SECT-4.4.1"></a>
<h5 id="title-IDAKEUTR" class="docSection3Title">8.4.4.1. Search-and-replace examples</h5>
<a name="IDX-CHP-8-2878"></a> 
<a name="IDX-CHP-8-2879"></a> 
<a name="IDX-CHP-8-2880"></a> 

<p class="docText">Here's an example showing how you might implement your own version of <tt>replaceAll</tt>. (Not that you'd want to, but it's illustrative.)</P>
<pre>
    public static String <span class="docEmphasis">replaceAll</span>(Matcher <span class="docEmphasis">m</span>, String <span class="docEmphasis">replacement</span>)
    {
       <span class="docEmphasis">m</span>.reset(); // <span class="docEmphasis">Be sure to start with a fresh Matcher object</span>
       StringBuffer <span class="docEmphasis">result</span> = new StringBuffer(); // <span class="docEmphasis">We'll build the updated copy
 here</span>

       while (<span class="docEmphasis">m</span>.find())
           <span class="docEmphasis">m</span>.appendReplacement(<span class="docEmphasis">result</span>, <span class="docEmphasis">replacement</span>);

       <span class="docEmphasis">m</span>.appendTail(<span class="docEmphasis">result</span>);
       return <span class="docEmphasis">result</span>.toString(); // <span class="docEmphasis">Convert result to a string and return</span>
    }
</pre><BR>

<p class="docText">As with the real <tt>replaceAll</tt> method, this code does not respect the region (&#9758; 384), but rather resets it prior to the search-and-replace operation.</p>
<p class="docText">To remedy that deficiency, here is a version of <tt>replaceAll</tt> that <span class="docEmphasis">does</span> respect the region. Changed or added sections of code are highlighted:</P>
<pre>
    public static String <span class="docEmphasis">replaceAllRegion</span>(Matcher <span class="docEmphasis">m</span>, String <span class="docEmphasis">replacement</span>)
    {
       Integer <span class="docEmphasis">start</span> = <span class="docEmphasis">m</span>.regionStart();
       Integer <span class="docEmphasis">end</span> = <span class="docEmphasis">m</span>.regionEnd();
       <span class="docEmphasis">m</span>.reset().region(<span class="docEmphasis">start</span>, <span class="docEmphasis">end</span>); // <span class="docEmphasis">Reset the matcher, but then restore
 the region</span>
       StringBuffer<a name="IDX-CHP-8-2881"></a> 
 <span class="docEmphasis">result</span> = new StringBuffer(); // <span class="docEmphasis">We'll build
 the updated copy here</span>

       while (<span class="docEmphasis">m</span>.find())
           <span class="docEmphasis">m</span>.appendReplacement(<span class="docEmphasis">result</span>, <span class="docEmphasis">replacement</span>);
       <span class="docEmphasis">m</span>.appendTail(<span class="docEmphasis">result</span>);
       return <span class="docEmphasis">result</span>.toString(); // <span class="docEmphasis">Convert to a String and return</span>
    }
</pre><BR>

<p class="docText">The combination of the <tt>reset</tt> and <tt>region</tt> methods in one expression is an example of <span class="docEmphasis">method chaining</span>, which is discussed starting on page 389.</p>
<p class="docText">This next example is sightly more involved; it prints a version of the string in the variable <tt>metric</tt>, with Celsius temperatures converted to Fahrenheit:</p>
<pre>
    // <span class="docEmphasis">Build a matcher to find numbers followed by "C" within the variable "Metric"</span>
    // <span class="docEmphasis">The following regex is:</span> <img src=images/U2308.jpg border=0>( \d+(?:\.\d* )? )C\b<img src=images/U230B.jpg border=0>
    Matcher <span class="docEmphasis">m</span> = Pattern.compile("(\\d+(?:\\.\\d*)?)C\\b").matcher(<span class="docEmphasis">metric</span>);
    StringBuffer <span class="docEmphasis">result</span> = new StringBuffer(); // <span class="docEmphasis">We'll build the updated copy here</span>

    while (<span class="docEmphasis">m</span>.find())
    {
      float <span class="docEmphasis">celsius</span> = Float.parseFloat(<span class="docEmphasis">m</span>.group(1));  // <span class="docEmphasis">Get the number, as a
 number</span>
      int <span class="docEmphasis">fahrenheit</span> = (int) (<span class="docEmphasis">celsius</span> * 9/5 + 32);   // <span class="docEmphasis">Convert to a Fahrenheit
 value</span>
      <span class="docEmphasis">m</span>.appendReplacement(<span class="docEmphasis">result</span>, <span class="docEmphasis">fahrenheit</span> + "F"); // <span class="docEmphasis">Insert it</span>
    }

    <span class="docEmphasis">m</span>.appendTail(<span class="docEmphasis">result</span>);
    System.out.println(<span class="docEmphasis">result</span>.toString()); // <span class="docEmphasis">Display the result</span>
</pre><BR>

<p class="docText">For example, if the variable <tt>meTRic</tt> contains '<span class="docEmphStrong">from 36.3C to 40.1C</span>.', it displays '<span class="docEmphStrong">from 97F to 104F</span>.'.</p>


<a name="regex3-CHP-8-SECT-4.5"></a>
<h4 id="title-IDAOKUTR" class="docSection2Title">8.4.5. In-Place Search and Replace</h4>
<a name="IDX-CHP-8-2882"></a> 
<a name="IDX-CHP-8-2883"></a> 

<p class="docText">So far, we've applied <tt>java.util.regex</tt> to only <tt>String</tt> objects, but since a matcher can be created with any object that implements the <tt>CharSequence</tt><a name="IDX-CHP-8-2884"></a> 
 interface, we can actually work with text that we can modify directly, in place, and on the fly.</p>
<p class="docText"><tt>StringBuffer</tt> and <tt>StringBuilder</tt><a name="IDX-CHP-8-2885"></a> 
 are commonly used classes that implement <tt>CharSequence</tt>, the former being multithread safe but less efficient. Both can be used like a <tt>String</tt> object, but, unlike a <tt>String</tt>, they can also can be modified. Examples in this book use <tt>StringBuilder</tt>, but feel free to use <tt>StringBuffer</tt> if coding for a multithreaded environment.</P>
<p class="docText">Here's a simple example illustrating a search through a <tt>StringBuilder</tt> object, with all-uppercase words being replaced by their lowercase counterparts:<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-8-FN-5">[<img src=images/U2020.jpg border=0>]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-8-FN-5">[<img src=images/U2020.jpg border=0>]</a></sup> The regex in the code is <img src=images/U2308.jpg border=0><tt>\b<span class="docEmphStrong">[</span>\p{Lu}\p{Lt}<span class="docEmphStrong">]</span>+\b</tt><img src=images/U230B.jpg border=0> You'll recall from <a class="docLink" href="regex3-CHP-3.html#regex3-CHP-3">Chapter 3</a> (&#9758; 123) that <tt>\p{Lu}</tt> matches the full range of Unicode uppercase letters, while <tt>\p{Lt}</tt> matches titlecase characters. The ASCII version of this regex is <img src=images/U2308.jpg border=0><tt>\b[A-Z]+\b</tt><img src=images/U230B.jpg border=0>.</p></blockquote>
<pre>
    StringBuilder <span class="docEmphasis">text</span> = new StringBuilder("It's <span class="docEmphStrong">SO</span> very <span class="docEmphStrong">RUDE</span> to shout!");
    Matcher <span class="docEmphasis">m</span> = Pattern.compile("\\b[\\p{Lu}\\p{Lt}]+\\b").matcher(<span class="docEmphasis">text</span>);
    while (<span class="docEmphasis">m</span>.find())
       <span class="docEmphasis">text</span>.replace(<span class="docEmphasis">m</span>.start(), <span class="docEmphasis">m</span>.end(), <span class="docEmphasis">m</span>.group().toLowerCase());
    System.out.println(<span class="docEmphasis">text</span>);
</pre><BR>

<p class="docText">This produces:</p>
<blockquote>
<p class="docText"><tt>It's <span class="docEmphStrong">so</span> very <span class="docEmphStrong">rude</span> to shout!</tt></p>
</blockquote>
<p class="docText">Two matches result in two calls to <tt><span class="docEmphasis">text</span>.replace</tt>. The first two arguments indicate the span of characters to be replaced (we pass the span that the regex matched), followed by the text to use as the replacement (the lowercase version of what was matched).</P>
<p class="docText">As long as the replacement text is the same length as the text being replaced, as is the case here, an in-place search and replace is this simple. Also, the approach remains this simple if only one search and replace is done, rather than the iterative application shown in this example.</p>
<a name="regex3-CHP-8-SECT-4.5.1"></a>
<H5 id="title-IDAWOUTR" class="docSection3Title">8.4.5.1. Using a different-sized replacement</h5>
<a name="IDX-CHP-8-2886"></a> 
<a name="IDX-CHP-8-2887"></a> 

<p class="docText">Processing gets more complicated if the replacement text is a different length than what it replaces. The changes we make to the target are done "behind the back" of the matcher, so its idea of the <span class="docEmphasis">match pointer</span><a name="IDX-CHP-8-2888"></a> 
 (where in the target to begin the next <tt>find</tt>) can become incorrect.</p>
<p class="docText">We can get around this by maintaining the match pointer ourselves, passing it to the <tt>find</tt> method to have it explicitly begin the search where we know it should. That's what we do in the following modification of the previous example, where we add &lt;<tt>b</tt>&gt;&#8943;&lt;<tt>/b</tt>&gt; tags around the newly lowercased text:</p>
<pre>
    StringBuilder <span class="docEmphasis">text</span> = new StringBuilder("It's SO very RUDE to shout!");
    Matcher <span class="docEmphasis">m</span> = Pattern.compile("\\b[\\p{Lu}\\p{Lt}]+\\b").matcher(<span class="docEmphasis">text</span>);
    int matchPointer = 0;// <span class="docEmphasis">First search begins at the start of the string</span>
    while (<span class="docEmphasis">m</span>.find(matchPointer)) {
       matchPointer = <span class="docEmphasis">m</span>.end(); // <span class="docEmphasis">Next search starts from where this one ended</span>
       <span class="docEmphasis">text</span>.replace(<span class="docEmphasis">m</span>.start(), <span class="docEmphasis">m</span>.end(), "&lt;b&gt;"+ <span class="docEmphasis">m</span>.group().toLowerCase()
 +"&lt;/b&gt;);
       matchPointer += 7; // <span class="docEmphasis">Account for having added '&lt;b&gt;' and '&lt;/b&gt;'</span>
    }
    System.out.println(<span class="docEmphasis">text</span>);
</pre><br>

<p class="docText">This produces:</p>
<blockquote>
<p class="docText"><tt>It's &lt;b&gt;so&lt;/b&gt; very &lt;b&gt;rude&lt;/b&gt; to shout!</tt></p>
</blockquote>


<a name="regex3-CHP-8-SECT-4.6"></a>
<h4 id="title-IDACRUTR" class="docSection2Title">8.4.6. The Matcher's Region</h4>
<p class="docText">Since Java<a name="IDX-CHP-8-2889"></a> 
 1.5, a matcher supports the concept of a changeable <span class="docEmphasis">region</span><a name="IDX-CHP-8-2890"></a> 
<a name="IDX-CHP-8-2891"></a> 
<a name="IDX-CHP-8-2892"></a> 
 with which you can restrict match attempts to some subset of the target string. Normally, a matcher's region encompasses the entire target text, but it can be changed on the fly with the <tt>region</tt> method.</p>
<p class="docText">The next example inspects a string of HTML, reporting image tags without an ALT attribute. It uses two matchers that work on the same text (the HTML), but with different regular expressions: one finds image tags, while the other finds ALT attributes.</p>
<p class="docText">Although the two matchers are applied to the same string, they're independent objects that are related only because we use the result of each image-tag match to explicitly isolate the ALT search to the image tag's body. We do this by using the <tt>start</tt>- and <tt>end</tt>-method data from the just-completed image-tag match to set the ALT-matcher's region, prior to invoking the ALT-matcher's <tt>find</tt>.</p>
<p class="docText">By isolating the image tag's body in this way, the ALT search tells us whether the image tag we just found, and not the whole HTML string in general, contains an ALT attribute.</p>
<pre>
    // <span class="docEmphasis">Matcher to find an image tag. The 'html' variable contains the
HTML in question</span>
    Matcher <span class="docEmphasis">mImg</span> = Pattern.compile("(?id)&lt;IMG\\s+(.*?)/?&gt;").matcher(<span class="docEmphasis">html</span>);

    // <span class="docEmphasis">Matcher to find an ALT attribute (to be applied to an IMG tag's body within
 the same 'html' variable)</span>
    Matcher <span class="docEmphasis">mAlt</span> = Pattern.compile("(?ix)\\b ALT \\s* =").matcher(<span class="docEmphasis">html</span>);

    // <span class="docEmphasis">For each image tag within the html</span> ...
    while (<span class="docEmphasis">mImg</span>.find()) {
       // <span class="docEmphasis">Restrict the next ALT search to the body of the just-found image tag</span>
       <span class="docEmphasis">mAlt</span>.region(<span class="docEmphasis">mImg</span>.start(1), <span class="docEmphasis">mImg</span>.end(1) );

       // <span class="docEmphasis">Report an error if no ALT found, showing the whole image tag found above</span>
       if (! <span class="docEmphasis">mAlt</span>.find())
           System.out.println("Missing ALT attribute in: " + <span class="docEmphasis">mImg</span>.group());
     }
</pre><BR>

<p class="docText">It may feel odd to indicate the target text in one location (when the <tt><span class="docEmphasis">mAlt</span></tt> matcher is created) and its range in another (the <tt><span class="docEmphasis">mAlt</span></tt>.region call). If so, another option is to create <tt><span class="docEmphasis">mAlt</span></tt> with a dummy target (an empty string, rather than <tt><span class="docEmphasis">html</span></tt>) and change the region call to <tt><span class="docEmphasis">mAlt</span>.<span class="docEmphStrong">reset(</span><span class="docEmphasis">html</span></tt>).<tt>region(</tt>&#8943;<tt>)</tt>. The extra call to <tt>reset</tt> is slightly less efficient, but keeping the setting of the target text in the same spot as the setting of the region may be clearer.</p>
<p class="docText">In any case, let me reiterate that if we hadn't restricted the ALT matcher by setting its region, its <tt>find</tt> would end up searching the entire string, reporting the useless fact of whether the HTML contained '<tt>ALT</tt>=' anywhere at all.</P>
<p class="docText">Let's extend this example so that it reports the line number within the HTML where the offending image tag starts. We'll do so by isolating our view of the HTML to the text before the image tag, then count how many newlines we can find.</p>
<p class="docText">New code is highlighted:</p>
<pre>
    // <span class="docEmphasis">Matcher to find an image tag. The 'html' variable contains the
HTML in question</span>
    Matcher <span class="docEmphasis">mImg</span> = Pattern.compile("(?id)&lt;IMG\\s+(.*?)/?&gt;").matcher(<span class="docEmphasis">html</span>);
    // <span class="docEmphasis">Matcher to find an ALT attribute (to be applied to an IMG tag's body within
 the same 'html' variable)</span>
    Matcher <span class="docEmphasis">mAlt</span> = Pattern.compile("(?ix)\\b ALT \\s* =").matcher(<span class="docEmphasis">html</span>);

    // <span class="docEmphasis">Matcher to find a newline</span>
    Matcher mLine = Pattern.compile("\\n").matcher(<span class="docEmphasis">html</span>);

    // <span class="docEmphasis">For each image tag within the html</span> ...
    while (<span class="docEmphasis">mImg</span>.find())
    {
       // <span class="docEmphasis">Restrict the next ALT search to the body of the just-found image tag</span>
       <span class="docEmphasis">mAlt</span>.region(<span class="docEmphasis">mImg</span>.start(1), <span class="docEmphasis">mImg</span>.end(1) );
       // <span class="docEmphasis">Report an error if no ALT found, showing the whole image tag found above</span>
       if (! <span class="docEmphasis">mAlt</span>.find()) {
          // <span class="docEmphasis">Restrict counting of newlines to the text before the start of the
 image tag</span>
          mLine.region(0, <span class="docEmphasis">mImg</span>.start());
          int lineNum = 1; // <span class="docEmphasis">The first line is numbered 1</span>
          while (mLine.find())
                 lineNum++; // <span class="docEmphasis">Each newline bumps up the line number</span>
          System.out.println("Missing ALT attribute on line " + lineNum);
       }
    }
</pre><BR>

<p class="docText">As before, when setting the region for the ALT matcher, we use the <tt>start(1)</tt> method of the image matcher to identify where in the HTML string the <span class="docEmphasis">body</span> of the image tag starts. Conversely, when setting the end of the newline-matching region, we use <tt>start()</tt> because it identifies where the <span class="docEmphasis">whole image tag</span> begins (which is where we want the newline counting to end).</P>
<a name="regex3-CHP-8-SECT-4.6.1"></a>
<H5 id="title-IDAOWUTR" class="docSection3Title">8.4.6.1. Points to keep in mind</H5>
<a name="IDX-CHP-8-2893"></a> 
<a name="IDX-CHP-8-2894"></a> 

<p class="docText">It's important to remember that not only do some search-related methods ignore the region, they actually invoke the <tt>reset</tt> method internally and so revert the region to its "entire text" default.</p>
<UL><li><p class="docList">Searching methods that respect the region:</p><pre>
    matches
    lookingAt
    find() (the no-argument version)
</pre><BR>
</LI><li><p class="docList">Methods that reset the matcher and its region:</P><pre>
    find(<span class="docEmphasis">text</span>) (the one-argument version)
    replaceAll
    replaceFirst
    reset (of course)
</pre><BR>
</li></ul>
<p class="docText">Also important to remember is that character offsets in the match-result data (that is, the values reported by <tt>start</tt> and <tt>end</tt> methods) are not region-relative values, but always with respect to the start of the entire target.</p>

<a name="regex3-CHP-8-SECT-4.6.2"></a>
<H5 id="title-IDA3XUTR" class="docSection3Title">8.4.6.2. Setting and inspecting region bounds</H5>
<a name="IDX-CHP-8-2895"></a> 

<a name="IDX-CHP-8-2896"></a> 
<a name="IDX-CHP-8-2897"></a> 
<a name="IDX-CHP-8-2898"></a> 
<a name="IDX-CHP-8-2899"></a> 

<p class="docText">Three matcher methods relate to setting and inspecting the region bounds:</p>
<a name="IDX-CHP-8-2900"></a><a name="IDX-CHP-8-2901"></a><dl class="docList">
<dt><br><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">Matcher <span class="docEmphStrong">region(</span>int <span class="docEmphasis">start</span>, int <span class="docEmphasis">end</span><span class="docEmphStrong">)</span></span></span></span></p></dt>
<dd><p class="docList">This method sets the matcher's region to the range of target-text characters between <span class="docEmphasis">start</span> and <span class="docEmphasis">end</span>, which are offsets from the beginning of the target text. It also resets the matcher, setting its <span class="docEmphasis">match pointer</span> to the start of the region, so the next <tt>find</tt> invocation begins there.</P>
<p class="docList">The region remains in effect until set again, or until one of the <tt>reset</tt> methods is called (either explicitly, or by one of the methods that invoke it &#9758; 392).</p>
<p class="docList">This method returns the matcher object itself, so it can be used with method chaining (&#9758; 389).</p>
<p class="docList">This method throws <tt>IndexOutOfBoundsException</tt> if <span class="docEmphasis">start</span> or <span class="docEmphasis">end</span> refer to a point outside the target text, or if <span class="docEmphasis">start</span> is greater than <span class="docEmphasis">end</span>.</P></dd>

<dt><br><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int <span class="docEmphStrong">regionStart()</span></span></span></span></P></dt>
<a name="IDX-CHP-8-2900"></a> 

<dd><p class="docList">Returns the character offset to the start of the matcher's current region. The default is zero.</p></dd>

<dt><BR><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">int <span class="docEmphStrong">regionEnd()</span></span></span></span></p></dt>
<a name="IDX-CHP-8-2901"></a> 

<dd><p class="docList">Returns the character offset to the end of the matcher's current region. The default is the length of the matcher's target text.</p></dd>
</dl>
<p class="docText">Because the <tt>region</tt> method requires both <span class="docEmphasis">start</span> and <span class="docEmphasis">end</span> to be explicitly provided, it can be a bit inconvenient when you want to set only one. <a class="docLink" href="#regex3-CHP-8-TABLE-4">Table 8-4</a> offers ways to do so.</p>
<a name="regex3-CHP-8-TABLE-4"></a><p><table cellspacing="0" FRAME="hsides" RULES="all" cellpadding="4" width="100%"><caption><h5 class="docTableTitle">Table 8-4. Setting Only One Edge of the Region</h5></caption><colgroup span="3"><col><col><col></colgroup><thead><tr><th class="thead" scope="col" align="center"><p class="docText">Region Start</p></th><th class="thead" scope="col" align="center"><p class="docText">Region End</p></th><th class="thead" scope="col" align="center"><p class="docText">Java Code</p></th></tr></thead><TR><td class="docTableCell" align="center"><p class="docText">set explicitly</P></td><td class="docTableCell" align="center"><p class="docText">leave unchanged</P></TD><TD class="docTableCell" align="left"><p class="docText"><span class="docEmphasis">m</span>.<tt>region</tt>(<span class="docEmphasis">start</span>, <span class="docEmphasis">m</span>.<tt>regionEnd()</tt>);</P></td></TR><tr><td class="docTableCell" align="center"><p class="docText">leave unchanged</P></TD><td class="docTableCell" align="center"><p class="docText">set explicitly</P></TD><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis">m</span>.<tt>region</tt>(<span class="docEmphasis">m</span>.<tt>regionStart()</tt>, <span class="docEmphasis">end</span>);</p></td></TR><TR><td class="docTableCell" align="center"><p class="docText">set explicitly</p></td><td class="docTableCell" align="center"><p class="docText">reset to default</P></td><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis">m</span>.<tt>reset()</tt>.<tt>region</tt>(<span class="docEmphasis">start</span>, <span class="docEmphasis">m</span>.<tt>regionEnd()</tt>);</P></td></tr><TR><td class="docTableCell" align="center"><p class="docText">reset to default</P></td><td class="docTableCell" align="center"><p class="docText">set explicitly</p></td><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis">m</span>.<tt>region</tt>(0, <span class="docEmphasis">end</span>);</p></td></tr></table></p><br>

<a name="regex3-CHP-8-SECT-4.6.3"></a>
<h5 id="title-IDAZYVTR" class="docSection3Title">8.4.6.3. Looking outside the current region</h5>
<p class="docText">Setting a region to something other than the all-text default normally hides, in every respect, the excluded text from the regex engine. This means, for example, that the start of the region is matched by <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0> even though it may not be the start of the target text.</P>
<p class="docText">However, it's possible to open up the areas outside the region to limited inspection. Turning on <span class="docEmphasis">transparent bounds</span> opens up the excluded text to "looking" constructs (lookahead, lookbehind, and word boundaries), and by turning off <span class="docEmphasis">anchoring bounds</span>, you can configure the edges of the region to <span class="docEmphasis">not</span> be considered the start and/or edge of the input (unless they truly are).</p>
<p class="docText">The reason one might want to change either of these flags is strongly related to why the region was adjusted from the default in the first place. We had no need to do this in the earlier region examples because of their naturethe region-related searches used neither anchoring nor looking constructs, for example.</P>
<p class="docText">But imagine again using a <tt>CharBuffer</tt><a name="IDX-CHP-8-2902"></a> 
 to hold text being edited by the user within your application. If the user does a search or search-and-replace operation, it's natural to limit the operation to the text after the cursor, so you'd set the region to start at the current cursor position. Imagine further that the user's cursor is at the marked point in this text:</p>
<blockquote>
<p class="docText"><tt>Madagas<sub><img src=images/U22CF.jpg border=0></sub>car is much too large to see on foot, so you'll need a car</tt>.</p>
</blockquote>
<p class="docText">and requests that matches of <img src=images/U2308.jpg border=0><tt>\b<span class="docEmphStrong">car</span>\b</tt><img src=images/U230B.jpg border=0> be changed to "automobile." After setting the region appropriately (to isolate the text to the right of the cursor), you'll launch the search and perhaps be surprised to find that it matches right there at the start of the region, in '<img border="0" alt="" width="81" height="13" SRC="images/regex3_u0805.jpg">'. It matches there because the transparent-bounds flag defaults to false, and as such, the <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0> believes that the start of the region is the start of the text. It can't "see" what comes before the start of the region. Were the transparent-bounds flag set to true, <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0> would see the '<tt>s</tt>' before the region-starting 'c' and know that <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0> can't match there.</P>

<a name="regex3-CHP-8-SECT-4.6.4"></a>
<H5 id="title-IDAZ0VTR" class="docSection3Title">8.4.6.4. Transparent bounds</H5>
<a name="IDX-CHP-8-2903"></a> 
<a name="IDX-CHP-8-2904"></a> 
<a name="IDX-CHP-8-2905"></a> 
<a name="IDX-CHP-8-2906"></a> 
<a name="IDX-CHP-8-2907"></a> 

<p class="docText">These methods relate to the transparent-bounds flag:</P>
<a name="IDX-CHP-8-2908"></a><a name="IDX-CHP-8-2909"></a><a name="IDX-CHP-8-2910"></a><a name="IDX-CHP-8-2911"></a><a name="IDX-CHP-8-2912"></a><dl class="docList">
<dt><br><P><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">Matcher <span class="docEmphStrong">useTransparentBounds(</span>boolean <span class="docEmphasis">b</span><span class="docEmphStrong">)</span></span></span></span></p></dt>
<a name="IDX-CHP-8-2908"></a> 

<dd><p class="docList">Sets the matcher's transparent-bounds flag to <span class="docEmphasis">true</span> or <span class="docEmphasis">false</span>, as per the argument. The default is <span class="docEmphasis">false</span>.</p>
<p class="docList">This method returns the matcher object itself, so it can be used with method chaining (&#9758; 389).</P></dd>

<dt><BR><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">boolean <span class="docEmphStrong">hasTransparentBounds()</span></span></span></span></P></dt>
<a name="IDX-CHP-8-2909"></a> 

<dd><p class="docList">Returns true if transparent bounds<a name="IDX-CHP-8-2910"></a> 
<a name="IDX-CHP-8-2911"></a> 
<a name="IDX-CHP-8-2912"></a> 
 are in effect, false otherwise.</P></dd>
</dl>
<p class="docText">The default state of a matcher's transparent-bounds flag is <span class="docEmphasis">false</span>, meaning that the region bounds are not transparent to "looking" constructs such as lookahead, lookbehind, and word boundaries. As such, characters that might exist beyond the edges of the region are not seen by the regex engine.<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-8-FN-6">[<img src=images/U2020.jpg border=0>]</a></sup> This means that even though the region start might be placed within a word, <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0> can match at the start of the region  it does not see that a letter exists just before the region-starting letter.</p><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-8-FN-6">[<img src=images/U2020.jpg border=0>]</a></sup> There's an exception as of Java<a name="IDX-CHP-8-2913"></a> 
 1.5 Update 7 due to an obscure bug I've reported to Sun. A <tt>Pattern.MULTILINE</tt> version of <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0>, (which can be considered a looking construct in the context of a nondefault region) can match at the start of the region if there's a line terminator just before the start of the region, even though anchoring bounds have been turned off and opaque bounds are on.</p></blockquote>
<p class="docText">This example illustrates a <span class="docEmphasis">false</span>(default) transparent-bounds flag:</p>
<pre>
    String <span class="docEmphasis">regex</span> = "\\bcar\\b"; // <img src=images/U2308.jpg border=0>\<span class="docEmphasis">b car</span>\b<img src=images/U230B.jpg border=0>
    String <span class="docEmphasis">text</span>  = "Madagascar is best seen by car or bike.";
    Matcher <span class="docEmphasis">m</span> = Pattern.compile(<span class="docEmphasis">regex</span>).matcher(<span class="docEmphasis">text</span>);
    <span class="docEmphasis">m</span>.region(7, <span class="docEmphasis">text</span>.length());
    <span class="docEmphasis">m</span>.find();
    System.out.println("Matches starting at character " + <span class="docEmphasis">m</span>.start());
</pre><BR>

<p class="docText">It produces:</P>
<blockquote>
<p class="docText"><tt>Matches starting at character 7</tt></p>
</blockquote>
<p class="docText">indicating that a word boundary indeed matched at the start of the region, in the middle of <tt>Madagas<sub><img src=images/U22CF.jpg border=0></sub>car</tt>, despite not being a word boundary at all. The non-transparent edge of the region "spoofed" a word boundary.</p>
<p class="docText">However, adding:</p>
<blockquote>
<p class="docText"><span class="docEmphasis">m</span>.<tt>useTransparentBounds(true)</tt>;</p>
</blockquote>
<p class="docText">before the <tt>find</tt> call causes the example to produce:</P>
<blockquote>
<p class="docText"><tt>Matches starting at character 27</tt></p>
</blockquote>
<p class="docText">Because the bounds are now transparent, the engine can see that the character just before the start of the region, '<tt>s</tt>', is a letter, thereby forbidding <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0> to match there. That's why a match isn't found until later, at '&#8943;by&#8226;<img border="0" alt="" width="24" height="10" SRC="images/regex3_u0806.jpg">&#8226;or&#8226;bike.'</p>
<p class="docText">Again, the transparent-bounds flag is relevant only when the region has been changed from its "all text" default. Note also that the <tt>reset</tt> method does <span class="docEmphasis">not</span> reset this flag.</P>

<a name="regex3-CHP-8-SECT-4.6.5"></a>
<h5 id="title-IDAKBSRP" class="docSection3Title">8.4.6.5. Anchoring bounds</h5>
<a name="IDX-CHP-8-2914"></a> 
<a name="IDX-CHP-8-2915"></a> 
<a name="IDX-CHP-8-2916"></a> 
<a name="IDX-CHP-8-2917"></a> 

<p class="docText">These methods relate to the anchoring-bounds flag:</P>
<a name="IDX-CHP-8-2918"></a><a name="IDX-CHP-8-2919"></a><a name="IDX-CHP-8-2920"></a><a name="IDX-CHP-8-2921"></a><a name="IDX-CHP-8-2922"></a><dl class="docList">
<dt><br><P><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">Matcher <span class="docEmphStrong">useAnchoringBounds(</span>boolean <span class="docEmphasis">b</span><span class="docEmphStrong">)</span></span></span></span></p></dt>
<a name="IDX-CHP-8-2918"></a> 

<dd><p class="docList">Sets the matcher's anchoring-bounds flag to <span class="docEmphasis">true</span> or <span class="docEmphasis">false</span>, as per the argument. The default is <span class="docEmphasis">true</span>.</p>
<p class="docList">This method returns the matcher object itself, so it can be used with method chaining (&#9758; 389).</p></dd>

<dt><br><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">boolean <span class="docEmphStrong">hasAnchoringBounds()</span></span></span></span></p></dt>
<a name="IDX-CHP-8-2919"></a> 

<dd><p class="docList">Returns true if anchoring bounds<a name="IDX-CHP-8-2920"></a> 
<a name="IDX-CHP-8-2921"></a> 
<a name="IDX-CHP-8-2922"></a> 
 are in effect, false otherwise.</p></dd>
</dl>
<p class="docText">The default state of a matcher's anchoring-bounds flag is <span class="docEmphasis">true</span>, meaning that the line anchors<a name="IDX-CHP-8-2923"></a> 
 <tt>(^ \A $ \z \Z)</tt> match at the region boundaries, even if those boundaries have been moved from the start and end of the target string. Setting the flag to <span class="docEmphasis">false</span> means that the line anchors match only at the true ends of the target string, should the region include them.</p>
<p class="docText">One might turn off anchoring bounds for the same kind of reasons that transparent bounds might be turned on, such as to keep the semantics of the region in line with a user's "the cursor is not at the start of the text" expectations.</p>
<p class="docText">As with the transparent-bounds flag, the anchoring-bounds flag is relevant only when the region has been changed from its "all text" default. Note also that the <tt>reset</tt> method does <span class="docEmphasis">not</span> reset this flag.</p>


<a name="regex3-CHP-8-SECT-4.7"></a>
<h4 id="title-IDABFSRP" class="docSection2Title">8.4.7. Method Chaining</h4>
<a name="IDX-CHP-8-2924"></a> 
<a name="IDX-CHP-8-2925"></a> 
<a name="IDX-CHP-8-2926"></a> 
<a name="IDX-CHP-8-2927"></a> 
<a name="IDX-CHP-8-2928"></a> 
<a name="IDX-CHP-8-2929"></a> 
<a name="IDX-CHP-8-2930"></a> 

<p class="docText">Consider this sequence, which prepares a matcher and sets some of its options:</P>
<pre>
    Pattern <span class="docEmphasis">p</span> = Pattern.compile(<span class="docEmphasis">regex</span>);  // <span class="docEmphasis">Compile regex</span>.
    Matcher <span class="docEmphasis">m</span> = <span class="docEmphasis">p</span>.matcher(<span class="docEmphasis">text</span>);         // <span class="docEmphasis">Associate regex with text,
 creating a Matcher</span>.
    <span class="docEmphasis">m</span>.region(5, <span class="docEmphasis">text</span>.length());          // <span class="docEmphasis">Bump start of region five
 characters forward</span>.
    <span class="docEmphasis">m</span>.useAnchoringBounds(false);         // <span class="docEmphasis">Don't let <img src=images/U2308.jpg border=0>^<img src=images/U230B.jpg border=0> et al. match at the
 region start</span>.
    <span class="docEmphasis">m</span>.useTransparentBounds(true);        // <span class="docEmphasis">Let looking constructs see across
 region edges</span>.
</pre><br>

<p class="docText">We've seen in earlier examples that if we don't need the pattern beyond the creation of the matcher (which is often the case), we can combine the first two lines:</P>
<pre>
    Matcher <span class="docEmphasis">m</span> = Pattern.compile(<span class="docEmphasis">regex</span>).matcher(<span class="docEmphasis">text</span>);
    <span class="docEmphasis">m</span>.region(5, <span class="docEmphasis">text</span>.length());   // <span class="docEmphasis">Bump start of region five characters
 forward</span>.
    <span class="docEmphasis">m</span>.useAnchoringBounds(false);  // <span class="docEmphasis">Don't let <img src=images/U2308.jpg border=0>^<img src=images/U230B.jpg border=0> et al. match at the region
 start</span>.
    <span class="docEmphasis">m</span>.useTransparentBounds(true); // <span class="docEmphasis">Let looking constructs see across region
 edges</span>.
</pre><br>

<p class="docText">However, because the two matcher methods invoked after that are from among those that return the matcher itself, we can combine everything into one line (although presented here on two lines to fit the page):</p>
<pre>
    Matcher <span class="docEmphasis">m</span> = Pattern.compile(<span class="docEmphasis">regex</span>).matcher(<span class="docEmphasis">text</span>).region(5, <span class="docEmphasis">text</span>.length())
                  .useAnchoringBounds(false).useTransparentBounds(true);
</pre><BR>

<p class="docText">This doesn't buy any extra functionality, but it can be quite convenient. This kind of "<a class="docLink" href="#regex3-CHP-8-SECT-4.7">method chaining</a>"<a name="IDX-CHP-8-2931"></a> 
<a name="IDX-CHP-8-2932"></a> 
 can make action-by-action documentation more difficult to fit in and format neatly, but then, good documentation tends to focus on the <span class="docEmphasis">why</span> rather than the <span class="docEmphasis">what</span>, so perhaps this is not such a concern. Method chaining is used to great effect in keeping the code on page 399 clear and concise.</P>

<a name="regex3-CHP-8-SECT-4.8"></a>
<H4 id="title-IDAERSRP" class="docSection2Title">8.4.8. Methods for Building a Scanner</H4>
<p class="docText">New in Java<a name="IDX-CHP-8-2933"></a> 
<a name="IDX-CHP-8-2934"></a> 
 1.5 are <tt>hitEnd</tt><a name="IDX-CHP-8-2935"></a> 
 and <tt>requireEnd</tt>,<a name="IDX-CHP-8-2936"></a> 
 two matcher methods used primarily in building scanners. A scanner<a name="IDX-CHP-8-2937"></a> 
 parses a stream of characters into a stream of tokens. For example, a scanner that's part of a compiler might accept '<tt>var</tt>&#8226;&lt;&#8226;<span class="docEmphasis">34</span>' and produce the three tokens IDENTIFIER &#183; LESSR_THAN &#183; INTEGER.</p>
<p class="docText">These methods help a scanner decide whether the results from the just-completed match attempt should be used to decide the proper interpretation of the current input. Generally speaking, a return value of <span class="docEmphasis">true</span> from either method means that more input is required before a definite decision can be made. For example, if the current input (say, characters being typed by the user in an interactive debugger) is the single character '<tt>&lt;</tt>', it's best to wait to see whether the next character is '<tt>=</tt>' so you can properly decide whether the next token should be LESS_THAN or LESS_THAN_OR_EQUAL.</P>
<p class="docText">These methods will likely be of little use to the vast majority of regex-related projects, but when they're at all useful, they're invaluable. This occasional invaluableness makes it all the more lamentable that <tt>hitEnd</tt><a name="IDX-CHP-8-2938"></a> 
 has a bug that renders it unreliable in Java 1.5. Luckily, it appears to have been fixed in Java 1.6, and for Java 1.5, there's an easy workaround described at the end of this section.</p>
<p class="docText">The subject of building a scanner is quite beyond the scope of this book, so I'll limit the coverage of these specialized methods to their definitions and some illustrative examples. (By the way, if you're in need of a scanner, you might be interested in <tt>java.util.Scanner</tt><a name="IDX-CHP-8-2939"></a> 
 as well.)</p>
<a name="IDX-CHP-8-2940"></a><dl class="docList">
<dt><BR><P><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">boolean <span class="docEmphStrong">hitEnd()</span></span></span></span></p></dt>
<dd><p class="docList">(This method is unreliable in Java 1.5; a workaround is presented on page 392.)</P>
<p class="docList">This method indicates whether the regex engine tried to inspect beyond the trailing end of the input during the previous match attempt (regardless of whether that attempt was ultimately successful). This includes the inspection done by boundaries such as <img src=images/U2308.jpg border=0><tt>\b</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0>.</P>
<p class="docList">If <tt>hitEnd</tt> returns true, more input could have changed the result (changed failure to success, changed success to failure, or changed the span of text matched). On the other hand, false means that the results from the previous attempt were derived solely from the input the regex engine had to work with, and, as such, appending additional text could not have changed the result.</p>
<p class="docList">The common application is that if you have a successful match after which <tt>hitEnd</tt> is true, you need to wait for more input before committing to a decision. If you have a failed match attempt and <tt>hitEnd</tt> is true, you'll want to allow more input to come in, rather than aborting with a syntax error.</p></dd>

<dt><br><P><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">boolean <span class="docEmphStrong">requireEnd()</span></span></span></span></P></dt>
<a name="IDX-CHP-8-2940"></a> 

<dd><p class="docList">This method, which is meaningful only after a successful match, indicates whether the regex engine relied on the location of the end of the input to achieve that success. Put another way, if <tt>requireEnd</tt> returns true, additional input could have caused the attempt to fail. If it returns false, additional input could have changed the details of success, but could not have turned success into failure.</p>
<p class="docList">Its common application is that if <tt>requireEnd</tt> is true, you should accept more input before committing to a decision about the input.</p></dd>
</dl>
<p class="docText">Both <tt>hitEnd</tt> and <tt>requireEnd</tt> respect the region.</p>
<a name="regex3-CHP-8-SECT-4.8.1"></a>
<h5 id="title-IDAKVSRP" class="docSection3Title">8.4.8.1. Examples illustrating <tt>hitEnd</tt> and <tt>requireEnd</tt></H5>
<p class="docText"><a class="docLink" href="#regex3-CHP-8-TABLE-5">Table 8-5</a> shows examples of <tt>hitEnd</tt> and <tt>requireEnd</tt> after a <tt>lookingAt</tt> search. Two expressions are used that, although unrealistically simple on their own, are useful in illustrating these methods.</p>
<a name="regex3-CHP-8-TABLE-5"></a><p><table cellspacing="0" FRAME="hsides" RULES="all" cellpadding="4" width="100%"><caption><H5 class="docTableTitle">Table 8-5. hitEnd and requireEnd after a lookingAt search</h5></caption><colgroup span="6"><col><col><col><col><col><col></colgroup><thead><tr><th class="thead" scope="col" align="center"><p class="docText">&nbsp;</P></th><th class="thead" scope="col" align="center"><p class="docText">Regex</p></th><th class="thead" scope="col" align="left"><p class="docText">Text</P></th><th class="thead" scope="col" align="left"><p class="docText">Match</p></th><th class="thead" scope="col" align="center"><p class="docText"><tt>hitEnd()</tt></p></th><th class="thead" scope="col" align="center"><p class="docText"><tt>requireEnd()</tt></p></th></tr></thead><tr><td class="docTableCell" align="center"><p class="docText"><span class="docEmphasis">1</span></p></td><td class="docTableCell" align="left"><p class="docText"><tt>\d+\b | [&gt;&lt;]=?</tt></p></td><td class="docTableCell" align="left"><p class="docText">'<tt>1234</tt>'</P></td><TD class="docTableCell" align="left"><p class="docText">'<img border="0" alt="" width="30" height="13" SRC="images/regex3_t0801.jpg">'</p></td><TD class="docTableCell" align="center"><p class="docText">true</P></TD><TD class="docTableCell" align="center"><p class="docText">true</p></TD></tr><tr><TD class="docTableCell" align="center"><p class="docText"><span class="docEmphasis">2</span></P></td><TD class="docTableCell" align="left"><p class="docText"><tt>\d+\b | [&gt;&lt;]=?</tt></P></td><td class="docTableCell" align="left"><p class="docText">'<tt>1234</tt>&#8226;&gt;&#8226;<tt>567</tt>'</p></TD><TD class="docTableCell" align="left"><p class="docText">'<img border="0" alt="" width="30" height="13" SRC="images/regex3_t0801.jpg">&#8226;&gt;&#8226;<tt>567</tt>'</p></td><td class="docTableCell" align="center"><p class="docText">false</p></TD><td class="docTableCell" align="center"><p class="docText">false</p></TD></tr><tr><TD class="docTableCell" align="center"><p class="docText"><span class="docEmphasis">3</span></p></TD><td class="docTableCell" align="left"><p class="docText"><tt>\d+\b | [</tt>&gt;&lt;<tt>]=?</tt></p></td><td class="docTableCell" align="left"><p class="docText">'<tt>&gt;</tt>'</p></td><td class="docTableCell" align="left"><p class="docText">'<img border="0" alt="" width="7" height="13" SRC="images/regex3_t0802.jpg">'</p></td><td class="docTableCell" align="center"><p class="docText">true</p></td><TD class="docTableCell" align="center"><p class="docText">false</p></TD></tr><tr><TD class="docTableCell" align="center"><p class="docText"><span class="docEmphasis">4</span></P></TD><TD class="docTableCell" align="left"><p class="docText"><tt>\d+\b | [</tt>&gt;&lt;<tt>]=?</tt></p></TD><td class="docTableCell" align="left"><p class="docText">'<tt>&gt;</tt>&#8226;<tt>567</tt>'</p></TD><TD class="docTableCell" align="left"><p class="docText">'<img border="0" alt="" width="7" height="13" SRC="images/regex3_t0802.jpg">&#8226;<tt>567</tt>'</p></TD><TD class="docTableCell" align="center"><p class="docText">false</p></td><td class="docTableCell" align="center"><p class="docText">false</P></TD></tr><tr><td class="docTableCell" align="center"><p class="docText"><span class="docEmphasis">5</span></p></TD><td class="docTableCell" align="left"><p class="docText"><tt>\d+\b | [</tt>&gt;&lt;<tt>]=?</tt></p></TD><td class="docTableCell" align="left"><p class="docText">'<tt>&gt;=</tt>'</p></TD><td class="docTableCell" align="left"><p class="docText">'<img border="0" alt="" width="14" height="13" SRC="images/regex3_t0803.jpg">'</P></td><td class="docTableCell" align="center"><p class="docText">false</p></td><td class="docTableCell" align="center"><p class="docText">false</p></td></tr><tr><td class="docTableCell" align="center"><p class="docText"><span class="docEmphasis">6</span></p></td><TD class="docTableCell" align="left"><p class="docText"><tt>\d+\b | [&gt;&lt;]=?</tt></p></TD><td class="docTableCell" align="left"><p class="docText">'<tt>&gt;=</tt>&#8226;<tt>567</tt>'</p></TD><TD class="docTableCell" align="left"><p class="docText">'<img border="0" alt="" width="14" height="13" SRC="images/regex3_t0803.jpg">&#8226;<tt>567</tt>'</P></TD><td class="docTableCell" align="center"><p class="docText">false</P></td><td class="docTableCell" align="center"><p class="docText">false</P></TD></tr><TR><TD class="docTableCell" align="center"><p class="docText"><span class="docEmphasis">7</span></p></td><td class="docTableCell" align="left"><p class="docText"><tt>\d+\b | [</tt>&gt;&lt;<tt>]=?</tt></P></TD><td class="docTableCell" align="left"><p class="docText">'<tt>oops</tt>'</p></td><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis">no match</span></P></td><td class="docTableCell" align="center"><p class="docText">false</P></td><td class="docTableCell" align="center"><p class="docText">&nbsp;</P></td></TR><tr><td class="docTableCell" align="center"><p class="docText"><span class="docEmphasis">8</span></p></td><td class="docTableCell" align="left"><p class="docText"><tt>(set | setup)\b</tt></p></td><td class="docTableCell" align="left"><p class="docText">'<tt>se</tt>'</p></td><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis">no match</span></p></TD><td class="docTableCell" align="center"><p class="docText">true</P></td><td class="docTableCell" align="center"><p class="docText">&nbsp;</P></TD></TR><TR><td class="docTableCell" align="center"><p class="docText"><span class="docEmphasis">9</span></P></td><td class="docTableCell" align="left"><p class="docText"><tt>(set | setup)\b</tt></P></TD><td class="docTableCell" align="left"><p class="docText">'<tt>set</tt>'</P></TD><td class="docTableCell" align="left"><p class="docText">'<img border="0" alt="" width="22" height="13" SRC="images/regex3_t0804.jpg">'</p></td><TD class="docTableCell" align="center"><p class="docText">true</P></td><td class="docTableCell" align="center"><p class="docText">true</p></td></TR><tr><td class="docTableCell" align="center"><p class="docText"><span class="docEmphasis">10</span></P></td><td class="docTableCell" align="left"><p class="docText"><tt>(set | setup)\b</tt></P></td><TD class="docTableCell" align="left"><p class="docText">'<tt>setu</tt>'</p></td><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis">no match</span></p></td><td class="docTableCell" align="center"><p class="docText">true</p></td><td class="docTableCell" align="center"><p class="docText">&nbsp;</p></td></tr><TR><td class="docTableCell" align="center"><p class="docText"><span class="docEmphasis">11</span></P></td><td class="docTableCell" align="left"><p class="docText"><tt>(set | setup)\b</tt></P></TD><TD class="docTableCell" align="left"><p class="docText">'<tt>setup</tt>'</P></td><TD class="docTableCell" align="left"><p class="docText">'<img border="0" alt="" width="36" height="13" SRC="images/regex3_t0805.jpg">'</p></td><TD class="docTableCell" align="center"><p class="docText">true</P></td><TD class="docTableCell" align="center"><p class="docText">true</P></td></tr><tr><TD class="docTableCell" align="center"><p class="docText"><span class="docEmphasis">12</span></P></td><td class="docTableCell" align="left"><p class="docText"><tt>(set | setup)\b</tt></p></td><TD class="docTableCell" align="left"><p class="docText">'<tt>set</tt>&#8226;<tt>x=3</tt>'</p></td><TD class="docTableCell" align="left"><p class="docText">'<img border="0" alt="" width="22" height="13" SRC="images/regex3_t0804.jpg">&#8226;<tt>x=3</tt>'</p></td><TD class="docTableCell" align="center"><p class="docText">false</p></TD><td class="docTableCell" align="center"><p class="docText">false</p></td></tr><tr><td class="docTableCell" align="center"><p class="docText"><span class="docEmphasis">13</span></p></td><td class="docTableCell" align="left"><p class="docText"><tt>(set | setup)\b</tt></p></td><td class="docTableCell" align="left"><p class="docText">'<tt>setup</tt>&#8226;<tt>x</tt>'</P></td><TD class="docTableCell" align="left"><p class="docText">'<img border="0" alt="" width="36" height="13" SRC="images/regex3_t0805.jpg">&#8226;<tt>x</tt>'</p></td><TD class="docTableCell" align="center"><p class="docText">false</P></TD><TD class="docTableCell" align="center"><p class="docText">false</p></TD></tr><tr><TD class="docTableCell" align="center"><p class="docText"><span class="docEmphasis">14</span></P></td><TD class="docTableCell" align="left"><p class="docText"><tt>(set | setup)\b</tt></P></td><td class="docTableCell" align="left"><p class="docText">'<tt>self</tt>'</p></TD><TD class="docTableCell" align="left"><p class="docText"><span class="docEmphasis">no match</span></p></td><td class="docTableCell" align="center"><p class="docText">false</p></TD><td class="docTableCell" align="center"><p class="docText">&nbsp;</p></TD></tr><tr><TD class="docTableCell" align="center"><p class="docText"><span class="docEmphasis">15</span></p></TD><td class="docTableCell" align="left"><p class="docText"><tt>(set | setup)\b</tt></p></td><td class="docTableCell" align="left"><p class="docText">'<tt>oops</tt>'</p></td><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis">no match</span></p></td><td class="docTableCell" align="center"><p class="docText">false</p></td><TD class="docTableCell" align="center"><p class="docText">&nbsp;</p></TD></tr></table></p><BR>
<p class="docText">The regex in the top half of <a class="docLink" href="#regex3-CHP-8-TABLE-5">Table 8-5</a> looks for a non-negative integer and four comparison operators: greater than, less than, greater-than-or-equal, and less-than-or-equal. The bottom-half regex is even simpler, looking for the words <tt>set</tt> and <tt>setup</tt>. Again, these are simple examples, but illustrative.</P>
<p class="docText">For example, notice in test 5 that even though the entire target was matched, <tt>hitEnd</tt> remains false. The reason is that, although the last character in the target was matched, the engine never had to inspect beyond that character (to check for another character or for a boundary).</P>

<a name="regex3-CHP-8-SECT-4.8.2"></a>
<H5 id="title-IDACTTRP" class="docSection3Title">8.4.8.2. The <tt>hitEnd</tt> bug and its workaround</h5>
<a name="IDX-CHP-8-2941"></a> 
<a name="IDX-CHP-8-2942"></a> 
<a name="IDX-CHP-8-2943"></a> 
<a name="IDX-CHP-8-2944"></a> 
<a name="IDX-CHP-8-2945"></a> 
<a name="IDX-CHP-8-2946"></a> 
<a name="IDX-CHP-8-2947"></a> 

<p class="docText">The "<tt>hitEnd</tt> bug" in Java 1.5 (fixed in Java 1.6)<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-8-FN-7">[<img src=images/U2020.jpg border=0>]</a></sup> causes unreliable results from the <tt>hitEnd</tt> method in one very specific situation: when an optional, single-character regex component is attempted in case-insensitive mode (specifically, when such an attempt fails).</P><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-8-FN-7">[<img src=images/U2020.jpg border=0>]</a></sup> As this book goes to press, Sun tells me that this bug should be fixed in "5.0u9," which means Java 1.5 Update 9. (You'll recall from the footnote on page 365 that the version of Java 1.5 covered by this book is Update 7.) And again, it's already fixed in the Java 1.6 beta.</p></blockquote>
<p class="docText">For example, the expression <img src=images/U2308.jpg border=0><tt>&gt;=?</tt><img src=images/U230B.jpg border=0> in case-insensitive mode (by itself, or as part of a larger expression) tickles the bug because '<tt>=</tt>' is an optional, single-character component. Another example, <img src=images/U2308.jpg border=0><tt>a|an|the</tt><img src=images/U230B.jpg border=0> in case-insensitive mode (again, alone or as part of a larger expression) tickles the bug because the <img src=images/U2308.jpg border=0><tt>a</tt><img src=images/U230B.jpg border=0> alternative is a single character, and being one of several alternatives, is optional.</p>
<p class="docText">Other examples include <img src=images/U2308.jpg border=0><tt>values?</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>\r?\n\r?\n</tt><img src=images/U230B.jpg border=0></P>
<p class="docText"><span class="docEmphasis"><span class="docEmphStrong">The workaround</span></span> The workaround is to remove the offending condition, either by turning off case-insensitive mode (at least for the offending subexpression), or to replace the single character with something else, such as a character class.</P>
<p class="docText">Using the first approach, <img src=images/U2308.jpg border=0><tt>&gt;=?</tt><img src=images/U230B.jpg border=0> might become <img src=images/U2308.jpg border=0><tt>(?-i:&gt;=?)</tt><img src=images/U230B.jpg border=0>, which uses a mode-modified span<a name="IDX-CHP-8-2948"></a> 
 (&#9758; 110) to ensure that insensitivity does not apply to the subexpr ession (which doesn't benefit from a case insensitivity to begin with, so the workaround is "free" in this case).</p>
<p class="docText">Using the second approach, <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">a</span>|an|the</tt><img src=images/U230B.jpg border=0> becomes <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">[aA]</span>|an|the</tt><img src=images/U230B.jpg border=0>, which preserves any case insensitivity applied via the <tt>Pattern.CASE_INSENSITIVE</tt> flag.</P>



</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-8-SECT-3.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-8-SECT-5.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>