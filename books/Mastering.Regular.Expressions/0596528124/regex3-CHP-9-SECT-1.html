<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 9.1.&nbsp; .NET's Regex Flavor</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-9.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-9-SECT-2.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="regex3-CHP-9-SECT-1"></a>
<H3 id="title-IDA3HNLF" class="docSection1Title">9.1. .NET's Regex Flavor</H3>
<a name="IDX-CHP-9-3043"></a> 
<a name="IDX-CHP-9-3044"></a> 
<a name="IDX-CHP-9-3045"></a> 
<a name="IDX-CHP-9-3046"></a> 
<a name="IDX-CHP-9-3047"></a> 
<a name="IDX-CHP-9-3048"></a> 
<a name="IDX-CHP-9-3049"></a> 
<a name="IDX-CHP-9-3050"></a> 
<a name="IDX-CHP-9-3051"></a> 
<a name="IDX-CHP-9-3052"></a> 
<a name="IDX-CHP-9-3053"></a> 
<a name="IDX-CHP-9-3054"></a> 
<a name="IDX-CHP-9-3055"></a> 
<a name="IDX-CHP-9-3056"></a> 
<a name="IDX-CHP-9-3057"></a> 
<a name="IDX-CHP-9-3058"></a> 
<a name="IDX-CHP-9-3059"></a> 
<a name="IDX-CHP-9-3060"></a> 
<a name="IDX-CHP-9-3061"></a> 
<a name="IDX-CHP-9-3062"></a> 
<a name="IDX-CHP-9-3063"></a> 

<p class="docText">.NET has been built with a Traditional NFA regex engine, so all the important NFA related lessons from <a class="docLink" href="regex3-CHP-4.html#regex3-CHP-4">Chapter 4</a>, <a class="docLink" href="regex3-CHP-5.html#regex3-CHP-5">5</a>, and <a class="docLink" href="regex3-CHP-6.html#regex3-CHP-6">6</a> are applicable. <a class="docLink" href="#regex3-CHP-9-TABLE-1">Table 9-1</a> on the facing page summarizes .NET's regex flavor, most of which is discussed in <a class="docLink" href="regex3-CHP-3.html#regex3-CHP-3">Chapter 3</a>.</P>
<p class="docText">Certain aspects of the flavor can be modified by <span class="docEmphasis">match modes</span> (&#9758;110), turned on via option flags to the various functions and constructors that accept regular expressions, or in some cases, turned on and off within the regex itself via <img src=images/U2308.jpg border=0><tt>(?<span class="docEmphasis">mods-mods</span>)</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(?</span><span class="docEmphasis">mods-mods</span>:&#8943;<span class="docEmphStrong">)</span></tt><img src=images/U230B.jpg border=0> constructs. The modes are listed in <a class="docLink" href="#regex3-CHP-9-TABLE-2">Table 9-2</a> on page 408.</P>
<p class="docText">In the table, "raw" escapes like <img src=images/U2308.jpg border=0><tt>\w</tt><img src=images/U230B.jpg border=0> are shown. These can be used directly in VB.NET string literals <tt>("\w")</tt>, and in C<span class="docEmphasis">#</span> verbatim strings <tt>(@"\w")</tt>. In languages without regex-friendly string literals, such as C++, each backslash in the regex requires two in the string literal <tt>(<span class="docEmphStrong">"\\w"</span>)</tt>. See "<a class="docLink" href="regex3-CHP-3-SECT-4.html#regex3-CHP-3-SECT-4.1">Strings as Regular Expressions</a>"(&#9758;101).</p>
<p class="docText">The following additional notes augment <a class="docLink" href="#regex3-CHP-9-TABLE-1">Table 9-1</a>:</P>
<ul><li><p class="docList">&#10112; <tt>\b</tt> is a character shorthand for backspace only within a character class.<a name="IDX-CHP-9-3064"></a> 
 Outside of a character class, <tt>\b</tt> matches a word boundary (&#9758;133).</P><p class="docList"><tt><span class="docEmphStrong">\x</span>##</tt><a name="IDX-CHP-9-3065"></a> 
<a name="IDX-CHP-9-3066"></a> 
 allows exactly two hexadecimal digits, e.g., <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">\xFC</span>ber</tt><img src=images/U230B.jpg border=0> matches '&uuml;<tt>ber</tt>'.</P><p class="docList"><tt><span class="docEmphStrong">\u</span>####</tt><a name="IDX-CHP-9-3067"></a> 
<a name="IDX-CHP-9-3068"></a> 
 allows exactly four hexadecimal digits, e.g., <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">\u00FC</span>ber</tt><img src=images/U230B.jpg border=0> matches '&uuml;<tt>ber</tt>', and <img src=images/U2308.jpg border=0><tt>\u20AC</tt><img src=images/U230B.jpg border=0> matches '&euro;'.</p></LI><LI><p class="docList">&#10113; As of Version 2.0, .NET Framework character classes support <span class="docEmphasis">class subtraction</span>,<a name="IDX-CHP-9-3069"></a> 
 such as <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">[</span>a-z-[aeiou]<span class="docEmphStrong">]</span></tt><img src=images/U230B.jpg border=0> for non-vowel lowercase ASCII letters (&#9758;125). Within a class, a hyphen followed by a class-like construct subtracts the characters specified by the latter from those specified before the hyphen.</p></li><li><p class="docList">&#10114; <tt><span class="docEmphStrong">\w</span></tt>, <tt><span class="docEmphStrong">\d</span></tt>, and <tt><span class="docEmphStrong">\s</span></tt> (and their uppercase counterparts) normally match the full range of appropriate Unicode characters, but change to an ASCII-only mode with the <tt>RegexOptions.ECMAScript</tt><a name="IDX-CHP-9-3070"></a> 
 option (&#9758;412).</P><p class="docList">In its default mode, <tt><span class="docEmphStrong">\w</span></tt> matches the Unicode properties <tt>\p{Ll},<a name="IDX-CHP-9-3071"></a> 
<a name="IDX-CHP-9-3072"></a> 
<a name="IDX-CHP-9-3073"></a> 
 \p{Lu},\p{Lt},<a name="IDX-CHP-9-3074"></a> 
<a name="IDX-CHP-9-3075"></a> 
<a name="IDX-CHP-9-3076"></a> 
<a name="IDX-CHP-9-3077"></a> 
<a name="IDX-CHP-9-3078"></a> 
<a name="IDX-CHP-9-3079"></a> 
 \p{Lo},<a name="IDX-CHP-9-3080"></a> 
<a name="IDX-CHP-9-3081"></a> 
<a name="IDX-CHP-9-3082"></a> 
 \p{Nd}</tt><a name="IDX-CHP-9-3083"></a> 
<a name="IDX-CHP-9-3084"></a> 
<a name="IDX-CHP-9-3085"></a> 
 and <tt>\p{Pc}</tt>.<a name="IDX-CHP-9-3086"></a> 
<a name="IDX-CHP-9-3087"></a> 
<a name="IDX-CHP-9-3088"></a> 
 Note that this does not include the <tt>\p{Lm}</tt><a name="IDX-CHP-9-3089"></a> 
<a name="IDX-CHP-9-3090"></a> 
<a name="IDX-CHP-9-3091"></a> 
 property. (See the table on page 123 for the property list.)</P><p class="docList">In its default mode, <tt><span class="docEmphStrong">\s</span></tt> matches <img src=images/U2308.jpg border=0><tt>[&#8226;\f\n\r\t\v\x85\p{Z}]</tt><img src=images/U230B.jpg border=0>. <tt>U+0085</tt> is the Unicode NEXT LINE<a name="IDX-CHP-9-3092"></a> 
 control character, and <tt>\p{Z}</tt><a name="IDX-CHP-9-3093"></a> 
<a name="IDX-CHP-9-3094"></a> 
 matches Unicode "separator" characters (&#9758;122).</p><a name="regex3-CHP-9-TABLE-1"></a><p><table cellspacing="0" FRAME="hsides" RULES="all" cellpadding="4" width="90%"><caption><h5 class="docTableTitle">Table 9-1. Overview of .NET's Regular-Expression Flavor</h5></caption><colgroup span="2"><col><col></colgroup><thead><TR><th class="thead" scope="col" align="left" colspan="2">
<p class="docText">Character Shorthands &#10112;</p></th></tr></thead><TR><td class="docTableCell" align="left"><p class="docText">&#9758;115 (c)</p></TD><td class="docTableCell" align="left"><p class="docText"><tt><span class="docEmphStrong">\a [\b] \e \f \n \r \t \v</span></tt><span class="docEmphasis">octal</span> <tt><span class="docEmphStrong">\x</span><span class="docEmphasis">##</span> <span class="docEmphStrong">\u</span><span class="docEmphasis">####</span> <span class="docEmphStrong">\c</span></tt><span class="docEmphasis">char</span></P></td></tr><tr><td class="docTableCell" align="left" colspan="2">
<p class="docText">Character Classes and Class-Like Constructs</p></td></tr><tr><td class="docTableCell" align="left"><p class="docText">&#9758;118</p></td><td class="docTableCell" align="left"><p class="docText">Classes:&#10113; <span class="docEmphStrong">[</span>&#8943;<span class="docEmphStrong">] [</span>^&#8943;<span class="docEmphStrong">]</span></P></td></TR><tr><td class="docTableCell" align="left"><p class="docText">&#9758;119</P></TD><TD class="docTableCell" align="left"><p class="docText">Any character except newline: <span class="docEmphasis">dot</span> (sometimes any character at all)</P></td></TR><tr><td class="docTableCell" align="left"><p class="docText">&#9758;120 (c)</P></TD><td class="docTableCell" align="left"><p class="docText">Class shorthands: &#10114; <tt><span class="docEmphStrong">\w \d \s \W \D \S</span></tt></P></TD></tr><tr><td class="docTableCell" align="left"><p class="docText">&#9758;121 (c)</P></TD><td class="docTableCell" align="left"><p class="docText">Unicode properties and blocks:&#10115;<a name="IDX-CHP-9-3100"></a> 
 <tt><span class="docEmphStrong">\p{</span></tt><span class="docEmphasis">Prop</span><tt><span class="docEmphStrong">} \P{</span></tt><span class="docEmphasis">Prop</span><tt>}</tt></p></td></tr><TR><td class="docTableCell" align="left" colspan="2">
<p class="docText">Anchors and Other Zero-Width Tests</p></TD></tr><tr><TD class="docTableCell" align="left"><p class="docText">&#9758;129</p></TD><td class="docTableCell" align="left"><p class="docText">Start of line/string: <tt>^<span class="docEmphStrong">\A</span></tt></p></td></tr><tr><td class="docTableCell" align="left"><p class="docText">&#9758;129</p></td><td class="docTableCell" align="left"><p class="docText">End of line/string: <tt><span class="docEmphStrong">$ \z \Z</span></tt></p></td></tr><TR><td class="docTableCell" align="left"><p class="docText">&#9758;130</P></td><td class="docTableCell" align="left"><p class="docText">End of previous match: &#10116; <tt><span class="docEmphStrong">\G</span></tt></P></TD></TR><TR><td class="docTableCell" align="left"><p class="docText">&#9758;133</P></td><td class="docTableCell" align="left"><p class="docText">Word boundary: <tt><span class="docEmphStrong">\b \B</span></tt></P></TD></tr><TR><TD class="docTableCell" align="left"><p class="docText">&#9758;133</p></td><td class="docTableCell" align="left"><p class="docText">Lookaround: &#10117; <tt><span class="docEmphStrong">(?= &#8943;) (?! &#8943;) (?&lt; =&#8943;) (?&lt; !&#8943;)</span></tt></P></TD></tr><tr><td class="docTableCell" align="left" colspan="2">
<p class="docText">Comments and Mode Modifiers</p></TD></tr><tr><TD class="docTableCell" align="left"><p class="docText">&#9758;135</p></td><TD class="docTableCell" align="left"><p class="docText">Mode modifiers: <tt><span class="docEmphStrong">(?</span></tt><span class="docEmphasis">mods-mods</span><tt><span class="docEmphStrong">)</span></tt> Modifiers allowed: <tt><span class="docEmphStrong">x s m i n</span></tt> (&#9758;408)</p></TD></tr><tr><td class="docTableCell" align="left"><p class="docText">&#9758;135</p></td><td class="docTableCell" align="left"><p class="docText">Mode-modified spans: <tt><span class="docEmphStrong">(?</span></tt><span class="docEmphasis">mods-mods</span><tt><span class="docEmphStrong">:</span></tt>&#8943;<tt><span class="docEmphStrong">)</span></tt></p></td></tr><tr><td class="docTableCell" align="left"><p class="docText">&#9758;136</p></TD><td class="docTableCell" align="left"><p class="docText">Comments: <tt><span class="docEmphStrong">(?#</span></tt> &#8943; <tt><span class="docEmphStrong">)</span></tt></P></td></tr><TR><TD class="docTableCell" align="left" colspan="2">
<p class="docText">Grouping, Capturing, Conditional, and Control</P></TD></tr><TR><td class="docTableCell" align="left"><p class="docText">&#9758;137</p></TD><TD class="docTableCell" align="left"><p class="docText">Capturing parentheses:&#10118; <tt><span class="docEmphStrong">(</span></tt>&#8943;<tt><span class="docEmphStrong">)\1 \2</span></tt> ...</p></TD></TR><tr><td class="docTableCell" align="left"><p class="docText">&#9758;436</p></TD><TD class="docTableCell" align="left"><p class="docText">Balanced Grouping <tt><span class="docEmphStrong">(?</span></tt>&lt;<span class="docEmphasis">name-name</span>&gt;&#8943;<tt><span class="docEmphStrong">)</span></tt></p></td></tr><tr><TD class="docTableCell" align="left"><p class="docText">&#9758;409</p></td><TD class="docTableCell" align="left"><p class="docText">Named capture, backreference: <tt><span class="docEmphStrong">(?&lt;</span></tt><span class="docEmphasis">name</span><span class="docEmphStrong">&gt;</span>&#8943;<tt><span class="docEmphStrong">) \k</span></tt><span class="docEmphStrong">&lt;</span><span class="docEmphasis">name</span><span class="docEmphStrong">&gt;</span></p></td></TR><tr><TD class="docTableCell" align="left"><p class="docText">&#9758;137</p></td><td class="docTableCell" align="left"><p class="docText">Grouping-only parentheses: <tt><span class="docEmphStrong">(?:</span></tt>&#8943;<tt><span class="docEmphStrong">)</span></tt></p></td></tr><tr><td class="docTableCell" align="left"><p class="docText">&#9758;139</p></td><td class="docTableCell" align="left"><p class="docText">Atomic grouping: <tt><span class="docEmphStrong">(?</span></tt>&gt;&#8943;<tt><span class="docEmphStrong">)</span></tt></p></TD></tr><TR><td class="docTableCell" align="left"><p class="docText">&#9758;139</p></TD><TD class="docTableCell" align="left"><p class="docText">Alternation: <span class="docEmphStrong">|</span></P></TD></tr><TR><td class="docTableCell" align="left"><p class="docText">&#9758;141</p></TD><TD class="docTableCell" align="left"><p class="docText">Greedy quantifiers: <tt><span class="docEmphStrong">* + ? {n} {n,} {x,y}</span></tt></p></TD></TR><tr><td class="docTableCell" align="left"><p class="docText">&#9758;141</p></TD><TD class="docTableCell" align="left"><p class="docText">Lazy quantifiers: <tt><span class="docEmphStrong">*? +? ?? {n}? {n,}? {x,y}?</span></tt></p></td></tr><tr><TD class="docTableCell" align="left"><p class="docText">&#9758;409</p></td><TD class="docTableCell" align="left"><p class="docText">Conditional: <tt><span class="docEmphStrong">(?</span></tt><span class="docEmphasis">if then</span>|<span class="docEmphasis">else</span>)  "if" can be lookaround, <tt><span class="docEmphStrong">(</span></tt><span class="docEmphasis">num</span><tt><span class="docEmphStrong">)</span></tt>, or <tt>(</tt><span class="docEmphasis">name</span> <tt>)</tt></p></td></TR><tr><TD class="docTableCell" align="left" colspan="2">
<p class="docText">(c)  may also be used within a character class &#10112;&#8943;&#10118; see text</p></td></tr></table></p><br></li><li><p class="docList">&#10115; <tt><span class="docEmphStrong">\p{&#8943;}</span></tt> and <tt><span class="docEmphStrong">\P{&#8943;}</span></tt> support standard Unicode properties and blocks, as of Unicode version 4.0.1. Unicode scripts are not supported.</p><p class="docList">Block names require the <tt>'Is'</tt> prefix (see the table on page 125), and only the raw form unadorned with spaces and underscores may be used. For example, <tt>\p{Is_Greek_Extended}</tt> and <tt>\p{Is Greek Extended}</tt> are not allowed; <tt>\p{IsGreekExtended}</tt> is required.</p><p class="docList">Only the short property names like <tt>\p{Lu}</tt> are supported  long names like <tt>\p{Lowercase_Letter}</tt> are not supported. Single-letter properties <span class="docEmphasis">do</span> require the braces (that is, the <tt>\pL</tt> shorthand for <tt>\p{L}</tt> is <span class="docEmphasis">not</span> supported). See the tables on pages 122 and 123.</p><p class="docList">The special composite property <tt>\p{L&amp;}</tt> is not supported, nor are the special properties <tt>\p{All}, \p{Assigned}</tt>, and <tt>\p{Unassigned}</tt>. Instead, you might use <img src=images/U2308.jpg border=0><tt>(?s:.)</tt><img src=images/U230B.jpg border=0>, <img src=images/U2308.jpg border=0><tt>\P{Cn}</tt><img src=images/U230B.jpg border=0>, and <img src=images/U2308.jpg border=0><tt>\p{Cn}</tt><img src=images/U230B.jpg border=0>,<a name="IDX-CHP-9-3101"></a> 
<a name="IDX-CHP-9-3102"></a> 
<a name="IDX-CHP-9-3103"></a> 
 respectively.</p></li><LI><p class="docList">&#10116; <tt><span class="docEmphStrong">\G</span></tt> matches the <span class="docEmphasis">end</span> of the <span class="docEmphasis">previous</span> match, despite the documentation's claim that it matches at the <span class="docEmphasis">beginning</span> of the <span class="docEmphasis">current</span> match (&#9758;130).</p></LI><li><p class="docList">&#10117; Both lookahead <span class="docEmphasis">and</span> lookbehind can employ arbitrary regular expressions. As of this writing, the .NET<a name="IDX-CHP-9-3104"></a> 
<a name="IDX-CHP-9-3105"></a> 
<a name="IDX-CHP-9-3106"></a> 
<a name="IDX-CHP-9-3107"></a> 
 regex engine is the only one that I know of that allows lookbehind with a subexpression that can match an arbitrary amount of text (&#9758;133).</p></LI><LI><p class="docList">&#10118; The <tt>RegexOptions.ExplicitCapture</tt><a name="IDX-CHP-9-3108"></a> 
 option (also available via the <tt><span class="docEmphStrong">(?n)</span></tt><a name="IDX-CHP-9-3109"></a> 
<a name="IDX-CHP-9-3110"></a> 
 mode modifier) turns off capturing for raw <img src=images/U2308.jpg border=0><tt>(&#8943;)</tt><img src=images/U230B.jpg border=0> parentheses. Explicitly named captures like <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(?&lt;num&gt;</span>\d+<span class="docEmphStrong">)</span></tt><img src=images/U230B.jpg border=0> still work (&#9758;138). If you use named captures, this option allows you to use the visually more pleasing <img src=images/U2308.jpg border=0><tt>(&#8943;)</tt><img src=images/U230B.jpg border=0> for grouping instead of <img src=images/U2308.jpg border=0><tt>(?:&#8943;)</tt><img src=images/U230B.jpg border=0>.</P><a name="regex3-CHP-9-TABLE-2"></a><P><table cellspacing="0" FRAME="hsides" RULES="all" cellpadding="4" width="90%"><caption><h5 class="docTableTitle">Table 9-2. The .NET Match and Regex Modes</H5></caption><colgroup span="3"><col><col><col></colgroup><thead><tr><th class="thead" scope="col" align="left"><p class="docText"><tt>RegexOptions</tt> option</p></th><th class="thead" scope="col" align="left"><p class="docText">(?<span class="docEmphasis">mode</span>)</P></th><th class="thead" scope="col" align="left"><p class="docText">Description</P></th></tr></thead><TR><TD class="docTableCell" align="left"><p class="docText"><tt>.Singleline</tt><a name="IDX-CHP-9-3111"></a> 
</p></td><td class="docTableCell" align="left"><p class="docText"><tt>s</tt></P></TD><td class="docTableCell" align="left"><p class="docText">Causes <span class="docEmphasis">dot</span> to match any character (&#9758;111).</p></td></tr><TR><td class="docTableCell" align="left"><p class="docText"><tt>.Multiline</tt><a name="IDX-CHP-9-3112"></a> 
</p></TD><td class="docTableCell" align="left"><p class="docText"><tt>m</tt></p></TD><td class="docTableCell" align="left"><p class="docText">Expands where <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0> can match (&#9758;111)</P></td></tr><tr><td class="docTableCell" align="left"><p class="docText"><tt>.IgnorePatternWhitespace</tt><a name="IDX-CHP-9-3113"></a> 
</p></td><td class="docTableCell" align="left"><p class="docText"><tt>x</tt></p></td><td class="docTableCell" align="left"><p class="docText">Sets free-spacing and comment mode (&#9758;72).</p></td></TR><tr><TD class="docTableCell" align="left"><p class="docText"><tt>.IgnoreCase</tt><a name="IDX-CHP-9-3114"></a> 
</p></td><TD class="docTableCell" align="left"><p class="docText"><tt>i</tt></P></TD><TD class="docTableCell" align="left"><p class="docText">Turns on case-insensitive matching.</p></TD></tr><tr><TD class="docTableCell" align="left"><p class="docText"><tt>.ExplicitCapture</tt></P></td><TD class="docTableCell" align="left"><p class="docText"><tt>n</tt></P></td><td class="docTableCell" align="left"><p class="docText">Turns capturing off for <img src=images/U2308.jpg border=0><tt>(&#8943;)</tt><img src=images/U230B.jpg border=0>, so only <img src=images/U2308.jpg border=0><tt>(?&lt; <span class="docEmphasis">name</span> &gt;&#8943;)</tt><img src=images/U230B.jpg border=0> capture.</p></TD></TR><tr><td class="docTableCell" align="left"><p class="docText"><tt>.ECMAScript</tt><a name="IDX-CHP-9-3115"></a> 
</p></td><TD class="docTableCell" align="center"><p class="docText">&nbsp;</p></td><TD class="docTableCell" align="left"><p class="docText">Restricts <img src=images/U2308.jpg border=0><tt>\w</tt><img src=images/U230B.jpg border=0>, <img src=images/U2308.jpg border=0><tt>\s</tt><img src=images/U230B.jpg border=0>, and <img src=images/U2308.jpg border=0><tt>\d</tt><img src=images/U230B.jpg border=0> to match ASCII characters only, and more (&#9758;412).</p></td></TR><tr><TD class="docTableCell" align="left"><p class="docText"><tt>.RightToLeft</tt><a name="IDX-CHP-9-3116"></a> 
</p></td><td class="docTableCell" align="center"><p class="docText">&nbsp;</p></td><td class="docTableCell" align="left"><p class="docText">The transmission applies the regex normally, but in the opposite direction (starting at the <span class="docEmphasis">end</span> of the string and moving toward the start). Unfortunately, buggy (&#9758;411).</p></td></tr><tr><td class="docTableCell" align="left"><p class="docText"><tt>.Compiled</tt><a name="IDX-CHP-9-3117"></a> 
</p></TD><td class="docTableCell" align="center"><p class="docText">&nbsp;</P></td><td class="docTableCell" align="left"><p class="docText">Spends extra time up front optimizing the regex so it matches more quickly when applied (&#9758;410).</P></TD></TR></table></P><br></LI></ul>
<a name="regex3-CHP-9-SECT-1.1"></a>
<h4 id="title-IDAV3OLF" class="docSection2Title">9.1.1. Additional Comments on the Flavor</H4>
<a name="IDX-CHP-9-3118"></a> 
<a name="IDX-CHP-9-3119"></a> 

<p class="docText">A few issues merit longer discussion than a bullet point allows.</P>
<a name="regex3-CHP-9-SECT-1.1.1"></a>
<h5 id="title-IDAI4OLF" class="docSection3Title">9.1.1.1. Named capture</H5>
<p class="docText">.NET<a name="IDX-CHP-9-3120"></a> 
<a name="IDX-CHP-9-3121"></a> 
<a name="IDX-CHP-9-3122"></a> 
 supports named capture (&#9758;138), through the <img src=images/U2308.jpg border=0><tt>(?&lt;<span class="docEmphasis">name</span>&gt;&#8943;)</tt><img src=images/U230B.jpg border=0> or <img src=images/U2308.jpg border=0><tt>(?'<span class="docEmphasis">name</span>'&#8943;)</tt><img src=images/U230B.jpg border=0> syntax. Both syntaxes mean the same thing and you can use either freely, but I prefer the syntax with <tt>&lt;&#8943;&gt;</tt>, as I believe it will be more widely used.</P>
<p class="docText">You can backreference the text matched by a named capture within the regex with <img src=images/U2308.jpg border=0><tt>\k&lt;<span class="docEmphasis">name</span>&gt;</tt><img src=images/U230B.jpg border=0> or <img src=images/U2308.jpg border=0><tt>\k<span class="docEmphasis">'name'</span></tt><img src=images/U230B.jpg border=0>.</p>
<p class="docText">After the match (once a <tt>Match</tt> object has been generated; an overview of .NET's object model follows, starting on page 416), the text matched within the named capture is available via the <tt>Match</tt> object's <tt>Groups</tt>(<span class="docEmphasis">name</span>) property. (C<span class="docEmphasis">#</span> requires <tt>Groups</tt>[<span class="docEmphasis">name</span>] instead.)</p>
<p class="docText">Within a replacement string (&#9758;424), the results of named capture are available via a <tt>$</tt>{<span class="docEmphasis">name</span>} sequence.</p>
<p class="docText">In order to allow all groups to be accessed numerically, which may be useful at times, named-capture groups are also given numbers. They receive their numbers <span class="docEmphasis">after</span> all the non-named ones receive theirs:</P><img border="0" alt="" width="217" height="28" SRC="images/regex3_u0901.jpg">
<p class="docText">The text matched by the <img src=images/U2308.jpg border=0><tt>\d+</tt><img src=images/U230B.jpg border=0> part of this example is available via both <tt>Groups("Num")</tt> and <tt>Groups(3)</tt>. It's still just one group, but with two names.</P>
<a name="regex3-CHP-9-SECT-1.1.1.1"></a>
<h5 id="title-IDAHBPLF" class="docSection4Title">9.1.1.1.1. An unfortunate consequence</h5>
<p class="docText">It's not recommended to mix normal capturing parentheses and named captures, but if you do, the way the capturing groups are assigned numbers has important consequences that you should be aware of. The ordering becomes important when capturing parentheses are used with <tt>Split</tt> (&#9758;425), and for the meaning of <tt>'$+'</tt> in a replacement string (&#9758;424).</p>


<a name="regex3-CHP-9-SECT-1.1.2"></a>
<h5 id="title-IDAWBPLF" class="docSection3Title">9.1.1.2. Conditional tests</H5>
<p class="docText">The <span class="docEmphasis">if</span> part of an <img src=images/U2308.jpg border=0><tt>(?<span class="docEmphasis">if then</span>|<span class="docEmphasis">else</span>)</tt><img src=images/U230B.jpg border=0> conditional (&#9758;140) can be any type of lookaround, or a captured group number or captured group name in parentheses. Plain text (or a plain regex) in this location is automatically treated as positive lookahead (that it, it has an implicit <img src=images/U2308.jpg border=0><tt>(?=&#8943;)</tt><img src=images/U230B.jpg border=0> wrapped around it). This can lead to an ambiguity: for instance, the <img src=images/U2308.jpg border=0><tt>(Num)</tt><img src=images/U230B.jpg border=0> of <img src=images/U2308.jpg border=0><tt>&#8943;(?(Num) <span class="docEmphasis">then</span>|<span class="docEmphasis">else</span>)&#8943;</tt><img src=images/U230B.jpg border=0> is turned into <img src=images/U2308.jpg border=0><tt>(?=Num)</tt><img src=images/U230B.jpg border=0> (lookahead for <tt>'Num'</tt>) if there is no <img src=images/U2308.jpg border=0><tt>(?&lt;Num&gt;&#8943;)</tt><img src=images/U230B.jpg border=0> named capture elsewhere in the regex. If there is such a named capture, whether it was successful is the result of the <span class="docEmphasis">if</span>.</p>
<p class="docText">I recommend not relying on "auto-lookaheadication."<a name="IDX-CHP-9-3123"></a> 
 Use the explicit <img src=images/U2308.jpg border=0><tt>(?=&#8943;)</tt><img src=images/U230B.jpg border=0> to make your intentions clearer to the human reader, and also to avert a surprise if some future version of the regex<a name="IDX-CHP-9-3124"></a> 
 engine adds additional <span class="docEmphasis">if</span> syntax.</p>

<a name="regex3-CHP-9-SECT-1.1.3"></a>
<H5 id="title-IDANDPLF" class="docSection3Title">9.1.1.3. "Compiled" expressions</h5>
<a name="IDX-CHP-9-3125"></a> 

<a name="IDX-CHP-9-3126"></a> 
<a name="IDX-CHP-9-3127"></a> 
<a name="IDX-CHP-9-3128"></a> 
<a name="IDX-CHP-9-3129"></a> 
<a name="IDX-CHP-9-3130"></a> 
<a name="IDX-CHP-9-3131"></a> 
<a name="IDX-CHP-9-3132"></a> 

<p class="docText">In earlier chapters, I use the word "compile" to describe the pre-application work any regex system must do to check that a regular expression is valid, and to convert it to an internal form suitable for its actual application to text. For this, .NET<a name="IDX-CHP-9-3133"></a> 
<a name="IDX-CHP-9-3134"></a> 
 regex terminology uses the word "parsing." It uses two versions of "compile" to refer to optimizations of that parsing phase.</p>
<p class="docText">Here are the details, in order of increasing optimization:</P>
<ul><LI><p class="docList"><span class="docEmphStrong">Parsing</span> The first time a regex is seen during the run of a program, it must be checked and converted into an internal form suitable for actual application by the regex engine. This process is referred to as "compile" elsewhere in this book (&#9758;241).</p></li><li><p class="docList"><span class="docEmphStrong">On-the-Fly Compilation</span> <tt>RegexOptions.Compiled</tt> is one of the options available when building a regex. Using it tells the regex engine to go further than simply converting to the default internal form, but to <span class="docEmphasis">compile</span> it to low-level MSIL (Microsoft Intermediate Language) code, which itself is then amenable to being optimized even further into even faster native machine code by the JIT<a name="IDX-CHP-9-3135"></a> 
<a name="IDX-CHP-9-3136"></a> 
<a name="IDX-CHP-9-3137"></a> 
<a name="IDX-CHP-9-3138"></a> 
 ("Just-In-Time" compiler) when the regex is actually applied.</p><p class="docList">It takes more time and memory to do this, but it allows the resulting regular expression to work faster. These tradeoffs are discussed later in this section.</p></li><li><p class="docList"><span class="docEmphStrong">Pre-Compiled Regexes</span> A <tt>Regex</tt> object (or objects) can be encapsulated into an assembly written to disk in a DLL (a Dynamically Loaded Library, i.e., a shared library). This makes it available for general use in other programs. This is called "compiling the assembly." For more, see "<a class="docLink" href="regex3-CHP-9-SECT-6.html#regex3-CHP-9-SECT-6.1">Regex Assemblies</a>" (&#9758;434).</p></li></ul>
<p class="docText">When considering on-the-fly compilation with <tt>RegexOptions.Compiled</tt>, there are important tradeoffs among initial startup time, ongoing memory usage, and regex match speed:</p>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="3"><col><col><col></colgroup><thead><TR><th class="thead" scope="col" align="left"><p class="docText">Metric</p></th><th class="thead" scope="col" align="left"><p class="docText">Without <tt>RegexOptions.Compiled</tt></P></th><th class="thead" scope="col" align="left"><p class="docText">With <tt>RegexOptions.Compiled</tt></p></th></tr></thead><TR><TD class="docTableCell" align="left"><p class="docText">Startup time</P></TD><td class="docTableCell" align="left"><p class="docText">Faster</P></td><td class="docTableCell" align="left"><p class="docText">Slower (by 60x)</P></TD></tr><TR><TD class="docTableCell" align="left"><p class="docText">Memory usage</p></td><td class="docTableCell" align="left"><p class="docText">Low</P></TD><td class="docTableCell" align="left"><p class="docText">High (about 515k each)</p></td></tr><TR><td class="docTableCell" align="left"><p class="docText">Match speed</p></TD><td class="docTableCell" align="left"><p class="docText">Not as fast</p></TD><td class="docTableCell" align="left"><p class="docText">Up to 10x faster</P></td></tr></table></p><br>
<p class="docText">The initial regex parsing (the default kind, without <tt>RegexOptions.Compiled</tt>) that must be done the first time each regex is seen in the program is relatively fast. Even on my clunky old 550MHz NT box, I benchmark about 1,500 complex compilations/ second. When <tt>RegexOptions.Compiled</tt> is used, that goes down to about 25/second, and increases memory usage by about 10k bytes per regex.</p>
<p class="docText">More importantly, that memory remains used for the life of the programthere's no way to unload it.</p>
<p class="docText">It definitely makes sense to use <tt>RegexOptions.Compiled</tt> in time-sensitive areas where processing speed is important, particularly for expressions that work with a lot of text. On the other hand, it makes little sense to use it on simple regexes that aren't applied to a lot of text. It's less clear which is best for the multitude of situations in betweenyou'll just have to weight the benefits and decide on a case-by-case basis.</p>
<p class="docText">In some cases, it may make sense to encapsulate an application's compiled expressions into its own DLL, as pre-compiled <tt>Regex</tt> objects. This uses less memory in the final program (the loading of the whole regex compilation package is bypassed), and allows faster loading (since they're compiled when the DLL is built, you don't have to wait for them to be compiled when you use them). A nice byproduct of this is that the expressions are made available to other programs that might wish to use them, so it's a great way to make a personal regex library. See "<a class="docLink" href="regex3-CHP-9-SECT-6.html#regex3-CHP-9-SIDEBAR-3">Creating Your Own Regex Library With an Assembly</a>" on page 435.</p>

<a name="regex3-CHP-9-SECT-1.1.4"></a>
<h5 id="title-IDA2KPLF" class="docSection3Title">9.1.1.4. Right-to-left matching</h5>
<a name="IDX-CHP-9-3139"></a> 

<p class="docText">The concept of "backwards" matching (matching from right to left in a string, rather than from left to right) has long intrigued regex developers. Perhaps the biggest issue facing the developer is to define exactly what "<a class="docLink" href="#regex3-CHP-9-SECT-1.1.4">right-to-left matching</a>" really means. Is the regex somehow reversed? Is the target text flipped? Or is it just that the regex is applied normally from each position within the target string, with the difference being that the transmission starts at the end of the string instead of at the beginning, and moves backwards with each bump-along rather than forward?</p>
<p class="docText">Just to think about it in concrete terms for a moment, consider applying <img src=images/U2308.jpg border=0><tt>\d+</tt><img src=images/U230B.jpg border=0> to the string <tt>'123&#8226;and&#8226;456'</tt>. We know a normal application matches <tt>'123'</tt>, and instinct somehow tells us that a right-to-left application should match <tt>'456'</tt>. However, if the regex engine uses the semantics described at the end of the previous paragraph, where the only difference is the starting point of the transmission and the direction of the bump-along, the results may be surprising. In these semantics, the regex engine works normally ("looking" to the right from where it's started), so the first attempt of <img src=images/U2308.jpg border=0><tt>\d+</tt><img src=images/U230B.jpg border=0>, at '&#8943;45<img src=images/U22CF.jpg border=0>6', doesn't match. The second attempt, at <tt>'&#8943;45</tt><img src=images/U22CF.jpg border=0>6' <span class="docEmphasis">does</span> match, as the bump-along has placed it "looking at" the <tt>'6'</tt>, which certainly matches <img src=images/U2308.jpg border=0><tt>\d+</tt><img src=images/U230B.jpg border=0>. So, we have a final match of only the final <tt>'6'</tt>.</p>
<p class="docText">One of .NET's regex options is <tt>RegexOptions.RightToLeft</tt>.<a name="IDX-CHP-9-3140"></a> 
 What are its semantics? The answer is: "that's a good question." The semantics are not documented, and my own tests indicate only that I can't pin them down. In many cases, such as the <tt>'123&#8226;and&#8226;456'</tt> example, it acts surprisingly intuitively (it matches <tt>'456'</tt>).</P>
<p class="docText">However, it sometimes fails to find <span class="docEmphasis">any</span> match, and at other times finds a match that seems to make no sense when compared with other results.</p>
<p class="docText">If you have a need for it, you may find that <tt>RegexOptions.RightToLeft</tt> seems to work exactly as you wish, but in the end, you use it at your own risk.</P>

<a name="regex3-CHP-9-SECT-1.1.5"></a>
<h5 id="title-IDA4MPLF" class="docSection3Title">9.1.1.5. Backslash-digit ambiguities</h5>
<a name="IDX-CHP-9-3141"></a> 
<a name="IDX-CHP-9-3142"></a> 
<a name="IDX-CHP-9-3143"></a> 

<p class="docText">When a backslash is followed by a number, it's either an octal escape or a backreference. Which of the two it's interpreted as, and how, depends on whether the <tt>RegexOptions.ECMAScript</tt><a name="IDX-CHP-9-3144"></a> 
 option has been specified. If you don't want to have to understand the subtle differences, you can always use <img src=images/U2308.jpg border=0><tt>\k&lt;num&gt;</tt><img src=images/U230B.jpg border=0> for a backreference, or start the octal escape with a zero (e.g., <img src=images/U2308.jpg border=0><tt>\08</tt><img src=images/U230B.jpg border=0>) to ensure it's taken as one. These work consistently, regardless of <tt>RegexOptions.ECMAScript</tt> being used or not.</P>
<p class="docText">If <tt>RegexOptions.ECMAScript</tt> is <span class="docEmphasis">not</span> used, single-digit escapes from <img src=images/U2308.jpg border=0><tt>\1</tt><img src=images/U230B.jpg border=0> through <img src=images/U2308.jpg border=0><tt>\9</tt><img src=images/U230B.jpg border=0> are always backreferences, and an escaped number beginning with zero is always an octal escape (e.g., <img src=images/U2308.jpg border=0><tt>\012</tt><img src=images/U230B.jpg border=0> matches an ASCII linefeed character). If it's not either of these cases, the number is taken as a backreference if it would "make sense" to do so (i.e., if there are at least that many capturing parentheses in the regex). Otherwise, so long as it has a value between <tt>\000</tt> and <tt>\377</tt>, it's taken as an octal escape. For example, <img src=images/U2308.jpg border=0><tt>\12</tt><img src=images/U230B.jpg border=0> is taken as a backreference if there are at least 12 sets of capturing parentheses, or an octal escape otherwise.</P>
<p class="docText">The semantics for when <tt>RegexOptions.ECMAScript</tt> is specified is described in the next section.</P>

<a name="regex3-CHP-9-SECT-1.1.6"></a>
<H5 id="title-IDA0OPLF" class="docSection3Title">9.1.1.6. ECMAScript mode</h5>
<p class="docText">ECMAScript is a standardized version of JavaScript<sup class="docFootnote"><a class="docLink" href="#regex3-CHP-9-FN-2">[<img src=images/U2020.jpg border=0>]</a></sup> with its own semantics of how regular expressions should be parsed and applied. A .NET regex attempts to mimic those semantics if created with the <tt>RegexOptions.ECMAScript</tt> option. If you don't know what ECMAScript is, or don't need compatibility with it, you can safely ignore this section.</P><blockquote><p class="docFootnote"><sup><a name="regex3-CHP-9-FN-2">[<img src=images/U2020.jpg border=0>]</a></sup> ECMA stands for "European Computer Manufacturers Association," a group formed in 1960 to standardize aspects of the growing field of computers.</p></blockquote>
<p class="docText">When <tt>RegexOptions.ECMAScript</tt> is in effect, the following apply:</p>
<UL><LI><p class="docList">Only the following may be combined with <tt>RegexOptions.ECMAScript</tt>:</p><pre>
    RegexOptions.IgnoreCase
    RegexOptions.Multiline
    RegexOptions.Compiled
</pre><BR>
</LI><li><p class="docList"><tt>\w</tt>, <tt>\d</tt>, and <tt>\s</tt> (and <tt>\W</tt>, <tt>\D</tt>, and <tt>\S</tt>) change to ASCII-only matching.</p></li><LI><p class="docList">When a backslash-digit sequence is found in a regex, the ambiguity between backreference and octal escape changes to favor a backreference, even if that means having to ignore some of the trailing digits. For example, with <img src=images/U2308.jpg border=0><tt>(&#8943;)\10</tt><img src=images/U230B.jpg border=0>, the <img src=images/U2308.jpg border=0><tt>\10</tt><img src=images/U230B.jpg border=0> is taken as a backreference to the first group, followed by a literal <tt>'0'</tt>.</P></li></ul>



<a href="7041536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-9.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-9-SECT-2.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>