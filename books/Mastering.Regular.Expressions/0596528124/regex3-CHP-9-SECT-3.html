<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 9.3.&nbsp; Core Object Details</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-9-SECT-2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-9-SECT-4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="regex3-CHP-9-SECT-3"></a>
<H3 id="title-IDAHVNNF" class="docSection1Title">9.3. Core Object Details</H3>
<p class="docText">Now that we've seen an overview, let's look at the details. First, we'll look at how to create a <tt>Regex</tt> object, followed by how to apply it to a string to yield a <tt>Match</tt> object, and how to work with that object and its <tt>Group</tt> objects.</P>
<p class="docText">In practice, you can often avoid having to explicitly create a <tt>Regex</tt> object, but it's good to be comfortable with them, so during this look at the core objects, I'll always explicitly create them. We'll see later what shortcuts .NET provides to make things more convenient.</P>
<p class="docText">In the lists that follow, I don't mention little-used methods that are merely inherited from the <tt>Object</tt> class.</p>
<a name="regex3-CHP-9-SECT-3.1"></a>
<H4 id="title-IDAAWNNF" class="docSection2Title">9.3.1. Creating <tt>Regex</tt> Objects</h4>
<a name="IDX-CHP-9-3175"></a> 
<a name="IDX-CHP-9-3176"></a> 
<a name="IDX-CHP-9-3177"></a> 

<p class="docText">The constructor for creating<a name="IDX-CHP-9-3178"></a> 
 a <tt>Regex</tt> object is uncomplicated. It accepts either one argument (the regex, as a string), or two arguments (the regex and a set of options).<a name="IDX-CHP-9-3179"></a> 
 Here's a one-argument example:</p>
<pre>
    Dim StripTrailWS = new Regex("\s+$") ' <span class="docEmphasis">for removing trailing whitespace</span>
</pre><BR>

<p class="docText">This just creates the <tt>Regex</tt> object, preparing it for use; no matching has been done to this point.</P>
<p class="docText">Here's a two-argument example:</p>
<pre>
    Dim GetSubject = new Regex("^subject: (.*)", RegexOptions.IgnoreCase)<a name="IDX-CHP-9-3180"></a> 

</pre><BR>

<p class="docText">That passes one of the <tt>RegexOptions</tt> flags, but you can pass multiple flags if they're <tt>OR</tt>'d together, as with:</P>
<pre>
    Dim GetSubject = new Regex("^subject: (.*)", _
                       RegexOptions.IgnoreCase OR RegexOptions.Multiline)<a name="IDX-CHP-9-3181"></a> 

</pre><br>

<a name="regex3-CHP-9-SECT-3.1.1"></a>
<h5 id="title-IDANYNNF" class="docSection3Title">9.3.1.1. Catching exceptions</h5>
<a name="IDX-CHP-9-3182"></a> 

<p class="docText">An <tt>ArgumentException</tt> error is thrown if a regex with an invalid combination of metacharacters is given. You don't normally need to catch this exception when using regular expressions you know to work, but it's important to catch it if using regular expressions from "outside" the program (e.g., entered by the user, or read from a configuration file). Here's an example:</P>
<pre>
    Dim <span class="docEmphasis">R</span> As Regex
    Try
        <span class="docEmphasis">R</span> = New Regex(SearchRegex)
    Catch <span class="docEmphasis">e</span> As ArgumentException
        Console.WriteLine("*ERROR* bad regex: " &amp; <span class="docEmphasis">e</span>.ToString)
        Exit Sub
    End Try
</pre><BR>

<p class="docText">Of course, depending on the application, you may want to do something other than writing to the console upon detection of the exception.</p>

<a name="regex3-CHP-9-SECT-3.1.2"></a>
<h5 id="title-IDAMZNNF" class="docSection3Title">9.3.1.2. Regex options</h5>
<a name="IDX-CHP-9-3183"></a> 
<a name="IDX-CHP-9-3184"></a> 
<a name="IDX-CHP-9-3185"></a> 
<a name="IDX-CHP-9-3186"></a> 
<a name="IDX-CHP-9-3187"></a> 

<p class="docText">The following option flags are allowed when creating a <tt>Regex</tt> object:</p>
<a name="IDX-CHP-9-3188"></a><a name="IDX-CHP-9-3189"></a><a name="IDX-CHP-9-3190"></a><a name="IDX-CHP-9-3191"></a><a name="IDX-CHP-9-3192"></a><a name="IDX-CHP-9-3193"></a><a name="IDX-CHP-9-3194"></a><a name="IDX-CHP-9-3195"></a><a name="IDX-CHP-9-3196"></a><dl class="docList">
<dt><BR><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">RegexOptions.<span class="docEmphStrong">IgnoreCase</span></span></span></span></p></dt>
<dd><p class="docList">This option indicates that when the regex is applied, it should be done in a case-insensitive manner (&#9758;110).</P>
</dd>

<dt><br><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">RegexOptions.<span class="docEmphStrong">IgnorePatternWhitespace</span></span></span></span></P></dt>
<a name="IDX-CHP-9-3188"></a> 

<dd>
<p class="docList">This option indicates that the regex should be parsed in a free-spacing and comments mode (&#9758;111). If you use raw <img src=images/U2308.jpg border=0><tt>#&#8943;</tt><img src=images/U230B.jpg border=0> comments, be sure to include a newline at the end of each logical line, or the first raw comment "comments out" the entire rest of the regex.</p>
<p class="docList">In VB.NET, this can be achieved with <tt>chr(10)</tt>,<a name="IDX-CHP-9-3189"></a> 
 as in this example:</P>
<pre>
    Dim <span class="docEmphasis">R</span> as Regex = New Regex( _
       "# Match a floating-point number ...        " &amp; chr(10) &amp; _
       " \d+(?:\.\d*)? # with a leading digit ...  " &amp; chr(10) &amp; _
       " |             # or ...                    " &amp; chr(10) &amp; _
       " \.\d+         # with a leading decimal point", _
       RegexOptions.IgnorePatternWhitespace)
</pre><br>

<p class="docList">That's cumbersome; in VB.NET, <img src=images/U2308.jpg border=0><tt>(?#&#8943;)</tt><img src=images/U230B.jpg border=0><a name="IDX-CHP-9-3190"></a> 
 comments can be more convenient:</p>
<pre>
    Dim <span class="docEmphasis">R</span> as Regex = New Regex( _
       "(?# Match a floating-point number ...           )" &amp; _
       " \d+(?:\.\d*)? (?# with a leading digit ...     )" &amp; _
       " |             (?# or ...                       )" &amp; _
       " \.\d+         (?# with a leading decimal point )", _
       RegexOptions.IgnorePatternWhitespace)
</pre><br>

</dd>

<dt><br><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">RegexOptions.<span class="docEmphStrong">Multiline</span></span></span></span></p></dt>
<dd><p class="docList">This option indicates that the regex should be applied in an enhanced line-anchor mode (&#9758;112). This allows <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0> and <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0> to match at embedded newlines in addition to the normal beginning and end of string, respectively.</p></dd>

<dt><br><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">RegexOptions.<span class="docEmphStrong">Singleline</span></span></span></span></p></dt>
<a name="IDX-CHP-9-3191"></a> 

<dd>
<p class="docList">This option indicates that the regex should be applied in a dot-matches-all mode (&#9758;111). This allows <span class="docEmphasis">dot</span> to match any character, rather than any character except a newline.</p>
</dd>

<dt><br><P><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">RegexOptions.<span class="docEmphStrong">ExplicitCapture</span></span></span></span></p></dt>
<a name="IDX-CHP-9-3192"></a> 

<dd>
<p class="docList">This option indicates that even raw <img src=images/U2308.jpg border=0><tt>(&#8943;)</tt><img src=images/U230B.jpg border=0> parentheses, which are normally capturing parentheses, should not capture, but rather behave like <img src=images/U2308.jpg border=0><tt>(?:&#8943;)</tt><img src=images/U230B.jpg border=0> grouping-only non-capturing parentheses. This leaves named-capture <img src=images/U2308.jpg border=0><tt>(?&lt;<span class="docEmphasis">name</span>&gt;&#8943;)</tt><img src=images/U230B.jpg border=0> parentheses as the only type of capturing parentheses.</P>
<p class="docList">If you're using named capture and also want non-capturing parentheses for grouping, it makes sense to use normal <img src=images/U2308.jpg border=0><tt>(&#8943;)</tt><img src=images/U230B.jpg border=0> parentheses and this option, as it keeps the regex more visually clear.</p>
</dd>

<dt><br><P><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">RegexOptions.<span class="docEmphStrong">RightToLeft</span></span></span></span></P></dt>
<a name="IDX-CHP-9-3193"></a> 

<dd><p class="docList">This option sets the regex to a right-to-left match mode (&#9758;411).</P>
</dd>

<dt><BR><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">RegexOptions.<span class="docEmphStrong">Compiled</span></span></span></span></P></dt>
<a name="IDX-CHP-9-3194"></a> 

<dd><p class="docList">This option indicates that the regex should be compiled, on the fly, to a highly-optimized format, which generally leads to much faster matching. This comes at the expense of increased compile time the first time it's used, and increased memory use for the duration of the program's execution.</p>
<p class="docList">If a regex is going to be used just once, or sparingly, it makes little sense to use <tt>RegexOptions.Compiled</tt>, since its extra memory remains used even when a <tt>Regex</tt> object created with it has been disposed of. But if a regex is used in a time-critical area, it's probably advantageous to use this flag.</p>
<p class="docList">You can see an example on page 237, where this option cuts the time for one benchmark about in half. Also, see the discussion about compiling to an assembly (&#9758;434).</P>
</dd>

<dt><BR><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">RegexOptions.<span class="docEmphStrong">ECMAScript</span></span></span></span></P></dt>
<a name="IDX-CHP-9-3195"></a> 

<dd><p class="docList">This option indicates that the regex should be parsed in a way that's compatible with <tt>ECMAScript</tt> (&#9758;412). If you don't know what <tt>ECMAScript</tt> is, or don't need compatibility with it, you can safely ignore this option.</P>
</dd>

<dt><br><p><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">RegexOptions.<span class="docEmphStrong">None</span></span></span></span></p></dt>
<a name="IDX-CHP-9-3196"></a> 

<dd><p class="docList">This is a "no extra options" value that's useful for initializing a <tt>RegexOptions</tt> variable, should you need to. As you decide options are required, they can be <tt>OR</tt>'d in to it.</P>
</dd>
</dl>


<a name="regex3-CHP-9-SECT-3.2"></a>
<H4 id="title-IDAACONF" class="docSection2Title">9.3.2. Using <tt>Regex</tt> Objects</h4>
<a name="IDX-CHP-9-3197"></a> 
<a name="IDX-CHP-9-3198"></a> 
<a name="IDX-CHP-9-3199"></a> 
<a name="IDX-CHP-9-3200"></a> 
<a name="IDX-CHP-9-3201"></a> 
<a name="IDX-CHP-9-3202"></a> 
<a name="IDX-CHP-9-3203"></a> 
<a name="IDX-CHP-9-3204"></a> 
<a name="IDX-CHP-9-3205"></a> 
<a name="IDX-CHP-9-3206"></a> 

<p class="docText">Just having a regex object is not useful unless you apply it, so the following methods swing it into action.</p>
<pre>
    <span class="docEmphasis">RegexObj</span>.<span class="docEmphStrong">IsMatch</span><a name="IDX-CHP-9-3207"></a> 
 (<span class="docEmphasis">target</span><span class="docEmphStrong">)</span>
                                  Return type: <span class="docEmphStrong">Boolean</span>
    <span class="docEmphasis">RegexObj</span>.<span class="docEmphStrong">IsMatch(</span><span class="docEmphasis">target, offset</span><span class="docEmphStrong">)</span>
</pre><br>

<p class="docText">The <tt>IsMatch</tt> method applies the object's regex to the <span class="docEmphasis">target</span> string, returning a simple <tt>Boolean</tt> indicating whether the attempt is successful. Here's an example:</p>
<pre>
    Dim R as RegexObj = New Regex("^\s*$")<a name="IDX-CHP-9-3208"></a> 

       <img src=images/U22EE.jpg border=0>
    If R.IsMatch(Line) Then
       ' Line is blank ...
            <img src=images/U22EE.jpg border=0>
    Endif
</pre><BR>

<p class="docText">If an <span class="docEmphasis">offset</span> (an integer) is provided, that many characters in the target string are bypassed before the regex is first attempted.</p>
<pre>
    <span class="docEmphasis">RegexObj</span>.<span class="docEmphStrong">Match</span><a name="IDX-CHP-9-3209"></a> 
 (<span class="docEmphasis">target</span><span class="docEmphStrong">)</span> Return type: <span class="docEmphStrong">Match</span> object
    <span class="docEmphasis">RegexObj</span>.<span class="docEmphStrong">Match</span> (<span class="docEmphasis">target<span class="docEmphStrong">,</span> offset</span><span class="docEmphStrong">)</span>
    <span class="docEmphasis">RegexObj</span>.<span class="docEmphStrong">Match</span> (<span class="docEmphasis">target<span class="docEmphStrong">,</span> offset<span class="docEmphStrong">,</span> maxlength</span><span class="docEmphStrong">)</span>
</pre><br>

<p class="docText">The <tt>Match</tt> method applies the object's regex to the <span class="docEmphasis">target</span> string, returning a <tt>Match</tt> object. With this <tt>Match</tt> object, you can query information about the results of the match (whether it was successful, the text matched, etc.), and initiate the "next" match of the same regex in the string. Details of the <tt>Match</tt> object follow, starting on page 427.</P>
<p class="docText">If an <span class="docEmphasis">offset</span> (an integer) is provided, that many characters in the target string are bypassed before the regex is first attempted.</p>
<p class="docText">If you provide a <span class="docEmphasis">maxlength</span> argument, it puts matching into a special mode where the <span class="docEmphasis">maxlength</span> characters starting <span class="docEmphasis">offset</span> characters into the <span class="docEmphasis">target</span> string are taken as the <span class="docEmphasis">entire</span> target string, as far as the regex engine is concerned. It pretends that characters outside the range don't even exist, so, for example, <img src=images/U2308.jpg border=0><tt>^</tt><img src=images/U230B.jpg border=0> can match at <span class="docEmphasis">offset</span> characters into the original <span class="docEmphasis">target</span> string, and <img src=images/U2308.jpg border=0><tt>$</tt><img src=images/U230B.jpg border=0> can match at <span class="docEmphasis">maxlength</span> characters after that. It also means that lookaround can't "see" the characters outside of that range. This is all very different from when only <span class="docEmphasis">offset</span> is provided, as that merely influences where the transmission begins applying the regexthe engine still "sees" the entire target string.</p>
<p class="docText">This table shows examples that illustrate the meaning of <span class="docEmphasis">offset</span> and <span class="docEmphasis">maxlength</span>:</P>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="100%"><colgroup span="4"><col><col><col><col></colgroup><thead><TR><th class="thead" scope="col" align="center"><p class="docText">&nbsp;</p></th><th class="thead" scope="col" align="center" colspan="3"><p class="docText">Results when <span class="docEmphasis">RegexObj</span> is built with ...</p></th></tr><tr><th class="thead" scope="col" align="left"><p class="docText">Method call</p></th><th class="thead" scope="col" align="left"><p class="docText"><img src=images/U2308.jpg border=0><tt>\d\d</tt><img src=images/U230B.jpg border=0></p></th><th class="thead" scope="col" align="left"><p class="docText"><img src=images/U2308.jpg border=0><tt>^\d\d</tt><img src=images/U230B.jpg border=0></p></th><th class="thead" scope="col" align="left"><p class="docText"><img src=images/U2308.jpg border=0><tt>^\d\d<span class="docEmphStrong">$</span></tt><img src=images/U230B.jpg border=0></p></th></tr></thead><tr><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis">RegexObj</span>.<tt>Match("May 16, 1998")</tt></p></TD><td class="docTableCell" align="left"><p class="docText">match <tt>'16'</tt></P></td><td class="docTableCell" align="left"><p class="docText">fail</P></TD><TD class="docTableCell" align="left"><p class="docText">fail</P></td></TR><tr><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis">RegexObj</span>.<tt>Match("May 16, 1998", 9)</tt></P></TD><td class="docTableCell" align="left"><p class="docText">match <tt>'99'</tt></P></TD><td class="docTableCell" align="left"><p class="docText">fail</p></td><TD class="docTableCell" align="left"><p class="docText">fail</P></td></tr><tr><td class="docTableCell" align="left"><p class="docText"><span class="docEmphasis">RegexObj</span>.<tt>Match("May 16, 1998", 9, 2)</tt></P></td><td class="docTableCell" align="left"><p class="docText">match <tt>'99'</tt></P></td><td class="docTableCell" align="left"><p class="docText">match <tt>'99'</tt></P></td><TD class="docTableCell" align="left"><p class="docText">match <tt>'99'</tt></p></td></tr></table></p><br>
<pre>
    <span class="docEmphasis">RegexObj</span>.<span class="docEmphStrong">Matches</span><a name="IDX-CHP-9-3210"></a> 
 (<span class="docEmphasis">target</span><span class="docEmphStrong">)</span> Return type:
 <span class="docEmphStrong">MatchCollection</span><a name="IDX-CHP-9-3211"></a> 

    <span class="docEmphasis">RegexObj</span>.<span class="docEmphStrong">Matches</span> (<span class="docEmphasis">target<span class="docEmphStrong">,</span> offset</span> <span class="docEmphStrong">)</span>
</pre><br>

<p class="docText">The <tt>Matches</tt> method is similar to the <tt>Match</tt> method, except <tt>Matches</tt> returns a collection of <tt>Match</tt> objects representing <span class="docEmphasis">all</span> the matches in the <span class="docEmphasis">target</span>, rather than just one <tt>Match</tt> object representing the <span class="docEmphasis">first</span> match. The returned object is a <tt>MatchCollection</tt>.</p>
<p class="docText">For example, after this initialization:</p>
<pre>
    Dim <span class="docEmphasis">R</span> as New Regex("\w+")
    Dim <span class="docEmphasis">Target</span> as String = "a few words"
</pre><br>

<p class="docText">this code snippet</p>
<pre>
    Dim <span class="docEmphasis">BunchOfMatches</span> as MatchCollection = <span class="docEmphasis">R</span>.Matches(Target)
    Dim <span class="docEmphasis">I</span> as Integer
    For <span class="docEmphasis">I</span> = 0 to <span class="docEmphasis">BunchOfMatches</span>.Count - 1
        Dim <span class="docEmphasis">MatchObj</span> as Match = <span class="docEmphasis">BunchOfMatches</span>.Item( <span class="docEmphasis">I</span>)
        Console.WriteLine("Match: " &amp; <span class="docEmphasis">MatchObj</span>.Value)
    Next
</pre><br>

<p class="docText">produces this output:</p>
<pre>
    Match: a
    Match: few
    Match: words
</pre><BR>

<p class="docText">The following example, which produces the same output, shows that you can dispense with the <tt>MatchCollection</tt> object altogether:</p>
<pre>
    Dim <span class="docEmphasis">MatchObj</span>  as Match
    For Each <span class="docEmphasis">MatchObj</span> in <span class="docEmphasis">R</span>.Matches(Target)
        Console.WriteLine("Match: " &amp; <span class="docEmphasis">MatchObj</span>.Value)
    Next
</pre><BR>

<p class="docText">Finally, as a comparison, here's how you can accomplish the same thing another way, with the <tt>Match</tt> (rather than <tt>Matches</tt>) method:</p>
<pre>
    Dim <span class="docEmphasis">MatchObj</span> as Match = <span class="docEmphasis">R</span>.Match(Target)
    While <span class="docEmphasis">MatchObj</span>.Success
        Console.WriteLine("Match: " &amp; <span class="docEmphasis">MatchObj</span>.Value)
        <span class="docEmphasis">MatchObj</span> = <span class="docEmphasis">MatchObj</span>.NextMatch()
    End While


    <span class="docEmphasis">RegexObj</span>.<span class="docEmphStrong">RegexObj</span> (<span class="docEmphasis">target, replacement</span>)
       Return type: <span class="docEmphStrong">String</span>
    <span class="docEmphasis">RegexObj</span>.<span class="docEmphStrong">RegexObj</span> (<span class="docEmphasis">target<span class="docEmphStrong">,</span> replacement<span class="docEmphStrong">,</span> count</span><span class="docEmphStrong">)</span>
    <span class="docEmphasis">RegexObj</span>.<span class="docEmphStrong">RegexObj</span> (<span class="docEmphasis">target<span class="docEmphStrong">,</span> replacement<span class="docEmphStrong">,</span> count<span class="docEmphStrong">,</span> offset</span><span class="docEmphStrong">)</span>
</pre><br>

<p class="docText">The <tt>Replace</tt><a name="IDX-CHP-9-3212"></a> 
 method does a search and replace<a name="IDX-CHP-9-3213"></a> 
<a name="IDX-CHP-9-3214"></a> 
<a name="IDX-CHP-9-3215"></a> 
 on the <span class="docEmphasis">target</span> string, returning a (possibly changed) copy of it. It applies the <tt>Regex</tt> object's regular expression, but instead of returning a <tt>Match</tt> object, it replaces the matched text. What the matched text is replaced with depends on the <span class="docEmphasis">replacement</span> argument. The replacement argument is overloaded; it can be either a string or a <tt>MatchEvaluator</tt><a name="IDX-CHP-9-3216"></a> 
 delegate.<a name="IDX-CHP-9-3217"></a> 
 If <span class="docEmphasis">replacement</span> is a string, it is interpreted according to the sidebar on the next page. For example,</P>
<pre>
    Dim <span class="docEmphasis">R_CapWord</span> as New Regex("\b[A-Z]\w*")
      <img src=images/U22EE.jpg border=0>
    Text = <span class="docEmphasis">R_CapWord</span>.Replace( <span class="docEmphasis">Text</span>, "&lt;B&gt;$0&lt;/B&gt;")
</pre><BR>

<p class="docText">wraps each capitalized word with &lt;B&gt;&#8943;&lt;/B&gt;.</P>
<p class="docText">If <span class="docEmphasis">count</span> is given, only that number of replacements is done. (The default is to do all replacements). To replace just the first match found, for example, use a <span class="docEmphasis">count</span> of one. If you know that there will be only one match, using an explicit <span class="docEmphasis">count</span> of one is more efficient than letting the <tt>Replace</tt> mechanics go through the work of trying to find additional matches. A <span class="docEmphasis">count</span> of <tt>-1</tt> means "replace all" (which, again, is the default when no <span class="docEmphasis">count</span> is given).</P>
<p class="docText">If an <span class="docEmphasis">offset</span> (an integer) is provided, that many characters in the target string are bypassed before the regex is applied. Bypassed characters are copied through to the result unchanged.</p>
<p class="docText">For example, this canonicalizes all whitespace (that is, reduces sequences of whitespace down to a single space):</P>
<pre>
    Dim <span class="docEmphasis">AnyWS</span> as New Regex("\s+")
      <img src=images/U22EE.jpg border=0>
    Target = <span class="docEmphasis">AnyWS</span>.Replace( <span class="docEmphasis">Target</span>, " ")
</pre><br>

<p class="docText">This converts <tt>'some&#8226;&#8226;&#8226;&#8226;&#8226;random&#8226;&#8226;&#8226;&#8226;&#8226;spacing'</tt> to <tt>'some&#8226;random&#8226;spacing'</tt>. The following does the same, except it leaves any <span class="docEmphasis">leading</span> whitespace alone:</p>
<pre>
    Dim <span class="docEmphasis">AnyWS</span> as New Regex("\s+")
    Dim LeadingWS as New Regex("^\s+")
      <img src=images/U22EE.jpg border=0>
    <span class="docEmphasis">Target</span> = <span class="docEmphasis">AnyWS</span>.Replace(<span class="docEmphasis">Target</span>, " ", -1, <span class="docEmphasis">LeadingWS</span>.Match(<span class="docEmphasis">Target</span>).Length)
</pre><BR>

<p class="docText">This converts <tt>'&#8226;&#8226;&#8226;&#8226;some&#8226;&#8226;&#8226;random&#8226;&#8226;&#8226;&#8226;&#8226;spacing</tt>' to <tt>'&#8226;&#8226;&#8226;&#8226;some&#8226;random&#8226;spacing'</tt>. It uses the length of what's matched by <tt>LeadingWS</tt> as the offset (as the count of characters to skip) when doing the search and replace. It uses a convenient feature of the <tt>Match</tt> object, returned here by <tt>LeadingWS.Match(Target)</tt>, that its <tt>Length</tt> property may be used even if the match fails. (Upon failure, the <tt>Length</tt> property has a value of zero, which is exactly what we need to apply <tt>AnyWS</tt> to the entire target.)</P>
<a name="regex3-CHP-9-SIDEBAR-1"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<h2 class="docSidebarTitle">Special Per-Match Replacement Sequences</h2>
<p class="docText">Both the <tt>Regex.Replace</tt> method and the <tt>Match.Result</tt> method accept a "replacement" string that's interpreted specially. Within it, the following sequences are replaced by appropriate text from the match:</p>
<P><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="90%"><colgroup span="2"><col><col></colgroup><thead><TR><th class="thead" scope="col" align="left"><p class="docText">Sequence</p></th><th class="thead" scope="col" align="left"><p class="docText">Replaced by</p></th></tr></thead><tr><TD class="docTableCell" align="center"><p class="docText"><tt>$&amp;</tt></p></td><TD class="docTableCell" align="left"><p class="docText">text matched by the regex (also available as <tt>$0</tt>)</p></td></TR><tr><TD class="docTableCell" align="center"><p class="docText"><tt>$1, $2,</tt> ...</p></td><td class="docTableCell" align="left"><p class="docText">text matched by the corresponding set of capturing parentheses</p></td></tr><tr><td class="docTableCell" align="center"><p class="docText"><tt>${</tt> <span class="docEmphasis">name</span> <tt>}</tt></p></td><td class="docTableCell" align="left"><p class="docText">text matched by the corresponding named capture</p></TD></tr><TR><td class="docTableCell" align="center"><p class="docText"><tt>$'</tt></p></TD><TD class="docTableCell" align="left"><p class="docText">text of the target string <span class="docEmphasis">before</span> the match location</P></TD></tr><TR><td class="docTableCell" align="center"><p class="docText"><tt>$'</tt></p></TD><TD class="docTableCell" align="left"><p class="docText">text of the target string <span class="docEmphasis">after</span> the match location</p></TD></TR><tr><td class="docTableCell" align="center"><p class="docText"><tt>$$</tt></p></TD><TD class="docTableCell" align="left"><p class="docText">a single <tt>'$'</tt> character</p></td></tr><tr><TD class="docTableCell" align="center"><p class="docText"><tt>$_</tt></p></td><TD class="docTableCell" align="left"><p class="docText">a copy of the entire original target string</p></td></TR><tr><TD class="docTableCell" align="center"><p class="docText"><tt>$+</tt></p></td><td class="docTableCell" align="left"><p class="docText">(see text below)</p></td></tr></table></p><br>
<p class="docText">The <tt>$+</tt> sequence is fairly useless as currently implemented. Its origins lie with Perl's useful <tt>$+</tt> variable, which references the highest-numbered set of capturing parentheses that <span class="docEmphasis">actually participated</span> in the match. (There's an example of it in use on page 202.) This .NET<a name="IDX-CHP-9-3218"></a> 
<a name="IDX-CHP-9-3219"></a> 
<a name="IDX-CHP-9-3220"></a> 
<a name="IDX-CHP-9-3221"></a> 
<a name="IDX-CHP-9-3222"></a> 
<a name="IDX-CHP-9-3223"></a> 
<a name="IDX-CHP-9-3224"></a> 
 replacement-string <tt>$+</tt>, though, merely references the highest-numbered set of capturing parentheses in the regex. It's particularly useless in light of the capturing-parentheses renumbering that's automatically done when named captures are used (&#9758;409).</p>
<p class="docText">Any uses of <tt>'$'</tt> in the replacement string in situations other than those described in the table are left unmolested.</p>
</td></tr></table></P><br>
<a name="regex3-CHP-9-SECT-3.2.1"></a>
<H5 id="title-IDAO4ONF" class="docSection3Title">9.3.2.1. Using a replacement delegate</h5>
<a name="IDX-CHP-9-3225"></a> 
<a name="IDX-CHP-9-3226"></a> 
<a name="IDX-CHP-9-3227"></a> 
<a name="IDX-CHP-9-3228"></a> 
<a name="IDX-CHP-9-3229"></a> 

<p class="docText">The <span class="docEmphasis">replacement</span> argument isn't limited to a simple string. It can be a <span class="docEmphasis">delegate</span> (basically, a pointer to a function). The delegate function is called after each match to generate the text to use as the replacement. Since the function can do any processing you want, it's an extremely powerful replacement mechanism.</p>
<p class="docText">The delegate is of the type <tt>MatchEvaluator</tt>, and is called once per match. The function it refers to should accept the <tt>Match</tt> object for the match, do whatever processing you like, and return the text to be used as the replacement.</P>
<p class="docText">As examples for comparison, the following two code snippets produce identical results:</P>
<pre>
    <span class="docEmphasis">Target</span> = <span class="docEmphasis">R</span>.Replace(<span class="docEmphasis">Target</span>, <span class="docEmphStrong">"&lt;&lt;$&amp;&gt;&gt;"</span>))
    -----------------------------------
    Function <span class="docEmphasis">MatchFunc</span>(ByVal <span class="docEmphasis">M</span> as Match) as String
      return <span class="docEmphasis">M</span>.Result(<span class="docEmphStrong">"&lt;&lt;$&amp;&gt;&gt;"</span>)
    End Function
    Dim <span class="docEmphasis">Evaluator</span> as MatchEvaluator = New MatchEvaluator(AddressOf <span class="docEmphasis">MatchFunc</span>)
      <img src=images/U22EE.jpg border=0>
    <span class="docEmphasis">Target</span> = <span class="docEmphasis">R</span>.Replace(<span class="docEmphasis">Target, Evaluator</span>)
</pre><BR>

<p class="docText">Both snippets highlight each match by wrapping the matched text in &lt;&lt;&#8943;&gt;&gt;. The advantage of using a delegate is that you can include code as complex as you like in computing the replacement. Here's an example that converts Celsius temperatures to Fahrenheit:</P>
<pre>
    Function <span class="docEmphasis">MatchFunc</span>(ByVal <span class="docEmphasis">M</span> as Match) as String
       '<span class="docEmphasis">Get numeric temperature from $1, then convert to Fahrenheit</span>
       Dim <span class="docEmphasis">Celsius</span> as Double = Double.Parse(<span class="docEmphasis">M</span>.Groups(1).Value)
       Dim <span class="docEmphasis">Fahrenheit</span> as Double = <span class="docEmphasis">Celsius</span> * 9/5 + 32
       Return <span class="docEmphasis">Fahrenheit</span> &amp; "F" '<span class="docEmphasis">Append an "F", and return</span>
       End Function

       Dim <span class="docEmphasis">Evaluator</span> as MatchEvaluator = New MatchEvaluator(AddressOf <span class="docEmphasis">MatchFunc</span>)
       <img src=images/U22EE.jpg border=0>
       Dim <span class="docEmphasis">R_Temp</span> as Regex = New Regex("(\d+)C\b", RegexOptions.IgnoreCase)
       <span class="docEmphasis">Target</span> = <span class="docEmphasis">R_Temp</span>.Replace( <span class="docEmphasis">Target</span>, Evaluator)
</pre><br>

<p class="docText">Given <tt>'Temp is 37C.'</tt> in <tt>Target</tt>, it replaces it with <tt>'Temp is 98.6F.'</tt>.</P>
<pre>
    <span class="docEmphasis">RegexObj</span>.<span class="docEmphStrong">Split</span><a name="IDX-CHP-9-3230"></a> 
 (<span class="docEmphasis">target</span><span class="docEmphStrong">)</span>
                              Return
type: array of <span class="docEmphStrong">String</span>
    <span class="docEmphasis">RegexObj</span>.<span class="docEmphStrong">Split</span> (<span class="docEmphasis">target<span class="docEmphStrong">,</span> count</span><span class="docEmphStrong">)</span>
    <span class="docEmphasis">RegexObj</span>.<span class="docEmphStrong">Split</span> (<span class="docEmphasis">target<span class="docEmphStrong">,</span> count<span class="docEmphStrong">,</span> offset</span><span class="docEmphStrong">)</span>
</pre><br>

<p class="docText">The <tt>Split</tt> method applies the object's regex to the <span class="docEmphasis">target</span> string, returning an array of the strings <span class="docEmphasis">separated</span> by the matches. Here's a trivial example:</p>
<pre>
    Dim <span class="docEmphasis">R</span> as New Regex("\.")
    Dim <span class="docEmphasis">Parts</span> as String() = <span class="docEmphasis">R</span>.Split("209.204.146.22")
</pre><BR>

<p class="docText">The <tt>R.Split</tt> returns the array of four strings <tt>('209', '204', '146', and '22')</tt> that are separated by the three matches of <img src=images/U2308.jpg border=0><tt>\.</tt><img src=images/U230B.jpg border=0> in the text.</P>
<p class="docText">If a <span class="docEmphasis">count</span> is provided, no more than <span class="docEmphasis">count</span> strings will be returned (unless capturing parentheses are usedmore on that in a bit). If <span class="docEmphasis">count</span> is not provided, <tt>Split</tt> returns as many strings as are separated by matches. Providing a <span class="docEmphasis">count</span> may mean that the regex stops being applied before the final match, and if so, the last string has the unsplit remainder of the line:</p>
<pre>
    Dim <span class="docEmphasis">R</span> as New Regex("\.")
    Dim <span class="docEmphasis">Parts</span> as String() = <span class="docEmphasis">R</span>.Split("209.204.146.22", 2)
</pre><BR>

<p class="docText">This time, <tt>Parts</tt> receives two strings, <tt>'209'</tt> and <tt>'204.146.22'</tt>.</P>
<p class="docText">If an <span class="docEmphasis">offset</span> (an integer) is provided, that many characters in the target string are bypassed before the regex is attempted. The bypassed text becomes part of the first string returned (unless <tt>RegexOptions.RightToLeft</tt><a name="IDX-CHP-9-3231"></a> 
 has been specified, in which case the bypassed text becomes part of the <span class="docEmphasis">last</span> string returned).</p>

<a name="regex3-CHP-9-SECT-3.2.2"></a>
<h5 id="title-IDARGPNF" class="docSection3Title">9.3.2.2. Using <tt>Split</tt> with capturing parentheses</h5>
<a name="IDX-CHP-9-3232"></a> 

<p class="docText">If capturing parentheses of any type are used, additional entries for captured text are <span class="docEmphasis">usually</span> inserted into the array. (We'll see in what cases they might not be inserted in a bit.) As a simple example, to separate a string like <tt>'2006-12-31'</tt> or <tt>'04/12/2007'</tt> into its component parts, you might split on <img src=images/U2308.jpg border=0><tt>[-/]</tt><img src=images/U230B.jpg border=0>, as with:</P>
<pre>
    Dim <span class="docEmphasis">R</span> as New Regex("[-/]")
    Dim <span class="docEmphasis">Parts</span> as String() = <span class="docEmphasis">R</span>.Split(MyDate)
</pre><BR>

<p class="docText">This returns a list of the three numbers (as strings). However, adding capturing parentheses and using <img src=images/U2308.jpg border=0><tt><span class="docEmphStrong">(</span>[-/,]<span class="docEmphStrong">)</span></tt><img src=images/U230B.jpg border=0> as the regex causes <tt>Split</tt> to return five strings: if <tt>MyDate</tt> contains <tt>'2006-12-31'</tt>, the strings are <tt>'2006', '-', '12', '-'</tt>, and <tt>'31'</tt>. The extra <tt>'-'</tt> elements are from the per-capture <tt>$1</tt>.</p>
<p class="docText">If there are multiple sets of capturing parentheses, they are inserted in their numerical ordering (which means that all named captures come after all unnamed captures &#9758;409).</p>
<p class="docText"><tt>Split</tt> works consistently with capturing parentheses so long as all sets of capturing parentheses actually participate in the match. However, there's a bug with the current version of .NET<a name="IDX-CHP-9-3233"></a> 
<a name="IDX-CHP-9-3234"></a> 
 such that if there is a set of capturing parentheses that doesn't participate in the match, it and all higher-numbered sets <span class="docEmphasis">don't</span> add an element to the returned list.</p>
<p class="docText">As a somewhat contrived example, consider wanting to split on a comma with optional whitespace around it, yet have the whitespace added to the list of elements returned. You might use <img src=images/U2308.jpg border=0><tt>(\s+)?,(\s+)?</tt><img src=images/U230B.jpg border=0> for this. When applied with <tt>Split</tt> to <tt>'this&#8226;,&#8226;&#8226;that'</tt>, four strings are returned, <tt>'this'&#8226;','&#8226;&#8226;', and 'that'</tt>. However, when applied to <tt>'this,&#8226;that'</tt>, the inability of the first set of capturing parentheses to match inhibits the element for it (and for all sets that follow) from being added to the list, so only two strings are returned, <tt>'this'</tt> and <tt>'that'</tt>. The inability to know beforehand exactly how many strings will be returned per match is a major shortcoming of the current implementation.</p>
<p class="docText">In this particular example, you could get around this problem simply by using <img src=images/U2308.jpg border=0><tt>(\s*),(\s*)</tt><img src=images/U230B.jpg border=0> (in which both groups are guaranteed to participate in any overall match). However, more complex expressions are not easily rewritten.</P>
<pre>
<span class="docEmphasis">RegexObj</span>.<span class="docEmphStrong">GetGroupNames()</span><a name="IDX-CHP-9-3235"></a> 
<a name="IDX-CHP-9-3236"></a> 

<span class="docEmphasis">RegexObj</span>.<span class="docEmphStrong">GetGroupNumbers()</span><a name="IDX-CHP-9-3237"></a> 
<a name="IDX-CHP-9-3238"></a> 

<span class="docEmphasis">RegexObj</span>.<span class="docEmphStrong">GroupNameFromNumber(</span><a name="IDX-CHP-9-3239"></a> 
<a name="IDX-CHP-9-3240"></a> 
 <span class="docEmphasis">number</span> <span class="docEmphStrong">)</span>
<span class="docEmphasis">RegexObj</span>.<span class="docEmphStrong">GroupNumberFromName(</span><a name="IDX-CHP-9-3241"></a> 
<a name="IDX-CHP-9-3242"></a> 
 name <span class="docEmphStrong">)</span>
</pre><br>

<p class="docText">These methods allow you to query information about the names (both numeric and, if named capture is used, by name) of capturing groups in the regex. They don't refer to any particular match, but merely to the names and numbers of groups that exist in the regex. The sidebar below shows an example of their use.</p>
<pre>
<span class="docEmphasis">RegexObj</span>.<span class="docEmphStrong">ToString()</span><a name="IDX-CHP-9-3243"></a> 
<a name="IDX-CHP-9-3244"></a> 

<span class="docEmphasis">RegexObj</span>.<span class="docEmphStrong">RightToLeft</span><a name="IDX-CHP-9-3245"></a> 

<span class="docEmphasis">RegexObj</span>.<span class="docEmphStrong">Options</span><a name="IDX-CHP-9-3246"></a> 

</pre><BR>

<p class="docText">These allow you to query information about the <tt>Regex</tt> object itself (as opposed to applying the regex object to a string). The <tt>ToString()</tt> method returns the pattern string originally passed to the regex constructor. The <tt>RightToLeft</tt> property returns a Boolean indicating whether <tt>RegexOptions.RightToLeft</tt> was specified with the regex. The <tt>Options</tt> property returns the <tt>RegexOptions</tt> that are associated with the regex. The following table shows the values of the individual options, which are added together when reported:</p>
<pre>
    0  None<a name="IDX-CHP-9-3247"></a> 
                16  Singleline<a name="IDX-CHP-9-3248"></a> 

    1  IgnoreCase<a name="IDX-CHP-9-3249"></a> 
          32  IgnorePatternWhitespace<a name="IDX-CHP-9-3250"></a> 

    2  Multiline<a name="IDX-CHP-9-3251"></a> 
           64  RightToLeft
    4  ExplicitCapture<a name="IDX-CHP-9-3252"></a> 
    256  ECMAScript<a name="IDX-CHP-9-3253"></a> 

    8  Compiled<a name="IDX-CHP-9-3254"></a> 

</pre><br>

<p class="docText">The missing 128 value is for a Microsoft debugging option not available in the final product.</P>
<p class="docText">The sidebar shows an example these methods in use.</p>


<a name="regex3-CHP-9-SECT-3.3"></a>
<H4 id="title-IDALPPNF" class="docSection2Title">9.3.3. Using <tt>Match</tt> Objects</h4>
<a name="IDX-CHP-9-3255"></a> 
<a name="IDX-CHP-9-3256"></a> 
<a name="IDX-CHP-9-3257"></a> 
<a name="IDX-CHP-9-3258"></a> 
<a name="IDX-CHP-9-3259"></a> 
<a name="IDX-CHP-9-3260"></a> 
<a name="IDX-CHP-9-3261"></a> 
<a name="IDX-CHP-9-3262"></a> 
<a name="IDX-CHP-9-3263"></a> 
<a name="IDX-CHP-9-3264"></a> 
<a name="IDX-CHP-9-3265"></a> 
<a name="IDX-CHP-9-3266"></a> 
<a name="IDX-CHP-9-3267"></a> 
<a name="IDX-CHP-9-3268"></a> 
<a name="IDX-CHP-9-3269"></a> 
<a name="IDX-CHP-9-3270"></a> 
<a name="IDX-CHP-9-3271"></a> 
<a name="IDX-CHP-9-3272"></a> 
<a name="IDX-CHP-9-3273"></a> 
<a name="IDX-CHP-9-3274"></a> 
<a name="IDX-CHP-9-3275"></a> 
<a name="IDX-CHP-9-3276"></a> 

<p class="docText"><tt>Match</tt> objects are created by a <tt>Regex</tt>'s <tt>Match</tt> method, the <tt>Regex.Match</tt> static function (discussed in a bit), and a <tt>Match</tt> object's own <tt>NextMatch</tt> method. It encapsulates all information relating to a single application of a regex. It has the following properties and methods:</p>
<a name="IDX-CHP-9-3277"></a><a name="IDX-CHP-9-3278"></a><dl class="docList">
<dt><br><p><span class="docPubcolor"><span class="docEmphasis">MatchObj</span>.<span class="docEmphStrong">Success</span></span></p></dt>
<a name="IDX-CHP-9-3277"></a> 

<dd>
<p class="docList">This returns a Boolean indicating whether the match was successful. If not, the object is a copy of the static <tt>Match.Empty</tt> object (&#9758;433).</p>
</dd>

<dt><br><p><span class="docPubcolor"><span class="docEmphasis">MatchObj</span>.<span class="docEmphStrong">Value</span></span></p></dt>
<a name="IDX-CHP-9-3278"></a> 

<dd><p class="docList"></p></dd>

<dt><br><p><span class="docPubcolor"><span class="docEmphasis">MatchObj</span>.<span class="docEmphStrong">ToString()</span></span></P></dt>
<dd>
<p class="docList">These return copies of the text actually matched.</p>
</dd>
</dl>
<a name="regex3-CHP-9-SIDEBAR-2"></a><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">Displaying Information about a Regex Object</H2>
<p class="docText">The following code displays what's known about the <tt>Regex</tt> object in the variable <tt>R</tt>:</P>
<pre>
    '<span class="docEmphasis">Display information known about the Regex object in the variable R</span>
    Console.WriteLine("Regex is: " &amp; <span class="docEmphasis">R</span>.ToString())
    Console.WriteLine("Options are: " &amp; <span class="docEmphasis">R</span>.Options)
    If <span class="docEmphasis">R</span>.RightToLeft
       Console.WriteLine("Is Right-To-Left: True")
    Else
       Console.WriteLine("Is Right-To-Left: False")
    End If

    Dim <span class="docEmphasis">S</span> as String
    For Each <span class="docEmphasis">S</span> in <span class="docEmphasis">R</span>.GetGroupNames()
        Console.WriteLine("Name """ &amp; <span class="docEmphasis">S</span> &amp; """ is Num #" &amp; _
                          <span class="docEmphasis">R</span>.GroupNumberFromName(<span class="docEmphasis">S</span>))
    Next
    Console.WriteLine("---")
    Dim <span class="docEmphasis">I</span> as Integer
    For Each <span class="docEmphasis">I</span> in <span class="docEmphasis">R</span>.GetGroupNumbers()
        Console.WriteLine("Num #" &amp; <span class="docEmphasis">I</span> &amp; " is Name """ &amp; _
                          <span class="docEmphasis">R</span>.GroupNameFromNumber(<span class="docEmphasis">I</span>) &amp; """")
    Next
</pre><BR>

<p class="docText">Run twice, once with each of the two <tt>Regex</tt> objects created with</p>
<pre>
    New Regex("^(\w+)://([^/]+)(/\S*)")

    New Regex("^(?&lt;proto&gt;\w+)://(?&lt;host&gt;[^/]+)(?&lt;page&gt;/\S*)",
              RegexOptions.Compiled)
</pre><BR>

<p class="docText">the following output is produced (with one regex cut off to fit the page):</p>
<p><table cellspacing="0" border="1" RULES="all" cellpadding="4" width="90%"><colgroup span="2"><col><col></colgroup><thead></thead><TR><TD class="docTableCell" align="left"><p class="docText">Regex is: ^(\w+)://([^/]+)(/\S*)</p></TD><TD class="docTableCell" align="left"><p class="docText">Regex is: ^(?&lt;proto&gt;\w+)://(?&lt;host&gt; &#8943;</p></td></tr><TR><TD class="docTableCell" align="left"><p class="docText">Option are: 0</p></td><td class="docTableCell" align="left"><p class="docText">Option are: 8</p></TD></tr><tr><TD class="docTableCell" align="left"><p class="docText">Is Right-To-Left: False</p></td><TD class="docTableCell" align="left"><p class="docText">Is Right-To-Left: False</p></TD></tr><tr><td class="docTableCell" align="left"><p class="docText">Name "0" is Num #0</p></td><td class="docTableCell" align="left"><p class="docText">Name "0" is Num #0</p></td></tr><tr><td class="docTableCell" align="left"><p class="docText">Name "1" is Num #1</p></TD><td class="docTableCell" align="left"><p class="docText">Name "proto" is Num #1</P></td></tr><TR><TD class="docTableCell" align="left"><p class="docText">Name "2" is Num #2</P></TD><td class="docTableCell" align="left"><p class="docText">Name "host" is Num #2</P></td></tr><TR><TD class="docTableCell" align="left"><p class="docText">Name "3" is Num #3</p></TD><TD class="docTableCell" align="left"><p class="docText">Name "page" is Num #3</p></td></tr><TR><TD class="docTableCell" align="left"><p class="docText">---</p></td><td class="docTableCell" align="left"><p class="docText">---</p></TD></tr><tr><TD class="docTableCell" align="left"><p class="docText">Num #0 is Name "0"</p></td><TD class="docTableCell" align="left"><p class="docText">Num #0 is Name "0"</p></TD></tr><tr><td class="docTableCell" align="left"><p class="docText">Num #1 is Name "1"</p></td><td class="docTableCell" align="left"><p class="docText">Num #1 is Name "proto"</p></td></tr><tr><td class="docTableCell" align="left"><p class="docText">Num #2 is Name "2"</p></TD><td class="docTableCell" align="left"><p class="docText">Num #2 is Name "host"</P></td></tr><TR><TD class="docTableCell" align="left"><p class="docText">Num #3 is Name "3"</P></TD><td class="docTableCell" align="left"><p class="docText">Num #3 is Name "page"</P></td></tr></table></P><BR>
</td></TR></table></P><br>
<a name="IDX-CHP-9-3279"></a><a name="IDX-CHP-9-3280"></a><a name="IDX-CHP-9-3281"></a><a name="IDX-CHP-9-3282"></a><a name="IDX-CHP-9-3283"></a><a name="IDX-CHP-9-3284"></a><a name="IDX-CHP-9-3285"></a><a name="IDX-CHP-9-3286"></a><dl class="docList">
<dt><br><p><span class="docPubcolor"><span class="docEmphasis">MatchObj</span>.<span class="docEmphStrong">Length</span></span></P></dt>
<a name="IDX-CHP-9-3279"></a> 

<dd><p class="docList">This returns the length of the text actually matched.</P></dd>

<dt><br><p><span class="docPubcolor"><span class="docEmphasis">MatchObj</span>.<span class="docEmphStrong">Index</span></span></p></dt>
<a name="IDX-CHP-9-3280"></a> 

<dd><p class="docList">This returns an integer indicating the position in the target text where the match was found. It's a zero-based index, so it's the number of characters from the start (left) of the string to the start (left) of the matched text. This is true even if <tt>RegexOptions.RightToLeft</tt><a name="IDX-CHP-9-3281"></a> 
 had been used to create the regex that generated this <tt>Match</tt> object.</p></dd>

<dt><BR><p><span class="docPubcolor"><span class="docEmphasis">MatchObj</span>.<span class="docEmphStrong">Groups</span></span></p></dt>
<a name="IDX-CHP-9-3282"></a> 

<dd><p class="docList">This property is a <tt>GroupCollection</tt><a name="IDX-CHP-9-3283"></a> 
 object, in which a number of <tt>Group</tt> objects are encapsulated. It is a normal collection object, with a <tt>Count</tt> and <tt>Item</tt> properties, but it's most commonly accessed by indexing into it, fetching an individual <tt>Group</tt> object. For example, <tt>M.Groups(3)</tt> is the <tt>Group</tt> object related to the third set of capturing parentheses, and <tt>M.Groups("HostName")</tt> is the group object for the "Hostname" named capture (e.g., after the use of <img src=images/U2308.jpg border=0><tt>(?&lt;HostName&gt;&#8943;)</tt><img src=images/U230B.jpg border=0> in a regex).</P>
<p class="docList">Note that C<span class="docEmphasis">#</span> requires <tt>M.Groups[3]</tt> and <tt>M.Groups["HostName"]</tt> instead.</p>
<p class="docList">The zeroth group represents the entire match itself. <span class="docEmphasis">MatchObj</span>.<tt>Groups(0).Value</tt>, for example, is the same as <span class="docEmphasis">MatchObj</span>.<tt>Value</tt>.</p>
</dd>

<dt><BR><p><span class="docPubcolor"><span class="docEmphasis">MatchObj</span>.<span class="docEmphStrong">NextMatch()</span></span></P></dt>
<a name="IDX-CHP-9-3284"></a> 

<dd><p class="docList">The <tt>NextMatch()</tt> method re-invokes the original regex to find the next match in the original string, returning a new <tt>Match</tt> object.</p></dd>

<dt><br><p><span class="docPubcolor"><span class="docEmphasis">MatchObj</span>.<span class="docEmphStrong">Result</span> (<span class="docEmphasis">string</span><span class="docEmphStrong">)</span>
<a name="IDX-CHP-9-3285"></a> 

</span></p></dt>
<dd><p class="docList">Special sequences in the given <span class="docEmphasis">string</span> are processed as shown in the sidebar on page 424, returning the resulting text. Here's a simple example:</p>
<pre>
    Dim <span class="docEmphasis">M</span> as Match = Regex.Match(SomeString, "\w+")
    Console.WriteLine(<span class="docEmphasis">M</span>.Result("The first word is '$&amp;'"))
</pre><br>

<p class="docList">You can use this to get a copy of the text to the left and right of the match, with</p>
<pre>
    <span class="docEmphasis">M</span>.Result("$'") '<span class="docEmphasis">This is the text to the left of the match</span>
    <span class="docEmphasis">M</span>.Result("$'") '<span class="docEmphasis">This is the text to the right of the match</span>
</pre><br>

<p class="docList">During debugging, it may be helpful to display something along the lines of:</p>
<pre>
    <span class="docEmphasis">M</span>.Result("[$'&lt;$&amp;&gt;$']"))
</pre><br>

<p class="docList">Given a <tt>Match</tt> object created by applying <img src=images/U2308.jpg border=0><tt>\d+</tt><img src=images/U230B.jpg border=0> to the string <tt>'May 16, 1998'</tt>, it returns <tt>'May &lt;16&gt;, 1998'</tt>, clearly showing the exact match.</p>
</dd>

<dt><br><P><span class="docPubcolor"><span class="docEmphasis">MatchObj</span>.<span class="docEmphStrong">Synchronized()</span></span></p></dt>
<a name="IDX-CHP-9-3286"></a> 

<dd><p class="docList">This returns a new <tt>Match</tt> object that's identical to the current one, except that it's safe for multi-threaded use.</P>
</dd>

<dt><br><p><span class="docPubcolor"><span class="docEmphasis">MatchObj</span>.<span class="docEmphStrong">Captures</span></span></P></dt>
<dd><p class="docList">The <tt>Captures</tt> property is not used often, but is discussed starting on page 437.</P>
</dd>
</dl>

<a name="regex3-CHP-9-SECT-3.4"></a>
<H4 id="title-IDAETINF" class="docSection2Title">9.3.4. Using <tt>Group</tt> Objects</H4>
<a name="IDX-CHP-9-3287"></a> 
<a name="IDX-CHP-9-3288"></a> 
<a name="IDX-CHP-9-3289"></a> 
<a name="IDX-CHP-9-3290"></a> 
<a name="IDX-CHP-9-3291"></a> 
<a name="IDX-CHP-9-3292"></a> 
<a name="IDX-CHP-9-3293"></a> 

<p class="docText">A <tt>Group</tt> object contains the match information for one set of capturing parentheses (or, if a zeroth group, for an entire match). It has the following properties and methods:</p>
<a name="IDX-CHP-9-3294"></a><a name="IDX-CHP-9-3295"></a><a name="IDX-CHP-9-3296"></a><a name="IDX-CHP-9-3297"></a><a name="IDX-CHP-9-3298"></a><dl class="docList">
<dt><BR><p><span class="docPubcolor"><span class="docEmphasis">GroupObj</span>.<span class="docEmphStrong">Success</span></span></p></dt>
<a name="IDX-CHP-9-3294"></a> 

<dd><p class="docList">This returns a Boolean indicating whether the group participated in the match. Not all groups necessarily "participate" in a successful overall match. For example, if <img src=images/U2308.jpg border=0><tt>(this)|(that)</tt><img src=images/U230B.jpg border=0> matches successfully, one of the sets of parentheses is guaranteed to have participated, while the other is guaranteed to have not. See the footnote on page 139 for another example.</P>
</dd>

<dt><BR><p><span class="docPubcolor"><span class="docEmphasis">GroupObj</span>.<span class="docEmphStrong">Value</span></span></P></dt>
<a name="IDX-CHP-9-3295"></a> 

<dd><p class="docList"></P></dd>

<dt><br><p><span class="docPubcolor"><span class="docEmphasis">GroupObj</span>.<span class="docEmphStrong">ToString()</span></span></p></dt>
<a name="IDX-CHP-9-3296"></a> 

<dd><p class="docList">These both return a copy of the text captured by this group. If the match hadn't been successful, these return an empty string.</P></dd>

<dt><BR><p><span class="docPubcolor"><span class="docEmphasis">GroupObj</span>.<span class="docEmphStrong">Length</span></span></p></dt>
<a name="IDX-CHP-9-3297"></a> 

<dd><p class="docList">This returns the length of the text captured by this group. If the match hadn't been successful, it returns zero.</p>
</dd>

<dt><br><P><span class="docPubcolor"><span class="docEmphasis">GroupObj</span>.<span class="docEmphStrong">Index</span></span></p></dt>
<a name="IDX-CHP-9-3298"></a> 

<dd><p class="docList">This returns an integer indicating where in the target text the group match was found. The return value is a zero-based index, so it's the number of characters from the start (left) of the string to the start (left) of the captured text. (This is true even if <tt>RegexOptions.RightToLeft</tt> had been used to create the regex that generated this <tt>Match</tt> object.)</p>
</dd>

<dt><BR><p><span class="docPubcolor"><span class="docEmphasis">GroupObj</span>.<span class="docEmphStrong">Captures</span></span></p></dt>
<dd><p class="docList">The <tt>Group</tt> object also has a <tt>Captures</tt> property discussed starting on page 437.</P>
</dd>
</dl>


</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-9-SECT-2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=regex3-CHP-9-SECT-4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>