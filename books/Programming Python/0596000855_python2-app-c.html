<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docAppendixTitle"--><!--SafTocEntry="Appendix C. Python Versus C++"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
	<a href="0596000855_python2-APP-B-SECT-5.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596000855_colophon.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="python2-APP-C"></A>

<H2 class="docAppendixTitle">Appendix C. Python Versus C++</H2>

<P class="docText"><A NAME="python2-IDXTERM-2725"></A> <A NAME="python2-IDXTERM-2726"></A>This appendix briefly summarizes
some of the differences between Python and C++ classes.
Python's <TT>class</TT> system can be thought of as a
subset of C++'s. Although the comparison to Modula 3 may be
closer, C++ is the dominant OOP language today. But in Python, things
are intentionally simpler -- classes are simply
<span class="docEmphasis">objects</span> with attached
<span class="docEmphasis">attributes</span> that may have links to other class
objects. They support generation of multiple instances, customization
by attribute inheritance, and operator overloading, but the object
model in Python is comparatively uncluttered. Here are some specific
differences between Python and
C++:<A NAME="IXT-C-336824"></A>
</P>

<A NAME="IXT-C-336825"></A><A NAME="IXT-C-336826"></A><A NAME="IXT-C-336827"></A><A NAME="IXT-C-336828"></A><A NAME="IXT-C-336829"></A><A NAME="IXT-C-336830"></A><A NAME="IXT-C-336831"></A><A NAME="IXT-C-336832"></A><A NAME="IXT-C-336833"></A><A NAME="IXT-C-336834"></A><A NAME="IXT-C-336835"></A><A NAME="IXT-C-336836"></A><A NAME="IXT-C-336837"></A><A NAME="IXT-C-336838"></A><A NAME="IXT-C-336839"></A><A NAME="IXT-C-336840"></A><A NAME="IXT-C-336841"></A><A NAME="IXT-C-336842"></A><A NAME="IXT-C-336843"></A><A NAME="IXT-C-336844"></A><A NAME="IXT-C-336845"></A><A NAME="IXT-C-336846"></A><A NAME="IXT-C-336847"></A><A NAME="IXT-C-336848"></A><A NAME="IXT-C-336849"></A><A NAME="IXT-C-336850"></A><A NAME="IXT-C-336851"></A><A NAME="IXT-C-336852"></A><A NAME="IXT-C-336853"></A><A NAME="IXT-C-336854"></A><A NAME="IXT-C-336855"></A><A NAME="IXT-C-336856"></A><A NAME="IXT-C-336857"></A><DL class="docList">
<DT><I><span class="docPubcolor">Attributes</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336825"></A>
<A NAME="IXT-C-336826"></A>
<A NAME="IXT-C-336827"></A>There is no
real distinction between data members and methods in Python; both
simply designate named <span class="docEmphasis">attributes</span> of instances
or classes, bound to functions or other kinds of objects. Attributes
are names attached to objects, and accessed by qualification:
<TT>object.attribute</TT>. Methods are merely class
attributes assigned to functions normally created with nested
<TT>def</TT> statements; members are just attribute names
assigned to other kinds of objects.
</P>
</DD><DT><I><span class="docPubcolor">Class object generation</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336828"></A>
<A NAME="IXT-C-336829"></A>Class statements
create <span class="docEmphasis">class</span> objects and assign them to a name.
Statements that assign names within a <TT>class</TT>
statement generate class attributes, and classes inherit attributes
from all other classes listed in their <TT>class</TT>
statement header line (multiple inheritance is supported; this is
discussed in a moment).
</P>
</DD><DT><I><span class="docPubcolor">Instance object creation</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336830"></A>
<A NAME="IXT-C-336831"></A>
<A NAME="IXT-C-336832"></A>Calling
a class object as though it were a function generates a new class
<span class="docEmphasis">instance</span> object. An instance begins with an
empty namespace that inherits names in the class's namespace;
assignments to instance attributes (e.g., to <TT>self</TT>
attributes within class method functions) create attributes in the
instance.
</P>
</DD><DT><I><span class="docPubcolor">Object deletion</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336833"></A>
<A NAME="IXT-C-336834"></A>Both
classes and instances (and any data they embed) are automatically
reclaimed when no longer held. There is no <TT>new</TT>
(classes are called instead) and Python's
<TT>del</TT> statement removes just one reference, unlike
C++'s <span class="docEmphasis">delete</span>.
</P>
</DD><DT><I><span class="docPubcolor">Member creation</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336835"></A>Class and
instance attributes, like simple variables, spring into existence
when assigned, are not declared ahead of time, and may reference any
type of object (they may even reference different object datatypes at
different times).
</P>
</DD><DT><I><span class="docPubcolor">Inheritance</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336836"></A>Python
inheritance is generally kicked off to search for an attribute
name's value: given an expression of the form
<TT>object.attribute</TT>, Python searches the namespace
object tree at <TT>object</TT> and above for the first
appearance of name <TT>attribute</TT>. An inheritance
search also occurs when expression operators and type operations are
applied to objects. A new, independent inheritance search is
performed for every <TT>object.attribute</TT> expression
that is evaluated -- even <TT>self.attr</TT> expressions
within a method function search anew for <TT>attr</TT> at
the instance object referenced by <TT>self</TT> and above.
</P>
</DD><DT><I><span class="docPubcolor">Runtime type information</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336837"></A>Python classes are
<span class="docEmphasis">objects</span> in memory at runtime -- they can be
passed around a program to provide a sort of runtime type resource
(e.g., a single function can generate instances of arbitrary classes
passed in as an argument). Both class and instance objects carry
interpreter information (e.g., a <TT>__dict__</TT>
attribute dictionary), and Python's <TT>type</TT>
function allows object type testing. Instance objects'
<TT>__class__</TT> attributes reference the class they
were created from, and class objects' <TT>__bases_
_</TT> attributes give class superclasses (base classes).
</P>
</DD><DT><I><span class="docPubcolor"> "this" pointer</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336838"></A>Python's equivalent of the C++
<TT>this</TT> instance pointer is the first argument added
to method function calls (and usually called <TT>self</TT>
by convention). It is usually implicit in a call but is used
explicitly in methods: there is no hidden instance scope for
unqualified names. Python methods are just functions nested in a
<TT>class</TT> statement that receive the implied instance
objects in their leftmost parameters.
</P>
</DD><DT><I><span class="docPubcolor">Virtual methods</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336839"></A><A NAME="IXT-C-336840"></A>In Python, all methods and data members
are <TT>virtual</TT> in the C++ sense: there is no notion
of a compile-time resolution of attributes based on an object's
type. Every attribute qualification (<TT>object.name</TT>)
is resolved at runtime, based on the qualified object's type.
</P>
</DD><DT><I><span class="docPubcolor">Pure virtuals</span></I></DT>
<DD>
<P class="docList">Methods called by a superclass but not defined by it correspond to
C++'s concept of "pure virtual" methods: methods
that must be redefined in a subclass. Since Python is not statically
compiled, there is no need for C++'s special syntax to declare
this case. Calls to undefined methods raise a name error exception at
runtime, which may or may not be caught with <TT>try</TT>
statements.
</P>
</DD><DT><I><span class="docPubcolor">Static members</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336841"></A>There is no
<TT>static</TT> class data declaration; instead,
assignments nested in a <TT>class</TT> statement generate
attribute names associated with the class and shared by all its
instances.
</P>
</DD><DT><I><span class="docPubcolor">Private members</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336842"></A>There is no
notion of true access restrictions for attributes; every member and
method is <span class="docEmphasis">public</span> in the C++ sense. Attribute
hiding is a matter of convention rather than syntax: C++'s
<TT>public</TT>, <TT>private</TT>, and
<TT>protected</TT> constraints don't apply (but see
also the new <TT>__X</TT> class name localization feature
in <A class="docLink" HREF="0596000855_python2-APP-A.html#python2-APP-A">Appendix A</A>).
</P>
</DD><DT><I><span class="docPubcolor">Const interfaces</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336843"></A>Objects
may be immutable, but names are not -- there is no equivalent of
C++'s <TT>const</TT> modifier. Nothing prevents a
name or object from being changed in a method, and methods can change
mutable arguments (the <TT>self</TT> object, for example).
Convention and common sense replaces extra syntax.
</P>
</DD><DT><I><span class="docPubcolor">Reference parameters</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336844"></A>There
is no direct analogue for C++'s <span class="docEmphasis">reference</span>
parameters. Python methods may return multiple values in a tuple and
can change passed-in objects if they're mutable (for instance,
by assigning to an object's attributes or changing lists and
dictionaries in place). But there is no aliasing between names at the
call and names in a function header: arguments are passed by
assignment, which creates shared object references.
</P>
</DD><DT><I><span class="docPubcolor">Operator overloading</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336845"></A>
<A NAME="IXT-C-336846"></A>Special
method names overload operators: there is no <TT>operator+</TT>
-like syntax but the effects are similar. For instance, a
class attribute named <TT>__add__</TT> overloads
(intercepts and implements) application of the <TT>+</TT>
operator to instances of the class; <TT>__getattr__</TT>
is roughly like C++ <TT>-&gt;</TT> overloading. Arbitrary
expressions require coding right-side methods (e.g., <TT>_
_radd__</TT> ).
</P>
</DD><DT><I><span class="docPubcolor">Templates</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336847"></A>Python is
dynamically typed -- names are references to arbitrary objects,
and there is no notion of type declarations. C++ templates are
neither applicable nor necessary. Python classes and functions can
generally be applied to any object type that implements the interface
protocols (operations and operators) expected by the class's
code. Subjects need not be of a certain datatype.
</P>
</DD><DT><I><span class="docPubcolor">Friends</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336848"></A>Everything is friendly in Python.
Because there is no notion of privacy constraints, any class can
access the internals of another.
</P>
</DD><DT><I><span class="docPubcolor">Function overloading</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336849"></A><A NAME="IXT-C-336850"></A>Python
polymorphism is based on virtual method calls: the type of a
qualified object determines what its methods do. Since Python
arguments' types are never declared (dynamically typed), there
is nothing like C++'s function overloading for dispatching to
different versions of a function based on the datatypes of its
arguments. You can explicitly test types and argument list lengths in
methods instead of writing separate functions for each type
combination (see <TT>type</TT> built-in function and
<TT>*args</TT> function argument form).
</P>
</DD><DT><I><span class="docPubcolor">Multiple inheritance</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336851"></A>Multiple
inheritance is coded by listing more than one superclass in
parentheses in a class statement header line. When multiple
inheritance is used, Python simply uses the
<span class="docEmphasis">first</span> appearance of an attribute found during a
depth-first, left-to-right search through the superclass tree. Python
resolves multiple inheritance conflicts this way instead of treating
them as errors.
</P>
</DD><DT><I><span class="docPubcolor">Virtual inheritance</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336852"></A>C++'s
notion of virtual base classes doesn't quite apply in Python. A
Python class instance is a single namespace dictionary (with a class
pointer for access to inherited attributes). Classes add attributes
to the class instance dictionary by assignment. Because of this
structure, each attribute exists in just one place -- the instance
dictionary. For inherited class attributes, the search of the
superclass tree resolves references unambiguously.
</P>
</DD><DT><I><span class="docPubcolor">Constructors</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336853"></A>
<A NAME="IXT-C-336854"></A>Python only runs the one <TT>_
_init__</TT> method found by the inheritance object tree
search. It doesn't run all accessible classes'
constructors automatically; if needed, we have to call other class
constructors manually. But this is no harder than specifying
superclass constructor arguments in C++. Python destructors (
<TT>__del__</TT> ) run when an instance is
garbage-collected (i.e., deallocated), not in response to
<span class="docEmphasis">delete</span> calls.
</P>
</DD><DT><I><span class="docPubcolor">Scope operators</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336855"></A>
<A NAME="IXT-C-336856"></A>C++
scope operators of the form <TT>Superclass::Method</TT> are
used to extend inherited methods and disambiguate inheritance
conflicts. Python's closest equivalent is
<TT>Superclass.Method</TT>, a class object qualification.
It isn't required for inheritance conflict resolution, but can
be used to override the default search rule and to call back to
superclasses in method extensions.
</P>
</DD><DT><I><span class="docPubcolor">Method pointers</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-C-336857"></A>Instead of
special syntax, Python method references are <span class="docEmphasis">objects</span>
; they may be passed, stored in data structures, and so
on. Method objects come in two flavors: <span class="docEmphasis">bound</span>
methods (when an instance is known) are instance/method pairs called
later like simple functions, and <span class="docEmphasis">unbound</span> methods
are simply references to a method function object and require an
instance to be passed explicitly when called.
</P>
</DD>
</DL>

<P class="docText"><A NAME="IXT-C-336858"></A>
<A NAME="IXT-C-336859"></A> <A NAME="IXT-C-336860"></A>Naturally, Python
has additional class features not found in C++, such as
<span class="docEmphasis">metaclass protocols</span> : <TT>__setattr_
_</TT> can be used to implement alternative interfaces, and an
instance's <TT>__class__</TT> pointer can be reset
to change the class type of an object dynamically. Moreover, class
attributes can be modified arbitrarily at runtime; classes are merely
objects with attached attribute names.
</P>

<P class="docText"><A NAME="IXT-C-336861"></A>In addition, Python differs from C++ in
numerous ways besides its class model. For instance, there are
neither type declarations nor compile and linking steps in Python;
you cannot overload <TT>=</TT> in Python as you can in C++
(assignment isn't an operator in Python); and pointers, central
to much C and C++ programming, are completely absent in Python
(though object references can have some of the same effects). Instead
of pointers, Python programs use first-class objects, which are
automatically allocated and reclaimed.
</P>

<P class="docText">Most of these differences stem from the fact that Python was designed
for speed of development, not speed of execution; much of C++'s
extra syntax would interfere with Python's purpose. See the
O'Reilly text <span class="docEmphasis">Learning Python</span> for a
complete introduction to Python classes and the remainder of the core
Python language. <A NAME="IXTR3-4"></A>
</P>


<ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
          <a href="0596000855_python2-APP-B-SECT-5.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596000855_colophon.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
