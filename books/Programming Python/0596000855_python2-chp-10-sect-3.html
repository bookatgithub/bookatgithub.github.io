<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="10.3 Socket Programming"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
	<a href="0596000855_python2-CHP-10-SECT-2.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596000855_python2-CHP-10-SECT-4.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="python2-CHP-10-SECT-3"></A>
<H3 class="docSection1Title">10.3 Socket Programming</H3>

<P class="docText"><A NAME="python2-IDXTERM-578"></A>
<A NAME="python2-IDXTERM-579"></A>Now
that we've seen how sockets figure into the Internet picture,
let's move on to explore the tools that Python provides for
programming sockets with Python scripts. This section shows you how
to use the Python socket interface to perform low-level network
communications; in later chapters, we will instead use one of the
higher-level protocol modules that hide underlying sockets.
</P>

<P class="docText">The basic socket interface in Python is the standard library's
<TT>socket</TT> module. Like the <TT>os</TT>
POSIX module, Python's <TT>socket</TT> module is just
a thin wrapper (interface layer) over the underlying C
library's socket calls. Like Python files, it's also
object-based: methods of a socket object implemented by this module
call out to the corresponding C library's operations after data
conversions. The <TT>socket</TT> module also includes tools
for converting bytes to a standard network ordering, wrapping socket
objects in simple file objects, and more. It supports socket
programming on any machine that supports BSD-style sockets -- MS
Windows, Linux, Unix, etc. -- and so provides a portable socket
interface.
</P>

<A NAME="python2-CHP-10-SECT-3.1"></A>
<H4 class="docSection2Title">10.3.1 Socket Basics</H4>

<P class="docText"><A NAME="IXT-10-337232"></A>
<A NAME="IXT-10-337233"></A>
<A NAME="IXT-10-337234"></A>
<A NAME="IXT-10-337235"></A>To create a
connection between machines, Python programs import the
<TT>socket</TT> module, create a socket object, and call
the object's methods to establish connections and send and
receive data. Socket object methods map directly to socket calls in
the C library. For example, the script in <A class="docLink" HREF="#python2-CHP-10-EX-1">Example 10-1</A> implements a program that simply listens for a
connection on a socket, and echoes back over a socket whatever it
receives through that socket, adding <TT>'Echo=&gt;'</TT>
string prefixes.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-10-EX-1"></A>Example 10-1. PP2E\Internet\Sockets\echo-server.py </H5>
<PRE>#########################################################
# Server side: open a socket on a port, listen for
# a message from a client, and send an echo reply; 
# this is a simple one-shot listen/reply per client, 
# but it goes into an infinite loop to listen for 
# more clients as long as this server script runs; 
#########################################################

from socket import *                    # get socket constructor and constants
myHost = ''                             # server machine, '' means local host
myPort = 50007                          # listen on a non-reserved port number

sockobj = socket(AF_INET, SOCK_STREAM)       # make a TCP socket object
sockobj.bind((myHost, myPort))               # bind it to server port number 
sockobj.listen(5)                            # listen, allow 5 pending connects

while 1:                                     # listen until process killed
    connection, address = sockobj.accept()   # wait for next client connect
    print 'Server connected by', address     # connection is a new socket
    while 1:
        data = connection.recv(1024)         # read next line on client socket
        if not data: break                   # send a reply line to the client
        connection.send('Echo=&gt;' + data)     # until eof when socket closed
    connection.close() </PRE>


<P class="docText"><A NAME="IXT-10-337236"></A>
<A NAME="IXT-10-337237"></A>As mentioned
earlier, we usually call programs like this that listen for incoming
connections <span class="docEmphasis">servers</span> because they provide a
service that can be accessed at a given machine and port on the
Internet. Programs that connect to such a server to access its
service are generally called <span class="docEmphasis">clients</span>. <A class="docLink" HREF="#python2-CHP-10-EX-2">Example 10-2</A> shows a simple client implemented in Python.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-10-EX-2"></A>Example 10-2. PP2E\Internet\Sockets\echo-client.py </H5>
<PRE>#############################################################
# Client side: use sockets to send data to the server, and 
# print server's reply to each message line; 'localhost' 
# means that the server is running on the same machine as 
# the client, which lets us test client and server on one 
# machine;  to test over the Internet, run a server on a remote 
# machine, and set serverHost or argv[1] to machine's domain
# name or IP addr;  Python sockets are a portable BSD socket
# interface, with object methods for standard socket calls;
#############################################################

import sys
from socket import *              # portable socket interface plus constants
serverHost = 'localhost'          # server name, or: 'starship.python.net'
serverPort = 50007                # non-reserved port used by the server

message = ['Hello network world']           # default text to send to server
if len(sys.argv) &gt; 1:
    serverHost = sys.argv[1]                # or server from cmd line arg 1
    if len(sys.argv) &gt; 2:                   # or text from cmd line args 2..n
        message = sys.argv[2:]              # one message for each arg listed

sockobj = socket(AF_INET, SOCK_STREAM)      # make a TCP/IP socket object
sockobj.connect((serverHost, serverPort))   # connect to server machine and port

for line in message:
    sockobj.send(line)                      # send line to server over socket
    data = sockobj.recv(1024)               # receive line from server: up to 1k
    print 'Client received:', `data`

sockobj.close()                             # close socket to send eof to server</PRE>


<A NAME="python2-CHP-10-SECT-3.1.1"></A>
<H5 class="docSection3Title">10.3.1.1 Server socket calls</H5>

<P class="docText"><A NAME="python2-IDXTERM-586"></A> <A NAME="python2-IDXTERM-587"></A>
<A NAME="python2-IDXTERM-588"></A>Before we see these programs in action,
let's take a minute to explain how this client and server do
their stuff. Both are fairly simple examples of socket scripts, but
they illustrate common call patterns of most socket-based programs.
In fact, this is boilerplate code: most socket programs generally
make the same socket calls that our two scripts do, so let's
step through the important points of these scripts line by line.
</P>

<P class="docText">Programs such as <A class="docLink" HREF="#python2-CHP-10-EX-1">Example 10-1</A> that provide services
for other programs with sockets generally start out by following this
sequence of calls:
</P>

<A NAME="IXT-10-337238"></A><A NAME="IXT-10-337239"></A><A NAME="IXT-10-337240"></A><A NAME="IXT-10-337241"></A><A NAME="IXT-10-337242"></A><A NAME="IXT-10-337243"></A><A NAME="IXT-10-337244"></A><A NAME="IXT-10-337245"></A><A NAME="IXT-10-337246"></A><A NAME="IXT-10-337247"></A><A NAME="IXT-10-337248"></A><A NAME="IXT-10-337249"></A><A NAME="IXT-10-337250"></A><A NAME="IXT-10-337251"></A><DL class="docList">
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">sockobj = socket(AF_INET, SOCK_STREAM)</span></span> </span></DT>
<DD>
<P class="docList"><A NAME="IXT-10-337238"></A>
<A NAME="IXT-10-337239"></A>
<A NAME="IXT-10-337240"></A>
<A NAME="IXT-10-337241"></A> <A NAME="IXT-10-337242"></A>
<A NAME="IXT-10-337243"></A>
<A NAME="IXT-10-337244"></A> <A NAME="IXT-10-337245"></A>Uses the Python socket module to create
a TCP socket object. The names <TT>AF_INET</TT> and
<TT>SOCK_STREAM</TT> are preassigned variables defined by
and imported form the socket module; using them in combination means
"create a TCP/IP socket," the standard communication
device for the Internet. More specifically,
<TT>AF_INET</TT> means the IP address protocol, and
<TT>SOCK_STREAM</TT> means the TCP transfer protocol.
</P>

<P class="docList">If you use other names in this call, you can instead create things
like UDP connectionless sockets (use <TT>SOCK_DGRAM</TT>
second) and Unix domain sockets on the local machine (use
<TT>AF_UNIX</TT> first), but we won't do so in this
book. See the Python library manual for details on these and other
socket module options.
</P>
</DD><DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">sockobj.bind((myHost, myPort))</span></span></span></DT>
<DD>
<P class="docList"><A NAME="IXT-10-337246"></A>
<A NAME="IXT-10-337247"></A>Associates
the socket object to an address -- for IP addresses, we pass a
server machine name and port number on that machine. This is where
the server identifies the machine and port associated with the
socket. In server programs, the hostname is typically an empty string
(""), which means the machine that the script runs on and
the port is a number outside the range 0-1023 (which is reserved for
standard protocols, described earlier). Note that each unique socket
dialog you support must have its own port number; if you try to open
a socket on a port already in use, Python will raise an exception.
Also notice the nested parenthesis in this call -- for the
<TT>AF_INET</TT> address protocol socket here, we pass the
host/port socket address to <TT>bind</TT> as a two-item
tuple object (pass a string for <TT>AF_UNIX</TT>).
Technically, <TT>bind</TT> takes a tuple of values
appropriate for the type of socket created (but see the next Note box
about the older and deprecated convention of passing values to this
function as distinct arguments).
</P>
</DD><DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">sockobj.listen(5)</span></span></span></DT>
<DD>
<P class="docList"><A NAME="IXT-10-337248"></A>
<A NAME="IXT-10-337249"></A>
<A NAME="IXT-10-337250"></A>
<A NAME="IXT-10-337251"></A>Starts
listening for incoming client connections and allows for a backlog of
up to five pending requests. The value passed sets the number of
incoming client requests queued by the operating system before new
requests are denied (which only happens if a server isn't fast
enough to process requests before the queues fill up). A value of 5
is usually enough for most socket-based programs; the value must be
at least 1.
</P>
</DD>
</DL>

<P class="docText">At this point, the server is ready to accept connection requests from
client programs running on remote machines (or the same machine), and
falls into an infinite loop waiting for them to arrive:
</P>

<A NAME="IXT-10-337252"></A><A NAME="IXT-10-337253"></A><DL class="docList">
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">connection, address = sockobj.accept()</span></span> </span></DT>
<DD>
<P class="docList"><A NAME="IXT-10-337252"></A>
<A NAME="IXT-10-337253"></A>Waits
for the next client connection request to occur; when it does, the
<TT>accept</TT> call returns a brand new socket object over
which data can be transferred from and to the connected client.
Connections are accepted on <TT>sockobj</TT>, but
communication with a client happens on <TT>connection</TT>,
the new socket. This call actually returns a two-item
tuple -- <TT>address</TT> is the connecting
client's Internet address. We can call
<TT>accept</TT> more than one time, to service multiple
client connections; that's why each call returns a new,
distinct socket for talking to a particular client.
</P>
</DD>
</DL>

<P class="docText">Once we have a client connection, we fall into another loop to
receive data from the client in blocks of 1024 bytes at a time, and
echo each block back to the client:
</P>

<A NAME="IXT-10-337254"></A><A NAME="IXT-10-337255"></A><A NAME="IXT-10-337256"></A><A NAME="IXT-10-337257"></A><A NAME="IXT-10-337258"></A><A NAME="IXT-10-337259"></A><A NAME="IXT-10-337260"></A><A NAME="IXT-10-337261"></A><A NAME="IXT-10-337262"></A><A NAME="IXT-10-337263"></A><DL class="docList">
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">data = connection.recv(1024)</span></span></span></DT>
<DD>
<P class="docList"><A NAME="IXT-10-337254"></A>
<A NAME="IXT-10-337255"></A>
<A NAME="IXT-10-337256"></A>
<A NAME="IXT-10-337257"></A>Reads
at most 1024 more bytes of the next message sent from a client (i.e.,
coming across the network), and returns it to the script as a string.
We get back an empty string when the client has
finished -- end-of-file is triggered when the client closes its
end of the socket.
</P>
</DD><DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">connection.send('Echo=&gt;' + data)</span></span></span></DT>
<DD>
<P class="docList"><A NAME="IXT-10-337258"></A>
<A NAME="IXT-10-337259"></A>Sends
the latest data block back to the client program, prepending the
string <TT>'Echo=&gt;'</TT> to it first. The client program
can then <TT>recv</TT> what we <TT>send</TT>
here -- the next reply line.
</P>
</DD><DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">connection.close()</span></span></span></DT>
<DD>
<P class="docList"><A NAME="IXT-10-337260"></A>
<A NAME="IXT-10-337261"></A>
<A NAME="IXT-10-337262"></A>
<A NAME="IXT-10-337263"></A>Shuts
down the connection with this particular client.
</P>
</DD>
</DL>

<P class="docText">After talking with a given client, the server goes back to its
infinite loop, and waits for the next client connection
request.<A NAME="IXTR3-159"></A> <A NAME="IXTR3-160"></A> <A NAME="IXTR3-161"></A>
</P>



<A NAME="python2-CHP-10-SECT-3.1.2"></A>
<H5 class="docSection3Title">10.3.1.2 Client socket calls</H5>

<P class="docText"><A NAME="IXT-10-337264"></A>
<A NAME="IXT-10-337265"></A>
<A NAME="IXT-10-337266"></A>On the other hand, client programs like
the one shown in <A class="docLink" HREF="#python2-CHP-10-EX-2">Example 10-2</A> follow simpler call
sequences. The main thing to keep in mind is that the client and
server must specify the same port number when opening their sockets,
and the client must identify the machine on which the server is
running (in our scripts, server and client agree to use port number
50007 for their conversation, outside the standard protocol range):
</P>

<A NAME="IXT-10-337267"></A><A NAME="IXT-10-337268"></A><A NAME="IXT-10-337269"></A><A NAME="IXT-10-337270"></A><DL class="docList">
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">sockobj = socket(AF_INET, SOCK_STREAM)</span></span></span></DT>
<DD>
<P class="docList"><A NAME="IXT-10-337267"></A>
<A NAME="IXT-10-337268"></A>Creates
a Python socket object in the client program, just like the server.
</P>
</DD><DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">sockobj.connect((serverHost, serverPort))</span></span></span></DT>
<DD>
<P class="docList"><A NAME="IXT-10-337269"></A>
<A NAME="IXT-10-337270"></A>Opens
a connection to the machine and port on which the server program is
listening for client connections. This is where the client specifies
the name of the service to be contacted. In the client, we can either
specify the name of the remote machine as a domain name (e.g.,
<span class="docEmphasis">starship.python.net</span>) or numeric
IP address. We can also give the server name as localhost to specify
that the server program is running on the same machine as the client;
that comes in handy for debugging servers without having to connect
to the Net. And again, the client's port number must match the
server's exactly. Note the nested parentheses again -- just
as in server <TT>bind</TT> calls, we really pass the
server's host/port address to <TT>connect</TT> in a
tuple object.
</P>
</DD>
</DL>

<P class="docText"><A NAME="IXT-10-337271"></A>Once
the client establishes a connection to the server, it falls into a
loop sending a message one line at a time and printing whatever the
server sends back after each line is sent:
</P>

<A NAME="IXT-10-337272"></A><A NAME="IXT-10-337273"></A><A NAME="IXT-10-337274"></A><A NAME="IXT-10-337275"></A><A NAME="IXT-10-337276"></A><A NAME="IXT-10-337277"></A><A NAME="IXT-10-337278"></A><DL class="docList">
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">sockobj.send(line)</span></span></span></DT>
<DD>
<P class="docList"><A NAME="IXT-10-337272"></A>
<A NAME="IXT-10-337273"></A>Transfers
the next message line to the server over the socket.
</P>
</DD><DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">data = sockobj.recv(1024)</span></span></span></DT>
<DD>
<P class="docList"><A NAME="IXT-10-337274"></A>
<A NAME="IXT-10-337275"></A>Reads
the next reply line sent by the server program. Technically, this
reads up to 1024 bytes of the next reply message and returns it as a
string.
</P>
</DD><DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">sockobj.close()</span></span></span></DT>
<DD>
<P class="docList"><A NAME="IXT-10-337276"></A>
<A NAME="IXT-10-337277"></A>
<A NAME="IXT-10-337278"></A>Closes
the connection with the server, sending it the end-of-file signal.
</P>
</DD>
</DL>

<P class="docText">And that's it. The server exchanges one or more lines of text
with each client that connects. The operating system takes care of
locating remote machines, routing bytes sent between programs across
the Internet, and (with TCP) making sure that our messages arrive
intact. That involves a lot of processing, too -- our strings may
ultimately travel around the world, crossing phone wires, satellite
links, and more along the way. But we can be happily ignorant of what
goes on beneath the socket call layer when programming in Python.
</P>

<P><table border="0" bgcolor="black" cellspacing="0" cellpadding="1" width="90%" align="center"><tr><td>
<table bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="6"><tr>
<td width="60" valign="top"><img src="FILES/tip_yellow.gif" width="50" height="54"></td>
<td valign="top">
<P class="docText">In older Python code, you may see
the <TT>AF_INET</TT> server address passed to the
server-side <TT>bind</TT> and client-side
<TT>connect</TT> socket methods as two distinct arguments,
instead of a two-item tuple:
</P>

<PRE>soc.bind(host,port)     vs soc.bind((host,port))
soc.connect(host,port)  vs soc.connect((host,port))</PRE>

<P class="docText">This two-argument form is now deprecated, and only worked at all due
to a shortcoming in earlier Python releases (unfortunately, the
Python library manual's socket example used the two-argument
form too!). The tuple server address form is preferred, and, in a
rare Python break with full backward-compatibility, will likely be
the only one that will work in future Python releases.
</P>
</td>
</tr></table></td></tr></table></P>



<A NAME="python2-CHP-10-SECT-3.1.3"></A>
<H5 class="docSection3Title">10.3.1.3 Running socket programs locally</H5>

<P class="docText"><A NAME="IXT-10-337279"></A>
<A NAME="IXT-10-337280"></A>
<A NAME="IXT-10-337281"></A>
<A NAME="IXT-10-337282"></A>Okay, let's put this
client and server to work. There are two ways to run these
scripts -- either on the same machine or on two different
machines. To run the client and the server on the same machine, bring
up two command-line consoles on your computer, start the server
program in one, and run the client repeatedly in the other. The
server keeps running and responds to requests made each time you run
the client script in the other window.
</P>

<P class="docText">For instance, here is the text that shows up in the MS-DOS console
window where I've started the server script:
</P>

<PRE>C:\...\PP2E\Internet\Sockets&gt;<B>python echo-server.py</B>
Server connected by ('127.0.0.1', 1025)
Server connected by ('127.0.0.1', 1026)
Server connected by ('127.0.0.1', 1027)</PRE>

<P class="docText">The output here gives the address (machine IP name and port number)
of each connecting client. Like most servers, this one runs
perpetually, listening for client connection requests. This one
receives three, but I have to show you the client window's text
for you to understand what this means:
</P>

<PRE>C:\...\PP2E\Internet\Sockets&gt;<B>python echo-client.py</B>
Client received: 'Echo=&gt;Hello network world'

C:\...\PP2E\Internet\Sockets&gt;<B>python echo-client.py localhost spam Spam SPAM</B>
Client received: 'Echo=&gt;spam'
Client received: 'Echo=&gt;Spam'
Client received: 'Echo=&gt;SPAM'

C:\...\PP2E\Internet\Sockets&gt;<B>python echo-client.py localhost Shrubbery</B>
Client received: 'Echo=&gt;Shrubbery'</PRE>

<P class="docText">Here, I ran the client script three times, while the server script
kept running in the other window. Each client connected to the
server, sent it a message of one or more lines of text, and read back
the server's reply -- an echo of each line of text sent from
the client. And each time a client is run, a new connection message
shows up in the server's window (that's why we got
three).
</P>

<P class="docText">It's important to notice that clients and server are running on
the same machine here (a Windows PC). The server and client agree on
port number, but use machine names "" and
"localhost" respectively, to refer to the computer that
they are running on. In fact, there is no Internet connection to
speak of. Sockets also work well as cross-program communications
tools on a single machine.
</P>



<A NAME="python2-CHP-10-SECT-3.1.4"></A>
<H5 class="docSection3Title">10.3.1.4 Running socket programs remotely</H5>

<P class="docText"><A NAME="IXT-10-337283"></A>
<A NAME="IXT-10-337284"></A>To make these scripts talk over the
Internet instead of on a single machine, we have to do some extra
work to run the server on a different computer. First, upload the
server's source file to a remote machine where you have an
account and a Python. Here's how I do it with FTP; your server
name and upload interface details may vary, and there are other ways
to copy files to a computer (e.g., email, web-page post forms,
etc.):<sup class="docFootnote"><A class="docLink" HREF="#">[3]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[3]</A></sup> The FTP command is standard on Windows
machines and most others. On Windows, simply type it in a DOS console
box to connect to an FTP server (or start your favorite FTP program);
on Linux, type the FTP command in an xterm window. You'll need
to supply your account name and password to connect to a
non-anonymous FTP site. For anonymous FTP, use
"anonymous" for the username and your email address for
the password (anonymous FTP sites are generally limited).</p></blockquote>

<PRE>C:\...\PP2E\Internet\Sockets&gt;<B>ftp starship.python.net</B>
Connected to starship.python.net.
User (starship.python.net:(none)): <B>lutz</B>
331 Password required for lutz.
Password:
230 User lutz logged in.
ftp&gt; <B>put echo-server.py</B>
200 PORT command successful.
150 Opening ASCII mode data connection for echo-server.py.
226 Transfer complete.
ftp: 1322 bytes sent in 0.06Seconds 22.03Kbytes/sec.
ftp&gt; <B>quit</B></PRE>

<P class="docText">Once you have the server program loaded on the other computer, you
need to run it there. Connect to that computer and start the server
program. I usually telnet into my server machine and start the server
program as a perpetually running process from the command
line.<sup class="docFootnote"><A class="docLink" HREF="#">[4]</A></sup>
The <TT>&amp;</TT> syntax in Unix/Linux shells can be used
to run the server script in the background; we could also make the
server directly executable with a <TT>#!</TT> line and a
<I>chmod</I> command (see <A class="docLink" HREF="0596000855_python2-CHP-2.html#python2-CHP-2">Chapter 2</A>,
for details). Here is the text that shows up in a Window on my PC
that is running a Telnet session connected to the Linux server where
I have an account (less a few deleted informational lines):
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[4]</A></sup> Telnet is a standard command on Windows and
Linux machines, too. On Windows, type it at a DOS console prompt or
in the Start/Run dialog box (it can also be started via a clickable
icon). Telnet usually runs in a window of its own.</p></blockquote>

<PRE>C:\...\PP2E\Internet\Sockets&gt;<B>telnet starship.python.net</B>
Red Hat Linux release 6.2 (Zoot)
Kernel 2.2.14-5.0smp on a 2-processor i686
login: <B>lutz</B>
Password:
[lutz@starship lutz]$ <B>python echo-server.py &amp;</B>
[1] 4098</PRE>

<P class="docText">Now that the server is listening for connections on the Net, run the
client on your local computer multiple times again. This time, the
client runs on a different machine than the server, so we pass in the
server's domain or IP name as a client command-line argument.
The server still uses a machine name of "" because it
always listens on whatever machine it runs upon. Here is what shows
up in the server's Telnet window:
</P>

<PRE>[lutz@starship lutz]$ Server connected by ('166.93.68.61', 1037)
Server connected by ('166.93.68.61', 1040)
Server connected by ('166.93.68.61', 1043)
Server connected by ('166.93.68.61', 1050)</PRE>

<P class="docText">And here is what appears in the MS-DOS console box where I run the
client. A "connected by" message appears in the server
Telnet window each time the client script is run in the client
window:
</P>

<PRE>C:\...\PP2E\Internet\Sockets&gt;<B>python echo-client.py starship.python.net</B>
Client received: 'Echo=&gt;Hello network world'

C:\...\PP2E\Internet\Sockets&gt;<B>python echo-client.py starship.python.net ni Ni NI</B>
Client received: 'Echo=&gt;ni'
Client received: 'Echo=&gt;Ni'
Client received: 'Echo=&gt;NI'

C:\...\PP2E\Internet\Sockets&gt;<B>python echo-client.py starship.python.net Shrubbery</B>
Client received: 'Echo=&gt;Shrubbery'

C:\...\PP2E\Internet\Sockets&gt;<B>ping starship.python.net</B>
Pinging starship.python.net [208.185.174.112] with 32 bytes of data:
Reply from 208.185.174.112: bytes=32 time=311ms TTL=246
<B>ctrl-C</B>
C:\...\PP2E\Internet\Sockets&gt;<B>python echo-client.py 208.185.174.112 Does she?</B>
Client received: 'Echo=&gt;Does'
Client received: 'Echo=&gt;she?'</PRE>

<P class="docText"><A NAME="IXT-10-337285"></A>The
"ping" command can be used to get an IP address for a
machine's domain name; either machine name form can be used to
connect in the client. This output is perhaps a bit
understated -- a lot is happening under the hood. The client,
running on my Windows laptop, connects with and talks to the server
program running on a Linux machine perhaps thousands of miles away.
It all happens about as fast as when client and server both run on
the laptop, and it uses the same library calls; only the server name
passed to clients differs.
</P>



<A NAME="python2-CHP-10-SECT-3.1.5"></A>
<H5 class="docSection3Title">10.3.1.5 Socket pragmatics</H5>

<P class="docText"><A NAME="IXT-10-337286"></A>Before we move on,
there are three practical usage details you should know. First of
all, you can run the client and server like this on any two
Internet-aware machines where Python is installed. Of course, to run
clients and server on different computers, you need both a live
Internet connection and access to another machine on which to run the
server. You don't need a big, expensive Internet link,
though -- a simple modem and dialup Internet account will do for
clients. When sockets are opened, Python is happy to use whatever
connectivity you have, be it a dedicated T1 line, or a dialup modem
account.
</P>

<P class="docText">On my laptop PC, for instance, Windows automatically dials out to my
ISP when clients are started or when Telnet server sessions are
opened. In this book's examples, server-side programs that run
remotely are executed on a machine called <span class="docEmphasis">starship.python.net</span>. If you don't have
an account of your own on such a server, simply run client and server
examples on the same machine, as shown earlier; all you need then is
a computer that allows sockets, and most do.
</P>

<P class="docText"><A NAME="IXT-10-337287"></A>Secondly, the socket module generally
raises exceptions if you ask for something invalid. For instance,
trying to connect to a nonexistent server (or unreachable servers, if
you have no Internet link) fails:
</P>

<PRE>C:\...\PP2E\Internet\Sockets&gt;<B>python echo-client.py www.nonesuch.com hello</B>
Traceback (innermost last):
  File "echo-client.py", line 24, in ?
    sockobj.connect((serverHost, serverPort))   # connect to server machine... 
  File "&lt;string&gt;", line 1, in connect
socket.error: (10061, 'winsock error')</PRE>

<P class="docText">Finally, also be sure to kill the server process before restarting it
again, or else the port number will be still in use, and you'll
get another exception:
</P>

<PRE>[lutz@starship uploads]$ <B>ps -x</B>
  PID TTY      STAT   TIME COMMAND
 5570 pts/0    S      0:00 -bash
 5570 pts/0    S      0:00 -bash
<B> 5633 pts/0    S      0:00 python echo-server.py</B>
 5634 pts/0    R      0:00 ps -x
[lutz@starship uploads]$ <B>python echo-server.py</B>
Traceback (most recent call last):
  File "echo-server.py", line 14, in ?
    sockobj.bind((myHost, myPort))               # bind it to server port number
socket.error: (98, 'Address already in use')</PRE>

<P class="docText"><A NAME="IXT-10-337288"></A>Under Python 1.5.2, a series of
Ctrl-C's will kill the server on Linux (be sure to type
<I>fg</I> to bring it to the foreground first if started
with an <TT>&amp;</TT>):
</P>

<PRE>[lutz@starship uploads]$ <B>python echo-server.py</B>
<B>ctrl-c</B>
Traceback (most recent call last):
  File "echo-server.py", line 18, in ?
    connection, address = sockobj.accept()   # wait for next client connect
KeyboardInterrupt</PRE>

<P class="docText"><A NAME="IXT-10-337289"></A>A Ctrl-C kill key combination
won't kill the server on my Windows machine, however. To kill
the perpetually running server process running locally on Windows,
you may need to type a Ctrl-Alt-Delete key combination, and then end
the Python task by selecting it in the process listbox that appears.
You can usually also kill a server on Linux with a
<TT>kill</TT> <TT>-9</TT>
<TT><I>pid</I></TT> shell command if it is running in
another window or in the background, but Ctrl-C is less typing.
</P>



<A NAME="python2-CHP-10-SECT-3.1.6"></A>
<H5 class="docSection3Title">10.3.1.6 Spawning clients in parallel</H5>

<P class="docText"><A NAME="IXT-10-337290"></A>To see how the server handles the
load, let's fire up eight copies of the client script in
parallel using the script in <A class="docLink" HREF="#python2-CHP-10-EX-3">Example 10-3</A> (see the
end of <A class="docLink" HREF="0596000855_python2-CHP-3.html#python2-CHP-3">Chapter 3</A>, for details on the
<TT>launchmodes</TT> module used here to spawn clients).
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-10-EX-3"></A>Example 10-3. PP2E\Internet\Sockets\testecho.py </H5>
<PRE>import sys, string
from PP2E.launchmodes import QuietPortableLauncher

numclients = 8
def start(cmdline): QuietPortableLauncher(cmdline, cmdline)()

# start('echo-server.py')              # spawn server locally if not yet started

args = string.join(sys.argv[1:], ' ')  # pass server name if running remotely
for i in range(numclients):
    start('echo-client.py %s' % args)  # spawn 8? clients to test the server</PRE>


<P class="docText">To run this script, pass no arguments to talk to a server listening
on port 50007 on the local machine; pass a real machine name to talk
to a server running remotely. On Windows, the clients' output
is discarded when spawned from this script:
</P>

<PRE>C:\...\PP2E\Internet\Sockets&gt;python testecho.py

C:\...\PP2E\Internet\Sockets&gt;python testecho.py starship.python.net</PRE>

<P class="docText">If the spawned clients connect to a server run locally, connection
messages show up in the server's window on the local machine:
</P>

<PRE>C:\...\PP2E\Internet\Sockets&gt;<B>python echo-server.py</B>
Server connected by ('127.0.0.1', 1283)
Server connected by ('127.0.0.1', 1284)
Server connected by ('127.0.0.1', 1285)
Server connected by ('127.0.0.1', 1286)
Server connected by ('127.0.0.1', 1287)
Server connected by ('127.0.0.1', 1288)
Server connected by ('127.0.0.1', 1289)
Server connected by ('127.0.0.1', 1290)</PRE>

<P class="docText">If the server is running remotely, the client connection messages
instead appear in the window displaying the Telnet connection to the
remote computer:
</P>

<PRE>[lutz@starship lutz]$ <B>python echo-server.py</B>
Server connected by ('166.93.68.61', 1301)
Server connected by ('166.93.68.61', 1302)
Server connected by ('166.93.68.61', 1308)
Server connected by ('166.93.68.61', 1309)
Server connected by ('166.93.68.61', 1313)
Server connected by ('166.93.68.61', 1314)
Server connected by ('166.93.68.61', 1307)
Server connected by ('166.93.68.61', 1312)</PRE>

<P class="docText">Keep in mind, however, that this works for our simple scripts only
because the server doesn't take a long time to respond to each
client's requests -- it can get back to the top of the
server script's outer <TT>while</TT> loop in time to
process the next incoming client. If it could not, we would probably
need to change the server to handle each client in parallel, or some
might be denied a connection. Technically, client connections would
fail after five clients are already waiting for the server's
attention, as specified in the server's
<TT>listen</TT> call. We'll see how servers can
handle multiple clients robustly in the next section.
</P>



<A NAME="python2-CHP-10-SECT-3.1.7"></A>
<H5 class="docSection3Title">10.3.1.7 Talking to reserved ports</H5>

<P class="docText"><A NAME="IXT-10-337291"></A>It's also important to know that this
client and server engage in a proprietary sort of discussion, and so
use a port number 50007 outside the range reserved for standard
protocols (0-1023). There's nothing preventing a client from
opening a socket on one of these special ports, however. For
instance, the following client-side code connects to programs
listening on the standard email, FTP, and HTTP web server ports on
three different server machines:
</P>

<PRE>C:\...\PP2E\Internet\Sockets&gt;python
&gt;&gt;&gt; <B>from socket import *</B>
&gt;&gt;&gt; <B>sock = socket(AF_INET, SOCK_STREAM)</B>
&gt;&gt;&gt; <B>sock.connect(('mail.rmi.net', 110)) </B>        # talk to RMI POP mail server
&gt;&gt;&gt; <B>print sock.recv(40)</B>
+OK Cubic Circle's v1.31 1998/05/13 POP3
&gt;&gt;&gt; <B>sock.close()</B>

&gt;&gt;&gt; <B>sock = socket(AF_INET, SOCK_STREAM)</B>
&gt;&gt;&gt; <B>sock.connect(('www.python.org', 21))  </B>      # talk to Python FTP server
&gt;&gt;&gt; <B>print sock.recv(40)</B>
220 python.org FTP server (Version wu-2.
&gt;&gt;&gt; <B>sock.close()</B>

&gt;&gt;&gt; <B>sock = socket(AF_INET, SOCK_STREAM)</B>
&gt;&gt;&gt; <B>sock.connect(('starship.python.net', 80))  </B> # starship HTTP web server
&gt;&gt;&gt; <B>sock.send('GET /\r\n')  </B>                    # fetch root web page
7
&gt;&gt;&gt; <B>sock.recv(60)</B>
'&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;\012&lt;HTM'
&gt;&gt;&gt; <B>sock.recv(60)</B>
'L&gt;\012 &lt;HEAD&gt;\012  &lt;TITLE&gt;Starship Slowly Recovering&lt;/TITLE&gt;\012 &lt;/HE'</PRE>

<P class="docText">If we know how to interpret the output returned by these ports'
servers, we could use raw sockets like this to fetch email, transfer
files, and grab web pages and invoke server-side scripts.
Fortunately, though, we don't have to worry about all the
underlying details -- Python's <TT>poplib</TT>,
<TT>ftplib</TT>, <TT>httplib</TT>, and
<TT>urllib</TT> modules provide higher-level interfaces for
talking to servers on these ports. Other Python protocol modules do
the same for other standard ports (e.g., NNTP, Telnet, and so on).
We'll meet some of these client-side protocol modules in the
next chapter.<sup class="docFootnote"><A class="docLink" HREF="#">[5]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[5]</A></sup> <A NAME="IXT-10-337292"></A>
<A NAME="IXT-10-337293"></A>
<A NAME="IXT-10-337294"></A>You might be
interested to know that the last part of this example, talking to
port 80, is exactly what your web browser does as you surf the Net:
followed links direct it to download web pages over this port. In
fact, this lowly port is the primary basis of the Web. In <A class="docLink" HREF="0596000855_python2-CHP-12.html#python2-CHP-12">Chapter 12</A>, we will meet an entire application
environment based upon sending data over port 80 -- CGI
server-side scripting. </p></blockquote>

<P class="docText">By the way, it's okay to open client-side connections on
reserved ports like this, but you can't install your own
server-side scripts for these ports unless you have special
permission:<A NAME="IXT-10-337295"></A>
<A NAME="IXT-10-337296"></A>
</P>

<PRE>[lutz@starship uploads]$ python
&gt;&gt;&gt; <B>from socket import *</B>
&gt;&gt;&gt; <B>sock = socket(AF_INET, SOCK_STREAM)</B>
&gt;&gt;&gt; <B>sock.bind(('', 80))</B>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
socket.error: (13, 'Permission denied')</PRE>

<P class="docText">Even if run by a user with the required permission, you'll get
the different exception we saw earlier if the port is already being
used by a real web server. On computers being used as general
servers, these ports really are reserved.<A NAME="IXTR3-162"></A> <A NAME="IXTR3-163"></A>
</P>




<a href="0596000855_"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
          <a href="0596000855_python2-CHP-10-SECT-2.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596000855_python2-CHP-10-SECT-4.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
