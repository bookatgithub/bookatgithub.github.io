<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="11.2 Transferring Files over the Net"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
	<a href="0596000855_python2-CHP-11-SECT-1.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596000855_python2-CHP-11-SECT-3.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="python2-CHP-11-SECT-2"></A>
<H3 class="docSection1Title">11.2 Transferring Files over the Net</H3>

<P class="docText"><A NAME="python2-IDXTERM-752"></A> <A NAME="python2-IDXTERM-753"></A> <A NAME="python2-IDXTERM-754"></A> <A NAME="python2-IDXTERM-755"></A> <A NAME="python2-IDXTERM-756"></A>As we saw in the
previous chapter, sockets see plenty of action on the Net. For
instance, the <TT>getfile</TT> example at the end of that
chapter allowed us to transfer entire files between machines. In
practice, though, higher-level protocols are behind much of what
happens on the Net. Protocols run on top of sockets, but hide much of
the complexity of the network scripting examples we've just
seen.
</P>

<P class="docText"><A NAME="IXT-11-337345"></A>FTP -- the File Transfer
Protocol -- is one of the more commonly used Internet protocols.
It defines a higher-level conversation model that is based on
exchanging command strings and file contents over sockets. By using
FTP, we can accomplish the same task as the prior chapter's
<TT>getfile</TT> script, but the interface is simpler, and
standard -- FTP lets us ask for files from any server machine that
supports FTP, without requiring that it run our custom
<TT>getfile</TT> script. FTP also supports more advanced
operations such as uploading files to the server, getting remote
directory listings, and more.
</P>

<P class="docText">Really, FTP runs on top of two sockets: one for passing control
commands between client and server (port 21), and another for
transferring bytes. By using a two-socket model, FTP avoids the
possibility of deadlocks (i.e., transfers on the data socket do not
block dialogs on the control socket). Ultimately, though,
Python's <TT>ftplib</TT> support module allows us to
upload and download files at a remote server machine by FTP, without
dealing in raw socket calls or FTP protocol details.
</P>

<A NAME="python2-CHP-11-SECT-2.1"></A>
<H4 class="docSection2Title">11.2.1 FTP: Fetching Python with Python</H4>

<P class="docText"><A NAME="python2-IDXTERM-758"></A>
<A NAME="python2-IDXTERM-759"></A>
<A NAME="python2-IDXTERM-760"></A>Because
the Python FTP interface is so easy to use, let's jump right
into a realistic example. The script in <A class="docLink" HREF="#python2-CHP-11-EX-1">Example 11-1</A>
automatically fetches and builds Python with Python. No, this
isn't a recursive chicken-and-egg thought exercise -- you
must already have installed Python to run this program. More
specifically, this Python script does the following:
</P>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">Downloads the Python source distribution by FTP</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Unpacks and compiles the distribution into a Python executable</P></span></LI>
</OL></span>
<P class="docText">The download portion will run on any machine with Python and sockets;
the unpacking and compiling code assumes a Unix-like build
environment as coded here, but could be tweaked to work with other
platforms.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-11-EX-1"></A>Example 11-1. PP2E\Internet\Ftp\getpython.py </H5>
<PRE>#!/usr/local/bin/python
###############################################################
# A Python script to download and build Python's source code.
# Uses ftplib, the ftp protocol handler which uses sockets.
# Ftp runs on 2 sockets (one for data, one for control--on
# ports 20 and 21) and imposes message text formats, but the 
# Python ftplib module hides most of this protocol's details.
###############################################################

import os
from ftplib import FTP                   # socket-based ftp tools
Version = '1.5'                          # version to download
tarname = 'python%s.tar.gz' % Version    # remote/local file name
 
print 'Connecting...'
localfile  = open(tarname, 'wb')         # where to store download
connection = FTP('ftp.python.org')       # connect to ftp site
connection.login()                       # default is anonymous login
connection.cwd('pub/python/src')         # xfer 1k at a time to localfile

print 'Downloading...'
connection.retrbinary('RETR ' + tarname, localfile.write, 1024)
connection.quit()
localfile.close()
 
print 'Unpacking...'
os.system('gzip -d '  + tarname)         # decompress
os.system('tar -xvf ' + tarname[:-3])    # strip .gz 

print 'Building...'
os.chdir('Python-' + Version)            # build Python itself
os.system('./configure')                 # assumes unix-style make
os.system('make')
os.system('make test')
print 'Done: see Python-%s/python.' % Version</PRE>


<P class="docText">Most of the FTP protocol details are encapsulated by the Python
<TT>ftplib</TT> module imported here. This script uses some
of the simplest interfaces in <TT>ftplib</TT> (we'll
see others in a moment), but they are representative of the module in
general:
</P>

<PRE>connection = FTP('ftp.python.org')       # connect to ftp site</PRE>

<P class="docText"><A NAME="IXT-11-337346"></A>
<A NAME="IXT-11-337347"></A>To
open a connection to a remote (or local) FTP server, create an
instance of the <TT>ftplib.FTP</TT> object, passing in the
name (domain or IP-style) of the machine you wish to connect to.
Assuming this call doesn't throw an exception, the resulting
FTP object exports methods that correspond to the usual FTP
operations. In fact, Python scripts act much like typical FTP client
programs -- just replace commands you would normally type or
select with method calls:
</P>

<PRE>connection.login()                       # default is anonymous login
connection.cwd('pub/python/src')         # xfer 1k at a time to localfile</PRE>

<P class="docText">Once connected, we log in, and go to the remote directory we want to
fetch a file from. The <TT>login</TT> method allows us to
pass in additional optional arguments to specify a username and
password; by default it performs anonymous FTP:
</P>

<PRE>connection.retrbinary('RETR ' + tarname, localfile.write, 1024)
connection.quit()</PRE>

<P class="docText">Once we're in the target directory, we simply call the
<TT>retrbinary</TT> method to download the target server
file in binary mode. The <TT>retrbinary</TT> call will take
awhile to complete, since it must download a big file. It gets three
arguments:<A NAME="IXT-11-337348"></A>
<A NAME="IXT-11-337349"></A>
<A NAME="IXT-11-337350"></A>
<A NAME="IXT-11-337351"></A>
</P>

<UL>
<LI><P class="docList">An FTP command string -- here, a string <TT>RETR</TT>
<TT><I>filename</I></TT>, which is the standard format for
FTP retrievals.
</P></LI>
<LI><P class="docList">A function or method to which Python passes each chunk of the
downloaded file's bytes -- here, the
<TT>write</TT> method of a newly created and opened local
file.
</P></LI>
<LI><P class="docList">A size for those chunks of bytes -- here, 1024 bytes are
downloaded at a time, but the default is reasonable if this argument
is omitted.
</P></LI>
</UL>
<P class="docText">Because this script creates a local file named
<TT>localfile</TT>, of the same name as the remote file
being fetched, and passes its <TT>write</TT> method to the
FTP retrieval method, the remote file's contents will
automatically appear in a local, client-side file after the download
is finished. By the way, notice that this file is opened in
"wb" binary output mode; if this script is run on
Windows, we want to avoid automatically expanding and
<TT>\n</TT> bytes into <TT>\r\n</TT> byte
sequences (that happens automatically on Windows when writing files
opened in "w" text mode).
</P>

<P class="docText">Finally, we call the FTP <TT>quit</TT> method to break the
connection with the server and manually <TT>close</TT> the
local file to force it to be complete before it is further processed
by the shell commands spawned by <TT>os.system</TT>
(it's not impossible that parts of the file are still held in
buffers before the <TT>close</TT>
call):<A NAME="IXT-11-337352"></A>
<A NAME="IXT-11-337353"></A>
<A NAME="IXT-11-337354"></A>
<A NAME="IXT-11-337355"></A>
</P>

<PRE>connection.quit()
localfile.close()</PRE>

<P class="docText">And that's all there is to it; all the FTP, socket, and
networking details are hidden behind the <TT>ftplib</TT>
interface module. Here is this script in action on a Linux machine,
with a couple thousand output lines cut in the interest of brevity:
</P>

<PRE>[lutz@starship test]$ <B>python getpython.py </B>
Connecting...
Downloading...
Unpacking...
Python-1.5/
Python-1.5/Doc/
Python-1.5/Doc/ref/
Python-1.5/Doc/ref/.cvsignore
Python-1.5/Doc/ref/fixps.py
...
<I> ...lots of tar lines deleted...</I>
...
Python-1.5/Tools/webchecker/webchecker.py
Python-1.5/Tools/webchecker/websucker.py
Building...
creating cache ./config.cache
checking MACHDEP... linux2
checking CCC...
checking for --without-gcc... no
checking for gcc... gcc
...
<I> ...lots of build lines deleted...</I>
...
Done: see Python-1.5/python.

[lutz@starship test]$ <B>cd Python-1.5/ </B>
[lutz@starship Python-1.5]$ <B>./python </B>
Python 1.5 (#1, Jul 12 2000, 12:35:52)  [GCC egcs-2.91.66 19990314/Li on linux2
Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam
&gt;&gt;&gt; print 'The Larch!'
The Larch!</PRE>

<P class="docText">Such a script could be automatically executed at regular intervals
(e.g., by a Unix <span class="docEmphasis">cron</span> job) to update a local
Python install with a fresh build. But the thing to notice here is
that this otherwise typical Python script fetches information from an
arbitrarily remote FTP site and machine. Given an Internet link, any
information published by an FTP server on the Net can be fetched by
and incorporated into Python scripts using interfaces such as these.
</P>

<A NAME="python2-CHP-11-SECT-2.1.1"></A>
<H5 class="docSection3Title">11.2.1.1 Using urllib to FTP files</H5>

<P class="docText"><A NAME="python2-IDXTERM-771"></A><A NAME="python2-IDXTERM-772"></A>
<A NAME="python2-IDXTERM-773"></A>
<A NAME="python2-IDXTERM-774"></A>In fact, FTP is just one way to transfer
information across the Net, and there are more general tools in the
Python library to accomplish the prior script's download.
Perhaps the most straightforward is the Python
<TT>urllib</TT> module: given an Internet address
string -- a URL, or Universal Resource Locator -- this module
opens a connection to the specified server and returns a file-like
object ready to be read with normal file object method calls (e.g.,
<TT>read</TT>, <TT>readlines</TT>).
</P>

<P class="docText">We can use such a higher-level interface to download anything with an
address on the Web -- files published by FTP sites (using URLs
that start with "ftp://"), web pages and outputs of
scripts that live on remote servers (using "http://"
URLs), local files (using "file://" URLs), Gopher server
data, and more. For instance, the script in <A class="docLink" HREF="#python2-CHP-11-EX-2">Example 11-2</A> does the same as the one in <A class="docLink" HREF="#python2-CHP-11-EX-1">Example 11-1</A>, but it uses the general
<TT>urllib</TT> module to fetch the source distribution
file, instead of the protocol-specific <TT>ftplib</TT>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-11-EX-2"></A>Example 11-2. PP2E\Internet\Ftp\getpython-urllib.py </H5>
<PRE>#!/usr/local/bin/python
###################################################################
# A Python script to download and build Python's source code
# use higher-level urllib instead of ftplib to fetch file
# urllib supports ftp, http, and gopher protocols, and local files
# urllib also allows downloads of html pages, images, text, etc.;
# see also Python html/xml parsers for web pages fetched by urllib;
###################################################################

import os
import urllib                           # socket-based web tools
Version = '1.5'                         # version to download
tarname = 'python%s.tar.gz' % Version   # remote/local file name
 
remoteaddr = 'ftp://ftp.python.org/pub/python/src/' + tarname
print 'Downloading', remoteaddr

# this works too:
# urllib.urlretrieve(remoteaddr, tarname)

remotefile = urllib.urlopen(remoteaddr)     # returns input file-like object
localfile  = open(tarname, 'wb')            # where to store data locally
localfile.write(remotefile.read())
localfile.close()
remotefile.close()
 
# the rest is the same
execfile('buildPython.py')</PRE>


<P class="docText">Don't sweat the details of the URL string used here;
we'll talk much more about URLs in the next chapter.
We'll also use <TT>urllib</TT> again in this and
later chapters to fetch web pages, format generated URL strings, and
get the output of remote scripts on the Web.<sup class="docFootnote"><A class="docLink" HREF="#">[1]</A></sup> Technically
speaking, <TT>urllib</TT> supports a variety of Internet
protocols (HTTP, FTP, Gopher, and local files), is only used for
reading remote objects (not writing or uploading them), and
retrievals must generally be run in threads if blocking is a concern.
But the basic interface shown in this script is straightforward. The
call:
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[1]</A></sup> For more
<TT>urllib</TT> download examples, see the section on HTTP
in this chapter. In bigger terms, tools like
<TT>urllib.urlopen</TT> allow scripts to both download
remote files and invoke programs that are located on a remote server
machine. In <A class="docLink" HREF="0596000855_python2-CHP-12.html#python2-CHP-12">Chapter 12</A>, we'll also see that
<TT>urllib</TT> includes tools for formatting (escaping)
URL strings for safe transmission. </p></blockquote>

<PRE>remotefile = urllib.urlopen(remoteaddr)     # returns input file-like object</PRE>

<P class="docText">contacts the server named in the <TT>remoteaddr</TT> URL
string and returns a file-like object connected to its download
stream (an FTP-based socket). Calling this file's
<TT>read</TT> method pulls down the file's contents,
which are written to a local client-side file. An even simpler
interface:
</P>

<A NAME="IXT-11-337356"></A><PRE>urllib.urlretrieve(remoteaddr, tarname)</PRE>

<P class="docText">also does the work of opening a local file and writing the downloaded
bytes into it -- things we do manually in the script as coded.
This comes in handy if we mean to download a file, but is less useful
if we want to process its data immediately.
</P>

<P class="docText">Either way, the end result is the same: the desired server file shows
up on the client machine. The remainder of the script -- unpacking
and building -- is identical to the original version, so
it's been moved to a reusable Python file run with the
<TT>execfile</TT> built-in (recall that
<TT>execfile</TT> runs a file as though its code were
pasted into the place where the <TT>execfile</TT> appears).
The script is shown in <A class="docLink" HREF="#python2-CHP-11-EX-3">Example 11-3</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-11-EX-3"></A>Example 11-3. PP2E\Internet\Ftp\buildPython.py </H5>
<PRE>#!/usr/local/bin/python
###############################################################
# A Python script to build Python from its source code.
# Run me in directory where Python source distribution lives.
###############################################################

import os
Version = '1.5'                         # version to build
tarname = 'python%s.tar.gz' % Version   # remote/local file name
 
print 'Unpacking...'
os.system('gzip -d '  + tarname)        # decompress file
os.system('tar -xvf ' + tarname[:-3])   # untar without '.gz'

print 'Building...'
os.chdir('Python-' + Version)           # build Python itself
os.system('./configure')                # assumes unix-style make
os.system('make')
os.system('make test')
print 'Done: see Python-%s/python.' % Version</PRE>


<P class="docText">The output this time is almost identical to the output of <A class="docLink" HREF="#python2-CHP-11-EX-1">Example 11-1</A>, so I'll show only a few portions (the
<TT>gzip</TT> message appears if you don't delete a
tar file left by a run in the past):
</P>

<PRE>[lutz@starship test]$ <B>python getpython-urllib.py </B>
Downloading ftp://ftp.python.org/pub/python/src/python1.5.tar.gz
Unpacking...
gzip: python1.5.tar already exists; do you wish to overwrite (y or n)? y
<I> ...tar lines... </I>
Building...
<I> ...build lines...</I>
Done: see Python-1.5/python.

[lutz@starship test]$ <B>python buildPython.py </B>
Unpacking...
<I> ...tar and build lines...</I></PRE>

<P class="docText">In fact, although the original script is all top-level code that runs
immediately and accomplishes only one task, there really are two
potentially reusable activities within it: fetching a file and
building Python from source. By splitting each part off into a module
of its own, we can reuse its program logic in other contexts, which
naturally leads us to the topic in the next section.<A NAME="IXTR3-192"></A> <A NAME="IXTR3-193"></A> <A NAME="IXTR3-194"></A><A NAME="IXTR3-195"></A>
</P>



<A NAME="python2-CHP-11-SECT-2.2"></A>
<H4 class="docSection2Title">11.2.2 FTP get and put Utilities</H4>

<P class="docText">Almost invariably, when I present the <TT>ftplib</TT>
interfaces in Python classes, students ask why programmers need to
supply the RETR string in the retrieval method. It's a good
question -- the RETR string is the name of the download command in
the FTP protocol, but <TT>ftplib</TT> is supposed to
encapsulate that protocol. As we'll see in a moment, we have to
supply an arguably odd STOR string for uploads as well. It's
boilerplate code that you accept on faith once you see it, but that
begs the question. You could always email Guido a proposed
<TT>ftplib</TT> patch, but that's not really a good
answer for beginning Python students.<sup class="docFootnote"><A class="docLink" HREF="#">[2]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[2]</A></sup> This is one
point in the class where I also usually threaten to write
Guido's home phone number on the whiteboard. But that's
generally an empty promise made just for comic effect. If you do want
to discuss Python language issues, Guido's email address, as
well as contact points for other Python core developers, are readily
available on the Net. As someone who's gotten anonymous
Python-related calls at home, I never do give out phone numbers (and
dialing 1-800-Hi-Guido is only funny the first time).</p></blockquote>

<P class="docText">A better answer is that there is no law against extending the
standard library modules with higher-level interfaces of our
own -- with just a few lines of reusable code, we can make the FTP
interface look any way we want in Python. For instance, we could,
once and for all, write utility modules that wrap the
<TT>ftplib</TT> interfaces to hide the RETR string. If we
place these utility modules in a directory on PYTHONPATH, they become
just as accessible as <TT>ftplib</TT> itself, automatically
reusable in any Python script we write in the future. Besides
removing the RETR string requirement, a wrapper module could also
make assumptions that simplify FTP operations into single function
calls.
</P>

<P class="docText">For instance, given a module that encapsulates and simplifies
<TT>ftplib</TT>, our Python fetch-and-build script could be
further reduced to the script shown in <A class="docLink" HREF="#python2-CHP-11-EX-4">Example 11-4</A>
 -- essentially just a function call and file execution.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-11-EX-4"></A>Example 11-4. PP2E\Internet\Ftp\getpython-modular.py </H5>
<PRE>#!/usr/local/bin/python
################################################################
# A Python script to download and build Python's source code.
# Uses getfile.py, a utility module which encapsulates ftp step.
################################################################

import getfile
Version = '1.5'                         # version to download
tarname = 'python%s.tar.gz' % Version   # remote/local file name

# fetch with utility 
getfile.getfile(tarname, 'ftp.python.org', 'pub/python/src')

# rest is the same
execfile('buildPython.py')</PRE>


<P class="docText">Besides having a line count that is much more impressive to
marketeers, the meat of this script has been split off into files for
reuse elsewhere. If you ever need to download a file again, simply
import an existing function rather than copying code with
cut-and-paste editing. Changes in download operations would need to
be made in only one file, not everywhere we've copied
boilerplate code; <TT>getfile.getfile</TT> could even be
changed to use <TT>urllib</TT> instead of
<TT>ftplib</TT> without effecting any of its clients.
It's good engineering.
</P>

<A NAME="python2-CHP-11-SECT-2.2.1"></A>
<H5 class="docSection3Title">11.2.2.1 Download utility</H5>

<P class="docText">So just how would we go about writing such an FTP interface wrapper
(he asks, knowingly)? Given the <TT>ftplib</TT> library
module, wrapping downloads of a particular file in a particular
directory is straightforward. Connected FTP objects support two
download methods:
</P>

<UL>
<LI><P class="docList"><A NAME="IXT-11-337357"></A>
<A NAME="IXT-11-337358"></A>
<A NAME="IXT-11-337359"></A>The
<TT>retrbinary</TT> method downloads the requested file in
binary mode, sending its bytes in chunks to a supplied function,
without line-feed mapping. Typically, the supplied function is a
write method of an open local file object, such that the bytes are
placed in the local file on the client.
</P></LI>
<LI><P class="docList">The <TT>retrlines</TT> method downloads the requested file
in ASCII text mode, sending each line of text to a supplied function
with all end-of-line characters stripped. Typically, the supplied
function adds a <TT>\n</TT> newline (mapped appropriately
for the client machine), and writes the line to a local file.
</P></LI>
</UL>
<P class="docText">We will meet the <TT>retrlines</TT> method in a later
example; the <TT>getfile</TT> utility module in <A class="docLink" HREF="#python2-CHP-11-EX-5">Example 11-5</A> transfers in binary mode always with
<TT>retrbinary</TT>. That is, files are downloaded exactly
as they were on the server, byte for byte, with the server's
line-feed conventions in text files. You may need to convert
line-feeds after downloads if they look odd in your text
editor -- see the converter tools in <A class="docLink" HREF="0596000855_python2-CHP-5.html#python2-CHP-5">Chapter 5</A>,
for pointers.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-11-EX-5"></A>Example 11-5. PP2E\Internet\Ftp\getfile.py </H5>
<PRE>#!/usr/local/bin/python
################################################# 
# Fetch an arbitrary file by ftp.  Anonymous 
# ftp unless you pass a user=(name, pswd) tuple.
# Gets the Monty Python theme song by default.
#################################################
 
from ftplib  import FTP          # socket-based ftp tools
from os.path import exists       # file existence test

file = 'sousa.au'                # default file coordinates
site = 'ftp.python.org'          # monty python theme song
dir  = 'pub/python/misc'

def getfile(file=file, site=site, dir=dir, user=(), verbose=1, force=0):
    """
    fetch a file by ftp from a site/directory
    anonymous or real login, binary transfer
    """
    if exists(file) and not force:
        if verbose: print file, 'already fetched'
    else:
        if verbose: print 'Downloading', file
        local = open(file, 'wb')                # local file of same name
        try:
            remote = FTP(site)                  # connect to ftp site
            apply(remote.login, user)           # anonymous=() or (name, pswd)
            remote.cwd(dir)
            remote.retrbinary('RETR ' + file, local.write, 1024)
            remote.quit()
        finally:
            local.close()                       # close file no matter what
        if verbose: print 'Download done.'      # caller handles exceptions

if __name__ == '__main__': getfile()            # anonymous python.org login</PRE>


<P class="docText">This module is mostly just a repackaging of the FTP code we used to
fetch the Python source distribution earlier, to make it simpler and
reusable. Because it is a callable function, the exported
<TT>getfile.getfile</TT> here tries to be as robust and
generally useful as possible, but even a function this small implies
some design decisions. Here are a few usage notes:
</P>

<A NAME="IXT-11-337360"></A><DL class="docList">
<DT><I><span class="docPubcolor">FTP mode </span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-11-337360"></A>The
<TT>getfile</TT> function in this script runs in anonymous
FTP mode by default, but a two-item tuple containing a username and
password string may be passed to the <TT>user</TT> argument
to log in to the remote server in non-anonymous mode. To use
anonymous FTP, either don't pass the user argument or pass it
an empty tuple, <TT>()</TT>. The FTP object
<TT>login</TT> method allows two optional arguments to
denote a username and password, and the <TT>apply</TT> call
in <A class="docLink" HREF="#python2-CHP-11-EX-5">Example 11-5</A> sends it whatever argument tuple you
pass to <TT>user</TT>.
</P>
</DD><DT><I><span class="docPubcolor">Processing modes </span></I></DT>
<DD>
<P class="docList">If passed, the last two arguments (<TT>verbose</TT>,
<TT>force</TT>) allow us to turn off status messages
printed to the <TT>stdout</TT> stream (perhaps undesirable
in a GUI context) and force downloads to happen even if the file
already exists locally (the download overwrites the existing local
file).
</P>
</DD><DT><span class="docPubcolor"><span class="docEmphasis">Exception protocol</span></span></DT>
<DD>
<P class="docList">The caller is expected to handle exceptions; this function wraps
downloads in a <TT>try</TT>/<TT>finally</TT>
statement to guarantee that the local output file is closed, but lets
exceptions propagate. If used in a GUI or run from a thread, for
instance, exceptions may require special handling unknown in this
file.
</P>
</DD><DT><span class="docPubcolor"><span class="docEmphasis">Self-test</span></span></DT>
<DD>
<P class="docList">If run standalone, this file downloads a
<span class="docEmphasis">sousa.au</span> audio file from
<A class="docLink" target="_blank" HREF="http://www.python.org/default.htm">http://www.python.org</A> as a self-test, but the
function will normally be passed FTP filenames, site names, and
directory names as well.
</P>
</DD><DT><span class="docPubcolor"><span class="docEmphasis">File mode</span></span></DT>
<DD>
<P class="docList">This script is careful to open the local output file in
"wb" binary mode to suppress end-line mapping, in case it
is run on Windows. As we learned in <A class="docLink" HREF="0596000855_python2-CHP-2.html#python2-CHP-2">Chapter 2</A>,
it's not impossible that true binary data files may have bytes
whose value is equal to a <TT>\n</TT> line-feed character;
opening in "w" text mode instead would make these bytes
be automatically expanded to a <TT>\r\n</TT> two-byte
sequence when written locally on Windows. This is only an issue for
portability to Windows (mode "w" works elsewhere). Again,
see <A class="docLink" HREF="0596000855_python2-CHP-5.html#python2-CHP-5">Chapter 5</A> for line-feed converter tools.
</P>
</DD><DT><I><span class="docPubcolor">Directory model </span></I></DT>
<DD>
<P class="docList">This function currently uses the same filename to identify both the
remote file and the local file where the download should be stored.
As such, it should be run in the directory where you want the file to
show up; use <TT>os.chdir</TT> to move to directories if
needed. (We could instead assume <span class="docEmphasis">filename</span> is the
local file's name, and strip the local directory with
<TT>os.path.split</TT> to get the remote name, or accept
two distinct filename arguments -- local and remote.)
</P>
</DD>
</DL>

<P class="docText">Notice also that, despite its name, this module is very different
than the <span class="docEmphasis">getfile.py</span> script we studied at the end
of the sockets material in the previous chapter. The socket-based
<TT>getfile</TT> implemented client and server-side logic
to download a server file to a client machine over raw sockets.
</P>

<P class="docText">This new <TT>getfile</TT> here is a client-side tool only.
Instead of raw sockets, it uses the simpler FTP protocol to request a
file from a server; all socket-level details are hidden in the
<TT>ftplib</TT> module's implementation of the FTP
client protocol. Furthermore, the server here is a perpetually
running program on the server machine, which listens for and responds
to FTP requests on a socket, on the dedicated FTP port (number 21).
The net functional effect is that this script requires an FTP server
to be running on the machine where the desired file lives, but such a
server is much more likely to be available.<A NAME="IXTR3-196"></A> <A NAME="IXTR3-197"></A> <A NAME="IXTR3-198"></A>
</P>



<A NAME="python2-CHP-11-SECT-2.2.2"></A>
<H5 class="docSection3Title">11.2.2.2 Upload utility</H5>

<P class="docText"><A NAME="python2-IDXTERM-786"></A>
<A NAME="python2-IDXTERM-787"></A> <A NAME="python2-IDXTERM-788"></A>While
we're at it, let's write a script to upload a single file
by FTP to a remote machine. The upload interfaces in the FTP module
are symmetric with the download interfaces. Given a connected FTP
object:
</P>

<UL>
<LI><P class="docList">Its <TT>storbinary</TT> method can be used to upload bytes
from an open local file object.
</P></LI>
<LI><P class="docList">Its <TT>storlines</TT> method can be used to upload text in
ASCII mode from an open local file object.
</P></LI>
</UL>
<P class="docText">Unlike the download interfaces, both of these methods are passed a
file object as a whole, not a file object method (or other function).
We will meet the <TT>storlines</TT> method in a later
example. The utility module in <A class="docLink" HREF="#python2-CHP-11-EX-6">Example 11-6</A> uses
<TT>storbinary</TT> such that the file whose name is passed
in is always uploaded verbatim -- in binary mode, without
line-feed translations for the target machine's conventions. If
this script uploads a text file, it will arrive exactly as stored on
the machine it came from, client line-feed markers and all.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-11-EX-6"></A>Example 11-6. PP2E\Internet\Ftp\putfile.py </H5>
<PRE>#!/usr/local/bin/python
################################################## 
# Store an arbitrary file by ftp.  Anonymous 
# ftp unless you pass a user=(name, pswd) tuple.
##################################################
 
import ftplib                    # socket-based ftp tools

file = 'sousa.au'                # default file coordinates
site = 'starship.python.net'     # monty python theme song
dir  = 'upload'

def putfile(file=file, site=site, dir=dir, user=(), verbose=1):
    """
    store a file by ftp to a site/directory
    anonymous or real login, binary transfer
    """
    if verbose: print 'Uploading', file
    local  = open(file, 'rb')               # local file of same name
    remote = ftplib.FTP(site)               # connect to ftp site
    apply(remote.login, user)               # anonymous or real login
    remote.cwd(dir)
    remote.storbinary('STOR ' + file, local, 1024)
    remote.quit()
    local.close()
    if verbose: print 'Upload done.'

if __name__ == '__main__':
    import sys, getpass
    pswd = getpass.getpass(site + ' pswd?')          # filename on cmdline
    putfile(file=sys.argv[1], user=('lutz', pswd))   # non-anonymous login</PRE>


<P class="docText">Notice that for portability, the local file is opened in
"rb" binary mode this time to suppress automatic
line-feed character conversions in case this is run on Windows; if
this is binary information, we don't want any bytes that happen
to have the value of the <TT>\r</TT> carriage-return
character to mysteriously go away during the transfer.
</P>

<P class="docText"><A NAME="IXT-11-337361"></A>Also
observe that the standard Python <TT>getpass.getpass</TT>
is used to ask for an FTP password in standalone mode. Like the
<TT>raw_input</TT> built-in function, this call prompts for
and reads a line of text from the console user; unlike
<TT>raw_input</TT>, <TT>getpass</TT> does not
echo typed characters on the screen at all (in fact, on Windows it
uses the low-level direct keyboard interface we met in the stream
redirection section of <A class="docLink" HREF="0596000855_python2-CHP-2.html#python2-CHP-2">Chapter 2</A>). This comes in
handy for protecting things like passwords from potentially prying
eyes.
</P>

<P class="docText">Like the download utility, this script uploads a local copy of an
audio file by default as a self-test, but you will normally pass in
real remote filename, site name, and directory name strings. Also
like the download utility, you may pass a
<TT>(username,</TT> <TT>password)</TT> tuple to
the <TT>user</TT> argument to trigger non-anonymous FTP
mode (anonymous FTP is the default).<A NAME="IXTR3-199"></A> <A NAME="IXTR3-200"></A> <A NAME="IXTR3-201"></A>
</P>



<A NAME="python2-CHP-11-SECT-2.2.3"></A>
<H5 class="docSection3Title">11.2.2.3 Playing the Monty Python theme song</H5>

<P class="docText">Wake up -- it's time for a bit of fun. Let's make use
of these scripts to transfer and play the Monty Python theme song
audio file maintained at Python's web site. First off,
let's write a module that downloads and plays the sample file,
as shown in <A class="docLink" HREF="#python2-CHP-11-EX-7">Example 11-7</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-11-EX-7"></A>Example 11-7. PP2E\Internet\Ftp\sousa.py </H5>
<PRE>#!/usr/local/bin/python
################################################# 
# Usage: % sousa.py
# Fetch and play the Monty Python theme song.
# This may not work on your system as is: it 
# requires a machine with ftp access, and uses
# audio filters on Unix and your .au player on 
# Windows.  Configure playfile.py as needed.
#################################################
 
import os, sys
from PP2E.Internet.Ftp.getfile  import getfile
from PP2E.Internet.Ftp.playfile import playfile
sample = 'sousa.au'

getfile(sample)    # fetch audio file by ftp
playfile(sample)   # send it to audio player</PRE>


<P class="docText">This script will run on any machine with Python, an Internet link,
and a recognizable audio player; it works on my Windows laptop with a
dialup Internet connection (if I could insert an audio file hyperlink
here to show what it sounds like, I would):
</P>

<PRE>C:\...\PP2E\Internet\Ftp&gt;<B>python sousa.py</B>
Downloading sousa.au
Download done.

C:\...\PP2E\Internet\Ftp&gt;<B>python sousa.py</B>
sousa.au already fetched</PRE>

<P class="docText">The <TT>getfile</TT> and <TT>putfile</TT> modules
can be used to move the sample file around, too. Both can either be
imported by clients that wish to use their functions, or run as
top-level programs to trigger self-tests. Let's run these
scripts from a command line and the interactive prompt to see how
they work. When run standalone, parameters are passed in the command
line, and the default file settings are used:
</P>

<PRE>C:\...\PP2E\Internet\Ftp&gt;<B>python putfile.py sousa.au</B>
starship.python.net pswd?
Uploading sousa.au
Upload done.</PRE>

<P class="docText">When imported, parameters are passed explicitly to functions:</P>

<PRE>C:\...\PP2E\Internet\Ftp&gt;<B>python</B>
&gt;&gt;&gt; <B>from getfile import getfile</B>
&gt;&gt;&gt; <B>getfile(file='sousa.au', site='starship.python.net', dir='upload',
...                          user=('lutz', '****'))</B>
Downloading sousa.au
Download done.
&gt;&gt;&gt; <B>from playfile import playfile</B>
&gt;&gt;&gt; <B>playfile('sousa.au')</B></PRE>

<P class="docText">I've left one piece out of the puzzle: all that's left is
to write a module that attempts to play an audio file portably (see
<A class="docLink" HREF="#python2-CHP-11-EX-8">Example 11-8</A>). Alas, this is the least
straightforward task because audio players vary per platform. On
Windows, the following module uses the DOS <I>start</I>
command to launch whatever you have registered to play audio files
(exactly as if you had double-clicked on the file's icon in a
file explorer); on the Windows 98 side of my Sony notebook machine,
this DOS command line:
</P>

<PRE>C:\...\PP2E\Internet\Ftp&gt;<B>python playfile.py sousa.au</B></PRE>

<P class="docText">pops up a media bar playing the sample. On Unix, it attempts to pass
the audio file to a command-line player program, if one has been
added to the <TT>unixfilter</TT> table -- tweak this for
your system (<I>cat </I>'ing audio files to
<I>/dev/audio</I> works on some Unix systems, too). On
other platforms, you'll need to do a bit more; there has been
some work towards portable audio interfaces in Python, but it's
notoriously platform-specific. Web browsers generally know how to
play audio files, so passing the filename in a URL to a browser
located via the <I>LaunchBrowser.py</I> script we met
in <A class="docLink" HREF="0596000855_python2-CHP-4.html#python2-CHP-4">Chapter 4</A>, is perhaps a portable solution here
as well (see that chapter for interface details).
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-11-EX-8"></A>Example 11-8. PP2E\Internet\Ftp\playfile.py </H5>
<PRE>#!/usr/local/bin/python
################################################# 
# Try to play an arbitrary audio file.
# This may not work on your system as is; it
# uses audio filters on Unix, and filename 
# associations on Windows via the start command
# line (i.e., whatever you have on your machine 
# to run *.au files--an audio player, or perhaps
# a web browser); configure me as needed.  We
# could instead launch a web browser here, with 
# LaunchBrowser.py.  See also: Lib/audiodev.py.
#################################################

import os, sys
sample = 'sousa.au'  # default audio file

unixhelpmsg = """
Sorry: can't find an audio filter for your system!
Add an entry for your system to the "unixfilter" 
dictionary in playfile.py, or play the file manually.
"""

unixfilter = {'sunos5':  '/usr/bin/audioplay',
              'linux2':  '&lt;unknown&gt;',
              'sunos4':  '/usr/demo/SOUND/play'}

def playfile(sample=sample):
    """
    play an audio file: use name associations 
    on windows, filter command-lines elsewhere
    """
    if sys.platform[:3] == 'win':
        os.system('start ' + sample)   # runs your audio player
    else:
        if not (unixfilter.has_key(sys.platform) and 
                os.path.exists(unixfilter[sys.platform])):
            print unixhelpmsg
        else:
            theme = open(sample, 'r')             
            audio = os.popen(unixfilter[sys.platform], 'w')  # spawn shell tool
            audio.write(theme.read())                        # send to its stdin

if __name__ == '__main__': playfile()</PRE>




<A NAME="python2-CHP-11-SECT-2.2.4"></A>
<H5 class="docSection3Title">11.2.2.4 Adding user interfaces</H5>

<P class="docText"><A NAME="python2-IDXTERM-793"></A> <A NAME="python2-IDXTERM-794"></A> <A NAME="python2-IDXTERM-795"></A> <A NAME="python2-IDXTERM-796"></A>If you read the last chapter, you'll
recall that it concluded with a quick look at scripts that added a
user interface to a socket-based <TT>getfile</TT>
script -- one that transferred files over a proprietary socket
dialog, instead of FTP. At the end of that presentation, I mentioned
that FTP is a much more generally useful way to move files around,
because FTP servers are so widely available on the Net. For
illustration purposes, <A class="docLink" HREF="#python2-CHP-11-EX-9">Example 11-9</A> shows a simple
mutation of the last chapter's user interface, implemented as a
new subclass of the last chapter's general form builder.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-11-EX-9"></A>Example 11-9. P2E\Internet\Ftp\getfilegui.py </H5>
<PRE>###############################################################
# launch ftp getfile function with a reusable form gui class;
# uses os.chdir to goto target local dir (getfile currently
# assumes that filename has no local directory path prefix);
# runs getfile.getfile in thread to allow more than one to be 
# running at once and avoid blocking gui during downloads;
# this differs from socket-based getfilegui, but reuses Form;
# supports both user and anonymous ftp as currently coded;
# caveats: the password field is not displayed as stars here,
# errors are printed to the console instead of shown in the 
# gui (threads can't touch the gui on Windows), this isn't 
# 100% thread safe (there is a slight delay between os.chdir
# here and opening the local output file in getfile) and we 
# could display both a save-as popup for picking the local dir,
# and a remote directory listings for picking the file to get;
###############################################################

from Tkinter import Tk, mainloop
from tkMessageBox import showinfo
import getfile, os, sys, thread                 # ftp getfile here, not socket
from PP2E.Internet.Sockets.form import Form     # reuse form tool in socket dir

class FtpForm(Form):
    def __init__(self):
        root = Tk()
        root.title(self.title)
        labels = ['Server Name', 'Remote Dir', 'File Name', 
                  'Local Dir',   'User Name?', 'Password?']
        Form.__init__(self, labels, root)
        self.mutex = thread.allocate_lock()
        self.threads = 0
    def transfer(self, filename, servername, remotedir, userinfo):
        try:
            self.do_transfer(filename, servername, remotedir, userinfo)
            print '%s of "%s" successful'  % (self.mode, filename)
        except:
            print '%s of "%s" has failed:' % (self.mode, filename),
            print sys.exc_info()[0], sys.exc_info()[1]
        self.mutex.acquire()
        self.threads = self.threads - 1
        self.mutex.release()
    def onSubmit(self):
        Form.onSubmit(self)
        localdir   = self.content['Local Dir'].get()
        remotedir  = self.content['Remote Dir'].get()
        servername = self.content['Server Name'].get()
        filename   = self.content['File Name'].get()
        username   = self.content['User Name?'].get()
        password   = self.content['Password?'].get()
        userinfo   = ()
        if username and password:
            userinfo = (username, password)
        if localdir:
            os.chdir(localdir)
        self.mutex.acquire()
        self.threads = self.threads + 1
        self.mutex.release()
        ftpargs = (filename, servername, remotedir, userinfo)
        thread.start_new_thread(self.transfer, ftpargs)
        showinfo(self.title, '%s of "%s" started' % (self.mode, filename))
    def onCancel(self):
        if self.threads == 0:
            Tk().quit()
        else:
            showinfo(self.title, 
                     'Cannot exit: %d threads running' % self.threads)

class FtpGetfileForm(FtpForm):
    title = 'FtpGetfileGui'
    mode  = 'Download'
    def do_transfer(self, filename, servername, remotedir, userinfo):
        getfile.getfile(filename, servername, remotedir, userinfo, 0, 1)

if __name__ == '__main__':
    FtpGetfileForm()
    mainloop()    </PRE>


<P class="docText">If you flip back to the end of the previous chapter, you'll
find that this version is similar in structure to its counterpart
there; in fact, it has the same name (and is distinct only because it
lives in a different directory). The class here, though, knows how to
use the FTP-based <TT>getfile</TT> module from earlier in
this chapter, instead of the socket-based <TT>getfile</TT>
module we met a chapter ago. When run, this version also implements
more input fields, as we see in <A class="docLink" HREF="#python2-CHP-11-FIG-1">Figure 11-1</A>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-11-FIG-1"></A>Figure 11-1. FTP getfile input form</H5>
<IMG BORDER="0" WIDTH="263" HEIGHT="139" src="FILES/ppy2_1101.gif" ALT="figs/ppy2_1101.gif"></CENTER>

<P class="docText">Notice that a full file path is entered for the local directory here.
Otherwise, the script assumes the current working directory, which
changes after each download and can vary depending on where the GUI
is launched (e.g., the current directory differs when this script is
run by the <TT>PyDemos</TT> program at the top of the
examples tree). When we click this GUI's Submit button (or
press the Enter key), this script simply passes the form's
input field values as arguments to the
<TT>getfile.getfile</TT> FTP utility function shown earlier
in this section. It also posts a pop-up to tell us the download has
begun (<A class="docLink" HREF="#python2-CHP-11-FIG-2">Figure 11-2</A>).
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-11-FIG-2"></A>Figure 11-2. FTP getfile info pop-up</H5>
<IMG BORDER="0" WIDTH="186" HEIGHT="96" src="FILES/ppy2_1102.gif" ALT="figs/ppy2_1102.gif"></CENTER>

<P class="docText">As currently coded, further download status messages from this point
on show up in the console window; here are the messages for a
successful download, as well as one that failed when I mistyped my
password (no, it's not really "xxxxxx"):
</P>

<PRE>User Name?      =&gt;      lutz
Server Name     =&gt;      starship.python.net
Local Dir       =&gt;      c:\temp
Password?       =&gt;      xxxxxx
File Name       =&gt;      index.html
Remote Dir      =&gt;      public_html/home
Download of "index.html" successful

User Name?      =&gt;      lutz
Server Name     =&gt;      starship.python.net
Local Dir       =&gt;      c:\temp
Password?       =&gt;      xxxxxx
File Name       =&gt;      index.html
Remote Dir      =&gt;      public_html/home
Download of "index.html" has failed: ftplib.error_perm 530 Login incorrect.</PRE>

<P class="docText">Given a username and password, the downloader logs into the specified
account. To do anonymous FTP instead, leave the username and password
fields blank. Let's start an anonymous FTP connection to fetch
the Python source distribution; <A class="docLink" HREF="#python2-CHP-11-FIG-3">Figure 11-3</A> shows
the filled-out form.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-11-FIG-3"></A>Figure 11-3. FTP getfile input form, anonymous FTP</H5>
<IMG BORDER="0" WIDTH="263" HEIGHT="139" src="FILES/ppy2_1103.gif" ALT="figs/ppy2_1103.gif"></CENTER>

<P class="docText">Pressing Submit on this form starts a download running in the
background as before; we get the pop-up shown in <A class="docLink" HREF="#python2-CHP-11-FIG-4">Figure 11-4</A> to verify the startup.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-11-FIG-4"></A>Figure 11-4. FTP getfile info pop-up</H5>
<IMG BORDER="0" WIDTH="210" HEIGHT="96" src="FILES/ppy2_1104.gif" ALT="figs/ppy2_1104.gif"></CENTER>

<P class="docText">Now, to illustrate the threading capabilities of this GUI,
let's start another download while this one is in progress. The
GUI stays active while downloads are under way, so we simply change
the input fields and press Submit again, as done in <A class="docLink" HREF="#python2-CHP-11-FIG-5">Figure 11-5</A>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-11-FIG-5"></A>Figure 11-5. FTP getfile input form, second thread</H5>
<IMG BORDER="0" WIDTH="263" HEIGHT="139" src="FILES/ppy2_1105.gif" ALT="figs/ppy2_1105.gif"></CENTER>

<P class="docText">This second download starts in parallel with the one attached to
<A class="docLink" target="_blank" HREF="ftp://ftp.python.org/default.htm">ftp.python.org</A>, because each download is run in
a thread, and more than one Internet connection can be active at
once. In fact, the GUI itself stays active during downloads only
because downloads are run in threads; if they were not, even screen
redraws wouldn't happen until a download finished.
</P>

<P class="docText">We discussed threads in <A class="docLink" HREF="0596000855_python2-CHP-3.html#python2-CHP-3">Chapter 3</A>, but this script
illustrates some practical thread concerns:
</P>

<UL>
<LI><P class="docList">This program takes care to not do anything GUI-related in a download
thread. At least in the current release on Windows, only the thread
that makes GUIs can process them (a Windows-only rule that has
nothing to do with Python or Tkinter).
</P></LI>
<LI><P class="docList">To avoid killing spawned download threads on some platforms, the GUI
must also be careful to not exit while any downloads are in progress.
It keeps track of the number of in-progress threads, and just
displays the pop-up in <A class="docLink" HREF="#python2-CHP-11-FIG-6">Figure 11-6</A> if we try to kill
the GUI while both of these downloads are in progress by pressing the
Cancel button.
</P></LI>
</UL>
<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-11-FIG-6"></A>Figure 11-6. FTP getfile busy pop-up</H5>
<IMG BORDER="0" WIDTH="174" HEIGHT="96" src="FILES/ppy2_1106.gif" ALT="figs/ppy2_1106.gif"></CENTER>

<P class="docText">We'll see ways to work around the no-GUI rule for threads when
we explore the <TT>PyMailGui</TT> example near the end of
this chapter. To be portable, though, we can't really close the
GUI until the active-thread count falls to zero. Here is the sort of
output that appears in the console window for these two downloads:
</P>

<PRE>C:\...\PP2E\Internet\Ftp&gt;<B>python getfilegui.py</B>
User Name?      =&gt;
Server Name     =&gt;      ftp.python.org
Local Dir       =&gt;      c:\temp
Password?       =&gt;
File Name       =&gt;      python1.5.tar.gz
Remote Dir      =&gt;      pub/python/src

User Name?      =&gt;      lutz
Server Name     =&gt;      starship.python.net
Local Dir       =&gt;      c:\temp
Password?       =&gt;      xxxxxx
File Name       =&gt;      about-pp.html
Remote Dir      =&gt;      public_html/home
Download of "about-pp.html" successful
Download of "python1.5.tar.gz" successful</PRE>

<P class="docText">This all isn't much more useful than a command-line-based tool,
of course, but it can be easily modified by changing its Python code,
and it provides enough of a GUI to qualify as a simple, first-cut FTP
user interface. Moreover, because this GUI runs downloads in Python
threads, more than one can be run at the same time from this GUI
without having to start or restart a different FTP client tool.
</P>

<P class="docText">While we're in a GUI mood, let's add a simple interface
to the <TT>putfile</TT> utility, too. The script in <A class="docLink" HREF="#python2-CHP-11-EX-10">Example 11-10</A> creates a dialog that starts uploads in
threads. It's almost the same as the <TT>getfile</TT>
GUI we just wrote, so there's nothing new to say. In fact,
because get and put operations are so similar from an interface
perspective, most of the get form's logic was deliberately
factored out into a single generic class (<TT>FtpForm</TT>)
such that changes need only be made in a single place. That is, the
put GUI here is mostly just a reuse of the get GUI, with distinct
output labels and transfer method. It's in a file by itself to
make it easy to launch as a standalone program.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-11-EX-10"></A>Example 11-10. PP2E\Internet\Ftp\putfilegui.py </H5>
<PRE>###############################################################
# launch ftp putfile function with a reusable form gui class;
# see getfilegui for notes: most of the same caveats apply;
# the get and put forms have been factored into a single 
# class such that changes need only be made in one place;
###############################################################

from Tkinter import mainloop
import putfile, getfilegui

class FtpPutfileForm(getfilegui.FtpForm):
    title = 'FtpPutfileGui'
    mode  = 'Upload'
    def do_transfer(self, filename, servername, remotedir, userinfo):
        putfile.putfile(filename, servername, remotedir, userinfo, 0)

if __name__ == '__main__':
    FtpPutfileForm()
    mainloop()    </PRE>


<P class="docText">Running this script looks much like running the download GUI, because
it's almost entirely the same code at work. Let's upload
a couple of files from the client machine to the
<I>starship</I> server; <A class="docLink" HREF="#python2-CHP-11-FIG-7">Figure 11-7</A>
shows the state of the GUI while starting one.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-11-FIG-7"></A>Figure 11-7. FTP putfile input form</H5>
<IMG BORDER="0" WIDTH="263" HEIGHT="139" src="FILES/ppy2_1107.gif" ALT="figs/ppy2_1107.gif"></CENTER>

<P class="docText">And here is the console window output we get when uploading two files
in parallel; here again, uploads run in threads, so if we start a new
upload before one in progress is finished, they overlap in time:
</P>

<PRE>User Name?      =&gt;      lutz
Server Name     =&gt;      starship.python.net
Local Dir       =&gt;      c:\stuff\website\public_html
Password?       =&gt;      xxxxxx
File Name       =&gt;      about-pp2e.html
Remote Dir      =&gt;      public_html

User Name?      =&gt;      lutz
Server Name     =&gt;      starship.python.net
Local Dir       =&gt;      c:\stuff\website\public_html
Password?       =&gt;      xxxxxx
File Name       =&gt;      about-ppr2e.html
Remote Dir      =&gt;      public_html
Upload of "about-pp2e.html" successful
Upload of "about-ppr2e.html" successful</PRE>

<P class="docText">Finally, we can bundle up both GUIs in a single launcher script that
knows how to start the get and put interfaces, regardless of which
directory we are in when the script is started, and independent of
the platform on which it runs. <A class="docLink" HREF="#python2-CHP-11-EX-11">Example 11-11</A> shows
this process. <A NAME="IXT-11-337362"></A>
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-11-EX-11"></A>Example 11-11. PP2E\Internet\Ftp\PyFtpGui.pyw </H5>
<PRE>################################################################
# spawn ftp get and put guis no matter what dir I'm run from;
# os.getcwd is not necessarily the place this script lives;
# could also hard-code a path from $PP2EHOME, or guessLocation;
# could also do this but need the DOS popup for status messages:
# from PP2E.launchmodes import PortableLauncher
# PortableLauncher('getfilegui', '%s/getfilegui.py' % mydir)()
################################################################

import os, sys
from PP2E.Launcher import findFirst
mydir = os.path.split(findFirst(os.curdir, 'PyFtpGui.pyw'))[0]

if sys.platform[:3] == 'win':
    os.system('start %s/getfilegui.py' % mydir)
    os.system('start %s/putfilegui.py' % mydir)
else:
    os.system('python %s/getfilegui.py &amp;' % mydir)
    os.system('python %s/putfilegui.py &amp;' % mydir)</PRE>


<P class="docText">When this script is started, both the <TT>get</TT> and
<TT>put</TT> GUIs appear as distinct, independently running
programs; alternatively, we might attach both forms to a single
interface. We could get much fancier than these two interfaces, of
course. For instance, we could pop up local file selection dialogs,
and we could display widgets that give status of downloads and
uploads in progress. We could even list files available at the remote
site in a selectable list box by requesting remote directory listings
over the FTP connection. To learn how to add features like that,
though, we need to move on to the next section.<A NAME="IXTR3-202"></A> <A NAME="IXTR3-203"></A> <A NAME="IXTR3-204"></A> <A NAME="IXTR3-205"></A>
</P>



<A NAME="python2-CHP-11-SECT-2.3"></A>
<H4 class="docSection2Title">11.2.3 Downloading Web Sites (Mirrors)</H4>

<P class="docText"><A NAME="python2-IDXTERM-802"></A>
<A NAME="python2-IDXTERM-803"></A> <A NAME="python2-IDXTERM-804"></A> <A NAME="python2-IDXTERM-805"></A><A NAME="IXT-11-337363"></A>Once
upon a time, Telnet was all I needed. My web site lived at an
Internet Service Provider (ISP) that provided general and free Telnet
access for all its customers. It was a simple time. All of my
site's files lived only in one place -- at my account
directory on my ISP's server machine. To make changes to web
pages, I simply started a Telnet session connected to my ISP's
machine and edited my web pages there online. Moreover, because
Telnet sessions can be run from almost any machine with an Internet
link, I was able to tweak my web pages everywhere -- from my PC,
from machines I had access to on the training road, from archaic
machines I played with when I was bored at my day job, and so on.
Life was good.
</P>

<P class="docText">But times have changed. Due to a security breach, my ISP made a
blanket decision to revoke Telnet access from all of their customers
(except, of course, those who elected to pay a substantial premium to
retain it). Seemingly, we weren't even supposed to have known
about Telnet in the first place. As a replacement, the ISP mandated
that all Telnet-inclined users should begin maintaining web page
files locally on their own machines, and upload them by FTP after
every change.
</P>

<P class="docText">That's nowhere near as nice as editing files kept in a single
place from almost any computer on the planet, of course, and this
triggered plenty of complaints and cancellations among the
technically savvy. Unfortunately, the technically savvy is a
financially insignificant subset; more to the point, my web
page's address had by this time been published in multiple
books sold around the world, so changing ISPs would have been no less
painful than changing update procedures.
</P>

<P class="docText">After the shouting, it dawned on me that Python could help here: by
writing Python scripts to automate the upload and download tasks
associated with maintaining my web site on my PC, I could at least
get back some of the mobility and ease of use that I'd lost.
Because Python FTP scripts will work on any machine with sockets, I
could run them both on my PC and on nearly any other computer where
Python was installed. Furthermore, the same scripts used to transfer
page files to and from my PC could be used to copy
("mirror") my site to another web server as a backup
copy, should my ISP experience an outage (trust me -- it happens).
</P>

<P class="docText">The following two scripts were born of all of the above frustrations.
The first, <span class="docEmphasis">mirrorflat.py</span>, automatically
downloads (i.e., copies) by FTP all the files in a directory at a
remote site, to a directory on the local machine. I keep the main
copy of my web site files on my PC these days, but really use this
script in two ways:
</P>

<UL>
<LI><P class="docList">To download my web site to client machines where I want to make
edits, I fetch the contents of my <span class="docEmphasis">public_html</span>
web directory of my account on my ISP's machine.
</P></LI>
<LI><P class="docList">To mirror my site to my account on the
<span class="docEmphasis">starship.python.net</span> server, I run this script
periodically from a Telnet session on the
<span class="docEmphasis">starship</span> machine (as I wrote this,
<span class="docEmphasis">starship</span> still clung to the radical notion that
users are intelligent enough to run Telnet).
</P></LI>
</UL>
<P class="docText">More generally, this script (shown in <A class="docLink" HREF="#python2-CHP-11-EX-12">Example 11-12</A>)
will download a directory full of files to any machine with Python
and sockets, from any machine running an FTP server.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-11-EX-12"></A>Example 11-12. PP2E\Internet\Ftp\mirrorflat.py </H5>
<PRE>#!/bin/env python 
###########################################################
# use ftp to copy (download) all files from a remote site
# and directory to a directory on the local machine; e.g., 
# run me periodically to mirror a flat ftp site;
###########################################################

import os, sys, ftplib
from getpass import getpass

remotesite = 'home.rmi.net'
remotedir  = 'public_html'
remoteuser = 'lutz'
remotepass = getpass('Please enter password for %s: ' % remotesite)
localdir   = (len(sys.argv) &gt; 1 and sys.argv[1]) or '.'
if sys.platform[:3] == 'win': raw_input() # clear stream
cleanall   = raw_input('Clean local directory first? ')[:1] in ['y', 'Y']

print 'connecting...'
connection = ftplib.FTP(remotesite)                 # connect to ftp site
connection.login(remoteuser, remotepass)            # login as user/password
connection.cwd(remotedir)                           # cd to directory to copy

if cleanall:
    for localname in os.listdir(localdir):          # try to delete all locals
        try:                                        # first to remove old files
            print 'deleting local', localname
            os.remove(os.path.join(localdir, localname))
        except:
            print 'cannot delete local', localname

count = 0                                           # download all remote files
remotefiles = connection.nlst()                     # nlst() gives files list
                                                    # dir()  gives full details
for remotename in remotefiles:
    localname = os.path.join(localdir, remotename) 
    print 'copying', remotename, 'to', localname
    if remotename[-4:] == 'html' or remotename[-3:] == 'txt':
        # use ascii mode xfer
        localfile = open(localname, 'w')
        callback  = lambda line, file=localfile: file.write(line + '\n')
        connection.retrlines('RETR ' + remotename, callback)
    else:
        # use binary mode xfer
        localfile = open(localname, 'wb')
        connection.retrbinary('RETR ' + remotename, localfile.write)
    localfile.close()
    count = count+1

connection.quit()
print 'Done:', count, 'files downloaded.'</PRE>


<P class="docText">There is not a whole lot new to speak of in this script, compared to
other FTP examples we've seen thus far. We open a connection
with the remote FTP server, log in with a username and password for
the desired account (this script never uses anonymous FTP), and go to
the desired remote directory. New here, though, are loops to iterate
over all the files in local and remote directories, text-based
retrievals, and file deletions:
</P>

<A NAME="IXT-11-337364"></A><A NAME="IXT-11-337365"></A><A NAME="IXT-11-337366"></A><A NAME="IXT-11-337367"></A><A NAME="IXT-11-337368"></A><A NAME="IXT-11-337369"></A><A NAME="IXT-11-337370"></A><A NAME="IXT-11-337371"></A><DL class="docList">
<DT><I><span class="docPubcolor">Deleting all local files</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-11-337364"></A>
<A NAME="IXT-11-337365"></A> <A NAME="IXT-11-337366"></A>This script has a
<TT>cleanall</TT> option, enabled by interactive prompt. If
selected, the script first deletes all the files in the local
directory before downloading, to make sure there are no extra files
there that aren't also on the server (there may be junk here
from a prior download). To delete local files, the script calls
<TT>os.listdir</TT> to get a list of filenames in the
directory, and <TT>os.remove</TT> to delete each; see <A class="docLink" HREF="0596000855_python2-CHP-2.html#python2-CHP-2">Chapter 2</A> earlier in this book (or the Python library
manual) for more details if you've forgotten what these calls
do.
</P>

<P class="docList">Notice the use of <TT>os.path.join</TT> to concatenate a
directory path and filename according to the host platform's
conventions; <TT>os.listdir</TT> returns filenames without
their directory paths, and this script is not necessarily run in the
local directory where downloads will be placed. The local directory
defaults to the current directory ("."), but can be set
differently with a command-line argument to the script.
</P>
</DD><DT><I><span class="docPubcolor">Fetching all remote files</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-11-337367"></A>To
grab all the files in a remote directory, we first need a list of
their names. The FTP object's <TT>nlst</TT> method is
the remote equivalent of <TT>os.listdir</TT>:
<TT>nlist</TT> returns a list of the string names of all
files in the current remote directory. Once we have this list, we
simply step through it in a loop, running FTP retrieval commands for
each filename in turn (more on this in a minute).
</P>

<P class="docList">The <TT>nlst</TT> method is, more or less, like requesting
a directory listing with an <TT>ls</TT> command in typical
interactive FTP programs, but Python automatically splits up the
listing's text into a list of filenames. We can pass it a
remote directory to be listed; by default it lists the current server
directory. A related FTP method, <TT>dir</TT>, returns the
list of line strings produced by an FTP <I>LIST</I>
command; its result is like typing a <I>dir</I> command
in an FTP session, and its lines contain complete file information,
unlike <TT>nlst</TT>. If you need to know more about all
the remote files, parse the result of a <TT>dir</TT> method
call.
</P>
</DD><DT><I><span class="docPubcolor">Text-based retrievals</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-11-337368"></A>
<A NAME="IXT-11-337369"></A>
<A NAME="IXT-11-337370"></A>
<A NAME="IXT-11-337371"></A>To keep line-feeds in sync with the
machines that my web files live on, this script distinguishes between
binary and text files. It uses a simple heuristic to do so: filenames
ending in .<I>html</I> or .<I>txt</I> are
assumed to be ASCII text data (HTML web pages and simple text files),
and all others are assumed to be binary files (e.g., GIF and JPEG
images, audio files, tar archives). This simple rule won't work
for every web site, but it does the trick at mine.
</P>

<P class="docList">Binary files are pulled down with the <TT>retrbinary</TT>
method we met earlier and a local open mode of "wb" to
suppress line-feed byte mapping (this script may be run on Windows or
Unix-like platforms). We don't use a chunk size third argument
here, though -- it defaults to a reasonable 8K if omitted.
</P>

<P class="docList">For ASCII text files, the script instead uses the
<TT>retrlines</TT> method, passing in a function to be
called for each line in the text file downloaded. The text line
handler function mostly just writes the line to a local file. But
notice that the handler function created by the
<TT>lambda</TT> here also adds an <TT>\n</TT>
newline character to the end of the line it is passed. Python's
<TT>retrlines</TT> method strips all line-feed characters
from lines to side-step platform differences. By adding an
<TT>\n</TT>, the script is sure to add the proper line-feed
marker character sequence for the local platform on which this script
runs (<TT>\n</TT> or <TT>\r\n</TT>). For this
automapping of the <TT>\n</TT> in the script to work, of
course, we must also open text output files in "w" text
mode, not "wb" -- the mapping from
<TT>\n</TT> to <TT>\r\n</TT> on Windows happens
when data is written to the file.
</P>
</DD>
</DL>

<P class="docText">All of this is simpler in action than in words. Here is the command I
use to download my entire web site from my ISP server account to my
Windows 98 laptop PC, in a single step:
</P>

<PRE>C:\Stuff\Website\public_html&gt;<B>python %X%\internet\ftp\mirrorflat.py </B>
Please enter password for home.rmi.net:
Clean local directory first?
connecting...
copying UPDATES to .\UPDATES
copying PythonPowered.gif to .\PythonPowered.gif
copying Pywin.gif to .\Pywin.gif
copying PythonPoweredAnim.gif to .\PythonPoweredAnim.gif
copying PythonPoweredSmall.gif to .\PythonPoweredSmall.gif
copying about-hopl.html to .\about-hopl.html
copying about-lp.html to .\about-lp.html
...
<I> ...lines deleted...</I>
...
copying training.html to .\training.html
copying trainingCD.GIF to .\trainingCD.GIF
copying uk-1.jpg to .\uk-1.jpg
copying uk-2.jpg to .\uk-2.jpg
copying uk-3.jpg to .\uk-3.jpg
copying whatsnew.html to .\whatsnew.html
copying whatsold.html to .\whatsold.html
copying xlate-lp.html to .\xlate-lp.html
copying uploadflat.py to .\uploadflat.py
copying ora-lp-france.gif to .\ora-lp-france.gif
Done: 130 files downloaded.</PRE>

<P class="docText">This can take awhile to complete (it's bound by network speed
constraints), but it is much more accurate and easy than downloading
files by hand. The script simply iterates over all the remote files
returned by the <TT>nlst</TT> method, and downloads each
with the FTP protocol (i.e., over sockets) in turn. It uses text
transfer mode for names that imply obviously text data, and binary
mode for others.
</P>

<P class="docText">With the script running this way, I make sure the initial assignments
in it reflect the machines involved, and then run the script from the
local directory where I want the site copy to be stored. Because the
download directory is usually not where the script lives, I need to
give Python the full path to the script file (<TT>%X%</TT>
evaluates a shell variable containing the top-level path to book
examples on my machine). When run on the
<span class="docEmphasis">starship</span> server in a Telnet session window, the
execution and script directory paths are different, but the script
works the same way.
</P>

<P class="docText">If you elect to delete local files in the download directory, you may
also see a batch of "deleting local..." messages scroll
by on the screen before any "copying..." lines appear:
</P>

<PRE>...
deleting local uploadflat.py
deleting local whatsnew.html
deleting local whatsold.html
deleting local xlate-lp.html
deleting local old-book.html
deleting local about-pp2e.html
deleting local about-ppr2e.html
deleting local old-book2.html
deleting local mirrorflat.py
...
copying about-pp-japan.html to ./about-pp-japan.html
copying about-pp.html to ./about-pp.html
copying about-ppr-germany.html to ./about-ppr-germany.html
copying about-ppr-japan.html to ./about-ppr-japan.html
copying about-ppr-toc.html to ./about-ppr-toc.html
...</PRE>

<P class="docText">By the way, if you botch the input of the remote site password, a
Python exception is raised; I sometimes need to run again (and type
slower):
</P>

<PRE>C:\Stuff\Website\public_html&gt;<B>python %X%\internet\ftp\mirrorflat.py</B>
Please enter password for home.rmi.net:
Clean local directory first?
connecting...
Traceback (innermost last):
  File "C:\PP2ndEd\examples\PP2E\internet\ftp\mirrorflat.py", line 20, in ?
    connection.login(remoteuser, remotepass)            # login as user/pass..
  File "C:\Program Files\Python\Lib\ftplib.py", line 316, in login
    if resp[0] == '3': resp = self.sendcmd('PASS ' + passwd)
  File "C:\Program Files\Python\Lib\ftplib.py", line 228, in sendcmd
    return self.getresp()
  File "C:\Program Files\Python\Lib\ftplib.py", line 201, in getresp
    raise error_perm, resp
ftplib.error_perm: 530 Login incorrect.</PRE>

<P class="docText">It's worth noting that this script is at least partially
configured by assignments near the top of the file. In addition, the
password and deletion options are given by interactive inputs, and
one command-line argument is allowed -- the local directory name
to store the downloaded files (it defaults to ".", the
directory where the script is run). Command-line arguments could be
employed to universally configure all the other download parameters
and options, too; but because of Python's simplicity and lack
of compile/link steps, changing settings in the text of Python
scripts is usually just as easy as typing words on a command line.
</P>

<P><table border="0" bgcolor="black" cellspacing="0" cellpadding="1" width="90%" align="center"><tr><td>
<table bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="6"><tr>
<td width="60" valign="top"><img src="FILES/tip_yellow.gif" width="50" height="54"></td>
<td valign="top">
<P class="docText"><A NAME="IXT-11-337372"></A>Windows
input note : If you study the previous code closely, you'll
notice that an extra <TT>raw_input</TT> call is made on
Windows only, after the <TT>getpass</TT> password input
call and before the <TT>cleanall</TT> option setting is
input. This is a workaround for what seems like a bug in Python 1.5.2
for Windows.</P>

<P class="docText">Oddly, the Windows port sometimes doesn't
synchronize command-line input and output streams as expected. Here,
this seems to be due to a <TT>getpass</TT> bug or
constraint -- because <TT>getpass</TT> uses the
low-level <TT>msvcrt</TT> keyboard interface module we met
in <A class="docLink" HREF="0596000855_python2-CHP-2.html#python2-CHP-2">Chapter 2</A>, it appears to not mix well with the
<TT>stdin</TT> stream buffering used by
<TT>raw_input</TT>, and botches the input stream in the
process. The extra <TT>raw_input</TT> clears the input
stream (<TT>sys.stdin.flush</TT> doesn't help).</P>

<P class="docText">In
fact, without the superfluous <TT>raw_input</TT> for
Windows, this script prompts for <TT>cleanall</TT> option
input, but never stops to let you type a reply! This effectively
disables <TT>cleanall</TT> altogether. To force distinct
input and output lines and correct <TT>raw_input</TT>
behavior, some scripts in this book run extra
<TT>print</TT> statements or <TT>raw_input</TT>
calls to sync up streams before further user interaction. There may
be other fixes, and this may be improved in future releases; try this
script without the extra <TT>raw_input</TT> to see if this
has been repaired in your Python.
</P>
</td>
</tr></table></td></tr></table></P>


<A NAME="python2-CHP-11-SECT-2.4"></A>
<H4 class="docSection2Title">11.2.4 Uploading Web Sites</H4>

<P class="docText"><A NAME="python2-IDXTERM-816"></A>Uploading
a full directory is symmetric to downloading: it's mostly a
matter of swapping the local and remote machines and operations in
the program we just met. The script in <A class="docLink" HREF="#python2-CHP-11-EX-13">Example 11-13</A>
uses FTP to copy all files in a directory on the local machine on
which it runs, up to a directory on a remote machine.
</P>

<P class="docText">I really use this script, too, most often to upload all of the files
maintained on my laptop PC to my ISP account in one fell swoop. I
also sometimes use it to copy my site from my PC to its
<span class="docEmphasis">starship</span> mirror machine, or from the mirror
machine back to my ISP. Because this script runs on any computer with
Python and sockets, it happily transfers a directory from any machine
on the Net to any machine running an FTP server. Simply change the
initial setting in this module as appropriate for the transfer you
have in mind.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-11-EX-13"></A>Example 11-13. PP2E\Internet\Ftp\uploadflat.py </H5>
<PRE>#!/bin/env python 
##########################################################################
# use ftp to upload all files from a local dir to a remote site/directory;
# e.g., run me to copy a web/ftp site's files from your PC to your ISP;
# assumes a flat directory upload: uploadall.py does nested directories.
# to go to my ISP, I change setting to 'home.rmi.net', and 'public_html'.
##########################################################################

import os, sys, ftplib, getpass

remotesite = 'starship.python.net'                  # upload to starship site
remotedir  = 'public_html/home'                     # from win laptop or other
remoteuser = 'lutz'
remotepass = getpass.getpass('Please enter password for %s: ' % remotesite)
localdir   = (len(sys.argv) &gt; 1 and sys.argv[1]) or '.'
if sys.platform[:3] == 'win': raw_input()           # clear stream
cleanall   = raw_input('Clean remote directory first? ')[:1] in ['y', 'Y']

print 'connecting...'
connection = ftplib.FTP(remotesite)                 # connect to ftp site
connection.login(remoteuser, remotepass)            # login as user/password
connection.cwd(remotedir)                           # cd to directory to copy

if cleanall:
    for remotename in connection.nlst():            # try to delete all remotes
        try:                                        # first to remove old files
            print 'deleting remote', remotename
            connection.delete(remotename)           
        except:                                     
            print 'cannot delete remote', remotename

count = 0
localfiles = os.listdir(localdir)                   # upload all local files
                                                    # listdir() strips dir path
for localname in localfiles:  
    localpath = os.path.join(localdir, localname) 
    print 'uploading', localpath, 'to', localname
    if localname[-4:] == 'html' or localname[-3:] == 'txt':
        # use ascii mode xfer
        localfile = open(localpath, 'r')
        connection.storlines('STOR ' + localname, localfile)
    else:
        # use binary mode xfer
        localfile = open(localpath, 'rb')
        connection.storbinary('STOR ' + localname, localfile, 1024)
    localfile.close()
    count = count+1

connection.quit()
print 'Done:', count, 'files uploaded.'</PRE>


<P class="docText">Like the mirror download script, the program here illustrates a
handful of new FTP interfaces and a set of FTP scripting techniques:
</P>

<A NAME="IXT-11-337373"></A><A NAME="IXT-11-337374"></A><A NAME="IXT-11-337375"></A><A NAME="IXT-11-337376"></A><A NAME="IXT-11-337377"></A><A NAME="IXT-11-337378"></A><A NAME="IXT-11-337379"></A><A NAME="IXT-11-337380"></A><A NAME="IXT-11-337381"></A><A NAME="IXT-11-337382"></A><DL class="docList">
<DT><I><span class="docPubcolor">Deleting all remote files</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-11-337373"></A>Just
like the mirror script, the upload begins by asking if we want to
delete all the files in the remote target directory before copying
any files there. This <TT>cleanall</TT> option is useful if
we've deleted files in the local copy of the directory in the
client -- the deleted files would remain on the server-side copy
unless we delete all files there first. To implement the remote
cleanup, this script simply gets a listing of all the files in the
remote directory with the FTP <TT>nlst</TT> method, and
deletes each in turn with the FTP <TT>delete</TT> method.
Assuming we have delete permission, the directory will be emptied
(file permissions depend on the account we logged into when
connecting to the server). We've already moved to the target
remote directory when deletions occur, so no directory paths must be
prepended to filenames here.
</P>
</DD><DT><I><span class="docPubcolor">Storing all local files</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-11-337374"></A>
<A NAME="IXT-11-337375"></A>
<A NAME="IXT-11-337376"></A>To apply the
upload operation to each file in the local directory, we get a list
of local filenames with the standard <TT>os.listdir</TT>
call, and take care to prepend the local source directory path to
each filename with the <TT>os.path.join</TT> call. Recall
that <TT>os.listdir</TT> returns filenames without
directory paths, and the source directory may not be the same as the
script's execution directory if passed on the command line.
</P>
</DD><DT><I><span class="docPubcolor">Text-based uploads</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-11-337377"></A>
<A NAME="IXT-11-337378"></A>This
script may be run on both Windows and Unix-like clients, so we need
to handle text files specially. Like the mirror download, this script
picks text or binary transfer modes by inspecting each
filename's extension -- HTML and text files are moved in FTP
text mode. We've already met the <TT>storbinary</TT>
FTP object method used to upload files in binary mode -- an exact,
byte-for-byte copy appears at the remote site.
</P>

<P class="docList">Text mode transfers work almost identically: the
<TT>storlines</TT> method accepts an FTP command string and
a local file (or file-like) object opened in text mode, and simply
copies each line in the local file to a same-named file on the remote
machine. As usual, if we run this script on Windows, opening the
input file in "r" text mode means that DOS-style
<TT>\r\n</TT> end-of-line sequences are mapped to the
<TT>\n</TT> character as lines are read. When the script is
run on Unix and Linux, lines end in a single <TT>\n</TT>
already, so no such mapping occurs. The net effect is that data is
read portably, with <TT>\n</TT> characters to represent
end-of-line. For binary files, we open in "rb" mode to
suppress such automatic mapping everywhere (we don't want bytes
that happen to have the same value as <TT>\r</TT> to
magically disappear when read on Windows).<sup class="docFootnote"><A class="docLink" HREF="#">[3]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[3]</A></sup> <A NAME="IXT-11-337379"></A>
<A NAME="IXT-11-337380"></A>
<A NAME="IXT-11-337381"></A>
<A NAME="IXT-11-337382"></A>Technically,
Python's <TT>storlines</TT> method automatically
sends all lines to the server with <TT>\r\n</TT> line-feed
sequences, no matter what it receives from the local file's
<TT>readline</TT> method (<TT>\n</TT> or
<TT>\r\n</TT>). Because of that, the most important
distinctions for uploads are to use the "rb" for binary
mode and the <TT>storlines</TT> method for text. Consult
module <I>ftplib.py</I> in the Python source library
directory for more details.</p></blockquote> 
</DD>
</DL>

<P class="docText">As for the mirror download script, this program simply iterates over
all files to be transferred (files in the local directory listing
this time), and transfers each in turn -- in either text or binary
mode, depending on the files' names. Here is the command I use
to upload my entire web site from my laptop Windows 98 PC to the
remote Unix server at my ISP, in a single step:
</P>

<PRE>C:\Stuff\Website\public_html&gt;<B>python %X%\Internet\Ftp\uploadflat.py </B>
Please enter password for starship.python.net:
Clean remote directory first?
connecting...
uploading .\LJsuppcover.jpg to LJsuppcover.jpg
uploading .\PythonPowered.gif to PythonPowered.gif
uploading .\PythonPoweredAnim.gif to PythonPoweredAnim.gif
uploading .\PythonPoweredSmall.gif to PythonPoweredSmall.gif
uploading .\Pywin.gif to Pywin.gif
uploading .\UPDATES to UPDATES
uploading .\about-hopl.html to about-hopl.html
uploading .\about-lp.html to about-lp.html
uploading .\about-pp-japan.html to about-pp-japan.html
...
<I> ...lines deleted...</I>
...
uploading .\trainingCD.GIF to trainingCD.GIF
uploading .\uk-1.jpg to uk-1.jpg
uploading .\uk-2.jpg to uk-2.jpg
uploading .\uk-3.jpg to uk-3.jpg
uploading .\uploadflat.py to uploadflat.py
uploading .\whatsnew.html to whatsnew.html
uploading .\whatsold.html to whatsold.html
uploading .\xlate-lp.html to xlate-lp.html
Done: 131 files uploaded.</PRE>

<P class="docText">Like the mirror example, I usually run this command from the local
directory where my web files are kept, and I pass Python the full
path to the script. When I run this on the
<span class="docEmphasis">starship</span> Linux server, it works the same, but
the paths to the script and my web files directory differ. If you
elect to clean the remote directory before uploading, you'll
get a bunch of "deleting remote..." messages before the
"uploading..." lines here, too:
</P>

<A NAME="IXTR3-206"></A><PRE>...
deleting remote uk-3.jpg
deleting remote whatsnew.html
deleting remote whatsold.html
deleting remote xlate-lp.html
deleting remote uploadflat.py
deleting remote ora-lp-france.gif
deleting remote LJsuppcover.jpg
deleting remote sonyz505js.gif
deleting remote pic14.html
...</PRE>


<A NAME="python2-CHP-11-SECT-2.5"></A>
<H4 class="docSection2Title">11.2.5 Uploads with Subdirectories</H4>

<P class="docText"><A NAME="python2-IDXTERM-827"></A>Perhaps the biggest limitation
of the web site download and upload scripts we just met are that they
assume the site directory is flat (hence their names) -- i.e.,
both transfer simple files only, and neither handles nested
subdirectories within the web directory to be transferred.
</P>

<P class="docText">For my purposes, that's a reasonable constraint. I avoid nested
subdirectories to keep things simple, and I store my home web site as
a simple directory of files. For other sites (including one I keep at
the <span class="docEmphasis">starship</span> machine), site transfer scripts are
easier to use if they also automatically transfer subdirectories
along the way.
</P>

<P class="docText">It turns out that supporting directories is fairly simple -- we
need to add only a bit of recursion and remote directory creation
calls. The upload script in <A class="docLink" HREF="#python2-CHP-11-EX-14">Example 11-14</A> extends the
one we just saw, to handle uploading all subdirectories nested within
the transferred directory. Furthermore, it recursively transfers
subdirectories within subdirectories -- the entire directory tree
contained within the top-level transfer directory is uploaded to the
target directory at the remote server.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-11-EX-14"></A>Example 11-14. PP2E\Internet\Ftp\uploadall.py </H5>
<PRE>#!/bin/env python
##########################################################################
# use ftp to upload all files from a local dir to a remote site/directory;
# this version supports uploading nested subdirectories too, but not the 
# cleanall option (that requires parsing ftp listings to detect remote 
# dirs, etc.);  to upload subdirectories, uses os.path.isdir(path) to see 
# if a local file is really a directory, FTP().mkd(path) to make the dir
# on the remote machine (wrapped in a try in case it already exists there), 
# and recursion to upload all files/dirs inside the nested subdirectory. 
# see also: uploadall-2.py, which doesn't assume the topremotedir exists.
##########################################################################
  
import os, sys, ftplib
from getpass import getpass

remotesite   = 'home.rmi.net'          # upload from pc or starship to rmi.net
topremotedir = 'public_html' 
remoteuser   = 'lutz'
remotepass   = getpass('Please enter password for %s: ' % remotesite)
toplocaldir  = (len(sys.argv) &gt; 1 and sys.argv[1]) or '.'

print 'connecting...'
connection = ftplib.FTP(remotesite)               # connect to ftp site
connection.login(remoteuser, remotepass)          # login as user/password
connection.cwd(topremotedir)                      # cd to directory to copy to
                                                  # assumes topremotedir exists
def uploadDir(localdir):
    global fcount, dcount
    localfiles = os.listdir(localdir)
    for localname in localfiles:  
        localpath = os.path.join(localdir, localname) 
        print 'uploading', localpath, 'to', localname
        if os.path.isdir(localpath):
            # recur into subdirs
            try:
                connection.mkd(localname)
                print localname, 'directory created'
            except: 
                print localname, 'directory not created'
            connection.cwd(localname)
            uploadDir(localpath)
            connection.cwd('..')
            dcount = dcount+1
        else:
            if localname[-4:] == 'html' or localname[-3:] == 'txt':
                # use ascii mode xfer
                localfile = open(localpath, 'r')
                connection.storlines('STOR ' + localname, localfile)
            else:
                # use binary mode xfer
                localfile = open(localpath, 'rb')
                connection.storbinary('STOR ' + localname, localfile, 1024)
            localfile.close()
            fcount = fcount+1

fcount = dcount = 0
uploadDir(toplocaldir)
connection.quit()
print 'Done:', fcount, 'files and', dcount, 'directories uploaded.'</PRE>


<P class="docText">Like the flat upload script, this one can be run on any machine with
Python and sockets and upload to any machine running an FTP server; I
run it both on my laptop PC and on <span class="docEmphasis">starship</span> by
Telnet to upload sites to my ISP.
</P>

<P class="docText">In the interest of space, I'll leave studying this variant in
more depth as a suggested exercise. Two quick pointers, though:
</P>

<UL>
<LI><P class="docList"><A NAME="IXT-11-337383"></A>The crux of
the matter here is the <TT>os.path.isdir</TT> test near the
top; if this test detects a directory in the current local directory,
we create a same-named directory on the remote machine with
<TT>connection.mkd</TT> and descend into it with
<TT>connection.cwd</TT>, and recur into the subdirectory on
the local machine. Like all FTP object methods,
<TT>mkd</TT> and <TT>cwd</TT> methods issue FTP
commands to the remote server. When we exit a local subdirectory, we
run a remote <TT>cwd('..')</TT> to climb to the remote
parent directory and continue. The rest of the script is roughly the
same as the original.
</P></LI>
<LI><P class="docList">Note that this script handles only directory tree uploads; recursive
uploads are generally more useful than recursive downloads, if you
maintain your web sites on your local PC and upload to a server
periodically, as I do. If you also want to download (mirror) a web
site that has subdirectories, see the mirror scripts in the Python
source distribution's Tools directory (currently, at file
location <span class="docEmphasis">Tools/scripts/ftpmirror.py</span>). It's
not much extra work, but requires parsing the output of a remote
listing command to detect remote directories, and that is just
complicated enough for me to omit here. For the same reason, the
recursive upload script shown here doesn't support the remote
directory cleanup option of the original -- such a feature would
require parsing remote listings as well.
</P></LI>
</UL>
<P class="docText">For more context, also see the <I>uploadall-2.py</I>
version of this script in the examples distribution; it's
similar, but coded so as not to assume that the top-level remote
directory already exists.<A NAME="IXTR3-207"></A> <A NAME="IXTR3-208"></A> <A NAME="IXTR3-209"></A> <A NAME="IXTR3-210"></A> <A NAME="IXTR3-211"></A><A NAME="IXTR3-212"></A> <A NAME="IXTR3-213"></A> <A NAME="IXTR3-214"></A> <A NAME="IXTR3-215"></A><A NAME="IXTR3-216"></A>
</P>



<a href="0596000855_"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
          <a href="0596000855_python2-CHP-11-SECT-1.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596000855_python2-CHP-11-SECT-3.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
